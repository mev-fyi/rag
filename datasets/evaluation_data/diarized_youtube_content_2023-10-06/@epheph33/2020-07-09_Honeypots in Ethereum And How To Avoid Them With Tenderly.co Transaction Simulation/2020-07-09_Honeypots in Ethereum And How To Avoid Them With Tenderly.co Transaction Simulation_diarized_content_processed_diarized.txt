00:00:01.290 - 00:01:03.520, Speaker A: Hello, my name is Scott Bigelow and today I'd like to talk to you about honeypots in Ethereum and how to avoid them using tools such as Tenderly Co. I'm currently working with the Ethereum Foundation on a program called Spot Check where we look at contracts that are deployed to mainnet or nearing mainnet release and check them for security issues. We often work directly with projects but we'll also look at Etherscan Verified Source Code in order to discover things that are being launched to reach out to them and see if we can provide any assistance. Now, in doing so, we often find honeypot contracts and have seen people lose money in real time. And so I'm hoping to raise awareness of how you can avoid honeypots using Pre Flight Transaction Tooling which we'll be demoing later in this video. So let's talk a little bit about what a honeypot actually is in this video as it relates to Ethereum. Specifically how one might fall into one of these honeypots, how they might get discovered and how using your understanding of solidity, they could trick you into sending it Ether when it doesn't do what you might expect it does.
00:01:03.520 - 00:01:48.766, Speaker A: And then we'll show how you can avoid falling victim to one of these honeypots using both Tenderly Co and also some raw JSON RPC calls to really show what's going on under the hood. And these tools should work for most honeypots you run into, allowing you to check what a transaction does before you actually send it on chain. So let's talk about what a honeypot actually is. So there's a scammer out in the wild right now and they operate by deploying smart contracts to Ethereum. And these smart contracts are designed to take your hard earned ETH. And in order to encourage you to interact with their smart contract they put a small amount of Ether on that contract and verify its source on Etherscan. Now, they will just let this sit there.
00:01:48.766 - 00:02:29.498, Speaker A: This can sit there for many, many days. They'll usually refresh these every once in a while so that they appear towards the top of the new Verified Source Code contracts. But eventually, at some point, you as a solidity developer might be reading through Verified Source Code or stumble upon this any number of ways and you'll say, you know what? Hey, I know how to read solidity. What does this thing do? It's not very long contract and it stores value. So I'm kind of curious what is this thing doing? And after reading it for a while, you notice like, hey, you know what? I think I understand how this contract works. And if I send this contract one ETH, well, then I think that I can convince this contract to send me eleven ETH back, right? And all that code is executing on the smart contract. Nobody can interfere with this.
00:02:29.498 - 00:03:30.186, Speaker A: There is basically ten ETH there for the taking. If I just use my solidity knowledge in order to take advantage of this contract. And so imagine your surprise when you finally do get around to crafting that right transaction, putting the right transaction call data on there and including your One ETH and sending this curated transaction. And instead of it sending you eleven ETH, it just takes your One ETH. Now this ETH will just sit there until the scammer finally comes around and realizes that somebody fell into this trap. And then they will send their transaction that actually does withdraw this eleven ETH because they registered themselves as the owner of this contract. So how might somebody actually discover a Honeypot like this? Like, how are you as a solidity developer going to be browsing through Etherscan? And why might you pick this one out as one to interact with? Well, let's just go to Etherscan.
00:03:30.186 - 00:03:51.830, Speaker A: And there is a function here for viewing recently verified smart contracts. This is a list of contracts that people have uploaded the source code to. And Etherscan has verified that that source code matches the bytecode on the blockchain. So we'll just take a look at the first one here. There's the address. Here's its name. Here's all the code that powers that smart contract.
00:03:51.830 - 00:04:17.326, Speaker A: Now, that one doesn't store any Ether, so it's probably not that interesting. Some of these do store quite a decent amount of Ether. Here's one stores $2 million of ETH. And we can just sit here and go through pages and pages and pages of these. Now, I previously looked about where the most recent one of these Honeypot contracts is. It's somewhere around here. But you can see lots of contracts are uploaded here.
00:04:17.326 - 00:04:34.226, Speaker A: Most of them don't have Ether attached to them, so the ones that do usually stand out a bit more. So here's one that has 597. We got one over here. It's got see here. Oh, this one's kind of interesting. Check this one out. We have a contract here with 15 ETH stored on it.
00:04:34.226 - 00:05:12.926, Speaker A: AB quiz. So let's check this thing out. So this is the Honeypot contract in question. And this contract is very, very short, right? This contract is only about 50 lines and there's lots of white space. There's no includes, there's nothing fancy here. And it makes reading through it and thinking that you understand what it does really easy, even though there are some subtleties to how this contract behaves. So the first thing that we'll notice is there is a function here called try that accepts a string response and anybody can interact with it.
00:05:12.926 - 00:05:51.002, Speaker A: The only restriction here on message sender is that it cannot come from a smart contract. Otherwise anybody can interact with it. This is the special code for a smart contract, cannot be the one that sends this transaction. And what we'll see here is that it's going to take this response that you sent in, it's going to hash it. And if that hash matches a hash that was previously stored and you sent along more than one Ether, it could be 1.1. Then this contract will transfer you its entire balance. Now, that seems like a pretty good deal if we could just understand what this string is.
00:05:51.002 - 00:06:26.774, Speaker A: So let's explore a little bit more about what this contract is trying to do. Well, we see that there is a question string and a response hash that are stored on the contract. In fact, if we go over here, we can look at the read contract and we can see it says a farmer has 17 sheep and all but nine die. How many are left? Okay, so it's some sort of a weird little riddle and you come down here and see, oh, wait a minute. Here is the place where this whole thing was kicked off. This is the place where they set this response hash. This is the place where they set the question that we recently read.
00:06:26.774 - 00:07:00.658, Speaker A: And that response that was hashed and stored was just an argument to this Start function call. So if we could just find where they called Start, we should be able to see this response here, right? I mean, this is ethereum. Nothing is private if we can just find the right bit of data. And you're thinking to yourself, I can't believe that the people who wrote this contract didn't know it was going to be this easy. So let's come over here and let's check out the contracts, the transactions for this contract. Check out the transaction hash. Let's see here.
00:07:00.658 - 00:07:25.258, Speaker A: That's the contract deployment. There's only one other one, so it's got to be it, right? Yeah, sure enough, they called Start with a question and a response. And look, that data is right here. That data is there for us to just look at. So there's a nice little decode input data button here where Etherscan will actually kind of parse out the arguments for you in a really, really nice way. And look at that. The answer here is nine.
00:07:25.258 - 00:07:54.340, Speaker A: And look at there's a capital E here. So they probably think they're being a little bit tricky and maybe that's why nobody else has tried because they didn't know how to look at this response data. Okay, well, we got the answer. So all we need to do in order to take all of this smart contracts ETH is just pass in that answer here. That nine with a capital E. It will hash it. That hash is going to match the response hash that was set here, right? So you're going to get the exact same value.
00:07:54.340 - 00:08:18.700, Speaker A: Let's go ahead and include 1.1 ETH. It doesn't really matter. We're going to get it all back anyway when this contract sends us its entire balance, right? So let's give it a shot. So we can use Etherscan to actually send transactions to the Ethereum network over in this right contract tab. We can say, well, let's connect to web3. It's like, yes, I know bad things can happen.
00:08:18.700 - 00:08:41.140, Speaker A: And I have MetaMask here. You'll see a MetaMask pop up in a second. Let's say the amount we're going to pay here is let's say we'll send 1.1 ETH. And the response I just copied and pasted from before, it's this nine, right? And so let's go ahead and say, yeah, let's go ahead and send this transaction. Pull this over. Now this account I have here doesn't actually have any ETH on it.
00:08:41.140 - 00:09:16.880, Speaker A: So we're not going to run the risk of accidentally sending this transaction. But if we did, if we could click confirm here, this is a transaction that we should forward 1.1 ETH with this call data to that contract. And what we would find is that once this contract lands, we have lost 1.1 ETH. We were never going to withdraw that contract's balance. And so let's say that instead of sending this transaction directly to the blockchain after we signed it and propagated it, let's use a tool that would tell us before we send a transaction what that transaction is likely to do.
00:09:16.880 - 00:09:49.080, Speaker A: So I rejected that and I want to use I'm going to copy the address of this. This is our AB quiz right here. I'm going to copy this address and let's pop open a tool over here called Tenderly. This is a service that offers some pretty nice little blockchain inspection tools. It allows you to monitor for events. It allows you to just look at a lot of different aspects of Ethereum in a fairly deep way, including analytics and monitoring. And I found this to be a very useful tool.
00:09:49.080 - 00:10:20.194, Speaker A: And one of the things you can do is you can let's see here. Let's go ahead and create a new project. And this project is going to be like quiz, check and by the way, Tenderly has free options. So you can just come up here and sign up for a free account. And I believe all the functionality I'm going to show you are freely available. So right now we have a brand new project. This allows you to kind of deeply look at certain smart contracts that you tell this project about.
00:10:20.194 - 00:10:55.114, Speaker A: So I copied and pasted that the address from that AB quiz and it actually integrates directly with Etherscan. It knows how to fetch the source code and the abi directly from Etherscan. So I just need to say import. And there we go. Now it's showing us transactions that have interacted with this contract already. But one of the neat tools that Tenderly offers is the ability to simulate a transaction, to specify all the attributes of a transaction and say, don't send this to the network with the private keys that have signed it. Just tell me what would happen if I did send this transaction.
00:10:55.114 - 00:11:21.458, Speaker A: So over here we have a simulator button and we can run a simulation. And we've already given it the address of this AB quiz. It knows about all the functions that are on that contract. And the one that we were talking about was try. So we can come over here and say, well, I remember the one thing that we had to do was include a value of over one ETH. So let's just do 1.1 ETH.
00:11:21.458 - 00:11:50.766, Speaker A: And this actually uses way. So ten to the 18th. So this is 1.1 in the ten to the 18th signifier. And the answer that we had come up with before that we extracted from that start was nine, right, for the capital E. So let's go ahead and we can set any from address we want here. It doesn't really matter which address that we use because we don't actually need to have the private keys to that.
00:11:50.766 - 00:12:21.530, Speaker A: We'll just see if this address were to send this transaction, what would happen. But we can put any address in here we want. But that zero address is just fine for our purposes. It doesn't have any special logic in there for handling the zero address. So I'm going to click simulate transaction. And what we see here is all the attributes of this transaction that it succeeded, how much gas it used, what we actually called. And what we see here is like the call trace stack of the interactions that happened as a result of this transaction.
00:12:21.530 - 00:12:57.390, Speaker A: Now, until you get a little more familiar with these tools, it could be a little difficult to see why this is a failure here. But this is supposed to list every unique interaction that happened within this contract. And with external contracts, it's not going to actually step through, but it'll tell you when it tries to forward value to somebody. It'll tell you when it tries to call functions on other contracts. And the fact that this only has the function call itself means that it accepted that ether and did nothing with it. It never tried to send you Ether. To show you an example of what it looks like when something does send ether, I have a contract interaction over here with WETH.
00:12:57.390 - 00:13:19.850, Speaker A: I'll just go ahead and search here. So here is a transaction that happened. It's just some random WETH withdrawal. And what we can see here, this is a transaction that actually did happen. And we can see that this thing called withdraw. And there is a call here where it actually said message sender transfer. So we can tell it actually reached this line and attempted to send this value.
00:13:19.850 - 00:13:53.570, Speaker A: And since we don't see that over here on our own simulated transaction right, there's no call to our address. This thing never actually was going to send the ether to us because we didn't satisfy this constraint here. And we'll talk a little bit about why about how that was not satisfied. Now, tenderly is a very nice tool. It provides a really nice user experience around simulating these transactions. But it's not technically magic. It's a nice slick interface on top of functionality that is also available on JSON RPC.
00:13:53.570 - 00:14:24.074, Speaker A: And I'll show you that right now. This is a curl against a JSON RPC node that I have running. And it instructs the RPC that we would like to trace a call. And it provides the full details about who is sending this transaction, where this transaction is going to, and the call data. In this case, it is somebody who holds WETH. This is just some random account I found out of the account holders. This is the WETH contract address.
00:14:24.074 - 00:14:46.034, Speaker A: And this basically says withdraw. And then this value over here is how much we would like to withdraw. So we're going to go ahead and hit enter here. And we'll see that the trace returned two elements in an array. The first one is the initial transaction. This is the from. This is the two, right? This is the transaction that we ended up sending.
00:14:46.034 - 00:15:32.120, Speaker A: And what we can see is there's another element here that there was another transaction that occurred because of this one, and that is that the WETH contract itself ended up sending to. This is to the same address here, right? To a bunch of value, right? Value in this case is ether. So we can see that when if this person let's go look at this thing up here. If this person were to call WETH with this data, WETH would send them one ETH, and we were able to simulate that transaction even without having the private keys to this person. So similarly, we could use this same tool to simulate the transaction that we were going to try to withdraw that AB quizzes ETH. So let's go ahead and do that. I'll move this off screen a little bit.
00:15:32.120 - 00:16:10.286, Speaker A: Let's go back to this contract here. Now, a nice way to come up with the input data that we need, right? Because input data was one of the fields that we need to come up with. We can go over here to write contract and use MetaMask to pop up this little window here. This is again the one where if I clicked confirm, I was going to lose all my money. But it'll actually tell you what input data it was going to use. So we can just copy this data, pop it on over here, and we're going to come up with our own little trace call. So again, this isn't with anymore.
00:16:10.286 - 00:16:37.690, Speaker A: So the data in question is the call data that we pulled out of Adam MetaMask. Now, who are we sending this transaction to? Well, the AB quiz contract, of course. So go here, just going to copy this address. Do to from. I don't mail. Just keep it the same, right? This is that WETH holder from before. It doesn't really matter what the from here because there's no caller restrictions.
00:16:37.690 - 00:17:10.006, Speaker A: And then the one last thing we need to do is that we actually have to include value we have to include some Ether value. So I'll do move this over here. You can see it better value. Again. This is JSON value. Now I need to let me do a little quick math over here. Okay, so this is the Hex value for 1.1
00:17:10.006 - 00:17:38.160, Speaker A: Ether. All right, this looks good. So here we are. We are sending a JSON RPC payload to my Ethereum RPC node to the AB quiz contract with the data that guesses the value nine as the string that we believe is the answer to this riddle. We are saying what would happen if we also included 1.1 Ether to satisfy part of that if conditional. Let's go ahead and run it.
00:17:38.160 - 00:18:37.730, Speaker A: And we can see the same output here, right? We can see that there was that first level call, right? This is us calling that contract with a value this 1.1 Ether. But remember, like in the WEF example, there was another one where WEF sent us Ether. There is no one here where the AB quiz contract sends us Ether back based on us getting the right answer. So we were able to figure out what this contract would have done with this transaction before we committed to actually sending that transaction. Okay, so now that we've explored how to simulate these transactions, let's look a little at how we might at what is causing this transaction to fail. How did this solidity contract trick us? And the way that it worked is actually kind of an abuse of the way that Etherscan displays data, displays transactions.
00:18:37.730 - 00:19:03.530, Speaker A: So we assumed that this function was the one that started this quiz that kind of activated this response hash. But it turns out that that's not actually what happened. There is another function here which will also set the response hash. But it will set a response hash directly. And this is a response hash that is just a random value to which there is no known string. That answers it. Right in here, they passed in a string and hashed it here.
00:19:03.530 - 00:19:49.506, Speaker A: They just passed in this hash directly. But we noticed that we never saw this new function being called. If we come over here to this actually, I didn't complete that thought right. Once this response hash is set, this response hash equals zero, will be false and will actually not do anything in this Start contract at all even though that was called. So the question is how were they able to call the New function before they called Start? To make these lines here a no op. And when we look over here at transactions, we don't see that call to New. Right? New was the one that is being called first that is preventing Start from actually taking any action.
00:19:49.506 - 00:20:26.546, Speaker A: And the answer has to do again with internal transactions. So even though it doesn't show up here, there's an internal transactions tab and in an advanced mode. And that allows us to see that there was some other interaction, right? This is a new transaction we hadn't seen before that happened before the Start that we were looking at. So in a way, they have hidden an interaction they had with this contract that called this New, right? So here's you can see it's like it's targeting that AB quiz contract here. It's passing in this call data. But because they made it an internal transaction, it didn't show up in the place that we expected. It showed up in a different tab.
00:20:26.546 - 00:20:57.358, Speaker A: And we assume that if Start was called, we assume something about what it would have done to that response hash variable. Another way we can see that something a little funky was at play here is if you look at this transaction here, right? This is the one that called Start with the question response. This is the one that didn't actually do anything. There's a little tab here for state changes. And this tab tells you all the storage slots that were updated on a contract. There'll be like a little drop down here. Notice there's nothing right here.
00:20:57.358 - 00:21:47.070, Speaker A: Basically saying that nothing changed on this contract, right? That if was false and it never ended up updating any of those storage slots. If we instead go back and look at the internal transaction that occurred right here, this is the internal transaction where they called New first in a way that was not apparent based on Etherscan's interface. And we go to state changes. This zero x 72 A, right? This one there is a down arrow here and we can see all the storage slots that were updated. So this transaction over here, see, this is seven two A is the AB quiz we've been talking about going back. If we look at that transaction, the transaction itself was not destined for that seven two A contract. It proxied it through another contract.
00:21:47.070 - 00:22:24.234, Speaker A: I also have some examples here of some previous examples of people kind of falling for this trick. So here's a few transaction hashes that I figured out before I started this video. So here we have somebody who deployed one of these contracts. You can see it looks remarkably similar, has a different question. But if you look here, see, somebody saw this like, oh, you know what, I'm going to send one Ether and get the right answer. And they actually realized they made a mistake by not including enough Ether and they tried it again with 1.1, but they still weren't getting that response hash correct.
00:22:24.234 - 00:22:46.226, Speaker A: And so they ended up ended up losing 2.1. So here the attacker deposited ten ETH. And then the attacker up here in this transaction withdrew 12.1 E. There's many, many versions of these. So here is deposited ten. Somebody took a guess at one.
00:22:46.226 - 00:23:16.140, Speaker A: Here's another one. Here's ten one. These are all different versions of somebody falling for this. Here's one that I kind of like. So again, this has been going on for a really long time, right? This is over 500 days ago. Somebody ended up losing four ETH here. They took two different shots at guessing, and again, this hacker deposited five ETH, and they walked away with nine.
00:23:16.140 - 00:23:48.166, Speaker A: Actually, that first one, the comments on that first one is a little funny, so I already showed you this one, but in this comments tab over here, you can see there's, like, a little discuss comment. If we look at it, ten out of ten would get honey potted. Again, I don't find it kind of funny, so somebody at least saw the humor in losing 2.1 E. So, yeah, that's what I have for you today. If you found this interesting, please feel free to reach out to me. I'd love to talk more about Ethereum security.
00:23:48.166 - 00:24:10.250, Speaker A: And again, I'm working with the EF to provide free quick checks of security for various Ethereum projects that are nearing or after mainnet deployment. So if you have a project that you think could benefit from that, please feel free to reach out to me. My email address is here on the slide, and I'll also make sure that I include it in the show notes. All right, talk to you later. Bye.
