00:00:00.250 - 00:00:55.150, Speaker A: Welcome to Using Flashbots to Mint NFTs on Ethereum Part One my name is Scott Bigelow and I am a co founder of Flashbots, a service that has been running on the Ethereum network for about a year, which has improved the way that bot operators and miners communicate while improving the overall health of the Ethereum network. In this talk, we will be discussing what Flashbots is, why you should use Flashbots to mint NFTs, and we will build a TypeScript based bot live that will mint NFTs on Ethereum. Using Flashbots. We will not be covering what an NFT is or how you mint them. So if this is something that you would like to get more familiarity with, I will leave some links in the video description. I recommend checking them out before popping back to this video. In part two, we will be extracting mev or maximally extractable value by minting NFTs with Flashbots.
00:00:55.150 - 00:02:06.958, Speaker A: What I mean by that is, in this video we will be creating a transaction using Flashbots which will send some amount of ETH to an NFT Minting contract, and so long as we land the transaction at the right time. While this NFT Minting contract is open for new Mints, this contract will send us an NFT back. At the end of this transaction, we will be down one ETH and up one NFT, and it is up to us to determine whether this trade was worth it. In part two, we will add another component here, which is a third party service called Artbotter IO. Artbotter is a system that allows users that are interested in an upcoming NFT drop to place an order ahead of time that allows anyone else to fill that order and receive the ETH that the user has staked. This allows us to create a small little arbitrage here where we can buy an NFT during the time which this NFT Minting is open, effectively sell this NFT to a user who has staked ETH, waiting for someone else to come along and buy the NFT on their behalf. And in doing so, we will receive their ETH that the contract was holding.
00:02:06.958 - 00:02:43.578, Speaker A: At the end of this transaction, we will not have an NFT. We will have flipped this NFT for more than we bought it for. We will have 0.1 ETH extra at the end of this transaction. When we talk about extractable value, we are talking about transactions which are intrinsically valuable that anyone can run on the Ethereum network. But if you are the one to do so, you end up with more assets at the end than when you started. So what is flashbots? The best way to understand Flashbots is to compare it to the standard Ethereum transaction propagation mechanisms in this diagram.
00:02:43.578 - 00:03:34.414, Speaker A: This here is a signed Ethereum transaction from an account that has ETH to use as gas. This could be created, say, by MetaMask. It could be created by your hardware wallet, but somehow you have created this transaction and you give it to the Ethereum network either via Infira or your local node. And this transaction will sit there and bounce around the Ethereum network being copied from node to node to node until eventually it finds its way to a mining system that is waiting to create a block with many of these transactions that it is discovered in the same way. And eventually these will become part of a block and they will be confirmed. So this is not how the Flashbot system gets transactions into blocks. Instead of operating on a single transaction, Flashbots operates on a bundle of transactions.
00:03:34.414 - 00:04:24.320, Speaker A: This is many transactions that are indicated in a very specific order to be included atomically. Instead of giving these transactions to the Ethereum propagation system, there is a Flashbots Relay, which is a hosted service that can receive these bundles. It will perform some lightweight inspection on the bundles to make sure that they are valid and profitable enough to be of interest to miners. And it will send them along directly into these miners, mempools waiting for the next block to get created. And then they will appear all of a sudden, not having been seen in the pending pool. Previously. So why would you use Flashbots to mint NFTs? Many of the NFT Minting systems have restrictions in them preventing smart contracts from participating in these sales.
00:04:24.320 - 00:05:08.170, Speaker A: In part two, one of the things we wanted to do was to mint an NFT before selling it, and we would like to do that in the exact same block. We do not want to be stuck holding this NFT while somebody else filled this order. We really would like to buy and sell in the exact same block and not maintain any price exposure using bundled execution, we can have multiple things happen in the same block. Even as the components we're acting with do not allow contract interactions. We also get pre confirmation privacy. By sending transactions directly to these miners and avoiding this pending pool or dark forest. We don't give our competitors a chance to see what we're doing until it's too late.
00:05:08.170 - 00:06:05.970, Speaker A: When it appears in a block, we also get revert protection. One of the agreements that Flashbots enabled miners have is that if a transaction that you submit reverts when it executes on chain, it won't be included by the miner, it will be discarded and the next transaction will be selected instead. This is a set of transactions from an NFT drop of something called eight bit token, and these here are the newest transactions and these are the oldest. This is Etherscan, which sorts backwards in some cases. And we can see here that these users were able to successfully mint one of these tokens and later transactions were not able to do so. Right here in this one block is the cutoff point for when this NFT sold out all of these users, not only did they not get an NFT they still had to pay the transaction fees associated that caused their transaction to revert. So they are out really two things at once.
00:06:05.970 - 00:07:03.246, Speaker A: Okay, now that we've covered what Flashbots is and why you would use Flashbots to mint NFTs, let's jump into building a TypeScript based bot that will mint NFTs using Flashbots. To do so, we are going to be using the Gorely Ethereum test network. I have two contracts here that I have previously deployed. One of them is called Waste Gas, and we're going to be using this one first as a demonstration to make sure that we have the Flashbots library working and can submit real transactions to the network. This Waste gas is a very simple contract that simply receives any transaction sent to it and uses all of the gas available. One of the things the Flashbot's relay confirms before sending the bundle to the miner is that a bundle uses enough gas to be interesting to the miner. There is a amount of gas, if you use less than the relay will give you an error saying please use more gas.
00:07:03.246 - 00:07:37.610, Speaker A: This is not something that's actually extracting value. So this contract really just bypasses that check. Let's create a Flashbots searcher or bot which targets waste gas and lands real transactions on the Gorli network. Okay, here I have a skeleton TypeScript project. I have no code and no interesting libraries installed here. I have some of the important TypeScript bits here, but nothing related to Ethereum has been added to this project yet. So one of the first things that we want to do when we are working with Ethereum is to install an Ethereum library.
00:07:37.610 - 00:08:16.534, Speaker A: My favorite library here is the Ethers JS library. It's a nice modern library with well defined TypeScript interfaces. But because the Flashbots relay is not an Ethereum service, it has different API endpoints that aren't covered by Ethers JS with proper typing and friendly return types. So we have our own bundle provider. This is a Flashbots plugin to the Ethers system that allows you to communicate with the Flashbots relay in a developer friendly way. Okay, and now we have these two dependencies installed. This is all we're going to need from dependencies.
00:08:16.534 - 00:08:51.640, Speaker A: So let's go ahead and start coding. Let's pop open a TypeScript file index. Let's just make sure we have TypeScript working here. So say, how about hello? So let's say Tsnode, which is a quick little tool that will run TypeScript for you without requiring it to be compiled. First we say hello. I also have an IDE run button here which does the same thing. The only difference being that when I run via my environment, I have a environment variable already loaded up that has a private key for Gorely that we will be using.
00:08:51.640 - 00:09:26.014, Speaker A: Okay, so let's start coding. Well, we're going to be talking to Ethereum. So one of the first things we're going to need is we're going to need a Ethereum provider, which is an interface that Ethers gives you, that allows you to communicate with an Ethereum endpoint. We'll say our Ethereum provider equals inferior. We're going to be using the inferior system to talk to Gorli. And I happen to know that network ID Five is the network for Gorli. We'll go ahead and import here and I like to make this thing a little bit more friendly.
00:09:26.014 - 00:10:14.878, Speaker A: So let's go ahead and say this is our chain ID. We'll be using that later in our transaction. And let's say, how about provider git block number, just make sure everything is working. This is an Asynchronous JavaScript function and we can't add an Await here because we are not in an Asynchronous function. So we can just wrap this into a method and say great, so now that we have this in a Asynchronous method, we can do this and let's actually make sure that we output it right. Let's go ahead and write this to the terminal. So I'm running this which will cause us to reach out to inferior, get the block number, print it so the inferior portion of this is working.
00:10:14.878 - 00:10:46.362, Speaker A: Now let's make this just a little bit fancier. Let's go ahead and grab every single block that comes in. Whenever there's a new block, I want to call a function that prints the block number. So get rid of this one. And now instead of printing it once, I'm going to run this thing, we're going to connect to infura. And every time a new block comes in, we are going to run this function which will just output block number. Okay, great.
00:10:46.362 - 00:11:19.054, Speaker A: So we see it. These are gorli blocks. Okay, now let's start interfacing with Flashbots. To do that, we're going to need to instantiate that Flashbots bundle provider that we installed earlier. The way you do that is there is a Flashbots bundle provider. There is a create static factory method that returns to us an object that we can use to send bundles. The arguments here are the generic provider because the Flashbots relay doesn't actually have any request.
00:11:19.054 - 00:11:49.630, Speaker A: You can ask it, you can't say estimate gas. You can't get a nonce. You need to give the Flashbots bundle provider a real Ethereum provider that can allow it to help you build your bundles by asking questions of the Ethereum network. Authsigner is the way that Flashbots does user authentication. You get to make up your own user, effectively creating your own wallet. So we can just say, let's just create a random wallet. This is used to kind of establish a reputation with Flashbots.
00:11:49.630 - 00:12:24.060, Speaker A: They can recognize when you send a lot of profitable bundles. And if you are a consistent relayer of profitable bundles for the miner, they can prioritize traffic based on that. And then the last thing is the connection string. This is the Flashbots relay to connect to. And I just recently read the doc, so I know that this is relaygorly Flashbots net and let's go ahead and just dump this into a constant. I'll call this flashbots endpoint. Great.
00:12:24.060 - 00:13:09.746, Speaker A: Okay, so now we need to this is an async. So we'll need to await this and we'll say flashbots provider equals this. So now we have our flashbots provider object. One of the unusual things about the way that you send transactions to flashbots is that instead of sending a transaction once into the pending pool and waiting for it to be included by a miner, you must resend a flashbots bundle for every single block that you want it to be included. This allows you to effectively cancel a transaction by just not sending it anymore. You don't need to try to replace this with a transaction at the same nonce. You can just say, you know what, whenever this process dies, that bundle should no longer be included because it isn't targeting any of the blocks.
00:13:09.746 - 00:13:45.410, Speaker A: All the blocks I was targeting have passed. We need to start sending a bundle every single block. That's why we set up this provider on block so we can say let's take this flashbots provider, we want to send a bundle. Well, these bundles are multiple transactions so we have an array here. The array wants us to specify transactions. We'll come back to this but let's kind of get this function call basically happy and it also wants a target block number, right? It wants to know which block would you like these transactions to be included in? Well, we know what the block number is. This is the current block number.
00:13:45.410 - 00:14:23.742, Speaker A: Let's just always try to land our transactions in the next block. So whenever we discover a new block, we try to land whatever bundle we come up with here in the very next block. And this is going to happen for every single block whether we land or not. So let's start building the transaction details that will create a bundle of transactions that will get sent along via the flashbots relay. We do this by submitting a transaction description along with a signing wallet. So we have new wallet and this comes from provider M. I called it wallet private key.
00:14:23.742 - 00:15:01.706, Speaker A: This is the environment variable. Sorry, not end. This is process env. So this is the environment variable I mentioned that is being included when I run this process and let's go ahead and extract this into a variable like we do all of our things call this the wallets perfect. An environment variable is something that might be present when this thing runs or it might not be. And so actually if we run this let's go ahead and try to try to run this, we're going to get a failure. This is going to get upset because what it's saying is, hey, this environment variable here, wallet private key.
00:15:01.706 - 00:15:41.062, Speaker A: This could be undefined or it could be a string. If you presented it and you are passing it to something that is not expecting an undefined value. So by running logic here, so say wallet, private key. If it equals undefined, then console wall. How about console error? Please provide wallet, private key ends. And we'll do a process exit here. Now, when we run this, TypeScript has recognized that we have taken care of the scenario in which, see, there's a different area.
00:15:41.062 - 00:16:17.986, Speaker A: We'll fix this. But it is recognized that this can no longer be undefined because if it was, we would have exited. This is one of the really nice things about using TypeScript and the error here, right? We should give it a provider as well. This allows us to run estimates later in the Flashbots provider send bundle process. Okay, so now that we got all this intermediary work done, let's start building the transaction that we would like Flashbots to send to the Gorely network miners so we can start asking for the kind of things we need to provide. So a chain ID, we already have that. It's.
00:16:17.986 - 00:16:45.630, Speaker A: Five type. We're going to use a type two transaction, which is EIP 1559 transaction. We're going to use a value of well, we're just wasting gas, right? So we're just going to say, how about value of zero? Expects a big number. What else do we have to add? How about gas limits? Well, we know we need to waste more than 42,000 gas. 50,000. It's kind of a nice round number. Data, we don't really need to provide any data.
00:16:45.630 - 00:17:16.306, Speaker A: Zero x the way that you say null. And let's start dealing with gas price. We need to say, well, what is our base fee? What is our max base fee that we're willing to pay? ERP, 1559 has made this actually a lot simpler when you're trying to do demo transactions. So we just need to provide kind of a reasonable number here. I don't even need to go look up what the right market value is here because it'll just select whatever is reasonable. So this here is the way that you say guay. So this is ten to the 9th is a guay.
00:17:16.306 - 00:18:00.966, Speaker A: And let's say, how many guay are we willing to pay? How about we're willing to pay three GWe for our base fee and we are willing to pay for our priority fee. Actually, you know what? We're going to reuse this. Let's go ahead and take this and let's turn this into a constant because this is the guay. We can just reuse that in our next thing we'll say, how about we're willing to pay this much for our priority fee? The last thing we have here is two, right? This is the destination of our transaction. Let's pop over here to our waste gas. Copy that address. Pop over here.
00:18:00.966 - 00:18:35.594, Speaker A: Say two is going to be this is specifying the waste gas contract address. We're going to waste 50,000 gas, but we're going to do so by sending a bundle to Flashbots. This is not going to be sent along to the standard pending pool. I think we have everything here we need to run. Let's go ahead and click it now. Not every miner on the Gorli network is a flashbots miner. And so there is going to be several blocks that go by here where we don't get included.
00:18:35.594 - 00:19:12.030, Speaker A: Because if the Gorely miner that mines that block isn't flashbots, it will not have received this transaction. It has no chance of including it. But we do have a Gorely enabled miner. So when it's that miner's turn, so long as we get this transaction to them in time, we will see that this contract here has an inbound transaction. Okay, there we go. We have our transaction that did not show pending and all of a sudden showed up in a block. If we take a look at the transaction details here, we can see that this transaction has all the details that we specified in our transaction description on Sendbundle.
00:19:12.030 - 00:19:40.998, Speaker A: We have our destination, we have the various gas prices we configured here's, the 50,000 gas. And true to form, the waste gas contract wasted all of our gas for us, ensuring that this became a valid bundle in the eyes of the flashbots relay. But wasting gas isn't really what we came here to do. We came here to buy NFTs. And so I set up a contract here called Fake Minter. This is already deployed on the Gorli network as well. Let's take a look at that.
00:19:40.998 - 00:20:29.910, Speaker A: And this is a very, very pared down implementation of what the contracts on main net look like for Minting NFTs. This is a fake ERC 721 contract which is the standard usually used for NFTs. And we deploy this ourselves. Our own fake NFT ish contract. But this contract itself here is the Fake Art Minter contract which has a function in it which requires you to send some bit of ETH, in this case 0.3. And we will, if you do so, mint an NFT directly into your account. We will emit a message and then the owner of this contract of the fake Art Minter Me, will receive the 0.3
00:20:29.910 - 00:21:05.722, Speaker A: E that you sent in order to buy this NFT. So what we need to do is take the example that we just created and instead of calling zero X or no call data, we need to call this Mint function. So let's pop over here. So let's really just change this system to target the Mint function of a different contract. Well, one of the most obvious changes we'll need to make is we're targeting a new contract. Let's grab, copy this address, paste it. 50,000 gas is almost certainly not going to be enough to do all the things that this needs to do with minting the 721 and forwarding the ETH.
00:21:05.722 - 00:21:41.998, Speaker A: But one of the really nice things about this flashbots provider is that this gas limit here is really an override. You don't need to provide it and if you delete that attribute, the flashbots provider will recognize that there is no gas limit provided and perform an estimate gas in order to populate that at the last minute before signing your transaction and sending it along to the flashbots relay. The rest of these transactions look good except for well value. Right? We decided that you needed 0.3 to cause that function to succeed onto the Mint. So let's actually make sure we're sending that value along. Now, how do we say 0.3?
00:21:41.998 - 00:22:17.126, Speaker A: We can say, well, how about, well, ten to the power of 18 is an Ether, right? So let's go ahead and make this a constant Ether. So we have our GUI on our Ether here, but right, we don't want to send a full Ether, right? That's too much. We need to say, well, how about an Ether divided by 100 mole three. This is how you say 0.3. You could also say big number from and pass it a string. But this is a nice, elegant way to pass value and be able to change it easily later. The last bit of information that is needed here is data.
00:22:17.126 - 00:22:45.182, Speaker A: This is the call data that is passed to the contract that needs to make sure that Mint is the function that we are invoking. There's a lot of ways to come up with what this call data is. Ethers itself has some really nice utilities around abi parsing. But we're going to skip all that and do the really easy way. We are going to say connect to web3. We'll choose MetaMask. Yeah, ether scan has access to our web3 object.
00:22:45.182 - 00:23:20.346, Speaker A: We'll go to Mint, we can say, well, this is the amount of Ether to include in it. If there was other parameters, you would have text boxes for them here. And we'll say write, okay, we have our MetaMask pop up here. And all this is garbage. All that we really care about for this is the data tab here under Hex data. Etherscan and MetaMask have already done the abi parsing that was necessary in order to figure out that this is the call data that you use to call the Mint function. So we can just copy this, pop back over.
00:23:20.346 - 00:23:49.206, Speaker A: We'll reject it, right? We didn't want to actually do this via MetaMask. We'll come over here and paste this and this should be good to go. We now have changed our little demo here to target a different contract. And just like before, we are every single block sending this transaction to the next block target. We're hitting run here. Let's pop back over and look for inbound transactions to this contract. Okay? So there we go.
00:23:49.206 - 00:24:17.642, Speaker A: Our transaction appeared out of nowhere. It was not pending. It appeared suddenly in this block. And again, if we go look at the transaction details, we see all of the details that we specified. The gas limit, right? We didn't type in this number, but the bundle provider was able to estimate that this was the amount of gas required and populated it without us doing anything. We have the same gas fees as before. Ether scan is able to say like, oh, well, this is the Mint function that you called, reversing it from the data that we passed.
00:24:17.642 - 00:25:00.122, Speaker A: And here we can see this is our NFT Mint, right? We were able to actually get token ID six of this fake NFT contract. And here's the 0.3 E right here. So this is the way that you can target arbitrary contract functions using MetaMask simply to extract the data that you need for the call data, which is really that missing part. And I'm sure you're thinking that, well, you're not really trying to mint these fake tokens, you're trying to mint some other token you're interested in. Let's take a look at a couple of others and see how we might have used a similar system to mint those NFTs. This is a production token called Eight bit.
00:25:00.122 - 00:25:29.442, Speaker A: It was the same one that I showed before where it sold out and there was those failures within that same block. And just as before, we can go to contract, write contract. And you might need to do a little bit of digging here, but it's pretty obvious we're talking about the Mint bit. This required some amount of ETH. You might need to either find the value required for minting either as a read. Let's see if we can do it. Here a read contract attribute.
00:25:29.442 - 00:25:53.086, Speaker A: Many times they'll have the price here perfect, right? This is the price. And in here they want it as Ether. I happen to know this is just zero eight. You might need to convert this value from way into ether to work it here. But honestly, this doesn't even really matter. What we're trying to do is just get the call data from this. This is a good example here because you can mint a different number of tokens depending on the call data you pass.
00:25:53.086 - 00:26:28.310, Speaker A: So let's say that you, in your flashbots, wanted to mint three. Well, we can say right here after connecting the MetaMask, don't forget that you can say three here, pop over to data. This data is a lot longer, right? So we have here the function signature and then there's the three. But it's going to be really important that you copy this entire thing before coming back and pasting it along here with the correct destination of the Minting contract. How about another one? This is the board. Apes Yacht Club. Go to write contract.
00:26:28.310 - 00:26:47.790, Speaker A: And here we go, mint Ape again. You figure out some amount of Ether, you might need to read it either from the contract source code or from here. Here we have Ape Price. Perfect. We can say number of tokens. How about seven? Let's get greedy again. Connect your web3 provider.
00:26:47.790 - 00:27:19.406, Speaker A: Got it. Seven. This transaction, of course, isn't going to succeed. The board Apes is not open for minting, but we can still use this as a good example. Again, here we are, we're getting that hex value. This is one way that you can look at a contract and use a system like Flashbots to figure out what that contract needs called on it. And instead of doing so with MetaMask, you can instead bring that data into Flashbots and have Flashbots do it on the back end and get all those benefits that we've previously discussed.
00:27:19.406 - 00:28:02.034, Speaker A: So let's just walk through a couple of quick things we might want to add to this. Well, this is Sendbundle, which is a function that returns a promise of a very useful object for submitting bundles. So let's go ahead and say I would like my bundle submit response. And of course this also needs to be an async function since this is a callback. So we have this submit response here and this does not throw when it has an error. This returns an error as a more standard response type that is not fatal. So one of the things we need to do before we start interacting with a submit response is make sure that it is not an error response.
00:28:02.034 - 00:29:13.594, Speaker A: So you can just say if error in bundle submit response, then we'll just say let's go ahead and log the error message so it's going to be bundlesubmitresponse error message and we'll just return. So that way we know when something bad is happening, but it's not something that we need to handle right now. But since we've done so, we now know that bundle submit response is not an error object, it is a successful response object. We can call this wait function, which is a promise that will wait until the block we have targeted hits and it will tell us about what happened, were we included or not. We also have simulate this is a very, very important function that allows us to, even before the target block has come, to ask the Flashbots relay to simulate what would happen if this was included, which can tell us if our overall bundle is working properly. So I'll go ahead and just console log this and I'll hit run, we're going to submit this bundle. But before that block even comes, we have asked the relay to tell us about what happened, specifically what the coinbase diff is right.
00:29:13.594 - 00:29:41.542, Speaker A: This is what we are incentivizing the miner with by what we are willing to pay the coinbase. So this can tell us whether this thing reverted. This will tell us if this thing had a EVM response. It would tell us what that EVM response if there was an error, we would see that here. So if you're having problems landing a transaction, this gives you a chance to see it because you don't see it on chain the same way that you see when you actually land action and figure out what's going on. This is the alternative to that, and it's free. You don't need to pay any of these revert fees to get this data.
00:29:41.542 - 00:30:32.898, Speaker A: You might also want to put something here like a gas price getters. So we have here what the max fee per gas is and max priority fee. And these are static. If you are trying to get into an NFT AirDrop, that could be a very competitive thing. And this might be a great place to call some sort of a function like get reasonable gas price that looks at what were people paying in the very last block to get into this NFT, and can I copy those values and add 5% on top of that? Because many of these gas stations that will tell you what a reasonable gas price to use aren't expecting these massive gas price changes that occur within just a few blocks while these NFT drops are happening. And you might need to create your own gas price oracle that is more targeted to these sudden changes in gas price. If you're interested in learning more about Flashbots, I invite you to check out Docs flashbots.
00:30:32.898 - 00:31:13.550, Speaker A: Net, where we keep a lot of up to date and useful information about how to interact with Flashbots. We have a lot of concepts we haven't covered. We didn't cover how bundles are priced so that we can select one bundle over the other, coinbase transfers, paying fees without using Gas RPC Endpoint, where you can learn how to interact with the endpoint yourself if you didn't want to use the Flashbots bundle provider. We have the Searcher Reputation system where we created that random wallet that we didn't use. There's a bunch of information here about why you might use that and how to take advantage of it. 1559 examples we have other libraries if you wanted to use, say, Go. We have a python library.
00:31:13.550 - 00:31:47.674, Speaker A: We also have our GitHub if you're interested in more example searchers to base your work on. And our Discord is a very active place, especially for searchers or people who are writing bots. There is a channel there called Hashtag Searchers with a lot of really helpful people helping others get their bots up and running and sharing strategies for how to extract that 0.1 ETH from Ethereum. Okay, and that's it. Don't forget to subscribe to get notified when part two comes out where we learn how to turn one ETH into 1.1 ETH.
00:31:47.674 - 00:31:48.380, Speaker A: I'll see you then.
