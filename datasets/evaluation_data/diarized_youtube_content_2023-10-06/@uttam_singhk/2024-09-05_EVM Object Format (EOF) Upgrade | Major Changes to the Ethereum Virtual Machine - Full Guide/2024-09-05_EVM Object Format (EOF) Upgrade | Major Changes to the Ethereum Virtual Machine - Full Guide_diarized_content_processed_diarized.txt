00:00:01.240 - 00:00:31.131, Speaker A: Gm. Gm. Everyone, in this video I'm going to discuss a very important upgrade to the EVM, which is EVM object format or EOS. And this is going to be EVM's biggest change since Genesis. And I am really excited about it. I highly recommend you to watch this video till the end, especially if you are a builder or you're involved in the EVM ecosystem. We are going to discuss EOF, which basically consists of series of EIPs, and how these EIPs directly benefit the EVM.
00:00:31.131 - 00:01:13.675, Speaker A: We will discuss the current execution specification and we will see an example of UF bytecode and even discuss some complexity and disadvantages. So let's get started. Okay, so Ethereum has seen substantial changes as the merge and EIP 1559 or EIP 4844 blobs. However, the EVM looks mostly the same. There hasn't been an update to the Ethereum virtual machine specifically. There has always been questions that EVM is too simplistic or some more features would be nice to have. And with EOF which we are going to discuss, it will be EVM's biggest change since genesis of Ethereum.
00:01:13.675 - 00:02:00.151, Speaker A: Right, which is another reason that you should watch this video till the end. And I can guarantee you that you will learn a lot from this video, even if you are a newbie. So let me first give you an overview of what UF is. Right, so we will discuss the current EVM specifications later. Right, so the new EVM Object Format proposal basically aims to make the industry standard Ethereum virtual machine more developer friendly. Okay, so the EF is collection of around 11 EIPs as of now, aimed at overhauling, control, flow, validation and execution of the EVM. And most of these EIPs are interdependent, requiring each to be included in the same artwork to be truly useful.
00:02:00.151 - 00:02:55.251, Speaker A: And this has been worked for roughly around four years and is going to be included in the petra, which is going to be the new Ethereum upgrade. And you can check out these EIPs individually. I will provide a link to all these EIPs in the description, so you can check out if you want, individually. Okay. Okay. So what is current EVM like? How it works? Right, so basically smart contracts today have no formats and the data they contain are called top codes, which are step by step instruction, you can say bytes to the Ethereum virtual machine to execute and some byte represent instructions, some byte can represent data and some byte can simply read that code. Okay, and one of these issues is just how unstructured this Input field is okay, anyone can put in anything and the EVM will do its best to interpret it, which is byte, byte.
00:02:55.251 - 00:03:37.933, Speaker A: Okay, so right now the EVM doesn't have a way to understand a smart contract holistically. Right? And it simply must read each line of code and attempt to execute it. Right, and this is the effect of designing EVM for simplicity. Execution is simple, but it is very costly and not efficient. Okay, and there are also some bad things about current evm, but we can discuss that later. But now let's understand more about eof. Okay, so roughly speaking, the EOF introduces a vergent container format for EVM bytecode which offers a mechanism for managing and breaking, you know, breaking changes to the EVM.
00:03:37.933 - 00:04:10.175, Speaker A: And this is EIP 3540, like the core EOF EIP. Okay, so the first version of the EOF would basically add dedicated data space to the contract versus right now where the data and code aren't distinguished. Right. So we will go deeper into the changes later. But this is like the bigger picture. Okay, so in simple terms, the proposal is to add a format to the contracts which would include code sections, data sections of functions, and more. Right.
00:04:10.175 - 00:04:40.604, Speaker A: So basically it defines a structure of a program, like what the functions are, where the data is, and making analysis and execution more efficient. Right. So the main goal of the core EIB 3540 is to add a format to these contracts. Okay, now let's look into an example and visualize those changes. Okay, so legacy means current evm. First of all, let me also just remove myself. So legacy here means the current evm.
00:04:40.604 - 00:05:07.617, Speaker A: And whenever I say legacy, it means that the current EVM in EUF is going to be the EUF evm. Right? So basically from now on there are going to be two versions of EVM which when I say legacy, I mean the current one. And you know, when the UF is the EUF version which is going to come. Okay, so here you can see in the UF code it introduces a header. So this is the simple legacy code. The code which is current we have right now. And this is the new UF bytecode.
00:05:07.617 - 00:05:35.587, Speaker A: And here you can see that it introduces the header that we just talked about here. Right, it introduces specifically a header. Okay? So don't worry if you don't understand it. I have another example for you. Okay, so this is a basic EOF contract with a data section being used to load a byte of data onto this stack. Okay, now let's break it down step by step. I've also Provided like.
00:05:35.587 - 00:06:36.109, Speaker A: You can also see more examples from this link here. We can go through it later. But yeah, this is basically a simple UF example. Okay, so now let's break down the UF example. Okay, I have mentioned different component with different color here, right? So let's break down each and every component here. Okay, so the starting two bytes are the magic bytes, the deployed code with UF prefix, right? So in London upgrade there was an EIP that rejected any contract that started with EF bytecode, right? And also the question is why not ef, right? Why not just ef? Why do we have this extra two zeros, right? It is because there is already a contract that is I think three contracts that is deployed that starts with ef, right? So that's why we need something extra, right? So that's why we have 00. And why only 00? Why not 01 or 02? Because it is cheaper in call data guess.
00:06:36.109 - 00:07:57.089, Speaker A: Okay, and currently there is no code that starts with EF00 bytes. So whenever we see EF bytecode, we can show that it is validated. Okay? So the next thing is the version number which is 01, which is set at 1 currently, right? And the next thing is the header, right? So the header starts right now and the header type section is four bytes long, which we will see what it is talking, which is what is four bytes long. The next thing is again the header which says that there is one code section which is four bytes long. We will see in the future which one is the code section, right? The next one is again the header which says there is a data section which 33 bytes long. So I think if you already know a bit of solidity, then you can see here which is the 33 bytes long, right? Okay, so the next thing is the header terminator, which is 00, which is basically saying that the header is terminated or header is ended, right? So again now the next thing is the type section, right? So the type section is basically, you can say it provides metadata about the code section. Okay? That's what type section is, right? So it is saying that first section zero inputs non returning max height one.
00:07:57.089 - 00:08:49.995, Speaker A: Okay? So the next thing is actually the code. So this is basically the code, right? So you can see here that here there was a header that was saying that the code section is four bytes long. So you can see the code section is exactly four bytes long. There was also a header here which says the type section is four bytes long. So you can also see the type section is four bytes long, right? Now the next thing is the data, right? So here you can see in the header in the data section it says that it is 33 bytes long, right? And you can see here the data which is the 33 bytes long, which is basically the code section in this particular example, which is data load and onto the stack the first word of data, you know, stop. So yeah, that is the data. And yeah, this is basically a simple breakdown of, you know, EF example in this particular link.
00:08:49.995 - 00:09:21.649, Speaker A: I will provide you this link in the description as well. So you can go to this link and there will be multiple other examples that you can check out. You know what, let's actually see those examples. Okay, so I am in the website. So there are multiple examples in this particular GitHub repo. This is by, if I'm not wrong, by epsilon, which they are working with. They are closely working on uf, right? So these are multiple examples.
00:09:21.649 - 00:10:03.325, Speaker A: There is a single minimum valid UF container which is doing nothing, which is basically a simple example. So you can see the example here. And then there are separate other examples, EF container with two code sections, one calling the other. So this is an example for that. And then yeah, there are at least five to six examples that you can check out, right? And also at the end, this one is the example that we took, I guess, right? So yeah, you know, you can check out this and I will provide the link to this in the description. There is also some other information as well, some useful information if you want to read more about UFE eof. Right, so but let's right now continue to our presentation.
00:10:03.325 - 00:10:52.867, Speaker A: Now let's also look into EVM UF taxonomy as it, as it visually represents like the EUF changes, right? So EUF separates EVM bytecode from data, making it easier for static analysis tools, formal verification and L2 to process the executable code. Right? So as you can see in this Diagram, there are 16 legacy opcodes which is like this is the legacy EVM that we discussed and this One is the EOF the new one, right? So there are 19 new EOF opcodes, UF validation, UF format. Right? And then this is the 16 legacy opcodes and everything, right? So yeah, this is just the basic overview of the opcodes. Okay. And this was like credit to this person. I took this image from Twitter. Okay, cool.
00:10:52.867 - 00:12:35.573, Speaker A: So now let's discuss some advantages of how UF is going to help developers as well. So one common annoyance of solidity programmers has been the stack to deep issue, right? And since the EVM only supports dupe 1 to dup 16 and swap 1 duplication. Of course, to swap the stack elements around, you can't have like more than 16 local variables or functions parameters in the solidity, right? And this has been a very, very big alliance for solidity developers that they need to structure their code around this issue. For beginners who haven't coded in solidity, imagine that every computer program gets a limited amount of memory to execute within and this check enforces a kind of a boundary, right? So yeah, so although this stack can be up to 1024 items item stall, but once you try to reference a variable in slot 16 or higher, it is going to fail, right? So stack 2 deep has always been an issue, right? So but with EOF, the EF introduces stupin, sharpen and exchange three opcodes. That makes an eight bit immediate, you know, which makes it possible to have up to 256 local variables or function parameters. Okay, so these three new instructions have been added, right? So the DPN basically duplicates a stack item at the top of the stack. The swap one Exchange swaps a stack items with top of the stack, right? And the exchange swaps two items in the stack itself.
00:12:35.573 - 00:13:21.657, Speaker A: Right? So however, these opcodes are not UF exclusive, so they could be easily be added to the normal EVM without the eof. Right, but they have been proposed in the eip before, which is 663. Right? And I can specifically create a long video on about this topic. And if you want a video to understand what is stack two deep error and all the stack things, then yeah, just comment down and I will create a separate video on this. Right, So I think getting rid of the stack 2 dip, you know, compiler error is one of the EF's biggest impact for the devs. So if you're a dev, then it will be, you know, helpful for you. Now let's discuss the next advantage.
00:13:21.657 - 00:13:53.593, Speaker A: Right, so the code validation at deploy time. So when someone creates a smart contract, there is no mandatory check to ensure that the code is correct. Right? Code was correct. This means a contract could have incomplete instructions or even undefined opcode instead. Right? So EVM only dealt with issues when the contract was actually executed at the runtime. Right? So with the EVM can analyze a smart contract before. So before it is deployed on chain itself.
00:13:53.593 - 00:15:00.335, Speaker A: Right? So if it fails any of those stacks, it can be rejected outside. So if your contract has any errors like incomplete instruction, example A push instructions without necessary data, the deployment will be rejected, right? So this ensures that Valid contracts are only deployed, right? So this is also kind of future proofing. So by rejecting the contracts with undefined instructions, it becomes safer. So let's say in the future, if we add new instructions to the ebm, we don't have to worry about the risk that older contacts might break or they behave unexpectedly. Right? To summarize, this, EIB EOF moves a lot of runtime checks to deploy time. And instead of having the interpreter validate the instructions repeatedly at runtime, the EVM bytecode is basically validated only once during the contract creation, providing a faster and a more secure execution. So there are also some new rules.
00:15:00.335 - 00:16:30.483, Speaker A: New deploy time validation rules like depreciated instructions such as call code and self destructs are rejected and then undefined instructions are rejected and then incomplete instructions like push without any data to push are also rejected. So yes, the code validation is not going to be at deploy time rather than runtime. Okay, so another advantage, I think probably the biggest advantage of UF is that the jump desk analysis is performed at deploy time instead of runtime. So, bit of an explanation here because not everyone knows about jump desk, right? So when a smart contract is running, it often needs to jump to different parts of its codes to perform certain tasks. Think of it like following a map where you have specific destination you need to reach, right? So jump desk analysis is like checking the map to make sure that all the destinations are valid and safe to go to. And it ensures that when the code makes a jump, it doesn't accidentally land in the middle of a data or instructions that doesn't makes sense to jump to, right? So the jump test introduction, which is opcode 0x5V marks a specific points in the code where the program is allowed to jump during the execution. So not every occurrence of the opcode 00:55B in the code is valid jump test.
00:16:30.483 - 00:17:20.853, Speaker A: Okay? This is because the same byte might appear as part of the other instructions or data in the code, not just in the jump test. Okay? The picture is not fully abducted saying the same thing. So this is why the jump dest analysis is provided. I hope the picture is clear like why jump dest analysis is required. It's basically checks that all the destination with the example are safe and they are valid to go through, right? So whenever it is going to make a jump, it doesn't accidentally land in the some, some of the data instruction that doesn't any, you know, make sense. Okay, so now what is the problem with this jump test analysis? Right? So again, following that example of the Map. Imagine you are following this map while driving.
00:17:20.853 - 00:17:50.193, Speaker A: Okay. But every time you come to a turn, right, you have to stop and then recheck the entire map again to make sure that you are still on the right path. Okay. So this slows you down every time. And this is not really an efficient way if you want to reach somewhere, right? Every time, if you want to, if you have to take a turn, if you have to see the map again, then this is a very very not an efficient way. Right. So this is similar to what happens with runtime analysis.
00:17:50.193 - 00:18:29.981, Speaker A: The jump test analysis is currently done every time the code is run, right. So which takes up processing power. There have been attacks in the past where people could overwhelm the system. Right. So basically a DOS attack by creating lots of contracts with complex code to slow things down, which is not really good for the evm. Right. So also in order to combat those issues, there was the maximum INIT code size when introduced in EIP3860 which basically introduced an extra additional guest cost for the jump desk analysis so that people can't really do the attacks.
00:18:29.981 - 00:18:59.101, Speaker A: Right. And with overwhelmed the system. Okay, so yeah, so that was introduced. So now with the euf, what is the scene? So with EOF the changes, UF changes the game by moving the jump desk analysis to the time when the contract is first deployed again. Right. So rather than every time it runs, this ensures that the jumps only point to a valid instructions, not a random data or you know, invalid areas of code. Right.
00:18:59.101 - 00:19:40.743, Speaker A: So this is going to be at deploy time instead of runtime again. Right. So do maybe, I'm not sure, maybe, but I think the max code size can be increased significantly without running into these issues again because the EIP3860 was introduced right. To so that we can make sure that this attacks can't happen and you know, nobody's overwhelming the system. But I think maybe the max code size can be increased significantly after this EIB or UF is introduced. Okay. So yeah, you know, EF changes the game and I think this is one of the most the biggest advantage of UF.
00:19:40.743 - 00:20:20.319, Speaker A: Okay, now let's continue to check other advantages. So EIP 7620, which is the UF contract creation. So since UF does not allow, you know, code observability which is required for legacy creation. Right. So instructions such as like the create or create to. If you don't know what Create 2 is, I've created actually a thread which you can check out. I will provide the link in the Description So the new instruction have to be used to, you know, create contracts, right? So the 7620 ERP has introduced three new opcodes which is UF Create, Transit TX Create and Return Contract instruction.
00:20:20.319 - 00:21:03.229, Speaker A: Right? So you can see that the first one initiates a contract constraint with the container index. The second one initiates a creation context with initialization code in the transaction data. And the return contract deploys a contract's white code at a container index. We have just seen all that in the structure when we were just talking about it. Okay. So now the UF factory contracts can run, you know, EOF create to run the code for an INIT container inside the factory container, which can then tell the written contract that refers to, you know, another sub container. Now some other advantages as well, which is the gas and code observability.
00:21:03.229 - 00:21:47.901, Speaker A: Right? So I think there was EIP 7069 which basically revamped call instructions as of right. Can upgrade, Ethereum upgrade. There are call, there is static call and the delegate instruction to interact with the external contract. So whenever you want to, you know, deal with external contracts, you use call static caller delegate call. Right? So EOF also gets rid of these gas opcodes and replaces with. Replaces this with variants that do not allow users to specify how much gas they would like to send with the call. Right? So this is these opcodes are not going to allow the user to specify how much gas they would like to send, right? So it creates like three simplified call instructions.
00:21:47.901 - 00:22:39.773, Speaker A: The external call, external static call and delegate call and return data load. Right? So as you can see, that same as call, but basically it's not going to allow but it will be without guess or return data parameters. Right? So similarly for standard static call as well and same for delegate call but without guess or return data parameters. And there is also return data load which removes the need to first copy the return data to memory and then load the value from that memory. This makes far more efficient return reading. So I think if you don't know how the external cause works, the delegate core works. I would say go and check out how proxy contracts work and you understand why the return data load, which basically it removes the need to first copy the return data to memory.
00:22:39.773 - 00:23:14.963, Speaker A: This is how the calls are working. You have to first copy the return data to the memory and then load the value from the memory. So now this makes more sense. This is more efficient reading. Okay, cool. So these new call structures do not specify a guess limit as I said, and button street basically pass the max amount of the Guess and the guest observability has been a problem in the past as the new hard folks may alter the behavior of the contracts, which basically depends on specific amounts of gas, meaning the contracts will no longer affected by repricing. Okay.
00:23:14.963 - 00:23:49.151, Speaker A: And then there also have been few new status code which is zero means success and then one means reward and two is for failure. And then maybe new status code might be added in the future as well. Right. So some other advantages as well. So one of the advantage of UF is smaller program size. The added structure of UF basically allows compiler to, you know, optimize the way they're structuring the code, which might reduce the program size by 2 to 5%. So yeah, this can be one of the advantages.
00:23:49.151 - 00:24:18.981, Speaker A: And we also have seen like you know, how it provides a structure to the code. Okay. So the EF also removes the dynamic jumps, which reduces the analysis to O of N in the worst case. And the EF also separates the EVM guide bytecode from the data, as we seen that, making it easier for static analysis tool, formal verification and L2s to process these executable code. Right. So this in general, overall it improves the developer experience. Right.
00:24:18.981 - 00:25:13.391, Speaker A: And I think it is good for developers since this UF is going to help them, you know, basically going to improvise the evm, the standard Ethereum virtual machine. But I think now it's also important to discuss some disadvantages and what some other people in the industry are saying about the UF and why it is not, you know, too much helpful or what are the disadvantages of that. So let's go and check the disadvantages. Now the biggest issue I see with UF is that it is extremely complex and we will still need to maintain like the unoptimized opcode for the legacy evm, like the current evm. And current EVM will still need to like, you know, be maintained and parallel. Like unless the Ethereum community can devise a mechanism to depreciate the legacy codes. Right.
00:25:13.391 - 00:25:49.631, Speaker A: And to be honest, there needs to be good reasons for protocols to move from existing contracts to like the UF contract. Like, for example, there must be some significant gas cost reduction. Right. Even if you are a dev and if you don't see any, you know, good specifications or, you know, any good changes and any good reason to migrate from the, you know, legacy contract to EF contracts, you will not do that effort. Right. So there has to be very good reasons for the developers to migrate their contracts. Okay.
00:25:49.631 - 00:26:23.533, Speaker A: And issue in practice. I think I see that we will still need to maintain that unoptimized opcode for the legacy vm, which means, you know, duplicating a lot of logic and once with the additional checks and ones without. Right. So these changes have been already resulted in two consensus issues which is one in BESU and EVM one which is used by Aragon. Right. And even before EVM made it to mainnet, so even before the EVM made it to mainnet there has been already some issues. Right.
00:26:23.533 - 00:27:12.689, Speaker A: And luckily these issues were found by developer before they made into release. But yeah, you know this has been, this has been a talk in the Ethereum ecosystem and as a dev, to be honest, as a security researcher, you know, we will have to learn new stuff I think when EUF comes into play. Okay. So also now there are few community members who are not happy with how EF is going into Petra and why they, you know, they have some good reasons for it. Right. The main question is, you know, why are we actively making layer one more complicated to the, you know, as this is not clearly necessary to the survival of Ethereum. Right.
00:27:12.689 - 00:27:39.795, Speaker A: So because according to the Ethereum roadmap and Ethereum has been very clear that L1 should be simple as possible to become a settlement layer and the focus should be making it, you know, easier for people to run the client and it's not that important for the rollup centric roadmap. Right. So yeah, you know, these have been a questions. This has been a pretty much big question for the Ethereum community. Right. And few members of the Geth team. Right.
00:27:39.795 - 00:28:24.697, Speaker A: So Geth is the most widely adopted clients which have basically, you know, they have drawn a line in the sand that they are not going to block the EOF the EVM object format upgrade but they warn that their support will be limited. Even in one of the Ethereum community call I know the developer said that if it blows up on the mainnet, if EOF blows up, then he's not going to stand up at 2am to fix it. I mean, yeah, that's, that's. I don't think so. He will be the obviously Ethereum devs are always going to be there to support Ethereum if anything goes wrong. But yeah, you know, this shows that they have a bit of frustration with euf. Okay.
00:28:24.697 - 00:29:13.929, Speaker A: And one of the other opinion is that we should leave this for L2s to implement because L2s have a very heavy VC money. So I think most of the people want that L2s should take care of this EOF implementation because they have VCs money and they can do a lot more. And I think people think that L1 should only focus on their roadmap and making sure that most of the people can run their Ethereum client. You know it's, it has to become like a settlement area with rollup centric roadmap. Okay. So you know this has been I think some of the opinions of other people and they don't want UF to be get into Petra. Okay, so let's see what happens.
00:29:13.929 - 00:29:41.301, Speaker A: And now let's also talk about some conclusion. I think we have already discussed all the advantages so we have seen what UF is. We have seen the structure. We have also seen a code example. We have seen advantages and separate E's stack to deep and code valid and everything. We have also discussed some disadvantages and also some what are the views of Ethereum community members and you know what is going to happen. So as a conclusion I think the UF suit of eips, you know stands benefit.
00:29:41.301 - 00:30:31.255, Speaker A: I, I personally believe that it benefit the ecosystem despite its complexity and you know all this difficult to follow history. And I think EOF is going to be the technical upgrades that are important to transform the EVM into like a mature computing platform and turning Ethereum into like a more mature protocol, not just Ethereum. I think all the EVM chains, right. And if you are a user what you need, you don't need to upgrade anything for a Vectra or for eof. And if you are a regular solidity dev then I think you shouldn't need to prepare too much because there is bus. But yeah, so you have to learn about new OP codes and new stuff and new chain changes. I think with this video you started that.
00:30:31.255 - 00:30:55.743, Speaker A: So yeah, if the EF gets merged into Vector then as a dev you will have to learn new stuff. So you know, be prepared for that. But right now I don't think so you will have to do anything. But yeah, rejoice says you might not even encounter the stack two deep error again. Okay. And UF will operate in parallel to legacy EVM smart contracts. So you know there is no need to worry that you have to migrate.
00:30:55.743 - 00:32:13.637, Speaker A: Right? So EVM UF EVM is going to operate in parallel, right. So yeah, I think this is a small conclusion and if you think that this video was helpful then please, please, please do share it on Twitter, you know, share it with people, share it with your community members who the fellows you're learning with and also thank you. Also you can subscribe to the YouTube channel if you're watching it on YouTube. If you're watching on Twitter then and go to my YouTube channel and subscribe there and also follow me on Twitter and there is a link to a telegram channel where I share a lot of stuff ranging from hackathons, from fellowships, from grant opportunities, also sometimes job and internships. So if you are looking, if you're a web3 specific builder and if you're looking for opportunities right so please join that group and yeah I also share some one on one booking slot so you can take mentorship but thank you for watching and do subscribe to the channel and let me know in the comment section if you liked it. What can I improved and maybe what another next video you want me to create and also watch my other crash courses as well. I've created multiple technical crash courses which might be useful so go and watch that.
00:32:13.637 - 00:32:15.765, Speaker A: So yeah till that thank you so much. Take care.
