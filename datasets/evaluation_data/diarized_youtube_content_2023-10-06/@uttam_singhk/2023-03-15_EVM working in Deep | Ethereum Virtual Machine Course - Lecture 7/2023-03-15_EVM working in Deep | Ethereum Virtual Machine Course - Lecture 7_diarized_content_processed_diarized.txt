00:00:00.330 - 00:00:36.566, Speaker A: Okay, so we are finally on our slide of EVM working on our part of EVM working how actually Ethereum virtual machine works under the hoods. We have already connected and, you know, learned about all that amazing stuff. Now let's talk about how actually EVM working with a real life example. So here is a diagram of EVM working. And you know, here is actually, you know, how it actually works. So first of all, in this diagram, you will see a transaction happening. So you can see a transaction here.
00:00:36.566 - 00:01:33.558, Speaker A: So this transaction contains some values, that is two data, the value gas price and all that stuff. So the two is actually to the contract where it is requesting the transaction. Like for example, this two address will be similar to this contract address. We will talk about this in a minute. But you'll be able to see this two address is same as this contract address. Because this transaction is requesting a transaction or some kind of calling this contract, right? This is calling this contract. And then you can also see that this transaction has some data which will go to the EVM and this contract.
00:01:33.558 - 00:02:49.182, Speaker A: So what happens is that whenever a transaction is coming in the EVM, the EVM will pull up the contract that it is calling, right? So whenever a transaction comes, like for example here, there's a transaction to this contract, then what EVM will do is EVM will pull up the contract that has been called, right? So EVM has right? Now pulled this contract because this contract has been called, right? And the contract has these things like address the nose, the balance of it. It also contains it code. The code of it which is immutable. We have discussed like, the code is in the bytecode form, right? And there is also like opcode one in that as well. Opcode basically breakdowns into opcode, right? So that bytecode is present in the contract which is immutable, which can't be changed. And then we have a storage, storage, which is immutable. So if you request on to submitting any of your transaction or any of your balance into that contract, you can do it on the storage, which is immutable.
00:02:49.182 - 00:03:29.950, Speaker A: It is in the form of key and value pairs. Okay? Yeah. And every EVM has this program counter that is set to zero. And EVM will use this program counter to step through this code. So this contract has this code which is in the bytecode format. So the EVM will use this program counter to step through this code and understand what does this contract code does. Right? So we have this transaction, again, we have this transaction which is sending some kind of data.
00:03:29.950 - 00:04:39.750, Speaker A: And what EVM will do is EVM will grab the smart contract, whatever, wherever this transaction is calling, right? And this will use this program counter to understand what this code is doing. And one more thing to understand is that for each and every transaction that has been called onto the EVM, the code of contract is always loaded and the program counter is always, the contract code is always loaded. And then the program counter is set to zero and the contract storage is also loaded. This storage is also loaded, right? And the memory is all set to zero in here, the stack and memory and everything, it is set to zero, right. It creates a new EVM instance every time there is a transaction being called, right? So this is what happens when a transaction is happening onto the EVM. Now, again, what will happen is that EVM will take this data. So this transaction has some data.
00:04:39.750 - 00:05:35.894, Speaker A: Maybe you are doing a transaction, you are calling a function on this contract, right? So what this does is that this data will be given to the EVM. EVM will take that data and deal with the code, right? For example, if you want to call a function on this contract, it will take that data, it will understand what it wants. What does the data wants? It will then interact with the contract. Like what contract? Understand this contract with program counter. And then it will execute it. For example, if you are calling a function, right, it will execute it and use stack and Mumburi to keep records of the things. And once it's done, it changes the storage on the contract as well.
00:05:35.894 - 00:06:37.446, Speaker A: Right? So once your data is understandable by the EVM, it uses the stack and memory and all of that stuff to actually do some kind of changes. And once the changes in done is done, like using this gas available memory and everything, the changes is done, there is a catch that there should be enough gas available. So once the gas is enough available, and the EVM has calculated the changes, like whatever it wants, once EVM has done that, it will update the storage of this contract, right? So this will update the storage of this contract. For example. Let's take an example as well. Clearly as well. So for example, this is an escrow contract, and you want to submit your money or basically your ether to this contract.
00:06:37.446 - 00:07:58.854, Speaker A: What you will do is basically this transaction is calling to this contract, and there is a data which contains message value, right? And it contains the value what you want to submit to this contract. So this data goes to the EVM. The EVM understands that, yeah, this takes the message value and it understands that this is what they want. This is what this particular transaction wants. And what it will do is it will update the storage of that contract, that, hey, this particular contract, this particular address, the transaction, who has sent the transaction, they have requested or they have post, they have provided this much of data, this much of function, it's calling this function to add the ether to this particular address, right? So what it will do is it will call that particular function and it will update the storage of that particular contract. So in this way, your data was successfully gone to the EVM, and EVM has understood it and it has done the changes. And finally it has done the state changes, final changes into the contract itself.
00:07:58.854 - 00:09:42.360, Speaker A: The contract itself is in form of storage, in the immutable, it's form of key and value pair, right? So it has finally updated the contract, the escrow contract, right? So one thing to notice that every Transaction is happening in line in EVM, when I mean every transaction is happening in line, it says that once one transaction is run, then only other transaction is executed. No transaction is executed parallel, right? So just like one, two, three, like one by one, one by one, right? And then once this state is updated, right? So the EVM has changed the state of this contract. So there is a new state, right? We have already discussed the state as well, the theorem state as well. So there is a new state and then this new state is broadcasted to the block. So for example, how blockchain works, I hope you understand that once that block has already finds the non value which is less than the particular target in proof of work, it has been changed. Now, in proof of stake, right? For example, there is block minor or basically block validator in the proof of stake EVM. So the block validator, the block owner miner has this changes, it has done this changes in this geth, for example, he is running geth or any other client service.
00:09:42.360 - 00:10:37.000, Speaker A: They have already calculated this ethereum state. This has news. So now this block, the particular validator block or that particular minor block, the state of that block changes changed. And what it will do is it will have to validate all other blocks that are in the blockchain, have to also agree to the same changes, right? In the blockchain. Proof of work I'm not sure about proof of stake yet. I will have to do my own research. But what happens in proof of stake chain is that every other block has some kind of rules and regulations, some kind of checklist, which they check is that if the block has this particular checklist, then only it will accept those changes of it.
00:10:37.000 - 00:11:20.894, Speaker A: So for example, the block hash is this much if that matches the hash of the previous block. So there are like a checklist which every block has to check before accepting the block, right? So every block checks that, and then every block accepts the new state of that blockchain. Okay, so this changes happening, happens in every 14 seconds. In Ethereum, like for example, every 14 seconds there is a new state, and then after 14 seconds there is again a new state. There is again a new state. So this is what happens. And every block computes those changes and we don't, right.
00:11:20.894 - 00:12:15.350, Speaker A: Every block has to compute all those changes. I'm not sure about the proof of stake thing, which I've talked about, the validator and all this stuff, but I'm pretty sure about the proof of work working. Right. Maybe I'm wrong on the proof of stake side. So what happens is that every block will have to change all that state. All the state changes, every block will have to compute it, right? So suppose there are 30 nodes in the ethereum, right? So what will happen is that every 30 node will have to update those changes. It will not happen that only 20 of those nodes will update update the changes, right? Every block or every node will have to update those state changes as well.
00:12:15.350 - 00:12:50.850, Speaker A: So we don't have the sharding yet. So we will not talk about much about that. I can create a separate video about that. Suppose there are 30 blocks or 30 nodes in the Ethereum, so every block will have to compute those state changes. We don't have sharding yet, in which every shard will have some blocks and they will have to change the state changes of that particular shard. And we don't have that, right? So let's not talk about it. We can create a next video about it.
00:12:50.850 - 00:13:30.094, Speaker A: And there is other chains that have already implemented shardium, so maybe if you want, you can look into it. I have not done my research. As of now, this is how actually the EVM works under the hood. And what it will happen again is there will be one case as well, like for example. So one thing also to remember or to take care of that. This transaction has some data, right? So this EVM will update this contract. But what if there is a call to another contract from this contract, right? So for that we have a special case for it.
00:13:30.094 - 00:14:51.238, Speaker A: That is the Ethereum virtual machines when it calls another smart contract, right? So one thing is again to notice that EVM has access to the world state and not historical data. EVM has only access to the particular world state, no historical data, no previous transaction access, not any access to external APIs or anything. So that's why we have so, you know, Ethereum virtual machine, EVM can't have access to the external APIs, right? So that's why we have this oracle contracts, right? So each smart contract can actually call another smart contract. So here, this EVM request, or this EVM understands this transaction, this data, the request, and then it pushes onto the contract. But what if this contract is required to call another contract? Right? So every smart contract can call another smart contract, and each call creates a new instance of EVM, right? So every time a smart contract calls another contract, there is a new EVM instance created. So let's take an example of an oracle. Like for example, Chainlink smart contract.
00:14:51.238 - 00:17:01.490, Speaker A: So Chainlink smart contract will have the changes in its storage of the current price of the ethereum, right? So the smart contracts on itself cannot get access to external API. So what if you want to know the price of the ethereum right? Now, what is the price of ethereum? So Chainlink smart contract will have the price, current price of Ethereum in its storage, so that the other contracts can check this contract for a given state, right? Or for a particular snapshot. So there is new ambiguity. So for that particular instance of this state, the price of the Ethereum, right, it will be price of ethereum or bitcoin or any other token will be the same for that particular amount of particular instance of time for every other EVM, right? That's why using this is very important, because there will be no ambiguity in future, right? So since the EVM smart contract, the chainlink smart contract, the chainlink smart contract will have the current price in its storage, and that only will be accessible to the smart contracts. That is calling that Chainlink Oracle smart contract, right? So this is like a simple example of how it will work. Now, let's talk about again, there is an EVM instance, right? For example, it again has this program counter gas available, stack in memory, all that stuff, right? And every time we have already talked that every time there is a creation of EVM, the program counter is set to zero, stack and memory, the memory is set to zero and all this stuff, right? So the EVM instance is sent to zero. And in a precipitate example, as we have seen, right, that suppose there is a call, like for example, there is a call from here that in this contract do this, this changes.
00:17:01.490 - 00:18:09.654, Speaker A: So this contract now has calculated the changes, but this contract now is basically in the middle, where the contract will have to call another contract to get the price. Again, if I take the chain link example, maybe this contract wants the price of ethereum, right? So this contract will call the chain link contract, right? So this contract will pass on some arguments, will pass on some input data, and there will be a new instance of EVM, right? And again, there will be program counter set to zero and gas available. The stack and memory is there, right? So what will happen is that this input data, right? So there is a transaction here. Here is a transaction in this example. Similarly, this input data will act as a transaction for this EVM instance, right? And once there is that input data, some kind of bytecode, it will calculate it. Or maybe it will call another smart contract. Like there may be another chain link.
00:18:09.654 - 00:18:36.130, Speaker A: Oracle. This chain link smart contract will call another smart contract, right? So there will be another EVM instance that will be created. Yes, this is the case. And then, suppose, for example, it ends here. Then it will calculate the result. Here, it will use the memory. All these EVM instances actually use memory to calculate all these changes.
00:18:36.130 - 00:20:04.862, Speaker A: And once the calculation is done, it will return some kind of data to the smart contract that has called this smart contract. So it will return some kind of data, and the state of the new EVM is being calculated. And this will be a new state, right? And also, when it passes the EVM EVM instance is passing the input, right? It is calling another smart contract. Then it will also pass the current state of that EVM instance. Because right now, this EVM instance one has already done some changes, right? It has already calculated some changes, so it has some change in its state, right? So it will also pass on this state to EVM instance two, right? And this state will be here. And again, if it is calling another EVM another smart contract, then the EVM instance three will have the current state of EVM instance one and EVM instance two, right? And then at the end, when the calculation is done and there is finally a return value that has gone to the EVM instance one, all this changes will be done and there will be a new world state, right? And only. And only if the gas doesn't runs out.
00:20:04.862 - 00:21:23.234, Speaker A: So if the gas runs out, then there will be the state of that EVM that was calculated will be reverted, but the gas that was consumed will be there and the nonce of that transaction that was called will be increased, right? So the gas will be taken as basically as a punishment for wasting the time of EVM for doing all this work. So if the gas has run out, then the state of that EVM will be reverted back. Right? And the return data, again, the return data is a way of smart contract that can return a value after a call, right? So this written data is basically a way a smart contract can return a value after a call. So this particular line is basically the return data. That is a way that how a smart contract can return a value after a call, right? So yeah, this is the second example of how when EVM calls another smart contract, that will happen. But you have to keep in mind the gas should not run out. If that is the case, everything will be reverted.
00:21:23.234 - 00:22:04.978, Speaker A: And if it is not, everything will be reverted and the EVM will just evaporate. Okay, so this is just a simple working of EVM. And I guess this is overall how the Ethereum virtual machine works. We have taken both of the examples, like example of EVM when it calls single one, and how if it calls another smart contract. So yeah, this is the EVM working. I hope you get how actually the EVM works. And yeah, if you are liking this video, please, if you're still watching it, please like this video comment and please share it on LinkedIn and Twitter.
00:22:04.978 - 00:22:17.780, Speaker A: Please do tag me as well. It's very important for me. Right. And please share it with your friends and family as well. And let them understand how actually EVM works under the hood, right?
