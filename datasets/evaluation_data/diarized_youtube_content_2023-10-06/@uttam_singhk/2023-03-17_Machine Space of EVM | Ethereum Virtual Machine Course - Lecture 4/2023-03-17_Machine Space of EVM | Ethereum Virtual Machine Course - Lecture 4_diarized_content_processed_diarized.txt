00:00:00.170 - 00:00:48.390, Speaker A: So let's now discuss the machine space of EVM. So before going into the working of the EVM, we will have to understand, like we will have, let's run through the vocabulary of the places where the EVM can actually access and store information. Okay, so as we discussed, that EVM is stack based machine, right? So there are no registers out there, right? There are no registers. And the intel computers actually have registers. And EVM is like CPU, right? It's like a CPU. Okay, you can say that. So let's actually talk about the machine spaces that it places where it can access and store the information, the EVM.
00:00:48.390 - 00:01:56.190, Speaker A: So first of all, let's talk about stack. So we have already discussed stack. Stack is like last and first out data structure. So stack stores value temporarily during the runtime to be executed for any operation used by any operations. Any operation takes word from the stack of pushed word onto the stack, or basically both stacks as push and pop, right? So basically any operation takes any of the word from the stack, right? So you can say that stack serves as the intermediate to read and write and manipulate data from the storage memory, call data and locks. We will talk about all these things. But yeah, you can understand right now as locks, it is basically an intermediate to read, write, or manipulate data from other spaces, right? So yeah, you will understand it when we discuss more about memory.
00:01:56.190 - 00:02:30.598, Speaker A: Count, storage, locks, and call data. But yeah, right now understand it basically as an intermediate for writing and manipulating the data. Right. Now let's talk about, before moving on, this is the size of the stack memory, 256 bits, and the depth is 124 elements, 1024 elements. Now let's talk about memory. So memory is also a temporary storage that is executed during the runtime of the transaction. Think memory as a ram.
00:02:30.598 - 00:02:49.730, Speaker A: So it's just like a Ram. It is also a volatile memory. And yeah, it's a byte addressing linear memory. You can also say that as well. And now let's talk about the call data. We will talk about what is the difference between memory storage and call data as well. But yeah, in the future.
00:02:49.730 - 00:03:37.730, Speaker A: But let's discuss call data. As of now, the call data is basically the data field of transaction. It is also just read alumni memory. It is a quite special data location of the EVM that actually refers to the location that stores the input parameter or the arguments of the function that is supposed to be called. So basically, if you are a solidity developer, I hope you have used call data in your code, right? And quite similar to memory, call data is also non persistent, like it's volatile. It's a non persistent data holder that is cleared after the execution of the transaction. So as the transaction is done, it is clear, like called it as clear.
00:03:37.730 - 00:04:05.334, Speaker A: Right. So it is also a temporary memory, right. And it stores the input parameters of the arguments of the function that is supposed to be called. So when you call the function, like you use the call data string, the name, right? So you do that, right. So this is here what call data is. If you're not a solidity developer, you haven't coded yet, so it's okay. But yeah, if you have used solidity, I hope you are aware of what call data is then we have locks.
00:04:05.334 - 00:04:46.230, Speaker A: So what is locks? Locks is write only input area to the emit locks. So basically it's a write only you can write to the locks if you're a solidity rep. Again, you know what are locks? Because once you create event, you specify events in your solidity code and then you emit your event. Once your transaction is done or once your function is executed, you want to emit that so that it is showed in the locks as well. Then you can read those locks and do it. Take it to the front end, you can read the locks and all that stuff. So I hope you are aware of that as well.
00:04:46.230 - 00:05:33.842, Speaker A: And we have the storage lastly. So storage is a persistent memory and you can see the size as well, 256 to 256. It's a key value store. We will talk about actually we will see in the working of the Ethereum virtual machine, we will see it is actually a key value store and how it actually works. Consider as of now, it's a persistent memory and it's key value stored as it is persistent. So it is persistent between any transaction. It is important what is persistent means when we say it is persistent, it is persistent between any of the transactions, right? And storage is represented in the form of Merkel Patricia.
00:05:33.842 - 00:06:16.574, Speaker A: Try the Ethereum python and the go client implementation as we were talking about. They uses labeldb to store those tries. And if I'm not wrong, they are changing it to cockroach DB. Right? But yeah, they uses as of now LabeldB to store these tries. And the Merkle Patricia tree is not just an architecture, basically it's architecture, but it also not just represents only the data structure, but it is also a database schema. One thing to keep in mind is that blockchain itself only stores the blocks, including the hash of the stutterade in the header. Right.
00:06:16.574 - 00:06:54.954, Speaker A: State root of the header. While the clients like Go Ethereum and Aragon, they store the full trice content in the database, right. So it's a very important difference. The blockchain itself only stores the block while the clients store the full trice contained in a database. Okay, so coming back to the topic, the EVM stores data in both storage and the memory. Storage is used to store data permanently, while memory is used to store data during any function calls, right. It is volatile.
00:06:54.954 - 00:07:34.666, Speaker A: Right. And you can also pass in function arguments as call data, right? If you are solid developer, you are already aware of it. But again, you can also pass in function argument as call data which act as allocating to memory, except the data is non modifiable. The data is non modifiable and you pass on data as an arguments when you are calling a function as well. So I hope now you also understand stack as well. Like stack is actually acting as an intermediate to read and write and manipulate data, right? From memory storage, call data, right? And locks. So stack is basically like intermediate.
00:07:34.666 - 00:08:09.114, Speaker A: I hope you get that now. So these are several resources as a space that EVM uses to access and store any of the information. I hope you are clear of all those resources. We have discussed each of them. And stack, memory, account, storage, locks, cold data. I hope I have covered everything if I've missed anything like write down in the comment section, but I hope I have covered everything. Now let's actually talk about before again, we are connecting the dots right now, right? Please bear it with me.
00:08:09.114 - 00:09:02.374, Speaker A: We will get to the EVM working of the EVM, but before that we have to understand few things and that's why I'm telling all of these things. And next, we will also discuss what is solidity. Like just one single single slide, small, small slide. What is solidity? What is bytecode? What is Abi? What is opcode? And once it is clear, we will go through one of the example, we will go through remix, we will write our code, we will compile it, we will see the bytecode, what is that bytecode? What it tells, like we will convert that bytecode into our opcode as well. And we will understand what this bytecode will do to the EVM. And after that, once we are clear, we have brought an understanding. And even as a solidity developer, it's important for you to learn what is happening under the behind to optimize your code, right? So it's very important to understand it.
00:09:02.374 - 00:09:07.300, Speaker A: So we will go through that as well. And then we will be talking about the working of EVM, right?
