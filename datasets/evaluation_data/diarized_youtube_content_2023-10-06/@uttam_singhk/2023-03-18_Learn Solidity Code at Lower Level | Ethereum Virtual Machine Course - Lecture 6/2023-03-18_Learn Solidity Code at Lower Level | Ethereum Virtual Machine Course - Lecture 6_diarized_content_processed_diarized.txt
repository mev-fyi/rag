00:00:00.170 - 00:00:19.166, Speaker A: Okay, so here I am on the remix ethereum ide and I have wrote down a small and very simple smart contract. That is my contract name, my contract where I have declared unsigned variable which is adding to number ten plus two and it is multiplying it by two.
00:00:19.188 - 00:00:19.374, Speaker B: Right?
00:00:19.412 - 00:00:37.906, Speaker A: So goal here is to just understand under the, under the hood how your solidity smart contracts work with the evm and what is happening under the hood. So just goal is to keep it simple. So here I have already written the code. Now let's actually compile our smart contract. So it will generate the bytecode and the API.
00:00:37.938 - 00:00:38.134, Speaker B: Yes.
00:00:38.172 - 00:00:52.018, Speaker A: So it is already generated. Now let's copy that bytecode and let's paste it here. And let's see what is happening. Where is the bytecode? Okay, so you will see all that stuther stuff, but your bytecode is this one object one. This is your actual bytecode.
00:00:52.054 - 00:00:52.302, Speaker B: Okay?
00:00:52.356 - 00:01:21.314, Speaker A: This long one. And one more thing. I have already copied this bytecode into this file. So we already had our bytecode here, right? So this is all our bytecode, right? And I will explain it later on. But here you will see one more thing. We will run through it and we will broke it down into the opcode, but the compiler has already done it for us. And it's a very good thing that they have broke down our smart bytecode into the opcode.
00:01:21.314 - 00:01:34.682, Speaker A: We can also compare it later on as well with what we have broken down into. Okay, so let's move on and let's just look at what our bytecode is doing.
00:01:34.736 - 00:01:35.002, Speaker B: Right?
00:01:35.056 - 00:02:16.914, Speaker A: So this is our bytecode, right? So as I sold that bytecode is a collection of opcodes, right? So let's see what is happening. So our bytecodes start with 60 80. So this is like our first four numbers of it. So what does 60 stands for? Let's go to the Ethereum website and there you will see the list of opcodes you can visit there. So we are looking for what? We are looking for 60, right? So we are looking for 60. So what does 60 does? So here you can see that 60 stands for push one, right? And it costs around three gas. And what push one is doing is that push one byte value onto the stack.
00:02:16.914 - 00:02:45.854, Speaker A: This is what the work of push one is here, right? So what it's doing is push zero x 80. So put zero x 80 into the stack. It is in hexadecimal format, right? So first four numbers of our bytecode is doing this, right? So this, like push this. And now again we have 60. So again we know that 60 cent for push one. And again the next two numbers are 40. So what it will again do is push four 80 into the stack.
00:02:45.854 - 00:03:34.670, Speaker A: Now our next number is 52. So let's go there and you will see where is 52, right? So 52 is here and it stands for m store, which is memory, to store something in the memory itself. So write a word to the memory, right? So this is what it stands for. Again, you will be able to see this is 52, and 52 allocates 60 of the memory space, right? So this is how we are breaking down our bytecode into our opcode. So here again, let's go to our code file, what we have copied, right? So this is what our compiler has already compiled and break down the opcodes for us. So again, we have already discussed it. The 60 stands for push one.
00:03:34.670 - 00:04:18.650, Speaker A: So just push eight 60 bytes and then push one, push four x zero. And then we have a store that is right to the memory, right? So this is what it is doing. If you want, what you can do is you can go through all over this bytecode and try to understand what it is going and what it is doing. If we go through each and every opcode and compile to understand what every copcode is doing, it will take like a two hour long video. If you want, I can create that just comment in the right section. But right now I just want to explain it to you how it is done. So till now what we have done is we have just compiled down or broke down the first few digits.
00:04:18.650 - 00:05:23.140, Speaker A: But this is a magic number, you see, 608-0604 this is actually a magic number. So whenever you deploy any of your smart contract, whether it's uniswap smart contract, whether it's any of your smart contract, it will start with this magic number. Why? Because this magic number, 608-060-4052 it says how your smart contract is being initialized, right? And it can change a little bit due to the version of the solidity compiler. I've seen it when I was compiling and running through it, I've seen that when you use a different compiler version, it can change. Sometimes the opcode will be same, push one and push one. But the memory, the zero x 81, this can change, right? So yeah, this is the magic number and it remains same for a smart contract. Again, there is an exception if you change the solidity compiler version in future, maybe there is something, there is a change in it.
00:05:23.140 - 00:05:56.074, Speaker A: So to further complicate the matter right now, zero x 80 and zero x 40 to be clear, it cannot be interpreted as it is not 40 or 80. This is a hexadecimal format. And 40 actually stands for 64. That is 16 into four. And 80 actually equates to 128 in the hexadecimal format, right? So zero x 60 is not 80. It is in a hexadecimal format. It computes to 128 in the decimal format.
00:05:56.074 - 00:06:54.766, Speaker A: Okay? So in short, what is happening under the hood is that push 10 x 80 and push 10 x 40 and mstro. What it is doing is that it is allocating 128 bytes of memory and moving the pointer to the beginning of the 64th byte. This is what it is doing in a simple matters. And now we have 64 bytes for scratch space and 32 bytes for our temporary memory storage, right? So see, what is happening is that here, if I'm not wrong, it is the initialization of your code. It basically is also initialization of your EVM instance as well, right? So it is generating 32 bytes of temporary memory storage and 62 bytes for your scratch space. If I'm not wrong, this is the initialization of your eVM. And this will remain same for all of your smart contracts.
00:06:54.798 - 00:06:54.994, Speaker B: Right?
00:06:55.032 - 00:07:18.034, Speaker A: So let's discuss more about it. And again, there are three places to store the data. We already discussed this in the architecture of the VM, but let's again discuss it with our opcode. One is the first is the push one. That is push one. Push one pushes one byte to the stack, right? So there is again the architecture of our EVM.
00:07:18.082 - 00:07:18.294, Speaker B: Right?
00:07:18.332 - 00:07:39.450, Speaker A: So what is done, what it does is basically it is pushing 61 byte to the stack. So we have just three places. Stack memory, right? And call data. Call data is not available here. But, yeah, it's not there. But we have discussed it, if you remember, okay, so there are three places where you can store the places where you store the data. One is push.
00:07:39.450 - 00:08:13.354, Speaker A: So push one to the stack, right? This is what it is doing. The push 160. Next is the s store, right? Ss store. What is doing is store it permanently onto the EVM storage. That is the blockchain. So if you use s store, what is doing? It is pushing your data or basically whatever you are doing into the EVM store that is permanent, that is here account storage here, right? And again, if you see push 32 again, what it is doing is it is pushing your memory to the stack, right? And the last one is memory or call. You also use call data as well.
00:08:13.354 - 00:08:57.666, Speaker A: But yeah, memory is also one of the thing. So memory, what it is doing, it is store it in the temporary memory or ram of the EVM. So as we discussed, memory is the temporary one that is non persistent is the temporary memory, or it is also known as the ram of EVM. So what this opcode is doing is that store your data in this m store or our memory, right? So there are many opcodes as well, like m load, s load, jump, stop, return. We will not go through each and every opcode. But these are just like three places. Our stack, our memory and our storage and memory or call data and our storage.
00:08:57.666 - 00:09:03.098, Speaker A: These are just three places where you can store the data.
00:09:03.184 - 00:09:03.434, Speaker B: Right?
00:09:03.472 - 00:09:27.730, Speaker A: So this is what this opcode is doing. And again, if you go to the code and if you can check if you want to go through each and every byte code and convert it into the opcode, you can feel free to do so. And here is an auto generated one. You can check it once you have done your own work.
00:09:27.800 - 00:09:28.226, Speaker B: Right.
00:09:28.328 - 00:09:48.466, Speaker A: And also let me tell you one more thing, is that let's now deploy the smart contract. As I was saying, right, your smart contract is not deployed on the blockchain. Your EA smart contract is converted into bytecode, and that bytecode is actually existing on the blockchain.
00:09:48.498 - 00:09:48.646, Speaker B: Right?
00:09:48.668 - 00:09:53.850, Speaker A: So let's actually deploy our smart contract and see what is happening.
00:09:53.920 - 00:09:54.298, Speaker B: Right.
00:09:54.384 - 00:10:04.574, Speaker A: So once you deploy our smart contract, right, it is being deployed successfully. You will be able to see it. Now let's actually debug it. Right? Not let debug it, but yeah, let's see the details of it.
00:10:04.612 - 00:10:05.054, Speaker B: Right.
00:10:05.172 - 00:10:11.486, Speaker A: So we go here, you can see here, let me just zoom in it for you.
00:10:11.508 - 00:10:11.694, Speaker B: Yeah.
00:10:11.732 - 00:10:24.414, Speaker A: So you can see the status true mind transaction hash from. What is the address that we are using right. Now. If you go in the input section, if you see clearly, you will see this as input.
00:10:24.462 - 00:10:24.722, Speaker B: Right.
00:10:24.776 - 00:10:26.570, Speaker A: And what is this? This is our bytecode.
00:10:26.590 - 00:10:26.966, Speaker B: Right.
00:10:27.068 - 00:10:36.706, Speaker A: You will be able to see that it starts with zero x 80 and it ends with 1033. And that's how our bytecode ends.
00:10:36.738 - 00:10:36.934, Speaker B: Right.
00:10:36.972 - 00:10:40.434, Speaker A: So the input is always in the bytecode format.
00:10:40.482 - 00:10:40.694, Speaker B: Right.
00:10:40.732 - 00:10:52.074, Speaker A: EVM doesn't understand solidity code. It has to be converted into bytecode, which is understood by the EVM. So this is why the input here, the e is in EVM format.
00:10:52.122 - 00:10:52.334, Speaker B: Right.
00:10:52.372 - 00:11:11.340, Speaker A: So this is all about our low level understanding of our code. I hope you got what we are doing and how the solidity smart contract actually works under the hood. And I hope now if you watch this, you will be also able to learn more about optimization of gas and other stuff as well.
