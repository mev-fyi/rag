00:00:01.850 - 00:00:34.454, Speaker A: What is solidity? Solidity is an object oriented language that is used for writing a smart contract. You can also use wiper as well for writing smart contracts on EVM machines, on EVM compatible chains. All these languages like object owned languages, solidity is such just like C or Java. And solidity can be compiled down to bytecodes with solve compiler that is present. Enter the EVM itself and then this bytecode gets onto the EVM and basically on the Ethereum. And yeah, it runs. Right.
00:00:34.454 - 00:01:01.358, Speaker A: So this is a simple definition of what solidity is. Now let's move on to bytecode. So as we suggested, that Ethereum smart contract is a bytecode that is actually deployed on the Ethereum blockchain. It's not your code doesn't goes into the Ethereum blockchain, it's your bytecode that goes into it. The even bytecode is written in hexadecimal format. So if you see that zero x sign, which means that it is saying that your number is in hexadecimal format. Now let's move forward.
00:01:01.358 - 00:01:41.686, Speaker A: And also one more thing is when we compile your solidity smart contract, it will translate your code into bytecode. That bytecode is only understandable by the EVM. Bytecode is not designed to be executed by the processor directly, but actually by another program. Right. So it can be directly executed on the virtual machine itself, or the bytecode can be either directly executed on the virtual machine such as an interpreter, or it may be further compiled on into my machine code for the better performance. You can see in the example as well. It gets compiled into ABI and bytecode.
00:01:41.686 - 00:02:11.362, Speaker A: We will talk about what ABI is. But yeah, you can see that here's the bytecode on the right hand side, and this is the assembly view of it, because you can actually break down your opcodes into breakdown bytecode into bunch of opcodes. Okay, yeah, so let's talk about actually what opcode is. Before that, let's talk about ABI. So ABI is an application binary interface. So when your solidity code gets compiled down, it gives two things. One is the JSON API and one is the bytecode.
00:02:11.362 - 00:02:34.750, Speaker A: So what is the ABI? ABI is application binary interface, as it, it usually interface. Right, so it's an interface to interact with the smart contract. Right. So it's in a JSON object. Basically JSON is JavaScript object notation format object. It describes the contract functions, the variables, modifiers, and the contract parameters that are in a JSON format. All these things are available.
00:02:34.750 - 00:03:11.914, Speaker A: So when you compile down your solidity code, you will able to see your ABI file as there as well, right, whatever you're using Ribix or vs code, whatever, hardat. So ABI allows anyone writing a smart contracts to be able to communicate between the web application that are written in high level languages like JavaScript, typescript and actually the bytecode of the EVM that understood. Right. So it basically is acting as an interface to connect your DAP and how it can contract, basically connect with the bytecode how it can communicate. Right. So it's acting between the, acting as an interface. Right.
00:03:11.914 - 00:03:42.206, Speaker A: So yeah, this is all about ABI. Now let's talk about opcode. So opcode is a short form of operation code. As its name suggests, the opcode is a type of code that tells the machine what to do. All Ethereum bytecode can be broken down into the series of operands and optimums, as we discussed. So opcode is a different whole topic, which can have its own crash course because there are several types of categories in opcodes as well. Stack management, automatic operations, environmental opcodes, memory management, operation course, et cetera.
00:03:42.206 - 00:04:41.794, Speaker A: There are a lot of them and it can be a different crash course. If you want me to write a crash course, just let me know. Here you can see that every opcode has its name and there is a minimum guesser. For example, let's actually see the bytecode example, right? So suppose this is a bytecode, right? And this is bytecode. We will break down our bytecode into small, small opcode. So here you can see the zero X one stands for ad, right? So you go to the Ethereum website, you see this list, and there will be a list of ethereum virtual machines, what Ethereum bytecode and what the opcode is for that particular opcode, right? So you can see that for example, zero one is for add. It means that this opcode means adding, and there is a minimum gas for it, that is three, right? So similarly, what here zero x one is doing is basically an opcode for adding two numbers in the EVM bytecode.
00:04:41.794 - 00:05:11.486, Speaker A: So what it does, it will remove two elements from the stack. As we said, the stack is last and first out. So it will remove two elements from the stack and then it will push the result, as I said, that on the stack your result is always on the top. Right? So this is the case and it is very important to understand the EVM bytecode. That is for minimizing gas consumption. Right? So this is all about opcode. So here you can see the other opcodes as well, like push one, right.
00:05:11.486 - 00:06:14.530, Speaker A: So here what it is saying is that push one bytecode of data into the stack, right? It says that so you can convert your bytecode into these different, different opcodes, right? So it is very important to understand how the opcode runs and what is the icode for minimizing the gas consumption, in turn reducing the cost for your end users. Right. It's very important to know that the goal is not, I mean it is the goal to optimize your contract. So when you deploy it, it reduces the number of gas and the amount that is required to deploy it. But also the main focus is for your end users, when it interacts with your smart contract, the gas fees, which he or she has to pay would be less. Right? So that's the main goal because you don't want your end users to pay a lot of gas fees, because you want more and more users to use and track with your solidity smart contract. And if the gas fees is very high, the contract is not optimized.
00:06:14.530 - 00:06:42.398, Speaker A: Eventually the users will have to pay a lot of gas fees and they don't want to do it. Right. So it's very important to write the optimized source code, basically solidity code, so that it reduces the cost for the end users. Okay, so this is the relation between the bytecode and the opcode. One more thing is that the assembly language also, it is important. So it is also possible to write the whole smart contract using opcodes. Yes, that's where the solidity, assembly language comes in.
00:06:42.398 - 00:07:12.326, Speaker A: It might be a lot harder to understand it, but it could be useful. It can do stuff which solidity can't do and it can also save you a lot of gas. So you can see that the U language, it is basically written in this format. And then assembly block is marked with curly braces. And this language is also called Yule. You can visit the solidity documentation if you want to learn about it. Here is the format of writing it.
00:07:12.326 - 00:07:36.400, Speaker A: You just write assembly and then there are curly braces. You write the smart contract there as well. Okay, awesome. I guess that's it for all these small, small topics. Now actually let's go to one of the main example. We will actually go onto the remix and we will write of our own code. We will deploy it out, we will check the bytecode, how it turns into the different stuff.
