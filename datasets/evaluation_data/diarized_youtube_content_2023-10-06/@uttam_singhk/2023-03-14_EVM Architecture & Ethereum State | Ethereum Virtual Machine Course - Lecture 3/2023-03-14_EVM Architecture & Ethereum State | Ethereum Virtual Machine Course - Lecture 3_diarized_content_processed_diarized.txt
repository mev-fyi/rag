00:00:00.250 - 00:00:49.414, Speaker A: Okay, so let's talk about EVM architecture. Like what is the architecture of the Ethereum virtual machine? How does it look like? So you can see it in the screen as well. Like the architecture of Ethereum virtual machine, it contains of this program counter gas available stack memory virtual machine, and there is account storage as well. Then first of all, I would like to tell you that EVM is a simple stack based architecture machine. So let's actually talk about what is stack based structure machine before we talk about the architecture. So there are two types of virtual machine. One is the register based virtual machines, which uses a set of registers to store variables and for calculating any of the results which are mostly present in the intel architecture.
00:00:49.414 - 00:01:22.706, Speaker A: If I'm not wrong, you can google it. I'm not sure about it, but yeah, these are like register based virtual machines. And then we have a stack based machine machine. So stack is basically stack based machine. Machines uses stack for the purposes, for purposes of storing variables or calculating the results, right? So stack is an database architecture. I hope you it is Lifo that is last in, first out. Whatever goes last comes first out, right? So it uses stack for the purpose of storing the variables and calculating the results.
00:01:22.706 - 00:02:01.726, Speaker A: And there are other well known stack based machines like JVM. JVM uses stack based machine only. And in the stack based machine, the data is always available. Like this is one of the advantages of stack based machine, that the data is always available at the top of the state machine, right? So you can see in the diagram as well. Like you insert and you push the numbers like 27. And then what you want, do you want the result of 20 plus seven? Right? So always, all the time. The result will always be available at the top of the stack by default, right? And you can see the SP pointer.
00:02:01.726 - 00:02:45.666, Speaker A: SP is the stack pointer, which refers always to the head of the state, right? So basically this is what stack is. And this is how the stack based machine work. And EVM is a stack based machine, right? So that's, we know about it, that EVM right now is a simple stack based architecture. Virtual machine. Now let's talk about different components of the Ethereum architecture. The theorem virtual machines, right? So it has program counter. Now what is program counter? So EVM initializes a program counter that is actually pointing to the opcode that is to be executed, right.
00:02:45.666 - 00:03:35.614, Speaker A: We have discussed what opcode is. We will discuss in our future slides as well. And opcode is basically just a code or basically that tells what to do to the EVM, right? It tells basically it's just like a small code as well. Or you can say it's like a command, right? That tells us what to be executed, right? So Ethereum initializes a program counter that is pointing to the opcode. So program counter encodes which instruction to be stored in the code and which should be the next to be executed by the EVM next. And every time it executes, there is an increment as the contract runs. So as the contract run, there is an increment in the program counter.
00:03:35.614 - 00:04:05.738, Speaker A: So basically the job of program counter is to encode the opcode, and it tells which opcode should be executed next to the EVM. And it increments every time the contract runs. Right? So it tells the EVM which opcode to be run next. Right. Then we have gas available. Gas available is nothing but how much amount of gas you provide for that particular transaction. What is the gaffability of that gas? Right.
00:04:05.738 - 00:04:57.734, Speaker A: After that we have a stack. So we have talked about stack last and first out. So this is basically also a temporary memory you can set as a tito byte element used to store smart contract instructions, inputs and outputs, whatever you provide, right? And there is also one stack created per call context. It is very important that every call context, there is only one stack that is created, and it is destroyed as the call context ends. Right? So this is like a temporary, you can say that every time you create a smart contract, there will be a stack, not. Basically every time there is an instance of a virtual machine, there will be a stack per call context, and it is destroyed once the call context ends. Okay, then we have EVM memory.
00:04:57.734 - 00:05:38.518, Speaker A: So EVM memory is also not persistent, right? It is, and it is destroyed at the end of the call context. As the call context ends, the instance of the EVM ends, the memory also ends. Right. Then we have storage. Storage is actually the persistent memory of the smart contracts. And each contract has its own storage. Right? So we will discuss in our future slides as well how the EVM grabs the storage and the state address of that particular contract, the code of that address, and then how it changes the storage of that particular contract as well.
00:05:38.518 - 00:06:24.594, Speaker A: So storage is the persistent memory of the smart contract. And again, each contract has its own storage, which is persistent. And that is like a world state, as you can say on the time we already discussed what world state is, that is the current state of the ethereum, right? And then we have the code, the virtual roam. That is the EVM code. So that code is the region where the instructions are stored. So this is the reason where the instructions are stored, the instruction data is stored in the code that it is also persistence as a part of contract account state field. And this is actually loaded with bytecode of the smart contracts that is to be executed, as I said on the blockchain.
00:06:24.594 - 00:06:56.670, Speaker A: Also in the EVM that nothing is present as your solidity code. Everything is a bytecode and that bytecode is understand by the virtual machine that is by the EVM. Right? So this is also like it is loaded with the byte code of the smart contracts that is to be executed. Okay, so yeah, this is all about the EVM architecture. Like what are each and every component. So we've discussed each and every component of this Ethereum architecture. We will discuss the machine space of EVM again in the future slides.
00:06:56.670 - 00:08:17.690, Speaker A: What is the spaces where Ethereum can, or basically EVM can store and read the value from? And yeah, so this is the small architecture of Ethereum. And we will talk about more when we will be discussing the working of the EVM. But I guess hope you're clear of what each and every component of the Ethereum or basically EVM does. Right, so now let's move on to the Ethereum virtual machines where it is actually stored. I want to give you a broader way of how where is the EVM actually stored and at the point of Ethereum, right, so we have this Ethereum code, then we have the theorem virtual machine, then we have the runtime processes like this Ethereum node. Basically the client services like get parity and other mines where we talk Arigon or any other software that is used for running the Ethereum nodes, the client services, then we have the hardware of that physical processors or wherever your node is running on whatever machine it is running. So EVM functions basically, as you can say, as a virtual cpu or as a virtual machine that is running inside of the Ethereum node or the Geth program or any other client service.
00:08:17.690 - 00:08:58.470, Speaker A: So Ethereum virtual machine is basically a virtual machine or a virtual cpu that is running inside of the geth. You can go and actually look at what is geth and what is the code of it. You can definitely look. It is basically a runtime process. Machines and everything happens. It updates this state of how the node actually contact each other, how the state actually changes and gets updated every time. And then every machine that is running that client service, that is the geth, they have their own physical processors, they have their own virtual basically os as well, right? So that is the hardware of that particular machine that we are talking about.
00:08:58.470 - 00:09:36.500, Speaker A: So solidity code again, it's compiled to bytecode and the distribution, and then actually it is distributed to every computer node running the gath in the network. Right. So your solidity bytecode compiles into the bytecode solidity codes, and then it is distributed to every computer node running the geth network. So this is how it works. We will talk about it more in the working. So just I want to give you a whole broader overview of where the EVM fits in it, right?
