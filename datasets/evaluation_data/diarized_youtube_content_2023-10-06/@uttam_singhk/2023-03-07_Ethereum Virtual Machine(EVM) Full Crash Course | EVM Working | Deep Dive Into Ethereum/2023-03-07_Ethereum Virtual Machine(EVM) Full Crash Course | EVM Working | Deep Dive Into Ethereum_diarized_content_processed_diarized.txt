00:00:00.410 - 00:00:44.086, Speaker A: Hey, hey everyone. I am Uttam Singh and this is a video and basically a crash course on EVM. That is Ethereum virtual machine, right? So in this course, I will tell you everything about EVM, Ethereum virtual machine, what it is, how it works and everything. And trust me, after you watch this video, you will not have to read any other article or you don't have to watch any other video of how EVM works. I will also go deep inside how bytecode is get compiled and how is EVM running and how your code gets into the EVM and how it runs. It executes, what happens. Right? I will discuss each and everything about the EVM.
00:00:44.086 - 00:01:22.354, Speaker A: So let's not waste more of our time and let's get started and see about what is the agenda of this course. But before getting started, if you are an expert, do leave your feedback in the comment section. You can watch the video if you're an expert, if I left anything or if there is something that I can improve. So do leave your feedback in the comment section and do subscribe to the channel right now. Because this is just one crash course, I'm going to upload other many crash course as well. And my goal is to educate people about blockchain. So please, please subscribe to the channel right now like this video, comment it and also follow me on Twitter and LinkedIn.
00:01:22.354 - 00:01:55.590, Speaker A: And if you have any doubt, please reach out to me. So let's get started with our video. So let's talk about the agenda for this crash course on EVM. And I have tried key, I will cover every topic, right? So first of all, we will talk about the history of EVM, right? It's very important for us to understand what was the history of EVM, who designed it, what was the topic behind it, what was the motive behind it. Right? It's very important for us to know. So we will discuss history of EVM and then we will also discuss virtual machines. Okay, so what are virtual machines? Ethereum is a virtual machine.
00:01:55.590 - 00:02:40.766, Speaker A: So it's very important for us to understand what is a virtual machine, how it works and other things as well. After that, we will be discussing what is EVM, what actually is Ethereum virtual machine. And then we will also discuss Ethereum state, right? Because the job of EVM is actually to update the Ethereum state, right? That's the simple job of EVM, right? And we will be discussing how Ethereum state works, how it gets update every time the EVM runs, and what happens behind the code. Right? And then we will also go into the EVM architecture. What is the architecture of EVM? How it works, what components it have and all other stuff as well. And then we will be talking about machine space of EVM. Right.
00:02:40.766 - 00:03:03.826, Speaker A: So this is a new topic. The EVM can access and store information in multiple places. That is around five to six places. So we are going to discuss that as well. And then we will also discuss EVM opcodes. Like what are operation codes, what are bytecodes, AbI and solidity. Like I'm not going to go deep inside each and every topic.
00:03:03.826 - 00:03:32.474, Speaker A: Opcode, bytecode API and solidity. But it's very important for us, if we are learning about EVM, then it's very important for us to learn how opcode works, how bytecode works, what is Abi and what is solidity? Just an overview is very important. Right. So again, machine cannot understand solidity code, right. So that's why we need all these things. Opcode, bytecode, Abi. Right, because machine can't directly understand solidity because it's a high level language.
00:03:32.474 - 00:04:00.314, Speaker A: Right. So we will talk about this as well. And we will also going to take a few example, right. We will take a real life example. We will go through remix, we will write a solidity code and we will compile it and we will compare the bytecode and convert a bytecode into opcodes, right, which is a good example. And you will really understand how your code works at a lower level and how it's get turned into opcode which is executed on the eVM. Right.
00:04:00.314 - 00:04:39.858, Speaker A: After that we are going to discuss EVM working. So why I'm not discussing EVM working in the above slides before all these things? Because I want to set up a stage for you guys to understand what is happening behind the scenes and what are these small, small things. Machine spaces, opcode. And once your brain is clear about what is happening, we can discuss about how EVM is working when we have connected the dots. So at the end, when we connect all the dots, we will see EVM working. I will also take an example there as well. And after that the last topic will be Turing completeness.
00:04:39.858 - 00:05:11.790, Speaker A: And the guess like what is Turing completeness? EVM is a Turing complete machine. Is it or is it not? Is a quasi Turing complete machine? And we will also discuss gas as well. What is gas and why it is required? What is the need for it? Right, so this is going to be a small crash course on EVM. Hope so. I have covered everything. If I left anything, just write down in the comment section if you are still watching this video, I guess you are interested pretty much in the course. So please like the video and hit the subscribe button as well.
00:05:11.790 - 00:06:08.546, Speaker A: So let's get started with our first topic. That is the history of EVM, right? So everyone knows who Vitalik is, right? Vitalik Butrin is the founder of Ethereum. He founded Ethereum at the age of 19, around 2013, if I'm not wrong. Then again, at that time only the EVM was also designed as well, right? Because EVM is the heart of Ethereum, right? Ethereum is nothing without of EVM, right? As a human body, we don't have anything without our heart, right? We are nothing without our heart, right? Similarly, Ethereum is nothing without EVM. The EVM is the heart of the Ethereum. So in similar year in 2013, only the EVM was designed with Vitalik and with Gavin Wood. So most of you know who Vitalik is, the founder of Ethereum, but people outside the industry, people don't know who Gavin Wood is.
00:06:08.546 - 00:07:29.222, Speaker A: So Gavin Wood is actually also one of the founder of Ethereum, right? And he was the one who designed the EVM machine in his tenure, right? He's also the inventor of solidity language. He was the one who created the solidity language and now he is the creator of Polkadot and Cosmos ecosystem, right? So I just wanted to discuss who Gavin Wood is, because most of us people know Vitalik but don't know Gavin Wood. So he was also one of the founder of Ethereum and he was the one who designed EVM along with Vitalik, and also created the solidity language, right? And you must be thinking why I have this BitTorrent logo in the slide. So according to Vitalik, what he says is that BitTorrent was actually one of the first DAP that was created. BitTorrent was created by Braham Cohen, and it is a file sharing protocol that was invented in around 2001. And despite several efforts to destroy it, like BitTorrent, you must have been using it to download movies and other stuff as well. And despite several efforts from government and other organization to destroy it, BitTorrent remains very much alive.
00:07:29.222 - 00:09:12.074, Speaker A: Why? Because to truly halt or to truly remove the BitTorrent from the Internet, every computer in every home across the world would have to shut down, because it's something that is decentralized also, and it's in every computer, right? So if you want to truly end or truly destroy the BitTorrent, then it has to be removed from each and every computer from around the world, which is a very hard task, right? So similarly, it's like a virtual machine as well. You can say it's more like Ethereum. And that's why Vitalik said that BitTorrent was actually one of the first DAP that was created. It's like virtual machines unbounded by any physical constraints, right? So yeah, this is all about, I guess, the history of EVM. Just a small history I wanted to discuss. So let's move on to our next topic, as I discussed about virtual machines, right? So what is virtual machine? Why it is important, why we have created this Ethereum virtual machine, right? So virtual machines, as you can see in the diagram as well, virtual machine is nothing, but it's a program that simulates the operation of a computer by isolating its real components and operating system, right? So basically it's an independent machine that is working on top of your computer. So for example, you have a computer, you have an operating system with os like Windows or any other os, right? You have a Mac or any other os.
00:09:12.074 - 00:10:53.918, Speaker A: And what will be happened? That virtual machine will run as an independent separate machine on top of your computer with different os, right? So you can do that as well. This is like one short example of virtual machines, right? So this one physical computer can actually run several virtual computers. So your computer can actually run more and more and more virtual machine, maybe two or three depends upon your capabilities of your computer, what are its programs and memory and all that stuff. So your computer can actually run separate virtual computers, to be precisely, we can call it as separate virtual machines, right? So this is like a simple definition of virtual machines. So now virtual machines can actually differ in their capabilities, right? Every virtual machine will have their own different tasks and they will have own capabilities. So for example, virtual machines such as Virtualbox, right? Virtualbox is a type of app that can help you create a virtual machine on top of your hardware and allow you to run any operating system on top of it, right? So you can download virtualbox on your computer and then you can create a virtual machine, basically that will create a different os in your computer which you can run. And maybe if you have Windows you can download the virtualbox and then you can create a Linux OS on your computer as a virtual machine, right? You can do that, right? And other than that, there are several other virtual machines as well, like Java virtual machines, which helps to, that is basically a Java runtime environment, right? It can run the Java code and stuff.
00:10:53.918 - 00:12:05.074, Speaker A: We'll not go into the specifics of each and every technology because each of them have its own set of approaches that is worthy of different video, because every virtual machine is different and they have different motive of that virtual machine. However, these virtual machines have some common features and some criteria for their evolution, regardless of what task they are designed to handle. So every virtual machines have some common features which we can discuss in our next slide. So, as I said, that virtual machines run in isolation from the other computer components and using only the computational resources. This is different actually from writing and executing native programs that directly work from the computer components, right? So for example, basically you have a windows, you have an os. Suppose Windows, you have Windows OS and you are running any DAP and running any of the applications. So that application will actually run on your own computer, right? And that will use your Windows computational resources and that will run on it.
00:12:05.074 - 00:12:46.750, Speaker A: But it's not the case for virtual environment. For virtual machine. Like in virtual machine, it will have its own computational resources. And if you're running an application on top on the virtual machine, it will use the computational resources of that virtual machine and not of your computer rights. So this is what EVM it runs like, and you can see it in the diagram as well. One more interesting thing to know is basically, if you are a developer, then what you will do is you will write your program in a source code and you will compile it into machine code. And that machine code is actually executable by the processor with a specific architecture.
00:12:46.750 - 00:13:40.734, Speaker A: So for example, you are a developer, you build a code that is actually running, that is actually a high level language. So what will happen is that your high level level code will be compiled and into a machine code. And that machine code will be not platform independent. It will be like platform dependent. That that machine code, it can only be understand by a particular machine or by a particular component, right? And in the case of virtual machine, it's different. In case of virtual machine source code, you can see it in the slide as well. The source code is actually compiled to the bytecodes, right? And this bytecode is then compiled to the machine code, right? So bytecode is actually acting as a platform independent thing, right? Because it can actually be executed on any platform using the virtual machine.
00:13:40.734 - 00:14:18.954, Speaker A: So for example, you are writing a source code and then this source code that's in a high level language. In our case in EM, it will be in solidity. Right? Now it's in Java. So you compile this code and this will generate a bytecode. Actually, this byte code can be compiled or maybe converted to machine code that is understood by each and every OS, right? So for example, there is a windows OS, there is a Linux OS, right? There is a different os. And not every machine can understood a single machine code. Every machine has its own architecture, every machine has its own specification.
00:14:18.954 - 00:15:21.042, Speaker A: So you have to provide them different machine codes. Depends on their what machine codes they'll understand, right? So it's a very big problem. That's why we have this bytecode. This bytecode is actually acting as a middleman, right? So in the virtual machine this is acting as a middleman. You just compiled your code in bytecode and this bytecode gets convert into the machine code of whatever machine you are using and it will be easier understood, right? So that's why we need this bytecode, because it's very important, right? And also thanks to bytecode, because due to bytecode only we can create this, an isolated universal environment, you can say for executing any of the program and without even worrying about its compatibility with the process architecture or whatever the other computer components is. You don't have to worry about whether the OS is windows, whether the OS is Linux, or whether the OS is Mac. You just have to write your code.
00:15:21.042 - 00:16:13.314, Speaker A: And if you're using a virtual machine, it will create an isolated, basically simple environment, universal environment, and where you can convert the code in bytecode and then this bytecode get converted into machine code. So you don't have to worry about the architecture of different os, you don't have to worry about it. So this actually makes the life of developers, life of developers very easy, right? So this is all about virtual machines. And I hope you understand what are virtual machines now and you can see it in the diagrams as well. And we will understand what bytecode is, especially in the context of solidity and EVm. So yeah, this is all about evirchural machines. And if you are still watching, I guess please go and write down in the comment section if you are still liking this video and give it a thumbs up as well.
00:16:13.314 - 00:17:13.990, Speaker A: Right now let's actually move on to our next topic. That is EVM, the Ethereum virtual machine. What it is, it is a type of virtual machine, but what actually is EVM? Okay, so yeah, Ethereum virtual machine. So what is ethereum virtual machine? In simple, very simple terms, ethereum virtual machine is nothing but a runtime environment for smart contracts in ethereum, right? So similarly, we discussed Java virtual machines before that. Java virtual machine actually allows any Java program to run on any machine, right? This was what the Java virtual machines, what we discussed in our slide. So similarly with our JVm we also have EVM. And what this EVM does is basically this EVM allows you to run EVM bytecode on any of the machine, right? So this is what the simple job of EVM is.
00:17:13.990 - 00:18:42.862, Speaker A: And this EVM is isolated from other parts of the system. This means that operation on the EVM should not affect your data or your programs in any of the way. No matter how many times you call a particular function or any function you're calling it multiple times, it should not affect it, right? So basically EVM is isolated from other parts of the system, no matter what, as we discussed, like virtual machine has nothing to do with the, it is basically an isolated independent machine, right? So it is basically an isolated environment, right? So this will not affect the data or any of the program that is running on the virtual machines, no matter how many times you call it, how many things you do with it, right? So you can also say that EVM is basically a computer or a machine that helps us to store the data on the blockchain. On the blockchain, right? So yeah, this is all about Ethereum virtual machine. And I guess this is like a small definition. Let's discuss more deep inside it and let's understand broader level. At a high level, how does it run as a developer as well? So basically what happens is that developer writes a code, right? And developer basically, if you're a developer, you write a code in solidity.
00:18:42.862 - 00:19:32.574, Speaker A: For a smart contract you are running that, and then EVM will actually compile that human readable solidity code or the wiper code as well. Viper is also one of the language, right? So the compiler will compile the human readable solidity, which will be written by developer, right? And into basically machine code or basically opcode. So by bytecode and opcode, there is a difference in that. We will discuss it in our future slides as well. But yeah, you can right now say that it compiles it into bytecode, and that bytecode is basically collection of opcodes. And basically that is a collection of opcodes. And that opcode will actually go on to the EVM.
00:19:32.574 - 00:21:12.046, Speaker A: That will change state the state of the theorem. We will discuss what Ethereum state is, but on a high level, you can understand this in a very simple language that you compile the smart contract, the smile contract into bytecode, and then that bytecode actually goes into the EVM. Your code is not going onto the EVM, only your bytecode is going onto the EVM, and that is only that gets executed and that's converted or basically it's already a collection of opcode and then that opcodes tells the virtual machines what to do. Like what will happen. It will tell the EVM what to do, what not to do, right? It will tell it, right? So you can say, in other words, the resulting bytecodes of these program does not have to vary depending on the specific machines, right? So basically, as we discussed, like the virtual machines don't have to worry about the underlying cpu architecture, right? So you know that there are different nodes of the Ethereum virtual machines, right? So basically the goal, and first of all, the goal of this presentation is not to explain how depths work. We are going to understand how Ethereum EVM virtual machine works, right? So this is just a broad level overview, right? So as I said, that you compiled those smart contracts and those smile contracts goes into the EVM, it gets converted into bytecode and that stuff, and then the opcode gets executed on EVM, which tells what to do and what not to do. And then this changes the state of the Ethereum nodes.
00:21:12.046 - 00:22:00.386, Speaker A: And all the ethereum nodes will have to agree with the Ethereum state. And then that's how the state gets upgraded every time you write a code or every time something is executed on the EVM, right? So simple. This is like notes, is just like distributed ledger that everyone has to agree once there is a change in the Ethereum state, right? And you can say basically EVM is also, people say it is a turing complete machine, but it is not actually turing complete. There is a little bit of thing in it. We will discuss it in our future slides. So it can actually run, which means that it can run any program as long as there is enough gas to process it. So writing on the blockchain as I guess is not free, I hope you are aware of it.
00:22:00.386 - 00:22:46.914, Speaker A: You need to provide some gas to deploy anything on the blockchain, right? So as long as there is enough gas, the process will run. Right. And again, the goal here is not to understand how Dapps work, what is the architecture of it. I am just focusing on this Ethereum virtual machine and how this works. But this is the overview of where EVM fits in our DAP ecosystem or in our Ethereum ecosystem. Like what is the job of EVM in this DAP working? Right. We often, as a solidity developer as well, we often ignore what is happening under the hood of the solidity and how the code gets worked.
00:22:46.914 - 00:24:00.270, Speaker A: So this video is all about explaining once you create your smart contract, what will happen, what will it happen on the EVM and once it is get compiled and how opcode run and what will happen if there are called to another contract and how the Ethereum nodes get updated due to the Ethereum virtual machine as well. And again, let me tell you that you also will be having a question regarding where is EVM and where does it fit? Right? So we will talk about Geth or any other client service that are in right now in the Ethereum nodes which help you to run the Ethereum node. Geth is basically a go implementation of the Ethereum protocol. And there are several other implementation of client services of theorem like Arigon, or there is also Python implementation. I guess Nethermind also had one, right? So we will discuss all those implementation. And actually when you download those things, like basically when you download those client services, like for example, you download Geth that you want to hey, I want to run Ethereum node. And with the Geth it comes EVM.
00:24:00.270 - 00:24:56.362, Speaker A: It comes along with the EVM, right? So we will discuss where it fits the EVM as well, what happens when you downloads it and what will happen. But yeah, this is all about what is EVM and where it actually fits, right? So let's move on to our next topic, which is very important. That is about the two types of the accounts that exist in the evms, or basically in the EVM compatible machines, or basically in the Ethereum, right? So there are two types of Ethereum accounts, as you can see in the presentation as well. One is the externally owned account and the other one is the contract account. So what is the difference between these two accounts? Right? So let's discuss that. So each of these accounts, as you can see, it contains a few of the things. One is the address, that is the address of every account that's already there.
00:24:56.362 - 00:25:51.866, Speaker A: And the other thing is they have nons, that is number only used once. And then they have balance, then they have storage hash, and then they have code hash as well. Right? The code as well. And there is a difference between these two accounts. What is the difference is that the externally owned account, right? In that they have address, they have nons, they have balance, but the storage and the code hash is empty, which means that there is no code, there is no storage in these types of accounts. These types of accounts are basically, they are controlled by an external actor, right? So if you go to metamask, you create an account, then you are creating an externally owned account. And that account, that will be what to say that will be handled or that will be taken care by you with your private keys.
00:25:51.866 - 00:26:50.202, Speaker A: That will be controlled by your private keys, right? So that is the externally owned account that you create on using metamask and any other wallet, and it does not contain any storage hash or any code hash. While if we talk about contract account. So again, the contract account, we have this address, we also have the nons, we also have the balance. But there are two extra things. That is the storage hand code hash, which are not empty in the contract account. So basically you write your smart contract, right? So that is basically a contract account when it's get deployed, right? So this code is like your code. That is, code hash is stored in the account, in the contract account, and then also it has storage, right? So if you have your code, it will also have some of the storage which downloads the data or basically stores the data in that particular contract.
00:26:50.202 - 00:27:32.942, Speaker A: So it also have a storage as well. And unlike externally owned account, in the contract account, the action is actually controlled by the code, right. You can say that contract is controlled by the EVM code. So whatever you tell the contract account, once you deploy your code, then their contract will be controlled by what the code says, right? So everyone says the code is the law here. Code is the law in the ethereum or in the blockchain. That's why we say it. Because the contract accounts are controlled by the EVM code, right? They're not controlled by any external private key.
00:27:32.942 - 00:28:01.686, Speaker A: Yes, the owner will be holding the private key from where he deployed. Right? But the contract account is actually controlled by the EVM code. And this contract account contains the EVM code. While in externally owned account, there is a private key that is controlling that account. And by the way, externally owned account cannot contain the code. Right. There is no code in this externally owned account.
00:28:01.686 - 00:29:11.326, Speaker A: Like while in the contract account, it stores the bytecode and the root hash of the merkel of the state tree. We will talk about the try as well merkel try root as well in the future slides. And these are basically the accounts that they just not hold your ether or your token balance, but they are also capable of storing your smart contract code within themselves and that are not controlled by private key, as I said. Right? But they are controlled by the logic of the code. So you write a code, you write logic in the form of code and then that logic controls the contract account, right? And any transaction between externally owned account can only be limited to either token transfer or either NFT transfer, any kind of transfer, right? So this is the limitations of externally old accounts. And this is only till ether or tokens aren't for any kind of transfer. Only while in the contract account, this is not the case.
00:29:11.326 - 00:30:36.194, Speaker A: And every time you're doing any of the externally owned account, right, the owner will have to sign the transaction to initiate any of the activity in their account. So basically, if you're doing any of the transaction from your metamask as well, your address as well, you will have to sign the transaction every time you do it, right? Since it is controlled by the externally actor, that is the private key of yours. Right? So this is what about two types of accounts that exist in the Ethereum ecosystem, and this mostly exists in all other EVM compatible chains. So this is going to be same, right? So let's move on to our next slide and our next topic, which is Ethereum state, which is also one of the very most important topic, and it's very important to understand what Ethereum state is if we want to understand the working of the EVM and Ethereum. Right? So let's get to move on to our next slide. So what is Ethereum state? So first of all, let's talk about what is a state. So state is basically, you can say it as what is the particular state? Like, what is your state at this particular point of time, whether you are a student, whether you are a working professional, what it is, right? So this is this state, right? And now what is state machine? State machine.
00:30:36.194 - 00:31:53.714, Speaker A: In simple terms, you can say it as basically a device that specializes in storing the state, as well as defining the rules of a state for changing a particular system. For example, if something happens, then this state machine will have some kind of rules that how will the state change and how there will be a new state, right? So to clear a confusion, Ethereum is transaction driven state machines. Or you can say Egypt. Ethereum is a transaction driven state machine, which means that whenever there is a transaction, there is change in the state. And this is what state machine does. So basically you can also call it EVM as a transaction driven state machine, and it changes the state of the Ethereum every time there is a transaction. So in a nutshell, every successful transaction, irrespective of whether it is a very big transaction, whether you are transferring thousand ethers, whether you are transferring 0.1
00:31:53.714 - 00:33:16.758, Speaker A: ether, whatever the amount is, it is big or very small, it will lead to a change in the Ethereum state, even in the slightest change in any of the accounts. We talked about two accounts, right? Externally owned account and contract account. So even a little bit of change in the Ethereum or any transaction in externally owned account or contract account, it will lead to a change and it will lead to a new state as well, right? This means that every single transaction that is mined, whether if you are transferring your NFT, whether you are sending a Transaction or whether that is a governance proposal, anything that is executed, it will lead to a change in the overall state. So you have a state, this transaction happens and there will be a new state, right? So this is what actual job of Ethereum is. Of EVM is the job of the EVM is actually to update the Ethereum state by computing a valid transaction as a result of smart contract execution or external accounts or externally owned account. If there is a transaction, the job of EVM is to update the Ethereum state. It is defined by the protocol.
00:33:16.758 - 00:34:01.562, Speaker A: So as you can see in the example as well, right? So there is world state. Like for example, consider you are drawing any transaction, right? So before that, this is the state of Ethereum, right? So let's take a real life example, right? So basically, for example, you are using a DAP, right? You're trying to use a DAP. So basically this world state, that is t, that is the world state before your transaction, right? This is the store. Like there is an address of that smart contract, there is a code and there is a storage as well. Right? Now you go to that DAP, you says, then basically you want to create your own account. Or basically you want to do anything with that smart contract. You want to execute it.
00:34:01.562 - 00:35:23.022, Speaker A: Now what will happen is that what you will do is basically you will send a transaction or a message call along with any of the input data that you want to transfer that hey, my name is this, please store this information into the smart contract and the storage of it in the blockchain basically, right? And you send your transaction with the input data and then what will happen is that the EVM will actually execute it. How will this change state? Like when you do a transaction, right? You give some input data. Then how would the state of the Ethereum will change? How will it know that there is an updation? So every time you send a transaction, it goes to the EVM and then EVM runs and then it updates the state. And there is basically a new state, right? So you know that there is a storage before this, you send it a transaction, it goes to the EVM, and then EVM updates the state of the Ethereum and there will be a new state. After your transaction is successfully mined, there will be a new state and this new state will be broadcasted to every other nodes of the blockchain. They will also have to update it. So EVM code is again executed on the Ethereum virtual machine.
00:35:23.022 - 00:35:51.834, Speaker A: Whatever happening will be happening in the Ethereum virtual machine. Your code. It will call another smart contract. What smart contract are you interacting with? It will call it in the EVM and then all the changes will happen in Ethereum and then it will change the world state. We will talk about deep in the working of EVM. How is that happening? How is actually the state of the Ethereum is changing how it calls other contract as well. Right? So you are doing a simple call.
00:35:51.834 - 00:36:37.418, Speaker A: Basically, if you're going to on a uniswap, you don't know what is happening. You are just calling the smart contract. But how will EVM execute it? We will talk about in our future lectures. But this is all about Ethereum state and how Ethereum state is very important. And basically you can understand the world state of Ethereum. Basically it represents the current state of the entire blockchain, which comprises of all the historical states that actually forms the current state hash. You can say that as well, that right now if you say the world state, so world state is nothing, but it represents the current state of the Ethereum at that particular moment of time.
00:36:37.418 - 00:37:16.338, Speaker A: The world state represents the current state of the entire blockchain. Right? So this is what world stated in a simple matter, in a simple manner. I hope you understand what Ethereum stated and what is world state. And yeah, if you understand it, do write in the comment section below as well. And now I guess let's move on to our next topic. That is EVM architecture. What is the architecture of EVM? What goes inside the EVM? What are the component it contains of what is the use of that particular component? We will go through each and every component of the EVM.
00:37:16.338 - 00:37:50.402, Speaker A: What is this? What is the program counter? What is storage hash? What is stack and everything. We will go into each of them. Right? So let's move on to our next topic. That is the Ethereum architecture. Okay, so let's talk about EVM architecture. Like what is the architecture of the Ethereum virtual machine? How does it look like? So you can see it in the screen as well. Like the architecture of Ethereum virtual machine, it contains of this program counter, gas, available stack memory, virtual machine, and there is account storage as well.
00:37:50.402 - 00:38:27.354, Speaker A: Then first of all, I would like to tell you that EVM is a simple stack based architecture machine. So let's actually talk about what is stack based architecture machine before we talk about the architecture. So there are two types of virtual machines. One is the register based virtual machines, which uses a set of registers to store variables and for calculating any of the results, which are mostly present in the intel architecture. If I'm not wrong, you can google it. I'm not sure about it, but yeah, these are like register based virtual machines. And then we have a stack based machine machine.
00:38:27.354 - 00:39:03.258, Speaker A: So stack is basically stack based virtual machines. Uses stack for the purposes, for purposes of storing variables or calculating the results, right? So stack is an database architecture. I hope you it is Lifo that is last in, first out. Whatever goes last comes first out, right? So it uses stack for the purpose of storing the variables and calculating the results. And there are other well known stack based machines like JVM. JVM uses stack based machine only. And in the stack based machine the data is always available.
00:39:03.258 - 00:39:51.734, Speaker A: Like this is one of the advantages of stack based machine, that the data is always available at the top of the state machine, right? So you can see in the diagram as well. Like you insert and you push the numbers like 27. And then what you want, you want the result of 20 plus seven, right? So always, all the time, the result will always be available at the top of the stack by default, right? And you can see the SP pointer. The SP is the stack pointer which refers always to the head of the state, right? So basically this is what stack is, and this is how the stack based machine work. And EVM is a stack based machine, right. So that's, we know about it. That EVM right now is a simple stack based architecture, virtual machine.
00:39:51.734 - 00:40:39.494, Speaker A: Now let's talk about different components of the Ethereum architecture. The Ethereum virtual machines, right? So it has program counter. Now what is program counter? So EVM initializes a program counter that is actually pointing to the opcode that is to be executed, right. We have discussed what opcode is. We will discuss in our future slides as well. And opcode is basically just a code or basically that tells what to do to the EVM, right? It tells, basically it's just like a small code as well. Or you can say it's like a command, right, that tells us what to be executed, right? So Ethereum initializes a program counter that is pointing to the opcode.
00:40:39.494 - 00:41:22.422, Speaker A: So program counter encodes which instruction to be stored in the code and which should be the next to be executed by the EVM next. And every time it executes, there is an increment as the contract runs. So as the contract run, there is an increment in the program counter. So basically the job of program counter is to encode the opcode, and it tells which opcode should be executed next to the EVM. And it increments every time the contract runs. Right. So it tells the EVM which opcode to be run next.
00:41:22.422 - 00:41:58.062, Speaker A: Right. Then we have gas available. Gas available is nothing but how much amount of gas you provide for that particular transaction. What is the gaffability of that gas? Right. After that we have a stack. So we have talked about stack last and first out. So this is basically also a temporary memory you can set as a tight two byte element used to store smart contract instructions, inputs and outputs, whatever you provide, right? And there is also one stack created per call context.
00:41:58.062 - 00:42:29.478, Speaker A: It is very important that every call context, there is only one stack that is created and it is destroyed as the call context ends. Right? So this is like a temporary. You can say that every time you create a smart contract, there will be a stack. Not. Basically every time there is an instance of a virtual machine, there will be a stack per call context, and it is destroyed once the call context ends. Okay, then we have EVM memory. So EVM memory is also not persistent.
00:42:29.478 - 00:43:07.318, Speaker A: Right? And it is destroyed at the end of the call context. As the call context ends, the instance of the EVM ends, the memory also ends. Right. Then we have storage. Storage is actually the persistent memory of the smart contracts. And each contract has its own storage. Right? So we will discuss in our future slides as well how the EVM grabs the storage and the state address of that particular contract, the code of that address, and then how it changes the storage of that particular contract as well.
00:43:07.318 - 00:43:35.854, Speaker A: So storage is the persistent memory of the smart contract. And again, each contract has its own storage, which is persistent. And that is like a world state, as you can say on the time we already discussed what world state is, that is the current state of the Ethereum. Right? And then we have the code, the virtual roam. That is the EVM code. So that code is the region where the instructions are stored. So this is a region where the instructions are stored.
00:43:35.854 - 00:44:10.918, Speaker A: The instruction data is stored in the code. That it is also persistence as a part of contract account state field. And this is actually loaded with bytecode of the smart contracts that is to be executed as I said, that on the blockchain. Also in the EVM, that nothing is present as your solidity code. Everything is a bytecode. And that bytecode is understand by the virtual machine that is by the EVM. Right? So this is also like, it is loaded with the byte code of the smart contracts that is to be executed.
00:44:10.918 - 00:44:54.086, Speaker A: Okay, so yeah, this is all about the EVM architecture. Like what are each and every component? So we've discussed each and every component of this Ethereum architecture. We will discuss the machine space of EVM again in the future. Slides what is the spaces where Ethereum can, or basically EVM can store and read the value from? This is the small architecture of Ethereum. And we will talk about more when we will be discussing the working of the EVM. But I guess hope you're clear of what each and every component of the Ethereum or basically EVM does. Right, so now let's move on to the Ethereum virtual machines where it is actually stored.
00:44:54.086 - 00:45:57.806, Speaker A: I want to give you a broader way of where is the ERM, actually stored and at the point of Ethereum. Right, so we have this Ethereum code, then we have the Ethereum virtual machine, then we have the runtime processes like this Ethereum node. Basically the client services like get parity and other mines where we talk the Arigon or any other software that is used for running the Ethereum nodes, the client services. Then we have the hardware of that physical processors or wherever your node is running on whatever machine it is running. So EVM functions basically as you can say as a virtual cpu or as a virtual machine that is running inside of the Ethereum node or the Geth program or any other client service. So Ethereum virtual machine is basically a virtual machine or a virtual cpu that is running inside of the geth. You can go and actually look at what is geth and what is the code of it.
00:45:57.806 - 00:46:58.866, Speaker A: You can definitely look at basically a runtime process machines and everything happens. It updates this state of how the node actually contact each other, how the state actually changes and gets updated every time. And then every machine that is running that client service, that is the geth, they have their own physical processors, they have their own virtual basically os as well, right? So that is the hardware of that particular machine that we are talking about. So solidity code again, it's compiled to bytecode and the distribution. And then actually it is distributed to every computer node running the gath in the network, right? So your solidity bytecode compiles into the bytecode solidity codes and then it is distributed to every computer node running the Geth network. So this is how it works. We will talk about it more in the working.
00:46:58.866 - 00:47:45.082, Speaker A: So just I want to give you a whole broader overview of where the EVM fits in it. Right? So let's now discuss the machine space of EVM. So before going into the working of the EVM, we will have to understand like let's run through the vocabulary of the places where the EVM can actually access and store information. Okay, so as we discussed, that EVM is stack based machine, right? So there are no registers out there, right? There are no registers. And the intel computers actually have registers. And EVM is like cpu, right? It's like a CPU. Okay, you can say that.
00:47:45.082 - 00:48:44.110, Speaker A: So let's actually talk about the machine spaces that it places where it can access and store the information. The EVM. So first of all, let's talk about stack. So we have already discussed stack. Stack is like last in, first out data structure. So stack stores value temporarily during the runtime to be executed for any operation used by any operations. Any operation takes word from the stack of pushed word onto the stack, or basically both stacks as push and pop, right? So basically any operation takes any of the word from the stack, right? So you can say that stack serves as the intermediate to read and write and manipulate data from the storage memory, call data and locks.
00:48:44.110 - 00:49:25.694, Speaker A: We will talk about all these things. But yeah, you can understand right now as logs, it is basically an intermediate to read, write, or manipulate data from other spaces, right? So yeah, you will understand it when we discuss more about memory. Count, storage, locks, and call data. But yeah, right now understand it basically as an intermediate that for writing and manipulating the data. Right. Now let's talk about, before moving on, this is the size of the stack memory, 256 bits, and the depth is 124 elements, 1024 elements. Now let's talk about memory.
00:49:25.694 - 00:49:48.694, Speaker A: So, memory is also a temporary storage that is executed during the runtime of the transaction. Think memory as a ram. So it's just like a ram. It is also a volatile memory. And yeah, it's a byte addressing linear memory. You can also say that as well. And now let's talk about the call data.
00:49:48.694 - 00:50:39.206, Speaker A: We will talk about what is the difference between memory storage and call data as well. But yeah, in the future, but let's discuss call data. As of now, the call data is basically the data field of transaction. It is also just read alumni memory. It is a quite special data location of the EVM that actually refers to the location that stores the input parameter or the arguments of the function that is supposed to be called. So basically, if you are a solidity developer, I hope you have used call data in your code, right? And quite similar to memory, call data is also non persistent, like it's volatile. It's a non persistent data holder that is cleared after the execution of the transaction.
00:50:39.206 - 00:51:06.322, Speaker A: So as the transaction is done, it is clear, like call data is clear. Right. So it is also a temporary memory, right. And it stores the input parameters of the arguments of the function that is supposed to be called. So when you call the function, like you use the call data string, the name, right? So you do that, right. So this is here what call data is. If you're not a solidity developer, you haven't coded yet, so it's okay.
00:51:06.322 - 00:51:49.534, Speaker A: But yeah, if you have used solidity, I hope you are aware of what call data is then we have locks. So what is locks? Locks is write only input area to the emit locks. So basically it's a write only you can write to the locks if you're a solid developer. Again, you know what are locks? Because once you create event, you specify events in your solidity code and then you emit your event. Once your transaction is done or once your function is executed, you want to emit that so that it is showed in the locks as well. Then you can read those locks and do it. Take it to the front end, you can read the locks and all that stuff.
00:51:49.534 - 00:52:26.038, Speaker A: So I hope you are aware of that as well. And we have the storage lastly. So storage is a persistent memory and you can see the size as well, 256 to 256. It's a key value store. We will talk about, actually we will see in the working of the Ethereum virtual machine, we will see it is actually a key value store and how it actually works. Consider as of now, it's a persistent memory and it's a key value stored as it is persistent. So it is persistent between any transaction.
00:52:26.038 - 00:53:24.282, Speaker A: It is important. What is persistent means when we say it is persistent, it is persistent between any of the transactions, right? And storage is represented in the form of Merkel Patricia. Try the Ethereum python and the go client implementation, as we were talking about, they uses labeldb to store those tries, right? And if I'm not wrong, they are changing it to cockroach DB. Right? But yeah, they uses as of now leveldb to store these tries. And the Merkel Patricia tree is not just an architecture, basically it's architecture, but it also not just represents only the data structure, but it is also a database schema. One thing to keep in mind is that blockchain itself only stores the blocks, including the hash of the stutterade in the header. Right? State root of the header.
00:53:24.282 - 00:54:08.714, Speaker A: While the clients like Go, Ethereum and Aragon, they store the full trice content in the database. Right? So it's a very important difference. The blockchain itself only stores the block while the clients store the full trice contained in a database. Okay, so coming back to the topic, the EVM stores data in both storage and the memory. Storage is used to store data permanently, while memory is used to store data during any function calls, right. It is volatile. Right? And you can also pass in function arguments as call data, right? If you are solid developer, you are already aware of it.
00:54:08.714 - 00:54:52.346, Speaker A: But again, you can also pass in function argument as call data which act as allocating to memory, except the data is non modifiable. The data is non modifiable and you pass on data as an arguments when you are calling a function as well. So I hope now you also understand stack as well. Like stack is actually acting as an intermediate to read and write and manipulate data, right? From memory storage, call data, right? And locks. So stack is basically like intermediate. I hope you get that now. So these are several resources as a space that EVM uses to access and store any of the information.
00:54:52.346 - 00:55:45.366, Speaker A: I hope you are clear of all those resources. We have discussed each of them and stack, memory, account, storage, locks, cold data. I hope I have covered everything if I've missed anything like write down in the comment section, but I hope I have covered everything. Now let's actually talk about before again, we are connecting the dots right now, right? Please bear it with me. We will get to the EVM working of the EVM, but before that we have to understand few things and that's why I'm telling all of these things. And next we will also discuss what is solidity? Like just one single, single slide, small, small slide. What is solidity? What is bytecode? What is Abi? What is opcode? And once it is clear, we will go through one of the example, we will go through remix, we will write our code, we will compile it, we will see the bytecode.
00:55:45.366 - 00:56:21.522, Speaker A: What is that bytecode? What it tells, like we will convert that bytecode into our opcode as well. And we will understand what this bytecode will do to the EVM. And after that, once we are clear, we have brought an understanding. And even as a solidity developer, it's important for you to learn what is happening under the behind to optimize your code, right? So it's very important to understand it. So we will go through that as well. And then we will be talking about the working of EVM, right? So next topic is solidity. What is solidity? Solidity is an object oriented language that is used for writing a smart contract.
00:56:21.522 - 00:56:49.534, Speaker A: You can also use wiper as well for writing smart contracts on EVM machines. On EVM compatible chains, all these languages like object owned languages. Solidity is just like C or Java. And solidity can be compiled down to bytecodes with solve compiler that is present in the EVM itself. And then this bytecode gets onto the EVM and basically on the ethereum. And yeah, it runs. Right.
00:56:49.534 - 00:57:14.946, Speaker A: So this is a simple definition of what solidity is. Now let's move on to bytecode. So as we suggested, that Ethereum smart contract is a bytecode that is actually deployed on the Ethereum blockchain. It's not. Your code doesn't goes into the Ethereum blockchain, it's your bytecode that goes into it. The even bytecode is written in hexadecimal format. So if you see that zero x sign, which means that it is saying that your number is in hexadecimal format.
00:57:14.946 - 00:57:52.846, Speaker A: Now let's move forward. And also one more thing is when we compile your solidity smart contract, it will translate your code into bytecode. That bytecode is only understandable by the EVM. Bytecode is not designed to be executed by the processor directly, but actually by another program. Right. So it can be directly executed on the virtual machine itself. Or the bytecode can be either directly executed on the virtual machine such as an interpreter, or it may be further compiled on into machine code for the better performance.
00:57:52.846 - 00:58:19.174, Speaker A: You can see in the example as well. It gets compiled into ABI and bytecode. We will talk about what ABI is, but yeah, you can see that here's the bytecode on the right hand side, and this is the assembly view of it because you can actually break down your opcodes into breakdown your bytecode into bunch of opcodes. Okay, yeah, so let's talk about actually what opcode is. Before that. Let's talk about ABI. So ABI is an application binary interface.
00:58:19.174 - 00:58:42.146, Speaker A: So when your solidity code gets compiled down, it gives two things. One is the JSON ABI and one is the bytecode. So what is the ABI? ABI is application binary interface as it usually interface. Right, so it's an interface to interact with the smart contract. Right. So it's in a JSON object. Basically JSON is JavaScript object notation format object.
00:58:42.146 - 00:59:14.234, Speaker A: It describes the contract functions, the variables, modifiers and the contract parameters that are in a JSON format. All these things are available. So when you compile down your solidity code, you will able to see your ABI file there as well. Right. Whatever you're using. Ribix or vs code, whatever hardat. So ABI allows anyone writing a smart contracts to be able to communicate between the web application that are written in high level languages like JavaScript, typescript and actually the bytecode of the EVM that understood.
00:59:14.234 - 00:59:37.958, Speaker A: Right, so it basically is acting as an interface to connect your DAP and how it can contract, basically connect with the bytecode how it can communicate. Right, so it's acting between the, acting as an interface. Right. So yeah, this is all about ABI. Now let's talk about opcodes. Opcode is a short form of operation code. As its name suggests, the opcode is a type of code that tells the machine what to do.
00:59:37.958 - 01:00:18.414, Speaker A: All Ethereum bytecode can be broken down into the series of operands and optcodes, as we discussed. So opcode is a different whole topic, which can have its own crash course because there are several types of categories in opcodes as well. Stack management, automatic operations, environmental opcodes, memory management, operation codes, et cetera. There are a lot of them and it can be a different crash course. If you want me to write a crash course, just let me know. Here you can see that every opcode has its name and there is a minimum guesser. For example, let's actually see the bytecode example, right? So suppose this is a bytecode, right? And this is bytecode.
01:00:18.414 - 01:01:10.514, Speaker A: We will break down our bytecode into small, small opcode. So here you can see the zero x one stands for ad, right? So you go to the Ethereum website, you see this list, and there will be a list of Ethereum virtual machines. What ethereum bytecode and what the opcode is for that particular opcode, right? So you can see that for example, zero one is for add. It means that this opcode means adding, and there is a minimum gas for it, that is three, right? So similarly, what here zero x one is doing is basically an opcode for adding two numbers in the EVM bytecode. So what it does, it will remove two elements from the stack. As we said, the stack is last and first out. So it will remove two elements from the stack and then it will push the result, as I said, that on the stack your result is always on the top.
01:01:10.514 - 01:02:08.258, Speaker A: Right? So this is the case and it is very important to understand the EVM bytecode, that is for minimizing gas consumption, right? So this is all about opcode. So here you can see the other opcodes as well, like push one, right? So here, watch it. What it is saying is that push one bytecode of data into the stack, right? It says that so you can convert your bytecode into these different, different opcodes, right? So it is very important to understand how the opcode runs and what is the icode for minimizing the gas consumption, in turn reducing the cost for your end users. Right. It's very important to know that the goal is not, I mean, it is the goal to optimize your contract. So when you deploy it, it reduces the number of gas and the amount that is required to deploy it. But also the main focus is for your end users.
01:02:08.258 - 01:02:47.694, Speaker A: When it interacts with your smart contract, the gas fees which he or she has to pay would be less. Right? So that's the main goal because you don't want your end users to pay a lot of gas fees because you want more and more users to use and track with your solidity smart contract. And if the gas fees is very high, the contract is not optimized. Eventually the users will have to pay a lot of gas fees and they don't want to do it. Right. So it's very important to write the optimized source code, basically solidity code, so that it reduces the cost for the end users. Okay, so this is the relation between the bytecode and the opcode.
01:02:47.694 - 01:03:19.174, Speaker A: One more thing is that the assembly language also, it is important. So it is also possible to write the whole smart Contract using opcodes. Yes, that's where the solidity assembly language comes in. It might be a lot harder to understand it, but it could be useful. It can do stuff which solidity can't do and it can also save you a lot of gas. So you can see that the u language, it is basically written in this format. And then assembly block is marked with curly braces.
01:03:19.174 - 01:03:37.614, Speaker A: And this language is also called Yule. You can visit the solidity documentation if you want to learn about it. Here is the format of writing it. You just write assembly and then there are curly braces. You write the smart contract there as well. Okay, awesome. I guess that's it for all these small, small topics.
01:03:37.614 - 01:04:28.642, Speaker A: Now actually let's go to one of the main example, right? We will actually go onto the remix and we will write our own code, we will deploy it out, we will check the bytecode, how it turns into the different stuff, and now we will understand it at a lower level. So let's go on to the coding as well. Okay, so here I am on the remix, ethereum ide and I have wrote down a small and very simple smart contract. That is my contract name, my contract where I have declared unsigned variable, which is adding to number ten plus two, and it is multiplying it by two. Right. So goal here is to just understand under the hood how your solidity smart contracts work with the evm and what is happening under the hood. So just goal is to keep it simple.
01:04:28.642 - 01:04:42.486, Speaker A: So here I have already written the code. Now let's actually compile our smart contract. So it will generate the bytecode and the API. Yes. So it is already generated. Now let's copy that bytecode and let's paste it here. And let's see what is happening.
01:04:42.486 - 01:05:04.382, Speaker A: Where is the bytecode? Okay, so you will see all that stuther stuff, but your bytecode is this one object one. This is your actual bytecode. Okay? This long one. And one more thing. I have already copied this bytecode into this file. So we already had our bytecode here, right? So this is all our bytecode. Right? And I will explain it later on.
01:05:04.382 - 01:05:44.790, Speaker A: But here you will see one more thing. We will run through it and we will broke it down into the opcode. But the compiler has already done it for us and it's a very good thing that they have broke down our smart bytecode into the opcode. We can also compare it later on as well with what we have broken down into. Okay? So let's move on and let's just look at what our bytecode is doing. Right? So this is our bytecode, right? So as I sold that bytecode is a collection of opcodes, right? So let's see what is happening. So our bytecodes start with 60 80.
01:05:44.790 - 01:06:23.746, Speaker A: So this is like our first four numbers of it. So what does 60 stands for? Let's go to the Ethereum website and there you will see the list of opcodes you can visit there. So we are looking for what? We are looking for 60, right? So we are looking for 60. So what does 60 does? So here you can see that 60 stands for push one, right? And it costs around three gas. And what push one is doing is that push one byte value onto the stack. This is what the work of push one is here, right? So what it's doing is push zero x 80. So put zero x 80 into the stack.
01:06:23.746 - 01:06:59.202, Speaker A: It is in hexadecimal format, right? So first four numbers of our bytecode is doing this, right? So this, like push this. And now again we have 60. So again we know that 60 stand for push one. And again the next two numbers are 40. So what it will again do is push four 80 into the stack. Now our next number is 52. So let's go there and you will see where is 52, right? So 52 is here and it stands for m store, which is memory, to store something in the memory itself.
01:06:59.202 - 01:07:32.890, Speaker A: So write a word to the memory. Right. So this is what it stands for. Again, you will be able to see this is 52, and 52 allocates 60 of the memory space, right? So this is how we are breaking down our bytecode into our opcode. So here again, let's go to our code file, what we have copied, right? So this is what our compiler has already compiled and break down the opcodes for us. So again, we have already discussed it. The 60 stands for push one.
01:07:32.890 - 01:08:04.546, Speaker A: So just push eight 60 bytes and then push one, push four x zero. And then we have a store that is right to the memory. Right? So this is what it is doing. If you want. What you can do is you can go through all over this bytecode and try to understand what it is going and what it is doing. If we go through each and every opcode and compile to understand what every copcode is doing, it will take like a two hour long video. If you want, I can create that, just comment in the right section.
01:08:04.546 - 01:09:02.634, Speaker A: But right now I just want to explain it to you how it is done. So till now what we have done is we have just compiled down or broke down the first few digits. But this is a magic number, you see, 608-0604 this is actually a magic number. So whenever you deploy any of your smart contract, whether it's uniswap smart contract, whether it's any of your smart contract, it will start with this magic number. Why? Because this magic number, 608-060-4052 it says how your smart contract is being initialized, right? And it can change a little bit due to the version of the solidity compiler. I've seen it when I was compiling and running through it, I've seen that when you use a different compiler version, it can change. Sometimes the opcode will be same, push one and push one.
01:09:02.634 - 01:09:44.914, Speaker A: But the memory, the zero X 81, this can change, right? So yeah, this is the magic number and it remains same for a smart contract. Again, there is an exception. If you change the solidity compiler version in future, maybe there is something, there is a change in it. So to further complicate the matter, right now, zero x 80 and zero x 40, to be clear, it cannot be interpreted as it is not 40 or 80. This is a hexadecimal format and 40 actually stands for 64. That is 16 into four. And 80 actually equates to 128 in the hexadecimal format.
01:09:44.914 - 01:10:34.694, Speaker A: Right? So zero x 60 is not 80, it is in a hexadecimal format. It computes to 128 in the decimal format. Okay? So in short, what is happening under the hood is that push 10 x 80 and push 10 x 40 and mstro. What it is doing is that it is allocating 128 bytes of memory and moving the Pointer to the beginning of the 64th byte. This is what it is doing in a simple matters. And now we have 64 bytes for scratch space and 32 bytes for our temporary memory storage, right? So see, what is happening is that here, if I'm not wrong, it is the initialization of your code. It basically is also an initialization of your EVM instance as well.
01:10:34.694 - 01:11:07.474, Speaker A: Right? So it is generating 32 bytes of temporary memory storage and 62 bytes for your scratch space. If I'm not wrong, this is the initialization of your EVM. And this will remain same for all of your smart contracts. Right? So let's discuss more about it. And again, there are three places to store the data. We have already discussed this in the architecture of the VM, but let us again discuss it with our opcode. One is the first is the push one.
01:11:07.474 - 01:11:27.142, Speaker A: That is push one. Push one pushes one byte to the stack. Right? So there is again the architecture of our EVM. Right? So what is done, what it does is basically it is pushing 61 byte to the stack. So we have just three places. Stack memory, right. And call data.
01:11:27.142 - 01:11:42.106, Speaker A: Call data is not available here. But yeah, it's not there, but we have discussed it, if you remember. Okay, so there are three places where you can store the places where you store the data. One is push. So push one to the stack, right. This is what it is doing. The push 160.
01:11:42.106 - 01:12:13.574, Speaker A: Next is the s store, right? Ss store. What is doing is store it permanently onto the EVM storage. That is the blockchain. So if you use s store, what is doing? It is pushing your data or basically whatever you are doing into the EVM store. That is permanent, that is here account storage here, right? And again, if you see push 32 again, what it is doing is it is pushing your memory to the stack, right? And the last one is memory or call. You also use call data as well. But yeah, memory is also one of the thing.
01:12:13.574 - 01:12:47.730, Speaker A: So memory, what it is doing, it is store it in the temporary memory or ram of the EVM. So as we discussed, memory is the temporary one. That is non persistent is the temporary memory, or it is also known as the Ram of EVM. So what this opcode is doing is that store your data in this m store or our memory. Right? So there are many opcodes as well, like m load, s load, jump, stop, return. We will not go through each and every opcode. But these are just like three places.
01:12:47.730 - 01:13:26.446, Speaker A: Our stack, our memory and our storage and memory or call data and our storage. These are just three places where you can store the data. Right? So this is what this opcode is doing. And again, if you go to the code and if you can check if you want to go through each and every byte code and convert it into the opcode, you can free, feel free to do so. And here is an auto generated one. You can check it once you have done your own work. Right.
01:13:26.446 - 01:13:56.450, Speaker A: And also let me tell you one more thing, is that let's now deploy the smart contract. As I was saying, right, your smart contract is not deployed on the blockchain. Your EA smart contract is converted into bytecode. And that bytecode is actually existing on the blockchain. Right? So let's actually deploy our smart contract and see what is happening. Right. So once you deploy our smart contract, right, it is being deployed successfully.
01:13:56.450 - 01:14:09.914, Speaker A: You will be able to see it. Now let's actually debug it. Right? Not let debug it, but yeah, let's see the details of it. Right. So we go here, you can see here, let me just zoom it. Zoom in it for you. Yeah.
01:14:09.914 - 01:14:30.978, Speaker A: So you can see the status true mind transaction hash from what is the address that we are using right. Now. If you go in the input section, if you see clearly, you will see this as input. Right. And what is this? This is our bytecode. Right. You will be able to see that it starts with zero x 80 and it ends with 1033.
01:14:30.978 - 01:14:50.294, Speaker A: And that's how our bytecode ends. Right. So the input is always in the bytecode format. Right. EVM doesn't understand solidity code. It has to be converted into bytecode, which is understood by the EVM. So this is why the input here is the e is in EVM format.
01:14:50.294 - 01:15:30.886, Speaker A: Right. So this is all about our low level understanding of our code. I hope you got what we are doing and how the solidity smart contracts actually works under the hood. And I hope now if you watch this, you will be also able to learn more about optimization of gas and other stuff as well. So yeah, let's move on to our next topic that is actually understanding the EVM working. Now we have connected all our dots, right? We have learned a lot of things. Now let's connect all those dots and learn about the EVM working.
01:15:30.886 - 01:16:07.346, Speaker A: Okay, so we are finally on our slide of EVM working on our part of EVM working how actually ethereum virtual machine works. Under the hoods, we have already connected and learned about all that amazing stuff. Now let's talk about how actually EVM working with a real life example. So here is a diagram of EVM working. And here is actually how it actually works. So first of all, in this diagram, you will see a transaction happening. So you can see a transaction here.
01:16:07.346 - 01:17:04.318, Speaker A: So this transaction contains some values, that is two data, the value gas price and all that stuff. So the two is actually to the contract where it is requesting the transaction. Like for example, this two address will be similar to this contract address. We will talk about this in a minute, but you will be able to see this contract. This two address is same as this contract address. Because this transaction is requesting a transaction or some kind of calling this contract, right? This is calling this contract. And then you can also see that this transaction has some data which will go to the EVM and this contract.
01:17:04.318 - 01:18:09.222, Speaker A: So what happens is that whenever a transaction is coming in the EVM, the EVM will pull up the contract that it is calling, right? So whenever a transaction comes, like for example here, there's a transaction to this contract. Then what EVM will do is EVM will pull up the contract that has been called, right? So EVM has right? Now pulled this contract because this contract has been called, right? And contract has these things like address the nose, the balance of it, it also contains it code. The code of it which is immutable. We have discussed like, the code is in the bytecode form, right? And there is also like opcode one in that as well. Opcode basically breakdowns into opcode, right? So that bytecode is present in the contract, which is immutable, which can't be changed. And then we have a storage. Storage, which is immutable.
01:18:09.222 - 01:18:54.662, Speaker A: So if you request on to submitting any of your transaction or any of your balance into that contract, you can do it on the storage which is immutable. It is in the form of key and value pairs. Okay? Yeah. And every EVM has this program counter that is set to zero. And EVM will use this program counter to step through this code. So this contract has this code which is in the bytecode format. So the EVM will use this program counter to step through this code and understand what does this contract code does.
01:18:54.662 - 01:19:51.450, Speaker A: Right? So we have this transaction, again, we have this transaction which is sending some kind of data. And what EVM will do is EVM will grab the smart contract, whatever, wherever this transaction is calling, right? And this will use this program counter to understand what this code is doing. And one more thing to understand is that for each and every transaction that has been called onto the EVM, the code of contract is always loaded and the program counter is always, the contract code is always loaded. And then the program counter is set to zero and the contract storage is also loaded. This storage is also loaded, right? And the memory is all set to zero. In here, the stack and memory and everything, it is set to zero. Right.
01:19:51.450 - 01:20:46.966, Speaker A: It creates a new EVM instance every time there is a transaction being called, right? So this is what happens when a transaction is happening onto the EVM. Now, again, what will happen is that EVM will take this data. So this transaction has some data. Maybe you are doing a transaction, you are calling a function on this contract, right? So what this does is that this data will be given to the EVM. EVM will take that data and deal with the code, right? For example, if you want to call a function on this contract, it will take that data, it will understand what it wants. What does the data wants? It will then interact with the contract. Like what contract? Understand this contract with program counter.
01:20:46.966 - 01:21:51.280, Speaker A: And then it will execute it. For example, if you are calling a function, right, it will execute it and use stack and mumburi to keep records of the things. And once it's done, it changes the storage on the contract as well. Right? So once your data is understandable by the EVM, it uses the stack and memory and all of that stuff to actually do some kind of changes. And once the changes in done is done, like using this gas available memory and everything the changes is done, there is a catch that there should be enough gas available. So once the gas is enough available, and the EVM has calculated the changes, like whatever it wants, once EVM has done that, it will update the storage of this contract, right? So this will update the storage of this contract. For example.
01:21:51.280 - 01:22:37.454, Speaker A: Let's take an example as well. Clearly as well. So for example, this is an escrow contract, and you want to submit your money or basically your ether to this contract. What you will do is basically, this transaction is calling to this contract and there is a data which contains message value, right? And it contains the value what you want to submit to this contract. So this data goes to the EVM. The EVM understands that, yeah, this takes the message value and it understands that this is what they want. This is what this particular transaction wants.
01:22:37.454 - 01:24:18.202, Speaker A: And what it will do is it will update the storage of that contract. That, hey, this particular contract, this particular address, the transaction, who has sent the transaction, they have requested or they have post, they have provided this much of data, this much of function, it's calling this function to add the ether to this particular address, right? So what it will do is it will call that particular function and it will update the storage of that particular contract. So in this way, your data was successfully gone to the EVM, and EVM has understood it and it has done the changes. And finally it has done the state changes, final changes into the contract itself. The contract itself is in form of storage, in the immutable, it's form of key and value pair, right? So it has finally updated the contract, the escrow contract, right? So one thing to notice that every transaction is happening in line in EVM, when I mean every transaction is happening in line, it says that once one transaction is run, then only other transaction is executed. No transaction is executed parallel. Right? So just like one, two, three, like one by one, one by one, right? And then once this state is updated, right? So the EVM has changed the state of this contract.
01:24:18.202 - 01:25:40.638, Speaker A: So there is a new state, right? We have already discussed the state as well, the theorem state as well. So there is a new state and then this new state is broadcasted to the block. So for example, how blockchain works, I hope you understand that once that block has already finds the non value which is less than the particular target in proof of work, it has been changed. Now, in proof of stake, right? For example, there is a block miner, right? Or basically block validator in EVM, the proof of stake EVM. So the block validator, the block owner miner has this changes, it has done this changes in this geth, for example, he is running geth or any other client service, they have already calculated this ethereum state, this has new state. So now this block, the particular validator block or that particular minor block, the state of that block changes changed. And what it will do is it will have to validate all other blocks that are in the blockchain, have to also agree to the same changes, right? In the blockchain.
01:25:40.638 - 01:26:36.646, Speaker A: Proof of work I'm not sure about proof of stake yet. I will have to do my own research. But what happens in proof of stake chain is that every other block has some kind of rules and regulations that like some kind of Checklist which they check, is that if the block has this particular checklist, then only it will accept those changes of it. So for example, the block hash is this much. If that matches the hash of the previous block. So there are like a checklist which every block has to check before accepting the block, right? So every block checks that, and then every block accepts the new state of that blockchain. Okay, so this changes happening happens in every 14 seconds.
01:26:36.646 - 01:27:14.278, Speaker A: In ethereum, like for example, every 14 seconds there is a new state, and then after 14 seconds there is again a new state. There is again a new state. So this is what happens. And every block computes those changes, and every block has to compute all those changes. I'm not sure about the proof of stake thing, which I've talked about, the validator and all this stuff, but I'm pretty sure about the proof of work working, right. Maybe I'm wrong on the proof of stake side. So what happens is that every block will have to change all that state.
01:27:14.278 - 01:28:15.078, Speaker A: All the state changes, every block will have to compute it, right? So suppose there are 30 nodes in the ethereum, right? So what will happen is that every 30 node will have to update those changes. It will not happen that that only 20 of those nodes will update the changes, right? Every block or every node will have to update those state changes as well. So we don't have the sharding yet. So we will not talk about much about that. I can create a separate video about that. Suppose there are 30 blocks or 30 nodes in the ethereum, so every block will have to compute those state changes. We don't have sharding yet, in which every shard will have some blocks and they will have to change the shard, the state changes of that particular shard.
01:28:15.078 - 01:28:53.122, Speaker A: And we don't have that, right? So let's not talk about it. I can create a next video about it. And there is other chains that have already implemented shardium, so maybe if you want, you can look into it. I have not done my research. As of now, this is how actually the EVM works under the hood. And what it will happen again is there will be one case as well, like for example. So one thing also to remember or to take care of that this transaction has some data, right? So this EVM will update this contract.
01:28:53.122 - 01:30:21.966, Speaker A: But what if there is a call to another contract from this contract, right? So for that we have a special case for it. That is the Ethereum virtual machines when it calls another smart contract, right? So one thing is again to notice that EVM has access to the world state and not historical data, right? EVM has only access to the particular world state, no historical data, no previous transaction access, not any access to external APIs or anything. So that's why we have oracles, right? So Ethereum virtual machine EVM can't have access to the external APIs, right? So that's why we have this oracle contracts, right? So each smart contract can actually call another smart contract. So here, this EVM request, or this EVM understands this transaction, this data, the request, and then it pushes onto the contract. But what if this contract is required to call another contract, right? So every smart contract can call another smart contract, and each call creates a new instance of EVM, right? So every time a smart contract calls another contract, there is a new EVM instance created. So let's take an example of an oracle. Like for example, Chainlink smart contract.
01:30:21.966 - 01:32:20.630, Speaker A: So chainlink will, smart contract will have the changes in its storage of the current price of the Ethereum, right? So the smart contracts on itself cannot get access to external API. So what if you want to know the price of the Ethereum right? Now, what is the price of Ethereum? So Chainlink smart contract will have the price, current price of Ethereum in its storage, so that the other contracts can check this contract for a given state, right? Or for a particular snapshot. So there is new ambiguity. So for that particular instance of this state, the price of the Ethereum, right, it will be price of Ethereum or bitcoin or any other token will be the same for that particular amount of particular instance of time for every other EVM, right? That's why using this is very important, because there will be no ambiguity in future, right? So since the EVM smart contract, the chainlink smart contract, the chainlink smart contract will have the current price in its storage, and that only will be accessible to the smart contracts. That is calling that Chainlink Oracle smart contract, right? So this is like a simple example of how it will work. Now, let's talk about again, there is an EVM instance, right? For example, it again has this program counter gas available, stack in memory, all that stuff, right? And every time we have already talked that every time there is a creation of EVM, the program counter is set to zero. Stack in memory, the memory is set to zero and all this stuff, right? So the EVM instance is sent to zero.
01:32:20.630 - 01:33:38.462, Speaker A: And in a pre save example, as we have seen, right, that suppose there is a call, like for example, there is a call from here that in this contract do this, this changes. So this contract now has calculated the changes, but this contract now is basically in the middle, where the contract will have to call another contract to get the price. Again, if I take the chain link example, maybe this contract wants the price of ethereum, right? So this contract will call the chainlink contract, right? So this contract will pass on some arguments, will pass on some input data, and there will be a new instance of EVM, right? And again, there will be program counter set to zero and gas available. The stack and memory is there, right? So what will happen is that this input data, right? So there is a transaction here. Here is a transaction in this example. Similarly, this input data will act as a transaction for this EVM instance, right? And once there is that input data, some kind of bytecode, it will calculate it. Or maybe it will call another smart contract.
01:33:38.462 - 01:34:06.858, Speaker A: Like there may be another the chain link, Oracle. The chain link smart contract will call another smart contract, right? So there will be another EVM instance that will be created. Yes, this is the case. And then, suppose, for example, it ends here. Then it will calculate the result. Here, it will use the memory. All these EVM instances actually use memory to calculate all these changes.
01:34:06.858 - 01:35:35.542, Speaker A: And once the calculation is done, it will return some kind of data to the smart contract that has called this smart contract. So it will return some kind of data, and the state of the new EVM is being calculated. And this will be a new state, right? And also, when it passes the EVM EVM instance is passing the input, right? It is calling another smart contract. Then it will also pass the current state of that EVM instance. Because right now, this EVM instance one has already done some changes, right? It has already calculated some changes, so it has some change in its state, right? So it will also pass on this state to EVM instance two, right? And this state will be here. And again, if it is calling another EVM another smart contract, then the EVM instance three will have the current state of EVM instance one and EVM instance two, right? And then at the end, when the calculation is done and there is finally a return value that has gone to the EVM instance one, all this changes will be done, and there will be a new world state, right? And only. And only if the gas doesn't runs out.
01:35:35.542 - 01:36:59.582, Speaker A: So if the gas runs out, then there will be the state of that EVM that was calculated will be reverted, but the gas that was consumed will be there, and the nonce of that transaction that was called will be increased, right? So the gas will be taken as basically as a punishment for wasting the time of EVM for doing all this work. So if the gas has run out, then the state of that EVM will be reverted back, right? And the written data again, the return data is a way of smart contract that can return a value after a call, right? So this return data is basically a way a smart contract can return a value after a call. So this particular line is basically the return data. That is a way that how a smart contract can enter a value after a call, right? So yeah, this is the second example of how when EVM calls another smart contract, that will happen. But you have to keep in mind the gas should not run out. If that is the case, everything will be reverted. And if it is not, everything will be reverted and the EVM will just evaporate.
01:36:59.582 - 01:37:38.158, Speaker A: Okay, so this is just a simple working of EVM. And I guess this is overall how the Ethereum virtual machine works. We have taken both of the examples, like example of EVM when it calls like single one, and how if it calls another smart contract. So yeah, this is the EVM working. I hope you get how actually the EVM works. And yeah, if you are liking this video, please, if you're still watching it, please, please like this video comment and please share it on LinkedIn and Twitter. Please do tag me as well.
01:37:38.158 - 01:38:06.642, Speaker A: It's very important for me. Right. And please share it with your friends and family as well. Understand and let them understand how actually EVM works under the hood. Right now we have to talk about just one topic that is left, or maybe two topics. One is the Ethereum gas and the EVM Turing machine, or whether it is a quasi Turing machine or a Turing complete machine. So yeah, let's move on to the last two topics.
01:38:06.642 - 01:38:38.606, Speaker A: That is the Ethereum gas and the Turing machine. Yeah, let's move on. Okay, so let's talk about gas. Ethereum gas. So what is gas? Gas is nothing but a unit of measurement that measures the amount of computational effort required to perform a certain operation on the Ethereum. It is also written on the screen as well. Like it is a fee that is required to conduct a transaction on the Ethereum blockchain.
01:38:38.606 - 01:40:02.522, Speaker A: Right? And it is also calculated in GUI as well, which is also one of the unit. And since Ethereum transaction, it requires certain amount of computational resources to complete, there should be a commission. That's why there is a gas fee that actually acts as a commission to successfully run those transactions in the Ethereum blockchain. The gas fee actually helps to maintain the security of Ethereum network as well. Right? So by demanding a fee for each calculation performed on the network, we do not allow attackers to send spam onto the network. Right? So to avoid any random infinite loops or any other computational losses in the code. Each transaction should actually set up some kind of limit on the number of computational steps for the code execution, right, because if there is some kind of a person who basically writes a loop that is never ending, then there will be a trouble with the block unit, with cogulup, right? So we don't want that, right? So there is a gas fee.
01:40:02.522 - 01:40:49.818, Speaker A: Once that gas fee or that particular gas amount is lost, or it is not enough to execute the transaction, the transaction will be reverted back. So in this way, it helps us to maintain the security of Ethereum as well. Gas is really very important for that as well. And each opcode has a fixed cost to be paid upon the execution measured by the gas. So when we were looking into the code example of the working of EVM, we were converting bytecode and EVM. There was actually mention of the gas for that particular opcode, right? So there is a particular gas for all that opcode. If you haven't seen that video, go and see that video as well.
01:40:49.818 - 01:41:22.470, Speaker A: So some opcodes can be triggered for gas refunds. Let's talk about Ethereum gas reference. So some opcode can trigger gas refunds, which reduces the cost of the transaction. So gas refunds are applied at the end of any transaction. But if a transaction has insufficient gas to reach the end of its run, its gas refund cannot be triggered. Right? So this is a case and the transaction fails as well. With the introduction of London for hard folk, two aspects of gas refund has been changed.
01:41:22.470 - 01:42:35.594, Speaker A: First is that the implement to how much gas can be refunded is lowered by the half of the total transaction cost to one fifth of the total transaction cost. And second is that the self destruct opcode, the self destruct opcode, which destroys and completely deletes the smart contract. And that opcode cannot trigger gas refunds, right? So only that opcode self destruct cannot trigger the gas refunds as well. So these are the changes after the London hard folk. And now let's actually talk about Ethereum Turing completeness. So whether Ethereum or EVM is a Turing complete machine or not. Right, so what is a Turing complete machine? A Turing complete machine is a system in which a program can be written that will find an answer to any computational problem, although there is no guaranteed regarding the runtime and the memory, right, and if your machine is Turing complete, then it could compute or it can use to solve any computational problem, right? So this is all about Turing machine.
01:42:35.594 - 01:43:15.642, Speaker A: So Ethereum is actually. People say that Ethereum is a Turing complete because it can execute any program that a Turing complete machine can run while reading and writing the smart contract and memory. So Ethereum is technically not Turing complete, it is quasi Turing complete. And why I say that? Because there are some things that it doesn't fulfill as Ethereum Turing machine. Right? So what is that thing is also one more fact. If you are watching this Turing complete, there was a person who created this Turing machine. In between a war.
01:43:15.642 - 01:43:46.114, Speaker A: There is a movie called imitation game, if you want. It is a good way to actually understand the history of Turing machines. So just go and watch it if you want. So now let's talk about why Ethereum is a EVM. Or Ethereum is a quasi Turing complete. So the properties of Turing machine are as follows. Like a Turing machine can run forever, it can use infinite memory, and Turing machine has random access memory, and Turing machine can simulate any other Turing machine.
01:43:46.114 - 01:44:48.582, Speaker A: But these properties ethereum doesn't have, because Ethereum, in Ethereum, we cannot have programs that can run forever, we cannot allow programs to use infinite memory. This is the case, right? And if we recall again, if you check out the Turing complete machine, basically in that any program can run forever and use infinite memory. So when EVM is executed a transaction, it carefully accounts for every transaction, right. Ethereum smart contract transaction or smart contract, can only execute a transaction so long it has enough gas. Right? And each instruction has a cost, that is a guess. So for example, adding two numbers cost three gas, calculating catch up to 56 hash cost 30 gas, right. Creating new contract account guess 32,000 gas.
01:44:48.582 - 01:45:39.306, Speaker A: So there is a particular guess for every other transaction or every instruction, right. And if a smart contract is executed and it's run into infinite loop, for example, it would eventually run out of gas and transaction would be reverted, right? So that's not possible in Ethereum. Right? And the EVM terminates the execution if the amount of gas exceeds the gas available for that transaction. So if the gas is not enough for that particular transaction, the EVM terminates that execution. Right? So that's why EVM is considered to be a quasi Turing complete machine and not a Turing complete machine. Right. So that's all about the crash course.
01:45:39.306 - 01:46:07.426, Speaker A: And finally, we have completed all the topics of Ethereum or the EVM. Ethereum virtual machine, right. So thanks a lot for watching. Thank you. And there are some links in the description which I have provided some blocks to EVM which you can go through, so please check out those links as well. And I have other videos I've created. You can visit those videos as well.
01:46:07.426 - 01:46:59.354, Speaker A: If you like and if you found this video, this crash course helpful then please please like to this video and subscribe to the channel. I will be creating more and more crash course for your understanding. My goal is here to simplify the blockchain stuff and actually clear the basics for all those blockchain developers that are out there. Maybe some of the developers, they don't understand the core stuff so I really want to help them understand the underhood of the working of blockchain, CVM, all that other stuff. So please subscribe to the channel and what other crash course you want me to create. Please write down in the comment section and do follow me on Twitter at the rate sink, underscore uttam. You can reach out to me on LinkedIn.
01:46:59.354 - 01:47:27.458, Speaker A: If you have any doubts regarding this crash course as well, just tweet it or dm me and what whatever it is, I will love to help you, but please share this to your family group in your Whatsapp group, college group or wherever you are. Please share it on Twitter and LinkedIn. And do tag me. So thanks a lot for watching. I hope you found this video helpful. Yeah, thank you so much for watching till that, take care and bye.
