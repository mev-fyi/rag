00:00:00.480 - 00:00:39.954, Speaker A: GM GM everyone, this video is a long video on diamond proxy pattern which is EIP 25 35 where we have discussed the architecture analogy and the code walkthrough of the diamond proxy pattern. I hope you will learn a lot from this advanced solidity topic. Let me know in the comment section if you like the video and if there is any topic that you want me to create video on. Also there is a link to Telegram channel in the description of this video where I usually share web3 hackathons, grants, internships, some job salad and everything related to web3. So do join that Telegram channel. And also there is a link to my twitter and LinkedIn so do follow me there and let me know if you have any questions. You can dm me there and let me know in the comment section if you like the video.
00:00:39.954 - 00:01:15.708, Speaker A: Enjoy. Thank you. So the agenda for this course, basically for this video is that we are going to master the diamond proxy pattern. That is EIP 25 35, right? So this is like a highly focused developer topic, right? So I think it makes sense for us this time to go more on the coding side and spend more time on the coding side, the coding walkthrough and, you know, looking on examples and tutorials, right. Rather than on the theory part. But still, I mean, if you are a new developer, I want to make sure that you understand everything so quickly. We will go over through like the theory of what it is.
00:01:15.708 - 00:01:50.194, Speaker A: What is diamond proxy pattern? Why do you need it? What are the function, what are the advantages, some architecture stuff. And then directly we will go into the coding. I will make sure that you understand each and every line of the code of the diamond pattern. There are so many diamond patterns, like diamond one, two, three different kind of patterns. We will go through, you know, one of them and I will explain to you like what exactly it is and how you can, you know, use this diamond proxy pattern while designing your protocol. Okay. And then after that we will go through what are the protocols that are using these proto the diamond pattern.
00:01:50.194 - 00:02:25.616, Speaker A: Right now. We will look into a little bit of code of that. And then at the end we will also look into the security practices, like what are the security practices that you want, needs to keep in mind while utilizing the diamond pattern. And then at the end we will have a guest lecture by the co founder, not really the co founder, but actually the EIB author of 25 35. That is the, you know, founder of Time and proxy Pattern. You can say that, right? The author of that. So he's coming and we will have a podcast with him so let's get started with the theory part and jump on to the coding directly.
00:02:25.616 - 00:03:03.492, Speaker A: Cool. So what is proxy pattern like? First of all, like after, before understanding diamond proxy pattern, it's good to understand what is proxy pattern. So traditionally, smart contracts have a limitation, I hope. Before starting this course, I'm hoping that you guys are already good with a little bit of solidity. I'm not asking you to be an advanced solidity dev because this is already advanced topic. Right. I'm hoping that, you know, basics of solidity, you know what delegate call is and how to call a function and everything, right? You, if you, if you don't know anything, go and watch my EVM crash course which will be really, really helpful.
00:03:03.492 - 00:03:40.536, Speaker A: Go and watch that and just learn like basics of solidity. That would be helpful because this topic is like very important and much popular these days. If you are like a, if you're targeting to get a find a job or, you know, trying to get into solidity and into web3 space, then you know, this topic is good for you and you can show it off in front of everyone in your recruiters interviews. And you know, you can create a YouTube project with this too. Okay, so cool. So traditional smart contracts basically have a limitations. That is, they are immutable and unchangeable once deployed.
00:03:40.536 - 00:04:11.784, Speaker A: Right. This is also like one of the benefits and also, and the limitations, like the immutable nature of smart contracts can be a problem. Like when developers need to add new functionalities or kind of, they want to fix a bug in a smart contract. And that's where these proxy patterns come in. Right? So what, what really happens in this proxy patterns is like there, there is a smart contract. There is a main smart contract which the person, which is the user interacts with. But the main smart contract also have like a proxy smart contract, right.
00:04:11.784 - 00:04:29.324, Speaker A: They can have multiple proxies. Right. Which, which will, which is also like another contract. So this contract delegates, calls, delegate call basically calls another smart contract. And then there is, then there is a return of the data. And then eventually, you know, you get a return of the data. Right.
00:04:29.324 - 00:04:56.986, Speaker A: So this is how usually the proxy pattern works. That there is a proxy behind of, you know, the main contract. There can be multiple proxies and, right. We can see one, two, three, and whatsoever, there is no limit. Okay, so this is basically the proxy pattern. And there are multiple types of proxy pattern. One is the transparent proxy, the universal upgradable proxy, standard proxy, and then there is beacon proxy, and at the end there is diamond proxy.
00:04:56.986 - 00:06:14.452, Speaker A: Right? So in this course, we are only going to talk about diamond proxy because I personally think it's like one of the best proxy pattern out there, right? And most of the people are utilizing only that proxy. I know people are still using other proxies, but I guess, you know, if you understand diamond proxy properly, I guess those three proxy patterns will be easy for you. But yeah, let in this course we will only focus on the diamond proxy pattern. Okay, cool. So moving ahead, like what is diamond pattern now? So diamond standard is a proxy design pattern developed by Nick Much, who's going to have a podcast with us at the end of this course. It enables the modularity and upgradability of the smart contracts basically, right? It's a type of proxy pattern, right. The dimension standard basically tackles the immutable nature of the smart contracts and, you know, allows all the deployed contracts to be upgraded by the developers, right? Like with the diamond standard, I would say like, you know, developers can add and replace or remove any smart contract functionality and can also split these functionalities into different, different contract parts, right? So if, as you can see in the diagram, right, it enables a single functions, right.
00:06:14.452 - 00:06:50.456, Speaker A: All these enable disabled functions to be modified without requiring entire implementation contract to be redeployed. How does this work? Like basically there will be a main contract that will be the diamond contract, right. And then it will, it is going to delegate called to small, small contracts, just like proxy pattern that we see or saw right now, right. It is going to delegate call basically, you know, they're going to delegate call to these multiple contracts. And these multiple contracts are called facet here, right. We will understand more on the architecture side. But yeah, this is like the simple stuff that basically, you know, with, without requiring to deploy any code.
00:06:50.456 - 00:08:15.326, Speaker A: Suppose for example a developer wants to change anything of this particular functionality, then they can change it, right? So understand that there's, this is a main contract and these are all the functions, functionalities, right, of the protocol or of the DAP. And if you want to change one functionality, you can do that, right? Because this is found functionality. There is second functionality, the start functionality. So you don't have to worry about changing all the, all the things in this, all the, all the contract, right. The full contract, you can just upgrade a little part of that that you want to change with whatever functionality, right? And like proxy patterns, like with broad access control where accounts with like certain permission can upgrade the entire contract. Like with diamond pack pattern support, I guess like there are modular permissions. This allows restrictions to be set only to be upgrade specific function with the smart contracts, right? So if you, and even if you want like certain permissions to give any to someone else to upgrade this particular function, you that you can do that you don't have to, you know, give permission to a single person to upgrade the proxy contract, right there, this is more of like you can say a modular design, a modular permission design, okay? So moving forward and learning more about the diamond pattern, right, so diamond pattern is basically a proxy design pattern that enables modularity and upgradability of smart contracts.
00:08:15.326 - 00:08:49.910, Speaker A: Simple, right. And the smart contract that implements this standard is known as the diamond, right. And the contract that provides different functionality to the diamonds are known as facets, right. So these two things that you have to understand is this contract. The main contract is called diamond with whom the user is going to interact. And all the function contracts where the functionality is, you know, return, all those contracts are called FaceTime, facet, okay, facet. So there can be multiple facet, facet, one facet, two facet, three, whatever facet, how many functionalities you want.
00:08:49.910 - 00:09:36.700, Speaker A: And this contract, the main contract which is going to delegate the call, it is called as diamond pattern, okay, like the diamond contract, okay, so the diamond standard works like other proxy standards and they stored like the smart contract date of the smart contract and use the solidity, fallback function to make delegate calls, right. So if you know a little bit of solidity, then you must have understood the fall of the fallback. The fallback function, right. So whenever there is something that is called and it is not present, then fallback function gets activated and eventually the call gets delegated to the, to the, you know, to the proxy pattern based upon the function selector and everything. We will understand it when we see the code. So you don't have to worry about that. But yeah, this is how, you know, with the fallback function, the things work.
00:09:36.700 - 00:10:16.938, Speaker A: We will see how the fallback function works. What is function selector? And you know how everything works, right. So don't you have to worry about it, just understand the basic architecture right now. Okay, the smart contract that implements this sender is known as diamond. And the contract that provides different functionality to the diamonds are called the facets, right? So hope you understand this. In the diamond pattern, like in the solidities, there is a function called delegate call, which is like a low level function that we just discussed, right? So it uses like the logic of the called contract, which will be the main contract while preserving and utilizing the call it storage. So if you don't understand like about the storage of how things work, just wait for like few minutes.
00:10:16.938 - 00:11:02.456, Speaker A: We, I will go through an example and I will like code something and I will show you how the storage of the solidity and EVM works. So it would be really helpful for you. Now let's quickly understand like what are the key features of that, right? Key features of diamond proxy pattern. That is the first of all it is like the smart contract upgradability. As I said, like developers can upgrade the smart contract that implements the diamond structure after the deployments. If there is anything that need to be updated, you can update the contract facet, right? Contract facet to whatever functionality you want to update the others is like there is unlimited functionality for a smart contract that there can be unlimited facets. There is no limit to these facets, there can be unlimited facets, right? What, how many you want, right? And then also there is no smart contract systems.
00:11:02.456 - 00:11:38.002, Speaker A: As I said, there is no limit for facet and then eventually there is no smart contracts limit. So if you know that the contract size limit is 24 kilobyte, so if your contract is more than 24 kb, it is not going to get deployed straight. So that is a problem with EVM. And sometimes there was, there was a discussion that we need to increase the size limit but Vitalik told that it is not really necessary. But there are other chains like maybe polygon discussed it somewhere that they want to increase the size limit. So I think they did it. I'm not exactly sure but yeah you can google it that the contract size.
00:11:38.002 - 00:11:58.138, Speaker A: But yeah in the, in the ethereum the contract size limit is still 24 kb. Okay. And as I said with these diamond smart contracts pattern there is no size limit. You can have as much as facets you want. So the limit doesn't really matter, sir. Okay. And there is modular and structural arrangement of the code and data, like modular and structure arrangement of the data.
00:11:58.138 - 00:13:01.330, Speaker A: So basically the functionalities are separated into various facets and you know allowing for more modular and no structural approach. So when I will show you the protocols that are utilizing the proxy, the diamond proxy pattern, you will see like it is like real, real good, like the modularity and the things about that, right? It's like really good. The architecture basically the one, and also there is like one fixed smart contract, as I said, like addressing, supporting like different assets. So developer can add multiple facets to diamonds. Like this is a very good way, like there will be one main contract and then there is all others contracts and you know you can keep upgrading them, you can add and remove, delete, whatever we will discuss all the architecture like how you once can do it. But yeah, you know, these are like key advantages of that. And like also one, one thing that I would say is that if your protocol can work with a single smart contract and none of the above benefits, I guess then apply to your application, then there is no need to use the proxy pattern or the diamond standard.
00:13:01.330 - 00:13:30.664, Speaker A: Like however, if you are in a situation where you need to use a proxy pattern, then I guess for your application then diamond personally will be my choice. And you will go through that. You will choose, you should choose that. But if it doesn't need it, then I guess it will create things more complicated. So it would be good to stay away from it if you really don't need a proxy pattern. But if you need it then yes, let's go for, you should go for a diamond proxy pattern. Okay.
00:13:30.664 - 00:13:55.598, Speaker A: Yeah. So about the architecture. About it, right. So what are the things that you need to know as an architecture? So after this we will go through the code and we will understand every bit of it, every, every file of solidity. Right. But yeah, just remember these names like what it is and what it does. I will come back to this, this presentation again and this page again.
00:13:55.598 - 00:14:27.180, Speaker A: So we will, you know, go through each and every, basically each and every thing one by one. Okay, so what is the diamond again? The diamond is basically the central contract that we just talked about which acts as a proxy. And you know, it basically routes functions calls to different appropriate facet. Right? Facet. And what is facet? And also there is like a mapping of functions like to the facet address. We will see that like, or there, there is basically, there has to be a match, right. How will the diamond main contract will know which facet to call? Right.
00:14:27.180 - 00:14:56.574, Speaker A: So there is basically a mapping of function selectors with the facet address. We will see how that works basically fast. And what is facet and face, as I showed like, it is an individual contracts that implements the functionality, right. So this is a, this is, this is like the facet, right? Individual contract, right. This is the diamond, the main contract. And there will be a mapping from here to here. You can see that with functions like facet addresses so that this particular contract knows what to call and when to call.
00:14:56.574 - 00:15:40.286, Speaker A: And there will be a fallback function implemented which we will see very soon. What is love? So loop is basically a set of standard functions based in, defined in EIP 25 35, right. It contains some, I can say it's some read only functions that used to get details of the diamond such as like its facets. How many facets exist, right? And then there is like all the function selectors. Basically, function selector is the function selector is like the first four bytes of the function signature, right. And you know, basically laup can help you to do that. There is also like a tool created by a few developers that you should check that like, like whoever is using smart contract, they should check.
00:15:40.286 - 00:16:24.126, Speaker A: I will provide the link in the description or we will check it later in the course. And what is diamond cut? So diamond cut is basically, basically there is also a face cut function that we will see which is a function used to add, replace or remove the facet and their corresponding functions. Lectures in the diamond. Like only an authorized address like the diamonds owner or the multi signature can perform this diamond cuts, right? So basically diamond cut is like, so when you want to add and replace any of the functionalities, that is the facets, then you call this diamond confection, like this diamond confunction. This file is going to help, right? So basically cutting the diamond, right. You understand the analogy. Let's try to understand the analogy.
00:16:24.126 - 00:17:15.460, Speaker A: The last thing is the diamond storage. So facets, like these facets, right, they do not store the state variables and the data of the diamond, right? Like facets cannot have a state since the diamond use them through the proxy calls, right? And therefore there must be a way for these diamond to share the state variables with assessor, right? So for this, the diamond use a more advanced and structured approach to their state variables, like allowing facets to access them. And there is a method for achieving this. And this is loneliness, more of like diamond storage. So when creating these applications with like the diamond standard, you can go with either two routes. One is maintaining to maintain basically your straight variables. The first one is diamond storage and the other one is app storage.
00:17:15.460 - 00:17:43.098, Speaker A: Okay, so cool. So I guess that's it. If you don't understand any of things, you don't need to worry about it. We will go through the code base and I will explain it to you each and everything. So I don't think so that will be a problem, right. But yeah, let's, before moving forward, I think it's very important to, you know, let you know like few things about the state variables and how the EVM storage works, right. The state variables and all the stuff.
00:17:43.098 - 00:17:58.842, Speaker A: Right. So for that, let me quickly give you a quick tutorial. So let's go to our remix and let's check out this. And then we will go through the versus code, the Githubs and you know, all this stuff. And then also we will code a example of diamond proxy. Cool. Let's go.
00:17:58.842 - 00:18:39.142, Speaker A: So I am on my remix and you know, architecture of this state variable is one of the important aspects of any solidity application or DeFi or blockchain application in general. And I decided to cover this topic first to give you a good understanding of how state variables are managed with diamond standard. Right. And obviously, like proxies are heavily, you know, rely on the delegate call function to execute the code from the contracts. Right. In context, in the context of your main contract. That will be the diamond contract here.
00:18:39.142 - 00:19:08.162, Speaker A: And since all the storage of the state variables is basically kept in the main file, that is the diamond full file, we need to make sure that our variables are not, you know, overwriting. Right. So let, let, let's go with this example. First. Let me tell you, let me tell you what I mean with all that, right? So basically here is a contract, right. This is a very, very simple contract. What I'm doing is they see there are basically three contracts.
00:19:08.162 - 00:19:27.642, Speaker A: One is the main contract. One is the spatial variable manager and not suspicial variable manager. Okay, so what is main contract doing? So main contract has two states variable. One is very special variable and then is not suspicion variable. Okay. And then there are two functions that we are calling. One is spread set very special variable.
00:19:27.642 - 00:19:52.706, Speaker A: We are going to, you know, change the value of very special variable. Right. So for that what we are doing is we are using the delegate call function, right. To delegate this call to this contract that is a special variable manager. So you can see suspicious variable manager, delegate call. Right. We are delegating this call and we are calling this function so that the value of very special variable, it is going to change to 100.
00:19:52.706 - 00:20:13.104, Speaker A: Right. And then there is another function that is set not so special variable. And with, so we are going to call with this not so special variable. We are going to also upgrade that. And how we are going to upgrade that again, delegate call to another contract which is not spatial variable manager. This is another contract. We are delegate call.
00:20:13.104 - 00:20:29.904, Speaker A: You're going to use delegate call. And then this is going to, you know, call this and write not special variable function. Okay. So I hope you understand what we are trying to do here. So if you want, you can pause this. I hope code is properly visible. You can pause this and try to understand what exactly is going on here.
00:20:29.904 - 00:20:51.520, Speaker A: Right. And, yeah, and now what I'm going to do is basically I'm going to deploy the smart contract. I think I've already compiled it. So that's not going to be a problem. But yeah, I'm just going to quickly deploy the main contract, the not so special variable contract and the spatial variable contract. Okay. So I have all the three contracts deployed.
00:20:51.520 - 00:21:07.324, Speaker A: Right. So when I'm looking at the main contract, what we, what we are going to do first is basically first we are going to check what is the value of not sufficient special variable. It is zero. Okay. And also check this value of very special variable. Okay. That is also zero.
00:21:07.324 - 00:21:30.730, Speaker A: Okay. So now what we are going to do is basically we are going to call in the main function. In the main contract, we are going to call set vary spatial variable function. Okay. So for that, what I need to pass, I need to pass the address of the, the contract to which we are going to delegate the call. That is the spatial variable manager contract. So this is the special variable manager contract.
00:21:30.730 - 00:21:50.448, Speaker A: I've copied it and I'm going to call it in set very special variable. Right. I'm passing on the address and I'm going to call this function. Okay, so I've successfully called this function. Now maybe pause, and what do you think? What will be the answer? Right, you can see the contract. This is the contract. And this is the function, what it is doing.
00:21:50.448 - 00:22:13.312, Speaker A: Okay. Maybe pause for a bit and think what is your answer? Okay, so what should be the answer? Now I'm clicking the very special variable. It is updated to 100, right. This is what we are expecting. We are setting the variable to 100 and we are getting this. Right. And now let's also again call the, another function which is trying to upgrade the value of not so spatial variable.
00:22:13.312 - 00:22:35.550, Speaker A: Right. So in this context, again, we are just going to, you know, call this contract now. Okay, and what, we have to pass it, we just have to pass the address of, you know, not so special contract. Okay, I've copied that. And now what I'm going to do is I'm going to paste the contract address here. Okay. I'm going to call this not so special function here.
00:22:35.550 - 00:23:10.390, Speaker A: Okay, so I've called this. It has successfully been called. Now again, take your time and let, let, what should be the answer according to you, right, this is the contract here. Okay, so now I'm going to check what is the answer for that? So the answer for that, if I'm clicking here, I'm again getting zero. But why is that, why is that happening right now? Okay, so I'm getting zero. Where, what about this variable, which is this very special variable? Okay, it should be hundred, right. It should not be changed, but again, if I click on this, the value of this is 50.
00:23:10.390 - 00:23:43.442, Speaker A: Why is that happening? Right. This is like a very, very good question. So if you know the answer, maybe you should google it. Or if you want to know if you're curious, you maybe google it. Or maybe if you are already smart, you should know the answer, right? Maybe take your time and think about it. So why is that happening? Is because solidity does not care about what your name, like what you name your variable, right? It only looks at this storage slot position. So a solidity doesn't know that this is the function.
00:23:43.442 - 00:25:07.520, Speaker A: Like the name of this state variable is very special variable. Or this is like the second variable, its name, is that, right? No, it works according to storage slot position. So what really is happening here, right? So if we, if we say like well basically the storage slot in not so special variable manager, right. It doesn't have very special variables. So here in this main contract we have two state variable, right? But in the not so special variable, there is only one state variable, right? So when we call, right, not spatial variable, which is this function, through like we are the delegate call from this main contract, we are set very spatial variable function. What is, what is going, what, what we are telling the contract is basically update in terms of like in the context of the main contract, just upgrade the storage slot zero to 50, right? So when we did for the first time, so when, when we called this function, like set a very special variable function, right? When we called this function, what really happened was it basically also told that in the context of this contract, please upgrade the storage slot zero. So basically this is, okay, I should write this is the storage slot one, right? And another contract is basically the storage slot one.
00:25:07.520 - 00:26:01.500, Speaker A: Let's, let's say for example, you know, this is it, right? So what we are saying when we are calling this function, like to set this the value of very special variable to 100, we just saying that when you, when you call this function, just make sure that the storage slot of zero is set to 100. Okay, this, this was already set when we called it, right? And, but when on the next, next time we are trying to call this function, what is again happening is that there is only one state variable, right? There is only one state variable. There are no two storage slots, right? So this, the storage slot for this is same as storage slot for this. So when we are, when we are saying that, update the value of not so special variable. Solidity doesn't know that because solidity works in the storage slot, it only is, understand storage slot. It doesn't understand key. Hey, you are trying, you are trying to say that you should call this contract like this state variable name.
00:26:01.500 - 00:26:48.346, Speaker A: No, it doesn't understand it. So basically it's going to just update the storage slot variable to 50, right? So the first storage, or the first storage slot was very special variable. So it updated that to 50 and it doesn't have this second storage slots like another storage slot like the one, one it does, it doesn't update that. Right. So this is what simply, you know, things are happening under the hood, right. And keeping this in mind that the EVM and basically the solidity, you know, they don't, they don't understand the state variable and works in the storage slot position, right. We need to make sure that we are not overwriting our storage sort because in the diamond proxy pattern we are going to use delegate fall function.
00:26:48.346 - 00:27:24.776, Speaker A: We are, we are especially going to use this delegate call function. Like this will be a very, very, very important call, right? So when I showed you in the architecture, there will be a main diamond contract and then we are going to delegate call to these facets, right. So we have to make sure that this is not happening. Right. All this, this, all this, you know, bad things are not happening. Right? So basically, you know, we have to make sure of that. Right? And now some notes that I would like to share and my observation and you know, things that you should understand, right? So solidity again does not care what your name of the variable is and it only looks at the storage slot position that you have to keep in mind.
00:27:24.776 - 00:27:59.400, Speaker A: Like this is if you're solidity dev or what are you doing in blockchain, you need to understand this. And you know, all the storage of our state variable is going to be kept in diamond Soul file. That is the main file. And facets like the proxy contract, like the smallest functionality contract that I just show you the architecture, right. That do, they do not store the state variables and you know the data of the dime, right? So all the storage of the state variable are kept in the diamond soul file. That is the main diamond contract like the main diamond soul file. Hope you remember that diagram.
00:27:59.400 - 00:28:50.914, Speaker A: If you don't like go back to the video and just understand the diagram, that main contract in the, in the diamond sole file, all the storage of the state variable will be there. And all this facet, like all the facets small smart functionality contract, they do not store the state variables, right. So now again as coming back we need to organize our state variables in such a way that there are no overwriting of this storage lot that we just said right there, we were trying to do it and there was some overwriting of the story slots, right. And the way we can do this is with the diamond storage. Right. So I hope, you know that the DIA, that there are in total like two, two to the power 256, you know, storage slot. So diamond storage basically takes advantage of all the storage slots that they are available in a smart contract that is two to the power 256.
00:28:50.914 - 00:29:18.590, Speaker A: Right. And like the theory behind the diamond storage is that because there are so many storage slots like two to the power 256, right. That if we even hash a unique value, right. Even if we hash a unique value, we will not. We will get a random storage slot that will almost not collide with almost another slot. Right. This is like the basic theory and this is how it works.
00:29:18.590 - 00:29:55.008, Speaker A: And we can, in this way we can, you know, share variables between the two smart contracts. That is between the facet and between the main contract, right. So basically hash a unique value, we will get a random storage slot and that will, you know, we will, that is not going to, certainly not going to collide with another storage slot. And this is how we are going to utilize the diamond, you know, storage pattern. Right. And like the diamond storage provides like the opportunity for your facets to keep also like the state variables specific to their smart contract like and, right. And also allowing facets to, you know, have this, all this cheerable things.
00:29:55.008 - 00:30:27.796, Speaker A: And facets are not storing anything. Only the, you know, all the storage are happening in the main file. That is the diamond sole file. Right. And if you are thinking that this is a little bit of risky, then let me tell you that this is the same process of how the solidity uses to store mappings and, you know, dynamic arrays. So if you have ever worked with, you know, solidity, then if you ever used mappings and all, then this is only how the mapping works. So you don't need to worry about that, you know, this might collide or something bad will happen.
00:30:27.796 - 00:31:27.866, Speaker A: Right. And, you know, so since the diamond storage standard, you know, complexity requires a bit of setup and all this stuff, so, you know, it is little hard. And there are basically, you know, two stories that we are going to look into that we just saw like the diamond storage and also there is app storage. So we will look into that. If you don't understand anything out of this, then don't worry. After this, like just before this, just after this, we are going to go through the diamond file like the actual diamond patterns that are there there are examples, I've been going to give you examples and we will see there how are they going to hash a unique value to get a random storage slot, and how they are going to, you know, also call this delegate function and how the main smart contract, that is the main diamond soul file, you know, how where it is storing, like the address of like the other facets, you know, and there is a mapping between facet and function selectors. And what if the diamond soul file, like the main file is going to call the wrong function, right.
00:31:27.866 - 00:32:08.952, Speaker A: So this is all we will going to understand, right? Right. So let's move on to the GitHub section. So I am in the awesome diamonds GitHub wrapper. The link to this is in the description. Basically all this is, this consists of all the things that are available for the diamond pattern, which is the official website, the EIP 2535 link and all the website and the articles for learning, right? And also they have like tools which, which can help you while you are, you know, building, using the diamond proxy cat to pattern this loudput tool which I personally liked and which I personally use. There is also diamond scan, which is like great for, you know, interface for the diamond pattern. And then there is all these commands tools and I guess audit reports too.
00:32:08.952 - 00:32:30.452, Speaker A: There are also some projects that are using diamonds. There is a list of that. We will also go through like few of them. But yeah, here is the list. The link to this is in the description which you can check out. Now let's move forward to the pattern that I want code. So before moving on, there is already a repo by the IP author, which is a great read me, which I really love it.
00:32:30.452 - 00:33:26.332, Speaker A: Right? So he explains about the diamond pattern and right now there is like three implementation that are available right now, which is diamond one, diamond two and diamond three. So basically all these implementations are doing the same thing, right? But these three different, these three implementation have different benefits and, you know, huge disadvantages in terms of code complexity and some guest costs, right? And there is basically the breakdown and the differences between stream limitations, right? Based on the ratings high, medium and low and their relation to each other. So you can quickly check it out. But in this particular video, we will go through the diamond three and try to understand the code base of that. But hopefully if you understand one of them, it wouldn't be harder for you to understand others, right. Here is the link to all those. And also there is also the details of how the diamond one, two, three is implemented and what are the differences between them.
00:33:26.332 - 00:33:44.628, Speaker A: So you can check this repo. Again, the link to this is in the description. So you can check out. Now let's go to the diamond third, which is the main repo. Okay, so I am in the diamond three hard hat GitHub repo. So this one also has a great uni file. Again.
00:33:44.628 - 00:34:17.566, Speaker A: So according to the, according to the EIP author, what you can do is basically this is in template. So whenever you're trying to, you know, use the diamond proxy pattern for your, for your protocol, you can just directly clone this repo. And there are so many tests and everything here. So basically according to the files, like diamond Sol file, which is the main contract, could be used as it is. You don't need to even touch it. Also if you want, it can be a starting point and you can customize it. And also in the other file that is the lib, the diamond.
00:34:17.566 - 00:34:44.557, Speaker A: So library, which is the most useful library, I guess could also be used as it is to implement the diamond storage. It also shows how to diamond storage. So you know, these are things that are already there. And also it shows the code for calling the diamond functions which we might do after this. Okay, cool. So let's deep dive into the contracts which are the most useful and let me explain it to you what they're doing. Okay, so again, this is the modular structure.
00:34:44.557 - 00:35:16.859, Speaker A: Even any projects who utilizing the diamond proxy pattern will have almost the same structure. So which is a great thing. And now let's move to the diamond Sol file, which is the main contract files. If you remember, I already told you that the diamond sole file is the main file with which your application people, the users are going to interact with the application and then this going to delegate call to all those facets. So here you can also see there is a diamond sole file. There are all these facets. These are basically different, different functionalities that one can add.
00:35:16.859 - 00:35:47.094, Speaker A: There are some interfaces which we will go through later. And the library, which is the lib diamond Sol file, I have already opened it another tab which is very helpful. Okay, so let's go to the first file, which is the dying one Sol file which is going to the main file. Right. So here it is importing the library, library diamond one. So I've already opened it in this tab because it's like one of the important library. I guess if you understand this contract, these two contracts, most of your work is done and it's, I guess that is, those are only the most too complex.
00:35:47.094 - 00:36:16.234, Speaker A: Not too complex, but yeah, as compared to other contracts, those two are the main complex contracts, which you need to understand. Okay? So first thing that this contract is basically doing is, you know, initializing the constructor. Here we are providing the contract owner what was going to the owner of this constructor. And then eventually we are adding the, you know, diamond cut function, diamond cut facet. So we can, you know, add more facets to it. Let's not worry about this. We can talk about this later.
00:36:16.234 - 00:37:10.716, Speaker A: But. Yeah, let's, let's see, we can see that Lib diamond file as the library has been using, has been used a lot in this total file. So let's just first go to the Lib diamond file and let's see what is happening there, right. Why it is so much use, right? So in the Lib diamond soul file in the library, you can see that first thing that they are doing is basically they are, you know, hashing the random storage, basically random string to get a random storage, right? So this is what we just learned on the remix that it is very hard to, it is not, it is very complex to manage the state variable. So this is how they are doing is basically they are, you know, hashing, taking 32 bytes, catch a cache of a string to use as a diamond storage location so that you can use this storage location to share between two contracts. That is the diamond soul file. And also like the facets and.
00:37:10.716 - 00:37:43.508, Speaker A: All right, so this is what we just learned right now, right? Don't worry about the app storage. We will discuss app storage later, right? There was two types of storage. One was diamond storage. One was app storage, right? So that I told you. So we'll discuss app storage later. Okay, cool. Now again, the question rises in this diamond, diamond Sol file that how this file is going to, you know, know which facet to call, right? So for that we have, we have a struct that is facet address and position, right? Which contains, contains of address of the facet address.
00:37:43.508 - 00:39:07.288, Speaker A: And also like the function selector position. Also there is another struct as well, right? So in, in the Lib diamond sol file, what's next they're doing is basically there is a diamond storage function, right? And this storage function, basically what it is just initializing that diamond storage, that random slot to a position, okay? Basically initializing the data. Basically initializing the diamond storage that you can just call it that, okay? And even if you see in the diamond soul file, the first thing that, you know, here it is doing with this file is with this lines of code is basically initializing the diamond, initializing the diamond storage. So that we can use the, this is storage where all the facet data will be stored, right? So this is what is happening here and I hope you understand it now like what I explained it to you in the remix that it's hard to, you know, straight to, you know, manage the state variables. So this is how, you know, by indexing a random storage and initializing the diamond storage, we are using it to share between diamond and facet address. And here in this storage, the facet data will be stored. Okay, so again in this diamond soul file there is this fallback function.
00:39:07.288 - 00:40:17.264, Speaker A: Basically this is like the main function which, through which, you know, the diamond sold diamond Sol file is going to call another facets, right? So as I've already told you that this is the first thing it is doing is initializing the diamond storage. And then the next thing that is happening is basically we want to get facet from the function selector, right? So how, which, how the diamond soul file is going to know which, which facet to call, right? So there is, in the lib, diamond soul, there is already a mapping which is the select to facet and position which is, I think being called here. Yes, selector to facet and position. Selector to facet and position. So this is the main mapping that is, you know, being called here, right? So if you can see here, it is basically calling that mapping to find out the facet, which facet to call, you know, according to the function selector. So this is what is happening here. And then there is assembly code just to, you know, call that particular contract by, by copying the function selector and any arguments that has been passed to this particular contract while, you know, users are interacting with this particular file.
00:40:17.264 - 00:40:51.542, Speaker A: Right? So in the, in the assembly code, it is just executing it and, you know, passing out all the arguments that were passed to the, you know, by calling the diamond soul file. Okay, so this is what it is. And you know, it was a simple file. I hope so you understood what I was trying to, you know, explain it. This is like a simple file. And now let's move to other interfaces, right? Let's understand the I, diamond cut interface. You know, what it is trying to do here.
00:40:51.542 - 00:41:32.350, Speaker A: Okay, so as I told you, like, you know, what the diamond cut dot storage file is doing is basically whenever you want to add any new facet or you want to remove the facet or you want to replace a facet, this is what the diamond cut, you know, interface or diamond cut file is going to help us with. Okay? And if you go to the facet file, you will also see a diamond cut dot soul facet which is here, right? So this is like the main diamond cut facet, which is. Yeah, you know, also importing the interface, the diamond cut interface. Okay. Okay. So let's move to the interface which is diamond, diamond cut dot soul. Okay.
00:41:32.350 - 00:41:56.656, Speaker A: So here there is enum which is facet cut function which is like one. The first one that is zero, one is to add. Then the replace is one. And then remove is true. There is again a struct with facet card. And then again there is a diamond cut function which is basically you call when you want to add, remove or replace any facet. So simple as that.
00:41:56.656 - 00:42:48.660, Speaker A: And this is basically for the transparency towards the users and towards the community. So this is why you have to have event emitted according to the EIP standard. Now let's go and check out the facet. In the facets folder, there is a diamond cut facet sol file. So here you can check out again it is just implementing that diamond cut function which we just saw in the interface, right? And again implementing that function by, you know, calling some of the functions in the lib diamond sol file which you can check out. So if you go to the lambda sol file, these are the functions that it is calling, which is the enforce has contract code files, right? And then again this is also calling the diamond cut function here. So diamond cut function should be here somewhere which is being called, I guess, you know.
00:42:48.660 - 00:43:27.314, Speaker A: Yeah, there is a diamond cut event, right? This is being emitted here. There is also this function which is the diamond cut function, right? And yeah, this is being called like whenever you want to add a replace or something, right? It is going to check what it is doing. If it's like adding functions, right? This is being called and then it's again checks if the action is to replace. Again checks if the action is to remove. And if there is nothing, no action is selected. This is going to basically give, you give an error, right? So this is what it is happening. And then again there is for add functions, you can check out this add function like how a facet is going to be added here.
00:43:27.314 - 00:43:51.634, Speaker A: So again it is going to check the function selector. Dot length is not equals to zero, right? No selector in the facets to cut. Again, it's going to check whether that, you know, facet exists or not. Even while, you know, even by replacing, you have to check that the function like the facet exists or not. Even while removing, you know, this is the game. You have to check whether the facet exists or not. And again, like the same stuff is happening.
00:43:51.634 - 00:44:15.380, Speaker A: Initializing the storage, the diamond storage. And you know, again, just checking address zero and all the basic stuff, you know, I think if you know solidity, you will understand most of it. Right. And this is what it is. This is what, here it is happening. And again, there is a replace function that is going to replace and remove the old facet. Like replace the old facet.
00:44:15.380 - 00:45:05.586, Speaker A: And there is a remove function as well if you want to, you know, remove any of the facet. Okay, cool. So let's go again back to the diamond cut facet sol contract. I guess we've already looked everything into that. Now let's go back to the, basically the facet folder. Now the main stuff is also, so there is also another interface, which is the loop interface that you have to check out. So the loop interface is also like, so whenever you want to check stuff about your diamond pattern, like what are the facets that exist? What are the function facet functions? Lecture when you, wherever you want to get such kind of information, you go to the diamond loop file, right, which we've already discussed.
00:45:05.586 - 00:45:32.758, Speaker A: So again, there is an interface which you can check out. There is struct for facet, which contains facet address and the function selector. And again, these are few functions that one can call, like which is the facets, which gives all the addresses of the facets and therefore type byte function selector. And there is also gets all the function selectors supported by specific facet. Get all the function selector. And then this gets all the facet addresses used by the diamond. And again, this also facet address.
00:45:32.758 - 00:46:12.794, Speaker A: So let's go to the facet file and let's see how the diamond loop facet sol is implemented. So again, it is like importing the library and the interface, right? And then it is going to implement the facet function, which one has to implement by, while using the interface. So you know, it is just looping and checking all the facets. And it's going to return that facet function selector again from the storage. It is going to, you know, get us all the function selectors. Basically that is provided by a facet. Okay, again, facet address, it is being implemented, you know, just initialized through this time and storage.
00:46:12.794 - 00:46:52.002, Speaker A: Check out all the facet addresses. This is what it is going to return. Basically an array of all those facet addresses, right? And this is how a user can interact and, you know, get all this stuff. Okay, cool. So this is the diamond loop facet Sol file, right? Now, what's the most important stuff other than this, I guess we are all almost done. So one important thing that I want to tell about this file is like a big detail is that you know, the Lib diamond solfi solely uses internal functions, right. This adds like the byte code to our contract, like saving us from needing to use another delegate call.
00:46:52.002 - 00:47:13.710, Speaker A: So whenever you know the contracts are importing it, it is automatically adds the bytecode to all our contracts. Right. So basically it saves us from calling another delegate call. Right. Cool. So I guess that said, if there is anything else that is lapsed in this file, let me check. I guess we are all good.
00:47:13.710 - 00:47:47.194, Speaker A: We have understood all the stuff about this. I don't think so. It was like as tough as, as much as complex site. If you understand the basics of don't think so, it will be hard for you to understand it. Hopefully if you are new to solidity then this was a good session for you to understand stuff. And the last thing that I want to tell you guys is more on the difference between the app storage and diamond storage. So to understand the app storage pattern, I found this great blog, again link to this in the description.
00:47:47.194 - 00:48:37.702, Speaker A: Okay, so how does exactly the app storage works? App storage is like works a little bit differently. So what you have, what one have to do is basically, you know, create a solidity file that inside, inside, inside your file you create a struct. In the app store storage file you basically create a struct and you then place as many state variables as you wish inside that struct, including all the other structs. Right. And then the first thing you do inside York smart contract is initialized app storage, right. This is basically setting storage slot to zero, to the beginning of the struct. And this creates basically a readable shared state, I guess between the contracts, right.
00:48:37.702 - 00:49:24.824, Speaker A: And this is how like technically it works, right. It's the first thing only state variable fs its position. The contract is, you know, zero. That's what I just told. And then I guess this is all of it mostly. But again, you have to understand like an important note on app storage is that if you need to update your app storage after deployment, you have to make sure to add your new state variable at the end of the app storage to prevent any storage collisions, collisions, and personally, you know, most of the people prefer to use app storage over to dimension storage for organization, but board gets the job done. And it is also worth noting that, you know, diamond storage and app storage are not like exclusive.
00:49:24.824 - 00:50:21.858, Speaker A: Even if you're utilizing app storage to manage your state variables, you know, in the live lib diamond Sol file that we just showed, it's going to use diamond storage to manage the facet data that we just saw how it is initializing the storage to manage all the facet data and all right, so even if you use this, it's not like exclusive, right? You will, you are just using it to manage your state variables. So this is like simple and short and sweet, I guess blog, I will provide a link to this and you can check it out. This is good stuff. Cool. So I quickly wanted to give you an oversight of the projects that are utilizing the diamond proxy pattern, right? So there is one of the projects that is Av Gochi that is utilizing the diamond proxy pattern. You can literally share the liquid, literally. See there, see their documentation where they have mentioned that they are using diamond pattern, how it is using.
00:50:21.858 - 00:50:51.190, Speaker A: So once you go to their GitHub repo. So if you go to their contracts and go to our go China, you will see all the same, almost the same thing. See the facet folder and they have diamond under diamonds, which is fascinating. They have again in the same folder they have facets and libraries and for the diamond file, right. And then the same stuff here. Now if we go to another project that is utilizing the proxy pattern is my personal favorite is leafy. Right.
00:50:51.190 - 00:51:18.078, Speaker A: They have this in the documentation, you can say see their architecture, you know, they just, there's a leafy, that is the diamond soul file, main file. And there are facets that through which they are delegating this call to these facets. Okay. Right. So you can just quickly check out, let's go and quickly check out their code as well. So if you go to their contracts and if you go to there. So it's filed using foundry.
00:51:18.078 - 00:51:44.874, Speaker A: I guess so, yeah. Again, you know, they have the life diamond soul which is going to be the main pie. So you know it is almost the same. So we just literally checked the diamond soul file in the, I guess diamond three template here. So they're literally using the same stuff. They have this fallback function again, right? And there's like they're initializing the same with this in the constructor and there is this confluence, the fallback function that is literally doing the same stuff. Right.
00:51:44.874 - 00:52:10.564, Speaker A: So you know, it's not that tough to use and build using diamond proxy patterns. So I guess, you know, after this maybe you should check out one of the projects from the list that I just show you that are utilizing. Maybe you know, try to build your own project with this. Right. So that would be a really great thing. And if you are like beginner or so, it will be really great. It will be a great adding add to your resume first of all.
00:52:10.564 - 00:52:54.820, Speaker A: And then eventually you will learn along the way. So you know, this is a great thing. And they also have like addresses of all the deployments and stuff which we are not going through. Okay, so I guess this explains all this stuff about like these are few overview of the projects that are utilizing the diamond proxy pattern. So rather than actually creating a fully fledged project with diamond proxy pattern, I am just going to show you guys how you can deploy your smart contracts and how you can, you know, add your facets and you know, deploy the whole diamond project. If you want a specific full video with, you know, example of building a proper fully fledged project with diamond proxy pattern, let me know in the comment section. Type down there if you want.
00:52:54.820 - 00:53:40.344, Speaker A: I can create a separate 1 hour video by, you know, by just creating a project with diamond proxy pattern. But for now, I guess for this video, let's keep it short and I will just show you the basics of it. Okay, so what you specifically have to just do here is just clone the die, the diamond hard hat third implementation which is, you know, just what we just saw. And you know, we were just going through that. Right? So just clone that GitHub wrapper. Right? And after that, once you've cloned, let's actually, let's, let's do the NPM install first so that we can make sure that it is installed. And meanwhile we will also open in the so versus card.
00:53:40.344 - 00:54:11.856, Speaker A: Okay, so we are under versus code. Let's also do NPM install. Okay, so on the meanwhile it is getting installed, let's go towards the code. So we've already seen all the contracts and stuff. Right? So what the other stuff that we can see here is that there is already a script that is deployed or J's file which we are going to utilize. Right? And then there is also I guess tests that are ready. Right? You can, you know, check these tests.
00:54:11.856 - 00:54:27.160, Speaker A: We can also, you know, run those steps while checking and stuff. Right? So let's see if it, if it's getting installed. Yeah, so the, it is getting installed. So it's going to take a few time. Let's be patient. It's usually slow. Okay, so finally it has installed.
00:54:27.160 - 00:55:02.064, Speaker A: Now what we have to do is basically let's go to the deploy file first of all. So in the deploy js file there you will see the facets that are added here that are deployed. So right now, like the test facets are not added. So if you go to facet, there's test one facet and test two facet which are not added right now, which we can edit later. Right. So yeah, so let's go and just deploy all the diamond pattern and the main contract and all these facets. So just go and type in the terminal hard hat, run this script slash.
00:55:02.064 - 00:55:36.138, Speaker A: Cool. So we are trying to just deploy with our script that is deployed or JS and then we can also run test. Okay, so what we can see is basically there is the diamond loop facet and the ownership facet. Oh, before that there is actually the main contract and diamond cut facet that is deployed. The main diamond deployed and the diamond initialization. And then there is the diamond cut facet which is basically, you know, we are adding facets to the diamond contract. Right.
00:55:36.138 - 00:55:57.350, Speaker A: So yeah, this is what is happening. It's simple. We've already cut through it and I guess this is complete diamond cut, which I guess is the event that is emitted if I'm not wrong. Yeah, maybe I'm wrong, but yeah, hopefully this is the event that is emitted whenever you do a diamond cut transaction. Right. You basically want to add facets, remove facet and all that stuff that we just saw. Okay.
00:55:57.350 - 00:56:23.788, Speaker A: And now let's also test our, the tests that are already written. So let's check that. Oh, it's not the right command. Hard at. Cool. Yeah. So okay, all the tasks the test has successfully passed, you can go to the file and check all the tests if you want.
00:56:23.788 - 00:56:41.008, Speaker A: And now let's actually add the test faucet in here. Right. So all the faucets that was also. So whenever you're creating. Right. So whenever you are now you are using this template to create your own projects. This is where you have to add the faucet, the facets basically.
00:56:41.008 - 00:57:06.614, Speaker A: Right. So this is the facet, start adding. So here you can also just quickly the second facet, dot soul PI. All right, cool. So we can save it and then again we can deploy on the deploy command so that, you know, the new projects facets can get deployed. It's going to get give a error if I'm not wrong. Okay, test one, facet, dot soul not found.
00:57:06.614 - 00:57:30.090, Speaker A: Test run facet sold. Okay, what's the name of that? Test one, test two, I think. What is wrong here? Okay, okay, so I found, what was the error? I've just added dot soul here. I have to remove it. Okay, I saved the file and again, trying to run the deploy script. Hopefully it should deploy now. Okay, yep.
00:57:30.090 - 00:57:45.532, Speaker A: So it's giving few errors that the few contracts are already existing. So I don't think so we should see that error. But yeah, if you can see that other facet, like the test, one facet has been deployed successfully. Right. Which was our goal. We have added that. Cool.
00:57:45.532 - 00:58:29.822, Speaker A: So yeah, I mean, you know this is the deployed address for the test facets, right? And yeah, so this is how it works. And this is how, you know, you can utilize proxy pattern in your smart contracts and you know, you can build a project using that. Okay. So I hope so that you liked this video. And now let's move to Nick who is going to give us, he was going to share his experience writing the EIP and you know, if he has some security consideration and everything. So let's move over to the podcast and thank you by the way, for, you know, watching this and do subscribe to the channel. Let me know if you have any comments.
00:58:29.822 - 00:59:01.150, Speaker A: How was your experience? Share it with people on LinkedIn or Twitter. Just tag me if you are like building anything now after this with diamond proxy pattern, let me know and do tag me. I would love to retweet on Twitter and share it on LinkedIn. And do join the telegram channel too. There is a telegram channel in the description which you should join where I usually share all the hackathons, updates and all that stuff. So please join the Telegram group. Thank you so much for watching GM.
00:59:01.150 - 00:59:18.914, Speaker A: GM, everyone. We have Nick Vitas who is the author of the Diamond Pattern, that is vip 25 35. And Nick, welcome and thank you for joining us. Like maybe just give us a quick overview of when did you join the world and what was your background?
00:59:20.214 - 01:00:01.834, Speaker B: Yeah, sure. So my background is in software development. I did manufacturing programming software for manufacturing companies. I did website development. And in 2018 I got involved with Ethereum and solidity programming and started, and I got interested in the standards, token standards and start building stuff and building something around to the max contract size limitation. And so that kind of started the effort journey to finding good ways to solve that, which then resulted in EIP 25 35. And also I found out other usefulnesses of it as well.
01:00:01.834 - 01:00:09.014, Speaker B: It's useful for organizing, organizing code for large code bases, modulizing things and upgrading things like that.
01:00:10.114 - 01:00:20.974, Speaker A: Okay. Yeah, that's awesome. That's what my next question was actually like. What was the story behind EIP 25 35? So the main logic was regarding the size of the contract, right?
01:00:22.224 - 01:01:20.204, Speaker B: Yeah, yeah. So, yeah. So for, I was working on a project where I was a token based project and I needed all the token functionality to come from a single contract, single address. And so that became, that began the early efforts to solve that problem. And then later then when helping that and developing the diamond standard, I found that actually that the pattern provides a way, kind of a standardized way to organize smart contract code in general. And it became so, you know, it came, became nice to be able to have a lot of contract functionality at a single address rather than at other addresses. Just to have one outward facing smart contract address that clients and other contracts get all just talked to instead of having multiple addresses.
01:01:20.204 - 01:01:39.684, Speaker B: It became like also when I wanted to upgrade functionality, it could be fine grain upgrades so that I just need to replace one function or I just need add a little bit more functionality. I can just do that instead of replacing a whole entire contract.
01:01:41.304 - 01:02:06.440, Speaker A: Got it. And also like, so right now there are so many projects, right? So if someone wants to utilize the, my diamond pattern, when should they utilize? I guess, you know, proxy, proxy contracts comes with their own, you know, their own struggle with being complex and, you know, getting hacked. So when should a project actually utilize diamond patents? Do you have anything like any answer to that?
01:02:06.512 - 01:03:08.026, Speaker B: I mean one thing is it's a general purpose design or architecture. So like there could be different circumstances, different circumstances or situations where people might want to use it because it's for pretty general. But I'd say that very commonly when, when your smart contract functionality starts getting larger where it's not golf, smart contract functionality is not going to fit into a single contract. And then depending on your project, does it make sense to have two separate contracts with two different addresses? You know, that's, want to do that, that's fine. Or does it, is it? Or do you want, you know, you have those functionality and you want it to be one address, then that's right. There is a candidate for the, for the diamond. Another situation is where, let's say you're going to, you want to release your project, but you want your project to sort of grow over time based on user feedback.
01:03:08.026 - 01:03:40.394, Speaker B: What happens? You know, you want to add functionality over time based on, you know, kind of this organic feedback, feedback loop of your community. And in that case you'd want an incremental development and the diamond provides that with upgrades. You can, you know, add functionality over time in an organized, standardized way. So, so, you know, you like gains gamings. That's the example that uses it.
01:03:41.134 - 01:03:45.686, Speaker A: Yeah, go cheese contracts. Yeah, yeah.
01:03:45.710 - 01:04:02.114, Speaker B: So those, those are kind of common cases, you know, larger code base where you're going to be incremental development over time. Off the top of my head, like, those are two very common useful use cases for the dime. Say Brad, there's others. So yeah, yeah.
01:04:02.154 - 01:04:20.994, Speaker A: So now let's deep dive into more of security concerns. I think you have audited a lot of protocols that are utilizing the smart patterns, the diamond pattern. So what are the common bugs that you usually find, like while auditing the diamond pattern contracts? Anything that comes in your mind.
01:04:22.734 - 01:05:10.052, Speaker B: You know, just sort of what comes to my mind is just kind of basic things with the diamond. You have to handle your variable storage a certain way. You have to use, you know, diamond storage or this pattern called app storage, which is just another variation of diamond storage. And if you're going to use those, then you have to use those exclusively. Meaning like, and so I know sometimes people go, oh my, I do an upgrade and everything broke or it's not working. And the first thing I look for is, okay, did you define storage variables outside diamond storage or outside app storage? Are you inheriting a contract that defines storage variables outside these things? And that's very easy to use to look for. It's not like an obscure bug at all.
01:05:10.052 - 01:05:54.892, Speaker B: It's like very easy to check for. So that, that's an obvious one. Let's see. Okay, I've seen there's some rules on upgrading a diamond as far as your storage. Like with diamond storage or app storage. If you're going to upgrade and you're going to add new state variables, you can typically add new state variables to end of structs and, and you know, add functions that use these new state variables and that's fine. But there's a couple like edge cases that are documented where like if you have an inner struct, instruct inside a struct and you want to add a state variable to that struct.
01:05:54.892 - 01:06:26.962, Speaker B: Like that's a no go. Can't, you know, that's going to overwrite stuff. So anyways, there's, there's like I have a, I have a website that, you know, goes over like this kind of stuff. There's a blog post for rules for upgrading diamonds for storage. So I guess like thinking, but like specifically to the diamond, the main thing is storage that I see, I don't think there's something else so much. Right. You know, I don't know if you have any questions, but like that's, otherwise it's just like typical solidity type type things.
01:06:27.058 - 01:06:38.334, Speaker A: You know, make sure you're, will there be more changes to the diamond pattern? Are you like working on like there are diamond one, diamond two, diamond three templates, I guess. Are you working on diamond for right now or not really?
01:06:38.914 - 01:07:21.034, Speaker B: Uh, no. I mean, yeah, there's like three different reference implementations for diamonds and they're just, you know, ways to implement the same standard. I'm not working on any other, other ways. I mean, that, that just shows like, um, like, like diamonds. Uh, let's see, diamonds, like the diamond one is a more simple implementation. Like the code is easy to read, it stays out of assembly as much as it can. And diamond two is like the same implementation as diamond one, but it's more optimized jumping into assembly to do that.
01:07:21.034 - 01:08:26.652, Speaker B: And so the them and 3D is just implemented a bit different in case you want simpler loop functions, which are these introspecting functions. So like, and other people can implement it other ways. So there's like the standard is meant to be flexible and, but at the same time standardize the interface, meaning like the functions used and some aspects of it that make it so that tooling, general tooling can be made for diamonds, will work for all diamonds. And so interoperability is really one of the key aims of the standard is interoperability, so that you build this tool that can look at what's in a diamond and that tool will look at, will work for all diamonds. And or a tool that, that manipulates or looks at the events of a die of a diamond can now look at the history of upgrades for all diamonds, you know, because it's, it's this, the event or upgrades, you know, tracking what has changed is standardized. So that, yeah, I mean, yeah, I've.
01:08:26.668 - 01:09:11.343, Speaker A: Saw that there are like hard aid templates, I guess, for the devs watching. I guess this is a great idea, great opportunity for you to go and create foundry templates, I guess, for all these diamond one, diamond two and diamond three. Right. And yeah, I do have like few general questions too. Do you have any advice for developers right now? Like people who are, you know, building smart contracts, how it's like since you have been into this industry for a while now, been coding smart contracts, doing something right, doing building a lot of projects, working as a senior engineer. So do you have any advice for developers maybe who are just starting to get learning, getting into smart contracts or maybe people who are already working with one or one year of experience with smart contracts developers? Do you have any advice for them?
01:09:12.963 - 01:10:11.124, Speaker B: I'd say some general advice. Do whatever you can to increase your understanding of solidity the EVM don't like. I feel the importance of understanding solidity and BVM, it's more important to understand that how the code works. You do like when you're working with some solidity project that you understand how it works. It's more important than other kinds of software, like a website or some other user interface software because like, you know, depending on that, but like you have a user interface error or something or bug, and it's like it can cause some momentary problems, but it's not likely going to lose, cause a loss of millions of dollars. Just do what you can to really understand solidity, the EVM and the code. Don't just copy and paste solidity code and use it in your project.
01:10:11.124 - 01:10:44.888, Speaker B: You know, there are some kind of more trusted sources, like open zeppelin stuff. But even then I would, you know, take, take care to try to understand what you're working with. Understand delegate call because, you know, diamonds, just so you understand delegate call how it works. Then understanding how the diamond pattern works a lot easier because that's like the heartbeat of it is the heart of it. And just, you know, practice stuff, like make stuff get familiar. Um, get good at debugging.
01:10:45.016 - 01:11:10.570, Speaker A: Uh, yeah, that's a good, yeah. Uh, cool. And what are you like bullish on right now? I mean, right now. So me as a developer, I see a lot of things right now coming into this web3 space. Right there is ZK and there is AI. Right? And then there is fat g sometimes. And there is everything there every time, every day when I open Twitter, there's a new buzzword.
01:11:10.570 - 01:11:22.374, Speaker A: So as a developer, how do I make sure that I am keeping up with stuff? And also, what are you bullish on right now? Are you exploring anything, AI, ZK or something like that?
01:11:23.074 - 01:12:13.868, Speaker B: No, I'm not right now, really. I'm just paying attention to what I see. Developers talking on Twitter and kind of seeing how things are evolving. I don't really particularly have a preference on things right now, like on what's on bullish on or more. I like to see these things where like these blockchains and L2s that are relying on the EBM because the nice smart contract stuff will work across the diamond stuff works like, works on so many chains because it's supported by the EDM. So I guess I'm just kind of bullish. You know, I'm just really kind of now getting old school and just being interested in solidity and EVM, smart based, smart contracts and of course, the Dax.
01:12:13.868 - 01:12:14.904, Speaker B: I'm really.
01:12:19.844 - 01:12:29.734, Speaker A: Yeah, I guess that was the answer. I'm bullish on EVM yeah, that's something that people need to be bullish on. Good. Awesome. So thank you so much, Nick.
01:12:29.854 - 01:12:50.394, Speaker B: It seems like EDM, you know, solidity is like how JavaScript is just like so universal for the web. It's like the solidity is kind of taken over for these blockchains. I mean, some of the blockchains use other stuff, but it's just so prevalent and I just see that continuing.
01:12:51.134 - 01:13:08.814, Speaker A: Yeah, absolutely. Even there is a great ecosystem. I see all these security researchers. I mean, I mean, this will take years for other blockchains to get this like all the security researchers, all these bug bounty programs, thousands of bug bounties and everything. Yeah, it's just so crazy. Cool. Awesome.
01:13:08.814 - 01:13:18.074, Speaker A: Then thank you so much, Nick, for joining and giving a short session. It was really helpful and, you know, great having you there. Thank you.
01:13:18.374 - 01:13:18.854, Speaker B: Hey, thanks.
