00:00:10.330 - 00:00:41.690, Speaker A: Hi, everyone, and welcome again to the system. Now, this is a series created by avalabs for developers, engineers and product builders, and anyone interested in learning about the latest research and technology technological advancements in blockchain. And today we are joined again by Kushal. I think he's the first returning guest. Kushal is a PhD candidate at Cornell Tech, and today he will present some of his consensus research. So thank you very much for joining us again today, Kushal, and the stage is yours.
00:00:42.190 - 00:01:08.142, Speaker B: Yeah, thanks for having me, Martin. Let me share my screen and we can get started. All right. Can you see my screen? Yes. Great. So, hi, everyone. I'll be presenting our work on this new DAG based consensus protocol called Mysticity.
00:01:08.142 - 00:02:15.974, Speaker B: This is joint work with my collaborators at Mist and labs. So the setting for this work is BFT consensus, where we are operating in partially synchronous network, so formally defined. These networks basically are not well behaved until a certain point, which is GST global stabilization time. And after that you have some bounds on how long the packets will take to deliver. And of course, we have the standard assumptions that you have f faulty nodes and you have at least three f plus one processors, or in other words, you have less than n by three nodes that are byzantine. What we want from our protocol is the first is the safety guarantee, that is, all honest nodes should commit a consistent sequence of transactions, or a consistent sequence of blocks, because you can then sequence the transactions based on these blocks. A slight difference here is that we will only work with consistent sequence of some blocks, and then we can actually derive the consistent sequence of all the blocks by looking at the causal history of the committed anchor point, so to say.
00:02:15.974 - 00:03:21.270, Speaker B: And then we of course need lightness, which is that after the network is stabilized, we want that an honest, needless leader's proposal should eventually be committed. Now, besides these consensus protocols, there is also a fast path in mrcity. So this fast path is actually a consensus list path. And the insight behind this is this insight is not unique to this work. There has been some prior work on this direction, which is falling from FastPay, Zeph and so on, which makes this insight that you don't need all transactions to actually undergo consensus. So transactions that do not have any input that is kind of shared by multiple users, you really can actually work with much less expensive primitive than consensus. So, for example, if you have cryptocurrency payments, where the input is just maybe in most cases, like one user who's authorizing the payment, then you really don't need consensus, but you can actually do something like consistent broadcast to actually prevent any equivocation which violates safety.
00:03:21.270 - 00:04:10.550, Speaker B: Now, if a user actually does equivocate, then in these protocols, actually the transaction would just not have liveness in the sense that the transaction would not commit. And so in our protocols, we actually also take care of this equivocation by actually leveraging consensus to unlock, so to say, transactions that are actually stuck because of equivocation. So Mr. City combines these consensus path as well as consensusless path. Now, the combination of these, I'll talk towards the end, but majority of the presentation would basically be focused around just explaining the consensus protocol. All right, so Mystery city C, as we call, is the consensus part of our protocol, mystery CDC. It has a baseline version, and then I'll introduce how we can have pipelining in this version.
00:04:10.550 - 00:04:53.670, Speaker B: And then I'll also introduce something called multi leaders, which makes the protocol more robust. And then, as I mentioned, there is a fast path in the protocol. So when you combine Mr. CDC, any of these variants, with a fast path which is based on consistent broadcast, then we have a protocol which we call Mississippi FPC, which is Fastpath and consensus. And finally, as I mentioned, we can actually unlock the fastpath transactions using consensus mechanism. And also we have nice epoch close mechanisms because these are actually important, especially in this case because you don't really have just one consensus path here, right? You have two paths here. So one is the fast path and one is the consensus path.
00:04:53.670 - 00:05:55.242, Speaker B: Now, if there was only one consensus path, then in some sense closing the epoch and starting a new epoch is kind of trivial. But because you have these two paths, the epoch close also becomes a little bit tricky. I'll not go into the details of it, but you can have a look at the paper if you're interested in how epoch close works. All right, so talking a little bit about related work in the category of DAG based protocols, you have protocols such as Dag Rider, Nawal Bullshark, which are the original pioneers of this class of work. Now, in these protocols, what you have is basically every block undergoes a reliable broadcast, which is to say, when you are building a dag, you're not really building a dag on the kind of raw blocks as such, but you're actually building a dag on the certificates that you obtain from reliable broadcast. So in some sense, even before you're building the dag, you are actually incurring a penalty of one round trip to actually get this certificate from the reliable broadcast. Whereas in mysticity, we actually let go of this reliable broadcast.
00:05:55.242 - 00:06:29.490, Speaker B: And we try to build a dag which is directly built on the raw blocks. So, in some sense, you kind of gain from actually not making this round trip to have the reliable broadcast of your block. And so, as we'll see, we'll build Dag directly based on raw blocks from the validators. All right, so now let's dive into the details of the consensus protocol. This is a very high level overview of what the dag looks like. So, if you notice, there are some structures in this dag. The first is the structure of waves.
00:06:29.490 - 00:06:54.918, Speaker B: So I'll talk a little bit about waves, and then I'll talk about how you can actually get rid of them when you actually do pipelining. But basically, every wave is consisting of three rounds. In this case, wave one is round one, two, three, and so on. Wave two and wave three. Right? So, in the first round of any wave, the validators actually propose a block. So each validator actually proposes a block. So n one, n two, n three, n four validators are proposing a block.
00:06:54.918 - 00:07:35.754, Speaker B: So, this is one view, according to an observer, which notices that, okay, in first round, the following blocks have been proposed. Then the next blocks actually reference these blocks from the previous round. And the second round of the wave is actually the support round. Now, the structure of the dag actually follows this property, called threshold logical clocks, which means that you can't really just produce a new block in the next round without actually getting at least two f plus one blocks from the previous round. So if you'll actually notice, every block in this dag actually references at least two f plus one blocks from the previous round. So that's the criteria for at least one of the criterias for a valid block.
00:07:35.882 - 00:07:36.366, Speaker C: Right?
00:07:36.468 - 00:08:01.314, Speaker B: So, in this case, for example, this particular block is referencing two f plus one. That is three blocks in this dag. Right? So these are the waves. And every block is referencing enough quorum of blocks from the previous round. And so you have the first round as proposed second round as support. And the third round is what we call a certify round. So this is the basic structure of the dag.
00:08:01.314 - 00:08:42.210, Speaker B: Now, what I want to do is actually introduce the consensus protocol by actually building this dag bit by bit. So let's consider the first round, which is the proposed round. In this round, you have, suppose a leader, which is the n one. In this case, the leader proposes the l one block in the first round, right? So in the next round, when other validators actually propose their blocks, some of them would actually reference this block in their blocks. Right. So in this case, n one, n two, and n three are actually producing blocks that are in some sense supporting the block from n one, which is the leader one block. L one block.
00:08:42.210 - 00:09:32.072, Speaker B: Now, for whatever reason, the block from n four is actually not supporting l one. So blocks that are actually having these backlinks to the previous round are the supporting blocks. And as I mentioned, every block must link to at least two f plus one blocks from the previous round. So even if n four is actually not supporting l one, it at least supports three blocks, which is n two, n three, and l four. Any questions so far, by the way? Okay, then I'll keep going. All right, so this is the definition of what it means to have one block support another block, right? And in the third round, we have. Third round is the certifying round, where a block will actually certify another block.
00:09:32.072 - 00:10:21.176, Speaker B: So in this case, this block is certifying the l one block if it actually references two f plus one supporting blocks. So in this case, the blue blocks are actually the supporting blocks, right? Because they are referencing the l one block. And the green block is actually a certifying block for l one because it's actually including two f plus one support for l one. Right. So if a block is actually referencing enough quorum of supporting blocks, then you actually say that, yes, this block is actually certifying l one. Right. The rule that we have for committing blocks is basically, if you have enough certifying blocks, if you have two f plus one certifying blocks, in this case, three certifying blocks.
00:10:21.176 - 00:11:22.604, Speaker B: Right? The three green blocks, all of them are actually certifying blocks because all of them are actually including enough supporting blocks in their references. So the first block here is actually including these three blocks as supporting blocks for l one. The second green block is also including three supporting blocks for l one and so on. So all these three are actually certifying blocks. And so if you observe two f plus one certifying blocks, then you can actually directly commit l one. So in some sense, we have this strong non equivocation property from all this, because for whatever reason, if n one actually tried to produce equivocating blocks, so send one block like l one, to one set of validators and an equivocating block to another set of validators, then you can actually see from quorum intersection, you'll not have enough certifying blocks for l one. In some sense, there'll be no equivocation.
00:11:22.604 - 00:12:09.644, Speaker B: In the realm of certificates, you'll never have two conflicting blocks acquiring enough certificates for them, or maybe two equivocating blocks, acquiring certificate for each of them. So certificate is this very consistent world, whereas blocks can be equivocated. So this is the direct commit rule. And, of course, you can have a direct skip rule, as we call it, which is that you can actually decide that, yes, l one will never be committed if there are enough blocks that do not support it. Right. So in this case, there are two f plus one blocks, the red blocks, which do not support l one. So you can actually be sure that, yes, in any other view, l one will never get enough support to be committed.
00:12:09.644 - 00:13:07.040, Speaker B: And so in that case, you can actually directly decide to skip this block. So you have these direct commits and direct skip rules. And now the question is, what happens if you have neither enough support and neither enough blames in some sense? So here you don't have two f plus one blocks that are actually supporting and two f plus one blocks that are actually certifying this block. So you can't really directly commit, but you also don't have two f plus one blocks that are actually not supporting it. So in some sense, you really can't make a decision whether you directly want to commit this or you actually directly want to skip this. So there might be other views where this block might be potentially committed, or there might be other views where this block might be potentially skipped. So, in that sense, we need more information to actually make a decision on this block.
00:13:07.040 - 00:13:09.170, Speaker B: Is that clear, by the way?
00:13:10.740 - 00:13:21.492, Speaker A: Yeah, I think I'd have two questions. So, meaning that we certify them, the blocks from round one and round three means we can only execute the transactions in round three.
00:13:21.546 - 00:13:21.764, Speaker B: Right.
00:13:21.802 - 00:13:29.450, Speaker A: Because before, we don't know which of the round one blocks would be certified and actually included in the chain. Right.
00:13:30.380 - 00:13:38.092, Speaker B: Sorry, Martin, can you repeat your question? I think my screen was. Yeah. Can you repeat your question? Yes.
00:13:38.146 - 00:13:40.108, Speaker A: Can you hear me now? Is that better?
00:13:40.194 - 00:13:41.470, Speaker B: Yeah, this is fine.
00:13:42.320 - 00:13:49.504, Speaker A: So the transactions in l one, they will only be executed after they've been certified in round three.
00:13:49.542 - 00:13:49.744, Speaker B: Right.
00:13:49.782 - 00:13:59.644, Speaker A: So we don't know which blocks are actually. So we kind of have a delay between block proposal and block execution. Is that correct?
00:13:59.782 - 00:14:24.920, Speaker B: Yeah, that's exactly right. So you basically take, in some sense, three message delays to actually commit a block. There's one message delay here in this round, then this round, and then you actually have another message delay to actually observe that, yes, there are two f plus one certifying blocks. So there's actually a three delta delay before you actually can at least the three delta delay before you can actually commit a block.
00:14:25.340 - 00:14:37.020, Speaker A: And is it per round? There's only a single block committed? Or could there, because we see like there are different blocks in round one. Or could there be also actual multiple blocks committed per round?
00:14:37.600 - 00:14:54.352, Speaker B: Right. That's an excellent question. I'll talk about that in the multireter, kind of like feature of the protocol. So that will come up down the line. Yeah. All right. So these are the rules for directly committing and directly skipping.
00:14:54.352 - 00:15:28.272, Speaker B: And now we need to make decision on this particular undecided case. Right. And so you have this. Suppose the DAg progresses and you are able to actually commit the l two block here. So the l two block is actually committed because you have, again, enough certifying blocks. So each of these green blocks are actually certifying for l two because each of them include enough supporting blocks for l two. So once you have two f plus one certifying blocks for l two, you can actually directly commit l two.
00:15:28.272 - 00:16:09.932, Speaker B: And so now the question is, okay, in the second wave, we have actually committed this proposal leader two, but we can't really actually directly commit it. Right. We know it will definitely be committed, but because we want a consistent sequence of blocks, we need to first make a decision on l one. Right. And so the property that we have here is when you have actually a directly committed block, if the directly committed block actually includes a certifying block for l one in its history, then you can actually first directly commit l one. Then you can actually indirectly commit l one and then commit l two. So let me show you what that means.
00:16:09.932 - 00:16:49.370, Speaker B: So in this case, you have this particular block, which is actually a certifying block for l one. Right, as we saw. And this certifying block or the certificate for l one is actually appearing in the history of this block that is definitely going to be committed. So in some sense, all the views, that is every observer that's observing this graph, that observer we know, will commit l two. And we know that there is a certificate for l one in the history of l two. So what that means is every observer will actually observe that, yes, this is the right block to commit in round one. And so it makes sense to first commit l one and then commit l two.
00:16:49.370 - 00:17:48.030, Speaker B: And so this indirect commit rule actually relies on this very core lemma that we have, which is that if you actually have two f plus one distinct authorities that certify a block, then in some sense, any block that you commit in the future will actually have a certificate for l one. So you have this intuitive property that is the supporting round is actually giving you non equivocation for this block. Right. But the enough certificates in the future are actually giving you durability in some sense. So if you have a directly committed block that's referencing a certificate, then you are actually going to be sure that, yes, this block is going to be durable for all the rounds to come. And so you can actually indirectly commit this block. Does that make sense?
00:17:51.040 - 00:17:51.740, Speaker A: Yes.
00:17:51.890 - 00:18:29.130, Speaker B: All right. So this is the indirect commit rule. And yes, of course, if you don't have a certificate in the history of l two, then you know that no other view will actually observe a certificate for l one in the history of l two. Right. Because l two is directly committed by everyone, then you can safely skip l one. So what that means is actually, if you are committing this block, l two here, and this l two has no certificate in its history for l one. So this certifying block is actually not really linked to l two, then you can actually decide to skip l one and directly commit l two.
00:18:29.130 - 00:19:28.340, Speaker B: So in some sense you are piggybacking the decision for l one on a future committed block. So these rules complete in some sense, the basic rules for the consensus protocol. So you have the direct commit rule and you have the direct skip rules and you have the indirect commit and the indirect skip rules. So once we have this baseline version, you can think that we just discussed that you are actually committing every block only after three message delays, right? So in some sense you are only committing in round one, round four, round seven and so on. And so the next feature of the protocol is actually you can pipeline these commits. So we don't need to actually only commit in round one, round four, but we can actually have pipeline waves. So we can also have proposals in round two, round five and so on.
00:19:28.340 - 00:20:05.060, Speaker B: So the round one proposal is actually being committed after round three. The round two proposal will be committed after round four. Right. And so on. So you have these superposed waves that are actually pipelined one after the other. I'll talk about what happens if you have one wave that is kind of like stalling the pipeline, right, because that's the main problem in pipelining. But on a high level, the naive intuition is that you can actually have these pipeline waves and you can commit a proposal in every round and you can also have a third wave.
00:20:05.060 - 00:21:05.000, Speaker B: So now you are actually committing proposals in the ideal conditions where there's not much equivocation and so on, you're actually committing every round. And so how leaders of a round are decided is basically any deterministic protocol. So you can do that using proof of stake or anything like that. But basically, for the sake of this protocol description, we assume that you already have a sequence of leaders in each round. In this case, you can see that it's like round robin, right? So you have l one, l two, l three, l four, which is coming from node 1234, and so on. So you can have any deterministic sequence, and then you can commit every round using pipelining. The next one is, can we go further and actually have multiple leaders in each proposal round? So here you will see that in the proposal rounds, round one and round four, we now not only have one leader, but we actually have multiple leaders.
00:21:05.000 - 00:21:49.220, Speaker B: So, in this case, in round one, the node one is actually the primary leader, and the node two is actually the secondary leader. And so what that means is, well, if you can actually commit this leader one, that's good. But if you can actually directly skip this leader one, right? So, for whatever reason, this leader one has crashed. This leader one crashed and did not publish its block and did not get enough support in round two. So you can actually know that you can directly skip leader one. In that case, we don't have to wait for three rounds and then have another proposal. All of us actually know that, yes, this leader one will be skipped, and so we can actually directly fall back to a second backup leader.
00:21:49.220 - 00:22:36.516, Speaker B: So, in this case, for whatever reason, l one crashed. And you know that you can directly skip this. Right? So then you can actually directly fall back to the backup leader. And you can actually try committing this leader, which is node two. I'd like to clarify that when you have actually byzantine settings where you have equivocating blocks and so on, this backup leader won't give you any kind of theoretical optimizations. But in cases where you have crash faults, not byzantine faults, when you have crash faults where you can actually decide that, yes, it's safe to skip this primary leader, then you can actually directly fall back to the secondary leader and so on. And so we don't have to limit ourselves to just one backup leader.
00:22:36.516 - 00:23:25.368, Speaker B: We can actually have multiple leaders, and we can have pipelining and multiple leaders going on at the same time. And in the limit, you can actually have multiple backup leaders. And each block in a proposal round can serve as a backup leader, and we can have a deterministic ranking of these. So, in this case, yes, there's a ranking where l one is the primary one, l one a is the backup one, l two a is the backup one, l two is the primary one and so on. And if we have more multileters, we can actually have total order on them. All right. Is there a question?
00:23:25.534 - 00:23:27.930, Speaker A: Yeah, I think Patrick, he can't see your hand.
00:23:29.260 - 00:24:13.860, Speaker C: Hey, good to see you again. I guess the question I had on this slide, just to kind of align on the insight, the idea is if everyone's producing these, what do you guys call them? I guess in each round, like, what are these blobs called? Let's call them blobs. I guess you basically just produce blobs with whatever, you know, in terms of referencing some set of earlier blobs, and then you just don't worry about it, send that to everybody else, and then after the fact, kind of decide who the leaders were and then from there determine the ordering. Once you get so many rounds in the future, is that, I guess, ultimate goal of the design of this in terms of how you're pipelining and do multileter.
00:24:14.200 - 00:24:46.480, Speaker B: Right. And the leaders, in some sense, do not have to be decided after the fact. Leaders can already be decided before, so we can already decide that. Look, in round one, because this is a permission setting where you know that these are the set of participants. You can actually already say, in this round, this guy will be the leader. In next round, this guy will be the leader, and so on. So you can already have a deterministic, and if someone fails to propose, then you can actually say, okay, there was no proposal in this round from this leader.
00:24:46.900 - 00:25:00.660, Speaker C: I guess as someone producing in round two, you're waiting to hear something from a leader in round one to make sure you reference that in your chunk in round two. Is that the idea of knowing who the leaders are ahead of time?
00:25:00.810 - 00:25:45.540, Speaker B: Yeah, that's exactly right. So one trade off for this design is if you compare the theoretical latency compared to Bullshark or other protocols. Mississippi City has a lower latency, which is three delta, as I mentioned, where you only need to wait for three message delays in the ideal conditions. But the trade off for that is basically you actually have to wait in every round. You can't progress as soon as you hear about all the non leader blocks. So in this case, in round two, if you don't hear from n one, you actually have to wait for your timeout. Or if you receive the block, you can't directly produce a new block without hearing from the leader of the previous round.
00:25:47.080 - 00:25:48.340, Speaker C: Excellent clarification.
00:25:48.840 - 00:26:04.810, Speaker B: Yeah. In this case, just to clarify a little bit more, in this case, if you don't hear from n one about the l one block, then you should not produce a new block just referencing the rest of the blocks. That's the idea for waiting. Yeah.
00:26:05.500 - 00:26:22.530, Speaker D: So it does not move forward as soon as it gets two f plus one responses. So if, for example, n one is the leader and n two receives responses from basically itself in three and n four, it still has to wait for n one to send it a message. What's the reason for that?
00:26:23.540 - 00:27:11.984, Speaker B: The reason is just like what Patrick was mentioning. If you don't wait and you just keep producing blocks, in some sense, you don't have liveness in your protocol. It's not needed for safety, but for liveness, you actually need to wait for a leader's proposal. Otherwise, if you just progress based on other people's blocks, then you'll just keep expanding your dag and never commit an honest leader's proposal. So this leader is honest, it's not equivocating, but its block is slow to reach other people. So in that sense, if you don't wait for this validator, then despite this validator being honest, its block will not commit. I see.
00:27:12.022 - 00:27:32.564, Speaker D: Okay, that makes sense. One other question I had. When you say that the backup leader only helps you if you have a non equivocating leader, is that just because in order to move on to the backup leader, you require to skip the original leader via the indirect skip rule, is that correct?
00:27:32.682 - 00:28:20.180, Speaker B: Exactly right. So as I mentioned, even in the indirect commit rule, in some sense, there's kind of like a total order on all these blocks. Whereas we are saying, okay, we'll first decide on things that have come before, and then we'll decide on things that have come after. Right. Because if we leave something undecided that has come before and we are trying to commit the later things, then you can have inconsistent sequences. In that sense, if you have an equivocating leader, primary leader, and you're not able to decide because it's equivocating, you should not really make any decision of committing or skipping the backup leader. Because if you make a decision to commit the backup leader, when you have not made a decision on the primary leader, other people might actually be committing the primary leader.
00:28:20.920 - 00:28:21.828, Speaker D: That makes sense.
00:28:21.914 - 00:28:44.044, Speaker B: You need a consistent sequence. In that sense, you need to really wait for the sequence that you have decided beforehand. So in this case, the sequence that we have decided beforehand is, well, all of us will try to make decision in the following order. L one, l one, a, l two, l two a, l three, l three, a, l four, l four a and so on. Cool.
00:28:44.082 - 00:28:44.732, Speaker D: That makes sense.
00:28:44.786 - 00:29:18.804, Speaker B: Thanks. All right? Yeah. These questions are great. And these are also very helpful because I have an exercise for all of us to try to decide the status of each block towards the end of the presentation. All right? So just to recap, we have direct decision rules where you are directly committing. If in round r plus two, you actually observe a quorum of certificates. So here you have three certificates, you're directly committing, and you can directly skip if you know that there are enough blocks that do not support this block.
00:29:18.804 - 00:29:55.248, Speaker B: And you leave it undecided otherwise, to be decided by the indirect rule. And so the indirect rule says that, look, we need to first find a block after round r plus two. So, first block here means first block in the sequence that we've determined, right? The sequence that we had determined was l one, l one a, l two, l two a, and so on, right? So everybody needs to agree on the sequence beforehand. That is a deterministic sequence. And so, in this case, for this particular block, the first block after round r plus two is. Suppose this one, right? Based on the status of this block. If this block is actually committed.
00:29:55.248 - 00:30:14.184, Speaker B: Then you can actually make a decision on this block. If this block is actually not committed. And if this block is undecided. Then in some sense that you have to actually wait for this block to be decided. And if this block is actually skipped. Then you can move on to the next block. And decide the status of this block based on the next one.
00:30:14.184 - 00:30:33.952, Speaker B: So, suppose in this round, the ordering was this block after this block. Sorry, this block before. This block before this block. Then, yes, this block is actually used for deciding the status of this one. If it's committed, then, yes, that's good. You can decide through the indirect decision rule. If it's skipped, then you can actually go to the next one.
00:30:33.952 - 00:31:14.680, Speaker B: And decide the status of this one based on that block and so on. And if this is undecided, then in some sense, you have to actually wait for the status of this block to be clear before you are deciding this one. Right? So this particular rule, if we put it in this way, it's certainly getting rid of all the waves and pipelining. Where now I'm saying, okay, let's forget about waves and pipelinings. Let's just work with the first block that comes after round r plus two. That is committed or undecided. So what that means is, look, we don't need to actually work in the same wave.
00:31:14.680 - 00:32:05.356, Speaker B: So if round four was actually part of the round one wave, right? So in this case, we saw that round four was part of the round one wave, the orange wave, I don't really need to actually now just work within the waves. Because if this wave stalls, the orange wave stalls, then everything else stalls, the green wave stalls, the blue wave stalls, and so on. And so the nice insight here is, actually, now we can break the barriers of this wave structure, and we can actually directly work with the first block that comes after the decision round. So this is the decision round for this r one block. Right? So the first block that comes after this can decide this. Well, if all these three are actually skipped, then I don't need to wait for the next round in this way, which is round seven. I can actually directly decide the status of this one based on round five.
00:32:05.356 - 00:32:54.460, Speaker B: So, in some sense, we are optimizing by going across waves now we don't really have to stick to the same wave. So if you have actually already decided the status of all the blocks after this round, r plus two, you are actually good to break the structure of wave. All right, so this will become more clear when we do this exercise. So in this case, yes, you have this directly committed block, right? This block has a certificate for the block in question. This block has certificate. So in some sense, you can actually directly, based on this block's commitment, you can actually commit this block as well, first. All right, so this is the indirect decision rule.
00:32:54.460 - 00:33:35.304, Speaker B: So let's now work through an exercise so that the consensus protocol is more clear. So we have this set of blocks in the following dag. And we have already decided on the sequence of these blocks, right? So we know that the sequence in which we need to decide are l one a l one b. L one c. L. Let's decide the status of each one, going from the last to the first. All right, so all of these are initially undecided, and now let's try to decide each one of them from the last one.
00:33:35.304 - 00:34:18.264, Speaker B: So we can't really decide on any of the blocks in round five and six, right? Because, as we said, we need to wait for at least three message delays, so we need to wait for at least r plus two round. So in that case, yes. We don't know whether these blocks would be committed or whether these blocks would be skipped. So these are incomplete waves in some sense. And these blocks will be undecided as of now. Now, let's go from last to first. Right? So L has enough certificates for it, and so we can actually directly commit L.
00:34:18.264 - 00:34:45.040, Speaker B: Let's go to L four C. L four C is similar where it has enough certificates. And so does L four B? So in some sense, yes, we have directly decided to commit. We have decided to commit L. We are not really outputting them just now, just yet, because we really need to decide on the previous blocks first. Only then we can actually output these. But we know that, yes, they will be committed sooner or later, or they will be output.
00:34:46.180 - 00:35:05.050, Speaker A: Are we starting with we have kind of like that if a or any blocks previous or more higher up are committed after or before, because we're moving from the back. So the order of these blocks would be l four B, l four C, and then L 4D.
00:35:05.420 - 00:35:19.644, Speaker B: Exactly. That's exactly right. So when you output these, you will actually output BCD. But we are deciding from last to first. Right. In this case, suppose L four A is skipped. Right.
00:35:19.644 - 00:35:54.932, Speaker B: So you now know that. Okay, I'll have to skip l four A and then output BCD directly. Okay. Right. So l four A is skipped because we know that there are enough blocks that do not support it. So there can never be a quorum of blocks that support it, which means it's safe to skip l four A. All right, so what about L has enough certificates for it in round r plus two, so we can actually commit this.
00:35:54.932 - 00:36:42.916, Speaker B: L. Well, directly commit L 3D. Similarly L three C, so you have enough support for it in the round r plus one, and then you have enough certificates for it in round r plus two and so on for l three B as well. Okay, now what about L also has enough certificates for a direct commit. So it has at least two f plus one certificates here in round r plus two. So you can actually commit L. Well, what about l two C? Well, L two C doesn't have enough blocks that actually support it.
00:36:42.916 - 00:37:14.370, Speaker B: There are only two blocks. There are not two f plus one blocks. There are not three blocks that support it. And there are also not three blocks that actually, in some sense, blame it or do not support it. So we really can directly decide to skip or commit this block. So now what we have to do is actually go to the first block after round r plus two. So the first block after round r plus two is actually this block, l five a for l two C.
00:37:14.370 - 00:37:56.588, Speaker B: But we know that l five a is actually undecided. This block can actually be, in future directly committed or skipped or whatever. So because we don't know the status of l five a, which is the first block after round r plus two, what that means is basically, in all the other views, we don't know whether they'll commit this or skip this. And so we should not base our decision for l two C based on this. And really we have no choice but to leave it undecided. So in this case, actually, l two C will be just left undecided. Does that make sense? Yes.
00:37:56.588 - 00:38:19.700, Speaker B: Okay. Coming to l two B, it's the same story where it doesn't have enough blames or enough support. And so we again have to look at the first block after round r plus two. That block is again undecided. And so you leave l two B also undecided. L two a can be directly committed. So we can actually say, okay, l two a will be committed.
00:38:19.700 - 00:39:02.368, Speaker B: Right? So now we have made these decisions up to round for all blocks in and after round two coming to round one. So l does not have enough blames or enough support. And so we look at the first block after round r plus two. So the first block after round r plus two is l four a. So in every view of all the other validators, will definitely decide to skip this l four a block, right? As we have already established that l four a will be skipped in the consensus output. So now we know that this block will be skipped. So we should not make a decision based on this.
00:39:02.368 - 00:39:37.724, Speaker B: Let's go to the next block right after r plus two that is actually either committed or undecided. So we are lucky that this next block is actually committed. It's not undecided. So now, because this block is committed, we know every other validator will actually commit it. We have already decided that. Right? So based on this block, we can actually decide whether to commit L, we see that there is a certificate in the history of L four B. There's a certified link to this block, right? This particular block in round three is actually a certificate for L 1D because it includes enough support for L.
00:39:37.724 - 00:40:08.170, Speaker B: Certificate appears in the history of this block that we know will be committed. So if we know that, yes, this block will be committed. And because of course, you have signatures on these blocks and so on, everybody will see the same history for L four B. And so everybody will see, yes, there is a certificate for L, we know that, yes, L 1D should be committed through our indirect commit rule. Does that make sense? Is there a question in the chat? Yeah, sorry. See? Questions. I can just only hear the sound.
00:40:10.300 - 00:40:43.868, Speaker A: I can see the certified link, right? Like the L four B. And then I think. I believe it's L three A or something like the lower one with a certified link. There are also other links, right? Like we could go from L four B to L down or even further up to L three C. How is that kind of certified link? Or how is this path? Is it like as long as there is any path and this is just one of the possible paths, or does it have to be that path?
00:40:44.044 - 00:41:08.660, Speaker B: No, it can be at least any one certificate. Because you know that, yes, the history of L four B will be consistent across all of them. So all of them. If you have at least one certificate, you know that, yes, there is a certificate in the history. And because you have a certificate, at least one certificate. If you have more, that's great. But if you have at least one certificate, you know that, yes, this block is not equivocated.
00:41:08.660 - 00:41:50.632, Speaker B: So you know that, yes, it's safe to actually commit this block. You have a certificate for it. Certificates are nice because when you have at least one certificate, you know that there was no equivocation for it because of quorum intersection. So you only need at least one certificate in the history of l four B. Okay. Yeah. So in some sense, the way to think about our commits here and processing the DAG is basically once we commit a block, really, we have a consistent view on the entire history of that block because these blocks are signed and you can't manipulate the data inside them.
00:41:50.632 - 00:42:24.352, Speaker B: So once we make a decision on one particular block, the entire history is decided. In some sense, at least the entire history is consistent across all of them. But we need to make decisions on whether to commit individual blocks or not. All right, so moving on to L one c. L one C, again has enough certificate. Sorry. L one c again is the same story as l doesn't have enough support or blames to directly commit or skip it.
00:42:24.352 - 00:42:47.290, Speaker B: So we need to go to the first block that's after round r plus two. There's a certified link. And so you again indirectly commit L one c. L one B is the same story. You again don't have enough blames or support. And so you again look to this block. This block is again skipped the first block after round r plus two, you go to this block to base your decision off.
00:42:47.290 - 00:43:21.800, Speaker B: And this block has no certificate in its history. Now, as I mentioned, this history is consistent across everybody. And so everybody is actually basing their decision based off this particular committed block, L four B. So everybody will see in their history that, yes, there is actually no certificate for l one B. And so all of them will make the same decision. All the validators will make the same decision that, yes, we should skip l one B. So L one B is skipped and l one a has enough certificates to directly commit it.
00:43:21.800 - 00:43:53.440, Speaker B: So now we have decided on the entire status of the DAG, right? Some blocks are committed, some blocks are skipped, and some blocks are undecided. Now, you can actually have. This is the sequence that we were going in, right? L one a L one B, L one C L. We stop at the first block that is undecided. Right. Because we don't want to output something for which we don't know the status of. So we break before the first indecided block, which is l two b.
00:43:53.440 - 00:44:29.460, Speaker B: We have decisions for all the other blocks before this particular one. And so we know that, yes, we can output the sequence. Obviously, we'll skip the one that is actually skipped. And so we output l one a, l one C l. Validators will actually output a consistent sequence, which is this one. All right, any questions?
00:44:30.710 - 00:44:46.360, Speaker A: I just have one question. I wonder when you said that l one b will be skipped. There are no. It's not enough certificates, that's why. Okay, never mind. Okay, all good. So what do we do then?
00:44:46.890 - 00:45:11.870, Speaker B: Yeah, in some sense, everybody has decided to skip l one b, right. Because there was no certificate for it. Intuitively, what that means is, look, nobody observed a certificate for it, so we can't be sure whether this block might be equivocated or not. It's really not safe to actually commit this block. So all of us decided to skip this one. And so we are actually skipping this contents of this block from our output sequence.
00:45:15.870 - 00:45:22.160, Speaker A: All right, I think we have one more question. Albert and Aaron. Oh, questions start now.
00:45:22.770 - 00:46:09.270, Speaker B: Yeah, I just have some small parts to cover about the consensus less path or the fast path, but that's a small part. So we can also do a little bit of questions now. Yeah, I was just wondering if you can explain a bit more out of the scale when you grow the number of participants. Like, I understand, you need this two f plus one kind of confirmation per round. Does it mean that essentially every block producer needs to broadcast its block to every participant in the network? Or is it enough to stop around these two f plus ones? Or how does it work when you have more than four? Right. Yeah. An honest node will have to broadcast its block to everybody else.
00:46:09.270 - 00:46:38.150, Speaker B: You can't broadcast it to just two f plus one, because what if f out of those are byzantine? So you only have then f plus one who have your block, which is not enough to gather support, gather certificates, commit, and so on. So you really want to make sure that if you are an honest participant, you broadcast your block to everybody. So if there are 200 participants, you should broadcast your block to 200 other people. Thank you. All right.
00:46:38.220 - 00:46:39.160, Speaker D: For the end.
00:46:39.610 - 00:47:31.302, Speaker B: Yeah. So now we have the consensus protocol. I'll talk a little bit about the consensus list path now, which is the fast path. So for the fast path, really, it's the same consistent broadcast protocol. But now we can actually have piggyback the votes and signatures from other validators inside the blocks. So each block will actually have votes for the consistent broadcast part inside their own block. If you have a simple cryptocurrency payment, I issue a payment, include that in a block, then all the future blocks or all the other validators will just include an explicit yes or no whether yes, they actually agree to this payment or not.
00:47:31.302 - 00:47:56.462, Speaker B: Right. And if they agree to this payment, of course they'll not let any double spend happen. So once you have enough two f plus one people actually saying yes, your transaction is finalized. That's for simple cryptocurrency payments. So you don't really need consensus. You can just have consistent broadcast, and you are really not signing every response from the validator. Typically in consistent broadcast, what happens is you broadcast something.
00:47:56.462 - 00:48:50.370, Speaker B: All the other validators actually send you a response, signed response saying, yes, I've received your response, I acknowledge it. But here you can kind of do some batching inside the block. So if there are ten transactions in the previous block, you can include ten votes for them, but just make one signature over the entire block. So that's because in production at least, we observed that really the bottleneck was actually at the cpu, there was too much signature generation, verification and so on happening. So once you alleviate the signature generation and verification load, you actually alleviate the compute bottleneck. So fast path is just piggybacked on the consensus path. All right, I already talked about this once you have two f plus one validators that have acknowledged your transaction, you can already go ahead and execute a transaction.
00:48:50.370 - 00:49:38.802, Speaker B: So let me skip over the other details of Fastpath and epoch close and all of that, and just talk to you about performance. You can have a look at the paper for security proofs. Now, for performance, this graph actually measures just Mississippi C without the fast path. So it just measures consensus performance compared to nawal, bullshark and hot stuff. So here you can see that actually for mississippity, the latency is much lower than other protocols while having high throughput. And this is practical performance. Yes.
00:49:38.802 - 00:50:21.766, Speaker B: But as I mentioned theoretically as well, you have only three message delays in Mr. City, whereas in Bullshark and whereas in Bullshark and naval hot stuff, you have lot more message delays, even theoretically. So you're actually committing more or less in 0.5 seconds when you don't have too much load on the system. All right. And this is an evaluation for robustness, which is basically saying, okay, what happens if some nodes randomly fail? This is for crash failure. This is not byzantine robustness.
00:50:21.766 - 00:51:14.150, Speaker B: So this crash failure, we evaluate this because we have these backup leaders or the multiple leaders. And so if some leaders actually fail, if you have backup leaders, then you really don't suffer the latency penalty of a leader failing because you can fall back to the backup one. So you can actually see that when you have faulty nodes here, the dashed line, when you have some nodes that are crashed randomly, the latency doesn't suffer too much. You have this degradation in the latency, which is not too much compared to other protocols. And finally, this is just the evaluation of the fast path compared to other related work, which is Zeph is one of them. Both of them are just doing consistent broadcast in mysticity. FPC, you are doing the fast path as well as consensus.
00:51:14.150 - 00:51:51.110, Speaker B: But we are only measuring the latency for the fastpath transactions, which is even lower than consensus, of course, because we are not doing consensus. You're only doing consistent broadcast. All right. With that, I'm happy to take questions. We discussed about Mr. CDC family of protocols, the baseline version, the pipelining version, the multi leader version. I also talked about, know the pipelining is not just naive pipelining, but you can actually have blocks from other waves helping you to commit a certain wave.
00:51:51.110 - 00:52:04.320, Speaker B: I discussed about the FPC protocol, which is just combining the consistent broadcast based consensusless path on top of the consensus path. And with that, I'm happy to take questions.
00:52:08.130 - 00:52:10.400, Speaker A: All right, Patrick, do you want to go ahead?
00:52:10.770 - 00:52:11.134, Speaker B: Yeah.
00:52:11.172 - 00:52:52.874, Speaker C: Could you go back to the sequence slide, I think, where you had at the top, like the ones that actually get. Yeah, this one. If you could just stop there. Perfect. So you mentioned that people are, in the previous question, people in round two are waiting for the leader, round one to actually reference in their block. I think it's a term you use. So when I'm looking at this, I guess my dumb question is, could you not just wait for all blocks in a previous round to be finalized before you determine the ordering? So then you can then determine deterministic execution, I guess.
00:52:52.874 - 00:53:05.680, Speaker C: Why do you need the leader? Because once I have a round, totally decided, I should be able to run some mechanism on top of that decided round to order those blocks deterministically for everybody, and then I don't have to wait for anybody?
00:53:09.540 - 00:53:25.768, Speaker B: I see. If I understand your question correctly, what you're saying is, okay, let's not have a predetermined sequence in which we will commit. So for round one, we don't know what the sequence is, but we'll see based on.
00:53:25.934 - 00:53:27.048, Speaker C: We'll figure it out later.
00:53:27.134 - 00:54:08.940, Speaker B: We'll figure it out later. My immediate thought is that if we figure it out later, okay, maybe for round one, but in round two or round three and round four, for the future rounds, we kind of do need this sequence, right. Because as we saw, we are kind of all going to the first leader. That was actually. So if you see here, we needed the sequence between l four a and l four b in order to see, okay, which one is going to help us decide? L one b. So in that sense, we needed a sequence in the future rounds to actually know. Yes, this is the block that all of us will use to base our decision for the indirect commit.
00:54:08.940 - 00:54:29.196, Speaker B: So in that sense, we need that sequence across validators. I'm not sure if it will work if you have a sequence for future rounds, but not a sequence for the past rounds, that seems a bit counterintuitive, but it's an interesting thought, because I.
00:54:29.218 - 00:54:55.910, Speaker C: Guess I thought that some of that, at least the indirect rules around how do you handle potentially equivocating leaders? But if you don't have a notion of a leader there, I guess the intuition, which I don't know if it's true, is if you can somehow back into that later, eventually, and deterministically. And I guess I don't know if it's true or not. I guess my question was if that made sense or not. And it seems like it could be an open question. I'm not sure.
00:54:56.680 - 00:55:44.564, Speaker B: Right. Yeah, I'm just wondering. It will be a little bit weird, because in round four, we know that we need this sequence, right. To base our decisions off. But then what will happen when we are actually trying to commit round four? Now, we'll say, okay, we don't actually need to know the sequence, we'll try to commit round four, but we already have a sequence in round four to help us decide any previous rounds. So in some sense, this round one blocks already should have a sequence to help us decide for round r minus two and so on. So you kind of need that sequence because all of us need to agree on what the indirect commit should be based off, I think.
00:55:44.564 - 00:55:45.510, Speaker B: Yeah.
00:55:48.620 - 00:56:31.510, Speaker C: I had one more question, actually. If you go back to the benchmarking slide, at least in the comparison with narwhal hs do you know if that implementation verifies the transactions or executes the transactions during the actual voting process like you typically would in hot stuff? Or is it something where it's computed after the fact? Because I would imagine obviously Mr. Seti or like Bullshark or these ones are going to perform better that have some sort of async execution. But in hot stuff I think you need that data to actually decide the block. So I didn't know how that benchmark was configured if that was taken into account or not.
00:56:32.040 - 00:57:03.228, Speaker B: Right. I think in novel hot stuff at least the semantic execution of transactions is not there to have equal parity with all the others. So in all of them you're kind of not interpreting what the transaction is doing, then doing any EVM execution or something like that, or any virtual machine execution. Yeah, it's just bare bones consensus protocol. Each transaction might themselves be invalid, but we are just working with okay, the.
00:57:03.234 - 00:57:09.184, Speaker C: Benchmark is pretty much just bytes basically, is what you're saying. There's not a lot else going on other than that, but the consent, yeah.
00:57:09.222 - 00:57:10.988, Speaker B: Just contempt to benchmark.
00:57:11.164 - 00:57:11.890, Speaker C: Thanks.
00:57:13.940 - 00:57:35.604, Speaker D: I had a few questions too. When a Fastpath transaction is sequenced, is that basically it returns this reliable broadcast certificate to the user so they know it will be eventually included. My question was, when can the outputs of that transaction be consumed in a separate transaction? Is that just after it's been directly committed or indirectly committed for fastbart transactions?
00:57:35.732 - 00:57:36.410, Speaker B: Yeah.
00:57:36.780 - 00:57:38.264, Speaker D: When can the outputs be?
00:57:38.302 - 00:58:30.280, Speaker B: Yeah, that's an excellent question, really. I mean, it will be a tragedy if we actually have to wait for consensus to execute fastbart transactions or for its effects to actually be reflected. So you don't need to wait for that. You really don't need to wait for that particular block to be committed or not. If you are doing fast path transactions, once you have enough validators that agree that yes, I've seen this transaction, this cryptocurrency payment, for example, happening. Once you have enough quorum of them to f plus one, basically agreeing to it, then you can already say yes, this cryptocurrency payment is already done, its effects are finalized, you can execute it, you can make the state change for the payment, and then you can consume the output of it in another Fastpat transaction.
00:58:32.700 - 00:58:52.450, Speaker D: That makes sense for FastPass transactions, but if you wanted to consume the output of it in a non Fastpass transaction, would you then have to wait? I guess that's my question is if a non FastPass transaction consumes the output, when does it decide the sequence, since that would sort of have to be globally agreed upon for any non fastpath transaction to consume it.
00:58:53.220 - 00:59:35.692, Speaker B: I see. I think it should be okay to even consume the fastpath transactions inside a non fastput transactions. What would be not okay is the opposite, which is you're consuming a non fastpath transaction, a consensus transaction in Fastpath, before that consensus transaction is finalized. But if you know that, yes, this fastpat transaction will be executed, its effects will be there. It will be okay to actually consume it in a consensus transaction. The intuition is that when the consensus transaction is actually committed and processed, everybody will already see that yes, the fastpath transaction on which this is based is already valid. Transfer of cryptocurrency or whatever.
00:59:35.692 - 00:59:40.944, Speaker B: So it's okay to consume the fastpath transactions in consensus. Cool.
00:59:41.062 - 00:59:53.990, Speaker D: And then my last question was, I don't think this was in the, if you wouldn't mind, would you be able to walk through what the protocol requires validators to store between rounds and how it performs garbage collection of that data?
00:59:56.440 - 01:00:48.390, Speaker B: I see. Yeah, at least in the paper, we kind of don't go too much into what you really need to store and so on. All of those are not really part of the protocol, but in terms of practically implementing the system, you need to have some sort of garbage collection. In this case, you've decided on the sequence of all the blocks until l two a. Then you can actually forget about the history of all the history of l one a, l one b, l one c. L garbage collect the history up to the point that you have decided and outputted. But you can't really garbage collect beyond that point.
01:00:48.390 - 01:01:31.428, Speaker B: So garbage collection in that sense works intuitively. That is, until the point you've decided. And you really need to only store, you need to store these blocks in a practical sense. If you're actually supplying, say, l two a block to somebody else, this l two a block is referencing l one a. So if another validator sees your l two a block and they're like, look, I don't have l one a, but you are referencing it, so give me that block. So for that synchronization to happen across validators, you do need to store the history of these blocks until the point that everybody has decided. Yeah, the synchronization problem is understudied, I would say.
01:01:31.428 - 01:01:55.324, Speaker B: It's really not clear as to practically how fast you have to garbage collect and so on. Like in ideal conditions, you can garbage collect pretty quickly, but when things are byzantine and worst case in the network conditions, I would say it's a little bit unclear. More work is required there. Cool.
01:01:55.362 - 01:01:56.060, Speaker D: That makes sense.
01:01:56.130 - 01:02:00.108, Speaker B: Thanks. Awesome.
01:02:00.274 - 01:02:20.820, Speaker A: Do we have any more questions or is that it? Okay, I think we're good to go. Thanks again, Kushal, for joining us. Really great presentation. As I said in the beginning, we will upload this video to our ableabs YouTube channel. So if you want to watch it again or want to refer to it later, feel free to check that out.
01:02:20.970 - 01:02:21.332, Speaker B: Yeah.
01:02:21.386 - 01:02:29.488, Speaker A: Thanks a lot, Kushal. Hopefully soon, a third time. This would be, again, a first. Let's see. Thanks a lot for joining.
01:02:29.584 - 01:02:33.464, Speaker B: Yeah, I just enjoy interacting with you and it was a pleasure. Thank you.
01:02:33.662 - 01:02:34.168, Speaker A: Awesome.
01:02:34.254 - 01:02:34.920, Speaker B: Cool. Perfect.
01:02:34.990 - 01:02:38.052, Speaker A: Then, everybody have a good day and see you soon. Bye bye.
01:02:38.196 - 01:02:39.610, Speaker C: Thanks for stopping by.
01:02:39.980 - 01:02:40.390, Speaker B: See you.
