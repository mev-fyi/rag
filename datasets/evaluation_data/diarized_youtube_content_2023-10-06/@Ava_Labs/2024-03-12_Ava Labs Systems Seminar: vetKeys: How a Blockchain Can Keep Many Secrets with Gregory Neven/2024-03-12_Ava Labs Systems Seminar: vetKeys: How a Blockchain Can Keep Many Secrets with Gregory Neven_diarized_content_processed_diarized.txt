00:00:09.770 - 00:00:10.654, Speaker A: Thanks everybody for coming.
00:00:10.692 - 00:00:17.386, Speaker B: And thanks especially to Gregory Nevin from Chainlink Labs for joining us today to present Vetkeys, how a blockchain can keep many secrets.
00:00:17.498 - 00:01:00.554, Speaker A: So thanks so much, Gregory, thanks a lot. Thanks a lot for having me. Thanks a lot for the opportunity to talk about it here. So this is joint work with my esteemed previous colleagues at Andrea Truly, Ashlyn Connolly, Francis van Price and Victor Schulp. Part of this work was done while I was still at definity, but now I'm, of course, at Chainlink Labs. The paper is, by the way, on Eprint, already on the link at the bottom there, so you can look up more details if you want to. So what is this about? The whole problem that we're trying to solve here, or that we're partially trying to solve, is confidentiality on blockchains.
00:01:00.554 - 00:01:49.614, Speaker A: If you believe the marketing pitch of at least some of the blockchains, the blockchains, everything you do on there, on web3, everything is secure by default. And that is partially true. It is definitely true in terms of integrity and availability, because the decentralized aspect actually makes for some good, strong guarantees in those respects. Also, censorship resistance is very well taken care of. Confidentiality, however, is actually problematic. It's not just that on web3, on blockchains, you don't automatically have it. It's actually worse than in the web two world, where at least your data would be stored on a bunch of machines within one organization, whether it would be a social network or a search engine or whatever, storing your data.
00:01:49.614 - 00:02:32.410, Speaker A: It's their machines who are storing it and not going outside of those machines, usually on a decentralized network. If your data is on a blockchain, it will be visible to the world. If this is a public blockchain, or at least to a whole set of nodes, independent nodes, each of which have a copy of your data. So you essentially have to assume that not a single one of them will be corrupt if you don't want your data to leak. So we want to make this situation better. And there have been ways suggested already in the literature to do this, or even in practice. One common approach is to rely on trusted execution platforms like Intel SGX or Amdsev SMP.
00:02:32.410 - 00:03:23.178, Speaker A: Problem with those is that they're good for features that otherwise you have no idea how you could get them. But, well, the bad thing is they just keep on getting broken all the time. And so there are multiple attacks in the literature actually pilfering out the keys from these machines. There was actually one attack that actually attacked the secret network, which was a blockchain that was relying on Intel SGX, and that was attacked by attacking SGX. So this is not a great choice. Now, of course, one way to solve it is just to have user side encryption keys, let users manage their own encryption keys, public keys, secret keys. And for a community that prouds itself on claims like not your key, not your crypto, you would think that this is obviously the right way to do it.
00:03:23.178 - 00:04:12.880, Speaker A: The thing is, it's maybe the right way to do it for the select few who can manage their keys correctly. But it's definitely not something that's suitable for a broader audience. And it's actually even more difficult than for signing keys, because for signing keys at least you have hardware support in trusted execution environments, and laptops in hardware wallets. So that hardware support is usually lacking for encryption keys. On top of that, what you could also do is store keys in browser storage on a somewhat secure machine. It's a big attack vector that you have in a browser, of course, and on top of that, in case you erase the cookies in your browser, you will also be erasing your encryption keys or the decryption keys. So it's just inconvenient to do that.
00:04:12.880 - 00:05:02.102, Speaker A: Another possibility is secret sharing. Share your secrets that you have over the nodes of the blockchain. Now that works for a couple of core secrets, but definitely doesn't work in case you want to store billions or trillions of secrets on a blockchain, just because if the topology of the network changes, if new nodes join or leave, you typically have to reshare all of the secret shared values that are in there. And this actually takes quite some effort, even for a handful of keys. It will be completely impossible for doing that for billions or trillions of secrets. Another approach would be zero knowledge proofs. Zero knowledge proofs typically work very well when there is a prover who knows the plain text and wants to convince, typically the nodes of a blockchain or the other users in a blockchain that things have happened correctly.
00:05:02.102 - 00:05:49.690, Speaker A: It doesn't work very well in use cases where you actually want one user to, under certain conditions, reveal a secret to some other user. This is not where zero knowledge would help. The big guns would help multiparty computation, fully homomorphic encryption, they would help to some extent. They're also still limited by the secret sharing thing, because for MPC you would still have to secret share your inputs over all of the nodes. And fully homorphic encryption is actually great technology. It works well for limited functionality, but not so much for general execution. So what we are proposing here is not going to solve the full privacy problem, because what it will not allow you to do, I'm already going to tell you, is operate on encrypted data.
00:05:49.690 - 00:07:05.474, Speaker A: The encrypted data will remain encrypted, but at least lets the blockchain route the encrypted data around and decide on the fly who gets access to which piece of data. How is it going to do that? So this is what vetkeys, or verifiably encrypted threshold keys are for. We will have a single master key that is secret, shared among the nodes and distributed application. Dapps or smart contracts will be able to deterministically derive strong cryptographic keys from this single master key. And these deterministically derived keys can then be used for doing symmetric encryption, asymmetric encryption signatures, and a whole list of things I will come to use cases later. But so the other thing is that these derived keys can not only be delivered to the smart contract, to the DAP itself, but could also be delivered in encrypted form to the user of the DAP directly, so that the DAP, or the nodes running the DAP, the blockchain nodes running the DAP, don't actually see that derived key. It's only the user of the smart contract, the user of the DAP, who gets to see the derived key.
00:07:05.474 - 00:07:58.130, Speaker A: And that allows you to make this sort of end to end encryption setting that vetkeys can be useful for. So for the rest of this talk, so I'll first go a bit deeper into the concept because it's not the most straightforward concept to grasp. Then we'll discuss some use cases, because I think that's actually the coolest part of this whole technology. I'll also briefly go into the cryptographic constructions and have some back of the envelope numbers on performance, what you can expect here. Okay, so to understand that, Keith, the easiest way to explain it to a cryptographer is by starting from identity based encryption. Now, not everybody in the audience is a cryptographer, I suppose. So let's first start off with identity based encryption, what that is.
00:07:58.130 - 00:08:29.470, Speaker A: So this is something known in the literature. Typically you have a centralized authority here on the right. Actually. Do you see my cursor on the screen when I move it? No. Okay, then I'm not going to make use of that. So we have a centralized authority on the right who generates a master key pair with a master public key and a master secret key. And there is a user bob on the top left, who wants to receive messages sent to him by Alice.
00:08:29.470 - 00:09:38.450, Speaker A: Alice wants to send messages to him encrypted using just the master public key, the common master public key of the whole system of the master authority and the identity of the user she's sending to. So the bitstring bob and what Bob will do is authenticate to the centralized authority and receive from the centralized authority a decryption key specific for the identity bob. And that allows it to decrypt messages that are encrypted to identity Bob but no other messages. And so that's what Alice can then do. She can encrypt messages that can only be decrypted by the truthful owner of the decryption key for the identity Bob. Now if we take this to a more realistic setting, typically you would probably not have the master authority himself vetting the identity of Bob. You would probably have like some in between party who would check the identity of Bob, and you would probably also not send those derived keys in unencrypted form over the network.
00:09:38.450 - 00:10:25.938, Speaker A: So what you would probably do is Bob generating a temporary transport key pair like a transport public key, and a transport secret key authenticates to this trusted intermediary. The trusted intermediary then tells the centralized authority like hey, give this guy the right key for Bob and encrypt that under this transport public key, because that's a transport public key that he provided. That derived key gets encrypted under this transport public key sent to Bob. Bob can decrypt his decryption key and therefore start decrypting messages. So that is one thing that you can do. Now the other thing is of course working in a blockchain setting. We don't like centralized authorities, right.
00:10:25.938 - 00:11:27.534, Speaker A: So obviously what you're going to do is decentralize that centralized authority, make sure that that's a network of nodes that generated and only a threshold of them would be able to reconstruct the master secret. However, they never actually reconstruct the master secret. They can have a threshold way of deriving those decryption keys. And then the final thing is we don't want a trusted intermediary sitting in between. It would be great if instead of a trusted intermediary this is actually a smart contract, taking the decisions which user is allowed to obtain which decryption key and do that on a blockchain in a decentralized setting. And that essentially completes the whole picture for verifiably encrypted threshold key derivation or vetkds the primitive behind the vet keys. So what you have in vetkeys is there is on the top right there is a network of nodes.
00:11:27.534 - 00:12:07.814, Speaker A: It could be a blockchain or an oracle network to a blockchain that generates this master key pair. The master secret key is secret shared among these nodes. There is a blockchain that is calling into this network of nodes and Dapps running on this blockchain. If there is a user on the blockchain who thinks he's allowed to obtain some decryption key, he will send an authenticated message to the DAP containing a transport public key. Again, this is just an ephemeral key. This is not a long term key. You just generate it once for this session and afterwards you can forget it again.
00:12:07.814 - 00:13:12.042, Speaker A: So no need for key management. On user side this transfer public key to the DAP in a signed transaction. The DAP will evaluate does this user satisfy the restrictions of policy in order to be able to obtain the decryption key? If so, make a call to that oracle network to derive the encrypted decryption key. Derive the decryption key for the identity, in this case bob, and do so in encrypted format. So every node will threshold derive decryption key in encrypted format under that transport public key that is generated by bulk. So what you then have on top of that is that you can verify these shares of the encrypted key. So the encrypted key shares can be individually verified to check which nodes have contributed valid shares and which nodes have not.
00:13:12.042 - 00:13:46.660, Speaker A: By checking which shares are valid. You can then also combine those shares into a single encrypted key. This encrypted key could appear on the blockchain as the valid response to this request. Everybody can check that. Indeed, this encrypted key contains a valid encryption of the key that the user requested. It gets sent to the user and only the user can actually decrypt the actual key that is inside there using the transport secret key. So that is the primitive that we're working on here.
00:13:46.660 - 00:14:33.060, Speaker A: Okay, right, how do we do this? I'm going to give some details of the constructions later. If you know a bit about identity based encryption, one of the, well actually the first scheme solving in full was the bonnet Franklin identity based encryption scheme, which has a key structure. The decryption keys in it are actually BLS signatures. And so we're going to use that. That means that essentially under the hood, this whole threshold key derivation is actually a form of encrypted threshold BLS signatures. So if that's all what you wanted to know, like this gives you it. Actually, under the hood it's threshold BLS with a little spice added on top.
00:14:33.060 - 00:15:15.854, Speaker A: Good. So let's discuss the use cases, which I think is the most exciting part. So I told you that we can do a lot of use cases. Let's dive in. The first one would be decentralized end to end encrypted messaging DAP on chain. How would you do this? So suppose you have a DAP that in this case is something like a decentralized version of signal or something. And if there is a user Alice, and she wants to send an encrypted message to Bob, then she could for example, send a signed message to the DAP saying, okay, here is a freshly generated transport public key, I want to talk to Bob.
00:15:15.854 - 00:15:47.094, Speaker A: I am Alice. Here's my signature on this. The DAp will then evaluate. Okay, yes, this is a valid transaction. And because she is Alice, she has access to the decryption key of the concatenation of the identities of Alice and Bob. So we would assume that there would be one decryption key for each pair of identities, and if only those two identities will get access to that decryption key. So the DaP would call in the vet key, derive a vet key for the concatenation of the Alice Bob identities.
00:15:47.094 - 00:16:29.978, Speaker A: That will result in an encrypted key. The encrypted key will be sent back to Alice. Alice will recover the decryption, sorry, will recover the derived key that is inside that encrypted key and use that derived key as a symmetric key. And that symmetric key she will use to encrypt the message that she wants to send to Bob. And she submits that ciphertext to the chain saying, okay, here's a message that I want to send to Bob, Bob. Then later on will appear and will come up, generate also a fresh transport public key, different one of course, and say, hey, I'm Bob. Did any new messages arrive for me? And the DAP will say, actually yes, there is a message for you.
00:16:29.978 - 00:17:08.310, Speaker A: You are Bob. This is a message that came from Alice. So you are allowed to derive the key for the concatenated identities of Alice and Bob. The encrypted key gets sent back to Bob. Bob decrypts the key inside, which is the key for Alice and Bob, and can use that to decrypt the message. So if you see what is going on here, the DaP is deciding on the fly which users are allowed to decrypt to obtain which decryption keys. Which derived keys? These keys are being used to encrypt messages and to decrypt them.
00:17:08.310 - 00:17:49.154, Speaker A: The nodes of the blockchain never see the encrypted messages. It's only visible on the user ends, and they also never see the actual derived keys. Those derived keys are delivered in encrypted form to the users. We can use a similar mechanism to do end to end encrypted storage, like a sort of decentralized version of Dropbox. You can also do social networks where your posts will get encrypted and are only decryptable by people who are satisfying the policy, like whatever your sharing preferences are. The dapt social network will then decide who is allowed to see which post. Each post could be encrypted with its own key.
00:17:49.154 - 00:19:03.514, Speaker A: So let's have perfect granularity which key is derived at which point. So in general, it's essentially the depth becomes a router of ciphertexts and becomes a decentralized access policy enforcement point. It can on the fly decide which user gets access to the plain text of which ciphertext, which is a pretty cool primitive to work with. Another cool thing that you could do is something like a dead man switch, as it's often called. This is sort of a mechanism in case you're sitting on some very sensitive information that you are fearing even for your life, for, that people may be after you and you want it to get published in case something happens to you. This could be useful for whistleblowers, for journalists, for dissidents. And so what you could do is that, let's say it's a journalist, a journalist would generate again a transport key pair and derive a vet key for something like his identity and the index of the documents that he wants to share.
00:19:03.514 - 00:20:06.762, Speaker A: Encrypt a document under that key and store it with the DAP. And tell the DAP like, look, I'm going to ping you every day or every week, as soon as you stop receiving my pings, just divulge the clear text of this document. So if the ping stopped coming in, then the smart contract will automatically derive the vet key and can then derive the vet key under like a dummy public key. So for example, you could just generate a transport key pair in the smart contract so it's visible to everyone and that will divulge the content of the document straight away. Or DDAP could actually have in some way assigned whoever is the next of kin to transfer this document to, who will then have the right to decrypt this document. That actually brings us to the other use of this. You could use this for a sort of digital inheritance of your passwords or your crypto keys or something, so that you store them in encrypted form on a smart contract.
00:20:06.762 - 00:21:10.190, Speaker A: And when you stop pinging them, then automatically the transfer will be enabled to whoever you assigned to be receiving your secrets, which is also a pretty cool application. Okay, another application is preventing minor extracted value. I'm pretty sure that in this crowd, I don't have to explain what minor extracted value is. Depending how you look at it, it's a great deal for miners, great source of income for miners, or it's a great rip off for the users of financial services on their blockchain. Truth is that a lot of money is being lost to users. And if you want to prevent this, then what you could do is sequence transactions in encrypted form and with vetkeys, you could do so in a very efficient way, because you could, for example, have users encrypt their transactions and use a sort of, instead of. Until now, the use cases were all using symmetric encryption of the documents.
00:21:10.190 - 00:22:37.786, Speaker A: You can actually also use a sort of public key encryption. It's actually identity based encryption at that point where the users would encrypt to the identifier of the time slot where they want their transaction to appear. And so what the DAP, for example, a digital exchange will do is collect ciphertexts from different users that are all encrypted to the same time slot, sequence them like in encrypted form, make sure that the order is fixed in encrypted form, and then when the time slot actually arrives, then only then perform the threshold operation to derive the decryption key for that particular time slot. In this case, don't have that decryption key delivered in encrypted form to the user, but have it delivered in clear form straight to the DAP, so that the DAP with that one decryption key can decrypt all of the ciphertexts who are in line for that time slot. So with just one threshold operation, you can decrypt thousands of ciphertext, thousands of encrypted transactions that have been submitted by different users. So that gives you actually a scale advantage that is much bigger than if you would have to do a threshold operation for every single encrypted transaction that needs to be executed. In a similar way, you could implement secret bid auctions where users encrypt their bids into an auction.
00:22:37.786 - 00:23:47.102, Speaker A: And at the end of the auction, all of the bids get decrypted again with just a single threshold operation you could use the auction, some identifier for the auction as the identity to which you encrypt. And that way you again have the same advantage, that with just one threshold operation you could decrypt all of the bids that ever made and determine who the winner is. There's more use cases, so in the paper they are explained in a bit more detail, but here just a brief summary of them. You can do something called time lock encryption. Encrypt to the future so you can encrypt to a time slot in the future and let a smart contract take care of making sure that when the time actually comes, only then triggering the derivation of the appropriate key and divulging the document. At that point there's a cryptographic cool tool called witness encryption, where you can encrypt to any member of a language. So a language, if you know these sort of theories, there's language members that have a witness thing.
00:23:47.102 - 00:24:52.662, Speaker A: For example, for products of two primes, and the witness is the two primes to prove that they are the factors of this product of two primes. So you can encrypt to any member of a language and decrypt when you have a witness to the language. You just have to set up a smart contract that allows to accept ciphertext encrypted to a language and will only divulge the decryption key for that language member when the transaction provides a correct witness for that language. Or maybe zero knowledge proof of such a language. If you don't want to reveal it on chain, then there's another cool cryptographic tool, one time programs, programs that can only get executed once on a single set of inputs. This would use garbled circuits where the wire encodings of the garbled circuit would be vet keys. And the smart contract protecting the one time program will only ever allow one wire encoding.
00:24:52.662 - 00:25:58.334, Speaker A: So for one bit value of each wire ever to be revealed to the public. So this way, like the creator of the onetime program uploads it on chain and can be sure that when it gets evaluated eventually only on one input, it can get evaluated. With all of this encryption use cases, you would almost forget that BLS signatures are actually also signatures, and you can actually use them as such as well, so what you're deriving here, these keys that you're deriving are actually signatures, and instead of using them as decryption keys, you can actually use them as signatures on the derivation identity, which then becomes the message, which is then kind of like, because they only can get triggered by the blockchain. You will have essentially a blockchain signing compact messages. There are some blockchains who have this built in, but others who do not. It essentially is a good replacement for what otherwise would have to be done by a live client who would verify that a certain statement was actually produced by a particular blockchain. And then there's a couple of use cases who are actually not in the current research paper yet.
00:25:58.334 - 00:27:02.462, Speaker A: This is something that is still ongoing work, but with a particular version of these vet keys, you can actually do more things like partially blind signatures where you hide part of the message and you reveal another part of the message. This would give you completely untraceable token transfers in like chom digital cash way. Please use that feature responsibly. It would also give you anonymous credentials in a threshold way, threshold oblivious transfer, threshold password strengthening, so that you can actually have digital assets that are protected by a password key and still not having offline attacks, offline dictionary tax on it. There's a lot of features that you can do with that as well. And not to forget all of this by just having one single message, secret key, secret shared over a bunch of nodes, which is actually a pretty powerful outcome for just one key here. Okay, so let me go to the cryptographic constructions.
00:27:02.462 - 00:28:32.542, Speaker A: I'm not going to go into too much detail, but for those who like to see the details, let's briefly dive in. I told you that the main constructions are essentially derived from the Bonet Franklin IDe identity based encryption scheme that uses BLS signatures as its decryption keys. So what we're going to do is, so what we have to do is thresholdize, of course, this BLS signature generation, which is fairly easy to do, but then we need to do that in a way that it is encrypted under this transport public key and verifiably encrypted, that you can check that an encrypted key share actually contains a correct key, and that you can compose it and also the composed version can be verified. And so what you're going to do there is actually encrypt the BLS signatures under a sort of algamal encryption in the group where these signatures live, in G one. And you can then verify these by publishing also not just the algamal public key in G one in the first group, but also in the other group, the G two. By doing so, you actually start leaking a little bit of information but you can actually prove, and the paper contains all the proof that for all applications that I mentioned, identity based encryption, PRFs, VRFs signatures, this leakage is actually not bad. Like everything stays secure without it.
00:28:32.542 - 00:29:36.418, Speaker A: But for other applications, you may have to check that it actually still stays secure. So what you do here is then typically just encrypting algamal encrypting under this transport public key. And then you can just aggregate all of the encrypted BLS signature shares. You can aggregate those and combine them into a compact encrypted key, encrypted BLS signature that then can be verified in the same way as the shares can be verified. Now this is one way to do it. The other way to do it is instead of extending the transport public key into the other group in order to allow verification, to actually add some information to the ciphertext. So you can have, instead of the randomness of algamal only appearing in the first group, also have that appear in the second group, then you can also check whether an encrypted signature or the right key is actually the correct one.
00:29:36.418 - 00:30:08.202, Speaker A: It's just a different means to the same end, has a different type of leakage, but also this leakage is okay for the applications that I mentioned. All of these constructions have a compact encrypted key. So the encrypted key is just a couple of group elements. In this case, three group elements in a previous schema was only two group elements. So they're very compact for those chains where that is important if they have to appear on chain, this is really compact information appearing there. Now for those chains where actually having a compact encrypted key is less crucial. There's actually also a couple of other schemes.
00:30:08.202 - 00:31:43.766, Speaker A: Instead of using the pairing verification for the encrypted keys, what you could do is actually still algamal encrypts in G one. But instead of revealing some extra information that allows you to test via a pairing equation, just add a proof in zero knowledge that you encrypted the correct item in the correct way under the correct key. So that means that every node is going to add such a proof and the encrypted key is then just going to consist of a concatenation of t of those encrypted keys together with their valid hero knowledge proofs and that gets sent back to the user. So obvious disadvantage is you have like order of t items, ciphertext with zero knowledge proofs in that encrypted key. But it may be a bit more efficient to do because you don't have to do pairing operations in order to verify encrypted shares or to verify the encrypted key. Or an even simpler scheme is not to use algamal encryption at all, just use any public key encryption and just let every known sign the fact that he encrypted his BLS signature share under this public key that the user provided. And then of course you cannot verify anymore in the sense of does this ciphertext contain a valid BLS signature share? But you can compensate for that by just having two t.
00:31:43.766 - 00:32:20.300, Speaker A: What do I have there exactly two t minus one ciphertext. So just provide enough ciphertext. So even if there are t minus one bad guys, that still leaves you t good guys. And so just let the user figure out which are the decrypt, all of them, figure out which here are the valid keys and perform the decryption locally. So this has of course the biggest cyprtext. It also has the disadvantage that it only works for thresholds that are smaller than half of the nodes that you're working with. But if the size of an encrypted key is not an issue, this actually may turn out to be the most efficient scheme to use it with.
00:32:20.300 - 00:33:22.406, Speaker A: That's for the constructions. A bit of an idea on the performance of this. So the numbers here are actually based on benchmarks we had for individual crypto operations, and then using a fancy excel spreadsheet, extrapolating those numbers for what it would take for the operations that we have in vetkeys. So what you're looking at here is the different schemes. We have the simple scheme at the left, the $0 scheme second, and then the two aggregate schemes. The bars here indicate the time needed per vetkey operation for each node in the network of nodes. So we're focusing on the network of nodes here, what the load is there, and so that is what the bars do.
00:33:22.406 - 00:34:01.270, Speaker A: There is also the dot graph that are connected by a line. This is the size of the encrypted keys in bytes. The axis of that is on the right of the graph. So what you get typically depending on the size of the network, of course. But in a five out of 13 threshold you would get a throughput of, depending on the scheme, between 20 or 500 vet keys per second per server core. So if you have like a ten core server, then it will be ten times this number. So it's a wide variety, of course, between the most efficient scheme and the least efficient schemes.
00:34:01.270 - 00:35:28.334, Speaker A: In larger network you have like seven to 200 vetkey operations per second per server core. Now you can actually make this more efficient by the first four bars here we're assuming that every node will first verify every individual encrypted key share, and only when it finds key valid ones, combine them and verify again the combined result. What you could do is actually take a shortcut and be optimistic. Just assume that most of the nodes, most of the time will be honest and without checking every single share, just combine them straight away and verify the combined result only, which then brings down a lot the time that every node has to spend on every vet key operation, and which then gives a throughput of like between 80 and 640 vetkeys per second per server core. And you can even do that more efficiently by essentially offloading all of the decryption part decryption effort to the user side. So let the user figure out, again, wait for enough shares to come up and just dump them all on the user, and let the user figure out which are the valid ones and combine them in a proper key, and that will give you an even a throughput of like between four and 20 to 650 vet keys per second per server core. Again, goal.
00:35:28.334 - 00:36:08.354, Speaker A: So here you have the disadvantage that of course the size of your encrypted keys becomes much bigger, as you can see in the line graph there. And of course that again, you can only have thresholds less than half, because otherwise you can never be sure that you are giving the user enough information to derive all of his keys. Right. And so with that, I think we can already come to a conclusion. Open the floor for discussion. So conclusion is really, I think these vet keys can actually be a cool tool for use in web3 privacy. The paper is online.
00:36:08.354 - 00:36:52.762, Speaker A: This has been implemented already on the Internet computer that definity developed. However, the implementation, for now, all the interfaces are in place, but it's a centralized implementation where every node is sitting on the full master secret key. I understood it's a matter of developer attention when it gets enough developer attention that people will actually, that definity will actually put in the effort to make the actual decentralized variant out of this. But so to play around with it, it's already available there. There's many applications, we saw a lot of end to end encrypted applications. So end to end meaning between the users of smart contracts, there's also MeV protection. Encrypting to the future, essentially.
00:36:52.762 - 00:37:29.660, Speaker A: I wouldn't be surprised if there's actually much cooler applications than the one in this presentation coming up once this actually gains some popularity, because really developers creativity is the limit here. And again, it's just a single master key that is secret shared over a bunch of nodes, and you get a throughput of like hundreds or hundreds of vet keys per second that you can do on a single server core on every node. So it's actually pretty damn efficient, I think, and I think I already concluded with that. Thank you very much. If you want more details, the paper is on eprint. And feel free to send me email if you want to hear more.
00:37:41.310 - 00:37:48.800, Speaker B: Yeah, I think we'll take some time for questions, if that's okay. If you still have time. Gregory and Tony, do you want to just unmute? Anybody can just chat out if you have questions.
00:37:50.210 - 00:38:24.726, Speaker C: Yeah. One of the questions I'm curious about, you mentioned when using the two groups, there's like information leakage. I am trying to go back a few years in my experience to remember a lot of this stuff, but can you talk a little bit about any intuition that there might be on use cases that might be safe or unsafe? Especially when you talk about developer creativity being unbounded. What are some limits and maybe some guardrails to consider?
00:38:24.908 - 00:39:23.980, Speaker A: Yeah. So essentially what you're leaking is this verifiably encrypted BLS signature is not a perfect encryption because you can verify it. The fact that you can verify it means that it's not a perfect CPA secure encryption. If it were, then it would have to hide everything about the signature inside of it, including whether it's a valid signature or not. The fact that you can verify it essentially is some information that you can glean from the ciphertext. And the typical sort of applications that would be very tricky to use, or even dangerous to use, is where possession of a valid encrypted signature helps you in any way where that by itself is something that you can show to someone like, oh, look, I have this verifiably encrypted signature of this key. Now give me this other thing.
00:39:23.980 - 00:39:44.466, Speaker A: Verifiably encrypted signatures have appeared in the literature. If a verifiably encrypted signature is a valuable asset to have, then this doesn't work in any applications where a verifiably encrypted signature is just, that is a means to get to the actual signature, then it should be fine. Got it.
00:39:44.488 - 00:39:45.042, Speaker C: That makes sense.
00:39:45.096 - 00:39:46.900, Speaker A: Thank you. Welcome.
00:39:51.370 - 00:39:57.798, Speaker B: You mentioned there was an open source implementation. I'd be really curious to take a look. Could you link that by any chance? Maybe just send in the chat?
00:39:57.974 - 00:40:10.170, Speaker A: Yeah, it's in the repo of the Internet computer. So the definitive Internet computer. I'll actually have to look it up myself. Can I provide you with a link later on?
00:40:10.320 - 00:40:18.590, Speaker B: Yeah, of course. I think I may have found a PR related to some RFPs on the dfinity site, but I haven't found that part itself. Yeah, that would be awesome.
00:40:18.660 - 00:40:19.280, Speaker A: Thanks.
00:40:20.450 - 00:40:25.614, Speaker D: I don't know much about the inner computer. What language is that in? Is that Golang? Rust.
00:40:25.742 - 00:40:59.310, Speaker A: It's rust. So everything that is node side is rust. Of course there is also some user side code that needs to be run here, right. This like generation of the transport keys and then recovering of the right key. This is typically something that you would want to do in any language that can run in a user's browser to make it very accessible. So there what I believe definity did, but it was actually some of it done after I left. Affinity is in rust and compiled to wasm so that it can be run inside the browser.
00:41:01.490 - 00:41:47.820, Speaker E: I'm curious, in what context do you think this primitive makes sense to offer as kind of its standalone service? And please correct me if I'm not thinking of it correctly, but similar to running this vetkey service as a chain link oracle network that other chains can interact with versus if possible, I don't even know, embeding it within a blockchain network where the validators participate in that protocol in order to provide that key support within the virtual machine. Yeah, I'm not sure if that's even possible.
00:41:48.670 - 00:42:29.622, Speaker A: Settings are perfectly possible. You can embed it in the nodes that are running the blockchain itself. The advantage probably of that being that you don't have to add another trust assumption to what you're doing, because you're already assuming on a threshold assumption on those nodes, probably. Now that of course is some effort like having some network, whether it be chainlink or any other party that implements this as a separate service that can be called from blockchains. Yeah. Then you have just like the advantage that it's more flexible, that a whole lot of different blockchains suddenly get access to it. I think they're fairly equivalent.
00:42:29.622 - 00:42:58.850, Speaker A: It's just like those blockchains who think this is worth to have as a built in feature, then you can build it in if somebody offers it as an external feature that also works. Cool, thanks. In terms of use cases and applications, I cannot really think of any differences. Actually, the only difference is if it's on an external network that you have the added trust assumption of having to trust the threshold of that external network.
00:43:00.150 - 00:43:06.150, Speaker E: Yeah, I guess the requirements to join are the given network, I guess.
00:43:06.300 - 00:43:07.000, Speaker A: Exactly.
00:43:10.170 - 00:43:33.614, Speaker B: I was going to ask as someone who's far away from being an expert in cryptography like yourself, but this seems like the most well fleshed out proposal that I've heard for adding cryptographic primitives in a practical way to blockchain ecosystems and this sort of mix between open data but still encrypted. Are there any other alternatives that I should look at that are similar or any other proposals that are similar? Or is this really first of its kind attempting to do this?
00:43:33.812 - 00:44:26.638, Speaker A: So it's related to threshold encryption in general, and there have been services that do threshold encryption by itself and threshold decryption. Now if you do that, then you don't have the scaling advantage that I mentioned. For example, in the MEV application, you will have to do one threshold operation for every single ciphertext that you ever want to decrypt. With vetkeys you have the added advantage of having this millions of ciphertext. If they're encrypted under the same identity, then you can decrypt them in one go, one threshold operation, and then decrypt all of them using the derived key. The other thing is the verifiable aspect. Some of these threshold encrypted implementations have that.
00:44:26.638 - 00:45:22.034, Speaker A: So the fact that if the different nodes contribute to the decryption, that you can check whether they contributed correctly to the decryption. So that is something that you need to do now. Also, most of these actually threshold encryption services, they actually reveal the ciphertext, sorry, they reveal the plain text to the nodes that are requesting the decryption, which of course shrinks the set of use cases quite a bit. So what you would have to do here is modify that. To do that in an encrypted form under a key that was provided by the user of the smart contract so that no single node on the whole blockchain will ever know the decryption of it. So I think this is like the big difference of it. The paper has some links to related work.
00:45:22.034 - 00:45:55.900, Speaker A: There are some research networks that do this. There's also for some restricted use cases, for example the encrypting to the future use case that I briefly mentioned there is the drand random beacon of protocol labs that does something particular for this use case. So it's essentially like a subset of vetkeys if you want, it's a similar data. Also use essentially bonnet Franklin ID and threshold BLs in it. Cool.
00:45:57.410 - 00:46:26.790, Speaker D: So because it's threshold BLs kind of in the back end, does that mean that as the set grows. Basically, all you're doing for a reconstitution is a polynomial interpolation. Is it n square root n? If you're doing the optimized interpolation as the number of t grows, basically, I'm just asking, as t grows, what's the performance kind of characteristics?
00:46:27.290 - 00:47:11.058, Speaker A: Now it's linear in t number of exponentiations. Let's see. You're catching me off guard there. I actually didn't study that complexity in detail. Sorry, I went too far back constructions here. So the combination is this Lagrange interpolation that you're talking about, right. This is essentially raising each of those ciphertext, like both elements of it, to the Lagrange coefficients and multiplying them together.
00:47:11.058 - 00:47:48.800, Speaker A: So if you do this as a multi exponentiation, you can actually do this better. If you happen to know multi exponentiation, it essentially allows you to do something like g one to the x one times g two to the x two times g three to the x three. Like a product of exponentiations. Evaluate that in essentially the time of a single exponentiation, if you can take the time to pre compute some things on it. So if you can pre compute some tables. So the memory you need for it is exponential in the number of things that you put in there. But then once you have that, then you actually get very fast.
00:47:48.800 - 00:47:56.260, Speaker A: So for small numbers of T, multi exponentiation would actually speed this up quite a bit, I think.
00:47:56.790 - 00:47:57.346, Speaker D: Interesting.
00:47:57.448 - 00:47:58.002, Speaker A: Very cool.
00:47:58.056 - 00:48:00.100, Speaker D: I haven't heard of that. I'll have to look that up.
00:48:01.110 - 00:48:22.780, Speaker A: Very cool. Thinking of it, I'm using exponentiation here as like, I'm using multiplicative notation for the groups. Of course, typically on elliptic curves, what I call exponentiation is actually called multiplication. So then this would be a multimultiplication or something. I don't know what you'll easier find the references for.
00:48:25.710 - 00:48:27.260, Speaker D: I'll play around with it.
00:48:31.250 - 00:48:47.922, Speaker B: Does anybody else have any more questions? All right then. Thank you so much again for coming, Gregory. This was a really great conversation. Really loved learning about that keys. I'm very interested to look at that open source implementation. I might have to play around with that.
00:48:48.056 - 00:48:52.530, Speaker A: Very good. I'll send you a link afterwards by email. Very good.
00:48:52.600 - 00:48:57.560, Speaker C: Yeah, definitely. Thanks for giving me something else to distract me from the stuff I have to do day to day.
00:48:59.450 - 00:49:09.830, Speaker A: Great. Always happy to do so. Thanks a lot for giving me the opportunity to talk about it. I love talking about it. So let me know if you have more comments. Just contact me over email. Awesome.
00:49:09.900 - 00:49:10.790, Speaker B: Thanks so much.
00:49:10.940 - 00:49:41.850, Speaker A: Very good. Bye everyone. Thank you so much. Thank you. Bye. Om.
