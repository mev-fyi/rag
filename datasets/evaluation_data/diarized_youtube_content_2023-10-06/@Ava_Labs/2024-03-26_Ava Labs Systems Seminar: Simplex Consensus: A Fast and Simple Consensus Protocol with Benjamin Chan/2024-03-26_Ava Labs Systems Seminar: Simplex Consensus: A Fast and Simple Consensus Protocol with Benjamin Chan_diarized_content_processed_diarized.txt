00:00:10.360 - 00:00:35.124, Speaker A: Hey, everyone, welcome to the system seminar. This is a series created by avalabs for developers, engineers, product builders, and anyone interested in learning about the latest research and advancement in blockchain. Today we are joined by Ben Chan. So, he is a PhD candidate at Cornell Tech. We've met at the IC three retreat in Switzerland, and he's going to talk about simplex consensus. Thanks a lot for joining, Ben, and the stage is yours.
00:00:36.504 - 00:01:00.744, Speaker B: Awesome. Thank you so much for having me. It's my pleasure to be here. A few of you have seen this talk before, and this longer version of the talk isn't that much more complicated because the protocol is so nice. So hopefully we all get what we're here for. So. Yes, okay, so the title of this talk is simplex consensus, a fast and simple consensus protocol.
00:01:00.744 - 00:01:20.024, Speaker B: We wrote this paper maybe a year ago now, and we presented it a few places in a few places, and hopefully, hopefully you find it fascinating because I think this is really a gorgeous protocol and that's really why I want to share it with you today. Let's see, how do I move slides?
00:01:23.824 - 00:01:28.444, Speaker A: Okay, just. I think I can make you co host.
00:01:28.744 - 00:01:31.044, Speaker B: Let me see Benjamin chan and then.
00:01:31.504 - 00:01:35.404, Speaker A: Add as co host. And then I think you should see some controls.
00:01:37.704 - 00:02:30.064, Speaker B: Do I see controls? I'll just go to my other tab. Okay, so maybe we don't need much motivation here, because we all work on blockchain protocols, but I do want to go over, hey, consensus protocols are still a really big part of today's world, and maybe an even bigger part than before. Ever since the beginning, they've been part of operations such as Apache Zookeeper or Kafka. They've been used to replicate databases. And more recently, of course, they've been used in blockchains in order to replicate transactions. And I guess just to go over what consensus is, we have a bunch of machines and we really just want everyone to agree. We want two properties, consistency and liveness.
00:02:30.064 - 00:03:19.634, Speaker B: Consistency means that when people see transactions on the network and they each output a log of transactions, these logs should be consistent across all of these machines. If I output a log and you output a log, they should be prefixes of the same log. And liveness says that, hey, our protocol should make progress, and importantly, they should hold when even some nodes are corrupted. And I think consensus is more relevant than ever today because we're in this new era of protocol design where, as I'm sure you're familiar, we have to support thousands of players, if not hundreds of thousands of participants. Many of these participants might be malicious, or maybe they're just very greedy people. Our Internet is also unreliable, and messages might be lost. And we require our protocols to be fast.
00:03:19.634 - 00:04:09.004, Speaker B: We want to confirm transactions very quickly, and we want them to be fair in the sense that no particular adversary can, I think, change the properties of the network in a way that doesn't benefit everyone. And really, the protocol that spun off this whole, this new era is bitcoin. Bitcoin and proof of work. And bitcoin is an amazing protocol, but it does have sub optimal performance. We have a transaction confirmation time of maybe 60 minutes if you wait for six blocks and it takes ten minutes before the next block is proposed. And at the end of the day, maybe the biggest critique is that bitcoin wastes a lot of electricity and computational resources. Yeah, the New York Times has gone over this many times, so people were like, let's do something different.
00:04:09.004 - 00:04:54.184, Speaker B: Let's do proof of stake instead. And as you can see, the performance characteristics are already much better. And I'm sure the system that you guys have built also performs quite well. But yes, Ethereum has a much smaller transaction confirmation time, maybe 15 minutes, much better block time, much better throughput. Algorand I use as an example, because it performs incredibly well in all of these characteristics at a technical level. And in this talk, I'm going to take us back to this partial synchronous proof of stake blockchain setting, because many of these protocols, like Ethereum and Algorand, they use classical permission consensus protocols under the hood. And in classical consensus, the set of n players is known ahead of time.
00:04:54.184 - 00:05:40.854, Speaker B: The overall latency of our proof of stake protocol is inherited from the underlying consensus protocol. But in order to take a classical consensus protocol and make it useful for the proof of stake setting, we do require additional features for fairness. Right. One particular feature is that maybe every block should be proposed by someone different, because block proposers might censor transactions. So you do want to rotate these block proposers, and this talk is really going to be about classical consensus protocols for the proof of stake setting. And I do want to add this note. We don't consider avalanche style protocols in this talk, and it's really an omission, and for no other reason than maybe it's not partial synchronous in the traditional sense.
00:05:40.854 - 00:06:17.564, Speaker B: It just won't be my focus. Okay, so I think if you just tuned in, this is really the summary of what I want to do today. I want to show you a consensus protocol with the easiest security proofs that we know of. And this is subjective. I think it's the easiest. We also want the consensus protocol with the best in class latency of all of the protocols that we've seen. And we are particularly interested in the partial synchronous, which I'll explain in a bit, partial synchronous setting, and where the number of faults is less than one third of the network.
00:06:17.564 - 00:07:35.402, Speaker B: I will also add a little bit more context. Consensus protocols are very well studied, but to this day, I think most other protocols have very non trivial liveness proofs, and it's a little bit hard to intuit why we should expect them to make progress. And my goal today is to convince you to implement our protocol simplex for functionality. And because it's so related to kind of this classical consensus area, maybe it'll even help you understand things like PBFT or Casper or Pax is better. That's really my goal. And of course this is a theoretical work, so we haven't implemented it yet, but we also argue that it is a good candidate to implement and extend. Okay, so our roadmap, first, I'm going to spend a bit more time on, hey, what exactly are we looking for in a good classical partial synchronous protocol that we can then use for the proof of stake setting? And then second, I'm going to go over the actual protocol and all the security proofs and hopefully convince you that this is one of the most beautiful protocols I might have ever seen.
00:07:35.402 - 00:08:25.528, Speaker B: It's a high ask, but, you know, gotta aim high. Okay, what do we look for in a consensus protocol? I think this is something very important that the classical literature doesn't talk about fairness. Okay? Each player should have a fair chance at proposing each block. And classically, something like the famous PBFT, where the same leader can propose each block for eternity. That is certainly not, quote, fair in some notion of fairness. It's just not suitable for a blockchain application if one proposer who might censor is in charge of every single block. Okay, so right off the bat, we're going to imagine a classical consensus protocol where each block is proposed by a different random leader.
00:08:25.528 - 00:08:55.204, Speaker B: We call this random leader consensus. It's a little informal, but we'll take this next, we want a fast protocol. We want fast transaction confirmation time. And that basically all that means is that, hey, I get a transaction at time t. How long does it take after time t in order to confirm this transaction? And I want to highlight that there's two cases here. There's an optimistic case where every block proposer is honest, everyone's good. If everyone's a good person or a good participant, then yes, maybe we do get fast latency.
00:08:55.204 - 00:09:28.214, Speaker B: But we also care about the pessimistic case when some block proposers are faulty, like a missing leader or a leader that crashes, and it turns out that all a bunch of other protocols don't perform as well in this setting. And I think the pessimistic case is quite underappreciated. And finally, we want an easy to understand protocol. It should be easy to understand why the protocol is secure. Okay, the network setting that we care about is called partial synchrony. Some of you might be familiar. This is the same network setting as Paxos.
00:09:28.214 - 00:10:19.974, Speaker B: Sorry that Paxos, and PPFT and Casper and tendermint and all of those protocols used. And partial synchrony is the following. We're going to assume that the network might be unreliable and even occasionally partition. Formally, there is a fixed unknown time GST, which stands for global stabilization time. There's a little delta, an unknown time bound little delta, and a known time bound big delta, such that before the global stabilization time, messages might take arbitrarily long to be delivered, if they're delivered at all. But after GST, we know that every message is delivered within little delta seconds. And partial synchrony models of flaky Internet or network partitions or implementation bugs that cause players to drop messages.
00:10:19.974 - 00:11:05.204, Speaker B: The intuition here is that this little Delta is the real message delay when the network is good. So the network is good after GST and bad before GST. After GST, little Delta is the real message delay, and big Delta is an upper bound on the message delay during these good periods of synchrony, which is given to the protocol as a parameter. And it's a parameter because the protocol might not actually know what the real message delay is. Maybe the message delivers messages in like 50 microseconds. But like, we want to be a little conservative and tell the protocol, hey, you should wait for 2 seconds for protocol or for messages to be delivered. So this is kind of the model that we all like to use in theoretical.
00:11:05.204 - 00:11:40.476, Speaker B: I mean, distributed algorithms and distributed consensus. I think it's quite nice, a little bit strange still, but quite nice. And let's look at the state of the art. Okay, there's a bunch of protocols that have been designed in this model. I'm talking about, like Algorand ICC, hot stuff. I had a password called Streamlet, which we designed to be a textbook kind of classical consensus algorithm. And really the fastest protocols get a confirmation latency of about three message delays after the block performance.
00:11:40.476 - 00:12:21.454, Speaker B: So Algorand and Dfinity's ICC kind of achieved this, at least in theory. And a bunch of protocols do what we call pipelining, they pipeline block proposals to achieve really good block time of two message delays. Optimistically. And what do I mean by this? I mean that the next block proposer proposes a block before the previous one has finalized their block. And yeah, so we start working on block I plus one before we know that block I is confirmed. So I call this pipelining. And this is also really nice because you want the time in between blocks to be short because that also impacts how long it takes for you to confirm a transaction.
00:12:21.454 - 00:13:03.314, Speaker B: However, these protocols that pipeline blocks often use multiple leaders in a row to get finalization. In particular, we need like maybe three leaders in a row to all be honest in order to get a finalized block. And we argue this is problematic because it hurts latency. And of course, if some leaders are bad, it might be hard to get three honest leaders in a row. So in the pessimistic case, latency will also be hurt. But I don't want to spend too much time on this, honestly. Streamlet has a nice protocol description, but I don't think its performance characteristics are great.
00:13:03.314 - 00:13:45.164, Speaker B: And simplex really gives us the best of everything. We have really good latency when analyzed in this model and in our eyes. And maybe more importantly for this talk, it's also easier to understand. So we have a lot of time, but we're going to get to the protocol right after this slide. I think the takeaway from the intro is, hey, we have a new consensus protocol for you. It's in a partial synchronous setting, tolerates one third faulting nodes. In our eyes, it has the easiest liveness proof, and we can get communication efficiency using various techniques like the one algorithm uses.
00:13:45.164 - 00:14:51.378, Speaker B: And I will take a question right now. Are the pessimistic liveness numbers the expected number of message delays, assuming that one third of nodes are faulty, yes, they are the expected number of message delays, assuming that one third of the block proposers are faulty for us, I think yes, and I think for a lot of these protocols, because one good leader doesn't give you finalization, then that's why the pessimistic aliveness gets hurt. Like host stuff requires a few good leaders in a row. And yes, essentially all prior work in this model has a non trivial liveness proof. That's kind of one of the things I want to highlight. Any other questions before I dive into the fun part, the more interesting part to me. Okay, I think we're good.
00:14:51.378 - 00:15:10.754, Speaker B: Yeah. Okay. Once again, we have n players. F of them are malicious. F is less than n over three. And we know everyone's public keys ahead of time. In the theory world, we call this a bear PKI because people can choose their own public keys.
00:15:10.754 - 00:16:00.764, Speaker B: And right off the bat, I think we have to get into some preliminaries in order to really just have a language for talking about our program. So the most important data structure is the blockchain, which you are intimately familiar with. And for us, each block of high h, it's just going to be a tuple h hash of a parent chain, comma transactions. And importantly for us, we're hashing the entire parent chain. This is just a simplification for the purposes of this talk. In reality, you can do something like hash the parent ish, but we won't get into that for now. A block hashes its entire parent chain, and every block is like this.
00:16:00.764 - 00:16:32.692, Speaker B: We also allow the blockchains to contain what we call dummy blocks. Okay, so dummy block is just the tuple h, comma bot, comma bot bar is like a null or just a default value for none. It's just an empty. Yeah. So it's just h h bar, comma bar. And again, in this blockchain that allows dummy blocks, each block that is not a dummy block must still extend the whole parent chain. So this.
00:16:32.692 - 00:17:03.630, Speaker B: This block here of height one hashes the genesis block, this block at height three hashes the entire chain up to height three, and that it extends. So the genesis, the height one block and the dummy block, and so on and so forth. Okay? Now let's talk about voting for blocks. We say that a player I votes for a block b, by signing the message I vote for b. This is quite straightforward. Okay. And we say a notarized block.
00:17:03.630 - 00:17:45.594, Speaker B: Sorry, a block is notarized. In my view, if I've seen at least two n over three or greater than two n over three votes for it, or signatures from 203 different players. And I'll denote it by this double block, this double border thing in the slides. Dummy blocks can also be notarized in our protocol. The final data structure that we're going to use is what we call a notarized blockchain, which is just a blockchain where every block of the chain is notarized except for genesis. Okay? And we have to. I think we have to talk about quorum intersection.
00:17:45.594 - 00:18:24.314, Speaker B: Why do we care about notarized blocs, and the fact that we saw 203 votes for them. Well, it's because we heavily depend on the following classical lemma, a very famous lemma which says that if honest players only vote for one of B or B prime, you don't vote for both. Then it cannot be that two n over three players voted for both b. Sorry, it cannot be that both two n over three players voted for b and two and over three players voted for b prime. So suppose each honest player only votes for one of them. Corrupt players can always vote for both. Well, in total, there's only n f votes from honest players.
00:18:24.314 - 00:18:49.688, Speaker B: There's two f votes from corrupt players. So there's n plus f total votes, which is strictly less than four n over three. So you simply cannot have enough votes for both b and b prime to get two n over three votes. That's quorum intersection. And now we're ready for the protocol itself. We're going to proceed. In iterations h equals one, two, three, dot, dot, dot.
00:18:49.688 - 00:19:27.904, Speaker B: In each iteration h, we are going to collectively try to build a notarized block of high hook. So in iteration one, we'll try to build a notarized block of height one. In iterations two will try to build a notarized block of height two, and so on and so forth. And we only move on to the next iteration when I've seen a notarized blockchain of that height or that length, rather. So I won't move on from iteration two until I see a notarized blockchain of length two. When I move on to the next iteration, I send my view of the notarized blockchain to everyone else. And this can be optimized.
00:19:27.904 - 00:20:05.724, Speaker B: All right, now how do we actually do block proposal, and how do we go for things? How do we actually construct these notarized blocks? Well, each iteration has a leader player chosen randomly ahead of time. For the purposes of this talk. And specifically, we'll let the leader of iteration h just be. I know you hash h modin, then you get a random, random, random process id. And now, hey, that process is the leader. Okay? And on. So for each iteration h, each player I, on entering iteration h, will do the following.
00:20:05.724 - 00:20:38.856, Speaker B: If I is the leader, I will find some notarized blockchain of length h minus one and extend it with a new block, b sub h, and send everyone a signed message. Hey, I propose this new block. It's kind of. You expect this to happen. The leader proposes a block. This block should include all the pending transactions and everyone else, all the voters, on seeing the first valid proposal from the leader, is going to sign and vote for this block and say, hey, I vote for bh. Importantly, you only do this once.
00:20:38.856 - 00:21:12.580, Speaker B: You only do this for the first ballot proposal that you see. And of course, if the network is good and the leader is honest, then this block proposal will get notarized in everyone's view. And voila, we finished iteration three, and we can move on to the next iteration. And just as a preview, we already know that by quorum intersection, at most one block proposal from the leader can ever be notarized in honest view. In the view of any honest player. Okay. But of course, the hard part about consensus is faults.
00:21:12.580 - 00:21:41.908, Speaker B: How do we handle faulty players? So one scenario you might imagine is, hey, maybe the network drops all messages, or the leader crashed, or maybe I just never saw a block proposal for that iteration. Right. Now, what do we do in iteration? I don't know, three, if the leader is missing a second scenario that might happen. Maybe our faulty leader sends different proposals to different players. So honest players split their vote. So no block proposal gets notarized. Right.
00:21:41.908 - 00:22:17.406, Speaker B: Neither proposal ever gets enough votes, never gets two and over three votes. Now, how do we move on to the next iteration? Now, our solution is once, like, we go back to dummy blocks, right? We have this concept of dummy blocks. This is where we use it. So if three big Delta time has passed since player I has entered iteration h, and if player I still hasn't entered iteration h, one, that player will just sign and vote for the dummy block, right? Basically. Hey, I've waited for three message delays. I've seen nothing. There's been no progress.
00:22:17.406 - 00:22:42.384, Speaker B: I'll sign the dummy block and recall that big Delta is this public parameter that upper bounds the message delay in good periods of message network synchrony. Okay, so I'll sign this dummy block, and ideally every honest player signs this dummy block, and voila, we can also move on to the next iteration on seeing a notarized dummy block.
00:22:47.124 - 00:22:50.156, Speaker A: Okay, I have a quick question.
00:22:50.260 - 00:22:50.540, Speaker B: Yes.
00:22:50.572 - 00:23:20.620, Speaker A: So is this kind of like, because we know from other consensus protocols that there are kind of like backup leaders, right? Like there's a leader, and then if the proposal is invalid or it doesn't exist at all, we kind of, like, fall back to these backup leader, and the circle gets larger and larger. Is this kind of like the. Like a similar mechanism, but not with a backup leader, but just kind of like, okay, if the leader doesn't progress, then we just all just go ahead with an empty dummy block.
00:23:20.812 - 00:23:48.624, Speaker B: Yeah, I think intuitively and conceptually even, they are very similar. Typically when you cycle through leaders, like if you go to a backup leader, we have to decide to move on to the next backup leader. Um, and a lot of protocols do use timeouts. Uh, you can envision, like here, it's kind of the same thing. It's just that our backup leader is the leader of the next block. Yeah. Uh, so I think conceptually they are very similar.
00:23:48.624 - 00:24:16.554, Speaker B: Yeah. Nice. Okay, thanks. Okay. Uh, notice before I finish the protocol description that due to false, there may be both a notarized block proposal for h and a notarized dummy block bot sub h. In the view of honest players, like in the view of an honest node. Right.
00:24:16.554 - 00:25:00.146, Speaker B: So maybe, I think maybe it's easier to visualize. Maybe Alice sees a notarized block proposal for height three and she's like, oh, we can move on to iteration four, but maybe the leader that proposed this block was malicious and maybe everyone else just timed out due to asynchrony. So maybe. Well, what am I trying to say? Maybe Alice is the only one who saw this notarized block. That's what I'm trying to say. Because the network is flaky and everyone else times out. Because maybe Verizon went down like it did in New York City recently, so everyone else timed out.
00:25:00.146 - 00:25:34.094, Speaker B: Hey, we never saw a block at high three within the allocated timeframe. So they all vote for bottom. So maybe Bob sees a notarized dummy block. That's entirely possible. So now there's a problem. Alice sees this notarized block at height three and Bob sees this notarized dummy block. The next leader can extend either notarized chain, but for agreement, eventually, when we finalize a block, we have to decide on a single block for that height at each height h.
00:25:34.094 - 00:26:29.184, Speaker B: So the question is, how do we finalize? How do we agree that, like, when I say notarized block, that is a final block and our mechanism is really easy. So finalizing blocks when a player I enters iteration h one, if that player I did not timeout and vote for the dummy block, that player, I will send everyone a signed finalized h message. It's just a message saying, hey, I did not timeout. I saw what I was supposed to see. And on seeing two and over three of these finalized messages, a player, I can finalize any notarized blockchain of length h that it sees in the transactions inside. So intuitively, what I'm going to argue later is that if I, as an honest player. See 203 finalized h messages.
00:26:29.184 - 00:27:12.378, Speaker B: Then that means, hey, 203 players didn't timeout. Therefore, 203 players did not vote for the dummy block. And therefore, by quorum intersection, the dummy block of high h cannot be notarized, which means that whatever good block we saw must have been the only block that could be or could exist at high h. And it's safe to extend that chain and also finalize all the transactions inside, because, like, there's just no fork there. You can't fork high hook. So that's the protocol. I'm not sure how helpful it is to kind of see it all in one place, but let's do it anyways.
00:27:12.378 - 00:27:50.634, Speaker B: So, in each iteration, the leader is going to propose a new block at that height, extending a notarized blockchain from the previous height. Everyone's going to vote for the first valid block proposal, and if they don't see anything for three message delays, we vote for the dummy block. And on seeing a notarized blockchain of length h, we enter the next iteration. If we did not vote for the dummy block, we send a finalized message. And on seeing 203 finalized messages, we say, hey, this iteration was good. We can finalize everything up to this point.
00:27:55.974 - 00:28:02.744, Speaker C: Is that just finalize h? It doesn't actually include the a block that was proposed there. I guess the block is actually unnecessary in this protocol, right?
00:28:03.884 - 00:28:04.904, Speaker B: How do you mean?
00:28:05.524 - 00:28:20.384, Speaker C: So it says finalize h as opposed to finalize block at height h, which seems like that's actually all that's necessary since you're just finalizing whether it was what everyone should have saw and there could be no other alternative or the dummy block.
00:28:21.284 - 00:28:43.854, Speaker B: Yeah, yeah. So I guess you bring up an interesting point which we did not think a lot about. You're right. Like, we can see, I can see 203 finalized messages for some h without seeing a block for that h. And I guess that just gives you a certificate saying, hey, if you ever see a block at that height, you can just immediately finalize it. But yes, you're right, we don't have to actually see the block there.
00:28:45.354 - 00:29:02.344, Speaker A: But doesn't that mean that I can see the finalize and then someone else gives me block at height age, but I'm not quite, you know, a malicious leader of that time can give me a different block and I will immediately finalize without really knowing that.
00:29:03.084 - 00:29:20.896, Speaker B: Oh, I should. You should find you can only finalize a notarized block at that height. So I won't. I won't do it for like, a random block proposal from the block leader or the iteration leader. But I will do it if I see that that proposal has had 203 votes. Okay.
00:29:20.920 - 00:29:21.656, Speaker A: I see.
00:29:21.840 - 00:29:35.776, Speaker B: Yeah. So. Sorry. Yeah. I should have meant I'm mixing up terminology. Yeah. So if we see a certificate of finalized messages, that gives us the ability to final.
00:29:35.776 - 00:29:42.816, Speaker B: Just to finalize any notarized block at that height without seeing a notarized block.
00:29:42.920 - 00:30:03.964, Speaker A: Are the messages are simple, that it's literally just saying finalize h or vote b. Or, or does it include like, you know, like kind of like a, like a, like a. Some kind of proof or something that the thing I'm finalizing has been notarized? Or can I just random finalized messages for whatever block that don't even exist?
00:30:05.624 - 00:31:02.914, Speaker B: Yeah. The finalized message is literally just h. Okay. Because we were trusting that. We're trusting that 203 of the protocol site, we're trusting that two thirds of the network is good. So we're trusting that if a good participant does send this finalized h message, they had better have seen a real block under the hood. And we can kind of, I mean, maybe like if we want to optimize some things after the three delta timeout, what happens if less than two thirds of the network signs the dummy block? Um, I will later show you, uh, that it must be that either 203, either the dummy block gets enough votes or enough people saw the notarized, like a real notarized block.
00:31:02.914 - 00:31:38.444, Speaker B: Um, so we'll never, we'll never end up in a scenario where we get stuck and there's not enough votes. And that will be part of the liveness proof, which I claimed was easy. And hopefully it is. Okay, I will move on, barring other questions. And now let's analyze the protocol so, security proofs. This is my favorite part because I'm a theoretician. But I do think it is important to try to understand why these protocols work.
00:31:38.444 - 00:32:05.220, Speaker B: And I think that our protocol description, like this protocol, is not the easiest protocol to describe. There's some simpler protocols out there, but I do think, I claim that it is maybe the easiest to understand. So this is really the core of the talk. It just takes a while to get here. Okay. First we want to prove consistency agreement. No double, no double spending.
00:32:05.220 - 00:32:36.130, Speaker B: Um, sure. Theorem is, let Alice and Bob be two honest players. And suppose Alice outputs some blockchain, which I call log, and Bob outputs some finalized log prime. When I say output, I mean finalized. And let's just say without loss of generality to Alice's log is shorter than Bob's, then we want to prove that log is a prefix or equal to log prime. Prefix of or equal to log prime. And this is.
00:32:36.130 - 00:32:55.370, Speaker B: This is your agreement property. Hopefully, that's. Hopefully that's. That's comprehensible. Okay, proof. Consider Alice's chain log, which is the shorter one, and let its length be h. So this chain I've drawn on the, on the slide here, this is what Alice's.
00:32:55.370 - 00:33:20.742, Speaker B: Alice has finalized. Okay. All the transactions in this chain are good. Okay. Since this blockchain is finalized by Alice, then Alice must have seen 203 messages of the form finalize h. And I claim that there can only be one notarized blockchain of length h across all the views of honest participants. Right.
00:33:20.742 - 00:33:55.286, Speaker B: If anyone sees a notarized blockchain of length h, they must see this chain that Alice output. How do I prove this? Well, sorry, just looking ahead. If I prove this, then Bob's chain must extend Alice's chain, and we have our agreement property. And that would conclude the proof. So really, the crux of our argument is proving this claim. Okay, how do we prove this claim that there's only one notarized blockchain of length h across all honest views? First, we claim that at most, one block proposal from the leader of h can be notarized in honest view. Right.
00:33:55.286 - 00:34:39.225, Speaker B: And the proof is each honest player or voter votes for at most one block proposal. And by quorum intersection, it cannot be that b prime got 203 votes and b got 203 votes. Therefore, only B could have gotten 203 votes and gotten notarized here. That's nice. But we also have to claim that the dummy block of high h here cannot be notarized in any honest view. So our claim is, since Alice saw 203 finalized h messages, the dummy block of high h cannot be notarized in any honest view. And once again, this is bi quorum intersection.
00:34:39.225 - 00:35:19.324, Speaker B: Because each honest player either votes finalized or for the dummy block, it can't vote for both. And therefore, because there are 203 finalized messages, dummy block cannot be notarized in anyone's view. There aren't any enough votes. And. Yeah, so Alice's chain is unique, and Bob's chain, by virtue of being notarized and having to extend a shorter notarized chain, must extend Alice's chain. Thus, it is safe to finalize all of Alice's transactions. And that's it.
00:35:19.324 - 00:35:49.754, Speaker B: That's consistency. Okay, now, liveness, our first claim. We're going to split aliveness into two parts. There's the honest leader case and the malicious leader case. So our first claim is that if the network is good, we're after this global stabilization time, then an honest leader can always get his block proposal notarized and then finalized. This should be the intuitive one. If the leader is good, then our protocol should make progress.
00:35:49.754 - 00:36:32.706, Speaker B: This is a little non like. I think technically formalizing all these things is kind of, kind of annoying, but I think it's quite nice here. So the fact that we rely on is that, hey, if some honest player enters iteration h by time t and the network is good, so t is greater than GST, then we know that every honest iteration, every honest player enters iteration h by time t plus little delta. Why is this? Well, it's because when an honest player enters iteration h, I send a length h minus one notarized blockchain to everyone else and everyone else will be like, oh, I saw a notarized blockchain of length h minus one. Let's go to iteration h. That's quite nice. Okay, so using this fact, we'll just try to prove liveness.
00:36:32.706 - 00:37:08.574, Speaker B: So at time t, let's say the leader of iteration h enters iteration h and proposes a new block extending some notarized chain. Subclaim one. Every honest node will see a notarization for some block of high h. By time t plus two little delta, something will get notarized. Okay, I claim this. And why is this? Well, at time t plus a little delta, every honest player will have entered iteration h and seeing the block proposal. So they either every, like, either everyone sends a vote for this block, or someone already moved on to the next iteration.
00:37:08.574 - 00:37:46.140, Speaker B: Right? In both of these cases, by time t plus two little delta, everyone will have seen a notarized bloc of high h by. Yeah, by time t plus two little delta. Right. If everyone votes for it, then it gets notarized. If someone's already in the next iteration, then soon everyone will join them in the next iteration. Okay, my second sub claim is that the dummy block of high h cannot be notarized in any honest view before this t two little delta. Why is this? Well, there just wasn't time for it.
00:37:46.140 - 00:38:32.574, Speaker B: So we know that the earliest any honest player could have entered iteration h is time t minus little delta. But no one's timer is going to fire until after time t plus three big message delays minus little delta. So the earliest any honest timer can fire is after this t plus two little delta that we care about. So if I do see a notarized block of high h, it must be a real block from the real block. Closer, like from the. From the leader it cannot be the dummy block and therefore everyone sends a finalized message and everyone will finalize that block. Right? This is in the good leader case.
00:38:32.574 - 00:39:03.636, Speaker B: All I'm trying to say here is that if the leader is good, then its block gets finalized. There's no dummy block. Like if the leader is good and the network is good, there won't be a dummy block. There will be a finalized block from the leader. Right? No one's timers will fire because the network's good. Okay, the liveness for faulty leaders. And this is maybe what Matthew was asking about, the dummy block.
00:39:03.636 - 00:39:51.774, Speaker B: What if not enough people sign the dummy block? Well, I claim that everyone will sign the dummy block. Okay, so claim. If the network is good after GST, any iteration will conclude after about four message delays, three big deltas plus one little delta. Now, even if the leader is malicious, why is this? Well, let time t be when every honest player has entered iteration h, and we know that eventually everyone will enter iteration. Hmm. By time t plus three big delta, either everyone's timer has fired or some honest process already moved on. Right? If I didn't move on, I will fire my timer.
00:39:51.774 - 00:40:30.514, Speaker B: But if there aren't enough dummy votes, then that means someone already moved to the next iteration. And recall that when the timer fires, we vote for the dummy block. And kind of applying the same fact that we did before. Excuse me. That means one message delay later. Either everyone saw a notarized dummy block, if everyone voted for a dummy block, or we got fast forwarded into the next iteration because someone already moved on. Whoever didn't vote for the dummy block already saw a valid notarized blockchain and must have sent it to everyone.
00:40:30.514 - 00:40:58.604, Speaker B: And that's it. That's aliveness proof. We've just shown that, like, iterations will make progress even if the leader is faulty. And we've shown that if the leader is good, then we finalize the block. Okay. And hopefully that, I don't know, was easy, relatively sort of easy to understand. But in conclusion, we have a new consensus protocol called simplex.
00:40:58.604 - 00:41:30.998, Speaker B: It's in the partial synchronous setting, kind of the same as PBFT. It has really nice security proofs and also really nice performance characteristics. And I think if you're interested in kind of this area of consensus and this classical setting, hopefully I've convinced you that our protocol is a nice candidate for you to take a deeper look at. But yeah, that's it for my talk. And I will open the stage for any questions you might have for Martin to chime in. Thank you. Awesome.
00:41:31.126 - 00:41:39.246, Speaker A: Thank you very much. Yeah, that sounds great. If you have any questions, please feel free to come forward and poke some holes into the proposal.
00:41:39.310 - 00:41:44.494, Speaker B: So. Okay.
00:41:44.534 - 00:41:45.874, Speaker A: Matthew, you go ahead.
00:41:47.014 - 00:42:32.524, Speaker B: Yeah. Just a quick question. Can you remind me again, why can people enter into iteration h at t minus little delta before t? So I claim that t minus little like this here. Yeah. I claim that the earliest any honest player can enter iteration H is at t minus little delta. This is because if some honest player entered even earlier, then the leader must have entered even earlier. So basically, when the leader enters iteration h and when some honest player enters iteration h, there must be like the time between them must be small, if that makes sense.
00:42:32.524 - 00:42:47.596, Speaker B: The leader cannot be too slow. Yeah, makes sense. Yeah. I wasn't sure if they were allowed to enter before the leader, basically, but they are. But we know that by like this little fact, which seems very easy, but it's not really. Or. I don't know.
00:42:47.596 - 00:43:02.144, Speaker B: A lot of stuff depends on this fact. Like the fact that an honest player can always pull other honest players into the same iteration within one message delay. It's really nice for us. Yeah. Cool. Thanks.
00:43:03.444 - 00:43:09.342, Speaker C: Is this entire liveness walker? Is this assuming it's after GST? I got a little bit confused with the big delta.
00:43:09.468 - 00:43:34.574, Speaker B: Little delta. Oh, yes. This is all after GST. The distinction between big delta and little delta is like our code. Because we're in this setting, our code will literally say, hey, timeout for 9 seconds. And we have to give the protocol this parameter like three times 3 seconds. We have to say, hey, let's just assume that when the network is good, messages get delivered within 3 seconds.
00:43:34.574 - 00:43:50.794, Speaker B: That's big delta, that three second, that's the parameter. And this little delta is the true message delivery time. And we include it just to be able to reason about when we need a timer. When don't we need a timer?
00:43:51.614 - 00:43:52.070, Speaker C: I see.
00:43:52.102 - 00:44:02.474, Speaker B: Okay, cool. Maybe the bottleneck is the timer. Sometimes. Maybe our network is really good and delivers things in ten microseconds. We still have a bottleneck with this timer.
00:44:03.134 - 00:44:12.206, Speaker C: I see. Okay. And so prior to GST, there's, there's no liveness whatsoever and it should be sort of filled with dummy blocks during that interval. Is that correct or.
00:44:12.310 - 00:44:19.114, Speaker B: Yeah. Okay, cool. Which. Yeah, awesome.
00:44:19.854 - 00:45:05.054, Speaker A: I have one question. Did you look into like, what happens if multiple proposals or nodes, validators that are the next leaders, or supposedly leaders, collaborate? Are each of these iterations completely isolated? So there is no benefit of multiple malicious validators proposals that are in chain. Can they have a more sophisticated strategy where the next few leaders really try to bring something out of concept, extending or working off chains that are not know, like, you know what I mean? Like, did you. Any of these attack vectors.
00:45:05.714 - 00:45:35.804, Speaker B: So our safety proof, this consistency proof, even if all the leaders are dishonest, literally all of them. As long as I finalize a block, then I can be sure that that block is finalized. In terms of liveness, I think we can argue that the worst thing that any malicious leader do is just submit a dummy. Like, so they. Yeah, they can halt the network if they're all malicious, but we always have safety here.
00:45:36.224 - 00:45:37.064, Speaker A: I see.
00:45:37.224 - 00:46:00.344, Speaker B: Yeah. And this is not a new guarantee either. I think, like, all of the classical protocols kind of give such a guarantee. It's only when we get into protocols, like ghost or like longest chain protocols, that we kind of run into a problem where. Where the, like, the proportion of leaders matters more. Yeah, I see.
00:46:01.244 - 00:46:07.172, Speaker A: All right, do we. Do we have any more questions from the audience? Anyone else?
00:46:07.268 - 00:46:07.904, Speaker B: No?
00:46:08.924 - 00:46:12.384, Speaker A: All right, Aaron, do you have anything else to add?
00:46:13.324 - 00:46:14.620, Speaker C: Thank you so much for coming, Benjamin.
00:46:14.652 - 00:46:15.172, Speaker B: This was great.
00:46:15.228 - 00:46:29.022, Speaker C: I was. When I read the write up, I was very confused about the dummy block and block both being able to get two win over three votes. Yeah. This was fantastic talk. It's really interesting and seems very simple. As you intended.
00:46:29.198 - 00:46:34.406, Speaker B: Oh, appreciate that. Yeah. If you have any questions, let me know. If you do anything with it, let me know. Yeah, absolutely.
00:46:34.430 - 00:46:40.554, Speaker C: I'm definitely thinking about implementing it. You guys haven't implemented even a practice implementation yet?
00:46:41.494 - 00:46:58.120, Speaker B: Well, I don't. I haven't written a line of code since, like, 2019, and we haven't. My group is a little, like, distributed right now, so we haven't been able to find students. So. Yeah, I don't know. Things are, I think, slower because we're both theoretical cryptographers. I think things are smaller, like here and.
00:46:58.120 - 00:46:58.928, Speaker B: Yeah.
00:46:59.096 - 00:46:59.720, Speaker A: Very cool.
00:46:59.792 - 00:47:03.528, Speaker C: What's the best way to reach out to you? Are you available on Twitter or email?
00:47:03.696 - 00:47:08.204, Speaker B: You can email me, even message me. I don't know. Yeah, everything's good.
00:47:10.184 - 00:47:21.016, Speaker A: Awesome. Perfect. Yeah. Then thanks a lot for joining us today. As I said, this video will be published on our YouTube channel, so if anyone here wants to refer back to it, feel free to do so.
00:47:21.120 - 00:47:21.488, Speaker B: Awesome.
00:47:21.536 - 00:47:22.520, Speaker A: Thanks a lot, Ben.
00:47:22.672 - 00:47:24.008, Speaker B: Thank you. Appreciate it.
00:47:24.136 - 00:47:24.744, Speaker C: Thanks so much, Ben.
