00:00:10.170 - 00:00:22.320, Speaker A: Hey, everybody, thank you so much for joining today. Today we have Morton Dahl from the Xama team, who's going to be presenting on fully homomorphic encryption inside of the EVM. So thank you so much for coming, Morton, and I'll leave it to you.
00:00:22.930 - 00:00:54.118, Speaker B: Yeah. Hey, Ron, thanks for inviting me. So let's jump straight into it, okay? Yeah. So what I want to talk about today is what we call the FH EVM, or how to build foliage morph encryption into the EVM. Maybe as a context, our approach kind of applies to any type of blockchain, or at least to other vms. But for now, we're focusing just on the EVM. Sama as a company is dedicated, one of the primary focuses is around poliomorphic encryption.
00:00:54.118 - 00:01:50.078, Speaker B: So we have our core fully morph encryption library that's being developed by a large research and engineering team. And then on top of that, we're building these blockchain components. So we're not launching our own blockchain, but we're rather providing the core tech components for anyone that wants to build fully morph encryption into their blockchain. We are currently team for the blockchain about ten, and this is the result of what we've been kind of been working on for the past year and a half. Okay, so I don't want to go into too much details about this. Everything on the blockchain today is public for good and bad, but some use cases definitely require some kind of confidentiality or privacy. Some of the use cases that we're currently focusing on are around keeping balances in a contract private, being able to do blind auctions where you don't have to reel anything about.
00:01:50.078 - 00:02:56.734, Speaker B: Besides, the final winner of the auction, gaming, could be one as well. What we do is we take fully morphe encryption, which is basically a technology that allows you to encrypt certain values and then do computations directly on the ciphertext instead of having to decrypt it and then do the computation. So without going into too many details, we might take an encryption of x, an encryption of Y, and then we can perform a homophobic addition on these two and get a third ciphertext, an encryption of x plus Y. Likewise, we can do comparisons between two encrypted values and then get a new ciphertext, which is then encrypting the comparison between these two plaintext values. But we can do this without being able to decrypt the data. More generally, we can take a function and then homophobically apply it to various ciphertexts and then get an encryption of the function applied to those inputs. Okay, so what fully morph encryption does for the blockchain is that allows you to take the inputs from users, and users can encrypt them, send them to the blockchain without being able to decrypt.
00:02:56.734 - 00:03:42.660, Speaker B: The blockchain can process on this data, including existing state, again without being able to decrypt it. And we can also store the data on blockchain so you don't need to keep a copy of the plain text data on the side for processing. You can really do all this stuff on chain and we can do this, or we design this in a way where we don't have to compromise on, I think, some of the important things. So we're not trying to do anything to hide the computation that's actually going on. So you can still see the logic of the smart contract, so you can still see what you're engaging with. Fhe also allows us to keep the access control logic free for smart contracts to implement whatever they need. So if you want to have certain access paradigms for your data, you can do this.
00:03:42.660 - 00:04:28.820, Speaker B: Concretely, what we do, and we'll see this when we look at the code in a bit, is that you can basically program your own access control. And if a smart contract says okay, this is okay to decrypt, then we decrypt that fhe. And the way we designed it also makes it possible to mix data from different users. So again, if you want to build, for instance, the auction, you want encrypted inputs from all the users, and then you want to compute on this combined data again without being able to decrypt to figure out who won the auction. And likewise, you're also a typical paradigm where you're mixing or you're composing different smart contracts. So in your auction you might have an ESC 20 token that kind of supplies the underlying assets that's being swapped. Okay.
00:04:28.820 - 00:05:17.614, Speaker B: Some of the more advanced use cases is also having a trustlet bridge. So basically you can take a signature key and you can encrypt it, put it on chain, and then you can have a smart contract generate a homophobic signature or a signature homophobically using this encrypted signature key, and then you can decrypt the signature and you can send it wherever you want. So you can basically move your wallet on chain because you can now keep data confidential. I already mentioned blind auction as a potential use case and also voting. So if you want to hide how much or keep confidential, the weight that you put in your certain vote. You can also do that think constitutional DaO or some other use cases where it has been a problem that all the data was public. So some of you are probably familiar with serial knowledge.
00:05:17.614 - 00:06:05.930, Speaker B: So just a quick word on how we see fhe comparing to serial knowledge. We see them as being really complementary. They both attempt to provide, or they both have a solution for providing confidentiality or privacy. We see stereo knowledge more as a solution for scalability, for roll ups for instance, where we think polymorphic encryption has an advantage is this composability both between mixing data from different users, but also mixing contract, having one contract call another contract. One of the problems with steel knowledge is that the computation still has to happen or the processing of the data still has to happen on plaintext. And then you're just generating a proof that you did that computation correctly. So this means that if you're taking data from multiple users, then you need to find one entity that can see the plaintext data and then do the computation on that and prove that it did it correctly.
00:06:05.930 - 00:06:59.010, Speaker B: And likewise, since you need this copy of the plaintext data off chain, you don't get the full benefits of having all the data on chain s and fhe, on the other hand, you can also mix the two. So fhe is not the silver bullet. Fhe together with the Ck, for instance, could be a nice way of getting confidentiality in a scalable way. Okay, so looking at the components that we provide or the FH EVM, basically what we do is all the three dots here represent validators on the blockchain. All the data on the blockchain, including the inputs from the users, are then encrypted under a single global public fhe key. So this is like a public key you typically know in classical crypto in an asymmetric key pair, except here it's a key that allows you to actually process on the data. So there is this public key is known to the world.
00:06:59.010 - 00:07:41.102, Speaker B: Users can encrypt the data under it, processing happening under this key. But the question is, how do we then get to the key or the corresponding secret key? Because we could generate a key pair and then share it to the validators. But then we have the problem that someone has seen the secret decryption key and could then break confidentiality of the chain. So we have a bunch of threshold protocols that allows us to ask the validators to collectively generate these keys and do operations as we see. And the first one is that the validators start out with nothing, and then between them they can run a threshold protocol that will then generate shares of the secret key. So what we end up with is now we have secret shares of the secret key shared between the validators. On their own.
00:07:41.102 - 00:08:36.850, Speaker B: These shares of the secret key doesn't leak anything, but they can come together and they can jointly decide, okay, now we want to use the key for certain operations, as we'll see. But there is a cryptographic assurance here that seeing just parts of the key doesn't give you any extra information about the actual key and doesn't allow you to do any computations, decryptions, for instance, with this key. Okay, and then inputs are really simple, as I said. So the user here just has an x and he downloads the global public fhe key, encrypts the inputs, sends it to the validators. When you want to do computations on this, the validators, they execute the smart contracts. The smart contracts, as we'll see in a bit, can execute homophobic operations. So if the validators or the blockchain start out with an encryption of x and encryption of y, then the smart contract can say, okay, now I want to compute an encryption of C based on these two inputs using homophobic operations.
00:08:36.850 - 00:09:23.246, Speaker B: Okay, at some point we also want to be able to decrypt values. Currently in two cases. One is in a smart contract. If you want to make certain assertions with a require statement you want to decrypt, that require to see, okay, should we continue this transaction or not? And of course also sometimes you want to get data out to the users. So we also have a threshold protocol where the validators, again, they will not see the full key, but they can run a protocol between them that will then take this encryption of x decrypted and then say, okay, here is the plain text inside the ciphertext. We also have what we call threshold re encryption. So in this case there is an additional key here, blue, we'll see on the next slide where it's coming from.
00:09:23.246 - 00:09:52.406, Speaker B: And then given this blue key, which is just a public key, and the encryption of x, they will perform an re encryption. So you now get an encryption of x under this new key. And they will do this without being able to, without decrypting the result in between. So the use case for this is when user wants to pull the data out of the blockchain. We also want to keep that confidential. We still want to keep that confidential for the validators. So in this case, the user will upload or generate a key pair locally.
00:09:52.406 - 00:10:33.490, Speaker B: He will upload the public key to the validators. The validators will run re encryption to get an encryption, in this case of x under the key they just received, and then send this encryption back to the user. Since he generated the key pair, he also knows the private decryption key, so he can decrypt this blue cycletext and obtain the plain text value. Okay, so where we are now is that we have a devnet that I'll be using here in a bit. And what we run in there is we're just running a single validator node. So this is just a proof of concept where it has a copy of the decryption key. It's running a homophobic library on cpus.
00:10:33.490 - 00:10:57.806, Speaker B: We're expecting speed ups from this, from moving to other hardware processing units. And we have a lot of exciting stuff coming. Larger data types, still large groups for the inputs. We're actually rolling out the threshold protocols later this year. And. Yeah, also adding support for various hardware accelerators. Okay, but let's try to look at the code.
00:10:57.806 - 00:11:45.360, Speaker B: Keep this a bit hands on. So what I have here, I opened up typical remix, and one of the things we wanted to do was to not change anything on the developer side of things. So as a smart contract developer, of course there's a few things you need to adapt to, but you don't need to change your tool chain. So we're just using ordinary remix here. And we could start by writing our own, an ESC 20 contract where we have, let's say, a public owner of it. Can you see this, please let me know if it's too small. Let's say that the owner of the contract is whoever created it.
00:11:45.360 - 00:12:11.960, Speaker B: And then we'll have our mapping here, our balances, okay. And of course we can compile this and we could actually. Let me just check that. Okay. The network is working. Okay, so nothing fancy so far. And then the first thing that the smart contract developer can do is they can import our, let me just make sure I grab the right one here.
00:12:11.960 - 00:12:52.820, Speaker B: They can import our solidity library, available online for operating on encrypted data. When you do this, one of the things you get is you get a new data type, which we call an EU int. So an encrypted Un 32. And by changing balances to be an EU int, we're now saying that, okay, you can still see that this address maps to something, but instead of mapping to a plain text balance, it's now mapping to an encrypted balance. So you're just seeing basically a ciphertext that you can't decrypt. We can try to compile this. Yeah, seems to run.
00:12:52.820 - 00:13:32.800, Speaker B: So in order to do something useful, maybe we want to add a minting function. So we say mint EU in and now we want to take some amount from the user. So we say again, okay, we want an EU in 32, and then we want to require that the sender of this transaction is the owner. And if so, then we update the balance. The next thing we see here is that we can now do an homorphic operation. So we're working on having operator overloading for this. So you don't have to have add, but you can just use the plus.
00:13:32.800 - 00:14:20.590, Speaker B: So what will happen here is we will take the euint that was associated previously with the owner, the new EU we got in from the user, and then homophobically add these two together to update the ciphertext that was sold here. And this is done without decrypting. So this will compile and this will be useful. But it's actually not exactly what we want. In order to understand that, I just want to dig into what this is. Eun 32 actually, and the EU in represents a ciphertext that has already been validated and is already on chain. But what we're having here is we're having a function that's being called by a user, where the user is providing the ciphertext.
00:14:20.590 - 00:15:13.490, Speaker B: And the reason that there is a difference here is we want to prevent, or we have to prevent users or malicious smart contract developers from essentially grabbing a ciphertext on chain and then sending it into a smart contract and have the smart contract decrypted. Part of the reason for this is, again, we wanted to keep the access control logic flexible. So as we'll see, it's really up to a smart contract to do this. So it'll be very easy to write a malicious smart contract that just accepts any ciphertext coming in from the user and then ask for this to be decrypted. And that's obviously breaking the whole confidentiality that we're trying to ensure. So when the ciphertext is coming in from the user, we actually need to kind of consider it as a raw ciphertext that hasn't been validated yet. And in order to do that, I'm going to change this to bytes, call data, and say this is the ciphertext.
00:15:13.490 - 00:16:32.780, Speaker B: And then in order to do this actual check EU in 32 two, I'm going to ask the blockchain to validate the ciphertext when it's coming. Okay, so what happens here is that in the call to convert it, the ciphertext actually comes with a serial knowledge, proof of knowledge that the user knew what was inside the ciphertext. So in other words, if he just grabs a ciphertext on chain, he won't be able to provide this proof, so he can't use it as a decryption oracle or intuitively, since he has proved that he already knows the plain text inside the ciphertext. If he were to write a smart contract that would decrypt that ciphertext, he's not learning anything new. So that's why this conversion is needed when it's data coming or it's a function being called from the user. The mint function we started out with was useful if you want to compose different smart contracts. If you want one contract that already has an EU int that has already been validated from the user to calling our mint function, then it would just pass along an EU in 32.
00:16:32.780 - 00:17:43.550, Speaker B: Another reason that we need this to acknowledge proof, it's more like a technical detail, is that the underlying encryption scheme that provides the fhe operations and the ciphertext require that basically the ciphertext is well formed. So it's not any random bit string, it's a ciphertext. It has to be kind of matching a certain form, otherwise there could be some leakage of the secret key associated with the public FHCP. Okay, so now we have our minting function, we can try to compile it and let's actually try to deploy it. And then we have a, just for fun, we have an associated Java SDK for interacting with an encrypted blockchain. So in this script we're taking an amount as input defaulting to 1000. We're then encrypting it on the client side and then sending a transaction, calling this mint transaction.
00:17:43.550 - 00:19:13.360, Speaker B: I try to execute that contract m run. Okay, let's have a look at our network. So here we have the devnet that we just interacted with and maybe not. Okay, so here we see our transaction. And what I wanted to show is this is the payload of the transaction. I don't have a way of decoding this for you, so I guess you'll have to take my word for it that this is really a ciphertext. Every ciphertext going into the blockchain is currently around 8 EU n 32 is around 8 is one of the things that we're also working on decreasing.
00:19:13.360 - 00:20:03.250, Speaker B: Okay, so we now minted a coin or 1000 tokens. The next thing we could try to do is try and get the balance of this. And you may have noticed that when I defined the mapping up here, I didn't specify if this was written public or internal. These euins, we now understand that they represent a ciphertext that has already been kind of ingested into the system, has been verified with the serial knowledge, proof and so on. Very concretely, what they are, they are just a hash of the underlying ciphertext. So when we ingest the ciphertext, like in the min function, we store the ciphertext on chain, and then we give a hash of that ciphertext to the smart contract. So this means that these Eu n 32, they're very easy to pass around, very efficient to pass around.
00:20:03.250 - 00:21:13.204, Speaker B: And then we do some reference counting garbage collection so that you don't have to, if you're no longer using ciphertext, then the memory can be garbage collected. But this also means that if you were to just read this EUn 32 as it is, then not only would it be a ciphertext that's encrypted under a global fhe key that you don't know the private decryption key for, it would be a hash of that ciphertext. So just reading the balance role like this, or the EUN 32 like this, is not useful. And what we actually need is we need to inject some logic that allows us to now do this re encryption that we've shown before, where we take the EU n 32, we take the associated ciphertext, and then we re encrypt that ciphertext under a user provided key. So if we define a function here, balance off, that takes a user key. So public key, I want this to be able to call from users, just a view function, and then it returns this new ciphertext. To do the re encryption, we have another function call here, reencrypt.
00:21:13.204 - 00:21:52.196, Speaker B: If you re encrypt, which takes the balances of message sender and re encrypts it under this public key. And for convenience. If this key was not or this balance was not defined, then we return the encryption of zero. Okay, encrypt. Okay, so this will work. But there is an obvious problem here. So, one is, this is a view function.
00:21:52.196 - 00:22:49.220, Speaker B: So when this function is not being signed by the user, when it's coming in, so we don't actually know that message sender is who they're supposed to be. In other words, it will be easy to fake a view function call and impersonate as someone else, or it would be easy to take an existing call and then replace the public key with something that the adversary knows. So what we need here is we need a link between the public key and message sender. And we're leaving this up to the smart contract how they want to implement this. One recommendation we have is to use EIP 712. So when we generate, when the user generates the signature for his public key, he will do so in our case on this demo with metamask. And then when metamask pops up to ask for a signature, we can actually show him some intelligent message instead of just saying okay, sign these random bytes.
00:22:49.220 - 00:23:41.110, Speaker B: So in order for that to work, I cheated a bit. So I'm just going to import a standard component, then we'll add this modifier. Okay, what this modifier does is it now takes the public key and the signature. Then it checks that the signer, first of all that it was a valid signature on the public key. Then it extracts the signer and require that the signer is message sender. So if I add this one up here, let me just verify. We say okay, we now want a public key, then we need to take the signature as inputs as well write.
00:23:41.110 - 00:25:11.150, Speaker B: I mean then I need to do one thing, I need to say that this one is twelve, and when we instantiate this, so again we're leaving this open to the smart contract developer. The only thing we need is really the public key. But now we can check a signature on that public key and let's see if we can compile this. Yeah, let's try to deploy, it's the client side script I'm running here. What we do is we generate essentially a key pair on the client. So a public key and a private key. Then we ask here, I just set up the wallet to, there's a hard coded key to generate a signature on the public key and then I'm calling balance off with the public key and the signature.
00:25:11.150 - 00:25:43.502, Speaker B: This is all part of our FHC VM Javascript SDK. Okay. But yeah, our balance was zero here because it's now a new contract. So we want to see anything we need to make again, NPM check with the block explorer. Okay, it seems to be successful. Yeah, all good. And then we can try to run balance off again.
00:25:43.502 - 00:26:23.450, Speaker B: And we now have 1000 tokens. Okay, so the last thing I wanted to show is okay, we can now mint coins and we can get the balance off, but we also need to be able to be nice to be able to transfer things. So let's make a transfer function address two. And again, if this was an internal function or to be called by another smart contract, we would pass in an EUN 32 amount here for instance. But since this is a user call function where we want to have a ciphertext coming in from the user. We need to do this verification step. So again, these are just the amount ciphertext.
00:26:23.450 - 00:27:08.982, Speaker B: And then we want to convert this, do the serial knowledge checks. 32 this. So now we got our amount. Then we can also homomorphically compute if we have enough, if the amount is less than the current balance of the sender. Again, we will compute this homomorphically without decrypting any of the data. And then we will arrive with an encrypted boolean. And then we basically want to require that this is true.
00:27:08.982 - 00:28:01.310, Speaker B: So what happens here is when we ask here we ask the validators to perform a decryption of this boolean value and then require that this decrypted boolean value was true. And if that's okay, then we can say balances. We can add the amount to the recipient and subtract it from the. Let me just close the window here. One sec. Our Paris is in the middle of Paris. Just our office in the middle of Paris, just in case.
00:28:01.310 - 00:28:33.816, Speaker B: Any doubt about that? Okay, so yeah, so the thing to highlight here is of course that we can do. These require statements. There is a small leakage involved with this. And I'll get back to that in a second. But yeah, now we have a transfer function as well. So I will compile the contract just to see if it works, try to deploy it, copy it. Here's right.
00:28:33.816 - 00:29:18.296, Speaker B: Now, since it's a new contract, I don't have any balance on it. Mint ish. We should have 1000 then. I have a different account here. Transfer to. Now we're calling this new transfer function. We're sending 100 tokens.
00:29:18.296 - 00:29:51.824, Speaker B: If I check the balance off of the all account, I see you have 900 left. We have a quick demo website here as well. I can type in the contract just to show this on the user side. So we now have the contract. Let me make sure I'm switched to the one the account we just send tokens to. And then when I get balanced now, so this is a step where we're locally generating a key pair and then doing a signature. We'll see that metamask pops up.
00:29:51.824 - 00:30:28.944, Speaker B: We can say, okay, we're asking for a re encrypt using this new generated public key. I'm okay with that. And then we get back 100 for the balance. Okay then let me jump back into this. The first thing we saw was this EU N 32 that represents an encrypted value that can be used for computation, storage, composition and so on. And as I said, is very efficient to pass around because it just handles or hashes of ciphertext. We have EU and 816 32, we're adding 64, 128.
00:30:28.944 - 00:31:13.580, Speaker B: We can do various operations, add more multiplication comparisons on this. The second thing we saw was that when it's a user call function, you have to convert it into an EU int. And what happens during that conversion is basically we check these two things. The first, that the ciphertext is well formed from a cryptographic perspective, that there's no associated risk by interpreting these bytes as a ciphertext. And then also this idea that the user needs to prove that he knew the underlying plaintext, because otherwise he could use this as a kind of a decryption oracle. The blockchain we had the re encrypt. I don't think I need to cover that anymore.
00:31:13.580 - 00:31:52.552, Speaker B: And then the requirement where we basically decrypt the boolean value and then do a require on that. As I said, this leaks something. It's not always clear what it leaks, but it leaks one bit of information, and then what can be deduced from that one bit of information, basically whether or not the transaction was reverted. Maybe that's too much in some cases. So as an alternative to a require, we also have what's called the cmux. So in the cmux, you compute the encrypted value that you want to propagate forward if your boolean is true, and the value that you want to propagate forward if your encrypted boolean is false. And then you do basically a condition on this.
00:31:52.552 - 00:32:21.990, Speaker B: So this generates a fresh ciphertext, so you won't be able to compare the result of the Cmox with e true value or e false value. In this case, it will be a fresh ciphertext and it will contain, or the plain text inside will be the same as e true value or e false value, depending on e condition. Okay. And that's it on my side. And yeah, we'd love to hear or answer any questions you might have on this.
00:32:27.240 - 00:32:47.790, Speaker C: Great, it was a great presentation. I have a mountain of questions, so if anyone wants to go before me, I feel like I might take a while. But yeah, if there's no one else that has any questions, I can start rattling them off. I was taking notes. Maybe, Martin, you could go first.
00:32:49.200 - 00:32:49.660, Speaker B: Yeah.
00:32:49.730 - 00:33:13.408, Speaker A: I just heard in the short that you said the UN doesn't have 32 bytes anymore, but was like the size increases to, I think, a couple of kilobytes. So I was wondering how much is kind of this overhead. We have to allocate storage there for the encrypted un compared to the relatively small regular uns.
00:33:13.584 - 00:33:55.536, Speaker B: So an encrypted EU end on its own, since it's just a hash, it's 256 bits, so it's very small. But the underlying ciphertext that is pointing to is significantly larger. So when it's an input coming from the user. Currently it's around 8 kb for a 32 bit value, but actually for all of them, all the way up to an EU in 256 that we also experimented with. There's a blow up there for the inputs. And then also when you compute on the ciphertext, you have to kind of convert them from the input format into a format that you can compute on them. And currently the size there is around 100.
00:33:55.536 - 00:34:05.700, Speaker B: We're working on basically squeezing all this stuff down. That's one of the key research focuses we have, getting the sizes smaller.
00:34:07.240 - 00:34:14.090, Speaker C: Is the 8 kb primarily the zero knowledge proof or is it the actual encrypted value?
00:34:14.780 - 00:34:32.540, Speaker B: So that's the actual encrypted value. Yeah, sorry. The devnet we just saw, I think I had a quick slide on. It only contains the actual ciphertext. And then we're adding the seal knowledge proof. But the seal knowledge proof itself is not massive, it's significantly smaller than the ciphertext.
00:34:35.440 - 00:34:45.904, Speaker A: One question I was going to ask Morton. Let me know if this is too much to go into now, but could you talk a bit about what your key generation protocol is for the global homomorphic key?
00:34:46.102 - 00:35:02.390, Speaker B: So for that one we're actually just using a generic protocol. This is only happening once, so we don't have to pay any special attention to it. What we've been trying to optimize is really the decryption routine and the re encryption routine because those are being executed much more often.
00:35:05.240 - 00:35:06.230, Speaker A: Go ahead.
00:35:06.840 - 00:35:21.324, Speaker B: No, I just wanted to add that. So one of the benefits we have is that Sama as a company is only focusing on one encryption scheme, tfhe. So it means that the MPC or the threshold protocols that we generate, we can optimize those for that particular encryption scheme. Cool.
00:35:21.442 - 00:35:30.092, Speaker A: I was going to ask, does that mean that once you do the key generation protocol, you're locked into the validator set from that point forward? And it's not a dynamic validator set, no.
00:35:30.146 - 00:35:36.416, Speaker B: So we have resharing protocols. So when you go from one set of validators to the other, they can basically reshare the shares of the key.
00:35:36.518 - 00:35:36.944, Speaker A: I see.
00:35:36.982 - 00:35:37.184, Speaker B: Okay.
00:35:37.222 - 00:35:43.876, Speaker A: And so the VM needs to be notified whenever there's a change to the validator set and goes through this key resharing protocol, is that correct?
00:35:43.978 - 00:35:46.004, Speaker B: Yeah. Okay. What protocol do you use?
00:35:46.042 - 00:35:47.696, Speaker A: I know you said you're using one off the shelf.
00:35:47.728 - 00:35:56.196, Speaker B: I'm just curious, which one for the key generation? Yes, good question. Actually, we have a white paper on this, so I'm happy to send across all those details.
00:35:56.228 - 00:36:39.700, Speaker A: Yeah, that'd be awesome. I'd love to look into it. The one other question I was going to ask is can you talk more about how you actually handle the decryption operation that happens within the EVM? For, let's say you perform one, like there's one opcode that needs to handle this decryption operation, but in order to do that decryption operation, you actually need to do this threshold across the validator set. So does that mean that in order to process that individual opcode or precompute or however this is happening on the back end, that every validator that you need to go through this protocol in order to decrypt a value at that point, and everybody has to have reached that point in the execution of the EVM to know that they're authorized to perform that operation?
00:36:40.360 - 00:37:11.948, Speaker B: Yeah, exactly. So basically we're asking all the validators to execute the smart contract code, in this case even for view functions, because we want the ground source or truth for whether or not decryption is allowed. So basically this access control to be determined by the smart contract so that each validator will then execute the smart contract and if they reach the re encrypt they will say okay, but now I have independently reached the point where I'm okay to enter this threshold protocol and then they trigger the threshold protocol between all the validators.
00:37:12.044 - 00:37:21.590, Speaker A: I see. Okay, so how do you handle the case then of answering an eth call, API call, does that have to go through the validator set as well?
00:37:22.680 - 00:37:29.408, Speaker B: So everything that's kind of native to the blockchain we can just execute as normal is only when you're running the smart contracts.
00:37:29.504 - 00:37:30.052, Speaker A: I see.
00:37:30.106 - 00:37:30.710, Speaker B: Cool.
00:37:32.360 - 00:37:53.340, Speaker C: To touch on that. I like a little bit more though, with the ERC 20 example of get balance, that's typically like a free call that you can look up a value on chain, but if it's requiring the participation of the full validator set, do you have to charge for that? Does that remove the ability to basically freely check your balance?
00:37:53.920 - 00:38:24.570, Speaker B: Yeah, it would. So we are looking into how to incentivize validators to be part of this. Obviously you can do things around caching, but that wouldn't necessarily be efficient. So one benefit of the underlying encryption scheme is that it's deterministic in the implementation as well. So caching is an opt in, unless of course the balance is changing. But yeah, right now in the current setup, in order to execute view functions, you can't just do that on an arbitrary full node. Basically, you need to touch the validators and then they agree on this.
00:38:26.060 - 00:39:06.150, Speaker A: One other question. So if you have to perform this threshold operation across the validator set of the network in order to process a block and potentially get multiple different opcodes, do you do any kind of optimization of like, we've accepted this block and then sort of defer the verification of the state route so that you can then after the block, after the ordering of transactions has already been accepted, you then actually go through and say, all right, this is the set of operations that we need to do. How do you actually go about sort of efficiently figuring out, this is the set of operations the validator set needs to collaborate to decrypt versus just in the middle of the execution of the EVM. Okay, pause, decrypt, continue execution, where you have to wait on everybody to hit that point.
00:39:06.680 - 00:39:43.120, Speaker B: So we haven't actually looked into much of this. We're kind of just executing along the way. One thing I don't think I mentioned in the slide, we do have what we call an optimistic require statement. So instead of right now, and every time you hit a required, there is a threshold protocol for the encryption of that boolean being triggered. But it's a nice pattern as well to say, okay, but we can just record that. Okay, this requirement needs to be checked before we can do a decryption or before we do a re encryption. So you can kind of accumulate the requires in an optimistic way and then just check them before you do decryption.
00:39:43.120 - 00:40:19.580, Speaker B: We encrypt. Sorry, but of course there's a trade off here because you are still paying for all the computations up until that require. So we have both. If you want to do like an immediate require and then immediately trigger the threshold protocols, then you can do that, but you can also do it optimistically. So we've also seen applications where people feel like too much leakage is happening by the transaction itself being reverted. And that's where things like the Cmux comes in, that basically you would never revert the transaction. You would effectively turn into a no op if the conditions were not satisfied.
00:40:19.580 - 00:40:29.032, Speaker B: The downside, of course, is the additional cost on gas when you do. That's really interesting. Go ahead, Stephen.
00:40:29.176 - 00:41:12.220, Speaker C: I was going to say so for the require, really in general, any logical branches. I understand that you're going to have to have some form of decryption encryption mechanism, but could you instead use some of more constant time operations? So in a lot of encryption stuff, in order to hide private keys, you have these constant time things where they basically do all the same operations every single time, regardless of any branches or logical branches, to basically avoid timing attacks. But in this case, could you do a similar mechanism to basically avoid these encryption?
00:41:13.680 - 00:42:02.444, Speaker B: Yeah, so this will be a way to, for instance, to get around the if branching where you need to run. I think in the MPC or the secure computation literature is typically called like a straight line program where you're executing all this stuff independently. We thought about having a compiler kind of step. I'm not sure how we would inject it into the solidity compiler, because again, we wanted to keep everything on the developer side, like untouched, you just import the library. But you could imagine at least having kind of a compiler step that would transform an if else statement into this kind of straight line constantine program. The problem there is, besides having to touch on the developer side, is also that the solidity code is typically not side effect free. Right.
00:42:02.444 - 00:43:00.784, Speaker B: So you might touch storage in one of the branches and not in the other one, and then all of a sudden you have to touch storage in both branches when you do things with the CMUX. So you can reformulate all of this stuff with the CMUX. But we figured it wouldn't necessarily be intuitive for the developer that, okay, I always have to pay for storage, and there could be a potential race condition. I don't know how you would even solve that, necessarily, where if the true branch is executed before the false branch, then whatever state you become this complicated, it could be done. I think theoretically it could be done, but in practice and giving a good developer experience, I think it's a bit tricky. We had a hackathon after ECC and this was one of the issues that we kind of came across, that people are not naturally used to thinking about CMOX, for instance, and using that instead.
00:43:00.982 - 00:43:36.270, Speaker C: I wonder if you could use some trick where you keep track of all of the evaluated conditions. So in assembly for some architectures, they'll have specific opcodes where they'd be like compare and add or something. And if this evaluates to true, then add. Otherwise no op, right? And then if you have an if else you can just have basically both of those where you have the if true, add in the first branch. Otherwise no op. And then the other case, if false ad no op kind of thing. And you basically just inline both.
00:43:36.270 - 00:44:00.080, Speaker C: Be pretty interesting. I don't know how that would. Yeah, I'm sure it'd be a huge pain to implement, but basically I think in order for this to work in a network that is actually larger, I feel like you're going to have to avoid as much of the threshold stuff as possible in the actual execution of the block, which is why I'm kind of like diving so deep into this. Specifically.
00:44:02.260 - 00:44:32.252, Speaker B: One of the things I would take away from some feedback is also that people, first of all, CMUX is a confusing term for this. It makes sense in the technical literature, but it's not something that people are used to thinking about. So maybe we rename it to if then else as a function call and then it still takes like three inputs, but it's called something else. But yeah. Also teaching around what are the good practices for dealing with some of these issues.
00:44:32.386 - 00:44:41.810, Speaker C: The CBox still requires that there's like a threshold encrypt. Re encrypt internally though, right, to change what the cipher text is.
00:44:42.260 - 00:45:16.300, Speaker B: No. So that's a purely local operation. That's just a homophobic operation. So you can, I think there's various ways of implementing it. I think the one we implemented is, let's see. So you take the true value and you subtract the false value and you multiply that with. How does it look? Then you multiply.
00:45:16.300 - 00:45:33.650, Speaker B: Yeah. So you take the true value, you subtract the false value, you multiply that with the condition and then you add the false value. It doesn't. Since it's integers this will work.
00:45:34.900 - 00:45:44.132, Speaker C: Interesting. And that still ends up producing an unknown ciphertext at the end that's independent from the first two.
00:45:44.266 - 00:45:52.090, Speaker B: Yeah, because you're essentially evaluating this small linear function over the ciphertext. That's cool.
00:45:58.140 - 00:46:37.860, Speaker C: I'll just start asking some of my questions too. Unless anyone else has. So is the threshold decryption verifiable? What I mean by that is obviously the validators are going to be partaking in this protocol and they're going to be generating the decrypted value. But as a user you're not going to be able to actually look at this chain and understand these values. Right. I personally think trusting the validator set is kind of implicit in blockchains, but there's a lot of people that like the ability to locally verify all the state modifications. And is that something that you kind of have to give up for this?
00:46:38.010 - 00:47:19.330, Speaker B: Yeah, excellent question. It's tricky because ideally we would like to tie all this stuff down to proof of stake. So there is kind of two separations like execution and consensus. We're not touching any of that because the homorphic operations are just done locally. So all of that stuff is still tied to proof of stake. But where we are relying on a threshold assumption right now is for the decryptions, the re encryptions. And tying that to proof of stake so far is very expensive, or expensive in terms of having to generate proofs and so on.
00:47:19.330 - 00:48:14.336, Speaker B: So what we do is we're just providing the components for someone to build a blockchain. So we're trying to keep this a bit flexible about, okay, what would the partner actually want to do? In this particular case, we also have two suites of protocols. One for if you're running like five validators, so think more in a permission setting and then another set, which we're currently benchmarking around 40 validators, I think, and then give some flexibility there. But yeah, it is a good question. How could we get efficient, publicly verifiable MPC protocols for this stuff? And I think the research is still going on on that as an interesting kind of example of this. So when we do the re encrypts right now for performance reasons, what we do. Okay, so when you do the re encrypt, you basically run an NPC protocol to take the fully morphe encrypted ciphertext and then turn it into secret shares among the validators.
00:48:14.336 - 00:49:31.196, Speaker B: And then instead of kind of turning that secret share of the value into an encryption under the user supplied classical public key, we just encrypt each share with the user's key and then send them back to the user, and then he can decrypt and do the reconstruction. The secret sharing scheme we used for all of it is a robust secret sharing scheme, meaning that we can detect, not only can people or validators disappear, we can also detect cheating. But in this particular case where we currently are, is that the user, since he will see these shares, he can do the robust reconstruction and he will know which validator lied. But he wouldn't be able to do anything about it with the current setup because otherwise he would have to run an expensive seal knowledge proof. But he basically has a choice between saying, okay, I know that some of the validators lied, so I don't trust this result, or I'm going to reveal enough shares so that someone else can really see that one of the validators lied, but revealing enough shares for someone to check this also reveals his own value. So he had this kind of choice between, okay, either I ignore the value because ignored it, or I tell the world, but then I also tell them what my private value was. So there is an efficiency trade off there.
00:49:31.196 - 00:49:39.360, Speaker B: In principle, we think it can be done, but for efficiency reasons, it's still interesting to kind of consider a middle ground.
00:49:39.700 - 00:50:17.996, Speaker C: That's super interesting. Yeah. Thank you. If no one else, I'll keep going. So, I know we had talked about how when verifying the block, you have to kind of perform lockstep decryption encryption on the network to be able to actually continue processing through. Have you considered. Okay, I guess, first question, how does that work with block building? Is the block builder the person that actually has to do this in the first place, or is the whole network building the block as they do this?
00:50:18.178 - 00:50:45.280, Speaker B: How does that work underneath, at least for the Devnet here? This one is based on tendermint. So the block has basically been committed to. And then it's a question of just executing that block afterwards. So the block builder doesn't have a special role outside of a normal consensus. In this case, they determine the block, and then afterwards they figure out which transactions were going through and which were reverted.
00:50:45.440 - 00:51:18.400, Speaker C: Do you still have gas refunds, though? It's like an early revert happens, or say you want to do a defi swap, and in the case where you actually perform the swap, it's really expensive, but in the case that you just check your slippage and then immediately return, do you actually return that gas that wasn't used? And if so, how can you prevent someone from just kind of submitting large transactions that don't actually do anything on chain?
00:51:19.060 - 00:51:37.220, Speaker B: So we're not actually touching any of that. We're not encrypting, let's say, the native coin or currency for the blockchain. So you can compute the gas cost, and then if you want to revert some of that or pay back some of that gas cost, you can do that. None of that is encrypted. So none of that touches the threshold network.
00:51:38.520 - 00:51:47.048, Speaker C: But I guess, how can you actually calculate what the total gas used of a transaction was without executing it? Is, I guess my question.
00:51:47.214 - 00:51:48.744, Speaker B: Oh, like gas estimation, how.
00:51:48.782 - 00:52:14.668, Speaker C: That's gas estimation, I think, is typically off chain, like guessing the gas limit, but on chain, if I'm the block builder and I have 15 million gas for the block limit, and I have a transaction whose gas limit is 15 million, it might use up to the whole block, and without executing it, I don't actually know how much gas it uses.
00:52:14.844 - 00:52:42.090, Speaker B: Yeah, that's true. This number you won't have. Okay, yeah. The block builder has less information related to this. We also looked into whether or not it could be a solution for mev because you kind of hide this information. But there is a question of efficiency there that this is probably down the line.
00:52:44.620 - 00:53:08.160, Speaker C: I think my last question. I know we're running low on time, but this is really my last question. So is all of the integer operations like the multiplies and adds, is that all finite field stuff, or do you have to have any special handling for overflows or things like that? This might be specific to the homomorphic explicitly operations.
00:53:08.840 - 00:53:12.704, Speaker B: Are you thinking from a solidity perspective or the underlying encryption scheme?
00:53:12.832 - 00:53:14.500, Speaker C: Underlying encryption scheme.
00:53:14.840 - 00:53:44.460, Speaker B: So it's modular arithmetic underneath. Yeah, but there is a question related to solidity, right. That sometimes you will want to have overflow checking in your smart contract. This will be expensive to do because this will be a decryption to see if something actually overflow. Or I guess you can kind of correct for it if you can detect homomorphically if an overflow happened. But you wouldn't know because that will be an encrypted value. So either you do something with cmugs where you have, if an overflow happened, I want this value.
00:53:44.460 - 00:53:51.760, Speaker B: Otherwise I just accept it. But yeah, the underlying encryption scheme is based on modular recently.
00:53:53.780 - 00:54:08.660, Speaker A: So after all the hardball questions from Steven, I was going to throw one softball in there. What use case are you most excited about for this? And what's the most interesting and exciting feedback that you've received from developers that were playing around with the last week at XCC?
00:54:09.560 - 00:54:56.260, Speaker B: Oh, good question. So what did we have? We had someone implemented the dark pool for swapping. Someone did voting. I think the, the one that we're currently seeing some interest in, not necessarily from the hackathon, I think someone did that hackathon as well. But for the overall, we think there is a good chance for tokenization as a use case for this, where you want to keep some of this data private. So you want to see what's going on, you want to see the computation that's happening. You just want to keep the data that's being computed on confidential.
00:54:58.600 - 00:55:42.950, Speaker A: Okay, then I have two more slightly hard questions. Have you thought about like as a, and I'm not a cryptographer, so let me know if this is a horrible question, but have you thought about having data that's on chain that's encrypted to both the global homomorphic public key as well as potentially owned by someone off chain so, for example, my balance on chain might be such that the global homomorphic key can decrypt it, as well as my own key that I have off chain could decrypt it as well. Would that be something that would be interesting? Because then you can request just the ciphertext, which every validator should have, and I could even run my own validator, which is not participating in the decryption, and then I could decrypt my own relevant values, because that sounds to me like if that were possible, that would be really interesting and escape a lot of these issues.
00:55:43.320 - 00:55:46.020, Speaker B: So you're thinking to avoid the re encryption step, basically?
00:55:46.090 - 00:56:10.060, Speaker A: Yeah, to avoid the re encryption step where you have to send it to me off chain, would it be possible to say, okay, we have this ciphertext and that it can actually be decrypted by both the global homomorphic key as well as some key that I own as the user. So you're constantly encrypting it to two parties, both the validator sets shared key as well as some person off chain.
00:56:11.520 - 00:56:53.428, Speaker B: We kind of started out, so we've gone through a few iterations, and initially we thought about having a separate key per user, although maybe that's not exactly what you're saying, but at least we thought about having a key per user. And at some point we also thought about having a key per smart contract. The problem is that it really gets in the way of composition. So, for instance, in the blind auction example I gave earlier, you would have data coming in from different users encrypted under different public keys. And then when you want to actually compute the winner of the auction, you end up with this ciphertext, which is now encrypted under a bunch of user keys. You can do this. So there are ways you can run a decryption protocol that then takes inputs from all the users.
00:56:53.428 - 00:57:31.300, Speaker B: But the problem is that then you would have all the users to kind of come back and provide part of given allowance that, okay, now you can do this. So if a user drops out, then you're a bit out of luck on this. So having distinct user keys really gets in the way of composition. And then the same for contracts, right, that you might say, okay, one contract has its own public key and all the data for the contract. But then having the blind auction called the ESC 20 token, that starts to be complicated for the same reasons as well. So that's why in the end we said, okay, let's have a single public key, and then all the data is just. And then you're free to compute on it any way you want.
00:57:31.300 - 00:57:31.812, Speaker B: Cool.
00:57:31.866 - 00:57:52.350, Speaker A: And then my other slightly harder question was, have you thought about reducing some of the functionality to avoid some of these issues? Because it sounds like what you have is really cool. And there are a couple of things that make things more difficult. So I'm curious if you guys have thought about just. All right, these are hard problems. Punt them down the road. This smaller set of functionality is really cool by itself. Have you thought about doing anything like.
00:57:53.600 - 00:58:20.580, Speaker B: So, at least from the homomorphic perspective or homophobic encryption, we are kind of already doing that. So maybe just touching back on Sama as a company. Right. So a large part of the company is working on the core homomorphic library, both from a research engineering perspective. And the particular encryption scheme is actually really powerful. So powerful that on top of it, we're building two applications. So one is the blockchain we've been talking about, and then the other one is machine learning or data science.
00:58:20.580 - 00:59:10.932, Speaker B: And I think one of the benefits of trying to put this into blockchain is that you already have a relatively limited number of functions and operations that you want to do, but the underlying encryption scheme can actually do. So you can have arbitrary functions in it. So you can basically evaluate a lookup table on the homophobically encrypted data. So we are, to answer your question, I think we're already boiling it down to things that we say, okay, we expose this in solidity and in the FhevM because this is the most useful, or we can optimize performance for it. For instance, the CMux. We're working on research to get a very efficient version of CMux because that's kind of a well defined operation we know we need in the solidity. Awesome.
00:59:10.986 - 00:59:11.990, Speaker A: Thanks so much.
00:59:12.680 - 00:59:57.988, Speaker B: Maybe I'll just promote a tiny bit of we're happy with this particular encryption scheme, especially for blockchain, because it has some nice properties. One is you can evaluate these arbitrary functions, including comparisons, which you can't do exact in other encryption schemes, fully morph encryption schemes, but you also get exact computations. So some of them you give approximate results, whereas in tFhe, you get exact results, and then finally you can have the arbitrary computations that are also deterministic. So this is what allows every validator to do their own computation and then do a comparison at the byte level afterwards for consensus. Awesome.
00:59:58.074 - 01:00:01.140, Speaker A: Thank you so much, Morin. I think that's all the time we have.
01:00:01.290 - 01:00:01.556, Speaker B: Yeah.
01:00:01.578 - 01:00:04.056, Speaker A: Thank you so much for joining. We really appreciate you taking the time today.
01:00:04.158 - 01:00:08.650, Speaker B: Thank you very much for inviting. This was a pleasure and great with all the questions. Loved it.
01:00:10.300 - 01:00:11.400, Speaker C: Thanks so much.
01:00:11.550 - 01:00:18.500, Speaker B: Bye, everyone. See everybody's.
