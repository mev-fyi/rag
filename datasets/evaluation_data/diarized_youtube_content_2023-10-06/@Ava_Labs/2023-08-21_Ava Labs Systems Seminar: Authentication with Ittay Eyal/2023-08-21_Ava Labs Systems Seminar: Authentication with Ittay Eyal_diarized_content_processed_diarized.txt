00:00:11.530 - 00:00:42.826, Speaker A: Thank you all for coming. This is another installment of the system seminar that we have here every Friday. We're trying to do it every Friday. It is so nice to have Itai here. Ayal from Technion, I have been wanting to get him on this for a while. Thank you for making it here because I know that the scheduling and time zone difference is a little bit painful on a Friday, but the format of this is, you're probably very familiar with when you were at Cornell. We did a system seminar every Friday at twelve.
00:00:42.826 - 00:01:21.880, Speaker A: This is basically the same thing. Everybody comes in, gets free food with uber Eats, and then they just look at cool presentations. In tech, the crowd is mostly, almost entirely, I think, engineering, actually. So it's very technical. And usually we leave time until like the last ten minutes or so to the hour for presentation and then last ten minutes, 15 minutes, whatever it is. We'll open up for questions, which I'm sure there will be plenty. So for the rest of you, I think you should all already know Itai, but if you don't, Itai is one of the biggest ogs in the crypto space as far as like actual research.
00:01:21.880 - 00:02:14.326, Speaker A: He is the guy behind the selfish mining paper, which Gunezwal, of course, got a lot of notoriety with. But it was one of the very first genuine, legitimate papers that showed a concrete attack on the bitcoin protocol where you only required about, what is it, like 33%, one third of the hash power to actually run the majority attack, if I remember correctly. But obviously Itai has done a lot more. He's done a lot of work on distributed systems work, a lot of work on trusted execution environments and yeah, I mean, it's just incredible amount of work over the years. He was a postdoc with Guin. That's how I got to meet him back at Cornell when I was a PhD student. He also was involved early on, believe it or not, in the avalanche paper.
00:02:14.326 - 00:02:21.386, Speaker A: So Itai has his hands on pretty much every cool thing that has happened in the past. How long have you been working on this?
00:02:21.408 - 00:02:21.914, Speaker B: Like the past?
00:02:21.952 - 00:02:23.354, Speaker A: Like eight years? Maybe more.
00:02:23.472 - 00:02:27.146, Speaker B: Ten years? Yeah, I think it's going to be ten years. Yeah.
00:02:27.248 - 00:02:42.174, Speaker A: Ten years of actual research work in the space. So I don't need to be talking much more about this. You guys can look at the work that Itai has done. It speaks for itself. But without further ado, I will leave it to you, Itai, to talk about the work you talk about today.
00:02:42.372 - 00:03:12.170, Speaker B: Yeah, I don't know. Maybe I should just leave after this introduction. I shouldn't say your. No. It's a pleasure and thank you for the invitation and for being a little bit flexible with the time. And we do actually do a bunch of work on systems and on incentives in blockchains. But I wanted to talk to you today about something different.
00:03:12.170 - 00:04:13.726, Speaker B: As the title indicates, which is client side security, we know that specifically authentication, right, the binding of a person principal to a digital identity, which translates in the blockchain world and digital asset world, be it a central bank, digital currency or NFT, or whatever, translates to a wallet. Since because this is done in this online fashion rather than face to face, I am going to intentionally stop along the way for questions. And I also very welcome questions. If something is unclear along the way, there are going to be a bunch of definitions because as we'll see, there's a lot to do to formally reason about all of this.
00:04:13.908 - 00:04:31.250, Speaker A: For a bit of format, guys, raise the hand sign on the screen here, and then you should have a little beep, and then you can pause when you see the hand sign. I'll do a test right now. That's what it looks like. So if somebody does that, then you can pause.
00:04:31.830 - 00:05:07.520, Speaker B: Perfect. Okay, so because it's hard to focus in front of the screen, I'm going to start from the bottom line, in case you lose me along the way. So I'm going to present to you a formal model of the authentication problem. Surprisingly, this is news. This was not done before, even though the authentication problem is obviously very old. I'm going to show you that when we look at the authentication world with probabilities of what might happen, we already see nontrivial behavior. And I'll show you that you can do a lot better.
00:05:07.520 - 00:06:27.334, Speaker B: If the system is synchronous between the principles looking to authenticate and the mechanism that authenticates them, then you can use interactive mechanisms and you can get significantly better security. And in particular, I'm going to show you a bound on the size of a maximal algorithm, which we'll define some examples of maximal mechanisms for any number of credentials. And I'll show you the complete set of all mechanisms of all maximal mechanisms, up to three credentials. Beyond that, it's an open question. And finally, I'll show how all this theory can be used to directly improve the state of the art. We'll have some concrete to the results include results done with Deepak Maram, who's now doing research at Miston Labs, and Mahimna Kalkar, who's completing his phd at Cornell Tech. Now, to clarify, we're talking here, I guess for most of you really, with the focus of avalanche client security.
00:06:27.334 - 00:07:32.190, Speaker B: But what I'm going to present it is quite general. It applies to all cryptocurrency contacts and decentralized finance where you have to identify to a smart contract. It applies to nfts, where you want them to be stored securely, and to central bank digital currencies when they come to life. Maybe they'll be centrally managed, but still you'll be in charge of your assets in all cases. You have to maintain this wallet. And what I'm going to present here, it is theoretical in general and it applies equally, though with perhaps different numbers to individuals. So you want to hold your day to day usable amount of cryptocurrency, where you pay merchants, et cetera, to huge companies that need to store high value assets, to asset management companies that store digital assets for their clients.
00:07:32.190 - 00:08:30.250, Speaker B: And honestly, it's going to be even more general. So it really applies to any case where you want to authenticate to a service and in particular to large scale services like when you log into Google or to Amazon. It's not decentralized, right? There is a company behind them, but still you can't call them and talk to them. It's an automated service and it should identify the principles, the clients, correctly. So the results here are going to apply there as well, though again, different numbers and different credential types. Now the reason all this is actually hard is that in the decentralized settings or large scale centralized setting, there is no office to appeal to. You can't call someone and say, look, I forgot my password and they will replace it because it's decentralized.
00:08:30.250 - 00:09:21.742, Speaker B: And you cannot say, look, I was hacked, some money was told and bring it back, like you can do with a credit card company, for example, or your bank in some cases. And so the problem is genuinely harder because we're missing a piece, we're missing the trusted party. And moreover, there is much more at stake than we're used to. If someone gets hold of the keys immediately, the money, the assets are lost and the amounts are large. So techniques that were completely okay for centralized systems are no longer sufficient. And this what led to revisiting this area. Now, in decentralized settings, we know we need to do certain things.
00:09:21.742 - 00:10:23.618, Speaker B: We know we should secure our individual keys, right? We have the secret keys, we should keep them very well. And we are willing to do things we weren't always willing to do in classical authentication contexts, like use k out of n credentials. This is very acceptable in the cryptocurrency world, because we know that this is what we need for security. But is this enough to quote better edge, no major thefts occur. These are the larger values we all hear of in the news of large companies. But individuals lose digital assets all the time because this is not enough. And there's been a lot of work on authentication, but it doesn't really touch the problem that I'm going to discuss today.
00:10:23.618 - 00:11:12.830, Speaker B: So previous work looked a lot of how to secure individual keys, how to secure individual credentials, passwords. There is a lot of work on what sort of passwords are secure and even what alternatives there are to passwords for authenticating. But these are still individual credentials. And then there are techniques for using multiple credentials like k out of n and with k out of n you still need to at some point to, let's say, sign your transaction. You need to get all the k signatures and sign it. So there's a point in time where a single machine has all k private keys. And so there are alternatives like threshold signatures, but these are all mechanics.
00:11:12.830 - 00:12:12.470, Speaker B: They tell us how to implement these sort of mechanisms where you need multiple keys or sets of keys, but not which keys or how many keys we should have, which is what I want to discuss today. There's also been some work on analyzing existing systems and on authorization policy, where you have a large organization and some principles in collaboration should be able to do things, and other principles can do other things. These, again, talk about the mechanics of how to implement it, not what we want to implement. How should we design our wallet? So let me just overview the system we're looking at. This is not the model, but I guess something we all know of. But I want to start giving things names so there's no central party. The principles send orders, transactions to the blockchain, including transactions to create the authentication mechanism, the wallet.
00:12:12.470 - 00:13:01.734, Speaker B: So the users choose their own wallets. It's not like when you log on to Microsoft, and Microsoft will tell you what's the structure of your authentication mechanism. Here you choose your own smart contract, how you secure your things, and then once you publish it, it's public to everyone. So the attacker can also see what is your security scheme, what is your authentication mechanism? Authentication is typically done with cryptographic signatures. Mostly we're going to have that as our mental model, and the user is then in charge of maintaining their secrets, their credentials, specifically private keys in this example. But in general, the credential can be anything. It can be a password you have to remember, then type in.
00:13:01.734 - 00:13:52.850, Speaker B: It can be a piece of paper hidden in a safe deposit box in Switzerland, which is secure enough, right. It can be this physical device where you have to plug it into your usb and then click the pin code and you can even implement things like one out of six threshold signature. Physically, as you see in this picture, it's pretty cool, I think. Can you see the one out of six? Yeah. Now, we want to model all this. How do we model all this? So let's start with the credentials, and this is going to go fast, so pause me if I went too fast. So let's look at what can happen to a credential.
00:13:52.850 - 00:14:32.782, Speaker B: Again, surprisingly, this was not done before. It's not rocket science, but it has to be formalized so the user can either have access or not have access to her credentials, and then the attacker can have access or not have access to that credential. I'm just talking about a single credential here. Now, if the user has access and the attacker does not have access, we say that the key is safe. If the user has access. Sorry, if the user lost access and the attacker does not have access, then we say that the key is lost. If the user has access and the attacker also has access, then we say the key is leaked.
00:14:32.782 - 00:15:22.818, Speaker B: So both of them have it. And if the user does not have access and the attacker does have access, we say that the key is stolen. Again, not rocket science, but let's look at some examples and it will make this very obvious if it wasn't so far. So for a password loss, for example, means it's forgotten and leak. Could be because it was guessed, the attacker guessed it is equivalent to a leak. Also, if they have a keylogger attached to your computer and they got the password as you were clicking it for the safe deposit box loss could mean you don't have access because there is Covid and no more flights around the world, you can't reach Switzerland and so you don't have access to your secret hidden there. For the physical device loss means either you forgot the pin or you broke the device and then you lost access.
00:15:22.818 - 00:16:00.110, Speaker B: Theft, though, means that the attacker stole the device and guessed your pin code right. So we're going to model all this into just the state, lost or stolen or et cetera. And finally, for a k out of n threshold signature, where you have these n pieces and you need k, we're going to say that they're actually n keys and the wallet requires k out of n, as we'll see in a minute. So credentials, four states. That's it. And here's our model. We have a user and an attacker, and we have an authentication mechanism.
00:16:00.110 - 00:16:56.834, Speaker B: The authentication mechanism keeps, it's the wallet, right? It keeps the tokens that the user wants access to. The user should authenticate, meaning should tell the authentication mechanism it wants to pay someone and the attacker tries to tell the authentication mechanism it wants the user's funds. Now, I just need a single attacker here, because this attacker represents the worst attacker at the worst time. So it could be that there are a bunch of attackers and they're all trying to get hold and steal your money. But there is a single point in time where with the worst situation where someone was able to get your key, logged keys and guessed your password. And then at this point of time, this is the worst possible attacker. This is the attacker in red here.
00:16:56.834 - 00:17:30.880, Speaker B: Okay? Now each of the user and the attacker has access to subset of the credentials in the system. So here the user has three and the attacker just has the silver one. And then we have the environment. The environment gives each of the user and the attacker an id. One gets id zero and the other gets id one. The environment chooses arbitrarily, gives one of them an identifier and the other the other identifier. The user and the attacker do not know in advance who is going to get which id.
00:17:30.880 - 00:17:57.110, Speaker B: But then they have to communicate with the authentication mechanism and the authentication mechanism is going to respond. It's going to decide and let the environment know whether it thinks that zero is the user and one is the attacker. So decide zero or that one is the attacker. I have a question. What about spoofing environment? Can you please elaborate?
00:18:00.250 - 00:18:29.760, Speaker C: So for example, it depends on the way that the system would figure out what the environment is. But for example, let's say it looks at cookies, right? So if you spoof the cookies of a regular user and the way the system verifies it, or for example, the system verifies using your ip, right, the source IP. If you manage to spoof the source IP now you both get the same id, right? Yeah, honestly, I don't really need an answer on that. I just kind of bring this up.
00:18:30.850 - 00:19:34.820, Speaker B: No, this is super important because this is a delicate point to understand the rest of it. So the id represents, let's say, the decision that the authentication mechanism is going to make. So if, let's say, the user orders to pay someone and the attacker orders to take the money, then the ip in this case, so the id is going to represent the two orders. So one of the id, let's say id zero is pay for coffee, id one is steal the money, and the authentication mechanism has to choose zero or one. And if the ip is used by the mechanism to identify the user or the attacker, then the ip is a credential. Meaning if the attacker can spoof the user's ip, then this credential is leaked. Does this make sense?
00:19:35.190 - 00:19:41.990, Speaker C: Yes. So basically the environment Id in this case is like a per transaction rather than per user.
00:19:42.570 - 00:19:43.318, Speaker B: Exactly.
00:19:43.484 - 00:19:44.150, Speaker C: Okay.
00:19:44.300 - 00:20:16.370, Speaker B: Exactly. If this is your model. In other cases it could be, for example, that I try to log in from a particular machine and the attacker tries to log in as me in a different machine. And then the IPS actually. Or some cookie. Right. Is the authentication mechanism decision of who to trust? And so if the mechanism chooses that one of the IPS is really the true user, then this is the decision.
00:20:16.370 - 00:20:26.562, Speaker B: Okay, thank you. Okay. Yeah. Aki.
00:20:26.706 - 00:20:34.310, Speaker D: Yes? You said earlier the user advanced doesn't know which id it will receive. Did you mean the authentication mechanism? I just want to clarify.
00:20:36.890 - 00:20:53.622, Speaker B: No one, only the environment knows which id everyone is going to get. And then the system starts and the user learns which id it got, and the attacker learns which id it got. And the authentication needs to communicate with them and decide.
00:20:53.766 - 00:21:04.530, Speaker D: Oh, I see. So you're saying that both the user and the attacker, in the model you're describing, they don't know which id they will receive. And that's what you mean by the user in advance doesn't know which id it will get.
00:21:04.680 - 00:21:05.234, Speaker B: Exactly.
00:21:05.352 - 00:21:06.146, Speaker D: Okay, got it.
00:21:06.168 - 00:21:45.610, Speaker B: Thank you. Okay. Anymore. Okay, so now we can talk about scenarios. If we have n keys, then the state of key, I will denote it, ki is going to be either safe loss, leak, or theft as we defined before. And then the scenario is a state vector, we will denote it, sigma, and it's going to be a vector of n states safe loss. Legal test from the scenario, we'll derive two vectors, one for owner key availability and one for attacker key availability.
00:21:45.610 - 00:22:12.654, Speaker B: For each of them, it will be true if the owner or the attacker respectively has the key. So safe means true and false, the user has it, or the owner. Here, sorry, it's o instead of u. The owner user has it and the attacker does not. Theft at the bottom line is the opposite. Loss means it's false for both of them. And now let's look at the probabilistic analysis.
00:22:12.654 - 00:22:44.006, Speaker B: Already this starts to become interesting. So here's the model I'm going to use for the probabilistic analysis. Each of the keys is going to have an independent fault probability. So the fault of key two is independent of the fault of key one. And we'll denote the probabilities PI is safe. That's the probability that key I is safe. PI leak is the probability that PI is leaked.
00:22:44.006 - 00:23:43.150, Speaker B: And in some cases, like the table at the bottom, we won't have an index, meaning all e's have the same probabilities, independent, but they all have the same probability of safe loss. So now with n keys, we have four to the n possible scenarios, right? Safe, safe, safe loss, safe leak, and so on. Four to the n lines. The probability is the probability of sigma one and sigma two of each case. And for each scenario, we're going to have two different availability vectors, sigma o and sigma a. Okay, to summarize, we have a scenario which is the state of all keys, and then the scenario has a probability. Now, a wallet, that's the authentication mechanism, is a predicate on n availabilities.
00:23:43.150 - 00:24:45.890, Speaker B: That is, someone contacts the wallet and shows the credentials they have, and the wallet needs to decide, is this the user or is this not the user? So, one example, it can take three keys, three credentials, k one, k two, and k three, and then it accepts, it, identifies the user. If the message has both key one and key two, or both key two and key three, any other combination does not work. So this is represented in this Boolean expression. And we're going to say that a wallet is successful in a scenario if the owner can satisfy the formula, but the adversary cannot. So this is a conservative assumption. I'm assuming that if the attacker has enough credentials to take the money, it's going to be quicker than the owner. So we're only safe if the adversary cannot satisfy the formula and the user can satisfy the formula.
00:24:45.890 - 00:24:54.020, Speaker B: And then the probability of failure is the probability of an unsuccessful scenario. Yes.
00:24:54.710 - 00:25:06.380, Speaker D: So you're saying that the combination k one, k three is not valid, then in this example, it's only k one or k two, or k two or k three. Okay, yeah, cool, thank you.
00:25:09.550 - 00:25:44.166, Speaker B: I'm not saying it makes sense. It's just an example. Now, how do we decide whether, how do we find the best possible wallet? So, wallets are monotone boolean functions. Let's see if we can scan all of them. Monotone Boolean function. Why? Because if I have more keys, I'm never worse off. If I have k one and k three, and that's enough to satisfy the expression, then also having k seven cannot harm me.
00:25:44.166 - 00:26:33.958, Speaker B: So the expression can only go from false to true. So it's a Boolean function. It's a monotone Boolean function going only from false to true, which means that the number of wallets is the dedicated number minus two. Dedicated was a mathematician from the 19th century, and he defined this number, which is the number of monoton Boolean formula minus two, because we don't care about constant false and constant true. They are also boolean monotone functions, but they're not so interesting as wallets, I guess. So here are some dedicated numbers. The dedicated number for zero keys is two, right? Constant false and constant true.
00:26:33.958 - 00:27:16.980, Speaker B: No wallets with zero credentials. If we have one credentials, one credential, then we have one possible wallet, right? K one. If we have two credentials already, we have four wallets, just k one, just k two, requiring both k one and k two, and requiring either k one or k two. If we have three keys, then we have 20 options. We have 20 possible wallets, right? You have just one of them, all of them at the bottom. You have any pair, you have just k one or k two and k three, and so on. So many options.
00:27:16.980 - 00:27:55.086, Speaker B: If we go to four, we already have 168. Five is much more. This actually grows extremely quickly. So quickly that we, humanity Wikipedia, do not know the dedicated number beyond eight, which was already discovered fairly recently. So we certainly cannot try all wallets if we have too many credentials. Okay, so for a large number of credentials, we cannot do an exhaustive search of the wallets. But let's start with one.
00:27:55.086 - 00:28:40.726, Speaker B: We can do one, right? So with one wallet, here's what happens. I'm going to show a bunch of these graphs. So let's start by carefully looking at this one. So this is a 3d graph, right? We have on the x axis the probability that the key is leaked going from zero to one, and on the y axis the probability that the key is lost, again going from zero to one. Now, in this entire graph, I'm going to have 1% probability of theft, as you see on the right, and the wallet is just going to be that single key. So the wallet is going to only be successful if the key is safe. The color and the lines indicate the failure probability.
00:28:40.726 - 00:29:40.340, Speaker B: So the failure probability is 99% at the origin, and then it drops linearly, as you see in a gradient as we go farther from the origin. Now let's look at more interesting wallets. These are the end wallet on the left and the or wallet on the right. The leak and the loss probabilities are the same for both keys, and the fault probability for each key is independent of the other one. So for the end on the left, we see that it handles better leakage, because if the key is leaked, then still the attacker cannot take the money. But the probability for loss at the bottom is fairly small. So the owner is going to be able to satisfy the end, but the attacker will not.
00:29:40.340 - 00:30:13.866, Speaker B: On the flip side, on the or wallet, you see the opposite. The or wallet is able to better handle loss because it just requires one key, but leak is unlikely and so it handles better going up than going to the right. So far, everything makes sense. Here's a surprise, and this is a slightly different type of graph. Here we have categories. So for each area, I'm going to choose a color for the best wallet. In this point, there might be more than one.
00:30:13.866 - 00:31:08.642, Speaker B: Here there are just one for each point. So we see that the end wallet is the best wallet when there is a high probability of leakage and the low probability of loss. And the or wallet is best when there's a high probability of loss and low probability of leakage. But, and let me increase the theft probability, so the effect is more pronounced. If the probabilities are fairly similar, then the best wallet is actually going to be just a single one. So just use one credential using just k one is better than using both credentials, the or the end. And note that the important part of the graph here is the origin, right? We are going to pick credentials that have the low probability of any fault.
00:31:08.642 - 00:32:04.746, Speaker B: So really, if we have the option of using two credentials or one, and we think both of them are very safe, we're actually better off just using one. Now, what happens with three keys? Three keys is common, right? This is what happens when there is no theft probability. So again, as expected, you see that if loss is likely, then, or is better, if leak is likely, then the end is better. And in the middle, you're better off with any pair option. And this also applies to the case where there is theft. Again, I chose a large value, and here I actually have some good news. This is not surprising in the sense that the common approach is to really use two out of three out of three wallets.
00:32:04.746 - 00:33:07.300, Speaker B: And we can now see here in a formal way, that around the origin, this really is the best wallet you can choose. Now, let me ask you, what do you think is the best thing to do if we have four keys? Should we choose? The natural extension of this would be to say the best thing is going to be either two out of four or three out of four, right? But which one? And this is the answer. Again, maybe not that surprising. So if the loss probability is more likely, then we're better off with two out of four. And if the leakage probability is a little more likely, then we're better off with three out of four. And if they're very likely, then it becomes the or wallet or the end wallet. If we introduce theft, it becomes even more interesting and at the origin we don't actually choose a symmetric wallet, so we choose something different.
00:33:07.300 - 00:33:57.860, Speaker B: Now I'm not going to keep drawing these, they are going to become hard to understand. So let's try to do something different and understand what happens as we increase the number of keys. So in these graphs, I'm going to show you the wallet failure probability. This is a log y axis, and the number of keys going from one to seven up to five. We could find the optimum that's in yellow, and then after that in green it's a guess. It's just some symmetric wallet. And then there's a heuristic in the black line that try to find if it can get better than the others.
00:33:57.860 - 00:34:32.510, Speaker B: Now we see that if we have only loss, the failure probability of the wallet drops exponentially with the number of keys. Similarly with a different wallet. But we don't see the optimal wallet here. We'll get an exponential improvement if there's only leakage. Now what happens if there is only theft here it becomes interesting. This is what happens when there's only theft. So the general trend is still exponential and exponential improvement, but we only improve as we go from even to Od.
00:34:32.510 - 00:35:08.646, Speaker B: You see here that we didn't improve from one to two keys because we know already that we're better off just using one. Right? You see here, this is me being honest. You see, the evolutionary, the heuristic didn't work too well, so we can't rely on it in general, as we cannot with heuristics. Here. The heuristic actually helped. So this case is not symmetric. So the first key suffers only theft with some probability, and the rest of the keys suffer only loss.
00:35:08.646 - 00:35:58.038, Speaker B: So one key can only be stolen, and then two, three, four, all the subsequent keys can only be lost here. Again, the general trend is exponential, but the wallets are different. And you see that the symmetric is not the optimum here and we need to choose a different wallet now. Sorry about that. The big lesson is here, this shows you three types of probabilities. We have keys that can be lost with 1%, 2% and 3% with theft probability written twice for some reason of 1%. So in all cases we have a 1% probability of theft.
00:35:58.038 - 00:36:41.702, Speaker B: But you see here that with six keys that have 3% loss probability, we have an order of magnitude lower failure probability than with three keys that have 1% loss probability. So even though the loss probability, the key is three times worse, in some sense we're better. Also, quantity over quality. More keys give us better security. We'll better use many not great keys than a few very well secured keys. So what does this mean for you? We allow you to answer this question with a wallet designer. You can actually go on GitHub.com
00:36:41.702 - 00:37:32.450, Speaker B: cryptowallet designer and try this out. You can feed in your estimated false probabilities of your keys. You can try different wallet configurations on the left and find the probability of failure of your wallet. Or you can ask the browser to find the optimal wallet for you. This actually won the first prize in the IC three blockchain camp hackathon last year. This is all run inside the browser, so nothing about your wallet design goes to any server. This can actually find the optimum for up to six keys by compiling c into WaSM.
00:37:32.450 - 00:38:10.260, Speaker B: It does simulate the needling for seven to twelve keys, and it compiles to bytecode, so you can deploy it with metamask with a click of a button. And we also have CLI clients, so you can generate your keys and interact with the contract once it's deployed. Was there a question? All right, so I want to talk about interactive authentication, but maybe I'll pause here briefly for questions about the probabilistic world, if you have them.
00:38:17.050 - 00:38:24.860, Speaker D: What'S the heuristic for determining these probabilities? It seems like it's great that there's this model, but then how do you determine the probabilities of everything?
00:38:26.430 - 00:38:32.822, Speaker B: So you're asking how do I determine the fault probabilities of my credentials?
00:38:32.966 - 00:38:34.938, Speaker D: Yeah, what's the heuristic for that?
00:38:35.104 - 00:39:20.566, Speaker B: That's an excellent question and a very open question. I'll answer briefly. First of all, we can't really tell, not generally, because this is not public knowledge. Nobody posts anywhere or indicates anywhere that they lost a secret key. So there is no public statistics anywhere. And personally, if you're asking about someone who needs to make a decision, they do this anyway. When they choose their credentials and they store them in different places, they make some estimates of what might happen and how they should design their wallet.
00:39:20.566 - 00:39:52.840, Speaker B: So this serves to actually find the optimal wallet for them in a formal way, but it will not help them decide how secure their keys are. I cannot estimate one's I don't know personal home security against someone who goes in there and looks in their closet. Right. It's really something that a company or an individual should do for themselves.
00:39:55.130 - 00:40:04.060, Speaker D: Would you have a number for the individual or. It highly depends. Would you have like a threshold number that you would consider to be like, this is a good number?
00:40:04.910 - 00:40:20.620, Speaker B: Absolutely not. I have no idea. This is probably a question for an insurance company kind of person. I mean, you need deep statistics, I think. Yeah.
00:40:21.870 - 00:40:22.342, Speaker E: Great.
00:40:22.416 - 00:40:32.434, Speaker B: I really wanted to do a user study, but I wouldn't know where to start. This is not my area. Really? Yeah. Dove, please. Yeah.
00:40:32.472 - 00:40:45.400, Speaker D: Just to follow up to Aki's question, what would be a scenario where each key would have different probabilities? Like based on the design, it seems like we're accounting for that kind of case. When would that case be true?
00:40:47.290 - 00:41:28.660, Speaker B: So if you have so typical scenario, right, you have one key on your phone, one key held by some company who's helping you take care of your assets and you authenticate online with them and then they will co sign with you, and then you have another key stored at the safe deposit box in the bank. Right. So each of these keys would have completely different probabilities. The third party company that you know nothing of has a higher theft probability than the safe deposit box, for example.
00:41:30.230 - 00:41:32.680, Speaker D: Right. Okay, that makes sense. Thank you.
00:41:39.050 - 00:42:18.530, Speaker B: Okay, moving on. So these type of wallets, maybe you haven't seen the analysis, but you've seen the wallets. What I now want to talk about is something a lot. Taking you to the next level and designing much more secure wallets. We call this interactive authentication. And I'm going to improve the model a little bit or actually restrict it a little bit by assuming that the network is synchronous. When is this the case? When you publish a transaction to the blockchain, the contract is going to start some timer and then something will happen after the timer elapses.
00:42:18.530 - 00:43:09.182, Speaker B: Non blockchain example, you wake up in the morning, you see a mail in your inbox saying that you've ordered 100 inch television to a country you can't find on the map. This is Amazon sending you a notification of an order and giving you the opportunity to contact them and tell them, wait, don't ship this. This wasn't actually. There is. Amazon is assuming that they can contact you before they ship the item. This goes back to a paper gun. And I wrote, led by Maltimuser, who's now at Princeton, called bitcoin covenants, which was a technique for implementing this on bitcoin.
00:43:09.182 - 00:43:52.974, Speaker B: But the hacking distributed blog talked specifically about these bitcoin vaults. This is the first interactive mechanism for cryptocurrencies I'm aware of, but it was a specific mechanism. And here I want to go very general. So let's look at an execution in this model. Okay, so we have the scenario, everybody has their keys, everybody has their ids, and then after the environment chooses the indexes, the user and the attacker interact with the mechanism. And so we're going to have a user strategy, which is what messages the user sends and when. And we have an attacker strategy, which is again the messaging strategy of the attacker, but also scheduling.
00:43:52.974 - 00:44:46.462, Speaker B: We'll assume conservatively that the attacker controls when a message, oh, hello, I see a small participant here. So the attacker controls scheduling, it controls when the user messages arrive to the authentication mechanism as well. And now we can talk about mechanism profile. So I'm stepping away from probabilities and being a little more general. So a security profile is the set of scenarios where a mechanism succeeds in all executions. So we have a scenario, we set a scenario and the user chooses a strategy. And whatever the attacker does, the user is going to succeed.
00:44:46.462 - 00:45:31.746, Speaker B: So the mechanism will identify the user correctly. So for the or wallet, this is the profile we're going to get. The wallet succeeds in the or if one of the keys is safe and the other is either safe or lost, because the user can always has at least one key and the attacker does not, the end wallet is going to look like this. So we're always going to succeed if the user, if one key, sorry. Is safe and the other is either safe or leaked because the attacker can't do anything with a single leaked key. This is the one key wallet. You see here that there are more check marks than in the previous two.
00:45:31.746 - 00:46:27.380, Speaker B: This hints to us a little bit what happened in the probabilistic scenario before. Now, this definition of the security profile implies a partial order on the set of mechanisms. So mechanism one, we're going to say it's better than mechanism two if the security profile of m one is a superset of the security profile of m two. So specifically a superset, I'm not just counting the successful scenarios, but it has to be an explicit superset, an exact superset, and it's a partial order because in this example, for example, the two profiles cannot be compared, neither is a superset of the other. Okay. Yeah.
00:46:27.830 - 00:46:40.120, Speaker D: Will be a case of when it is a superset. I can see how they're not sets of one another, but I can't think of when it would be a superset of one another, or like one would be a superset of another.
00:46:41.530 - 00:46:46.860, Speaker B: Here is a non realistic example, but if it looked like this, then one would be a superset of the other.
00:46:49.630 - 00:46:52.774, Speaker D: The left is a superset of the right, or the vice.
00:46:52.902 - 00:47:25.590, Speaker B: Okay, yeah, we'll see more example in a second. So now we can talk about maximal mechanism. These are the best mechanisms you can use. And so this is the demonstration of the partial order. And a maximally secure mechanism, or a maximal mechanism is a mechanism where there is no other mechanism that is better. Of course there are other mechanisms that are neither better. There might be other mechanisms that are neither better nor worse.
00:47:25.590 - 00:48:04.718, Speaker B: And I'm going to show you some of them. One of them, and it's going to be based on this interactive mechanism template which is going to go as follows. The mechanism will receive credentials from one party and it will wait until it receives credentials from the other party. It can wait like this because we assume the network is synchronous. So there is definitely going to be a bounded time. The mechanism can wait and then it will receive the credentials from the other party. If it didn't, then that party that did not send the message is the attacker.
00:48:04.718 - 00:48:45.142, Speaker B: The user is going to send the message, and then given the messages from both parties, the mechanism will feed them into a function j we call the judging function. And this judging function will decide who is the user based on the credentials of both parties. So the mechanism is going to be simply defined by the single function j and the mechanism. I'll propose we call it a priority mechanism. We define a priority between the credentials. You see here. Purple beats silver beats gold, and j chooses the player that submits a unique high priority credential.
00:48:45.142 - 00:49:30.430, Speaker B: Two examples. Here, alice has the purple and the attacker does not. So Alice wins. In this case, they both have the silver, so we can't decide based on the silver, but then the attacker has the gold and alice does not. So the attacker wins. Does this make sense? And this is the profile of the two credential priority mechanism, which is great. If we look at the other profiles we've seen the or the end or the one key, the priority mechanism is better than all of them.
00:49:30.430 - 00:50:20.958, Speaker B: In fact, it is maximally secure. There is no better mechanism. How can I say this? Because I know I can prove the maximum number of successful scenarios in the maximum size, really cardinality of a profile. It's this, and I'm going to very briefly explain the idea. First of all, this entire cube is failure. So if no key is safe, then no mechanism can succeed. And when I say succeed, I mean succeed in all executions, even though a mechanism could always decide zero.
00:50:20.958 - 00:51:22.130, Speaker B: And then in some executions where the environment gives the user the id zero, it will succeed. But I only market scenario is successful if the mechanism succeeds in all executions. Proof outline in all of these cases, and I emphasize again, this is a cube. So for n keys, it's going to be an n dimensional cube of three by three by three by three by three by three. And in all of this cube, the attacker has a superset of the owner's credentials, because no credential is safe. So for each credential either only the attacker has it, both of them have it, or neither of them has it, and then the attacker can do anything that the user can, and so no mechanism can succeed in any of these. And the other thing is that we define complement scenarios.
00:51:22.130 - 00:51:57.280, Speaker B: A complement of a scenario is a scenario where you flip safe to stolen and stolen to safe. So leak means both of them has a credential. In the complement, it remains leaked. Loss means neither of them have it. In the complement, it remains lost, but safe. Only the user has it becomes stolen, only the attacker has it, and vice versa. And so if we're successful in one scenario, in the complement, the attacker can do everything the user could in the original, and so the attacker can win.
00:51:57.280 - 00:52:51.220, Speaker B: And this is enough to prove this bound. This priority mechanism is a maximal mechanism, and this is actually true for any number of keys. And we're curious now to learn what's the complete set of maximal mechanisms. So there cannot be a better mechanism. There cannot be an optimal mechanism, not in this set. So why do we care about a complete set of maximal mechanisms? Because if we look again at probabilities, for example, then the optimal wallet, the optimal authentication mechanism, is going to be in this set. Not every maximal mechanism is going to be optimal, but the optimal one is going to be in this set.
00:52:51.220 - 00:53:50.274, Speaker B: I'm running out of time, so I'm only going to briefly mention these two final things. So first of all, like the priority mechanism I presented, we identified two other types of maximal mechanisms based on the same template, and we can show that these actually cover the complete set of maximal mechanisms up to n equals three. So with four credentials, there might be other types of mechanisms that are maximal. These are open questions. If you guys are doing research or interested for practical reasons, I would love to talk about that. And finally, in terms of applications, we analyzed a bunch of things. First of all, all two key wallets, we were able to find were better than all of them.
00:53:50.274 - 00:54:27.310, Speaker B: So if you have two keys, then using our priority or maximum mechanisms is better. And finally, we analyzed the argent popular wallet. It's actually very well built. It has over a million users, so it's a real thing. And they have a bunch of procedures that they address, like quick withdrawal if you have enough credentials, regular withdrawals. Otherwise they can do credential refresh. And we show that they are pretty good and they can be even better than what they say in their specification.
00:54:27.310 - 00:55:08.154, Speaker B: And we are speaking with them about these improvements. But in general, our maximal mechanisms can actually do better than the argent design for n greater than two. So three or more. So there are direct lessons here for applications. And with that I concluded. So we talked about authentication and its criticality for digital asset storage. I showed you a model with probabilities and how we already find some surprises and we should carefully design our mechanisms.
00:55:08.154 - 00:55:26.500, Speaker B: And we saw what happens when we can rely on synchrony and how we can get way better security and what are the bounds we have to face and some maximum algorithms we found. Thank you.
00:55:27.750 - 00:55:29.410, Speaker A: Have a question from Makash.
00:55:30.390 - 00:55:56.662, Speaker E: Hey, yeah, thanks. I know we're short on time, so keep it short. It was actually a pretty long question, but thanks for some of the stuff around the maximally secure mechanisms. I think the specific question around what you said about you cannot be a better than optimal mechanism. That's not in your original set. Correct. When you're looking at a priority mechanism.
00:55:56.662 - 00:56:56.494, Speaker E: Right. When you're looking at the complete set of it, which is for n is less than equal to three in this case. Right. I think at that point, I'm curious what happens, why it really breaks. Firstly, when we go for or beyond based on the matrix you have here, because if you are signing the weightage from purple, greater than silver, greater than gold. That's the point where I was kind of curious, because I look at some of the other implementations on argent, and we've done some thorough research around some of the drawbacks of them being having like, technical exploitation risk, contract risk, gas intensive areas that we kind of decided to move away from, sort of that social recovery aspect of things for what Arjun's doing. But moving forward, obviously, this is a big area that we want to kind of invest in or grow in and make sure that we're moving away from going towards seedless authentication, authorization recovery and all of that.
00:56:56.494 - 00:57:23.640, Speaker E: But I'm curious on those two aspects. Right. So maybe I might have to follow up with another question just given time. But I also was curious to see specifically on the priority mechanisms, on why you think it breaks when it's greater than three. And what are some of the leading providers out there that are looking at. We have looked at Unipass as well, which you may be aware of as well. So any insight that would be helpful, at least while everyone's on the.
00:57:24.910 - 00:58:17.240, Speaker B: So first of all, about UniPass, we didn't analyze it, I can't say anything. The analysis of argent, I didn't spend a lot of time because I didn't think it's important for the focus of this talk. But this actually required fairly comprehensive work. The specification of the protocol does not lend itself to direct analysis of this. You need to do a careful analysis, and this will be the case, I think, for other solutions as well, regarding priority. So priority is actually sufficient for two keys. If you have just n equals two keys, then you have two priority mechanisms, right? K one then k two, or k two then k one, and that's enough.
00:58:17.240 - 00:59:03.838, Speaker B: All other mechanisms are weaker than at least one of them. And as you see here, but as you go to n equals three, there are other mechanisms that are also optimal. Majority is one, which I did not describe. There is no majority mechanism that is better than priority. Priority is still maximal, but there are other maximal mechanisms that we call them the set majority. They are also maximal. So the best probability, if we had probabilities, might be a maximal algorithm and not a priority mechanism.
00:59:03.838 - 00:59:57.770, Speaker B: But this is even not enough still, because there is another type which we call priority with exception. Unless you ask me specifically, I'm not going to go into the details, but it's another type of judging based mechanism, and these three together cover all maximal mechanisms. So every mechanism is weaker than at least one of those three types, and with four, we don't know what happens. Probably we'll need more. And there is also a potential surprising option if there is a maximal mechanism that has less scenarios. So we know the bound on the number of scenarios, but we don't know that all maximal mechanisms must reach this bound.
00:59:59.230 - 01:00:21.810, Speaker E: Got you. Okay, that makes more sense. The priority with exception aspect was something specific, because what you said around the weightage where purple is greater than silver, greater than gold, right? In that you can actually have an exception where if someone has a silver and a gold, and the other person has only a silver, but you have a different priority or weightage.
01:00:22.550 - 01:00:45.282, Speaker B: That's what you mean by the priority. I can actually describe it. So it's a priority mechanism, and the only exception is if one party gives you the lowest priority, and the other party gives you the second lowest priority, then you do the opposite of what the priority would say. In all other cases, you follow the priority you defined. That's the priority with exceptions.
01:00:45.426 - 01:00:47.114, Speaker E: Got you. Okay, that makes more sense.
01:00:47.152 - 01:00:54.220, Speaker B: I don't know if it's important in and of itself, but if you're interested in the complete set, then you have to take it into.
01:00:56.350 - 01:00:57.642, Speaker E: Very, very informative.
01:00:57.706 - 01:00:59.882, Speaker B: Thank you, Akash.
01:00:59.946 - 01:01:04.960, Speaker A: Feel free to also, of course, follow this with Ita offline, Akash is on the core team as.
01:01:07.010 - 01:01:16.562, Speaker B: So. Yeah. So you're the guys I wanted to hit with this talk. So please shoot me an email. You can find my email and I would love to talk more.
01:01:16.616 - 01:01:35.842, Speaker A: Yeah, I'll connect you email afterwards. No problem. I'll connect you guys. But I think we're actually above time now, so we'll cut it off here. Thank you so much. There was a lot here that I've started to think about on the core side, so we should really start thinking about this kind of stuff. Further reading links.
01:01:35.842 - 01:01:41.846, Speaker A: Ita, if you have any pointers, maybe to your Twitter where you have Kevin.
01:01:41.878 - 01:01:44.566, Speaker B: Maybe I'll send you the links and you can distribute.
01:01:44.678 - 01:01:55.710, Speaker A: Please send me the links. I'll forward to the rest of the team, and then we'll circulate internally. Thank you all. Thank you. Itai, everybody. Great weekend. And itai, see you at summit.
01:01:56.530 - 01:01:59.022, Speaker B: See you at summit. Yeah. Please come say hi.
01:01:59.156 - 01:02:00.142, Speaker A: Of course, of course.
01:02:00.196 - 01:02:01.178, Speaker B: All right, see you all. Bye.
