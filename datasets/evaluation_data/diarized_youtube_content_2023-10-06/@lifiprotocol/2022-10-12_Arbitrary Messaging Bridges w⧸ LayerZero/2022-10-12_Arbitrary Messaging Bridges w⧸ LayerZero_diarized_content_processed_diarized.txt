00:00:05.960 - 00:00:21.401, Speaker A: That'll be awesome. All right, we're going to kick this off as we invite Brian Pellegrino, co founder of Layer Zero. Hey, Brian, welcome to our A and B series. It's great to have you here. How are you doing?
00:00:21.433 - 00:00:23.685, Speaker B: Hey, man, thanks so much. Glad to be here.
00:00:26.515 - 00:00:40.135, Speaker A: Yeah, we're really excited to have you here and kickstart this conversation. So with no further ado, I'd like to introduce our hosts, Arjun and Cram, AKA Lego Murdoch. Over to you guys.
00:00:41.755 - 00:01:25.645, Speaker C: Man, what a. What an introduction. Also great to have a blue checkmark speaker over here. Love that means we have a great Twitter space for you guys when we have a blue check mark as the guest. So just to introduce this little series that we have, this is the AMB series, only five times later. AMB stands for arbitrary messaging bridges, which is what layer 0 is. So recently, Arjun and I and all everyone at lefi kind of created and published a deep dive on arbitrary messaging bridges, where we compared and contrasted seven of the biggest bridges in the space.
00:01:25.645 - 00:02:08.685, Speaker C: Because this was like a 44 minute read in like 10,000 words. We figured that all of you degenerates probably just wanted a shorter, you know, synopsis of our analysis and audio version. And we thought the best way to get that across was to actually have different teams come on. So today we're having Layer Zero on the Twitter spaces with us. We're super excited about it. And before we get started, Brian, I would just love for you to hop in, give a little background on yourself, and then we'll jump into the Layer zero specifics.
00:02:09.605 - 00:02:56.355, Speaker B: Yeah, sure. I won't repeat the long version because I think many, many people listening probably heard it at least a couple of times now. But I've spent a computer science background, spent eight years playing sort of the highest stakes I could play in professional poker. Ten years starting companies, two of which were acquired and then another way too long period doing some ML stuff, so sold some machine learning models to some of the pro baseball team. I did academic research with Facebook, AI research, and have been in crypto since 2013, basically full time since 2016.
00:02:59.375 - 00:03:31.355, Speaker C: Beautiful. And I don't think I mentioned it, but Brian is the co founder and CEO of Layer Zero Labs. So he is probably the best person to Talk to about layer 0 in the entire world. So we're so excited to have him here. Arjun, I think I'll bring you in here to just give the listeners a basic foundation for what an A and B is before we go into the specifics on what layer 0 specific flavor of an A and B, how that works.
00:03:32.185 - 00:04:09.309, Speaker D: Yeah, thank you. First of all, Brian, great to have you here. Looking forward to the chat and about ambs, as you mentioned before. So they're arbitrary messaging bridges and these are like new age bridges that have just become very popular in the last six months. And they allow any piece of data to be moved from one chain to another. And before this we had token bridges and they only allowed assets to be moved across chains. But with messaging bridges there's a whole new world of functionality that we can open up.
00:04:09.309 - 00:04:29.085, Speaker D: So these allow contract calls, cross chain governance, cross chain NFTs, you name it. So we recently wrote a great comparison, a big comparison framework on some of the biggest bridges out there. And one of them was Layer zero. So super excited for this one.
00:04:31.145 - 00:04:52.365, Speaker C: Yeah, I think the best way to kick this off is to just ask the most general question that we can to Brian and ask Brian, what is layer zero? Just maybe the TLDR version and how does it work?
00:04:53.615 - 00:05:31.195, Speaker B: Yeah, Layer zero, the way that I think about it internally is just, you know, layer zero is a generalized messaging layer. That's what it is. So what it really gives you is kind of coordination between contracts. So you have all these contracts and all these different chains. You know, the first thing that people kind of built on top of this stuff were kind of singular bridges of value transfer. But then you realized when you generalized it more that really could be anything. And the way that a packet on the Internet is like a piece of compute on one side, a payload, some byte, some data and the piece of compute on the other.
00:05:31.195 - 00:06:24.115, Speaker B: Here you have kind of a contract call data and a contract call. And so when you think about it like that, like, you know, really you can do anything, anything between contracts that you can do on chain already, but you now have coordination or shared state. So this can be things like running a cron about state, sharing certain state information about the application itself. It can be mutating the metadata of an NFT because you've like won something in a game on the other chain or your usual cases of swapping, lending and borrowing, bridging, all of these things. It really is just as straightforward as that in terms of what it actually is kind of doing at the end State that. I think that's what all the arbitrary messaging bridges are trying to do. And that's certainly what we're doing is just generalized messaging.
00:06:24.115 - 00:07:16.593, Speaker B: How it works is layer zero is, you know, meant to be designed as a protocol and I think that's like very important. So it's meant to have kind of two core thesis. As we build this thing, those two things are like the tenants that we should never ever break. The first is that if our team disappears from the face of the earth today, the protocol will still exist. It's not a service, you're not opting into something that we're running. It's a protocol that exists and it will exist until Ethereum makes breaking changes. The second is that even in a world where we want to be maximally adversarial, where our only goal was to try to be and try to impact kind of the applications built on, all applications should have a way that we can have zero impact.
00:07:16.593 - 00:07:50.615, Speaker B: Right? We should be able to do no harm. And so like when protocols, that's how we think about it. So layer 0 is immutable endpoints deployed on every kind of nonce management and validation. Then you take a contract call on chain A. So this could be, let's just take a bridge for example, right? Like your classic wrapped asset bridge. It could be like, okay, we've locked up some asset here, earned some asset here. We're going to take a receipt of that, move it to the destination chain, prove that receipt and then do something over there.
00:07:50.615 - 00:08:12.075, Speaker B: So lock here, mint there, burn there, mint there, you know, whatever, whatever that might to be. And yeah, I would, you know, again, I don't know how technical you guys intend this to be or like how deep you want to dive into any of these contours, but I'm going to let you guys lead the conversation. So I'll keep it pretty vague for now.
00:08:12.615 - 00:09:06.765, Speaker C: Yeah, no, I think that was a fantastic synopsis. We actually do want to dive a little bit into the details here and I think a good place to start is talking about those endpoints on different chains. Because I think the endpoints and then the relayer Oracle relationship are the two major innovations that Layer zero has brought to the market. And so can you kind of talk about the big thing from layer zero, in my opinion is that you have created, I believe you call them your lightweight on chain clients via these endpoints which are actually just smart contracts on chain. Can you talk about how you were able to build a smart contract that is lightweight and maybe explain what that means to people who don't spend their entire day reading white papers?
00:09:07.135 - 00:10:25.605, Speaker B: Yeah, yeah, sure. So yeah, I mean really it came down to. So me and both my co founders a long time ago at this point, like our background was in IEEE testing and conformance, so working on like early Internet protocol standards and how these things are written and built. And it felt like the whole space was reinventing a lot of things, but not necessarily taking any lessons from a lot of this stuff, which is, which has already been built in other systems, right? Networking protocols, messaging protocols, these are not like new, you know, entirely new things, although we're applying it to definitely a new field with different parameters. And so one of the things about the endpoint was like you do not want to have a really bulky header, especially when we're talking about passing between networks and crypto where like data is very expensive, right? So like when you have these, you know, constructs what this messaging standard looks like or what anything looks like, extra space, things that are unnecessary just become so expensive over time, especially at high messaging volume. So the question was like the lightest weight thing that you can possibly do. And for us it really was just like nonce invalidation, like that's really all you.
00:10:25.605 - 00:11:09.957, Speaker B: What is a message order? Because we want to be able to guarantee the order of delivery so that relayers that sit in the middle can't, can't reorg or you know, can't move around and extract value by the order that they submit the messages in. And it forces applications to not be able to censor very efficiently. So helps for censorship resistance as well. But so the endpoint is just a bare minimum contract that's meant to say, you know, basically application interacts with it. All it implements is send and receive. So like I'm sending some arbitrary bytes and I'm interpreting bytes that are coming in and that's all that it does. And then on top of that you have a validation library.
00:11:09.957 - 00:11:45.031, Speaker B: And the validation libraries can evolve over time. So our big bet was that like every, every bridge basically that existed when we started this two years ago sucked in our opinion. Like basically all of them. There were no, especially for EVM stuff, they're just like, were no good bridges. Nobody was doing this efficiently. And like, we were basically the bet that, hey, we don't think any validation methodology that exists today is going to be de facto five to ten years from now. So why focus on that, right? Focus on the construct and have the validation library be able to evolve over time as everything comes out.
00:11:45.031 - 00:12:21.443, Speaker B: So you've seen sort of huge movements into improving this over the last kind of year or continuous, continuous movement to improving this. But already we've seen that. So like we've already put out five new validation libraries and we have another one coming out shortly. And so sometimes this is as simple as like, hey, this is A more gas efficient way of doing the thing we're already doing. So maybe it's 20% more gas efficient. And sometimes this can be something completely different. Like, hey, this is, you know, this is a ZK library, or this is optimism messaging.
00:12:21.443 - 00:12:59.639, Speaker B: This is, it could be an entirely different construct. There really are no bounds in what these validation libraries look like. But the point was that the endpoint is separate than that. It's entirely different problem. And then the way basically it deals with it is that applications interact with the endpoint so they're ending and receiving data from other contracts on other chains, usually themselves. So you know, like sushiswap to sushiswap or whatever and then they can opt into specific validation libraries. And so sometimes this is, you know, sometimes you always want to be on the newest one.
00:12:59.639 - 00:13:47.331, Speaker B: So maybe this is, you know, somebody who cares about gas efficiency, but sometimes you want to be on the most battle tested one. Say you're, you know, Stargate and billions or your AAVE or your Uniswap or whoever, then 20% gas efficiency might seem kind of attractive. But you might not want to move everything over from a battle tested library. So you have the ability to stay on a previous library for as long as you want in perpetuity. There's nothing we can ever, ever change that library completely immutable. We can never force you to move from that library. And so only when the new library has been battle tested for 12 months, let's say, then maybe you migrate over and it's the same thing, there's just different applications.
00:13:47.331 - 00:14:41.823, Speaker B: The kind of example I always give is the needs of, let's say ave a process like 500 million and you know, something like crabada dealing in, you know, 10, 10 cent crab NFTs, how they price security, how they, you know, cost for security is just like extremely different. So forcing them to opt into the same exact validation libraries is insane. And this is very common with governance too, right? Like why you want to stream every vote individually. Like imagine you're going from some other network to Ethereum. Like paying an Ethereum transaction for every single vote that goes through is insane. When you have the ability to batch transaction and validate them all at once, make a single attestation to the batch. There's all these different things about why you might want these libraries, but Layer zero itself as a whole is meant to really be agnostic about that.
00:14:41.823 - 00:14:47.795, Speaker B: It's a framework or protocol for doing these things. And then the validation can evolve over time.
00:14:50.665 - 00:15:34.915, Speaker C: That was a meaty description of the Endpoints and I, I always say in these a B series that like I need to go back and re. Listen just, just because there's so much alpha being dropped at all times. But okay, so we situated it. The endpoints are kind of the smart contracts on each chains that are, well they're. The endpoints are kind of the way that transaction are executed and started. That's where you're kind of touching the user applications. Now one of the reasons that those can be very lightweight is because there's some off chain computation being utilized via the Oracle and relay layer.
00:15:34.915 - 00:15:51.345, Speaker C: I'm hoping I'm describing that correctly. If I've messed anything up here, Brian, I'm sure you'll, you'll correct me, but could you maybe situate what the Oracle and relayers relationship is to the endpoints and then maybe dive into what those two entities do?
00:15:51.965 - 00:16:36.901, Speaker B: Yep. Yeah. So to be clear, there's no like real computation, right? The, the Oracle and relayer don't actually validate anything. They're not you know, running any of like the proofs or you know, nothing of that is being generated off chain. So the entire validation happens on chain in the validation library. So in the current validation Library which is ULN v2, what happens is you have some transaction that happens on source, you basically break apart this state data into two pieces, the hash or the block header and then the transaction proof. And so the Oracle and relayer basically take these components, submit them to the destination chain, then you do the inclusion proof.
00:16:36.901 - 00:17:35.929, Speaker B: So you walk the transaction proof up to the root configure, confirm that it's a valid transaction and then kind of pass it on to the destination contract if it is valid basically. And so those two systems, we labeled them a little bit foolishly, we called them Oracle and Relayer. I guess Oracle is the kind of larger misnomer. So we do work with all the major Oracles, but it really is just any system that outputs a block header and a relayer is just any system that outputs a transaction proof. So like this can look like anything, right? Like the chain links Oracle looks it might be than like switchboard or band or some application running their own. Really these can be any system. And I want to be clear that like the Oracle Relayer are also very specific to ULN v2.
00:17:35.929 - 00:17:52.245, Speaker B: Like the current validation library, there's a world where a new validation library has an entirely different construct. Right. So yeah, that is much less layer 0 specific and more validation library specific. But in the current construct, yeah, that's exactly what it Is.
00:17:55.425 - 00:18:02.695, Speaker D: So if you had an the opportunity to rename the Oracle component, what would you name it?
00:18:03.155 - 00:18:28.891, Speaker B: Yeah, it's a good question. It's funny, we were just talking about this, I think there would be another layer. We're actually likely going to be releasing something soonish. I can't remember what Isaac called it. There's Relayer, there's something else. I will have to come back to you with that. But he there, there's like another internal name.
00:18:28.891 - 00:18:40.535, Speaker B: We've already come. Like this has caused like way too much confusion for way too long, but I don't remember what he came up with. I've always been the bad one at naming to be honest.
00:18:42.795 - 00:19:29.345, Speaker C: Yeah, naming is always so difficult. Oracle, Relayer. Yeah, always, always, always a tough, tough decision there. Okay, so before we go further into I want to hit on pre crime and then we also want to have, we'll call it a. I don't want it to be a debate but a conversation about trust assumptions. But before we hit that, I think just a basic summary of like a transaction life cycle on layer zero. So if you could, you know, give maybe an example of a user application wanting to do a specific thing and how that works through the layer layers is layer zero system, that would be awesome and we can kind of get into some different topics.
00:19:30.125 - 00:20:02.187, Speaker B: Yeah, sure, absolutely. And for what it's worth, I'll just preface, I'm very open to debate so we can have however dynamic of a conversation you want to have. Don't be afraid to ask anything in terms of lifecycle of a transaction. I'll use Stargate. Stargate is this application that we built on top of layer zero. It's basically just a bridge, but a little bit different than normal bridges which we're really like. We're going to wrap locks something up on contract A and mint you a wrap synthetic on contract B.
00:20:02.187 - 00:20:50.591, Speaker B: Problem with that was the user, the holder of asset on the destination chain is the one who kind of absorbs all bridge risks. So if there was ever an issue with a bridge, if there was ever an issue with the contract, the user themselves kind of suffers. Their asset is now worthless. And we always thought that that was like a really terrible property and a huge divergence from how users are used to like okay, they swap in Uniswap, great, they absorb the risk of the Uniswap contracts but when they're done they just go about their day, they have their asset. They don't really like think about, well, maybe Uniswap's code is bad and Someone will find it and all of a sudden everything I have, my wallet will be worth nothing. And so the construct of Stargate was you're going to have liquid pools of assets. It solved a couple of really unique problems with kind of the delta algorithm that we invented.
00:20:50.591 - 00:21:16.659, Speaker B: But like the we're going to have native assets that sit in the pool. Users will simply be able to add to one, subtract from the other from their world. It will be, you know, totally, totally abstracted. They won't know the difference between anything. They're just going to keep the assets as exactly the same. All the risk is basically born by the LPs. So risk to the LPs, LPs get compensated for this.
00:21:16.659 - 00:22:05.951, Speaker B: Users have, you know, don't need to carry risk in perpetuity. And applications have this property of instant guaranteed finality. So this is why, you know, Sushi swap and Pancakeswap and all these others have kind of built on top of this and Radiant and many others. And so what a transaction there looks like at a super high level is very simply that a user adds assets into one side and withdraws assets from the other. So right, two contract cards add on chain A, subtract on chain B on the layer 0 side. You know what's really happening is user adds to a contract on chain A in Stargate. Stargate basically triggers a message to say, hey, I want to communicate like I'm going to this chain and the user is going to remove some asset from that chain.
00:22:05.951 - 00:22:53.725, Speaker B: I'm going to bring a receipt that gives the current updated state, state of the world in terms of how credits are indexed. That message gets moved across the destination chain. So again, the Oracle and relayer kind of pull apart the state data block header gets submitted on destination chain, transaction proof gets committed on destination chain, Merkle inclusion walk is done, message gets sent to the Stargate contract on the destination side. So Stargate contract now knows that that's a valid message. It reads that data, interprets it and says, okay, let me update my credit indexes and let me release these funds to the user on chain B. That's really like the high level flow of what's happening there.
00:22:58.545 - 00:23:18.665, Speaker C: Beautiful. And just from the user perspective, I just want to point out that I literally just used Omniax yesterday and I did a bridging transaction via layer 0 and I only paid gas on the source chain. Can you kind of talk about that decision and how you make that happen?
00:23:18.965 - 00:24:36.399, Speaker B: Yeah, 100%. So that was actually something we thought was super, super important, was the Current state when we started of bridges, where you want to go Ethereum to Solana and you were going to lock up some asset on Ethereum, so you pay an Ethereum transaction, you had to switch your wallet, get like to an entirely new wallet, right? Switch to a Solana wallet, go to some centralized exchange, get SOL in your wallet, need to like claim the transaction on the other side and then you can do something we thought that was, well, like one insane but incredibly restrictive to building like what real consumer experience would look like long term. And so we came up with this thing of gas abstraction, not, you know, completely novel. There's been plenty of ideas about like gasless transactions and other things, but really what this is is just a way to abstract away. And so now when you're going Ethereum to Solana, the source chain basically has a quote for units of, for the cost of Sol in units of eth for, for the example I gave above. And so the user gets quoted all at once for the entire transaction flow. They only ever sign one transaction and the entire flow gets executed.
00:24:36.399 - 00:25:23.085, Speaker B: So what this looks like now you might have something that's like really complex. Like it can be like unstake swap to a different asset, initiate a bridge claim, a bridge on the other chain, swap again to another asset and stake. So like six different transactions. And that could all be bundled up into one transaction for the user. The user clicks signs once from source chain, only pays in source gas. And you know, in their eyes, just like magically, they're in the other farm on the other side staking. So now when you talk about like wallet experiences, you know, you have a wallet that sits above and you know, monitors 15 different farms on eight different chains and the user can kind of seamlessly move between them without knowing the underlying chain, the underlying gas, any of that.
00:25:23.085 - 00:26:11.445, Speaker B: And so you have the ability to abstract away the gas of the coal itself and then even airdrop the user gas on the other side. How this is actually done is the relayer is responsible or any relayer is responsible for this concept of gas abstraction. So the relayers are managing pools of gas across each chain, pricing the gas kind of against each other on all across chains and then accepting a one and giving out on the other end. So it takes this complexity for the developer and this complexity for the user and moves it down a layer so that the people sort of running node infra and operating sort of the layers of this underlying network itself. The burden is kind of kept with them.
00:26:15.015 - 00:27:15.283, Speaker C: Yeah, the abstraction, the abstracting away gas from the End user, I think is crucial for the bridging space going forward. Just because I think, you know, we're kind of all degenerate. It's probably, if you're listening to the AMD series here from lefi, you're a bit of a bridge degenerate. But for normies, I think, you know, if they want to ever buy an NFT on, you know, an L2 or an Alt L1 and they have funds starting on mainnet, it's just, it's such a hard user journey and abstracting away a lot of the complexities and signatures is massive. And so I think what y'all are doing is awesome. Before we hop into trust assumptions, I'd love to hear a bit more. I've been reading a lot about Pre crime and what you're building there, and maybe you can hit pre crime what Layer zero thinks about, you know, their security levels.
00:27:15.283 - 00:27:22.855, Speaker C: I know, I know the Oracle and relay relationship is key to that and I think I'll just let you go from there.
00:27:23.715 - 00:27:53.581, Speaker B: Yeah, I mean, pre crime itself basically is, you know, you have this new element introduced and nobody was taking advantage of this before. And that seemed really insane to us and it really got thrown in our face when, when we launched, we kind of had no idea what to expect for launch. And then all of a sudden, within two weeks, Stargate had $4.4 billion in TVL and we were like, all right, we spent the next month doing nothing but security related things.
00:27:53.773 - 00:27:56.413, Speaker C: That's a good problem to have, right?
00:27:56.549 - 00:28:58.277, Speaker B: Yeah, yes, absolutely. But it was just very intense, let's say. And so, you know, pre crime was, listen, when you have a contract in an atomic setting, if there's a bug in the contract, it's just like hacked, right? Everything's gone fine. But like you have all these bridge hacks that play out in a way that any observer sitting from the outside like could tell you that this is wrong, right? Like Nomad, we all watch this hack over two hours, like slowly. It was like watching a train wreck in slow motion. The Axio Infinity hack, like, oh, do you think any, you know, 10 year old could look at this and be like, well, you're giving $650 million over there and you've gotten zero over here. Like, does that seem valid? So when you have this, when you lose atomicity, and that's what happens when you do transactions between chains, right? The best case you can possibly have is you've committed something into a block on source chain on chain A.
00:28:58.277 - 00:29:45.565, Speaker B: And then like, you need to Immediately get it in the next block onto chain B. Like that's the best possible case. And even there you have this measure of latency. And that measure of latency like introduces a really interesting surface around security. And so what we've done is said, hey, now when this is happening, what you can actually do is you can allow the applications themselves to set a list of invariants. Invariants are things that must be true for a transaction to be valid or to be submitted. And so now as you are going to submit this transaction on the destination chain, what actually happens is pre crime for all chains locally runs the state transition locally and confirms that the resulting state still meets all invariants.
00:29:45.565 - 00:30:23.045, Speaker B: So some clever bytes into a message and tries to convince the destination contract like, yeah, don't worry, I'm all good over there. I definitely gave you 20 million, so give me 20 million over here. Now pre crime basically just validates that. So like the natural invariant for a bridge would be like solvency. Yeah, if I'm giving out X here, make sure the entire system is still solvent or that I've received X over there. But there's tons of other invariants that applications could introduce. And so this is moving now from a singular service to being an entirely generic service that any application can opt into.
00:30:23.045 - 00:30:30.375, Speaker B: And I think that's like super, super cool for the kind of surface of risk in cross chain messaging.
00:30:31.275 - 00:30:57.105, Speaker C: Yeah, the way I sort of conceptualize the pre crime is I've, you know, we've all been, we were all really waiting for the merge for months and months and months and you know, they were doing shadow forks all the time. And I sort of envision pre crime like that, you know, you're forking and then you can kind of see what goes. If there's anything wrong with that fork once it goes through. Is that a good way to think about it?
00:30:57.885 - 00:31:04.465, Speaker B: Yeah, exactly. I mean that's exactly what's happening is local forks of every chain state transition locally and just check the state.
00:31:05.205 - 00:32:07.035, Speaker C: Yeah, I always like to try to summarize these right of the curve concepts for us people in the middle curve, like me personally. But okay, so I think we're about the 30 minute mark and I'd love to give you time to talk about what people are building on LZ at the end here, but I do want to just kind of Talk Trust. Layer 0 has one of my favorite, favorite, favorite white papers. I think y'all did a great job explaining what layer 0 is and going through the transaction life cycle. But one of the things that we've always talked internally here about at LeFi is that y'all describe yourself trustless Omnichain protocol. And I would just love hear what you mean by trustless. And Arjun, maybe you want to tack on something to that question.
00:32:08.725 - 00:32:31.345, Speaker D: No, I think you described it perfectly. And Brian has also been on many conversations. I remember him being on the burning bridges, Twitter spaces explaining everything to the team there. And yeah, we just want to ask you what is your definition of trustless and do you think layer zero in its current form is trustless right now?
00:32:32.325 - 00:33:03.747, Speaker B: Yeah. So I would actually that are involved in this over time and that don't like we don't think any system has the elements of complete trustlessness. We don't think it can be achieved in a cross chain manner. You can do things. So this can be the our definition of trustless early when we wrote the paper was this it was that an application who wants to have complete control over their applications want to. The largest applications of the world will want to have some lever of control over. Messages are going through.
00:33:03.747 - 00:33:53.487, Speaker B: So like circles recent USDC is a perfect example of this right where you, you know, circles basically saying look, listen, we're going to allow USDC to be minted across chains, but we want to be able to sign off on every single message that goes across. So it's not that we don't want to move it, it's not that we don't want to let bridges move it. It's not that we're not willing to encapsulate this within additional security properties of each of these bridges. It's that we sign and prove that it's valid. And that was the biggest thing for us is in all existing systems you would have this construct of, you know, there's one chain or one parameterization that sits in the middle. Every application must opt into that parameterization and everybody must have the same trust assumptions. Everybody must price cost for security at exactly the same price.
00:33:53.487 - 00:34:50.513, Speaker B: And so this gets into kind of the AAVE versus Krabata thing, right? So like if you're AAVE dealing with these huge liquidations and Crabada passing around some kind of like smaller NFTs, well the amount that you're willing to price costs for security is like drastically different. So if everybody's opting in the same parameterization like somebody is wildly, wildly overpaying or somebody's not getting nearly enough security and both of those situations really suck. When you have a smaller applications, they might be willing to opt into a certain configuration. This might be like Listen, Chainlink is my Oracle Coin, Coinbase is my Relayer. I'm okay sort of externalizing or pricing the risk that both Chainlink and Coinbase are not simultaneously malicious, including against the application. When you're a larger application, you might say, hey, actually I want to use an Oracle with a thousand nodes or relayer with 100 nodes. Or I actually, like Circle, want to have my own signature.
00:34:50.513 - 00:35:35.155, Speaker B: I want to run one of these components myself. I think that was the biggest thing is there's no underlying consensus, Meg. Like there is no BFT that's happening. There's Robin. There's no like pure consensus where you just sybil the network and all of a sudden you can like exploit everything on every application. The point of layer zero is to move these into like, specific shards or pathways of risk because you will always have, you will always have some risk, you will always have some trust assumption. And that gives the application the ability, right? When Cirque DC across layer 0 and they include their own signature in it, that gives them the ability to say they do not like their users don't need to unilaterally trust them.
00:35:35.155 - 00:36:34.115, Speaker B: Because if you're running one of these components yourself, you cannot do anything unilaterally, right? So if, say, a world where, I don't know, Uniswap decides that they're going to run one of these components, great. Users don't need to only trust Uniswap. Uniswap. If Uniswap tried to do something malicious, well, it would still be backstopped by the other piece in the system, right? They would basically veto that. But it also means that Uniswap or Circle or whoever has 100% control, such that if anybody else does anything malicious, they have the ability to veto that as well. So there's no additional trust assumptions past what they already have by basically entrusting, whether it's the application entrusting Circle, Circle already has trust assumptions around the centralized company and entity. If they run one of these components, they get everything that layer zero provides with trust assumptions.
00:36:34.115 - 00:37:11.145, Speaker B: Exactly what they wanted to do before. Exactly the same before. As we were writing this, that was really the definition was, you know, you have the ability as from the application perspective, to have this be, you know, no additional trust added to the system. And yet you're improving it such that you no longer have unilateral control. The users don't need to trust you entirely. But I do think over the last two years since writing the paper, one, both our implementation changed a bit from the way that the paper was described and to our view on the entire space has changed a bit.
00:37:14.605 - 00:37:57.125, Speaker D: I think that was a great way to put it, especially with the circle example and yeah, so you can as well, in the last answer, that you use a dlayer and Oracle combination. And that's how you kind of, you know, not depend on any one party as the other one can veto the the faulty one. So can you maybe talk more about the default combination of Oracle Relayer that you're using right now and if you've seen any application come up with their own combination of Relayer and Oracle? Because I know layer zero does provide flexibility.
00:37:57.825 - 00:38:34.455, Speaker B: Yep, yeah, 100%. So right now there are about nine oracles being onboarded. So these are, you know, every major traditional Oracle company in the world. So your chain, link, band, flux, switchboard, sort of all of these groups, right? And then you have this kind of TSS Oracle that's kind of from the large entities. So this is like Sequoia, ftx, Polygon. And then you have a bunch of applications who are introducing their own right now. On the relayer side, there's a wait list of about 40 to 45.
00:38:34.455 - 00:39:01.949, Speaker B: Most of these are kind of your large nodem for entities like very known entities who kind of are very good. Like when you're running a relayer, you need to do a bunch of things right now. You need to run full nodes of every single chain. You need to deal with GAS abstraction, you need to deal with all these things. So right now, LayerZero Labs is the only relayer. Is still the whole system from day one open and permissionless. Anybody can run an Oracle right now.
00:39:01.949 - 00:39:43.491, Speaker B: Anybody can run a relayer right now. But we have not released our reference implementation of our relayer and so that's made it time consuming for people basically to make their own. And so we actually just rewrote this entirely. We'll be releasing it soon. One of the biggest things was that relaying transactions, you know, that part is, that part's easy enough, right? You run the node and you pass across the transaction proof. But you have all these other things that came in, like GAS abstraction, like pre crime. And so now that becomes like pretty onerous, especially the GAS abstraction for every single relayer to need to do themselves.
00:39:43.491 - 00:40:19.915, Speaker B: So one of the big things was open up this reference implementation, break out these GAS abstraction and pre crime into modules, as we call them, and allow all relayers to be able to opt in or subscribe to those modules. So now it will be possible for anybody to easily Run a relayer and not need to deal with gas abstraction. Right. That is something they can, they can still tell if they want, but they can opt into an external module. And so basically we just continuously bringing the bar down for what it takes for people to be able to do this. And I think that really is like the biggest thing is just you gotta just make it easier for people. Right.
00:40:19.915 - 00:40:27.215, Speaker B: It should be similar to running a node in a network. It should be similar to kind of all these things that people are used to doing already.
00:40:30.595 - 00:40:49.005, Speaker C: Okay, and then outside of the additional security you get by running your own relayer, is there any financial incentive planned for LZ there for relayers or is it going to stay with just the security?
00:40:50.265 - 00:41:33.595, Speaker B: Yeah, yeah, of course. Right. I think any, for any network to make sense like there needs to be this level of crypto economic security both in how sort of their, you know, their own systems look like, which oftentimes are systems of bonding and slashing, but also in actual intelligence incentive for message passing itself. So right now the way that most relayers do this is basically Oracle's all of their own pricing mechanisms. So you go out to any of traditional oracles and they all price X for a call and each of them price this differently. So maybe you'll have an oracle that is cheaper and one that's more secure but more expensive and so on and so forth. Right.
00:41:33.595 - 00:42:12.589, Speaker B: So they all have their own mechanism on the relayer side, how this for gas abstraction at least it's typically you need to deal with gas Vol. So when you're leaving Ethereum, if you're waiting, let's say you've set your block comp. So that's another thing that's entirely modular in the layers. Zero side, it's not unified parameterization is every application gets to set their own block comp. So you know, let's say you set 15 coming. So now you need to wait 3 minutes and 15 seconds for your transaction to resolve. And so the relayer has basically already charged you on source for gas.
00:42:12.589 - 00:43:03.637, Speaker B: They've said, hey, I've collected gas here, so you know, you've paid me on source and I'm going to pay on destination on your behalf even if I lose money, even if the price has moved against me. So the relayer now is absorbing like 3 minutes and 15 seconds of gas volatility between the two gases, of price volatility between the two gases. And so they typically mark up that gas 3 to 5%. Now relayers, they lose, you know, they lose. I don't know what the exact number is, but let's say like 40% of the time they're submitting transactions or like losing the money and 60% of the time they're making some percentage of that spread. So maybe on average over time they make like, I don't know, one and a half, 2% on sort of like total gas spent across chains or at least the destination gas. So that's how it's done.
00:43:03.637 - 00:43:20.425, Speaker B: Now there's no, you know, it doesn't matter if you're sending a dollar or a million dollars or $100 million. There's no like BIPS fee that's added in. There's nothing additional on top of that. It's more on pure volume of messaging and markup of that gas itself to account for gas.
00:43:22.615 - 00:43:58.305, Speaker C: Okay, okay, that's. That is so much good info right there. And then. Okay, another question that Arjuna and I have kind of been talking about is, so layer 0 is an A and B. So you know, it's not always just going to be moving tokens from chain A to chain B. It's also going to be moving, you know, data from chain A to chain B. Is there any way for relayers to monetize that at the moment? Like conceptually, Is that something you're looking into? That might be a dumb question, but it's something that Arjuna and I are kind of thinking about.
00:43:58.685 - 00:44:52.385, Speaker B: No, yeah, absolutely. I think, you know, relayers have, at the end of the day, this, this layer, this like validation in the middle is likely to get commoditized over time, right? So like you relayers can charge even now they have the ability to kind of charge whatever they want. But it means that like most people are going to opt into something that is like sits more like everything is this, you know, think of it as this line of cost versus security, right? Everything comes down to that. You will always take something that is more secure for less cost. So if a relayer or any system jacks up their price to where it's like equal security for way more cost, people will migrate to another system, to another sort of operator, right? And so everything kind of lives on that line. The nice part about layer zero is like most other systems, they're a single point down the line. They say, here is our parameterization.
00:44:52.385 - 00:45:23.205, Speaker B: We're one point on cost for security. Everybody opted layer zero's construct was we're going to allow through this configuration of different, you know, Oracle and relayer configurations. Like let's say there's 10 points on the line. Now of cost for security and applications get to opt into which one they want. Maybe one wants to be on the left side of like cheap cost, low security because what they're doing isn't security intensive. But they still need these cross chain calls. And maybe somebody wants to be on the sort of extreme high right side.
00:45:23.205 - 00:45:59.125, Speaker B: And so you know, every relayer has the ability to price this and price sort of the system that they're engaging in for general calls. So relayer price when you're bridging a token. Right. If you're a bridge. So it's important to remember that layer zero, like I know we're arbitrary messaging bridges, but people think about bridges in the traditional sense of like okay, we're moving value, we're moving $1,000, a million dollars from one chain to the other. And the big thing is that when you're doing that, most systems monetize taking a percentage fee. So they're taking 6bps, 8bps, 10bps, whatever that is.
00:45:59.125 - 00:46:23.203, Speaker B: Right. Some percentage of that Overall transaction. Layer 0 is not that. Layer 0 doesn't know what the underlying call is. It has no idea if it's mutating NFT metadata or moving a token or releasing funds from opposite pool or just sharing state data between chains. So everything is a generic message to layer zero, all of it. You can build a bridge on top of that.
00:46:23.203 - 00:46:34.855, Speaker B: Stargate is a bridge on top of that. But layer zero itself doesn't know, doesn't care. Everything comes down to the pure generic message thing is priced to that pure generic message call.
00:46:37.955 - 00:46:42.255, Speaker D: That's a lot of great information that's not publicly available by the way.
00:46:43.555 - 00:46:49.165, Speaker B: So much for a better job of putting stuff out. I know, man. Yes, very, very aware.
00:46:50.345 - 00:47:21.525, Speaker D: I mean it's great. So as long as you talk about it honestly, it's very good to see that. And another trust assumption that we've written is basically what happens if there's a 51% attack because layer zero has endpoints on different chains. Right. So in case of 51% attack, how would the design perform? Will the users funds will be at risk or have you guys thought about this before?
00:47:22.385 - 00:48:02.931, Speaker B: Yeah, 100%. So this problem really sits outside of all messaging. Right. Messaging at its core is you're going to affect a state on a destination chain. You're going to mutate some state over there based on a belief state of source chain at a current point in time. As soon as you mutate that state, as soon as you affect a contract on the destination chain, you're doing that with the belief state of source, whenever that happens, if there's a reorg after that, it doesn't matter what messaging system you're using, it's going to have basically done something based on incorrect data. There's always risk inherent there.
00:48:02.931 - 00:49:21.009, Speaker B: The way that we have done this, what we didn't like about other systems is that every other system was, hey, everybody into the same set of parameters, everybody subscribes 10 block comps or 100 block comps. You might have systems who push a new update and that totally changes the underlying security parameters of the overall system. Obviously we did Nomad, Nomad pushed this new code update and everything on top was exposed to this, this new thing that was pushed. And in most systems that's the same thing, right? They might push something that says, hey listen, we actually think it's a better user experience to go to 50 block comps on Polygon instead of 200. We think that's probably within the bounds and maybe that's fine for some applications, but for other applications with hundreds of millions or billions at risk now there might be like a real direct economic incentive to reorg policy on, to try to basically get that right. And so we didn't think that makes sense at all to live at the technology layer, so that lives at the application layer for us. And applications can decide if they want to wait 5 blocks, 15 blocks, 500 blocks, bypass optimistic roll ups or not, totally up to them.
00:49:21.009 - 00:50:28.843, Speaker B: At the end of the day, the application itself basically gets to decide what they want that risk threshold to be. And so when you're moving, you know, I don't know, a billion dollars between central banks, like maybe you don't care if there's a full day of clearing time when you're moving, I don't know, some arbitrary state data for something that like doesn't have strong financial incentive behind it. Maybe you just want it to be incredibly fast and like it just doesn't matter that much. At the end of the day we give applications optionality, but in all messages systems it does not matter which one you're describing if you affect a contract on destination chain based on an incorrect view of the source chain. So after the transaction happens, source chain gets reorged, there's nothing that you can do. The only way you'd be able to do that is like you would have to give the destination contract like complete arbitrary control to like arbitrarily reorder or like roll back any transaction ever, which would be the most insane sort of security assumption for any application. Or user building on top.
00:50:28.843 - 00:50:52.885, Speaker B: So you know, I don't think you'll ever, ever really see a system like that. But yeah, 51 packs of source chains themselves are always going to be an issue. And all messages universal for us we just say we doesn't make any sense for us to arbitrarily decide that applications or for the protocol to do that. That should not live at the technology layer, it should live at the application layer and they should have optionality for what that looks like.
00:50:55.345 - 00:51:13.961, Speaker C: That was a very answer for the 51% attack. Yeah, that, that, that is kind of to me a very under discussed topic in the bridging space. So thank you for all that good info. So I think we have prepared for it.
00:51:14.113 - 00:51:18.005, Speaker D: He was waiting for this question and he had an answer ready like the perfect.
00:51:20.185 - 00:51:29.485, Speaker B: I mean we talk about this a lot, right? That's like a, it's a huge, huge assumption with how applications build. So this is something we've been talking about internally for you know, a year and a half now or something.
00:51:32.505 - 00:52:20.195, Speaker C: Yeah, and I'm. We could probably talk, we could probably have a whole nother Twitter space. It's just about the 51 attack, but we only have like 12 minutes left. So I do want to just kind of clear, clear the floor here and talk just more about like where Layer zero kind of sees itself in the AMB world. We're asking this to everyone who comes on to the AMB series but like how does layer zero kind of see the other types of AMB bridges? You know, whether it's wormhole seller, IM, synapse, there's probably 10 or 15 out there at this point. Do you think that it is a one bridge to rule them all type of ecosystem or do you think there's room for others?
00:52:22.535 - 00:53:09.311, Speaker B: Yeah, so I mean I think very clearly, I think very clearly when it comes to technology and certainly technology like this, it's very likely to be winner take most. So like that's my personal opinion is it is very likely to be winner take most. I think if anything the space has taught us over the last year or two is that really what you need to focus on is like surviving, right. Like security needs to come first. We've just been doing our thing, just continuously progressing along and every single other person building in the space, hack after hack after hack after hack. And so we think long term, like security will be the baseline for everything. Everything basically will revolve around that and like the majority of other things will be secondary and like great gas obstruction, all this stuff is Fantastic.
00:53:09.311 - 00:53:56.677, Speaker B: But really underlying security matters more than anything because like if you're, if you get hacked, like none of it matters. It doesn't matter what fancy thing is. So the, our big issue internally with other systems, and I've talked about this quite publicly, was, was two is one. That risk was centralized. So one system, one set of whatever and if that breaks, you know, arbitrarily send messages to every application on every chain. So maximum contagion, mint infinite of this stable and drain every dex and every lending pool thing just cause the maximum chaos kind of universally. And so the assumption there is like that single system has the ability to secure the unified value of every other chain, which seems insane.
00:53:56.677 - 00:55:05.385, Speaker B: The other actually more pressing concern is just the general security practices. We're like, we try to be really insane about how we approach this, which is every single thing that we write basically goes through one to three internal audits and one to four external audits, usually two to four depending on how sensitive. So like we've spent four plus million dollars now on audits alone just year to date, just this year we have four ongoing audits. Right now we have three auditing teams on permanent retainer. And so like when we see other systems basically, you know, one single audit back with like 40 issues and you're like, all right, fix the issues and chip into production hacked, right? Like that kind of stuff just feels like the space just won't allow that to be the status quo for a long time. And then the other thing is you might have whatever fancy hand and wavy stuff you have on top. You have this really awesome new validator system, do ZK this or Optimistic messaging or it doesn't matter.
00:55:05.385 - 00:55:48.785, Speaker B: But every single one of these systems have their contracts completely upgradable. So no matter what you're hand waving up top, at the end of the day the minimum security assumption is just the admin keys of the upgradable contract, right? It's just like a single multisig that can change the underlying security properties for every single application. And like that to me is just, is just insane. People love to focus on like the flashy up top, like oh, this new thing, that new thing. But when you actually dive into the code and look at the underlying system like it's just one single set of admins that we see in admin keys get hacked like time and time and time again. Like we have to look at Harmony and Axiom, like all these other examples. And so like I think the space really will stop.
00:55:48.785 - 00:56:20.059, Speaker B: Well, like we'll start to coalesce around pure underlying. And I think that more than anything else will, will be the biggest lever. And I think upgradable contracts right now is just like acceptable practice within the space is is utter, utter, utter madness. And so like for you know, obviously our stance is maybe a little bit skewed but, but like we just don't ever ship. Every single thing that we ship is immutable. Endpoints are immutable. Validation libraries are immutable.
00:56:20.059 - 00:56:32.775, Speaker B: We can never change those properties on anybody. And we think the whole space will move in that direction. And if they don't, we think they will continue to suffer hack after hack after hack, which I certainly hope does not happen.
00:56:35.875 - 00:56:56.455, Speaker D: I think we all that and we're always pushing for better security practice practices and as you are. So it's great to hear that you're always working on that. Next thing we'd like to ask is who is already building on layer zero and what are the use cases that you think are like perfect to build on layer zero?
00:56:58.435 - 00:57:39.425, Speaker B: Yeah. So it has been very, very interesting when we launched so launched roughly about six months ago now when we launched there were 700 contracts on Testnet and zero on Mainnet. So we had like a small developer community who like thought when our original white paper was published were cool and people were testing, they were starting to build things. Fast forward six months later, obviously like I said Stargate launched. Stargate went to 4.4 billion TVL. Stargate was its own independent thing as just the first application on top that was so it had its own kind of entity.
00:57:39.425 - 00:58:12.715, Speaker B: And then externally to that, you know testnet contracts have grown from 700 to 8,000 plus. So massive bottoms up like developer growth of just people building. Right. Most of these people don't ever talk to us. They come in, they use the docs and they built like a huge community of people building 1200, almost 1300 contracts on mainnet. So a lot of those have already migrated over to mainnet and a huge amount of overhang still coming over. So there are a ton of people genuinely building and then externally to that, you know we have teams now.
00:58:12.715 - 00:58:51.847, Speaker B: I think there's more than a billion dollars of external teams and TVL already on top of layer 0. I think there will be multiple billions more coming in the coming months. So you know there's, there's a bunch of other stuff that's, that's right around the corner but there's already you know, billions in TVL externally to Stargate. Add on Stargate as well. You're talking probably two plus billion billions in transactional volume. Yeah, it's been like we have been blown away by how vibrant the dev community has been. And I think that metric of just like test net contract growth, main net contract growth, like how many migrate over.
00:58:51.847 - 00:59:11.211, Speaker B: That's really the stuff that. And overall messaging that I pay attention to. But yeah, you've seen teams like hash flow teams like radiant Tons. Tons. Tons, obviously, again, like sushi and pancake. Yeah. There's a bunch more that I'm a clear pool, a bunch more that I'm missing.
00:59:11.211 - 00:59:23.935, Speaker B: But a lot of really quality teams have come out and they've gone on actually to have massive TVL to raise amazing valuations. It's been really cool to. I've loved working with the ecosystem.
00:59:24.955 - 01:00:14.655, Speaker C: Yep. The radiant use case in particular, where you can, I believe you can deposit on one chain and take a loan out on another is cool. And another thing I like to ask all of these A and B builders is, you know, to put on your, you know, futuristic hat, you know, extrapolate out five years. What do you think is like a really cool use case that AMBs are going to allow developers to build in the next five years or decade that we're probably not even thinking about now? I think as people building in this space and The A and Bs, like, you guys have a great kind of head start on all of us normies who are still thinking liquidity network works our bridges.
01:00:15.315 - 01:00:50.315, Speaker B: Okay, so the thing that I usually bring up here, and again I always preface this with I am literally the only person I've ever heard talk about this. So I have no, like, I don't think anybody else is excited about it. But when we talk like five years, this is something that's always been in the back of my. Basically, like, I think we're at the stage now where just like early Internet, every. Everything was built monolithically. Right. When I wrote code when I was 13, you know, I would write a cool program and I would like host it on my own computer that would sit in my house and like, lucky people would like put it in a server that would sit in a data center.
01:00:50.315 - 01:01:29.279, Speaker B: But it was just like single application, single server and like, that was it. That's what, that's how applications were built. And then you now fast forward to today and like every single thing that we do basically involves like microservices. Like, that's why we're able to stream this right now. That's why we have Netflix and Zoom and like all of these other things. You have all of these systems that are like hyper optimized for storage, for compute, for all of these different things. And so I think there's a world where once you have the seamless layer of communication between chains, now you have the ability for applications to build things that are like orders of magnitude more complex that are being built right now.
01:01:29.279 - 01:02:25.565, Speaker B: So like you will never store everything you want on Ethereum ever. But like now you have the ability to have all of your storage on arweave, like take it, bundle it up, do a really complex computation on Solana, roll the result back to Ethereum. You basically have the ability to leverage these orthogonal trade offs of every chain and fracture kind of the way or where the compute or how each of these components are done in the underlying application and basically resolve all that to a single source. And I think that sort of architecture is completely unexplored right now and super, super, super interesting. So you know, I guess contrarian takes or like future takes and it be like, oh, it'll be some iterative improvement of exactly what we're doing now. Like that's my contrarian take I guess is like that, that sort of thing will be unlocked. And I think that's just so far away from what's happening right now that it's, it's super fascinating.
01:02:27.915 - 01:03:00.205, Speaker A: Yeah, that's really great to hear and to have you just, you know, pull back the curtain on what it may look like five years down the line. And it's really great for us just to see as listeners and those who are fans of LAY zero and users, we're coming towards the end of this now, Brian, but I'd really, really like you to touch on anything else that you maybe would like to add to the conversation. Maybe something you were hoping to, well, maybe hoping that we would bring up, that maybe we didn't bring up. Is there any alpha, anything you'd like to share with our community and your community here today?
01:03:01.345 - 01:03:36.555, Speaker B: I mean listen, like from, from, from our end, it's, it's the same sort of thing that I described before. Like I think anybody who watches us regularly like sees that we ship a lot. Like our focus is just to keep doing the thing that we're doing, keep chugging along, be always first. Like we will just be that, that steady horse in the race who hopefully, you know, stays ahead on sort of all fronts. Pure focus is developer adoption. I make it as easy as possible for people to build on top of 19 chains. Right now we're about to add our first non EVM.
01:03:36.555 - 01:04:00.175, Speaker B: So we'll be on Aptos Day 1. We'll be on Sui Day, be on Solana shortly. So just like slow but sure progress. And I think again, I hope we'll be able to continue working with people who just like build freaking awesome stuff on top of us. There's such a huge pipeline of people building stuff that hasn't come out to market yet that I'm just excited generally for the space.
01:04:01.195 - 01:04:53.415, Speaker A: Yeah, I think we share that sentiment. I'm really excited as well and to be building alongside as we've aggregated Lay zero vice, Stargate. Obviously this has been a really insightful and fruitful conversation. I don't know, these A and B series spaces just seem to be getting better and better and it was really great having you just share some insights, Brian. So thank you so much for being a part of this conversation in the space with us and you know, just hopping on this call with us and to our community members, thank you for joining in, tuning in. As always, Arjun and Mark were here with us giving us all the alpha communication and insights over there. But before we leave, I do have to mention that if you have not read this wonderful piece of art that I like to call it the A and B comparison framework by Arjun and Mark, then head over to our blog and read it.
01:04:53.415 - 01:05:06.825, Speaker A: We touch on all things A and B, providing an overview of them, how they work, transaction lifestyles. Lifestyles. Also life cycle. I mean transaction lifestyles. That's interesting. All types of security. We overview the trust assumptions.
01:05:06.825 - 01:05:17.761, Speaker A: So this is, this is a Great read. It's 44 minutes long, so have some snacks ready but I promise you it'll be worth it. But that's all we have.
01:05:17.793 - 01:05:31.995, Speaker B: I'm looking, I'm looking. I'm looking forward to a bridge Bridge Vogue, you know, with Transaction Lifestyle. So I'm excited for you guys next piece to come out. Thank you guys so much for the conversation and thank you guys for having me.
01:05:32.455 - 01:05:34.235, Speaker A: No, thanks for being a part of it.
01:05:36.295 - 01:05:37.915, Speaker C: All right, until next week.
01:05:39.975 - 01:05:41.735, Speaker A: Until next week. Cheers everybody.
