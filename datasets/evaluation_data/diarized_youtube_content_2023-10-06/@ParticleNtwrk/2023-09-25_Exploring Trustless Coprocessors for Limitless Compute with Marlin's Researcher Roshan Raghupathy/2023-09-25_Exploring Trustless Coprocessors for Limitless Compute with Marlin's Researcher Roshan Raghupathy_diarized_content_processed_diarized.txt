00:00:00.120 - 00:00:02.714, Speaker A: Sharing. I welcome you to join us in a room.
00:00:07.654 - 00:00:08.478, Speaker B: All right, cool.
00:00:08.526 - 00:00:09.414, Speaker C: Let's get started.
00:00:09.574 - 00:00:25.174, Speaker B: So I'm originally at Madden and we are currently building code processors for you. So let's start with what I mean by what is a code processor. So traditionally a core processor is like an additional processor that you just quickly supplement your tool.
00:00:25.294 - 00:00:31.200, Speaker C: An example would be like a GPU, for example, from them. And it's usually Petra.
00:00:31.232 - 00:00:38.584, Speaker B: At certain tasks there is a cpu faster, cheaper or more efficient. And you can sometimes offer entirely new capabilities.
00:00:38.704 - 00:00:46.084, Speaker C: For example, your phone probably has an independent network card, which enables mobile, which is if you can't really do.
00:00:48.144 - 00:00:54.592, Speaker B: While the coprocessor is an additional cost, the reason why we do it is because it usually improves the performance of.
00:00:54.608 - 00:01:04.168, Speaker C: Your system on the constant system as it goes. For example, if you buy a desktop.
00:01:04.216 - 00:01:06.160, Speaker B: Office shell, you can add additional stuff.
00:01:06.192 - 00:01:12.364, Speaker C: Into your desktop, the other components that you might have in the system.
00:01:13.304 - 00:01:31.316, Speaker B: So like there's some examples over here, the one of the GPU's. So the one on the top left is like a very old floating point system called stuff.
00:01:31.340 - 00:01:32.420, Speaker C: I'm just doing integer stuff.
00:01:32.452 - 00:01:42.424, Speaker B: So you need a separate chip. And the one in the top middle is what you currently have on your iPhones. It's like a security player that's inside your iPhone system.
00:01:43.004 - 00:01:51.652, Speaker C: And on the top right you have an audio card, which is like audio processing capabilities nice to plug into.
00:01:51.828 - 00:01:54.556, Speaker B: And the only one is like Ethernet.
00:01:54.660 - 00:01:56.744, Speaker C: Obviously your CPO can't talk to the network.
00:01:58.964 - 00:02:05.532, Speaker B: So what we want to provide is basically that. So the way you currently add a.
00:02:05.548 - 00:02:06.932, Speaker C: GPU to your system to make it.
00:02:06.948 - 00:02:09.212, Speaker B: Faster, more efficient, all that, we want.
00:02:09.228 - 00:02:11.424, Speaker C: To do that for like other.
00:02:15.224 - 00:02:26.232, Speaker B: Yeah. Let's answer the most important question, which is why? So main reason is this experience for web3 today sucks because smart contracts.
00:02:26.248 - 00:02:27.488, Speaker C: Are like really expensive.
00:02:27.656 - 00:02:32.072, Speaker B: And that's because the execution today is basically performed by all the validators, right?
00:02:32.208 - 00:02:38.648, Speaker C: And maximum decentralization, which means it has to support hardware that's not as strong.
00:02:38.816 - 00:02:41.088, Speaker B: And it also has to make comment.
00:02:41.136 - 00:02:44.518, Speaker C: Hardware that anybody and everybody can use. So.
00:02:44.686 - 00:03:17.238, Speaker B: And it also makes a decision to prioritize simplicity, performance. It is not to say that these decisions are bad. Decisions are good for what Ethereum actually provides. So yeah, the goal of Ethereum is to be like decentralized, to be accessible to as many people as possible. And since it's a very core infrastructure component, it has to be like ideal that I'm like a no surface area for parts of. The problem is that this basically makes the video slow you have a limited instruction set.
00:03:17.286 - 00:03:23.190, Speaker C: For example, all your cpu's today probably have vector instructions which are not exposed inside the game at all.
00:03:23.302 - 00:03:29.422, Speaker B: And you don't have any hardware acceleration. So let's try to redesign our own.
00:03:29.478 - 00:03:32.474, Speaker C: Computer code processor that can serve.
00:03:33.014 - 00:03:39.078, Speaker B: I have a few votes over here for one. All the computers basically performed by every validator.
00:03:39.126 - 00:03:41.754, Speaker C: So let's minimize the amount that needs to be done.
00:03:42.134 - 00:04:08.820, Speaker B: And while doing this, I'm fine incurring the cost of higher compute on the co processor itself. Within skills obviously I want to want it to be usable from the blockchain, so I need smart contract communication. And further, I'm going to make it as doesn't seem familiar to you because what I just described is vault.
00:04:08.852 - 00:04:09.424, Speaker C: No?
00:04:10.004 - 00:04:12.060, Speaker B: So they excel at literally one task.
00:04:12.132 - 00:04:14.620, Speaker C: Which is quickly and cheaply prove that.
00:04:14.652 - 00:04:16.332, Speaker B: A given set of framework chains takes.
00:04:16.348 - 00:04:18.024, Speaker C: A blockchain from extreme data state.
00:04:18.804 - 00:04:23.716, Speaker B: And the way the minimize on chain compute is basically by shifting the burden onto a program.
00:04:23.860 - 00:04:27.772, Speaker C: So your secret is basically, and a.
00:04:27.788 - 00:04:29.358, Speaker B: Nice property is trackable.
00:04:29.476 - 00:04:31.854, Speaker C: So you can just have rollouts and products and robots.
00:04:33.674 - 00:04:39.794, Speaker B: But Rolux still don't really work for us because rollouts are fundamentally also just.
00:04:39.834 - 00:04:42.534, Speaker C: Smart contracts, which means they are limited.
00:04:42.954 - 00:04:47.826, Speaker B: By the same limitations that you have on Ethereum, which is that you don't.
00:04:47.850 - 00:04:51.610, Speaker C: Have a lot of capabilities today. Like you're basically only access data that's.
00:04:51.642 - 00:04:52.946, Speaker B: Already on the blockchain.
00:04:53.090 - 00:04:56.856, Speaker C: You can't really access data that's unlike other blockchains you can't access data from.
00:04:57.050 - 00:04:59.556, Speaker B: Usually API, you can't serve request to.
00:04:59.580 - 00:05:06.284, Speaker C: Users, you can't do anything. The transaction is like quite small, complete simple settings.
00:05:06.444 - 00:05:08.124, Speaker B: And we're going to keep performing computation.
00:05:08.164 - 00:05:10.944, Speaker C: In private because most of the transactions are just public.
00:05:11.844 - 00:05:16.924, Speaker B: So our goal is to do so much more than that.
00:05:17.044 - 00:05:18.944, Speaker C: That's why we're building our customers.
00:05:19.684 - 00:05:25.818, Speaker B: So let's think about this. So what if my smart contract could.
00:05:25.946 - 00:05:29.454, Speaker C: Get for Internet access and possibly make API queries from the services?
00:05:30.074 - 00:05:31.506, Speaker B: What if I could get access to.
00:05:31.530 - 00:05:39.214, Speaker C: Data that's another blockchain and I can process them? What if I could run my own like a specific instead of serving?
00:05:39.834 - 00:05:43.814, Speaker B: And what if I get better vms than the EM may be more efficient?
00:05:45.194 - 00:06:00.144, Speaker C: How can I run servers like directly accessible my users through, especially if they are compatible with your existing browsers, which apps can make the choice for themselves?
00:06:00.644 - 00:06:27.668, Speaker B: So there's good news. And the good news is that our program is this. The bad news is it doesn't provide all of it all the time. You kind of have to pretty much use between what you want for the application and the most basic thing that you might probably be in and choosing is what is the security model that you want. So one choice is of course you get proofs, cryptographic proof of computation. This means it supports a wide variety.
00:06:27.716 - 00:06:33.620, Speaker C: Of proof systems and different radars based on pro sizes, proving times what supported stuff.
00:06:33.812 - 00:06:37.544, Speaker B: And if done well, it gives you privacy for free.
00:06:38.324 - 00:06:42.638, Speaker C: And the primary goal of course make a large amount of effort to achieve the verified answer.
00:06:42.796 - 00:06:59.106, Speaker B: So ZK Pros provide cryptographic security, which is the highest level you can get, but they're pretty expensive and pretty slow. The other choice that we provide is secure intakes. So these are hardware isolated environments, that.
00:06:59.210 - 00:07:03.494, Speaker C: Is code and data from environment, including the host that's actually running.
00:07:03.914 - 00:07:05.614, Speaker B: It's pretty popular to build into.
00:07:07.434 - 00:07:11.982, Speaker C: Our Google confidential computing time.
00:07:12.158 - 00:07:15.474, Speaker B: Something we are really excited about is echoing.
00:07:18.934 - 00:07:20.670, Speaker C: Applications for there as well.
00:07:20.862 - 00:07:28.422, Speaker B: So employees are much cheaper, much faster than CD approach.
00:07:28.558 - 00:07:33.034, Speaker C: But the security you get is not from cryptography, it's from the application, from the online.
00:07:34.934 - 00:07:45.618, Speaker B: So depending on that, depending on what your requirements are, you probably pick one of like three parts to use a constraint. One of the first going serverless using encase.
00:07:45.746 - 00:07:48.174, Speaker C: So this is best suited for like short tasks.
00:07:48.754 - 00:07:50.130, Speaker B: If you need like load and select.
00:07:50.162 - 00:07:59.698, Speaker C: High performance API servers. For packing server you pay only for what you use because it's serverless and.
00:07:59.866 - 00:08:01.722, Speaker B: You can sort of access the entire network.
00:08:01.778 - 00:08:07.774, Speaker C: So that means you have access to APIs, rpcs, to other chains and like full data support.
00:08:09.954 - 00:08:17.458, Speaker B: The other option is do the same thing using secret rules. So you get better security in the form of, because you just get the.
00:08:17.546 - 00:08:19.374, Speaker C: Highest level of cryptographic security.
00:08:19.674 - 00:08:24.714, Speaker B: But you kind of have to make some trade offs over there. One major tradeoff is you can't really.
00:08:24.754 - 00:08:31.134, Speaker C: Access a message of data on the network because you can't really create CKM rules for the independent cpu.
00:08:31.774 - 00:08:33.710, Speaker B: And it's also relatively a lot more.
00:08:33.742 - 00:08:36.714, Speaker C: Expensive and slower generated, you can see.
00:08:39.094 - 00:08:53.342, Speaker B: So that's one and the third option for those of you who don't want servers serverless is just run your own server. It's well suited for like tasks that.
00:08:53.358 - 00:09:07.800, Speaker C: Are long running on the perpetual, they run forever. There's a capacity for your server with stateful execution. So even sort of save stuff on there, save stuff in memory that you use to serve the next request. Don't have to do everything from scratch.
00:09:07.832 - 00:09:11.768, Speaker B: Again and basically run anything in any language because at the end of the.
00:09:11.776 - 00:09:16.244, Speaker C: Day what you have is your current code will just work inside app just like that.
00:09:16.664 - 00:09:18.976, Speaker B: And you get obviously the highest level.
00:09:19.000 - 00:09:21.124, Speaker C: Of latency and performance from this.
00:09:22.144 - 00:09:25.248, Speaker B: So yeah, there's no onsize fix all.
00:09:25.416 - 00:09:29.366, Speaker C: It's all in real because based on what you want, instead of just picking.
00:09:29.390 - 00:09:35.094, Speaker B: It ourselves, we believe that we should just offer a toolbox and applications are sort of free to choose what works.
00:09:35.134 - 00:09:36.234, Speaker C: Best for their use.
00:09:38.174 - 00:09:42.354, Speaker B: So this is something that people are already building on us.
00:09:42.894 - 00:09:44.878, Speaker C: So we have like people in backend.
00:09:44.926 - 00:09:46.394, Speaker B: We have some people working on like.
00:09:47.974 - 00:09:48.994, Speaker C: For example.
00:09:51.374 - 00:09:52.446, Speaker B: There are some people running.
00:09:52.470 - 00:09:59.494, Speaker C: MVP bots and stuff. Arc is not using master for the custom cryptography because Ethereum obviously doesn't have pre compiled.
00:10:00.994 - 00:10:06.914, Speaker B: So to support our CK means we are also running like a roof market.
00:10:07.074 - 00:10:08.466, Speaker C: So let's say you have apps that.
00:10:08.570 - 00:10:10.490, Speaker B: Need ZK proofs to be generated, but.
00:10:10.602 - 00:10:19.930, Speaker C: They don't really have powerful hardware or. So we sort of have a specialized network of operators, one much more efficient since they serve a lot of multiple.
00:10:19.962 - 00:10:22.398, Speaker B: Projects they can much faster and cheaper.
00:10:22.446 - 00:10:24.766, Speaker C: Because they have specialized hardware that's due.
00:10:24.790 - 00:10:26.198, Speaker B: To generating CK groups.
00:10:26.326 - 00:10:29.234, Speaker C: So yeah, this is something we are working on as well.
00:10:31.054 - 00:10:34.438, Speaker B: All right. Yeah. So to wrap it up, if you.
00:10:34.446 - 00:10:39.166, Speaker C: Guys need computer apps that you want to be verifiable on chain or you.
00:10:39.190 - 00:10:40.862, Speaker B: Guys are probably having servers today, feel.
00:10:40.878 - 00:10:44.606, Speaker C: Free to come speak to us and.
00:10:44.670 - 00:10:45.838, Speaker B: See what's your bullet something goal.
00:10:45.886 - 00:10:52.714, Speaker C: Obviously happy to provide grants and credits. We just launched an awesome minute like a couple of months back. So if you guys want an answer.
00:10:54.214 - 00:10:57.214, Speaker B: That'S it from my side. Thank you for social.
00:10:57.374 - 00:11:01.954, Speaker C: Obviously I'll be around the event. So if you guys want to talk to me, feel free to come pick you.
00:11:02.694 - 00:11:03.534, Speaker A: Thank you so much for.
