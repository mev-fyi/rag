00:00:00.240 - 00:00:51.538, Speaker A: In just nine minutes lets learn how to send gasless transactions purging particles wallet as a service as well as biconomy to facilitate full ERC 4337 account abstraction functionality. So a somewhat lesser known component of particles wallet as a service is our native account abstraction stack, as well as our compatibility with various different aa stack providers. This means that as a developer you have the freedom to choose whether a user is onboarded to an externally owned account or a smart account after they log in with their social accounts like their Google, email, etcetera through particle authentication. So you can use particle as a sort of smart wall as a service utilizing MPC tss onboarding through various social logins to facilitate complete account abstraction interaction. Specifically, today we're going to be creating a demo application that leverages our native account abstraction SDK to utilize a smart account tied to our social login and send gasless transactions. So in just nine minutes, let's learn how to leverage particles wallet as a service in tandem with biconomy to use a smart account and send gasless transactions. All right, let's jump right into it.
00:00:51.538 - 00:01:28.368, Speaker A: So, to preface again today we're going to be building a demo application that leverages our account abstraction SDK in tandem with particle auth to facilitate the creation management of a smart account, which we'll then use to send a gasless test transaction. And of course this is happening largely through biconomy as our account abstraction SDK has built in bikonomy support. Okay, so to begin like usual, we need to start by importing a few base libraries. We can start with react, and specifically we can import, use state and use effect. We can also import particle network from apparticle dash network. This will be sort of the master variable for configuring and interacting with particle. To go with this, we'll also need to import particle provider from apparticle and bash network slash provider.
00:01:28.368 - 00:01:58.576, Speaker A: Additionally, this application will be hosted on ethereum go early, which we can import from apparticle network slash chains. And finally, our last import from particle network will be from the account abstraction SDK. For this we'll need to import a wrap provider smart account and send transaction mode. And that'll come from particle network aa. We'll also be using ethers for our connection to web3, so we can import ethers from ethers. And then finally, of course we can import our css. Alright, so now that we've imported all of our libraries, we can move on to establishing some base variables and objects.
00:01:58.576 - 00:02:25.720, Speaker A: Let's start by defining constant. This will contain three keys, our project id, our client key, and our app id. Before we define those in here, quickly head over to the particle dashboard and create these keys. Alright, so as you can see here, I'm now in the particle dashboard. I can click on add new project and I'll name this a demo, then click save in here I'll need to create an application in my case, of course I'm building a web app so I can select web, I can name the application. In this case I can just do demo app. And then in here I can throw in the domain in which this web app will be hosted and then I can click ok.
00:02:25.720 - 00:02:56.520, Speaker A: From here I'll need to copy the project id, the client key as well as the app id. Now I can take all those values and throw them into environment variables. With those created and set, we can now define our config object. We can start with project id and set that equal to process dot env, dot react app project id that's my environment variable for my project id. We can also do client key as well as app id. Okay, so now with our config created, we'll need to use it in two different objects. We can start with particle be our master object for particle auth that will contain all of our configurations.
00:02:56.520 - 00:03:20.086, Speaker A: So we can do new particle network. Then we can pass in config. And then of course we'll need to set the chain name to ethereum goerly dot name. Similarly we can do the chain id which will be ethereum goerly id. I also want to do some initial configuration of the wallet popup. I can do this in a parameter called wallet and set that equal to an object that contains display wallet entry as true. And I'll also want to set the UI mode to dark.
00:03:20.086 - 00:03:47.342, Speaker A: All right, so now we have our sort of master particle object created. We'll now need to move on to creating our smart account object. We can call this smart account and very simply set it equal to new smart account and then pass a new particle provider which takes particle auth. And then in here, similar to the particle object we can pass in the config. And then we'll need to define a second config called network config. So we can open up network config and open an array. And then in here, because we'll only be interacting with go early and keep this to just one object that contains two different parameters.
00:03:47.342 - 00:04:14.062, Speaker A: These parameters will be dapp API key, which we can set equal to our bikonomykey as well as the chain id of ethereum go early. But before we move on, let's quickly go and create our bikonomykey using the environment variable here. All right, so as you can see, I'm now on the biconomy dashboard. I'll start by clicking add your first paymaster. I can name this just something like demo video particle. This will of course be on the ethereum go early testnet and I'll set it equal to version one. Then we can click register before we grab this API key and throw it into our environment variable.
00:04:14.062 - 00:04:34.640, Speaker A: I want to first set up the gas tank. We'll be using this in the transaction later. We can start by clicking set up gas tank. Then I've connected with my wallet here and I'll click on set up gas tank. And to fund these gasless transactions I'm going to deposit some gorilla ethereum. In this case I'll deposit 50 gorilla ETH and all right, now the gas tank has around 50 ethernet which will be used to sponsor further transactions. Let's head back over to overview and copy that API key.
00:04:34.640 - 00:05:17.874, Speaker A: I'll throw that into the environment variable under react app economy key and we can move forward. So now we're going to initialize our primary mechanism of interacting with a smart account. Do this we're going to use the AARAP provider to create a custom provider on ethers. We can do this in a variable called customer provider set that equal to new ethers providers web3 provider and then pass in new AArApp provider which will take smartaccount as well as the type of transaction that we'll be facilitating. In this case, I can set send transaction mode to gasless and then for the network we can just pass in any alright, so now with our custom provider defined, we need to quickly set particle ERC 4337 to true. This will just very simply tell the wallet pop up in the bottom right corner to open our smart account by default. Alright, so now we're done with all of our general configuration, we can move on to creating the application itself.
00:05:17.874 - 00:05:56.716, Speaker A: We're going to do this in a variable called app and the entire application will be held within this single app component. To start, we'll need to set two global variables or states, the first of which will be user info and set user info, which we can set as use state and pass and no. Then the second will be ETH balance and set ETH balance, which we can also set as use state with null. So with those defined, we're going to quickly need to spin up a listener that automatically updates our ethereum balance anytime the user information updates. So for example, if I switch the social account that I'm logged into and the user information changes within this session, then we'll be able to detect that and update the balance accordingly. So we can do that by opening up use effect and then first checking if user info is defined. If it is, we can fetch ETH balance.
00:05:56.716 - 00:06:30.352, Speaker A: This is currently undefined, but we'll be defining that in just a moment and then we can pass in user info. All right, so now that we've set up a listener to automatically update our balance, let's move on to actually creating this fetch ETH balance function. This will be very simple, just three lines of code, the first of which will be defining address as await smartaccount get address. And then of course we can pull the balance with await custom provider getbalance and then address. Finally, with the balance pull, we can set that as the ethereum balance with set ETH balance and then calling ethers utils that formate ether and then pass in balance. This will convert balance from a way value to an ether value. All right, so now we're about halfway down.
00:06:30.352 - 00:06:59.698, Speaker A: We'll need to very quickly set the logic for handling the actual social login functionality within this demo app. We can save this in a variable called handle login, which will take one parameter called preferred auth type. Alright, so this will be super simple, just about two lines of code. Essentially we'll need to define a variable called user. We're going to use a one line conditional definition. The conditional in this case will be checking if particle dot auth dot is login returns as false. So if the user is not logged in, then we can do await particle dot auth dot login and set the preferred auth type.
00:06:59.698 - 00:07:26.728, Speaker A: Otherwise, if they are logged in, then we can just do particle auth dot, get userinfo and then we can call set user info and pass in user. We're defining user based on the condition of if somebody is already logged in or not, they aren't logged in. Then we call the login function with our preferred auth type passed in. And if they're already logged in then we just simply pull their user info. Let's now move on to actually executing the user operation. In this case we'll be sending 0.001 e to a dead burn address and we're going to do so in a way that's gasless and of course facilitated through a user operation.
00:07:26.728 - 00:07:54.824, Speaker A: So we can call this function execute user auth and we can start by defining the signer in a variable called signer. The signer in this case will be the owner address of the smart account. So to get this we can do custom provider getsigner. Then we can go ahead and build our transaction in an object called tx in which we can set two as this address here. This is just your traditional dead burn address as well as the value set equal to ethers utils parse ether in this case, like I mentioned, I want to send 0.001 so I'm just simply burning 0.001 ETH.
00:07:54.824 - 00:08:32.152, Speaker A: You can now go and send the transaction and save this in a variable called txresponse and call await signer dot send transaction and then pass in tx. Then we can wait for the receipt in a variable called tx receipt in which we can do await txresponse wait. Then we can just print out the transaction hash so it sets the entire function for creating our basic transaction and executing it in a way that's gasless and facilitated through a user operation is all done within three variable declarations. We can now move on to opening return. If you've watched these videos before, usually skip past this part. So let's go through the process of formatting everything and then I'll come back. Alright, so now we have everything structured and all of our functions mapped to actual buttons.
00:08:32.152 - 00:08:54.776, Speaker A: We're just creating two buttons, one for signing in with Google, one for signing in with Twitter. When those are clicked, we're passing in either Google or Twitter as a string, which is the preferred auth type to handle login. We're displaying the name of the user that's logged in and creating a button called execute user operation which is mapped to executeusero. So all we have left to do now is do export defaults and then app. Let's go ahead and run it and see if it works. So as you can see, looks like it all worked. We have all of these sign in buttons right here.
00:08:54.776 - 00:09:05.360, Speaker A: So let's give it a try. Let's go and sign with Google. And here I can select my Google account. Go ahead and choose this one. As you can see here, I'm all logged in. I have my Google accounts name right here. I have my balance in ETH and of course we have the execute user operation button right there.
00:09:05.360 - 00:09:20.670, Speaker A: Additionally, because we turned it on, we also have the particle pop up right here which is already set to my smart account. And of course this is on ethereum go early so I have about 100 go early ETH. So let's click on execute user operation and see if it works. We have this pop up here that we need to sign. So we click on confirm. All right, the transaction has been signed. Now it's being pushed through the network.
00:09:20.670 - 00:09:31.126, Speaker A: If you remember, in the code, we actually console logged the transaction hash. So let's take a look at the console here. Alright, cool. So we have the transaction hash right here and go ahead and copy it. And there we go. We have the transaction right here. You can see the transfer of 0.001
00:09:31.126 - 00:09:53.104, Speaker A: ETH from my smart account right here to the dead burn address right there. And as you can see, for this transaction I paid no gas fees and that entire application is built in under 100 lines of code. As usual, the repository containing all of the code covered in this video will be available within 24 hours after posting. If you'd like to learn more about particle network, I'll have the introduction to particle video linked below. And if you'd like to get hands on and play with some of our web demos, I'll also have that linked below.
