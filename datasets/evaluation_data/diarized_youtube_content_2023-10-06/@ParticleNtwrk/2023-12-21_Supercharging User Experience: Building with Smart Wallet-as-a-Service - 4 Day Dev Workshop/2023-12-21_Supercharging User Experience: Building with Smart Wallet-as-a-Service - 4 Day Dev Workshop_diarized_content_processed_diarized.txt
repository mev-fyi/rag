00:00:00.160 - 00:00:45.300, Speaker A: So like I mentioned, basically the workshop that I'm going through today is actually a part of a series being ran by another Deverell in the industry. And it's kind of a group of deverells that are coming together and doing this sort of four day, almost like workshop marathon between a bunch of different, you know, organizations where basically we're all running workshops. I think it's like three a day for the next four days up until Thursday. And today I'm participating basically by doing a workshop on building with smart walls as a surface. So building applications that leverage, while it's a service that basically uses account abstraction to sort of supercharge the user experience of your application, increase flexibility, fun stuff like that. So basically, the ability to create applications that feel the best way to usually use is web two adjacent. So this is what we're gonna go through today.
00:00:45.300 - 00:01:24.066, Speaker A: We're basically gonna go through two halves of this. The first will be basically defining what smart wallet service actually is. What is smart wallet service? How does it work? Why is it important? What does it enable? Then from there we're going to go through an actual code example. So we're going to go through a demo that I'll be making or that I have made and walk through the integration process and what it looks like programmatically, so that as a developer, maybe you can get a better idea of what we're working with here in terms of a tech stack and what the SDKs look like. So pretty cool. Like I mentioned, we're going to aim for about 30 to 45 minutes, kind of the full 101, what smartwatch is and how you can start building with it. So some cool things to get going here.
00:01:24.066 - 00:01:58.898, Speaker A: I have limited room on my screen, so I'm going to close this out now. We're going to kind of go through the slide deck here. And what I want to start with basically is, like I mentioned, describing and running through what smart walls of service actually is as a technology. So first of all, quick intro if you're watching this, and of course you can see my twitter, but my real name is Ethan, of course, so I go by the alias Tabasco. I do develop relations at particle. I've been doing developer relations with web3 for about a little bit over two years now, I think previously I was at a company called Chainstock. I webparticlenow for, I think around five months.
00:01:58.898 - 00:02:44.634, Speaker A: It's been a ton of fun. We have a ton of cool things coming out in that next few months. And a lot has happened over the past few months. So I'm excited to share with you guys today basically a lot of what we've been working on, especially since I joined, which is honing in on this idea of smart walls of service. I think what works first to kind of give you guys some context, both that are of course, here live and watching back to the recording, I think it's important to first start by defining what walls of surfaces. This is a relatively new idea in the web3 space, where basically for a long time, traditionally as an ecosystem, we used browser based and extension based wallets to interact with web3. Or sometimes if you're on mobile, then you'll use an application like trust wallet or something like that.
00:02:44.634 - 00:03:48.794, Speaker A: But in general, for a long time, we used extensions and we use fully self custodial wallets, like metamask and rainbow and stuff like that, or even like Trustwallet on the mobile side. And these are great, these have a lot of features, they're strong and they work really well. They're good at what they do. But a big issue that came up after using these for so long as an ecosystem, is that our goal collectively is sort of to onboard this mass amount of users, to onboard a significant number of primarily consumers to start using the products in web3 and sort of start using what we've been building for so long and actually bring capital into the space and kind of create the next generation of the Internet almost. So to achieve this, we have sort of fallen short on one major component of web3, which is actually the onboarding side. Because at the moment, or traditionally, when you're using these extension based wallets, when you're using things like metamask and whatnot, these require you to do a few things that are barriers to entry. The first is actually manage your own private key.
00:03:48.794 - 00:04:27.928, Speaker A: So with these traditional wallets, as a user, you need to basically not only generate your own private key, but keep it secure. So this is kind of a problem. And the kind of duct tape solution for this was seed phrases which make saving private keys more accessible because you can write down, you know, 1224 words and that's your representation of the private key. Although this is still friction. I mean, as a user, you can't expect going to your next door neighbor and saying, hey, you know, here, sign up for a wallet. But to do so, you need to write down these twelve or 24 words and keep it safe. And if anybody gets it, then you lose all your money.
00:04:27.928 - 00:04:59.372, Speaker A: And I mean, the list goes on of points of friction when it comes to general consumers. I think traditional wallets are great for most people, especially heavy web3 users. But wallets of service is basically an answer to the need to have some sort of mechanism of onboarding that services consumers or people that aren't familiar with web3 already. This is the point of wallets of service. This is something that we've been building towards and trying to build our core product around for quite some time. Basically, we have two kind of flagship products that fit into this. The first is particle auth.
00:04:59.372 - 00:05:45.222, Speaker A: This is our mechanism that leverages MPC tss to basically onboard people through their social accounts. So through their Twitter, Google, email, phone number, etcetera. And then this also typically goes hand in hand with particle connect, which is our in house connection model for doing things like facilitating connection with metamask and Walt Connect and whatnot. But of course, we're also compatible with Rainbowkit and, you know, individual buttons and so on. So basically, our two kind of pillars of this wallet service product is web two authentication with particle auth, and sort of collectivized web3 authentication with particle connect. Particle connect is very similar to Rainbowkit, if that's probably the best reference point for that. This uses a mechanism called MPCTSs, which I won't get into too much today.
00:05:45.222 - 00:06:27.644, Speaker A: It's pretty complicated, but. But basically we leverage this sort of key management mechanism that allows you to generate a wallet through your social login without having to like having to manage those private keys yourself. You don't have to write anything down on a piece of paper and keep it safe physically. You don't have to worry about the necessity of keeping those keys safe yourself, because basically they are secured using this mechanism called MPC tss. There are other wallet service providers out there that use alternative mechanisms, but we're quite confident in the security and the convenience of MPC tss. Additionally, of course, this has very closely in with account abstraction, which I will get into in a moment. But basically, of course on my side doing developer relations.
00:06:27.644 - 00:07:33.564, Speaker A: A big part of our focus in this is trying to create a sort of all in one developer flow. So a way of using what was a service that feels natural for developers, that one or two SDKs and very sort of like step by step cohesive mechanisms for getting started to create an application that's fully compatible with wall as a service. Because ultimately, the idea here is as a developer, we want you to be able to, in like ideally less than 50 lines of code, add full social login functionality and embedded wallet functionality within your application. This is pretty big. I mean, being able to effectively open up your application to general users in under 50 lines of code has some pretty big effects on the actual level of onboarding and usage that these applications see. So we really wanted to make sure that we could deliver on that goal of less than 50 lines and even fewer, in many cases like fewer than 30 sometimes to integrate walls of service, and of course even do things like manage a custom user interface. And we have various different APIs and SDKs across every platform you can imagine, pretty much.
00:07:33.564 - 00:08:53.048, Speaker A: And so far we've seen good success with this product, with applications like Apex Pro. This is a good example of a pretty solid, relatively widely known application that's integrated our wallet service. And they've done this in a way where basically you can, as you can see, log in with your social account, you're now into the application, you can use it however you want, even open up a wallet modal right there to manage your tokens, nfts, stuff like that. Basically the entire wallet experience and nothing more than like a one click onboarding flow with your, in this case your Google account, but with really any social login mechanism that you can imagine. So it's pretty cool. This is something that we've worked really hard on over the past, really like one year plus, and it's now in a state where we have had a lot of applications like apex integrate it, and it has transformed their onboarding flow into something that is accessible to general users. But what we kind of found is that this slide is taken from one of my previous talks on intents, but I felt it was relevant here in that increasingly, as we continue to work on wallet service, we find that wallet as a service, as a base product, is incomplete in a large capacity, because traditionally wallets of service onboards people to eoas, which works as a means of interaction.
00:08:53.048 - 00:09:57.554, Speaker A: But eoas are traditionally very rigid. They are very limited in what you can and can't do with them. They're not very, I mean, they aren't programmable at all. They're just like, you know, you have to kind of take very complicated routes to do things like SS transactions and so on. So the solution to this is, well, if we're creating a UX solution that's meant to onboard people and kind of supercharge user experience, eoas probably aren't the answer to that because of their intrinsic rigidity. So instead, what we can do is create something that we call smart walls of service, which basically, in simple terms, is taking this idea of walls of service and introducing a kind of abstraction natively to it to create kind of a more complete answer to the underlying UX problem of onboarding that wall as a service aims to provide a solution to. So I'm going to talk a little bit about what that entails, what combining account abstraction and bctss, or in this case wallets of service, actually brings to end users and changes in the onboarding flow.
00:09:57.554 - 00:10:53.644, Speaker A: This is something that I wanted to highlight, especially for developers. This really encapsulates the minimum number of lines of code that we can possibly fit into this to get full functionality. Every piece of code that you're seeing on screen right now is actually more than you need to get started. So it's very, very simple. It's pretty natural integration flow programmatically. But back to the point. The idea here is that basically, instead of having users use an EOA directly after social login, when you generate that EOA, which is of course secured by MPC TSS, then we actually directly assign any smart account implementation to that so simple account bikonomy, cyber connect, even what we're thinking about right now, like, you know, light accounts, stuff like that, safe, you know, some cool other account implementations.
00:10:53.644 - 00:11:39.234, Speaker A: But basically we assign a smart account implementation to this EOA that we generate with MPC TSS. Now we use this to then of course leverage account abstraction. So we can do things like gases transactions, batch transactions, I mean, anything you can imagine in the realms of account abstraction, even things like session keys. So the actual implementation flow programmatically is quite simple. As you can see, we're basically initiating social login here with either particle auth or particle auth core, which you may or may not be familiar with that we then initiate the smart account. We basically choose what implementation we want to use, and then we start using account abstraction, building user operations, setting them, creating session keys, retrieving the smart account address and so on. So there's some cool functionality there as well.
00:11:39.234 - 00:12:25.404, Speaker A: Okay, so before I kind of move on to the actual coding side and show you guys what that looks like, this is a graphic that kind of goes through our smart walls of service tech stack. So basically the idea here is that we try to be as modular as possible. So basically what we want to do is kind of create this foundation for leveraging account abstraction with walls of service. So you can of course, in this case you generate a wallet with particle auth. And I'm kind of referring to the wallet service flow specifically, but you generate a wallet with particle Auth secured by MPC TSs. And then that of course leverages our account structure SDK to assign a smart account implementation. In this case we have, for example, biconomy safe core zero dev cyber account.
00:12:25.404 - 00:13:14.204, Speaker A: But at the moment we support biconomy cyber account and simple account. And then you can do things like, you know, sponsored transactions. We even have our own in house bundler and Paymaster for managing that kind of thing. Then you construct user operations, you send them with any bundler, but by default that's our bundler. And now you've leveraged account abstraction. So it's actually pretty simple at its core, taking what was an incomplete solution with just the EOA based walls of service and introducing this natively to account abstraction to now onboard users, both into clicks, but also to accounts that are almost infinitely flexible. So you can basically do whatever you want with these accounts and kind of create custom logic in that sense, which significantly increases the onboarding potential and just what you can achieve in general with this product.
00:13:14.204 - 00:13:53.224, Speaker A: So let's see if I can refresh that. Looks like my Google Slide is messed up. We can skip that. It must have corrupted whenever I transferred the file, but this is basically the same slide as I had before. This is basically like a rundown of our account traction stack. Pretty simple. It's just we have this kind of idea of a native implementation and an external implementation in which if you use native implementation with our SDKs, then use our in house bundler, either by economy or our in house Paymaster, one of those three different smart accounts, as well as of course the signer being our wallets of service.
00:13:53.224 - 00:14:52.584, Speaker A: For an external implementation, you can use any kind of infrastructure that you want, Pimlico, alchemy, stackup, either spot whatever you want to use and of course any account implementation. And basically what you just do is use particle as the assigner in that case, and you can assign whatever you want and use any piece of infrastructure with that as well. So this is kind of like a preface to what I will be going over in a moment, which is the sort of level is of added programmatic complexity. The idea here is, like I mentioned, we want to basically have the integration within an existing application in as few lines of code as possible. We want this to be something that's easy to integrate, but also makes a pretty significant impact to the actual underlying flow of onboarding and utilization of an application. So in this case, I actually have this in under 90 lines of code where this entire demo application is made, I think in 87 lines of code, or something that includes the JSX and all of the imports and the definitions and stuff like that. So pretty cool.
00:14:52.584 - 00:15:19.930, Speaker A: Now I'm going to go through programmatic examples. So what the actual coding side of this looks like over the next 1015 minutes or so. But of course, if you want to learn a little bit more about what we're building here, have a Twitter with these QR codes. Or of course, my Twitter is, you know, I'm posting this on Twitter. So feel free to head over to my Twitter account, follow up particlenetwork, and check out our website. We have some cool stuff happening pretty soon, especially with new documentation, new websites and stuff like that. So keep an eye out on that.
00:15:19.930 - 00:15:41.950, Speaker A: But what I want to do now is quickly switch my screen here and see if it will let me do that. Give me one moment. I want to show you guys basically what the flow looks like here for the sort of actual coding side. So let me find the window here. Particle workshop demo. There we go. Now let me resize this a little bit.
00:15:41.950 - 00:15:55.518, Speaker A: One moment. Using obs on the fly. It's actually a cool application. I'm not opposed to obs, so. Cool. There we go. I can resize that a little bit.
00:15:55.518 - 00:16:28.684, Speaker A: We can move that right there. Cool. So this is an application that prepared specifically for this workshop today. Like I mentioned, the idea here is basically to create a demo and as you know, few lines of code as possible. And this is achieved in this case, I think, in maybe around 120 lines of code. I was a little bit kind of, I put a lot in this application, so it exceeds that limit a little bit. But the actual utilization here of account abstraction is achieved in basically like 30 lines of code between everything if this were to be an existing application.
00:16:28.684 - 00:16:55.034, Speaker A: So first, I want to show you what this actually looks like, what the application here with this demo. So log out here. Of course, I have the holiday colors within the corner here. I actually changed these colors based upon typically what partner we're doing the video with. But in this case, of course, we have the protocol network logo as well as our two buttons. Sign in with Google and sign up with Twitter or X. I guess I'm going to actually sign in with Google.
00:16:55.034 - 00:17:15.294, Speaker A: I'm going to select this Google account right here and see if that will go ahead and load me in. Oh, let me refresh that. It might, my streaming might be messed up. Let me try twitter here. My Internet is almost up because of the live stream. There we go. Perfect.
00:17:15.294 - 00:17:51.892, Speaker A: Cool. So I am now in this application. Let me actually send some gowerly ETH over here. That way I can show you guys what a transaction looks like, but as you can see, that is basically what the onboarding flow looks like. Pretty simple as you can see in terms of the actual Twitter onboarding and same thing with Google, it's about two clicks. So this is a pretty significant evolution over what we would typically see from something like a metamask or any other traditional wallet application. So let me send one go early ETH over here and that should come through in a moment.
00:17:51.892 - 00:18:28.878, Speaker A: But this is actually a smart account that I'm using that's tied directly to my twitter, so it's pretty cool. As you can see here, I'm on ethereum, go early. I have the simple account implementation. I have the address right here, which I'm currently sending a one ETH to, and that's pretty cool. So once I get that ETH, I'll show you what the user operation execution flow looks like. But as you can see, I have my twitter name, my balance in ETH, and this was all done. I basically went from having no account to signing with my Twitter account, assigning that to a smart account, and now being ready to start sending user operations in two clicks for the end user and less than 30 lines of code for the developer.
00:18:28.878 - 00:18:43.714, Speaker A: So pretty cool flow. We're pretty happy with that and how simple that is. So here is one ETH. My count, I'm not sure if this is gasless or not. It's not. So let me actually do this. Let's actually go and quickly make this transaction gasless.
00:18:43.714 - 00:19:13.684, Speaker A: So because this is on ethereum, go early, I can go ahead and pass this in right here and then reboot the application. We're going to make sure this user operation that I send through this application is indeed gasless and it's sponsored. So let's go ahead and click this button now and give this a try. So we have the message signature here. This is the user operation hash that I am now signing. I'll go and click on confirm and we will let that go through. It might take a moment.
00:19:13.684 - 00:19:37.588, Speaker A: We'll see a little pop up right here once it's complete. Go early is not the fastest chain in the world. I'm unfortunately still using go early, although I have a lot more sepolia ETH. But I tend to find myself back at go early, especially because, I don't know, it just feels a little bit easier to use sometimes. But I know it's being deprecated quite soon, so that's unfortunate. Let's see. I think we're still waiting for that transaction to go through.
00:19:37.588 - 00:19:56.504, Speaker A: It should also pop up here in the console once it has gone through. But in the meantime, we are waiting for that. There we go. It has already gone through. Cool. So that's the transaction has actually head over to go whirly ether scan and check out that transaction hash. As you can see, success.
00:19:56.504 - 00:20:13.542, Speaker A: We have 0.001 ETH sent to a debt address. In this case it's just a burn of some ETH. Pretty simple stuff. In this case, I think if I refresh I don't even need to. As you can see, I didn't pay any gas fees for that, so I sent 0.01 ETH and the gas was totally covered.
00:20:13.542 - 00:20:52.694, Speaker A: And as you saw live there, pretty much I implemented the gasless transaction component and I think it was not even one line of code. So just adding this object right here. So pretty cool flow to give you guys a quick insight into what the actual application here looks like and how it's structured. Basically what we're looking at here is this uses a part of our SDK called particle Auth core, which is basically sort of a lightweight implementation of particle auth that allows you to customize it really deeply. And the actual interface is embedded directly in the application, as you saw. So this is a pretty cool SDK that we actually just recently released. But as you can see here, what I'm doing is I'm basically configuring particle auth.
00:20:52.694 - 00:21:21.182, Speaker A: I'm throwing in the components from the particle dashboard, defining what smart account I want to use as well as the wallet options. So I'm kind of restricting these chains on the wallet to Ethereum. Go early, making sure that the wallet modal is visible. And then that is within our index file. This actually wraps our app component now within app. It's also quite simple. Basically what we're doing here is we're using three hooks, use Ethereum, use connect and use auth core.
00:21:21.182 - 00:22:16.084, Speaker A: This powers in this case the entire functionality of the application because basically we're just funneling all this actually like user operation construction and sending through ethers. So we're generating a custom EIP 1193 provider that we're using that within ethers here. As you can see within custom provider we're using smart account, which we defined up here again with all of our kind of like key values, as well as the smart account chosen as a simple account implementation. And then we set that as a gasless, actually Gaslit provider object where all the transactions sent to this provider will be sponsored if they are on testnet or if we have logic for that setup within our paymaster on the dashboard. Then we're setting one state for the balance fetching. We are retrieving the balance, quite simple. We're handling social login and basically one function call which is connect derived from the use connect hook up here.
00:22:16.084 - 00:23:00.084, Speaker A: Then we are executing a sample user operation, just a burn of 0.01 ETH to this data address right here, sending that transaction as you would with any other transaction on ethers. But in this case, because we are using a custom provider derived from a wrap provider, it's actually all routed through a user operation. So we're leveraging that smart account directly through ethers as if we were doing an EOA. Which means that like the idea here is if you're already using ethers or web3 js, then you can start using smart accounts derived from social login with nothing more than just generating a new provider object, which is a pretty cool idea. And that's basically what is done here. So you could remove all the smart account stuff and actually just switch to metamask and this would function the exact same way.
00:23:00.084 - 00:23:34.628, Speaker A: But you add an extra 20 or 30 lines of code to this, all of a sudden you're now using social logins and you're using gases transactions within an assigned smart account. So a pretty cool flow there as well. Then of course we are sending that user operation, waiting for the transaction hash, throwing it on screen, and then of course we're kind of formatting all this in some pretty complicated JSX, which is just logos and buttons and stuff like that. So it's a pretty cool flow. As you can see, this entire application is about 90 lines of code. If you remove the JSX, it's about 60. The index file itself is about 15 lines of code of configuration.
00:23:34.628 - 00:24:07.814, Speaker A: So in total it's a quite simple flow. It's like step one, configure. Step two, define your hooks. Step three, define the smart account, define your provider object, and now you've implemented the entire SDK. So this is kind of the idea that we're going for. We actually just published an article last week about the developer experience flow of our SDKs. And this article kind of dove into our underlying motivation behind why we value developer experience and why why it's important to have these sort of easy transaction flows.
00:24:07.814 - 00:24:43.462, Speaker A: So this example here kind of encapsulates our focus on that, in that we want to optimize for brevity. So we want it to be as fast as possible, we want it to be as easy to understand as possible, and we want all this to be achieved without actually sacrificing complexity or richness of integration. So this is really what we've been kind of striving for. And I think we've achieved this in a large capacity. As you can see within the application here, we're integrating all this without sacrificing the potential of customization whatnot. Which actually brings me to a cool point here. So let me open up my dashboard on particle here and show you.
00:24:43.462 - 00:25:15.544, Speaker A: I believe this should be here. If I go ahead and change this branding, I think actually let's go to the code here. Let's change this to remove the social type. So we can just do a general connection model here. We can reboot this and I'll show you what the customization aspect looks like, which I think is pretty cool as well. So let's log out here. Let's say we want to sign in with button and this will just throw a generic kind of a particle auth interface here.
00:25:15.544 - 00:25:38.204, Speaker A: So let's head back over here and let's start customizing this. So let's do background color to, I don't know, something that is easy to look at. Let's do kind of like that light pinkish red color. Whoops. Do that. And let's do keep the primary text color as black. Maybe we can do an accent color of.
00:25:38.204 - 00:26:04.834, Speaker A: I'm not a front end designer if you can't tell. Oh, there we go. I don't think that applied. Let's do actually keep that as white. Maybe I want to do like a red and green kind of configuration. Let's see if I can maybe set the primary button here to some kind of lighter green. Something like a sort of like pastel color.
00:26:04.834 - 00:26:33.870, Speaker A: I think it looks a little bit less Christmassy and more like a, like a watermelon or something. But yeah, this is, this is like an example of what it looks like. So like take my not good design here and go and publish that. And you can see what this actually looks like in the application here. So let's refresh this and see. It might take a moment to apply, but we published it so this should be applied soon because I am using this if I'm correct. Or maybe I need to.
00:26:33.870 - 00:26:57.082, Speaker A: Let's see, what am I? I'm not sure what project I'm using actually. Let me quickly head over to a different project. Make sure I'm using the right project id. One moment. Need to switch the project id. So let me quickly go back over here. 1 second before I wrap up here.
00:26:57.082 - 00:27:31.592, Speaker A: I do want to showcase? I do think it's important. So let's quickly highlight this and just open this up. Back up real quick while I am waiting to figure out the product id is basically how we manage. We actually assign implementations here based upon project id that you derive from the dashboard. So in this case, let me go ahead and grab the project id here. I do have to not show it because it's sensitive, but I can throw this into my environment variable here. Yes, it is different.
00:27:31.592 - 00:28:08.204, Speaker A: Let me throw that in there and see if I can apply this right here. Perfect. Okay, where is the app id? I think that works and it should be one moment. There we go. Okay, I can switch my screens again, change the window capture here. Protocol workshop demo okay, I can change the screen size, so I am using the correct project id. So let me check again.
00:28:08.204 - 00:28:57.040, Speaker A: It might not be configured correctly within this application, but I can check real quick to make sure. Basically, the idea then is that basically whenever you go to the dashboard or you can define this programmatically, of course, go back to the branding here. It looks like maybe I didn't save it correctly, but whenever you go back to the dashboard here, you can define this no code way or you don't need to actually define anything programmatically to do this customization. You can do it all in UI, you can save and publish it, and then you're good to go within your application. You can even get down to the specific border radius and the text on screen, the logos used and everything like that. It's pretty cool. And then you can even go into the verification modal and what the transaction confirmation looks like, and you can even change the email and the SMS that gets sent.
00:28:57.040 - 00:29:28.292, Speaker A: So overall, this is, I think, a pretty solid level of customization within auth core. You can even go deeper, you can customize the underlying UI and UX process. So that's pretty cool as well. We'll be getting too deep into that today because it can get a little bit complex. But this demo in general, this example of kind of building an application with particle is I think a pretty good representation of the initial flow of what the integration looks like. So in this case, 120 lines of code. We have a complete demo location ready to go from scratch to start using particle.
00:29:28.292 - 00:30:16.890, Speaker A: Actually, if you want to kind of start working with particle and build a demo like this yourself, what you can do is we have a ton of repositories that dive into basically this exact type of demo. So we have one for linear that was posted last week. We have one for Alchemy's account kit, tyco, PGN, Zksync and kind of the list goes on. Scroll combo x one session keys base and all of these follow the same idea, the same flow of basically we have the index file that we use here for configuration. Then we go into the app file and we kind of start using different hooks and having these three main functions which is fetch, balance, handle, login and execute user operation. Pretty simple flow. Overall, this is kind of what we've been working on.
00:30:16.890 - 00:30:32.610, Speaker A: And of course if you want to learn a little bit more then we have these videos. I post usually two or three videos a week. Diving into this exact concept. I have a ton that was posted over the past few weeks. Head over to my Twitter profile atobascoweb3. Check out some of those videos. We have a lot of them posted on our YouTube channel particlenetwork as well.
00:30:32.610 - 00:30:52.286, Speaker A: Follow our main Twitter account particlenetwork. We always have some cool stuff going on. We have a lot being released over the next few few weeks, few months even. A lot of stuff that I'm really excited about, some stuff that might even get announced this week. So keep an eye on what we're doing. If you want to of course start working with this yourself and you want to get some guidance. We have a pretty solid discord server.
00:30:52.286 - 00:31:19.826, Speaker A: I highly recommend heading over to it. You can find it linked on our website particle.net work. Other than that, this was a super solid first Twitter live stream workshop for me. Really appreciate this kind of, you know, four day workshop marathon being organized. Super cool concept and we might be doing more of these in the future. We're going to probably be doing some workshops over the next few weeks with some cool stuff that we have releasing and some cool announcements that we'll be making pretty soon.
00:31:19.826 - 00:31:37.938, Speaker A: So keep an eye on for that as well. Other than that, make sure to follow us. Head over to particle.net work and of course go to docs dot particle.net work if you want to learn how to get started. And also head over to my kind of GitHub here if you want to as well. Tabasco ATW to head over to some of those demo repositories too.
00:31:37.938 - 00:31:57.594, Speaker A: Other than that, I think that is about it. Thank you everybody for hopping in. We had some pretty good peaks, I think, 35 40 viewers, something like that. So good first implementation of a Twitter live stream for me at least. Other than that, definitely make sure to catch the videos posted this week and I believe that is about it. I think I'll go ahead and end it off.
