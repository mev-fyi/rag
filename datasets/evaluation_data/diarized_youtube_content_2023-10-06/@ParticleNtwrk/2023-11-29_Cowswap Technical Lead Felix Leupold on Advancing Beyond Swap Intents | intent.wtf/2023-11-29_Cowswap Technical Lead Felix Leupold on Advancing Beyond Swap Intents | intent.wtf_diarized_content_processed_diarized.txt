00:00:06.200 - 00:00:54.348, Speaker A: Yeah. So for the next speaker, we have Felix of council. Thank you very much. I'm here to basically expand on what converters talked about and take intents one level further, basically beyond kind of the use case that we see today, swap intents and how we achieve this with the introduction of a recent feature we've added as call books, maybe just to get everyone in the room on the same page. This event is called eventwgf. So probably everyone is here just saying, what the fuck are events? Intents. Intents are just fancy word for living, right? And well, of course this is not the case, but in a way, the whole hype around intents, I think started with limit swap orders.
00:00:54.348 - 00:01:40.198, Speaker A: Swap intents. And in a way, yeah, it was like the first, and probably still until today, the most strongest use case for where intents actually, and we had calprotocol, where I think in 2019 started to release the first version of an exchange that allows users to kind of trade in terms of intense abstract. So swap, limit orders. And I wanted to just quickly go back to what our thought process was at that time. Also then preparing for the actual design of clockwork, fully focused on intents and why we thought it made sense compared to users sending specific soft transactions into the mempool. When we launched, EIP 1.59 was not even a thing.
00:01:40.198 - 00:02:42.316, Speaker A: So the TLDR of the slide is just transaction management is very hard. And in 2020, 2021, this was even more true because you would have to decide what is the correct gas price to set. And gas prices were extremely volatile. And now if you have the 1509, you only have to really decide on the tip, which is much easier, because usually a one two, 3g way tip is sufficient. But even beyond just transaction management, if you're making a swap, one of the fundamental problems for you as a user is how do I get best execution? And that's actually a really, really tough problem for retail users to achieve, because, well, maybe prices are very volatile and blockchains operate in these discrete time intervals, blocks that happen. So let's unpack that a little bit. Prices are very volatile, which means that you see a price on the Uniswap UI, you click swap, but then 12 seconds later it ends up in actually being mined in the block and the price has changed because other people are trading the same asset at the same time.
00:02:42.316 - 00:03:40.916, Speaker A: So in order for you to make your trade go through, you actually have to tell the UI that. I find that the price moves against me with some certain slippage tolerance. Now, if you do that properly and trade a very volatile token instead of large slippage tolerance, you then open up yourself to nav extraction, where even if the price doesn't move against you, somebody that observes your now very less limit order can take it and basically manipulate the price. When you need to front run you, execute you at your slippage tolerance, at your limit price, and then back run you to risk free and atomically extract value. So then you might go ahead and say, okay, let me just set a very tight slippage tolerance. But even then you might not get test execution, just because if you're making a large trade likely that we don't want to execute that tray just on a single pool, you might want to route it and split it across many defi venues. And the optimal split and optimal route also depends on the state of the block.
00:03:40.916 - 00:04:40.872, Speaker A: So as time moves on, as the state changes the route that was optimal when you saw maybe the computation in power swap, or one inch if you're using a dead segregator, is no longer the optimal route when your trade actually gets executed. And this becomes even more of a problem if you are not security aware user and you're not using EOA for your major swaps, you're using a multi signature account like safe. You have multiple signers that you need to use in order to actually authorize that transaction. Then you'll have one point in time where you're proposing your trade transaction, and then another point in time where you've got all the signatures and your transaction will actually make it on chain. And that time difference again will make it very hard for you to get optimal execution because prices are volatile and change. And now if you're an institution and you have people around the globe that need to sign, your delay comes up to maybe a couple of hours. And if you're a DAo that actually goes through a vote, your delay might even be a couple of days.
00:04:40.872 - 00:06:17.800, Speaker A: Getting optimized execution is extremely tough. And the second drawback that we saw at the time was still true today, especially where the government is that retail users have to do all this complex stuff. But if they mess up, they have a pretty high cost, because if the transaction fails, they pay fast transaction costs that can, you know, in bull market times be $100 per transaction or achieving nothing. And back in the days we ran a study that actually showed 15% of Dex aggregator trades and more than 15 of Uniswap trades were failing at the time, causing a lot of harm and cost execution cost to the users. So what we basically built with cloud protocol was a delegated trade execution system, which is pretty much the definition of intents. Instead of the user explicitly saying how they want to achieve their trade by signing a transaction and giving it to the miner, asking them to go to uniswap that exact tray, the user on cloud protocol just signs a message saying I want to swap this asset for that asset, and hands that off to a professional third party, a solver like Enzo, and basically has that professional party optimize and handle all the complexities that we've seen on the previous slide. To summarize some of the advantages and disadvantages of this approach, of course the advantages barely outweigh the drawbacks, but basically by handing off just this abstract to a solver, the trader does not commit to a concrete execution path on chain.
00:06:17.800 - 00:06:59.286, Speaker A: I think that's the key part. That decision is put as late in the cycle as possible. Even within the twelve second block time, the solver can decide to just 100 milliseconds before the block gets picked by the proposer. Commit to what is the, the best execution path for this trade, in this route, in this block. And if the solver for mistake and the transaction reverted, they could go ahead and in the next block try again with different, or even in the same block, try multiple routes and make it so that the builder would only pick one of the many. And so we really have complete flexibility and deferred that optimal trade execution finding to the latest possible stage. For the trader.
00:06:59.286 - 00:07:46.938, Speaker A: The user experience advantage is that they only pay the fee if their trade actually goes through. They outsource the reversion risk to that professional party. And another really nice user experience benefit is that the way that they pay their network fee equivalent back to the solver can be in any token, it doesn't have to be in the native e currency, so you don't need to as a user, be stacked with some token that doesn't necessarily relate to the trades that you're doing. If you're selling some shitcoin, then you can also pay your network feed and shitcoin. There are a few drawbacks. This clicker is not working super well. But I think back in the day, one of the main drawbacks that we had was convincing integrations, users and people to actually switch to this new paradigm.
00:07:46.938 - 00:08:17.722, Speaker A: Just because people are conservative by nature and we've always signed transactions. Let's keep on signing transactions. With the rise of other intent based systems such as unisovaxed and one extrusion, we've kind of gotten to the point where now people see, okay, intents are the future. Let's move towards that way. But there's still a technical drawback that I'd like to mention around the gas costs for intents are slightly higher than, at least in most cases. Thank user. You executed that intent natively by themselves.
00:08:17.722 - 00:09:56.464, Speaker A: And that's mainly because we have to do an extra signature verification step in the smart contract that is basically executing the intent. And this is because in the traditional model, basically the fact that the user is okay with what's happening. As part of the general Ethereum based protocol transaction verification, we're looking at the EOA of the user and have they signed this transaction? Of course this happens in intent based systems as well, but there the message TX origin is the solver, and so we need to have an additional signature verification to actually make sure that the solver is doing something that the user was fine with. But we can actually overcome this drawback in the way that cloud protocol has evolved, implemented intents, which is not just executing intents individually by sequentially by one another, but actually enabling or opening what we call batch auctions to collect multiple trade intents, or the same block, putting them all together into a single batch, having a decentralized solver network to compete for the right to execute the batch, and then settling not just the single intent, but multiple trade intents in the same Ethereum transaction. And so batch auctions we have mainly, I guess, only advantages. The main advantage we get from not just executing intents individually, but in batches is that we can match people directly with one another here to peer. And that's why we have calling coincidence of ones cars.
00:09:56.464 - 00:10:31.124, Speaker A: That's where the name card protocol is coming from. It's basically if you want to sell an asset that I want to buy, and the asset that you are wanting to buy happens to be the asset that I also want to sell, then have a coincidence of wants. We want the exact opposite thing and can trade peer to peer. In this case, we don't have to pay a market maker or LP fee to the protocol that we would otherwise go to to trade. We don't have to pay price impact. We are moving the price up and back down again. So we overall get a structural price improvement that you're not getting on any other decentralized exchange protocols.
00:10:31.124 - 00:11:32.674, Speaker A: On top of that, cows make your trades fundamentally, because if you're kind of agreeing with the other person, okay, this is the price that we'll trade against one another, peer to peer, and you're not relying on any kind of publicly available liquidity source such as Uniswap, then there's nobody that can come in for you and snipe away the price that we saw was operating and come back after you to trade sandwich you. In a way, it doesn't matter. You're not depending on any of these sniper public liquidity sources. So the settlement can be first slot in the block, in the middle of the block, or at the end of the block. The execution doesn't matter. So, coincidence of once we fundamentally reduce the amount of entity that that you're exposing. But even if there's not a coincidence of one, just by the simple fact that you're handing off execution to the solvers, you're reducing the effective mev that you're likely going to expose as a retail user dramatically just because solvers are much more sophisticated.
00:11:32.674 - 00:12:31.584, Speaker A: The drawback that we saw on the previous slide, gas overhead is amortized by the fact that we can now put multiple intents into the same transaction so we can share the 20,000 gas that Ethereum charges for each transaction as a base fee. But also, if two swaps acts as the same uniswap pool, for instance, the cost for trading against the pool is amortized across swaps, making it more gas efficient. And then the last thing that batch auctions allow is we can impose additional fairness guarantees on the execution of swaps. And one of the fairness guarantees that cal protocol is that's very important to us is we want to have a uniform clearing price. If two people trade the same asset within the same block, there's no reason that they should be matched at different prices because blocks just get emitted at a single instant in time. There's no guarantee first come, first served. It's all kind of arbitrarily ordering by the proposal or blockbuilder.
00:12:31.584 - 00:13:15.484, Speaker A: So there's no good reason why people that end up trading the same same asset should be trading at a different price. Now, this is not possible in the traditional model, because every ethereum transaction kind of needs to be executed sequentially. So you cannot impose these uniform price pairing constraints on it. But in a batch, you can say that, well, if the intent is on the same token pair, it needs to be executed at the same. And this, again, in our mind fundamentally reduces any. Not just trying to evolve, users make less mistakes. But really, if there's just a single price per token per block, there's no way how a builder could rearrange or take advantage of buying an asset low and reselling it at a higher price of a new block because there's just one press.
00:13:15.484 - 00:14:46.754, Speaker A: And so we think that this is like one of the strongest positions and ways of how we can fundamentally reduce me beyond chain and make rent extraction protocols or infrastructure less harmful than maybe even less. One more kind of detail about how the batch option and cow protocol work is that we are not only looking at each token pair and seeing who wants to buy and sell on that exact token there, we actually aggregate all intents into a multi dimensional batch auction, which then allows us to also find coincidence of ones in multiple dimensions in what we call ring trades. So even if in this example, nobody is trading the exact buy and sell token of the other person, we can still pair up the four traders and execute them as what is called a rig trade. And this is particularly powerful on Ethereum today, because here we see two tokens involved are Dai and Eustace represent the same underlying asset, the US dollar. And then we're seeing this kind of cambrian explosion of tokens as fragmentation of liquidity, the same asset being represented with multiple underlying tokens, which makes it very hard to fragment. Liquidity is kind of bad for the user. And so by batching the entire aggregate demand and supply for all tokens into a single auction, we can re aggregate that fragmented liquidity and make it better for more efficient for fiber to train.
00:14:46.754 - 00:15:43.818, Speaker A: This was kind of a recap on what cloud protocol is, how we got into intents. Today I mainly want to talk about how we go beyond just swap intents and augment what the user can express to basically anything, any intent that we think people may have in order to look at hooks. It's extended, intense. Let's first look at the basic life of a power order and what happens in the system when it here. For simplicity, we just assume there's and so there's no goods and wants. Their execution happens with some on chain liquidity and is kick started by the solver. So the first thing that happens in our settlement contract is that we verify the signature of the trade intent, making sure that the user is actually willing to make the swap that the solver proposes or says they would.
00:15:43.818 - 00:16:40.440, Speaker A: We then transfer in the sell tokens so that we have something to work with, something to convert into the buy token. The solver then has with their initiation of the settlement, also provided us with, call it a recipe of how the trade should be executed on chain. A list of on chain interactions, DeFi protocols, private market makers, things to fall into to convert the sell token into the by token. Those interactions are executed and eventually the buy tokens are transferred out to the user and the trades. Now, if we look at a hooked cow order, it's pretty much exactly the same. We're still making a swap, but we allow the user now to specify arbitrary interactions, if you will, before and after the settlement is executed. So the very first thing we do is we call a bunch of user specified prehooks.
00:16:40.440 - 00:17:35.659, Speaker A: I go into the next slide show exactly how the flow of a prehook works, but the idea there is that the prehook can enable the swap. It could pull in funds from some defi protocol where you have mistake. It could set an allowance that is needed to make a swap happen. Basically, anything that needs to happen before your swap can go through, you can specify in a quick and then similarly, if you want to clean up after yourself after the trade, you want to use the proceed, bridge them over to some other chain or put them into some staking protocol. You can do that in a post. So before and after your trade, you can now do arbitrary clause, which looks the intent expression language that comparable supports to a new. Just the way that concretely all the hooks flow is a little bit technical, but basically the settlement contract holds a bunch of state and allowances.
00:17:35.659 - 00:18:30.276, Speaker A: So we don't want users to kind of execute their hooks in the context of the COVID settlement contract. That is only up for solvers who who are posting a bond and are stashed or something racist happens. We don't want traders to have to post a bond in order to use cover calls. So what we do is we first switch the caller contracts just call into a very dumb multi cent contract that we call the trampoline, which has no allowance, no state. And then that contract calls into your target hook just to make it clean and secure. If you're wondering how you as a developer or tech savvy user, can specify a hook within your car protocol order, it's actually quite simple. If you've ever signed a car order with Metamask, you might have come across this appdata field, which looks like a very gibberish 32 bytes string.
00:18:30.276 - 00:19:20.884, Speaker A: What it actually is, is a pointer to a file that is hosted on ipfs, and that file can have arbitrary metadata about your swap intent. And so what we've added are these fields hooks. It's a list of pre and a list of post hooks, which the user can specify the target contract, the call data and the gas limit, and then upload the file with the hooks for their order up to ipfs, which would give them an IPFS hash. And if they specify that hash with the app data that they sign. Also to authorize the hooks, the protocol will automatically pick them up and then execute. So it's quite simple, quite nice to add docs to your trades. And we have also a full step by step ethers J's tutorial on our docs curve page and walk you through how to add a bit to a transaction.
00:19:20.884 - 00:20:32.574, Speaker A: Now I want to go through a few use cases for hooks. How can they be useful in practice, some of which we already implemented on the pre hook side? One way we can use generally to prepare your trade one specific edge case for intent based systems is when people trying to trade the native asset on Ethereum, which is not really possible through intents today because you need for intents generally you need to allow the solver to kind of work with the funds on your behalf. And since ether is the native token, you cannot really set an allowance for it. You cannot allows somebody to pull out ether from your contract and therefore usually you have to wrap it into the ERC 20 version which is wrapped ether for any trade as possible. Now this used to make it a very annoying three step process to trade ether, but we've recently kind of deployed a native ease flow which allows users to wrap natively before the trade happens. And that is one of the examples where previously the second example is another step that you need to be done before you trade. We executed setting an allowance.
00:20:32.574 - 00:21:24.680, Speaker A: It's the second step that you set before you can swap. And there are some more moderate years of 20 tokens that allow setting allowances via permit signature. And those permit signatures can also be executed as part of a preview. So now on password specifically you can go and for example have an account that has no ether just gets funded with UCC. You sign a permit for the UCC, you sign a swap for the USCC, and protocol will completely guess this, convert that into some other token you might care about, or even bridge it to another chain where you have your main kind of defi activity. Third use case which is not yet implemented. We are sponsoring a grant at the hackathon this week, so if you're interested in building, talk to me afterwards.
00:21:24.680 - 00:22:17.094, Speaker A: We were super happy to see people build more stuff on top of carbox, but one idea here would be to enable a trade by for instance unstaking an NP position or something else. Maybe withdrawing from a maker position or unwinding a loan in some way that basically is a prerequisite for your trade to go through. The last idea here is even more technical and a bit more exotic. This would be to deploy the smart contract that is making the trade just in time. So you could theoretically have an empty address. It looks like an empty address before the settlement contract, before the settlement goes to. And in the pre hook, you're kind of just in time deploying the safe that is going to be at that address, and that implements like some programmatic order, which could be a TWAP order or a stop loss order, something else.
00:22:17.094 - 00:23:06.194, Speaker A: Again, very technical. We can talk about it in more detail, but I just wanted to show you that the use cases for somewhat endless. On the postdoc side, I think the most common one is bridging assets after you've traded onto another chain. This has been prototyped by the Polygon team able to bridge to any other chain. And another example would be to restake your LP tokens. For instance, if you want to farm with some yield and go back into the LP position and then restate it, you could do that as opposed to, as well. So yeah, just to summarize, what do hooks allow you? They allow to connect your swap intents with anything else you might want to do before or after you trade.
00:23:06.194 - 00:23:37.902, Speaker A: There's a few gotchas, I don't know how much time I have. They're also somewhat technical, so I might just go through them very quickly. One is about the caller context trampoline contract that we talked about. Just keep in mind that if, for instance, the trader is in the UA, you might need some form of account extraction to actually allow that trampoline context to do something on behalf of the trader. You should be careful to not leave any balances or allowances on this trampoline. I think right now there's about $30. Somebody left dollar 30 in the trampoline contract.
00:23:37.902 - 00:24:15.370, Speaker A: So if somebody wants some lunch money, go ahead and take it out. If you're building a hook, make sure to not leave anything behind. There's some limitations as to what you can do with hooks. We had some people asking, okay, take out a flash loan and then use that proceeds to trade and then pay it back afterwards. This unfortunately is not possible because we have to kind of yield back to the settlement contract to do the trade before we can execute the post hook. Again, kind of technical. And the last thing is maybe more grasp, easy to grasp is that every hook specified the gas limit that is to use.
00:24:15.370 - 00:24:50.462, Speaker A: And this gas limit is also converted into the cell token and charged as a network fee from the user. And so if you're developing hooks, just make sure that that gas limit is well estimated. If you overestimate it, then the user may pay to match. If you underestimate made it, the hook may run out of gas and not execute. But generally it's fairly simple to build and we're hoping that we can get some people excited to build on this this weekend. Even Dan Robinson from Paradigm is super excited and wants to see what people are building on hooks. I think unfortunately, he was talking with four hooks here.
00:24:50.462 - 00:24:57.414, Speaker A: But you don't need to wait for your new four hooks because car sale hooks are already live in production and you can start building on them today. Thank you.
