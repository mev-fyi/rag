00:00:00.280 - 00:00:35.661, Speaker A: In just 12 minutes, let's explore Mantle Network and build a demo application that leverages Particle's Smart Wallet service to supercharge user experience. So recently I've been doing a lot of research into Mantle Network. This is because Mantle is sort of considered as a hyperscaling solution. This is derived from the fact that Mantle is a optimistic Ethereum roll up that leverages Eigenda and thus has really low fees and extremely fast transactions. And it achieves this while retaining a very high degree of security inherited directly from Ethereum. So really strong UX stemming from powerful fundamentals paired with solid security. And it was a natural decision for us to expand our Smart Wallet as a service natively to Mantle just a few months ago.
00:00:35.661 - 00:00:47.469, Speaker A: This means that you can build applications that leverage Mantle's intrinsic performance alongside our smart walls of service to create consumer ready applications that feel fast and accessible and in this case almost infinitely flexible due to the utilization of account abstraction.
00:00:47.517 - 00:00:48.421, Speaker B: So today I want to dive into.
00:00:48.453 - 00:00:56.381, Speaker A: This a little bit further and in just 12 minutes walk through the process of building a demo application that onboards a user into Mantle through their social login, then assigns a smart account and.
00:00:56.413 - 00:01:22.005, Speaker B: Sends a completely gasless transaction. So a get started. So as you can see, I've spun up a pretty basic react application template because we're going to be filling in both Index tsx and App tsx to basically create an application that first of all onboards a user through their social account. In this case we're going to do either Google or Twitter and it'll automatically assign them a smart account implementation. For this example, we'll be using simple account and then it uses that smart account to send a gasless transaction natively on Mantle, but specifically in this example, Mantle testnet.
00:01:22.045 - 00:01:23.421, Speaker A: So to begin doing this, navigate over.
00:01:23.453 - 00:01:54.545, Speaker B: To your index tsx file or index ts depending on your application structure. And let's get started by importing a few different required libraries. The first of course will be React. We can also import React DOM along with Mantle test nets from App Particle Dash Network slash chains. Then also from Particle, we can go ahead and import auth core context provider. That'll be from App, Particle Network, slash off or modal and then we can close it off just by importing our main app component from Slash App. Of course that component isn't currently built out, but we'll be building it in just a moment.
00:01:54.545 - 00:02:28.621, Speaker B: First here with an index, we need to basically configure Particle network. This will be done through auth core context provide, which we'll use to wrap our app file and establish some base configuration for ParticleAuth, which is the SDK that drives social login. So let's go ahead and open up React DOM and do Create root. Now within create root, we can pass document, get element by id, which will take root, and then we can cast that to type HTML element, then execute Render. Now, within Render, let's start by opening up a react strict mode tag. And in here we can establish the important component which is Auth Core Context Provider. Within Auth Core Context Provider, we can establish options.
00:02:28.621 - 00:02:51.871, Speaker B: And Options will contain all the configurations that I mentioned earlier. Of these configurations, only three are required. This is your Project id, your client key, and your App id. For every usage of Particle, whether it's Particle Auth or Particle Connect, or even just the account abstraction SDK by itself, you need to use these key values to initialize the SDK. So to retrieve these, head over to the Particle Dashboard and create a project. All right, so as you can see, I am now on the Particle Dashboard, that's Dashboard, Particle Network.
00:02:51.943 - 00:02:52.927, Speaker A: And in here I'll go ahead and.
00:02:52.951 - 00:03:24.771, Speaker B: Create a new project. I'll name this Mantle Demo and click Save. We're now on the primary Particle Dashboard and of course we can configure the look, the customization, we can even fund the Pay Master, open our bundler, manage RPC endpoints, and so on. But in this case, I want to focus on the Applications menu here to, of course, like I mentioned before, retrieve these three required values. Now we have the Product ID and the client key, but we still need the App ID to retrieve this. Let's go ahead and create an application for this example that will be a web app and I'll again name this Mantle Demo. And then within Domain, I'm going to throw in the URL in which I'm hosting this application.
00:03:24.771 - 00:03:53.425, Speaker B: Although of course, if you're doing this in Local host, it says it's required, but you don't need to use the actual domain. You can throw in any filler domain here and it'll still work. Let's now go and click on ok, and there we go. Let's copy the Product id, the client key and the App id. Now we can throw those into environment variables within our application and continue. So let's first define the Project ID as Process env, React, App, Project id, the same thing for the client key along with the App id. Now that we have those defined, we now need to configure two different main options.
00:03:53.425 - 00:04:19.469, Speaker B: This will be ERC437 and the wallet options. Let's start with ERC437, which will be our account abstraction options, basically determining what type of account we display within the Wallet model. So we can set this up with ERC437, that'll be an object. And within this we can set name to simple along with version 21.0. This will display the simple kind implementation that I mentioned earlier within the Wallet interface. Let's now go ahead and define Wallet. And we want to set visible to true.
00:04:19.469 - 00:04:46.265, Speaker B: This will ensure that the Wallet modal, the little particle logo in the bottom corner of the application, pops up upon login. This acts as a mechanism for users to control their wallet, although it's optional, if you want to set this to false, then feel free. But because we're setting it to true, let's also define custom style and restrict the chain within support chains to mantle Test and perfect. Let's go and close this off by throwing in our app component. And there we go. We've imported all of our base libraries and configured authcore Context Provider to initialize the SDK. So let's now move on to our app tsx file.
00:04:46.265 - 00:05:20.343, Speaker B: This file will essentially control and define all of the primary functionalities within the application itself. And in this example, it'll only be around 90 lines of code. So let's get started again by importing some base libraries such as React along with Use State and Use Effect. We can also import our required hooks from Particle auth that'll be use Ethereum, use Connect and use auth core. That'll be from app particle-network/auth core mode. We can once again import Mantle TestNet from app Particle Dash Network slash chains. Then on the account abstraction side, we can import a wrap provider send transaction mode and smart account.
00:05:20.343 - 00:05:42.395, Speaker B: And this will be from app Particle network slash A. Then finally, we can also import ethers along with notification from anti. Then you close it off, we can import our css. All right, perfect. So let's now move on to establishing our primary app component. We can define this as app and open it up right here. To begin, we'll need to initialize the different hooks that we just imported and segment them into functions that we'll be using within our application.
00:05:42.395 - 00:06:13.649, Speaker B: We can start with Provider as use Ethereum along with Connect and disconnect from use Connect. Then finally, we can throw in user info as use auth core. Additionally, let's quickly define one state that'll be balance and set balance as use state. This will, in a moment allow us to Reflect the account balance on the front end. All right, so now with all of our hooks established and our state defined, let's move on to establishing our Smart Account object that will essentially act as the master variable for the account abstraction component of this application. That will essentially act as the master variable for the account abstraction component of this application. It's called a Smart Account.
00:06:13.649 - 00:06:48.197, Speaker B: That'll be new Smart Account, then Provider. Then we can open it up here. Within Smart Account, we'll need to once again define the three key required values as Project id, Client Key and App id. Then essentially Particle uses a modular account abstraction framework, meaning that we let developers choose what specific Smart Account implementation they'd like their users to use. Currently we support either Biconomy, Cyber Connect or Simple Account. For this application, we'll be using Simple Account. So we can open up a Options and define simple, then set chain ID to mantle testnet ID and version 21.0.
00:06:48.197 - 00:07:38.007, Speaker B: Now we want to use this Smart Account object within the construction of a custom ETHERS provider. This will allow us to build a pretty standard application leveraging native functions of ethers, but route everything through the Smart account so transactions become user operations and the signer becomes the Smart account itself. So let's do this within Custom Provider and set that equal to new ethers.providers.web 3 provider which will take new a wrap provider which itself we can pass Smart Account along with Send Transaction mode gasless. By passing in Send transaction mode gasless, we're basically telling the SDK to route all transactions that we send through this ETHERS provider as gasless transactions, or at least throw them through the condition that we set within the Particle dashboard to potentially qualify as gasless. Because we're on a testnet, all transactions that we send through this format will be automatically sponsored free of charge. So by establishing this, the transaction that we send in a moment will be completely gasless.
00:07:38.007 - 00:08:09.515, Speaker B: Then to close it off, we can also throw in any okay, so now let's start by building out our three main functions. This will be Fetch balance, Handle login and execute userop. Let's begin with the logic behind fetching the balance and displaying it within the front end. Let's start by opening up a use effect and check the condition of user info, basically determining if user info is defined or not, or in official terms, truthy or falsy. If user info is defined, meaning a user has logged in, then we can go and call fetch balance. Now we'll be defining this in a moment. Then we also want to make this use effect Dependent upon the status of user info.
00:08:09.515 - 00:08:37.253, Speaker B: Okay, so now let's write the fetch balance function. This will be fetch balance and it'll be asynchronous. So we can write this function in basically just three lines of code. To start, let's pull the address with await smart account dot get address. Then let's pull the balance of that address within balance response through await custom provider dot get balance and then address. Now finally we can set the balance state with set balance. Although balance response is going to by default be a way value that isn't very human readable.
00:08:37.253 - 00:09:00.555, Speaker B: So let's convert that way value into an ether value through ethers.utils. format ether and then throw in balance response. Perfect. So that's all of our balance fetching logic done. Let's now move on to defining the logic behind the social login functionality. So basically how we're going to facilitate account creation through a user social account, let's call this handle login and it'll take one parameter called auth type. Now within here it'll be quite simple.
00:09:00.555 - 00:09:34.579, Speaker B: We want to start by again checking the condition of user info. Although in this case we want to check if user info is not defined. So if it's actually a falsely value indicating that a user has not logged in, then we want to call await connect and pass in social type as auth type and the chain as mantle testnet. So then upon calling handle login, we're checking if the user has not logged in. If they haven't, then we're using the connect function to initiate social login to initiate social login within the specific authentication type defined within handle login. Alright, so let's now build our final function. This will be Execute user op and the goal of this function will be to send a sample transaction.
00:09:34.579 - 00:09:59.719, Speaker B: For this example we can just burn one mnt. So to do this, let's first start by retrieving the signer within signer. That'll be custom, provider, get signer. Then we can go ahead and construct our transaction within TX and this will just contain two different parameters. The first will just simply be two, and that'll be this address right here. This is basically how we burn the tokens by sending them directly to this address. Let's also throw the value as ethers, utils, parse ether and then one.
00:09:59.719 - 00:10:35.421, Speaker B: Okay, so we can now send that transaction within tx response through await signer.send transaction and passing in the tx object that we just made, let's also pull the transaction hash of that transaction through TX receipt Which will just be await TX response. Wait. Now we can push a notification success that uses TX receipt within message as TX receipt transaction hash. And there we go. At this point we've imported all our base libraries, defined our hooks, configured our smart account, fetched the account's balance handle social login and executed a sample transaction. Let's now structure all of this within our JSX through a return statement.
00:10:35.421 - 00:10:56.317, Speaker B: Although within these videos I actually skipped this part because it can take quite a while and be a little bit repetitive. So I'm going to go ahead and get this written and then come back. All right, so there we go. Basically what we're doing here is just again checking the condition of user info if user info is not defined. So if a user has not logged in just yet, then we show them the two login buttons. Either sign in with Google or sign in with X. These buttons are of course mapped to handle login.
00:10:56.317 - 00:11:18.841, Speaker B: Then once a user has logged in, then we display their name, their balance and MNT as well as two buttons, Execute user operation and log out. Logout is just simply mapped to disconnect, which we defined up here. All right, so let's now go ahead and close this off through export, default and then app. And we're now ready to go ahead and run the application and see if it works. All right, and there we go. Looks like it worked. We have our two buttons, Sign in with Google and sign in with X.
00:11:18.841 - 00:11:37.761, Speaker B: Let's go ahead and sign in with Google and we have a standard Google login pop up right here. I'll go and click on this account. And there we go. You have my name, My Balance and MNT, which is 97.99. Our two buttons and of course the Particle Wallet pop up right here. As you can see within the wallet interface itself we have our balance. We can Even check our NFTs activity, some tools and so on.
00:11:37.761 - 00:11:55.163, Speaker B: Okay, so let's go and give this a try by clicking Execute User Operation. And we have the confirmation right here. I'll go ahead and click on confirm and almost instantly we have a transaction ready to go. So let's go and copy this and head over to the Explorer. And it was successful. And as you can see as well, my balance has now gone down by 1 MMT. But I paid no gas fees, so that transaction was completely gasless.
00:11:55.163 - 00:12:23.415, Speaker B: Mantle is a really powerful blockchain that's shockingly quick and cheap to use. Thus it makes perfect sense to build an application on Mantle leveraging consumer facing technology like Smart Wall as a service to create next generation web two adjacent applications. If you'd like to learn more about Particle Network and what we're building, including each component of our tech stack, like our Smart Wall as a service, our intent Fusion protocol, our confidential ZK stack, et cetera, then I'll have a full blog post covering that linked below. Otherwise, if you'd like to try the demo that we built today, or our primary web demo, then I'll also have both of those linked below.
