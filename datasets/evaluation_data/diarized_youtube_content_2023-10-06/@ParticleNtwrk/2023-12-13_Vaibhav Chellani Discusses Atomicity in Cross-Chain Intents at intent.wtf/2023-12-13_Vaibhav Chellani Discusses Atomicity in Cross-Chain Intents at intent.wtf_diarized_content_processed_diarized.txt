00:00:08.280 - 00:00:39.680, Speaker A: Also available at socket, which is an interop protocol. And who here hates bridging? That likely includes me. So we got to fix that problem. And we've been working on it for quite some time. We haven't found the perfect solution yet. Maybe this is it. But in that journey we've come across some very interesting problems, which I think don't kind of lead to intents directly, but in a more kind of tangential way.
00:00:39.680 - 00:01:15.668, Speaker A: So I'm not here kind of like talking about socket, but more about these interesting problems. One of them is like atomicity for cross chain intents, right? Cross chain is by default async. You don't have one chain, there is no one transaction. It's by default something that's executed across multiple chains. So whenever you are doing things on one chain, a transaction gives you this notion of atomicity. Unfortunately, in this option world, we don't have it. So what are intents? I think let's skip that completely.
00:01:15.668 - 00:01:35.484, Speaker A: It really doesn't matter. Everything is intended broadly. What's an intent? Life cycle. User wants to do an action. User signs some preferences along with that action. So let's say a user wants to do a swap. He says, I want to do it quickly.
00:01:35.484 - 00:02:27.224, Speaker A: Someone says I want the best price, so on and so forth, whatever the preference might be. And then there's a bunch of network, some off chain actors, some solvers who try to optimize that action for the end user, and they do it in the most dynamic sense as possible, which is like just around TX execution. You try to find the best part broadly, that's what's going on. Once that happens, the network fulfills the intent. And there's often a smart contract on the chain that kind of settles the interaction between the user that's signing the intent and the network or the solver that's fulfilling it. Usually it's a smart contract. And all of this happens atomically in a single DX, right? So this kind of like is in bold because that's, that's the problem, like cross check has.
00:02:27.224 - 00:03:12.420, Speaker A: But before I kind of get into it, like, what does atomic even mean? Right? What atomic really means is intents have two states, a failure state and a success state. Taking a quick example for like swap intents, the success cases, the user receives the minimum output that he asked for for the output. So if someone's doing an ETH USDC swap, the user probably defined like, I want a minimum of this much amount of USDC success cases, the user receives like at least the minimum. The failure case for, let's say a swap indent is the user is still holding the original amount of the input token. So the swap did not happen. So either the swap happens or the swap does not happen. There is no middle case.
00:03:12.420 - 00:03:51.754, Speaker A: Right. This is what I mean atomically. Now on a signal chain context, all of this happens atomically and synchronously. What that means is like all of this happens in a single TX. So it's atomic and synchronous, right. There's a very nice kind of mean there that kind of like shows that how this settlement is kind of like fulfilling the intent. Kind of like bridging the gap between the intent and the software now like quickly, kind of like talking about the real problem here, how do you handle like async intents? Yeah, this is why I love Istanbul.
00:03:51.754 - 00:04:26.702, Speaker A: I think like there are a good amount of use cases where we need like some sort of like async intent, right. Intents I don't think is the right kind of way to frame these kind of use cases. But again, I'm not going to define intents. A good amount of examples are bridging. There is always going to be some latency between a source TX and a destination TX whenever there is bridging involved. Now, we will try to make it as small as possible, but it's an async operation. Things are happening on multiple chains at the same time.
00:04:26.702 - 00:04:54.794, Speaker A: Some other quick examples of, let's say, async intents are DCA. Someone wants to buy 100 kw of USDC and they want to do it daily. So some small batches being executed daily. So by definition this intent is being executed over time. There are two arms, which is if someone wants to sell, let's say, 1000 ETH. Vitalik is finally dumping his bags. He put up a dwarm order and it will get executed over time in small chunks.
00:04:54.794 - 00:05:33.564, Speaker A: So these are some, let's say, good examples of async index. Now for today, since I'm from socket, I'll be talking about a specific async index, which is like bridging. So what's a typical bridging show today? A user deposits funds into a bridge contract and waits and prays for funds to be received on the destination. And this is completely fine, absolutely fine. This is how we are going to get the next billion dollar billion users on chain. The user has no delivery guarantee. The principal say it will take five minutes.
00:05:33.564 - 00:06:02.088, Speaker A: But we all know that's certainly not true. It's mostly an estimate. If it all goes well, you might get it in the next five minutes, the entire process is zero atomicity. The user has given funds and he has no guarantee if he get them or not. And they are just kind of like sitting there in limbo. So this is the current scenario. So what we really need to do is make things atomic.
00:06:02.088 - 00:06:49.490, Speaker A: What I mean by that is user needs stronger guarantees that if I start this bridging process, I'll be done in the next five minutes or I'll get my funds back. Things are, async intents have success and failure. But I think we probably need to introduce another state here, which is an in progress state for the Internet where funds are kind of deposited into a neutral escrow where they sit for the next five minutes. Now, this is the in progress date. The bridging guys can look at this and start fronting the user liquidity on the destination. Now, if it's now, if this is not done in the next five minutes, the user will get funds back from the escrow. If it's done in the next five minutes, the solver will get them on the source chain.
00:06:49.490 - 00:07:34.766, Speaker A: So kind of like moving this notion of atomicity from the transaction level, from the blockchain level to the app level still allows us to have atomicity, but in an asynchronous way. So I think what's really going to happen from here on is using protocols like socket, people will be able to kind of build atomic applications still. But these atomic applications will be, these atomic flows will be executed asynchronously instead of all of them happening in a single TX on the source chip. Right. Users will still have strong guarantees that things will get done in the next five minutes, but it's not going to be like success or fail. There will be a middle state, which is the in progress state. I mean, yeah, this is atomic ish.
00:07:34.766 - 00:08:08.254, Speaker A: I think this is pretty much it, guys. Kind of like trying to keep it short here. I think to kind of like settle these async intents, we kind of like move atomic guarantees to the app level. Now, these applications across chain are connected via something like socket that allows these applications to talk to each other. This way users get like some sort of like guarantees around execution of their intent. There's a success date, failure case, and in progress date, and the user will kind of be in the in progress date for a finite amount of time. Right.
00:08:08.254 - 00:08:41.164, Speaker A: So this is like a primitive that can be expanded to multiple blockchain applications, be it lending, borrowing, be it blockchain trading, be it bridging, whatever. And I think we are kind of like working on something like this. I'm happy to share Alpha post not, but if you have questions, there's a QR code, feel free to dm me. I think that's pretty much it. Thank you so much. Yes. Can you elaborate a bit on the escrow contract? Yeah.
00:08:41.164 - 00:08:57.730, Speaker A: What exactly? It is just a simple contract you put in USDC. It starts a ticker. It basically, let's say, starts a ticker towards the time. Let's say the time. 30 minutes. USDC comes in 30 minutes. Start.
00:08:57.730 - 00:09:48.126, Speaker A: Now, the bridge has to either complete it in 30 minutes or the other escrow contract will allow the user to take the funds back. This escrow contract is connected via something like socket, which kind of like, relays cross chain information across chains to let the escrow know if the transfer was done or not. So if the bridge is still happening over multiple blocks, how do you still do the intent atomically? The intent is still atomic ish in the sense, because at the end of 30 minutes, or like, whatever the time block is, the use, the bridging will either be done or not done. So this is. That's why I say it's like atomic ish. Kick off the bridge. But.
00:09:48.126 - 00:10:04.590, Speaker A: Exactly. Exactly, exactly. It's an easy process. That's exactly why this problem is very interesting. Sorry, go ahead. So for users to take money out of escrow, they have to make gas. Yeah, exactly.
00:10:04.590 - 00:10:17.654, Speaker A: Or you could have some key per anyone can, you know, kind of do it for you. Right. But there is another accident. That's. Yeah. Trying to say. I mean, in that case, you know, the user then can be.
00:10:17.654 - 00:10:43.218, Speaker A: You're like, yeah, there's a. There's a grieving attack there. Yeah, I'm just. No, no, you are absolutely right. So whenever, let's say, some sort of like, entity pulls funds from the user's eoa to the s two to kind of prevent this beefing attack, you kind of like, force the solver to put up, let's say, $20. Right. Some sort of like, finite amount of money so that, you know, this griefing attack gets kind of like solved for.
00:10:43.218 - 00:11:18.026, Speaker A: But, yeah, that's a good catch. You've kind of shifted the game here, the way that solvers are now going to take a lot more risk, because the solvers are going to have to settle on the second chain before they can even have the first chain. And the solvers will need to trust whether it's your network, I don't know if it's going to be centralized party at the beginning or like a validator. What are you thinking? Yeah, I think that's actually pretty right. Because, like, right now, the paradigm is the user is trusting the bridge. So, I mean, let's flip that equation, right? Let's. Let's.
00:11:18.026 - 00:11:56.122, Speaker A: Let's have the solver do. Let's have the solver deal with the uncertainty. Let's. Let's have these, like, solvers, which are the intelligent beings, kind of, like, determine, uh, determine, like, how much risk they want to take and, you know, like, what are the time logs that they're going to work with, so on and so forth. Right. The way socket is built, the message verification is agnostic, so solvers can decide what's the kind of risk they're willing to take, so they can come ahead and say, I will only work with an intent if it's willing to settle over, let's say, an optimistic verification model or a CK verification model, or even the native product. Right.
00:11:56.122 - 00:12:46.816, Speaker A: Solos can decide what's the kind of verification that they want to open themselves up to. But I think this is one of the really good side effects, where uncertainty moves from the user to the solver, and solvers can get paid for it, and users will gladly pay in order to get stronger delivery guarantees. Does this SMT cover also swap on the destination chain swap or in swap as well? Absolutely. So if someone wants to do. Someone wants to go from, like, shitcoin a to, let's say someone also breeds a shitcoin a do a destination chain. So what will happen is the software on the destination will, you know, let's say, come with USDC and dynamically, just. Just like, let's say how carswap one inch and all these protocols work.
00:12:46.816 - 00:13:10.344, Speaker A: Dynamically swap on the destination from their USDC, the shitcoin that the user wants. And when that happens, we send a message from destination resource that says, the shitcoin has been delivered. Right. So release the shitcoin. The escrow will release the shitcoin to the solver on the source chain, and they can swap it, and, you know, that. And the solver takes a five minute exposure to the shit coin. Exactly.
00:13:10.344 - 00:13:29.966, Speaker A: Edge funds. Yeah, I think. Yeah, I think the idea is, like, kind of, like, move complexity to these solvers and kind of, like, make lives for the end user. If that's all the questions. Thank you so much. I'll be there in the lobby. We can jump.
00:13:29.966 - 00:13:30.534, Speaker A: Thank you.
