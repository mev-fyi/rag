00:00:14.200 - 00:00:45.132, Speaker A: Okay, hello, party. So I know that this is the last talk of intent. WTF? And of course it's Thursday, so defconnect is also about to end. So hopefully I can leave you guys with something to think about here that won't be too boring. So specifically I want to talk about today is bringing intent centric to life. So throughout the event today, if you guys have been here for a little while, you've probably heard intent, that word too many times. But really, a lot of this is conceptual.
00:00:45.132 - 00:01:30.164, Speaker A: At protocol, what we want to do is create a generalized implementation of intents that is actually utilized on a large scale between different applications and of course in this case, sort of onboard consumers. So let's dive into here specifically. The way that we're doing this is through something called particle network v two, which is a collection of technologies that I'll define in a moment. But first of all, I think it's important to introduce particle network. Some of you guys might be familiar, of course, we're hosting this event today, but the kind of team cl dot is that basically what we do is we provide wallet service. This was our sort of core product offering for a very long time, but over a year. And essentially wallet service is a mechanism of onboarding.
00:01:30.164 - 00:02:25.932, Speaker A: Interaction with applications feels natural and seamless within its host application. So for example, you can imagine onboarding to some sort of Dex or something or game using your Google account or your email. This is kind of a big evolution of how we onboard people and of course facilitate interaction, in this case through embedded wallets. So a wallet experience isn't external, but rather internal to the actual application. So this is what we've been building at the moment, we have over 15 million activated wallets, over 800, like significant client partners that are leveraging this path of onboarding, specifically in this case for sort of web two users or people that might not be as web3 adjacent, as many of us are. So wallet as a service, as I just defined, is great. This is something that has been at the core of our business model for a long time.
00:02:25.932 - 00:03:05.554, Speaker A: But it's undeniable that wallet service has a number of pretty big issues. Most of these issues actually stem from the fact that they use eoas. Traditionally, this means that they're pretty rigid. You can't do a lot with wall of service, really because of the fact that once you log in with your social account within a given application, you're provided with an EOA. Developers don't have a lot of room to work with here. Now, with wallet as a service, you can extend the functionalities of EOA a little bit more through things like master passwords and payment passwords derive from key management mechanism. In our case it's called mpctss.
00:03:05.554 - 00:04:24.250, Speaker A: But still, traditionally eoas are incredibly binding and our solution to this is the integration of account abstraction, which I'll talk more about in a moment, but specifically in kind of the context of intents, a massive, massive issue of well, service that actually only solves one half of the UX problem. So UX problem is actually two distinct issues. First, one is the process of onboarding to the point of expression, right? So from when a user actually logs in with their social account, their Google email, Twitter, LinkedIn, GitHub, right, and now have a wallet they can use to express what they want to do this for a long time was a broken component of web3. Download venomous skin, generate the seed frames, write it down on a piece of paper, keep it safe, keep it secure yourself. This is not a good process and we fix this already account abstraction, specifically in our case facilitated through the means of wallet as a service. Now we can onboard somebody with their already existing web two accounts into a smart account that is flexible and works natively within the applications in which they're integrated. Although probably the more complicated part of this issue is where intents come in.
00:04:24.250 - 00:05:16.730, Speaker A: This is the process of expression to outcome. So once a user has been onboarded and they get to the point of expression, the issue now is, well, how do they express what they want perceive an outcome? Today, this includes expressing a sequential, raw, very base level, step by step transactions, approvals, confirmation, et cetera, to get to where they want to go. This means that a user has to solve their own path of point a to point b, which is not very user friendly, especially because blockchain forces are quite inherently healthier. So to solve both these problems, I think that we're really not going to see much onboarding until they are both solved because it's too inaccessible. But it solved both these problems. There's kind of two core components that we see this, right, that actually contribute to both almost equally. The first is smart wallet service.
00:05:16.730 - 00:06:29.392, Speaker A: This is the existing wallet service that we currently have, powered by MVC TSS for key management, tied directly with account structure. So rather than leading to an externally owned account, you lead to a smart account that can be any implementation using bundler paymaster, so that applications can kind of refine their onboarding and initial utilization experience with account sponsor, gas fees, batch transactions, create custom account implementations, whatever they want to do which is initiated by social logins. With wall as a service, this solves some of it. The second half is intent centric architecture. So to actually get somebody from the point of expression to when they have an outcome, the way that we do this is with, this is what you guys have been hearing about all day today. This is what we need to solve this core problem. Okay, so now that we've defined kind of what the UX problem is and what particle network is, I think it's also important to find particle network v two, which you saw in the sort of introductory title slide in the beginning.
00:06:29.392 - 00:07:18.054, Speaker A: So part of network b two is a collection of different technologies. Like I mentioned, for a long time, all we had was the wallets of service. But what we realized is that there's a lot of wallets of requires what, three auth Pertv? I mean, at the end of the day, these providers, including ourselves, are all kind of providing the same fundamental solution to that first half of the problem. But at portable, if we want to contribute in a larger capacity to solving these crypto UX problems, we need to extend beyond wallet service to the solutions I just outlined a moment ago, which in our case is of course our walls of service on chain account abstraction. Whole different topic, we'll get into that today. But ZK was another big different topic for confidential login. And then what we're talking about today, which is the intent fusion protocol.
00:07:18.054 - 00:08:19.810, Speaker A: So the intent to Jim protocol is the kind of one layer that we usually provide for this. We actually just formally announced the architecture yesterday, but it's a permissionless, universal framework and domain specific language for expressing, transforming, and executing intents. So doing so in a way that is generalized and open permission, permissionless, and of course in this case universal. So not just through our wallet and service, but through multiple interfaces to express intent. Typically on the developer side, have that be transformed into a list of transactions or steps that need to happen and then have that be executed. But that's kind of a mouthful. So what is time? You probably heard the definition a few times, but you know, intent really isn't universally accepted in terms of a specific definition.
00:08:19.810 - 00:09:02.466, Speaker A: It's still a little bit of a debate in the community. How do you define intent specifically? How narrow or how broad should the definition be? Some people believe that intent should be very specific to defi others putting ourselves in, people like Ganola. A more abstract definition here, I believe this is also a definition that essential follows, which is just very simply something I think you guys have heard today as well. A set of declarative constraints involving signatures that allow users to delegate transaction creation and execution in third parties without relinquishing full control over to those third parties. This is intense. It's the act of saying I want to get to an endpoint. I have input and output constraints.
00:09:02.466 - 00:09:47.034, Speaker A: I need transactions to get to that point, generate these transactions for me and execute them. This is kind of the core of what we're trying to do. This is a visualization of that. You've probably seen visualizations like these before, but the TLDR here is that of course, at the moment with that second half of the problem, that top kind of visualization there is exactly why we need intent. Because at the moment, to get from point a to point b, it is manual intervention. Step one, step two, three and four, initiated and confirmed by the user, but also discovered by the user. The user needs to know what they want to do to get to point b, versus in our case with the intent fusion protocol and intent centricity in general.
00:09:47.034 - 00:10:34.954, Speaker A: Instead, it's simply expression. So in this case, on the actual DSL side, this involves just simply an array of input constraints and output constraints. So what do you want as an input? What do you want as the desired output? And then what needs to happen in between this, which is usually what a user would do in the top example, is discovered and executed by the intent fusion protocol and then presented to the end user. Okay, so this is kind of a complicated graphic here, and this is something that we just announced yesterday. So this is our intent fusion protocol. Specifically usage of the intent fusion protocol in the context of a single chain solution. So solution that stays confined within the chain in which it was initiated on.
00:10:34.954 - 00:11:22.306, Speaker A: It's actually at its core pretty simple. The way that we see intents is very simply a transfer of data. So in this case, like I mentioned, a transfer of input network constraints from user address, whether that's a smart account or an EOA, to a solver as well as a coordinator. We define this as a reactor, but as you can see, the actual flow here is pretty simple. A user, usually through the means of an application that has structured an intent, initiates a request for solver. This hits a solver network, which competes to basically provide the user with an optimal path. In this case, actually what we decided to do is allow the user to choose what path they want dictated by the solvers that have given them multiple paths to take.
00:11:22.306 - 00:12:23.042, Speaker A: Then depending upon the path they take, the solver is of course rewarded f and intent object is signed and created, then passed through the reactor for coordination and execution on chain. So this is simply the architecture that we have proposed here, coordinated by the DSL that I mentioned earlier, which is simply arrays of input mathematicians. Now this actually extends further into cross chain. So an example we like to give is you can imagine you are on polygon and you have 100 mat, you want to play a game on base that costs 40 matic to mince an NFT that the game requires to play. Right at the moment, this is four or five transactions that you use. The alternative here is actually doing this for the user. So discovering the cross chain transactions, the bridging that needs to happen to get to the point that they have running on polygon and spend the value of that format on an NFT used on base for a specific game.
00:12:23.042 - 00:13:31.948, Speaker A: So this is the architecture there. I won't go into the specifics here. As you'll see in a moment, we have an article that outlines this, but what this enables is exactly that. So intents that are confined to a specific chain, but generalized execution of transactions across multiple chains. Okay, so this is kind of our vision, and you saw this graphic earlier, but our vision for an intent centric future. So really what we want to see is that applications, most applications, especially those with potentially complex paths or a high barrier entry, like a base specific NFT lump invention, these will have native intents that can be structured and expressed to the intent fusion protocol that users can then query and solve that involve any significant number of transactions, and therefore abstracting away the actual transactional experience for users for complex scenarios. So this means that at the moment, what usually would take 45 minutes for a given user will take maybe two clicks, the instruction of intent object, choosing the path they want to take, sign that and install.
00:13:31.948 - 00:14:33.304, Speaker A: So this is a pretty significant evolution in how we approach transactions and how we approach actual utilization of web3 that we believe will hopefully solve the second half of the UX problem through the means of the intended fusion protocol. If we can solve both these halves, the whole point of onboarding to expression, and then through that, the point of expression to having an outcome, then we'll have this sort of foundation. The infrastructure that we need to create applications, whether it's games, whether it's payments, defi, etcetera, that feel very adjacent, if not potentially more smooth than web two applications. The vision is eventually that most applications that you build in the future, especially those that leverage both of these solutions, won't really feel like web3 applications. It'll feel like web 2.5 or something like this. Because the complexity that exists natively within blockchain today will be almost entirely threaded away their intents and through vault service or account manager.
00:14:33.304 - 00:15:38.384, Speaker A: So this is the article that we posted yesterday. We actually originally announced the intent fusion protocol in Singapore at our infracon event, and we're pretty silent about it for a while because we've been wanting to make sure that we get this right. This is kind of a successful first real attempt at like generalized intent implementation. So we took a while. We just released this article yesterday that dives into the architecture that I just spoke about. The data, be specific, like use cases of this, how this might be structured on the end user side, as well as the actual integration flow for developers. So we're going to release more academically aligned papers, articles on this in the near future that dive into questions like, well, what does a specific DSL input like, an array of input and output constraints, what does that actually look like visually? We're going to have all these questions answered in future papers that we'll hopefully be releasing in the next few months.
00:15:38.384 - 00:16:19.096, Speaker A: Actually, we have a quite soon timeline in terms of full implementation of the intent fusion protocol, hopefully within the next few quarters. So this is something that we've been working on for quite a while and we believe will complement our wallet service quite well in achieving next generation crypto, usually. Okay, so I unfortunately don't have time for questions. I have another panel that I'm going to go to in a few minutes, but my name is ethan. I go by the alias Tabasco online. You can find me on Twitter obascoweb3. And of course you can follow us on Twitter article arcticlenetwork through the QR code there and also check our website particle.net
00:16:19.096 - 00:16:39.864, Speaker A: work. We have a lot coming out in this. We're really focused on solving these core ux problems without sacrificing things like privacy or of course developer experience. So you keep up to date everything that we're doing on that website and definitely check out the blog posts that I showed in the last slide. That's it, check it out. Thank you guys.
