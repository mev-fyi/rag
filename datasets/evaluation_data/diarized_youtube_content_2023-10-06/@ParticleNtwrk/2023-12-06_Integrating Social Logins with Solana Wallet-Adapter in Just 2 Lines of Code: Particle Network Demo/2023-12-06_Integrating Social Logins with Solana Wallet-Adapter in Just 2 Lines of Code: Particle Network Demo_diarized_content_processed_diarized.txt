00:00:00.200 - 00:00:40.934, Speaker A: In just ten minutes, let's build this application. Leveraging particle connect to facilitate both web two based login with particle auth as well as web3 based login with Phantom. Particle connect is essentially our native modular walled adapter and component for connecting to both EVM chains as well as Solana. Specifically, particle connect enables users to log into adapt through either their social login, so their Google account, email, etcetera, or through their web3 wallet, in this case for Solana with Phantom. So specifically today, in just ten minutes, we'll be creating an application that implements particle connect to of course, first of all initiate a connection. Then we'll include some testing logic like balance retrievals, message signing, stuff like that. By implementing this, we'll basically be able to curate an experience that's equally accessible to both web3 natives and potentially consumers coming from web two.
00:00:40.934 - 00:00:59.948, Speaker A: So I think it'll be pretty cool. Let's jump right into it. All right, so this will be pretty simple, just a little bit over 100 lines of code. And essentially the goal here is to initialize protocol connect within a traditional connect wallet button. We'll also need to build our logic around whether the user is connecting with their social login or with phantom, as each case is going to require different handling for things like the signatures and whatnot. But it's pretty simple overall. So let's begin.
00:00:59.948 - 00:01:31.482, Speaker A: Of course, as usual, to get started here, we'll need to import a number of different base libraries. Start with react and use effect. We can also import button and notification from AnTD. Additionally, we'll need to import a number of components from particles connect React UI. This will be connect button modal provider use account, use particle connect and use connect kit from particle Dash network Connect ReactuI. Additionally, within this application we're going to support both the Solana Mainnet and Solana Devnet. So to handle this on the particle side, we can import Solana and Solana Devnet from at particle network chain.
00:01:31.482 - 00:02:07.078, Speaker A: We can also import Solana wallets from particle Connect. This will contain the phantom option that we'll include within the connection UI, and we can import connection and then publicate from Solana web3 js. Finally, before we import our CSS, we can import base 58 from base 58, and then as usual, we can do our CSS right there. And to format the connection UI itself, we can import apparticle network slash Connect Reactui disk index CSS. Okay, so that's all of our base libraries imported. Let's move on to creating the first of two components within this application this will be page connect kit. Essentially within page connect kit, we'll be configuring particle and essentially telling it what options we want to have within the connection menu.
00:02:07.078 - 00:02:30.070, Speaker A: So we can do all of this in a constant called options. But before we fill this out, we'll need to essentially connect this application to the particle dashboard with a few key variables, specifically our project id, client key and app id. So let's head over to the particle dashboard and grab those. All right, as you can see, I'm here on the particle dashboard and click on add new project. I'll name this particle connect demo and click save. And then in here I'll need to create an application. In my case, I'm building a web app.
00:02:30.070 - 00:02:56.246, Speaker A: So I'll select web, I'll name this Solana test, and then we can paste in the domain in which this application will be hosted. Okay, so now from here and grab the product id, the client key, and the app id. Okay, so now we can fill out some of these options, the first of which will be Project id. Also this to process env react, app, project id. I can also set the client key and the app id. Okay, so now with those set, we've essentially connected our application with the particle dashboard. Let's move on to the next option, which is chains, so we can define chains.
00:02:56.246 - 00:03:26.798, Speaker A: And in here, of course, we can do Solana and Solana Devnet. Then for the wallets, we can just enter Solana wallets. At the moment this is just phantom, but in the future we'll have other options. And then additionally, as you saw in the intro, when you sign with particle or when you sign in with a social login, you have the ability to essentially enter the wallet within a little wallet pop up in the corner. Although this is optional, you can choose whether or not you want to include this with particle wallet entry. And in my case, I'm going to set this to true with display wallet entry. And then specifically within that wallet interface that you saw, I want to keep that interface exclusive to Solana and Solana Devnet.
00:03:26.798 - 00:03:50.414, Speaker A: Alright, so those are all of our main configurations set up. Let's now move on to structuring this and setting up our modal provider. We can do this in a return statement. Start by opening up modal provider, and then in here we'll want to define a parameter called particle auth sort. And within this parameter we can essentially choose what social logins we want to be supported within this application. So do you want Google, email, Twitter? This is where we can configure that. So in my case I'll be doing email, phone, Google, Twitter, Apple, Facebook and GitHub.
00:03:50.414 - 00:04:18.966, Speaker A: And then of course additionally we can set options equal to options and then we can close it off just by throwing in connect content. This is currently undefined, so let's go ahead and define it. We can call this the same name, connect content. And essentially connect content will contain all of our logic for handling connection with Phantom, retrieving the balance, signing a message, and of course we'll also include the logic for disconnecting from the application. Start by defining a few different variables. To begin, we can define connect disconnect from use particle connect. We can also define connectkit as use Connectkit.
00:04:18.966 - 00:04:47.774, Speaker A: We can do account as use account and we can define is particleactive as ConnectKit particle auth is login. This will essentially tell us if a user has logged in with particle or not. Okay, so now let's define a function called get provider. We'll be using this to help connect to Phantom in a moment. So we can call this get provider and we'll actually be defining this function with a one line conditional. So this will be is particle active, which of course is the boolean that we defined up here. And depending on whether is particle active is true or false, we can return either null or window dot phantom dot Solana.
00:04:47.774 - 00:05:24.942, Speaker A: Okay, so with all that defined, let's move on to creating the main function that will actually handle the connection with fan. With of course the support from git provider, we can call this connect phantom. It'll be asynchronous and we can first define provider as get provider. Now if provider is not null. So if provider is window Phantom Solana, then we can just simply do await provider dot connect. And now what we can do to actually initialize that connection is open up a use effect and check if account returns a truth value, which means in this case it should define if it is and we can connect phantom. So essentially whenever account updates, call the connect Phantom method right here, which will conditionally connect our Phantom wallet only if we've chosen Phantom as a connection option.
00:05:24.942 - 00:05:58.194, Speaker A: So now we have all of our logic built out for handling the connection with Phantom. Let's move on to creating the three buttons in our application. This will again be get balance, personal sign and disconnect. We can start with get balance and to get the balance we'll be using Solana web3 j's. So we'll need to first define connection as new connection and then we can throw in an RPC URL here. I've saved mine and process env react app RPC URL let's also define Phantom provider as get provider. Now we create a variable for the address of our account which will be conditionally defined based upon whether phantom provider is Phantom returns true or false.
00:05:58.194 - 00:06:42.664, Speaker A: If it returns true, which means that we have Phantom connected, then we can just do Phantom provider public key tostring. Otherwise, if it's false, then we can do await connect kit particle Solana Getaddress alright, so let's move on to actually pulling the balance itself. With Solana web3, we can save this in a variable called balance and this will be await connection dot get balance and then we create a new instance of public and then pass in our address. Then to indicate that this call was successful, we can throw a notification dot success and set the message as getbalance successful and set the description as balance. Then we can do balance divided by 29. This arithmetic here will essentially convert the balance from a lamport value to a sole in which we can indicate that it's in soul by saying soul. Alright, so it's pretty simple.
00:06:42.664 - 00:07:08.950, Speaker A: That's get balance. Let's create a similar function, but for signing a message so we can call this personal sign. It'll also be asynchronous. And let's start by defining the message that we want these different wallets to sign. Do something simple like GMGM particle network. We'll then need to create another version of this message called encoded message which we can define as new text encoder, dot encode and then pass in message. We can now the same as last time, create our phantom vitre object which will just be get provider.
00:07:08.950 - 00:07:38.024, Speaker A: And now let's go ahead and actually sign the message itself. And now let's go ahead and actually sign the message itself. We can save this in a variable called sign message. And what we'll do is actually very similar to the last one. We'll do a conditional function call based upon again if Phantom provider, that is, phantom, returns true or false. So we'll need to either call the signmessage method on Phantom provider or the sign message method on Connectkit. So of course if Isfantom is true, we can do await Phantom provider that signmessage, then the encoded message and we can display that as UTF eight.
00:07:38.024 - 00:08:18.332, Speaker A: Otherwise, if it's false and we can do await connectkit particle Solana signmessage in which we can call base 58 dot encode and then encoded message and this will automatically be displayed in UTF eight on particle. Then of course we can throw a notification success and set the message as personal sign successful. And actually what we can do is within this message here, mention that it was either a particle sign or a phantom sign. So we can do that by calling phantom provider is phantom in which we can set the text to either phantom or particle. Then in the description we can just stringify the response and signed message. Alright, and we're almost done. All we have left to do now is define our disconnect logic so we can call this on disconnect.
00:08:18.332 - 00:08:38.648, Speaker A: We just keep it as one line and then call disconnect and set hide loading to true. Let's now go ahead and open up return and we can structure everything here in our JSX. I'll go ahead and do that and come back in a moment. Alright. And there we go. It's pretty simple. We're just initializing the connect button and then depending on if the user has signed in or not displaying, get balance personal sign and disconnect.
00:08:38.648 - 00:09:08.800, Speaker A: So we can close everything off just by doing export default and then page connect kit. And actually before we give it a try, what I forgot to do was throw this right here, right here and right here. Adding in this little question mark essentially makes it so that if phantom provider is null, which we expect it to be in some cases, then we won't have an error thrown. Okay, so with that fix made, let's go ahead and run it and see if it works. Alright, so as you can see, looks like it worked. Let's go give it a try by clicking connect wallet and we have all of our particle auth options from email, phone, Google, Twitter, et cetera. All the options that we defined as well as Phantom.
00:09:08.800 - 00:09:25.352, Speaker A: For now, let's give it a try with Google and I'll select my Google account right here. And there we go. I'm now signed in. We have of course the particle wallet pop up right here because I defined it as being true. We can see the tokens that I have, the NFT, the different transactions can receive. I can buy soul with a built in on ramp swap, et cetera. Similar functionality is actually built directly into the connection you want.
00:09:25.352 - 00:09:39.940, Speaker A: So we can open the wallet with this button right here or we can buy crypto copy address or log out. Let's now try get balance. As you can see right there, I have zero soul. We can also try the personal signature GMGM particle network. We can go ahead and confirm and there we go. Let's go ahead and disconnect and give it a try with Phantom. All right, so now I'll just select Phantom.
00:09:39.940 - 00:09:59.964, Speaker A: I can go ahead and log in, and as you can see here, I'm now connected with my phantom wallet. Let's go and click on get balance CI 14 soul. We can do the signature button GMGM particle network go and click on sign and there we go. So that was using particle connect with Solana. If you'd like to learn more about particle, then I'll have the introduction of particle video linked below. And if you'd like to play with either the application that we built today or any of our other various different web demos, then I'll have those links below.
