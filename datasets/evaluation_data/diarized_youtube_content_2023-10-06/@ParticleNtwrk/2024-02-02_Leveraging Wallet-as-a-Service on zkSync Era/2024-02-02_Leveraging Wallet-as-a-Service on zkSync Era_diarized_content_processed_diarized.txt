00:00:00.200 - 00:01:01.390, Speaker A: In just nine minutes, let's use particle as well as a service to implement social login within an application built on Zksync era. Zksync era is a L2 zk rollup that scales Ethereum and of course inherits 100% of its security. This intrinsic scalability leads directly into pretty impressive performance, so fast transactions, low transaction fees, and of course in the case of Zksync, native account abstraction. Zksync is at the forefront of really exciting Ethereum scaling solutions, specifically one that's centered very closely around user experience without compromising security. Thus, this makes Zksync a great contender for developers looking to build consumer facing applications. It's for this exact reason that a little while back we decided to support the Zksync era mainnet and go early testnet natively within our wallet as a service. What this means is that when you're building an application on Zksync, you can take advantage of the intrinsic UX capabilities of Zksync by implementing social login, so onboarding users through their Google account, Twitter account and so on, and then facilitating interaction with this account through an embedded wallet, thus refining and streamlining the interaction experience of your application to feel very web two adjacent and specific to your exact use case.
00:01:01.390 - 00:01:32.734, Speaker A: So this is why today, in just nine minutes, we're going to go through the process of building a simple application that connects to the Zksync era, go early testnet and onboards a user through their social login, either their Google account or their Twitter account, and then tests that interaction through a sample transaction. So let's jump right into it. So like I mentioned, we're going to be building a pretty simple application. This will be around 90 lines of code in which we'll be basically implementing particles wallet as a service to onboard a user entirely through a social login, resulting in a non custodial embedded wallet that they can use to then send a sample transaction, in this case a burn about 0.001 ETH. Let's go and get started. Begin.
00:01:32.734 - 00:02:15.002, Speaker A: I want to import a number of different libraries so we can start with react as well as use state and useeffect. Additionally, from particle network we can import particle network and that'll be from particle DaSH network slash auth. You can also import particle provider from apparticle DaSH network slash provider. Additionally, specifically for Zksync can import Zksync error at Testnet from particle network chains. Now of course we'll also need ethers along with optionally notification from anti and then we can close this out here by importing our CSS. Okay, so now that we have all these imported, we'll need to begin before we actually build our application by configuring particle network itself. To do this, we'll need to create a variable called particle, that'll be new particle network in which we can pass in an object with our various different configurations.
00:02:15.002 - 00:02:41.068, Speaker A: Although before we build that object, let's first head over to the particle dashboard and retrieve a few key values that we'll need for the configuration right here. Okay, so I'm now here on the particle dashboard. Let's go and click on add new project. I'll name the Zksync demo and click Save. Now specifically in here we'll need to grab the project id client key as well as the app id, although as you can tell, we don't have the app id. So to retrieve it, we'll first need to create an application on either iOS, Android, or web. I'll select web, I'll name this again Zksync demo, and I'll throw in the domain in which I'm hosting it right here.
00:02:41.068 - 00:03:11.348, Speaker A: Although of course if you have yet to get to the point where you're hosting your application on a domain and you're just running it on localhost, then you can throw in any filler domain here and it'll still work. So I'll go and click ok and there we go. There's a lot more to this dashboard. Of course you can customize the actual interface itself, access our paymaster and bundler, our RPC nodes, and so on. But for now we just need to copy the project id, the client key, and the app id. Now we can throw those into environment variables within our application and continue go and start in here. By setting our project id, in my case it'll be process envy react app project id.
00:03:11.348 - 00:03:46.540, Speaker A: I can do the same thing for my client key along with my app id. Initially, I can set the chain name async erratestnet dot name along with the chain id as zksync erratestnet id. Now of course, if we were doing this on Mainnet, then I could use the standard ZK sync error object right here. Additionally, I can set wallet to this object here in which I want to pass in display wallet entry as true. So that's our particle object config. Although before we move on to our app component, we'll need to create a custom ethers provider using this object to add all of our transactions and whatnot through particles wallet as a service itself. So let's do this within a variable called custom provider.
00:03:46.540 - 00:04:10.766, Speaker A: We can set that equal to new ethers providers web3 provider. Then we can pass in new particle provider, which will take particle dot auth. Then we can also throw in any so basically what this will do is because of course we're passing in our custom 1193 provider object. When we call and use ethers, it'll be automatically routed to particle. You'll see a demonstration of this in a moment. But first let's go ahead and actually build out the core application logic within app. We can open that up right here.
00:04:10.766 - 00:04:35.782, Speaker A: Let's start by setting two states. This will be balance and set balance as well as userinfo and set user info with those set. Let's also open up a use effect within here we can implement our logic to keep the balance in the front end as up to date and accurate. So to do that, let's first open with a conditional checking if user info is defined or if it's truthy or falsey. If it is defined, then we can call fetch balance. We'll be writing this function in one moment. Now, of course we can close this use effect by making it dependent on user info.
00:04:35.782 - 00:05:08.906, Speaker A: Okay, so let's go ahead and write the fetch balance function as fetch balance. That'll be asynchronous. Basically we can do this whole function in about two lines of code. To start, we'll need to pull the balance and balance response. And to do that we can do await custom provider getbalance, which will take await custom provider Getsigner getaddress. Now this will pull the balance of our address in way, so we'll want to go ahead and set that balance within our state through setbalance, although we'll need to set it as an ether value instead of way, in which case we can use ethers, utils, format ether, and pass in balance response. All right, so that's our balance logic done.
00:05:08.906 - 00:05:36.798, Speaker A: Now on our front end we'll have a mechanism to retrieve the balance of the user, update it when we need to, and of course display it as a readable format. Let's now go ahead and create our logic for the social login. Let's do this within a function called handle login that'll take one parameter called preferred auth type and similar to fetch balance. We can do this in about two lines of code. To start, we can open with a one line conditional. We can save the result of that conditional in a variable called user, and basically we'll be checking the status of whether or not a user is logged in. So we can do this with particle dot off dot is login.
00:05:36.798 - 00:06:01.964, Speaker A: Now, if they aren't logged in. So if this returns true, meaning is login returns false. And that's of course inverted to a true value that we can call await particle dot auth dot login and then pass in preferred auth type. Otherwise, if the user is logged in that we can simply call particle dot auth dot getuserinfo. Then, similar to balance, we'll need to set that state with set user info and then pass in user. Let's go ahead and close this off with our final function. This will be execute tx.
00:06:01.964 - 00:06:22.140, Speaker A: Now basically within this function we want to send a transaction, in this case just a basic sample transaction in which we burn 0.001 ETH. So basically just sending it to a dead address. This will be quite simple. We can start by retrieving the signer custom provider Getsigner. Then of course we'll need to construct the transaction object containing all of our core transaction details. You can keep this to just two values.
00:06:22.140 - 00:06:56.534, Speaker A: Basically the first will be the to field, which in my case will be this dead address right here. And then we can fill in the value field as ethers utils parse ether 0.001. This will convert an ether value of 0.0012 way. So now with our signer retrieve and our transaction object constructed, we can send the transaction in a variable called txresponse, which will be await signer send transaction, and then passing in tx. Now of course we'll also want the receipt of this transaction within Tx receipt, where we can basically just do await tx response. And then that will save the transaction receipt, including the transaction hash to txreceat.
00:06:56.534 - 00:07:23.406, Speaker A: So now to close off this function we can throw notification success. This is optional, purely a front end element to display the transaction hash so I can set message to txreceat transactionhash. And that's it. We've gone ahead and fetched the user's balance, logged them in through a social account, and executed a sample transaction. And go ahead and end this off by formatting our JSX within a return statement right here. Although usually I skip this part because it can be a little bit redundant. So I'll go ahead and get this done and then come back and there we go.
00:07:23.406 - 00:07:54.446, Speaker A: It's pretty simple. We're basically just checking again the status of user info. So basically determining if a user is logged in or not, then creating two buttons. Either sign in with Google or sign in with Twitter, which are mapped to handle login passing in a string of either Google or Twitter. We have many more social login mechanisms, from email to phone number, GitHub, Facebook, LinkedIn, Discord and so on. But in this case, for the sake of simplicity, I want to stick to Google and Twitter. Then once the user has logged in, we display their name, their balance and ETH and two buttons, first being execute transaction, which is mapped to execute TX, and the second being disconnect, which is mapped to particle auth logout.
00:07:54.446 - 00:08:23.662, Speaker A: Okay, so to finally end this off, all we have left to do is throw in export defaults and then app perfect. So that's the sample application done to go ahead and give it a try to see if it works. So as you can see, I am on the main page here we have, as we set up our two buttons, sign in with Google and sign up with Twitter. For this example, let's go and choose sign with Google and click it right here. As you can see, I now have the modal popup. If you choose to follow the GitHub repository that I've linked below this video, then this popup will actually be integrated within the application itself because that'll use particle auth core. Although in this case, because I'm using particle auth, we have this pop up right here in which I can choose my Google account.
00:08:23.662 - 00:08:45.630, Speaker A: And there we go, we have my name, my balance in ETH, which at the moment is 0.148. And then of course our two buttons execute transaction and logout. But also, as you'll notice, we have this little particle logo down here, which is our wallet modal for interacting with the wallet. This is optional, you don't have to display this, but this offers a unified mechanism of using the wallet generated by the social login. So let's go and give it a try by clicking execute transaction. As you can see, I'm setting 0.001 ETH to this address right here.
00:08:45.630 - 00:09:09.302, Speaker A: And of course we have the network fee, which I can even customize if I want to, along with the function, the hex data, et cetera. So let's go and click on confirm. And there we go. We already have the transaction hash ready, so let's go and copy this and head over to the Zksync testnet Explorer and check it out. We have the transfer from my address to this address for 0.001 ETH. Building consumer facing applications on Zksync using wallet as a service for social logins and embedded interaction is simple.
00:09:09.302 - 00:09:29.674, Speaker A: As you can see, we built that entire application in around 85 lines of code. If you'd like to learn more about particle network, then I'll have an explainer video linked below. Additionally, if you'd like to view the code for a similar sample application that achieves the same thing, but instead using our auth core SDK, then I'll have that GitHub repository linked below. Additionally, if you'd like to try either our primary web demo or the demo that we built today, then you can also find both of those below.
