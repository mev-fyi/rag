00:00:23.530 - 00:00:48.050, Speaker A: So hey. Hello. I'm Rob from Pods. I'm co founder at Pods Finance. We are an options protocol. We try to be easy to understand all those things related to derivatives. We have complexity enough in this space like you need to know MetaMask blockchain gas and then derivatives like options futures forwards.
00:00:48.050 - 00:01:34.100, Speaker A: So we wanted to bring the easiest experience for the users to grasp all this complexity. And the reason that I wanted to do this talk is because we are a team that came out from hackathons last year. We had this project Omidify on If Denver last year by the way, this is vitalik. He's not much excited but we were like a okay. And yeah, so after that we decided to start Pods as a real company and we also participated in hack money. It's another big hackathon. I think they just had the last version last month.
00:01:34.100 - 00:02:29.134, Speaker A: So I wish I had know a lot of things that I'm going to say today because maybe you already know that's not a lot of content out there that show you the stones, the path of stones that make it easier to understand what you need to do in order to have cold audit ready. So when I started I thought that the process was like that okay, I do the hackathon, I have some code, I do an audit, maybe not. And then okay, I'm ready to production. That whole things in web two seems to happen, right? Why here we are different. But the reality was something like this. I code, I test, I code, I do some documentation, maybe it's not enough. Then I run the coverage.
00:02:29.134 - 00:03:00.110, Speaker A: My coverage is like 30%, I do a lot of tests, again more testing and then I have to create like a test network. Oh, but Ave is a different network, like Ave is in covent and my system is like, I don't know, hobson. So I need to create like mock contracts. Oh, Chenglink's not already in my network. Oh, maybe optimism. They don't even have the spot price of the asset with the Oracle that I'm going to use. So yeah, the reality is a little bit complex.
00:03:00.110 - 00:03:59.982, Speaker A: So this is kind of the first version of the contracts that we had just after the hackathon, like almost like four contracts and one abstraction and after we ended up before the audit with kind of these architecture here. So it's much more complex than we thought. You started to realize that he's missing a lot of stuff in order to have a real system running. So coming back to the audit, we already know they are so expensive, especially for a startup that you don't have a lot of runway. They are slow. I've been talking to developers here in the last days and they are scheduling audits for December. They don't even know if they are going to have runaway or if they are going to have code to audit.
00:03:59.982 - 00:04:51.842, Speaker A: But they are saving spots. And after starting the process, it's going to take you at least one month to finish the whole process. Like, you send the code, you receive the first feedback, you do the fixes and send again second feedback. So it's going to take you at least more one month there. So requires a pre work and they are not going to tell you that. They are not going to tell you, oh, you're going to start an audit next month. Oh, how is your documentation? Do you have tests already? They are not going to tell you that, but then after in the report, that's the reason I'm here, to tell you some truths and to tips in order to get there and at least not feel that you paid a lot of money.
00:04:51.842 - 00:05:29.322, Speaker A: And then you feel, oh my God, documentation, your documentation is wrong or it's a typo here. You are not paying this a lot of money to have those kind of errors. We are searching for another type of errors here. Okay, so if you like game analogies, like real time strategy, for me, audits, they are similar to cannons, the heavy army. They are low, expensive, and they are effective for a very specific kind of efforts that you want to search. And usually they are for the late game. So not in the beginning.
00:05:29.322 - 00:06:13.754, Speaker A: Like, I just finished my hackathon and tomorrow I want an audit. No, they are the late game. So why do we need it? Do we really need it? For me, the reason that we need audits is because we have a different paradigm here. We are talking about web three. You cannot pull the plug as at the last resort. Like, okay, I have a bug, let's shut down, fix, deploy again. Like, I don't have this option and you cannot, like, probably if you already work in the web two, oh, let's write it directly to the database.
00:06:13.754 - 00:06:45.554, Speaker A: I have admin powers here, so if you have an error, you could go there and reverse here. We don't have this option. So for me, that's the reason that we need audits. And for me, that's one of the best phrases that in my first like this phrase came out, appeared in my first conversation with one auditor that we had. And he said, rob buildings, put that in your head. It's another mentality here. It's more similar to the hardware.
00:06:45.554 - 00:07:22.500, Speaker A: It's more similar to building a phone. You don't want to have bugs in your camera after you shipped directly to your clients. So for me, that was the hardest thing because I was not used to it. I came from this mentality here, build fast and break things. But here, since it's hardware, it's similar to hardware, you should try to build fast and don't be wrecked. It's not easy. We are still figuring out how do we do it.
00:07:22.500 - 00:08:23.110, Speaker A: And the most of the effort comes before the application, not after the launch. Okay, so how to make sure that your money is going to be worth it pre work. Let's talk about what you should have in order to have a good audit. So again, to talk about that, let's understand security layers is our game analogy. Like you have the kennels, the red one, the audits right there. But what are the other soldiers here and what type of wars, what type of opponents? In our case, opponents, they are the vulnerabilities, the hacks. So this is a list that I think you should have before the audit.
00:08:23.110 - 00:08:59.262, Speaker A: At the minimum, I think static analysis is fuzzing testing. Like this is optional, at least for the first audit. If you have time, if you have more developers in your team that you have time to learn and implement, it's okay. But at least those four elements here, I think they are necessary. So the first one unit tests, no secret here. Like the soldiers, very easy to do. I don't have much to say about it.
00:08:59.262 - 00:10:00.980, Speaker A: Like the most important thing is you need to test every execution tree that you have. For those who don't know what is an execution tree, like if you have one function, two ifs, then you have two paths, far paths, like one if like positive, false. So in order to test all those things, I recommend to use Waffle and they help you like mocking your contracts and creating fixtures. Because testing here is going to take you a lot of time each time that you change something and you need to run. For example, in our application we have like 25 contracts, takes around 20 minutes every time that we yeah, we have like 500 tests and it's taking like 20 minutes in our GitHub actions to run the test every time. So it's better to have these in your head like do fixtures since the day one. It's going to save you some time.
00:10:00.980 - 00:10:39.686, Speaker A: Yeah. So unit tests is like specific to functions. Then you have the integration tests is where you test the scenarios. Like in our case we do options. So for example, in order to exercise an option, you need to mint first. So here I'm not test in order to test only the exercise function, I need to prepare the state of the system to be ready for that. Some hints here, I recommend using like main net FARC or Tenly fork.
00:10:39.686 - 00:11:10.130, Speaker A: So then you can already test. For example, if I'm doing something related to yield farming rewards on avi, then you fork and then you test directly this state of the blockchain. And if your system is not self contained, keep that in mind. That's not going to be easy to have like a testnet fully testing. So that's why I recommend the main net FARC. Okay, next one. Coverage.
00:11:10.130 - 00:12:06.854, Speaker A: Coverage is not like for me in my head, it's not like a soldier. It's more like, I don't know, but it's like a thing that helps your soldier that make them stronger. It's very easy to implement. That's why I put the effort there and help measure and visualize and track like constantly. What is the current state of your test? Especially if you are missing some of the execution trees that you didn't create a unit test for. That going really fast here. For me, the easiest way to implement coverage, use hard hat like four line of four codes here and you get ready the coverage, solidity coverage is the one that I'm using there coverage coveralls.
00:12:06.854 - 00:13:14.974, Speaker A: They are free for public repositories and they have like those there you can see for each file what is the current state. And down here they shown like in yellow. What is the execution tree, execution path that is missing? So I think a good way to do it is you do your test from your mind, from your feeling in the first place. And then one week or two weeks after you install coveralls, run the first time and then you are going to realize that you forget to test like some execution paths. It's also good to keep the coverage because there's another phrase that people say that reaching a high state of coverage is easy. Maintaining is hard because every time that you change something, you need to add more tests. So you can add to the GitHub actions to test every time you can check inside our repo, like in the workflows, you can copy that.
00:13:14.974 - 00:13:59.178, Speaker A: I think the hardest part is going to set your secrets on GitHub token there. But then you're going to have the process automatically like running the coverage from hard hat uploading the results to coveralls every time that someone do like a pull request. So I recommend that. And these number minimum of 90% came out from the auditors. I've heard many times like oh, the minimum that you should have is 90%. We are trying to do the 101, but some of the tests requires another layer. In order to find the execution path that fails.
00:13:59.178 - 00:14:25.014, Speaker A: You are going to need like fuzzy testing to find the boundaries. So it's not easily. Let's focus first on having at least 90%. Okay, next one documentation. For me, documentation is also not a soldier. It's more like a supporter too. It's like the Priest because you need to convince other developers to build on top of our system.
00:14:25.014 - 00:15:21.522, Speaker A: For me, that's why it's like the priest and I put like three stars for the effort because I personally don't like I think developers doesn't like to write documentation. But you going to need it. We are using GitBook also. No, it's not free. It's kind of expensive. If you have an alternative there, we spent a lot of money, but it's easy because they have a good user interface that other known developer people could use. So our business team also help us on writing the documentation and don't need to use GitHub and the CLI okay, so the most important thing here is documentation should be like an anonymous writing.
00:15:21.522 - 00:16:05.910, Speaker A: Documentation only in the code is not enough. Having only the white paper is not enough because you have different types of public that are going to use your documentation. So this came out also from the Rob. Your system is so complex. I can't understand looking directly to the code even if your documentation is correct. So can you give me an overview? Why are you doing this? Why this is different from the other elements in the market. So yeah, start from the big context, the big picture, and then like the onion deep dive later in the specific parts that you need more explanations.
00:16:05.910 - 00:16:42.850, Speaker A: For example, in our case, we use a numeric method in order to guess the next value. So we have a specific part of the documentation just explaining this part of the system. Okay, next one. Fuzzy testing. For me, they are the walls and towers. Why? Because you are protecting all the possible roles in our system. So if I have a small hole that I didn't find yet, okay, let's build a wall here and try to protect from the other things that I'm not expecting.
00:16:42.850 - 00:17:40.878, Speaker A: But they require a big effort. It's not easy. The tools that we have is kind of hacky ekijna is what we are using. Why do you have to know the two basic types of fuz testing that you have out there is like the asserts and invariants. What is invariant is like the general rules on your system that you don't want to crash or to follow those situations. So for example, the total supply of tokens should be equal to the total amount of exercised options, for example. And then you run for a day, usually like Akijina takes one day to run like 50,000 simulations there and then you can start finding your boundaries.
00:17:40.878 - 00:18:15.016, Speaker A: So if I have an overflow oh, okay. What is the minimum threshold to reach that overflow? You can find it with fuzzy testing. Then you come back to the coverage and then you create like a unit testing, testing only that boundary. Yeah. So that's to talk about the pre work. But that's only technical stuff. This is also important that negotiation with the auditors, I think we had some problems, so it's good to understand.
00:18:15.016 - 00:19:06.650, Speaker A: Well, what is the scope like? Okay, are we going to have three, four phases of feedbacks? Like if I add a feature in the middle of the audit because like you said, oh, your system requires, I don't know, like admin function here. Okay, I added this function and they need to re audit the function that I just added. Is that going to be included in the audit? Make sure that you negotiate all those elements. The deadlines like oh, that's going to take me one week to fix the thing that you found. Is that okay? One week, two weeks. And the type of test. We have talked to some companies that for example, they don't search for economic problems.
00:19:06.650 - 00:19:41.540, Speaker A: So it's kind of strange. Like we are inside like a DeFi. So they say oh, this is economic testing, it's testing our model. We don't do that. We test only security, like reentrance those kind of errors. So it's good to have in mind what is the type of test that they are going to support? Yeah, an extra thing like after the audit. The audit is not like the end goal before the launch.
00:19:41.540 - 00:20:11.836, Speaker A: We need to remember what is risk. So risk is a function of the probability of something almost wrong and the size of the impact. So all the things that we have just talked is for probability of events. Like I'm trying to reduce the probability of the event, but that's another way to tackle this. I can reduce the impact. How do I do that? Guarded lunch. I can add like a cap.
00:20:11.836 - 00:20:55.804, Speaker A: So in the case of something goes wrong, I have a limit for that. So I'm reducing the impact, not the probability. And like kind of an emergency stop button that it's arguable if that's going to protect you. But we are trying to attack the impact, not the probability. So I think that's it. If you wanted to check the blog post version of this talk, you can check on Blog Pods Finance. And if you have other questions about our experience with audits and from turning our company, like from a project to a hackathon because I'm just talking here about the tech.
00:20:55.804 - 00:21:26.790, Speaker A: But it's also all the other things, like fundraising, corporation law. You can also talk with us, but we really want to help you. And that's it. Guys, I think you have support enough to go through your journey here. Question? Yeah, speaking.
00:21:30.700 - 00:21:46.750, Speaker B: Do you have any insight comparing hard hat and JavaScript based environments with Brownie, which is like Python based tool chain? Do you prefer one over the other or do you have some insight on that?
00:21:47.440 - 00:22:23.416, Speaker A: Yeah, that's a good question. Yeah, you said about browning, but it's also important. I've seen other projects doing tests directly with solidity. If you check reflexor like the Rye thing, they don't use like node python, they use directly solidity to write unit tests. It's kind of more complex. But the reason that we pick it like JavaScript is easier. So if I want someone like Duax, for example, to help us with something or to understand what is happening, that's the reason that we pick it.
00:22:23.416 - 00:22:30.010, Speaker A: By the way, when we started, Brownie was not live yet. So that was the reason.
00:22:31.420 - 00:22:38.600, Speaker C: So Ehydna is kind of difficult to set up. I'm just wondering, was it worth it? Did it actually find any bugs? A hidden?
00:22:38.760 - 00:22:41.884, Speaker A: Yeah, it's hard to set up the hidden. Oh, sorry.
00:22:42.002 - 00:22:51.024, Speaker C: So Ehidna is difficult to set up, right? Initially, I'm just wondering was it worth the effort? Did it actually find any bugs in your contracts once you managed to set it up?
00:22:51.222 - 00:23:12.520, Speaker A: Yeah, that's why I told that it's more to the end. Because to be honest, we launched it on polygon before having fuzzy testing and it's hard to set up. By the way, using Docker, I still can't use Echidina, I'm running directly using the binary.
00:23:14.700 - 00:23:17.156, Speaker C: But in your case, did it actually find any bugs?
00:23:17.188 - 00:23:43.840, Speaker A: Yeah, they found boundaries, not bugs. Okay, but boundary. And it's important to find boundaries because then you can check like oh, should I take care of this overflow or it's going to happen like only if 1 trillion if. Okay, so that's not a market situation. Yeah, so important for boundaries. Any other question? No.
00:23:45.410 - 00:24:10.150, Speaker D: Yeah, just a small question about maybe after the Icasan. I don't know, you have like a small team and maybe not everyone is a solidity developer. So what's your best advice? Do you hire some freelance to do some peer reviews just before going to an audit?
00:24:13.050 - 00:24:16.934, Speaker A: You mean like finding someone to review.
00:24:17.052 - 00:24:38.286, Speaker D: Your yeah, because I know that if you are the only one or just two writing the code, I'm pretty sure there will be some issues and vulnerabilities. So I was wondering what's the best way to avoid that? I don't know, maybe to ease the work for the auditors.
00:24:38.478 - 00:25:04.620, Speaker A: Yeah, no, for sure. In our case, the community is pretty helpful. For sure. If you find any. Oh, you're working a similar project, do you want to trade? And we can review your code, you review ours. Something like that would work, yeah. Also, if you want to help, I can point you some guys in the field that would be happy to help you.
00:25:06.110 - 00:25:07.580, Speaker D: Okay, thank you.
00:25:13.400 - 00:25:14.870, Speaker A: So that's it.
00:25:28.320 - 00:25:31.930, Speaker C: One oh yeah.
