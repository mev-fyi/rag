00:00:00.810 - 00:00:40.650, Speaker A: Test, test, test. Hello. Hi, my name is Yevgeni Kuzikov, I'm currently at proximity, which is defianir, and today I'm going to talk about social in web three. So first, before we start, we need to answer a simple question. So what's the difference between blockchain and web three? And basically it's written in rust, it's likely a blockchain. If it's in PowerPoint, it's a web three. So my background, I worked at Google Plus at Google and spent some time at Facebook.
00:00:40.650 - 00:01:44.394, Speaker A: Then I eventually joined near and currently in proximity. And social is kind of my side project, which I have passion about. So why near? So it has named account, so you don't need ENS, it has multiple keys per account, so you can actually not be restricted by a single key. An account can be an actual contract, so you can have a vault on your account and can be like multi SIG, whatever the contract uses JSON, so you don't need an Abi. And storage in near protocol is managed by the amount of money. So it's somewhat similar to solana accounts, except for you can dynamically allocate more storage if you have monia on the account. It is scalable because it's sharded and it has a free public RPC, so I don't need to start with infuria.
00:01:44.394 - 00:02:24.134, Speaker A: And I also contributed the protocol, so it biased my decision. So I'm going to talk about four experiments today. There's actually one more and first one we call it Near FM. It's live and it was on testnet. It's basically decentralized Twitter. So how it works, it has no backend, it's only like a front end app and it uses a public archival node that has access to the previous blocks. It relies on approval state because if you have a lite client, you can prove that anything happened on chain.
00:02:24.134 - 00:03:14.300, Speaker A: You can fetch it, it has no operational cost. And the way it works, the front end is like IPFS, the user covered the cost of the storage and reads a comment from the public RPC node. It's censorship resistant so long as the underlying network is censorship resistant and it's also open source. So I call it a post chain. Basically it's a chain of posts. The way it works is only the last post is stored on chain in the contract and previous posts by the same user are linked by the block hash or like block height. So this way you can recover entire history of what user posted while keeping the storage minimum on the latest state.
00:03:14.300 - 00:04:23.140, Speaker A: You can also create a permanent link to the previous post by going to say, okay, this user at this block height and the only issue that the user cannot post more than once per block. But blocks are like 1 second, so it's not a big deal. And front end uses recursive fetching by going back, hey, what was the post at this height, what was the previous height? And so on and you cannot delete it because some blockchain which is maybe an issue. The contract also has a social graph where user can create bi directional edges, so they can basically notify someone that they got followed and they cover a storage for this reverse edge. So you can see who followed you, but you don't have to pay for that. So the graph is public and reusable, which means any application that uses account ID can actually grab this graph from the contract and use it on their front end. So for example, let's display friends that you follow, NFTs from friends that you follow.
00:04:23.140 - 00:05:28.950, Speaker A: So Feed feed is actually a combination of the graph and the posts. So a contract returns only a last post for every edge that you follow and then you can recursively recover the rest on the front end and then you just need to store them based on time or like block height. So why it didn't work out well, likes actually require N by M storage and Lens Protocol is example why it's also not on chain. UI is hard and all the improvements actually need to be done and added to the contract. I think Lens is also having similar issues where if you want to add some new feature, you actually need to put it in a contract and then upgrade everyone to this contract and just a mess. So I stopped working on it and the app stopped evolving and that's a problem with decentralization of development. And when testnet was forked on here for some random reason, block heights were reset and we lost the history of the posts.
00:05:28.950 - 00:06:02.560, Speaker A: So it has some risks. So the next one is the wiki. It's basically Wikipedia hosted fully on chain and it also uses Web Four. I'll talk about this. So it's an article of chains. So when you post an article, the previous edits getting deleted, but they are linked by the post, a similar idea and linked by the height of the previous block. And you can go back in time on the front end to recover entire edit history.
00:06:02.560 - 00:06:41.446, Speaker A: It uses Shard storage which is kind of cool, so users don't have to worry about their storage or like owning the article or refund when someone edited their article. So that's good. And how we actually pay for this? Through donations, like a traditional wiki style. It's also very easy to use. So here's the article I did on ECC. Basically copied some code, put some markdown, created a new URL, it's now live. Articles within the Wikipedia are automatically linked.
00:06:41.446 - 00:08:03.430, Speaker A: So if you create a new article and create a link, you will be able to navigate from one article to another. So you can actually create the real Wikipedia on this markdown is very simple and like less bytes to store it on chain and you only need one transaction to create an article and it will be live. So what is web four? It's something average between Web Three and what Jack Dorsey does with Web Five. Actually the main innovation here is when you deploy a contract, you can also put some link how the contract should be rendering, for example a link to IPFS and if you have a hosting that understand that format, that can pull this data, render it for you and get it done. So the wiki near is the account we used for the deploying the contract, the Wikipedia contract on near and it automatically served from the wiki Nier page in the future you can imagine that brave browser for example, if it understand that format, it tracks the near blockchain, it can serve this data without any other backends. Yes, as I said, it redirects to IPFS if you need to or you can actually serve static pages or dynamically generated HTML straight from the contract. And you can read more on this article that I also put on Wikipedia.
00:08:03.430 - 00:08:51.078, Speaker A: So why it didn't work? It actually works great except for it doesn't have a reputation system. So it's easy to abuse. Like anyone can come to the page and now edit it and put something else like promote their scum coin. There is no permission to restrict the edits, that's actually to prevent someone from taking all the three letter characters articles and later trying to sell the access to them. And it's like bad navigation and no search because it's also mostly a front end only app. But if you add a back end to this, you can build a full search and you can fix navigation, you can actually improve it. It's also open source, like all of this I'm talking are just open source product.
00:08:51.078 - 00:10:14.094, Speaker A: Now a near social which is a centralized Twitter or like what they call it federated Twitter, it's back to web two, it's a mastered an instance but with a few features freed for the users and you use your near account. So in this case, for example, Alex Near, you log into this app without email or like Azure credentials and it generates your account at Alex. So you get something like at Alex at near social and it's uniquely maps one to one for the accounts and that allows us to serve this data through the API. You also get the push notification, which kind of cool, where you can react to the events happening on chain. So login is near as simple, you log in with a near account, you also get in auto generated credentials for a mobile app that you can log in on mobile if you don't have a wallet and it has a built in kind of invitation system. So one to one map means as I said, Alex Near links to for example at Alex. And for this now we can say that Alex Near has a profile, we know their social ages and it has a custom display name.
00:10:14.094 - 00:11:06.590, Speaker A: So for example, my profile Eugene the Dream, it has like Atmop, but it also has the profile picture background and stuff like this. You can also export posts so long as they are public, but it obviously needs to be trusted. The API is in memory API that exports data from the Masterdam and serves it from memory instantaneously for really fast from Rust. So for example, for mob near you can get a profile picture. And we integrated this feature into Daviki to display the authors of the articles with more rich media. So the Daviki kind of UI doesn't have to at all care about how they render a profile, how they do this, how to store it. Right now every app is kind of independently displaying the users.
00:11:06.590 - 00:12:09.454, Speaker A: This one is unifying them and also the graph can be used to show NFTs by a friend. You can refer friends to the app and you can do friend of friend expansion like intersection of two friends, like who should you follow? In this particular app, it also has the push notifications which works the following way when an action happens on a near blockchain, it logs an event similar on ethereum event, an indexer picks it up. So in this case the Wiki contract has an article modified by one of the users or created. In this case this event is caught by the indexer. A subscriber to some type of event through the filter gets a push notification on some random backend through the Mastodon API, the traditional API. It makes a post on the mastodon and tagging the user that just created this article or edited it. And my mobile app on Mastodon just picked it up and rendered this.
00:12:09.454 - 00:12:51.970, Speaker A: So it's kind of cool where within 2 seconds I got a notification for something happens on chain on a completely random independent account. So why it didn't work out, it was centralized and that was the main problem. It failed the network effect because people are really not interested in another Twitter, they just want to be only on Twitter. It has no incentives to join and it was not really composable. So only outside of API you can do this. So like you need to use the Mastermind API that's off chain and it's hard to iterate because it's on Ruby. So I present you Social 7.0
00:12:51.970 - 00:13:32.422, Speaker A: because it's keeping three other products that I built that not very relevant to the stock. So it's like 7th iteration. So before we go, I want to talk about what is Social and Web Two. And we have a company or their company, it basically creates the application, then it's used by the users, the users create the data and the data is used by the application and it's owned by the company. So what about developers? Well, they're actually begging for the data and getting wrecked by the company. So that's a social and web two. Now, in Social and Web Three we actually start with developers.
00:13:32.422 - 00:14:38.680, Speaker A: They build applications and applications used by the users who create data and the data is used by the applications but it's actually owned by the users. So the developers do not own this data, but they can use this data and also they can reuse applications because they are like open source usually. So that's pretty good. So what about the company? Well, it's been said so what is social? So to answer this question, I actually have to google it because it's a hard question and majority of the social media talks about we have a profile identity and a bio that's what identifies you as a user. You have social graph contacts and groups that's your connections to other people achievements, pages and soul bound tokens. That's actually the thing that you made in life and you are proud of or not. Well, for example, a soul bound token can be a negative one but you cannot get rid of this.
00:14:38.680 - 00:15:26.754, Speaker A: You have public feeds, blogs and newsletters, that's how you get information from your network and you can add encryption to this data. And now you have private nodes, your settings, all the personalization that is not accessible by all the developers. On top of encryption you can build messages, email and chats where even so data is public. No one can use it except for the parties that have the keys to this data. In this case, the user with end to end encryption will have the data to decrypt the messages and the data can be just used publicly everywhere. Now you can on top reviews, ratings and reputation. This kind of quantitative metric added on top of the graph.
00:15:26.754 - 00:16:33.414, Speaker A: So for example Likes or like super Likes and you can have notifications which are coming back for users to immediately react to something. So how we do this, we keep data on chain and that has a lot of benefits. So the data is owned by the users so long as the contract allows this, it has unrestricted public reads, you can sync up the blockchain and get the data in from any computer without restrictions. You can require permissions for rights by limiting how you write to the contract and you have immutable data history so it allows you to go back in time and find what's going on there and do this kind of optimizations on the storage layer. It's verifiable and provable because a blockchain is kind of designed for that and it's also accessible by other contracts. So it allows you to compose the interesting applications on blockchain. It also scales with the blockchain.
00:16:33.414 - 00:17:18.718, Speaker A: So if blockchain scales and ships like a sharding and you can shard it, then you get better performance. But you probably cannot store ton of data because it might be expensive. So you would mostly focus on the metadata that you care about and the Azure contract might care about. So how we can store it? We can store it in something like a key value tree store. So it's like a key value store, but more with hierarchy like a tree. So that allows users to have independent storage. So under their account ID they can store all the information about them, they cover the cost of this storage and they cover the rights to the storage.
00:17:18.718 - 00:17:52.078, Speaker A: Some modifications it can be like in a simple JSON like representation. It's also very important that doesn't have a specific schema like on lens protocol. Again, they have a specific schema right now where even so it's flexible. They kind of enforce in certain methods. Here we trying to keep it free form and I'll tell why. It also can be sharded by account ID so you can scale with the network adding more shards. So the reason we're not using schema is because we should use standards.
00:17:52.078 - 00:18:54.200, Speaker A: And the standards is a great way to make it decentralized because standards are not forcing you to be this way, they kind of like suggesting you to be this way. And a community can define standard instead of the foundation who's governed the protocol can define standard. There can be multiple competing standards and that should be fairly common. I think Ethereum with ERC standards also have multiple NFT competing standards that eventually one of them get adopted by the community, but they don't enforce it on the Ethereum blockchain network. So standards may evolve and eventually we get rid of one token and start with another one. The contracts can stay immutable, which is very important to guard the control of this and remove the liabilities from me if I develop this contract. And later someone comes to me and say hey, can we delete this account and I don't have an option to do this.
00:18:54.200 - 00:19:51.370, Speaker A: And it also modifies how we create new applications. So we start with Idea, then we deploy the MVP without writing a standard first, then we test it publicly and if it seems to be working out, then we define a standard. We propose the standard and it's created and discussed by the community. Then there is a write permissions on top of this layer and user has a control over the write permissions. And for example, they can only give a permission to modify a profile information under a profile like up to a certain amount of bytes. So that allows you to onboard JavaScript developers who really don't have the experience with the contract development and they can write apps for that social platform. You can build contract permissions, you can do data based permissions which are interesting.
00:19:51.370 - 00:20:44.234, Speaker A: You can pretty much implement an NFT on this if you specify hey, only the person who in this key has ability to modify that key and you can have permissions for permissions, which is like way too complicated. So what is a front end for this? It's a JavaScript and can be only a front end. So don't need a contract. There can be multiple react components, react hooks for this and simple JSON API to query this, but also you can have a custom API backend that can do more complicated logic. You can also use WebSockets for live updates, so your app is more live. So what is the back end? The backend is synchronized to near blockchain, it indexes historical data but it also understands all the standards that were invented and agreed on by community. You can obviously have multiple of them.
00:20:44.234 - 00:21:36.858, Speaker A: So it can do search, it can do graph expansion, it can do rating and reputation, it can do notifications, but it also can be upgraded frequently, not like a contract, it also open source. So anyone who don't like the current backend and don't have access, can spawn their own backend and use it. So here's the architecture. We start with this contract under newer blockchain where there's other contracts, then the front ends interact with the newer blockchain and blockchain or like Azure contracts can interact with the social contracts. Then we involve standards, the standards come into the contracts and front end apps and finally we can build the custom backends that understand standards and have custom logic. So why it may work. So basically data apps, users and developers create a network effect.
00:21:36.858 - 00:22:23.658, Speaker A: The social graph makes it easy to onboard new applications, pages and achievements create gamification and we see this with games. Users bring their friends in because they're like hey, you are missing out. And developers build new application that brings users more. And overall, the ecosystem keeps growing, so every component is replaceable and the open source is encouraged, so that allows you to spawn. Any other PS data is public so you can take it out, spawn on a different blockchain, and it has no governments and no token and no operational cost. That's actually very important because the governments has the bias. Tokens create different incentives and the cost.
00:22:23.658 - 00:23:21.220, Speaker A: If I die, they better like live. So thank you and let me know if you have questions. Yes, hello. So if anyone has a question, do not hesitate to ask. Could you elaborate a bit on the role of tokens? So the tokens usually create variable incentives on this and we don't want a token for something that is base layer. So if you want to monetize your product, you can issue your own token but it doesn't need to be on this low level where you just store data and a user cover for the storage of the data. So that's why we don't need a base layer token to modify because there's no governments evolved like anyone can propose a new standard, anyone can write data in the format they want and they all have equal access.
00:23:21.220 - 00:23:32.430, Speaker A: Any other question? Well, thank you. Thank you.
