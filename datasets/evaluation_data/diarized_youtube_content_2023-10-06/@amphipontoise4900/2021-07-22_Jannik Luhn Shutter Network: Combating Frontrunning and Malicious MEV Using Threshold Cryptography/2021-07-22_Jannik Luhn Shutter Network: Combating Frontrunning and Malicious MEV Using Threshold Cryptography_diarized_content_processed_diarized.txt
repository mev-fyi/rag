00:00:26.480 - 00:01:34.664, Speaker A: Hi, good morning everyone. Great to see so many people here, even though two people are leaving. My name is Yannick, I'm working at Brainwat and I'm here to present our most recent project called Shutter, which is our contribution to combating this problem of front running and various types of malicious mev. We have a 40 minutes slot, so quite a lot of time. So I want to start with some general introduction about mev in general and solutions that the community employs to counter it and tries to evaluate. And then after that I'm going to present how Shutter works and in which circumstances we can apply it and in the end go a bit deeper into the protocol, in particular into the cryptography and the governance, even though we're not going to have any formulas, so it's still going to be quite high level. So what's mev? Mev is an acronym.
00:01:34.664 - 00:02:39.756, Speaker A: Stands for minor Extractable Value or maximally Extractable Value. And it's basically the value that a block producer can extract by being what the block producer is supposed to do by producing a block, in particular by choosing which transactions go into block, by injecting their own, by censoring others and by reordering them, like by changing the order or choosing the order in a certain way. That's mostly it. But there's also more obscure types of mev based on tweaking various fields that blocks have for example, timestamps also choosing on which parent block to build their block, and sometimes even not by producing no block at all, even though they could. I've been talking about the block producer, even though it's called Minor Extractable Value. So this term minor is a bit strange here, but that's simply for historical reasons. It's a representative of the block producer, which in other protocols could be called validator or sequencer, and only in proof of work protocols.
00:02:39.756 - 00:03:23.740, Speaker A: It's the miner. And another reason why the minor term is a bit strange is that usually in practice it's not actually the miner who extracts the value themselves, but they outsource this task to so called sequencers, which are very to so called searchers, which are very specialized and very good at finding these mev opportunities. And they basically bribe the miner and pay them a share of the profits so they too can collaborate. But in the end, it's always the miner who is in charge. So I think it's fair to call it mine. Extractable value. To make it a bit more concrete, I have a couple of examples of mev.
00:03:23.740 - 00:04:06.512, Speaker A: The first one is arbitrage. It's probably the most common type of mev. Say there's two exchanges, decentralized exchanges, and for some reason there's a token which has different prices on the two, even though it's the same token. So what a miner can do now is they can buy on one exchange the exchange where the token is cheaper, and sell it on the other immediately for basically a risk free profit. It's all permissionless so anyone can do that. But since the block producer has the right to order transactions, they can do so first. Basically, they can be faster than anyone else at using this opportunity.
00:04:06.512 - 00:04:41.204, Speaker A: So it's a form of minor extractable value. As a result of this arbitrage, usually the price on exchanges is equalized. Next example, front running. Front running is trying to get a transaction executed before another transaction, knowing that this transaction will happen in the future. So the transaction that the front runner sends can kind of look into the future. And sometimes it's possible to make money out of that knowledge. For example, if the transaction that's going to happen into the future in the future will driver the price of some asset.
00:04:41.204 - 00:05:23.160, Speaker A: So what the block producer can do is they can execute a buy transaction before that transaction, then the price will increase and sell afterwards again and make a risk free profit. As a result, the miner receives a worse price and essentially pays the block producer. Last example, censorship. That's a bit hypothetical, but I wanted to still have it. So I don't think it happens in practice, but it could at some point very well. Do. Say there's a contract that has an operator and the operator is paid a reward for every block there are the operators, they perform some sort of job and they get paid to do it.
00:05:23.160 - 00:05:49.852, Speaker A: And the right to be an operator can be bought by anyone. So now imagine you're an operator. Someone else wants to buy it from you. You don't want that. You want to stay the operator to reap your rewards. Then you could bribe the miner to censor this other transaction so that you can stay the operator for longer. And this, again, is another form of minor extractable value, this bribe.
00:05:49.852 - 00:06:23.876, Speaker A: And as a result of this form of mev, a legitimate transaction, which ideally would be included immediately, is delayed. Yes. So these are examples. Some of them are theoretical, some more practical. But is this actually a problem or is it actually happening? And the answer is yes. There's this effort by the flashboards group to quantify the MEB extracted in practice. And we can see that basically, since the last ECC, more than $750,000,000 of mev have been extracted.
00:06:23.876 - 00:07:09.192, Speaker A: So it's actually a problem or a topic we should be talking about and try to understand. And one thing to say here is that this is even only a lower bound. So it's hard to, in general, Detective, if mev was extracted or not. So they just have certain witnesses, basically, or markers to detect if a transaction is mev or not. And everything that doesn't fit into this pattern will not be counted. So the number could be, and probably is even higher than that. Now, is it actually good or bad, mev extraction? And it's not so clear in the first place.
00:07:09.192 - 00:08:19.212, Speaker A: So I tried to come up with some criteria to determine that if mev extraction is harmful or useful. And the three that I found to see if it's harmful is the first one is if it's clearly at the expense of one particular user, if it's simply a value transfer from a user to a miner and no value is returned, then I think it's clearly harmful because it discourages the user from using the system. So it's something we should try to prevent. Next, mev extraction I think is harmful when it's centralized. If it's only accessible to certain actors, then this is first of all unfair and also a problem because it might lead to centralization of the block production itself. So if it's centralized, certain parties have an economic advantage over other block producers and then they will just price each other out. And lastly, mev extraction I think is bad if it has negative externalities.
00:08:19.212 - 00:09:09.872, Speaker A: So the thing I'm thinking of here is for some mev extraction, extraction strategies build on top of spamming the blockchain by sending a lot of transactions and that just uses the space that is very limited in blocks for something that maybe doesn't provide a lot of value. So that's also a case of bad or harmful mev. But there are cases where mev extraction is actually useful, namely if it has positive externalities. And the main example I'm thinking of here is Arbitrage. So Arbitrage is useful, it equilibrates the price on different exchanges, so it has positive side effects. But nevertheless there's many cases where it's bad. So we should look at those.
00:09:09.872 - 00:10:04.160, Speaker A: And I think the case where it's clearly bad is front running. So that's what we are trying to prevent the most. So what solutions do we have? First of all, application layer techniques. So probably the most obvious solution is to build applications that aren't susceptible to mev. And some of those techniques are very well known, have been known for a long time. For example, don't rely on exact timestamps because the minor can simply has a lot of freedom to choose them or using block hashes for randomness. And that's another thing you shouldn't do because the minor can has some influence on the block hash.
00:10:04.160 - 00:11:17.016, Speaker A: There's more complicated techniques like commit reveal schemes, batching mechanisms, sometimes even like privacy techniques which prevent mev kind of as a side effect and probably many more. So there's definitely lots of stuff to do there and people should probably do that if they build applications right now. But unfortunately it puts a very heavy burden on the application developer. They have to think about a lot of problems which ideally they, in my opinion, shouldn't have to worry about. Another approach to mev, not prevention of mev is this idea of democratizing extraction. Here the plan is to give everyone or to most wide group of people the ability and the proper tools to participate in this extraction effort in order to prevent this centralization of mev and also to make it more efficient like to prevent this transaction spam, for example. And that's the most famous example of that is this mev gas client the Flashbots group came up with.
00:11:17.016 - 00:12:16.540, Speaker A: And that is good because it prevents centralization, but it has also some negative effects mostly that now a lot more mev is actually extracted. So also a lot of harm is done by that. If it's good in some or not is unclear. And another thing that happens, which I think is quite funny, that we now have this searchers as kind of a new job title, some people make a lot of money using that and that also is nice for them. But it also has the side effect that to some extent they're wasting their time, they're not producing a lot of value. It would be much nicer if they could work on more useful projects that the community can actually benefit from. Okay, next, democratize rewards.
00:12:16.540 - 00:13:21.672, Speaker A: What I mean here is this mev auctions, the idea of auctioning off the right to order transactions in a block, that I think the optimism team is strongly considering and using these rewards that have been auctioned off to fund public goods, like to redistribute the money that is made to do some useful things with it. That's I think is a good idea, but it doesn't really do anything about the mev extraction itself. So yeah, not too much to talk about. And now the solution that I think is the most promising is to build mev resistant base layers. So simply a base layer where the plug producer does not have a lot of power, or his powers are reduced, or their powers are reduced. So for example, that they cannot order transactions freely, or they cannot choose the timestamps however they want, then that would be much nicer for the applications because they don't have to worry about all these things. They could just rely on a secure base layer.
00:13:21.672 - 00:14:14.544, Speaker A: And this could be a layer one blockchain, it could be a layer two blockchain, a roller for example, or it could even be a middleware kind of sitting between the blockchain and the application. Okay, so that's the introduction. Now we can talk about shutter. Shutter is like falls into this category, if you might have guessed, trying to build an MEV resistant base layer. And the basic principle is to encrypt transactions. So users encrypt their transactions, send it to the block producer, the block producer will sequence to them, put them in some order, finalize this order, and only then the transactions will be decrypted and executed. The idea here is, I mean, the block releaser can still reorder them however they want, but they don't have any information about what the transactions do.
00:14:14.544 - 00:15:04.576, Speaker A: So they can't extract any value from knowing that a certain transaction will happen at a certain point in time. So in a way, the proposer's powers are reduced or the proposer's knowledge is reduced and now this will happen basically. Then at some point there will be a next block with new transactions, with a new key and it will happen until the end of time. And we can see here that the key is only ever released when the block is finished, when the transaction order is already determined and cannot be changed anymore. That's the basic idea. Now we have these keys. Question if we have keys, how are they generated? First idea and that would come to mind is let the user generate them.
00:15:04.576 - 00:16:19.108, Speaker A: The problem is that this doesn't work because the user could simply decide to not decrypt their transactions and this gives them a free option which breaks many or at least some applications. And one example to think about here is if you have a market where you can bet on rising prices or falling prices, what a user could do is they could do both, bet both on rising and on falling prices and then only decrypt and reveal the transaction that makes them money. So this doesn't work. This would lead to a lot of problems for applications. If we can't let the user decrypt their own transactions, then maybe we can use a trusted third party. This would, I guess, also work, but then we have this trusted third party who could do all the front running and we would rely on a trusted third party, which is not something we want to do in blockchains in general. So if we can't do use the users or trusted parties, we can rely on decentralization, we can use a committee and only trust the committee as a whole to act honestly.
00:16:19.108 - 00:17:19.356, Speaker A: And this works, this is what we do. So to do that, how does a committee generate keys for that? We have this cryptographic notion of disputed key generation protocols. So we have a set of nodes, some of them are honest, some are evil, some are offline. And as long as enough honest people are there, the protocol is secure and the keys are generated in a fair fashion. So it's ensured that the keys are generated at all and that they are not generated early. Okay, so this is like a very general technique and it can be applied in different settings. What we need if we want to apply it, basically we need a way to sequence these transactions, to build these blocks that I talked about and we need a way to execute the transactions later.
00:17:19.356 - 00:18:12.860, Speaker A: So these are basically our two requirements on the platform we build on. And the first thing that comes to mind is of course to build a whole new blockchain that does that. So here the sequencing mechanism would be the blockchain itself, the blocks in the blockchain and the execution mechanism would also be the blockchain only delayed by one block. This would probably be where the idea could be applied in the cleanest fashion. It would be like the most clean implementation. It could also be used for centralized institutions so if there's some centralized exchange front running, there is probably also a big problem. And it might even be a bigger problem than in these open blockchain systems because it's hidden, it's happening behind closed doors.
00:18:12.860 - 00:18:58.584, Speaker A: But if they would apply such a technique such as shutter, they could make themselves more secure and more interesting for consumers. And lastly, we can also implement it on Ethereum today. And that's what we started with, that's what we called on chain shutter. And here our sequencing mechanism is simply a contract. Like the batcher contract, the user sends their encrypted transaction to the batcher contract. The batcher contract will put them in kind of blocks. But in our case, the blocks span more than one Ethereum block.
00:18:58.584 - 00:19:46.040, Speaker A: So we call them batches. Once a batch is closed, finished, after a certain block number, the keepers come, they take the transactions, decrypt them and send them to the executor contract. So the executor contract here is our execution layer. And then the executor contract will make some checks that this has happened faithfully and then send the transactions further to the target contract. So the target contract, what I mean is the contract that the user actually want to use the exchange or whatever is the thing that wants to be fundraising protected. Ideally, even the decryption would happen on chain. Like as you can see here, the decryption is done by the keepers.
00:19:46.040 - 00:20:18.980, Speaker A: I think I haven't introduced the term. So the keepers is what we call the group that generates the keys. Pretty self explanatory, I think. Ideally this would happen on chain. Ideally they would only provide the key and the chain would do the decryption themselves. Unfortunately, this doesn't work due to efficiency reasons of the current EVM implementation, but in theory it would be possible. Now this works, so it can be used for applications to make them front running protected.
00:20:18.980 - 00:21:33.916, Speaker A: But there are some problems with it that I want to highlight so that people know what they're using. One thing is that it does require contracts to actually be aware of shutter and opt into using shutter. The reason for that is that what you can't do is simply use shutter to send a transaction to the existing uniswap. The reason for that is that while these transactions here in the context of the batcher contract are front running protected from each other, the decryption transaction is a normal Ethereum transaction. And this could be front running protected, could be front run. So what the target contract has to do if they want to use shutter is they have to make sure that they only accept transactions from this executor contract in order to block all these side channels, like these parallel channels to introduce transactions from. As I said, this means that the application has to be aware of shutter and actually use it.
00:21:33.916 - 00:22:09.796, Speaker A: And the other problem is that increases latency a bit. So we have to wait for a batch to be closed and then wait for a couple of more blocks so that we can be sure that they won't be reor. So you have to wait for a little longer than for a normal transaction. We've built this example application to show how the user experience would look like and to have an example for applications who want to integrate it, how they would do it. It's on Gurley, there's a URL, you can try it out. It's very simple. We call it a public on chain billboard.
00:22:09.796 - 00:23:24.960, Speaker A: So all you can do is send a transaction which will be locked but this transaction will be frontering protected for some reason. Okay, so Cryptography, as I said, I don't want to talk about the formulas but I do want to talk about the general idea of the key generation protocol that we use. And to repeat this once again, we have this group of keepers that wants to generate keys in this fault tolerant fashion that even works if some of them are malicious. And we have the requirement that it has to be very efficient because we want to support a large group of keepers to ensure that this set is actually honest. And we want to repeat this protocol many many times for every new batch. So we can't rely on typical DKG protocols which are often more inefficient and require lots of messages to be exchanged for every new key generation step. So, in order to understand our protocol, I want to introduce two timescales that we use.
00:23:24.960 - 00:24:29.924, Speaker A: The first one is the epoch. The epoch is in every epoch we generate one key pair so that's this short timescale that happens very frequently and then we have another long timescale on top of that which we call the eon. And the eon will only ever start when the keeper set changes, when a new member joins or leaves. And this will be very infrequently, for example only once a day, or even once a week or once a month. So now the idea of the protocol is to separate to run a setup phase for every eon and then run a very efficient version of that during each epoch. So in the eon phase we generate the so called eon public key which will be sent to everyone, everyone can see it and every keeper will receive a secret key share that kind of belongs to this public key. This phase may take a long time.
00:24:29.924 - 00:25:32.280, Speaker A: So for this, this is a relatively standard DKG process where lots of messages have to be exchanged but this is fine because it will only happen very infrequently. And now during every epoch what we do is we derive from that key material, we already have a new key or a new key pair and this can be very efficient. So in particular for the epoch public key that we use to encrypt transaction, that's simply a function of the eon public key. So for that we don't need any new messages to be exchanged. Everyone can just compute that locally. So maximally efficient. And to generate the epoch secret key here what every keeper has to do is they have to derive from this eon secret key share, an epoch secret key share and then we combine a lot of those to receive the epoch secret key and this then is a key pair, a valid one.
00:25:32.280 - 00:26:58.740, Speaker A: And so, as I said, this one is efficient, doesn't require messages at all and this one only requires a single message per keeper. So yeah, it's very doable to do that a lot of time times in a very high frequent setting. And now the governance that I want to talk about, one thing I haven't mentioned yet at all is where does the keeper set come from? And the problem is we want to ensure that the keeper is actually honest and we can't just allow anyone to join the set because while our protocol is very efficient it of course can only support a limited number of nodes. What projects usually do is they in some way or another sell off the right to participate to the highest bidder. So in proof of stake protocols you submit a deposit and the more deposit you submit the larger share you get. And we think though that this is not a good idea for many protocols. It is a good idea, of course, but in our case it wouldn't work so well, especially if we start small because it would be very cheap to simply buy off the whole thing and make the set malicious.
00:26:58.740 - 00:28:18.844, Speaker A: Fortunately we can rely on the base layer, we can rely on ethereum where we have this cool things called Dows which can make more subjective decisions, they can make it more smart, they can make smarter decisions and they can find ways to select keepers in a better way. They could, for example, rely them to be connected to real world identities or they could use something like Bright ID to make sure that there won't be like one person won't have multiple members in the set or things like that for that. I think Dao is a very good tool because it can make these subjective decisions and the other subjective decision they have to make, or it's maybe on more negotiation is how to reward them. So they need to get some money, the Dao will receive fees from the users that use it and they have to decide on how to redistribute them to the keepers. So that's what the Dao has to do. So that's already the end of the talk. I'm surprised I'm faster than I was.
00:28:18.844 - 00:28:58.220, Speaker A: That's nice. So to wrap it up, mev extraction should be prevented in many cases. There are cases where it's good, but also many where it should be prevented in particular front running because it harms in one particular user. Shutter provides a relatively general mechanism to do that which can be applied in different settings. The first one we applied it in is as a middleware on Ethereum as a set of smart contracts that can be used right now, basically. And we are working now on different implementations in other settings. Yeah, that's all.
00:28:58.220 - 00:29:08.850, Speaker A: Thank you. Quick. So we have time for a lot of questions, if you have any.
00:29:13.540 - 00:29:16.620, Speaker B: How big of a set of keepers can be supported?
00:29:16.780 - 00:29:17.248, Speaker A: Sorry?
00:29:17.334 - 00:29:20.664, Speaker B: How big of a set of keepers can be efficiently supported?
00:29:20.812 - 00:29:52.104, Speaker A: So we tested it with up to 200 keepers but I think we are at the moment just limited by implementation. So the protocol, if we make our implementations better, if we improve the performance of that, it can be I don't have a number, but in theory it's very scalable because we only need to send this one message per keeper. So I don't think there's a low limit.
00:29:52.152 - 00:30:02.720, Speaker B: The keeper set have to stay fixed. I don't understand in this epbox where you do this kind of changing of the key, are you still using the same set or can you change it?
00:30:02.790 - 00:30:14.564, Speaker A: Yes, you can change the set, but if you do so you need to start a new Eon and run this setup phase again.
00:30:14.682 - 00:30:20.710, Speaker B: And how often do you think that could be done? Like redoing the whole thing?
00:30:21.720 - 00:30:54.816, Speaker A: Once a day or once a week is probably a useful time. The nice thing is while it has to take a long time, we don't have to turn off the protocol during the time. We can just continue using the old set and only once the new set is ready transition to it. And there's also a chance to we haven't done this yet, but in theory the protocol could be like the cryptography protocol could be extended to allow for exchanging set. So that's also an option, but we haven't explored this yet.
00:30:54.918 - 00:30:55.730, Speaker B: Thank you.
00:31:03.880 - 00:32:10.388, Speaker C: Kind of curious to hear in terms of the future of ethereum and how big of a controversial topic like mev and Flashbots and all that has become what proposals for E 2.0 and kind of some of the new EIP proposals that are getting pushed through will help kind of enable something like this to be more widely adopted across the network. And I think in terms of talking about how this won't be prevented on E 2.0 also the validators are now going to basically do what the miners are doing now. I think the biggest criticism to ETH right now is basically how Mev is exploiting the users and everything. So what are proposals for the future to combat that? Aside from maybe something like shutter.
00:32:10.564 - 00:33:10.060, Speaker A: So there's definitely things that base layer could do but it's still kind of an open discussions what the best solutions are. So I don't think Ethereum wants to commit to any particular scheme. Fortunately we have in Ethereum this what Vitalik once called this roll up centric roadmap and roll ups provide like basically an ideal ground for experimentation. So we can build different techniques in a roll up, try it out and either only use roll ups that use techniques that worked or eventually maybe in the future integrate them into the ethereum base layer. But for now I don't think Ethereum should do anything different and I also think they have to because we can use roll ups that prevent mev extraction.
00:33:17.940 - 00:33:56.872, Speaker D: So with regard to your noting that because of side channels and other issues around the Onchain contract, there needed to be this awareness within the Smart Contracts, et cetera, of Shutter. To what extent is there a set of threat models under which do not rely on, let's say, cooperation between the contracts and the miners, but are just more minor driven or some other entities where still on net improves things. To run this through shutter. Even for contracts which have no awareness.
00:33:56.936 - 00:34:40.910, Speaker A: Of shutter, I don't think it helped. Like of course if you assume that miners commit to not front running these shutter transactions then of course it would work, but I really doubt they would do that because we see that they are up to extracting mev. So I don't think it makes a lot of sense to have like this threat model. Yeah, it's very simple. Contracts should simply that want to use shutter. They should simply only accept transactions through their channel. All the closing the sessions is very simple.
00:34:40.910 - 00:34:56.880, Speaker A: Yeah, all right, any question? Yeah, any last question?
00:35:00.850 - 00:35:36.746, Speaker C: I guess just to tie it all together, what would you say to somebody who's heavily critical about mev and likes to kind of push the agenda that Ethereum is fundamentally broken from mev and all that stuff? I've been hearing it a lot lately and I think there's not enough people kind of vocalizing the real points to make that. Obviously there were some good points in here in the presentation, but in general to kind of use to discuss I.
00:35:36.768 - 00:36:30.380, Speaker A: Would say that mev is a very general problem and it does not only affect mev ethereum, it affects basically all blockchains, even in some sense bitcoin, some say bitcoin is also affected by mev. And the only reason why a blockchain would not be affected by it is because no one uses it or because there's no interesting use cases. And also I would say that the Ethereum community has proven to be very critical of themselves too and capable of first detecting these problems and also coming up with solutions to fix them. So the Ethereum community as a group of people are very good at solving these problems.
00:36:36.930 - 00:37:24.800, Speaker E: Yeah, just to add my two cent as well on Ethereum's mev problem, my opinion is that actually it's not just like something that you should solve at the protocol level. Of course, maybe we can solve at the protocol level at some point, but this is more of a DAP problem. So if you want some boring use case for Ethereum like. For an example, this transferring ether, then the mev model is the same as bitcoin. You can extract value, maybe some exchanges, but if you have a specific DAP, then it's also the responsibility of the DAP to avoid mev. So for an example, at Claros, we are planning to use commit and review and exchanges can do the same thing, just commit your transaction and then you finalize it done. So, yeah, it's not the end of the world.
00:37:41.870 - 00:38:40.140, Speaker B: From what you said before, like 200 keepers, maybe more, and you could change it once a day. It seems like it would be something that even now, maybe it could be implemented at protocol level, like not necessarily in ethereum, but on a roll up. If there's a roll up that has a set of validators, you could use the validator set already to kind of have a committee every day, let's say. And those being the keepers, is that something that you're at all thinking about, trying to propose this to some roll up or anyway just go in this direction at all? Because it seems to me like just protocol level solutions are generally I mean, it is true that it is a bit of a DAP application layer problem, but it's hard to convince. I don't think it's as easy as saying, well, yeah, they can just do commit, reveal DApps don't want to do that because it's bad for users and they don't want to lose users. So I think protocol level solutions tend to be a lot more general and you can make sure that everyone actually benefits from them.
00:38:40.830 - 00:39:05.480, Speaker A: I fully agree. It's much nicer if the protocol solves this for them. As long as they don't do it, you have to do your own things. But yeah, we're definitely exploring using this in a roll up because as I said earlier, it's the ideal experimentation ground. It's not a lot of risk and it fits perfectly basically to this use case. So definitely something we want to do.
00:39:13.390 - 00:39:14.774, Speaker B: There's also a question in the YouTube.
00:39:14.822 - 00:39:57.814, Speaker A: Livestream, so the question is this one. Okay, there is a question online. Do you want to read it? Okay, good. Can I attack by triggering new eons in high frequency? No. So I think the idea is to start a new eon in order to basically denial or service attack the protocol. This can be easily prevented by changing the rules in which the keeper set changes. So there could be, for example, like a queue of keepers.
00:39:57.814 - 00:40:25.280, Speaker A: If you register you want to become a keeper, then you have to wait until the next day, until the next day starts, and only then the eon will be triggered. So, yeah, it's not a denial of service attack vector. It's not like anyone can start a new eon. It thanks a lot. Is it okay? Yeah, thanks a lot.
