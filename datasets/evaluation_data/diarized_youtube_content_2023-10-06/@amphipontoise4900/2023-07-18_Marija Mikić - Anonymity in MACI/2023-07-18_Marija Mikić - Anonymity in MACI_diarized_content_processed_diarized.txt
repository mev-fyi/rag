00:00:20.570 - 00:00:52.800, Speaker A: It is nice to be here. Today's topic is anonym in Macy. My name is Maria Mikich. I'm ZK researcher. In the team 332-7327 is R and D department in the Ethic 42 company, which is Venture Builder company. And my team three, two, seven obtain a grant from Ethereum Foundation to add anonymity in Macy. So, before we start, a little bit more about me.
00:00:52.800 - 00:01:35.180, Speaker A: I'm also Assistant Professor and Faculty of Mathematics in Belgrade, Serbia. And I'm head of Department of Differential Equation at the same faculty. And I'm also co founder of Mathematical Academy. Mathematical Academy is some kind of private school where we're working with talents in the field of mathematics and physics, and our participants attending primary and secondary school. And for example, this year they won 24 medals on stained competition. So we are very proud of them. And today's topic is anonymity in Macy and is connecting to a voting system.
00:01:35.180 - 00:02:50.660, Speaker A: It is very important to note here that it's very difficult to create a voting system that is completely resistant to collusion, to blackmail of any kind, to censor votes, or to add some extra votes. So what we want to achieve is to have complete privacy and anonymity in voting at the same time. So the question arise is it even possible to create such a voting system? And we have Macy. What is Macy? Macy is minimal anti collusion infrastructure. We can see it as an application that allows users to have voting on chain Macy, reduce bribery and disable tensor voting. This means that no one can vote on behalf of someone else, and it is not possible to falsify the results of voting. The initial idea related to this Macy project came from Vitalik, and we can also see Macy as a collection of ZK circuits, smart contract and TypeScript packages that we can use to build our programs on top.
00:02:50.660 - 00:03:51.990, Speaker A: So how Macy really works? What is done so far in Macy? Before we add anonymity in Macy, can voters cancel the vote if, for example, they were blackmailed? And who can see how voters voted? We want to answer on these questions. Well, in Macy we have users or voters, and we have voting coordinator. First, voters need to be registered to register, they need to send their public key, and their public key plays a role of their identity. So in order to vote, user needs to create a vote. And all votes are encrypted before it's sent to Macy's smart contract. So everything on chain is hidden, and this is really good. And two, only people who can decrypt these votes are coordinator and the user.
00:03:51.990 - 00:04:38.726, Speaker A: In Macy, we use elliptic curve, diffie hellman encryption. So how precisely this goes well, in order to create the message, user needs to create a comment. The comment contains of user public key, vote option, won't amount, and some other variables that is not important for us today. So when user create a comment, user needs to sign this comment with his public key. And after that, he needs to encrypt the comment and the signature in order to obtain the message. Okay, so in this message, user can have two actions. The first one is to change his public key, and the second one is to change the vote option.
00:04:38.726 - 00:05:18.578, Speaker A: So if we have a user who is blackmailed to vote for option two, but this user really wants to vote for option one, and that user registered with his public key one, he can send two messages. The first one will be to change his public key. His public key. He wants that his public key be public key two. Okay? And the second is to vote to vote for option one. He really wants to vote for option one. Okay, after create comment, he will sign this comment with Public key one, encrypts it and sent to the Macy Smart contact.
00:05:18.578 - 00:05:56.074, Speaker A: When coordinator decrypts the message, he will change the public key of User. User will have public key two and he will add vote for option one. After this, user can send one more message. In the second message, user can vote for option two. Blackmailer wants that this user vote for option two. Okay, he will wrote here in the field that his public key is public key one. And he will sign this comment with Public key one, encrypts it and sent to the Macy's Mark contract.
00:05:56.074 - 00:06:49.310, Speaker A: When coordinator decrypts this message, he will show that the public key that user used for signing the message is not the same as user public key. Okay? So this message will be invalid message, but user can decrypt this message. User can prove to the blackmailer that he really vote for option two, but this message is an invalid message. But the blackmailer could not know that this message is invalid message. Okay, so as we already said before, we use elliptic curve diffie Hellman encryption in Macy. In order to obtain the share key, coordinator needs to multiply his private key with a public key of Voter. Okay, so private key of coordinator is a field number.
00:06:49.310 - 00:07:40.410, Speaker A: It's a number. And the public key of User is point on elliptic curve. The results of multiplication will be the point on elliptic curve, and this point on elliptic curve is a shared key. But when voter wants to decrypt the message, he will multiply his private key with coordinator public key and he will get the same point on elliptic curve. Because here we use very elegant property of elliptic curve. When voting is over, the coordinator enter the scene and the coordinator needs to make zero knowledge proof that he was decrypted all messages and that he update State three correctly. After verification, he needs to create one more zero knowledge proof.
00:07:40.410 - 00:08:38.386, Speaker A: He collects all the votes and make zero knowledge proof with results of voting. And coordinator cannot add some extra vote or censor someone's vote or change vote because he will get the false proof and this is very nice feature and we want to save it. But we saw that the burning problem in Macy was that coordinator can decrypt all the votes. So if we have a malicious coordinator, he can pass on the information and we don't want to have it. So we want to add anonymity in Macy project. How to do that? Well, we need to use Algaml encryption, we need to use randomization, and of course we need to use zero knowledge proofs. So let's start how Algamal encryption works.
00:08:38.386 - 00:09:33.140, Speaker A: When we have a voter and coordinator, in order to obtain their public keys, they need to multiply their private keys with generator point on elliptic curve. So, private keys are field elements numbers and the public keys are points on elliptic curve. When user want to encrypt the message using Algama encryption, he needs to have inputs, that is some random variable x public key of person who will decrypt the data and of course the secret message. In our circuit, we will calculate the big x. The big x is the result of multiplication little x with generator point on elliptic curve. So if someone wants to know little x, he cannot do that. Because we have discrete log problem.
00:09:33.140 - 00:10:43.162, Speaker A: In order to assign our message to point on elliptic curve, we have map to curve problem. This is very hard problem, but in our case it was very simple because we only need to encrypt two states, zero and one. So we can easy have map bijective map that assigned message to the curve point. For example, we use base point and infinity point for this. And after that, in circuit, we need to calculate Me which is the result of adding point M which represent our message to results of multiplication of little x with public key of person who will decrypt the data and the output of the circuit will be Me and big x. When person wants to decrypt this secret message, he needs to calculate little x multiplied by public key. Public key of person who will decrypt the data.
00:10:43.162 - 00:12:07.142, Speaker A: But this person cannot know little x because we had discrete log problem. So he will calculate the result of multiplication of his private key with a big x. He obtained big x so he can calculate this. But here we will get the same result as the result of multiplication of little x with his public key, because we use very elegant property of elliptic curve so this person can decrypt the data. It is very important to note here that here person who decrypt the data don't need to know public key of person who encrypt the data and we don't have it in elliptic curve diffd helman encryption, we also use randomization. We use randomization when we want to convey the same two cipher text, but we don't want to see the link between them. Okay? So the function that randomized this cipher existing ciphertext to another ciphertext is create in such a way that these two ciphertext can be decryptable using the same public key.
00:12:07.142 - 00:13:08.062, Speaker A: And of course, when we decrypt this message, we will get the same message. Okay, how we use all of this stuff? We want to save two nice features that we already had in Macy project. For example, we want to save that person can change his public key and can change his vote because then he can prove to the blackmail that he really vote for option that blackmailer wants to vote. But this message, of course, will be invalid message. And of course we want all the messages all votes be encrypted and stored on chain. But we also want to add we want to add anonymity we want to add that Coordinator cannot see how voters voted. So in order to obtain that, we need to disable Coordinator to see the link between the old and the new public key of a voter.
00:13:08.062 - 00:14:08.314, Speaker A: So we need to have two more messages. The first message will be to deactivate their public key, not to change to deactivate. After that, Coordinator coordinator will add this public key to the set of deactivated keys and encrypted state using Lgaml encryption. In order to generate a public key, person needs to make zero knowledge proof that his old public key belongs to the set of deactivated keys. Okay. And the output of the circle will be the randomized message and nullifiers. It is very important here to note that the nullifiers are important because we need to make sure that user can generate exactly one public key.
00:14:08.314 - 00:14:21.440, Speaker A: So in this way, Coordinator cannot know the link between the old and the new public key. And we add anonymity in Macy. Thank you.
00:14:29.570 - 00:14:40.510, Speaker B: Thank you, Maria. Sorry, maybe one.
00:14:42.800 - 00:14:56.450, Speaker C: Thank you for this insightful presentation. Very interesting. Could you elaborate a little bit more on the practical use cases of this? I mean, which types of votings would you like to process? What is the practical application?
00:14:57.220 - 00:15:12.390, Speaker A: I think that we can use it for some kind of voting in web3, but to be honest, I don't think that we can use it for state voting or something like this.
00:15:18.310 - 00:15:25.270, Speaker C: So do you think this is going to be like a smart contract or does it require some other infrastructure?
00:15:27.050 - 00:15:33.740, Speaker A: Yes, we use smart contracts for verification of the proof. Not only.
00:15:35.470 - 00:15:42.230, Speaker B: Thank you, you can always get in touch with the speaker of the of the floor.
