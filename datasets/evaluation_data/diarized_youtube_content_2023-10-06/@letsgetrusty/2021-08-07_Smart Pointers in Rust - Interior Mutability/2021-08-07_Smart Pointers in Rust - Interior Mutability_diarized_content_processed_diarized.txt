00:00:00.720 - 00:00:53.100, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan, and this channel is all about the rust programming language. Today we're continuing our series on smart pointers in rust, and we'll go over the refcel smart pointer and the interior mutability pattern. So with that, let's get rusty. Interior mutability is a design pattern in rust that allows you to mutate data even when there are immutable references to that data, which is typically disallowed by the borrowing rules to mutate data. This pattern uses unsafe code inside a data structure to bypass the typical rules around mutation and borrowing. Unsafe code is code that is not checked at compile time for memory safety, and we'll learn more about it in chapter 19.
00:00:53.100 - 00:01:45.892, Speaker A: Now, even though the borrowing rules aren't enforced at compile time, we can still enforce them at runtime. And you might ask, why would you want to enforce the borrowing rules at runtime instead of compile time? Well, in just a sec, we'll talk about a practical example of why you would want to do this. But first, I'd like to introduce you to the Refcel smart pointer. The refcel smart pointer represents single ownership over the data it holds, much like the box smart pointer. The difference is the box smart pointer enforces the borrowing rules at compile time, whereas the ref cell smart pointer enforces borrowing rules at runtime. This means if you break the borrowing rules at runtime, your program will panic and exit. The advantage of checking the borrowing rules at compile time is that errors will be caught sooner in the development cycle, and there's no runtime performance costs.
00:01:45.892 - 00:02:27.632, Speaker A: For these reasons, checking borrowing rules at compile time is the default in rust. The advantage of checking borrowing rules at runtime is that certain memory safe scenarios are allowed, whereas they would be disallowed at compile time. This is because certain properties of a program are impossible to detect using static analysis. The most famous example of this is the halting problem, which you can search on YouTube. The Refcel smart pointer is useful when you're sure that your code is following the borrowing rules, but the compiler can't understand or guarantee that. Note that you can only use the Refcel smart pointer in single threaded programs. In chapter 16, we'll learn how to get the same functionality in multi threaded programs.
00:02:27.632 - 00:03:17.702, Speaker A: Let's go over the smart pointers we learned about thus far and talk about their differences. The RC Smart pointer, which stands for reference counting, enables multiple ownership to the same piece of data. On the other hand, the box and Refcell smart pointers allow single ownership to a piece of data. The box smart pointer allows immutable or mutable borrows that are checked at compile time. The RC smart pointer allows only immutable borrows checked at compile time, and the Refcell smart pointer allows immutable or mutable borrows checked at runtime. Now, because the refsel smart pointer allows mutable borrows checked out runtime, you can have a mutable value inside a refcel smart pointer, even if the refcell smart pointer itself is immutable. Contrast this with the box smart pointer.
00:03:17.702 - 00:03:52.532, Speaker A: The box smart pointer allows immutable or mutable borrows checked at compile time. But this means if you want the value inside a box smart pointer to be mutable, then the box smart pointer itself has to be mutable. Mutating a value inside an immutable value is called the interior mutability pattern. Let's see what happens when we try to use the interior mutability pattern with the borrowing rules being checked at compile time. In this first example, we have an immutable variable called a, which is set to five. And then we have a variable called b, which is immutable. Borrow to a.
00:03:52.532 - 00:04:29.784, Speaker A: Here you can see we get some red squigglies, and if we hover over to see the error, you'll see that the error states you cannot borrow a as mutable because it is not declared as mutable. So in this case, the borrowing rules are saying, hey, you can't mutably borrow a because a is immutable, so you can't actually change the underlying data. Let's look at the next example. We have a mutable variable called c, which is set to ten. And then we have a variable called d, which is an immutable borrowed to c. Then on line seven, we're using the dereference operator to change the underlying value from ten to 20. As you can see, we get some red squigglies again.
00:04:29.784 - 00:05:10.438, Speaker A: So let's hover over and see the error. In this case, it states that d is an immutable reference, so the data it refers to cannot be written. As you can see, the barring rules checked at compile time don't allow us to have an immutable reference to mutable data. Now we could solve this with some indirection. So imagine we have a data structure that stores some value, and inside that data structure the value is mutable. But when we get a reference to that data structure, the reference itself is immutable code outside of the data structure would not be able to mutate the data stored within the data structure directly. But you can imagine we could call some methods that would mutate the inner value.
00:05:10.438 - 00:06:01.398, Speaker A: This is called the interior mutability pattern and is essentially what the ref cell smart pointer does. The ref cell smart pointer is a little fancier though, because instead of calling methods to mutate the data, we can call methods to get an immutable or mutable reference to the data. And this works because the refcel smart pointer checks that the references are valid at runtime. Next, let's talk about a use case for the interior mutability pattern. In this scenario, we have a library that tracks a value against a maximum value and sends messages. Depending on how close the value is to the maximum value, this library could keep track of the quota for how much API calls a user is able to make. As an example, our library will only provide the functionality to track how close a value is to the maximum value and what messages to send at what times.
00:06:01.398 - 00:06:37.564, Speaker A: Applications implementing our library are expected to provide the mechanism for actually sending the message, whether it's through email, text, or something else. All right, let's go through the code together. First we have a messenger trait which has one method called send. It takes an immutable reference to self and then a message to send. Then we have a struct called limit tracker with three fields. First we have the messenger field, which is going to be a reference to a generic type, and as you can see up here, the generic type must implement the messenger trait. Also, because we're borrowing t here we have to add a lifetime annotation.
00:06:37.564 - 00:07:17.594, Speaker A: Next we have a value field representing the current value and the max field representing the max value. They are both of type usize, which is a pointer sized unsigned integer type. Now honestly, I'm not sure why these aren't unsigned 32 bit integers or unsigned 64 bit integers, but this is the way the rustbook has implemented it. Next we have an implementation block for limit tracker struct. We have to specify our lifetime and generic again, and we have to make sure that our generic has the same trait bound. Then we have the new function which is our constructor. We pass in a messenger and a max value, and then create a new limit tracker.
00:07:17.594 - 00:07:50.596, Speaker A: Lastly, we have a method called setvalue. We pass in immutable reference to self and the value we want to set. First we set the value, and then we calculate the percentage of the current value to our max. And as you can see, to get the calculation we have to cast our usize types to a floating point number. Then we check the percentage of max. If the percentage of max is equal or greater to 100%, we send a message saying that the user has hit their quota. If we are at 90% or above, we send a message warning the user that their quota has almost been met.
00:07:50.596 - 00:08:22.634, Speaker A: And we also send a warning if we're at 75% or above. Now, let's say we wanted to test our library. Specifically, we want to test that at certain points 75%, 90% and 100% messages are being sent out. We could test this code using a mock object. When we send a message we call self messenger send. So imagine if we pass in a mock messenger object to our limit tracker struct. Our mock messenger object could keep track of how many times the send method was called.
00:08:22.634 - 00:09:12.660, Speaker A: So when we hit these certain points we can assert that the send method was called x amount of times. Recall that the messenger field could be any type that implements the messenger trait, and the messenger trait just requires a one method called the send let's go ahead and implement our tests. First, I'll create a test module. First we'll bring everything from the parent module into scope. Then we'll create our mock messenger. Our mock messenger is going to be a struct with one field called sentmessages, which will store a vector of messages being sent. Then we have an implementation block with one constructor function that creates a new mock messenger and sets the sent messages to an empty vector.
00:09:12.660 - 00:09:51.642, Speaker A: Next we'll implement the messenger trait for our mock messenger. Here, when the send method is called, instead of sending the message, we're simply going to push the message into our send messages vector. All right, the last step is to implement the test. Our test is called it sends an over 75% warning message. First we create a new mock messenger, and then we create a new limit tracker. We pass in a reference to our mock messenger and the max value, which in this case is going to be 100. Then we call limit tracker dot set value and pass in 80.
00:09:51.642 - 00:10:32.248, Speaker A: Now, because our max is 100, passing in 80 means that we're at 80% of our quota. So we should see a new message being sent. And that's exactly what we assert online. 69 we assert that send messages length is equal to one because we should have one message. Now, I went ahead and saved this file and if I scroll up you can see we get some red squiggly lines inside our messenger implementation for mock messenger. If I hover over you can see that the error message states we cannot borrow self dot sendmessages as mutable because it's behind an immutable reference. Here inside the send method, we're taking an immutable reference to self.
00:10:32.248 - 00:11:19.084, Speaker A: Self in this case is our mock messenger struct. And because we're taking an immutable reference, that means any fields inside the struct have to be immutable as well. So here when we call sendmessages pushed, this is not allowed because this WoulD be mutating the vector. Now, if I hover over the error again, you'll see we get a suggestion here which says consider changing this to be immutable reference. What this is telling us to do is instead of taking an immutable reference to self, to take a mutable reference to self. But this gives us another error, and if I hover over the red squigglies, you can see that we have an incompatible type error. Remember that the messenger trait requires that we have a function called senditive that takes an immutable reference to self, so we can't have it be a mutable reference.
00:11:19.084 - 00:11:55.440, Speaker A: So we find ourselves in a predicament. We need a mutable reference so we can modify the send messages field on our mock messenger struct. However, we can't get immutable reference in this function because that would break the function signature of send, which is defined in our messenger trait. In this situation, we can use the interior mutability pattern. Specifically, we can wrap send messages inside a Refcell smart pointer. The first thing we'll do is scroll to the top and bring refcel into scope. Then, for the sentmessages field, we'll wrap our vector of strings inside a refcel smart pointer.
00:11:55.440 - 00:12:33.666, Speaker A: Next, we'll need to update our constructor function. Here we're constructing a new refcel smart pointer and passing in our empty vector. Now we can update our send method implementation. Sendmessages is now our Refcell smart pointer, and it's immutable. But we can get a mutable reference to the value stored inside our smart pointer by calling borrow mute. Then we can call the push method on our mutable reference and append the message. Now that our send method is working, the last thing to do is update the test.
00:12:33.666 - 00:13:15.110, Speaker A: Now again, here send messages is our ref cell smart pointer, but we want to get the length of the vector stored inside of our smart pointer. And in this case, we don't need a mutable reference, we can simply get an immutable reference. And to do that we'll call borrow. And there you go. We took care of all the compiler errors, and if we open up a terminal and run cargo test and scroll up, you can see that our test is passing. Now recall that I said the refsal smart pointer checks the borrowing rules at runtime, and one of the borrowing rules is that we can't have two immutable references at the same time. So let's see what happens when this is the case.
00:13:15.110 - 00:14:08.120, Speaker A: Here I've created two variables that take immutable reference to sent messages. Then I push the passed in message using the first mutable reference and and then also using the second mutable reference. Notice that we don't have any compile time errors even though we have two mutable references, which is not allowed. But let's see what happens when we run cargo test again. As you can see, our test failed, and if I scroll up, you can see the thread panicked with the following message already borrowed on line 60 and on line 60 is when we take our second mutable reference, which is not allowed to. The interior mutability pattern gives us flexibility, but we have to be careful and make sure that our code abides by the borrowing rules. Also note that because we're checking the borrowing rules at runtime, this does result in a small runtime performance hit.
00:14:08.120 - 00:14:56.572, Speaker A: The last thing I want to cover is combining the RC or reference counting smart pointer with the refcel smart pointer to get multiple owners of mutable data. Recall the cons list we implemented when we talked about the RC smart pointer. We used RC because we wanted to have two lists that both share a third list like so. Also recall that we couldn't change values inside our lists once they were created because RC only stores immutable values. In this updated example, we could update values inside our list after they have been created with the use of the refcel smart pointer. Here inside our listenum we have a cons variant that stores an integer and another list. Both the list and the integer are wrapped in the RC smart pointer because we want them to have multiple owners.
00:14:56.572 - 00:15:38.950, Speaker A: Our integer value is additionally wrapped in the ref cell smart pointer because we want it to be mutable. Down here we bring our variance and smart pointers into scope so we can use them in main first, we create a variable called value, which is going to be an integer of five, and we wrap it in a rough cell smart pointer and then an RC smart pointer. That way we can mutate it and it could have multiple owners. Then we create our first cons list called a. A is going to be a cons variant and for the value we're going to clone our value variable defined above. We want to use clone here because we want our value variable and our a list to both own the value. This list is only going to have one element, so we simply put nil here.
00:15:38.950 - 00:16:42.126, Speaker A: We also store the cons variant in an RC smart pointer because we want list b and c to reference a. Then we create list b and c, which store the values three and four respectively, and reference list a. After we create our lists, we're updating value, and here we're using the automatic dereferencing feature which will automatically dereference Rc into Refcell. And then we call borrow mu on refcell to get immutable reference, and then the dereference operator so we can actually modify the underlying value by adding ten to it. Now at this point, the integer stored inside a value should be 15, and recall that we're passing value into our A list, and then b and c both reference a. Finally, at the bottom here we print all three of our lists, so let's run our program and see what we get. And as you can see, because a has a reference to value and b and c reference a, when we updated value, the update appears in all three lists.
00:16:42.126 - 00:16:53.030, Speaker A: That's it for this video. If you enjoyed it, make sure to smash that like button. And if you want to see weekly rust content, make sure to hit subscribe. So with that, I'll see you in the next one.
