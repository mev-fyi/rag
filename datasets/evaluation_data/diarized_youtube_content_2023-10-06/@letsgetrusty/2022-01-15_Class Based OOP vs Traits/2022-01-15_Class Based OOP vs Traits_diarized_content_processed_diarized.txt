00:00:00.320 - 00:00:57.617, Speaker A: In today's video we'll be comparing class based object oriented programming as implemented in Java with the trait system in Rust. In object oriented programming we use objects to group data and procedures that operate on that data. In Java, classes are used to store data in the form of class variables and procedures in the form of class methods. In Rust, structs and enums are used to store data and and implementation blocks are used to store functionality related to that data. In Java, constructors are used to define how a class should be instantiated and then the new keyword is used to actually instantiate a class. Rust does not have the notion of constructors. You can instantiate a struct or enum directly, or if you don't want to expose the data inside your enum or struct, you can create a constructor like function and the idiomatic way to do this is to create an associated function AKA a static method called new.
00:00:57.617 - 00:01:32.705, Speaker A: The new function will return an instance of your struct or enum and then you can use the new function directly to create new instances. In Java you have access modifiers such as public or private, and in Rust you have the same thing. Except in Rust most things are private by default, so in order to make something public you simply use the pub keyword. In Java you can share data and functionality through inheritance. Let's say we had two classes, human and dog. They both share the same data and functionality. They both have a name and an age, and then they both have get methods for name and age.
00:01:32.705 - 00:02:10.383, Speaker A: We can reduce duplication by creating another class called animal, moving name, age, get name and get age into animal and then have human and dog inherit from animal. In Rust we can't share data in a similar way. However, we could share functionality by using traits. We can create a new trait called animal with two methods, get name and get age. Then we can implement animal for human and for dog. We can have default implementations inside our trait. For example, we can change get name to return no name by default and that could be overwritten by structs implementing the animal trait.
00:02:10.383 - 00:02:49.191, Speaker A: We can also create a dependency relationship by using super traits. For example, we can create a new trait called pet with one method called show affection. We want to ensure that any type implementing the pet trait also implements the animal trait. So we can make animal a super trait of pet. And although we're using one super trait, in this case, we can add as many super traits as we'd like. Lastly, let's talk about polymorphism, which is the ability to substitute one object for another, as long as they both have certain characteristics. Let's say we wanted to write the function print animal name, which will take an animal and then called the get name method.
00:02:49.191 - 00:03:12.835, Speaker A: In Java, this is straightforward. We simply create our function pass in an animal and then call get name. Then we can call our function with either a dog or a human. In Rust, we have two options. We could either use generics with trait bounds, or we could use trait objects. First, let's explore generics. We'll create a function called print animal name, which will take one generic type parameter.
00:03:12.835 - 00:03:54.191, Speaker A: At this point, we won't be able to call get name because T could be any type. So let's restrict the type by saying that T must be something that implements the animal trait. Now we're able to call our function and pass in either a dog or a human. With this approach, at compile time, our generic print animal name function will be transformed into two concrete functions, one for dogs and one for humans. More generically, a concrete function will be created for every concrete type we pass into this function. Because of this process, the big downside is you must know all the concrete types that will be passed into this function at compile time. This is not always possible.
00:03:54.191 - 00:04:33.289, Speaker A: For example, imagine we had a library which exposed the animal trait so that other developers can implement custom animals. In that scenario, we would have no way of knowing what concrete types implement our animal trait. Because of this, we would want to use trait objects. Trait objects are specified using the DIN keyword and must be behind some type of pointer. In this case, we'll use a reference. The DIN keyword stands for dynamic dispatch, which means that your program will figure out which concrete method to call at runtime instead of compile time. Now that our function is updated to use a tray object, we simply have to update the call sites to pass in the borrowed form of our dog and human.
00:04:33.289 - 00:05:09.557, Speaker A: Another scenario where tray objects are needed is is when you want to use multiple concrete types at the same time. For example, let's say we wanted to create a vector of animals. In Java, we would simply instantiate a vector where the type is the animal class. So we can store anything that's an animal or any class that inherits from animal. In Rust, we would do something very similar, except our vector will hold animal trait objects. In summary, if you don't know all the concrete types that will be used at compile time, or, or if you need to use multiple concrete types at the same time, then use a trait object. Otherwise, you can use generics with trait bounds.
00:05:09.557 - 00:05:27.945, Speaker A: Alright, that's it for this video. If you enjoyed it, make sure to hit the like button. And if you want to see weekly Rust videos, make sure to hit subscribe. Lastly, and most importantly, get your free Rust cheat sheet by heading over to letsgetrusty.com cheatsheet and with that said, I'll see you in the next one.
