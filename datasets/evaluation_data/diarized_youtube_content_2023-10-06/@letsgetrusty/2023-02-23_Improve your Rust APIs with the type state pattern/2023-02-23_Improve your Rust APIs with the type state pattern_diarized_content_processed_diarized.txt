00:00:00.320 - 00:01:01.657, Speaker A: In this video, I'm going to show you how to make your rust APIs 10 times better by leveraging Rust's amazing type system. Specifically, we'll talk about using generics and zero size types to prevent consumers of your API from misusing it. Also, I'll walk you through a real life example step by step so you can apply this technique to your own code. Before we get started, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com for forward slash cheat sheet Imagine we are building a library for a Password Manager. We expose one public struct named Password Manager, which contains two private fields, a master password, and a hash map of usernames and passwords. We've also added some functionality to make Password Manager useful a constructor function idiomatically named New the unlock and lock methods, a method to list passwords, a method to add passwords, a method to get the encryption algorithm used, and a method to get the version of the Password Manager.
00:01:01.657 - 00:01:41.775, Speaker A: With the API of our Password Manager defined, let's see an example of how it will be used. First, we create a new instance of Password Manager. Then we unlock the manager by passing in the master password, list the passwords in the Password Manager, and finally lock the manager again. This is how the API is supposed to be used. Before listing passwords, we must first unlock the manager, and once the manager is locked, we can no longer list or add passwords. However, there's nothing preventing users of this API from misusing it. For example, we can call these functions out of order, or we can call functions consecutively even though it doesn't make sense.
00:01:41.775 - 00:02:36.775, Speaker A: As you can see, the code still compiles, which is a problem because we don't want users of our API to run into runtime errors or unexpected results when using our API. What we want to do is encode our API with the notion that Password Manager has two states, a locked state and an unlock state. These states have different functionality. For example, when the Password manager is locked, you should be able to call unlock, but you should not be able to call lock list passwords or add password. Conversely, if the Password Manager is unlocked, you should be able to call lock, list passwords, and add password, but you should not be able to call unlock. There is also some functionality that you should be able to call in both states, in this case the encryption and version method. Now that we know what the problem is and what information we'd like to encode, let's go over some solutions.
00:02:36.775 - 00:03:16.341, Speaker A: The first solution is to add some extra state to the password manager. In this case, we can add a new field called locked, which is going to be a boolean. Then in the constructor we'll set locked to true. Then when unlocked is called, if the password matches the stored master password, we can set locked to false. Finally, inside the list passwords and add password method, we could check if locked is set to false. If locked is true, then we need to do some error handling. We could do this in two ways.
00:03:16.341 - 00:03:58.485, Speaker A: The first way is to simply panic, which is not ideal because we don't want the program to crash just because the user called list passwords by mistake. The second option is to change the signature of these functions to return a result type. Then if locked is true, we can simply return an error. This approach is not ideal for a couple of reasons. First of all, it complicates the API. In the case of list passwords, instead of returning a simple hash map, it now returns a result type, which forces users of the API to understand why this function could potentially error. Second of all, all the methods in this API are shown to the user regardless if the password manager is locked or unlocked.
00:03:58.485 - 00:04:55.045, Speaker A: For example, after creating a new Password manager instance, if I try to check the available methods, I could see that add password and list passwords are available even though the password manager is in a locked state. Ideally, these methods should not even be listed unless the password manager is unlocked to prevent confusion. The issue with the current solution is that it uses runtime checks, so calling list passwords on line 47 won't give us any compile time errors. We would only notice a problem at runtime. To address these issues, let's explore a compile time solution. Instead of having one password manager struct, imagine if we had two structs, a locked password manager and an unlocked password manager. Then we can define two separate implementation blocks.
00:04:55.045 - 00:06:32.711, Speaker A: The locked password manager will contain a constructor function and the unlock method, which will return an unlocked password manager. It will also contain the encryption and version methods. However, we'll move the lock list passwords and add password methods to the unlocked Password Manager implementation block, and we'll implement the lock method which returns a locked password manager. Unlocked password manager also has to implement the encryption and version methods, as those methods are common to both structs. Now that our API is updated, let's see how it would be used in main. First, we'll update Password Manager to locked Password Manager. This automatically gives us an error on line 66 because the list passwords method is not available on locked Password Manager.
00:06:32.711 - 00:07:22.901, Speaker A: If we take a look at the available methods, the only methods that are available are encryption, version, and unlock. This is great because users only have access to methods which make sense in the locked state. Let's go ahead and fix this code by calling Unlock first. We'll also save the return value of unlock in a variable called manager, which will shadow the original Manager variable. Now that Manager points to an unlocked password manager, we can call list passwords on line 67. We cannot, however, call unlock on line 68 because we already have an unlocked manager. We get one last compile time error on line 68 because we're calling lock, which requires a mutable reference to self.
00:07:22.901 - 00:08:05.859, Speaker A: However, we have an immutable manager instance. Let's go ahead and update the lock and unlock methods to consume self. Great. We now have an API that prevents users of the API from misusing it at compile time. But this solution is still not ideal for a couple of reasons. Notice that there's quite a bit of duplication going on. Both of these structs contain the same fields, and we need this to be the case so that this information is preserved between state changes.
00:08:05.859 - 00:08:54.999, Speaker A: Both structs must also implement functions that are common between both states, in this case encryption and version. We want to preserve these nice compile time checks without the need for all this duplication. Rust allows us to achieve this using generics and zero size types. First, let's revert back to using one struct called Password Manager. We'll also create two unit structs to represent the locked and unlocked state. Next, we'll add a generic parameter to the Password Manager struct called state, and default it to locked. We now get a compile time error which says the state parameter is never used.
00:08:54.999 - 00:09:38.713, Speaker A: Consider removing state, referring to it in a field, or using a marker such as phantom data. In this case, we want to go with option three and use phantom data. So we'll add a new field called state and set it equal to phantom data. Our struct is now error free. But what exactly did we just do? First, we added a generic parameter called state. When we create new instances of Password Manager, we must replace this generic parameter with a concrete type which defaults to the locked struct, but it could also be the unlocked struct. This is beneficial because a locked password manager does not equal an unlocked password manager.
00:09:38.713 - 00:10:08.229, Speaker A: These are two distinct types, which means we can implement different methods on each type, which will do in just a second. The cool thing about this approach is that we were able to create distinct types without needing to create a separate struct for each type. However, adding a generic parameter causes a problem. We have to use the generic parameter somewhere within our struct. The thing is, we don't really care about this generic parameter. We're only using it to create distinct types. That's where phantom data comes in.
00:10:08.229 - 00:10:46.299, Speaker A: Phantom data is a zero size type used to mark things that act like they own t, which in this case is state. By using phantom data Data on line 13, Password Manager will act like it stores state in the state field. However, at compile time, this field will actually be optimized away. That's why phantom data is called a zero size type, because it takes up no space. We could go without using phantom data and simply store state in the state field and never use the state field. However, that would just be wasting memory. All right, now that we have our Password Manager struct defined, let's update the implementation blocks.
00:10:46.299 - 00:12:29.785, Speaker A: First, we'll change locked Password Manager to a Password Manager where state is set to locked and the only method we'll put in this block is unlock. We'll also update this method to return an unlocked Password Manager. Next, we'll update Unlocked Password Manager. This implementation block will contain three methods. Lock list passwords and add password. We'll move encryption and version to a separate implementation block. Finally, we'll create one more implementation block with a constructor function.
00:12:29.785 - 00:13:32.653, Speaker A: Alright, let's go through the implementation blocks together, starting from the top. This implementation block only applies to locked password managers. Locked password managers get a method called unlock, which gives you an unlocked password manager. This implementation block only applies to unlocked password managers. Unlocked password managers get access to three lock list passwords and add password. This next implementation block uses a generic instead of a concrete type, which means these methods will be available for all instances of Password Manager, no matter what the concrete type of state is. This final implementation block contains our associated functions, which in this case is just the new constructor function.
00:13:32.653 - 00:14:05.415, Speaker A: With that, we're done implementing Password Manager. Let's go ahead and update main. We'll simply change Locked Password Manager to Password Manager. When we first construct a Password Manager, it defaults to a locked Password manager. So if we look at the methods available, they are unlock, Encryption, and Version. Then after calling unlock, we get an unlocked password manager. If we check the methods available, you could see they are Add Password List, Passwords, Lock encryption, and version.
00:14:05.415 - 00:14:34.375, Speaker A: Congratulations. You now know how to use generics and zero size types to make it impossible for users to misuse your rust APIs and are one step closer to becoming a Rust station. Before you go, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheatsheet if you enjoyed this video, make sure to give it a like and subscribe to the channel for weekly Rust content. With that said, I'll see you in the next one.
