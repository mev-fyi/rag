00:00:00.400 - 00:00:46.061, Speaker A: In this video, I'll give you an overview of Rust by describing the unique features which make Rust special. Those features are performance, memory safety, the powerful type system, polymorphism with traits, and generics, extensibility with macros, and building and package management. Let's go through these features together, starting with performance. Rust is fast. In fact, its performance is on par with C and C. But what makes Rust fast? Rust has a minimal runtime, which means there isn't a bunch of extra code bundled with your program. Rust also provides zero cost abstractions, meaning you get to use higher level programming features like generics, iterators, and so on without incurring a runtime cost.
00:00:46.061 - 00:01:21.425, Speaker A: Finally, Rust does not have a garbage collector, which means your programs will have predictable runtime performance. Rust is also memory safe thanks to a set of rules regarding owning and borrowing values. These rules are enforced at compile time to make sure memory safety is not violated. First, let's talk about the ownership rules, which state that each value in Rust has a variable called its owner. There can only be one owner at a time, and when that owner goes out of scope, the value will be dropped. These rules prevent double, free and use after free errors at compile time. Let's take a look at an example.
00:01:21.425 - 00:01:57.883, Speaker A: In this example we see a variable named Ben defined within an inner scope. Ben owns an instance of employee. After the println statement, the interscope ends and Ben goes out of scope, which means that it will be dropped and the employee instance will automatically be cleaned up. If we tried to print Ben's name after the interscope ends, we would get a compile time error. The ownership model allows Rust to automatically clean up memory for us and prevents us from using memory after it has been cleaned up. Here's another example. This time we have an additional variable named Bento which is set equal to Ben.
00:01:57.883 - 00:02:33.879, Speaker A: We then print out Bento name. Let's see what happens if we uncomment the other print line statement, we get a compile time error stating that we are trying to use a moved value. Remember, ownership rule 2 states that there could only be one owner at a given time. When we set Ben 2 equal to Ben, ownership of the employee instance was moved from Ben to Bend 2 and Ben was invalidated. In other words, Rust has move semantics by default. However, sometimes it's useful to have multiple variables own a single value. Fortunately, this is possible in Rust using a reference counting smart pointer.
00:02:33.879 - 00:03:27.349, Speaker A: By wrapping Employee with an instance of the RC smart pointer, we are explicitly opting into multiple ownership, which has an additional runtime cost Managing the reference count Next, let's talk about borrowing. The borrowing rules state that at any given time you could either have one mutable reference or any number of immutable references, and references must always be valid. These rules prevent data races and dangling references at compile time. For example, here we have the variable ben again and three immutable references, which are called borrows in Rust to indicate that we are borrowing a value instead of taking ownership. If we try to make one of these references mutable, we would get a compile time error because mixing mutable and immutable references can potentially cause data races. If we comment out the immutable references, our code compiles again. Let's take a look at another example.
00:03:27.349 - 00:03:55.783, Speaker A: This time we have a function called createemployee, which takes a name and returns an employee instance. Currently, the function returns an own type. Let's change it to return a reference instead. This results in a compile time error. The error states that we cannot return a reference to a local variable. The employee variable inside the function will be dropped at the end of the function, which means the reference returned will be pointing to invalid memory. This is called a dangling reference.
00:03:55.783 - 00:04:28.855, Speaker A: Luckily, Rust prevents us from doing something potentially catastrophic. The solution in this case is to return an own type. As you can see, the ownership and borrowing rules prevent us from violating memory safety, and the excellent error messages tell us exactly what we need to fix. Another great Rust feature is its powerful type system. Firstly, Rust offers immutability and privacy by default. Variables are immutable by default, unless explicitly marked as mutable with the mute keyword. In Rust, almost everything is private by default.
00:04:28.855 - 00:05:00.533, Speaker A: In this example, we get errors because employee is defined inside a module but not marked as public. To fix the errors, we have to make the employee struct public using the pub keyword. We also have to make sure each field in the employee struct is public. Next, let's talk about some of the types in the Rust standard library. One thing you might be surprised to learn is that Rust does not have the concept of null values, infamously called the billion dollar mistake. Null values have caused developers pain for many years. Fortunately, Rust has a solution.
00:05:00.533 - 00:05:37.505, Speaker A: In Rust, optional values are expressed with the option enum, which could either be the none variant or the sum variant containing the underlying value. In this example, we have a function called getuser, which takes a user ID and returns a user instance. Inside the function, we check if a user for the given ID exists. If so, we return a user instance. If not, we need to return a value indicating that a user could not be found. In other languages, you might return null in this case. However, one of the issues with using null is by looking at the function signature, the caller has no idea that the value returned may be null.
00:05:37.505 - 00:06:03.125, Speaker A: In Rust, null is not a valid keyword. Instead, we can return an option enum containing a user instance. The function signature makes it clear that the returned value may be empty inside the function. If a user is found, we return the user wrapped in the sumvariant. Otherwise, we return the none variant. When this function is called, the return value cannot be used as if it were a user instance, because it's not. It's an optional type.
00:06:03.125 - 00:06:40.509, Speaker A: Instead, the caller has to check if the returned optional is the sumvariant or the non variant. As you can see, the type system in Rust forces us to be explicit about optional values. Rust also forces us to be explicit about error handling. Rust has two categories of errors, recoverable errors and unrecoverable errors. For unrecoverable errors, developers can use the Panic macro, which will immediately exit the program. For recoverable errors, the result enum is used. The result enum has two variants, the OK variant, which contains the result of an operation, and the error variant, which contains an error type.
00:06:40.509 - 00:07:14.283, Speaker A: Some languages use exceptions for error handling. In this example, we have a function called Purchase, which accepts a customer and item as input, and returns a receipt. If the item is alcohol and the customer is under 21 years of age, an exception is thrown. One reason this style of error handling is problematic is that the caller of this function has no idea an exception could be thrown. By looking at the function signature. In Rust, we could use the result enum instead. The function signature now clearly indicates that this operation may fail if the customer is under age.
00:07:14.283 - 00:07:58.457, Speaker A: One option is to return an error message in the form of a string. Alternatively, we could return a custom error type, which the caller can react to. Programmatically, calling the purchase function returns a result enum which has to be checked to see if it's the OK variant or the error variant. This forces the caller to explicitly handle the error case. Here we print out the item's name in the success case and print out that the purchase was unsuccessful in the error case. Callers could also choose to call unwrap on the result enum, which will return the value stored inside the OK variant or Panic if the returned value is the error variant. This is especially great for quick prototyping, and when you're ready to make your code more robust, you can simply search for all the unwrapped calls.
00:07:58.457 - 00:08:35.595, Speaker A: One great aspect of Rust is the functional features it provides. Pattern matching is something we've already seen when talking about the option and result enums. Pattern matching is a control flow mechanism that allows us to match against types and execute code paths based on patterns. This is especially useful when dealing with enums. In this example we have an enum called role and a function called caneditdocument inside the function. We match on the role instance passed in and return true if the role is admin or editor and false otherwise. Match expressions are exhaustive, meaning all possible values must be accounted for.
00:08:35.595 - 00:09:06.137, Speaker A: Rust also supports closures which are similar to functions but could be stored in variables and passed around like regular values. In this example, we create a closure and assign it to the variable adder. We can then call adder like a regular function. Finally, in Rust you will see iterators and combinators used frequently. In this example we have a vector of strings representing students and their grades. Let's say we want to convert these strings to student structs and filter out all students with a GPA below. 3.5
00:09:06.137 - 00:09:44.769, Speaker A: first we need to call the iter method to turn our vector into an iterator. Then we use the map combinator which will call a closure on each value in the iterator. Inside the closure, we parse the string into a name and GPA and return an optional type containing a student struct or the nonvariant. If parsing fails, then we call flatten to remove the nonvariants filter to filter out students with a GPA below 3.5 and finally collect to turn the iterator back into a vector. The final result is a vector of student structs. The best part is because Rust has zero cost abstractions, using this approach is just as fast as using a loop.
00:09:44.769 - 00:10:20.423, Speaker A: Next, let's talk about user defined types. Rust does not have the notion of objects or classes. Instead, user defined types are represented as enums or structs. Enums in Rust are powerful because variants can contain structured data. In this example we have an enum called command with three variants, Quit, which doesn't contain any extra data, Move, which contains an x and y coordinate, and Speak, which contains a string. Instantiating enums is straightforward. In Rust there is only one way to create an instance of a user defined type, name it and initialize all of its fields at once.
00:10:20.423 - 00:10:57.219, Speaker A: You can also add functions and methods to enums using an implementation block. In this case we added an execution method which can be called on each instance, structs are the other user defined type. In Rust, structs contain fields which could be any type, including enums and other structs. In this example, we have a struct representing a player in a video game. To create a new player instance, we simply name it and initialize all of its fields at once. Just like enums, we can add functions and methods to structs by defining an implementation block. In this case, we added a function called new, which acts as a constructor function.
00:10:57.219 - 00:11:31.667, Speaker A: The function takes a name and returns a new instance of player with default values for level and health. We can then create a new player instance by calling the new function. Next, let's talk about polymorphism with generics and traits. Polymorphism is the ability to substitute multiple objects for each other if they share certain characteristics. Some languages achieve this through inheritance. However, Rust does not support classical inheritance as it often leads to sharing more code than necessary, making code inflexible. Instead, Rust achieves polymorphism through generics and traits.
00:11:31.667 - 00:12:10.705, Speaker A: First, let's look at traits. In this example, we have a struct called Player with one method called dealdamage, which returns the amount of damage a player can deal in battle based on their level. Imagine that we also defined a struct for non playable characters who can deal damage. If we wanted to create a function that handled characters that could battle, we would need a way for that function to accept both players and NPCs. With languages that support classical inheritance, you would create a base class that player and NPC would inherit from. But in Rust we can define common functionalities using traits. We'll create a trait called Battle, which has one method called dealdamage.
00:12:10.705 - 00:12:41.801, Speaker A: Traits are similar to interfaces in other languages such as Java. Notice that the method has no body. User defined types implementing this trait are responsible for implementing the method body. However, we could provide a default implementation for convenience. This can also help reduce duplication. We can now change Player's implementation block to an implementation block for the Battle trait. We can do the same thing for npc, except for npc, we can use the default implementation of Deal damage, so we'll leave the implementation block empty.
00:12:41.801 - 00:13:10.461, Speaker A: Now we can create an instance of Player and NPC and add a function called Attack which accepts a generic type with a traitbound. Traitbounds impose constraints on generics. In this case, the generic must be a type that implements the battle trait. We can then call attack and pass in our Player instance or NPC instance. Let's look at another way Rust achieves polymorphism. Here we see the player struct again. This time we want to add a new field to player representing the items a player is carrying.
00:13:10.461 - 00:13:55.591, Speaker A: We can use a vector, but what type should the vector store? Because items could be different types, we might consider using a generic, creating an item trait and adding a trait bound to the generic. Unfortunately, this will not give us the result we want because generics are replaced with concrete types at compile time, which means we must know all possible concrete types at compile time. In this case, we don't know which items a player will hold until runtime. Another problem is currently the vector can only store one concrete type, but we want the ability to store a variety of items as long as they implement the item trait. To accomplish our goal, we can use another tool. Rust provides for polymorphism called trait objects. Here we're using the box smart pointer, which means that items in the vector are stored on the heap.
00:13:55.591 - 00:14:24.599, Speaker A: The DIN item syntax is used to identify trait objects. DIN is short for dynamic dispatch, meaning that the concrete types will be figured out at runtime. This means we will incur a slight runtime cost, but we're trading that off for flexibility. As you can see, Rust provides several tools to achieve polymorphism. Another powerful Rust feature is the ability to extend the language with macros. Macros are a type of metaprogramming. They allow you to write code which generates more code.
00:14:24.599 - 00:14:57.221, Speaker A: Macros are useful for reducing duplication and introducing syntax that is not natively supported in Rust. For example, here we define and populate a hash map of team scores. We can make this code less verbose by using a macro. Here we're using a macro called map, which allows us to create and populate a hash map at the same time. Also, notice the arrow syntax. This syntax for creating hash maps is not natively supported in Rust, but thanks to macros, we are able to extend the syntax. Let's take a look at a more realistic example.
00:14:57.221 - 00:15:27.985, Speaker A: Here we have a simple web server implemented using the Rocket framework. It takes over 300 lines of code, so much code that it could not fit on the screen. Let's see this exact same example using macros. This time our simple server takes up 11 lines of code, including white spaces. On line three, a macro is used to define an HTTP GET route, which takes a name and age as URL parameters. And on line eight, a macro is used to set up the Rocket framework infrastructure. As you can see, macros can be extremely powerful.
00:15:27.985 - 00:15:54.677, Speaker A: Next, let's discuss building and package management in other languages such as C. This is a big Pain point. Rust, on the other hand, makes it easy. Rust comes with a standard build tool and package manager called Cargo. Similar to NPM, which is used for JavaScript projects. Cargo makes managing Rust projects straightforward. Dependencies are defined inside a configuration file called Cargo toml along with other information about your Rust project.
00:15:54.677 - 00:16:36.304, Speaker A: You can create a new Rust project by running Cargo New Run your app with Cargo Run Test your app with Cargo Test, and publish your app to Crates IO With Cargo Publish. All of these CLI commands are available to you out of the box. Crates IO is a public registry for Rust packages, similar to the NPM registry for JavaScript. Here you can find community built libraries for your project or upload your own projects. These features in combination are what make the Rust programming language special. If you enjoy this video, make sure to share it with a friend and subscribe for more Rust content. Lastly, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com
00:16:36.304 - 00:16:40.435, Speaker A: CheatSheet with that said, I'll see you in the next one.
