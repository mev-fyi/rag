00:00:00.520 - 00:00:45.987, Speaker A: Rust stole C's three best features. In this video, I'll cover exactly what these features are and more importantly, how the Rust creators innovated on top of these features. At the end, I'll also explain the biggest limitation Rust has to overcome in order to truly compete and potentially replace C. The first feature Rust stole from C is, ironically, the resource management model. When C was first introduced, the creator Bjorn Strawstrup came up with an extremely useful design pattern called raii, which stands for Resource Acquisition is initialization. The idea is that resources like heap allocated memory, database connections, and file handles should be tied to the life cycle of objects. When an object is created, it should acquire the resources it needs.
00:00:45.987 - 00:01:21.055, Speaker A: This is done in the object's constructor function, and when the object is destroyed, the resource should be released. This is done in the object's destructor function. This design pattern leads to reliable resource management, cleaner code, and most importantly, it reduces the risk of resource leaks. That's why it's used throughout the C standard library. In fact, OfStream already implements RAII internally, so we can use it directly to manipulate files. To automatically clean up heap allocated memory, we can use the unique smart pointer from the standard library and to automatically manage database connections. We can use third party libraries.
00:01:21.055 - 00:01:56.691, Speaker A: Raii is so useful that Rust took this design pattern and made it a core part of the language. Similar to C, the Rust standard library extensively uses raii. We can manipulate files and the handle will automatically be released. The box smart pointer is used to automatically clean up heap allocated memory, and we can manage database connections using third party libraries. But Rust doesn't stop there. It provides two major improvements on top of the traditional RAII pattern in C. First, unlike C, Rust prevents you from accidentally shooting yourself in the foot.
00:01:56.691 - 00:02:45.065, Speaker A: In C, you can bypass the RAII pattern and allocate memory manually using the new and delete operators. This can lead to mistakes like use after free errors if you attempt to access a pointer after calling delete, double free errors if you accidentally call delete twice, and resource leaks if you forget to call delete. These bugs can and do compromise the stability, security and performance of software. Microsoft famously reported that 70% of vulnerabilities found in their products were caused by memory safety bugs. Rust avoids these pitfalls because it doesn't have operators like new and delete. It only allows you to allocate resources using RAII constructs. The second major improvement Rust provides on top of the traditional RAII pattern is automatically managing references to data.
00:02:45.065 - 00:03:49.445, Speaker A: In Rust, the compiler enforces the validity of references When a value is deallocated, the compiler will prevent any references to that dealloc allocated value from being used again by performing compile time checks. This means references are guaranteed to point to valid memory, so you don't have to worry about infamous bugs like null pointer dereferences, use after free errors and data races. The RAII pattern in Rust is called the ownership model, and the extra compile time checks that ensure the validity of references is called the borrowing model. Together they ensure that resources are automatically cleaned up and references are always valid, eliminating an entire class of memory safety bugs. The second feature rustole from C is the principle of zero cost abstractions. This principle can be summarized with the following phrase what you don't use you don't pay for, and what you do use you couldn't have hand coded any better. This means that high level abstractions like generics and collections should not impose any runtime overhead or performance penalties compared to code.
00:03:49.445 - 00:04:33.765, Speaker A: Using low level abstractions like loops and counters, this leads to a great developer experience while preserving lightning fast performance. In this C example, we create a vector of integers and then use a for loop to find the greatest element in the vector. This code includes loop initialization, condition checking and element comparison, making it less readable and more prone to errors. By using the Iterator abstraction in C, this code becomes a lot simpler. Now we just have to call the max element function in the standard library. The iterator abstraction encapsulates iteration and comparison logic, making the code cleaner, more concise, and less error prone without sacrificing performance. Here's how we would write the same code in Rust.
00:04:33.765 - 00:05:32.033, Speaker A: First we turn a vector into an iterator by calling the iter method, and then we find the greatest element by calling the max method. In this example we're actually using a few zero cost abstractions, the first one being the iterator abstraction. The second one is the option enum, and the third is pattern matching. The beautiful thing about Rust is that it builds on top of the zero cost abstraction principle by further emphasizing memory safety and thread safety. For example, if we go back to the C example and call the max element function with an empty vector, it would lead to undefined behavior because we would get back an object that is not safe to dereference, but in the next line we are attempting to dereference it. In Rust, on the other hand, the max method returns an option type, so if we call it on an empty vector, it would simply return the none variant. The option type forces us to check whether the return type is the sum variant or the none variant, which makes our code a lot more robust while preserving blazingly fast performance.
00:05:32.033 - 00:06:05.655, Speaker A: The third feature rustole from C is generic programming. In C, generic programming is implemented through templates. Templates allow you to write code that works with any data type, providing flexibility and reusability. This template function, called print, takes a single parameter of generic type T. The generic is also constrained by the printable concept. Concepts in C define requirements that a type must satisfy. In this case, for a type to be considered printable, it must be able to output to stdout, and the operation must return a reference to ostream.
00:06:05.655 - 00:06:44.147, Speaker A: By using this concept as a constraint on the generic type T, the print function ensures that it will only be instantiated for types that can actually be printed. Rust took the idea of generics and modernized it In Rust we have generics, which are inspired by C templates, but with two key improvements. First, notice the clean and concise syntax. Rust generics are more intuitive and easier to read. Second, Rust integrates generics tightly with its trait system. In this example, we're explicitly stating that the generic T must implement the display trait. This is similar to C concepts, but it's been a part of Rust from the very beginning.
00:06:44.147 - 00:07:42.449, Speaker A: Because generics and traits are tightly integrated in Rust, you'll get clear error messages when you use a type that doesn't meet the requirements, which has been a historic pain point with C templates. Rust's approach to generics also maintains the zero cost abstraction principle we discussed earlier. The compiled code is just as efficient as if you had written separate functions for for each concrete type, because this is actually what Rust does automatically for you at compile time. Moreover, Rust's ownership system applies to generic code as well, ensuring that even generic functions are memory safe and thread safe. By refining C's template system, Rust has made generic programming more accessible and safer while maintaining its power and performance benefits. Now, while Rust has made significant strides improving on C's features, it still faces a major limitation. Ecosystem and Compatibility C has been around for decades and has built up a vast ecosystem and wide ranging industry adoption.
00:07:42.449 - 00:08:29.229, Speaker A: C also has near seamless compatibility with C, meaning you can run your application on virtually any operating system or hardware platform. Rust, being a newer language, is still building its ecosystem, and while industry adoption is rapidly growing, it's still in the early stages. And Rust's compatibility with C, while improving, isn't as seamless as Cs. This ecosystem gap means that for many existing large scale projects or specialized industries, C remains the go to choice. Despite Rust's safety advantages, for Rust to truly compete with C, it needs to continue growing its ecosystem and improving its compatibility with existing code bases. Despite these challenges, I'm very optimistic about Rust's future. As the ecosystem grows and compatibility improves, I think the rate of adoption will only increase.
00:08:29.229 - 00:08:40.305, Speaker A: If you need help becoming a Rust developer or are just curious about the opportunities, make sure to get your free rust training@letsgetrusty.com Bootcamp Hope you've enjoyed the video and remember to stay rusty.
