00:00:00.560 - 00:00:36.745, Speaker A: Welcome back, Rust gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, hit that subscribe button for weekly Rust videos. In the last video, we started chapter 12 of the Rustling book, in which we're creating a CLI program similar to grep. In this video, we're going to finish off chapter 12 by moving some of our logic into a library crate and then practicing test driven development. So with that, let's get rusty. So far, this is our program.
00:00:36.745 - 00:01:25.535, Speaker A: We have a main function which takes in our command line arguments, stores them in a variable called args, then constructs a config struct and passes the config struct into our run function. Now this works, but our main RS file is starting to get a little bit bloated. So let's extract some of the logic out into a library. Create specifically the run function and our config struct along with its implementation block. So the first thing we'll do is open up our folder hierarchy and create a new file inside the source directory called lib r. And this will be the root of our library crate. Next, let's go ahead and move over our run function and our config struct into our library crate.
00:01:25.535 - 00:02:20.345, Speaker A: We'll also want to copy over the relevant use statements. Now, remember that everything in Rust is private by default. So if we want code outside of our library crate to access our run function and our config struct, we need to explicitly make it public. And we need to make the fields of our struct public as well. Next we'll go back to main and remove the unused use statements. And next we want to import config from our library crate. So to do that, we'll type in use mini grep, which is the name of our library crate.
00:02:20.345 - 00:03:10.453, Speaker A: Colon colon config finally, instead of bringing the run function into scope, we'll specify mini grep colon colon run. Let's go ahead and run our program to test it out. We'll type in cargo run test and then poem txt, which, if you recall in the first video, we created in the root of our directory. And as you can see, our program works as expected. We get the contents of poem txt printed out. Great, our program is working and we have a small main function with the core logic of our program inside our library crate. So next we'll take advantage of that by doing some test driven development.
00:03:10.453 - 00:03:44.857, Speaker A: Here we're inside lib RS and to Practice Test driven development. What we want to do is write a test that fails, then implement the logic that will make the test pass. And finally, if necessary, refactor our code and make sure our test is still passing. Currently our program just prints out the contents of a file. But what we want is for our program to use our query string to search inside the file and only print out lines that contain our query. To do this, we'll create a function called search. But before creating that function, let's write a failing test.
00:03:44.857 - 00:04:17.787, Speaker A: So we'll scroll down here and add a test module. Here we're defining a module called tests, which has the configuration test. And then we're importing everything from the parent module. Next, let's add our test. Here we have a function called one result and it has a test attribute, meaning that it's a test function. And then we have a variable called query which is equal to duct. And then a variable called contents which is equal to this Rust Safe, fast, productive.
00:04:17.787 - 00:04:45.751, Speaker A: Pick three. Lastly, we have this assert equal statement. And here we call the search function, which doesn't exist yet. And we pass it the query and contents. And what we expect to be returned is an array of lines that contain our query string. And in this case we only expect one line to contain our query string, which is safe, fast and productive because it has duct in it. And that's why this test is called one result.
00:04:45.751 - 00:05:35.465, Speaker A: Now, this code will not compile because the search function is not yet defined. So let's define the search function and make a return and an empty vector. We'll define the search function right above the test module and it'll be public, and it'll take a query parameter which will be a string slice, and contents, which will also be a string slice, and then it will return a vector of string slices. And then inside the body of our function, we're simply going to return an empty vector. Now, if you notice, we have some red squigglies up here and if I hover over, we can see the error. The error is missing. Lifetime specifier.
00:05:35.465 - 00:06:17.405, Speaker A: This function's return type contains a borrowed value, but the signature does not say whether it is borrowed from query or contents. Remember that anytime we return a reference from a function, we we have to tie the lifetime of that reference to the lifetime of one of the input parameters. In this case, we want the strings in the returned vector to have a lifetime tied to the contents input parameter. And that's because the return strings will simply be lines inside the contents string. So let's specify our lifetime. First we'll add the name of our lifetime after the name of our function, and in this case it's tick a. Then we'll assign tick a to contents.
00:06:17.405 - 00:06:52.965, Speaker A: Finally, we'll assign tick a to the string slices returned in our vector. Now we have a working search function, so let's go ahead and run cargo test. As expected, we have one failing test and our test fails because our assertion failed. We expected a vector with one string, but. But we got an empty vector. Now let's write the code that will make this test pass inside our search function. The first thing we'll do is loop through each line in contents.
00:06:52.965 - 00:07:40.665, Speaker A: Next, we'll check if each line contains the query string. And if it does, we want to add the line to a results vector. So let's create our results vector above our for loop. Note that we want to make our results vector mutable because we're going to mutate it. So inside our if statement, let's push the line onto the results vector. And lastly, at the end of our function, we want to return our results vector. Let's go ahead and run our test suite again.
00:07:40.665 - 00:08:23.701, Speaker A: And this time we got a passing test. Now that we have a search function and it's tested, let's use our search function inside of our run function. So here, instead of printing out the contents of our file, we want to print out the lines which contain our query string. Here we're calling our search function passing in the query and the contents Search returns a vector of strings and each string is a line which contains our query. So then we loop over the lines and print out each line. Let's run our program to test this out. We'll go cargo run.
00:08:23.701 - 00:09:00.753, Speaker A: Our query is going to be frog and then our file is going to be poem.txt and here you can see we get one line which contains the word frog. We can also test this out by passing in a query that doesn't exist. So we can type in cargo run dog and then poem Txt, and in this case we get zero lines. Great, we have a working program, but let's improve it a little bit further. Currently our search logic is case sensitive. So let's add the option to do case insensitive searching.
00:09:00.753 - 00:09:36.745, Speaker A: And instead of using command line arguments, we'll take this opportunity to use environment variables. Let's keep practicing test driven development by first adding a failing test. So we'll scroll back down to our test module and add a new test. Our test function is called case insensitive and our query string is is rust with Lowercase and uppercase letters. The content string contains two instances of rust. The first word is rust with a capital r. And then rust is also in the word trust, all lowercase.
00:09:36.745 - 00:10:18.437, Speaker A: Then we have an assert equals statement in which we call a function named search case insensitive. And that function doesn't exist yet. And what we expect to get back are two lines, rust and trust me. Let's scroll back up to our first test case and change the name to case sensitive. We'll also change the content string by adding the word duct tape to the end and we'll capitalize duct. And this is because our query is lowercase duct, so we expect not to get this last line in the resulting vector. Our code won't compile yet because the search case insensitive function isn't defined.
00:10:18.437 - 00:10:50.375, Speaker A: So let's define it above our test module. Just like our search function, we take in a query contents and return a vector of string slices. And we have a lifetime parameter here. Then we just return an empty vector. So let's go ahead and run our test suite. And as expected, we have one passing test and one failing test. Now let's implement the functionality that will make this test pass.
00:10:50.375 - 00:11:51.255, Speaker A: The first thing we're doing here is creating a query variable which will shadow the query being passed in, and we set it equal to query dot, lowercase. Then we create our results vector like before, and then we loop through each line in our contents string before checking if the line contains our query. We first call tolowercase on that line, which will return the text in that line all lowercase, so we can check the lowercase line and compare it to our lowercase query. Note that tolowercase returns a new string, so we're not modifying the original strings. Then, if our line contains our query, we add the line to our results vector and return results at the end of our function. Now let's run our test suite again, and this time both our tests pass. Now that we have a search function and a search case insensitive function, our program needs to figure out which one to use.
00:11:51.255 - 00:12:33.425, Speaker A: And to do that, we can use environment variables. But before we get to using environment variables, let's create a new field on our config struct called case sensitive, and it'll be a boolean. Case sensitive will represent whether we want our search to be case sensitive or not. Next, let's modify the run function to use our case sensitive field. Here we've created a results variable which is equal to this if statement. If case sensitive is true, we execute search, Else we execute search case insensitive. Then we want to loop through our results and print out each line.
00:12:33.425 - 00:13:15.639, Speaker A: Finally, let's modify the new function on our config struct to use environment variables. So first we'll need to import the environment module from the standard library. Then we'll modify the new function. Here we're calling the var function in the environment module, which takes in a key to an environment variable and returns a result type. If the key exists and it's set, the result will be okay containing the set value. Otherwise the result will be an error. Then we call iserror, which will return a boolean.
00:13:15.639 - 00:13:56.465, Speaker A: So if case insensitive is not set, we'll get an error and our variable will be false. But if it is set, our variable will be true. Then we simply pass our case sensitive variable to config. Let's try this out by running our program. We'll type in cargo run, our query will be two, and then our file name will be poem txt and here we get two lines. Next, let's set our environment variable. If you're using bash, you can type in export the name of the environment variable, which in this case will be case, underscore, insensitive, all capitalized equal to true.
00:13:56.465 - 00:15:01.665, Speaker A: And then run our program again, and this time we get three lines. I can go ahead and unset our environment variable, run our program again, and now we have two lines again. The last thing we'll do is change our error messages so that they print out to standard error instead of standard output. And luckily for us, all our error handling is inside main RS command line programs are expected to send errors to the standard error stream. That way, if a user wanted to, for example, send the output stream to a file, they would still see errors on the screen. To show that this is broken in our program, let's run our program and redirect the standard output to a file we'll type in cargo run greater than, which will redirect the output to a file and then the name of the file. And in this case it will be output txt and you can see we don't have any text in the terminal.
00:15:01.665 - 00:16:14.655, Speaker A: But if we open our file structure and go to output txt will get our error message, which is problem parsing arguments, not enough arguments. Let's fix this so that we don't get errors in our standard output. And to do so, it's very simple. Instead of using print new line statements, we'll add an e to the front of print ln and then this will print to the standard error stream and we'll do the same thing down here. Now let's try running the exact same command as before and this time you see we get our error inside the terminal and if we go to output txt we get no text because there was no standard output. Let's try running this again with a valid input so we'll go cargo run to poem txt and then greater than output txt and this time we don't have anything inside the terminal because we didn't get any errors but you can see the standard output was redirected to output TXT and there you have it. Chapter 12 of the Rustling Book complete.
00:16:14.655 - 00:16:30.265, Speaker A: In this chapter we took everything we learned from previous chapters and built a command line interface program. If you enjoy this video make sure to give it a like and if you want to see weekly Rust content make sure to subscribe and with that I'll see you in the next one.
