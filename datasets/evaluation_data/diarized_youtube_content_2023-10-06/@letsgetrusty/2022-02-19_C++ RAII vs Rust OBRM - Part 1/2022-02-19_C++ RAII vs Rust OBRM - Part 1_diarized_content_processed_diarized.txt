00:00:00.400 - 00:00:46.570, Speaker A: What's up, rustations? Welcome back to let's get Rusty, your number one resource for all things rust. In today's video, we're continuing our series on memory management. If you haven't already, make sure to check out the last video, which was about memory regions. Today we'll be discussing a resource management pattern in C called RAII, and comparing that to the ownership system in rust. So with that said, let's get rusty. First, we'll discuss RAII, which stands for resource acquisition is initialization. This is a technique, a pattern, or best practice for exception safe resource management in C.
00:00:46.570 - 00:01:14.696, Speaker A: The pattern is actually really simple, but the name is extremely confusing. So let's break it down by first talking about what a resource is. Here's a generic definition. A resource is something with a finite supply that requires management. An example would be memory allocated on the heap. The heap has a finite supply of memory, and developers must manage allocations and deallocations. Another example are network sockets.
00:01:14.696 - 00:01:53.788, Speaker A: Network sockets are in finite supply, and developers must manage opening and closing network sockets. Other examples of resources are file handles, database handles, mutexes, and more. So far, we've just been talking about memory and managing memory, but as you can see, memory is just one resource. There are many other types of resources, and all of them need to be managed. Which brings us to the problem. The problem with managing resources is that if you manually manage resources, it's extremely error prone and ownership is ambiguous. To better understand this problem, let's jump into some code.
00:01:53.788 - 00:02:37.506, Speaker A: Here's a simple C program with a dummy class called car and a function called memory example. Inside the function, we create a new instance of car, and because we use the new keyword, car is going to be stored on the heap, and we'll get back a pointer. At the end of the function, we use the delete keyword to clean up memory on the heap. In this example, heap memory is the resource, and we're manually managing allocations and deallocations with the new and delete keywords. Now, there are some obvious mistakes you can make here. For example, if you delete car twice, that would lead to a double free error, and if you forget to delete car, then that would lead to a memory leak. However, you could also make some subtle mistakes.
00:02:37.506 - 00:03:30.446, Speaker A: For example, on line 61, a function called function that can throw is called if this function does indeed throw an error, then we would not get to line 63, causing a memory leak. Similarly, on line 62, we return early based on some condition. If we do return early, then line 63 will never be executed, thus causing a memory leak. Let's take a look at a similar example with file handles. Here we have another function called file example, and inside the function we acquire a file handle, and at the end of the function we close the file handle similar to the heap example before. If we call function that can throw and it does throw, or if we return early based on some condition, then the file handle will not be closed. As you can see, manually managing resources is extremely error prone.
00:03:30.446 - 00:04:19.854, Speaker A: On top of that, ownership is ambiguous. For example, imagine that we had multiple pointers to the car stored on the heap. Well, if we had multiple pointers, who's responsible for cleaning up the car? To address these problems, RAII was created, the idea being instead of manually managing resources, let objects, specifically the constructors and destructors of objects, manage resources. Let's go back to the car example. Instead of manually allocating and deallocating memory on the heap, we'll create a new class called car manager. Our class has one private member called p, which is a pointer to a car instance on the heap. In the class constructor, a pointer to a car gets passed in and assigned to p, and in the destructor, P gets cleaned up.
00:04:19.854 - 00:05:01.742, Speaker A: This class is using the RaII pattern. When a class instance is initialized, we acquire resources, and when the class instance is destroyed, we clean up the resources. Let's take a look at how we would use the car manager class. Looking at example number two, you could see that we create an instance of Carmanager and pass in a pointer to car. One important thing to notice here is that when we create car manager, we do not use the new keyword. So car manager will be allocated on the stack instead of the heap, because car manager is allocated on the stack. When this function returns, Carmanager will be cleaned up.
00:05:01.742 - 00:05:36.920, Speaker A: This means that the destructor of Carmanager will be called, which in turn will clean up the resource being held by carmanager. In addition, if the function on line 62 throws an exception, or if we return early, Carmanager is still going to get cleaned up, which means our resource is still going to get cleaned up. This is the power of Raii. First of all, the code looks a lot cleaner. And second of all, we can't create a memory leak by mistake like we could with the first example. Let's see how this pattern applies to our file handle example. Here's the file example function from before.
00:05:36.920 - 00:06:27.714, Speaker A: Again, we'll start off by creating a class, this time called file. Just like before, our class has one private member in this case, it's a file handle called file. However, unlike before in our constructor, instead of passing in the resource, we're going to pass in a file name and then create the resource inside the constructor and assign it to file. Then in the destructor we'll close the file handle. Next, let's see how we would use this class. Instead of manually creating the file handle and then closing it at the end of the function, we simply create an instance of file and pass in our file name. Again, file is stored on the stack, which means that at the end of this function, file will be cleaned up, its destructor will be called, and thus the file handle will be closed.
00:06:27.714 - 00:07:10.726, Speaker A: Even if on line 32 this function throws or we return early, file will still be cleaned up again. This code is a lot cleaner and it's not possible to create a resource leak like we could with the first example. Now that we've seen the benefits of RaII, let's go back to our memory example to talk about how RAII is implemented in the C standard library. Here we can see the first example in which we manage memory allocated on the heap manually. In the second example, we use the car manager class to manage a car instance that's allocated on the heap. Car manager only works for cars. However, many different data types could be stored on the heap.
00:07:10.726 - 00:08:09.726, Speaker A: What if we created a class that manages heap allocated memory no matter what data type it is? Fortunately for us, we don't have to implement this ourselves because the C standard library already has something like this and it's called unique pointer. You'll notice that example three is very similar to example two, except instead of using car manager recall, make unique and pass in car as a generic argument which creates a unique pointer instance. When this function returns, car will be cleaned up, causing the unique pointer destructor to be called, which will clean up memory stored on the heap. One benefit of this approach is we no longer need to use the new keyword. In example number two, we got rid of delete, but we still had to use the new keyword to create an instance of car. In example number three, we don't need the new keyword at all. If you recall from the slides, there were two problems with manually managing resources.
00:08:09.726 - 00:09:08.948, Speaker A: One of them is that it's extremely error prone and we've seen how RAII could help us with that. But the other one is that ownership is ambiguous, and RaII also helps us with ownership. By ownership, I mean who is responsible for cleaning up the resource? Is it the current function is it the caller of the current function? What if we had multiple classes which each had a pointer to the same instance of cardinal on the heap? Which of those classes would be responsible for cleaning up the heap allocated memory? Well, by using a unique pointer, we know that this car variable owns the heap allocated memory. So when car goes out of scope, the heap allocated memory will be cleaned up. When using a unique pointer, we can't create another unique pointer that points to the same car. For example, let's try to create another unique pointer called car two, and we'll set that equal to car. And as you can see, we get an error.
00:09:08.948 - 00:09:54.354, Speaker A: This is good, because if we didn't get an error, then ownership would be ambiguous. We wouldn't know whether car or car two owned. Cleaning up the heap allocated resource so unique pointer represents one single owner of a resource. However, there is a way to have shared ownership of a resource. To do that, instead of using a unique pointer, we can use a shared pointer. Shared pointers allow you to share ownership of a resource by using reference counting. When the first shared pointer is created, the reference count is one.
00:09:54.354 - 00:10:30.888, Speaker A: There is one reference to this car allocated on the heap. When the second shared pointer is created and assigned to char, the reference count goes up to two. Now there are two shared references pointing to the same char allocated on the heap. When this function returns, car will be cleaned up. When car is cleaned up, its destructor will be called, which will decrease the reference count to one. Then car two will be cleaned up, its destructor will be called, and the reference count will decrease to zero. Once the reference count is zero, then the heap allocated memory will be cleaned up.
00:10:30.888 - 00:11:18.034, Speaker A: So if you wanted to have multiple classes, each with a pointer to the same car allocated on the heap, then you would use a shared pointer. In summary, a resource is something that is finite and has to be managed, like heap allocated memory, network sockets, file handles, and more. Managing resources manually is error prone and ownership is ambiguous. RAII is a pattern where resources are managed through objects, specifically the constructors and destructors. And lastly, the RAII pattern is used in the C standard library specifically for anything allocated on the heap. You can use a smart pointer to manage the memory for you. An example would be unique pointer or shared pointer.
00:11:18.034 - 00:11:41.790, Speaker A: In part two, we'll discuss how this pattern compares to the ownership system in rust. If you enjoyed this video, make sure to leave a like and a comment, or if you found anything confusing, make sure to leave a comment as well. Lastly, and most importantly, get your free rust cheat sheet by heading over to letsgetrusty.com cheatsheet. And with that said, I'll see you in the next one.
