00:00:00.320 - 00:00:38.168, Speaker A: Rust is a special language. It eliminates an entire class of memory safety bugs at runtime by enforcing a set of rules at compile time. But theres a catch. As a rust developer, youre constantly bombarded with compile time errors. Debugging these errors is so common and so frustrating that the rust community has a name for it. Fighting the borrow checker and the number one mistake you can make when learning rust is attempting to fight the borrow checker without being prepared for battle. In the last video, I explained how a part of the rust compiler called the borrow checker analyzes your code to make sure it follows a set of rules which ensure memory safety.
00:00:38.168 - 00:01:12.802, Speaker A: Those rules are called the ownership and borrowing rules. Even though these rules are simple, they can result in a constant stream of errors that will leave you endlessly debugging code instead of shipping features. So in this video, I'll give you three principles of battle you must know in order to win the great war against the borrow checker. With that said, let's get rusty. Principle one know thy enemy. The rust borrow checker has two important characteristics you need to be aware of. It's basic and conservative.
00:01:12.802 - 00:01:59.016, Speaker A: Basic in the sense that it enforces a simple set of rules, and conservative in the sense that it will reject potentially valid code if it can't deterministically prove the code is memory safe. Let me show you what I mean. We have a user struct with two fields, a user id and a vector of posts. In main, we create a new user instance and then store the user's posts in a variable. Now let's see what happens when we try to mutate the user id. Mutating the id directly on the user struct works without any issues, but mutating the id by calling the setid method results in an error stating borrow of partially moved value user. What does partially move meant, and why are we getting this error? Remember that according to the ownership rules, each value in rust has an owner, and there can only be one single owner at a time.
00:01:59.016 - 00:02:33.384, Speaker A: When we create our user instance, the vector of posts is owned by the posts field. Then when we define user posts and set it equal to user posts, the vector moves into user posts and the post struct field is invalidated. User posts is now the new and sole owner of the vector. This is called a partial move because part of the struct is moved while the rest remains usable. The next line works because we are mutating the part of the struct that wasnt moved. But when we try to call the setid method, the borrow checker freaks out. This makes sense if we look at the methods signature.
00:02:33.384 - 00:03:22.500, Speaker A: Setid accepts a mutable reference to self, which is an instance of a user struct. The problem is, getting a mutable reference to a user instance that has partially moved data can cause memory safety issues. Imagine if we tried to access the posts field inside the function. Of course, in this case we are only modifying the user id field, but the borrow checker doesn't know that. It doesn't analyze the function's implementation, it simply looks at the function signature, checks the basic ownership and borrowing rules, and conservatively rejects code which might violate them. If it were able to analyze our specific implementation, not only would that complicate the ownership and borrowing rules, but it would also dramatically increase compile times. Understanding that the borrow checker is basic and conservative will help prepare you for the battle ahead and give you the mindset needed to win.
00:03:22.500 - 00:04:11.476, Speaker A: Principle two wage war strategically. Knowing your enemy is a good start, but its not enough. In order to engage in battle and win, you need a strategy. Heres the simple three step process I go through any time I get a compile time error. Step one read the error message I know this sounds obvious, but its amazing how many times ive started googling for a solution or started sprinkling ark everywhere before thoroughly reading and understanding the error Im getting. Making sure you read error messages is very important, especially because oftentimes the compiler gives you helpful hints and even solutions. In this example, we're passing a vector into a function and then attempting to print the vector.
00:04:11.476 - 00:04:48.338, Speaker A: We get an error stating borrowed of moved value numbers. The compiler tells us what line is throwing the error, where the value was moved, and why it was moved. The compiler also gives us helpful hints with possible solutions like changing the process function to accept a borrowed value or cloning the vector of numbers. And if we need more information about this specific error, the compiler gives us a command we can run which gives us a detailed explanation of the error that includes examples. Now that we've read the error message thoroughly, we can move on to step two. Work through the problem. This is where you reason about the error and try to solve it yourself.
00:04:48.338 - 00:05:31.462, Speaker A: In this case, if the process function only needs immutable access to the vector, we can pass in a borrowed value. However, in other situations the solution is not as clear. In this example, we're attempting to pass a reference to a vector into a newly spawned thread. We get an error stating borrowed value does not live long enough and that data has been borrowed for tick static. This error requires a deeper understanding of rust, and the compiler doesn't suggest any possible solutions. In situations like this where you can't reason about the problem without additional help, instead of using Google or stack overflow, you can deploy step three use AI. I use AI tools every single day for various tasks, including coding, and it's truly a game changer.
00:05:31.462 - 00:06:20.892, Speaker A: For example, I can ask GitHub Copilot to explain this error to me. Because Copilot has access to my code, it will give me a tailored answer, including the solution and an explanation. Not only that, but I can actually have a conversation with copilot about my code. Using AI not only to help you write code, but also to help you understand and debug code will dramatically improve your productivity. Now that you know your enemy and have a strategy in place, you're ready for battle. However, battle is costly, and you should only engage the enemy when necessary. Principle three avoid battle the best way to win the battle against the borrow checker is to avoid it in the first place.
00:06:20.892 - 00:07:03.070, Speaker A: This is by no means easy to do, but heres a general guideline to follow. Make it work, make it right make it fast the first step is to make sure your code works as intended. Don't worry about making it clean, idiomatic, or performant. Avoid the hard parts of rust like lifetimes. Use owned values instead of references, clone data where it makes sense, or use the RC smart pointer for shared ownership, and avoid error handling by simply calling unwrap. It's also important to ignore certain areas in rust that are known to be difficult, things like self referential structs, advanced data structures like linked lists and graphs, concurrency and parallelism, unsafe rust and macros. You're not that guy, pal.
00:07:03.070 - 00:07:25.834, Speaker A: Trust me, you're not that guy. Once your code is working, you can move on to step two. Make it right. This is where you refactor your code to make it more idiomatic. As a bonus, writing idiomatic rust will help you avoid borrow checker errors. Writing idiomatic rust is a large topic which deserves a video of its own. In fact, I've already made a playlist going over idiomatic, which you can check out.
00:07:25.834 - 00:08:13.306, Speaker A: You can also check out the idiomatic Rust GitHub repo, which is a peer reviewed collection of articles, talks, and repos that teach concise idiomatic rust, and you can find a link to it in the description of this video. The last step is to optimize your code for speed if necessary, which may include using advanced concepts like multiple lifetimes or unsafe rust. Using this guideline will help you avoid constantly fighting the borrow checker and make you feel a lot more productive when riding rust. With these three principles of battle, know your enemy, wage war strategically, and avoid battle. You are now equipped to fight the borrow checker and win. Before you go, make sure to get your free rust cheat sheet@letsgetrusty.com. cheatsheet let me know if this video has been helpful by leaving a comment below.
00:08:13.306 - 00:08:20.760, Speaker A: Give this video a like if you enjoyed it, and subscribe to the channel for more rust content. Hope you've enjoyed the video, and remember to stay rusty.
