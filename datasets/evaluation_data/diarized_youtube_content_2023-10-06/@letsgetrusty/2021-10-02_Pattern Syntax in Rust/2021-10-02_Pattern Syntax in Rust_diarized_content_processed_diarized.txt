00:00:00.360 - 00:00:32.722, Speaker A: Welcome back, Rust Gang. If you're joining us for the very first time, my name is Bogdan and this channel is all about the rust programming language. In the last video we talked about patterns and matching in rust. If you haven't seen that, make sure to check it out. In this video, we're going to talk about all the valid syntax you can use inside patterns and why you might want to use each one. So with that, let's get rusty. The first pattern you can match on is matching against literals.
00:00:32.722 - 00:01:07.262, Speaker A: So for example, here we have a variable called x, and it's going to be set to one, and then we match on x. You can see that in these arms the pattern is simply a literal one, two, three, or a catch all. In this case, we're going to map to one, which is the first arm. This pattern is useful when you want your code to take action when it receives a concrete value. The next pattern you can match on are named variables. In this example, we have a variable called x, which is going to be a sum value containing five and a variable called y, which is going to be equal to ten. Then we match on x.
00:01:07.262 - 00:01:46.940, Speaker A: If x is a sum variant containing the value 50, then we print got 50. Otherwise, if x is a some variant containing any other value, then we store that value in a variable called y and print out matched y equals xdev. Then whatever value we got if the two arms above don't match, then we go into the catch all arm and print out default case x equals and then the x variable. In this example, the second branch is using the named variable pattern. In this case, y is the named variable. One thing to know here is that the match block creates a new scope. So variables defined within the match block will shadow variables outside of the match block.
00:01:46.940 - 00:02:20.468, Speaker A: Specifically, in this case, the y defined inside the match block will shadow the y defined outside of the match block. So when we print this text here, this y is not going to be the y that's defined up above. It's going to be whatever is stored in the sum variant. However, the variable x inside our catch all arm is the same variable as defined up above, because there's no variable named x inside this block to shadow it. Next, let's talk about matching multiple patterns. Here we're matching on x, and then the first branch is using this operator here. This is an or operator.
00:02:20.468 - 00:02:52.624, Speaker A: We're saying if x is one or two, then go into this arm. We can continue adding to this as well. For example, we could do one or two or three. Also, note that these patterns are simple literals, but the patterns can be as complex as you'd like. Next, let's talk about matching ranges of values using this range with an equal sign syntax. Here you can match to an inclusive range of values. For example, here we're saying if x is a value between one and five, including five, then execute this arm.
00:02:52.624 - 00:03:18.440, Speaker A: Note that we can use the same syntax on characters as well. Note that the range operator only works on numeric values and characters. Next, let's talk about patterns that destructure values. We can destructure structs each tuples and references to use different parts of these values. First, we'll talk about destructing structs. Here we have a struct called point and it has two fields, x and y. Both of them are integers.
00:03:18.440 - 00:03:57.002, Speaker A: Inside of main we create a new point, setting x to zero and y to seven, and we name the variable p. Then we have some interesting syntax online. Nine what we're doing here is deconstructing p, which is a point structured, and we're creating two variables, a and b. A is going to be mapped to whatever value is inside of x, and b is going to be mapped to whatever value is inside of y. So a is going to be zero and b is going to be seven. In this case, this example shows that the names of variables inside of a pattern don't have to match the field names inside of a struct. However, it is common to have variables inside of a pattern match the field names.
00:03:57.002 - 00:04:46.292, Speaker A: So if we wanted to do that here, we we can simply remove a and b. When we're destructing a struct, we can use named variables and literals. In this example, we create a new point and then we call match on that point. The first branch is matching any point that lies on the x axis. Here we're saying the y value has to be zero, and then whatever the x value is, map it to this x variable and print it out. The second branch is matching any point that lies on the y axis by specifying that x has to be zero, then mapping the y value to this local y variable and then printing it out. The third branch will print out any point that doesn't lie directly on the x axis or y axis.
00:04:46.292 - 00:05:22.106, Speaker A: Next, let's talk about destructing enums. Here we have an enum called message with four variants. First we have a unit like variant called quit. Then we have a struct variant with two fields called move. Then we have a tuple variant with one value called the right, and finally we have a tuple variant with three values called change color. Inside of main we create a new variable called message and set that equal to the change color variant of our message enum, and then we call a match expression on our message variable. If the variant is quit, we can't destruct it any further, so we just print out quit.
00:05:22.106 - 00:06:15.768, Speaker A: If the variant is moved, then we destruct the fields into local variables called x and y and then print them out. If the variant is right, then we extract out the value inside of our tuple into a variable named text, and then print out the text. Finally, if the variant is changed color, then we're going to destruct the tuple into three variables named rgb and print them out. You can also destruct nested enums and structs. Here I've changed the message enum such that the change color variant, instead of storing three numbers, it's going to store the color enum. The color enum has two variants, rgb, which is a tuple of three integers, and hsv, which is also a tuple of three integers. In the main function, we create a new message variable and set it equal to the change color variant of message, and then we pass in a new color enum, which is going to be the HSV variant.
00:06:15.768 - 00:06:52.144, Speaker A: Then we use a match expression on our message variable. The first arm matches on a change color variant that contains an RGB variant, and then we bind the values inside the rgb variant to r, g, and b. Then we simply print out the red, green and blue values. In the second branch we do something very similar. For the HSv variant, we can specify these complex conditions in one match expression, even though two enums are involved. Here's an example of even more complicated destructuring. Here we have a less statement which is equal to a tuple that contains another tuple, and a struct.
00:06:52.144 - 00:07:42.300, Speaker A: What this pattern up here is doing is destructing all the primitive values from the inner tuple and inner struct into the variables feet, inches, x, and y. Next, let's talk about ignoring values in patterns. In this example we have a function called foo, which takes two arguments that are 32 bit integers, and as you can see, one of the arguments is named y, but the other one is an underscore. We've seen underscores being used in match expressions as a wildcard, but they could be used in any other pattern as well. When used as an argument name, this function will completely ignore the first value passed in. This could be useful when you need a function signature to be something specific, but you're not going to use all the arguments passed in. Instead of allowing the compiler to throw a warning saying you have unused arguments, you can use the underscore.
00:07:42.300 - 00:08:29.850, Speaker A: You can also use the underscore in another pattern to just ignore part of a value. Here we're managing some setting, and the business requirement is that if the setting has no value, then we can set a value. However, if the setting already has a value, then we can't modify it. In main we have a variable called setting value, which is going to be an optional containing an integer, and we also have a variable called new setting value, which again is going to be an optional containing an integer. Then we have a match expression and we're matching on a tuple that contains both the setting value and the new setting value. In the first arm we have a pattern that matches a tuple with two sum variants, and we don't care what's stored in the sum variant, so we use an underscore. If both the setting value and the new setting value are some variants, then we print out.
00:08:29.850 - 00:09:08.122, Speaker A: Can't overwrite an existing customized value. Then we have a catchall arm which modifies the setting and sets it to the new setting value. This code allows us to modify the setting value if it hasn't been set already, and it also allows us to clear the setting value by setting it back to none. If the setting does have a value already, then we can't modify it with a new value. We can also use underscores in multiple places within one pattern to ignore particular values. In this case we're matching on a tuple of integers and we're ignoring the second and the fourth value. If you're prototyping and have an unused variable, you don't want the rust compiler to complain about.
00:09:08.122 - 00:09:41.022, Speaker A: You can prefix it with an underscore. So here, for example, we have x with an underscore, and we don't get any compiler warnings, but we have another unused variable, y, for which we do get a compiler warning. One thing to know is that prefixing a variable name with an underscore is different than using just an underscore. Prefixing a variable name with an underscore still binds the value. For example, let's take a look at this code. Here we're creating an optional variable called s, which is going to be a some variant containing the string hello. And then we're using an if let statement.
00:09:41.022 - 00:10:19.468, Speaker A: If s is a some variant we want to print out found a string, but we don't care about the actual string inside of the sum variant. So to keep the compiler from complaining, we prefix s with an underscore. But you can see down here, when we tried to print s, we get an error saying that s has already been moved. The reason for this is that this variable up here is still binding to the value inside of our sum variant. Because s contains a string, the string will be moved into this underscore s variable. If we didn't want to move our string out of the sum variant, then instead of using underscore s, we can simply use underscore. And as you can see, our code is now compiling.
00:10:19.468 - 00:10:52.996, Speaker A: If you only care about certain parts of a value and want to ignore all the other parts, then you can use the range syntax. For example, here we have the struct point with three fields x, y, and z. Then we construct a new point and name it origin, and then we match on that point. We only have one arm here, and the pattern we're using binds to the x field. And using the range syntax ignores all the other fields. The range syntax will expand to as many values as it needs to be. For example, here we have a tuple called numbers, and then we match on that tuple.
00:10:52.996 - 00:11:28.120, Speaker A: We only have one arm, which is going to be the following pattern. We're going to bind the first value to this first variable, we're going to bind the last value to this last variable, and then everything in the middle we're going to ignore. Note that using the range syntax must be unambiguous. For example, let's say we change this pattern to the following. Here we get an error because we have the range syntax on both sides of the second variable. In this case, rust can't determine what the second variable should bind to. Is it the second value, is it the third, or is it the fourth? Next, let's talk about match guards.
00:11:28.120 - 00:12:07.194, Speaker A: A match guard is an additional if condition specified after the pattern in a match arm that must also match, along with a pattern for the arm to be chosen. Match guards are useful for expressing complex ideas that patterns themselves cannot express. In this example, we have a variable called num, which is going to be an optional containing an integer. Then we match on num. In the first arm, we're matching on a sum variant and binding the value to x, but we're also checking if x is less than five, and if so, we go into this arm and print less than five, and then the number in the second arm. We're also matching on the sum variant. However, we don't have a match guard.
00:12:07.194 - 00:12:35.846, Speaker A: So if x is equal or greater than five, then we go into this arm. Otherwise, if we get a non variant, then we return a unit type. Note that we can't express that we want x to be less than five using just patterns. So match guards are here to fulfill that role. Match guards also solve issues with shadowing inside the match block. In this example, we have a variable called x which is going to be an optional containing an integer. And then we have a variable called y which is set to ten.
00:12:35.846 - 00:13:16.538, Speaker A: Then we match on x. And for the first arm what we want to do is execute some piece of code when x is equal to y. So when x is ten we can't use the variable y inside of the pattern because if we do, then the y inside of the pattern will shadow the y outside of the match block. But we could use y inside of our match guard. So here we're saying match on any sum variant, then bind the value to n and also make sure that n is equal to y. You can also specify multiple patterns and have the match guard applied to each pattern. In this example we have a variable called x, which is going to be four, and then we have a variable called y which is going to be false.
00:13:16.538 - 00:13:57.316, Speaker A: Then we match on x and the first arm is saying x has to be either four, five or six and y has to be true for this arm to execute. Again, note that this match guard doesn't only apply to the last pattern, it applies to each pattern. All right, the last thing we're going to talk about is the operator. The operator lets us create a variable that holds a value. At the same time we're testing that value to see whether it matches a pattern. For example, here we have an enum called message which contains a variant called hello, which is a struct variant with one field called id. Below we construct a new message and then match on our message variable.
00:13:57.316 - 00:14:45.426, Speaker A: In the first arm we use the following pattern to match a hello variant where the id is between three and seven, but we also want to store that id in a variable called id underscore variable. So to accomplish this we use the operator. If we didn't care about saving the value in a variable, then we can simply use the range operator without the operator like we do in the second arm. And if we wanted to bind the value without checking if it's in a certain range, then we can just use a named variable like we do in the third arm. So again the operator allows us to test a value while also saving it to a variable. Also note that this variable could be the same as the field name, like so I just happen to name it differently. All right, that's it for this video.
00:14:45.426 - 00:15:14.410, Speaker A: As you can see, patterns are used in a lot of places and they're extremely powerful, especially when coupled with match guards. If you enjoyed this video, then slap that like button and if you want to see weekly rust videos, then hit subscribe and the notification bella to be notified when new videos come out. Lastly, I have a free rust cheat sheet which I would like to give to you. So if you want access to that, go to letsgetrusty.com cheatsheet and with that ill see you in the next one.
