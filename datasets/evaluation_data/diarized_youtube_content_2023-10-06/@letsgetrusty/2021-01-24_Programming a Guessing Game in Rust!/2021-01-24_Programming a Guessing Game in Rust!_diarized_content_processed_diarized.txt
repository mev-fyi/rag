00:00:00.400 - 00:00:33.773, Speaker A: Welcome back to let's Get Rusty. My name is Bogdan, and this channel is all about the Rust programming language. If that sounds appealing to you, make sure to hover over that subscribe button and give it a nice little poke. Last time we went through chapter one of the Rustling Book, in which we created a hello World program. If you haven't checked out that video already, make sure to do so in this video. We're going through chapter two of the book in which we'll create a fully functional AAA rated guessing game. We're also going to add something special to our game that's not in the book, so make sure to stick around till the end of the video.
00:00:33.773 - 00:01:07.455, Speaker A: And with that, let's get started. Okay, now the first thing we actually need to do is create our cargo project. So we'll go into our terminal, type in cargo new guessing game, then we'll CD into that directory and open it in VS code. As you can see, we have our standard hello world program. We could type in cargo run here to make sure it works. But if you have the language server installed, VS code gives you this neat little button here which will run the program as well. Now we can start writing our guessing game.
00:01:07.455 - 00:01:47.487, Speaker A: The first thing we want to do is change this print statement of hello World into a print statement that prompts our users to input a number. Now that we have a prompt, let's actually capture the input from the user. So the first thing we're going to want to do is create a variable to store the user's input. And in Rust we do that by using the let keyword. So I'll go ahead and create a variable called guess, and we'll set that equal to a string. Now here we have string, which is a type in Rust standard library. And it's a utf, a encoded, growable string.
00:01:47.487 - 00:02:11.539, Speaker A: That doesn't make much sense. We'll go more in depth into strings in later chapters. Then we have this colon colon New syntax. New is a function on the string type, and it's an associated function. Other languages call these static methods, but essentially it's the same thing. And then new returns an empty string that we could use. Now, notice Rust is also smart enough to realize that our variable guess is of type string without us actually having to annotate it.
00:02:11.539 - 00:02:46.145, Speaker A: And that's because Rust knows that this new function returns a string. One last thing here, in Rust, variables are immutable by default. But we know we want to change guess because we want to capture the user's input and store that in gus. So to make it mutable, we'll use the mute keyword here. Now that we have our variable set up, let's actually take in the user's input. To do that, we'll need to bring a library called IO into scope. To bring the IO library into scope, we simply type use std for the standard library IO.
00:02:46.145 - 00:03:20.325, Speaker A: Okay, now let's actually use the IO library. To do that, we'll type in IO std and stdn will give us a handle to the standard input of the current process. Readline will take in the user's input and append it to the specified buffer, which in this case is our guest string. Notice also that this function takes a mutable reference to string. Learn about references in later chapters. But this is essentially saying that it'll take a reference to string, modify it without taking ownership of the string. So we'll go ahead and pass in immutable reference to guess.
00:03:20.325 - 00:03:53.037, Speaker A: Readline returns a result type. And let me pull up the documentation here. The result type is an enumeration that could either return the variant okay, which will hold our return value, or error, which will hold an error object. And this is great because this forces us to handle the error case. In this instance, we know that if an error is returned, it's probably a system error, so we'll use the expect function here. And as you can see, if the OK variant is returned, then expect will just return the value contained in ok. Otherwise it will panic with the message provided.
00:03:53.037 - 00:04:24.415, Speaker A: In this case, our message would simply be failed to read line. Now that we've captured the user's input, let's actually print it out. To do that we'll use this println statement, and this is different from our other statements because we have these curly brackets and these are just placeholders for variables, in this case our guest string. So far we've prompted the user for input. We captured the input and printed it back out. So now is a good time to actually test if our program works. To do that, simply type in cargo run, we get prompted for input.
00:04:24.415 - 00:04:58.143, Speaker A: I'll type in 22 and press enter. And as you can see, you guessed 22 was printed back out. The next step is to add a random number. But Rust standard library doesn't come with this ability, so we'll need to add a new dependency. To do that we'll go into our cargo toml file and under dependencies add rand, which is the dependency and the version number. Now that we have our dependency, the next step is to run cargo build and as you can see we got rand and we also got the libraries that RAND depends on. Now let's actually use our RAND dependency.
00:04:58.143 - 00:05:43.155, Speaker A: First we'll go back to main rs, Then we'll add another use statement. In this case, we're bringing the range trait into scope. The range trait defines methods that random number generators use, so we need to bring it into scope, but otherwise you don't need to worry about this as we'll learn about traits in other chapters. Okay, next we'll create a new variable using the let keyword. And in this case we're going to call it secret number, and we'll set that equal to rand thread range.gen range and we'll set the load to 1 and the high to 101 because the high is exclusive here. Thread range is an associated function that would give us a random number generator, and genrange is a method that will produce a random number between 1 and 100.
00:05:43.155 - 00:06:09.449, Speaker A: Now that we have our secret number, let's go ahead and print it out. We'll use curly brackets again to pass in our secret number. Now we can run our program and see if we actually get a random number. So we'll go cargo run and you can see it says 72. I'll input my guess and if we run it again, we get a different number, in this case 81. Now let's compare the number we guessed versus the number that was generated. To do that, first we need to bring ordering into scope.
00:06:09.449 - 00:06:34.259, Speaker A: Ordering is simply an enum that is the result of two things being compared. And if I go to the definition, we could see that there's three different variants. It's either less than, equal or greater than. Now we can scroll to the end of our program and compare guess. To do that, we'll type in guess.cmp. and as you can see, CMP takes a reference to the thing we want to compare. So in this case it'll be our secret number.
00:06:34.259 - 00:07:05.223, Speaker A: You could also see that CMP returns an ordering enum, which, as we've seen before, could either be less than, greater than, or equal. What we want to do is print out a different string depending on what ordering variant is returned. Rust makes this easy with something called a match expression. To create a match expression, simply put the word match in front of the statement and then curly brackets after the statement. And here we want to match all the possible return values. So if the return value is the less variant of ordering, then we want to print too small. If it's the greater variant, then we print too big.
00:07:05.223 - 00:07:36.075, Speaker A: And if it's equal, we print. You win. Now, as soon as I saved, I got these red squigglies here, and it's saying that we can't compare type string to a type integer. Which makes sense because our secret number is an integer and guess is actually a string. To fix this, we'll take the user's input that's a string and convert it into an integer. We'll go ahead and create a new guess variable right after we get the user's input. And now we'll take the first guess variable, which is a string, and call trim on it.
00:07:36.075 - 00:08:07.911, Speaker A: Trim will parse any white space at the beginning or end of the line. Next, we want to take the string and parse it into an integer. To do that, we call the parse function. Now, parse doesn't actually know what to convert our string type into, so in order to give it a hint, we'll need to annotate our variable. And in this case we want an unsigned 32 bit integer. Finally, the parse function could fail, so it returns a result type, which could be the parsed value or an error. In this case, we'll do the same thing as before and call the expect function with our message.
00:08:07.911 - 00:08:33.777, Speaker A: If parse fails to convert our string into an integer, then the user probably did not type in a number, so we'll give them a message to warn them. Now, as you can see, the red squigglies went away and our compare logic at the end of the program is valid. Let's run our program to make sure it works. We'll go cargo run and you can see the guess is 47. So I'll type in 46 and it should say too small. And there you go, it says too small. We'll run the program again.
00:08:33.777 - 00:08:52.977, Speaker A: This time we get 75, I'll type in 76 and we get too big. We'll run the program one more time. This time we get 50. So I'll type in 50 and there we go. Our comparison logic works. Now we have the basic functionality of the game. But if a user guesses a number that's not correct, then we tell them it's either too small or too big and quit right away.
00:08:52.977 - 00:09:19.384, Speaker A: What we actually want to do is let them keep guessing until they get the right number. To do that, we will add a loop. We'll add the loop right before we prompt the user to input their guess. And we'll put everything underneath inside the loop. Okay, great. Now let's try running our game. We'll go cargo Run and The number is 70.
00:09:19.384 - 00:09:40.353, Speaker A: I'm going to guess 50. It's telling me my number is too small and I could guess again. Now I guess 70 and it says you win. But wait, the game still continues and I could type 70 again. It'll say I won. Type in a different number and it never ends. Because we don't have anything telling our loop to stop.
00:09:40.353 - 00:10:06.731, Speaker A: We could have or type in quit here and the game will quit. You can see our program panics because we did not put in a real number. In fact, if we type in any input that's not a number, our program will end. Let's make this a little smarter. We know if the user guesses the correct number, we want the program to end. To do this, we'll go back to our match statement and modify the equal arm. Now, as you can see, not only do we print you win, but we also break out of the loop.
00:10:06.731 - 00:10:29.823, Speaker A: Let's save this and run our program again. The number is 43. I'll guess 42 says too small and then I'll guess 43. And as expected, it says you win and the program exits. Now, our program is just about done, but there are a couple things we could do to improve it. The first thing thing is invalid input. So if we run our program and type in a random string, we panic and exit the program.
00:10:29.823 - 00:10:57.519, Speaker A: Ideally, we would keep prompting the user to input a number until it's valid. To do this, we can modify this line of code which panics if the parse function fails. As mentioned before, parse returns a result enum which could either be OK or error. This means we can use a match expression to handle either case. We'll start by including the match keyword at the beginning of the line. Then instead of calling expect, we'll do curly brackets and handle the possible variance. The first variant is okay, which is a type that wraps our output.
00:10:57.519 - 00:11:32.187, Speaker A: In this case, our Type is a 32 bit unsigned integer and all we want to do is return it. The second case is error, and in this case we're using the underscore, which is a catchall value. What we're saying is no matter what error we get, we want to continue to the next iteration of the loop. There's one detail I forgot to mention earlier. Right here we declare guess as a variable of type string, But a few lines down, we redeclare guess and now it's an unsigned 32 bit integer. This is called shadowing, and it's often used in situations where you want to convert a variable from one type to another while preserving the same name. We'll learn more about shadowing in chapter three.
00:11:32.187 - 00:12:09.087, Speaker A: All right, now we can run our program, and if we give it invalid input, it keeps asking us to enter our guess until we give it a valid number. At this point, our game is fully functional. But we can still do one last thing to make it just a little bit better, and that's introducing color. So let's go back to our cargo toml file and we'll add a new dependency called colored. We'll save that and run cargo build. Next we'll go back to main RS and look at our comparison logic. If the guest number is too small or too big, we want the text to be red.
00:12:09.087 - 00:12:38.697, Speaker A: And if the number is correct, we want the text to be green. The first thing we'll do is scroll back up to the top and bring our colored library into scope. Next, we'll scroll down and modify our print line statements. We'll use the curly brackets again and call dot red on the text we want to be red. Then we'll do a similar thing for the green text, except we'll call dot green. Okay, now let's try running our game. The number is 39.
00:12:38.697 - 00:12:53.589, Speaker A: I'll guess 38. And I'll get red text. And then I'll guess 39. And we have UWin and green text. And under 40 lines of code we have a fully functional guessing game. And there you have it. Chapter two of the Rust book complete.
00:12:53.589 - 00:13:11.165, Speaker A: We learned about variables, the match statement methods, associative functions using external crates, and more. If you enjoy this video, make sure to give it a like. And if you can't get enough of Rust content, make sure to subscribe and hit the notification bell so you can be notified when new videos come out. I'll see you in the next one.
