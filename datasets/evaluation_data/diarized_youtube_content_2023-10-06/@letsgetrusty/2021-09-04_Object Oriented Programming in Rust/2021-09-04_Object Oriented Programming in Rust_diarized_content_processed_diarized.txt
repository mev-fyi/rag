00:00:00.480 - 00:00:36.284, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In today's video, we're discussing object oriented features. In the context of Rust, there are many different competing definitions describing what object oriented programming is. Some of those definitions would classify Rust as an object oriented programming language, and others would not. Rust is influenced by many programming paradigms, including object oriented programming. For example, in chapter 13, we talked about the features of Rust that come from functional languages.
00:00:36.284 - 00:01:36.620, Speaker A: When it comes to object oriented programming, there are arguably three characteristics that most object oriented programming languages share, objects, encapsulation and inheritance. Let's talk about what each of these characteristics mean and if they are supported. In Rust, objects are made out of data and methods that operate on that data. In rust, structs and enums hold data, and you can use implementation blocks to provide methods on structs and enums. So even though structs and enums are not called objects, they provide the same functionality. The next characteristic is encapsulation, which means that implementation details of an object are hidden from the code using that object. Instead of changing the internals directly, code outside of the object is limited to interacting with the object through its public API.
00:01:36.620 - 00:02:27.032, Speaker A: This enables the programmer to change the internals of an object without changing code which uses that object. In chapter seven, we learned how to use the pub keyword to decide which modules, types, functions, and methods are public because in rust everything is private by default. For example, here we have a struct called averaged collection. It contains two fields, a list of integers, and the average of those integers. Here our struct is caching the average such that it doesn't have to be computed on demand every time. Notice that our struct is public so that code outside of this library can use our struct, but the fields are private. And this is important in this particular case because we want to make sure that when this list is updated, when elements are removed or added, the average is also updated.
00:02:27.032 - 00:03:09.352, Speaker A: Instead of letting code manipulate these internals directly, we're going to create an implementation block with methods that modify the internal state. Here we have an implementation block for our averaged collection. Structural has three key methods, add, remove, and average. The add method takes a mutable reference to self and a value. Then it adds that value to the list and calls update average. The remove method takes immutable reference to self and returns an optional integer inside the method. The first thing we do is call pop on that list, which will remove a value, and this will return an optional integer which we store in results, and then we match on result.
00:03:09.352 - 00:04:02.388, Speaker A: If we get a value, then we update average and return that value, and if we get none, then we simply return none. We also have a method called average, which takes a reference to self and returns a 64 bit floating point number. Here we simply return a self dot average. We don't have to do any extra calculations in this method because our two methods that modify the list add and remove call update average and if we scroll down, you'll see we have a private method called update average. Update average will take immutable reference to self, calculate the average, and then store that inside self average. Because we've encapsulated the internals of averaged collection, we could change the internals without changing code that uses our struct. For example, instead of storing our integers in a vector, we could store them in a hash set.
00:04:02.388 - 00:04:48.698, Speaker A: Then the methods to add and remove numbers from that hash set will change. But as long as our public add and remove functions have the same signature code, using our struct doesn't have to care. So, to summarize, the fact that things are private by default but you can use the pub keyword to make things public gives you the ability to encapsulate implementation details in rust. Finally, let's talk about inheritance. Inheritance is the ability for an object to inherit from another object's definition, gaining the data and behavior of that other object without having to define the data and behavior itself. Rust does not have this ability. Specifically, you can't define a struct that inherits fields and methods from another struct.
00:04:48.698 - 00:05:22.988, Speaker A: Rust, however, does have some other tools you can use, depending on why you're reaching for inheritance. There are two main reasons for using inheritance. The first one is code sharing. You can implement behavior on one type, and then all the other types that inherit from it can reuse that behavior. In rust, you can accomplish the same thing by using default trait method implementations. Note that there is a limitation. As of this video traits can only define methods, not fields, although there is a proposal out there that will allow traits define fields.
00:05:22.988 - 00:06:07.108, Speaker A: The other reason to use inheritance is for polymorphism. Polymorphism allows you to substitute multiple objects for each other at runtime if they share certain characteristics. In classical inheritance, that characteristic would be a parent class. For example, you could have a base class called vehicle, and then subclasses that inherent from that, such as truck, motorcycle, car, etcetera. And then you can define a function which takes in a vehicle, and then at runtime you can pass in a truck, a car, or a motorcycle to that function. Rust takes a different approach. In fact, it's so different I had to pause recording and get a haircut just to talk about it.
00:06:07.108 - 00:06:46.830, Speaker A: In rust, you can use generics to abstract away concrete types, and you can use straight bounds to restrict the characteristics of those types. In addition to generics, Rust also provides trait objects which are similar to generics except they use dynamic dispatch, whereas generics use static dispatch. In the next video, I'll be going deeper into trait objects and the difference between static dispatch and dynamic dispatch. Alright, that's it for this video. If you enjoyed it, make sure to give that like button a hug. And if you want to see weekly rust videos, go ahead and give the subscribe button a little smooch. Also, hit the notification bell so you're notified when I release videos.
00:06:46.830 - 00:06:59.350, Speaker A: Lastly, and most importantly, I have created a rust cheat sheet which you definitely want access to, so click the link in the description to get your copy and with that, I'll see you in the next one.
