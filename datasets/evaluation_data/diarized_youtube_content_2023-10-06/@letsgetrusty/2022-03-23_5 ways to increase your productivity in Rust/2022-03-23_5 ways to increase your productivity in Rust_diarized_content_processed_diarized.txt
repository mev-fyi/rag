00:00:00.440 - 00:00:55.325, Speaker A: What's up, Rustations in this video, we're going to be going over tips and tricks that will make you a more productive Rust developer so you can spend less time writing Rust code and more time convincing your boss that your team should use Rust. Also, make sure to stick around till the end of the video for a simple tip that will make writing Rust 10 times easier, but most Rust beginners miss with that said, let's get rusty. First, let's talk about some Cargo plugins that will improve your productivity. In this example, I have a simple guessing game CLI program, which I got from the Rustling book. I can run the program with Cargo Run. However, if I notice something is wrong, first I have to update the code. Then I have to exit out of my program and rerun it.
00:00:55.325 - 00:01:51.777, Speaker A: This process can be improved with a Cargo plugin called Cargo Watch. To install Cargo Watch, run Cargo Install Cargo Watch. Cargo Watch monitors your source files for changes and runs Cargo commands when they occur. For example, we could run Cargo Watch X Run. This will look for file changes and execute Cargo Run when changes are detected. So now when our code changes, our program is automatically recompiled. Cargo Watch also has many useful options.
00:01:51.777 - 00:02:45.965, Speaker A: For example, we could run Cargo Watch dash C to clear the terminal and Q to suppress console output. The next Cargo plugin I want to talk about is Cargo Next Test Cargo Next Test is a next generation test runner for Rust. In this example, I have the RIP Grep repository open. Let's use Cargo's standard test runner by typing in Cargo Test. As we can see, all the tests are passing. Now we'll use Next Test by typing in Cargo Next Test Run. The first thing you'll notice is that the CLI output looks a lot cleaner.
00:02:45.965 - 00:03:27.255, Speaker A: However, this is not the main benefit on some code bases. Next test executes tests 60% faster than cargo Test. On top of that, Next Test can detect flaky tests and partition test runs across multiple CI jobs. Decreasing test execution speed will allow you to iterate faster, thus making you more productive. Speaking of fast iteration, one of the slowest parts of iterating on a Rust program is waiting for it to compile. To decrease compilation times, you can use SCCache, otherwise known as shared compilation cache. SCCache is actually a Mozilla project.
00:03:27.255 - 00:04:11.855, Speaker A: It's a compiler wrapper that allows you to share build artifacts across different workspaces. This means if you have multiple Rust projects with an identical dependency, sccache will allow you to compile that dependency once and share it across those projects. In addition, SCCache allows you to store cache results either on local disk or in the cloud. Another way to improve your productivity in Rust and in general is to use an AI assisted code completion tool, e.g. tab 9 or GitHub Copilot. These tools help you save time by writing less code. For example, here I have a trait called SQL Database, which requires one function called Query to be implemented.
00:04:11.855 - 00:04:58.683, Speaker A: Then I have two structs for Postgres and MySQL. Let's implement SQL Database for Postgres because I have Tab 9 installed as soon as I start writing the signature for query. Tab 9 suggests how to complete this line of code and it turns out that this suggestion is correct. So I can simply press tab and it will autocomplete. Now this is a simple example, but when you're writing a lot of code, these auto completions add up and end up saving you a lot of time. The last productivity tip is a quote from the famous Kent Beck which goes like make it work. Make it right.
00:04:58.683 - 00:05:45.361, Speaker A: Make it fast. This means that when developing first make sure your code works as intended, then refactor your code to make it cleaner, and finally, if needed, optimize your code. When first learning Rust, it's easy to get tripped up by error handling or lifetime management. You can, however, defer error handling by using the Unwrap macro and avoid lifetime management by copying own values or using the RC smart pointer. Now, I'm not saying this will alleviate all the frustrations beginners face when learning Rust, but the point is to get working code as fast as possible without hating Rust because you're fighting the Borrow checker every step of the way. That's it for this video. Let me know if you have any other productivity tips down in the comment section below.
00:05:45.361 - 00:05:55.625, Speaker A: Also, get your free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet and with that said, I'll see you in the next one.
