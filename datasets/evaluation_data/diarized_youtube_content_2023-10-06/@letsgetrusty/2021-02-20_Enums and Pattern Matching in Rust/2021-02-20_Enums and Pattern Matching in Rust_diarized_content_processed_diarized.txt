00:00:00.360 - 00:00:23.105, Speaker A: Welcome back to let's Get Rusty. My name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, make sure to subscribe, because every time you subscribe, we convert a go. Developer. Last time we went over chapter five, in which we talked about grouping related data using structs. If you haven't already, make sure to check that video out. As I mentioned before, structs and enums are the building blocks for creating new types in Rust.
00:00:23.105 - 00:00:50.341, Speaker A: So in this video we're going over chapter six, which will cover enums. Many languages implement enums, but the features vary. In Rust, enums are extremely powerful, and they're most similar to enums implemented in functional programming languages. We'll also talk about a very specific enum called the option enum and go through pattern matching. So with that, let's get started. Enums allow us to enumerate a list of variants. So when is it appropriate to use enums over structs? Let's take the example of IP addresses.
00:00:50.341 - 00:01:17.455, Speaker A: We can enumerate all the variants. There's only two version 4 and version 6, and an IP address can only be one of those variants. Given these properties, if we wanted to express IP addresses in code, using enums would make sense. So let's go ahead and do that. We'll start by using the enum keyword followed by the name of our enum. In this case, it's IP address kind, curly brackets. And then we list our variants, in this case, version 4 and version 6.
00:01:17.455 - 00:01:55.311, Speaker A: Now, in main, we can create instances for each of our variants. Variants are namespaced under their identifier, so in this case we use colon colon to specify each of our variants. Our two variables, 4 and 6, are both variants of the IP address kind type. This means we could, for example, define a function. Our function in this case is called route. That takes in our enum type, and we can pass it either four or six because they're the same type. Our enum is able to capture the version of our IP address, but let's say we also wanted to capture the actual IP address.
00:01:55.311 - 00:02:49.489, Speaker A: So to do that, we might take what we learned in the last chapter and create a struct. We'll define our struct right underneath the enum and we'll call it IP address. The first field is going to be called kind, and the type will be our IP address kind enum, and then the second field will be our actual IP address. In main, we'll create a new variable for our local host IP address. The IP address struct allows us to group the version of the IP address with the actual IP address. But we can make this code even more concise by putting data directly inside the enum variant. To store data inside our variants, we'll add parentheses after the variant and specify what type of data we'd like to store.
00:02:49.489 - 00:03:19.273, Speaker A: In this case, a string for our IP address. Scrolling back down to main. Let's redefine our localhost variable. Note that enum variants can store different types of data. For example, let's say for our version 4 variant, instead of storing a string, we want to store four eight bit integers. As you can see, this is easily done. And now our localhost variable is complaining because we pass a string instead of four integers.
00:03:19.273 - 00:03:40.715, Speaker A: So let's fix that. Enum variants can store a wide variety of types. As an example, let's introduce the message enum. Here we have four variants. The first variant stores no data. The second variant stores an anonymous struct. The third variant stores a single string, and the fourth variant stores three integers.
00:03:40.715 - 00:04:23.921, Speaker A: Note that we could define each of these variants as a separate struct, like so. However, these structs are all of different type. The benefit of an enum is that all of these variants are grouped under the message type, just like structs. We could define methods and associated functions on our enum type. And just like before, to do this, we'll define an implementation block. All right, now let's talk about the option enum. Many languages have null values, and null values represent a useful concept.
00:04:23.921 - 00:04:57.637, Speaker A: A value could either exist or it could be null, meaning that there is no value. But the problem with null values is that the type system can't guarantee that if you use a value it's not null. But in Rust there are no null values. I know, mind blown, but instead we have the option enum. The option enum looks like this and it has only two variants, sum, which stores some value. Here it's a generic, so it could be any value, or none, which stores no value. So if you have a value that could potentially be null or not exist, then you would wrap it in the option enum, as we'll see in a bit.
00:04:57.637 - 00:05:34.815, Speaker A: This allows the type system to enforce that we handle the none case when a value doesn't exist and guarantee that in the sum case our value is present. Optional values are so useful that the option enum and its variance are included in our program scope by default. Here are some examples of optional values. We have an optional integer, an optional String slice and another optional integer, which is set to none. For the first two variables, we didn't have to annotate the type, and that's because Rust can infer the type from the values being passed in. So the first value is an integer here and the second is a string. But for the none case, no value is being passed in, so we do have to annotate the type.
00:05:34.815 - 00:05:59.599, Speaker A: Now let's look at another example. Here we have two variables, X and Y. X is an integer and Y is an optional integer. So it could either be an integer or it could be nothing. Let's see what happens if we try to add these two values together and we get a compile time error. If we hover over the red squigglies, you can see the errors. You cannot add an optional type to an integer type, which makes sense.
00:05:59.599 - 00:06:29.811, Speaker A: They're different types. In order to make our code work, we need to extract our integer out of the sumvariant. In general, to extract values out of the sumvariant, we would write code that handles all possible variants. So, for example, if the variant is none, we run this set of code. And if the variant is sum, we can safely use the value and run this set of code. The option enum also has some very useful methods. For example, let's say in this case, if Y has a value, we'd like to use it, but if it doesn't have a value, we'd like to use a default value.
00:06:29.811 - 00:07:04.827, Speaker A: To do that, we can call the unwrap or method on our Y variable. In this case, our default value is 0. Now, because Y is defined as 5 and X is 5, some will be 10. However, we could change Y to a none value and our code still runs. And that's because Instead of adding 5, we'll now add the default value 0 and sum will be 5. Now let's talk about the match expression. If you remember from previous chapters, match allows you to compare a value against a set of patterns.
00:07:04.827 - 00:07:43.831, Speaker A: These patterns could be literals, variables, wildcards, and many other types, which we'll cover in chapter 18. Having expressive patterns makes the match statement powerful, along with the fact that the match expression is exhaustive, meaning that we have to match all possible cases. This makes the match expression very useful for enums. For example, in this case we have a coin enum, which enumerates various coin types, the penny, nickel, dime and quarter. And then we have a function called value in sense, which takes in a coin and then runs a match expression. Then, for every type of coin, we Simply return its value. Here the code for each arm is short, so we don't have to use curly brackets.
00:07:43.831 - 00:08:14.725, Speaker A: However, if our code was longer, we would. For example, we could change penny to print out lucky penny before returning one. These patterns can also bind to values. To show this in action, let's create another enum which will represent the state minted on each quarter. We'll call our enum usstate and derive the debug trait, which will make it easy to print. Then we'll modify our quarter variant to store the US state. Next, we'll change the last arm in our match expression.
00:08:14.725 - 00:09:00.085, Speaker A: Here we're matching on the quarter variant, and now we have this state variable which will bind to the US state stored inside of quarter and then we simply just print out the State and return 25. Let's scroll back up to main and actually call our function. Here we're passing in a quarter that contains the US state of Alaska. We'll type in cargo run and as you can see, Alaska is printed out. Now let's combine the match expression with our option enum. To do that, we'll create a function that takes in an optional integer and adds one to it. We'll call our function +1 and it'll take in an argument called x, which will be an optional integer.
00:09:00.085 - 00:09:52.480, Speaker A: And we'll also return an optional integer inside the body of our function. Let's use the match expression to match all variants of X. The first variant is none, and in this case we want to just return none. The second variant is sum, and we specify the variable I which will bind to our integer. In this case we want to return our integer +1. Notice that we can't just return I +1, we have to wrap it in sum, and that's because our return value is an optional. Next, let's see how our function could be used in main, Our first variable is 5, which is the integer 5 wrapped in sum.
00:09:52.480 - 00:10:15.755, Speaker A: Then we pass 5 into our plus 1 function. In our plus 1, function x is now our optional and when we match X, we go down each arm in order. The first arm is none, which doesn't match. So we go to the second arm, which is sum. Sum matches, and now I becomes five. Then we return five plus one wrapped in sum. Our second call to plus one is with the value none.
00:10:15.755 - 00:10:51.307, Speaker A: So again we go into our function X will be none, will match on x, and this time we match the first arm, which is none, and then we just return none. Now, as I've mentioned before, match expressions are exhaustive Meaning that we have to match all possible values. So if we remove the first arm, you can see we get an error. The error states that we're missing an arm, and it even specifies that we're not matching on the none variant. In this case, we only have two possible values, sum and none. But imagine a case in which we have many, many different types of values. In that circumstance, we can use the underscore placeholder like.
00:10:51.307 - 00:11:19.633, Speaker A: So this code is saying match X and if X matches sum, execute this code. Otherwise, if it's any other pattern, execute this code. The last thing we're going to talk about is the if let syntax. So let's have a look at this example program. We have a variable called some value, which is equal to 3, and then we match on some value. If some value is exactly 3, then we print 3, otherwise we do nothing. In this case, we only care about one variant, sum containing three.
00:11:19.633 - 00:11:51.249, Speaker A: So it's a little verbose to write the entire match expression. Let's rewrite this using the if let syntax. Now, I'll be honest, this syntax is pretty confusing to me, but let's go through it together. We start with if let, and then the next part is read backwards. So we're saying if some value matches this sum 3, then print 3. The match expression is exhaustive, so we have to specify all values. But when we use the if let syntax, we only have to specify the pattern we care about, and all other patterns are ignored.
00:11:51.249 - 00:12:12.177, Speaker A: We can also see that the if less syntax is slightly less verbose. It saves us one line of code. But like I said, it seems pretty confusing to me, so I would probably just use the match expression. Although it is good to know that the if let syntax exists. And there you have it. Chapter six complete. We discussed enums, pattern matching, the option enum, and the if let syntax.
00:12:12.177 - 00:12:22.695, Speaker A: If you enjoyed this video, make sure to give it a like. And if you want to see more Rust content, make sure to subscribe and hit the notification bell so you can be notified. New videos come out. I'll see you in the next one.
