00:00:01.280 - 00:00:36.251, Speaker A: What's up Rustations? My name is Bogdan and in today's video I'm going to cover eight common mistakes new Rust developers make. Also, at the end of the video I'm going to cover a bonus mistake that even more experienced Rust developers make, so stick around for that. This video is based on a great blog post written by Michael Bryan, and I'll provide a link to it in the description. Speaking of useful things to read, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com forward/cheat sheet. Now let's jump into the video. The first mistake new Rust stations make is unnecessary indirection.
00:00:36.251 - 00:01:20.375, Speaker A: In this example we have a function called Fancy print which takes a string as input and prints it out. A new Rust station may notice that Fancy Print does not need to mutate its input and update the input type to be a reference to an owned string. This works, however, it introduces unnecessary indirection. An own string can be automatically coerced to a string slice, so changing S to a string slice still works. And it has the extra benefit of making the API more flexible because Fancy Print can now accept references to own strings or string slices. The second mistake new Rustations make is overusing slice indexing. Indexing into a slice or array is very common in other languages such as C.
00:01:20.375 - 00:01:58.907, Speaker A: However, it's very easy to crash your program with an index out of bounds error using this approach. Luckily, we can avoid these problems in Rust. In this example, we are calculating the difference between adjacent elements in a vector and must remember to start the for loop at index one, not zero. Instead of indexing into the vector, we can use the Array Windows method to access adjacent elements. We can improve this further by getting rid of the for loop and using the map method instead. As you can see, Rust's powerful type system enables us to safely perform operations on vectors, arrays, and slices. The third mistake new Rust stations make is using sentinel values.
00:01:58.907 - 00:02:32.023, Speaker A: Sentinel values are values that have a special meaning. Examples include negative one, an empty string, and null. Here is a code example In C, the find function takes an array, the array's length, and a value to find as inputs. Negative one is returned if the value could not be found. In Rust, we don't need to use sentinel values because the type system gives us a way to represent optional values. In this Rust code example, get username returns an empty string if ID is not equal to 1. Instead, we can return the option enum.
00:02:32.023 - 00:03:01.163, Speaker A: By updating the function signature, we are making it clear to the caller that this function might return none and that case should be handled. Speaking of enums, the fourth mistake nuvrustations make is not taking advantage of them. In this example, a user's role is represented as a string. This is bad for all kinds of reasons. The role can be mistyped, for example. Also, it's not easy to tell when roles are added or removed. Instead, using an enum would be the right approach in this case.
00:03:01.163 - 00:03:42.303, Speaker A: Here we've defined an enum named role inside Campublish blog. We use a match expression to return the correct boolean value. Match expressions and pattern matching in general are very powerful when used on enums. However, another mistake new rustations make is not utilizing pattern matching enough. In this example an optional type is being checked to be the sumvariant and then unwrapped, and in this example an array is checked to see if it's not empty before retrieving the first element. Both of these examples can be improved by using pattern matching, specifically the if let syntax. The fifth mistake new Rust stations make is not doing error handling properly.
00:03:42.303 - 00:04:21.959, Speaker A: Error handling in Rust is a complex topic that warrants its own video, but I want to highlight two common mistakes. The first mistake is not using the question mark operator for error propagation. In this example we have a function called parse, then add. Inside the function body we parse two string slices as integers, check for parsing errors, and if there are none, return the sum. This code works, but can be improved using the question mark operator to propagate errors. We can shrink this function down to just a few lines of code. Another mistake new Rust stations make is creating custom error types that don't implement the error trait.
00:04:21.959 - 00:05:02.527, Speaker A: Implementing the error trait has a few benefits. It semantically marks your type as an error, it gives your type the basic components of a good error in Rust, and it allows your type to work with the rest of the Rust error ecosystem, specifically third party crates. However, implementing the error trait manually is tedious and involves boilerplate that can clutter your code. Instead, you should use the this error library to implement the necessary traits via macros. The sixth mistake new restations make is not using traits provided in the standard library. Let's go through a few useful ones. The default trait allows you to provide useful default values for your types.
00:05:02.527 - 00:05:45.053, Speaker A: In this example we have a struct called player. Instead of manually initializing level items and special power every time we construct a new player instance, let's implement the default trait. Now we are able to construct new player instances by calling the default associated function. Also note that the default trait can be derived if all the structs fields also implement default. Another set of useful traits is from and try from. These traits allow you to convert between types and are especially useful for converting between errors. The only difference between these traits is that try from is used for conversions that can potentially fail, while from is used for conversions that must not fail.
00:05:45.053 - 00:06:23.187, Speaker A: In this example, we've defined a custom error type called CLI error. It has two variants, IO error and parse error. Then we implement the from trait twice, one implementation to convert an IO error to a CLI error and the other to convert a parseint error to a CLI error. Finally, we'll define a function called Open and parse file and use the question mark operator to convert and propagate errors with ease. Another useful trait is from str. This trait allows you to parse user defined types from a string. For example, here we have a struct called point with an x and y field.
00:06:23.187 - 00:07:01.645, Speaker A: By implementing the From Stirred trait, we can write code which parses any given string into a point instance or fails if the string is malformed. In this case, we are specifying that the string should have coordinates defined inside parentheses separated by a comma. Then we are able to create new point instances from strings. This is especially useful when parsing string data from files. The seventh mistake new row stations make is not taking advantage of macros in the standard library. The first useful macro is to do, which allows you to compile your program with unfinished code. This is especially useful when prototyping.
00:07:01.645 - 00:07:35.225, Speaker A: In the following example we have a struct called DB which implements the database trait. For this code to compile, we must implement all the required methods. However, let's say we only care about the connect method at the moment. We can use the to do macro inside Query's function body and have our code compile without actually implementing the method. Then in main we can create a new instance of my DB and call the Connect method. Note that if we did call the query method, the program would panic at runtime. The last set of useful macros I want to talk about is concat and format.
00:07:35.225 - 00:08:11.883, Speaker A: Concat allows you to easily concatenate literals into a static string. Slice and format allows you to easily create own strings using interpolation. Both of these macros are useful when working with strings. The eighth mistake New Rust stations make is not using the tooling Rust provides specifically Cargo format and Cargo Clippy. Cargo Format is a tool for formatting your Rust code according to predefined style guidelines. This ensures your formatting is consistent and easy to read. To run Cargo format, simply navigate to the root of your Rust project and run Cargo Format in your terminal.
00:08:11.883 - 00:08:44.737, Speaker A: You can also configure Cargo format to run automatically on Save by installing Rust Analyzer and then enabling Format on Save in Settings. JSON Clippy is a linter for your Rust code. It catches common mistakes and improves your code. You can run Clippy by executing Cargo Clippy in the root of your Cargo project. You can also add additional arguments. For example, you can make complex code violations errors rather than warnings. Or you can elevate all warnings to errors, which is useful for continuous integration builds.
00:08:44.737 - 00:09:27.665, Speaker A: Speaking of continuous integration, it's very simple to set up Clippy with GitHub Actions. In this case, we are running Clippy on Git push and failing the build if any warnings appear. Now, before we move on to the bonus mistake even experienced Rust developers make, let me know if you're enjoying this video by hitting the like button and subscribing to the channel. All right, the last mistake I'd like to talk about has to do with structuring your code. Popular languages like Python, Java, and JavaScript allow you to easily share and mutate objects. However, because of Rust's ownership memory model, you must be careful when combining multiple ownership and mutation. Michael gives a good example of this in his blog, so let's go through it together.
00:09:27.665 - 00:09:58.505, Speaker A: Imagine implementing the logic for a game where a player must attack a group of monsters. Once the player inflicts enough damage, they win. First, let's implement the logic. In TypeScript. We'll create a class named Monster, which has a health property, a takedamage method, and a receiveddamage property, which stores a list of callback functions. These functions are called whenever the takedamage method is executed. Next, we'll create a class called damagecounter, which will track the total damage the player has inflicted.
00:09:58.505 - 00:10:34.083, Speaker A: Ondamageinflicted will be used to track total damage, and reachtargetdamage will be used to check if the goal is reached. Finally, we'll create a damage counter instance and an array of monsters. Add a callback which calls Counter ondamageinflicted for each monster, and set up a while loop to inflict random amounts of damage on random monsters until the goal is reached. In TypeScript, this code is straightforward and works as you would expect. Now let's try porting it to Rust. Instead of a monster class, we'll define a monster struct. Otherwise, the code is very similar.
00:10:34.083 - 00:11:29.435, Speaker A: We have a takedamage method which decreases self health and calls each callback with the damage received, and an addlistener method which accepts a closure and adds it to the vector of callbacks. We also implement the default trait to easily construct new instances of monster. Then in main we'll create a new damage counter instance, create a vector of monsters, add a callback which executes counter on damage received to all monsters, and run a while loop containing code which inflicts random amounts of damage on random monsters until the goal is reached. Pretty simple, right? Well, this code doesn't actually compile. In fact, there are several compile time errors. The first error we get is cannot borrow counter as mutable as it is a captured variable in a F enclosure. The problem is the closure on line 56 captures counter as an immutable reference.
00:11:29.435 - 00:12:27.397, Speaker A: However, counter ondamagerceived needs a mutable reference to self. We also get an error stating that we are borrowing counter mutably more than once because the closures are added in a loop, an error stating counter does not live long enough because it's in a boxed closure and no lifetime annotations are specified, and an error stating that we cannot immutably borrow counter because it is already borrowed as mutable. All these errors stem from the strict borrowing rules in Rust. To fix these issues, the common approach is to introduce multiple ownership and interior mutability. First, we'll wrap counter in the RC Smart Pointer, which enables shared ownership, and the RefCell Smart Pointer, which enables interior mutability. Then we'll update the for loop by cloning counter, moving it into the closure, and creating a mutable reference before calling on damage received. Finally, we'll update the while loop to take an immutable reference to counter before calling reach target damage.
00:12:27.397 - 00:13:22.951, Speaker A: With that, our code is now compiling, but you may be wondering what's the mistake here. In general, the mistake Rustations tend to make is overusing the RC and RefCell smart pointers or its counterparts arc and mutex. Besides the downsides of increased code complexity and decreased performance, you also get a decrease in memory safety because interior mutability works by checking borrowing rules at runtime instead of compile time. This means if you're not careful, your code can cause deadlocks and crashes. So what's the alternative? The alternative is changing your API or code structure so that you're not holding long lived references to other objects. For example, instead of storing callbacks in a field in the Monster struct, we could have the takedamage method take a callback as input. This would get rid of the need for smart pointers and simplify the main function.
00:13:22.951 - 00:13:59.490, Speaker A: If, however, passing in a callback isn't a good option for your specific use case, there is another approach. Instead of accepting a closure, the TakedaMage method can return a summary of what happened as a result of inflicting damage. Then we can use the summary data to call on damage received. As you can see, programming in Rust requires thinking about how your code is structured and how memory is being used. That's it for this video. Let me know what you consider to be common mistakes new Rust stations make in the comments section below. Lastly, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com
00:13:59.490 - 00:14:04.255, Speaker A: CheatSheet with that said, I'll see you in the next one.
