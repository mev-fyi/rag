00:00:00.400 - 00:00:35.805, Speaker A: Welcome back, Rust Gang. If you're joining us for the very first time, my name is Bogdan and this channel is all about the Rust programming language. In today's short video, we're continuing our series on advanced Rust by talking about advanced functions and closures. So with that, let's get rusty. First, we'll talk about function pointers. Previously we've talked about passing closures to functions, but you can also pass functions to functions. This is useful when you want to pass in a function you've already defined.
00:00:35.805 - 00:01:17.579, Speaker A: Instead of creating a new closure to pass in a function as an argument to another function, we can use a function pointer which is specified with the lowercase fn. If we hover over this fn here, you can see it says fn is a function or a function pointer. In this example we have a function called do twice, which takes in two arguments. The first argument is called f, which is a function pointer with the following signature. The function will accept an integer and return an integer. Then our second argument is called arg, which is just going to be the argument passed in to our function pointer. Inside the function body, we call F2 times, passing in the argument, and then return the sum.
00:01:17.579 - 00:01:56.907, Speaker A: In main, we create a new variable called answer, which is going to be equal to the return value of do twice, and then we pass in add one, which is a function we defined up above that takes in an integer, adds one to it, and returns the new integer and the value 5 inside of do twice. We're going to call F with our argument. So in this case we're going to call add one with the argument five, which is going to result in six. Then we're going to do that again. So we're going to have 6 plus 6, which is going to equal 12. So in this case the answer is 12. Unlike closures, FN is a type rather than a trait, so we can specify FN directly instead of using one of the function traits as a trait bound.
00:01:56.907 - 00:02:50.247, Speaker A: If you recall from the video on closures, there are three closure traits, and they are FN, FNMU and FN1S. FN specifies that the closure captures the variables in its environment immutably. FN specifies that the closure captures the variables in its environment mutably, and FN1 specifies that the closure takes ownership of the values in its environment, thus consuming the variables. Function pointers implement all three closure traits. So if you have a function that expects a closure, you can pass in a closure or a function pointer, which is why it's best practice to Write functions that accept closures. For example, we can update the f argument here to take in a closure or a function pointer by doing the following. First we'll specify a generic which is going to be T, and we'll say that F takes in this generic t type.
00:02:50.247 - 00:03:36.261, Speaker A: Then we're going to introduce a trait bound. So we're going to say T is going to be anything that implements the fn trait. This is a subtle difference, but now we're using the capitalized fn, which is a closure trait bound, rather than the lowercase fn, which is a function pointer type. This allows us to pass in a function pointer or a closure to our f argument here. And as you can see, our code still compiles do twice. Can still take in our Add one function One case in which you might only want to accept function pointers instead of function pointers and closures is if you're interfacing with external code that does not support closures. For example, C functions can accept functions as arguments, but the C programming language does not support closures.
00:03:36.261 - 00:04:22.607, Speaker A: Let's look at another example where we can use a closure or a predefined function. In this example we have a variable called list of numbers, which is a vector of numbers numbers, and then we convert that vector of numbers into a vector of strings by calling the map. Function map will take in a closure or a function pointer that will be called for every element in the iterator. In this case, for every integer in our vector, we're going to call tostring to turn it into a string. And then here we call collect to turn our iterator into a vector of strings. Currently we're passing in a closure to map. However, we can pass in a function pointer like so here we're passing in the tostring method on the tostring trait, which will be implemented for any type that implements the display trait.
00:04:22.607 - 00:05:17.567, Speaker A: Note that we have to use this fully qualified syntax because there are multiple methods named tostring in the scope. Here's another useful pattern that exploits an implementation detail of tuple structs and tuple struct enum variants. Tuple structs use parentheses to initialize values inside the tuple structure which look like a function call. In fact, these initializers are implemented as functions that take an arguments and return an instance of that tuple struct. This means we can use these initializers as function pointers. For example, here we're creating a vector of statuses by calling map on a range of integers, passing in our value variant to map, map is going to treat value like a function pointer, where the argument is going to be an integer, and then the return value is going to be a value variant. Some people prefer this style, other people prefer using closures, but in any case they both get compiled down to the same code, so it's up to your personal preference.
00:05:17.567 - 00:05:58.695, Speaker A: The last thing I want to talk about is returning closures from functions. Here we have a function called returns closure, which is always going to return the same closure. Closures are represented using traits, so we can't return a concrete type here. Instead, what we can do is use the impulse syntax. For example, here we can say we're going to return something that implements the FN trait, taking in an integer and returning an integer. Note that this syntax will not work in all situations. For example, let's say that our returns closure function took in an argument A, which is going to be an integer.
00:05:58.695 - 00:06:37.241, Speaker A: Then let's say we wanted to return a closure based on the value of A. In this case, if A is greater than zero, then we want to return a closure that will take in an argument B, add it to A, and then return the sum. Otherwise, we're going to return a closure that takes B as an argument, subtracts B from A, and returns the difference. Notice that we get an error here. If I hover over it, it'll say that no two closures, even if identical, have the same type. Consider boxing your closure and or using it as a trait object. As the AIR states, each closure is a unique type, even if identical to another closure.
00:06:37.241 - 00:07:21.353, Speaker A: The two closures we have defined here are different types, and the impulse trait syntax only works if we're returning one type. In this case, we're returning one of two types depending on the value of A. So in this case, instead of using the impulse syntax, we can return a trait object. Now, just like with other trait objects, Rust doesn't know the size of the closure being returned, so we have to wrap it in some sort of pointer. In this case, we'll use the box smart pointer, and then we'll also need to wrap our closures inside the function body in a box Smart pointer. Now, as you can see, our code is compiling. That's it for this video.
00:07:21.353 - 00:07:44.645, Speaker A: If you enjoyed it, then go ahead and tickle that like button. And if you want to see weekly Rust videos, then go ahead and subscribe and hit that notification bell. Lastly, and most importantly, I have a free Rust cheat sheet which I would like to give to you. So if you want access to that, then head over to LetsGetRusty.com Cheat Sheet. And with all that said, I'll see you in the next one.
