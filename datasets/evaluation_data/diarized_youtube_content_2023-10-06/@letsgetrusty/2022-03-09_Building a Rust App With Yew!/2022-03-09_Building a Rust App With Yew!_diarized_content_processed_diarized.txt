00:00:00.440 - 00:00:39.852, Speaker A: What's up Rust stations? Welcome back to let's get rusty, your number one resource for all things Rust. In today's video, we're going to be building a simple counter web app using the U framework. U is a modern rust framework which allows you to create multi threaded web apps using webassembly. U is component based like react, offers great performance, and is interoperable with JavaScript. Alright, with the intro out of the way, let's get rusty. Before we start writing our app, we need to do some basic setup. First, make sure you have rust 156.0
00:00:39.852 - 00:01:30.230, Speaker A: or above installed. To check which version of rust you have, simply run rustc version. Next, we need to install the Webassembly compilation target. To do this, run rustup target add Wasam 32 unknown unknown lastly, we need to install a tool called Trunk, which is a webassembly web application bundler for rust. To do this, simply run cargo install trunk I already have trunk installed, but if you're installing trunk for the first time, note that it could take quite some time. Alright, our setup is now complete. Next, let's create a new cargo project called UAPP.
00:01:30.230 - 00:02:12.996, Speaker A: Then we'll cd into the UAPP directory and open it up in versus code. The first thing we'll do is open up cargo toml and add u as a dependency. Then we'll open up main rs and import everything from the U prelude. This will give us everything we need to build our U app. As I've mentioned before, components are the building blocks in you. Components are able to manage their own state and render themselves to the DoM, much like react components. Let's create our first component.
00:02:12.996 - 00:02:54.936, Speaker A: To do that, we'll add a struct called countercomponent. Counter component is going to have one field called count, which is going to be assigned a 64 bit integer. The fields in this struct represent the state of our component. Next, we'll add an enum called message. Our enum will only have one variant called addone. The message enum represents the type of messages our component can receive. Messages can be dispatched based on UI events, for example, a button click.
00:02:54.936 - 00:04:20.380, Speaker A: Now that we have our component state and the messages our component can receive, the last thing we'll do is implement some lifecycle methods on our component. To do that, we'll implement the component trait for counter component. First, we'll need to set two associated types, message and properties. Message is going to be set to our message enum and properties is going to be set to a unit type properties describe the data passed in from a parent component like props in reactival. In this case, our counter component doesn't have any properties. Next, we'll implement the first lifecycle method called create is called when our component is created, one argument is passed in which is a reference to context. Context has two fields properties the parent component is passing in, and scope.
00:04:20.380 - 00:05:29.224, Speaker A: Scope is used to create callbacks which pass messages to our component. In this case, we don't need to use context. We'll simply return an instance of counter component with count initialized to zero. The next lifecycle method we'll implement is called update. It update is responsible for handling messages sent to the component. This lifecycle method gets three immutable reference to self, a context, and the message being sent inside the method body. We use a match expression to handle any type of message this component can receive.
00:05:29.224 - 00:06:23.442, Speaker A: In this case, we only have one message variant called addone. When the message addone is received, we'll increment count and then return true, which we actually have to specify in the signature. The update method returns a boolean which determines whether the component should be re rendered or not. In this case, we do want to re render our component after incrementing the count so the new number is displayed on the screen. The last lifecycle method well implement is called view. The view method describes how a component should be rendered. This is similar to the render function in react.
00:06:23.442 - 00:07:18.520, Speaker A: Vue gets passed two parameters, an immutable reference to self and context, and the return type is HTML. To describe how the HTML for this component should look, we can use the HTML macro. This macro allows us to write HTML code inside rust similar to JSX in react. Our HTML consists of a wrapper div with the class container and two elements, a paragraph where the text is self count and a button where the text is one. When this button is clicked, we want to increment self count and re render this component. To do that, we'll first get a reference to scope from context by calling the link method. Then well add an onclick handler to our button.
00:07:18.520 - 00:08:26.478, Speaker A: Inside the onclick handler we call the callback method onlink, which will create a callback that sends a message to the linked component. Callback takes a closure with one parameter, in this case a mouse event which we'll ignore using underscore and simply return the message add one our component is fully functional. When this button is clicked, the add one message will be sent to our component. Then the update method will get the addone message incrementself count and re render the component the last thing we need to do is start our UAPP in Main. Here we're simply calling StartApp and passing in our root component, which in this case is going to be counter component. Before running our app, we also need to add a simple index HTML file to the root of our repository. All right, now we're ready to run our app.
00:08:26.478 - 00:08:58.840, Speaker A: Let's open up a terminal and type in trunk serve trunkserve does a few things. First, it builds our webassembly app. You can see the artifacts in the dist directory. It also spawns a web server for us. Here we can see that the web server is listening on localhost port 8080. Lastly, if we change our code, our webassembly app will be rebuilt and our web server will refresh. Let's open up a web browser and navigate to localhost 8080.
00:08:58.840 - 00:09:50.040, Speaker A: Its really hard to tell but if I zoom in you can see that our UI is actually displaying and if I click the button our counter is functional. Lets improve this experience by styling our UI. Unfortunately, as of this recording Yu doesnt offer a built in way to style components. We can however style our components using a CSS stylesheet and trunk assets. First, let's add a new file to the root of our repository called style CSS. Then we'll add the styling for our app. Remember that our div wrapper had a class called container, so we can use that class to style our components.
00:09:50.040 - 00:10:30.190, Speaker A: Lastly, we just need to link the CSS file inside index HTML. Note that our link tag must have a data trunk attribute so that trunk knows to process this file and include it inside the disk directory. Let's open up our web browser again and as you can see the UI looks a lot better. Alright, that's it for this video. If you want access to the code, a GitHub repository link is in the description. Let me know you like this video by tickling that like button. And if you want to see more project based videos, let me know down in the comments section below.
00:10:30.190 - 00:10:40.450, Speaker A: Lastly, get your free rust cheat sheet by heading over to letsgetrusty.com cheatsheet and with that said, I'll see you in the next one.
