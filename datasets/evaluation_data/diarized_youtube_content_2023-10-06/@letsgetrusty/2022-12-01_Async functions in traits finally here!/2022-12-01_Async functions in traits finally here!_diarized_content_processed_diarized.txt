00:00:00.400 - 00:00:32.391, Speaker A: In Rust we have an async await syntax similar to JavaScript. This syntax allows us to write asynchronous code that looks similar to synchronous code. The most common use of async await is with async functions. An async function is a function that returns a future. A future represents an asynchronous task to be done, similar to a promise in JavaScript. The main difference is that futures are lazy, meaning they won't do any work unless you explicitly await them. This allows futures to be a zero cost abstraction.
00:00:32.391 - 00:01:00.493, Speaker A: Despite being great for developing concurrent applications. Rust's async away syntax has a historical problem. Imagine you want to define an async function on a trait. In this example we have a trait called database with an async function called fetch data. You might expect something like this to work. Unfortunately, it doesn't. To understand why, let's remove the syntactic sugar the async keyword provides and define the return type of fetch data explicitly.
00:01:00.493 - 00:01:36.835, Speaker A: Here we use generic associated types to specify that fetch data returns some type that implements the future trait. The problem is we can't actually implement this trait because we can name the concrete type returned by an async block. This is because each async block creates a unique type. Instead of specifying a concrete type, we could set fetch data to imple future. However, impl future is not supported in associated types just yet. There are some workarounds available, but they have various drawbacks. One of them is returning boxed futures.
00:01:36.835 - 00:02:13.211, Speaker A: As you can see, this is very verbose. However, we could use the async trait crate macro to write this boilerplate code for us. This workaround has some drawbacks. For example, it relies on the standard library, which embedded applications usually avoid. It also requires dynamic dispatch and heap allocation, which may be a non starter for performance critical applications or libraries. Fortunately, the Rust team has recently released support for async functions inside traits on the nightly version of Rust. After enabling the experimental feature, you can write and implement traits with async functions.
00:02:13.211 - 00:02:42.391, Speaker A: As you would expect, the Rust team is already planning to use this new feature in the async iterator trait. Currently, this trait relies on manual pull implementations. However, now it can be written like this. As you can see, the code looks a lot cleaner. Before we go further, it's important to mention that this feature has a couple of limitations. Firstly, you cannot call an async function with dynamic dispatch. Solutions are being discussed, but none are close to completion.
00:02:42.391 - 00:03:20.655, Speaker A: In the meantime, if you need dynamic dispatch to work, you can use the asynctrate macro mentioned earlier in this video. Another limitation is that you cannot spawn a generic function while using a work stealing executor like Tokio. This is because we would need to express that the future returned by the async function implements send. Currently, there's no good way of doing that. There is a temporary solution using another Nightly feature, but it's not ideal. Note that the Rust team is working on implementing a better solution. Despite these limitations, Async functions in traits may not be that far from stabilization.
00:03:20.655 - 00:03:48.245, Speaker A: If you want to try out this new feature, you can change your Rust compiler to the Nightly build and experiment with it. The more people testing and giving feedback, the better. That's it for this video. But before you go, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheatsheet also, make sure to give this video a like and if you want to see weekly Rust content, then subscribe to the channel. With that said, I'll see you in the next one.
