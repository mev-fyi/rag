00:00:00.360 - 00:00:37.684, Speaker A: Welcome back to let's get Rusty. My name is Bogdan, and this channel is all about the rust programming language. If that sounds interesting to you, make sure to tap that subscribe button so you can get rust videos every single week. Last time we went over chapter seven, in which we talked about managing large projects using Rust's module system. In this video, we'll go over chapter eight, which talks about common collections. Collections allow you to store multiple values, but unlike arrays or I or tuples, collections are allocated on the heap, meaning the size of the collection could grow or shrink as needed. Specifically, we'll talk about vectors, strings, and hashmaps.
00:00:37.684 - 00:01:24.126, Speaker A: So with that, let's get started. The first collection type. We'll talk about our vectors here. I created a new package called collections, and in main I've defined an array called a, and it contains sign 32 bit integers. So now let's create a vector of signed 32 bit integers. We'll call our vector v, and we'll specify the type as a vector of sine 32 bit integers, and then we'll set that equal to vec new here we're calling the new function on the vector type, which will create an empty vector. Now, vectors can hold any type of values, and because we're not initializing the vector with any of values, rust can't infer what type we want.
00:01:24.126 - 00:02:21.940, Speaker A: So here we have to specify the type using generic syntax, and in our case, it's sine 32 bit integers. Now, a vector can grow in size, so even though this vector is empty right now, we can add elements to it. To do that, let's make the vector mutable, and then we can call a method called push to push elements onto the vector, like so. So here we're pushing one, two, and three onto our vector. Now, if we wanted to create a vector and initialize it with values at the same time, rust has a convenient macro for that. So let's create another variable called v two, and we'll set that equal to vec exclamation point, and then specify the values we want to initialize the vector with. This looks very similar to our array initialization, except that we have the vec macro specified in the beginning here.
00:02:21.940 - 00:03:03.094, Speaker A: And notice that we didn't have to specify the type explicitly, and that's because rust couldn't infer the type from the values we passed into the macro. Note that vectors, just like any other type stored on the heap, will be dropped when they go out of scope. So to illustrate this, let's put our v two variable in its own scope. When this scope ends, which is right here, v two will be dropped. Also, all the elements inside of our vector will be dropped as well. Now let's talk about accessing elements inside of a vector. There are two ways to access elements, and the first way is to directly reference an index in the vector.
00:03:03.094 - 00:03:41.018, Speaker A: As an example here I have a vector called v with five elements, and what we'll do is access the third index. Here we create a variable named third, which is equal to ampersand v, and that specifies a reference to our vector. And then we use brackets to specify the index we want, and it's zero based. So if we want third index, we specify the number two. Then we just print our variable. Let's go ahead and run this program. We'll type in cargo run, and we see that the third element is three, which is correct.
00:03:41.018 - 00:04:25.210, Speaker A: Now the problem with this approach is that we can specify an invalid index. For example, instead of two, let's put 20 here. Now, we don't have element at the 21st index, so when we try to do cargo run, we'll get an error. Here we get an index out of bounds error, which says that the length of our vector is five, but the index we specified is 20. Now notice that this is a runtime error. If we use an array and try to access index that was out of bounds, we would get a compile time error, so the program wouldn't even run until we fix the error. And that's because with arrays we know the size of the array at compile time, but with the vector, we don't know the size at compile time.
00:04:25.210 - 00:05:16.408, Speaker A: Vectors are stored on the heap, so they could be of variable size. All that to say, if you directly reference an element in a vector, then you're saying I expect my program to crash at runtime if an invalid index is used. But let's say you don't want your program to crash if an invalid index is used instead, you want to handle that case gracefully. In that situation, rust provides a safer way to access elements in a vector using the get method. Let's change this 20 back to two, and at the bottom here we'll use the get method to access the third index. Now here, instead of getting a reference to the third element directly, we're calling the get method and passing it our index. And the get method, as you can see here, returns an option.
00:05:16.408 - 00:05:55.810, Speaker A: You might recall from my video on enums that the option enum represents some value or no value. Here we use a match expression to handle both the sum case and the none case. In the sum case, we get our integer and store that in a variable called third, and then we print the variable out. In the none case, we print out that there is no third element. Let's comment out the print line statement up here and run our program again, and we get the expected output. The third element is three. Now let's change this to 20 and we'll run our program again.
00:05:55.810 - 00:07:05.870, Speaker A: This time, instead of throwing a runtime error, our get method returns none because there is no element at the index we specified. So we execute the code in our none branch. So again, if you want to handle index out of bounds errors gracefully without crashing your program, you would access elements on your vector using the get method. Now, when we access elements in a vector, we are getting a reference to that element. And if you recall in the video I did about ownership in rust, there are some rules around references, namely that you cannot have a immutable reference and immutable reference to the same thing at the same time. For example, let's say after we create this third variable up here, and before we print it out, we want to add an element to our vector, like so, and we'll need to make our vector mutable. Now, if I uncomment this print line, you see that we get an error, and the error states we can't borrow v as mutable because it is already borrowed as immutable.
00:07:05.870 - 00:07:51.344, Speaker A: On line four, we take an immutable reference to a value in the vector. On line five, we take immutable reference to push a new element onto the vector. And then on line six, we use our immutable reference that we created on line four. This is a problem, because when we have an immutable reference to something, we expect the underlying value to not change. But if we have a mutable reference to the same thing, then the underlying value could change. And the way that happens with vectors is that when we push a new element onto a vector, we might need to allocate more memory to make room for that new value. And when we do that, we need to move all the elements in our vector to new memory locations.
00:07:51.344 - 00:08:33.618, Speaker A: And if that were to happen, then our variable we declared here on line four would be pointing to something else. Now let's talk about iterating over elements in our vector. For example, let's say we want to iterate over all the elements in our vector v and print them out. To do that, we can use the for in loop. So we'll type out for I in, and then we'll take a reference to our vector and print out each element. Let's run our program and we get our list of elements printed out. What's happening here is we're looping through all the elements in our v vector, and we're taking an immutable reference to each element and then printing it out.
00:08:33.618 - 00:09:17.828, Speaker A: But we could also take a mutable reference and then modify the value. Here we're using the dereference operator to get the underlying value and add 50 to it. We'll learn more about the dereference operator in chapter 15. Underneath this foreign loop, let's print out all our values again, and then we'll run our program, and you can see that all the values in the vector have 50 added to them. The last thing I want to talk about with regard to vectors is storing enum variance inside of a vector. As I've mentioned before, vectors can only store one type of data. But let's say we want to store different types of data.
00:09:17.828 - 00:09:56.120, Speaker A: In this example, we want our vector to represent a row of cells in a spreadsheet. Each cell could store either an integer, a floating point number, or a string. In order to represent this in a vector, we can create an enum that represents the cell. We'll call a spreadsheet cell and then create variance for each type of data. In this case, we have an int variant, a float variant, and a text variant. Now, remember that all of these variants are under the same type, which in this case is spreadsheet cell. So we could create a vector of spreadsheet cells, and then inside the vector we could have different variants.
00:09:56.120 - 00:10:36.062, Speaker A: Now, the only catch is when you reference a specific element inside of the vector, you have to use a match expression to figure out which variant of the enum it is. And that's because our vector is of type spreadsheet cell. So here we're referencing the second element in our vector, and we're saying if it's an integer, then print out the integer, and if it's anything else, print out not an integer. All right, now let's talk about strings. And before we start, I just want to say that strings are pretty dang complicated. In higher programming languages, the complexity of strings is abstracted away from the programmer. But in lower programming languages such as Rust, we have to deal with that complexity.
00:10:36.062 - 00:11:06.546, Speaker A: So with that preface, let's talk about what a string actually is. In rust, strings are stored as a collection of UTF eight encoded bytes. So let's just start with a collection of bytes. We see a string as letters and numbers, but a computer only understands ones and zeros. So in memory, a string is just a list or a collection of ones and zeros. Now, a program needs to be able to interpret those ones and zeros and print out the correct characters. And that's where encoding comes into play.
00:11:06.546 - 00:12:04.644, Speaker A: So what is the UTF eight encoding? In order to understand UTF eight, we first have to understand ASCII, or the american standard code for information interchange. ASCII is a string encoding, so it defines how to take ones and zeros and turn it into a string, or take a string and turn it into ones and zeros. The problem is, each ASCII character is stored as a byte, and only seven bits of that byte are used to represent the character. That means ASCII can only represent 128 unique characters. And so ASCII only represents the english Alphabet, some special characters, and a few commands. Now, because ASCII only represents english characters, other countries created their own encoding standards that could represent characters in their language. Now, this is problematic because with all these different encoding standards, how does a program know which standard to use when parsing a collection of bytes? And so, to solve this problem, Unicode was created.
00:12:04.644 - 00:12:53.026, Speaker A: Unicode is a universal character set, meaning that it represents characters from all the well known languages and also things like emojis. Another great part of Unicode is that it's backwards compatible with ASCII, and that's because the first 128 symbols of Unicode are ASCII characters. So you can use a Unicode encoding to parse ASCII text. And now that we understand Unicode, let's talk about UTF eight. UTF eight is a variable with character encoding for Unicode variable width, because each character in UTF eight could be represented as one byte, two bytes, three bytes, or four bytes. This is very important. Remember that in ASCII each character is represented by one byte, but with UTF eight, each character could be a different size in terms of bytes.
00:12:53.026 - 00:13:26.342, Speaker A: UTF eight is the most popular encoding of Unicode, so you've probably seen it before. That's why in rust we use UTF eight as well. Now that we have some background about strings, let's talk about creating a new string. Just like with the vectors, we can use the new function to create an empty string. We can also define string slices like so we could take the string slice and turn it into an own string by using the tostring method. Lastly, we can create an own string from a string slice by using the from function. Remember that strings are utf eight encoded, so we can write strings in English, but we could also write strings in many other languages as well.
00:13:26.342 - 00:13:55.892, Speaker A: Now let's talk about appending to a string. Just like a vector, a string can grow or shrink in size. Here we create a new string called s, and it contains foo. And then we can use the push stir method to append bar to the string. And this method takes a string slice, because we don't actually want to take ownership of the string being passed in. We can also append characters to the end of a string using the push method. At the end of these operations, our string will be foo bar exclamation point.
00:13:55.892 - 00:14:40.618, Speaker A: We can also append strings using the plus operator. So here we have s one and s two defined, and then s three is equal to s one plus a reference to s two. What's happening here is removing ownership of s one into s three, and then we're taking all the characters in s two and appending them to the end of s three. And this saves a little bit of memory compared to copying both strings. Also note that because we moved ownership of s one, if we try to use s one after we've declared s three, then we'll get an error, and the error states that we cannot borrow a value after it's been moved. We can also concatenate these strings using the format macro like so. In this case, we're combining s one and s two and storing that in s three.
00:14:40.618 - 00:15:17.358, Speaker A: The format macro doesn't take ownership of these strings, so we can still use s one and s two after this call. Now let's talk about indexing into a string. Here we have the string hello and what we want to do is get the first character. In higher programming languages, this could simply be done by using brackets and specifying the index of the character you want. But in rust, you see, we get an error and it says that our string cannot be indexed by an integer. Why is this? Well, remember that a string is a collection of bytes. So what's the length of our hello string? You might say five, because there are five characters, and that would be correct because each of these characters is one byte.
00:15:17.358 - 00:16:01.920, Speaker A: However, let's change hello to which is hello in Russian. Now, what's the length of this string? You might say twelve, because you see twelve characters, but actually it's 24 because each of these characters is two bytes long. Remember, in UTF, eight strings could be one to four bytes long. So if we wanted to get the first character in our string, using this syntax would not work, because here we're specifying the first byte in our collection of bytes. But the first character is two bytes, so this would only give us half the character, which is not what we expect. To better understand this, let's talk about the three relevant ways a word is represented in Unicode. So here we have the hindi word namaste, and it can be represented in three different ways.
00:16:01.920 - 00:16:26.468, Speaker A: The first way is a collection of bytes, and you can see here there are 18 bytes in this word. The second way is scalar values. You can think about these as building blocks in Unicode. They could represent a full character or parts of a character. And in rust, this is what the char type refers to. And lastly we have grapheme clusters. This is what you and I would consider a character.
00:16:26.468 - 00:17:02.268, Speaker A: So Namaste has four grapheme clusters. The problem with indexing into a string is rust doesn't know what we want to receive, bytes, scalar values, or grapheme clusters. So we have to use more specific methods. In order to access the bytes of a string. We can use the bytes method, like so the bytes method returns a collection of bytes. And here what we're doing is iterating over every byte and printing it out. So let's go ahead and run our program, and you can see we get a list of bytes.
00:17:02.268 - 00:17:51.560, Speaker A: Similarly, we can iterate over our scalar values using the chars method, like so let's go ahead and run our program, and here we get our list of chars. And lastly we have grapheme clusters. And you might be thinking, great, this is what I wanted all along. Well, unfortunately, in order to keep the rust standard library lean, the ability to iterate over grapheme clusters is not included by default. To iterate over grapheme clusters, we need to import a crate. Let's head over to my cargo toml file, and you can see I already included this Unicode segmentation crate, which will allow us to iterate over grapheme clusters. Since I already have this included, let's go back to our main Rs file and bring it into scope.
00:17:51.560 - 00:18:30.342, Speaker A: Then we can scroll down and add the following code. Here we're calling the graphemes method on our string, which will give us a collection of graphemes we're passing in. True, to get extended grapheme clusters which we want, and then printing out each individual grapheme. Let's go ahead and run our program, and you can see we get the characters we'd expect. As you can see, strings are pretty complex, and in rust we have to deal with that complexity. If you're still confused, don't worry. I plan to make an entire video about strings in the future, but for now, let's continue on to hashmaps.
00:18:30.342 - 00:19:00.440, Speaker A: Hashmaps allow you to store key value pairs, and those keys and values could be of any type. Also, it uses a hashing function to determine how to place those keys and values in memory. In order to create a new hashmap. First we need to bring the hashmap type into scope from the standard library, like so. Next, let's define some keys. In this case, we want to track a game. So we want the keys to be the team name and the values to be the team's score.
00:19:00.440 - 00:19:32.258, Speaker A: Here we have team blue and team yellow. Next, let's create our hashmap. Our hashmap is named scores, and just like vectors and strings, we can use the new function. Lastly, let's populate our hashmap. To add entries into our hashmap, we use the insert function and then we specify the key and value. So the keys are our team name and the value is our team score. Team blue has a score of ten and team yellow has a score of 15.
00:19:32.258 - 00:20:14.802, Speaker A: Note that we are not passing in the strings by reference. So passing in blue and yellow here will actually move the ownership of those strings into the hashmap. We can see this if we try to print the blue string after these two insert statements. Here, we get an error saying we cannot borrow a mood value if we didn't want the hashmap to take ownership of our string. We could pass in a reference to our string, but that would require the use of lifetimes, which we'll talk about in chapter ten. We can get individual values out of a hashmap by using the get method and specifying a key like so. Here we create a variable called teamname and assign it to the string blue.
00:20:14.802 - 00:20:43.172, Speaker A: And then we call scores get and pass a reference to our string. The get method takes a reference to a key and returns an optional value. So you can see here that score is an option that may contain a reference to our integer. The reason we get an option here is because we can't guarantee that a value will be returned. Imagine for example, if you passed in an invalid key. In that case, we would return none. We can also iterate over all the elements in our hash map.
00:20:43.172 - 00:21:07.634, Speaker A: Like so. Here we're using a foreign loop and we're extracting out a tuple that contains the key and value. And then we're just printing out the key and value pair. Now let's talk about updating our hash map. And again, we'll use the game example with teams and scores. So we have our scores hashmap and underneath we have two insert statements. The first insert statement takes the key blue and inserts the value ten.
00:21:07.634 - 00:21:39.324, Speaker A: The second insert statement also takes the key blue and inserts 20. What this will do is overwrite the blue key with the value 20. If we don't want to overwrite existing values, we can use the syntax below. First we call scores entry, which will give us an entry enum that represents the value for a given key. In this case, the key is yellow, and then we can call methods on that enum. In this case, we're calling or insert. This line of code is saying if there isn't an entry for the yellow key, then insert a new entry with the value 30.
00:21:39.324 - 00:22:09.058, Speaker A: However, if there is an entry, then do nothing. So for this first line, yellow doesn't exist, so we'll create a new entry for yellow with the value 30. But on the second line, yellow does exist, so we don't do anything. Now let's look at an example in which we want to update a value in our hash map based on an old value. Here we have a string hello world, wonderful world. And then we create a hashmap. And what we want to do is to populate our hashmap with the word count in our string.
00:22:09.058 - 00:22:40.658, Speaker A: So for example, hello would be a key, and its value will be one because it only appears once in the string. World would also be a key, and its value would be two because it appears twice in this string. And wonderful would be a key with the value one because it appears once in this string. So to do this, first we call text dot split whitespace, which will take our text here and create a collection of words split by whitespace. So the first word will be hello, and then world. Wonderful, and then world again. Then we'll iterate over that collection using the for in loop.
00:22:40.658 - 00:23:19.750, Speaker A: Now this is where it gets interesting. Inside our foreign loop, we take the word and call map dot entry passing in the word. Remember, this returns an enum representing the value at that key, which could be an existing value or no value at all, and we call or insert zero. So what this will do is if the word doesn't already exist, it will add the word to our hashmap and initialize its value to zero. And if it does exist, it won't do anything. But the interesting part here is that the or insert function returns a mutable reference to our value. So now that we have a mutable reference to our value, we can dereference it and add one to increment it.
00:23:19.750 - 00:23:50.976, Speaker A: Let's go through this together. First, I'll add a comment above our foreign loop so we can see what our collection looks like. So for our first iteration, word will be hello. And then we call the or insert function. Because we don't have an entry for hello yet, we will make a new entry and initialize the value to zero. Then we'll get back immutable reference to our value, which is zero, and then we'll increment it to one. We'll do the same thing for world and set its value to one, and then also the same thing for wonderful.
00:23:50.976 - 00:24:32.806, Speaker A: Then we get to our last entry, which is world, in this case calling or inserted. Do anything, but we'll still get back a mutable reference to our value, which is one, and then we'll increment our value to two. And after the loop we can print out our hashmap filled with word counts. So let's go ahead and run our program, and as you can see, hello is set to one, world is set to two, and wonderful is set to one, as expected. And there you have it, chapter eight of the rustling book complete. We learned about vectors, strings, and all the complexities that come with strings and hashmaps. If you enjoyed this video, make sure to give it a like.
00:24:32.806 - 00:24:54.730, Speaker A: And if you want to see rust content on a weekly basis, make sure to hit subscribe. Lastly, if you have a rust topic you want me to cover, go ahead and leave a comment down below. And with that, I'll see you in the next one. Ramdez.
