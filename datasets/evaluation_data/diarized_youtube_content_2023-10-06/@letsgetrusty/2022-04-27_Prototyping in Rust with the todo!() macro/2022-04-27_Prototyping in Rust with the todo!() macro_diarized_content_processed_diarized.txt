00:00:00.440 - 00:01:17.102, Speaker A: Let's say that you're creating a simple blogging website and you want to implement APIs for basic crud operations, create, read, update, and delete. For blog posts in your rust project, a blog post is represented as a post struct containing an optional id, a title field, and a body field. Now, in this example, let's say you know what the API of each endpoint should look like, so you start by defining the function signature for each operation. Rust will throw a bunch of errors because each of these functions have a return type, but were not returning anything from the function body. What we want to do is implement one API at a time without worrying about the other APIs. In a situation like this where you're prototyping and you want to defer the implementation of a function or method without worrying about compile time errors, you can use the todo macro. The todo macro indicates that there's unfinished code and prevents type check errors.
00:01:17.102 - 00:01:51.552, Speaker A: This allows us to focus on implementing one endpoint without worrying about the rest. Now we could return a dummy value instead of using todo. For example, for create post, we can return a Dummyok variant. This technically works, however, it has a couple disadvantages. First of all, it's more code. Second of all, it's harder to tell that this is a dummy value that needs to be replaced at some point in the future. At runtime, if we call createpost, it will return a valid value.
00:01:51.552 - 00:02:31.916, Speaker A: However, if we're using the todomacro, calling createpost will panic. Also, dummy values take various forms, while the to do macro is a consistent way to identify unimplemented code. Because of this, we can integrate the todo macro with todo extensions in versus code. For example the todo tree extension. First, we'll open up the extension settings and then scroll down to the regex section. This regular expression defines how to match todo items in comment sections. We can allow the todo macro to be matched by adding a vertical pipe at the end of the regular expression followed by todo exclamation point.
00:02:31.916 - 00:03:27.010, Speaker A: Then when we navigate back to lib rs, our todo macros will be highlighted and they'll also show up in the side panel. By having this extension set up, you can easily track remaining work and navigate to those spots. The Todo macro also works great for implementing traits. For example, lets say we had a trait called serialize. Serialize has three methods which each serialize the type to a different format, JSON, XML or YAML. Let's implement serialize for post. If I leave the implementation block empty, I'll get a compile time error.
00:03:27.010 - 00:04:04.922, Speaker A: Saying that not all trait items are implemented versus code also gives me the option to implement stubs for all missing members. By doing this, each method was generated with a call to Todo inside. We no longer have compile time errors and can go about implementing each method individually. Alright, rustations, that's it for this video. If you haven't already, make sure to get your free rust cheat sheet by heading over to let's get rusty.com cheatsheet. If you found this video useful, make sure to let me know by giving it a like and leaving a comment down below.
00:04:04.922 - 00:04:08.170, Speaker A: With that said, I'll see you in the next one.
