00:00:00.400 - 00:00:32.563, Speaker A: Welcome back to let's Get Rusty. My name is Bogdan, and this channel is all about the Rust programming language. If that sounds interesting to you, make sure to poke that subscribe button. In the last video, we went over chapter six, in which we talked about enums and pattern matching. If you haven't already, make sure to check that video out. In this video, we're going over chapter seven, in which we'll talk about managing growing projects using packages, crates, modules. In previous videos, we have been writing all our code in one file, which lives in the default module.
00:00:32.563 - 00:01:17.513, Speaker A: But as our project grows, we need a way to organize our code, and we also need a way to encapsulate our code. For example, imagine you had some chunk of code that dealt with authentication. You don't want the rest of your code to know everything about how the authentication code works. Maybe you just want to expose a method that's called login and keep the rest of the code hidden from the rest of your program. To address these needs, Rust has a module system that starts with a package. When you type in cargo new, you create a new package, and a package stores crates. A crate could either be a binary crate, so code you can execute, or a library crate, which is code that could be used by other programs.
00:01:17.513 - 00:01:57.643, Speaker A: Crates contain modules. Modules allow you to organize a chunk of code and control the privacy rules. So, going back to the authentication example, let's say you have a library crate that contains an authentication module. You can then make the code inside your authentication module private, but expose one public login method. If we wanted code outside of the authentication module to call the public login method, it would have to specify a path to that login method. That's the basic module system. Rust also has something called workspaces, which are meant for very large projects and allow you to store interrelated packages inside the workspace.
00:01:57.643 - 00:02:37.995, Speaker A: We'll talk more about that in chapter 14. With that background, let's jump into creating some packages and crates. Let's first create a new package called My project. To do that, we'll type in cargo new and then the name of our package. We'll CD into the directory and open it in VS code. Here we have the default file structure for our package. We can open up cargo automl, and at the top you see we have package and then the name, which is my project.
00:02:37.995 - 00:03:26.447, Speaker A: Now, as I've mentioned before, packages store crates, and we can actually define crates inside of our cargo toml file. Here we don't see any crates defined. So does that mean our package doesn't have any crates. Well, actually, we do have a binary crate, and that's because if you look in the source directory, we have a file called main rs. Rust follows the convention that if you have main RS defined in your source directory, then a binary crate with the same name as your package will be automatically created and main RS will be the crate root. The crate root is the source file that the Rust compiler starts at when building your crate. It also makes up the root module of your crate.
00:03:26.447 - 00:04:13.407, Speaker A: There's also a similar convention for library crates. So in our source directory, let's create a file called lib rs. If lib RS is defined in the root of your source directory, then Rust will automatically create a library crate with the same name as your package, and Lib RS will be the crate root. So in this case, even though we don't have any crates defined in our cargo automo file, our package actually does have two crates, following the Live RS and main RS convention. The last thing to do here is to mention some rules around crates. The first rule is a package must have at least one crate. The second rule is a package could have either zero library crates or one library crate.
00:04:13.407 - 00:04:51.571, Speaker A: And lastly, a package could have any number of binary crates. In our case, we have one library crate and one binary crate. If we wanted more binary crates, we would create a folder called bin. And in this folder we could define files. So in this case, let's just do a file called another one, and each file in this folder will represent another binary crate. Now that we understand packages and crates, let's talk about modules. And to do that, we'll create a new package called restaurant.
00:04:51.571 - 00:05:37.821, Speaker A: And we want this package to contain a library crate. So to do that, we'll specify Lib we'll CD into our directory and open the package in VS code. Here we get a file structure that looks similar to our previous package. But if we go to the source directory instead of main rs, we have lib RS defined by default. Here we get a test module automatically added for us, which we don't need right now. So let's go ahead and delete that. Our goal is to create a library that will help run a restaurant.
00:05:37.821 - 00:06:16.123, Speaker A: And we'll think about a restaurant as as two parts. The front of the house, which represents the area where the customers are, and the back of the house, which represents where the food is being made, dishes are being cleaned, and where the manager would typically be. To start off, I'll paste in some code which represents the front of the house. At the top, we Have a module called Front of the house. Modules are specified using the mod keyword, followed by the name of the module and then curly brackets. Inside of the front of the house module, we have two other modules, Hosting and Serving. Inside of the hosting module, we have two functions related to hosting duties.
00:06:16.123 - 00:06:48.531, Speaker A: Add to waitlist and C. Inside of the serving module, we have three functions that are related to serving duties. Take order, Serve order and take payment. Modules can contain other modules inside of them. They could also contain structs, enums, constants, traits, and so on. Structuring our code this way keeps it organized. If in the future, for example, we wanted to add the ability to seat people at a VIP table, we would know exactly where to put that function.
00:06:48.531 - 00:07:22.933, Speaker A: Looking at the Rust book, we could see what our module tree looks like. At the top we have a module called crate. Yes, it's a little confusing that a module is called Crate, but bear with me. Crate is a module that gets created by default for our crate route, which is lib rs. Inside of that we have the Front of house module, and inside of that we have two modules, hosting and serving, each of which have functions defined in them. A good analogy is to think about the module tree like the folder or directory tree on your computer. Now let's talk about paths.
00:07:22.933 - 00:07:57.763, Speaker A: Going back to the directory analogy, if you wanted to reference a file inside your directory tree, you would need to specify a path to that file. In the same way, if you wanted to reference an item in your module tree, let's say a function, you would need to specify a path to that function. Here I've simplified our Front of house module a bit. Now we just have a hosting module inside with one function add to waitlist. Outside of the module we have a function called eatrestaurant. And inside this function we want to call to waitlist. To do so, we need to specify the path to that function.
00:07:57.763 - 00:08:37.501, Speaker A: In Rust, a path could either be an absolute path or a relative path. Paths are specified using identifiers separated by double colon. So, for example, here we have an absolute path and it starts at the root of our module tree. With crate inside of crate, we reference front of house and then hosting, and then finally our function Relative paths start from the current module. So in this example, our function eat restaurant is inside of the crate module, which means we can start with front of house and then reference hosting and then our function. Now, notice we have some errors here. If we hover over the red squigglies, we could see that it says the hosting module is private.
00:08:37.501 - 00:09:20.075, Speaker A: This is because of Rust privacy rules, by default, a child module and everything inside of it is private from the perspective of of the parent module. So in this case, Front of house can't see hosting or anything inside of hosting. On the flip side, child modules are able to see anything that's defined in their parent modules. This system allows us to hide implementation details by default and only expose the functions we need to to the outside world. In this case, we do want to expose our Add to waitlist function, and to do that we can use the pub keyword. So first let's expose our hosting module. To do that, we'll include the pub keyword in front of mod.
00:09:20.075 - 00:10:01.764, Speaker A: As you can see, our error moves from hosting to our function. And that's because at this point hosting is public, but our function is still private. To fix this, let's also add the pub keyword in front of our function definition. And now we're able to access the add to waitlist function outside of the hosting module without any issues. Let's look at another example with relative paths using the super keyword. In this example we have a function called Serve Order defined in the top crate module. Then we have the Back of house module, which has two functions, FixInCorrectOrder and CookOrder.
00:10:01.764 - 00:10:39.675, Speaker A: Inside of the FixInCorrectOrder function, we're able to call cookorder because that's defined in the same module. And we're also able to call Serve order by using the relative path. And here we specify super, which allows us to reference the parent module, which in this case is crate. And then we specify the function we want to call. Now let's talk about privacy rules when it comes to structs using another example. In this example we have a module called Back of house, and inside the module we have a structure called breakfast, which represents a breakfast meal. The struct has two properties, toast and seasonal fruit.
00:10:39.675 - 00:11:11.237, Speaker A: Then we define an implementation block which has an associated function for our struct called summer. This function will build a summer breakfast meal. It takes in a string called toast and then creates a new breakfast struct with toast set to the string we passed in. And seasonal fruit is something the restaurant will decide on. So we hard coded to peaches. At the bottom we have a function called Eat at restaurant. And inside of this function what we want to do is call the summer associated function to create a new breakfast meal.
00:11:11.237 - 00:11:46.935, Speaker A: But you can see we get a couple errors. Our breakfast struct is private by default, so we can't access it. Also, you could See that our Summer associated function is also private by default. To fix these errors, let's add the pub keyword to both the breakfast struct and the summer associated function. Our errors are gone, which is great. So now let's say after we get our meal, we'd like to change the toast from rye to wheat. To do that, let's try reassigning the toast field on our meal variable.
00:11:46.935 - 00:12:27.211, Speaker A: And here you can see we get an error. The error says the toast field is private. Even though our struct is public by default, fields within the struct are private. So to fix this, we can explicitly mark toast as a public field. And now we're able to reassign. Also note that in order to create a new breakfast struct, we need to use the Summer associated function. We can't create a breakfast struct directly inside of E restaurant, and that's because the breakfast struct includes a private field, Seasonal fruit.
00:12:27.211 - 00:13:16.889, Speaker A: If we did attempt to create the breakfast struct directly like so, we would get an error which says that the seasonal fruit field is private, so we can't create the struct directly. Let's look at another example using enums. Again, we have a module called Back of House, and inside we have an enum called Appetizer, which has two variants, Soup and Salad. Then at the bottom inside of our Eat at restaurant function, we create two orders by specifying the variant of appetizer we want. As expected, we get errors here because Appetizer is private by default. To fix this, let's make Appetizer public. Notice that in our E Restaurant function we are using the Soup and Salad variant, but up here we didn't have to specify explicitly that they're public.
00:13:16.889 - 00:13:56.255, Speaker A: Enums wouldn't be very useful if their variants were private. So by default, if you mark an enum public, all of its variants are public as well. All right, now let's take a look at yet another example so we could talk about the use keyword. In this example, we have a module called Front of House, which contains a module called Hosting, which contains a function called Add to waitlist. And then we have a function at the bottom here, Eat at Restaurant, which calls our Add to waitlist function. Specifying the full path when calling these functions isn't very pretty or ideal. So to get around that, Rust provides the use keyword.
00:13:56.255 - 00:14:40.935, Speaker A: Use allows you to bring a path into scope. So as an example, let's bring the hosting module into scope. Now that our hosting module is in scope, we can Use it without specifying front of House. Here we specify the path as an absolute path, but we could also specify it as a relative path. To do that, let's change crate to self. Here, Self is referencing the current module, and then we can specify front of House and hosting. Now, here, instead of bringing the hosting module into scope, we could have gone further and brought the Add to waitlist function into scope.
00:14:40.935 - 00:15:17.273, Speaker A: That way we wouldn't even have to specify hosting here. However, in Rust, the idiomatic way to bring functions into scope is to bring the function's parent module into scope. And that's because we're still minimizing the path we have to specify. But we're also making it clear that this attawaylist function is not a local function. It's actually defined inside of another module. On the other hand, if you're bringing enums, structs, or other items into scope, it's idiomatic to specify the full path. The exception to this is if you're bringing in two items, let's say two structs from different modules into scope, and they have the same name.
00:15:17.273 - 00:16:01.211, Speaker A: In that case, you would want to bring the parent modules into scope so that the names don't conflict. As an example, let's take a look at the following code. We have two functions which use a result type, but each uses a different result type coming from a different module. To prevent the names from conflicting, we bring the parent module into scope and then reference the result type by specifying the parent module first. Another way of doing this is to rename one of the result types when we bring it into scope. So in this example, we bring the result type from the format module into scope, and then we bring the result type from the IO module into scope, but we rename it to IO result, and we can do this using the as keyword. And then our functions could reference each type by its name.
00:16:01.211 - 00:16:37.397, Speaker A: All right, now let's go back to our restaurant example. So we could talk about re exporting. Like before, we have our front of house module, which has our hosting module inside, and the add to waitlist function. Then at the bottom we have the eat at restaurant function, which calls add to waitlist, and we don't have to specify the full path because here we bring the hosting module into scope. Now let's say that we want some code that's external to this file to also have access to the add to waitlist function. Well, currently it would not have access. The only thing it would have access to is eat Restaurant, because we've made this function public.
00:16:37.397 - 00:17:22.615, Speaker A: If we want external code to be able to call the add to waitlist function directly, we need to re export the hosting module. To do this, we simply add the pub keyword in front of our use statement. Now we're bringing the hosting module into scope by using the use keyword, but we're also marking this public so external code could reference hosting as well. The use keyword allows us to bring items into scope within our program, but it also allows us to bring in items from external dependencies into scope. For example, let's go to our cargo toml file and add the ran dependency. Then inside of the lib.rs file we could bring the range trait into scope.
00:17:22.615 - 00:18:13.037, Speaker A: The range trait is brought into scope from our external dependency, and now that it's in scope, we could use it to create a random number. If you remember our guessing game, this is the same exact code. And here I'm just creating a number from 1 to 100. Now let's say we wanted to bring a few more items from rand into scope. Now we could list all of these items on a separate line, but given that they all start with rand, we can refactor this into one line using nested paths. Here we're specifying the common part of the path, which is rand. And then we have two colons, curly brackets, and the nested paths.
00:18:13.037 - 00:18:39.589, Speaker A: If you're bringing a lot of items into scope, using nested paths can help you keep your code clean and concise. Let's see another example. Here we're bringing IO into scope from the standard library. And we're also bringing write into scope, which is defined inside of IO. The common path between these two use statements is stdio. So let's write this in one line. Here we're using nested paths.
00:18:39.589 - 00:19:16.435, Speaker A: Again, so we specify std IO and then here we say self to refer to IO itself, and then write. Lastly, we'll talk about the glob operator. Let's say that we wanted to bring all the public items underneath IO into scope. To do that we'll specify std IO and then asterisk. And now all public items underneath IO are in scope. Up until this point, we've defined multiple modules in one file. But as you can imagine, if your program grows, a module might get large in size, and in that case you might want to move your module definition into another file.
00:19:16.435 - 00:20:32.335, Speaker A: Let's see how that's done by moving the definition of our front of house module into a different file. To start, we'll create a new file in the root of our source directory called Front of House rs. Then we'll take the contents of Front of House and move it into our new file going back to lib rs Instead of curly brackets after our Front of House module definition, we'll replace it by just adding a semicolon. This tells Rust define the Front of House module here, but get the contents from a different file with the same name as the module. To continue with our example, let's go back to Front of House and extract the definition of the hosting module into a separate file. To get started, we'll create a new directory called Front of House, and in that directory we'll create a new file called hosting rs. Then we'll go back to our Front of House file and take the contents of the hosting module and paste it into our hosting RS file.
00:20:32.335 - 00:21:26.765, Speaker A: Finally, we'll go back again to our Front of House file and remove the curly brackets, replacing them with a semicolon. Going back to lib rs, we can see that everything still works as expected. Let's go through this one more time. We can declare modules in Rust using the mod keyword, and we can define the contents of our module in line if we use curly brackets as we've seen before. But if we want the contents of our module to be in a different file, then we can just use a semicolon here and put the contents of the module in a file with the same name as the module. In this case, we declare Front of House here and the contents are in a file called front of house.rs. similarly, we can declare child modules and have their content live in a different file.
00:21:26.765 - 00:22:11.609, Speaker A: But for child modules, we need to have the corresponding file, which in this case is Hosting RS live in a directory with the same name as the parent module, which in this case is Front of House. That was a lot. In this video we learned about Rust module system. We learned about packages, crates, modules, privacy rules, paths, bringing paths into scope, re exporting and separating out the content of a module into a separate file. If you like this video, make sure to give it a thumbs up. And if you want to see more Rust content on a weekly basis, make sure to subscribe. Lastly, if you have any specific Rust topics you want me to COVID leave a comment down below to let me know.
00:22:11.609 - 00:22:14.345, Speaker A: And with that, I'll see you in the next one.
