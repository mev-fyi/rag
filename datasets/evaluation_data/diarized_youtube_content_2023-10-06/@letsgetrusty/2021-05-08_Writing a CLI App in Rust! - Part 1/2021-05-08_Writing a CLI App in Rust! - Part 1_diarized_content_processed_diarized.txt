00:00:00.560 - 00:00:37.415, Speaker A: Welcome back, Rust gang. If you're new here, my name is Bogdan, and this channel is all about the Rust programming language. If that sounds interesting to you, hit the subscribe button for weekly Rust videos. In the last two videos, we went over chapter 11 of the Rustling Book, in which we learned how to write automated tests in Rust. In this video, we're going over Chapter 12 of the Rustling Book, in which we'll write a CLI program using the knowledge we learned from previous chapters. Things like strings and vectors, organizing code, handling errors, traits and lifetimes, and writing tests. So with that, let's get rusty.
00:00:37.415 - 00:01:27.935, Speaker A: We'll be creating a simple version of a popular command line tool called grep, which at its base level allows us to search for a string within a file. And our project will be called Mini Grab. So the first thing we'll do is create a new cargo project by typing in cargo new and then Mini Grab. Then we'll CD into our project and open it in VS code. Here I have main RS open with the default program, which just prints hello world. And the first thing we want to do is take in command line arguments, because we want the user to pass in a string and a file name. To do that, first we'll import the environment module from the standard library.
00:01:27.935 - 00:02:28.650, Speaker A: Then we'll create a variable called args, and the type will be a vector of strings. And then we'll call the ARGS method on the environment module and then collect. The ARGS function will give us an iterator over the arguments passed to our program, and the collect function will turn that iterator into a collection. And that's why we need to specify the type here, which is a vector of strings, because collect needs to know what type of collection we want. And then lastly, instead of printing out hello world, we'll print out our arguments. Let's go ahead and run our program and you can see, if I don't pass in any arguments, we get one argument by default, which is the path to our binary. Next we'll try passing in some arguments, and you can see this time we get two more arguments, which we passed in needle and haysack.
00:02:28.650 - 00:03:18.185, Speaker A: For the sake of this program, we don't care about the binary path. All we care about is the two parameters passed in, which will be the query and the file name. So in main, let's create two variables and store our query and file name. First we'll create a variable called query, and we'll set that equal to a reference to our vector at index one, because remember, we don't care about the first index, which will be the binary path. Next we'll do something similar for the file name. And lastly, we'll print out our query and file name. Next we'll run our program again, but this time we'll pass in a query and a file name.
00:03:18.185 - 00:03:50.221, Speaker A: And you can see that we get searching for test in sample. Txt. Great. Now that we're able to parse our arguments, the next step is to read from a file. So what we'll do is create a new file at the root of our directory called poem.txt, and we'll insert a poem. This is a poem by Emily Dickinson and you can find it in the wrestling book, or you can pause the video, type it in yourself.
00:03:50.221 - 00:04:32.493, Speaker A: But really all we need is some sample text to test on. Next, let's go back to main RS and we'll write the code to read the contents of our file. The first thing we need to do is import another module to help us with file reading. So we'll type in use std and then FS for file system. Then at the end of our program, we'll create another variable called contents and we'll set that = to fs:// colon read to string. Then we'll pass in the path to our file. And this function retestring takes a file name and converts the contents into a string, and it also returns a result.
00:04:32.493 - 00:05:15.287, Speaker A: Now, if it returns an error, we want to exit our program. So what we'll type in is expect and then pass in an error message. In this case, our error message is something went wrong reading the file. So again we use the file system module and call the read to string function, which takes in a path to a file and returns a result type. If the file doesn't exist, for example, it'll return an error, and if the file does exist, it'll return the contents of that file in a string. We then call expect on the result type, which will give us the value wrapped in the okay variant. If the result is okay, and if the result is an error, we will exit our program and print the following error message.
00:05:15.287 - 00:05:53.365, Speaker A: Something went wrong reading the file. Now, at the end of our program, we can print out the contents of our file. Let's go ahead and run our program. And for the query, it doesn't really matter, so we'll just type in the and for the file name, we'll Type in poem.txt, which is the file we just created. And there you go, you can see we get the contents of our file printed out at this Point, our program is able to parse arguments, read a file and print out the contents to the screen. Now that we have this basic functionality working, it's a good time to refactor our program.
00:05:53.365 - 00:06:28.833, Speaker A: Specifically, there are a few things we could improve. The first thing is that our main function does two things. It parses arguments and it reads a file. Now, for this small function, that's not a huge deal. But in general we want to keep the responsibility of a function scoped and ideally a function will only have one responsibility. Second of all, we have these two arguments, query and file name, which are connected, but that connection isn't expressed in our program. Thirdly, when we read the contents of a file and it fails, our error message is simply something went wrong reading the file.
00:06:28.833 - 00:07:12.357, Speaker A: This isn't very specific and is not going to help the user very much. And lastly, we don't have a centralized place to handle errors, so. So we have this error which could occur when we fail to read a file. And we'll also get an error if we pass in the wrong amount of arguments. For example, if we don't pass in any arguments, then we will fail to get the query and file name parameters, which will make our program panic and return an error. Let's tackle the first problem, which is that main has too many responsibilities. The Rust community has developed a pattern for when the main function of a binary crate gets too large and the pattern is to create a library crate and then have our binary crate call functions in the library crate.
00:07:12.357 - 00:07:40.495, Speaker A: So right now we have main rs, which is a binary crate. And what we'll do is create a library crate with a lib.rs file. Then we can move most of our programs logic into lib dot and main. RS will be responsible for things like parsing arguments and then passing those arguments to function calls within our library crate. Now, before we create the lib.rs file, let's rework our program to extract out some logic.
00:07:40.495 - 00:08:38.549, Speaker A: And the first thing we're going to extract out is argument parsing. So let's create a new function called parse config and it's going to take an argument called args, which will be a reference to an array of strings, and it will return a tuple with two string slices inside the function body. We'll extract out query and file name from the args parameter and we can simply use this code up here and then we'll return our tuple. Finally, we'll call our new function in main. Here we're calling parseconfig and passing it args. And then parseconfig returns a tuple. So we're destructing that tuple into two variables, query and filename.
00:08:38.549 - 00:09:22.989, Speaker A: Now, our parseconfig function returns a tuple with two strings which represent the query and file name. But it's still not very clear that these two strings are connected. So let's fix that problem next by creating a new struct called config. And our struct will hold the query and file name. Next, we'll change our parse config function to return a config type and actually create a config instead of a tuple. And we get an error here because I named one of the fields file instead of file name. So let's fix that, and we have two more errors.
00:09:22.989 - 00:10:03.119, Speaker A: If we hover over, you can see that we have mismatch types. Our config struct expects a string while we give it a reference to a string. Now, we could store references to a string, but that will require the use of lifetimes. So for now, let's keep a simple and pass in strings. So what we'll do here is remove the reference operator from the beginning of args. And because we don't want to take ownership of the string, what we'll do is call the clone method to clone the string. Now, this isn't the most efficient thing to do because we're creating copies of the string, but it is the simplest thing to do.
00:10:03.119 - 00:10:30.179, Speaker A: In chapter 13, we'll look at how to use lifetimes to handle this case more efficiently. Next, we'll scroll up to main and actually use our config type. So here, instead of destructing a tuple, will create a variable called config, which will be the config that parse config returns. And then we'll call config query here, config.file name here, and then again config.file name. Great.
00:10:30.179 - 00:11:20.051, Speaker A: Now we have this parse config function that parses our command line arguments. And we have our config struct, which logically groups our query and file name parameters into a unit. But there's still room for improvement. The parseconfig function is very closely tied to our config struct, but our program doesn't express this coupling. To fix this, instead of having a separate function to parse command line arguments, we can add this logic to the implementation of our config struct. To do that, let's create an implementation block for our config, struct, and then we're going to cut and paste this function into the implementation block, and instead of calling it parseconfig, we're going to call it new. Calling this function new is a convention for constructor functions.
00:11:20.051 - 00:11:49.145, Speaker A: So here we're getting a list of arguments, and we're constructing a new config. Now let's scroll back up to main and use our new function. Now let's turn our attention to fixing error handling. If we call our program and don't pass in enough arguments, then we get a cryptic error message. So let's try that. And here you can see the error message is index out of bounds. The length is 1, but the index is 1 to a user.
00:11:49.145 - 00:12:22.467, Speaker A: This is confusing. To fix this, let's add a better error message. So we'll scroll back down to our code which handles argument parsing in this case the new function, and we'll add a check up above. Here we're checking the length of our arguments, and if the length is less than three, we panic and print out the message. Not enough arguments. So let's try running our program again with zero arguments. And now you can see we get a slightly better error message saying not enough arguments.
00:12:22.467 - 00:13:09.215, Speaker A: Now, this is an improvement, but we still have all this other noise here, and that's because we're calling panic. And panic is more appropriate when we have a programming error rather than a usage error. So let's fix this so that we return an error message without all the extra noise. The first thing we'll do is instead of returning config from our new function, we'll return a result type like so. And this result type will either have a config in the okay case or a string in the air case, which will represent our error message. Then, instead of panicking here, what we'll do is return an error type with our error message. And then down here we'll return an okay type, wrapping our config.
00:13:09.215 - 00:14:03.583, Speaker A: Now we can scroll back up to main and handle our new result type. But before we do that, we're going to import another module from the standard library called process, which will help us exit the program without panicking. Now, calling new on config returns a result type, which could either have a config or an error containing a string, which is our error message. And what we'll do is call a function called unwrap or else. And this function takes in a closure, which will contain the error variant. And what we'll do is print out the error and Then exit the program. What the unwrap or else function will do is in the OK case it will return the value stored in ok.
00:14:03.583 - 00:14:41.679, Speaker A: And in the error case, it'll execute this closure, passing it the error. And we'll learn more about closures in chapter 13. Inside our closure, we print out the error and then call Process exit and pass it a status code. This will terminate our program with the status code passed in. Let's go ahead and rerun our program and we won't pass any arguments like last time, and you can see we get our error message problem. Parsing arguments not enough arguments, but this time we don't have all the extra noise. Now that we've refactored our configuration parsing, let's extract out some more.
00:14:41.679 - 00:15:39.653, Speaker A: Logic from main will create a function called run which will contain logic that doesn't have to do with setting up the configuration or handling errors. We'll define our run function right underneath Main and it'll take a config and then from Main we'll cut and paste the logic that reads the file and prints out the contents. And then lastly we'll call Run from Main. Next, let's improve the error handling inside our run function. Currently we call expect, which will panic if we get an error reading the contents of the file. Instead, let's return a result type from our run function. In the success case, we return a unit type, which is basically nothing, and in the error case we return an error.
00:15:39.653 - 00:16:37.595, Speaker A: And you don't have to worry too much about the syntax here, but basically what we're doing is saying return any type of error. And we have some red squigglies here because we actually have to import the error type next, instead of calling expect here, all we're going to do is add a question mark to the end of this function call. And what that will do is if read to string returns an error type, that error type will automatically be returned from the run function. Lastly, we have to handle the success case. So after we print out the contents of our file, we'll return the OK case and pass it a unit. Now our run function is complete, but you can see if we scroll back up to main, we get a warning here which basically says that we're returning a result type, but we're not handling the error case of our result type. Let's fix this by handling the error variant and and in this case we only care about the error variant.
00:16:37.595 - 00:17:20.221, Speaker A: So we can use the if let syntax. Here we're saying if the call to run results in an error variant, then execute the code inside this block. Inside this block, we print out the error, and then we exit the program with a status code of 1. Let's test this out by running our program and passing in a file that doesn't exist. And here you can see we get an application error, and the error is no such file or directory. That's it for part one of chapter 12. In the next video, we'll finish out chapter 12 by extracting our logic into a library crate and then adding tests.
00:17:20.221 - 00:17:32.635, Speaker A: So if you want to see that video and weekly Rust videos, make sure to hit subscribe. Lastly, if you enjoy this video, make sure to give it a like for the YouTube algorithm. And with that, I'll see you in the next one.
