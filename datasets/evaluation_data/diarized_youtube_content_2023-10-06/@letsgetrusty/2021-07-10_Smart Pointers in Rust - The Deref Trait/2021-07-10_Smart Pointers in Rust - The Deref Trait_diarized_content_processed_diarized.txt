00:00:00.520 - 00:00:41.961, Speaker A: Welcome back, Rust gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In the last video, we started talking about smart pointers by going over the box smart pointer. And if you recall, I said that smart pointers are structs that implement the DEREF trait and the drop trait. Well, in this video, we're going to go over the DEREF trait, which allows you to treat pointers like regular references. So with that, let's get rusty. The DEREF trait allows you to customize the behavior of the dereference operator, which is this little guy right here.
00:00:41.961 - 00:01:16.299, Speaker A: So the first thing we'll do is take a look at how the dereference operator works with references, which are a type of pointer. You can think about pointers as an arrow pointing to a value stored somewhere in memory. So let's take a look at the following example. We have a variable called X which stores the integer 5. And then we have a variable called Y which is a reference to X. In this case, Y is a memory address or pointer that points to the location where five is stored. Then we have two assert equal statements.
00:01:16.299 - 00:02:02.315, Speaker A: First, we assert that x is equal to 5, which we could see is true here. Then we assert that dereferencing Y is also equal to 5. So what the dereference operator will do is it will follow the memory address that is stored in Y to the actual value, which in this case should be five. Now what happens if we get rid of the dereference operator and just assert that Y is equal to 5? Let's do that on the next line. As you can see, we get some red squigglies. So let's run cargo check to see the actual error. The error states we can't compare an integer to a reference to an integer because they're different types.
00:02:02.315 - 00:02:31.767, Speaker A: Now, we can modify this example to use smart pointers instead of references. Specifically box, the smart pointer, which we learned about in the last video. So let's get rid of this. Assert equals statement at the end. And instead of Y taking a reference to X, we'll create a new box. Just like our reference box is pointing to a value stored somewhere in memory, in this case the value 5. So we can use the dereference operator the same way.
00:02:31.767 - 00:03:17.145, Speaker A: The only difference here is that Y is pointing to a copy of 5. Because if you recall, when primitives such as integers get passed to a function, the value is copied instead of ownership being transferred. Box is a smart pointer that implements the D ref trait, which allows the dereference operator to work the same as if it were a reference. To understand how this works, next we'll create our own smart pointer which implements the D trait. We're going to base our smart pointer on the box smart pointer and call it My box. The box smart pointer is implemented as a tuple struct, which holds one generic value. Now that our My box smart pointer is defined, let's create an implementation block for the new function.
00:03:17.145 - 00:04:22.193, Speaker A: Our new function is going to take an argument called x, which will be of type t, and return an instance of MyBox. One thing to know is that there's a big difference between the box smart pointer in the standard library and the My box smart pointer we just created, which is that X is not stored on the heap. And that's just because for now, we're focused on the dereference operator and not so much where data is stored. All right, now that we have our My Box smart pointer defined, let's use my box instead of box in our main function. If you look down here, we get some red squigglies, and if I hover over them, we'll get an error that says type my box of integer cannot be dereferenced. And that's because we haven't implemented the ability to dereference our smart pointer. To do so, we'll need to implement the DEREF trait.
00:04:22.193 - 00:04:59.123, Speaker A: The first thing we'll do is bring the DEREF trait into scope. Next, to implement the D trait for My box smart pointer, we'll create a new implementation block. Now, let's go through this implementation together. At the top, we have an associated type called target, which is equal to our generic t. Associated types are a slightly different way of declaring a generic parameter. But you don't have to worry too much about this right now, because we're going to cover it in depth in chapter 19. Then we have the D method.
00:04:59.123 - 00:05:38.375, Speaker A: The D trait requires that we implement one method called d, which takes a reference to self and returns a reference to the inner data. In this case, it's going to be self target. Or we can simply just write a reference to T. Now, recall that my box is a tuple struct. So inside the D method, what we're doing is returning a reference to self zero, which is the first item in our tuple. And again, we only have one item. In summary, what we're saying is when the dereference operator is used, we want to return a reference to the item stored in our tuple struct.
00:05:38.375 - 00:06:30.573, Speaker A: Now, if we scroll Back down to main, you can see that our assertion passes without the DEREF trait. The compiler only knows how to dereference references. The DREF trait allows the Rust compiler to take any value that implements D call the D method to get a reference, which the compiler knows how to dereference. On line 24, when we use the dereference operator on why Rust actually calls the following code, first we call deref to get a reference, and then we use the dereference operator. Because Rust does this automatically, we don't have to think about whether or not to call the DEREF method. And that allows us to treat regular references and types that implement the D trait the same. Now you might be asking why does D return a reference instead of the value itself? And this has to do with Rust's ownership system.
00:06:30.573 - 00:07:05.799, Speaker A: If D returned the value directly, Rust would move ownership of the value outside of our smart pointer. And in most cases, when we're using the dereference operator, we don't want this. Next, let's talk about implicit draft coercion with functions and methods. D ref coercion is a convenience feature in Rust that happens automatically for types that implement the D trait. D ref coercion will convert a reference to one type to a reference to a different type. Let's take a look at the following example. We have a function called hello, which takes a string slice and prints it out.
00:07:05.799 - 00:07:38.329, Speaker A: Now, in main, we'll create a new smart pointer to a string. Here we're going to call it m, and then we'll call our hello function and pass a reference to m. And as you can see, this works. We don't have any errors, even though M is of type my box. And here we're passing in a reference to my box while the hello function expects a string slice. Let's see how this works. On line 27, we're calling hello and we're passing in a reference to mybox.
00:07:38.329 - 00:08:35.005, Speaker A: Now what we need to do is get from a reference to my box to a string slice. Well, my box implements the DREF trait, and if we call dref on M, we'll get back a reference to a string. The string type in Rust Standard Library also implements the D trait, and if we call dref on a string, we'll get back a string slice. Rust will see that the type being passed to hello is different than the type expected by the function signature and automatically perform these chained DEREF calls at compile time to get the correct type. If Rust didn't have automatic draft coercion in order to call hello with M, we would have to write it like this. Here we're dereferencing M to a string and then taking a reference to a string slice that will be the full range of the string. As you can see, without automatic deref coercion, our code would be harder to write, read, and understand.
00:08:35.005 - 00:09:40.099, Speaker A: Similar to how you use the dereft trait to override the dereference operator for immutable references, you can use the derefmutrait to override the dereference operator for mutable references. Rust will perform draft coercion in the following cases when going from an immutable reference to another immutable reference, when going from a mutable reference to another mutable reference, and when going from a mutable reference to another immutable reference. Rust cannot perform draft coercion when going from an immutable reference to a mutable reference, and this has to do with the borrowing rules. The borrowing rules state that you can only have one mutable reference to a specific piece of data within a specific scope. Converting a mutable reference to an immutable reference will not break that rule. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that piece of data, which is something the borrowing rules cannot guarantee. That's it for this video.
00:09:40.099 - 00:09:49.565, Speaker A: If you enjoyed it, make sure to smash that like button. And if you want to see weekly Rust content, make sure to hit subscribe. And with that, I'll see you in the next one.
