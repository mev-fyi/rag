00:00:00.440 - 00:00:41.302, Speaker A: What's up, rustations? Welcome back to let's get Rusty, your number one resource for all things Rust. In today's video, we're continuing our series on memory management, or more broadly, resource management. In the last video we discussed, the RAII, or resource acquisition is initialization pattern in C. If you haven't already, make sure to watch that video. Today we'll be comparing RAII to OBRM, which is ownership based resource management. The system implemented in rust. Ownership based resource management is oftentimes called the ownership system in rust.
00:00:41.302 - 00:01:29.104, Speaker A: For simplicity, it's very similar and in fact based on RAII. But instead of being a best practice or a pattern, it's a built in language feature. Specifically, the ownership system is simply three rules that are checked at compile time. The rules are one, each value in rust has a variable that's called its owner. Two, there could only be one owner at a time, and three, when the owner goes out of scope, the value will be dropped. To help us understand these rules, let's take a look at a code example comparing RaII to the ownership system in rust. On the left, we have two examples of the RaII pattern in circumental, which we saw in the last video, and on the right, we have equivalent examples in Rust.
00:01:29.104 - 00:02:07.156, Speaker A: In the first C example, we manage memory allocated on the heap by using a unique smart pointer. When this function returns, the unique smart pointer will be cleaned up. Its destructor will be called, causing the memory on the heap to be cleaned up. Even if an exception is thrown in the middle of our function, or if we return early, the heap allocated memory will still be cleaned up. In rust, we can allocate memory on the heap using the box smart pointer, which is similar to the unique smart pointer in C. There are also other ways to allocate memory on the heap. For example, on line 15, we're creating a heap allocated string.
00:02:07.156 - 00:02:57.714, Speaker A: According to the ownership rules. Each value in rust has a variable that's called its owner. In this case, car is the owner of this heap allocated car instance in, and mystring is the owner of this heap allocated string. At the end of this function, car and mystring will go out of scope, meaning that their values will be cleaned up again. This will happen regardless if our function panics in the middle or if we return early. As you can see, the C example and the rest example are very similar. The difference is in C, we can manage our heap allocated memory manually or opt in to use smart pointers, which in turn use the RAII pattern inrust ownership is a language feature that's checked at compile time, so it's on by default, and we can choose to opt out of it if we use unsafe rust.
00:02:57.714 - 00:03:36.200, Speaker A: Another difference between rust and c is that move semantics are implicit. For example, let's say I wanted to create another car unique pointer. We'll call it car two, and we'll set it equal to cardinal. An error will be thrown because unique pointer requires single ownership. We cant have two unique pointers pointing to the same car instance stored on the heap. We could, however, move ownership from car to car two by using the move function. At this point, car two owns the car instance allocated on the heap, and car is no longer valid.
00:03:36.200 - 00:04:37.724, Speaker A: Let's do the same thing in rust. We'll create a new variable called car two and set it equal to car. Notice that with rust we don't get any errors, and that's because move semantics are implicit, meaning that when we set car two equal to car one, car two will now be the owner of this heap allocated memory, and car will be invalidated. The last thing I want to talk about is shared ownership. If you recall, one of the ownership rules in rust is that there can only be one owner at a given time. But what happens if you want to have shared ownership over a resource? Well, in C, instead of using a unique pointer, we would use a shared pointer. Now, Char and car two both have shared ownership of the same heap allocated memory.
00:04:37.724 - 00:05:16.026, Speaker A: To do the same thing in rust, we would simply replace box with rc, which stands for reference counting. Then, instead of moving ownership of car into car two, we'll call the clone method. Calling clone on an RC smart pointer will produce a new smart pointer pointing to the same memory location. So at this point, car and car two are both pointing to the same heap allocated memory. Note that the ownership system in rust is not only for managing memory, it's for managing resources in general. For example, let's look at managing file handles. In C.
00:05:16.026 - 00:05:55.864, Speaker A: We implemented the file class, which use the RAII pattern to manage our file handle. At the end of this function, file will be cleaned up, its destructor will be called and, and thus the file handle will be closed. In rust, we first create a path object and then pass it in to open a file. Then at the end of this function, file will go out of scope and the file handle will be closed. In summary, the ownership system in rust is similar to RAII, except the name is a little more intuitive. Move semantics are the default, and instead of being a pattern or best practice, it's a language feature. If you enjoyed this video, make sure to give it a like and leave a comment.
00:05:55.864 - 00:06:10.240, Speaker A: Also, if you found anything confusing, leave a comment as well. Lastly, and most importantly, get your free rust cheat sheet by heading over to letsgetrusty.com cheatsheet. And with that said, I'll see you in the next one.
