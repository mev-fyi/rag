00:00:00.440 - 00:00:57.497, Speaker A: Rust has intentionally made some very bold design choices. One fascinating design choice that differentiates Rust from other well known languages is that Rust doesn't use traditional constructor primitives. Object oriented languages like C, Java, and C provide specialized constructor functions that handle object initialization, encapsulate the process of constructing an object, and support inheritance by providing ways to initialize base classes. For example, in C, a constructor is a function that has the same name as the class, but this is not a regular function. In fact, there's a lot of hidden logic complexity and pitfalls in this code. The first problem with C constructors is that they allow you to create half baked objects. If we keep the constructor and passed in arguments exactly the same, but forget to initialize the age field with the passed in value, C will still create an instance of person, but age will now contain indeterminate values which can lead to undefined behavior.
00:00:57.497 - 00:01:47.997, Speaker A: Behavior not good the second problem with C constructors is that error handling is a nightmare to deal with. Notice that this function doesn't specify a return type. This is because C implicitly returns a pointer to the newly created person object after the constructor finishes executing. We cannot specify that the return type should be some type of optional or result type. Instead, we're forced to use unintuitive error handling approaches such as throwing exceptions, which is far from ideal because we're introducing a hidden failure mode that every caller has to remember to handle. The third problem with C constructors is that when inheritance is involved, it becomes dangerously easy to accidentally introduce bugs. For example, let's say we updated the person class by adding a virtual function called Introduce.
00:01:47.997 - 00:02:34.931, Speaker A: Virtual functions in C are functions that can be overridden in derived classes. Then we'll create an employee class which inherits from person, overrides the Introduce function, and calls Introduce in its constructor. We've just unintentionally introduced a bug. You might expect that calling Introduce an employee's constructor would call the employee implementation of Introduce. But that's not the case because the employee instance isn't fully initialized before the constructor finishes executing, C will actually call the Introduce implementation in the Person base class. As you can see, not knowing the nuances of how C constructors work can lead to unexpected behavior without any warnings. So those are only a few obvious pitfalls with traditional OOP constructors, and there are plenty of others I haven't mentioned.
00:02:34.931 - 00:03:21.173, Speaker A: In contrast, Rust's approach to both object creation and inheritance is very different. Rust relentlessly prioritizes explicit initialization over Implicit constructors, simplicity over complex or opaque features, and composition over inheritance. But how do these principles eliminate the pitfalls of object construction in traditional object oriented languages? Let's find out. In Rust, the simplest way to create an object is using the field initialization syntax. This is similar to object literals in some other languages, but with a major difference. In many other languages, missing fields are either implicitly initialized to default values or left uninitialized. In contrast, when you create an object in Rust, you must explicitly initialize all the fields.
00:03:21.173 - 00:03:59.645, Speaker A: This strict requirement is a core safety feature of Rust. It eliminates the risk of unexpected behavior and hard to track down memory bugs. For more flexibility, you can also move this field initialization logic into an associated function called new. This approach provides similar encapsulation benefits to traditional constructors. Without any hidden logic or added complexity, you can still perform custom initialization, logic validation, or resource acquisition, much like you would in a traditional constructor. You can also make your fields private so that they can only be accessed through functions defined on your object. But the beautiful thing about Rust is that this function isn't special in any way.
00:03:59.645 - 00:04:35.503, Speaker A: It's just a regular function. Naming it new is simply a convention, but you're free to call it whatever you'd like. You can also have multiple constructor functions if needed, and because this is a regular function, error handling becomes very straightforward. You can simply return a result type which will force callers to handle the error case. Additionally, if we want the ability to create objects with default values, we can use the default trait in the standard library. This trait requires that we implement a regular function called default. We can implement this trait manually, or for simple cases we can implement it automatically by deriving it.
00:04:35.503 - 00:05:44.911, Speaker A: Note that to create an object with default values, you have to call the default function explicitly. There are no implicit default constructors because again, Rust favors explicit initialization over implicit constructors. Now, because Rust also favors composition over inheritance, if we wanted to create an employee object that shared behavior with the person object, we would use Rust's trait system and composition. We can create a trait called introducible, which person and employee both implement, and then have the employee struct contain an instance of person. This approach avoids many of the pitfalls of traditional OOP inheritance, such as fragile base classes or unexpected behavior in constructor chains, while still providing polymorphism through traits. By making these bold design choices, Rust has been able to avoid the pitfalls of traditional OOP languages, simplify low level software development, and make it accessible to an entirely new demographic of programmers coming from higher level languages like JavaScript, Python and Ruby. That's why I believe Rust is here to stay, and learning it is extremely valuable, especially if you feel stuck and not growing as a developer.
00:05:44.911 - 00:05:57.295, Speaker A: If you're interested in becoming a Rust developer or are simply curious about the opportunities, make sure to get your free rust training@letsgetrusty.com Bootcamp. Hope you've enjoyed this video and remember to stay rusty.
