00:00:00.440 - 00:00:41.077, Speaker A: Rust's most wanted feature has finally been released. In this video, I'm going to explain what this feature is and why it's so useful, how you can take advantage of it, and also some important limitations that you need to be aware of. This new feature is actually a combination of two existing powerful Rust features, the async Await syntax and traits. First, let's explore async await. Just like in JavaScript or C, the async keyword in Rust is used to define functions that perform operations which take an unknown amount of time to complete. Things like making an API call call or fetching data from a database. On the other hand, the await keyword is used when calling these functions to wait for them to complete before moving on to the next line of code.
00:00:41.077 - 00:01:17.551, Speaker A: This powerful syntax greatly simplifies and improves the readability of asynchronous code, making it look similar to synchronous code. The second powerful feature is traits. Traits are similar to interfaces in Java or Abstract classes in C. They're a way to define shared behavior that different types can implement. In the latest release of Rust, these two powerful features were combined to unlock a ton of exciting use cases. Functions and Traits can now use the implies syntax to return any type that implements a particular trait. This is important because it means we can finally define async functions inside of traits.
00:01:17.551 - 00:01:59.109, Speaker A: And this is because an async function is syntactic sugar for a function that returns a type which implements the future trait. The ability to define async functions inside of traits is a major leap forward, which simplifies creating unified interfaces for async APIs. Imagine building a backend service that performs user authentication. You can define a user authenticator trait which has an authenticate and register method. And then you can define multiple concrete authenticators, for example a database authenticator and an oauth authenticator. This is what I typically do in my own Rust projects, and now I can do it without using a third party crate. But although this feature works for my use case, it may not work for yours just yet.
00:01:59.109 - 00:02:33.009, Speaker A: That's because there are some very important limitations you need to be aware of. Async functions and traits or more generally, the impulse trait syntax for return values is discouraged in public traits. To understand why, let's de sugar the fetch function. Fetch returns a type which implements the future trait. This works great for single threaded environments, but for multithreaded environments, the user of this trait may want to add a send bound so that the return value can be sent safely between threads. Unfortunately, currently this is not allowed. Users of your public trait cannot put additional bounds on the return type.
00:02:33.009 - 00:03:24.149, Speaker A: There is a workaround which is to use the trait variant crate. This creates two versions of your trait, in this example local HTTP service for single threaded environments and HTTP service for multithreaded environments. But for now, in general, the Impulse trait syntax or async functions and traits are best used for internal traits, which will only be used inside your own code base. Another limitation is the lack of support for dynamic dispatch. Traits that have async functions or functions who use the impul trait syntax for the return value are not object safe, which means they cannot be used for dynamic dispatch. Both of these limitations are going to be addressed in the future, but for the time being, if you need to define async functions in public traits, or if you need dynamic dispatch support, or if you need to support Rust versions older than 1.75, then you can use the asynctrate macro.
00:03:24.149 - 00:03:41.245, Speaker A: Despite these limitations, this feature is still a major leap forward for Async Rust, and it makes me particularly excited about the future of backend development with Rust. Before you go, make sure to get your free Rust cheat sheet@letsgetrusty.com cheatsheet Hope you've enjoyed the video, and remember to stay rusty.
