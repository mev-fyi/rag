00:00:00.680 - 00:00:22.625, Speaker A: Welcome back, Rust gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. If that tickles your fancy, make sure to click. Subscribe for weekly Rust videos. In the last video, we continued covering chapter 10 by going over traits. In this video, we're going to finish off chapter 10 by talking about lifetimes. So with that, let's get rusty.
00:00:22.625 - 00:00:57.405, Speaker A: Let's start off by talking about dangling references. What is a dangling reference? It's a reference that points to invalid data, and Rust does not like dangling references. Let's take a look at the following example. We have a variable called R declared here. And then we create an inner scope with another variable declared called X and set it equal to five. And then we say R is equal to a reference to X. By the way, in Rust you can reference primitive values like we do here.
00:00:57.405 - 00:01:30.631, Speaker A: And then after this, we try to print R. At this point, R is a dangling reference. And why is that? It's because R is a reference to X which is declared inside this inner scope. And when this inner scope is done, then X is invalidated, right? But here we try to print R, which points to X. Luckily, Rust will allow this code to compile. You can see here we have some red squiggly lines, and if we hover over, it says X does not live long enough. Right? X does not live long enough for us to print R down here.
00:01:30.631 - 00:02:11.901, Speaker A: Now, Rust knows this at compile time, and it's able to do so using the borrow checker. The borrow checker runs at compile time and checks to make sure that all borrowed values or references are valid. Here. I went ahead and annotated the lifetimes of our variables so you can get a better idea of how the borrow checker works. The lifetime of a variable refers to how long the variable lives for. As an example, here we declare R and its lifetime is annotated with tick A and it lives till the end of the main function. Then, inside our inner scope, we declare the variable X and its lifetime is annotated with tick B and it only lives till the end of the inner scope.
00:02:11.901 - 00:02:47.763, Speaker A: With this information, the borrow checker is able to say, okay, R refers to X down here when we try to print it. But X has a lifetime that ends up here. So R is a dangling reference, and that's why we get this error that says X does not live long enough. Let's look at a slightly different example. Here we declare X up on top, set it equal to five, and then we declare R Set it to a reference of X and then print out R. This time we don't get a compile time error. Why is that? Well, that's because the lifetime of X starts up here and goes till the end of the main function.
00:02:47.763 - 00:03:21.515, Speaker A: And the lifetime of our starts down here and also goes till the end of the main function. So when we print R down here, R is referencing X, and the lifetime of X is still valid at this point. So again, we don't get a compile time error. Now, the borrower checker was able to figure all of this out for us without any help. Next, we're going to talk about situations in which we do need to help the compiler using generic lifetime annotations. Let's take a look at the following example here. In main, we define string one and string two, which are just strings.
00:03:21.515 - 00:04:01.821, Speaker A: And then we define this result variable, which is set equal to a call to the longest function. Now, the longest function takes in two references to a string slice, X and Y, and then it returns the longest string. So again the return type will be a reference to a string slice. Once we have our result, then we simply print it. So here we'll print the longest string. Now, let's think about this from the point of view of the borrow checker. As the borrow checker, how would you know that result, when we printed down here is not a dangling reference? Remember that the borrow checker checks the lifetimes of references to see if they're valid or not.
00:04:01.821 - 00:04:33.369, Speaker A: But what is the lifetime of result? Well, the longest function returns a reference here, but we have no idea what the lifetime of this reference is. First of all, we return either X or Y based on this if statement. Now, X could have a different lifetime than Y. So that's our first problem. We don't know which we're returning X or Y, and they could have different lifetimes. Second of all, we don't know the exact lifetime of X or Y because these are just placeholders. Imagine that this function gets called from many different places.
00:04:33.369 - 00:05:17.665, Speaker A: So X and Y could have many different lifetimes. The borrowed checker doesn't know how to handle this ambiguity. And so we get an error, which you can see by these little red squigglies here. If I hover over it says missing lifetime specifier, the functions return type contains a borrowed value, but the signature does not say whether it is borrowed from X or from Y. And that makes sense, right? X or Y could have a different lifetime, and we need to know which of those lifetimes is being used as the Returned lifetime. Now to fix this situation, we need to use something called a generic lifetime annotation. So what is that? Generic lifetime annotations describe the relationship between the lifetimes of multiple references and how they relate to each other.
00:05:17.665 - 00:05:55.561, Speaker A: So they don't actually change the lifetime of a reference, but rather just explain the relationship between different lifetimes. Now this could get a little bit confusing, and that's because generic lifetime annotations is a mouthful. So typically when people refer to them, they just say lifetimes. Let's go ahead and fix this code using generic lifetime annotations. Now, the first word is generic. So just like regular generics, to define a generic lifetime annotation, we start by specifying it after the function name inside of angle brackets. Generic lifetime annotations always start with an apostrophe or a tick.
00:05:55.561 - 00:06:26.281, Speaker A: I'm going to call it a tick from now on, followed by the name of the lifetime. Now we can name our lifetime anything we want. For example, we can name it Apple. I don't know why you would want to do that, but you can. But the convention is to name it a lowercase letter starting with A and then following the Alphabet, so A, B, C and so on. So now we've declared our generic lifetime annotation and now we can use it inside our function. So we could say that X is going to use our lifetime and Y is going to use our lifetime as well.
00:06:26.281 - 00:06:57.323, Speaker A: And our return type is going to use the same lifetime. As a side note, here's how you specify generic lifetime annotations. Here we have a reference. Underneath we have a reference with an explicit lifetime annotation. And then below we have a mutable reference with an explicit lifetime annotation. Going back to our example, here we declare a generic lifetime A and then we annotate X, Y and the return value with A. This means that X, Y and the return value will have the same lifetime.
00:06:57.323 - 00:07:28.433, Speaker A: Well, not really. Remember that generic lifetime annotations don't actually change the lifetime. They just create relationships between the lifetimes of multiple references. So here what we're actually saying is that there's a relationship between X, Y and the return value. That relationship is this. The lifetime of the return reference will be the same as the smallest lifetime of the arguments. So if X has a smaller lifetime than Y, then the lifetime of the returned reference will be the same as X.
00:07:28.433 - 00:08:28.243, Speaker A: And if Y has a smaller lifetime than X, then the return values lifetime will be that of Y. Hopefully that makes sense. Our longest function is going to return a reference to A String slice, which is either going to be the x input or the y input, but we don't know which one it's going to be. In main, we take the result type and print it here. So from the perspective of the borrow checker, how does the borrow checker know that result is not a dangling reference here? Well, we just told the borrow checker that whatever gets returned from longest and saved here in result will have a lifetime that is equal to the smallest lifetime being passed in. So now all the borrow checker has to do is say, okay, what is the smallest lifetime being passed in? Is it string one or is it string two? In this case they're equal, but you can imagine they could be different lifetimes. And then it simply has to say, when this result is printed here, is the smallest lifetime still valid? And if it is so in this case String 1 and String 2 are still valid here, then we're good.
00:08:28.243 - 00:09:05.577, Speaker A: Let's look at another example in which string one and string two have different lifetimes. String one is defined up top here, and its lifetime is going to be till the end of the main function. Everything else is defined inside this inner scope, including string two. So string two's lifetime is going to be only until the end of the scope. Then again, we call our longest function, save the result in our result variable and print it out. Now, results lifetime is going to be the same as the smallest lifetime being passed in to the longest function. And in this case it's string two, because its lifetime only lasts until the end of this inner scope.
00:09:05.577 - 00:09:34.179, Speaker A: Now, the bar checker looks at this print line statement and says it's valid. And that's because when we write this print line statement, string two is still valid. Now let's look at this final example. Here we have string one at the top, and its lifetime is valid till the end of the main function. And then we declare result and then an inner scope. Now, in this inner scope, we declare string two and then set result equal to our longest function. And then we try to print result outside of this inner scope.
00:09:34.179 - 00:10:29.343, Speaker A: In this case, we get an error. If we hover over the red squiggly lines, we could see that String 2 does not live long enough. Now, what does this mean? Well, remember, results lifetime is going to be that of the smallest lifetime being passed, in which in this case is string two. So results lifetime is only going to last till the end of this inner scope. So when we try to print result after this inner scope is done, it's problematic because string two does not live Long enough for this to be valid. You could imagine that if longest returned string 2, then string 2 will be invalidated after the scope is done, and then results will be pointing to invalid data, AKA dangling reference. So using lifetime annotations help the borrow checker understand the relationship between the lifetimes of multiple references, which in turn helps the borrow checker identify dangling references.
00:10:29.343 - 00:10:59.111, Speaker A: Now, you can specify different lifetime annotations depending on what your function is doing. As an example, let's say that we want our longest function to always return X no matter what. In this case, we don't care about the lifetime of Y because we're always going to return X. So we can remove this tick a from y. And now you can see that our error in main went away. Our code is actually valid now. And why is that? Well, we know that longest is always going to return a reference that has the same lifetime as X.
00:10:59.111 - 00:11:38.827, Speaker A: And in this case, X is string one, and string one lives till the end of the main function. So printing result here is valid. Something interesting to note here is that the lifetime of our return value always has to be tied to the lifetime of one of our parameters. Now you might ask, why is that? Well, it's because if we pass back a reference from a function, it has to be a reference to something that is passed in. And that's because we can't return a reference to something created inside the function. So, for example, let's try to do just that. Here we're creating a string inside of our function and passing back a reference to that string.
00:11:38.827 - 00:12:26.469, Speaker A: Now we can remove this ticket from X because we don't care about the lifetime of X, and we get an error. Now let's hover over the error says cannot return value referencing local variable result returns a value referencing data owned by the current function. So what is this really saying? This error is saying we cannot return a reference to something created within the function, because once this function is over, the local variables get destroyed. So again, if we're returning a reference, it has to be a reference to a parameter passed into the function. The other option we have is to return an own type. So, for example, we can return a string instead of a reference to a string slice, and then we can return results. This works because even though we're creating result inside of our function, we're returning an own type which transfers ownership.
00:12:26.469 - 00:12:57.419, Speaker A: Next, I want to briefly go over structs that have lifetime annotations. In previous chapters, when we use structs, we always used own data types. But if we want to Use a reference. Then we need to specify lifetime annotations. So here we have a struct called important excerpt and it has a reference to a string in its part field. In order for this to work, we need to specify a lifetime annotation. And again we do this using the angle brackets and tick a here after the name of our struct and then also annotate the reference here.
00:12:57.419 - 00:13:39.017, Speaker A: In main, we have a variable called novel, which is a string, and then a variable called first sentence, which takes a reference to a string slice. That's the first sentence of the novel. Then we create a new instance of our struct and pass it first sentence. Now, up here, our lifetime annotation is saying that our struct cannot outlive the reference passed into part. So in main, if we try to use our variable I, which is an instance of our structure after first sentence has gone out of scope, we would get an error. Now, let's talk about lifetime elision rules. If you recall from chapter four, we had this function we wrote called first word, which takes a reference to a string slice and returns the first word.
00:13:39.017 - 00:14:19.359, Speaker A: Here I've included a lifetime annotation. But if you recall from chapter four, we didn't actually specify the lifetime annotation. And if I remove tick a here, you can see that the function still works. We don't get any red squigglies. Our code compiles just fine. So why is this? Well, there are scenarios where the compiler can deterministically infer the lifetime annotations, and it does this by checking the three lifetime elision rules. Now, before I jump into the rules, one thing to note is that lifetimes of arguments being passed in are called input lifetimes, and lifetimes of the return values are called output lifetimes.
00:14:19.359 - 00:15:06.801, Speaker A: The first rule is each parameter that is a reference gets its own lifetime parameter. So in our first word, function S will get a lifetime parameter. The second rule is if there is exactly one input lifetime parameter, then that lifetime is assigned to all output lifetime parameters. So in our first word function, our return type is going to get tick A, and that's because we only have one input lifetime here. So, as you could see, by using the first two rules, the compiler was able to generate these lifetimes, so we don't have to specify them ourselves. If we had multiple input lifetimes, such as we did with our longest function, then we have to specify the lifetimes manually. And that's because that breaks rule two, which is that there's only one input lifetime parameter.
00:15:06.801 - 00:15:45.913, Speaker A: Rule three states. If there are multiple input lifetime parameters, but one of them is a reference to self or immutable reference to self, the lifetime of self is assigned to all output lifetime parameters. Now, the third rule only applies to methods, and it will make a little bit more sense when we see an example in just a bit. But in general, the compiler will try to follow these three rules. And if at the end of these three rules it still can't figure out what the lifetimes are, then we have to manually specify them. Let's go back to our important excerpt example to see lifetime annotations inside of methods. Here we have our struct, and underneath we declare an implementation block for our struct.
00:15:45.913 - 00:16:27.115, Speaker A: Now, lifetime annotations are a type of generic. So just like with generics, we need to include the lifetime annotation inside of angle brackets after impul and then after the name of our struct, then we have a function called return part, which takes a reference to self, a reference to a string slice called announcement, and returns a reference to a string slice inside our function. We print the announcement and then return itself part. Now, why do we not need to specify lifetime annotations? Well, let's go through our rules. Rule number one is that each parameter that's a reference gets its own lifetime. So a reference to self will get a lifetime. Let's just say tick a and announcement will get a lifetime.
00:16:27.115 - 00:17:12.277, Speaker A: Let's say tick B. The second rule is that if we have exactly one input lifetime, that the output lifetimes will be the same as the input lifetime. In this case, we have two input lifetimes, so Rule 2 doesn't apply. The third rule is that if one of the parameters to our function is a reference to self or immutable reference to self, then all output lifetimes will be the same as self. And that's the case in this example. So we don't have to include the lifetime annotations explicitly, but if we want to, we could like so in this case, we don't have to specify tick a in angle brackets after our function name, because it's already in scope here. Next, I want to briefly cover a special lifetime called the static lifetime.
00:17:12.277 - 00:17:54.155, Speaker A: The static lifetime means that the reference could live as long as the duration of the program. All string literals have a static lifetime. And that's because, if you recall, string literals are stored in the program's binary, so they could live for the duration of the program. For the grand finale, we're going to take everything we Learned in chapter 10, generic traits, trait bounds, and lifetimes, and put it all together in one piece of code. Here we have a function called longest with an announcement. It's a function that takes two string references, X and Y, and a generic type called N, which is an announcement for short. And then it's going to print the announcement and return the longest string.
00:17:54.155 - 00:18:28.567, Speaker A: First, let's talk about the use of generics. Here. Our parameter an is of type T, so it's a generic type, but we use a trait bound down here in the where clause to limit it to any types that implement display. So types that could be printed to the screen. And finally, we have lifetime annotations. We take in two parameters, X and Y, which are both a reference to a string slice, and then we return a reference to a string slice. Because we have two references, the compiler can't do automatic lifetime elision, so we have to manually specify the lifetime.
00:18:28.567 - 00:18:56.209, Speaker A: And in this case it's tick a here on XY and the return value. That's it for chapter 10. And boy, was it a big chapter. We covered generics, traits, trait bounds and lifetimes. If you made it this far, give yourself a big pat on the back. And if you enjoy this video, make sure to smash the like button. Finally, make sure to subscribe so you can join the Rust gang and be notified when I release the next video, which will be about writing tests in Rust.
00:18:56.209 - 00:18:58.745, Speaker A: With that, I'll see you in the next one.
