00:00:00.440 - 00:00:39.480, Speaker A: What's up, rust stations? Welcome back to let's get rusty, your number one resource for all things rust. If you haven't already, make sure to get your free rust cheat sheet by heading over to let's get rusty.com cheatsheet. Today we're going to be taking a look at some functional aspects of rust, specifically combinators. So what is a combinator? Well, some of the definitions on Google make things more complicated than they need to be, so I'll give you my very simple definition. Combinators are pure functions or methods that perform a small, specific task. These functions can be combined or chained together, hence the term combinator, to perform complex operations.
00:00:39.480 - 00:01:19.130, Speaker A: To help us understand, let's go through an example together, first without combinators, and then adding combinators to see how they can improve our code. In this example, we have a vector of strings where each string represents a student. The string has the student's name and their GPA. We also have a struct defined above called student, which contains a name and a GPA. Our goal is to turn this vector of strings into a vector of student objects. Also, we want to filter out any student that got a GPA lower than a 3.5 1st.
00:01:19.130 - 00:02:18.448, Speaker A: We'll write code to fulfill these requirements without using combinators. Let's create another variable called good students, which will be a vector. Then we'll loop through each student in the original student's vector. Each student is represented by a string. We need to take that string and split it into two strings, one containing the name and the other containing the GPA. Here were splitting the string using space as a delimiter, which gives us back an iterator over the substrings. Then we're calling next on the iterator to give us the next item.
00:02:18.448 - 00:03:29.014, Speaker A: In the iteration, the first item should be name and the second item should be GPA. Next returns an optional because it could return none if there is no next item. So the next step is to check if name and GPA are the sum variant. If we get into this if block, we know that name and GPA are the sum variant, so we can simply unwrap them and then we'll turn them into own strings. The student struct expects GPA to be a floating point number. So next we need to parse the GPh into a floating point number. Parsing a string might fail, so parse returns a result type.
00:03:29.014 - 00:04:30.820, Speaker A: Next, we need to make sure that GPA is the okay variant. At this point we got the student's name and their parse GPA. So the last thing to do is check whether the GPA is greater or equal to 3.5. To add students to the good students vector we also need to make that variable mutable. And there you have it. Our code is now complete. Lets print out the students in the good students vector to see if it worked.
00:04:30.820 - 00:05:14.670, Speaker A: Our code is working. Three students were printed out, all with the GPA of 3.5 or greater. Despite having working code, its not exactly the most readable code in the world. For example, we have three if statements nested here. Let's explore an alternative way to write this code using combinators. First we'll create a variable called good students which is going to be a vector of students.
00:05:14.670 - 00:06:37.014, Speaker A: Well set it equal to students iTEr ITer is a combinator that will return an iterator over the students in the students vector. Next we'll call the map combinator which will allow us to transform the type of each item in the iterator to a different type. In this case we want to take each student string and transform it into a student struct. First we'll split the string into name and GPA. The map method takes a closure where the passnup parameter is the original type and the return value is the new type. In this case we're mapping string to an optional which either contains a student or the none variant. This allows us to use the question mark operator.
00:06:37.014 - 00:07:12.308, Speaker A: The next method returns an optional. We use the question mark operator so that if next returns none, then our function returns early with none for GPA. If we call next and get the some variant containing a string, we also need to parse that string into a floating point number parse returns a result type. However, we want to turn that result type into an optional. Luckily for us, we can call the ok combinator which will do exactly that. By calling this map operation, we've transformed our iterator of strings into an iterator of optional students. Next, let's filter out the none variance.
00:07:12.308 - 00:07:48.672, Speaker A: One way to do this is by calling the flatten combinator. Flattens will consume our iterator and return a new iterator that flattens nested structure. In this case, we're flattening an option that contains a student to just a student and all the non variants will be excluded automatically. Next, we need to filter out all the students that have a GPA less than a 3.5. To do that we can use the filter. Combinator. Filter accepts a closure that will be executed for each item in the iterator.
00:07:48.672 - 00:08:35.028, Speaker A: If the closure returns true, then that item will be kept. Otherwise it will be filtered out. The last thing we need to do is call the collect combinator, which will turn our iterator into a collection, and that's it. We've achieved the same thing as before, except this time using combinators, and the code looks a lot cleaner. Let's print out the results to make sure our code is correct. Here we can see the results of our code both with combinators and without combinators. That's it for this video.
00:08:35.028 - 00:08:53.200, Speaker A: If you enjoyed it, make sure to leave a like and let me know down in the comment section below if you want to see more videos about functional programming in rust. Lastly, make sure to get your free rust cheat sheet by heading over to letsgetrusty.com forward slash cheat sheet. And with that said, I'll see you in the next one.
