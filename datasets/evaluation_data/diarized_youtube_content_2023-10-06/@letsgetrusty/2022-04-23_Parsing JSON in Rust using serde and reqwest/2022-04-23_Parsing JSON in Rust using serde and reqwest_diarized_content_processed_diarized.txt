00:00:00.560 - 00:00:32.571, Speaker A: What's up, Rust Stations? Welcome back to let's Get Rusty. In today's video, we're going to be talking about parsing JSON in Rust. But before we get started, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet. With that said, let's get Rusty. I went ahead and created a new cargo project. The first thing we need to do is switch over to Cargo TOML and add some dependencies.
00:00:32.571 - 00:01:07.745, Speaker A: First we'll add serde, which will allow us to parse JSON. Also, we need to make sure the derive feature is enabled so we have access to the serialize and deserialize derive macros. Next we'll add a dependency on request and enable the JSON feature. Request is a high level HTTP client which will allow us to fetch JSON from an API. And finally, we'll add a dependency on Tokio with the full feature enabled. Tokio is an async runtime for Rust and will allow us to use the async await syntax. Now that we have all our dependencies, let's switch over to main rs.
00:01:07.745 - 00:02:01.333, Speaker A: The first thing we'll do is hook up Tokio. Now that our app is hooked up to use the Tokyo async runtime, let's make our first HTTP request. First we create a new request client and then issue a get request to jsonplaceholder.com todos. We also add a URL param to make sure we only get the todo objects for user 1. We then send the request, await the response, turn the response body into a string, await that operation, and then save that string in a variable called todos. And finally we print out to dos.
00:02:01.333 - 00:02:51.895, Speaker A: Let's go ahead and run our program. It might be hard to tell, but we get back a JSON string containing an array of to do items. Let's go ahead and parse this JSON string into a struct. The first thing we need to do is import the serialize and deserialize traits from serde. Then we'll create a struct representing each to do item. Each to do item contains a user id, an optional id, a title, and a completed flag. Next we'll derive the serialize and deserialize traits so that we can turn JSON into this struct or turn this struct into JSON.
00:02:51.895 - 00:03:57.461, Speaker A: We'll also annotate the user ID field so it's serialized with this given name instead of the field name. This is because by convention, field names in Rust use Snake case, while the API we're calling uses camel case. Now that the to do struct is defined, let's use it in main Instead of converting the response body into a string, we'll convert it into JSON. We'll also explicitly annotate the type of todos, which is going to be a vector of todo structs. Let's go ahead and rerun our program. Notice that the response was successfully turned into a vector of todostructs. We've just seen an example of how to call an API which returns JSON and then turn that JSON into Rust types.
00:03:57.461 - 00:05:02.167, Speaker A: Next, let's see an example of how we could take a Rust type, convert it into JSON, and send it to an API. First we'll create a new instance of todo. Then we'll issue a post request which serializes this instance into JSON and print the result. Again we create our request client, but instead of calling get this time we issue a post request to the todo's endpoint. We then set the body of the request to JSON. We pass in a reference to new todo, which will serialize the to do instance into JSON. Then we send the request, await the response, turn the response into JSON, await the operation, and save that response in new to do.
00:05:02.167 - 00:05:44.395, Speaker A: Finally, we print out the result. Let's go ahead and run our program. As we can see, our to do item was successfully saved with the ID of 201. So far we've seen how we can send and receive structured JSON. The last thing I want to talk about is how to send and receive arbitrary JSON. First, we need to add another dependency on the serdejson crate. This gives us access to a macro called JSON, which allows us to construct arbitrary JSON objects.
00:05:44.395 - 00:06:31.985, Speaker A: On line 23. Instead of passing in a todostruct, let's construct a JSON object. Here we're using the JSON macro to construct a TODO item using the regular JSON format. The JSON macro allows us to construct arbitrary JSON objects. We can also accept arbitrary JSON from an API by changing this explicit type annotation from todo to value. Value is a type that represents an arbitrary valid JSON value. Let's go ahead and run our program.
00:06:31.985 - 00:07:06.685, Speaker A: Our request worked, except this time. Instead of serializing the response into a todostruct, it serialized to an arbitrary JSON object. That's it for this video. If you enjoyed it, make sure to give it a like subscribe to the channel and leave a comment down below. Lastly, and most importantly, get your free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet. With that said, I'll see you in the next one.
