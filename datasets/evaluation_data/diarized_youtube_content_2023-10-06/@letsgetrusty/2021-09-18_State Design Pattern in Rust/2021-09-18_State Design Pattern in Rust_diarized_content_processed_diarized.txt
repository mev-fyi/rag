00:00:00.520 - 00:00:50.181, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In the last few videos we've been talking about object oriented features in Rust, and in today's video we're going to finish that series by implementing the state object oriented pattern using Rust. So with that said, let's get rusty. In the state pattern we have some value which has internal state, and that internal state is represented by state objects. Each state object is responsible for its own behavior and deciding when to transition into another state. The value that holds the state objects knows nothing about the different behaviors of states or when to transition to different states.
00:00:50.181 - 00:01:29.317, Speaker A: The benefits of using the state pattern is that when business requirements change, we don't need to change the code which uses the value. We simply need to change code inside one of the state objects or perhaps add new state objects. If this is not clear, then don't worry, it will become clearer as we implement our example, and you can also Google the state design pattern to get more information. Speaking of examples, to understand how the state pattern works, we'll be incrementally implementing a blog post workflow in Rust. Here's the workflow. A blog post starts off as an empty draft. Once the draft is done, then a review of the post is required.
00:01:29.317 - 00:02:10.325, Speaker A: Once the post is approved, it gets published, and only published posts return content for print so that unpublished blog posts cannot be printed. Also, we need to make sure that changes to the blog post follow a specific sequence. If somebody attempts to review a blog post before a review is requested, then that blog post should remain in a draft state. Here's an example of the workflow in code. I went ahead and created a new binary project called Blog and populated the main function. In main we create a new post and then we call Add text to populate the post with text. Then we assert that calling post content returns an empty string.
00:02:10.325 - 00:02:45.951, Speaker A: Post content will return the contents of that post. But because the post is in a draft state, we we want that string to be empty. Next we call Post Request Review. At this point, post content should still return an empty string because our post hasn't been approved. Then once the post has been approved, post content should return the actual contents of the post. Notice here that we're only interacting with the post type. The post type will store a value representing the state of the post, which could either be draft, waiting for review or published.
00:02:45.951 - 00:03:22.305, Speaker A: Changing from one state to another will be managed inside of the post type. The state will change in response to methods being called on the post type. Also, users won't be allowed to make a mistake such as publishing a post before it has been reviewed. Notice that at the top here we get some red squigglies, and that's because we haven't implemented our library crate yet. So let's go ahead and do that. First thing is creating a new file called lib RS and it's going to be inside your source folder. Now we can start implementing our blog library by first defining our post struct.
00:03:22.305 - 00:04:12.715, Speaker A: Our post is going to have two fields. The first one is called state and it will be an optional trait object. Later on in this tutorial, we'll learn about why state needs to be optional. The second field is going to be called content and it's simply going to be a string storing the content of the blog post. Let's go ahead and define the state trait. We'll also define our first state, which is a draft state. Finally, we'll add an implementation block for our post struct and define the new constructor function.
00:04:12.715 - 00:05:18.887, Speaker A: Initially, we're going to set the state to draft, and content is going to be an empty string. Because the fields of our posts are private, the only way to create a new post is using the new constructor function. The new constructor function creates a post with the state set to draft, which ensures that when a post is created, it's always going to start off in a draft state. The state trade defines shared behavior between various states of a post. Currently, we only have the draft state defined, but later we'll add a pending review state and a published state. Also, we don't have any shared methods defined at the moment, but we'll add some later when we define the other states. Next, let's talk about adding text to our post.
00:05:18.887 - 00:06:14.245, Speaker A: As you can see, our post has a field called content, which is a string, but this field is private so we can't modify it directly. Instead, we'll need to implement a method that modifies this internal field. If we go back to main, you can see we use a method called Add text which will append some text to our post. So let's go ahead and implement the Add text method. Add text will take a mutable reference to self because we need to modify our post instance and it's going to take some text which is going to be a string slice inside the method body. We're going to call self content, push str and then pass in our text. The add text functionality is something we want to support, but it doesn't depend on the state the post is in, and therefore it's not part of the state pattern.
00:06:14.245 - 00:06:59.145, Speaker A: And you can see this because the text method doesn't interact with the state field. If we go back to main, you can see now we're compiling up to line six. So next let's implement the content method. Content is going to take a reference to self and it's going to return a string slice. Now, regardless of the content inside of our post, we want our content method to return an empty string unless the post is published. And because our post can only be in a draft state thus far, we're going to simply return an empty string always. Later on, when we implement the published state, we'll go back and change this to actually return the contents of the post.
00:06:59.145 - 00:08:08.961, Speaker A: If we go back to main rs, you can see that our program is compiling till line seven. So next let's implement the ability to request a review for a post. First, we'll add a new state called pending review. Next, we're going to define a new method on our state trait, and it's going to be called request review. It's going to take ownership of self, and it's going to return a state trait object. This method doesn't have a default implementation, so we'll need a custom implementation for both draft and pending review. Notice that request review will take ownership of a box containing self, and we don't use self within this function.
00:08:08.961 - 00:09:07.625, Speaker A: So essentially what we're doing here is invalidating the old state and then returning a new state that could be used in its place. When we call request review on a draft state, we want to return a pending review state. And if we call request review on a pending review state, well, we don't need to do anything because it's already in review. So we simply return self. Next, let's implement a public request review method on the post structure. All right, let's talk about this. First of all, the request review method takes immutable reference to self because we want to modify the post instance, then we're using the if let syntax.
00:09:07.625 - 00:10:11.197, Speaker A: This is the pattern we want to match on a some variant that holds our state, and we're setting it=self.state.take. the take method will take the value out of the option and leave none in its place. So we're moving the value inside our option, which is the state, outside of our post and into this state variable. This is why we needed to make the state field on our post struct optional, because in this case we want to move the state out of our post. But Rust doesn't allow unpopulated struck fields, but with an optional value we're able to call take, which will give us ownership of state and in its place it's going to leave the non variant. Now that we have ownership over state, we're going to reassign self State on line 24, Hero Self State is going to be the non variant, so we're going to reassign it to a some variant and inside some we're going to call State Request review. Request review will consume this old state and invalidate it and then return a new state.
00:10:11.197 - 00:10:53.989, Speaker A: Now we can see some of the advantages of the state pattern. The request review method on the post struct is going to be the same no matter what state we're in. Each state is responsible for its own rules that govern what happens when we call request review on that particular state object. Now that the request review method is complete, if we go back to main, you can see that our program compiles to line 10. So next let's talk about the ability to approve a post. First we'll add a new published state. We'll need to implement the request review function, and just like the pending review state, it's going to return self.
00:10:53.989 - 00:11:51.725, Speaker A: In this case, if request review is called on a published state object, then we don't want to do anything because the post has already been published. Next, we're going to add a new method to our state trait, and it's going to be very similar to the request review method, except it's going to be called approve for the draft state object. When we call approve, we're going to return self because we can't approve a draft until a review has been requested. Same thing for the published state object. If a post is already published, then approving the post should have no effect if the approve method is called on the pending review state. However, what we want to do is transition into a published state. The last thing to do is to add an approve method to our post struct, and this is going to be very similar to our request review method, except we're going to replace request review with approve.
00:11:51.725 - 00:12:39.395, Speaker A: The last thing we need to do is update the content method on our post struct to return the contents of the post if it's in a published state. Here we call self.state.as ref. We call as ref because state is going to be an optional that owns the state object, but instead we want a reference to the state object. Now because we know that there's always going to be a valid state object. We can call unwrap here to get the value inside of the sum variant. Then we call the Content method on our state object, which is not yet implemented, and we pass in our post.
00:12:39.395 - 00:13:32.923, Speaker A: The goal is to keep all these rules contained within the state objects. So the content method takes a reference to the post so that it has access to the content field on that post and can return the appropriate string. One last thing to know here is that calling as ref is going to return an optional that that contains a reference to a box that contains our actual state object. But because of draft coercion, we're able to call content directly on that state object. Next, let's implement the content method on our state trait. We're going to take a reference to self and then we're going to have an argument called post, which is going to be a reference to a post, and then we'll return a string slice. Now, for this function we're going to have a default implementation which is just going to return an empty string.
00:13:32.923 - 00:14:15.677, Speaker A: Then we'll just copy this and create a custom implementation for the published state. And in this case we want to return a reference to post content. Notice here that we get an error which states that the post parameter and the return type have different lifetimes. Here our function takes two references and it also returns a reference. So we need to tell the compiler the relationship between these three references. In this case, our return type is going to be post content, so the lifetime of our return type is tied to the lifetime of the post. We can let the compiler know this by specifying a lifetime annotation.
00:14:15.677 - 00:15:09.567, Speaker A: In this case, I'm just going to use tick A. We also have to update the function signature inside our trait definition and we're all done. If we go back to main, you see we get no compile time errors, and if I open up the terminal and type in cargo run, you'll see that our program compiled successfully, which means these assert statements worked. This state pattern is easy to extend. For example, you can add another method called reject, which will take a post that's under review back to a draft state. Also try making it so that two approvals are required before a post is published. The last exercise you can try is making it so that you can only add text to a post when it's in draft mode.
00:15:09.567 - 00:15:52.645, Speaker A: One downside of the state pattern is that some states are coupled to each other. For example, imagine we wanted to add a state between pending review and published. This state is going to be called scheduled. After adding the scheduled state, we would need to update the pending review state such that when approve is called, it would transition to the scheduled state instead of the published state. Another downside is duplication. For example, in the post struct we have very similar implementations for the request review method and the approve method. If we had many more methods with similar code, we can consider using macros to reduce some of the repetition by implementing the state pattern exactly as we would in an object oriented programming language.
00:15:52.645 - 00:16:34.979, Speaker A: We're not taking full advantage of rust strengths. Let's try a slightly different approach. We'll modify our library such that invalid states and transitions are compile time errors, rather than encapsulating states and transitions completely so that outside code has no knowledge of them. Will encode different states as different types. First I'll delete everything and then I'll add two structs, post and draft post, which each have a field called content. Then we'll add an implementation block for both structs. Our post struct is going to have the new constructor function as it did before, but this time instead of returning a post, it's going to return a draft post.
00:16:34.979 - 00:17:35.411, Speaker A: We also have a method to get the content of the post and then for our draft post implementation we have one method which is add text. Note that our structs don't need the state field anymore, and that's because removing the encoding of state to the type of the struct. Also notice that our draft post struct doesn't have a content method. This ensures that all draft posts do not have the ability to print their contents. Lastly, note that because the content field of both our post struct and draft post struct are private, the only way to create a draft post is to call the new function on the post struct and currently there is no way to create an instance of the post struct. Next, we want the ability to review a post, so let's implement the pending review state by creating a new struct. Our pending review post struct is also going to have a private content field and it's going to have one method which is called approve and approve will return an instance of post.
00:17:35.411 - 00:18:23.925, Speaker A: Finally, we need a way to get from the draft post state to the pending review post state. So we'll add a new method to draft post which is called Request review. Request review is going to return an instance of the pending review post struct passing in the contents from the draft post. The Request review and approve methods take ownership of self, meaning that they'll consume and invalidate the old state and then return the new state. The pending review post struct doesn't have a content method, so we can't get the content of a post if it's in review state. And also the only way to get a pending review post struct is to call request review on a draft post. We've now encoded the blog post workflow into the type system and the last thing to do is change main rs.
00:18:23.925 - 00:19:13.769, Speaker A: First of all, we can't call the content method unless the post is published, so we'll get rid of these assert statements. Secondly, the request review and approve methods no longer change internal state. Instead they return a new post type, so we'll use shadowing here to account for that. As you can see, we start off with a draft post and then by calling request review we get a pending review post and then by calling approve we get a regular post on which we can call the content method. This implementation doesn't quite follow the object oriented state pattern anymore. However, the advantages Invalid states are impossible due to the type system and type checking. So as you can see, Rust is capable of implementing object oriented design patterns.
00:19:13.769 - 00:20:01.797, Speaker A: However, other patterns such as encoding state into the type system are also possible. Also, taking different approaches will yield different trade offs. Rethinking problems to take advantage of Rust features can provide benefits such as catching certain bugs during compile time. Using object oriented patterns won't always be the best approach in Rust because of features such as ownership, which object oriented programming languages don't have. Alright, that concludes our series on object oriented concepts in Rust. Hopefully you learned a little bit about using trait objects to get object oriented features in Rust and things such as dynamic dispatch versus Static dispatch. If you enjoy this video, make sure to gently lean up against that like button and if you want to see weekly Rust videos, then hit subscribe and the notification bell.
00:20:01.797 - 00:20:14.215, Speaker A: And lastly, I'm going to be releasing a Rust cheat sheet which you don't want to miss out on. So click the link in the description to get access and with that I'll see you in the next one. Be.
