00:00:00.360 - 00:00:42.297, Speaker A: In this video, we're going to be going over the Rust release cycle, which is important to know if you're a Rust developer. But before we get started, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheatsheet Rust has a guiding principle, stability without stagnation. The goal is for you to never have to worry about upgrading to a new version of stable Rust. Each upgrade should be painless while giving you new features, fewer bugs, and faster compile times. For the rest of this video, I'll explain how Rust accomplishes this. Rust follows a release train model where every six weeks a new version of Rust is released to make sure the new release is robust and bug free.
00:00:42.297 - 00:01:12.389, Speaker A: This model uses three channels. Nightly is built every night from the master branch of the Rust Git repository. It's used for experimentation and testing new language features. Beta is built every six weeks and is used for finding and reporting bugs. And lastly, we have Stable, which is also also built every six weeks and is the production ready version of Rust. This is called the Train model because every six weeks a new stable release leaves the station. Let's look at a visual example of how a new stable release is shipped.
00:01:12.389 - 00:01:48.233, Speaker A: Every night a new nightly release of Rust is created from the master branch of the Rust Git repository automatically. In this diagram, the red nodes represent a new nightly release. Every six weeks a new beta release is created from the master branch. Nightly continues to get new versions while the beta branch is tested for regressions. If a regression is found, the fix is applied to Master, so Nightly is fixed. Then the fix is backported to the beta branch and a new release of Beta is produced. Six weeks after the first beta release was created, a new stable release of Rust is created from the beta branch.
00:01:48.233 - 00:02:30.363, Speaker A: At the same time, the next beta release is also created and the cycle repeats again. As you can see, this model allows experimentation while also allowing developers time to fix bugs before the next stable release. A Rust release and its associated components are called a toolchain. You can list the toolchains you have installed by running RustUp toolchain list. You can also install or update a toolchain by running rustup Update and then the name of the toolchain. Lastly, you can change the default tool chain by running RustUp Default and then the name of the toolchain. If you're curious what the current version of Rust is and when the next release date is, you can get this information by heading over to what rustisit.com
00:02:30.363 - 00:03:02.705, Speaker A: with that background, let's go over the Nightly, Beta and Stable releases in a little bit more detail. Nightly Rust is intended for experimentation and testing new language features. This means that it might be buggy. Occasionally, features in Rust are gated behind feature flags, which determine what features are enabled in a given release. In the Nightly version of Rust, you can enable experimental features. To do this, simply annotate your code with the feature attribute passing in the appropriate feature flag. In this example, we're enabling the box syntax feature.
00:03:02.705 - 00:03:39.485, Speaker A: Note that these features can only be enabled in Nightly, not Beta or Stable. As I've mentioned before, the beta release of Rust is used to find and report bugs. Developers are encouraged to test against Beta in their continuous integration setup to catch bugs before they reach stable. Finally, Stable Rust is the recommended version of Rust to use in production. Rust releases use semantic versioning, and every new release of Stable is a minor version bump. This means Rust has very strong stability guarantees. Once a feature reaches stable, the Rust team is committed to supporting that feature for all future releases.
00:03:39.485 - 00:04:30.197, Speaker A: This is what makes upgrading to new versions of Rust painless, because new versions of Rust do not include breaking changes, so your code should continue to work. You might be wondering, without breaking changes such as new keywords, how can the language evolve? Rust tackles the problem of breaking Making changes with Rust additions Features that are not backwards compatible, such as adding a new keyword, are released as part of a new Rust edition. A new Rust edition is released roughly every three years and is named after the year it's released. For example, so far we have Rust 2015, Rust 2018, and Rust 2021 additions contain breaking changes. However, they are opt in. All Rust compiler versions support any edition that existed prior to the compiler's release. This means you can be on the latest vers of Rust and use any addition you'd like.
00:04:30.197 - 00:05:17.289, Speaker A: The Rust compiler can also link crates with different additions. For example, you can have a crate on the 2018 edition with two dependencies, one dependency on the 2015 edition and another dependency on the 2021 edition. This means your code is isolated from breaking changes, and it's another way Rust maintains its promise of stability. And when you're ready to upgrade to the next edition, you can use the Cargo fix sub command to automatically fix your code for the next edition. Now that we understand the Rust release cycle, the three channels and additions, let's take a step back and talk about how new features are introduced. Rust's development model follows the Request for Comments process. If you'd like to propose an improvement you can write an RFC and submit a pull request.
00:05:17.289 - 00:05:56.109, Speaker A: Each proposal is reviewed and discussed by the Rust team which is comprised of many sub teams. You can see the full list of sub teams on the Rust website. If a feature is accepted an issue is opened on the Rust repository and someone can implement it. Note that the person who implements the RFC might not be the same person who wrote the rfc. This process allows anyone to improve Rust and ensures that features are thought through. In summary, Rust strives for stability without stagnation. It achieves this by using a six week release cycle coupled with three channels nightly for experimentation, beta for testing and stable for production use.
00:05:56.109 - 00:06:13.955, Speaker A: Additions allow you to opt into breaking changes and an RFC process is used to introduce new features. That's it for this video, but before you go make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet with that said, I'll see you in the next one.
