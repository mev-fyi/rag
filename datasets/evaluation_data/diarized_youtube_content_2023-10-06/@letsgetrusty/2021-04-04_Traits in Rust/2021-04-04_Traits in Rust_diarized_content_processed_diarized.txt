00:00:00.440 - 00:00:26.035, Speaker A: Welcome back to let's Get Rusty. My name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, hit that subscribe button for weekly Rust videos. In the last video, we covered chapter 10 of the Rustling book, specifically part one, which talks about generics. In this video, we're going to cover part two, which talks about defining shared behavior using traits. So let's jump into it. Let's look at the following example.
00:00:26.035 - 00:01:02.385, Speaker A: Say we have a program which aggregates different types of text content. In this case a news article and a tweet. Now, the news article has an author, headline and some content, and the tweet has a username, some content, and two booleans that indicate whether the tweet is a reply or a retweet. Now what we want is the ability to summarize a news article and also the ability to summarize a tweet. So. So we can post that in our text aggregation feed. In this case, we can use a trait to define the shared behavior between a tweet and a news article, which in this case is summarization.
00:01:02.385 - 00:01:30.031, Speaker A: To get more specific, by shared behavior, I mean methods. So traits allow us to define a set of methods that are shared across different types. Let's go ahead and define a summary trait to do that. First we'll start off with pub, because we want to make this trait public. And then we'll type in trait followed by our trait name, which in this case is summary. And then curly brackets. Inside the curly brackets we can define the shared methods.
00:01:30.031 - 00:02:17.105, Speaker A: So in this case we're going to have a method called summarize, and it will take a reference to self and then it will return a string. Notice here that we only specified the method signature. We don't actually have a method body, and that's because we don't want to dictate the implementation. We just want to say that for every type that implements this trait, they should have this summarize method and it will return a string. Now let's implement the summary trait for our news article type. So we'll create a new implementation block and we'll say impul and then summary our trait for news article. Then we'll specify our implementation of the summarized method.
00:02:17.105 - 00:02:50.005, Speaker A: Here we're saying implement the summary trait for news article. And in our summarize method, we're returning a string that contains the headline of the news article and the author. Next we'll define the summary trait for our tweet type. For a tweet, we Return a string with the username and the content of the tweet, because the content of the Tweet is only 280 characters. Here in Maine, we create a tweet with some random data and an article with some random data. And then we can call summarize on both the tweet and the article. Let's go ahead and run our program.
00:02:50.005 - 00:03:35.923, Speaker A: And here you can see we get a summary for the tweet and a summary for the article. Next, let's talk about default implementations. So we'll scroll back up to our summary trait and let's say that instead of specifying this summarize method signature and expecting every type that implements this trait to to specify the body of summarize, we want a default implementation. To do that, we can simply add a method body like so. Here we're saying that our summary trait has a method called summarize and its default implementation is to return this read more string. Our tweet struct overrides this implementation and has its own implementation, which is perfectly fine. So for tweet, we'll return this string here.
00:03:35.923 - 00:04:09.577, Speaker A: And for demonstration purposes, we'll remove the custom implementation with summarize from news article so we can see the default implementation. To do that, we'll just remove the contents of this input block. Let's go ahead and run our program again. And we get the same string for tweet, but for our article we get the default implementation. Default implementations can call other methods inside our trait definition. So for example, instead of having one function summarize, we'll have two. The first method is called summarizeauthor.
00:04:09.577 - 00:04:49.363, Speaker A: It will return the name of the author and it has no default implementation. The second method is called summarize, and it does have a default implementation which uses our summarizeal method. And up above we get an error because we actually need to implement summarizeal for our tweet. So let's do that here. We're simply going to return the username. We also need an implementation for our news article here we're just going to return the author and again we need to specify summarize author because it doesn't have a default implementation. But we don't have to specify summarize because it does have a default implementation down here.
00:04:49.363 - 00:05:26.981, Speaker A: Let's go ahead and run our program again and we get the same thing for our tweet, but for our news article. You can see we get the default implementation and now we have the author's name here. Now that we know how to define and use traits. Let's talk about traits as parameters. Here I have a new function called notify, and it takes in one item, which is a reference to something that implements summary. So basically we're saying item could be anything, any type that implements summary. And then we're calling this print line method, which prints breaking news and then calls summarize on the item down here.
00:05:26.981 - 00:06:04.849, Speaker A: In main, I call notify and pass a reference to article. Let's go ahead and run our program. And now you can see it prints out breaking news and then the summary of our article. Note that this impulse syntax here works for straightforward cases, but it's actually syntax sugar for something called a trait bound, which looks like this. Here we have notify and it uses a generic, which we call T. And then we write this colon space summary text, which means that this generic is limited to something that implements the summary trait. And then we simply use our generic in the parameter definition here.
00:06:04.849 - 00:06:50.247, Speaker A: Again, this is a longer form of the function up above using the impl syntax, and impl could be used for more concise code in simple cases. Let's look at a slightly more complicated example where trait bounds give us more power. Here we have our notify function, and now instead of taking one parameter, it takes two parameter item one and item two. And again here we want both of them to be any type that implements the summary trait. But what if we wanted both item one and item two to be exactly the same type? Well, we can't really express that with the impulse syntax, but we can with the traitbound syntax. In our function below, we use a generic called T which implements summary, but this T is one type. And then we say item one and item two are both of type T.
00:06:50.247 - 00:07:17.401, Speaker A: So not only is a type that implements the summary trait, but it's the exact same type. Note that we could also specify multiple traits using the impulse syntax. It'll look like this. Here we're saying item one has to be something that implements both summary and the display trait. We could also do the same thing for the trait bound syntax. So after summary we'll just add plus display. And this is saying we have a type T which has to implement the summary trait and a display trait.
00:07:17.401 - 00:08:09.413, Speaker A: One last thing to know here, specifying multiple trait bounds could hinder readability. For example, we have this function called sum function, and it has a generic type T that implements display and clone. And then we have a generic type U which implements clone and debug and and as you can see, there's a lot of text between the function name and the function parameters, which doesn't look very readable. So to fix this, we can use something called the where clause, like so here again, we're declaring some function which has two generics, t and u, and the parameters of this function use those generics. And then after the return type, we specify our where clause. We're saying where T implements display and clone, and you implements clone and debug. So as you can see, we take these trait bounds and we just move them to after the function signature, which makes things more readable.
00:08:09.413 - 00:08:42.807, Speaker A: Now let's talk about return types. Here we have our summary trade definition, and underneath we define a function called returns summarizable. And you can see here the return type is impulse summary. So we're returning any type that implements the summary trait, not a concrete type. And then inside the function body we return a tweet. Then in main we can call print line with this statement here, returns summarizable, which again will return something that implements summary dot summarize. And we know we can call dot summarize here because whatever is returned has the summary trait.
00:08:42.807 - 00:09:35.481, Speaker A: So let's go ahead and run our program and as you can see, we get the summary of our tweet. Returning types that implement a certain trait instead of concrete types is very useful inside of closures and iterators, which is something we'll learn more about in chapter 13. Note that this impul trait syntax for the return type does have a restriction, which is that if we were to return a news article or a tweet, for example, depending on a boolean that was passed in like we do here, this would not be allowed. Basically, we can only return one type, and this has to do with how the compiler implements the infiltrate syntax. We'll learn more about how to get around this in chapter 17. Next, I want to talk about using trait bounds to conditionally implement methods. Here we have a struct called pair, and it has two fields, x and y, which are both a generic type T.
00:09:35.481 - 00:10:18.149, Speaker A: Then we have two implementation blocks. The first implementation block is on the type pair of T. So pair with a type parameter that's generic. This is basically saying this implementation block is for any pair struct, and inside we have the new function which creates a new pair. Our second implementation block looks very similar, except here we use trait bounds to say that T has to implement display and partial order. Then we define this comparedisplay method which compares X and y, and we could do that because we know X and Y implement the display and partial order trait. So again, what we're saying with these two implementation blocks is that every pair struct is going to have this new function.
00:10:18.149 - 00:11:05.893, Speaker A: However, this compare display method is only going to be available to pair structs where the type of X and y implement display and partial order. The last thing I want to mention very briefly is blanket implementations. Basically, we can implement a trait on a type that implements another trait. In this example, we're implementing the tostring trait on any type T that implements the display trait, and this is used widely in the standard library and might seem confusing. And I'll make an entire video about this particular subject, but just to throw it out there, this does exist as well. In the last video we learned about generics, which let us abstract concrete types in order to reduce duplication. And in this video we learned about traits, which let us specify shared behavior across multiple types.
00:11:05.893 - 00:11:33.775, Speaker A: We also learned how to use generics with traits to create trait bounds, which allow us to, instead of using concrete types, use a generic type that specifies some set of functionality. In the next video, we're going to be talking about one of the hardest subjects in Rust, which are lifetimes. If you want to see that, make sure you subscribe so you can get a notification when it comes out. And if you like this video, make sure to give it a thumbs up for the YouTube algorithm. And with that, I'll see you in the next one.
