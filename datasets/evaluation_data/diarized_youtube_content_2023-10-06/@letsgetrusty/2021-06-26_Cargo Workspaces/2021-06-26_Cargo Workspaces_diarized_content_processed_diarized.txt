00:00:00.520 - 00:00:26.009, Speaker A: Welcome back, Rust gang. If you're new here, my name is Bogdan, and this channel is all about the Rust programming language. If that sounds interesting to you, click that subscribe button. For weekly Rust videos. In the last video, we talked about publishing a crate to Crates IO. And in this video we're primarily going to talk about Cargo workspaces. Recall that in chapter 12 we built a CLI program that had a binary crate and a library crate.
00:00:26.009 - 00:01:11.291, Speaker A: Now, what happens if the project keeps growing and we have multiple library crates? Well, in that case, cargo workspaces might help you organize your project. Workspaces help you manage multiple related packages that are developed in tandem. Packages in a workspace share common dependency resolution by having one cargo lock file. Packages in a workspace also share one output directory and various settings such such as profiles. All right, now we have enough of the basic information to get started. So with that, let's get rusty. For simplicity, we're going to create a workspace with one binary that depends on two libraries.
00:01:11.291 - 00:01:58.065, Speaker A: The first library will have a add one function, and the second library will have an add to function, which our binary will use. To start off, let's create a directory called add and CD into it. Then let's open this up in VS code. Next, we'll add a cargo TOML file, which will configure the entire workspace. Now, instead of having a package section like usual, we'll create a workspace section. Next, we can specify the packages in our workspace, which are called workspace members. So to do that, we'll type in members, equal and then brackets.
00:01:58.065 - 00:02:35.857, Speaker A: And here we'll type in the path to our packages. First we're going to specify the path to our binary, which is going to be called adder. So the path is just adder. Next we'll open up the terminal and actually create the adder package. At this point, we can also build our workspace by running Cargo Build from the add directory. At this point, we can see that the cargo log file and target directory were generated at the root of our workspace. And if we look at the adder package, you can see that it doesn't have a cargo lock file or a target directory.
00:02:35.857 - 00:03:14.615, Speaker A: Even if we run cargo build from the adder directory, we would still see the output in the top level target directory. Cargo uses this structure because packages in a workspace are meant to depend on each other. If each package had its own target directory, then when you would compile that package, you would have to also compile all its dependencies. So this reduces the amount of recompilation you have to do. All right. Next, we'll add another package or member to our workspace and call it add1. Then we'll type in cargo new add1 and then dash dash lib because we want to create a library.
00:03:14.615 - 00:04:03.085, Speaker A: Next, let's navigate to the lib RS file in our new library, and we'll delete this default tests module and add a public add one function. Now that we have this library with an add one function, we we can use it from within the adder binary. So let's open up the cargo toml file within the adder directory. Next, we need to specify that our adder binary depends on our Add1 library. So let's scroll down to the dependency section and add our add one library as a dependency. Cargo doesn't assume that crates within a workspace depend on each other, so we have to make this relationship explicit. Next, we'll open up main RS within the source directory in our adder package.
00:04:03.085 - 00:04:46.105, Speaker A: And notice that when we type in the library name, we use an underscore instead of a dash. Then we can modify main to use our Add1 function. Here we're declaring a new variable called num and setting it to 10. And then we have this print line statement which prints hello world, the number we just declared, and then the number plus one. And we get that by calling our add one function. All right, now let's build our workspace by typing in cargo build at the root of our workspace. Next, we can run our attr binary from the root of our workspace by typing in cargo run P to specify the package we want to run and then adder.
00:04:46.105 - 00:05:26.453, Speaker A: And as you can see, our add1 function worked. Next, let's talk about external dependencies. If you look at the Explorer tab on the left, you'll see that we have a cargo toml file for both our add one package and our adder package. However, we only have one cargo lock file in the root of our workspace. This ensures that all our crates are using the same version of all dependencies. So if we add a dependency to our add one package and we add the same dependency to our adder package, they will both resolve to the same version. Making all packages in a workspace use the same dependencies, ensures that the packages are compatible with each other.
00:05:26.453 - 00:06:14.285, Speaker A: Let's try this out. By adding an external dependency, we'll go to the cargo toml file for our add one package and add the create rand as a dependency. Then we can go into lib RS and bring RAND into scope and we'll get a little warning here because we're not actually using rand anywhere in our program. Then from the root of our workspace in the add directory, we can run cargo build. This will bring in and compile the rand crate. And if we look at the cargo dot lock file in the root of our workspace, we can see that we have the ran crate here. And if we go a little bit down, you can see the rand crate is defined here as a dependency.
00:06:14.285 - 00:07:06.341, Speaker A: Now, even though rand is a dependency of our Add1 package and it's defined in the root cargo lock file, it doesn't mean that we can use rand in any other package in the workspace. For example, if we go into main RS in our adder package and try to bring rand into scope, we should get an error. If I hover over the red squigglies, you can see that the error is an unresolved import rand. To fix this, we'll need to add rand as a dependency of the adder package inside of adders cargo toml file. And now we can bring rand into scope inside main rs. At this point, both our adder package and our add one package have a dependency on the rand crate. However, only one version of the rand crate will be downloaded.
00:07:06.341 - 00:07:51.445, Speaker A: Next, let's briefly COVID testing inside our Add one package. We'll add a test module and one test inside lib rs. The test is called It Works, and it simply asserts that calling our add one function with two is going to return three. Next, we'll open up the terminal and run Cargo test from our workspace root, which is the add folder. If I scroll up, you can see that the first section is showing the test that ran for the ADD1 project. And in this case, we just had one test called it Works, which succeeded. The next section is Tests that ran for our adder project, and you can see zero tests were found.
00:07:51.445 - 00:08:25.497, Speaker A: The last section lists documentation tests that ran for our ADD1 library. And as you can see, there are zero documentation tests at this point. Running cargo tests like this in the root of our workspace will run tests for all the projects within that workspace. If we want to run tests for a specific project, we can do that by specifying P. For example, let's run tests only for the Add1 project. So to do that, we'll type in Cargo test p and then add one. This time we only have two sections.
00:08:25.497 - 00:09:05.595, Speaker A: The first section is for our regular tests, we only have one called It Works. And the second section is for our documentation tests. Which we have 0 of. I'm going to stop here, but I'll give you some homework. If you'd like to continue, then go ahead and add another library called add2, which will have a function similar to add1, except of course it's going to add2 to the integer being passed in as we're wrapping up. Talking about Workspaces One thing to note is that if you want to publish the packages within a workspace, you have to publish them individually, meaning you'll have to CD into each package. In this example, adder and Add one and then run Cargo publish from their respective directories.
00:09:05.595 - 00:10:01.715, Speaker A: That's about it for workspaces. So next time you find yourself in a situation where you have a big monolithic project with a lot of components that change together and and you want to make them a little more organized by splitting them out into different projects, then consider using workspaces. Next we'll talk about installing binaries from Crates IO with Cargo install. Now, this isn't meant to be a replacement for system packages or package managers such as Homebrew, but rather it's a convenient way for Rust developers to use tools built by other Rust developers and publish to Crates IO. Note that you can only install packages that have a binary target. Remember, packages could have binary targets and library targets, but specifically we need the binary target because we need something we could actually execute. All binaries installed using the Cargo install command are stored inside the Installation routes bin directory.
00:10:01.715 - 00:11:08.311, Speaker A: If you installed Rust using Rust up, then this is the path to the bin directory. Make sure to have this path inside your path environment variable, so that way you can run programs installed with the Cargo install Command. In Chapter 12, I mentioned that there's a Rust implementation of the popular tool grep called rip grep. To install rip grep, we'll run the following command cargo install rip grep the second to last line here shows where the binary is installed, and in this case it's in the Cargo bin directory and the executable is actually named rg. Now that the tool is installed, and assuming that your path environment variable is set up correctly, you can simply run RG help and you can see the executable is working. One cool thing about these binaries is that you can use them to extend Cargo with custom commands. If you have a binary in your path that's prefixed with cargo.
00:11:08.311 - 00:11:42.115, Speaker A: For example, let's say that the binary is called cargo dash something. Then you can run this as a sub command of cargo by typing in cargo space something. Cargo is designed this way so you can extend cargo without actually modifying cargo's code. That concludes chapter 14 of the Wrestling book. If you enjoy this video, make sure to smash that like button. And if you want to see weekly Rust content, make sure to hit that subscribe button. And with that, I'll see you in the next one.
