00:00:00.520 - 00:00:48.796, Speaker A: When it comes to idiomatic rust, one of my favorite design patterns is called extension traits, and I actually stumbled across this powerful pattern when dealing with a restriction in rust. Rust has an unusual rule called the orphan rule. The orphan rule states that you cannot implement a trait defined outside of your crate on a type defined outside of your crate. In other words, you can only implement a trait for a given type if either the trait is internal to your own crate or the type is internal to your own crate. For example, you can implement an internal trait called sum on the external vector type defined in rust standard library. Or you can implement the external debug trait defined in rust standard library on an internal rectangle type. However, you cannot implement the debug trait on the vector type because both are external to your crate.
00:00:48.796 - 00:01:31.310, Speaker A: This rule prevents conflicting trait implementations. You can imagine that the standard library has its own implementation of debug for vector. If we were allowed to define an alternative implementation, the compiler wouldn't know which implementation to use. The orphan rule eliminates this ambiguity. Now that we understand the orphan rule and why it's needed, let's dig a bit deeper into the two ways traits can be implemented without violating the orphan rule. First, we'll talk about a best practice when it comes to implementing external traits defined elsewhere on internal types you've defined. And secondly, we'll talk about the extension traits design pattern that results from the ability to implement internal traits you've defined on external types defined elsewhere.
00:01:31.310 - 00:02:19.978, Speaker A: Imagine you're writing a rust library and are exposing structs and enums as part of your public API. It's best practice to implement most of the standard library traits such as debug, clone default and partial equal, which are external to your crate on your internal types which you are exposing. Essentially, we are anticipating that consumers of our library will likely use these common traits. If we decide not to implement these traits, it will cause unnecessary headaches for library consumers. This is because of the orphan rule. Lets switch perspectives and put ourselves in the shoes of a library consumer. As consumers, we wont be able to do basic things like print the user type with debug formatting because the debug tray is not implemented, and because of the orphan rule, we won't be able to implement the debug trait ourselves.
00:02:19.978 - 00:03:24.926, Speaker A: From our perspective as a library consumer, the debug trait is external because it's defined in rust standard library, and the user type is also external because it's defined in a third party library. One way to get around this is by using the new type pattern by wrapping an external type in a tuple struct defined within our own crate, we can implement external traits on that type, but this is not ideal because it does require additional boilerplate, and it can be very difficult to write a sensible implementation of a trait without access to the types internals. So again, if you're writing a rust library, it's best practice to implement these standard library traits eagerly on types your API exposes. Now this is an example of implementing an external trait on an internal type defined within our own crate. But what about the other side? Implementing an internal trait defined within our own crate on an external type. This is actually a widely used design pattern in rust called extension traits. By implementing our own traits on external types, we can extend their functionality.
00:03:24.926 - 00:04:05.854, Speaker A: Let's go through a simple example and then discuss a more complicated one. Let's say we're writing a web server in rust using the actics web framework. Actics web expects route handlers to accept an HTTP request object and return an HTTP response object. With the extension traits pattern, we can add functionality to either object. For example, we can define an HTTP request extension trait with a method called getjwt. Then we can implement this internal trait on the external HTTP request object to extract the JSON web token from the authorization header. Finally, inside our route handler, we're able to use this new method with just a few lines of code.
00:04:05.854 - 00:04:53.220, Speaker A: We were able to extend the functionality of a type external to our own crate. Pretty cool, right? I actually recently used this exact approach to add a method called isarch Linuxuser on the Httprequest object. Now, whenever I detect an arch user trying to access my website, I graciously redirect them to the Ubuntu install page with the basics covered. Let's look at a more advanced example. Imagine we wanted to extend the functionality of iterators by adding a method called unique, which filters out duplicate items. In this case, instead of extending the functionality of a single external struct or enum, we want to extend the functionality of all concrete types which implement the iterator trait defined in rust standard library. The solution is a bit complicated, so let's go through it step by step.
00:04:53.220 - 00:05:31.022, Speaker A: First, we'll define a new extension trait and add iterator as a super trait. This means that any type implementing our extension trait must also implement the iterator trait in Rust standard library. This allows us to build on top of the iterator trait. Next, we'll define a method that consumes the iterator and returns a new internal struct called Uniqueiterator, which stores the original iterator and a hash set of scene items. We'll also add a default implementation. Basically, we want to consume the original iterator and return a specialized iterator that only produces unique items. Note that we need to make sure self is sized so it could be consumed by our method.
00:05:31.022 - 00:06:29.810, Speaker A: We also need to make sure the iterable items implement equal and hash so they could be stored in the hash set and clone so they could be cloned when being added to the hash set. Next, we'll implement the external iterator trait on our internal uniqueiterator type so it works seamlessly with Rust's iterator methods. The only required method is next, which produces the next item in the iteration. Our implementation will use the hash set to only yield unique items. Finally, instead of implementing our extension trait on various concrete iterator types manually, we can leverage another powerful rust feature called blanket implementations. By using generics and trait bounds, we can implement our extension trait on any concrete type which implements the iterator trait, and now we can call the unique method on any concrete iterator type. The extension traits pattern is extremely powerful because it allows you to add custom methods to existing types without modifying their original definitions.
00:06:29.810 - 00:06:53.010, Speaker A: That's why it's widely used in the rust ecosystem. In fact, the example we just covered is taken from the popular iter tools crate. Other popular crates using this pattern include serdae, rayon, and Chrono. If you'd like to learn more about Rust's unique features and patterns, make sure to get your free rust cheat sheet by heading over to let'sgetrusty dot cheatsheet. Hope you've enjoyed this video, and remember to stay rusty.
