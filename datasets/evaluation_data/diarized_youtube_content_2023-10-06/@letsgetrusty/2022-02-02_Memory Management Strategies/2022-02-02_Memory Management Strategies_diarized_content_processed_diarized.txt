00:00:00.360 - 00:00:39.325, Speaker A: What's up Rustations? Welcome back to let's Get Rusty, your number one resource for all things Rust. In today's video, we're continuing our series on memory management. In the last video, we discussed memory regions, specifically the stack, the heap, and static memory. If you haven't seen that video already, then pause this video and make sure to watch that one. In this video, we're going to discuss the different strategies for managing memory on the heap. So with that, let's get Rusty. When it comes to managing memory on the heap, we can think about the different strategies along a spectrum.
00:00:39.325 - 00:01:21.411, Speaker A: On one extreme you have manual memory management, where the programmer allocates and deallocates memory manually. An example of this would be the C programming language. On the other extreme, you have automatic memory management, AKA garbage collection, where memory is allocated and deallocated automatically. You can think about this as a little program running inside your program that cleans up memory for you. Examples of garbage collected languages are java, C sharp, JavaScript, Python, et cetera. So that leaves us with the middle of the spectrum. In the middle we have patterns like raii, which stands for Resource acquisition, is initialization and was created for the C programming language.
00:01:21.411 - 00:02:07.043, Speaker A: We also have obrm, which stands for Ownership Based Resource Management. That's the system implemented in Rust. OBRM is based on raii, except that instead of being a pattern that you can choose to use, it's built into the language. In the next couple of videos I'll be diving into RAI and Ownership Based Resource management, but for now, just know that it lies somewhere in between manual memory management and automatic memory management. All right, with that overview, let's look at the pros and cons of each strategy. Starting off with manual memory management, the pros of this strategy is that you have full control over your memory. You get to decide when it's allocated and when it's deallocated, which means that your programs will be very efficient.
00:02:07.043 - 00:02:32.439, Speaker A: The cons are that manual memory management is very tedious and also very error prone. You might forget to clean up memory, for example, or try to access invalid memory. This could lead to bugs in your program and more importantly, severe security vulnerabilities. So let's look at the other side of the spectrum, automatic memory management. The pros are it's easy. Memory is managed for you so you don't have to think about it. Also, it's error free.
00:02:32.439 - 00:03:12.785, Speaker A: Now, you can still have bugs in your program, but you won't have memory defects that lead to severe security vulnerabilities like you would if you used manual memory management. Now the cons are you have no control over your memory because somebody else is managing your memory. Your programs will also not be as efficient, and that's because the garbage collector has to pause execution of your program every once in a while to clean up memory. You might have noticed this, but if you look at the two sides of the spectrum, you'll see that they have opposite trade offs. Now let's look at the middle. You get all the pros of manual memory management, you have control over your memory and your program is efficient. However, you get the added benefit of memory safety.
00:03:12.785 - 00:04:04.797, Speaker A: Now I say mostly error free here because it's not going to be as error free as a garbage collected language, but it's going to be pretty dang close. Now the one con I listed here is that it's still somewhat tedious. Not going to be as tedious as manual memory management, but it's certainly not going to be as easy as automatic memory management where you don't even have to think about memory at all. Now that we have an overview of the pros and cons, let's talk about how these strategies relate to Rust from a programmer's perspective. It would be really nice if we could just use automatic memory management because I wouldn't have to worry about managing memory myself. However, Rust is a systems programming language which means that it has to be extremely efficient and automatic memory management is not efficient, so the that's going to be ruled out. Rust is also a memory safe programming language, so manual memory management is ruled out because it's error prone.
00:04:04.797 - 00:04:36.515, Speaker A: That leaves us with the strategies in the middle which achieve efficiency and memory safety. In the next couple of videos I'll be going over how RAII and OBRM work and comparing C to Rust in terms of memory management. If you enjoyed this video, let me know by leaving a like and a comment. And if I missed something or got something wrong, let me know down in the comments as well. Lastly, get your free Rust cheat sheet by heading over to letsgetrussy. Com cheat sheet and with that said, I'll see you in the next one.
