00:00:00.400 - 00:00:24.001, Speaker A: Welcome back, Rust Gang. If you're joining us for the first time, my name is Bogdan, and this channel is all about the Rust programming language. Now, before we get started, I've noticed that over 50% of you are not subscribed to the channel. What are you doing? Hit that subscribe button. Hit that notification bell. Because I'm releasing weekly Rust content which you don't want to miss out on. Also, I've created a free Rust cheat sheet just for you.
00:00:24.001 - 00:01:00.495, Speaker A: If you want access to that, head over to LetsGetRusty.com Cheat Sheet. With that said, today we're continuing the series on Advanced Rust by talking about advanced traits. So with that, let's get rusty. First, let's talk about associated types. Associated types are placeholders which you can add to your trait, and then methods can use that placeholder. For example, here we've defined the Iterator trait which has one associated type named item, and we use it in the next method.
00:01:00.495 - 00:01:34.111, Speaker A: Item will be the thing we return. Then when we implement our Iterator trait, we will specify a concrete type for item. This way you can define a trait which uses some type that's unknown until we implement the trait. In this example, the Iterator trait has a method called next which is going to return the next item in an iteration. However, we don't know what the type of that item is until the Iterator trait is implemented. If the Iterator trait is implemented on a vector of integers, then atom will be an integer. If it's implemented on a string, then item will be a character.
00:01:34.111 - 00:02:26.155, Speaker A: As an example, now you might be thinking, what's the difference between associated types and generics? They both allow us to define a type without specifying the concrete value. The difference is, with associated types we can only have one concrete type per implementation, whereas with generics we can have multiple concrete types per implementation. For example, let's say we have some struct. In this case we're going to call it counter, and we're just going to leave it empty. And then let's implement our Iterator trait for counter. First we'll specify a concrete type for item, and in this case it's going to be an unsigned 32 bit integer. Then we'll implement the next function, and because this is just an example, we're going to return sum zero.
00:02:26.155 - 00:03:16.025, Speaker A: Here we have an implementation of iterator for counter where item is an unsigned 32 bit integer, and we can't have another implementation where item is something different. For example, let's say we wanted to have another implementation, so we'll copy this block and instead of an unsigned 32 bit integer, we wanted an unsigned 16 bit integer. As you can see, we get a compile time error saying that there's conflicting implementations for the trait iterator on type counter. So we can't have two implementations where item is a different type. But now let's say we use generics to implement Iterator. Instead of an associated type, we're going to specify a generic, which in this case we'll just call t. And then our next function is going to return an optional with that generic inside.
00:03:16.025 - 00:04:20.593, Speaker A: Then we're going to change both our implementations of Iterator for counter. In the first implementation we want our generic to be a concrete type of unsigned 32 bit integer. Then we can get rid of this associated type and return an unsigned 32 bit integer. For the second implementation we want to do something similar, except this time we're going to return an unsigned 16 bit integer. As you can see, our code is compiling just fine. Generics allow us to have multiple implementations of the Iterator trait on a single type, substituting the generic for different concrete values. So when deciding between associated types and generics, the question is, does it make sense to have multiple implementations for a single type or just one implementation for that type? In the case of the Iterator trait, it makes sense to use an associated type because for any given implementation we want the next method to return the same concrete type.
00:04:20.593 - 00:05:04.247, Speaker A: Next, let's talk about default generic type parameters and operator overloading. Generic type parameters could specify a default concrete type. This allows implementers to not have to specify a concrete type unless it's different than the default. A great use case for this is when customizing the behavior of an operator, AKA operator overloading Rust allows you to customize the semantics of certain operators that have associated traits. In the standard library ops module, one of the operators you can overload is the add operator. For example, we can overload the add operator for our point struct by implementing the add trait for point. First we specify a concrete type for output, which is an associated type.
00:05:04.247 - 00:05:43.095, Speaker A: And here output is going to be the return type of the add method. In this case, we want to return another point. Then we're going to implement the add method, taking in another point and returning a point where the X field is going to be the sum of self x and other x and the y field is going to be the sum of self y and other dot y. Then in main we can add two points together. In this case, point one is going to have x equal to 1 and y equal to 0, and point two is going to have x equal to 2 and y equal to 3. And we're going to assert that the output is going to be a point where X is 3 and Y is also 3. Now, if we were to look at the implementation of the add trait, it would look like this.
00:05:43.095 - 00:06:26.071, Speaker A: Notice that the add trait has a generic called rhs, which stands for right hand side, and that's the type that's passed into the add method. RHS has a default concrete type which is going to be self or the type that's implementing the add trait. This makes sense because typically when we want to add two things together, for example a point with another point, the return type is going to be a point as well. Because RHS has a default concrete type. We didn't need to specify a concrete type when we implemented add for point because we were returning a point. Let's look at an example where we would want to specify the type passed into the add method. In this example we have two tuple structs named millimeters and meters.
00:06:26.071 - 00:07:00.275, Speaker A: We then implement the add trait for the millimeter struct. And in this case we want to specify that the RHS generic, which is the generic being passed into the add method is going to be meters. We want the ability to add meters to millimeters and have millimeters be returned. In general, you can use default generic type parameters for two reasons. Reason number one is to extend a type without breaking existing code. Reason number two is to allow customization for specific cases, which most users won't need. The attree in the standard library is an example of the second case.
00:07:00.275 - 00:07:40.613, Speaker A: Most of the time we want to add the same types, but in certain situations, such as this one, we want to be able to add different types. Reason number one is the opposite. If you already have a type and you want to add a generic parameter, but you don't want to break existing code, then you can have a default concrete type. Next, let's talk about calling methods with the same name. Rust allows you to have two traits with the same method and implement both those traits on one type. It's also possible to implement a method on the type itself with the same name as the methods inside the traits. If you get into the situation where you have the same name for methods, then you need to tell Rust which method you'd like to call.
00:07:40.613 - 00:08:14.643, Speaker A: Let's look at the following example. We have a trait called Pilot, which has a method called Fly. We have a trait called wizard, which also has a method called fly. And then we have a struct called human. The human struct implements a method called fly, and we also implement the Pilot trait and the wizard trait for Human. Then in main, we create a new human and call the Fly method. Let's go ahead and run our program and what we get printed out is waving arms furiously, which is the method that's implemented on the human struct.
00:08:14.643 - 00:09:11.487, Speaker A: If we wanted to call the Fly method either from the Pilot trait or from the wizard trait, then we need more explicit syntax. For example, if I wanted to call the Fly method on the Pilot trait, then I would type in pilot, colon, colon, fly, and then pass it a reference to person. And I could do the same thing for the wizard trait. Let's go ahead and run our program again, and this time the first string printed out is this is your captain speaking, which is the pilot implementation of Fly. Then the second string printed is up, which is the wizard implementation of Fly. And then the third string is waving arms furiously, which is the human struct implementation of Fly. Now, because the Fly method takes self as a parameter, if we had two different structs which both implemented the wizard trait, for example, Russ would know which Fly method to call based on the type of self.
00:09:11.487 - 00:09:55.725, Speaker A: However, this is not true for associated functions because they don't take self as a parameter. As an example, let's remove these two calls to Pilot and Wizard, and then we'll change our methods to associated functions. Then we can change main to call our associated function. Let's go ahead and run our code, and the string we get is waving arms furiously. So again, by default, the associated function that gets called is the associated function on our struct itself. But let's say this is not what we wanted. What we actually wanted is for the associated function defined in the wizard trait to be called.
00:09:55.725 - 00:10:28.567, Speaker A: To do that, we need to use fully qualified syntax, which looks like this. This tells Rust that we want to call the Fly function on the wizard trait as implemented for Human. Let's go ahead and run our program again, and this time the string we get is up. Next, let's talk about super traits. You might have a trait that's dependent on functionality from another trait. In this case, your trait is dependent on the other trait being implemented. The trait you rely on is called a super trait.
00:10:28.567 - 00:11:21.507, Speaker A: For example, here we have a trait called outline print with a function also called outline print. Calling this method will print a value framed in asterisk, for example if we pass it the point struct the then it will print something like this. Notice that we get an error here calling tostring because we don't know if self implements tostring. Tostring is defined in the display trait, so we want to make sure that anything that implements outline print also implements the display trait. To encode this relationship, first we'll import the format module which contains the display trait, and then after outline print we'll write colon format display and we actually need two colons here. Because we've specified that our trait depends on the display trait, we can now use the tostring method. Let's see what happens if we try to implement our trait on the point struct without also implementing the display trait.
00:11:21.507 - 00:12:08.045, Speaker A: First we'll define the point struct. Then we'll implement outline print for point. Notice here that we get an error saying that point doesn't implement the display trait. To fix this, we simply implement the display trait for point the last thing I want to talk about is the new type pattern. In chapter 10 of the Rustling Book, we learned about the Orphan rule which states that we can implement a trait on a type as long as the trait or the type is defined within our crate. The new type pattern allows us to get around this restriction. We do this by creating a tuple struct with one field which is going to be the type we're wrapping this thin wrapper around.
00:12:08.045 - 00:13:01.795, Speaker A: Our type is local to our crate, so we can implement any trait we'd like for it. In this example, we want to implement the display trait for a vector, but the display trait and vector type are both defined outside of our crate. To get around the Orphan rule, we create a new tuple struct called wrapper which stores a vector, and then we can implement the display trait for Wrapper Inside our implementation, we can simply access the vector by calling self. The downside of this pattern is that wrapper is a new type, so we can't call methods defined on the vector type directly on wrapper. However, if we did want our new type to implement every method on the type it's holding, then we can implement the dereference trait such that dereferencing wrapper would return the inner value. However, if we only wanted our new type to have a subset of methods defined on the inner type, then we would have to implement each of those methods manually. Alright, that's it for this video.
00:13:01.795 - 00:13:24.735, Speaker A: If you enjoyed it, then high five that like button and if you want to see weekly Rust videos, then hit subscribe and hit that notification bell. Lastly, and most importantly, I have a free Rust cheat sheet which I would like to give to you. So if you want access to that, head over to let'sgetrusty.com forward/cheat sheet. And with that said, I'll see you in the next one.
