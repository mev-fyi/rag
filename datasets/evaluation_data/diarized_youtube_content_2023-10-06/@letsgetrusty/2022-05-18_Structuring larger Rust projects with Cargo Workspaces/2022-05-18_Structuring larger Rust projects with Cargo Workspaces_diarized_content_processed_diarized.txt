00:00:00.400 - 00:00:41.428, Speaker A: A workspace is a collection of related cargo packages. Packages in a workspace share a cargo lock file, meaning that if multiple packages have the same dependency, that dependency will be resolved to one version. Packages in a workspace also share one output directory and various build settings such as profiles. Workspaces are useful when you're working on multiple related packages together. For example, let's say we wanted to have a monolithic codebase for a blogging website. Our blogging website will have three packages, one containing the API, another containing the front end, and a third containing code that is shared between the two. There are two ways to create a workspace.
00:00:41.428 - 00:01:18.774, Speaker A: The first is to use a root package, and the second is to create a virtual manifest. In this example, we're going to use a virtual manifest. To start, we'll create a new directory called blog. Then well cd into that directory and create a cargo toml file. Then well open up this folder in versus code. Next well open up cargo Toml and add a workspace section. Then well list the packages in our workspace.
00:01:18.774 - 00:02:24.308, Speaker A: Packages in a workspace are called members, so let's add a members field. First we have our blog API, then our blog front end, and finally the shared code. Next we'll open up the terminal and create these packages. First we'll create the blog API and here I'm specifying vcs none so that a git repository isn't automatically created. Then we'll create the blog web package, and lastly we'll create the blog shared package which is going to have a library crate. At this point we have a blog directory containing a cargo toml file and three packages. This cargo toml file is called a virtual manifest because it defines a workspace rather than a package.
00:02:24.308 - 00:03:20.100, Speaker A: Let's go ahead and run cargo build from the root blog directory. Notice that a cargo lock and a target directory were generated in the root blog directory. And if we look at blog API, blog shared and blog web, they do not have a target directory or cargo log file. If we open up the top level target directory and click debug, you can see that it contains our blog API binary, our blog web binary, and our blog shared library. Running cargo commands such as build or test from the root of our workspace will build or test every package in the workspace. However, we could target a specific package with the p flag. For example, we can build blog API by typing in cargo build P blog API.
00:03:20.100 - 00:04:22.980, Speaker A: Next, let's update the three packages in our workspace, starting off with the shared library. First we'll add the Serde library as a dependency which is used for serialization. Also well turn on the derive feature so we have access to the serialize and deserialize derive macros. Then well open up lib rs, delete the default test module and implement a post struct and well also add a constructor function. Next well import, serialize and deserialize from serde. Then well derive the serialize, deserialize and debug traits for post. Now that post is defined lets use it inside our blog API and blog frontend.
00:04:22.980 - 00:05:39.094, Speaker A: First well open up cargo toml inside blog API and add blog shared as a dependency. In this case, because blogshared is a local dependency, we can specify a path to it. Then we'll open up main rs and import post, create a new post in main and print it out. And we can do the same thing for blog web. And there you go. We have a front end codebase, a backend codebase, and a shared codebase all being developed in the same workspace. That's it for this video.
00:05:39.094 - 00:05:56.410, Speaker A: But before you leave, if you haven't already, make sure to get your free rust cheat sheet by heading over to letsgetrusty.com cheatsheet. Also, let me know if you enjoyed this video by leaving a comment down below and giving this video a like. With that said, ill see you in the next one.
