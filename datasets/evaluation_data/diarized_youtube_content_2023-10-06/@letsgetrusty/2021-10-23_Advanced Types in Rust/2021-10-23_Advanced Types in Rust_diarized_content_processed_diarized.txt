00:00:00.320 - 00:00:42.264, Speaker A: Welcome back, Rust Gang. If you're joining us for the very first time, my name is Bogdan, and this channel is all about the rust programming language. In today's video, we're continuing the advanced Rust series by talking about advanced types in rust. So with that said, let's get rusty. First, let's talk about the new type pattern. In the last video, we talked about the new type pattern in the context of implementing a trait on a given type. As a recap in rust, there's a rule called the orphan rule, which states that you can implement a trait on a given type if either the trait or the type is defined within your crate.
00:00:42.264 - 00:01:20.790, Speaker A: However, if you want to implement a trait on a type where both the trait and the type are defined outside of your crate, then you can use the new type pattern. In this example, we want to implement the display trait on a vector type. However, both the display trait and the vector type are defined outside of our crate. We get around this by creating a new type called wrapper, which is a tuple struct containing vector. Because wrapper is defined within our crate, we can implement the display trait for wrapper. Then, inside the implementation block, we can simply use the wrapped value, which in this case is a vector. By calling self dot zero, we can also use the new type pattern to increase type safety.
00:01:20.790 - 00:02:00.282, Speaker A: Imagine you had two functions. One function took in age as a parameter. Another function took in an employee id as a parameter. The type of both parameters is an unsigned 32 bit integer. If you want to prevent the user from passing in the employee id instead of age, or vice versa, then you can create a new type which wraps an unsigned 32 bit integer. For example, we can create a tuple struct for age and id. Then, instead of passing in a raw integer to those functions, we can pass in either the age or the id.
00:02:00.282 - 00:02:36.430, Speaker A: Another use of the newtype pattern is to abstract away implementation details. For example, we can create a people type which wraps a hashmap of integers to strings. Code using the people type will only be exposed to the public API of the people type and have no knowledge of the internal data structures being used. In general, the new type pattern is a lightweight way to achieve encapsulation. In addition to the newline pattern, rust allows you to create type aliases to give existing types new names. For example, here we create the type alias kilometers for assigned 32 bit integer. Note that kilometers is not a new type.
00:02:36.430 - 00:03:23.596, Speaker A: It's a synonym for a signed 32 bit integers, so it will be treated just like assigned 32 bit integer for example, here we declare x, which is going to be of type signed 32 bit integer, and then we declare y, which is going to be of type kilometers. Then we can add x and y because they're both technically the same type. The main use case of type aliases is to reduce repetition. For example, imagine we have a lengthy type like we do here, used in many different places. Instead of writing this type out over and over again, we can create a type alias. Then we can replace all the long instances of our type with the type alias. Now, this code is much easier to read and write.
00:03:23.596 - 00:03:56.104, Speaker A: Type aliases could convey meaning as well. For example, thunk is a word for code that will be evaluated at some later point in time. This is an appropriate name for closure that gets stored next, let's talk about the never type. The never type is a special type denoted with an exclamation point, and in this case it'll mean that this function will never return. Let's talk about why the never type is useful. Recall that in chapter two we built a guessing game, and we had some code which parsed user input into an integer. The code looks something like this inside our game loop.
00:03:56.104 - 00:04:29.988, Speaker A: We took in a user input called guess, which was a string, and then we called trim and parse to parse it into an integer. The parse method returns a result type. If the parsing succeeded, we simply return the integer. However, if the parsing failed, we call continue to skip this current iteration. As you might have noticed, the type of guess is an unsigned 32 bit integer. So how is one arm allowed to return an unsigned 32 bit integer while the other arm ends with continue? As you might have guessed, continue has a never type. Rust will look at both arms of this match expression.
00:04:29.988 - 00:05:11.854, Speaker A: The first arm returns a 32 bit integer, and the second arm returns another type, so it can never return. Thus, Rust concludes that the return type of this expression is an unsigned 32 bit integer. We're allowed to write this code because if we get into the error arm, continue will not return anything. Instead, it will move control back to the top of the loop, meaning that guests will never be assigned. So the only type guests will be assigned is an unsigned 32 bit integer. If we execute the ok arm, the never type is useful with the panic macro as well. For example, the option enum has a method called unwrapd, which will evaluate self, and if self is a sometype, it will return the value stored in self.
00:05:11.854 - 00:05:37.162, Speaker A: However, if self is the non type, it'll panic. Panic returns a never type. So if we get into the non arm, we won't be returning from this function. Thus, the return value of this function is t. One final expression that has the never type is a loop. Here, the loop never ends, so the value of this expression is the never type. However, this wouldn't be true if we had a break statement inside of the loop, because the break statement will cause the loop to terminate.
00:05:37.162 - 00:06:13.934, Speaker A: Lastly, let's talk about dynamically sized types and the size straight. Dynamically sized types, sometimes called dsds or unsigned types, are types whose size we can only know at runtime. One example of a dynamically sized type is the stir type. Here we have two stir types, s one and s two. Now, because rust can't determine the size of these stir types at compile time, if we try to write this code, we would get a bunch of errors. If I hover over s one, you can see that the error states the size of the values of type stir cannot be known at compile time. All local variables must have a statically known size.
00:06:13.934 - 00:06:57.492, Speaker A: So how do we fix these errors? Well, in this case, we already know what to do. Instead of using stir directly, we'll use the borrowed version of stir. This string slice structure will store two values, an address pointing to the location of the string in memory and the length of the string. Both the address value and the length of the string have a type of usage, meaning that we know their size at compile time, which is why this code works. In general, this is the way dynamically sized types are used in rust. They have an extra bit of metadata which stores the size of the dynamic information. The golden rule for dynamically sized types is that we must always put them behind some sort of point.
00:06:57.492 - 00:07:38.500, Speaker A: Here, the stir type is behind a reference, but we can also put it behind a box smart pointer or an RC. Smart pointer traits are also dynamically sized types. Recall that in chapter 17 when we talked about trait objects, we mentioned that trait objects have to be behind some sort of pointer. Rust has a special trait called the size trait to determine whether a type size can be known at compile time or not. The size tray is automatically implemented for every type whose size is known at compile time. Also, rust implicitly adds the size straight bound to every generic function. For example, we have a function here which takes a generic, and rust will automatically add the size straight bound like so.
00:07:38.500 - 00:08:04.852, Speaker A: So by default, generic functions will only work on types whose size is known at compile time. However, you can use the special syntax to relax this restriction. Here we're saying t may be sized or not. Note that this special syntax is only available for the size straight. Also, because t can potentially be unsized, we have to put our arguments type behind some sort of pointer. In this case, we've chosen a reference. That's it for this video.
00:08:04.852 - 00:08:26.510, Speaker A: If you enjoyed it, then lean up against that like button. And if you want to see weekly rust content, then hit subscribe and hit that notification bell. Lastly, and most importantly, I have a free rust cheat sheet which I want you to have. So if you want access to that, head over to let's get rusty.com cheatsheet. And with that said, I'll see you in the next one.
