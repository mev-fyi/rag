00:00:00.520 - 00:00:50.312, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the rust programming language, so if you want to see weekly rust videos, make sure to hit subscribe. Also, I'm going to be releasing a rust cheat sheet very soon, so if you want access to that, make sure to click the link in the description. In the last video, we started chapter 16 of the wrestling book titled Fearless Concurrency, and we learned about creating threads. In this video, we're going to learn about using messages to pass data between threads. So with that, let's get rusty. One increasingly popular approach to ensuring safe concurrency is message passing, where you have threads or actors passing messages to each other which contain data.
00:00:50.312 - 00:01:38.714, Speaker A: The Go programming language has a slogan that summarizes this approach. Do not communicate by sharing memory, instead, share memory by communicating. One tool rust provides to enable message passing concurrency is something called a channel, and it's included in the standard library. Channels are analogous to a channel of water, like a river or a stream. If you put something like a rubber duck or a boat on the stream, it will travel downstream to the end of the waterway. A channel in programming has two halves, the transmitter and the receiver. Going back to the river analogy, the transmitter is the upstream location where you would place the rubber duck, and the receiver is the downstream location where the rubber duck will end up.
00:01:38.714 - 00:02:25.206, Speaker A: One part of your code calls methods on the transmitter passing in the data you want to send, and another part of your code is listening to the receiver for arriving messages. The channel is said to be closed if either the transmitter or the receiver half is dropped. Once you're familiar with channels, you can implement things such as a chat system or a program in which many threads perform part of a calculation and one thread aggregates the results. All right, enough talking. Let's see how channels are created in code. The first thing we'll do is bring the MPSC module from the standard library into scope. MPSC stands for multi producer, single consumer.
00:02:25.206 - 00:03:10.128, Speaker A: In Rust, the way channels are implemented, you can have multiple producers of messages, but only one receiver of messages. To create a channel, we'll call the channel function on our MPSC module. Channel is going to return a tuple, which contains the sender and receiver. So let's extract both of those out into a variable. Here, I'm destructing the contents of the tuple into two variables, Tx for the sender and Rx for the receiver. Tx and Rx are traditionally used in many fields for transmitter and receiver, respectively. Next, we're going to spawn a thread and use our sender to send a message.
00:03:10.128 - 00:04:04.182, Speaker A: First, we'll need to bring the thread module from the standard library into scope. Next, we're going to call the spawn function to spawn a thread. Then we'll create a new variable for the message we want to send. Lastly, we'll call Tx send passing in our message, and then unwrap. Notice that in order to use our sender to send a message, we need to move TX into the closure. If we remove the move keyword, you'll see we get an error which states that it's not safe to share the sender between threads. Notice that we also call unwrap after send, and that's because the send method returns a result type.
00:04:04.182 - 00:04:52.970, Speaker A: If the receiving end has been dropped for some reason, when we try to send a message, then send will return an error in this case, we call unwrapped to panic in that case. But if this was an actual production application, you'd want to handle this case more gracefully. Next, let's use our receiver in the main thread to receive a message. We'll create a new variable called received, and that's going to be equal to rxdev dot receive, in this case recv for short unwrap. Then we'll just print the message we got. Our receiver has two useful methods, receive and try receive. The receive method will block the main thread's execution while it waits for a message or a value to be sent down the channel.
00:04:52.970 - 00:05:24.114, Speaker A: The receive method returns a result type. If we have a value, then we'll get the value. However, if the channel closes, then we'll get an error indicating that no more values are coming. The try receive method, however, will not block the main thread's execution. Instead, it will return a result type immediately. The result type will be an okay variant holding the value if a value is available, or it'll be an error if no values are available at the time. Try receive is useful when you want your thread to do other work.
00:05:24.114 - 00:06:02.448, Speaker A: For example, we can have a loop where every so often we call try receive to see if there are any new messages, but otherwise we let the thread do other work. For this example, we're using the receive method for simplicity, because the main thread isn't doing any other work. By the way, when we're calling the send method in our simple program, we're passing in a string, but we don't have to pass in a string. We can pass in any type we'd like. All right, let's go ahead and run our program, and as you can see, our main thread got the message hi. Next, let's talk about ownership rules and how they relate to concurrent code. Ownership rules help us prevent errors in our concurrent code.
00:06:02.448 - 00:06:54.210, Speaker A: As an example, let's see what would happen if we tried to use our message variable after we've already sent it down the channel. If we were allowed to do this, it would be problematic because we would send a message to another thread, and then afterwards we could potentially modify or drop the variable. Luckily for us, we get a compile time error, and if I hover over, you'll see the error states we cannot borrow a moved value. This is because when we call, send and pass in our value, send takes ownership of the value. So, as you can see in this example, the ownership rules prevent us from doing something dangerous, which is modifying or dropping a value after it has been passed to another thread. Next, we'll modify this code to pass multiple messages to prove that our code is running concurrently. Instead of having a single message, let's create a vector of values.
00:06:54.210 - 00:07:46.520, Speaker A: Then, instead of sending a single message or value, we'll loop through our vector and send each message. We'll also let the thread sleep for 1 second after each call to send. Lastly, instead of calling receive on our receiver once, we'll use a for loop to get all the messages passed down the channel and print them out. Notice here that we're not calling the receive method anymore. Instead, we're treating Rx as an iterator. Every iteration will have a value that we pass down the channel, and when the channel closes, iteration will end. Let's go ahead and run our program again, and this time you can see we're getting messages from the spawn thread with a 1 second delay.
00:07:46.520 - 00:08:25.020, Speaker A: The last thing we'll talk about is creating multiple producers to send messages. Currently we have one thread that sends messages. However, let's say we want to have two threads that send messages. So let's go ahead and copy and paste this code for the second spawn thread. Well, also change the values. Notice here that we get a compile time error which states that we cannot use the TX variable because it has already been moved into the first spawn thread. To fix this, let's scroll back up to the top and create a new variable called TXT two, and that will be equal to TX clone.
00:08:25.020 - 00:09:05.438, Speaker A: This will give us a new sending handle which we can use in our second spawn thread. Now we have two threads that are passing messages down the channel to the main thread. So let's run our program so we can see that the messages from each thread are being sent non deterministically. Note that the output might be different on your machine, and also when you rerun this each time, the output could be different as well. That's it for this video. If you enjoyed it, make sure to hit that like button. And if you want to see weekly rust content, make sure to hit subscribe.
00:09:05.438 - 00:09:14.670, Speaker A: Also, I'm releasing a rust cheat sheet, so if you want access to that, make sure to click the link in the description and with that, I'll see you in the next one.
