00:00:00.560 - 00:00:36.425, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan, and this channel is all about the Rust programming language. In the last video, we covered part one of chapter 11, in which we learned how to write tests. And in this video, we're going to cover part two, in which we'll learn how to run tests in different ways, and also how to organize our tests into integration tests and unit tests. So with that, let's get rusty. Here we have the adder library from the last video. If you haven't already, make sure to check out the last video so you're up to date.
00:00:36.425 - 00:01:07.463, Speaker A: And we have a test module with two tests. One test returns a result type and tests that two plus two equals four. And the second test also tests that two plus two equals four, but it just uses an assert equals statement. Let's go ahead and run our test suite. And we have two passing tests. Cargo Tests compiles your code in test mode and runs the resulting test binary. So far we've just been running cargo tests, but we could specify command line options to change some of the defaults.
00:01:07.463 - 00:01:46.785, Speaker A: For example, by default, all tests get run in parallel in a separate thread. Also, all generated output is captured and not printed to the screen. So, for example, in our test, if we had a print statement, that wouldn't actually get printed out when we do Cargo Test. Now, there are two sets of command line options. One set goes to the cargo test command, and the other set goes to the resulting test binary. These two sets of command line options are separated by two dashes, like so. So, for example, if we want to figure out which options we could pass to the cargo test command, we would type in Cargo test dash dash help.
00:01:46.785 - 00:02:28.473, Speaker A: And if we want to figure out which commands we could pass to the resulting test binary, we would type in cargo test dash dash, and then dash dash help. If we scroll up a little bit, you will see this command line option Test threads. And this option lets you set the number of threads used when running tests in parallel. So remember, by default, every test gets its own thread. But if we wanted to run tests serially, we can set test threads equal to one. So let's do that. We'll type in cargo test dash dash, because we're specifying command line options for the resulting binary.
00:02:28.473 - 00:03:04.243, Speaker A: And then dash dash test dash threads, and we'll set it equal to one. Note that generally you probably don't want to do this because your tests will run slower. But in some cases this might be useful. For example, you might have some tests that modify A file on disk, and it happens to be the same file. Now, if the tests run in parallel, they'll modify the file at the same time, which will cause tests to fail. You can solve this issue by having each test modify a different file or running the test serially instead of in parallel. Next, let's talk about showing output.
00:03:04.243 - 00:03:45.061, Speaker A: In this example, we have a function called prints and returns 10, which takes in an integer, prints the integer, and then simply returns 10. Then in our test suite below, we have one test that will pass because we assert that the value returned from our function is 10. And then we have a test that will fail because we assert that the value returned from Our function is 5. Let's go ahead and run our test suite. And as expected, we have one failing test. Now, here you can see that for our failing test, we see our print statement, I got the value 8. But for our test that succeeded, we don't see the print statement.
00:03:45.061 - 00:04:30.499, Speaker A: This is because by default, standard output is captured for passing tests and we don't see it on the screen. But we could change this with command line options. So let's go ahead and run our test suite again, except this time we're going to give an argument to the resulting binary called show output. So we'll type in cargo test dash, dash, and then dash dash, show, dash output. And this time you can see we get our print statement for the failing case, but on top we also get our print statement for the passing case. Next, let's talk about running a subset of tests using the test name. So in this example we have a function called add to, which takes an integer and returns that integer plus 2.
00:04:30.499 - 00:05:01.313, Speaker A: Then we have our test module and a few tests. First, we test that if we pass in two, we get four. Then we test that if we pass in three, we get five. And then we have a test called 100, which tests that if we pass in 100, we get back 102. Now let's go ahead and run our test suite. And you can see all our tests are passing. Now, let's say we only want to run one test, specifically the test called 100.
00:05:01.313 - 00:05:34.155, Speaker A: We can do this by typing in cargo test and then 100. We can also run a subset of tests by specifying part of the name. If we go up here, you can see that the first two tests start with add. So let's type in cargo test add. And you can see this time only these two functions or run. Now, notice that the module name is in the test name. So here we have tests, which is Our module name, colon, colon, and then the test name.
00:05:34.155 - 00:05:59.961, Speaker A: So we could also run tests based on the module. Let's go ahead and do that. And then here we'll specify tests, colon, colon. And now you can see all three tests were run. Lastly, for this section, let's talk about ignoring tests. So in this example we have one test called It Works, which asserts that two plus two equals four. And then we have this test called expensive test.
00:05:59.961 - 00:06:32.389, Speaker A: Now you can imagine that this is some tests which takes up a lot of time, a lot of resources. In this case, the comment says this could take up to an hour to run. So we want to ignore this case in normal situations and only run it occasionally. Above the function name you can see we have this attribute called ignore, which will, well, ignore the test. So let's go ahead and run our test suite. And you can see we have one test that passed and one test that was ignored. Now let's say you do want to run the expensive test.
00:06:32.389 - 00:07:04.015, Speaker A: In that case you can type in cargo test dash dash, space dash dash, ignored. Now this will run only the ignore test, so it'll run expensive test. And in this case it passed. And you can see we have one filtered out test. Next, let's talk about test organization. The Rust community thinks about tests in two main categories, unit tests and integration tests. Unit tests are small, focused, test one module in isolation and could test private interfaces.
00:07:04.015 - 00:07:42.587, Speaker A: Integration tests are completely external to your library and thus test the public interface of your library. Now, up until this point we've been writing unit tests, and in Rust, unit tests live in the same file as our product code. So let's take a look at this example. We have a function called add to, which calls this inner function that's private, called inner adder. And inner adder actually does the work of adding two numbers together. Then we have our test module. Now, it's convention that in the same file as your product code, you have a module called tests which hold your test.
00:07:42.587 - 00:08:20.939, Speaker A: And then you can see that the module has this attribute here. CFG stands for configuration. And here we say the configuration is test, which means that cargo will only compile this code. When we run cargo test inside our module, we import everything from the parent module. And then we have our test function, which calls the internal adder function. Now, internal adder is private, but we're able to call it inside our test module because of the relationship between parent and child modules. In Rust, child modules are able to access anything in their parent module, even private fields.
00:08:20.939 - 00:08:58.531, Speaker A: Some people in the testing community say you shouldn't test private functions, and in Rust you don't have to, but it is available to you. Also, you might be thinking it's kind of weird to have your test code in the exact same file as your product code. Can I just have my test code in a different file? The short answer is there is a way to put your tests in a separate file and even in a separate folder. But Rust doesn't make this super easy, and putting your tests inside the same file as your product code is the convention. So I would stick with that as much as you can. Now, let's talk about integration tests. Integration tests live in a folder called Tests at the root of your project.
00:08:58.531 - 00:09:34.907, Speaker A: So if I open up my project structure, you you could see at the root we have source, and then we have this tests folder. And inside I've created a file called Integration test. Cargo knows to look for integration tests inside the test directory at the root of our project. And Cargo will turn each of these files in the test directory into a crate. Notice that at the top of our integration test file, we have to bring our adder library into scope. And that's because again, every file in the test directory is going to be a new crate. Then we simply write our test function.
00:09:34.907 - 00:10:05.261, Speaker A: Notice that it's annotated with test. But this time we don't have a module with the config annotation because Cargo knows that all the files in the test directory are tests inside our test. We assert that calling add to and passing a 2 will equal 4. And notice that we have to call the public API. We can't call the inner adder function. Now let's go ahead and run our tests this time. Notice we have three sections.
00:10:05.261 - 00:10:51.521, Speaker A: The first section is for our unit tests, which we currently only have one and it's passing. The second section is for our integration tests, and we only have one, and it's also passing. And then the third section is for our document tests, and currently we have zero of those. If we wanted to run just our integration tests, we can type in cargo test dash dash test and then integration underscore test, because every file in the test directory is treated as a separate crate. This could lead to unexpected behavior. For example, let's say you have multiple integration test files and you want to share some code between those files. You might do something like I did here, which is create a new file called common.rs,
00:10:51.521 - 00:11:25.801, Speaker A: which has the shared code, in this case a public function called setup. Let's go ahead and run our test suite this time. Notice that we have four sections. The first section is for unit tests, and the next two sections are for our integration tests. We get one section for each integration test file. So the first one is for common rs, which has zero tests, and the second one is for our integration test file. So Cargo is treating our common RS file as an integration test file.
00:11:25.801 - 00:12:10.057, Speaker A: But this is not what we actually want it to do. To get the behavior we desire, Instead of creating a common RS file, let's create a new folder inside our test directory and we'll call this folder common. Then inside our folder, we're going to create a file called mods rs. Then we'll take the code in our common RS file, copy it, and paste it into mods rs. Finally, we'll delete common rs. Now let's run our test suite again, and you can see that this time we only get three sections. This is because files and subdirectories of the test folder do not get compiled as crates.
00:12:10.057 - 00:13:02.847, Speaker A: Also, because we put our code into a file called mods rs, our code is now in a module that could be used by our other integration test files. Let's go back to our integration test file, and here we want to use our new module. So what we'll do is we'll type in mod common semicolon and Looks like I get an error here. It's unable to resolve the module, and that's because I named our file mods rs and it should be mod.rs here. And now the error is resolved. This is a module declaration, and it will look for the contents of the module in either a file called common rs or a folder called common with a file called mod.rs.
00:13:02.847 - 00:13:30.269, Speaker A: then we can call the function defined in our module like so. One thing to know here is we have a lib.rs file right here in our source directory, which means we have a library crate. If we had a main.rs file, we would have a binary crate. And we can't directly test binary crates with integration tests. This is why it's common to see a binary crate that's a thin wrapper around a library crate.
00:13:30.269 - 00:13:58.895, Speaker A: So that way you can test the library crate with integration tests. That completes chapter 11. We learn how to write tests, how to run tests in different ways, using command line arguments, and how to organize unit tests and integration tests. If you enjoyed this video, make sure to hit the like button. And if you want to see new Rust videos every single week, make sure to subscribe with that. I'll see you in the next one SA.
