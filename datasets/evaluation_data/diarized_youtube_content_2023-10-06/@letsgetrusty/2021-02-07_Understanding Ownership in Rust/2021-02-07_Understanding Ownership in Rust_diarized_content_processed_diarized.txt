00:00:00.360 - 00:00:27.671, Speaker A: Welcome back to let's Get Rusty. My name is Bogdan and this channel is all about the Rust programming language. If that sounds interesting to you, hover over that subscribe button and give it a fist bump. Last time we went over chapter three of the Rustling book, in which we covered basic programming concepts in the context of Rust. If you haven't already, check that video out. In this video, we're going to be talking about chapter four. And this is a very special video because chapter four covers Rust's most unique feature, ownership.
00:00:27.671 - 00:01:06.913, Speaker A: Ownership is what allows Rust to make memory safety guarantees without the use of a garbage collector. We'll also cover references borrowing the Slice type and how Rust lays out data in memory. So with that, let's get started. First, we'll answer the basic question, what is ownership or the ownership model In Rust, the ownership model is a way to manage memory. Now you might ask why do we need a way to manage memory? And to understand, it's helpful to look at the two other solutions for managing memory today. First, we have Garbage Collection. If you've ever written an app using a higher level programming language such as Java or C Sharp, you didn't have to worry about memory management because the garbage collector did it for you.
00:01:06.913 - 00:01:34.237, Speaker A: Now, this approach has some pros and cons. The first pro is that it's error free, meaning that if you were to manage memory yourself, you might introduce memory bugs. But since that's being handled by the Garbage collector, you can be pretty sure that there aren't any memory issues. I put an asterisk because garbage collectors could have bugs themselves. But for the most part you can be be rest assured that your memory is being managed safely. The second pro is faster write time. Because you don't have to deal with memory, you can write your programs faster.
00:01:34.237 - 00:02:05.857, Speaker A: Now let's look at the cons. Firstly, we're giving up fine grained control of our memory. That's because the Garbage collector now handles all our memory. Secondly, our runtime performance can be slower and more unpredictable. Slower because we can't manually optimize our memory and unpredictable because the garbage collector could choose to clean up memory at any point in time and when it does so, it slows down our program. Lastly, we have a larger program size because the Garbage Collector is a piece of code that we have to include within our program. Now let's look at manual memory management.
00:02:05.857 - 00:02:41.797, Speaker A: If you've written C or C, you have to allocate and deallocate memory manually. Now the pros of this is full control over your Memory, which leads to a faster runtime because you can optimize things, and a smaller program size because you don't have to include a garbage collector. The cons are first, it's extremely error prone. Many, many bugs and security issues are caused by incorrect memory management. And second, you have a slower write time because you have to think about memory. It takes longer to write your program. Notice here that the pros and cons of garbage collection and the pros and cons of manual memory management are the exact opposite.
00:02:41.797 - 00:03:18.363, Speaker A: We're making opposite trade offs here. Either of these solutions could be appropriate depending on the context. If you're writing a high level app like a website, it makes sense to sacrifice runtime performance and have a larger program size for the ease of use and faster write time you get with a garbage collector. On the other hand, if you're writing low level system components, then you probably care a lot more about runtime performance and program size. So it'd make more sense to use manual memory management. Now we could talk about the ownership model, which is a third way to manage memory. Now Rust is a systems programming language, so it does care about runtime performance and program size.
00:03:18.363 - 00:03:56.151, Speaker A: And as you can see here, we get all the benefits of manual memory management, control over our memory, faster runtime and smaller program size. Rust, however, is also a memory safe language, so we can't use manual memory management because as we said before, it's error prone. And as you can see here, the ownership model is error free. And the way Rust achieves this is by doing a bunch of compile time checks to make sure you're using memory in a safe way. Now I put an asterisk here because even though Rust is memory safe by default, it does allow you to opt out of memory safety with the unsafe keyword. But that's meant to be used sparingly. As you might know, everything in software is a trade off.
00:03:56.151 - 00:04:45.165, Speaker A: So the ownership model gives us memory safety, but the con is we get a slower write time, slower than man manual memory management. And that's because Rust has a strict set of rules around memory management and if you break those rules, you'll get compile time errors you have to deal with. This is sometimes known as fighting with a borrow checker and it could be frustrating, but as anything with time you'll get better and things will become easier. The big idea here is that this trade off is worth it. It's worth spending the time upfront dealing with the borrow checker so you don't have to spend hours and hours later Debugging runtime Memory issues now because Rust is a systems programming language, it's important for us to know how our memory is laid out during runtime. Rust makes certain decisions based on if our memory is stored on the stack or on the heap. So next we'll briefly go over what the stack and heap are during runtime.
00:04:45.165 - 00:05:21.103, Speaker A: Our program has access to both the stack and the heap. The stack is fixed size and cannot grow or shrink during runtime. The stack also stores stack frames, which are created for every function that executes, and the stack frame stores the local variables of the function being executed. The size of a stack frame is calculated at compile time, so that means the variables inside a stack frame must have a known fixed size. Variables inside of a stack frame also only live as long as the stack frame lives. So for example, in this program, A gets executed first, so we push A onto the stack. Then A executes B.
00:05:21.103 - 00:05:46.991, Speaker A: So we push a stack frame for B onto the stack. Now when B finishes executing, it gets popped off the stack and all of its variables are dropped. Then when A gets done executing, all its local variables are dropped. The heap, on the other hand, is less organized. It could grow or shrink at runtime, and the data stored in the heap could be dynamic in size. It could be large amounts of data, and we control the lifetime of the data. Let's go back to our example.
00:05:46.991 - 00:06:09.477, Speaker A: First we execute the function A which creates a new stack frame. A initializes the variables X and Y. X is a string literal which is actually stored in our binary. So in the stack frame, X here will be a reference to that string. In our binary, Y is a signed 32 bit integer which is a fixed size. So we can store Y directly in the stack frame. Then we execute the function B.
00:06:09.477 - 00:06:45.105, Speaker A: So another stack frame is created and B creates its own variable named x. X is of type string, which could be dynamic in size, so we can't store it directly on the stack. Instead, we ask the heap to allocate memory for the string, which it does, and then the heap passes back a pointer. The pointer is what we actually store on the stack. Note that pushing to the stack is faster than allocating on the heap because the heap has spend time looking for a place to store the new data. Also note that accessing data on the stack is faster than accessing data on the heap, because with the heap you have to follow the pointer. I know that was a very brief explanation.
00:06:45.105 - 00:07:27.501, Speaker A: So if you're still confused or want a more thorough explanation, I put a link in the description of a video that goes into a lot more detail on the stack and heap, so make sure to check that out. All right, let's get back to ownership. And before we go any further, there are three ownership rules that are crucial to remember. Write these down, put them in a word doc, get them tattooed, whatever it takes. The the rules are one each value in Rust has a variable that's called its owner. So one variable, one owner, two There can only be one owner at a time, so variable cannot have two owners at the same time, and three when the owner goes out of scope, the value is dropped. As an example, I created a new scope here using the curly brackets and inside I defined the variable s.
00:07:27.501 - 00:08:07.169, Speaker A: Here S is not valid because it is not declared yet. Then we declare s and it is valid. From this point forward we could do things with S. Then when the scope ends, S is invalidated and Rust drops the value S here is a string literal, and as I've mentioned before, string literals are stored directly in the binary and are fixed in size. So what if we wanted a string that's dynamic in size and that we could mutate? Well, we would have to use the string type. I went ahead and converted S to a string type and now our string is stored on the heap. In programming languages such as C, to allocate memory on the heap, you would have to use the new keyword, and then you would have to deallocate that memory using the delete keyword when you're done with it.
00:08:07.169 - 00:08:37.869, Speaker A: In Rust, this happens automatically when we declare s. Here Rust automatically allocates memory on the heap for our string, and then when the scope ends, S is invalidated and Rust drops our value, meaning that it deallocates the memory on the heap automatically. Next, let's talk about how variables and data interact. Here we have two variables, X and Y. X is set to 5 and Y is set to x. And as you can tell by the comment, this is going to do what you might expect, which is copy the value 5 into Y. Let's look at a more interesting example.
00:08:37.869 - 00:09:12.793, Speaker A: Here we have the variable S1 and we set that equal to a string type. On the right hand side you can see what S1 looks like. Under the hood we have a pointer that's pointing to the actual memory location on the heap. We have a length which is the length of the string, and we have capacity, which is the actual amount of memory allocated on the heap for our string. On the next line we declare S2 and set that equal to S1. So what would we expect to happen in this situation? Some might expect the value to be cloned. Like we see on the right hand side, S1 is pointing to a string on the heap, and S2 is another pointer pointing to a new string on the heap.
00:09:12.793 - 00:09:42.865, Speaker A: But this is not what happens. As it would be very expensive to create a new string on the heap, others might think that we do a shallow copy. So S1 has a pointer that points to hello on the heap, and S2 has a pointer that points to the same hello on the heap. This is not quite what happens, because to ensure memory safety, Rust invalidates S1. So instead of being a shallow copy, this is called a move. Going back to our program, let's try to print S1 after it's been moved into S2. We'll call it cargo run.
00:09:42.865 - 00:10:17.369, Speaker A: And as you could see, we got a compile time error which says S1 was moved here. And then we tried to use S1 after it has. What if we did actually want to clone the string instead of moving S1? Well, rust has a common method for that. So Instead of setting S2 equal to S1, we'll set S2 equal to S1 and we'll call the clone method on on it. And now we can run our program and it compiles successfully. So Rust defaults to moving a value. And if you want to perform the more expensive clone operation, there's a method for that.
00:10:17.369 - 00:10:44.719, Speaker A: There's one other detail here up above, when we set y equal to x, this did a copy, not a move. Rust has a copy trait as simple types stored on the stack, such as integers, booleans and characters. Implement. This trait allows those types to be copied instead of moved. Next, let's talk about ownership and functions. Here we have a variable called S, that's a string and a function called takes ownership. The takes ownership function takes in some string as a parameter and then prints it out.
00:10:44.719 - 00:11:19.729, Speaker A: In main, we try to print the variable S after we call takesonership, but we get an error and the error states that S cannot be borrowed after a move. And that's because when we pass in parameters into a function, it's the same as if we were to assign S to another variable. So here passing in S moves S into the sumstring variable. Then some string gets printed out and after this scope is done, some string gets dropped. Let's look at another example. We have the variable X here, that is an integer and a function called makes copy. Makes copy takes in an integer and then prints it out.
00:11:19.729 - 00:11:49.539, Speaker A: Here you can see we pass an X, but instead of being moved, remember integers are copied, so it gets copied into the sum integer variable printed out. But we can still use x after the function call. This also works the opposite way. Here we have a variable S1 that's equal to the return value of gives ownership. Gives ownership is a function that returns a string. And here you can see we create a string that's called some string, and then we return that string. Returning the string moves the ownership of the string to the S1 variable, and then we can use it afterwards.
00:11:49.539 - 00:12:27.407, Speaker A: Lastly, we could take ownership and give it back. For example, here we have a variable called S2, which is a string, and we pass that into a function called takes and gives back. Takes and gives back takes in an argument that's a string called a string, and then just returns a string. So here we're moving the value of S2 into the function, and then we're just returning a string which moves the value back out of the function into S3. Moving ownership into a function and back out is tedious. What if we just wanted to use a variable without taking ownership? Well, that's where references come in, and that's what we'll talk about next. To understand references, let's see how they could fix the following situation.
00:12:27.407 - 00:12:56.357, Speaker A: Here we have a function called calculate length. What we want to do is take in a string and return the length of that string. However, we don't want to take ownership of the string. The solution here is to return a tuple that contains the string and the length of the string. Up here you could see we assign the string to S2 and the length to a variable called len. You could also see that this looks very strange and probably not something you would ever want to write. To fix this, let's first modify our calculate length function.
00:12:56.357 - 00:13:37.907, Speaker A: First, we'll change the return type to be just the length of the string. Next we'll return just the length. Up above, we'll get rid of S2 and print S1 down here. As expected, we get an error here because we're borrowing S1 after it's been moved into the function. To fix this error, instead of calculate length, taking a string, we'll make it take a reference to a string, and we do that by adding an ampersand before the string. Next, in the main function, instead of passing in a string, we'll pass in a reference to a string by using the ampersand again. Great.
00:13:37.907 - 00:14:15.367, Speaker A: Now we have no errors, and that's because S is a reference to A string and references don't take ownership of the underlying value. Here in the Rust book, you can see a diagram of what a reference looks like. S is the reference, and it points to S1, which actually points to our string in the heap. S is a local variable inside of calculate length, and when the function finishes executing, S is dropped. But that's okay, because if we drop S here, we still have S1 pointing to our string. Passing in references as function parameters is called borrowing, because we're borrowing the value, but we're not actually taking ownership of it. Also note that references are immutable by default.
00:14:15.367 - 00:14:50.015, Speaker A: So if we try to modify S here, you could see that we get an error which says we cannot borrow the value as mutable. Here I have another example. We have a string and a function called change, which takes a reference to that string and then attempts to modify it again. References are immutable by default, so we can't modify the value. But let's say we actually did want to modify the value without taking ownership of it. To do that, first we'll need to make S1 immutable variable. Next, instead of passing in a reference, we're going to pass in a mutable reference.
00:14:50.015 - 00:15:32.459, Speaker A: Finally, we'll have the change function take an immutable reference. Now the change function is able to mutate our string without taking ownership of the underlying value. Mutable references have a big restriction though, which is you can only have one mutable reference to a particular piece of data in a particular scope. For example, we have a string here and a variable called R1, which is immutable reference to the string. Now let's add another mutable reference and print out both references. Here we have R2, which is another mutable reference to string, and then a print statement that prints out both R1 and R2, and you can see we get an error here. The error states you cannot borrow S as mutable more than once at a time.
00:15:32.459 - 00:16:21.347, Speaker A: The big benefit of this restriction is that Rust can prevent data races at compile time. A data race occurs if we have two pointers pointing to the same piece of data, and one of those pointers is used to write to the data, and there's no mechanism to synchronize data access between those pointers. In that situation, you could imagine that one pointer will try to read the data in the middle of the other pointer, modifying the data, and in that case we'll get corrupt data back. To fix this error, we can switch these references back to be immutable references. And now we don't have any errors. But what happens if we mix immutable references with mutable references? Let's go ahead and add another variable. We'll also go ahead and make smutable, but as you can see, we still get an error here.
00:16:21.347 - 00:16:57.741, Speaker A: We're running into another restriction. You can't have a mutable reference if an immutable reference already exists. Immutable references don't expect the underlying value to change, and this is problematic if we do have a mutable reference. You can, however, have multiple immutable references. It's okay to have multiple immutable references because the underlying data is not going to change. Note that the scope of a reference starts when it's first introduced and ends when it's used for the last time. So, for example, R1 is introduced here, so the scope starts here, and it's used for the last time in this print line statement.
00:16:57.741 - 00:17:37.581, Speaker A: So the scope ends here. This means that we can add a third mutable reference underneath this print line statement and we'll make S mutable. And this works just fine, because at this point R1 and R2 are out of scope, so we can declare immutable reference. Next, let's talk about dangling references. What happens if we have a reference that points to invalid data? Well, here we can see we have a variable called reference to nothing, and it's set to the return value of dangle. Dangle is a function that returns a reference to a string. Inside of dangle, we can see we have a variable called S which is set to a string, and then we return a reference to that string.
00:17:37.581 - 00:18:08.043, Speaker A: However, S is defined within the scope of this function. So when this function finishes executing, Rust will drop our string or deallocate our string from the heap. Therefore, our reference will be pointing to invalid memory. But as you could see, Rust prevents this from happening because we get an error here. If we hover over, we see that the error states this functions return type contains a borrowed value, but there is no value for it to be borrowed from. We don't have a value for it to be borrowed from because the value gets dropped. We also get a recommendation to use something called a lifetime.
00:18:08.043 - 00:18:33.913, Speaker A: Lifetimes is something we'll talk about in chapter 10, but for now we can ignore it. The point here is that again, Rust prevents us from doing something that's memory unsafe to wrap up references. Let's review the rules of references. Number one. At any given time for a particular piece of data in a particular scope, you can either have one mutable reference or any number of Immutable references. And number two, those references must be valid. The data they point to must be valid.
00:18:33.913 - 00:19:11.353, Speaker A: The last thing we're going to talk about are slices. Slices let you reference a contiguous sequence of elements within a collection instead of referencing the entire collection. And just like the references we covered in the last section, slices do not take ownership of the underlying data. To understand why slices are useful, let's start with a problem. Imagine we have a function we want to write called first word. Takes in a reference to a string because we don't want to take ownership of that string, and then it returns the first word in that string. Looking at the function signature, what would our return type be? We don't have a way to return part of the string, but maybe we can return an index to the end of the first word.
00:19:11.353 - 00:19:37.789, Speaker A: That implementation will look something like this. Here we're returning an index to the end of the word and inside our function. What we do is we take the string and convert it into an array of bytes. Then we use a foreign loop. Here we take the bytes, call the iterator function, and then call enumerate so we can get the index of each item and the item itself. Then for every item, we check if it equals an empty space which signifies the end of a word. And if that's true, then we return that index.
00:19:37.789 - 00:20:01.717, Speaker A: If we go through this entire loop and don't find an empty space, then that means that the entire string is one word. So we can return the length of the string. There are two problems with this implementation. The first is that the return value is not tied to the string. And here's what I mean. In main, we have a string under the variable S. We pass that string to first word and we store the return value in a variable called word.
00:20:01.717 - 00:20:34.139, Speaker A: In this case, our return value is 5 because our first word is hello, h is at index 0. Then we have e at index 1 ll at index 2, and 3 o at index 4. And the space is at index 5. Now the problem is on line 4, we call the clear method on our string, which makes it an empty string. So now our variable word is still 5, even though the string is empty. And again, this is because our return value is not tied to the string itself. This means we have to manually keep our return value in sync with the string, which is extremely error prone.
00:20:34.139 - 00:21:01.157, Speaker A: Second problem comes when we want to change the implementation. Imagine, instead of the first word, we wanted to return the second word. In that case, we would have to return a tuple with two values, an index to the start of the word and an index to the end of the word. And now we have more values that we need to keep in sync with the string. To get around these issues, let's introduce the string slice here. Underneath our string, we'll declare two string slices. Here we've defined two string slices.
00:21:01.157 - 00:21:31.457, Speaker A: Hello, and world. They look very similar to string references, except we have this bracket syntax here with a range inside. This is saying give us a reference to the string, but we only want part of the string. Specifically, we want the part of the string starting from index 0 and ending at index 4. The 5 is exclusive here, and that will give us the word hello. On the second line we're doing something similar, but from index 6 to 11, which will give us world. The Rust book has a nice diagram to show us what's going on.
00:21:31.457 - 00:22:11.543, Speaker A: Here we have S, which is our string, and you can see it has a pointer pointing to the string on the heap. And then world is our string slice. That's a reference pointing to the same string on the heap, but starting at index 6, we can simplify these string slices a bit further. If we're starting from the beginning of the string, we can omit the zero here here. And if our range continues to the end of the string, we can omit 11 here as well. Lastly, if we want a string slice to span the entirety of the string, we can omit the first and second value here. In this case, world is a string slice that will reference the entire string.
00:22:11.543 - 00:22:52.785, Speaker A: Now that we know about string slices, let's modify our first word function to take advantage of them. The first thing we'll do is change the return type from the index to a string slice. Next, if the first word is found, instead of returning the index, we'll return a string slice. Here we're returning a string slice from the beginning of the word to the index where the space was found. Lastly, at the end here, instead of returning the length of the string, we'll return a string slice to the entire string. Now, our word variable is a string slice which is tied to the string itself. And to prove that, let's try printing out word after we click the string.
00:22:52.785 - 00:23:29.901, Speaker A: And here we can see we get an error. Cannot borrow S as mutable because it is already borrowed as immutable word is a string slice, which is an immutable reference to string. And here we call clear which mutates the string. That means we need a mutable reference. And if you recall, we cannot mix mutable and immutable references in the same scope let's get rid of the code that's erroring and we'll create a new variable called S2 and we'll set it to a string literal. Hello, world. As you can see, string literals are actually string slices.
00:23:29.901 - 00:23:57.793, Speaker A: As I mentioned before, string literals are stored directly in the binary. But S2 here is actually a string slice to that location in the binary. Now let's say we wanted our first word function to also work with string literals. In that case it would have to take in a string slice. So let's change that that. Notice that our call to first word here kept working. This is because our string reference gets automatically coerced to a string slice.
00:23:57.793 - 00:24:35.851, Speaker A: And now we can pass an S2 and our function still continues to work. And notice here that strings have the type of string with a capital S, and string slices have their type written as ampersand lowercase str. We can also have slices on different types of collections. For example, we have an array here. Let's say we want to create a slice on this array. So we'll create a new variable called slice, and we'll set that equal to a portion of the A array. Here you could see we use a similar syntax.
00:24:35.851 - 00:25:06.251, Speaker A: We have the ampersand A for the A array and then brackets. And here we do a range from 0 to 2. So our slice here references the first two values in the A array. And you can see here, instead of the type being ampersand str, it's ampersand curly brackets i32 because the array stores a list of signed 32 bit integers. And there you have it. Chapter four of the Rustling Book Complete. We learned about ownership, memory management, references, borrowing the slice type, and much more.
00:25:06.251 - 00:25:19.515, Speaker A: If you like this video, make sure to give it a thumbs up. And if you want to see more Rust content, make sure to hit subscribe and the notification bell so you can be notified when the next video comes out. I'll see you in the next one.
