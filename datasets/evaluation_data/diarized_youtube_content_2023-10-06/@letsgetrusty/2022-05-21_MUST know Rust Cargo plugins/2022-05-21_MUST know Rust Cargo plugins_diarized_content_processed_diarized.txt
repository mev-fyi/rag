00:00:00.600 - 00:01:01.530, Speaker A: Cargo watch monitors your project source files and runs cargo commands when your source files change. For example, we could type cargo Watch X run to execute cargo run whenever our source files change. If we comment to outline 43, our code will be recompiled. Cargo watch also provides a lot of other options. For example, we could type cargo watch c to clear the terminal, q to suppress the output of cargo watch itself, and w to only focus on the source directory. Cargo edit allows you to add, upgrade and remove dependencies from the command line. For example, we can add the rand dependency to this project by typing in cargo add rand version 0.7.
00:01:01.530 - 00:01:36.460, Speaker A: This will automatically update the cargo toml file. With our new dependency, we can upgrade the dependency by typing in cargo upgrade rand. In this case it was upgraded to version zero 8.5, which is the latest version. And finally we can remove the dependency by typing in cargo rm rand. The cargo modules plugin allows us to visualize a crates module structure. To see the module structure in a tree like format, we could type in cargo modules generate tree.
00:01:36.460 - 00:02:21.082, Speaker A: Here we can see the default crate module, two top level modules, models and utils, and a module inside utils called message helpers. We can also see the visibility of each module. For example, message helpers is public also by adding the with types flag, we can also see the types inside each module. Here we can see some top level functions, a struct inside the models module, and so on. Cargo audit checks if your project's dependencies have any security vulnerabilities, which is especially useful. Continuous integration to audit your project, simply type cargo audit. In this case, zero vulnerabilities were found.
00:02:21.082 - 00:03:02.914, Speaker A: However, we did get one warning, because we're using a crate that is unmaintained. Cargo tarpaulin is another plugin that's very useful for continuous integration. This plugin calculates code coverage for your project. However, the caveat is it only supports x 64 processors running Linux, so you might not be able to use this plugin on your local machine. If you're running macOS or windows, however, you can still use it with continuous integration, assuming that your continuous integration runs on Linux machines. Cargo next test is a next generation test runner for rust. It offers beautiful test results, flaky test detection, and on some code bases can run tests 60% faster.
00:03:02.914 - 00:03:50.990, Speaker A: To execute tests using next test, write cargo next test run as you can see, the output is organized and has beautiful colors, which helps with readability. Cargo make is a task runner and build tool for rust. It allows you to define a set of tasks and run them in a flow tasks could be defined in TOML files. For example, here we have a toml file called build Toml. It includes several tasks, one to format the code, one one to clean the code, one to build the code, and one to test the code. And finally a build flow is defined which executes the other tasks in a given order. To run our flow, we type cargo makefile, specify build Toml, and then our flow, which is build flow.
00:03:50.990 - 00:04:37.260, Speaker A: The last cargo plugin I want to talk about is cargo release, which is a cargo sub command to help smooth the release process. Some features include ensuring that you're in a good state, meaning you're on the right branch, up to date with remote and have a clean working tree. This plugin also handles tagging and publishing to crates IO and allows you to update files like changelogs and dockerfiles using search and replace. That's it for this video, but before you go, make sure to get your free rust cheat sheet bye by heading over to letsgetrusty.com cheatsheet. Also, if you liked the video, make sure to give it a like and leave a comment down below. With that said, ill see you in the next one.
