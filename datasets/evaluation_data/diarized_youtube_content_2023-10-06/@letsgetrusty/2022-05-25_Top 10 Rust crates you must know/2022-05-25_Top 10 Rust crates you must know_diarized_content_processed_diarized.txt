00:00:00.560 - 00:00:46.611, Speaker A: In this video we're going to discuss some of the most common Rust crates that you should be familiar with. Rust is known to have a small standard library, but lucky for us there are plenty of community crates on Crates IO that we could take advantage of. Some of these crates are very common and will appear over and over again in the projects you work on or contribute to, so it's important to be familiar with them. Two of the most common crates are Serde and SerdeJSON. Serde is a framework for serializing and deserializing Rust data structures and serde. JSON, as the name implies, adds support for the JSON format. If you want to learn how to use SERDE specifically to serialize and deserialize JSON, I made a video all about that topic which I'll link to up above.
00:00:46.611 - 00:01:37.847, Speaker A: The next two very common crates you're likely to run into are anyhow and this error Error handling in Rust could be tedious and complicated. These two crates are designed to make that process easier. The Anyhow crate provides a trait object based error type which can make error handling easy if the caller of your function doesn't care what type of error is being returned. Now, if the caller of your function does care about the error being returned because, say it wants to do different things based on the error type, then you can use the this error crate. This error provides a convenient derived macro which you can use to create an enum of different error types. Let me know down in the comment section below if you'd like to see a video showing how to use these two crates. The next crate I'd like to talk about is called Tokio.
00:01:37.847 - 00:02:22.771, Speaker A: Tokio is an async runtime for Rust. The Rust programming language itself supports the async await concurrency model, where you can mark functions as async and then await them. Marking a function async returns a future which is similar to a promise in JavaScript. Now one major difference between futures and promises is that in JavaScript promises are executed automatically, whereas in Rust, futures are not executed automatically. So in Rust we need an executor or a runtime to execute the futures. Now unfortunately, the Rust standard library does not come with a built in async runtime. Remember, the Rust standard library is very small.
00:02:22.771 - 00:03:32.031, Speaker A: Instead, the Rust team decided that the Rust community should build the async runtimes tailored to particular needs, and so Tokyo was born and now it's the most popular Rust async runtime. So if you're writing asynchronous code in Rust, you need to be familiar with Tokyo. The next crate I want to talk about is the Log Crate, which is actually created and maintained by the Rustling team. Log is a library which provides a single logging API that abstracts over actual logging implementations. It's unlikely that you'll use this crate directly, but you'll likely use crates built on top of it, for example Environment Logger, which is a logging implementation configured via an environment variable, or Pretty Event Logger, which is built on top of Event Logger and provides prettier output. Or the Tracing Crate, which is bundled with Tokio that allows you to collect structured event based diagnostic information for your async programs. And finally, I want to give an honorable mention to a crate which I personally use quite a bit, called Chrono, which is a date and time library for Rust.
00:03:32.031 - 00:03:53.875, Speaker A: Before you leave, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet. Also, if you like this video, make sure to give it a like and comment down below. And lastly, if you want to see videos like this about Rust, then hit that subscribe button. With that said, I'll see you in the next one.
