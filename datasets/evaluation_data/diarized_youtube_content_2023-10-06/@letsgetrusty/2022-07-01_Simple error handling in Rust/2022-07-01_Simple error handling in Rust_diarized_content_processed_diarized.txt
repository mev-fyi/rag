00:00:00.400 - 00:00:41.674, Speaker A: Error handling is one of those topics in Rust that could get really complicated really fast. In some languages, you throw and catch exceptions. In rust, if an operation could fail, it returns a result enum. The result enum could either be an okay variant or an error variant. Now, when you consider creating custom error types, propagating errors, reporting errors both to the user and to the developer, with extra debug information, abstraction layers, and best practices, things get really complicated. Complicated enough for rust to have an error handling project group dedicated to improving error handling in rust. Notably, this group has been working on improving the error trait in the standard library.
00:00:41.674 - 00:01:34.108, Speaker A: Besides that, third party libraries like this error and anyhow have been created to make error handling easier in rust. Despite these crates, air handling in rust can still be complicated, especially to newcomers. That's why the developers at hash, which is a startup focused on building tools to improve decision making, have decided to create their own error handling library called error stack. In a blog post announcing error stack, the developers at hash explain what their error handling approach used to be and why they created error stack. They used to define custom error types as large top level enums at the module or crate level with many different variants. When crossing boundaries, they would transform one error to another using the from trait and they also took advantage of the this error crate to help reduce boilerplate. However, this approach led to error messages that werent very helpful.
00:01:34.108 - 00:02:31.494, Speaker A: As you can see from this example, the error messages had very little context defining custom error types as enums with many variants also introduced overhead that hurt them in periods of rapid development. Because of these pain points and others, they decided to create an error handling library. Now, error handling libraries like this error and anyhow already exist. So what makes error stack different? The developers at hash wanted to create an error handling library with a few key features. First of all, they wanted to encourage users to provide a new error type when crossing module or create boundaries or when changing levels of abstraction. For example, returning a config parse error when parsing a configuration file versus returning an IO error when reading a file from disk, and they wanted this to be possible without needing many implementations of the from trait. Additionally, they wanted the ability to attach any data to an error without a lot of configuration.
00:02:31.494 - 00:02:57.438, Speaker A: With these features in mind, they created error stack. Error stack centers around the idea of taking a base error and building it up as it gets propagated. They call this base error a report. A report is organized as a stack of frames where each frame contains either a context or an attachment. The context is a high level description of the error. This is typically going to be a type that implements the error. Trait.
00:02:57.438 - 00:03:40.178, Speaker A: Attachments are extra information you can add. They could be string like types or arbitrary data types. The caveat is arbitrary types are added using the provider API, which requires a nightly version of of the rust compiler. The report is able to iterate through its frame stack from most recent to the root cause, producing an easy to read error message. Now that we have a theoretical understanding of error stack, let's take a code example and add error handling with error stack. In the following example, we have a CLI program which takes a name as input and returns credit card information from some sort of persisted storage. The persisted storage could be a database, a file, but for simplicity.
00:03:40.178 - 00:04:32.960, Speaker A: In this example it's simply a hashmap. In this hashmap the keys are names and the values are credit card information stored as a string of four numbers, the credit card number, the expiration month, the expiration year, and the CVV. Let's see how this program works by getting the credit card information for Amy. As we can see, the credit card information is parsed into a card struct containing the number, expiration, year, month and CvV. Now that we know how this program works from the user standpoint, let's take a look at the implementation. First we see a hashmap of names and credit card information stored in the variable credit cards. Our program then prompts the user to enter a name and stores it in a variable called name.
00:04:32.960 - 00:05:03.782, Speaker A: Then we call the function getcreditcardinfo passing in the credit card hashmap and the name. This function returns a card struct which we then print. Let's take a closer look at this function inside the function body. We first get the credit card information from the credit card hashmap. Then we pass that information into the parsecard function which returns a card struct and then we simply return the card. Let's take a look at the parsecard function. Inside parsecard.
00:05:03.782 - 00:05:44.296, Speaker A: We call parsecardnumbers which takes the string and converts it into a vector of integers. Once we have a vector of integers, we simply call the pop method to get the CVV year, month and number, and then use those variables to construct a new card instance. The cardstruct has three fields, number, expiration, and CVV. Expiration is an instance of the expiration struct which stores the year and month. Lets take a closer look at the parsecardnumbers function. Inside this function we take the cardstring and split it by the space character. Then we turn that into a vector.
00:05:44.296 - 00:06:17.920, Speaker A: Next we map over each substring and turn it into an unsigned 32 bit integer. Finally, we call collect to turn the iterator into a result type containing a vector of unsigned 32 bit integers, or an error which we ignore. Now, as we saw before, with the correct input this program works. However, we're not doing any error handling. Instead, we're calling unwrap everywhere, which means our program will panic if we get the error variant. Let's see what happens if we give our program invalid input first. Well try to enter an invalid name.
00:06:17.920 - 00:06:59.472, Speaker A: As we can see, our program panicked because we called unwrap on an optional type whose variant was none. This message is not really helpful. We have no idea why the optional value was none. Lets look at another error scenario. This time well see what happens when an entry in our hashmap has payment information thats missing a CVV number. For the Tim entry, we'll simply delete CVV and then run our program again and pass in Tim as the name. Again we get the same error message.
00:06:59.472 - 00:07:33.936, Speaker A: We tried to unwrap an optional, but the variant was none, even though it's a different error case. Lastly, we'll try a third error scenario where one of the entries in the hashmap has payment information that that's malformed. To do that, we'll modify Bob's entry to change the expiration month from a number to a string. Then we'll run the program again and enter Bob as the name. This time we get a slightly better error. We see that the value is parseint error, and specifically it's an invalid digit. But we're still missing a lot of context.
00:07:33.936 - 00:08:26.768, Speaker A: For example, whose credit card is being parsed and which part of the credit card info was an invalid digit. Let's improve this output by introducing logging and error handling to this CLI application. The first thing we'll do is open up cargo toml and add some dependencies. First we'll need log and environment logger for logging, and then we'll also need air stack for error handling. With these dependencies added, we can now begin modifying our code. First well import the format module and error trait from the standard library. Then well import a few things from error stack into report is a tray which allows us to convert error variance into a report.
00:08:26.768 - 00:09:28.650, Speaker A: Struct report is the type we'll be using for error handling. Result is a type alias for the result enum in the standard library, where the error variant is a report and result extension is a trait for result which will allow us to provide context information on reports with those types imported. The next thing we'll do is add error handling to the parsecardnumbers function. First we'll create a custom error type for parsing errors. We'll create a struct called parse payment infoerhead. Well also derive the debug trait and implement the display trait. And lastly well implement the error trait for parse payment infoer.
00:09:28.650 - 00:10:52.446, Speaker A: Now that we have a custom error type for parsing errors, lets update parse card numbers instead of returning a vector, well return a result which will either be a vector of integers or a parse payment info error inside the map method we call parse on our string to parse it into an integer. Callingparse returns a result which will either be the parse result or an error variant. Lets call the report method to turn that error variant into a report. Well also add a string attachment to the report to give more information about the error. We call the attach printablelazing method to lazily add a new printable attachment which will print out the specific substring that could not be parsed as an unsigned 32 bit integer. Next, well remove this unwrap and add a question mark to propagate any errors. We get a compile time error here, and that's because the function signature expects the error returned to be a parse payment info error.
00:10:52.446 - 00:11:52.720, Speaker A: But when we parse our substrings on line 22, the error parse returns is a parseint error. We then create a report on line 23 with the context set to parseint error. So we need a way to transform this parseint error into a parse payments info error. Now without error stack, you might do this by implementing the from trait, but with error stack all we have to do is change the context. To do that, after collect, we'll simply call change context and pass in parse payment infoerror. Our code is now compiling and the nice thing is, error stack used the type system to force us to change context. When we're switching from a lower level of abstraction, parsing individual substrings to a higher level of abstraction, returning a result for this function call the last thing we'll do is add another printable attachment after changing context.
00:11:52.720 - 00:12:57.860, Speaker A: Here we're printing out failed to parse input as numbers and then specifying what the input was. So far we took the error returned from parse, which is parseint error, and created a report where the context is set to parseinterror. Then we added a printable attachment to the report to give more information about the error. Then we changed the context to parsepayment infoer and added some more information. As you can see, little by little we are building up the report before propagating it. Now that parsecard numbers is complete, lets update parsecardous instead of returning card, we'll return a result type and because this function is dealing with parsing the card string, our error variant will be parse paymentinfoerror. Again, we can then add a question mark to the end of parse card numbers to propagate the error variant.
00:12:57.860 - 00:13:54.806, Speaker A: In this case, we did not have to switch context because parse card numbers and parse card have the same context. Parse payment infoer this makes sense because both functions are at a similar level of abstraction. Currently we're calling the pop method four times on our vector of integers because we expect there to be four integers. However, we're not checking for that. So let's create a check. If the length of numbers is not the expected length, which is four, then we're going to return the error variant. Because this is a base error, meaning we're not propagating an error from another function, we'll create a new report setting the context to parse payment info error.
00:13:54.806 - 00:15:01.580, Speaker A: We'll also add a printable attachment saying an incorrect number of elements was parsed, specifying the expected length, the actual length, and the numbers themselves. With that, the parsecard function is complete and we can move on to updating the getcreditcard info function. Just like with the other functions, we want to return a result type, but what should the error variant be? It doesn't make sense to use the parse payment info error because this function is at a higher level of abstraction. So instead, let's create another custom error type. Our error type is going to be an enum called credit card error, and it will have two variants, invalid input and other. Our previous custom error was an empty struct, but this time we're using an enum with two variants. Why is that? With the parsing error, we simply wanted to attach some extra information and propagate the error.
00:15:01.580 - 00:15:33.604, Speaker A: With this error, however, we want to programmatically handle two different cases. The first case is if the user gave us invalid input. For example, they gave us a name that did not exist in our hash map. In that situation, we want to tell the user their input is invalid. The second case is if we get an error unrelated to the user's input. In that situation, we simply want to say something went wrong, try again. The user of our program has no knowledge of its inner workings, so we don't need to expose them to the underlying error.
00:15:33.604 - 00:17:07.660, Speaker A: All right, to finish up this custom error type we need to implement the debug trait, display trait and error trait. The debug trait we can simply derive for the display tray. Well simply print out credit card error. Could now retrieve credit cardinal alright, now that we got all three traits implemented, lets update getcreditcardinfo first well change the return type to a result. Then instead of calling unwrap online 93 will handle the error variant. Calling the get method on a hashmap returns an optional we then call okrls to map that optional to a result type. If the optional is the sum variant, then it gets turned into an ok variant and if it's a none variant then this closure gets called.
00:17:07.660 - 00:17:49.330, Speaker A: Inside this closure we create a message string saying no credit card was found for the given name. We then return a new report with a context set to the invalidinput variant of credit card error. The invalid input variant contains the message and we also attach the message to the report. Next, lets focus on line 99 where we call parsecard. If parsecard returns an error, we want to propagate that error. To do that we can add a question mark at the end of the call. Well also need to change the context because parsecard returns parsepayment info error as the error variant and our function returns credit card error as the error variant.
00:17:49.330 - 00:18:46.594, Speaker A: We get an error here because parsecard accepts a string slice, but cardstring is currently a result type. We can simply fix this by propagating the error with a question mark. The last thing well do is add a printable attachment after we change context on line 100 and notice that the context is the other variant of credit card error and we include some extra information about the error as an attachment. Specifically, well print out whose credit card could not be parsed. With that, the getcreditcardinfo function is complete and the last function we need to update is main. GetCreditCardinfo can potentially return a credit card error. In this case we want to handle that error programmatically.
00:18:46.594 - 00:19:46.668, Speaker A: To do that we'll match against result. If we get the ok variant, we can simply print out the credit card information. If we get the error variant, then we take the report and match against the current context or current error by calling currentContext. If its the invalid input variant of credit card error, then we simply print out the message stored inside the variant, and if it's the other variant, then we'll print out something went wrong. Try again. Again. Users don't know the internal implementation of our program, so this is all the information they need.
00:19:46.668 - 00:20:43.440, Speaker A: However, as a developer debugging this program, you want a comprehensive report of the error. To get that information, let's go ahead and log this report. We'll be logging the report at the error level and the last thing we need to do is initialize environment logger at the top of main. With that, our CLI application is now updated with logging and error handling. Let's go ahead and run our program. First we'll run it with logging turned off. If we enter Amy, we get Amys credit card information as expected.
00:20:43.440 - 00:21:28.100, Speaker A: Next lets try entering an invalid name. We get a message saying no credit card was found for invalid as expected. Next let's try getting credit card information for Tim which should not work because his payment information is missing the CVV as expected, we simply get a message saying something went wrong. Try again. This message is appropriate for users, but if you're a developer debugging the program, you want more information about the error. To get more information we can simply change rust log to error. Lets set rust log to error and try entering an invalid name.
00:21:28.100 - 00:22:08.658, Speaker A: This time not only do we get the user facing message, but we also get a nice error log. The error log states that there was a credit card error could not retrieve credit card at line 95 in maintain. We also see the printable attachment here which is the same as the user facing message. Next lets try parsing Tims credit card information. This time we get a longer error log. First we see that there was a credit card error could not retrieve credit card at line 100. In main it also says TiMs card could not be parsed.
00:22:08.658 - 00:22:48.696, Speaker A: We also see that this error was caused by another error. Parsing payment error invalid payment info at line 57. In main, the error also states that an incorrect number of elements were parsed. Four were expected but we got three and we also see the elements that were parsed. This error log gives the developer enough information to understand what went wrong. Lastly, lets try getting credit card information for Bob. Again we see a credit card error caused by invalid payment info, but this time it's not caused by an incorrect number of elements.
00:22:48.696 - 00:23:17.790, Speaker A: The error states fail to parse input as numbers. We also see the input and clearly one of them is not a number. If we look at the underlying error, it states invalid digit found in string DeC could not be parsed as an unsigned 32 bit integer. This error log is great. It tells the developer exactly what went wrong. So as you can see, error stack greatly simplifies error handling in rust. If you want access to the code, I'll have a link in the description.
00:23:17.790 - 00:23:35.760, Speaker A: That's it for this video, but before you go, make sure to get your free rust cheat sheet by heading over to let's get rusty.com cheatsheet. Also, let me know if you want to see more videos on error handling by leaving a comment down below. With that said, I'll see you in the next one.
