00:00:00.360 - 00:00:37.120, Speaker A: What's up, rustations? Welcome back to let's get Rusty, the number one resource for all things rust. If you haven't already, make sure to subscribe to the channel for weekly rust videos. And most importantly, get your free yes, I said free rust cheat sheet by heading over to let'sgetrusty dot cheatsheet. In the last video, we talked about macros and specifically declarative macros in Rust. If you haven't seen that video already, make sure to check it out. Today we're finishing off the advanced Rust series by talking about procedural macros. So with that said, let's get rusty.
00:00:37.120 - 00:01:25.306, Speaker A: Procedural macros are like functions. They take code as input, operate on that code, and produce code as output. This is in contrast with declarative macros, which match against patterns, and replace code with a with other code. There are three kinds of procedural macros, custom derived attribute like and function like, and they all work in a similar fashion for complex technical reasons, which the Rust team hopes to eliminate in the future. Procedural macros must be defined in their own crate with a custom crate type. The three kinds of procedural macros are all defined using a similar syntax, which you can see here. First, we bring the proc macro crate into scope, which defines token stream.
00:01:25.306 - 00:02:18.390, Speaker A: Then we define our procedural macro by defining a function where the name of the function is the name of our procedural macro, and the input is going to be a token stream, which is the code we're operating on, and the output is also going to be a token stream, which is the code we're producing. Tokens are the smallest individual elements of a program. They can represent keywords, identifiers, operators, separators, or literals. Our function must also have an attribute which specifies the kind of procedural macro we're creating. With that background, let's create our own custom derived macro. Our custom derived macro is going to be called hello macro, and it will implement a trait conveniently also called hello macro, which will have an associated function with a default implementation that prints out hello macro. Here's an example of some code using our macro.
00:02:18.390 - 00:03:04.210, Speaker A: First, we need to bring our macro into scope, and we'll discuss why we need to bring two crates into scope in just a second, and then we can define a struct. In this case it's called pancakes, and have a derive attribute specifying our macro. What this will do is implement our hello macro trait for the pancake struct, which means now we can call hello Macro from the pancake struct. Alright, now let's actually implement hello macro. The first thing we need to do is create a new library crate called hello Macro. So let's open up a terminal and type in cargo new hello macro lib. Then I'll cd into the newly created directory and open it up in versus code.
00:03:04.210 - 00:03:41.846, Speaker A: Here I've opened up lib rs. Let's delete the code that's automatically generated and define our trait. Our macro has one associated function named hello Macro. Now, I've said previously that we wanted this associated function to have a default implementation, and we could do that if we wanted to simply print hello Macro. But imagine if we wanted to do something a little more complicated. Imagine that we wanted to print hello macro, followed by the type on which the trait was implemented. On rust doesn't have reflective capabilities, so we can't look up the name of the type at runtime.
00:03:41.846 - 00:04:26.774, Speaker A: The solution here is to use our macro to generate the default implementation. All right, now that we have our trade defined, we need to define our procedural macro. And if you recall from the beginning of the video, at this time, procedural macros have to be defined in their own crate. So let's open up our terminal again, and we're going to create a new library crate inside of our hello macro crate. We'll go ahead and type in cargo new hello underscore macro, underscore derive, and then dash dash lib. There's a naming convention when structuring crates and macro crates. If you have a custom derived macro, then you'll name the crate whatever your crate's name was.
00:04:26.774 - 00:05:15.060, Speaker A: So in this case, hello macro and append derived. Because these two crates are tightly coupled, we created our macro crate inside of our library crate. Each crate still has to be published separately, and code using our crates has to bring each crate into scope, which is why we saw those two use statements in our example earlier. Next, let's open up the cargo toml file of our newly created crate. Now, remember I said macro crates are a special type of crate. So to signify that we're going to type in proc dash macro equals true, we'll also need to add the syn and quote crates as dependencies, and we'll see why in just a second. Also, I made a mistake here.
00:05:15.060 - 00:05:54.030, Speaker A: This proc macro attribute must be under the lib section. All right, now let's open up the lib rs file inside our hello macro derived crate, and we're going to replace the automatically generated code with an implementation of our macro. Alright, let's go through this together. First, we have this statement extern create proc macro proc macro is a crate that comes with rust, so we didn't have to declare it in our dependencies section inside of cargo toml. However, to import the crate, we do have to write this extern crate statement. The proc macro crate allows us to read and manipulate rust code. Next, we have three use statements.
00:05:54.030 - 00:06:45.204, Speaker A: We bring token stream into scope, quote into scope, and syn into scope. The syncrate, short for syntax, allows us to take a string of rust code and turn it into a syntax tree data structure, which we could operate on. And finally, the quote crate can take the syntax tree data structure and turn it back into rust code. Next, we define our custom derived macro. Notice that our code is split into two operations. The hello macro derive function is responsible for parsing the token stream into a syntax tree, and the impo hello macro function is responsible for transforming that syntax tree. This separation of concerns makes the code easier to understand, and it reduces duplication, because this parsing part is going to be the same for almost all procedural macros, while the part that actually manipulates the syntax tree is going to be different.
00:06:45.204 - 00:07:17.800, Speaker A: Our function is annotated with proc macro derived, indicating that this is a custom derived macro with the name hello macro. Inside our function body. We use the syncrate to parse our input, which is a token stream into an abstract syntax tree. Here we're calling unwrap, which means our function will panic if parsing fails. This is appropriate because we're not returning a result type, and also this function is only going to be called at compile time, not runtime. Then we pass the syntax tree into implied hello macro. So let's go ahead and implement that function.
00:07:17.800 - 00:08:00.366, Speaker A: Inside our function body, we extract out the name of the type we're working on into a variable called name, and then we use the quote macro to output some rust code. In this case, we want to implement the hello macro tree on our type. The quote macro has templating abilities, so this pound name here will be replaced with the actual name of our type. Then we want to provide a custom implementation for the hello macro associated function, which in this case is going to print hello macro. My name is, and then the name of the type. We're working on the stringify macro. Here we'll take an expression and turn it into a string without evaluating the expression like the format macro would.
00:08:00.366 - 00:08:40.846, Speaker A: The last thing to do here is take the output of the quote macro, which we saved in a variable called gentle, and turn it into a token stream by calling the into method. At this point, both our hello macro crate and our hello macro derive crate should be complete. So let's go ahead and run cargo build to make sure we were able to successfully build the hello macro derive crate. So now let's cd out into the hello macro crate and run cargo build again. And that was successful as well. Now let's actually test our macro out. I'm going to switch back to the example project from before.
00:08:40.846 - 00:09:09.806, Speaker A: Next, I'm going to open up the cargo toml file and add our two crates as dependencies. In this case, I don't want to publish the crates to crates IO, so I'm going to specify a local relative path. Then if I switch back over to main rs, you can see that the red squigglies went away. So our code should be able to compile go ahead and open up the terminal and type cargo run. As expected, the following string was printed. Hello macro. My name is pancakes.
00:09:09.806 - 00:09:51.510, Speaker A: Next, we're briefly going to go over attribute like macros and function like macros. Attribute like macros are similar to custom derived macros, except instead of generating code for the derive attribute, we can create a custom attribute. Also, custom derived macros only work on structs and enums, whereas attribute like macros work on other types such as functions. Let's look at the following example. Imagine you're building a web framework and you want to create a new attribute called route which takes in an HTTP method and a route. This macro will generate code which will map a specific HTTP request to a given function. In this case, we're mapping a get request on the root path to the index function.
00:09:51.510 - 00:10:22.258, Speaker A: We would define our attribute like macro by specifying a function annotated with proc macro attribute, and our function would take in two arguments. The first argument is going to contain the contents of the attribute. So in this case it's going to be the HTTP method and the path. The second argument is going to contain the contents of the item the attribute is attached to. In this case, our index function. Other than that attribute like macros work just like custom derived macros. Lastly, let's look at function like macros.
00:10:22.258 - 00:11:11.380, Speaker A: Function like macros look like function calls. However they are more flexible. Firstly, they could take a variable number of arguments, and secondly they operate on rust code. In this example, we want to generate a function like macro called SQL, which will take a SQL statement as an argument, validate that that SQL statement has the correct syntax, and then generate code that will allow you to execute that SQL statement. As you can see, the definition for our function like macro is extremely similar to our custom derived macro, with the only difference being that we're annotating our function with proc macro instead of proc macro derive alright, that's it for this video on procedural macros in Rust. If you have any questions, or if you want to see me do more videos about macros, leave a comment down below. Also, make sure to subscribe for weekly rust videos.
00:11:11.380 - 00:11:22.700, Speaker A: And most importantly, get your free rust cheat sheet by heading over to let's get rusty.com cheatsheet. And with all that said, I'll see you in the next one.
