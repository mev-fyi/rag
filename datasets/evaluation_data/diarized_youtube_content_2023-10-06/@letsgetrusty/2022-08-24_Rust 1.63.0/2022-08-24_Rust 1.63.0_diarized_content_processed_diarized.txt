00:00:00.400 - 00:00:47.398, Speaker A: A new version of rust was recently released, rust version 163.0. Let's go through the changes together, but before we get started, if you haven't already, make sure to get your free rust cheat sheet by heading over to let'sgetrusty dot cheatsheet. The first change in this release are scoped threads. When spawning threads using the spawn function, the past enclosure has a bound of static, which means it cannot contain any non static references. This means passing in borrowed values does not work. In this example, if we try to reference the variable a in our spawn thread, we would get a compile time error, even though this restriction isn't necessary in cases where threads are joined at the end of a function. As of this release, the standard library has an API for spawning scoped threads.
00:00:47.398 - 00:01:37.612, Speaker A: The scope function accepts a closure which gets passed a scope object. Scoped threads can borrow non static values because the API guarantees that the spawn threads will exit when the scope object is dropped at the end of the closure. In this example, we can immutably borrow a in the first spawn thread and mutably borrow x in the second spawn thread because no other threads are using it. After the scope ends, we are able to access and modify our variables again in the main thread. The next feature in this release is ownership for raw file descriptors or handles, depending on which operating system you're targeting. Previously, when working with platform APIs, you would represent raw file descriptors or handles using the cint type or its alias raw file descriptor. The problem is these types don't encode whether the API takes ownership of the file descriptor or merely borrows it.
00:01:37.612 - 00:02:28.446, Speaker A: As of this release, rust provides wrapper types such as borrowed file descriptor and owned file descriptor. These types are marked as transparent, meaning that extern C bindings can directly take these types to encode the ownership semantics. It's recommended that new APIs use these types instead of the raw file descriptor type. Another change is that in this release, the conditional variable mutex and reader writer lock types are able to be created in const contexts. This means you can avoid using crates like lazy static for creating global statics with mutex, reader writer lock, or conditional variable values. Prior to this release, if you had a function with two arguments, the first one being a generic and the second one being a generic with a trait bound, you would get an error if you try to specify a concrete type for the first generic using the turbofish syntax. In this release, this restriction has been relaxed.
00:02:28.446 - 00:02:52.810, Speaker A: However, the impulse trait parameter, despite destriggering to a generic, remains opaque and cannot be specified with the turbofish syntax. Lastly, with this release, non lexical lifetimes are now available in all editions of Rust. If you haven't already, make sure to get your free rust cheat sheet by heading over to letsgetrusty.com cheatsheet. With that said, I'll see you in the next one.
00:02:56.120 - 00:03:01.610, Speaker B: Beverage.
