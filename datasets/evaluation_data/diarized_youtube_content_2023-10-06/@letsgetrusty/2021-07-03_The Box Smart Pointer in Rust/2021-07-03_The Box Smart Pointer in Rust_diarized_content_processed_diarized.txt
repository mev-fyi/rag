00:00:00.480 - 00:00:43.591, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In the last video, we covered chapter 14 of the Rustling Book, which talked about publishing crates to crates IO and using cargo workspaces. In this video, we're covering chapter 15 of the Rustling book, which talks about smart pointers. So with that, let's get rusty. First, let's talk about what a pointer is. A pointer is a general concept for a variable that stores a memory address, and that memory address refers to or points to some other data in memory.
00:00:43.591 - 00:01:30.347, Speaker A: The most common pointer in Rust is a reference. References simply borrow the values they point to, meaning that they don't have ownership over the values. References don't have any special capabilities, which which also means they don't have much overhead, unlike smart pointers. Smart pointers are data structures that act like a pointer but have metadata and extra capabilities tacked on. One example is a reference counting smart pointer, which allows a piece of data to have multiple owners by keeping track of the owners and once there are no more owners, cleaning up the data. In many cases, smart pointers own the data the that they point to, unlike references, which simply borrow the values. Turns out we've already encountered smart pointers.
00:01:30.347 - 00:02:16.123, Speaker A: Specifically, I'm talking about strings and vectors. Both these types are smart pointers because they own some data and allow you to manipulate it. They store extra metadata, such as the capacity, and they have extra capabilities. For example, the string type ensures that the data is valid. UTF8 smart pointers are usually implemented using structs, but unlike regular structs, they implement the DREF and drop traits. The draft trait allows instances of your smart pointer struct to be treated like references, so you can write code which works with either references or smart pointers. The drop trait allows you to customize the code that is run when an instance of your smart pointer goes out of scope.
00:02:16.123 - 00:03:07.901, Speaker A: Smart pointers are a general design pattern used frequently in Rust. Also, many libraries implement their own smart pointers, so we won't be covering every single smart pointer out there. Instead, we'll be covering the most common smart pointers used within the Rust standard library, starting with box, which is a smart pointer that allows you to allocate values on the heap. Here I have a very simple example of using the box smart pointer. We have a variable called B, which is equal to a new instance of box passing in the value 5, and then we simply print our variable. The thing we pass into the new function is what we want to store on the heap. So in this case we're storing five on the heap and on the stack, we're storing a pointer or a memory address to the location of five on the heap, and that pointer is what's stored in B.
00:03:07.901 - 00:04:10.649, Speaker A: Boxes don't have any overhead except storing the data on the heap, but they also don't have many other capabilities, so you would typically use them in the following situations. When you have a type whose exact size can't be known at compile time, and you want to use a value of that type in a context which requires knowing the exact size. When you have a large amount of data and you want to transfer ownership of the data, but you want to make sure that the data isn't copied because again, it's a large amount of data. And lastly, when you own a value and you only care that the value implements a specific trait rather than it being a specific type. This third case is known as a trait object, and we'll cover it in depth in chapter 17. Going back to our program, notice that in the print line statement we simply use our box value as if it were a value on the stack. So let's go ahead and run our program and you can see we get B equals 5 just like any other owned value.
00:04:10.649 - 00:04:44.253, Speaker A: When our box goes out of scope. In this case, B will go out of scope at the end of main, it will be deallocated, meaning that the box smart pointer on the stack will be deallocated, and the underlying data on the heap will also be deallocated. Now, this is of course a contrived example. Typically you won't store a single value on the heap. In fact, in this case, storing five on the stack would be a lot more appropriate. So typically boxes aren't used by themselves. Next, let's look at a case in which boxes are actually useful.
00:04:44.253 - 00:05:31.233, Speaker A: In the following example, we have a recursive enum called lists, and it has two variants, cons and nil. The the cons variant is a tuple which holds an integer, and then a list which is again this enum. So it is recursive. Rust needs to know how much space a type takes up at compile time. But in this example, and in general with recursive enums, we don't know how much space the enum could take up, because in theory, we could recurse forever here. Before we talk about how to fix this using boxes, let's first talk about this specific enum called a cons list. The cons list is a data structure that comes from the programming language Lisp and its dialects.
00:05:31.233 - 00:06:05.397, Speaker A: Now, I'm not going to go too deep into the cons list data structure. You can Google the Wiki page and learn more if you'd like. But here's a simple visual representation. Here we have a few boxes with two cells. The first cell holds a value, in this case, an integer, and the second cell points to the next box until we get to the last box, which points to nil. Looking at our example Listenum, you can see how this is implemented in code. We have one variant that holds a value, and then another list, and then the second variant is nil.
00:06:05.397 - 00:06:40.863, Speaker A: Although functional programming languages use cons lists frequently, it's not a data structure that's commonly used in Rust. Most of the time, if you have a list of items in Rust, it's better to use a vector. Other, more complex recursive data types are useful in various situations. So using the cons list as an example helps us understand how boxes can allow for recursive data types. Notice that in our cons variant we're storing an integer. We could make this a generic type, but for simplicity, we're using an integer instead. Now let's talk about how we could define a CONS list.
00:06:40.863 - 00:07:30.135, Speaker A: So, first we'll bring our list variance into scope. Then we'll define a new variable called list. To start off our list, we'll create an instance of the cons variant, and for the first value, we'll store one as the integer. Now, the second value is of type list, so we'll store another cons instance. This time we'll store 2 as the integer. And then for the second value again, another cons instance. This time we'll store 3 for the integer, and then nil for the second value.
00:07:30.135 - 00:08:11.443, Speaker A: Nil here just denotes the end of the list. So let's go through this together. We have a cell, a con cell here which stores one, and then another console which stores two, then another console which stores three, and finally the value nil. So again, if we were to look at this in a diagram, we'll have a cell with one pointing to another cell with two pointing to another cell with three, and then we end the list. In this case, the cells aren't pointing to each other. It's more like this cell contains the cell which contains the cell. However, it's just easier to think about it in that way.
00:08:11.443 - 00:09:05.803, Speaker A: Now, you might have noticed that up here we have some red squiggly lines. So let's open up our terminal and run cargo. Check to see the E the error states that our list enum is a recursive type that has an infinite size, and in our cons variant the list value is recursive without indirection. Then it has a helpful tip to insert some indirection by wrapping list inside the box smart pointer. Indirection here means that instead of storing the list value directly, we should store a pointer to the list value. To understand this error and why the box smart pointer fixes it, let's first talk about how Rust computes the size of non recursive enums. Here I have the message enum we used in chapter six and you can see it has four variants.
00:09:05.803 - 00:09:46.919, Speaker A: The way Rust will figure out the size needed to store a variant of message is it's going to go through each variant and see how much size the variant needs. For example, quit doesn't need any space. Move is a struct with two values. So that's going to take some space. Then we have a tuple type with one string and we have another tuple with three integers. Rust will figure out which variant needs the most amount of space. Because we can only use one variant of the message enum at one time, the most space message is going to take up is equal to the most space the largest variant is going to take up.
00:09:46.919 - 00:10:15.917, Speaker A: Now let's try to do the same thing for our list enum. The variant nil doesn't take up any space, but the variant cons it does take up some space. It stores a tuple type with an integer and then a list. Well, now Rust has to go in and see how much space list takes up. So we're back here to our list enum and then again we go into cons. It stores list. So we have to go back to our enum and as you can see, there's no way to tell how big our list is going to be.
00:10:15.917 - 00:10:59.345, Speaker A: Now, if we open up our terminal again, remember that the helpful hint says we can fix this by wrapping list in a box smart pointer. So let's do that. Now why did this fix our error? Well, let's try to figure out the size of list again. So remember we'll look at each variant and see how much space it takes up. So again, nil takes up no space and the cons variant takes up some space. It stores an integer, but this time instead of storing a list, it stores a box smart pointer. The box smart pointer is going to be a fixed size pointer and it's going to point to some arbitrary amount of data on the heap.
00:10:59.345 - 00:12:04.753, Speaker A: But on the stack again, it's a fixed size pointer, so we know exactly how much space we need for the cons variant, and thus the problem is solved. Now we just need to modify main we start off with a cons variant which stores one, and then instead of storing another list variant, we'll store a box type and again we'll do the same thing for the inner cons variant, it stores two, and instead of storing another list variant, we'll store a boxtype and then we'll do this one more time for nil. Not the most readable code, but now our list is working. Our code is compiling without errors. That's it for this video. If you enjoyed it, make sure to smash that like button. And if you want to stick around for next week when we talk about the DEREF and drop traits, make sure to hit subscribe.
00:12:04.753 - 00:12:07.425, Speaker A: And with that, I'll see you in the next one.
