00:00:00.360 - 00:00:54.392, Speaker A: This code is a pile of shit, a nightmare waiting to happen. To understand why and how to fix it, you first have to understand the biggest lesson rust has taught me, which is the power of leveraging the type system to enforce invariance. Let's break that down. In the context of programming, an invariant is a rule or condition that must always be true. If we're writing software that manages bank accounts, one invariant could be that the balance can never be less than zero, assuming the account doesn't allow overdrafting. But how would we enforce this invariant? There are a few approaches broken down into two categories, manual enforcement and automated enforcement. Manual enforcement includes code reviews, code comments, documentation, design documents, and even tribal knowledge that you share amongst your team members.
00:00:54.392 - 00:01:35.934, Speaker A: As you can imagine, this type of enforcement is very brittle, but it does have its use cases. Imagine a UI invariant that any delete action requires, presenting a confirmation prompt to the user. This would be very difficult to automatically enforce, so you may opt for a more manual approach, such as documentation in the form of design guidelines and code reviews. Breaking this invariant wouldnt be a catastrophic event, so a manual approach can be sufficient. If we use the manual approach in our bank balance example, it would quickly lead to disaster. We cant afford violations. We need a more robust method of enforcement, which brings us to automated enforcement.
00:01:35.934 - 00:02:13.206, Speaker A: This includes runtime assertions, runtime checks, testing, input validation, and leveraging the type system. Well touch on all of these approaches and especially highlight how to leverage the type system, which is the most robust way to enforce invariance. Let's start by talking about the first automated enforcement method assertions. We'll assert that the initial balance is greater or equal to zero. We'll do a similar assert when depositing and when withdrawing. We'll also assert that the account has sufficient funds. Our invariant is now automatically checked through code, but there are a few issues.
00:02:13.206 - 00:03:07.372, Speaker A: Assertions are checked at runtime, which means developers can still write defective code. Also, if the assert fails, our program will panic and crash. Lets improve this code by leveraging rust type system well change the type of balance from a signed 32 bit integer to an unsigned 32 bit integer, which means the balance cannot be a negative number. We can now remove the asserts in the new and deposit functions and the first assert in the withdrawal function, but we still need to make sure the account has sufficient funds. Here we can leverage an important feature of rust type system. Well change the return value to a result type to account for this potential failure mode, and then inside the function well perform a simple runtime check because withdrawal returns a result type, it will force callers to handle the potential error. We can also add tests to make sure withdrawal behaves correctly.
00:03:07.372 - 00:04:00.156, Speaker A: With this setup, our code wont compile or our test will fail if the invariant is violated, making our enforcement much more robust. This powerful software design methodology of leveraging the type system to enforce invariance is called type driven design, and although our previous example was simple, the type system can actually enforce some very complex invariants, especially if the language is statically typed and has an expressive type system like rust. At the beginning of the video I said that this code is a nightmare waiting to happen. Why is that? We have an API endpoint for creating new users. The invariant is that the email and password should always be valid. We enforce this through input validation. Users give us untrusted input and we call a couple validation functions to make sure the input conforms to our requirements.
00:04:00.156 - 00:04:49.056, Speaker A: Only then do we persist the data in the database. The problem is, these checks are only done at one point in time in the beginning of our request handler. So can the insert user function safely expect that the email and password are valid? If we look at the type signature in isolation, there is no information guaranteeing that the email and password are valid. They're defined as simple strings. This function has to trust that the caller performed proper validation before passing in the input, which is a recipe for disaster as the codebase grows and changes over time. You can imagine a validation check accidentally being removed, or the data being modified in some way, which can lead to disastrous results. One way to prevent against this is to perform validation again inside the insert user function.
00:04:49.056 - 00:05:32.226, Speaker A: However, this introduces unnecessary redundancy and room for error. Instead, we can take advantage of a principle from type driven design, parse don't validate. Instead of sprinkling validation functions throughout our codebase, we can parse user input into new types that are guaranteed to uphold our invariants. First, we'll create two new types, email and password. Both are tuple structs which wrap a string. Value wrapping built in types which have loose requirements in user defined types which have stricter requirements, is called the newtype pattern in Rust. In this case, our requirements, or invariants, are that email is formatted correctly and that password meets our length requirements.
00:05:32.226 - 00:06:20.794, Speaker A: To enforce this well, add a parse function which takes an untrusted string as input and parses it into an email or password type. The parse operation may fail, so we'll return a result type. Here we're leveraging several unique features of Rust's type system. Because of Rust's visibility rules. The inner string is private and inaccessible outside of the struct, and because rust doesn't have built in or default constructors, the only way to construct an email or password instance is through the parse function. We are still using the same validation functions as before, but now the validation logic is contained within the type and the validation state is persisted within the type. Let's also add a astir method to allow read only access to the underlying string data.
00:06:20.794 - 00:07:12.824, Speaker A: We can now update the user struct to use our new types and update the route handler to parse user input. Now any downstream code can be sure that the email and password are valid. Type driven design is a big topic, and this is only the tip of the iceberg. We just talked about the parse dont validate principle and how to implement it using the Newtype pattern in rust. We can also use more advanced patterns such as the type state pattern, which allows you to define different states an object can be in define specific actions for each state and ensure valid state transitions. Let's say the user in our API example can be in one of three states, a viewer, editor or admin. First, we'll create a struct to represent each state and then define a user role.
00:07:12.824 - 00:07:57.342, Speaker A: Generic onuser, which defaults to viewer, will store the generic in a state field which uses phantom data to avoid unnecessary allocation. Then we can define methods available to all states and state specific methods like an edit method for editors. We can also enforce proper state transitions. Viewers can be promoted to editors, editors to admins, and admins may be demoted to editors. Notice that we're taking advantage of Rust's ownership model. These state transition functions take self as input, which moves the instance into the function and makes it unusable going forward. This means that if a viewer instance gets promoted to an editor, the old user instance cannot be used.
00:07:57.342 - 00:08:53.930, Speaker A: This is a grossly simplified overview of the type state pattern, but I did make a video if you want an extensive explanation of advanced patterns like this. So how do you start leveraging type driven design in your own rust projects? There are many ways to implement this powerful software design methodology in Rust. Theoretically you can apply some of these patterns to other languages, but Rust makes it especially practical with the way its type system is designed in other languages. These patterns are not always practical, if at all possible. To get started with type driven design, the first thing you can do is look through your previous projects to see if there are any opportunities to apply the more straightforward patterns like parse dont validate, which we talked about in this video. And before you do that, make sure you have your rust fundamentals down, which you can do by getting your free rust cheat sheet@letsgetrusty.com. cheatsheet hope youve enjoyed the video and remember to stay rusty.
