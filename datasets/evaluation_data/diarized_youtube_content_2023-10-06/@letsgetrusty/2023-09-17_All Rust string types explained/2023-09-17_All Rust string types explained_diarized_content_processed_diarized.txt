00:00:00.440 - 00:00:57.997, Speaker A: Why is it that in C, strings are simply an array of characters, but in Rust, strings are represented by all these different types? Many Rust beginners see this as unnecessary complexity, but the Rust team was very intentional about how strings are designed in Rust, and it has everything to do with safety, efficiency, and flexibility. In this video, I'll explain all the different string types in Rust and how each of them plays a significant role in building blazingly fast Rust applications. Towards the end, I'll also cover a couple rare, specialized string types you can use to squeeze out maximum performance. Now, to truly appreciate how Rust handles strings, it's critical to first understand what strings fundamentally are. In programming, data is fundamentally represented as binary ones and zeros. For a program to convert this binary data into a human readable string, it needs two key pieces of information, the character encoding being used and a way to determine the length of the string. Let's talk about character encoding first.
00:00:57.997 - 00:01:37.775, Speaker A: Binary data is typically processed as a sequence of bytes. Each byte containing eight bits and a byte can be represented as an integer using the binary number system. Now, a character encoding is simply a standard for mapping bytes to characters. There are two very common encodings that you need to know when dealing with strings ASCII and UTF8. ASCII stands for American Standard Code for Information Interchange, a very simple encoding where each character is represented by 1 byte. Using ASCII, we can map the first byte in this example to a capital h and the second byte to a lowercase e. And if we continue on, we can encode the entire hello world string in ascii.
00:01:37.775 - 00:02:03.613, Speaker A: This works well for simple English strings. However, ASCII is very limited. A single byte can only represent 256 distinct values. As a result, ASCII only supports the English Alphabet symbols and control characters. It doesn't support other languages or complex characters like emojis. That's where UTF8 comes in. UTF8 is a variable with encoding where characters are anywhere from one to four bytes.
00:02:03.613 - 00:02:41.763, Speaker A: This means that it can encode over a million characters, including every language in the world, and complex characters like emojis. It's also completely backwards compatible with ASCII. All these great features is why UTF8 is the most widely adopted character encoding in the world. Now that we know how to convert bytes into characters, let's discuss the other important piece of information programs need to represent a its length. A string is a sequence of bytes that lives within a larger block of memory. When you create a string variable in your program, it points to the first byte of the string. But how does a program determine where the string ends? There are two main approaches.
00:02:41.763 - 00:03:15.905, Speaker A: The first approach is to use a termination character, commonly a null byte, to mark the end of a string. This approach is simple and saves memory, but it has a runtime cost for certain operations. For example, to get the length of the string, you have to traverse the string byte by byte until you get to the termination character. The second approach involves storing the string's length along with a pointer to the first byte of the string in a higher level data structure. The benefit is some runtime operations will be faster. For example, retrieving the string's length can be done in constant time. However, this approach does use some additional memory.
00:03:15.905 - 00:04:02.871, Speaker A: With this fundamental understanding of strings, we can now explore why strings in C are really simple, but also really dangerous, and then talk about how Rust addresses these issues. In C, strings are simply represented as an array of characters or a pointer pointing to the first character in the string. A null terminator is automatically added by the compiler to mark the end of a string, and C does not enforce any particular encoding. This simplicity comes at a price. Developers are responsible for making sure strings are valid and handled properly, which oftentimes leads to disaster. For example, let's say your program took in some user input and you expected that input to be valid UTF8. If you forget to validate this input or your validation isn't done properly, it could lead to data corruption or worse, security vulnerabilities.
00:04:02.871 - 00:04:49.713, Speaker A: Let's take a look at another example. Say you have a string and you want to copy that string. So you create a buffer with 16 characters, which is the amount of characters your string has, and then use the string copy function to populate the buffer. Turns out this code causes a buffer overflow, which can lead to data corruption, undefined behavior, security vulnerabilities, or system crashes. And that's because we forgot to account for the null byte character the compiler automatically inserts at the end of our string. Now, we can avoid this mistake by using the size of function when creating a new buffer, but the point is, it's really easy to make catastrophic mistakes in C. Now that we've seen how dangerous strings in C can be, let's turn our attention to Rust, a language that reimagines string handling with safety, efficiency, and flexibility in mind.
00:04:49.713 - 00:05:26.779, Speaker A: Rust leverages its powerful type system to ensure string safety in three key ways. Firstly, string types in Rust store the string length as metadata instead of using a null terminator. This leads to more efficient runtime operations and prevents vulnerabilities like buffer overflows. Secondly, strings and Rust are guaranteed to be valid UTF8. This ensures that strings are compatible across languages and systems, while also preventing issues like data corruption. And it makes it easier to work with strings because developers don't need to think about the encoding. Thirdly, strings in Rust, or more generally variables in Rust, are immutable by default.
00:05:26.779 - 00:06:03.069, Speaker A: This helps prevent issues where the contents of a string are changed unexpectedly. Now, there are many ways to represent a string in Rust, and we'll cover all of them in this video. But at the core, Rust has two primary string types, strings and string slices. Understanding these two types and their differences is critical because they cover 90% of use cases and you'll be working with them all the time. If you take away one thing from this video, it should be a deeper understanding of these two types. So let's go over the technical details of each type and their use case. The string type in Rust is a heap allocated, growable UTF8 encoded string.
00:06:03.069 - 00:06:39.229, Speaker A: This is called an owned type because it owns the underlying data and is responsible for cleaning it up. When the string variable goes out of scope, the underlying data is automatically deallocated. This type consists of a pointer to the string data on the heap, the string's length, and its capacity. This design allows it to be efficient for string manipulation. A string slice, on the other hand, is a view into a string. It represents a contiguous sequence of UTF a encoded bytes, making it efficient for read only operations. This is called a borrow type because it doesn't own the underlying data, it simply has access to it.
00:06:39.229 - 00:07:47.555, Speaker A: Unlike the string type, string slices in most cases do not own their data. They are essentially a reference to a segment of a string or another string slice holding only a pointer to the start of the slice and the length of the slice. Unlike the string type, string slices don't contain capacity information because they're not growable. Another difference is that while the string type is always allocated on the heap, string slices can reference data on the heap or in the data section of the compiled binary, which is the case for string literals or strings stored on the stack, which is rare but possible. These two types have distinct use cases. The string type is useful when you want to create or modify string data dynamically at runtime, for example when reading and altering file content or collecting user input. String slices, on the other hand, are useful when you want to read or analyze pre existing string data without making changes to it, for example Parsing command line arguments or searching for a substring within A larger string so far we've discussed how Rust ensures string safety by storing length metadata instead of using a termination character, enforcing UTFA encoding, and making strings immutable by default.
00:07:47.555 - 00:08:26.107, Speaker A: We also covered the two main string types in Rust strings and string slices. Now it's time to buckle up, because we're going to cover all the other string types in Rust, which enable efficiency and flexibility. Being aware of these types is important so that you're not caught off guard when you come across them, and truly understanding these types will allow you to utilize the full power of Rust. First, let's talk about the different variations of string slices. Here we have a string literal, which is a reference to a string slice. This is actually syntactic sugar for a reference with a static lifetime. A static lifetime indicates that the data being pointed to is guaranteed to be available for the entire duration of the program's execution.
00:08:26.107 - 00:09:08.938, Speaker A: This makes sense for string literals because they're stored in the compiled binary. Now, most of the time you don't have to explicitly write out the static lifetime, but there are cases where you do have to write it out, for example, when storing string slices in structs or enums. In this example, the parse error variant stores a string literal, or when returning a string slice from a function that has no other borrowed parameters. Now, you may have noticed that the string slice type is made up of two parts, the reference operator and the STR type. The STR type represents a dynamically sized sequence of UTF8 encoded bytes. In other words, STR describes a string slice, but we can't use it directly as a standalone type because its size is not known at compile time. Instead, we have to use STR behind some type of pointer.
00:09:08.938 - 00:09:44.919, Speaker A: A reference. This is by far the most common string slice type you'll see, but it's not the only one. Let's explore three other pointer types we can use with the STR type. For specialized cases, instead of using a reference, we can wrap the STR type in a box. Smart pointer this type represents an owned, non growable heap allocated string slice. It's useful when you want to freeze a string to prevent further modifications or save memory by dropping the extra capacity information the string type stores. In this example, we create a string type and then turn it into a box STR type to indicate that we want to keep the string as is without further modifications.
00:09:44.919 - 00:10:36.521, Speaker A: This saves a small amount of memory by dropping the capacity information the string type stores in real world code. You might use the box store type in cases when you're working with APIs that need to return an own string that will not be modified further, or when you want to aggressively optimize for memory usage and you know the string will not change. You can also use the STR type with the Reference counting smart pointer, which is useful when you want to share ownership of an immutable string slice across multiple parts of your program without cloning the actual string data. For example, let's say we have a large string representing some text, and multiple parts of our program want to hold references to a particular section of the text. To avoid copying that subsection, we can use an RC STR type. The actual string data is only stored once in memory, regardless of how many RC instances we create. This could be beneficial when you're dealing with really large strings that would be expensive to clone.
00:10:36.521 - 00:11:24.623, Speaker A: The counterpart to the RC smart pointer is the ARC smart pointer, which stands for Atomic reference counted. Unlike the RC smart pointer, ARC is thread safe. Wrapping the STR type in this smart pointer is useful when you have an immutable string slice that you want to share across multiple threads without having to clone the string data. In this example, we create a regular string slice and wrap it with an ARC smart pointer. Then we can spawn three threads which can all read the slice without having to clone the string data itself. Now that we have a better understanding of string slices, let's dive a little deeper into the string type. The string type is essentially a wrapper around a vector of bytes, the difference being those bytes are guaranteed to be valid UTF8 this allows the string type to provide methods that make it convenient to work with Unicode text, and it also enables safe manipulation of string data.
00:11:24.623 - 00:12:15.975, Speaker A: However, representing a string as a vector of bytes or a slice of bytes can be useful when dealing with binary data, constructing strings byte by byte, or when dealing with strings that use an encoding other than UTF8. In this example, we're calling the Read Latin 1 String function to simulate reading a string with the Latin 1 encoding from some external source like a binary file or network packet. This function returns a vector of bytes. Then we call the latin one to string function and pass in the vector of bytes as a slice of bytes. This function converts the Latin 1 encoded string to a UTF 8 encoded string. As you can see, binary string representations are useful when dealing with non UTF 8 encoded strings. Now let's switch course and talk about something that you'll likely see pretty often in rust code, and that's different string literal representations, specifically raw string literals and byte strings.
00:12:15.975 - 00:13:03.353, Speaker A: Here's a string literal In Rust, if we wanted to include special characters like double quotes or backslashes within the string, we would need to escape them with backslashes. This becomes tedious in certain cases, like writing regular expressions or defining JSON objects as string literals. In these cases we can use a raw string literal by prefixing the string with a lowercase r and adding a hash symbol on either side of the string. Raw string literals allow you to write special characters like backslashes and quotes without needing to escape them. Here we can see a raw string literal being used to create a regular expression pattern. Byte strings, on the other hand, are created by prefixing a string literal with a lowercase b. This creates a slice of bytes, which is useful for dealing with network protocols that expect a byte sequence like the HTTP protocol.
00:13:03.353 - 00:13:47.943, Speaker A: You can also combine raw string literals with byte strings. In this example, we define a raw byte string containing the PNG file format signature, which we can use to identify PNG files. We just covered string literals, which are straightforward and common in Rust, but what if you have more specialized needs or constraints? What if you want to squeeze out every ounce of performance? That's where some of Rust's lesser known string types come into play. Let's dive into these hidden gems and see how you could take advantage of them. String slices are most often represented like this, an immutable reference to a sequence of UTF8 encoded bytes. However, it is possible to create a mutable reference. This allows you to directly modify the contents of a string slice while ensuring memory safety and UTF8 compliance.
00:13:47.943 - 00:14:38.219, Speaker A: Although rare, this is useful for in place string transformations without needing to allocate new memory for a separate string. In this example we have a function called anonymizeemails, which takes a mutable string slice as input and uses a regular expression to find email addresses within the string and then replace them with asterisks. Note that we're using some unsafe code here, and that's because we're calling asbytes mute, which returns a mutable byte slice. It's our responsibility to ensure that those bytes are valid UTF8 even after being modified. Mutable slices are generally avoided in idiomatic Rust code due to the complexities and potential pitfalls around ensuring that the Data remains valid UTF 8. However, you may see this type used in low level libraries or in code that needs to be aggressively optimized. Another specialized string type you might come across is the cow Enum.
00:14:38.219 - 00:15:13.575, Speaker A: COW stands for copy on write. This type is useful when you have a function that sometimes modifies a string and other times doesn't, and you want to avoid making a new allocation in cases where no modification is necessary. For example, let's say you have a function that takes a string and returns a sanitized version of it. If the input string doesn't contain any blacklisted words, then you can return it directly without allocating a new string. In this case, we're returning the COW borrowed variant, which is essentially a zero cost operation. Otherwise we create a new sanitized string and return that. In this case it's the COW owned variant.
00:15:13.575 - 00:16:04.719, Speaker A: So far we've discussed how Rust utilizes its robust type system to ensure string safety. We've also explored the two main string types in Rust and examined a variety of other string types designed for efficiency and flexibility. Now let's talk about a special group of string types that deal with interoperability. These types abstract away differences between operating systems and help connect your Rust code with other languages. For example, the OSString and OSSTR types in Rust are useful for handling strings in a way that is compatible with operating systems. Unlike strings and string slices, which are guaranteed to be UTF8 encoded, Ostring and OSS STR can contain any sequence of bytes on Unix like systems, or any sequence of 16 bit values on Windows. This is useful when interacting with system calls that don't require strings to be UTF8 encoded.
00:16:04.719 - 00:16:42.839, Speaker A: For example, let's consider file operations. When reading the names of all files in a directory, you can't guarantee that every file name will be valid. UTF8 Using OSString, you can read these names even if they contain invalid UTF8 sequences. This allows you to handle non UTF8 file names gracefully. If the conversion to a regular Rust UTF 8 encoded string fails, we can still handle the OSS string value as needed. This is especially important for writing cross platform code, as different operating systems have different requirements and conventions for strings. Path and path buff are specialized strings in Rust for dealing with file system paths.
00:16:42.839 - 00:17:22.761, Speaker A: A path is an immutable view of a path similar to a string slice. It's used for reading or inspecting paths, and a path buff is a mutable and owned version of a path similar to the string type. It's used when you want to create or modify paths. These types are useful for interoperability because operating systems handle file paths differently. In this example, we use Path and Path buff to read the contents of a file. First we use the path type to reference a directory, and then we pass it into the Read file function, which uses the path buff type to construct the full path to the file within the directory. We then pass this full path to the file open function.
00:17:22.761 - 00:18:03.123, Speaker A: Lastly, we have the C STR and CSTRING types, which is useful when you're interfacing Rust code with C libraries that expect null terminated strings. These types provide a safe way to handle C compatible strings. For example, let's say we wanted to call the get environment function from the C standard library which fetches the value of an environment variable. This function accepts a C string as input and returns a C string as output. To call it, we first create a null terminated C string containing the environment variable name path. Then we call the get environment C function using a pointer to the C string. This function returns a pointer to a null terminated array of characters.
00:18:03.123 - 00:18:35.617, Speaker A: We take this pointer and convert it to a C STR instance. And finally we convert the C STR to a regular Rust string slice, ensuring that the Data is valid. UTF8 by using CString and C Str, you can safely pass string data back and forth between Rust and C functions, ensuring that the null terminator expectations of C are upheld. We've covered a lot in this video, so let's do a quick summary. Rust ensures string safety in three key ways. Firstly, Rust string types do not use a null terminator. Instead, the strings length is stored in the type.
00:18:35.617 - 00:19:09.625, Speaker A: Secondly, strings in Rust are guaranteed to be valid UTF 8, and thirdly, strings in Rust are immutable by default. Rust has two main string types. String is a heap allocated growable UTF 8 encoded string. It's an own type, meaning that it's responsible for cleaning up the underlying string data, which is done automatically when the string variable goes out of scope. The string type is used to create or modify strings at runtime. Its counterpart are string slices. A string slice is a view into a string or part of a string which could be allocated on the heap, the stack, or or in the compiled binary.
00:19:09.625 - 00:19:45.886, Speaker A: String slices are represented as a reference to the STR type. STR represents a sequence of UTF A encoded bytes of dynamic length. Because STR size cannot be known at compile time, it must be used behind some type of pointer, which in this case is a reference. This is a borrowed type because it doesn't own the underlying string data, it simply has access to it. String slices are used to read and analyze strings. String literals in Rust are string slices with a static lifetime. In most cases, you don't have to explicitly write out the static lifetime because the compiler will automatically infer it, but there are cases when you do need to specify it, e.g.
00:19:45.886 - 00:20:46.119, Speaker A: instruct or enum definitions 99% of the time the STR type will be behind a reference, but you could also wrap it in other pointer types. For example, a box str represents an owned non growable heap allocated string slice. This type is used to freeze a string to prevent further modifications or to save memory by dropping the extra capacity information the string type stores. Using the RC Smart pointer allows you to share ownership of an immutable string slice across multiple parts of your program without cloning the actual string data, and using the ARC Smart pointer allows you to have an immutable string slice that you can share across multiple threads without having to clone the string data. Strings in Rust can be represented as a vector of bytes or a slice of bytes, which is useful for non UTF a encoded strings String literals have a few special formats. Raw string literals allow you to include special characters like double quotes within a string without needing to escape them. This is useful when writing regular expressions or defining a JSON object as a string literal.
00:20:46.119 - 00:21:31.397, Speaker A: Byte strings allow you to represent a string literal as a slice of bytes, which is useful when dealing with network protocols that expect byte sequences like the HTTP protocol, and you can combine raw string literals and byte strings to create raw byte strings. Rust also has a couple of specialized string types. Mutable string slices allow you to directly modify the contents of a string slice. This is useful for in place string transformations without allocating new memory for a separate string. Another specialized string type you may come across is the cow enum, which stands for copy on write. This type is useful when you have a function that sometimes needs to modify a string and you want to avoid making a new allocation in cases where no modification is needed. Lastly, we have strings that facilitate interoperability.
00:21:31.397 - 00:22:02.835, Speaker A: OSString and OSS are useful for handling strings in a way that is compatible with the operating system. These types are used to interact with system calls that don't require strings to be UTF 8. Encoded path and path Buff are used to handle file system paths in an OS agnostic way. Finally, C STR and C string are useful when you're interfacing Rust code with C libraries that expect null terminated strings. If you want to see more Rust content like this, make sure to hit the subscribe button. Hope you've enjoyed the video and remember to stay rusty.
