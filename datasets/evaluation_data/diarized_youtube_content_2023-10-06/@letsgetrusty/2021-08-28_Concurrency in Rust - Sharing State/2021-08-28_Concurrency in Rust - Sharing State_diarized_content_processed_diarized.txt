00:00:00.440 - 00:00:42.288, Speaker A: Welcome back Rust Gang. If you're new here, my name is Bogdan and this channel is all about the rust programming language. Today we're continuing our series on fearless concurrency in Rust. Last time we talked about transferring data between threads using message passing, and in this video we're going to talk about transferring data using shared state. You can think about shared state concurrency as one way data flow. One thread passes a message to another thread and then that receiving thread now owns the data. With shared state concurrency, on the other hand, we have some piece of data in memory that multiple threads can read and write to, and rust gives you the flexibility to pick between these different approaches.
00:00:42.288 - 00:01:24.464, Speaker A: So with that background, let's get rusty. The first thing we'll talk about are mutexes. Mutex is an abbreviation for mutual exclusion. A mutual exclusion means that you have some piece of data and only one thread could access that piece of data at any given time. To achieve this, mutexes use a locking system. When a thread wants access to a piece of data behind a mutex, it will signal that it wants access to that data and acquire the mutex's lock. The lock is a data structure that keeps track of which thread has exclusive access to a piece of data.
00:01:24.464 - 00:02:14.180, Speaker A: Once a thread has acquired a lock on a particular piece of data, no other thread can access that data. Once the thread is done with that piece of data, it can unlock the data and allow other threads to have access to it. Now, mutexes have a reputation for being hard to manage because you have to remember two rules. One is that you have to acquire a lock before you have access to data, and two, you have to release that lock when you're done with the data so that other threads can have access. Now this is a pain point that might lead people away from using this approach, but fortunately rust type system and ownership rules guarantee that you can't get locking and unlocking wrong. Let's jump into an example by creating a mutex. The first thing we need to do is import mutex from the standard library.
00:02:14.180 - 00:03:03.834, Speaker A: Then in main let's create a new mutex that holds the integer five, just like with many other types. To create a new mutex we call the associated function new and then pass in the data we want to store. Alright, next let's access the data in our mutex. First we'll create an inner scope. Then we'll create a variable called num and it's going to be mutable and we'll set that equal to m dot lock. So we're acquiring a lock and then we'll call unwrap. Here we call the lock method to acquire a lock, and this will actually block the current thread until that lock is able to be acquired.
00:03:03.834 - 00:03:56.538, Speaker A: Now when we call lock, it returns a result type because if there's already a thread that has a lock to that data and that thread panics, then calling lock will fail. And in this case we call unwrap, which is saying that if lock fails, then panic. Notice here that the type system is making sure we call lock because m is not an integer, it's a mutex that holds an integer. So we can't directly manipulate that integer until we call lock. After calling lock and unwrap, we get a mutex guard smart pointer whose d ref trait points to the inner data of the mutex, which in this case is the integer five. Also, Mutex guard implements the drop trait such that when mutex guard goes out of scope, then it releases the lock to the data. This means releasing the lock will be done automatically for you so you don't have to remember.
00:03:56.538 - 00:04:31.956, Speaker A: All right, now that we got a mutable mutex guard, let's go ahead and manipulate the underlying data by using the dereference operator. Then at the end of main let's go ahead and print m. Next we'll run our program and as you can see, m now stores the value six. Next, let's talk about sharing a value between threads. We'll create a new mutex that holds the integer zero. And then we'll spin up ten threads that each increment the value by one. So at the end we'll have the number ten.
00:04:31.956 - 00:05:34.734, Speaker A: First we'll import thread from the standard library. Then we can delete everything in main and we'll start off by creating our counter variable. Next we'll create a mutable vector that stores all our threads. Then we'll add a for loop and inside the for loop create our threads. Here we're creating a variable called handle, which is going to be a new spawn thread, and within the spawn thread we get a lock to counter and then we increment our counter. We also use the move keyword to move our counter variable into the thread. We'll talk about the red squigglies in just a second, and then after a handle is created we append it to our vector of threads.
00:05:34.734 - 00:06:17.960, Speaker A: After creating our threads, let's join them all to the main thread and then print out the result of counter. All right, that completes our program, but let's go back to the error we saw above around the move statement. If I hover over, you'll see that the error states we cannot move counter because it has already been moved in the previous iteration. What we want here is to allow counter to have multiple owners, and if you recall from chapter 15, the way we did that was using the reference counting smart pointer. So let's go ahead and wrap counter in the reference counting smart pointer. First we'll import the reference counting smart pointer here. Then we'll go ahead and wrap counter in the RCSmart pointer.
00:06:17.960 - 00:07:06.752, Speaker A: Then inside our for loop we're going to create another variable called counter, which will shadow the counter defined in main, and we'll call RC clone. That should be it. But notice here we get an error, and if I hover over the red squigglies, you'll see that it states we cannot pass the RC smart pointer safely between threads. The RC smart pointer gives us the functionality we want, but unfortunately it's not thread safe. So what we want is something exactly like RC, but thread safe. Fortunately, the Rust standard library has the atomic reference counting smart pointer, which is exactly what we want. Atomics are a concurrency primitive, which you can learn more about by looking at the standard library documentation for this video.
00:07:06.752 - 00:07:47.854, Speaker A: All you need to know are atomics are like primitive types, except that they could be shared across threads. So let's update our example. To use the atomic reference counting smart pointer, first we'll need to update our import, and then everywhere we use the RC smart pointer, we're going to change it to arc. We can also remove this unused import, and just like that, our program is compiling. Let's go ahead and run our program, and as expected, the result we get is ten. You might have noticed that counter is immutable, but we're able to get a mutable reference to the value that it holds. And that's because mutex uses interior mutability.
00:07:47.854 - 00:08:42.842, Speaker A: In the same way that the Refcel smart pointer allows you to mutate a value that's inside an RC smart pointer, the Mutex smart pointer allows you to mutate a value inside the arc smart pointer. Also note that the Refcell smart pointer comes with the risk of creating circular dependencies, and the mutex smart pointer comes with the risk of creating deadlocks. We won't be discussing deadlock mitigation strategies in this video, but if that's something you want to see, leave a comment down below. The rust language itself provides few concurrency features, but it does give you the building blocks to create your own concurrency features or use concurrency features written by others. Two basic concurrency concepts provided to you as building blocks by the standard library are the send and sync traits. I won't be going into those traits in this video, but if you wanna see a future video diving deeper into concurrency, leave a comment down below. All right, that's it for this video.
00:08:42.842 - 00:09:01.680, Speaker A: If you enjoyed it, make sure to leave a like and if you wanna see weekly rust content, then make sure to hit subscribe. Also, I'm gonna be launching a rust cheat sheet which you don't wanna miss out on, so if you want access to that, make sure to click the link in the description and with that I'll see you in the next one.
