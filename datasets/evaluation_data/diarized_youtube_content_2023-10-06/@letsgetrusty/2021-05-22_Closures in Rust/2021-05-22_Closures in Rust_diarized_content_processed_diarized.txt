00:00:00.880 - 00:00:41.043, Speaker A: Welcome back, Rust gang. If you're new here, my name is Bogdan, and this channel is all about the Rust programming language. In the last video, we went over Chapter 12 of the Rustling Book, in which we created a CLI program. In this video, we're going over Chapter 13, specifically Part 1 of Chapter 13, in which we'll talk about closures. So with that, let's get rusty. First of all, what are closures? Closures are like functions, except that they're anonymous, meaning that they don't have names. They could be stored as variables and passed around.
00:00:41.043 - 00:01:38.935, Speaker A: They could even be passed in as input parameters to a function, and they capture the variables inside the scope in which they are defined. In order to better understand closures, we'll use them in the following example. Imagine you're building a backend for a fitness app, and the backend is built in Rust. The fitness app will generate customized workouts for a user based on various factors like their age, body mass index, workout preference, and intensity level. Now, the implementation of this algorithm doesn't matter so much. What matters is that part of this algorithm runs a calculation that is expensive and takes a few seconds to run. Here, we've simulated this calculation with a function called simulated expensive calculation, which takes in an intensity and then prints out Calculating slowly lets the thread sleep for two seconds and returns the intensity.
00:01:38.935 - 00:02:16.015, Speaker A: Now, here in main, we're simulating the code that will be called if the user wanted a new workout. We're calling generate workout, which is a function we haven't created yet. And Generate workout takes two parameters, the intensity a user has specified and a random number to provide some variety to the generated workout. Now, because we're not actually building the front end in this example, we'll pass in a simulated intensity of 10. And for the random number, we could use the RAND crate and actually generate a random number. But again, that's not our focus in this example. So we'll just set the random number to a hard coded 7.
00:02:16.015 - 00:02:46.513, Speaker A: Next, we'll define the generated workout function right underneath main. Our generate workout function takes in an intensity and random number. If the intensity is less than 25, we print out do x number of pushups and do x number of sit ups to figure out how many pushups and sit ups to do. We call our expensive calculation. If the intensity is over 25, then we go into the else clause. Here we check our random number. If it's exactly three, we print out.
00:02:46.513 - 00:03:14.939, Speaker A: Take a break. Otherwise we print out run x amount of minutes and again to calculate the number of minutes to run. We use our expensive calculation function. Now, this works, but it could use some refactoring. One issue is that we're calling our expensive function in multiple places. So if we change the way the function gets called, for example, if we add another parameter, then we have to change all the call sites. Also, we call our expensive function multiple times, unnecessarily.
00:03:14.939 - 00:04:00.045, Speaker A: For example, in this if block, we call our expensive function twice when we really only need to call it once, and then pass the return value to both these print statements. Now, this might be fine for normal functions, but remember, this is an expensive function which takes two seconds to run. So we want to limit the amount of times we call this function as much as possible. Let's fix these two issues by storing the result of our expensive function call inside a variable. So we'll create a new variable at the top of our function. We'll call it expensive result, and we'll set it equal to our expensive function call. Then we'll use our variable in all our print line statements.
00:04:00.045 - 00:04:46.305, Speaker A: Now, this takes care of our duplication issue. But now we have another issue. We're calling our expensive function in every single case here at the top, no matter what gets executed below, we're going to call our expensive function. But here you can see that if the random number is 3, we don't need our expensive function because we just simply print out this text. What we want is to define our code in one place, but only execute it when necessary. So let's try refactoring this using closures. Let's scroll back up to the top of our program, and instead of defining this expensive result variable, we'll define a closure.
00:04:46.305 - 00:05:37.183, Speaker A: Here we have a variable called expensive closure, which is equal to our closure. Now remember, closures are anonymous functions, and the difference between a closure and a function, or at least the main visual difference, is instead of the input parameters being inside of parentheses, they're inside of these vertical pipes. So here we have one input parameter, which is num, followed by brackets, which hold the body of our closure. And if our closure was only one line, then we don't even need the brackets. So inside our closure body, we execute our expensive calculation and then we return num. Finally, at the end, we need this semicolon here to finish off the let statement. Note that our expensive closure variable is not storing the return value of our closure, rather it's storing the closure itself.
00:05:37.183 - 00:06:27.013, Speaker A: Also note that the body of our closure is identical to the body of our expensive function defined up here. Now that our Closure is defined, we can call it inside our print line statements. As you can see, the syntax for calling our closure is similar to the syntax for calling a function. We specify our variable name, which holds our closure, followed by parentheses, and then pass in the input parameters. Now our logic is defined in one place, and we're only calling our expensive operation when needed. But we're back with an old problem, which is that in this if block calling our expensive operation twice, which isn't good. Now, we could fix this problem by storing the result of our expensive closure call at the top of this if statement.
00:06:27.013 - 00:07:12.123, Speaker A: But there's another way we could solve this problem, which we'll talk about in just a bit. Before we solve that problem, you might have noticed that we didn't have to annotate the type of our closures input parameter, nor did we have to annotate our closures return value. For regular functions, we would have to specify the type of our input parameters and the type of our return values. And that's because functions are part of an explicit interface exposed to users, so agreeing on the types being passed in and returned is important. Closures, on the other hand, are usually short and only relevant within a narrow context. So the compiler is able to determine the input parameter types and the return types. This is similar to how the compiler is able to determine the types of most variables.
00:07:12.123 - 00:07:59.369, Speaker A: Note that we could make the types explicit if we want, like so this makes the types explicit at the cost of being more verbose. Note that closure definitions could only have one concrete type inferred for each input parameter. For instance, here we have a variable called example closure, which is equal to a closure that takes an x and then returns x. Now, because the closure is used here on line 26 with a string, the compiler infers that the input parameter type is a string. But then right Underneath on line 27, we call our example closure variable with an integer. Now the compiler will complain and the arrow will say that we have mismatched types. We're expecting a string, but we get an integer.
00:07:59.369 - 00:08:50.309, Speaker A: So the way the compiler works is that the first type passed into our closure will be the concrete type of our input parameters. Now let's get back to the problem of calling our expensive closure twice in this if block. Again, we could solve this function by creating a variable at the top of our if block and just storing the result of our expensive closure and then using that result in both of these print line statements. But we're going to do something else. What we'll do is use the memorization pattern by creating a struct which will hold our closure and the result of our closure. Here I created a struct called cacher, right above our generate workout function. Now, in order to define structs, enums or even function parameters that use closures, we need to use generics and trait bounds.
00:08:50.309 - 00:09:38.031, Speaker A: Here our cache instruct is using a generic called t. And below we define a trait bound for a generic, and the trait we're using is fn, short for function. Now, without going into what the FN trait is, just know that it's provided by the standard library and all closures implement one of the three FN traits. One of them is fn, the other one is fn mute, and the last one is fn. Once we'll go into the differences between these three traits in just a bit. Here we added types to the FN trait to represent the input parameters of our closure, which is going to be one unsigned 32 bit integer and also the output parameters, which is going to be again an unsigned 32 bit integer. Then in the body of our struct we have two fields.
00:09:38.031 - 00:10:22.501, Speaker A: The first one is calculation, which will store our generic type. So calculation could be any closure that meets this tray bound up here. Then we have value, which is going to be an optional 32 bit integer, values optional because when our cacher is initialized it's going to be none. And then once we call our calculation, we'll store the return value inside of our value field. Note that regular functions also implement these three fn traits, so we can store a regular function inside our calculation field as well. Next I'll paste in the implementation block for a cache struct and we'll talk about it. Okay, let's walk through this.
00:10:22.501 - 00:11:14.305, Speaker A: We we have our implementation block for cacher, which has the same generic and trait bound as our cache struct. And then the first function inside is called new. New is a constructor function. It takes in a calculation which is of type t, our closure, and then creates a new cacher passing in the calculation and setting value to none. Then we have our value method, and it's a method because the first parameter is a reference to self, and in fact we have a mutable reference to self. The next parameter is arg, which is the argument we'll pass into our closure, and it's an unsigned 32 bit integer. The return type is also an unsigned 32 bit integer inside the value method, we're going to do a match expression on self value, so we're checking the self Value type.
00:11:14.305 - 00:11:55.391, Speaker A: And remember, self value is an optional type, and when we first create our cacher, it will be set to none. So we'll execute this none branch inside the none arm. We're creating a variable called V and setting it equal to the result of calling our calculation closure and passing in the arg variable. Then we're mutating the value field of the current cacher instance and setting it to sum passing in V. This is where the caching happens. We're caching the return value of our calculation inside the value field, and then we simply return V. Next, let's use our cacher struct inside the generate workout function.
00:11:55.391 - 00:12:49.475, Speaker A: But before we do that, let's first run our program. As you can see, our expensive closure was called twice. Once to calculate the number of pushups and the second time to calculate the number of situps. Let's make this more efficient by wrapping our closure definition up here inside our cache struct. Here we're calling the new function on our cache struct and passing in our closure, which will be set to the calculation field on our cache struct. Let's change our variable name to cached result. We'll also want to make our variable mutable because we'll be calling the value method, which will mutate our cache or struct.
00:12:49.475 - 00:13:48.309, Speaker A: Then, instead of calling expensive closure, we'll call cached result dot value. Let's go ahead and run our program again, and as you can see, this time we only call our expensive operation once. Now, caching values is generally a useful behavior, so we might want to use our cacher in different contexts. But there are two problems preventing us from doing this. Problem number one is calling our value method is going to return the same value no matter what the ARG input parameter is. For example, let's say the first time we call the value method, we pass in 1 as the value for arg. Because this is the first time we're calling the value method, Self value is going to evaluate to none.
00:13:48.309 - 00:14:42.785, Speaker A: So we'll go into the none branch and then call our closure with our arg, which is going to be equal to one. Then we'll take the resulting value and save it inside self value. Now imagine we call our value method again, but this time we pass in two as the value for arg. This time, self value already exists. So we'll go into the sum arm and just return the value stored in sum. This is problematic because argued to our closure, which means that it could change the resulting value coming from our closure but with our current implementation, value is always going to be equal to the result of calling our closure with the argument passed into the first call to value. What I'm basically saying is instead of caching one value, no matter what the argument passed in, is, we need to cache one value for each argument being passed in because the argument influences the value.
00:14:42.785 - 00:15:38.239, Speaker A: As an exercise, you can fix this implementation by storing a hash map instead of a single value. The keys of the hash map will be the argument passed into value, and the values in your hash map will be the result of calling the closure with the argument. Then, inside the body of this value method, you'll need to look up the arg inside your hash map, and if a value for that arg exists, then just simply return the value, and if it doesn't exist, run your expensive calculation and store the result inside your hash map. The second problem with our cacher implementation is that we're using hard coded types. For example, we're saying that our closure needs to accept an integer and return an integer, and our value needs to be an integer as well. To fix this, you can simply use generics instead of hard coded values. The last thing I want to talk about is capturing the environment with closures.
00:15:38.239 - 00:16:10.011, Speaker A: Unlike functions, closures have access to variables that are defined within the scope in which the closure is defined. Here's a simple example. At the top, we have a variable called X which is equal to 4. Then we have a closure called equal to X, which takes in a variable called Z and then returns a boolean. The boolean is going to be equal to this expression. Z is equal to X. Now, even though X is defined outside of our closure, our closure still has access to X because they're both defined within the same scope.
00:16:10.011 - 00:16:50.425, Speaker A: Then we define a variable called Y and set it also equal to 4. Finally, we call our closure passing in Y. The call to our closure is wrapped inside an assert macro, which will panic if the call to our function results in false. So let's go ahead and run our program, and as you could see, we did not panic. Now let's see what would happen if we use a function instead of a closure. So we'll change our equal to X closure into a function. Here you can see some red squiggly lines underneath X, and if I hover over, you can see the error is can't capture dynamic environment inside a function.
00:16:50.425 - 00:17:35.469, Speaker A: Use a closure instead. So the compiler is actually telling us to use a closure instead of a function. Because closures are able to capture their environment, they have to use extra memory to store that context. But because functions don't capture their environment, they don't incur the same overhead. Closures capture values from their environment in three ways, which directly map to the three ways a function could take in input parameters by taking ownership by borrowing mutably or by borrowing immutably. These three ways to capture the environment are encoded in the function traits we talked about earlier, which are fn once fnmute and fn. FNCE takes ownership of the variables inside the closures environment.
00:17:35.469 - 00:18:21.729, Speaker A: The once part of the name represents the fact that closures can't take ownership of the same variables more than once. So these closures could only be called once FN mutably borrows values, and fn immutably borrows values. When you create a closure, Rust infers which of these traits to use based on how you use the values inside closures environment. We could, however, force the closure to take ownership of the values it uses inside its environment by using the move keyword in front of the closure. This is mostly useful when you're passing a closure from one thread to another thread, so you can also pass the ownership of the variables from one thread to the other thread. For example, in this case X is equal to a vector. We have our closure which doesn't change.
00:18:21.729 - 00:19:12.103, Speaker A: Then we print X out, and then we have y equal to a vector as well. And then we call our closure again passing in Y and asserting that it returns true. Now, because inside our closure we're just evaluating x against Z, we're not taking ownership of X inside our closure. But again, we could force the closure to take ownership by specifying the move keyword in front of our closure definition. Now, our closure does take ownership of X, and we get an error in our print statement below the definition of our closure. If I hover over the red squigglies, you could see that it says we're using a borrowed value after it's been moved. This makes sense because up above our closure takes ownership of X, so we can't use X after it's been moved.
00:19:12.103 - 00:19:39.325, Speaker A: Down here. All right, that concludes part one of chapter 13 in which we covered closures. Now, I know closures could be difficult to digest, and we didn't go through all the possible ways to use closures. So if you want to see another video about closures with more examples, comment down below. And of course, if you enjoy this video, make sure to give it a thumbs up in the next video we're going over iterators. So if you want to be notified of that. Make sure to hit subscribe.
00:19:39.325 - 00:19:46.795, Speaker A: And with that, I'll see you in the next one sa.
