00:00:00.600 - 00:00:51.635, Speaker A: This is one of Rust's most complicated features, higher rank trade bounds, and it's a very important feature to understand for two reasons. First, you're likely to encounter it in the source code of popular Rust libraries like Serde, Tokyo, or Axum. Second, it will fundamentally change your understanding of how generics, traits and lifetimes work together in Rust. To make your life a living night. I mean to enable advanced generic programming techniques offering maximum flexibility now, part of what makes higher rank trade bounds difficult to understand is that the documentation for this feature is quite sparse. So in this video I'll explain what higher rank trade bounds are and how they're used in advanced generic code to create extremely flexible APIs. In order to understand hiring trade bounds, we must briefly cover traits, trade bounds and lifetime annotations.
00:00:51.635 - 00:01:30.195, Speaker A: Traits are similar to interfaces in other languages. They allow us to define shared behavior in an abstract way through functions and methods that types can implement. Traitbounds, on the other hand, allow us to combine traits with generics. This code gives us a compile time error saying the generic T does not implement the debug trait. The problem is our function accepts any generic type which may or may not be printable with debug formatting. The solution is to use trait bounds to limit the possible concrete types this generic will accept to only those types which implement the debug trait. In other words, this generic is bound by the debug trait, hence the name trade bounds.
00:01:30.195 - 00:02:18.493, Speaker A: It's important to know that we can also specify trade bounds using the where clause or the impulse syntax, which we'll see later in the higher rank trade bounds example. Higher rank trade bounds make use of two distinct types of generics in Rust. So far we've seen type generics which allow us to abstract over concrete types. But Rust also offers another type of generic lifetime annotations. Unlike type generics, which allow us to write code that can work with multiple concrete types, generic lifetime annotations are primarily used to express relationships between the lifetimes of references, which help the compiler ensure references remain valid while being used. Let's say we have a function that accepts a string slice as input and returns the first word in the slice. The compiler actually expands the function signature to this tick.
00:02:18.493 - 00:03:09.813, Speaker A: A is a generic lifetime annotation that creates a relationship between the lifetime of the input reference and the lifetime of the returned reference. The relationship states that the reference returned by this function must be valid for at least as long as the input reference is valid. This helps the compiler check for invalid references. If we made the lifetime of the returned reference longer than the input reference, the compiler would throw an error. In this case, my string will be deallocated at the end of the inner scope, so using the returned reference afterwards would be invalid. Rust compiler prevents this memory safety bug, and luckily for us, in most cases we don't even have to write generic lifetime annotations explicitly because the Rust compiler is smart enough to infer them. Now that we understand traits, trait bounds, and generic lifetime annotations, let's discuss higher rank trait bounds.
00:03:09.813 - 00:03:55.255, Speaker A: So far we've used trait bounds and lifetime generics separately. Higher rank trait bounds combine these concepts by allowing trait bounds to be higher ranked over lifetimes. In other words, it allows us to specify that a trait bound should hold true for all possible lifetimes. This is useful when expressing complex lifetime relationships. Here we have a trait called formatter that defines one function which accepts any type implementing the display trait and returns a formatted string. We'll implement this trait on the simple format struct, and then create a function which accepts a formatter and returns a closure that formats a given string using that formatter. Note that to return a closure we use the special FN trait to define the closure signature.
00:03:55.255 - 00:04:44.181, Speaker A: In main, we can create this closure and call it on both a string slice and a heap allocated string. If we look back at the apply format function, you'll notice that the return closure accepts a reference. The compiler infers the generic lifetime annotation for this reference, but if we were to write it explicitly, what would that look like? You may intuitively write it like this by defining a generic lifetime on the function apply format and assigning the generic lifetime to the reference. However, this code gives us a compile time error saying borrowed value may not live long enough. To understand this error, we need to break down the function signature of apply format. Tick A is declared as a generic lifetime parameter of the function, but it's not used in the input parameters. Instead, it only appears in the return type.
00:04:44.181 - 00:05:42.157, Speaker A: So what relationship does tick a create here? In this case, tick A establishes a relationship between the lifetime of the input reference that the return closure accepts and the lifetime of the closure itself. This relationship ensures that the closure returned by apply format can only be called with references that live at least as long as the closure itself. Going back to main, we can see that the closure is stored in the format function variable, which lives until the end of main scope. Values in Rust are dropped in the reverse order that they are defined. This means the string S2 will be dropped before the closure stored informat function once S2 is dropped, all references to S2 become invalid because the references are pointing to deallocated memory. So the lifetime of all references pointing to the string S2 will end when S2 is dropped. The problem is the closure stored informat function expects all references passed to it to live as long as the closure itself.
00:05:42.157 - 00:06:35.251, Speaker A: One way to get around this error is to define the format function variable after S2 has been created so that format function is dropped before S2. But this doesn't fix all permutations of this issue of the closure, outliving the references passed to it. For example, if we created an inner scope and called our closure with a reference to a string defined within that inner scope, we would get a similar compile time error saying borrowed value does not live long enough. In this case, S3 is dropped at the end of the inner scope, which isn't allowed because the reference to s3 will be invalid before the closure is dropped. Now this code is technically memory safe. However, it doesn't quite satisfy the lifetime constraint our code originally set, hence the compile time error. The core problem is that the lifetime constraint we originally set is too restrictive because of the way we've defined our generic lifetime annotation.
00:06:35.251 - 00:07:30.775, Speaker A: The lifetime of the reference passed to our closure is tied to the lifetime of the closure. What we really want is for our closure to work with references of any lifetime, and we can achieve this with higher rank trait bounds. Instead of defining the lifetime generic on the function, we'll use the for tick a syntax to make the FN trait bound higher ranked over lifetimes, meaning the return closure can work with string slices of any lifetime, as long as that lifetime covers at least the duration of the closures execution. With this simple modification, our code is now compiling just like lifetime generics. In many cases, higher rank trade bounds are not written explicitly because the compiler is smart enough to infer them. However, in some cases explicitly writing them out is required, which is why you'll likely run into them when looking through Rust crates that deal with complex generic abstractions. And now when you come across this syntax, you'll know what it means and why it's being used.
00:07:30.775 - 00:07:40.275, Speaker A: If you want to become a Rust developer, make sure to get your free 4 day training@letsgetrusty.com Bootcamp Hope you've enjoyed the video and remember to stay rusty.
