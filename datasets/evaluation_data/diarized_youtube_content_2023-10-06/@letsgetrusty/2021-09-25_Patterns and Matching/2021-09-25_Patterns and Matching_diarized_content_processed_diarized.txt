00:00:00.480 - 00:00:45.627, Speaker A: Welcome back, Rust gang. If you're new, my name is Bogdan and this channel is all about the Rust programming language. In today's video, we're starting chapter 18 of the Rustling Book, which talks about patterns and matching. Patterns are a special syntax in Rust for matching against the structure of types. A pattern consists of some combination of the literals, destructed arrays, enums, structs or tuples, variables, wildcards, and placeholders. These components describe the shape of the data we're working with, which we can then match against values to determine whether our program has the correct data to continue running a particular piece of code. Now that we have some background, we can talk about all the places patterns can be used.
00:00:45.627 - 00:01:31.555, Speaker A: So with that, let's get rusty. As discussed in chapter 6, we use patterns inside the arms of match expressions. For example, here we have an enum of different languages, and then at the bottom we create a variable called language set to English, and then we have a match expression on that variable. Match expressions are defined by the match keyword followed by the value we want to match on curly brackets, and then one or more match arms. Match arms consist of a pattern which maps to an expression. So here we're saying if this language variable is English, print this string. If it's Spanish, print this string, and if it's Russian, print this string.
00:01:31.555 - 00:02:09.157, Speaker A: One thing about match expressions is that they have to be exhaustive, meaning that every possible value for this variable has to be accounted for. This is why we get an error here saying that our patterns are non exhaustive because we're not accounting for the Japanese variant. We could fix this by adding a branch for Japanese. However, another way to fix this is using a catchall pattern. The catchall pattern is defined by using an underscore. What this means is that if we go through all of these arms and none of them match the variable, then we execute the last arm. One thing to know here is that the underscore doesn't bind to the variable we're matching on.
00:02:09.157 - 00:03:06.097, Speaker A: If we did want to bind to the variable we're matching on, instead of using an underscore, we can specify a variable name here. For example, we can say lang, and then we can use that variable inside our arm. What we're saying here is that if we go through all of these arms and none of them match, then whatever variable was used store in lang and print out unsupported language with the language being used. Another place you can use patterns is in conditional if let expressions. If you recall from chapter six, you can use if let Expressions if you want to match on some variable, but you only care about one case, here we have a piece of code that determines a user's authorization status, and it takes into account three variables. The first variable is called authorization status, and it's going to be an optional containing a string slice. Currently we set it to none.
00:03:06.097 - 00:03:51.899, Speaker A: Then we have a variable called is admin, which is going to be a boolean. Currently we set it to false. And lastly we have a variable called group id, which is going to be a result type containing either an unsigned 8 bit integer or an error. Here we set it to the result of parsing the string 34 into an integer. All right, let's go through the code which determines a user's authorization status. First we have an if let expression, and we're matching on the variable authorization status, which is an optional containing a string slice, and this is the pattern we're matching on. If authorization status is a sum variant, then we want to take the string slice stored inside the sum variant and map it to the status variable and then print out the status.
00:03:51.899 - 00:04:29.887, Speaker A: If authorization status doesn't match this pattern, for example, if it's a non variant, then we go into this else if block. If is administrative, Then we print out the authorization status is equal to admin. Otherwise we go into this else if let expression. So we're matching on group id, which is a result type. If the group ID is an okay variant, then we take the integer stored in that okay variant and map it to group ID. Then we check if the group ID is over 30, the authorization status is privileged. If it's equal or less than 30, then the authorization status is basic.
00:04:29.887 - 00:05:14.757, Speaker A: Note that because the variable inside our pattern is named the same as the variable we're matching on, the variable inside our pattern is going to shadow the variable we're matching on. At the bottom we have an else block. So if we don't go into any of these previous blocks, then we print out that the authorization status is guessed. The downside of if let expressions is that the compiler doesn't enforce that they're exhaustive. So, for example, here we can omit the else case and our program will compile just fine, even though this might introduce a defect similar to the if less syntax. The while let syntax allows you to run a loop as long as the pattern specified continues to match. In this example, we create a new vector and push three integers onto that vector.
00:05:14.757 - 00:05:44.075, Speaker A: Then we call while let and match on the result of calling stack.pop, which is going to return an Optional. If the return value is a sum variant, then we're going to take the integer stored inside the sumvariant and print it out. So first we're going to print out 1, then 2, then 3. Then when we get to the end of the vector stack, pop is going to return a non variant, so the while loop will exit. Another place we can use patterns is in for loops. Here we have a vector of characters a, b, and c.
00:05:44.075 - 00:06:18.443, Speaker A: And then we call for on v.iter. enumerate enumerate is going to return a tuple containing the index and value. And here we're using a pattern to destructure that tuple into two variables, index and value, and then print out the variables. You might be surprised to learn that patterns are used in let statements as well. For example, here we're declaring a variable called X and setting it equal to five. But if we were to describe the let statement more formally, it would look something like this. Let pattern equals some expression.
00:06:18.443 - 00:06:53.865, Speaker A: So here we're saying X is a pattern that matches any expression. In this case, our expression is 5, so we set 5 equal to x. Let's look at a slightly more complicated example. Here we have a let statement where the expression is a tuple and the pattern here deconstructs a tuple. Rust will compare this tuple to the pattern being used, and in this case they match because the tuple has three elements and the pattern has three elements as well. So 1 will bind to x, 2 will bind to y, and 3 will bind to Z. If the pattern did not match, we would get a compile time error.
00:06:53.865 - 00:07:48.451, Speaker A: For example, let's remove the last element in our pattern. Here we get an error saying that we expect a tuple pattern that matches three integers, but we get a tuple pattern that only matches two values, while the expression being evaluated has three values. If we wanted to ignore a value in the expression being evaluated, we can use an underscore like so here we're binding 1 to x, 2 to y, and then we're ignoring the third value. Lastly, function parameters could also be patterns. For example, here we create a tuple and then we call print coordinates, passing in a reference to that tuple inside our print coordinates function, we deconstruct our tuple into the variables X and y, and then print out the current location. And note that this also works with closures as well. The last thing I want to talk about is irrefutable and refutable patterns.
00:07:48.451 - 00:08:32.575, Speaker A: Irrefutable patterns are patterns that will always match. For example, Here X is always going to match no matter what the expression is. Refutable patterns might not match. For example, here we have a pattern that matches the sum variant. If if X is a nonvariant, which in this case it is, then this pattern will not match. It's important to note that function parameters, let statements and for loops only accept irrefutable patterns because the program can't do anything meaningful if the pattern fails to match. If let and while let expressions accept both irrefutable and refutable patterns, but you'll get a compiler warning if you use an irrefutable pattern, because by definition those expressions are meant to handle matching failures.
00:08:32.575 - 00:09:09.671, Speaker A: In general, you don't need to worry about the distinction between refutable and irrefutable patterns. However, you do need to be familiar with the concept of refutability so you can respond to compile time errors. Let's look at a couple examples at the top. Here we declare a variable called X and set it equal to none. Then we have the select statement which has a pattern that matches on the sum variant, and we set it equal to x. The problem here is that because X is a non variant, this will never match. And here you can see we get an error stating that let bindings require an irrefutable pattern, but the pattern we use here is refutable.
00:09:09.671 - 00:09:38.683, Speaker A: In the next example we have an if less statement and the pattern here is x, which will match any expression, so we'll always print x. This gives us a compiler warning. If I hover over, you can see that it states this pattern will always match. So the if let is useless. All right, that's it for this video about patterns. If you enjoyed it, then show that like button some love. And if you want to see weekly Rust videos, then hit subscribe and the notification bell to be notified when new videos come out.
00:09:38.683 - 00:09:52.045, Speaker A: Lastly, if you want access to a free Rust cheat sheet, which I know you do, then head over to www.letsgetrusty cheatsheet and with that I'll see you in the next one.
