00:00:00.400 - 00:01:07.475, Speaker A: What's up Rust Stations welcome back to let's Get Rusty, your number one resource for all things Rust. If you haven't already, subscribe to the channel for weekly Rust videos and get your free Yes, I said free Rust cheat sheet by heading over to LetsGetRusty.com Cheat Sheet in today's video, we're starting off a three part series going over the last chapter of the Rustling Book, which is going to have us build a multi threaded in this first video we'll build a single threaded web server. Then in the next video we'll turn it into a multi threaded web server. And finally in the last video, we'll talk about graceful shutdown and cleanup. So with that background, let's get Rusty the first step is to create a binary project and to do that, open up your favorite terminal and type in cargo new and then we'll call our project server. Then we can CD into our new directory and open it up in your favorite code editor.
00:01:07.475 - 00:02:18.675, Speaker A: Here I've opened up main rs. Now our server is going to be bare bones, meaning we're going to work directly with the HTTP and TCP protocols. TCP is a transport layer protocol describing how data is transferred from one computer to another, and HTTP is an application level protocol describing how the data is structured. So for example, if you had a client, say a web browser, requesting a webpage from a server, HTTP is going to describe the structure of the data the client is sending to the server and the server is sending back to the client so that both know how to interpret the data, and TCP is going to describe how to actually send that data from the client to the server or vice versa. Delving deep into the TCP and HTTP protocols is out of scope for this video, but if you would like to learn more, I'll link to some supplemental learning materials in the description. Given that background, the first thing we need to do is listen to TCP requests. So we're going to bring in the TCP listener struct from the standard library into scope.
00:02:18.675 - 00:03:01.575, Speaker A: Next we're going to create a new listener. To create a new listener we call the Bind associated function and pass in the IP address we want to bind on and the port number. In this case the IP address is going to be 127001, which is local host, and then the port is going to be 7878. You can use a different port number, but the Rustbook uses this port because it spells out rust. When typed on the telephone. Bind returns a result type. If this was a production server, we would want to handle that error case gracefully.
00:03:01.575 - 00:04:08.933, Speaker A: But because we're just doing this for practice, we're going to call unwrap, which means our program will panic if we get the error variant. Now that we have a TCP listener at this address listening for connections, let's go ahead and loop through the connections and print that we have a connection established. Here we call the incoming method on listener, which is going to give us an iterator over the connections being received on our listener in the form of a TCP stream. So here stream is going to be of type result containing either a TCP stream or an error inside our for loop, we're going to use shadowing to create another variable called stream, which is going to be set to stream dot unwrap. So we get the TCP stream or panic if there's an error, then we're simply going to print out connection established. All right, now let's actually run our program. We'll open up a terminal and type in cargo run.
00:04:08.933 - 00:04:32.845, Speaker A: Then we'll open up a web browser and navigate to the address we're listening on. A couple things to notice here. First, our string is printed out, meaning that we got a connection from our client. Secondly, the web browser is going to show some type of error here. It says safari can't open the page. Yours might say connection reset. And this is because our server is not actually returning any data.
00:04:32.845 - 00:05:05.505, Speaker A: And lastly, our string is printed out multiple times. That's because web browsers will retry connections when they fail. Now that we know our server is working, let's go back to the code. Also, you can shut down your server by pressing control C in your terminal. Next, we'll implement reading data from the TCP stream. The first thing we need to do is bring the TCP stream struct into scope. We'll also need to bring the IO modules prelude into scope.
00:05:05.505 - 00:06:15.331, Speaker A: Next, we'll create a function called handle connection, which will take a mutable TCP stream as input. In the for loop up above, instead of printing out connection established, we'll call our handle connection function and pass in the stream. Next, we'll implement the body of handle connection to read data from the TCP stream and print it out. First, we'll create a buffer to hold the data that is read. Next, we'll call stream read and pass in our buffer. All right, and I'm getting an error here saying that there's no read method on the struct TCP stream. And that's because I did one of the imports incorrectly.
00:06:15.331 - 00:07:03.097, Speaker A: With the IO prelude, we actually want to import the contents inside the Prelude module. All right. The last thing we want to do is print out the contents of our buffer. All right, let's go through this together. Firstly, we made the stream argument mutable, because the read method on stream takes a mutable reference to self. This is because when you're reading from a stream, some internal state gets modified. Inside our function body, we create a buffer that's going to be 1024 bytes long.
00:07:03.097 - 00:07:45.075, Speaker A: This is large enough to store the basic requests we're going to be working with. However, if this was a production server, you would want your buffer to handle requests of arbitrary size. Next, we call stream read and pass in our buffer, which will populate the buffer with data from the stream and read returns a result type. In this case, for simplicity, we call unwrap, so our program will panic if there's an error. Lastly, we print the contents of our buffer by calling the from UTF8 lossy function, which converts a slice of bytes to a string including invalid characters. What we pass in is a slice of our buffer spanning the entire buffer. Now that our handle connection function is fully implemented, let's run our program again.
00:07:45.075 - 00:08:24.709, Speaker A: Open up the web browser again and refresh the page. Going back to the terminal, we can see multiple requests being made. If I scroll up, you can see three GET requests being made to the root directory here, which indicates that the browser was in fact retrying failed requests. Let's look at the structure of the requests. The first line is called the request line, and it contains information such as the HTTP method used, the uri, which is similar to the URL, and the HTTP version number. Here we're seeing a GET request on the root path using HTTP version 1.1, even though it's not visible here.
00:08:24.709 - 00:09:02.627, Speaker A: The request line ends with a carriage return and line feed sequence, which is basically something that separates the request line from the rest of the request data. Underneath the request line, we have various request headers and then the request body. Since this is a get request, we don't have a body. All right, now we can shut down our server and talk about writing a response. Our response must be in the following format. First, we have the status line, which consists of the HTTP version, the status code reason phrase, and a carriage return line feed sequence. Next, we list the headers, followed by a carriage return line feed sequence, and finally the message body.
00:09:02.627 - 00:09:27.937, Speaker A: Here's an example of a request that contains no headers and no message body. First, we specify the HTTP version. Then the status code 200 is the standard status code for success. And then the reason phrase, which is going to be okay. And then we need two carriage return line feed sequences. A carriage return in line feed sequence is denoted with a backslash R followed by a backslash N. This is actually the response we want to return.
00:09:27.937 - 00:10:04.675, Speaker A: So let's go ahead and copy it and then delete this print line statement. Then we'll save the response in a new variable. Next we'll write our response to the stream. And finally we'll flush the stream. The write method accepts a buffer of bytes as an input. So here we can get that by calling response as bytes. Just like the read method, write returns a result type.
00:10:04.675 - 00:10:36.025, Speaker A: And here we're calling unwrap, which means our program will panic if we get an error variant. Flush will wait until all bytes are written to the connection and it also returns the result type. So we call unwrap again. With these changes, our web server is going to return a valid response. So let's run our web server again and refresh the web page. Now, instead of getting an error page, we get a blank page. So next let's implement returning valid HTML.
00:10:36.025 - 00:11:07.465, Speaker A: The first thing we'll do is create a new file called index HTML at the root of our project, not in the source folder. The root of our project. In this file you can place any valid HTML you'd like. Just make sure to have something visible in the body so we can see it on the web page. All right. Now we can modify our handle connection function to return this HTML page. First, we'll need to get the contents of our file and store it in a variable.
00:11:07.465 - 00:11:45.993, Speaker A: We'll also need to import the file system module. Lastly, let's update our response. Here we're using the format macro for string interpolation. Our response looks similar to the response before. But now that we're returning actual content, we need a content length header. The content length header specifies the amount of bytes we're returning in the message body. And in this case, we could get that number by calling the len method on contents.
00:11:45.993 - 00:12:23.573, Speaker A: Then we simply add the actual contents to the end of our response. Let's go ahead and run our server again and then refresh our web page. As you can see, our server is now responding with valid HTML. One problem here is that we're going to return this HTML for any request. So next let's validate the request that we're getting. First, let's create a variable hard coding the request line we're expecting. Notice that we're prefixing our string with this lowercase b, which will give us a byte array representing our string.
00:12:23.573 - 00:13:14.653, Speaker A: Next, we're going to check if the buffer starts with our expected string. If the buffer starts with the expected string, then we want to return our index HTML page. If the buffer didn't start with the string we expected, then we don't recognize the request. So we can return a 404 page. First, let's create the 404 HTML page. Then, in the else block, we're going to return the 404 page. This code is very similar to the code which returns index HTML.
00:13:14.653 - 00:13:50.153, Speaker A: We have a variable called status line which contains our 404 status. Then we extract out the contents of our 404 HTML page. Then we create our response which contains the status line length of our content and then the content itself. Finally, we write the response to the stream and then flush the stream. Let's test this out by running our server. If we reload the page, we still get the expected HTML. However, if we try to make a request to a different path, you can see that we get our 404 page.
00:13:50.153 - 00:14:38.475, Speaker A: Now that our server is working as expected, let's go back and do a little bit of refactoring. If we look at our if else branch, then the only two differences we can see between them are the status line and the HTML page we're rendering. So let's go ahead and simplify this code. First, we'll take the contents of the else block and move it outside of the if else statement. Then let's scroll up and copy the status code for our index HTML page and then delete the rest of this block. Now we want our if else expression to return a tuple containing two strings, the status line and the appropriate HTML page. Then we're going to take the return value and deconstruct it into two variables.
00:14:38.475 - 00:15:42.199, Speaker A: If the buffer starts with an expected request line, then status line is going to be a 200 and the file name is going to be index HTML. Otherwise, status line is going to be 44 and the file name is going to Be 44 HTML. Our status line variable is already being used in the response. So the last thing to do is replace this hard coded string with file name and that's it. You should be able to restart your server and have it work just as it did before, except now the code is a little bit cleaner. All right, that's it for part one of building a web server in Rust. In this video, we learned about TCP HTTP accepting an HTTP request and returning valid HTML data.
00:15:42.199 - 00:16:09.285, Speaker A: Currently our server implementation is single threaded. In part two we're going to talk about how to make it multi threaded and why we would want to do so. If you would like to see more project based videos, then leave a comment down below specifying what types of projects you would like to see. And finally get your free yes free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet. And with that said, I'll see you all in the next one.
