00:00:00.520 - 00:00:37.401, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In the last few videos we talked about references, smart pointers, how to create smart pointers, and the box smart pointer. Specifically, in this video, we're going to be talking about a reference counting smart pointer which allows us to share ownership of some data. So with that, let's get rusty. In the majority of cases, ownership is clear. You know exactly which variable owns a specific value.
00:00:37.401 - 00:01:10.765, Speaker A: However, there are cases where a single value has multiple owners. For example, let's say you have a graph with multiple edges that point to the same node. Conceptually, that node is owned by all the edges. In this case, a node should not be cleaned up unless it doesn't have any edges pointing to it. To enable multiple ownership of a value, we can use a reference counting smart pointer which will keep track of the number of references to a value. And when there are no more references, the value will get cleaned up. An analogy would be a TV in a living room.
00:01:10.765 - 00:01:44.249, Speaker A: When a person walks into the living room, they turn on the tv. As more people walk into the room, they start watching the tv. Then people start to leave. And when the last person leaves the living room, they turn off the tv. If the TV turned off while there were multiple people in the living room, there would be panic. The reference counting smart pointer is used when we want to allocate a value on the heap and have multiple parts of our program read that value. And we don't know which part of our program is going to finish using that value last at compile time.
00:01:44.249 - 00:02:37.605, Speaker A: If we knew which part was going to finish using the data last, we can simply make that part the data's owner and ownership rules would be enforced before we jump into code. One thing to note is that the reference counting smart pointer we use in this video is only useful in single threaded programs. In chapter 16, we'll talk about how to use reference counting in multi threaded programs. To demonstrate how the reference counting smart pointer works, we'll use the cons list example from the first video on smart pointers. If you haven't already, make sure to check that video out so you're up to date. As a quick refresher, you can think about a CONS list as a set of boxes with two cells. The first cell stores a value, in this case an integer, and the second cell points to the next box until we get to the end of the list, in which case the second cell points to nil.
00:02:37.605 - 00:03:16.365, Speaker A: In this case, what we want is to have two lists that both share ownership of a third list. So we have a list called B, a list called c, and they both point to a list called A. Here's that example written in code using the box smart pointer. First we have our list enum, which has two variants, cons and nil. Cons stores the value, which is an integer, and then points to another list. Then we bring our enum variants into scope and use them inside of main. First we create list A by creating new instances of the cons variant.
00:03:16.365 - 00:04:06.085, Speaker A: Think of cons as the box. The first cell is 5, and the second cell points to another box, in this case storing 10 and then pointing to yet another box which stores nil, signifying the end of our list. Then we create list B and c, which store 3 and 4 respectively, and point to list A. You might have noticed that on line 11 we have some red squigglys around the A variable, and if I hover over, you can see that the error states were attempting to use a value that's already been moved. The cons variants own the data they hold. So on line 10 we create a variable called B, and then we assign that to a cons variant passing in A, which means that B now owns A. In other words, A has been moved into B.
00:04:06.085 - 00:04:58.195, Speaker A: For this reason, we can't use a on line 11 when we try to create list c. Now, we could change the definition of the cons variant told references instead of owned values, but that would require the use of lifetimes. By using lifetime parameters, we would be specifying that every element in the list has to live at least as long as the entire list. The borrow checker wouldn't let us compile code like this, for example, because the temporary nil would be dropped before A could take a reference to it. Instead, we could change the cons variant of our list enumerated to use a reference counting pointer instead of a box pointer, like so. We'll also need to bring the reference counting smart pointer into scope. Then in main, instead of constructing instances of the box smart pointer, we'll construct instances of our reference counting smart pointer.
00:04:58.195 - 00:05:44.007, Speaker A: We'll also need to wrap the a list inside of a reference counting smart pointer because we're passing it in to B and C. Then to pass A into B and C, we'll call RC colon colon clone and pass it a reference to A.RC colon colon clone doesn't make deep copies of the data like most clone implementations. Calling clone here only increments the reference count. Note that Another way to do this is to call a clone. In this case, however, it's convention to use the first syntax. Let's go through what's happening here.
00:05:44.007 - 00:06:16.865, Speaker A: We have list B and C, and we want both of these lists to point to list A. Now, we can't just pass in a reference to A here because what we expect is an own type. So we'll get a mismatch types error. We also can't pass an A directly because that would move ownership of A into B. And then we're left with our previous error, which is that we can't borrow a value that's already been moved. So the solution here is to use the clone method, which will give us back an owned value. However, in this case, clone does not deep copy the data.
00:06:16.865 - 00:06:54.627, Speaker A: Instead it just increases the reference count. Here I've modified main a bit so we can see how the reference count changes over time. First we create list A and then we print out the reference count. Then we create list B and print out the reference count again. Then we create an inner scope and inside the inner scope create list C and then print out the reference count another time. Finally, outside of the inner scope, we print out the reference count one last time. Note that to get the reference count, we're calling strong count instead of just count because the RC type also has weak count, which we'll learn about later in this chapter.
00:06:54.627 - 00:07:15.715, Speaker A: Let's go through this code and see what the expected behavior is. On line 11, we create list A. So when we print the reference count right below, it should be one. Then we create list B and print out the reference count again. At this point it should be two. Then inside an inner scope, we create list C and print out the reference count. So at this point it should be three.
00:07:15.715 - 00:07:46.725, Speaker A: Now, because C is defined within this inner scope, when the interscope ends, C should be dropped, meaning that the reference count will decrease. So on line 19, the reference count should be back to two. Let's go ahead and run our program to confirm. First, after creating list A, our reference count is 1. Then after creating list B, our reference count is 2. Then after creating list C, our reference count is 3. And when C goes out of scope, our reference count is back to two.
00:07:46.725 - 00:08:21.831, Speaker A: When we get to the end of main, A and B will both be out of scope, meaning that the reference count will be zero and and thus the smart pointer will be cleaned up. Note that the reference counting smart pointer only allows multiple parts of your program to read the same data, not modify it. If the reference counting smart pointer allowed multiple mutable references, we would be violating the borrowing rules. But mutability is useful, and that's where the interior mutability pattern comes into play. And we'll talk about that in the next video. That's it for this video. If you enjoyed it, make sure to smash that like button.
00:08:21.831 - 00:08:29.655, Speaker A: And if you want to be notified when the next video comes out, make sure to hit subscribe. And with that, I'll see you in the next one.
