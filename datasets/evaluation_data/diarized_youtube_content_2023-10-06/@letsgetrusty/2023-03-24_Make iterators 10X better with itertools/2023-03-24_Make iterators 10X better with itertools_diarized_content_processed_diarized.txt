00:00:00.280 - 00:00:47.470, Speaker A: Rusts type system has a lot of great things to offer, powerful enums, pattern matching, and the traits system, to name a few. But another great feature of rust that sometimes gets overlooked is its first class support of the iterator pattern. Any type can implement the iterator trait defined in the standard library, which only requires implementing the next method. Then the type gets access to a wide range of methods for working with iterators such as map, foreach, fold and more, and the type will automatically work with for loops. Best of all, iterators are a zero cost abstraction, meaning they don't incur additional runtime overhead. As powerful as iterators are in rust, sometimes you want some extra functionality that is not included in the standard library. That's where the iter tools crate comes in.
00:00:47.470 - 00:01:31.780, Speaker A: Itertools provides extra iterator adapters, methods, functions, and macros. Let's go through an example of how we can use iter tools to make iterators even more powerful. Before we get started, make sure to get your free rust cheat sheet@letsgetrusty.com cheatsheet here we have a sample project defined and what we want to do is parse these two Apache log files. Each log file contains four requests with a simplified format. Each logline contains the request IP address, a timestamp, the request that was sent, the response status code, and the size of the response body. These log files also contain duplicate lines, as you can see here, and the lines are out of order.
00:01:31.780 - 00:02:24.700, Speaker A: We will have to fix both issues when parsing the log files. Alright, let's look at the existing code predefined for us. Main Rs contains an empty main function and defines two modules, file and log. The file module contains a helper function which will return an iterator over lines read from a file on disk. The log module contains a struct called Apache log entry which represents a single entry in the log file. There are several traits implemented, including partial equal equal hash order and partial order, which will help with sorting and de duplicating the entries later on. The try from trait is also implemented so that we can convert a string slice into an Apache log entry.
00:02:24.700 - 00:03:42.444, Speaker A: And lastly, we have one test function to make sure that the triform tray is working correctly. In main, what we want to do is parse the log files into a series of Apache log entry structs, merge the log entries from both files, de duplicate the log entries, and sort them. The first thing we'll do is read the log files and get an iterator over the individual lines well also need to import readlines from the file module. Next we're going to take these two iterators over lines and turn them into iterators over Apache log entries, and we'll need to import Apache log entry. All right, there's a lot going on here, so let's go through it together. The first thing we do is call filter map on our iterator because we want to both filter out any lines that could not be read and map each line to an Apache log entry struct. Filter map accepts a closure which it's going to execute for each line.
00:03:42.444 - 00:04:36.098, Speaker A: The closure accepts one parameter which is going to be the line, and it's a result type containing either the line string or an error. The filter in filter map works on option types by filtering out the non variance. So the first thing we're going to do is take our result type and turn it into an optional using the okay method. If l was an error variant, it would be turned into a non variant and then early returned using the question mark operator. If we get the sum variant, however, we're going to call as ref because the try into implementation for Apache log entry expects a string slice, we have to use this long piece of syntax here to specify that we're calling try into for the Apache log entry struct. In this case. I'm not sure there's a more concise way to do this, but if you know of one, leave a comment down below and finally try into can fail, so it returns a result type which we call okay on to turn it into an optional.
00:04:36.098 - 00:05:21.910, Speaker A: Then we simply return that optional. With this little bit of code we were able to turn an iterator of lines into an iterator of Apache log entries, and so far we've been able to do this using the iterator methods in the standard library. Next we want to merge these two iterators, de duplicate the entries and sort them. Doing this with the iterator methods in the standard library would not be straightforward. So let's import the iter tools crate to help us out. Then well import the itertools trait. Itertools uses the extension traits pattern to extend the iterator trait in the standard library, adding a lot of useful methods.
00:05:21.910 - 00:06:09.510, Speaker A: Just by bringing this trait into scope, our iterators have access to new methods. Here we called the merge method from itertools to merge log one and log two. Then we called unique to deduplicate the entries and sorted to sort the entries. Finally, we called Collectvec to turn the iterator into a vector. Lets print out the results and run the program. Here we can see the list of Apache log entries printed out with pretty formatting. There were two duplicate requests that were removed, leaving us with six requests, and by looking at the timestamps we can see that they are in order.
00:06:09.510 - 00:06:39.050, Speaker A: Besides the methods used here, iter tools offer a lot of other useful methods such as interleave permutations and map into check out the crates documentation for more details. That's it for this video on the iter tools crate. Before you go, make sure to get your free rust cheat sheet@letsgetrusty.com. cheatsheet if you enjoy this content, make sure to like the video and subscribe to the channel for weekly rust videos. With that said, ill see you in the next one.
