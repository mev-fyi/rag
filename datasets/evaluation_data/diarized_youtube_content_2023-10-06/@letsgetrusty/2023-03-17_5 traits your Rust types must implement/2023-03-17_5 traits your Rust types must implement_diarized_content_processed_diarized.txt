00:00:00.280 - 00:00:49.474, Speaker A: Five standard library traits your rust types should absolutely implement, especially if you're exposing your types as part of a public interface. You see, the rust orphan rule states that you cannot implement a foreign trait on a foreign type. This means users of your library will not be able to implement these traits themselves unless they create a wrapper type, which is annoying. Also, they may not even be able to write a reasonable implementation without access to the types internals. The last thing you want is for someone to try using your rust library and give up on life. These five traits provide basic functionality that rust stations expect your types to have, and fortunately for us, they can all be derived. At the end of the video, I'll go over a 6th trait your types should absolutely implement that is not part of the standard library, so make sure to stick around for that.
00:00:49.474 - 00:01:33.092, Speaker A: Before we get started, make sure to get your free rust cheat sheet by heading over to let'sgetrusty dot forward slash cheat sheet imagine we're creating a rust library that exposes a public type called user. User is a struct with three id, name, and role. In main, let's simulate how this type could potentially be used by users of our library. First, we'll create a user type. Then we'll print it out with the debug formatting. Debug formatting can be very useful. For example, let's say an error occurs, so we want to print out that error with debug formatting, and also print out the user struct to give some extra context.
00:01:33.092 - 00:02:15.910, Speaker A: Unfortunately, we get a compile time error. User cannot be printed out using debug formatting because it doesn't implement the debug trait. The error message suggests that we derive this trait, which is exactly what we're going to do. We'll also need to implement debug for the role enum. The next thing users of your library will likely want to do is make copies of your types. This can be done using the clone method. Here we get a compile time error, which states that no method named clone is defined on the user type, and that's because we need to derive the clone trait.
00:02:15.910 - 00:03:09.246, Speaker A: The third thing users of your library will likely want to do is create instances of your types with default values. This can be done using the default associated function, just like with clone. In order for this function to work, we need to derive the default trait. When we derive the default trait, default values will be given to types where a reasonable default exists. For example, an unsigned 32 bit integer will default to zero, and a string type will default to an empty string. For enums, a reasonable default does not exist, so we have to specify one using attributes. In this case, we're saying the guest variant is the default.
00:03:09.246 - 00:03:53.646, Speaker A: You can also have a custom implementation of default. For example, maybe you don't want the id to default to zero, or the name to default to an empty string, but in our case, because the default role is guest, these values are fine. The next thing users of your library will likely want to do is compare instances of a given type. This is especially useful when writing tests. To make this functionality work well, need to implement the partial equal trait. This gives us the basic ability to compare instances of this type. However, there are also some related traits which give you more functionality.
00:03:53.646 - 00:04:28.802, Speaker A: Those are partial order, hash equal, and order. Take a look at the documentation for these traits to see if they apply for your use case. The next set of traits your type should implement is send and sync. Send is implemented if your type is safe to send between threads, and sync is implemented if your type is safe to be shared between threads via references. The good news is these are auto traits, which means they are automatically implemented for your types. But there's a caveat. These traits are automatically implemented unless your type contains a value which is not send or sync.
00:04:28.802 - 00:05:37.560, Speaker A: For example, let's say we added a new field to user which held a reference counted type. Here we have a field called db which holds a shared reference to a database instance. The problem is the RC smart pointer is neither send or sync. This means our user type is no longer send or sync either. This is bad because users of our library can no longer send this type between threads. To fix this issue, instead of using the reference counted smart pointer, we can use the atomic reference counted smart pointer arc is send and sync, so our type can once again be passed between threads. But as you just saw, it's really easy to add a type which is not send or sync.
00:05:37.560 - 00:06:19.092, Speaker A: So how can we prevent against this? John Jensen set in his book rest for rustations, which I highly recommend you read, gives us a clever trick. First, well implement a function called isnormal. Then we'll create a simple test function. Isnormal defines a generic type t, which must implement the send and sync traits along with sized and unpin. These are all auto traits that normal types should implement. Notice that t is not used anywhere in this function, and that's completely fine. All we're going to do in our test is call that function replacing t with the type we want to test.
00:06:19.092 - 00:07:05.842, Speaker A: What this will do is make sure that user implements these four traits. Let's see what happens if we revert back to using the RC smart pointer. As you can see, we now get a compile time error which states that RC cannot be sent between threads safely. We didn't even have to run this test because these trait bounds are checked at compile time. Alright, let's switch back to using the arc smart pointer. Lastly, let's talk about a set of traits your types should definitely implement that are not in the standard library. Those traits are serialize and deserialize from the Serde crate.
00:07:05.842 - 00:07:58.340, Speaker A: This will allow your type to be serialized and deserialized in common formats, for example JSON. To implement these traits, we must first add the serde crate as a dependency. We'll also add a dependency on serde JSON. Now we can derive serialize and deserialize from serda. First we have to import the crates, then we'll add them to role and user. Here we get an error because this type does not implement the deserialized trait. Now we could fix this, but in this case we don't need to serialize this field, so we're going to go ahead and skip it by adding a attribute.
00:07:58.340 - 00:08:49.454, Speaker A: Great, our type can now be serialized and deserialized. Let's see how that works in main. First we'll create a JSON string, then we'll deserialize the string to a user type, and finally print user with debug formatting. Great, everything works as expected. One last thing to mention here is that you probably don't want to implement serialize and deserialize by default. Even though this is very common and useful, some users don't need this functionality. Typically, libraries will gate this functionality behind a feature flag.
00:08:49.454 - 00:09:20.220, Speaker A: That way users only take a dependency on serde if the functionality is needed. Let's see how this works. First we're going to open up cargo toml and make surday an optional dependency. Then we'll add a new feature called Serday. When this feature is enabled, the Serde dependency will be included. Finally, in main, we'll gate our code behind the new feature flag. First we'll gate importing deserialize and serialize using a config expression.
00:09:20.220 - 00:10:17.640, Speaker A: Then we'll gate implementing deserialize and serialize using a config attribute expression, and we'll do the same thing for the user type. And finally well gate the use of serde JSON in main. Then if we run the code without any features enabled, we only get one print line statement. But if we enable the Serde feature, we get the second print line statement. With these traits implemented, your type is now ready to be shared with the world. That's it for this video. Before you go, make sure to get your free rust cheat sheet at let's get rusty.com
00:10:17.640 - 00:10:27.300, Speaker A: cheatsheet. If you enjoyed the video, make sure to give it a like and subscribe to the channel for weekly rust content. With that said, I'll see you in the next one.
