00:00:00.440 - 00:00:39.457, Speaker A: Welcome back, Rust gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In the last video, we talked about characteristics of object oriented programming languages and how they apply to Rust. Rust doesn't support classical inheritance. However, it does achieve polymorphism, which is the ability for code to work on multiple types of data through trait objects. So in this video, we're going to talk about trait objects, what they are, how they're used, et cetera. So with that, let's get rusty to learn about tray objects.
00:00:39.457 - 00:01:37.299, Speaker A: Let's talk about a hypothetical situation. Imagine you're building a GUI library or a graphical user interface library. The goal of this library is to take in a list of visual elements, such as buttons, text boxes, sliders, et cetera, and be able to draw them to the screen. In addition, we would like users of our library to be able to extend our library, meaning that they could create their own visual components that are able to be drawn to the screen. This means at compile time we won't know the full breadth of objects that are going to be used. However, we do know that all of these visual objects are going to have a method called draw, which we can execute. If we were using a language with classical inheritance, we might create a base class called Visual component, which has a draw method, and then other visual components, such as buttons, text boxes, sliders could inherit from that class and thus inherit the draw method.
00:01:37.299 - 00:02:01.893, Speaker A: They could also overwrite the draw method with their own implementation. In Rust, we define shared behavior using traits. So let's go ahead and create a trait called draw, which has one method, also called draw. Here I've created a new project with a main.rs file that just has an empty main function. And then I've also added lib.rs, which is where we're going to be writing all our library code.
00:02:01.893 - 00:02:51.663, Speaker A: All right, the first thing we're going to do is define a public trait called draw. Then we'll define a function called draw, which takes a reference to self. That's it for our trait. Next, we'll define a struct called screen, which will hold a list of drawable components. We're going to have one public field called components, and that's going to be a vector. Our vector is going to contain a box smart pointer, and then our box smart pointer is going to contain any type that implements the draw trait. Here we have a vector of trait objects.
00:02:51.663 - 00:03:51.945, Speaker A: We define a trait object by first specifying some sort of pointer, such as a reference or a box smart Pointer, then using the DIN keyword followed by the relevant trait. The DIN keyword stands for dynamic dispatch, and later on in this video, we'll talk about the difference between static dispatch and dynamic dispatch. Also in chapter 19, we're going to go over why tray objects need to use some sort of pointer. Now that we've defined our tray object, Rust will ensure at compile time that any object in this vector implements the draw trait. Now that we have a vector of components, let's create a new implementation block for our screenstruct with one method called run, which will iterate through our components and draw them to the screen. We'll use the impulse keyword. Then we'll create a new public function called run, which will take a reference to self, and it's not going to return anything inside our method body.
00:03:51.945 - 00:05:12.981, Speaker A: We're going to iterate through our components vector, and for each component we're going to call the draw method. At this point we have a screenstruct which has a vector of components, and those components could be anything that implements the draw trait. We also have a method called run, which will draw all of our components to the screen. One thing you might be asking yourself is why not use generics instead of trait objects like we do here? Well, let's comment out this implementation and paste in the generics implementation, and then talk about the differences here. Our screenstruct has a vector of components, and that vector stores a generic type T. Note that we also have a trait bound here, meaning that T has to be something that implements the draw trait. Now, you might be thinking this is exactly the same functionality as our trait object implementation, but there is one crucial difference, which is that when you use generics, you're limited to one type, meaning that our screen component could store buttons, it could store sliders, it could store text input fields, but it can't store a mixture of the three.
00:05:12.981 - 00:06:02.155, Speaker A: So, for example, we can have a list of buttons mixed in with sliders mixed in with input boxes. The list has to be homogeneous. So if your list is homogeneous, meaning that you only store buttons, or you only store text input fields, then using generics with trait bounds is preferable because there is no runtime cost. However, if you need the flexibility to store any type that implements a certain trait, then you'd want to use trait objects, which do have a performance cost, which we'll talk about later in this video. Now let's implement some drawable components. The first one we're going to implement is a button component, so we'll create a new struct called button, and it's going to have three fields. First it's going to have a width, which is going to be an unsigned 32 bit integer.
00:06:02.155 - 00:06:45.049, Speaker A: And then it's also going to have a height, again an unsigned 32 bit integer. And finally it's going to have a label which is going to be a string. Then all we have to do is implement the draw trait for our button. Note that the goal of this example is to learn about trait objects, not actually implement a GUI library. So we're just going to leave a comment here instead of an actual implementation. Note that each drawable component could have whatever fields are relevant to that component. For example, these are the fields relevant to the button component.
00:06:45.049 - 00:07:26.249, Speaker A: But a text input component might have a text field, for example, that stores user input. Also note that each drawable component can have custom functionality. They all have to implement the draw trait and have the draw method defined, but they can have other methods defined as well. For example, for the button component, we might have an onclick handler, which is a function that does something when the user clicks a button. So far we have a GUI library that can draw components to the screen, and our library has one component defined, which is the button component. Next, let's talk about how consumers of our library could define their own drawable components. First we'll go to main RS and import the draw trait from our GUI library.
00:07:26.249 - 00:08:25.165, Speaker A: We'll type in use and then the name of our library. In my case it's guillib and then colon Colon draw. Now that the draw trait is in scope, let's define another drawable component called select box. This component is also going to have three fields. The first one is width, the second one is height, and the last one is called options, which is going to be a vector of strings. Next we'll implement the draw trait for our select box component. Now that we've defined our custom drawable component, let's use our GUI library inside of main.
00:08:25.165 - 00:09:08.555, Speaker A: First, I'll change this use statement up above to also import screen and button. Then inside of main, let's create a new variable called screen, which is going to be an instance of our screenstruct. The screenshot has one field called components, which is going to be a vector. Next we'll add components to our vector. Remember that each component has to be within the box Smart pointer. So let's create a new box Smart pointer Instance. Our first component is going to be a select box.
00:09:08.555 - 00:10:19.803, Speaker A: We need to specify a width and also a height and then options. Next we'll add a Button component. Again, we need a width and a height and then a label. Now that we've defined our vector of components, we can simply call screen.run and that's it. We have a GUI library that could take a list of drawable components and draw them to the screen. Because we use trait objects, Rust will ensure at compile time that any component in this list implements the draw trait.
00:10:19.803 - 00:11:15.833, Speaker A: Let's see what happens if we add a component that does not implement the draw trait. We'll add a new element to the top of our list, and first we need to use the box smart pointer, and then inside the box smart pointer, we're simply going to store a string. Here we have some red squigglies, and if I hover over, you'll see that it essentially says that the draw trait is not implemented for the string type, therefore we cannot use it in this list. Now let's talk a little bit about static versus dynamic dispatch. If you recall, Chapter 10 of the Wrestling book talks about a process called monomorphization, which happens when we use generics and trait bounds. Monomorphization is a process where the compiler will generate non generic implementations of functions based on the concrete types used in place of generic types. For example, let's say you had a function called draw which takes two generic parameters and adds them.
00:11:15.833 - 00:11:49.299, Speaker A: Then let's say that you use that function with floating point numbers and integers. Well, the compiler will generate a function called integer add and then another one called float add. Then it will find all the call sites of the add method and replace it with the concrete implementation. So essentially we're taking a generic implementation and substituting it for a concrete implementation. This is called static dispatch. Static dispatch is when the compiler knows that the concrete functions you're calling at compile time. The opposite is dynamic dispatch.
00:11:49.299 - 00:12:26.723, Speaker A: Dynamic dispatch happens when the compiler does not know the concrete methods you're calling at compile time. So instead it figures that out at runtime. When using tray objects, the Rust compiler must use dynamic dispatch. And that's because the compiler doesn't know all the concrete objects that are going to be used at compile time. Instead, the compiler will add code to figure out the correct method to call at runtime, which means there is a runtime performance cost. However, the upside is you get to write flexible code that can accept any object which implements a certain trait. The last thing I want to talk about is object safety.
00:12:26.723 - 00:13:04.579, Speaker A: You can only make object safe traits into trait bounds. So what does it mean to be object safe? Well, there are two relevant rules you must follow. A trait is object safe when all of the methods implemented on that trait have these two properties. The return type is not self and there are no generic parameters. If a trait does not have these two properties then the Rust compiler can't figure out the concrete type of that trait and therefore doesn't know the correct method to call. If you're interested in learning more about object safety in the description, I've added a link to a relevant Request for comment document which you can read. Alright, that's it for this video.
00:13:04.579 - 00:13:21.355, Speaker A: If you enjoyed it, give that like button a high five and if you want to see weekly Rust videos then hit the subscribe button and notification bell. Lastly, I'm going to be releasing a Rust cheat sheet so if you want access to that, make sure to click the link in the description and with that said, I'll see you in the next one.
