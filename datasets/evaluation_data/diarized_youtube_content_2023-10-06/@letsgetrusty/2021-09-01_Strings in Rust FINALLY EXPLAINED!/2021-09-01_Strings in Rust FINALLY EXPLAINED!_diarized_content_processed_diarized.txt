00:00:00.680 - 00:00:34.802, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this YouTube channel is all about the Rust programming language. If that sounds interesting to you, make sure to hit subscribe for weekly Rust videos. Now, Rust is a lower level programming language, so it exposes us to some complexities that we wouldn't be exposed to if we were programming in a higher level programming language. One of those complexities is strings. Now, I come from a JavaScript background where the complexities of strings are hidden. So all this time I just assumed strings were simple.
00:00:34.802 - 00:01:35.468, Speaker A: But as I started programming in Rust, I realized strings are actually far more complex than I originally thought. So if you're like me and you were mind blown and confused by how complex strings were when you started programming in Rust, then this video is for you. In this video, I'm going to go over why strings are so complex, why Rust has two string types, and in general, how to use strings in Rust. So with all that said, let's get rusty, alright? To understand strings, we're going to take it all the way back to computer science 101 and talk about binary. Now, a computer's main memory consists of a bunch of transistors that could either have a high voltage level or a low voltage level. One or zero. So at the end of the day, computers can only understand ones and zeros, but that's not very useful to us.
00:01:35.468 - 00:02:25.690, Speaker A: Well, luckily we can transform these ones and zeros into integers using the binary number system here. For example, we can take a byte, which is eight bits, and represent the number 65 by turning on the first bit, which is going to be equal to one, and the 7th bit, which is going to be equal to 64. Great. Now we can represent whatever integer we want, but that's still not super useful. Let's say what we really want is to represent some text. So how can we get from integers to text? Well, what if we encoded these integers with meaning? What if we said every integer maps to a specific character? Then we can string these characters together to form words and sentences. And that brings us to ASCII.
00:02:25.690 - 00:03:34.058, Speaker A: ASCII stands for the american standard code for information interchange, and it's an encoding which maps integers to characters. So, for example, if we wanted to represent hello, exclamation point, we would represent it with the following integers which would map to the individual characters. Now, the first version of ASCII represented each character with seven bits, which means that we only have a total of 128 characters that could be represented. Now that's a very limited number, and if we go to the ASCII wiki page, you can see all the values that we could represent. A lot of them are the symbols you see on your keyboard, integers, and then of course, the english Alphabet, both lowercase and uppercase letters. Okay, so we have a limited number of characters, but it's enough to encode the english Alphabet integers and the special symbols on your keyboard. But what about all the other languages out there? Well, as I've mentioned before, ASCII stands for american standard code for information interchange.
00:03:34.058 - 00:04:10.376, Speaker A: So it only accounts for the english Alphabet. It doesn't account for any other language. Now, AsciI was created in the 1960s, long before the World Wide Web. So people didn't have to worry about creating a standard that encompasses multiple languages. Instead, what happened was multiple standards were created. So you had all these countries creating text encoding standards that would work with their language, which was fine for a little while, until the World Wide Web. In the 1990s, the World Wide Web was invented, which allowed people from all over the world to communicate with each other.
00:04:10.376 - 00:04:52.530, Speaker A: But this created a problem with all these different text encodings. How are people supposed to share information? To solve this problem, a bunch of people got together to form a group called the Unicode Consortium. And the way they solved this problem is by creating a standard that encompassed all the different characters out there. Now, the Unicode consortium has created multiple standards, but the one that stuck and is widely used on the web today is called UTF eight. UTF stands for Unicode transformation format, and the eight is for eight bits or a byte. Now, UTF eight is a variable with character encoding. With ASCII, you can represent a character in one byte.
00:04:52.530 - 00:05:26.114, Speaker A: Well, in UTF eight, a character could be an I in a range from one byte to four bytes. This means that the UTF eight standard could encode over a million characters. And what's even better is that UTF eight is backwards compatible with ASCII. Let's take a look at how UTF eight encodes text. The first byte tells us how many bytes a character takes up. For example, if a character takes up one byte, then that byte will start with zero. If a character takes up two bytes, then the first byte will start with one 10.
00:05:26.114 - 00:06:14.550, Speaker A: If a character takes up three bytes, the first byte will start with 1110. And if a character takes up four bytes, the first byte will start with eleven one 10. Remember that ASCII characters are seven bits, so we can store all our ASCII characters in one byte. For characters that take up multiple bytes, the first byte will tell us how many bytes that character takes up, and then the preceding bytes will start with ten. This format makes it easy to tell whether we're at the starting byte of a character or if we're in the middle of a character. Now, because UTF eight can represent over a million characters, not only does it encompass essentially all the languages in the world, but it also encodes things like emojis. For example, here's the crab emoji encoded in UTF eight.
00:06:14.550 - 00:06:59.854, Speaker A: Here we can see the first byte indicates that this character takes up four bytes because it starts with eleven, one 10. Then all the preceding bytes start with ten, and then all the other bits represent the actual character. Now, the reason I'm talking about UTF eight is not because it's the encoding used on the World Wide Web, but because it's also the encoding used in rust. Text in Rust is encoded in UTF eight, so it's important to understand how UTF eight works. Specifically, it's important to understand that UTF eight is a variable with character encoding. This is going to come into play later when we manipulate strings in code. All right, now that we have some background about what strings are, let's talk about some rust specific concepts.
00:06:59.854 - 00:07:40.050, Speaker A: To start off, we're going to talk about the two different types of strings in rust. Rust has two string types, str and stringental. Here I have them represented. Visually, STr is a string type that is core to rust language, and what it is is a view into a sequence of UTF eight encoded bytes of dynamic length. These bytes could either be stored in the application's binary on the stack or on the heap. Now, these bytes represent a string, and like I've said before, the amount of bytes is dynamic, meaning we can't know the amount of bytes of compile time. I mean, sure, you might say that if the bytes are in the binary, then we would know at compile time.
00:07:40.050 - 00:08:07.930, Speaker A: But if the bytes are, for example, on the heap, then those bytes could be allocated at runtime. Thus, we don't know the size at compile time. Because of this, we don't use the stir type directly. We use the borrowed form, which is going to be ampersand stir. This is commonly referred to as a string slice. Now, the rust compiler needs to know the size of the types we use at compile time. We can't know the size of stir because it points to a dynamic length of bytes.
00:08:07.930 - 00:08:58.982, Speaker A: But we do know the size of a string slice, because a string slice just stores an address pointing to the first byte of the string and the length of the string. In this case, we have a string slice that points to the string hello in our application's binary, and because this is ASCII, each character is going to be encapsulated within a byte, and the length here is six. And then, as I've said before, we can store in the application binary. The string could also be on the stack or the heap. To summarize, a string slice, which is what we're going to be using in code, is just a view of a sequence of UTF eight encoded bytes. A string slice doesn't own the underlying data, and here the string slice is pointing to an entire string. But we can also have a string slice that's just viewing a portion of a string.
00:08:58.982 - 00:09:43.756, Speaker A: So if you just need an immutable view of a string or part of a string, then use a string slice. The string type, on the other hand, is provided by rust standard library, and it's a growable mutable owned UTF eight encoded string. With the string type, the underlying string is always going to be allocated on the heap. And unlike a string slice, we're going to keep track of three values, an address pointing to the first byte of the string, the length of the string, and the capacity of the string. Length is the amount of bytes the string takes up, and capacity is the amount of bytes we have to work with. So in this case the string takes up six bytes, but we have ten bytes to work with. Now, this string slice has more overhead than a string slice.
00:09:43.756 - 00:10:21.630, Speaker A: However, the advantage is we own the data so we can manipulate the string however we'd like. So again, if we just need an immutable view of a string, we'll use a string slice. But if we want to actually own the data and manipulate the string, then we'll use the string type. The rustling book has a good example of how these two types interact with each other. In this example, we have the string hello world, and it's stored on the heap. Then we have a variable called s, which is a string type that owns that data owns that string. We also have a string slice, which is just viewing a part of the string, in this case the word world.
00:10:21.630 - 00:11:04.828, Speaker A: All right, now that we have a better understanding of the two string types in rust, let's jump into some code and see how we work with string slices and strings. We'll start off by creating a string literal in a variable called s one. Here I've written out which is hello world in ukrainian and added a crab emoji. Two things to know. One is that this string is utf a encoded so we can use whatever language we'd like and add things such as emojis. The second thing to notice is we have this type annotation hint here, which is saying that our string literal is of type string slice in rust. String literals are string slices that are stored in the applications binary.
00:11:04.828 - 00:11:58.516, Speaker A: Next we'll create a string that's stored on the heap and one which we can manipulate. And to do that we'll create a new variable called s two and call string colon from and then pass in a string literal. As you can see, s two is of type string. We can also create strings by calling methods on string literals like so we'll create a new variable called s three, which is going to be equal to Gravitz feet, and then we're going to call to string. Another method we can use to achieve the same thing is to owned. And lastly we'll create a string slice that references an owned string. So here we'll create a variable called s five and that's going to be equal to a reference to s four.
00:11:58.516 - 00:12:41.530, Speaker A: Then we're going to use brackets to specify a range. And in this case we're just going to do dot dot, which is going to be a range for the entire string. Let's go ahead and print out s five. And as you can see, s five is going to be a string slice over the entire string pervitzvit alright, now that we know how to create strings and string slices, let's talk about manipulating strings. In this example I have a variable called s, which is equal to the string foo. And the first thing we need to do if we want to manipulate the string is mark this variable as mutable. Then we can use the push stir method to append to this string.
00:12:41.530 - 00:13:13.880, Speaker A: In this case we're appending bar. Let's go ahead and print out our string. And now another method we can use to manipulate the string is called replace range. Replace range will take two arguments, a range that we'd like to manipulate and the string we'd like to replace the range with. In this case I'm using dot dot, which means the range is the entirety of the string. So we're replacing the entire string with boss. So let's go ahead and print our string again.
00:13:13.880 - 00:14:07.018, Speaker A: Let's go ahead and run our program. As you can see, the first string printed out is foobar because we appended bar up here. And then the second string is boz because we replaced the entire string with boss. Next, let's talk about concatenating strings first, we'll talk about concatenating two strings using the plus operator. To do that, we'll create a new variable called s three, and we'll set it equal to s one plus a reference to s two. What this is going to do is move s one into s three and then copy the contents of of s two and append it to s three. Now, because s one has been moved, if we try to print out s one, we'll get an error, and the error states, you cannot borrow s one because it has already been moved.
00:14:07.018 - 00:14:41.244, Speaker A: Let's print out s three now and run our program. And as you can see, we get the string hello world. Another way to concatenate strings is using the format macro. Here we have three strings tick, tack, and toe. And then we're calling the format macro, which uses string interpolation to replace these brackets with the variables being passed in. Now, the format macro is going to be less efficient than the plus operator because it's going to copy the contents of each of these strings. Also note that the format macro could take string types, and it could also take string slices.
00:14:41.244 - 00:15:20.904, Speaker A: So here we can replace s three with toe, for example, and our code will still compile. Let's go ahead and print our string and then run our program. And as you can see, we get tic tac toe. Here are some other ways to concatenate strings. We could take two string slices, put them in an array, and then call concat to get a string type. We could also get a string type by calling the format macro and passing in two string slices. If we, however, want to concatenate two string slices and have the result type be a string slice, then we can use the concat macro.
00:15:20.904 - 00:15:50.188, Speaker A: And lastly, going back to the plus operator, you could take a string and concatenate that string with a string slice. Like so. Everything thus far has been pretty straightforward. Next, we're going to talk about indexing into a string, which is a little more complicated than one might think. Let's take a look at the following example. We have a string with five crab emojis, and now let's say we want to extract out the first crab. So what we might do is create a new string called s two, and that'll be equal to s one.
00:15:50.188 - 00:16:26.872, Speaker A: And then we'll use brackets to extract out the first index. As you can see, we get an error, and if I hover over, you'll see that Russ is telling us we can't index into a string using an integer. Well, why is this well, a string is just a collection of bytes. So this code here is going to give us the first byte in our string. But as I mentioned before, in UTF eight, a character could be between one to four bytes. This crab in particular is four bytes long. So you might expect this code here to give you the first crab, but in fact, it gives you just the first byte, which doesn't really mean anything.
00:16:26.872 - 00:17:07.098, Speaker A: So, to prevent errors where people try to index into a string and don't get the expected output, rust doesn't let you index into a string using an integer. Rust does, however, allow you to create a string slice over a specific set of bytes. So, for example, in this case, we know that the crab is four bytes long. So let's create a string slice of the first four bytes. Then we can print out s two and run our program. And as you can see, we get the first crab. Now here we have to be very careful because we have to know exactly how many bytes a character is.
00:17:07.098 - 00:17:50.158, Speaker A: For example, let's say instead of four, we wrote three here and then ran our program again. As you can see, our main thread panicked because byte index three is not a character boundary. Essentially, Rust will make sure that a string or a string slice is valid UTf eight, and here s two is not valid utf eight. So the main thread panics. Also, with this example, each character is four bytes long because it's the same character. But we could have characters of different bytes. For example, we can insert some ascii text here, and now this crab is gonna be four bytes long, but th and e are each going to be a byte long, because in UTF eight characters could be a different amount of bytes.
00:17:50.158 - 00:18:41.264, Speaker A: If you want to find a particular character within a string, it's not going to take constant time, it's actually going to take linear time, and that's because you have to iterate through each character to find the one you're looking for, which is a great segue into talking about iterating over a string. There's a few ways to iterate over a string. The first one is iterating over the bytes of a string, and you can do that by calling the bytes method, which will give you an iterator over the bytes of a string. And then in this example, we're using a for loop to print each byte, and here we're printing out the bytes of the word namaste. Let's go ahead and run our program, and as you can see, we get a list of bytes which are just going to be integers, and in total, this word has 18 bytes. Next, let's talk about iterating over the characters of a string. To do that, we can call the chars method.
00:18:41.264 - 00:19:38.270, Speaker A: So let's go ahead and print out the characters of the string. Notice there are some characters that are being printed out that the terminal can't really display, so let me leave a comment of the characters that were printed out. This is a little confusing because you might have expected chars to be an iterator over the user perceived characters of the string, but in fact it's an iterator over the Unicode scalar values of this string. Scalar values are a basic unit in Unicode, and some user perceived characters are made up of multiple scalar values. In Unicode, user perceived characters are known as grapheme clusters, and in order to iterate over graphene clusters, we actually have to import a crate. Here I've imported the Unicode segmentation crate, which gives us a method on strings called graphemes. Calling graphemes will give us a iterator over the graphemes of a string, and here we pass in true to get the extended graphemes, which is recommended.
00:19:38.270 - 00:20:19.922, Speaker A: So let's go ahead and run our program, and as you can see, we get a list of user perceived characters. Next, I like to quickly go over strings and functions in rust. A typical pattern you'll see in rust is a function that takes in a string slice and returns a string. An advantage of taking in string slices is that we can pass string slices to our function, but we can also pass in references to strings. As you can see, in main we have s one, which is a string slice, and s two, which is a string. We can pass both s one into our function, and we can also pass in a reference to s two. This is because of a feature in rust called the refcorsion.
00:20:19.922 - 00:21:01.508, Speaker A: When we pass in a reference to a string, it is automatically coerced to a string slice. We want our function to return a string type because we want the caller to take ownership of the string. There's one more thing I'd like to mention before I end the video. Remember earlier I said if you want to find a specific character within a UTF eight encoded string, then you have to iterate over the entire string, because each character could be a different amount of bytes. Specifically, each character is between one to four bytes. Well, let's imagine that we made all the characters four bytes. Of course, that would use up more memory, but then we could find a character in constant time.
00:21:01.508 - 00:21:28.990, Speaker A: As far as I know, something like this is not implemented in Rust, but it is implemented in go with the rune type. Alright, that's it for this video on strings. If you enjoyed it, make sure to smash that like button, and if you want to see weekly rust content, make sure to hit subscribe. Also, I'm going to be releasing a free rust cheat sheet which you don't want to miss out on, so if you want access to that, make sure to click the link in the description and with that I'll see you in the next one.
