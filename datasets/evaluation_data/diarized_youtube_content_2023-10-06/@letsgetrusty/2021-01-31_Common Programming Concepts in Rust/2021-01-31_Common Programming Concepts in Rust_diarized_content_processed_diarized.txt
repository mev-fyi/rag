00:00:00.360 - 00:00:27.737, Speaker A: Welcome back to let's Get Rusty. My name is Bogdan, and this channel is all about the Rust programming language. If that sounds interesting to you, hover over that subscribe button and give it a high five. Last time we went over chapter two of the book, and if you haven't seen that video, make sure to check it out. In this video, we're going over chapter three, in which we'll learn basic programming concepts such as variables, basic types, functions, control, flow, and comments. With that, let's get started. All right, I went ahead and created a new Cargo project.
00:00:27.737 - 00:01:08.649, Speaker A: I assume everyone knows how to do this, but if you don't, go ahead and watch my previous videos and you can name this project whatever you'd like. I chose to name mines variables. Now, the first thing we're going to do is start off by talking about variables and immutability. You might remember from previous videos that variables are immutable by default in Rust. So to prove that out, let's create a new variable called X and we'll set that equal to 5, and then we'll print the variable. Next we'll reassign it to something else, in this case6, and we'll print it out again. Now, I didn't even have to compile this to get an error because I have a language server running.
00:01:08.649 - 00:01:41.615, Speaker A: So if I hover over the red squigglies, I could see that we have error saying you cannot assign twice to an immutable variable, in this case X. So let's say we did want to make it immutable. All we have to do is type in mute after the let keyword. And now we can reassign X and we can go cargo run. And we see that X gets printed out as 5 on the first line and 6 on the second line. Rust also has the concept of constant values or values that can never change. To create one, we'll use the const keyword.
00:01:41.615 - 00:02:22.301, Speaker A: And here I'll create one for my subscriber count. I'll set the type to an unsigned 32 bit integer and make it equal 100,000. We can all dream when declaring constants, it's common practice to have the variable name be all uppercase with underscores where there are spaces. Now you might ask, why do we need constants when variables in Rust are already immutable by default? Well, there are a few key differences between constants and variables. The first is you cannot mutate a constant. So, for example, if I type in mute in front of our constant, I get an error here that says const globals cannot be mutable. So if you declare a constant, you can be sure that it will never be mutant.
00:02:22.301 - 00:02:52.535, Speaker A: Const variables must also be type annotated. You can see here our constant is an unsigned 32 bit integer. Up here we didn't annotate our X variable because Rustin referred that it was assigned 32 bit integer. But for constants, we have to annotate it. Constant variables can also only be set to constant expressions. For example, with our variable X, we could have set it to the return value of a function. But we cannot set constants to the return value of a function or any value that is computed runtime.
00:02:52.535 - 00:03:28.823, Speaker A: Lastly, here, 100,000 might be hard to read. Luckily, Rust allows us to make numeric literals more readable by adding an underscore. And there we have our constant with a little warning telling us that it's never used, which is okay. Now, the last thing I want to talk about on the subject of variables is shadowing. Shadowing allows you to create a new variable using an existing name. For example, in our program, instead of making X mutable, we can remove the mute keyword and then redeclare X here. Now, this first X variable is shadowed by the second X variable.
00:03:28.823 - 00:03:57.211, Speaker A: This gives us two advantages. First, we preserve mutability. This first X is still immutable, and the second X is also immutable. Secondly, we could change types. So, for example, we could take the second variable, which is a 6, and instead of an integer, we can make it a string. Now we can go and run our program, and you can see that 5 is printed for the first X and the string 6 is printed for the second X. Next, we'll look at data types, specifically scalar data types and compound data types.
00:03:57.211 - 00:04:31.628, Speaker A: Scalar data types represent a single value, while compound data types represent a group of values. First, let's talk about scalar data types. Rust has four main scalar data types, which are integers, floating point numbers, booleans, and characters. Integers are numbers without a fractional component. And here I have the Rust book pulled up with a table showing you the integer types. In Rust, every integer has a length, and it could either be signed or unsigned. Signed integers could be positive or negative numbers, and unsigned integers could only be positive numbers.
00:04:31.628 - 00:05:20.849, Speaker A: Integers could be 8 bits in size, 16 bits, 32 bits, 64 bits, 128 bits, or arc, which depends on the architecture, usually either 64 or 32 bit. Rust defaults integers to assign 32 bit integer. And as you can see, we have different ways of representing integers decimal, hex, octal, binary or byte. Lastly, let's talk about integer overflow. Here I have an 8 bit unsigned integer which can hold a max value of 255. If I try to set this to a number greater than 255 in debug builds, Rust will panic and in release builds, Rust will perform two's complement wrapping, which means values greater than the maximum will wrap around back to the minimum values. So 256 would become 0, 257 would become 1.
00:05:20.849 - 00:06:06.301, Speaker A: Also, if you have a language server running and you try to Change this to 256, you'll get an error warning you of the overflow. Rust also supports floating point numbers which are numbers with decimal points, and as you can see the default is a 64 bit double precision floating point number. And of course we could do our basic numeric operations such as addition, subtraction, multiplication, division and remainder. Next we have booleans which represent the values true or false. And lastly we have the character type which represents a Unicode character, is written with single quotes and something we'll learn about more in chapter eight. Next let's talk about compound types, which are types that represent a group of values. First we have the tuple type, which you can think about as a fixed size array of related data that could be of different type.
00:06:06.301 - 00:06:37.289, Speaker A: Here we have a tuple with only two values. The first is a string representing a YouTube channel name and the second is an integer representing subscriber count. Tuples are written by using a comma separated list inside of parentheses and you can see here our type is automatically annotated. We can get values out of tuples in two ways. The first is destructuring and the second is dot notation. To destructure a tuple, we'll create a new set of variables inside parentheses. Here we have channel and subcount and we'll set that equal to our tuple.
00:06:37.289 - 00:07:08.951, Speaker A: Setting this equal to our tuple will take the first variable and set that equal to the first value in our tuple. Then it'll take the second value and set that equal to the second value in our tuple. We could also get values out of tuples by using the dot notation. For example, we'll create a new variable called subcount and set that equal to the tuple at value 1. Tuples as well as arrays, both start at index 0. To declare arrays in Rust, we use a comma separated list, but instead of parentheses we use brackets. In Rust, arrays are fixed length.
00:07:08.951 - 00:07:47.091, Speaker A: If you want Something that can change size dynamically, you would have to use a vector, which we'll talk about more in chapter 8. To access individual values within an array, we use the standard bracket syntax here. Arrays could also be declared using this syntax here, which says create an array with eight values, all set to zero. Lastly, if we try to access an index that's invalid, for example, here we have a variable X that accesses index 3, which does not exist. We can type cargo run and we see that we get an out of bounds exception. Rust prevents us from doing something that's memory unsafe, and it's able to do this because we know the size of the array. Next, let's talk about functions.
00:07:47.091 - 00:08:29.815, Speaker A: In Rust, functions can be declared using the FN keyword. So here we'll define a function right underneath main and we'll simply make it print another function. Rust uses the Snake case convention for function names, meaning that the function name should be all lowercase, and whenever there's a space, use an underscore. Now we can call our new function from main by specifying the function name and parentheses. Then we'll do cargo run and we can see that our function was called. We can also allow our function to take in parameters by specifying the parameter name and its type inside the parentheses. We can add multiple parameters by separating them with a comma, like so.
00:08:29.815 - 00:09:06.073, Speaker A: And as you can see, we get an error here because our function takes two arguments, but we're not passing any. So let's pass in some arguments and let's also change our function to print out the values passed in. Then we can run our program and we see our values printed out. In Rust, we could think about a piece of code as either a statement or an expression. Statements perform some action but do not return a value, whereas expressions return a value. As an example, inside of my function, the print line statements are well, statements because they don't return anything. Here we created a new variable called sum, which adds x and y together.
00:09:06.073 - 00:09:36.557, Speaker A: X plus y. Here is an expression because we add x and y and return that value. In Rust, we can return values from a function in two ways. The first way is to use the return statement. Here we're returning sum and you can see we get an error because the function doesn't have a return type. To specify a return type after the parentheses, you can add a dash and an arrow and then specify the return type. In this case, assign 32 bit integer inside of a function.
00:09:36.557 - 00:10:05.717, Speaker A: The last expression is implicitly returned. So if we want to return sum, we can remove the return keyword. Also, for the last expression in a function, we omit the semicolon. We can simplify this further by removing sum and just returning x plus y. Then, in our main function, we can create a new variable called sum and set that equal to the return value of our function. Then we can print out our value. Let's run our program and you can see we print out 1122 and the sum.
00:10:05.717 - 00:10:23.877, Speaker A: All right. Now let's talk about control flow. First, we have if statements and if you've programmed before. The syntax should be very familiar. We have an if block with a condition and code that executes. If that condition is true, we can have else if blocks. And finally we can have an else block if all the other conditions fail.
00:10:23.877 - 00:10:46.407, Speaker A: In Rust, however, the condition must be explicitly a boolean. So, for example, if we just try to evaluate number, we'll get an error. Here we're trying to evaluate an integer, but instead we need a bool. Lastly, we can use an if else statement inside of a let statement. For example, we have this variable that's called condition. We set it to true. And then we have a variable called number.
00:10:46.407 - 00:11:08.295, Speaker A: And we set that to an if else expression. If the condition is true, the number is five, else, the number will be six. Next, we'll talk about the three different types of loops in Rust. The most basic type of loop we create using the loop keyword. What this will do is execute the code inside of the loop until we call break. Right now, we don't call break at all. So if I run the program, it'll execute forever.
00:11:08.295 - 00:11:39.105, Speaker A: You can press control C to exit the program. We'll go back and add a break statement. Then we'll run our program again, and this time the loop only executes once. We can also return values from this type of loop. To show how this works, let's create a new mutable variable called counter and set it equal to zero. Then every time we run our loop, we'll increment counter. Next, we'll add a if statement to check when counter gets to 10.
00:11:39.105 - 00:12:09.375, Speaker A: And when it does, we'll break out of the loop and return counter. Then we'll remove our previous break statement. Adding counter after break will make this loop return counter. Now we can set the return value to another variable. In this case, we'll call it result. We'll need to add a semicolon to the end of our loop and print out the value. Now, when we run our program, we'll get 10 printed out.
00:12:09.375 - 00:12:37.109, Speaker A: There are two other types of loops in Rust. The second one is the classic while loop, which will execute as long as a certain condition is true. In this case, we have a variable called number set to three, and we're saying while the number does not equal zero, execute the code inside the loop. In this case, we'll just print the number and decrement it. Then when we get zero, we'll print the next line which is left off. If we run the program, it will print 3, 2, 1 left off. The last type of loop is a for loop or a for in loop.
00:12:37.109 - 00:13:18.967, Speaker A: And this is useful when you're looping through a collection. So here we have a collection of integers and we want to loop through it. To do that, we'll type in for element in and then our variable name, which is a dot iter, which will give us an iterator for the array, and then curly brackets. Finally, we'll print the element, this is saying for every element in our array, take that element and print it to the screen. We can also use the for loop to loop over a range, which is a type provided by the standard library, which represents a sequence of numbers. As an example, we could type in for number in and this time we'll do parentheses, 1, dot dot for curly brackets. And we'll print the number.
00:13:18.967 - 00:13:48.131, Speaker A: And apparently the parentheses are not required, so we can remove those. Okay, so this is a range and what it will do is create a sequence of numbers from 1 to 3. Because the last number is exclusive, running the for loop on it will do the same thing as before. We'll say for every number in this range, take the number and print it out. We can go ahead and run our program and as you can see, we get the values in our array and then we get the values in our range. And really quickly. I just want to go over comments.
00:13:48.131 - 00:14:11.395, Speaker A: We have two basic types of comments in Rust. There are single line comments, which you could write using two forward slashes. And there are block comments which you can write using a forward slash and asterisks and to end it, an asterisk and a forward slash. There are also document comments, but we'll learn about that at another time. And there you have it. Chapter three complete. We learned about variables, basic types, functions, comments, and control flow.
00:14:11.395 - 00:14:22.485, Speaker A: If you like this video, make sure to give it a like. And if you want more Rust content, make sure to subscribe and hit the notification bell to be notified when new videos come out. I'll see you in the next one.
