00:00:00.440 - 00:00:32.184, Speaker A: It's all a lie. Rust is hard is a big, fat lie. In fact, it's the complete opposite. Rust makes our lives easy. In this video, I'll explain the various ways Rust makes coding incredibly easy for us, especially compared to other languages. At the end of the video, I'll also cover two newbie mistakes you might be guilty of that make Rust harder than it needs to be, so stick around for that. This video is part of a series for the upcoming official launch of my Rust developer Boot camp, the all in one Rust learning program you've all been asking for.
00:00:32.184 - 00:01:01.908, Speaker A: The Rust developer bootcamp, will be launching on August 15. To join the waitlist, pause this video right now and head over to letsgetrusty.com bootcamp. And now lets get rusty. First of all, Rust makes coding easy for us by avoiding one of the biggest fumbles in programming history, the trillion dollar mistake, adjusted for inflation, the infamous null pointer, or more generally, null object. Java is notorious for this. In Java, all non primitive types can be null, which often causes issues like null pointer exceptions.
00:01:01.908 - 00:01:53.222, Speaker A: In this example, we have the getusername function that returns a nullable username string. Unfortunately, the function signature doesn't make it clear that a null value may be returned. To prevent null pointer exceptions, we would need to either make sure a non null value is always returned, which is extremely flawed because this guarantee is not enforced by the type system, or we would need to force the caller to perform a null check every time, which is often forgotten or overlooked. Now, to be fair, Java eight introduced the optional type to represent either a non null value or no value at all, but the underlying issue is still not addressed. Null is still part of the language, and null pointer exceptions still occur all the time in Java programs. In fact, ironically, because optional is a non primitive type, it could also be set to null and cause null pointer exceptions. Here's the getusername example in rust.
00:01:53.222 - 00:02:39.290, Speaker A: In rust, all values and pointers to values must be valid. If you want an optional or nullable value, you must explicitly wrap it in the option enum. This approach forces you to handle the none case explicitly and ensures that you can't accidentally dereference a null pointer, which can lead to security vulnerabilities and crashes. Many languages, such as Java, C, and go suffer from null objects and pointers, but Rust's well thought out approach eliminates the trillion dollar mistake completely. There's one aspect when designing a language that is very difficult to get right and often leads to controversy. Once decided, the language is pretty much stuck with it and has to suffer the consequences for good, and that is error handling. Somehow, rust manages to get it just right.
00:02:39.290 - 00:03:04.120, Speaker A: There are a number of error handling strategies implemented in various languages. JavaScript uses exceptions. Here we have a function that takes two integers, divides them, and returns the result. It will throw an error if the denominator is zero. When calling this function, a try catch block is used for error handling. This approach has a few downsides. The function signature doesn't indicate that an error can be thrown, which means you have to rely on documentation.
00:03:04.120 - 00:03:52.060, Speaker A: Also, catching errors is not enforced by the type system, which can lead to application crashes or unexpected behavior. It's very easy to forget adding a try catch block, especially when functions change from not throwing any errors to potentially throwing errors. Thirdly, the error object in JavaScript only accepts a string message and a couple other optional parameters, which doesnt provide a lot of context about the error. Go takes a different approach to error handling by allowing multiple return values. Here, divide returns two values, a floating point number, and an error object which is set to nil if the operation succeeds. In main, we simply have to check if the returned error object is nil. This is an improvement because the function signature clearly states that an error may be returned, but ghost type system doesn't force us to check the error object, which can lead to runtime exceptions.
00:03:52.060 - 00:04:58.172, Speaker A: Rust's error handling system fixes this just how rust makes nullable values explicit with the option enum. It makes error handling explicit with the result enum, which can either be the ok variant containing a result or the error variant containing an error. Using the result enum leads to compile time safety because the error case must be checked, which can easily be done with the match expression. Note that Rust does give you the flexibility to explicitly ignore errors at the cost of runtime exceptions with methods like unwrap and unwrap, or these methods are convenient when prototyping and can easily be found and replaced when your code needs to be more robust. Rust explicit approach to error handling results in code that is simple, flexible, and extremely easy to reason about. Now, this is only the tip of the iceberg. Rust has plenty of other amazing features for error handling, like custom errors with structs and enums, automatic error propagation, composability with the option enum, the error trait, and popular third party libraries like this error, and anyhow, unfortunately, I don't have the time to go through all of these features in this video.
00:04:58.172 - 00:05:36.040, Speaker A: Luckily, in the Rust developer bootcamp, which will be launching on August 15, I've included a dedicated error handling module covering all of these topics and much more. To get early access, head over to letsgetrusted.com boot camp. Did you know that Rust could save you millions of dollars? Well, not you specifically, but the company you work for. Microsoft famously reported that 70% of vulnerabilities in their products were caused by memory safety issues. You can only imagine how much money and resources Microsoft had to burn to address these issues. Rusts claim to fame is its promise of memory safety without sacrificing performance.
00:05:36.040 - 00:06:20.308, Speaker A: Rust does quite a few things to prevent memory safety issues and make our lives easier. I've already mentioned that in rust, all values and pointers must be valid. If you want an optional or nullable type, you have to explicitly wrap it in the option enum. This is a big step towards achieving memory safety, but rust goes even further by automatically cleaning up values for you when variables go out of scope. This is done through the ownership and borrowing system, which are rules the compiler enforces to maintain. Memory safety guarantees, all without the overhead of a garbage collector. Rusts elegant approach to memory management and memory safety has fundamentally changed systems programming, allowing us to write blazingly fast, low level code without the fear of introducing catastrophic bugs.
00:06:20.308 - 00:06:59.410, Speaker A: One of the most confusing and time consuming parts of software development is figuring out how to build and deploy your app to production, a process that should be simple and automated but often turns into an unmanageable mess. Rust tackles this problem by providing several tools that make this process effortless. For example, in Rust, cross compilation is built in. Let's say you want to compile for a 64 bit Arm architecture running Linux. First, you would add the target to your rust installation by using the rustup target add command. Then you would add any custom configurations to the cargo TOMl file. In this example, we want to statically link the cruntime library to the resulting binary.
00:06:59.410 - 00:07:45.528, Speaker A: And lastly, you would build your rust project for the target platform using the cargo build command. This allows you to build standalone binaries, which could be executed without having any additional software installed. Rust also makes dependency management extremely easy. All your dependencies are stored in the cargo toml file, and you can find publicly available dependencies on crates IO or use it to publish your own projects. The beautiful thing is that managing your dependencies, compiling your program, and running tests is all done with one single built in tool called cargo. This modern tooling is extremely valuable and a breath of fresh air, especially if you're coming from other systems programming languages like C. As you can see, Rust was beautifully designed to make shipping your code as simple as possible.
00:07:45.528 - 00:08:43.290, Speaker A: Lastly, let's talk about a few newbie mistakes you may be guilty of that make rust harder than it needs to be. Before we get to that, keep in mind that gaining a deep understanding of these incredible rust features and how to use them in real world applications takes a lot of practice. That's why I created the Rust developer boot camp, launching on August 15, which I'll talk more about at the end of the video. The first newbie mistake, which could lead to a lot of frustration, is diving into rust without first truly understanding the core concepts, which make Rust an incredibly unique language, concepts like ownership, borrowing, and algebraic data types. For example, if you truly understood ownership and borrowing, you would realize why implementing the linked list data structure in rust is not as easy or straightforward as other languages. The second newbie mistake is not deliberately studying the standard library. Studying the standard library benefits you in a couple ways.
00:08:43.290 - 00:09:35.980, Speaker A: First, it allows you to see how Rust's core concepts, which I mentioned earlier, are actually implemented in code, which is critical to writing effective rust. And secondly, it gives you important tools to write idiomatic rust code, tools like the default trait that can be derived, which allows you to create instances of types with default values. Gaining a deep understanding of rust core concepts and mastering the standard library can be very difficult. It can leave you feeling confused, frustrated, and ultimately defeated. When I was learning Rust, I kept wondering, does it really need to be this hard? A lot of times I felt like I just wasn't smart enough or I didn't have what it takes. But luckily, I persevered, and now I've made it my mission to make Rust accessible to everyone. That's why I created the Rust developer bootcamp, to make learning rust fun, easy, and accessible to everyone.
00:09:35.980 - 00:10:02.390, Speaker A: No matter what your background is in this bootcamp, not only will you learn Rust's core concepts, but you'll also be guided by various exercises, real world projects, and more to get you out of tutorial hell and shipping rust code as soon as possible. The Rust developer boot camp will be launching on August 15, and you can get early access by heading over to letsgetrusty.com boot camp. Hope you enjoyed the video and remember to stay rusty.
