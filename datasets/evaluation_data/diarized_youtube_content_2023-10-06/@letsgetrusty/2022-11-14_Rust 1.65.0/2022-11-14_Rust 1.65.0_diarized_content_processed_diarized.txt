00:00:00.320 - 00:00:30.187, Speaker A: A new version of Rust was Recently released, version 1.65.0. In this video, we'll go over the new features in this release, and there are some really good ones. But before we get to that, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com Cheat Sheet. Now let's jump into the video. The first major feature in this release is generic associated types or gats. Associated types are placeholder types or type aliases inside trait definitions.
00:00:30.187 - 00:00:57.587, Speaker A: When implementing a trait, a concrete type is specified. For example, let's take a look at the Iterator trait. It has an associated type called item. Item is used as the return type when calling the next method. This makes sense because Iterator will be implemented for many different types, so the return value will vary. When we implement Iterator, we specify the concrete type for item. In this example, we implement iterator for the playlist struct, so we can iterate over songs in a playlist.
00:00:57.587 - 00:01:19.621, Speaker A: Therefore, the concrete type of item will be song. This works fine. However, up until this release, associated types were limited. More specifically, they could not contain lifetimes or generic type parameters with trait bounds. Well, now they can. This enables a number of new patterns. For example, we can write an iterator where the next function returns something that borrows from self.
00:01:19.621 - 00:02:00.979, Speaker A: You may have noticed an odd piece of syntax in this example. The where clause with self being set to tick a. This enforces that item cannot outlive self, which makes sense because the next method is intended to return a reference to part of self. If you find this syntax confusing, then good welcome to Rust. In all seriousness, the Rust team is currently debating this syntax and considering potential alternatives, such as always assuming this bound or implying it based on usage within the trait. You can learn more about the specifics by looking through issue 87489 GitHub. Although we cover just one example use case of GATS, in reality they enable a vast range of patterns and APIs.
00:02:00.979 - 00:02:36.877, Speaker A: In fact, many Rust projects and libraries were blocked on gats being stable. So while you may not personally use gats, the libraries you depend on may take advantage of them. The second major feature in this release is let else statements. Previously, let statements could only use irrefutable patterns, which means patterns that always match. As of this release, less statements could match against refutable patterns if they contain an else block. Let's look at a concrete example. Here we have a function called getsemver that takes a string representing a semantic version number for example 1.65.0
00:02:36.877 - 00:03:16.249, Speaker A: and returns an optional semver struct. If the passed in string is an invalid semantic version number, then the non variant will be returned inside the function. We'll split the string argument by the period character, which will give us an iterator over the substrings. We will then map the first three substrings into variables major, minor, and patch using a let statement. Calling the next method will return an optional type, so we must check for nonevariance. If a non variant is found, we can simply early return none from the function. Then we will parse each substring into an integer and store the results in major, minor and patch using another let statement.
00:03:16.249 - 00:03:52.353, Speaker A: Parsing might fail, so we must check for error variants. If we find any, then just like before, we will early return none from the function. Finally, after splitting and parsing the string, we can construct a new semver struct and return it. This function works, but the code could be improved let's combine the let statements with the if checks below them in the first let statement. Instead of matching against whatever the next method returns, let's only match on some variants. This gives us an error because we are now using a refutable pattern. The next method might return a non variant, in which case our pattern won't match.
00:03:52.353 - 00:04:22.047, Speaker A: Rust doesn't know what to do in this situation. Luckily we are now able to specify what should happen in this situation by attaching an else block to our let statement. If our pattern does not match, we'll simply return none from the function. We can then remove the if check below. We'll do the same thing with the second less statement, except this time we are matching on OK variance. Again we can remove the if check below. Our code looks a lot cleaner and we were able to get rid of the unwrap calls which makes our code more robust.
00:04:22.047 - 00:04:53.427, Speaker A: Another new feature in this release is the ability to break from labeled blocks. Previously only loop blocks could be labeled as break targets. In this release, regular blocks can be labeled as break targets as well. You can also include an expression value when breaking from a particular block, like you see in the following example. In this case, result will be set to 1, 2, or 3 depending on which if checks. If any execute. Yet another feature in this release is the ability to split out debug information on Linux.
00:04:53.427 - 00:05:34.131, Speaker A: In version 1.51.0, Rust added support for splitting out debug information on macOS. As of this release, this option is also stable on Linux. By splitting out debug info, the linker avoids processing this information, which leads to faster linking speeds. There are three configuration options available off, which prevents splitting debug info and is the default Unpacked, which produces multiple dwarf object files, and Packed, which produces a single dwarf package. You can control this configuration by passing the Split debug info flag to Rust C, or by adding the Split debug info setting to your Cargo automl file underneath the profile.dev section.
00:05:34.131 - 00:05:48.355, Speaker A: Let me know what you think about this new batch of features in the comments section down below. And before you go, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com forward/cheat sheet. With that said, I'll see you guys in the next one.
