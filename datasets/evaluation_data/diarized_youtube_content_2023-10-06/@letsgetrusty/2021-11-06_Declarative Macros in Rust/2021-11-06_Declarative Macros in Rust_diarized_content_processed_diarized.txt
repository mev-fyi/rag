00:00:00.520 - 00:00:50.107, Speaker A: What's up, Rust Stations? Welcome back to let's Get Rusty, the number one resource for all things Rust. Make sure to subscribe to the channel for weekly Rust videos and get your free Yes, I said Free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet today we're continuing the advanced Rust series by talking about declarative macros. Macros allow you to write code which writes other code, which is known as metaprogramming. You could think about macros kind of like a function where the input is code and the output is also code that is transformed in some way. We've already been using macros throughout this Rust series, for example the print line macro or the vec macro. These macros expand to produce more code than the code you've written.
00:00:50.107 - 00:01:34.243, Speaker A: Manually writing macros allows you to reduce the amount of code you have to write and maintain, which is similar to the role of functions. However, there are a few key differences. Functions must declare the number of parameters they could accept, whereas macros can accept a variable number of parameters. Also, functions are called at runtime, whereas macros are expanded before your program finishes compiling. So macros are a lot more powerful than functions. However, the downside is you're introducing more complexity because you're writing code which writes other code, meaning that macros are going to be harder to read, understand, and maintain. With that caveat, Rust has two forms of macros, declarative macros and procedural macros.
00:01:34.243 - 00:02:28.787, Speaker A: In this video, we're going to focus on declarative macros, and in the next video we'll focus on procedural macros. So with that said, let's get rusty. Declarative macros are the most widely used form of macros in Rust, and they allow you to write something similar to a match expression. Let's look at a declarative macro we've already used before, the VEC macro. I went ahead and created a new Rust project and added two files, Main rs, which is the entry point for our binary crate, and lib rs, which is the entry point for our library crate. Inside main RS we have a main function which has two variables, V1 and V2. V1 is going to be a vector of integers, and you can see we use the vec macro here by specifying the vec keyword followed by an exclamation point and then the values we want in our Vector.
00:02:28.787 - 00:03:07.113, Speaker A: In this case 1, 2, and 3. V2 is a vector of string slices, and we follow a similar pattern here, passing in string slices as the values in Our vector. Two things to know here. One is that we can pass different types when calling the VEC macro, and two is that we can pass in a variable amount of arguments. So for V1 we pass in three arguments, and for V2 we pass in five arguments. Now let's head over to Lib RS to see how the VEC macro is implemented. This is a simplified version of the VEC macro from the standard library, so let's go through it together.
00:03:07.113 - 00:03:45.835, Speaker A: The first thing we see is this macro export annotation. This annotation means that whenever the crate in which this macro is defined in is brought into scope, this macro should be made available. Then we define our declarative macro by starting off with macro rules followed by the name of our macro, in this case vec. And also note here that the exclamation point is not included in the name. Then we add curly brackets which contain the body of our macro. As you can see, the body of our macro is similar to a match expression, in this case, a match expression with one arm. Here we have a pattern to match on and a code block associated with that pattern.
00:03:45.835 - 00:04:26.477, Speaker A: If the inputs to our macro match this pattern, then the following code will be emitted. Otherwise an error will be thrown because we only have one arm. But note that macros could have multiple arms. The pattern syntax used in macros is different than the pattern syntax used in match expressions because we're matching against actual code versus values. We start off with two parentheses which encompass the entire pattern. And then we have this dollar sign with parentheses which is saying capture any values that match the pattern inside these parentheses for use in the replacement code. The pattern here matches any rust expression and assigns it to the variable $sign X.
00:04:26.477 - 00:05:06.119, Speaker A: Then we see this comma, which means that a literal comma could appear after the code which matches this pattern, and then an asterisk, meaning that our pattern can match zero or more times. So let's see what would happen if we called our macro with 1, 2, and 3 as the input. Our pattern here is going to match three times, once for every expression in the code we pass in. So first we're going to match 1, which is an expression, and assign it to $sign X. Then we're going to match on 2, assign it to $sign X, and then match on 3. Now let's look at the body of our arm. This is the code that's going to be generated.
00:05:06.119 - 00:05:38.497, Speaker A: First we create a vector called temp vec. Then we have these three lines of code which are saying generate this line of code. For every match that we get, the first match we're going to get is a match against one. So one is going to be assigned to dollar sign x and then this line of code is going to be emitted with $sign x being replaced with 1. We'll generate this line of code two more times for the values 2 and 3 so the output would look like this. And that's it. We've defined a simple macro that allows us to create vectors.
00:05:38.497 - 00:06:23.945, Speaker A: Now obviously declarative macros could get a complex and we didn't talk about all the various pattern matching we can do here. I won't discuss that in detail in this video, but in the description I'll link to a book called the Little Book of Rust Macros where you can learn more. If you want to see videos delving deeper into macros, leave a comment down below. One thing to know here is that the Rust team is working on replacing macro rules with another kind of declarative macro. Macro Rules has some strange edge cases which this new kind of declarative macro is supposed to fix, so once it comes out, macro rules will be deprecated again. If you want to learn more, I'll link to the Little Book of Rust macros in the description. That's it for this video on declarative Rust macros.
00:06:23.945 - 00:06:45.965, Speaker A: If you have any questions, or if you want to see more videos about macros, then leave a comment down below. If you haven't already hit subscribe to get weekly Rust videos and most importantly, get your free yes Free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet with that said, I'll see you in the next one.
