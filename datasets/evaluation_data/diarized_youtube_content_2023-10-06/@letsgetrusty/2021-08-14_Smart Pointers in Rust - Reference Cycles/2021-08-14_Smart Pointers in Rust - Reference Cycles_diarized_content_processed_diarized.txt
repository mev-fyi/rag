00:00:00.560 - 00:00:33.714, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the rust programming language. So if you want to see weekly rust videos, make sure to hit that subscribe button. Also, I'm working on a rust cheat sheet which will have important information such as the borrowing rules and the most common smart pointers to use. So if you want access to that when it comes out, make sure to click the link in the description. In the last few videos, we've been going over the various smart pointers in Rust. In this video, we're going to end the Smart Pointer series by talking about reference cycles and memory leaks.
00:00:33.714 - 00:01:19.004, Speaker A: So with that, let's get rusty. The thing rust is known for is being a memory safe language, so it provides certain guarantees, such as you can't have databases. However, it does not provide the same guarantee for memory leaks. Rust makes it difficult, but not impossible to create memory that is never cleaned up. We can create a memory leak by using the RC smart pointer or the reference counting smart pointer and the Refcell smart pointer, which allows for mutability. Using these two smart pointers, we can create references where items reference each other in a cycle, which will create a memory leak. To see why this is the case, let's jump into an example.
00:01:19.004 - 00:02:14.614, Speaker A: Here we have a cons list enum, which we've been using throughout the Smart Pointer series, but in this case we store a 32 bit integer and then a list that's wrapped in the RC Smart pointer and Refcell smart pointer. We use the reference counting smart pointer because we want our list to have multiple owners, and we use the ref cell smart pointer because we want to be able to mutate the list or swap out the list for another list. Down here we also have an implementation block with a convenience method called tail. Here we take an immutable borrower to self, and then we have this match expression. So if our variant is the cons variant, then we get the list from the cons variant and return the list wrapped in sum, and if it's the nil variant, we return none. Next, let's talk about how we would use our list to create a reference cycle. First, we declare list A, which is a cons variant wrapped in the RC smart pointer, because we want this list to have multiple owners.
00:02:14.614 - 00:02:54.108, Speaker A: List A just has one item, which is the integer five, and the second value in the tuple is nil. Then we print out the initial reference count of list a using the strong count function, and after that we print out the next item in a using the tail method, and in this case the next item will be nil. Then we'll create list b, which stores the integer ten and the next item will be list a. And we can do that using a the clone function. After creating list b, we print out the reference count of list a, which at this point should be two. When list a was first created, the reference count was one. Then when we cloned list a into list b, the reference count jumped to two.
00:02:54.108 - 00:03:41.100, Speaker A: Then we print list b's initial reference count, which at this point should be one. And afterwards we print out the next item in list b, which will be list a. Then we're modifying list a to store list b by calling list a dot tail, which will give us the next item in list a. And then we're using the if let syntax because we only care about the sum variant. Remember that the tail method returns an option type which is an enum that could either be sum or none. So if we get the sum variant, it's going to hold a reference to an item which is our list wrapped in the RC smart pointer wrapped in the ref cell smart pointer. Now remember, at this point link is going to hold nil, which is wrapped in RC, which is wrapped in refsal, but we want to change it to have a reference to list b.
00:03:41.100 - 00:04:22.480, Speaker A: Now the rest of smart pointer allows us to mutate the value it holds. So what we'll do is call link dot borrow mu, which will give us a mutable reference to the data. Now that we have a mutable reference, we're going to use the dereference operator to actually change the data, and what we want to change it to is a reference to list b, and we'll do that by calling Rc clone and passing in b. Next we'll print out the reference count of list B, which should now be two. When we first created list B, the reference count was one, and then when we passed b into a, the reference count jumped to two. And lastly we'll print out the reference count of list A, which should still be two. Let's verify this by running our program.
00:04:22.480 - 00:05:05.442, Speaker A: A's initial reference count is one and A's initial next item is nil. A's reference count after creating b is two, because now B has a reference to a, B's initial reference count is one and B's initial. Next item is list A. B's reference count after changing a to reference b is now two and a's reference count remains two. We've just created a reference cycle because list A references List B and list B references list A. To help clarify this, I've used my amazing paint skills to represent this visually. First we'll start off with list A.
00:05:05.442 - 00:05:33.788, Speaker A: On the stack we have a simple pointer which we'll call a, and it points to some memory stored on the heap. In this case we'll call it tick a. Tick a holds the integer five and the value nil. Next we create list b. Again. On the stack we have a simple pointer which we'll call b, and it points to some memory on the heap which we'll call tick b. And tick b stores the integer ten and then a reference to tick a.
00:05:33.788 - 00:06:12.478, Speaker A: And as you can see, the reference count to this piece of data on the heap is two. We have tick a here, and then we also have tick a stored in bhidden. Next we modified list a, so instead of storing nil it would store a reference to list B. And again, as you could see, this piece of data on the heap has a reference count of two because we have tick b here. Then we also have tick b inside of list A. Now if we go back to the code, you can see there's a comment here that says if you uncomment this line right here, then we'll get a stack overflow. Now why is that? Here we're simply printing the next item in list A.
00:06:12.478 - 00:06:36.336, Speaker A: Let's go back to our illustration to see why this is a problem. Here we have list a on the heap. If we print the next item in a, it will be a reference to list b. So we'll have to print list b, which stores list a. Then we'll have to print list a, then list b again. And as you can see, this goes on infinitely, so we'll get a stack overflow. Now these circular dependencies also cause a memory leak.
00:06:36.336 - 00:07:09.166, Speaker A: And why is that? Well, at the end of main a and b will be cleaned up. So let's see what happens when they get cleaned up. First, b will get cleaned up, and as you can see, the memory on the stack will get cleaned up. However, the memory on the heap will not get cleaned up and that's because this memory is still referenced inside of list a. Then a gets cleaned up, and again the stack memory gets cleaned up. However, the memory on the heap does not get cleaned up. That's because this memory location is still referenced here.
00:07:09.166 - 00:07:57.656, Speaker A: Now, as you can see, we're in a situation where we have these two lists allocated on the heap, but we don't have any stack variables pointing to these lists, which means that they're orphaned and won't get cleaned up. So again, reference cycles aren't easy to create, but they're not impossible to create either. If you're mixing reference counting with interior immutability, you need to make sure that reference cycles aren't being created. Creating reference cycles is a logical bug in your code which should be prevented using automated tests, code reviews and other software engineering best practices. So far we've been using pointers that own the data they point to. But if you're in a situation where you can get away with pointers that don't own the data they point to, aka weak pointers, then you can also prevent reference cycles. And that's what we're going to take a look at next.
00:07:57.656 - 00:08:40.556, Speaker A: In this example, we're going to create a tree structure with nodes that know about their child nodes. Here we have our node struct and has two fields value, which is an integer, and children which will be its child nodes. Children is going to be a vector of nodes and node is going to be wrapped in the RC smart pointer because we want variables outside of this tree to be able to point to node so we can traverse the tree. We also want the ability to modify a node's children. So our vector is wrapped in the refsal smart pointer. Here's how we would use our node struct in main first we create a variable called leaf, which is going to be a node that stores the integer three and four children. It's going to have an empty vector.
00:08:40.556 - 00:09:11.406, Speaker A: Then we create another variable called branch which is going to be another node with the value five. And for children we're going to create a vector that stores one node. And in this case we're going to store our leaf node by calling RC. Now in this case we could get to the leaf node from the branch node because leaf is a child of branch. So we could call branch children. But we can't get to the branch node from the leaf node because children don't know about their parent. They don't have a reference to their parent.
00:09:11.406 - 00:09:43.630, Speaker A: So next, let's talk about adding parent references. Now in order to make our node aware of its parent, we're going to add a new field to our node struct called parenthood. Now we want to be able to modify the parent node. So first we'll start with a refcel smart pointer. We also want the ability for variables outside of our tree to be able to reference our parent node. So we want our parent node to have multiple ownership. However, we can't use the RCsmart pointer because this will create a reference cycle.
00:09:43.630 - 00:10:23.724, Speaker A: Luckily for us, we don't need an RC smart pointer. If you think about the relationship of parent to children, then it makes sense for a parent to own its children. When a parent goes out of scope and is dropped, the children should be dropped as well. However, the same is not true the other way. Children should not own their parent. When children are dropped, their parent should not be dropped because of this relationship. Instead of using RC, we can use the weak smart pointer here, and we also need to import weak the weak smart pointer is a version of the reference counting smart pointer that holds a non owning reference.
00:10:23.724 - 00:11:01.686, Speaker A: Now let's scroll back down to main and update our nodes. First, we'll update the leaf node by adding the parent field. At this point our leaf node doesn't have a parent, so we'll create an empty weak pointer calling weak new, which will create a weak pointer without allocating memory. And we'll also do the same thing for the branch node by adding a parent field. Next, we're going to modify Leaf's parent field to store our branch node. Here we're calling leaf parent, which will give us our refcel smart pointer. And then we're calling borrow mute because we want immutable reference to the value stored inside our refcel smart pointer.
00:11:01.686 - 00:11:45.384, Speaker A: And then we're using the dereference operator to actually change the value, and we're going to change the value to point to our branch node. Up here you can see that branch is a reference counting smart pointer, but our parent field expects a weak smart pointer. So in order to transform a reference counting smart pointer to a weak smart pointer, we can call RC downgrade and pass in our reference counting smart pointer. Now let's add some log statements. After we create our leaf node, we're going to print out our leaf nodes parent. Here we're calling Leaf parent borrow because we only need an immutable reference. And then we're calling upgrade, which will attempt to convert our weak smart pointer into an RC smart pointer.
00:11:45.384 - 00:12:34.994, Speaker A: And as you can see, the value we get back is an optional value because the underlying value stored in our pointer may have been dropped. And in that case we'll get back a non variant. If it hasn't been dropped, we'll get us some variant with our RCsmart pointer. We'll also print out Leaf's parent at the bottom of main. Note that whenever we want to see or mutate the value inside a weak smart pointer, we have to call upgrade to upgrade it to an RCSmart pointer because the weak smart pointer has no idea if the inner value has been dropped or not. Now let's go ahead and run our program to see the print statements. As you can see, at first our leafs parent is none, and then after we assign the parent to be our branch variable, we get a some variant with our branch node.
00:12:34.994 - 00:13:17.980, Speaker A: Now internally, the RC smart pointer stores two counts, a strong count and a weak count. The strong count is the number of references which have ownership of the data and the weak count is the number of references that don't have ownership of the data. We can print out these two counts by using the strong count function and the weak count function after we create our leaf node. In this example, we're printing out the strong count and the weak count. At this point the strong count should be one and the weak count should be zero. Next we create an inner scope and inside this inner scope we create our branch node. Then we modify our leaf node such that the parent field is a weak reference to the branch node.
00:13:17.980 - 00:14:02.004, Speaker A: Next we're printing out the strong count and we count of our branch node. In this case the strong count should be one and the weak count should also be one because leaf has a weak reference to branch. Then we're printing out the strong count and we count of our leaf node. In this case, the strong count should be two because leaf is a child of our branch node and then the weak count should be zero. Now, because the branch node was created within this inner scope, when this inner scope ends, the branch node will have a strong count of zero and will be dropped. Note that at this point our branch node still has a weak count of one because leaf has a weak reference to branch. However, the weak count has no influence over whether the underlying value is dropped or not.
00:14:02.004 - 00:14:44.102, Speaker A: At the end of main, we print leaf's parent node, which in this case should be none because branch was dropped. Then we print the leaf nodes strong count and weak count. The strong count in this case is going to be one because again the branch node was dropped and the weak count is zero. All the logic that manages the strong count and weak count is built into the rc and weak smart pointer and their implementation of the drop trait. Let's go ahead and run our program. As you can see, after the leaf node is created, the strong count is one and the we count is zero. After we create our branch node and set the Leafs parent to branch branch will have a strong count of one and also a weak count of one.
00:14:44.102 - 00:15:11.704, Speaker A: The Leaf node will have a strong count of two and a weak count of zero. Then the inner scope ends, and now Leaf's parent is going to be none. And then Leaf's strong count is back to one and the weak count is zero. That concludes chapter 15 of the wrestling book and our mini series on smart pointers. If you enjoyed this video, make sure to smash that like button. And if you want to see weekly rust content, you already know what to do. Make sure to subscribe and hit the notification bell.
00:15:11.704 - 00:15:27.480, Speaker A: Lastly, I'm going to be releasing a rust cheat sheet very soon, which includes things like the borrowing rules and the most common smart pointers, etc. Etcetera. If you want to be notified when that gets released, click the link in the description and with that, I'll see you in the next.
