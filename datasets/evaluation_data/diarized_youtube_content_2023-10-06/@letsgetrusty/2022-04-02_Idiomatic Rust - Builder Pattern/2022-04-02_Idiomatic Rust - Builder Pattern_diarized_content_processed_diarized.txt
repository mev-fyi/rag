00:00:00.400 - 00:00:35.659, Speaker A: What's Up, Rustations? And welcome back. In today's video, we're going to be continuing our series on idiomatic Rust by talking about the builder pattern. But before we get to that, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet. With that said, let's get rusty. In this example we have a struct called Server, which represents configuration options for an HTTP server. Options include the host and port.
00:00:35.659 - 00:01:26.707, Speaker A: The server will be running on an optional TLS certificate, hot reloading, and the timeout in milliseconds. Let's say that we want to make this struct public, but keep the fields private. Instead, the fields will be initialized with the new constructor function. First, we'll create an implementation block for server. Then we'll add an associated function called new, which takes host and port. To construct a basic server instance, all we need to pass in is the host and port number. By default, TLS will be set to none, hot reloading will be set to false, and the timeout will be set to 2000 milliseconds.
00:01:26.707 - 00:02:14.475, Speaker A: This works for basic cases, but let's say we also want the ability to construct an HTTP server with a TLS configuration. Rust does not support function overloading, so we can't create a second function called new, which takes more arguments. Instead, one option we have is to create another constructor function with a different name. In this case, the function is called newtls. It takes a host port and an additional TLS argument. With this constructor, host, port and TLS are configurable while hot reloading and timeout are set to their default values. Let's take this one step further and create a third constructor which allows us to set all the fields in the server structure.
00:02:14.475 - 00:03:08.155, Speaker A: This third and final constructor is called NewAdvanced. It takes a host port, TLS, hover, load, and timeout as arguments. Let's see how we would use these three constructors in main. First we'll add three variables, host, port, and certify. Then we'll construct a basic server instance. We'll also create a server instance using the TLS constructor. And finally, we'll create a server instance with all fields configured using the advanced constructor.
00:03:08.155 - 00:03:49.535, Speaker A: Our code is compiling. However, the API of Server could be improved. Right now we have three different constructor functions with different names, and the list of arguments passed to each function keeps getting bigger and bigger. Imagine if more fields are added to server. We might need to Create new constructor functions with even longer argument lists. To prevent the proliferation of constructor functions, we can use the builder pattern to construct new instances of server. First we'll add a new struct called Server Builder.
00:03:49.535 - 00:05:12.525, Speaker A: Server Builder has the same fields as Server, except host and port are the only non optional fields. Next we'll create an implementation block for Server Builder and add methods to set each of the optional fields. Each method will be named after the field it's modifying. For example, this method is called tls. It takes a mutable reference to self and an argument called TLS Inside the function body, TLS is set to the sumvariant and a mutable reference to self is returned. We'll add two more similar methods for the hot reload and timeout fields. The last method we'll add is called build, which will return a server instance.
00:05:12.525 - 00:05:59.039, Speaker A: Build takes a mutable reference to self and constructs a new server instance. For hot reload, we either unwrap the sumvariant or return the default value of boolean, which is false. And for timeout we either unwrap the sumvariant or set timeout to 2000 milliseconds. Server Builder is now complete. Next we'll modify Server. First we'll get rid of the new, advanced and new TLS constructor functions. We'll have a single constructor called new, but instead of returning self, it will return.
00:05:59.039 - 00:06:57.565, Speaker A: Server Builder, host and port will be passed through to the server builder instance while TLS, hot reload and timeout will be initialized to the none variant. Our implementation of the builder pattern for server is now complete. Let's use it in main. For Basic Server, the code stays mostly the same, except now the new function returns. A server builder to get a server, we have to call the build method. For the TLS server we'll call new, and then the TLS method and finally build. And finally for the fully configured server, we'll call new and then the tls, hot reload and timeout methods.
00:06:57.565 - 00:07:51.271, Speaker A: Once again we have three servers with different levels of configuration, except this time we're calling one constructor function and a bunch of useful methods to build up the configuration. With this pattern, the server struct could easily be extended with new configuration fields. One last thing I'd like to mention is that if you don't want to write a bunch of boilerplate code to implement the builder pattern, then you can use the derived builder crate. This crate provides a rust macro that automatically implements the builder pattern for an arbitrary struct. Alright that's it for this video. If you want access to the code, a GitHub link is in the description. Make sure to leave a comment if you enjoyed this video, poke that like button.
00:07:51.271 - 00:08:02.735, Speaker A: And most importantly, if you haven't already, get your free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet with that said, I'll see you in the next one.
