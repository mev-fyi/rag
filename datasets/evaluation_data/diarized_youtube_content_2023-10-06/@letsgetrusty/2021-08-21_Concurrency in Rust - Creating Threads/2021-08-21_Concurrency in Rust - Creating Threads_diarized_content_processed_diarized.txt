00:00:00.480 - 00:00:43.757, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. If that sounds appealing to you, make sure to hit subscribe for weekly Rust content. Today we're starting chapter 16 of the Rustling Book, and it's titled Fearless Concurrency. One of the goals of the Rust language is handling concurrent programming safely and efficiently. Concurrent programming is when different parts of your program execute independently, and parallel programming is when different parts of your program execute at the same time. These two concepts are closely tied, so for simplicity for the remainder of this chapter, when you hear concurrent, know that it means concurrent and or parallel.
00:00:43.757 - 00:01:41.703, Speaker A: By leveraging Rust type system and powerful ownership model, a lot of concurrency errors are able to be caught at compile time. Because of this, you're able to write code that is free of subtle bugs and and is easy to refactor without introducing new bugs. Which is why Rust uses the term fearless concurrency. Because Rust is a lower level programming language, it has various solutions to handle concurrency problems, and we'll explore those solutions throughout this concurrency series. So with that background, let's get rusty. In most current operating systems, an executed program's code is ran within a process, and the operating system manages running multiple processes at once. Within a program, you can have independent parts that run simultaneously, and the features that run these independent parts are called threads.
00:01:41.703 - 00:02:42.161, Speaker A: Splitting your program's computation into multiple threads can improve performance because multiple parts of your program are running at the same time, but this also increases complexity. Because threads run simultaneously, you don't have control over the order in which different parts of your program are executed, which leads to some unique challenges. One such challenge are race conditions, where threads are accessing data or resources in an inconsistent order. Another challenge are deadlocks, where we have two threads that are both waiting for a resource that the other thread has, thus making both threads wait indefinitely. Lastly, because execution order is non deterministic, bugs can appear that only happen in certain situations and are hard to reproduce and fix reliably. Rust attempts to mitigate the negative effects of using threads. However, it's on the programmer to be thoughtful when designing their program for a multithreaded context.
00:02:42.161 - 00:03:25.901, Speaker A: Now, there are two main types of threads. One to one threads, also called OS threads, native threads, system threads, etc. And green threads, also called user threads or program threads, etc. Many operating systems provide an API to create new threads. One to one threads mean that when you create a thread in your program, it maps to an operating system thread, so there's a one to one mapping. Many programming languages provide their own special implementation of threads, which we call green threads. Green threads do not have a one to one mapping with operating system threads, so you can have 20 green threads that map to only five operating system threads.
00:03:25.901 - 00:04:09.883, Speaker A: This is why we call the green thread model an M to N model, because there are m green threads that map to n operating system threads. Each model has its advantages and trade offs, and the trade off most important to Rust is runtime support. By runtime I mean the code that's included by the programming language in every single binary. Rust aims to have an extremely small runtime, in fact, almost no runtime at all. Now, the trade off is sacrificing features, because the more features we include out of the box, the larger the runtime will be. Because green threads would require a larger language runtime. Rust only includes one to one threads or OS threads in its standard library.
00:04:09.883 - 00:05:08.031, Speaker A: However, if you would like to use green threads with the trade off of having a larger binary, then you could use crates that provide such functionality. Now that we've talked about threads in the context of Rust, let's jump into creating some threads in code. Here I have an empty main RS file, and the first thing we're going to do is import thread from the standard library. Then, in order to create a new thread, we're going to call the spawn function on thread and pass in a closure. Inside our thread, we're going to loop through a range of integers and then we're going to print the number and let the thread sleep for a millisecond. We'll also need to import duration. Outside of our spawn thread, we're also going to loop through a range of 1 to 5 and print the number.
00:05:08.031 - 00:05:59.465, Speaker A: Here you can see we're printing out the number and letting the thread sleep for 1 millisecond. By default, every program has one main thread, so in this case, we're letting the main thread sleep for 1 millisecond. Also, thread sleep here just means that we're going to pause execution of this thread for a specified amount of time. To summarize, we've spun up a thread, and within the thread we're going to count from one to 10, and for every number we're going to print the number and let the thread sleep for a millisecond. In our main thread, we're also going to loop from 1 to 5, print the number and let the thread sleep for a millisecond. Let's run our program to see what happens. Here we can see we got number one printed from our main thread, then number one printed from our spawn thread, number two from main, number two from spawned, three from main, three from spawned, four from main, and then we have four and five from our spawn thread.
00:05:59.465 - 00:06:38.885, Speaker A: Note that the output might look different on your computer because again the execution order is non deterministic. Also notice that the main thread finished printing all of its numbers. We had a range from 1 to 5, so we printed 1 to 4, but the spawn thread didn't finish printing all of its numbers. The range was one through 10, but we only got to number five. And this is because when the main thread ends, the spawn thread is stopped, no matter if it finished executing or not. Next, we'll look at how we can modify our code to allow the spawn thread to finish execution. The first thing we'll do is store the return value of the spawn function, which will be a join handle type.
00:06:38.885 - 00:07:34.625, Speaker A: Then at the end of main we'll call handle join, which will wait for our thread to finish executing. We'll also need to call unwrap because join returns a result type. Calling join will block the thread currently running, which in this case is the main thread, until the thread associated with the handle, which is the spawn thread, terminates. Blocking a thread means that the thread is prevented from doing any further work or exiting. Let's run our program again to see how the output has changed. As you can see, the two threads alternate in execution until we get to the end of the main thread, and then our spawn thread is allowed to finish executing by printing out the rest of its numbers. Now let's see what would happen if we take this handle joincall and move it right after our spawn thread is created.
00:07:34.625 - 00:08:13.761, Speaker A: Because we called join right after our spawn thread was created, the main thread will wait for the spawn thread to finish executing. So we print 1 through 9 before printing out the numbers in the main thread. Small details, such as where the join method is called can affect whether or not your threads run at the same time. Next, let's talk about using move closures with threads. Up until this point, when we spawned a thread, the thread didn't depend on any variables outside of the thread. But let's take a look at the following example. We have a variable called V in the main thread, which is a vector, and then we spawn a new thread.
00:08:13.761 - 00:08:55.669, Speaker A: And inside the new thread we want to print out the vector we created in the main thread. But as you can see, we have some red squigglies here indicating a compile time error. And if I hover over you can see there are a few errors, one of which states that the closure may outlive the current function, but it borrows V which is owned the current function. Rust sees that V is being used inside our closure, but it's declared outside of our closure. So Rust will infer how to capture V. And because V is only used in this print line statement, Rust will infer that we only need a reference to V. However, this is a problem because Rust doesn't know how long this spawn thread will run for, so it doesn't know if V will always be a valid reference.
00:08:55.669 - 00:09:56.677, Speaker A: Imagine if after spawning a new thread, we call the drop function on V. If we were allowed to write this code, then there's a possibility that when we run our program, we would spawn this thread immediately, switch back to the main thread, drop the value V, then switch back to the spawn thread, at which point V would be invalid. Because Rust doesn't know how long our thread will run for, Rust doesn't allow us to take a reference to V inside the closure. And if we hover over this red squiggly here, you can see it gives us a hint, and the hint states to force the closure to take ownership of V, Use the move KEYWORD in chapter 13, we learned about closures and the move keyword. If we put the move keyword in front of our closure, we're telling Rust don't infer that the values inside our closure are borrowed. Instead, what we explicitly want is to move values inside the closure or have the closure take over ownership of the values. After specifying the move keyword, we no longer have a compile time error.
00:09:56.677 - 00:10:30.375, Speaker A: And that's because now V is moved inside of the spawn thread, which means it can no longer be used inside of main. If I try to call the drop function on variable V again inside of main, you'll see we get a compile time error which states that we cannot use V after it has been moved. That's it for this video. If you found it useful, make sure to tap the like button, and if you want to see weekly Rust content, make sure to hit subscribe. Also, I'm going to be releasing a Rust cheat sheet, so if you want access to that, make sure to click the link in the description, and with that I'll see you in the next one.
