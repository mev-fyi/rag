00:00:00.320 - 00:00:46.627, Speaker A: A little while ago, I made a video going over Chapter 11 of the Rustling Book, which talked about writing automated tests in Rust. In that video, we learned how to write basic unit tests in Rust, but there was one big piece that was missing. Unit tests are meant to be fast, reliable and deterministic. But what happens when your code is making API calls or database queries, or manipulating the file system? When writing unit tests, we don't want to be doing things like making database queries. That's because database queries could be slow, they're unreliable if there's a network outage, and they're non deterministic because the state of the database changes over time. Fortunately, we don't have to. Instead, we can use a technique called mocking.
00:00:46.627 - 00:01:51.537, Speaker A: Mocking allows us to substitute real objects, such as traits or structs, with their fake or mock implementations, which mimic the public interface of the real objects, except they don't execute the underlying code. Mock objects also keep track of how they're being used, so we can assert that, for example, a function is called x amount of times with certain parameters. All right, with the theory out of the way, let's jump into some code to see how we would use mocking in practice, I went ahead and created a new project with a library crate. As you can see, I have lib RS open, which comes with a default test module, which we're going to ignore for now. In this example, let's say we want our library to expose one public function which is called get user. Get user will query a database and get a user based on an id. The first argument is going to be called DB and it's going to be pointing to an object that implements the database trait.
00:01:51.537 - 00:02:33.475, Speaker A: We'll implement the database trait in just a moment. The second argument is going to be called id, which represents the ID of the user we want to get. Because this is just an example, we're not going to have a return type. Alright, now that the signature of getuser is complete, let's implement the database trait. The database trait defines one method called executequery, which will take a query string and execute it against a database. Next, let's implement the function body for getuser. First we're going to construct a query, in this case a SQL query where we select all columns in the users table where ID is equal to the ID passed in, and then we'll call execute query on the database instance passed in.
00:02:33.475 - 00:03:09.085, Speaker A: Now that our library is complete, let's say we wanted to test the getuser function. Specifically, we want to ensure that the correct Query gets executed, but we don't actually want to execute the query against a live database. So instead of passing in a real database instance, we'll pass in a mock database instance. Our mock instance will keep track of how many times execute query gets called and what arguments are passed in. Now we can construct the mock instance ourselves by creating a struct that implements the database trait. But that would be tedious. So instead we're going to use a mocking library called machall.
00:03:09.085 - 00:03:40.247, Speaker A: So we'll open up cargo toml and add macall as a dependency. Then we'll go back to lib RS and use mocall. Then we'll add the auto mock attribute to our database trait. This attribute up here means that we're only going to bring mock all into scope when running cargo test. And this attribute means we're only going to apply auto mock to our database trait when running cargo test. And that's it. Our database trait will now have an automatic mock implementation.
00:03:40.247 - 00:04:17.135, Speaker A: So next let's create our test. We'll scroll down and replace it works with getuser executes correct query. Then we'll bring all items from our parent module into scope. Inside our test function, we know we want to call get user with some sort of mock database and then a random ID. In this case, I'm going to use 22. Now we just have to create our mock database. Mock all has already created a mock database for us which is going to have the same name as our trait prefixed with mock.
00:04:17.135 - 00:04:55.131, Speaker A: So in this case mock database. And here we're getting a mismatch types error because remember, we have to wrap our database in a box. Smart pointer. All right, now we have a mock database and we're passing it into get user. The last thing we want to do is assert that get user calls execute query on our mock database with the correct query. We can do this using something called expectations. For example, we can say mock database.expect
00:04:55.131 - 00:05:28.845, Speaker A: execute query. This is saying we expect execute query to be called on our mock database. In order to call expect execute query, we also have to make our mock database mutable. Then we can call the with method to make sure we got the right arguments. In this case, because we're passing in 22, we expect our query string to contain 22. Next we'll call once to assert that execute query is only called one time. And finally we'll call the returning method.
00:05:28.845 - 00:06:14.525, Speaker A: We must specify what we expect execute query to return. In this case, execute query doesn't return anything, so we pass in a closure that returns a unit type and with that our test is now complete. Notice that we don't have any assert statements in our test. Instead we pass a mock database to get user and use various methods to set expectations on our mock database which if broken, will fail the test. If we run our test, you can see that it passes. If we close the terminal and change 22 to 11 and run the test again, you'll see that it fails. We get a failure here because we're expecting our query string to include 22, but we're passing in 11.
00:06:14.525 - 00:06:33.965, Speaker A: Alright, that's it for this video on the basics of mocking in Rust. If you want to see more test related videos, leave a comment down below. And most importantly, get your free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet with that said, I'll see you in the next one.
