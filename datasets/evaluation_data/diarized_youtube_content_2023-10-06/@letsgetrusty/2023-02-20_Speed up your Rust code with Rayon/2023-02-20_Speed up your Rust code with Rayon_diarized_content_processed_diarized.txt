00:00:00.280 - 00:00:46.959, Speaker A: Rayon is a data parallelism library for Rust, which makes it easy to add parallelism to your sequential code. It's extremely lightweight and guarantees data race freedom. In this video, we'll go over Rayon's API, how to use it in practice, how Rayon works under the hood, and some customizations you could take advantage of. But before we get started, if you haven't already, make sure to get your free Rust cheat sheet@letsgetrusty.com cheatsheet with that said, let's get rusty. Rayon can be used through its low level APIs like the join function, which takes two closures and potentially runs them in parallel. Or its high level API like the Parallel Iterator trait, which is a parallel version of the Iterator trait in the standard library.
00:00:46.959 - 00:01:27.967, Speaker A: Let's see how the high level API works. In this example, we have a function called numberofadults which takes a vector of people, turns it into an Iterator, filters out anyone under the age of 18 and returns the count. Currently this operation is done serially, but we can parallelize it with Rayon. To use the high level Rayon API, we must first import a few traits. Instead of importing each trait individually, we can simply import the Rayon Prelude. Then on line 8, we'll change iter to to par iter. And just like that, our filter operation is now parallelized.
00:01:27.967 - 00:02:11.045, Speaker A: This pattern of importing a trait and getting extra methods on existing types is called extension traits, and I'll talk about it in a separate video. Let's see how using Rayon impacts performance. First, we'll make a clone of this function and prefix the name with par. Now that we have a version that uses Rayon and a version that does not use Rayon, let's add some benchmark tests. Note that benchmark tests require the nightly version of Rust. First, we must enable the test feature and import the test crate. Then we'll add our benchmark tests.
00:02:11.045 - 00:03:16.849, Speaker A: We've added two tests, one that tests the Rayon version and one that tests the version without Rayon. For each test, we'll create an array of 200,000 people with an age randomly selected between 13 and 80. Let's go ahead and run these tests. Looking at the results, we could see that the version without rayon took 28,000 nanoseconds and the version with rayon took 134,000 nanoseconds. Okay, I think I know what's going on. Rayon dynamically picks whether to run an operation serially or in parallel. However, the first time it runs an operation, it defaults to running it in parallel.
00:03:16.849 - 00:04:09.439, Speaker A: In Our case, running the filter operation on the people vector in parallel will actually lead to worse performance because our filter logic is very simple. To fix this, we could either do two things. Either make the filter logic more complex or increase the size of our vector. Let's go ahead and increase the size of our vector. We'll Change it from 200,000 people to 2 million people and rerun the tests. Now we can see that the version with Rayon is performing better than the version without Rayon. We've seen Rayon in practice Next, let's talk about how it works under the hood to run operations in parallel, Raion spins up a thread pool and async runtime.
00:04:09.439 - 00:05:04.515, Speaker A: It uses a technique called work stealing, similar to Tokyo, which allows idle threads to steal tasks from other threads, making the async runtime more efficient. One of the big ideas of Raion is potential parallelism. In the beginning of this video I mentioned that the low level function join takes two closures and potentially runs them in parallel. Rayon may run the closures serially or in parallel based on certain conditions, like whether idle cores are available. Also note that Partiter is a thin abstraction on top of Join, so it uses potential parallelism as well. The idea is to annotate your programs with calls to Join, Partiter or any other Rayon API to indicate where parallelism might be a good idea and let Rayon decide when to take advantage of that. This approach has some pros and cons.
00:05:04.515 - 00:06:04.995, Speaker A: Knowing when to parallelize can be hard to figure out at compile time. You need certain information only available at runtime, like does the computer have idle cores? Or what other parallel operations are currently happening. Moving this complexity into a library and making it an implementation detail removes the burden from library users and simplifies the library's API. One downside of this approach is that it's more restrictive. For example, you cannot use channels to communicate between closures passed to the join function because it could cause a deadlock if Rayon decides to execute the closures serially, and this may not be obvious to users of the library. You can, however, still use Mutex and atomic types, so Rayon is great for divide and conquer type of algorithms where communication between threads is not necessary. Another way to think about it is that Raion works well for sequential algorithms that could benefit from parallelization.
00:06:04.995 - 00:06:34.265, Speaker A: Rayon is dead simple to use. However, it also offers some customization in case you need it. For example, you can create a custom thread pool and pick the number of threads it contains. That's it for this video on Rayon. Let me know in the comments section down below which rust crate I should cover next. And if you enjoyed this video, make sure to give it a like. Last but not least, if you haven't already, get your free rust cheat sheet by heading over to LetsGetRusty.com
00:06:34.265 - 00:06:39.395, Speaker A: CheatSheet with that said, I'll see you in the next one.
