00:00:00.440 - 00:00:29.124, Speaker A: You might have been told that Rust is complex, but that's not true. Rust is actually way more complex than you think. In this video, I'll show you the different ways Rust hides its intricate complexity from us. First, let's start with a seemingly simple hello world program. Looks straightforward, right? Just a main function and a print statement. But this is not what the compiler sees. Notice that print line isn't a function, it's a macro, which means it expands into more complex code at compile time.
00:00:29.124 - 00:01:08.004, Speaker A: There's also additional hidden code in this example that isn't generated by the macro. To reveal this hidden code, we can use a tool called cargo expand. Cargo expand is a powerful development tool that shows us the full rust code that the compiler sees after expanding macros and applying compiler transformations. If we run cargo expand, our hello world example will expand into the following code. Let's go through it step by step. The first three lines import the prelude, which is a set of commonly used items defined in the standard library, including commonly used traits, the box smart pointer, and the option and result enums. The first line enables the Prelude import feature.
00:01:08.004 - 00:01:51.950, Speaker A: Features often represent unstable or evolving functionality. The prelude import feature allows the Rust team to modify how the compiler internally handles importing the prelude, allowing for potential optimizations without affecting stable user code. The second line is a special attribute that ensures the prelude items are available throughout your entire codebase. And the third line is what actually imports all of the items from the Rust 2021 editions Prelude into the current scope. Rust editions are a mechanism for introducing breaking changes without forcing everyone to upgrade. Every three years, a new edition is released, which introduces new features and syntax. But here's the magic additions are opt in so you're not forced to upgrade.
00:01:51.950 - 00:02:39.664, Speaker A: Each crate gets to pick the addition it uses, and crates in one edition must seamlessly interoperate with those compiled in other editions. This means you get the benefit of new features without the downside of breaking existing code. The next two lines tell the compiler to use the Rust standard library. Macrouse is an attribute that allows macros from the standard library to be used without explicit imports, and the extern create standard declares a dependency on the standard library and instructs the compiler to link against it. In newer versions of Rust, extern crate is not needed for most crates because the compiler automatically links dependencies defined in cargo toml. The extern crate standard line is used here to support older versions of Rust. Next, let's look at the code in main this is what our print line macro expands into.
00:02:39.664 - 00:03:32.792, Speaker A: Underscore print is a low level function in Rust's IO module that handles the actual string printing formatargs is another macro that handles string formatting and any formatting arguments. Its a special macro thats built directly into the compiler and doesnt actually expand into rust code. If we look at the definition for print, we see that it calls an even lower level function print two, which accepts the formatted string arguments, a buffer, which in this case is stdout, and a label. Print two then prints the string to the buffer and handles any possible errors. Going back to our hello world example, we see that print is called within an innerscope. This is part of how Rust handles macro expansion. The inner scope ensures that temporary variables or expressions created during macro expansion don't leak into the surrounding scope, and helps prevent unintended variable shadowing or lifetime issues.
00:03:32.792 - 00:04:39.590, Speaker A: Now, in order to run this expanded code, we need to switch to the nightly compiler and enable the print internals feature, because this code uses internal compiler features that aren't part of Rust's stable public API. And now we're able to run our hello world example. As you can see, Rust does a lot of work behind the scenes, even for simple programs. Macros like println expand into more complex, optimized code. Rust automatically imports commonly used items and links to the standard library, and even simple operations have safety checks and optimizations that we don't see. And Rust's approach of managing complexity extends far beyond our hello world example, from automatically managing memory with the ownership system to simplifying error handling with the result type and the question mark operator, to providing built in tools like a package manager, linter and formatter, Rust consistently strives to manage complexity and make our lives easier. So next time you write hello world and Rust, remember you're not just printing a string, you're using a powerful, safe, and efficient programming language that's doing a lot of heavy lifting for you, even if you might have been told otherwise.
00:04:39.590 - 00:04:53.690, Speaker A: If you need help becoming a rust developer or are just curious about the opportunities, make sure to get your free four day training@letsgetrusty.com. bootcamp hope youve enjoyed this video, and remember to stay rusty.
