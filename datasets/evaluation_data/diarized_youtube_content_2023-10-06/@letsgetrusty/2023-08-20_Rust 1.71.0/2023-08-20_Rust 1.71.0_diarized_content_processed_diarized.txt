00:00:00.360 - 00:00:28.700, Speaker A: In this video, I'm going to go over the latest release of Rust version 171.0. Specifically, I'll cover the five big updates, which are the Cunwind ABI. The newly added debugger visualization attributes raw Dilib, linking the upgrade to muscle 1.2, and const initialized thread locals. With that said, let's get rusty. The first update in this release is the stabilization of the Cunwind ABI. To understand this feature, we must first understand unwinding and abisde.
00:00:28.700 - 00:01:09.110, Speaker A: Unwinding is the process that occurs when your program panics. The program walks back through the stack frame by frame and cleans up resources before gracefully terminating. The alternative to unwinding is aborting, which means terminating the program as soon as a panic is encountered. Although this is simpler and more performant, it could lead to resources not being properly cleaned up. In rust, you can configure whether you want your program to unwind or abort when a panic occurs. ABIs are often compared to APIs APIs define how software interacts at the source code level, while ABIs define how software interacts at the binary level. This allows software built in one language, like rust to interact with software built in another language like C or C.
00:01:09.110 - 00:01:57.794, Speaker A: The C ABI is a set of conventions defining how C programs are compiled and linked, ensuring consistent binary level interaction. Because of CS long history and ubiquity, the CABI is often used as the standard for inter language interoperability. The problem is the CABI does not support unwinding, so if unwinding crosses the ABI boundary, it causes undefined behavior. Fortunately, in this release, the c unwind ABI was stabilized, which allows for safe unwinding across the ABI boundary. This allows rust to be used in more complex applications that require safe interoperability with other languages. For example, rust can now be used to write libraries that can be called from C. The second update in this release is the new debugger visualization attributes, which can be used to improve third party debugger outputs.
00:01:57.794 - 00:02:37.222, Speaker A: For example, we can add the debugger visualizer attribute to this person, struct and embed visualizer files. The GNU debugger uses a python script that describes how a type should be visualized. In the debugger view. Microsoft debuggers like Visual Studio use nav is, which is an XML based framework. These visualizer files improve your debugging experience by allowing you to control what you see in debugger outputs. The third major update in this release is the introduction of raw dialib linking for Windows platforms to understand this feature, it's essential to explain a bit about linking and share libraries. Linking is the process of combining various compiled object files and libraries into a single executable or library.
00:02:37.222 - 00:03:26.340, Speaker A: Linking can be static or dynamic. Static linking includes all the required library code into the final executable at compile time, producing a larger but self contained binary. In contrast with dynamic linking, the final executable contains references to shared libraries, which could be used by multiple programs at the same time. When a program runs, these shared libraries are loaded into memory as needed. A dynamic link library, or DLL, is Microsoft's implementation of shared libraries. Before this release, linking against a Windows DLL required the associated import library to be available at build time, meaning you had to ship that library with your project. You can now avoid this headache by using the kind option and setting it to raw dialib in the link attribute, allowing rust to generate bindings to DLL functions without needing import libraries to be present at build time.
00:03:26.340 - 00:04:11.140, Speaker A: You can also bind to symbols provided by DLL's by ordinal, rather than named symbols using the new link ordinal attribute. This change simplifies crates providing bindings to Windows libraries and makes it easier to cross compile rust programs. The fourth update in this release is updating all Linux muscle targets to version one. 2.3 muscle is an implementation of the C standard library, which is lightweight, efficient, and simple, making it ideal for embedded systems, containers, and programs that require static linking. The most notable update in this new version of muscle is the introduction of 64 bit time. This means data types and functions can represent time past the year 2038, whereas the existing 32 bit type on 32 bit architectures would overflow.
00:04:11.140 - 00:04:45.860, Speaker A: The fifth update in this release is newly added documentation for the const initialized thread locals feature. This feature allows developers to create thread local variables that are initialized with a constant expression. This can be useful when storing data that should not change, such as configuration data or cryptographic keys. This feature was actually stabilized in Rust version 159.0, but never documented until now. For more details about this release, ill leave a link to the official blog post in the description. If youve enjoyed this video, make sure to leave a like subscribe for weekly rust content and remember to stay rusty.
