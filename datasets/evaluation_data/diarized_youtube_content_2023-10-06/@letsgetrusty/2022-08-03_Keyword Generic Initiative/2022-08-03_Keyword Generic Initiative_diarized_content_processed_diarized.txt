00:00:00.560 - 00:00:42.331, Speaker A: Recently, a new blog post was published on the Inside Rust blog announcing the Keyword Generics initiative. In this video, we'll go through the goals of the initiative, the problems being solved, and how this initiative could help Async Rust. But before we get started, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheatsheet Currently, Rust allows a function to be generic over types. For example, this function accepts any type that implements the debug trait. However, Rust does not allow functions to be generic over over whether a function is async or not, whether a function can fail or not, or whether a function is const or not. These properties are represented by keyword modifiers like async or const.
00:00:42.331 - 00:01:50.305, Speaker A: The goal of this initiative is to make it possible for functions to be generic over these keyword modifiers, hence the name Keyword Generics. To understand why this is important, let's take a look at one keyword modifier async the problem with async today is that library authors duplicate code for async and non async contexts, with the only difference being the async keyword. For example, a library may define async functions in a crate named foo and define synchronous versions of those functions in a crate called blocking foo by wrapping the async functions in a call to block on. This is not ideal for two reasons. First, we're going through an async runtime to get the same results, which is often not zero cost, but more importantly, we have to keep these two versions of our library in sync with each other, which is hard to do in practice without automation, leading to mismatched functionality. A good example of this is the Async standard library crate, which is a minimal async version of the Rust standard library. This library has to duplicate a large part of the standard library's API surface and keep in sync with the standard library as it changes over time.
00:01:50.305 - 00:02:30.713, Speaker A: The Rust developer community has come up with several solutions to this problem, most notably the maybeasync procedural macro crate. This macro will automatically generate async and async variant of a function for you. However, it does have clear limitations with respect to diagnostics and ergonomics. This is not an issue with the crate, but rather the inherent complexity of the problem being solved. Now that we've talked about the duplication problem, let's talk about another problem, the sandwich problem. The sandwich problem occurs when a type passed into an operation wants to perform control flow not supported by the type it's passed into. The classic example is a map operation.
00:02:30.713 - 00:03:06.123, Speaker A: Here we have the enum option, which has a map method that takes an option of one type and converts it to an option of another type. On the last line we call map. On an instance of option inside the closure, we await on the type stored inside the sumvariant. This results in a compile time error. We cannot call await inside the closure because it's not an async context. We cannot convert the closure to be async itself because the map method doesn't know how to call async functions. To solve this problem, we could provide a new method called async map, which does provide an async closure.
00:03:06.123 - 00:03:40.639, Speaker A: However, this can result in an explosion of methods, especially if we add other effects, for example a map method that can fail and can be async. If this was the case, we would have to have four different methods for each combination. As you can imagine, this list will grow exponentially if we add more states. Keyword generics would help solve both the duplication problem and the sandwich problem. Let's see how they would work in practice. Here's an example of a trait and a function being generic over asynchronous. Note that this syntax is entirely made up for this example and is subject to major changes in the future.
00:03:40.639 - 00:04:18.659, Speaker A: In this example we have a trait called read with two methods, read and readtostring. The generic a after the async keyword means that this trait is generic over asynchronous. We also have a function called read to string which accepts a reader. Inside the function body, we create a string instance and then call reader readtostring passing in the string instance. This function is also generic over asynchronous. You can think about the generic a as a flag which indicates whether the function is being compiled in an async context or not. The generic a is also forwarded to the impl read, making that conditional on asynchronous as well.
00:04:18.659 - 00:05:14.513, Speaker A: Notice that in the function body we're using await after calling readtostring. For technical reasons, this is required to be written and will essentially be reduced to a no op in non async mode. Again, note that this syntax is entirely made up, but it should give you an idea of what this initiative is working towards. Now you may be wondering, wouldn't this make the Rust programming language more complicated? The goal of this initiative is not to minimize the complexity of the Rust programming language, but rather to minimize the complexity of programming in Rust, choosing between Sync or Async code is a fundamental choice which needs to be made. This complexity cannot be avoided and needs to exist somewhere. This initiative aims to help library authors support both Sync and Async versions of their library with the help of the compiler, and leave it up to the application authors to decide how they want to compile their code. Another aim of this initiative is maximal backwards compatibility.
00:05:14.513 - 00:06:04.379, Speaker A: However, they did state that this is one of the hardest aspects of this feature. It's also worth noting that despite this video only talking about the Async keyword, this feature is being designed with other keywords in mind as well. For example, there are thoughts about adding a keyword for failability in the future, with a couple options for syntax being talked about, such as adding try before the function signature or returning throws. This initiative just started and is in the pre RFC phase. The current goal is to enumerate the full problem space design space and find a balanced solution and eventually summarize that in the form of an rfc. Then, after the RFC is accepted, implement it in nightly, work on the kinks, and eventually move it to stable. However, during some point in this process, it's possible for the team to conclude that this initiative is infeasible.
00:06:04.379 - 00:06:17.535, Speaker A: Let me know in the comments below what you think about this initiative. And before you go, if you haven't already, get your free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet with that said, I'll see you in the next one.
