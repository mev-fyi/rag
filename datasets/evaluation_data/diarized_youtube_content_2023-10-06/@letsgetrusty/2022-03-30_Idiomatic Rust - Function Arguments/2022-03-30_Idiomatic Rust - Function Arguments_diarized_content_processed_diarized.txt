00:00:00.480 - 00:00:39.091, Speaker A: What's up, Rustations? In today's video, we're going to be talking about the idiomatic way to pass borrowed arguments into functions. But before we get to that, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com CheatSheet. With that said, let's get rusty. In the following example, we have a trait called animal with one method called speak and two structs. The first struct is cat, has a field called name and it implements the animal trait. The second struct is called dog.
00:00:39.091 - 00:01:47.163, Speaker A: It also has a name and implements the animal trait. Let's create two instances of these structs in main. First we'll create two pet names. Next we'll create an instance of a cat named Pina and an instance of a dog named Oreo. And finally we'll create a vector of animals. To create a vector of animals, we have to use a trait object, and trait objects have to be behind some sort of reference. In this case, we're using a box smart pointer.
00:01:47.163 - 00:03:08.145, Speaker A: This means that we have to box cat and dog. All right, now that we have some types defined string to represent names. A cat instance and a dog instance, and a vector of animals, let's define some functions which take these types as arguments. The first function we'll create is called print animal name. Print animal name does not need to take ownership of name, so we pass in a reference to a string. Next we'll create a function called print dog. In main, we could see that dog is a box smart pointer containing a dog instance.
00:03:08.145 - 00:03:59.065, Speaker A: So that's the type we pass into the printdog function. However, we don't need to take ownership of dog, so instead we use the borrowed form. The last function we'll implement is called animalsounds. Animal sounds takes an argument called animals, which is a vector of animal trait objects. We don't need to take ownership of the vector, so we use the borrowed form. Let's use these functions in main. First we'll call Print animal name and pass an Oreo.
00:03:59.065 - 00:04:50.753, Speaker A: Then we'll call print dog and pass in dog. Finally we'll call animal sounds and pass in animals. Let's go ahead and run our program as expected. First the name oria was printed out. Then an instance of the dog struct, and finally the result of calling speak on a cat and a dog. Our functions are working for these inputs. However they could be improved.
00:04:50.753 - 00:05:40.925, Speaker A: Let's say that we added a new name jax and made it a string slice. Let's try calling printimalname and passing in jax. We get a mismatch types error because print animal name is expecting a reference to a string. However, we're passing in a string slice. This could easily be fixed by changing the signature of print animal name. Instead of taking a reference to a string, we can simply change it to take a string slice and our code is now compiling. This works because a reference to a string could be coerced to a string slice.
00:05:40.925 - 00:06:16.117, Speaker A: In general, if you have a function argument with a type that could be coerced to another type, prefer the coercion target. This will make your code more flexible because your function will be able to accept more types. You will also avoid unnecessary layers of indirection. For example, the string type is already a layer of indirection. It's a pointer to a string on the heap. A reference to a string type is a pointer to a pointer to a string. Removing one of those pointers one of those layers of indirection is preferable.
00:06:16.117 - 00:06:57.637, Speaker A: Next, let's look at the printdog function. First, we'll create a new dog instance. The new instance of dog is stored in a variable called dog 2. Let's try to call print dog and pass in dog 2. Again we get a mismatch types error. PrintDog is expecting a reference to a boxsmart pointer containing a dog, but we're passing in a reference to a dog. Notice that dog two is not boxed.
00:06:57.637 - 00:07:49.015, Speaker A: Again, we can fix this by changing the signature of printdog to remove a layer of indirection. Instead of taking a reference to a box. Smart pointer which contains a dog will simply take a reference to a dog and our code is compiling. Again, this works because a reference to a box smart pointer containing a dog could be coerced to a reference to a dog. Finally, let's talk about animal sounds. Instead of passing in a vector of animal trait objects, let's try passing in an array of animal trait objects. Again, as expected, we get a mismatched types error because we're passing in an array where a vector is expected.
00:07:49.015 - 00:08:27.425, Speaker A: Let's fix this by changing the signature of animal sounds. Instead of taking a reference to a vector, we'll take a reference to an array and our code is now compiling. And if we switch back to using a vector, our code still compiles. This is because a vector of animal trait objects could be coerced to an array of animal trait objects. Alright, that's it for this video. Let me know if you enjoyed it by leaving a comment down below and hitting that like button. Also, make sure to get your free rust cheat sheet by heading over to letsgetrusty.com
00:08:27.425 - 00:08:32.275, Speaker A: chi she and with that said, I'll see you in the next one.
