00:00:00.200 - 00:00:51.450, Speaker A: In this video, well go over the latest release of rust version 168.0. Specifically, well cover the three big features which are cargo's new sparse protocol, local pin construction with the pin macro, and the default alloc error handler. Before we get started, make sure to get your free rust cheat sheet by heading over to let'sgetrusty dot cheatsheet. First, let's talk about Cargo's new sparse protocol for cargo to determine which crates exist on crates IO, it downloads an index from a GitHub repo which lists all versions of all crates. As you can imagine, this takes a long time and only gets worse as the index grows. The current solution is especially slow and wasteful in stateless CI environments which download the full index, use only a tiny fraction of it, and throw it away. To address this issue, a new protocol to fetch the index has been introduced.
00:00:51.450 - 00:01:34.116, Speaker A: Instead of using Git, it fetches files from the index directly over HTTPs. Additionally, Cargill will only download information about the specific crate dependencies in your project, which provides a significant performance improvement. For now, you must opt into this new protocol by setting the cargo registries crates IO protocol environment variable to sparse or by adding the following lines of code to your cargo toml file. The sparse protocol is set to become the default for crates IO in the 170.0 release in a few months. Next, let's talk about local pin construction. Async functions return futures a future is an asynchronous value that might not have finished computing yet.
00:01:34.116 - 00:02:03.192, Speaker A: Futures are pulled until they are completed. However, you can only poll a future if it has been pinned. Pinning a future means fixing it to a specific memory location, preventing it from being moved. This is needed to make it safe for async blocks to contain references. If we call await on a future, pinning will automatically be done for us. However, the future is consumed. If you want to call DA on a mutable reference to a future, you are responsible for pinning the future.
00:02:03.192 - 00:02:47.176, Speaker A: Libraries like Tokyo have a pin macro to make this easy. However, the new pin macro in the standard library is able to take advantage of pin internals and temporary lifetime extension for a more expression like macro. Also, it can be used without relying on a third party dependency. Next, lets talk about the default alloc error handler when allocation fails in rust, APIs like box new or VeC push have no way to indicate the failure to your program. So instead, if you're using the standard library, your program will print a standard error and abort as of this release. If your program does not include the standard library. For example, if you're targeting embedded devices, your program will default to panicking if allocation fails.
00:02:47.176 - 00:03:20.826, Speaker A: This default behavior can be adjusted via the panic handler macro if desired. Note that aborting and panicking are slightly different. Panicking causes the stack to unwind. Destructors will be called, giving you a chance to gracefully handle the catastrophic error. Aborting, on the other hand, means your program will exit immediately. This can be a problem if your program was in the middle of modifying a system state, for example making changes to the file system. The release blog mentions that panicking by default will likely be implemented for programs which include the standard library in the future.
00:03:20.826 - 00:03:35.930, Speaker A: That's it for this video. Before you go, make sure to get your free rust cheat sheet at let's get rusty.com cheatsheet. If you enjoyed the video, make sure to give it a like and subscribe to the channel for more weekly rust content. With that said, I'll see you in the next one.
