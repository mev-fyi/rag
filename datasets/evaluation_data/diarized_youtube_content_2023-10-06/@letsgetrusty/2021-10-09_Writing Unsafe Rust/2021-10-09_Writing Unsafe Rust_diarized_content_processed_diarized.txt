00:00:00.280 - 00:00:40.065, Speaker A: I don't know about you, but sometimes I get tired of playing it safe. Sometimes I want to live life dangerously. And if you feel the same way, then today's video is especially for you. In today's video, I'm kicking off the advanced Rust series by talking about riding unsafe Rust code. So take off your helmets, unbuckle your seat belts, and let's get freaking rusty. So far, all the code we have written has been enforced to follow Rust's memory safety guarantees at compile time. However, if we want to opt out of these memory safety guarantees, then we can use Unsafe Rust.
00:00:40.065 - 00:01:27.999, Speaker A: Unsafe Rust exists for two reasons. Reason number one is that static analysis is conservative by nature, so Rust will reject a valid program if it can't guarantee that that program is memory safe, even though you as the developer know that the program is memory safe. The second reason is that the underlying computer hardware is inherently unsafe. If Rust didn't allow you to do unsafe operations, then you couldn't do certain tasks. Rust is a systems programming language, so it must allow you to do low level systems programming, which sometimes requires unsafe code. To write Unsafe Rust, you simply use the unsafe keyword, and the unsafe keyword gives you five abilities that you don't have in the safe Rust world. The first ability is to dereference raw pointers.
00:01:27.999 - 00:02:09.227, Speaker A: The second ability is to call an unsafe function or method. The third ability is to access or modify immutable static variable. The fourth ability is to implement an unsafe trait, and the fifth ability is to access fields of unions. It's important to understand that unsafe doesn't turn off, borrow checker, or disable Rust safety checks. If you have a reference inside of unsafe code, it will still be checked. So even though you have access to those five abilities I mentioned previously, you still get some degree of safety. Unsafe code isn't necessarily dangerous, but the onus is on the developer to make sure that memory inside of unsafe blocks is handled appropriately.
00:02:09.227 - 00:02:48.327, Speaker A: People make mistakes, so writing unsafe code could introduce memory issues. But if you keep your unsafe code small and isolated, then those issues will be easier to debug. You can also enclose unsafe code in a safe abstraction and provide a safe API, which we'll talk about later in this video. All right, now that we have some background, let's go into each of the five abilities Unsafe Rust gives us. In chapter four of the Rustling Book, in the Dangling References section, it mentioned that the compiler will ensure references are valid. Unsafe Rust has two types of raw pointers that are similar to references. A mutable raw pointer and an immutable raw pointer.
00:02:48.327 - 00:03:28.749, Speaker A: Immutable raw pointers are written as asterisk, const, and then the type that the pointer points to. Mutable raw pointers are written as asterisks, mute, and then the type the pointer points to. Note that the asterisk here isn't a dereference operator. It's simply how we declare raw pointers in the context of raw pointers. Immutable means that the pointer can't be directly assigned after it has been dereferenced. Let's quickly go over some differences between references and smart pointers compared to raw pointers. Raw pointers are allowed to ignore Rust borrowing rules by having mutable and immutable pointers or multiple mutable pointers to the same location in memory.
00:03:28.749 - 00:04:09.801, Speaker A: Raw pointers are also not guaranteed to point to valid memory. Raw pointers are allowed to be null, and finally, raw pointers don't implement any type of of automatic cleanup. In the following example, we're creating an immutable raw pointer and immutable raw pointer from references. Notice that we don't see the unsafe keyword anywhere. Rust allows us to create raw pointers, but it doesn't allow us to dereference the raw pointers unless it's in an unsafe block. Here we use the as keyword to cast an immutable reference and immutable reference to their corresponding raw pointer types. Because we created these raw pointers from a reference, we know that the memory they're pointing to is valid.
00:04:09.801 - 00:04:40.481, Speaker A: But in general we can't make that assumption for raw pointer types. For example, let's create another raw pointer pointing to an arbitrary memory address. Here we're defining some random address, and then we're creating a raw pointer that points to that address. There might be valid memory at that address, or there might not be. We have no idea. Trying to use arbitrary memory is undefined behavior. The compiler might optimize this code so such that there is no memory access, or we might get a segmentation fault.
00:04:40.481 - 00:05:30.011, Speaker A: Usually there is no good reason to write code like this, but it is possible. Let's go ahead and delete this code and then dereference R1 and R2. In order to dereference raw pointers, we have to use the unsafe keyword, and in this case we're going to create an unsafe block. Here we use the dereference operator to dereference R1 and R2 and print out the value. So let's go ahead and run our program, and as you can see, R1 and R2 are both five. Note here that we created an immutable raw pointer and immutable raw pointer pointing to the same location in memory. If we were to create an immutable and immutable reference to the same location in memory, then our program would not compile because that would be breaking Rust ownership rules.
00:05:30.011 - 00:06:17.955, Speaker A: Raw pointers allow us to bypass the ownership rules, but we have to be careful because this might create a data race. Even with all the dangers, rot pointers are still useful, especially when interfacing with C code or building up safe abstractions that the borrow checker doesn't understand. Next, let's talk about the second ability we have in unsafe Rust code, which is the ability to call an unsafe function or method. Unsafe functions and methods look the same as regular functions and methods, except that they have the unsafe keywords at the beginning of their definition. The unsafe keyword in this context means that the function has requirements that we need to uphold when calling the function. More specifically, it means that when calling this function, we need to give it the correct arguments. If we give it the incorrect arguments, it could lead to undefined behavior.
00:06:17.955 - 00:07:03.285, Speaker A: By calling an unsafe function, you're saying that you've read the function's documentation and you're taking responsibility for upholding the functions contracts. Unsafe functions must be called inside other unsafe functions or an unsafe block. If I go ahead and remove the unsafe block here, then we'll get a compile time error saying this operation is unsafe and requires an unsafe function or block. The bodies of unsafe functions are effectively unsafe blocks, so we don't have to introduce an additional unsafe block inside of this function. Next, let's talk about creating a safe abstraction over unsafe code. Just because a function contains unsafe code doesn't make it an unsafe function. In fact, you can wrap unsafe code inside of a safe function.
00:07:03.285 - 00:07:44.185, Speaker A: As an example, let's look at the split at mute function from the standard library, which implements some unsafe code, and explore how we might implement it. This is a safe method implemented on mutable slices, which will split the slice into two slices along the index passed in. For example, here we have a vector v, and then we create a mutable slice named R. Then we call R split at mute, passing in three. Split mute will return a tuple containing two slices. Here we're destructing that tuple into the variables A and B, and then we're asserting that A is 1, 2, 3, and B is 4, 5, 6. Imagine we wanted to implement this function using only safe Rust code.
00:07:44.185 - 00:08:14.927, Speaker A: It might look something like this. Note that rather than Implementing a method that takes a generic slice. We're implementing a function that takes a slice of integers for simplicity. The implementation is straightforward. First, we get the length of the slice and save it in a variable named len. And then we assert that the midpoint we pass in is less than or equal to the length of the slice. Then, once we know we have a valid midpoint, we return a tuple, and inside the tuple we create two slices.
00:08:14.927 - 00:09:01.611, Speaker A: The first slice is going to be everything up to the midpoint, and the second slice is going to be everything after the midpoint. You might not notice, but we're getting an error here, and the error message is cannot borrow slice is mutable more than once at a time. When we're creating this tuple, we're mutably borrowing slice twice in the same scope. The borrow checker can't understand that we're borrowing different parts of the slice. All it knows is that we're borrowing the slice mutably twice within the same scope, which is not allowed in this case. We know our code is okay, but Rust isn't smart enough to figure that out, which makes it a good time to use an unsafe block. So let's replace this implementation with another implementation that compiles Recall from chapter four that slices are a pointer to some data and the length of that data.
00:09:01.611 - 00:10:03.365, Speaker A: On line 15, we store the length of the slice inside a variable called len, and on line 16 we call as mute pointer to get a raw mutable pointer to our slice. We keep the assert here because we want to make sure that the midpoint is valid, and then we have an unsafe block in which we create and return our tuple. We create our slices by importing the slice module and then calling from raw parts mute, which is going to create a new slice, taking in a pointer to some data and a length. In this case, we're creating a new slice that starts at the beginning of the slice that's passed in and is going to be as long as the midpoint. For our second slice, we call pointer add, which will return a pointer at a given offset. In this case, the offset we're using is the length of our midpoint, and the length we want is the number of items after the midpoint, and we calculate that by subtracting the midpoint from the length of our slice. The from raw parts mute function is unsafe because it must trust that the raw pointer passed in is valid.
00:10:03.365 - 00:10:43.467, Speaker A: The add method is also unsafe because it must trust that the pointer it passes back at an offset is valid. That's why in order to use these functions, we had to create an unsafe block by looking at the code and asserting that this midpoint is valid. We know that the raw pointers used inside of this unsafe block are valid, and therefore this is an appropriate use of unsafe. Note that even though we have an unsafe block inside of this function, the function itself is safe and can be called from safe Rust code. What we've done is created a safe abstraction around unsafe code. Next, let's talk about functions that call external code. Sometimes your Rust code may need to interact with code in a different language.
00:10:43.467 - 00:11:27.923, Speaker A: For this purpose, Rust has the extern keyword, which facilitates the creation and use of a foreign function interface, or ffi. A foreign language interface is a way for a programming language to define a function that another language or a foreign language could call. In this example, we've set up an integration with the ABS function from the C Standard library. Calling a function defined within an extern block is always unsafe because we don't know if the language we're calling into has the same rules and guarantees as Rust. It's the developer's responsibility to make sure that the functions defined within an external block are safe to call. Within an external block. We specify the name and signature of the foreign function we want to call.
00:11:27.923 - 00:12:17.865, Speaker A: The C up here defines which application binary interface or ABI the external function uses. The ABI defines how to call the function at the assembly level, the C ABI is the most common ABI and follows the C programming languages abi. We can also allow other languages to call our Rust functions by using the extern keyword in the function signature. We also have to add this no mangle annotation to let the Rust compiler know not to mangle the name of our function. Mangling is when the compiler changes the name of a function to give it more information for other parts of the compilation process. Here we want to prevent that behavior so that external code knows exactly what the name of our function is. Next, let's talk about the third ability unsafe Rust gives us, which is the ability to access and modify mutable static variables.
00:12:17.865 - 00:13:02.653, Speaker A: Up until this point, we haven't talked about global variables in Rust, which are supported but could be problematic with Rust ownership rules. If two threads are accessing the same mutable global state, the then it could cause a data race. For example, in Rust, global variables are called static variables, and here we have an example of a static variable called hello World. Static variables are similar to constants in that the convention for naming the variable is to use Screaming Snake case. Also, we must annotate the type of our static variable. Also, static variables must have a static lifetime. In this case, a string literal does have a static lifetime, but we don't have to specify it in this type annotation, because Rust can infer that.
00:13:02.653 - 00:13:53.533, Speaker A: Now, you might think that constants and immutable static variables are similar, but there is a slight difference. Static variables have a fixed address in memory, meaning that you're always accessing the same data. Constants are allowed to duplicate their data whenever they're used. For example, if you're referencing a constant throughout your code base, then the compiler can replace all those instances of the constant with the concrete value. Another difference between constants and static variables is that static variables can be mutable, but accessing and modifying mutable static variables is unsafe. In this example, we have a mutable static variable called counter, which is an integer initially set to zero. Then we declare a function called add to count, which takes in a number and then increments the counter by that number inside an unsafe block.
00:13:53.533 - 00:14:42.289, Speaker A: Our add to count function is safe, meaning that we could use it inside of main without an unsafe block, but we do have to create an unsafe block when we access counter. Next, let's talk about the fourth ability unsafe Rust gives us, which is the ability to implement an unsafe trait. A trait is unsafe when at least one of its methods is unsafe. We can mark a trait unsafe by adding the unsafe keyword to its definition and also to its input blocks. The fifth ability we get with unsafe code is the ability to access fields of unions. A union is similar to a struct, but only one field is used for each instance. Unions are primarily used to interface with C unions, and it's unsafe to access fields of a union because Rust can't guarantee what the type of data stored in the union is for a given instance.
00:14:42.289 - 00:15:10.865, Speaker A: If there's one thing to take away from this video, it's that using unsafe isn't wrong or frowned upon. When you have a use case for unsafe, then go ahead and use it. Just make sure you're being safe with memory. Alright, that's it for this video. If you enjoyed it, then no matter what, do not hit the like button. And if you want to see weekly Rust content, do not hit subscribe and definitely don't hit that notification bell. Finally, if you want access to a free Rust cheat sheet, which I know you do, then head over to letsgetrusty.com
00:15:10.865 - 00:15:16.345, Speaker A: cheat sheet and with that said, I'll see you in the next one.
