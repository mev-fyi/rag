00:00:00.440 - 00:00:49.907, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this channel is all about the Rust programming language. In the last few videos, we talked about Rust's functional features, specifically iterators and closures. In this video, we're going to take a step back and focus on Cargo and Crates IO. Specifically, we'll be talking about customizing your build through build profiles, publishing a crate to Crates IO, organizing large projects with workspaces, installing binaries from Crates IO, and extending Cargo with custom commands. So with that, let's get rusty here. I've initialized a new project called My Crate, and the first thing we're going to talk about is Release profiles.
00:00:49.907 - 00:01:36.473, Speaker A: Release profiles allow you to configure how your code is compiled, and Cargo has two main profiles, Dev and Release. The dev profile is defined with good defaults for development, and the Release profile is defined with good defaults for a release build. If we run Cargo Build, our code will compile with the dev profile, which you can see specified here. If we want to compile our code with the Release profile, we'll type in Cargo Build and then dash dash, release. And as you can see, Release is specified here. We also get some extra information. You can see that the Release build is optimized, whereas the dev build is unoptimized and contains debug information.
00:01:36.473 - 00:02:16.601, Speaker A: Cargo has default settings for these profiles. However, we could customize the settings in the Cargo TOML file here. I've added two sections for the dev and release profiles, and I've added the OPT level setting. Opt level stands for optimization level, and it could be 0, 1, 2, or 3, 0 being no optimizations and 3 being the highest number of optimizations. Now, these are actually the default settings. The dev profile will have an OPT level of zero because we're going to be compiling a lot. So we want our compilation speed to be fast, and that trades off the runtime speed.
00:02:16.601 - 00:02:43.173, Speaker A: So we'll have a fast compile time, a slower runtime. For dev and for release, it's the opposite. We're only going to be compiling once and running the program many times. So we'll exchange a slower compile time for a faster runtime. But as I've said, these are customizable. So let's say for the dev profile, instead of having an opt level of 0, you actually want an op level of 1. Well, you can simply change the 0 to 1 and get your desired result.
00:02:43.173 - 00:03:29.813, Speaker A: Note that this is just one setting. If you want a full list of settings, refer to Cargo's documentation In previous videos, we took advantage of other people's code by downloading Crates from Crates IO. In this section, let's talk about uploading your own code to Crates IO. But before we get to that, we'll talk about preparing your code for public consumption, starting with writing useful documentation. Comments Documentation comments are useful when documenting your public API so that others know how to use your code. Regular comments start with two slashes, while documentation comments start with three slashes and use markdown for formatting. Additionally, Rust will turn your documentation into an HTML format that's easy to read.
00:03:29.813 - 00:04:10.573, Speaker A: In this example, we have a function called add1, which takes in an integer, adds one to it, and then returns the new integer. Right above the function, we have a documentation comment. At the top we explain what the function does, and then we have this example section which gives an example of how to use the function. There's a code block which shows how to call our function. And then at the bottom there's also this assert statement which asserts that we get back the correct value. And as we'll see later on, Russ will actually run this documentation comment as a test. Now, in order to build the HTML documentation for our crate, let's open our terminal and type in Cargo Doc.
00:04:10.573 - 00:05:05.059, Speaker A: And for convenience, we'll add Open, which will just open a web browser with our documentation. Here's the webpage Rust generated. We have the name of our crate and then a list of functions in our crate, which currently we only have one and our function is called add1. If we click into that, we could see the signature of the function and the example section. Now, besides examples, there are a few other commonly used sections, one of which is a Panics section which describes scenarios in which a function would panic. Also, if a function returns a result type, it's common to have an error section which describes the kind of errors that could be returned and what conditions have to occur for those errors to be returned. Lastly, if your function is unsafe, then it's common to have a safety section which explains why your function is unsafe and conditions in which your function could panic.
00:05:05.059 - 00:05:50.775, Speaker A: Let's go back to our code and talk about the example section. Again, as I mentioned earlier, because we have this assert equals statement. This example is actually a documentation test. So if I run Cargo test, you can see we have this doc tests section here for my crate and we have one test that is passing on line five of lib.rs and if we look at line five, it's in fact our example. This is great because this forces the documentation to be in sync with the code. So for example, if we change our function to return instead of plus one plus two and rerun our tests, you can see that now our documentation test fails.
00:05:50.775 - 00:06:30.349, Speaker A: Now let's talk about a different style of documentation. Comments. Instead of using three slashes, we'll use two slashes and an exclamation point. And this style of comment, instead of documenting the item following the comment, it documents the item containing the comment. So in this example, because this comment is inside live rs, it's documenting our library crate. Let's go ahead and open our terminal and run cargo doc dash dash open again. This time when we open our documentation, we could see our comment documenting the functionality of our crate.
00:06:30.349 - 00:07:05.121, Speaker A: Next, let's talk about re exporting. Here I've created a new project called Art which has a library crate. And from this top comment you can see that Art is a library for modeling artistic concepts. This library has two modules. The first one is called kinds and contains two enums, Primary color and secondary color. The second module is called utils and contains one function called mix, which takes two primary colors and returns a secondary color. This structure makes sense to us, the library author, but it might not make sense to people using our library.
00:07:05.121 - 00:07:46.807, Speaker A: For example, let's say a user of our library wants to reference the primary color and and secondary color enums. If we open up the documentation for crate, you could see that in order to access those enums, you first have to go into the kinds module and then you have access to the enums. We can also see this by going back into main rs. Here's how we would access the primary color enum and the mix function. We would first have to reference their module and then the item we want. Again, this structure makes sense internally, but let's say as the library author, we want users to have access to the enums and the mix function at the top level without having to reference their respective modules. To do this, let's go Back to our lib.rs
00:07:46.807 - 00:08:56.141, Speaker A: file and re export the enums and the mix function. To do that, we'll use the pub use keyword and then a relative path starting from self. Now, primary color, secondary color and mix will be exported from the top level of our library. Here I've regenerated the documentation for our library and as you can see, we have a new section called re exports which shows our re exported items. If we go back to main rs instead of importing our items from the modules, you can see that we can import our items from the top level of our Library. Again, Pub use statements allow you to make your public API different from the internal structure of your program, which could be very useful for people consuming your library. With all that background about documentation, comments and public APIs, now we can talk about how to actually create an account on Crates IO and publish a crate.
00:08:56.141 - 00:09:54.809, Speaker A: The first thing we'll do is go to Crates IO and log in with our GitHub account. Currently, you must have a GitHub account to log into Crates IO, so if you don't already, make sure to sign up for GitHub. So we'll click this little login to GitHub link at the top and it will take us through the login process. Next, click the drop down menu next to your profile icon and go to Account Settings. From here you'll scroll down to API Access, then you'll click New Token, assign a name to your token and click Create. This will give us a login token which you shouldn't share with anyone, like I'm doing right now. So what we'll do is copy this command and put it into our terminal and we've successfully logged in.
00:09:54.809 - 00:10:40.635, Speaker A: Now that we're logged in, we could publish our crate, but before doing so, we need to double check the metadata which is located in our Cargo TOML file. One important thing here is the name of your crate. When you're developing locally, the name doesn't really matter, but when you publish to Crates IO, your name must be unique. So before publishing, make sure to go to Crates IO and check if your desired name has already been taken. In this case, ART isn't a very unique name, so I'll prefix it with my first name and then I'll run Cargo Publish. In this case, if I scroll up, I see I have an error saying that three files in my working directory contain changes that were not committed. So let's go ahead and commit our changes.
00:10:40.635 - 00:11:30.765, Speaker A: And of course I actually have to set up my GitHub account on this computer, so give me just one sec. Okay, all our files are now committed, so let's try publishing again. Okay, and this time I get another error, and that's because I renamed the module, so I have to actually change the module name here again. I have to commit the changes. Okay, let's try that one more time. And of course we get an error, but this time it's an API error, and the error occurs because we're missing some metadata fields, specifically the description field and the license field. So let's go ahead and add those.
00:11:30.765 - 00:12:23.051, Speaker A: All right, we now have our description and license field entered in. So let's run Cargo Publish again, and this time we get an error because our email address isn't verified. So we'll need to go back to Crates IO and verify the email address. Okay, my email address has been verified, so let's run Cargo Publish again, and this time I'm just going to assume we're going to get an error. And what do you know, we actually succeeded. Now, if I go to Crates IO, I can type in my library's name and you can see it's been uploaded. Now, one thing to know about publishing to Crates IO is that it's permanent, meaning that now that this code is published, it cannot be deleted.
00:12:23.051 - 00:13:06.513, Speaker A: I can publish new versions, but the code as it is right now will be forever on Crates IO. Crates IO archives code this way because others may rely on your library and we don't want to break them by deleting or modifying the code. When you want to upload a new version of your library to Crates IO, simply change the version number in Cargo TOML using the semantic versioning rules and run Cargo Publish again. Now, as I've said before, you can delete or modify your code once it's up on Crates IO, but you can stop specific versions from continuing to be downloaded. You can do this using the Cargo yank command. For example, let's say I didn't want this version 0.1.0 be downloaded anymore.
00:13:06.513 - 00:13:48.163, Speaker A: To do that, I'll type in Cargo Yank dash dash vers for versions and then our version number. What this will do is for anyone with this version in their Cargo lock file, they can continue to keep downloading this version. However, those downloading our library for the first time won't be allowed to download this specific version. Additionally, if you've yanked a specific version and you want to undo it, you can simply type undo. That's it for part one of chapter 14. If you enjoyed this video, make sure to give it a thumbs up. And if you want to see weekly Rust content, make sure to hit that subscribe button.
00:13:48.163 - 00:13:50.915, Speaker A: And with that, I'll see you in the next one.
