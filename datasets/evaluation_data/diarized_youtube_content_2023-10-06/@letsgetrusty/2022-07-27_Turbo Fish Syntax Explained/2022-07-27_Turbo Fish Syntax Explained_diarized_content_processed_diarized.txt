00:00:00.560 - 00:00:37.569, Speaker A: Rust has a special syntax affectionately called turbofish. The turbofish syntax is used to specify concrete types for generic type parameters. It looks like this double colon followed by angle brackets. The double colon is prefixed with an identifier, which could be a function or method name, struct, name, or enum variant, and the angle brackets contain a concrete type. Let's see how this syntax is used in practice. In this example, we have two variables, name, which is an array of string slices, and gpa, which is an array of floating point numbers. Rust uses type inference to automatically detect types.
00:00:37.569 - 00:01:24.367, Speaker A: Type inference can also work with generic type parameters. In this example, we've created a new variable called students, which is a hashmap. Then we called the insert method passing in the first element in the name array and the first element in the GPA array. The hashmap struct is defined with two generics, K and V for the key and value pair. Because we called insert passing in concrete values, Rust was able to infer that Students is a hash map containing string slices for keys and floating point numbers for values. But what happens if we comment out the call to insert? In this case, Rust does not have enough information to infer the concrete types, so an error is thrown. We can fix this error by adding explicit type annotations like you see here, or we can use the turbofish syntax.
00:01:24.367 - 00:02:08.909, Speaker A: In this case, the turbofish syntax is used after hash map to specify the concrete values for K and v. Using the turbofish syntax in this case makes the code slightly less readable, and it's not necessary as long as we call the insert method at least once. So next, let's take a look at an example where using the turbofish syntax is beneficial. String slices have a method called parse, which allows you to convert the string slice into another type, for example a number. This function returns a result type containing F, which is a generic with a trait bound of fromstr. This means F could be any type that implements the fromstr trait. If we call parse on a string slice without type annotations, Rust throws a compile time error.
00:02:08.909 - 00:02:46.285, Speaker A: This is because Rust cannot infer the concrete type of F. One way to fix this error is to add an explicit type annotation to the num variable. Doing this solves the compile time error, but as you can see, it's pretty verbose. Not only is the return type long, but we also have to import parseint error. We could make this code less verbose by ignoring the error type, but an even better option is to use the turbofish syntax. In this case, the turbofish syntax is used after the method name to specify the concrete type for F. As you can see, using the turbofish syntax in this case made our code clean and concise.
00:02:46.285 - 00:03:13.897, Speaker A: Let's take a look at another example. Iterators have a method called collect which turns the iterator into some kind of collection. This method returns a generic type, which could be anything that implements the from iterator tree trait. Let's see how this method is used in practice. Here we have a variable called numbers, which is a vector of integers. To get that vector of integers, we first start with an array of string slices. Calling the iter method turns the array into an iterator.
00:03:13.897 - 00:03:57.685, Speaker A: Then the filter map method will parse each string slice into a number, or discard it if it cannot be parsed into a number. Finally, the collect method turns the iterator of integers into a collection of integers. Writing this code results in an error because Rust cannot infer the type of number numbers. Specifically, Rust cannot infer the concrete type of the be generic. When calling the collect method, we can fix the error by adding an explicit type annotation. However, what happens if we perform additional operations after calling collect? Here we're calling contains after collect to see if the collection contains the number two. This results in a compile time error because Rust cannot infer the concrete type of the collection we want.
00:03:57.685 - 00:04:42.061, Speaker A: Adding an explicit type annotation won't help in this case, because the contains to variable is going to be the type returned from the contains method, which in this case is a boolean. Given this code, Rust cannot infer the type of collection we want. To fix this error, we can use the turbofish syntax to specify that we want a vector of integers. Additionally, we can omit the type stored inside the vector, because Rust can figure this out by looking at the call to contains. This example shows that the turbofish syntax is useful in situations where we don't want to bind the result of an operation to a variable. Let's take a look at one more example. Here we have a function called sizeof, which returns the size of a given type in bytes.
00:04:42.061 - 00:05:28.475, Speaker A: The function signature defines a generic type t. However, t is not used for the arguments or return value. This means when calling this function, we must use the turbofish syntax to specify a concrete type for t. Otherwise we'll get a compile time error. This is a rare case where the turbofish syntax has to be used because there's no other alternative. In summary, the turbofish syntax is used to specify concrete types for generic type parameters, you can use this syntax instead of explicit type annotations for brevity or when explicit type annotations don't work, for example when you don't want to bind the result of an operation to a variable, or in special cases like the size of function. If you haven't already, make sure to get your free Rust cheat sheet at letsgetrusty.com
00:05:28.475 - 00:05:33.215, Speaker A: forward slash cheat sheet. With that said, I'll see you in the next one.
