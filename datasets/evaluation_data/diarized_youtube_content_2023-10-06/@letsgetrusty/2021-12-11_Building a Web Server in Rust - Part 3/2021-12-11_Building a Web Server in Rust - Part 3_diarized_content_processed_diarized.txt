00:00:00.320 - 00:00:34.705, Speaker A: What's up, Rust Stations welcome back to let's Get Rusty, your number one resource for all things Rust. Make sure to hit that subscribe button for weekly Rust videos. And most importantly, get your free Rust cheat sheet by heading over to LetsGetRusty.com Cheat Sheet in the last two videos, we learned about building a web server in Rust. First we implemented a single threaded web server, and then we implemented a multi threaded web server. In this video, we're going to finish up our web server project by talking about graceful shutdown and cleanup. So with that said, let's get Rusty.
00:00:34.705 - 00:01:23.535, Speaker A: Here's our web server code so far. If this looks unfamiliar to you, then make sure to check out the first two web server videos. Currently we don't have any cleanup code, so if we have a running server and we hit Control C, our server will abruptly shut down and any thread that's in the middle of processing a request will just abruptly exit. Let's improve this by letting threads finish up their current request before shutting down the server. To do that, we'll implement the drop trait on thread pool. The drop tray requires us to implement the draw method, which takes immutable reference to self. Inside the drop method, we'll loop through each one of our workers and call the join method on their thread.
00:01:23.535 - 00:02:26.619, Speaker A: Calling the join method will wait for the associated thread to finish, but as you can see, we get an error here which states that we cannot move out of worker thread because it's behind immutable reference. We get this error because worker is a mutable reference, but the join method takes ownership of its argument. To solve this problem, we need a way to move thread out of the worker instance. Instead of having the worker store a join handle directly, we can have the worker store an optional containing the join handle or the none variant. Then we can use the take method on thread to move the join handle out of the optional and replace it with the non variant. So let's update our worker struct to store an optional. Then we'll need to update the new function on worker.
00:02:26.619 - 00:03:15.695, Speaker A: Instead of passing in thread directly, we'll store it in the sumvariant. Lastly, we'll need to update our drop implementation. Here we're calling take which returns an optional, so we use the if less syntax to match on the sumvariant. The sumvariant will store the thread by value, so then we can call the join method on it. If take returns the none variant, then we know that the workers thread has already been cleaned up, so there's nothing left to do. Our code is now compiling without any errors or warnings, but our cleanup logic is not done quite yet. The join method will wait for a thread to finish.
00:03:15.695 - 00:03:54.945, Speaker A: However, our current implementation of our threads is that they'll loop indefinitely. So with our current implementation, calling the join method will make the main thread block forever waiting for a thread to finish. To fix this problem, let's modify our threads. Currently, our threads are only listening for new jobs. We'll modify our threads to listen for either a job or a signal that they need to terminate. To start off, we'll create a new enum called Message. The message enum is going to have two variants.
00:03:54.945 - 00:04:56.935, Speaker A: The first variant is new job, containing the job we want to execute, and the second variant is terminate, signaling that we want our thread to shut down. Next, let's update our sender in thread pool to send messages instead of jobs. Next, we'll update the execute method. Now let's update the new function on our worker struct. The receiver passed in is going to receive messages instead of jobs. Then we can match on the type of message we get. If we get the new job variant, then we'll execute the job like we did before.
00:04:56.935 - 00:06:07.495, Speaker A: And if we get the terminate variant, then we'll exit the loop. Now that our threads are able to terminate, let's update the drop implementation on thread pool to send the terminate message. Here we're looping through our workers and then sending a terminate message. So we'll send a number of terminate messages equivalent to the number of workers we have now. We have no control over the order in which our workers pick up this terminate message. Workers pick up messages when they're done with their job, and we know that if they pick up the terminate message, then the worker will terminate. This means that as long as the number of terminate messages is equivalent to the number of workers we have, then eventually each worker will pick up a terminate message and exit.
00:06:07.495 - 00:07:14.675, Speaker A: After sending out the terminate messages, we loop through all our workers again, and this time we call the join method. Calling the join method ensures that each worker has enough time to receive and process the terminate message. Now that our cleanup code is complete, let's go back to Main and modify it so we can see the cleanup code in action. Instead of processing every request that comes in, we're only going to process the first two requests and then shut down listener.Incoming returns an iterator of the incoming requests, and we're calling the take method on our iterator, which creates a new iterator yielding the first N elements in this case we're passing in two as the argument let's run our server and make a request going back to the terminal. You can see that we got three requests and on the third request our server terminated. Because we're using threads, the order of these messages is non deterministic, so you might see a different output on your terminal.
00:07:14.675 - 00:07:44.455, Speaker A: Regardless of the output, you'll see that two workers got a job. In this case, worker one got a job and worker two got a job. Also, we can see that the main function ends with shutting down being printed. When the main function ends, our thread pool goes out of scope and its drop method is called in Thread pools. Drop Method we send the terminate message to all workers in our console. We can see that each worker was told to terminate. With that, we're done implementing a basic web server in Rust and we've come to the end of the rustling book.
00:07:44.455 - 00:08:12.135, Speaker A: Congratulations. Now that you have a basic understanding of Rust, comment down below what types of videos you would like for me to do next. If you enjoy this video, make sure to give it a like. And if you want to see weekly Rust content, hit that subscribe button. Most importantly, get your free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet and with that said, I'll see you in the next one SA.
