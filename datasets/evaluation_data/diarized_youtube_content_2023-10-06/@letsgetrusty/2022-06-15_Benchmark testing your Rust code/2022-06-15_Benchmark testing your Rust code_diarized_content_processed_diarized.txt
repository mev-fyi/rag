00:00:00.360 - 00:00:39.099, Speaker A: In the following example, I have a library with one public function called sortarray. Sortarray takes one argument, which is a mutable reference to an array containing items that could be ordered inside the function body. We use a specific sorting algorithm to sort the array, in this case bubble sort. The sorting algorithms are located in a module called Sorting, which for the sake of this video we could ignore. Now, let's say we wanted to benchmark this function to track performance and make sure performance is not regressed. Rust actually has a built in test crate. However, at this moment that test crate is unstable and only available in nightly versions of Rust.
00:00:39.099 - 00:01:23.915, Speaker A: So instead we're going to use a library called Criterion. First, let's open up Cargo TOML and add Criterion as a dev dependency. Next, we'll configure our benchmark target. First we declare the name of our benchmark, in this case sorting benchmark. Then we set Harness to false to disable Rust's default bench harness. In other words, we're disabling the default benchmarking system so we could use Criterion's benchmarking system. Next, we'll create a folder called Benches in the root of our project, and inside that folder we'll add a new file called sorting benchmark.rs.
00:01:23.915 - 00:02:18.213, Speaker A: first, let's bring our sortarray function into scope. We'll also bring some items from the criterion crate into scope. Next, we'll set up our test function. The criterion group macro is used to define a collection of functions to call with a common criterion configuration. The first argument is the name of the group, in this case benches, and the remaining arguments are names of functions. In this case we only have one function called sortarraybenchmark. And the criterion main macro expands to a main function which runs all the benchmarks in a given group, in this case the Benches group.
00:02:18.213 - 00:03:03.277, Speaker A: With the setup complete, let's focus on our benchmark function. Each benchmark function gets access to an instance of the criterion struct, which allows us to configure and execute benchmarks. We'll use the criterion struct to create a new benchmark, but first let's set up some data. Here we created an unsorted array. We also use the black box function, which prevents the compiler from optimizing away computations in a benchmark. Next, let's create our benchmark. To create a new benchmark, we call Benchmark function on the criterion struct instance.
00:03:03.277 - 00:04:00.335, Speaker A: This function takes two arguments, an ID and a closure. Inside the closure, we get access to an instance of bencher which allows us to iterate a benchmark function to measure its performance inside the closure body we call the ITER method, which takes another closure that executes our sortarray function. The sortarray function will be executed many times for its performance to be accurately measured and with that our benchmark is now complete. Let's go ahead and run it. To run our benchmarks we execute Cargo Bench Our benchmark executed in about 4Ns. Let's run the benchmark again. This time we get a similar result and it even states that no change in performance was detected.
00:04:00.335 - 00:04:38.285, Speaker A: Now let's go back to Lib RS and change our sorting algorithm. Instead of using Bubble sort, we'll use Selection sort, which is much slower. Let's run our benchmark again. Notice that our performance has regressed, taking 15Ns to run almost a 300% increase. As you can see, using benchmark tests could help you prevent regressions in performance sensitive code. That's it for this video. But before you go, make sure to get your free Rust cheat sheet by heading over to letsgetrusty.com
00:04:38.285 - 00:04:48.985, Speaker A: cheatsheet also, if you enjoyed this video, let me know by leaving a like and a comment in the comment section down below. With that said, I'll see you in the next one.
