00:00:00.440 - 00:00:25.345, Speaker A: Welcome back to let's Get Rusty. My name is Bogdan, and this channel is all about the Rust programming language. If that sounds interesting to you, make sure to poke that subscribe button for weekly Rust videos. In the last video, we went over chapter eight, which covered common collections such as strings, vectors, and hash maps. If you haven't already, make sure to check that video out. In this video, we're going over chapter nine, which covers error handling and Rust. So with that, let's get started.
00:00:25.345 - 00:01:01.853, Speaker A: First, let's talk about the Panic macro. If your program fails in a way that's unrecoverable, or you can't handle the error gracefully, then you can call the Panic macro, which will immediately quit your program and print out an error message. Here's a simple example. We have our main function, and all we do is call panic with the error message crash and burn. So let's go ahead and run our program. Here we have our errors saying main panicked, our error message, and also the line which threw the error down. Here we also get some helpful text saying that we could display a backtrace using this environment variable.
00:01:01.853 - 00:01:49.473, Speaker A: A backtrace will list out all the functions called leading up to the erring code. And in this case it wouldn't be that useful because our error encode is the first line of the main function. So let's move on to an example that would benefit from seeing a backtrace. So here we have another example, and this is extremely contrived, but just for demonstration purposes, we have main, which calls a function called A, and then A calls a function called B, and then B calls a function called C, which takes in a integer. And if that integer is 22, it happens to panic. All right, now let's go ahead and run our program. As expected, we get an error with the Message don't pass in 22 at line 15 in main RS.
00:01:49.473 - 00:02:44.305, Speaker A: If we scroll down, you could see that line 15 is in fact our panic call. Now let's just imagine that our C function could be called from a variety of places, so we don't know where the call is coming from. This error message down here doesn't really help us understand who's making the call to see and passing in 22. So for that, let's run our program again with this backtrace environment variable so that we can get the backtrace output at the top. Here we can see that some code in Rust standard library is being called by our C function, which is the function that panics and C is being called by Our B function and B is being called by A. So now we know that C is being called by B. So going back to our program, we can see, oh yeah, B here is calling C with 22, which it's not supposed to be doing.
00:02:44.305 - 00:03:17.787, Speaker A: So let's change that to 21, and if we run our program, it compiles without any issues. All right, now let's talk about errors, which are recoverable errors that you can handle gracefully and don't want to crash your program. For those cases we have the result enum. The result enum is similar to the option enum. Remember, the option enum represents some value or no value. Well, the result enum represents success or failure, just like the option enum. The result enum has two variants, OK and error.
00:03:17.787 - 00:03:59.497, Speaker A: OK represents the success case and stores some generic value, and error represents the error case and stores some generic error value. Lastly, just like the option enum result is very common, so the enum and its variants are brought into scope by default. Here we have an example that uses the result enum. First we import the file struct from Rust Standard library and then in main we declare a variable called F and set that equal to this expression right here. We call open on the file struct and pass it a path to the file we want to open. If we hover over open, you can see that open returns a result type, and that's because opening a file may fail. For example, the file might not be there.
00:03:59.497 - 00:04:35.601, Speaker A: If we hover over F, you could also see that the type of F is result, which could either be a file or an error. So now we must handle the success case and the error case. And to do that we can use a match expression like so. Here we're using shadowing to redeclare F, and we're setting that equal to a match expression. We're matching on this F up here, which is a result type. And if the variant is okay, we bind the file to this file variable and return it. And if the variant is an error, we bind the error to this error variable and then panic, throwing up this error message and passing it the error.
00:04:35.601 - 00:05:15.315, Speaker A: Let's go ahead and run our program. Here we get our error saying there was a problem opening the file and some more information about the error itself, the code of the error, the kind of error which is not found, and then the message which is no such file or directory. And that makes sense because currently hello text doesn't exist. Now let's say we wanted to handle this a little more gracefully Instead of panicking when the file doesn't exist, what we want to do is create a new file. The first thing I'll do is bring into scope the error kind enum. This enum will let us match on the type of error we get. Then instead of panicking here, what we'll do is match on the type of error we get.
00:05:15.315 - 00:05:52.939, Speaker A: Calling the kind method on our error will give us back an enum representing the kind of error we got. What we want to do is handle the not found error case gracefully. So first let's match on that. Now, when the file is not found, we want to create a new file. But creating a new file can fail. So we have to create yet another match statement to handle the result type. Here we're saying if the file is not found, then attempt to create the file.
00:05:52.939 - 00:06:38.275, Speaker A: But attempting to create the file might fail. So we match on the result type and in the success case, we map the file to our FC variable and then return that. And then in the error case, we panic with the message problem creating the file. The last thing we want to do is handle any other type of errors, because remember, match statements are exhaustive, so we have to handle all cases. Here we're saying if the error is anything other than not found, bind the error to this other error variable and then panic with the message problem opening the file passing in the error. Now let's run our program again and you can see this time we don't fail. And if we open up our file browser, you can see that we have a new file called hello text.
00:06:38.275 - 00:07:04.711, Speaker A: Now, writing this code using nested match expressions could make it hard to read. So there's another way to write this exact same code using closures. And this is something we'll learn more about in chapter 13. But here's a quick preview. Here we're attempting to open our hello text file and then we're calling Unwrap or else, which will give us back the file. Or call this anonymous function or closure passing. In the air inside our closure we have an if statement.
00:07:04.711 - 00:07:40.413, Speaker A: If the error is not found, then we attempt to create the file calling unwrap or else again, which will give us back the newly created file if this call succeeds. Notice that we don't have a semicolon at the end here, which means this is an expression. Or in the failure case, it'll call another closure, which will just panic. And then in the else case here we also panic. And again, we'll learn more about this in chapter 13. Speaking of unwrapping let's talk about some useful functions on the result enum. Here we're back to our original example where we're attempting to open the file and then using a match expression to either get the file or panic when an error occurs.
00:07:40.413 - 00:08:19.789, Speaker A: Instead of writing this match expression, we can simplify our code by calling unwrap Here. Unwrap does the same thing as our match expression. In the success case, it will take the thing stored inside of the okay variant, which in this case is a file, and return that. And in the error case it will panic. And you can also see that our f variable now is of type file. Now we also have the expect method, which allows us to specify the error message that gets passed to the panic macro. So here, for example, we want the message to be fail to open hello txt.
00:08:19.789 - 00:09:00.785, Speaker A: Let's go ahead and run our program and as you can see, we get fail to open hello Txt as expected. Now let's talk about error propagation. Oftentimes when you have a function whose implementation calls something that could fail, you want to return that error back to the caller instead of handling it within the function. This gives more control to the caller who can decide what to do with that error, and this is called error propagation. Let's look at the following example. We have a function called read username from file and the function returns a result type, which could either be a string, our username, or an error inside our function. We attempt to open hello txt, which could fail.
00:09:00.785 - 00:09:30.713, Speaker A: So open returns a result type which we store in f. Next we have a match expression. If opening the file succeeds, then we take that file and store it in f. But if opening the file fails, then we take that error and return it. Next we create a new string and then call read to string on our file, which will read the contents of our file and store it within the string. Read to string returns a result type. So in the success case we return the string, and in the error case again we return an error.
00:09:30.713 - 00:10:04.285, Speaker A: This allows the code calling our function read username from file to determine how best to deal with these errors. We can simplify this code further. So instead of using this match expression, we can simply add a question mark to the end of our call to open. This will do something very similar to calling the unwrap or expect methods. If we succeed in opening the file, then the file is returned and stored in f. And if we fail to get the file, then instead of panicking, our function will end early and return the error. Let's go ahead and remove this code.
00:10:04.285 - 00:10:43.555, Speaker A: We can also get rid of this match expression by simplifying the code like so here we're calling read to string, passing it s, and then we specify a question mark. So if this call fails, then our function will return an error. If we get to this next line, then we know read to string succeeded, so we can safely return the string. And lastly, we get a little error here because we're borrowing F as mutable, but it's not declared as a mutable variable. So let's fix that. Now our function is a lot simpler, but we can continue simplifying our function by chaining method calls. So first I'll take our string and move it to the top of the function.
00:10:43.555 - 00:11:19.033, Speaker A: Next, we see that we have two related method calls. One is to open the file, and the other one is to read from the file. So instead of creating our F variable, we can simply just chain those method calls. Here we're opening our file and we specify a question mark. So if there's an error, our function will return that error. And if we succeed in opening the file, then we immediately call read to string and pass it S. And again we specify a question mark so that if this call fails, our function will return the error.
00:11:19.033 - 00:11:57.103, Speaker A: And finally we just return our string. Now we got our code down from four lines to three lines. Can it get simpler than that? The answer is yes. So first let me change this file import statement so that we import FS directly. And then we could change these three lines to one line. The file system module has a convenient function called read to string, which takes in a path to a file and returns a result, which could either be a string containing the contents of the file or an error. Now, what happens if we try to use the question mark operator in our main function? Well, our main function doesn't return anything.
00:11:57.103 - 00:12:43.137, Speaker A: And you can see here we get an error if we hover over the error states. The question mark operator can only be used in a function that returns result or option. The main function is special, so there are restrictions on what type it could return. One option is to return nothing, like we have here, but another option is to return a result type, like so here we changed main to return a result type, and in the success case, we return a unit, which is basically nothing. And in the error case, we return this weird thing which is a trait object and something we'll learn more about in chapter 17. But basically this means any type of error. So now in our function body, we can use the question mark operator, and if everything succeeds, we return A unit.
00:12:43.137 - 00:13:34.743, Speaker A: Now that we've covered the panic macro and the result enumerated, the question is, when should you use either of these? In general, the default should be using the result enum and error propagation. This prevents your program from crashing, and error propagation allows the caller to decide how best to handle the error. You should only use panic in exceptional circumstances, in circumstances in which recovering from the error is not possible and your program cannot continue because it's in a bad state, so you must end the program. Another appropriate place to allow your code to panic is in example code. In example code, methods like unwrap and expect are used for brevity and also because in example code there's no context for determining how to deal with errors. You may also use unwrap or expect in prototype code. So imagine you're trying to get something out really quickly to see if it works, and you don't want to deal with error handling.
00:13:34.743 - 00:14:17.451, Speaker A: Then, if the code is moving past the prototype phase, you can find all the expect and unwrap statements and easily introduce error handling. Expect an unwrap could also be used in test code, because in test code you want your test to fail if something that you expected to succeed fails. Lastly, you may want to use expect or unwrap when you know a call to a function will succeed. In this example, we have a simple program that takes a string and converts it into an IP address enum. Now, because this string is hard coded here, we know that the parse function will always succeed, so we can safely call unwrap. If this string, however, was dynamic and came from something such as user input, then we wouldn't want to call unwrap. We would want to handle the potential error case.
00:14:17.451 - 00:14:48.047, Speaker A: The last thing I want to talk about is creating custom types for validation. If you remember, in chapter two, we created a guessing game which allowed a user to guess a number from 1 to 100, but we never validated that the number they inputted was between 1 and 100. Now, this is a snippet of code from the guessing game with some added validation. So first we take our string and parse it into an integer. And then here we have some validation which checks that the number is between 1 and 100. And then we continue on with the rest of the game. Now this works, but it's problematic.
00:14:48.047 - 00:15:16.455, Speaker A: You can imagine that guess could be used in a lot of other different places, and in those other places we can't guarantee that guess is between 1 and 100. Somebody might come along and delete this validation. For example, and we might be able to catch it in this snippet of code. But. But all the other places that use Guess wouldn't know. An alternative approach is to create a custom type that handles validation. In this example, we created a guest struct, which has one field called value, which stores our integer.
00:15:16.455 - 00:15:50.907, Speaker A: We also have this associated function called new, which takes in a value, validates that it's between 1 and 100, and then returns a new instance of our guest struct with that value. Lastly, we have a method called value, which returns the value stored in our guest struct. And we want this function because we don't want the value field to be manipulated directly. In fact, we don't want the value field to be manipulated at all. Now, our guessing game can use this new guest type, and any code dealing with Guess can be confident that the value stored inside of it is between 1 and 100. There you have it. Chapter 9 of the Wrestling book Complete.
00:15:50.907 - 00:16:09.105, Speaker A: We learned about error handling. We learned about the Panic macro, the result enumerated using Unwrap and Expect using the Question Mark operator, and more. If you like this video, make sure to give it a like. And if you want to see weekly Rust content, make sure to hit that subscribe button. And with that, I'll see you in the next one.
