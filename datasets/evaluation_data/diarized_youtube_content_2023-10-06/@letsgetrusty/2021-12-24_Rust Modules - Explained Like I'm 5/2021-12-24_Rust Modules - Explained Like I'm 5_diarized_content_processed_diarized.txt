00:00:00.360 - 00:00:48.049, Speaker A: What's up, Rustations? Welcome back to let's Get Rusty, your number one resource for all things Rust. If you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com Cheat Sheet. In today's video, we're going to cover one of the most confusing topics in Rust for newcomers, and that's Rust module system. Specifically, we'll go through what modules are, why we need them, how modules in Rust are different from modules in other languages such as Python or JavaScript, and we're going to learn how to actually implement modules by going through a code example. So with that said, let's get Rusty. Modules serve a few purposes.
00:00:48.049 - 00:01:34.257, Speaker A: They help us organize code for readability and reuse, and they also help us control scope and privacy. Modules contain items such as functions, structs, enums, traits, and other modules. So far, this all probably makes sense. However, if you're coming from a language such as Python or JavaScript, where modules are mapped to files, then you might be confused, because in Rust, modules are not mapped to the file system. In Rust, modules have to be explicitly defined with the mod keyword. A single file could have multiple modules defined inside of it, for example. The Rust team chose this approach to make the module system flexible and to make things such as conditional compilation straightforward.
00:01:34.257 - 00:02:12.815, Speaker A: All right, enough with the theory. Let's see how modules work by going through a code example. What we'll do is implement a library called auth service without using modules, and then we'll see how we can use modules to refactor our code. So the first thing we'll do is create a library crate called auth Service. Then we'll CD into our newly created directory and open it up in Vs code. Here I have our Auth service project open. First, let's delete the default code in lib RS and then implement a function called authenticate.
00:02:12.815 - 00:03:14.535, Speaker A: Authenticate is going to be the public API of our auth service, and it's going to take a set of credentials. So next let's create a struct that represents the credentials, and we're going to have a username and password. And then authenticate is going to have one input parameter called creds. As you can see, we get some warnings indicating that our struct, function and argument are not used. Now, in a typical application, I would want these warnings so I can get rid of unused code. But because this is just an example, I'm going to add a crate level allow attribute to suppress these warnings. Now, our auth service is going to verify the credentials by checking against the credentials stored in a database.
00:03:14.535 - 00:04:26.197, Speaker A: So let's create another method that allows us to connect to a database and we'll simply call this Connect to database. Connected database is going to return a status which will define up above. Because this is just an example, we're going to have Connected database always return connected variant. Inside our authenticate function, we'll call connect to database and if the status return is connected, we'll attempt to authenticate the user. If the status returned from connected database is connected, then we're going to call the login function which isn't implemented yet. So let's go ahead and add it. The login function is going to perform some sort of authentication and once it succeeds, it will return a user object by calling getuser.
00:04:26.197 - 00:04:54.889, Speaker A: For completeness. Let's also add a function that will log the user out. With that, our auth service library is complete. However, this code could be improved. In this single file, we have multiple levels of abstraction. We have the high level function we want to export exposed from our library called authenticate, and then we have lower level functions like get user, logout, et cetera. This single file is also mixing concerns.
00:04:54.889 - 00:05:33.795, Speaker A: We have models and functions that have to do with authentication, such as credentials and login. And we also have functions and models that have to do with the database which are connected database and status. We can clean this code up by encapsulating the authentication related code and the database related code into separate modules. Before we do that, it's worth noting that we already have a module. And to prove that, let's open up the terminal and install cargo modules. Cargo modules is a cargo plugin that allows us to visualize our crate module tree. To install cargo modules, you simply type cargo Install cargo modules.
00:05:33.795 - 00:06:21.783, Speaker A: Then to visualize the module tree, we type in cargo modules generate tree. As you can see, we currently have one module called crate. The crate module is the root of your module tree and it's automatically created for every crate. The contents of the crate module is either lib RS if you're working with a library crate, or main RS if you're working with a binary crate. In this case, auth service is a library crate. So the contents of the crate module is lib rs and we can see that if we run the generate tree command again, but specify the with types flag. Here we see that our crate module has a struct, an enum, and several functions.
00:06:21.783 - 00:06:58.295, Speaker A: Here we can also see the visibility of each item in rust. By default, most things are private. Each of these items are tagged with pub crate, meaning that they're visible inside our crate, but they're not visible to consumers of our crate. So currently our auth service library has no public API. Now, most of these things we want to keep hidden from consumers. However, we do want to expose the authenticate function to consumers, and in order to do that, we could change its visibility by using the pub keyword. Let's go ahead and scroll down to our authenticate function and prefix our function with the pub keyword.
00:06:58.295 - 00:07:45.561, Speaker A: Now, here we get an error because we're making the authenticate function public. However, its argument credentials is still private, which doesn't make sense. So let's also make credentials public. Then we'll go back to our terminal and generate our module tree again. Now, you can see that our create module has a public interface with two items, the credential struct and the authenticate function. This is exactly the public interface we want. So next let's focus on organizing our code by taking the database related related code and putting it into a module, and then taking the authentication related code and putting it into another module.
00:07:45.561 - 00:08:57.315, Speaker A: First, we'll create our database module. To create a module in Rust, we use the mod keyword. Next, we'll put the status enum inside our database module. We also want the connect to database and get user functions inside our database module. Our database module is now complete. Next, let's create an authutils module which stores the auth related code. We'll also create a sub module inside of authutils called Models, which will store the credentials structure.
00:08:57.315 - 00:09:40.989, Speaker A: All right, now that we've created all our modules, let's focus on fixing these errors. If I hover over the red squigglies, you can see it states Credentials is not found in this scope, and neither is getuser. This makes sense. Credentials is defined within a sub module called models, and getuser is defined within the database module. We need to tell the authutils module how to find these items. To do so, we can specify the item's fully qualified name, which is either the relative path to that item within the module tree or the absolute path to that item within the module tree. For example, we know that credentials is defined within the models sub module.
00:09:40.989 - 00:10:23.825, Speaker A: So to specify a relative path, we can simply type in models colon colon credentials. For getuser, we can use the absolute path by starting off with the module tree root, which is going to be our crate module, and then navigating to the database module. Now we get a different error which states that the getuser function is private. Up here, we were able to use credentials without an error because credentials is already declared as public. However, if we scroll up to the database module, you can see that the getuser function is not public. Remember in Rust, most things are private by default. So if we want to make getuser visible outside of this module, then we need to use the pub keyword.
00:10:23.825 - 00:11:19.207, Speaker A: Now, if we scroll back down to the authutils module, you can see that the errors are gone. Next, let's tackle errors in our authenticate function. Here we're using credentials, status, connected database, and login, all of which are not defined within this scope. So again, we need to specify the path to these items within the module tree. Let's go ahead and use relative paths to give all these items a fully qualified name. And like before, we see a bunch of privacy errors. The models module is private, the status enum is private, the connect to database function is private, and the login function is private.
00:11:19.207 - 00:12:15.515, Speaker A: Here we have access to the authutils module and the database module. Because they're defined within the same scope as authenticate, they're all siblings inside the crate module. The models module, however, is defined within authutils and so is private by default. To fix these errors, we simply have to make these items public, and now all the errors are resolved. Now, you may have noticed that these fully qualified names could get quite long, especially if we have multiple levels of sub modules. To clean up this code a bit, we could take advantage of the use declaration to create local name bindings to a given path. For example, let's copy this path to credentials and create a use declaration.
00:12:15.515 - 00:13:09.655, Speaker A: Then we can change this line to simply use credentials. Here we're saying that whenever credentials is used within this scope, which is the create module, then it refers to the credentials struct, which is defined within the models module, which is inside the auth utils module. Another way of wording this is that the use declaration is bringing credentials into scope. And yet another way to word this is that we're importing credentials. Although I hesitate to use this language because the use declaration is a shorthand for referencing fully qualified symbols that are defined somewhere within our module tree, which is different than importing an external dependency. In the rustling book, the language tends to be bringing items into scope, so that's the language I'll also be using. With that aside out of the way, let's also bring the status enum into scope.
00:13:09.655 - 00:14:00.925, Speaker A: All right, our code is now compiling, and it's a Little more organized. Let's open up the terminal and see what our module tree looks like. As you can see, we have our Create module and then two sub modules, Authutils and Database. If I open up the File Explorer, you'll see that we only have one file inside of our source directory, Lib rs, yet we have several modules inside our module tree. This goes back to my point that Rust modules don't have a one to one mapping to the file system like other languages such as JavaScript or Python. However, let's say you did want to split up your modules into separate files. So far, the modules we've defined have been inline, meaning that the module declaration and its contents are defined together.
00:14:00.925 - 00:14:40.443, Speaker A: You can, however, define the contents of your module in a different file. In Rust, there are two ways of doing this, both of which can be awkward or confusing if you're coming from other languages. So let's go through each way together. If you have a module with no sub modules, such as the database module here, then the process is straightforward. In our source directory, we could create a new file called database rs. And then we could take the contents of our database module and put it in database rs. Then go back to lib RS and replace the curly brackets with a semicolon.
00:14:40.443 - 00:15:30.651, Speaker A: Nice and simple. If we open up our terminal and look at our module tree again, you'll see that it didn't change. Database is still a child of Crate. Now, one thing you might be wondering about or find confusing is why do we need this mod database declaration inside lib rs? Let's see what happens when we comment out this line and generate our module tree again. As you can see, Database is no longer in the module tree. Remember that in Rust, modules are not mapped to the file system, so there's no way to tell that this database RS file is the database module and that it's a sub module of Crate. In Rust, sub modules must be declared within the parent module, regardless of if their content is defined inline or in a different file.
00:15:30.651 - 00:16:03.121, Speaker A: Having this database declaration on line three tells Rust that the create module has a sub module called Database. And because the contents of the database module are not defined in line, Rust will automatically look for a file called database rs. All right, that was pretty straightforward. Now let's talk about modules with sub modules, like our authutils module. As I mentioned before, there are two ways to structure this. The first one is to create a folder with the same name as our module, which contains a mod.rs file.
00:16:03.121 - 00:16:48.245, Speaker A: For example, let's create a new folder inside our source directory called authutils. Then inside the authutils folder, we'll create a file called mod rs. Then we'll go back to lib rs, take the contents of authutils and move it into the mod RS file. Next we'll create another file inside authutils called models rs. Then we'll go back to mod rs, take the contents of the Models module, and move them into models rs. Next we'll go back to mod RS and replace the curly brackets with a semicolon. And finally we'll go back to lib RS and do the same thing.
00:16:48.245 - 00:17:17.246, Speaker A: Authutils is defined as a sub module of crate. The contents of authutils are not defined inline. So Rust will look for a file called authutils rs. No such file exists. So next Rust will look for a file called mod RS inside of a folder called authutils, which does exist. Here we can see the contents of authutils. Now authutils has a sub module called models, and the contents are not defined inline.
00:17:17.246 - 00:17:54.787, Speaker A: So again Rust will look for a file called models rs, which exists. One important thing to know here is that models RS must be located inside the authutils folder, not the source directory. All right, we've successfully moved the contents of all our modules into separate files. This approach of using a mod RS file is analogous to using an index JS file in JavaScript. The downside of this approach is imagine having a bunch of mod RS files open in your code editor. It could be hard to tell which module you're modifying. Which brings us to the second approach, which was introduced in the 2018 edition of Rust.
00:17:54.787 - 00:18:48.273, Speaker A: Instead of a mod RS file, we're going to create a new file in our source directory called authutils rs. Then we'll copy over the contents of mod RS and delete mod rs. With this approach, the contents of authutils is defined within the authutils RS file, and all of its sub modules are defined within the authutils folder. Either approaches work, and you can mix and match them as you please. Going back to lib rs, you can see that our code is a lot cleaner. Our auth service library has one public function called authenticate, and all the implementation details are hidden away in sub modules. One thing that might be confusing here are these mod statements next to these use statements.
00:18:48.273 - 00:19:34.415, Speaker A: The mod Statements on line 3 and 4 indicate that our crate module has two sub modules, database and authutils. The use statements on line six and seven, bring credentials and status into scope so that we don't have to use their fully qualified names. Use statements are also useful for re exporting. Currently our Create module only exports one item, the authenticate function, but we also need to export the credential struct from our top level module. To accomplish this, we can re export credentials by adding the pub keyword before use. Now we're bringing credentials into scope and re exporting it from the top module and with that our auth service library is complete. If you found this information useful, make sure to give the video a like and leave a comment down below.
00:19:34.415 - 00:19:49.135, Speaker A: Tell me which confusing Rust topic you want me to cover next. Lastly, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet and with that, I'll see you in the next one.
