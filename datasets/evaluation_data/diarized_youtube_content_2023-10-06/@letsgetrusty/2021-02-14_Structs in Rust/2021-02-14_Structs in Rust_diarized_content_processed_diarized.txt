00:00:00.360 - 00:00:29.110, Speaker A: Welcome back to let's get Rusty. My name is Bogdan and this channel is all about the rust programming language. If that sounds interesting to you, make sure to hit the subscribe button and notification bell so you can be notified when new videos come out. Last time we went over chapter four of the rustling book, in which we covered Rust's ownership model. If you haven't already, make sure to check that video out. Enums and structs are the building blocks for creating new types in rust. In this video we're going to go over chapter five, which which covers grouping related data using structs.
00:00:29.110 - 00:01:06.670, Speaker A: We'll also cover how to define methods and associated functions on structs and how they compare to tuples. So with that, let's get started. Now, like I said before, structs allow you to group related data together. Think about them as object attributes in an object oriented programming language. If you haven't already, go ahead and create a new cargo project. I've created one called structs here, and as an example we're going to create a structured a user. So to start off we'll use the struct keyword followed by the name of our struct curly brackets, and then we list the attributes we want on our struct.
00:01:06.670 - 00:01:53.182, Speaker A: So the first thing we want is a username and it will be of type string. Next we want an email address, and this will also be of type string. Next we want to track how many times the user has signed in, and this is going to be an unsigned 64 bit integer. And lastly we're going to track if the user is active, and this will be a simple boolean. Now, like a tuple, our struct allows us to group related data together of different types. So here we have strings and unsigned 42 bit integer and a boolean. But we get the benefit of actually naming our structure.
00:01:53.182 - 00:02:47.620, Speaker A: So this is a new type and we also named the data inside our struct. This allows us to reference our data by name instead of by index location. Now that we have our user struct defined, let's create a new instance. So in main we'll create a new variable called user one, and we'll set that equal to new instance of user by specifying user curly brackets. And then we'll specify the attributes and these could be in any order. So we'll start with email, and then we'll specify username. Active will be set to true, and signing count will be one.
00:02:47.620 - 00:03:39.738, Speaker A: We can guess specific values from our struct using the dot notation. So for example, let's create a new variable called name, and we'll set that equal to the username of our user one variable. We can also modify specific values in our struct using the dot notation. So first we'll have to make our user one variable mutable. And now let's change the username of our user one variable. And notice here that we had to make the entire struct mutable. We can't just make one field of the struct mutable.
00:03:39.738 - 00:04:50.610, Speaker A: We can also use functions to construct new instances of user. As an example, let's create a new function called build user and it will take in an email and username, and what we want to return is a new instance of user. The email address of our new user should be the email address passed in to this function, same thing with the username, and we'll set default values for the other attributes. And I get an error because of course we actually have to specify that we're returning a user type. Lastly, because our function arguments have the same name as the fields in our user struct, we can simplify this declaration like so. This is called the field init shorthand syntax. Alright, now let's go back up to main and use our function to create another user.
00:04:50.610 - 00:06:05.558, Speaker A: Another nice convenient feature is that we can create new instances of a struct using existing instances. As an example, let's create another user and we'll give our user an email and username. And now we could say for the remaining fields just give us whatever user two has. And to do that we'll just type user two. So in this case user three will get this email address, this username, but for the active and sign in fields they'll come from user two. So active will be true and sign and count will be one. We can also create structs without name fields, and these are called tuple structs.
00:06:05.558 - 00:06:58.618, Speaker A: As an example, let's create a tuple struct called color and one called point. Tuple shucks are useful when you want your entire tuple to have a name and be of different type than other tuples. So as an example, color and point both have the same field types, which are three sine 32 bit integers, but they are of different type. One is color and one is point. So if a function expects a tuple struct of type point, you cannot pass it color. There's also something called unit like structs, which are structs without any fields, but we'll cover those in chapter ten. Lastly, notice that our user struct has two fields, username and email, which are both of type string.
00:06:58.618 - 00:07:26.732, Speaker A: And that's because we want our fields to actually own the string data. We could have our fields reference borrowed data such as string slices. However, that requires using lifetimes. So we'll cover that topic in chapter ten. To understand the value of structs, we'll rewrite this program that calculates the area of a rectangle. As you can see, in main we have two variables for the width and height of a rectangle. And then we pass those variables into a function called area, which takes in a width height, and then calculates the area.
00:07:26.732 - 00:08:15.710, Speaker A: Now let's run this program by typing in cargo run, and as you can see, we get back 1500 pixels, which is correct. So this program works, but it could definitely be improved in terms of readability. For example, we're calculating the area of one triangle so the width and the height are related. However, our program doesn't express that these two variables are related. So to make this more readable and more manageable, let's start by grouping these two variables together using tuples. Instead of passing in two variables, we'll pass in one variable called dimensions, and that will be equal to a tuple containing the width and the height. Then we'll modify the body of the function to multiply the first and second value of our dimensions tuple.
00:08:15.710 - 00:08:49.404, Speaker A: Now that our function is working, instead of passing in a width and a height, we're going to pass in a variable called rect and we'll define it above. Now let's run our program again to make sure it works. Great, our program works. And now our width and height are grouped together. Now we have a new problem. It's great that we're passing in one variable that describes the dimensions of our rectangle. However, it's not clear what the fields in our tuples represent because they're not named.
00:08:49.404 - 00:09:49.540, Speaker A: So is the first variable the width or the height? To remove this ambiguity, let's refactor this code again using structs. First we'll create a new struct called rectangle and it will have two fields, width and height. Next, we'll change our variable rect to be an instance of our rectangle struct. Now let's modify our function to accept a rectangle structural. And here you can see we're passing in a reference to a rectangle because we want to use its fields but not actually take ownership. So now let's modify the body of our function. Lastly, we'll go back up to main and pass in a reference to our rectangle.
00:09:49.540 - 00:10:27.390, Speaker A: Now let's rerun our program and as you can see, we get 1500 as expected. But now our program is a lot more readable because we have a type for our rectangle with meaningful fields. Next, let's talk about derived traits. While building out this program, it would be nice to see what our rectangle instances look like. To do this, let's try to print out our rectangle and we get an error. If we hover over, we could see that it says our rectangle struct doesn't implement the display trait. The display trait specifies how something should be printed.
00:10:27.390 - 00:10:57.832, Speaker A: Primitive types such as integers implement this display trait by default because there's only one way to print an integer. But for custom types like our struct, we have to implement it ourselves. Notice that we also get this helpful hint in format strings. You may be able to use this syntax and the syntaxes inside our brackets add a colon and a question mark. So let's try that. And now we get a different error. Our rectangle struct doesn't implement the debug trait, which allows us to print out information useful to developers.
00:10:57.832 - 00:11:31.778, Speaker A: And here we also get some helpful text. It says add this derived debug text or manually implement debug. So let's try adding this text to our struct. And now the error has gone away. Now if we run our program again, you can see we get our rectangle instance printed out. We can make this a little prettier by adding the hash symbol or hashtag between the colon. And here you can see our fields get printed on a new line which is more readable.
00:11:31.778 - 00:12:05.180, Speaker A: Going back to our struct. Debug here is a trait, and adding derive here allows the compiler to provide a basic implementation of the debug tree. And again, we'll learn more about traits in chapter ten. Our program is looking pretty good. We got related data grouped together under the rectangle struct. However, now we have this function called area that's very closely tied to a rectangle, but is defined separately from the rectangle. We can improve this by grouping area with our rectangle struct by using the method syntax methods are similar to functions, except that they're tied to an instance of a struct.
00:12:05.180 - 00:12:37.378, Speaker A: So let's go up here and add an area function to our rectangle. Structural we'll start by creating something called an implementation block for a rectangle struct. To do that, we'll use the impl keyword followed by the name of our struct, and then curly brackets. Implementation blocks will house the functions and methods associated with our struct. Now, let's define the area method. The first argument in a method is always self, which is the instance the method is being called on. Here we're taking a reference to our rectangle instance.
00:12:37.378 - 00:13:15.298, Speaker A: We could also take immutable reference, or in rare cases, we could take ownership of the instance. In this case, we only need a reference. Next, let's specify our return type in the body of our method. We're going to multiply the width and height of our instance. Next, we can scroll down and delete our original area function. Then we'll replace the call to our area function with a call to the area method on our rect instance. Lastly, we can run our program again, and we get the same exact output.
00:13:15.298 - 00:13:55.072, Speaker A: The benefit of using a method is that our code is a lot more organized now, and it's clear that the area function is associated with rectangles. Another thing to note is down here, we use the dot notation to call the area method on our rect instance. In languages like C, there's different syntax when you're calling a method on an object directly, or calling the method on a pointer to an object. In rust, the syntax is the same because rust has a feature called automatic referencing and dereferencing. Next, let's create a method that takes in multiple parameters. Our method will be called can hold. It will take in a reference to another rectangle and determine if the current rectangle instance can hold the pass in rectangle inside itself.
00:13:55.072 - 00:14:35.240, Speaker A: Just like before, we'll start with declaring our method. And again, the first argument is always self. Our second argument is going to be called other, and it's going to be a reference to another rectangle. Lastly, our return type is going to be a boolean in our body. We're simply going to check if our current instance has a greater width and height than the passing rectangle. Now let's go back to main and create two more rectangles. Our first rectangle is going to be smaller.
00:14:35.240 - 00:15:34.420, Speaker A: Then we'll create a third rectangle that's bigger. Now well call the canhold method passing in our two new rectangles. Now we'll run our program again, and as you can see, rect can hold rect one because it's smaller, but cannot hold rec two because rect two is bigger. Inside our implementation block, we can also define associated functions. Unlike methods, associated functions are not tied to an instance of our struct as an example, let's write an associated function that constructs a square. We could write our associated function inside this implementation block, but structs allow us to have multiple implementation blocks. So for the sake of example, let's create a new implementation block.
00:15:34.420 - 00:16:24.900, Speaker A: Next lets define our square function. Now because its an associated function and not a method, we dont get past in the self argument. So here well just take in an argument called size and our return type will be a rectangle inside the body. Well create a rectangle instance and pass in size for both the width and heighten. Again, we could have defined our square associated function in the original implementation block, but just for example we defined it in this new block. In chapter ten we'll talk about the usefulness of multiple implementation blocks when we talk about generic types and traits. Also note that the way to differentiate methods and associated functions is by the self argument.
00:16:24.900 - 00:16:59.538, Speaker A: Methods get past self, whereas associated functions don't. Now let's scroll back down to main and use our square associated function. We'll create another variable called rect three. And now instead of using the dot notation, we'll type in rectangle and then our square function. And there you have it. In this chapter we learn how to use structs to group related data and functionality. We learn how structs relate to tuples and we use structs to refactor some existing code to make it more readable and manageable.
00:16:59.538 - 00:17:10.850, Speaker A: If you like this video, make sure to give it a like. And if you want to see more rust content, make sure to hit subscribe and the notification bell so you can be notified of new videos. With that, I'll see you in the next one.
