00:00:00.440 - 00:00:49.373, Speaker A: Rpc, which stands for remote procedure Call, is a way for your code to call an external service using a function call instead of an HTTP request. The benefit of this technology is that it simplifies your code because it looks like you're making regular function calls even though you're accessing an external service. This is why RPC is commonly used in a microservice architecture. Grpc, which was created by Google, is the most popular RPC framework. One major benefit of GRPC is that microservices could talk to each other even if they're implemented in different languages. This is because RPC functions and arguments are defined using an interface definition language called protobuf. That protobuf is then used to generate function stubs in many different languages.
00:00:49.373 - 00:01:23.683, Speaker A: Rust has great support for grpc. In today's video, we're going to learn how to use GRPC in Rust by implementing a GRPC server and client. But before we get to that, if you haven't already, make sure to get your free Rust cheat sheet by heading over to LetsGetRusty.com cheat sheet. With that said, let's get rusty. In this video, we're going to simulate a payment service in Rust. The first thing we want to do is define our protocol buffers.
00:01:23.683 - 00:02:07.465, Speaker A: So to do that, let's create a new folder in the root directory called Proto. Then we'll add a file called Payments Proto. Then we'll specify the syntax version we're using and define a package name. The package name will be used by the GRPC library we add later on. Next, let's define a service. Our service is going to be called Bitcoin, which is a payment method, and it's going to have one function called Send Payment, which takes a BTC payment request and returns a BTC payment response. Let's define both those messages.
00:02:07.465 - 00:03:17.615, Speaker A: A payment request is going to have a from address to address and payment amount, and a payment response is going to have a flag indicating if the transaction was successful and a message. Now that our protocol buffers are defined, let's flip over to Cargo TOML and add some dependencies. The first two dependencies we'll add is Tonic and Prostitute. Prost is a protocol buffer implementation for Rust, and Tonic is a GRPC implementation for Rust. We'll also take a dependency on Tokio, which is the most popular Async runtime for Rust for Tokyo will enable the macros and multithreaded runtime features. We'll also take a build dependency on Tonic Build, which will allow Cargo to build our Protocol buffers during compilation. To use this dependency, we'll also need to add a Build RS file in the root of our directory.
00:03:17.615 - 00:04:24.289, Speaker A: This file acts as a build script for Cargo and it will configure Tonic Build. Here we're telling Tonic Build to compile our protocol buffers, which are located in the Proto directory. With the setup out of the way, let's create our GRPC server and client. First, we'll rename Main RS to Server rs. We'll also create a new file in the source directory called Client rs, and we'll give Client RS an empty main function. Then we'll navigate back to Cargo toml and mark both these files as binary crates. Server RS is going to be compiled to a library called Payments Server, and Client RS is going to be compiled to a binary called Payments Client.
00:04:24.289 - 00:05:22.515, Speaker A: Then we'll implement the GRPC server. First, we'll import the various types Tonic generated for us based on our protocol buffer definitions. On lines six through eight, we declare a new module called Payments, which is going to use the Include proto macro to include the types Tonic generated for us based on our Payments proto file. On line three and four, we bring those types into scope. Also on line one, we bring some types defined in the Tonic library into scope. Underneath the Payments module, let's create a new struct called Bitcoin Service. Then we'll implement the Bitcoin trait which we defined up here for Bitcoin Service.
00:05:22.515 - 00:06:41.095, Speaker A: The Bitcoin tray requires that we implement all the methods we've defined on the Bitcoin service, which in this case is only one method called Send payment. Also note that we add this Tonic asynctrate attribute because the Send payment method is going to be async. The Send payment method is going to take a request which is going to be a GRPC request containing BTC payment request metadata, and return a result which is either going to be a GRPC response containing BTC payment response metadata or a GRPC status. In the error case inside the method body, we're going to print the request, get the request metadata, create a reply, and then send out the reply. Because this is just an example, we're always going to set successful to true. The last thing we need to do is update main. Let's update Main to use the Tokyo Async runtime.
00:06:41.095 - 00:07:35.855, Speaker A: Then we'll create a new instance of Bitcoin service. And finally we'll instantiate a new GRPC server which uses Bitcoin service. With that, our GRPC server is now complete. Next, let's implement our GRPC client just like before. First we'll import the protobuf types Tonic defined for us. In this case, we only need Bitcoin client and BTC payment request. And again like before, we'll update Main to use the Tokyo runtime.
00:07:35.855 - 00:08:48.395, Speaker A: Inside Main, let's instantiate a new instance of Bitcoin client. Then we'll create a new BTC payment request. Finally, we'll send the request and print the response. With that, our GRPC client is now complete. Let's go ahead and test our code by running the GRPC server and client at the same time. First we'll run the server by typing in Cargo Run Bin Payments Server. Then we'll run the client in a separate terminal by typing in Cargo Run Bin Payments client.
00:08:48.395 - 00:09:11.475, Speaker A: As we can see, our GRPC server got the request and returned a response. That's it for this video. But before you leave, make sure to get your free Rust cheat sheet by heading over to letsgetrusty.com cheatsheet also, if you enjoyed the content, make sure to give the video a like and subscribe to the channel. With that said, I'll see you in the next one.
