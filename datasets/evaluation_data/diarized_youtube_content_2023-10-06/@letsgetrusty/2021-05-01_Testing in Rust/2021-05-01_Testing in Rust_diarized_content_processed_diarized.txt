00:00:00.400 - 00:00:38.600, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan, and this channel is all about the rust programming language. If that sounds interesting to you, make sure to hit subscribe for weekly rust videos. In the last video, we covered chapter ten of the rustling book, which talked about generics, traits, and lifetimes. It was a big chapter, so if you haven't seen that already, make sure to check it out. In this video, we're going over chapter eleven of the wrestling book, which talks about testing, and we're going to break it up into two parts. Part one, which is this video is going to talk about writing tests, and part two is going to talk about running tests and organizing tests into integration tests and unit tests.
00:00:38.600 - 00:01:14.966, Speaker A: So with that, let's get rusty. Before we start, as a quick aside, let's talk about why we want to write tests. Rust already does a great job making sure our program is correct with a powerful type system and things like the borrow checker. So it could check that we're passing around the right types and that we're not mismanaging our memory. But it can't really check that our functions, for example, are doing the right thing. You know, it can't check our business logic, the intent of our code. So for that, we need to write tests.
00:01:14.966 - 00:01:57.670, Speaker A: All right, with that, let's move on to actually writing some tests. To start off, we're going to create a new library using cargo, and the library is going to be called adder. So we'll type in cargo, new adder, and then to create a library, you type in lib. And now we can cd into our library and open it in versus code. Here I have the adder library open in versus code, and you can see in the source directory we have a file called lib dot rs. If I open it up, you can see that we already have a test module and a test written for us. Our module is called tests, and it has this config attribute with an input of test.
00:01:57.670 - 00:02:23.576, Speaker A: We can ignore this for now. And then inside we have a function called it works, which asserts that two plus two is equal to four. Now, this function has its own attribute called test. In rust, functions are tests. If they have this test attribute, we can also have other functions inside this module that are not tests and are simply helper functions. So those functions would not have the test attribute. All right, let's go ahead and run our test.
00:02:23.576 - 00:02:54.656, Speaker A: We'll open a terminal and type in cargo test. Here are the results. First, we see each test that rust ran. In this case, it's only one test, which is called it works, and then the status of the test, which is okay, meaning it was successful. Then we see a summary of all the tests that were run, and again, in this case, it's only one test. So the status is okay, meaning all the tests passed. We have one passing test, zero failed test, zero ignore tests, zero measure tests, and zero filtered out tests.
00:02:54.656 - 00:03:24.654, Speaker A: In the next video, we'll go over how to ignore and filter out tests and measure tests. Here are performance tests. The section below is similar to the section above, but it's specific to document tests. In rust, you can write tests in your documentation. Currently, we don't have any documentation or tests in our documentation, so you can see everything is zero here and the status is okay. We'll learn about documentation tests in chapter 14. Next, let's write a test that fails in rust.
00:03:24.654 - 00:03:58.534, Speaker A: A test fails when something inside the test function panics. Each test is ran in a new thread, and if the main thread sees that the test thread has died, then it fails the test. So here we'll add a test called failing test, and inside we'll just panic right away with the message, make this test fail. Let's go ahead and run our test suite again. And this time you could see that we have a failing test. At the top. Here we see all our tests, and our first test failed.
00:03:58.534 - 00:04:30.124, Speaker A: Our second test succeeded. Then we have this failure section, which tells us exactly why a test failed. In this case, our failing test failed because it panicked at line nine with the message make this test fail. Then we have this bottom section, which just lists out the names of the failing tests. And then finally, we have our test summary. So even though we have one passing test and one fail test overall, the summary is our test suite failed. Now that we know the basics of writing a test, let's test some actual code.
00:04:30.124 - 00:05:20.398, Speaker A: And to do that, I'll paste in some code that we wrote in chapter five. At the top we have a struct called rectangle, which stores the width and the height of a rectangle. And then below we have an implementation block for a rectangle with one method called can hold, which takes in another rectangle and returns true if the current rectangle can hold the past and rectangle inside itself. Let's test the canhold method. So to do that, we'll go down to our test module and remove the current tests. Now, our product code is in the default module, and our tests are in the test module. So in order to test our product code, we have to bring it into scope and to do that we'll have use the use keyword and a relative path.
00:05:20.398 - 00:05:52.016, Speaker A: In this case super, because we're referencing the parent module. And then we'll simply import everything. Next we'll write our test function. And remember a test function needs to have the attribute test. So we'll add that first, and then we'll write our function. In this case, our function is going to be called larger can hold smaller. Next, we'll create two rectangles.
00:05:52.016 - 00:06:32.140, Speaker A: Here I have a rectangle called larger and a rectangle called smaller. And the smaller rectangle is obviously smaller than the larger rectangle. Next, we want to assert that calling can hold on the larger rectangle and passing in the smaller rectangle results in true. To do that, we'll use the assert macro, which asserts that a given expression evaluates to true. And in this case we're going to say larger. And then we're going to call the can hold function on our larger rectangle. And then we're going to pass in a reference to our smaller rectangle.
00:06:32.140 - 00:07:05.130, Speaker A: Let's go ahead and run our test. And our code is correct, so our test passes. Next, let's add another test. And in this case we're going to test that a smaller rectangle cannot hold a larger rectangle. Here the code is very similar to our first test. We have a larger rectangle, a smaller rectangle, except this time we call smaller can hold pass in our larger rectangle. And this is supposed to evaluate to false.
00:07:05.130 - 00:07:40.280, Speaker A: So we have the exclamation mark at the beginning to make this expression true. If false is returned. Let's run our test suite again. And this time you see we have two passing tests. Next, let's see what would happen if we introduce a bug. So we'll close the terminal and we'll go up here to our product code, and let's change this greater than sign to a less than sign, for example. And then we'll run our test suite again.
00:07:40.280 - 00:08:21.384, Speaker A: And now you can see that our test suite caught the bug. Here you can see that our test larger can hold smaller panicked. And that's because the assert macro will panic if the expression passed in the evaluates to false. Next, let's look at an example using the assert equal macro. The assert equal macro will allow you to compare two values. So in this case we have a function called add to, which takes in an integer, adds two to it, and then returns it. At the bottom we have our tests module with one test which asserts that if we call, add to and pass it to the output will be four.
00:08:21.384 - 00:09:08.926, Speaker A: Let's go ahead and run our test and our test passes. Now let's make our test fail by modifying our function. So instead of plus two, we'll say plus three, and we'll run our test again. Here you can see that our test failed because our assertion panicked, and that's because left was not equal to right. In this case, our left value was four and our right value was five. Note that in some languages or testing frameworks, the left side of an assert equals statement is the actual value, and the right side is the expected value. But in rust there's no distinction between these, so you can have the expected value as the left side or the right side.
00:09:08.926 - 00:09:47.374, Speaker A: The counterpart to assert equal is assert not equal, or assert ne. Assert not equal will do the opposite. It'll assert that the two parameters passed in are not equal. So let's run our test suite again. And this time our test passes because the two parameters passed in are in fact not equal. One thing to know here is both parameters passed into a ser not equal or assert equal have to implement the partial equality and debug traits. All the primitive values and most of the standard library have these two traits implemented.
00:09:47.374 - 00:10:25.820, Speaker A: But if we create our own structures and enums, we'll have to implement them ourselves. Next, let's talk about custom failure messages. In this example, we have a function called greeting, which takes a name that's a string and then prints hello and that name. Then we have our test module with a test called greeting contains name. We have a variable called result which calls our greeting function with the name Carol. And then we assert that result contains carol. Let's go ahead and run our test suite and we get a passing test.
00:10:25.820 - 00:10:55.630, Speaker A: Next, let's modify our greeting function to make the test fail. Here we're going to remove name. Now let's run our test suite again and we get a failure. Here we can see the test thread panicked because our result failed. At result contains Carol and it gives us the line number. Now this is okay, but it's not the most useful failure message. So let's write our own custom failure message.
00:10:55.630 - 00:11:37.756, Speaker A: So we'll take this assert statement and add a failure message. Assert takes a custom failure message as the second parameter, and the parameters after that will fill in the placeholders in our custom failure message. So in this case we have one placeholder and it will be filled in by result. In this case, our failure message is greeting did not contain name, the value was, and then we put in the result. Let's run our test suite again. And now you can see we get a much more helpful failure message. It says, panicked at greeting, did not contain name.
00:11:37.756 - 00:12:08.334, Speaker A: The value was hello. Next, let's talk about writing a test that asserts a function fails. Here we have some code from chapter two when we wrote our guessing game. We have a guest struct which holds a value. And then we have an implementation block with one function called new. Now, in order to make this guessing game work, the user has to give a value that's between one and 100. So inside this new function, we check if the value is less than one or greater than 100.
00:12:08.334 - 00:12:42.952, Speaker A: Then we panic. Now if I scroll down to the test suite, you can see we have one test function called greater than 100. Here we create a new guest struct and pass in 200, which should make the function panic. Now, right above the function name you can see we have this attribute called should panic. What this will do is assert that the code inside this function body should panic. So let's go ahead and run our test suite, and you can see our test suite passes. Now let's modify the new function so that it does not panic.
00:12:42.952 - 00:13:05.856, Speaker A: And what we'll do is remove this check for a value that's greater than 100. Then we'll rerun our test suite. And now you can see our test failed. And here we have a note. Test did not panic as expected. Now this works, but it's very imprecise. All our test is saying is that the function we call should panic, but it could panic for any reason.
00:13:05.856 - 00:13:47.064, Speaker A: Let's make our assertion a little more precise. And the first thing we're going to do is modify our new function. With this modification, we'll have two different calls to panic with different failure messages. Now we can scroll down to our test suite and modify our should panic attribute to only panic for a specific failure message. Like so this is saying, assert that the code in this test function panics, and the failure message is expected to be guess value must be less than or equal to 100. Let's run our test suite again. And our test suite passes.
00:13:47.064 - 00:14:33.202, Speaker A: And that's because we're passing in 200. So now let's change this to negative two and run our test suite again. And now we get a failure because the message we got was different than the message we expected. The last thing we're going to talk about are tests that return a result type. In this example, we have a test function called it works, which returns a result type. And the success case is going to be a unit type, which is basically nothing, or in the error case, we're going to have a string tests that return a result type allow you to use the question mark operator, which can be convenient if you have multiple operations within the test that could return an error type and you want the test to fail. If any of those return an error type.
00:14:33.202 - 00:15:00.590, Speaker A: There you have it, part one of chapter eleven complete. In this part, we learned how to write tests, and in the next video we'll learn how to run tests in different ways, and also how to organize tests between unit tests and integration tests. If you enjoyed this video, make sure to give it a like. And if you want to see more rust content every single week, make sure to subscribe. And with that, I'll see you in the next one.
