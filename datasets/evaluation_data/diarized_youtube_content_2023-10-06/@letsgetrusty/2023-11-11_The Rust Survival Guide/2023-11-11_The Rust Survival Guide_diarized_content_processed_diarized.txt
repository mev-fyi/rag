00:00:00.440 - 00:00:45.455, Speaker A: There are so many programming languages you can potentially learn, but options quickly evaporate when you start adding basic requirements. If you're looking for a language that's general purpose, gives you low level control, is memory safe, and is extremely performant, there's only one obvious Rust. The problem is many have tried to learn Rust and many have failed along the way. But all hope is not lost. To survive your Rust learning journey, all you need is a clear understanding of a few core concepts. Welcome to the Rust Survival Guide, where I'll cover the fundamental concepts of Rust you need to know to be an effective Rust developer. More importantly, I'll explain some of the weird, unique and hard to understand parts of Rust that tends to trip people up so you can write Rust code with confidence instead of rage quitting and reverting back to JavaScript.
00:00:45.455 - 00:01:42.329, Speaker A: In this video, I'll cover the most fundamental and arguably the hardest to understand aspect of Rust memory management. Specifically, I'll explain how ownership, borrowing, and lifetimes work together to prevent catastrophic memory bugs while maintaining peak performance, and how you can use these concepts to effortlessly write idiomatic Rust code instead of getting stuck fighting the borrow checker. Now, it's no secret that the Rust compiler is the Karen of all compilers screaming at you for every little mistake you make. But this is for good reason. You see, traditionally, memory management, specifically memory management on the Heap, has been done in one of two ways, either by using a garbage collector that cleans up memory for you, or by giving developers the ability to manually allocate and deallocate memory. But these two approaches are problematic. Using a garbage collector results in too much runtime overhead for a system's programming language, and manual memory management is simply too error prone.
00:01:42.329 - 00:02:22.557, Speaker A: Trusting developers to manually write safe code is like giving a flamethrower to a toddler. Something is definitely getting burned down. Rust takes a unique approach to memory management, which solves both of these problems. The Rust compiler, or more specifically, a portion of the compiler known as the borrow Checker, analyzes your code and enforces a few simple rules at compile time that makes writing code which violates memory safety simply impossible. And because these rules are enforced at compile time, there is no runtime overhead, resulting in the beautiful combination of optimal performance and memory safety. The rules I'm referring to are known as the ownership and borrowing rules. Let's start with ownership.
00:02:22.557 - 00:03:01.113, Speaker A: There are only three rules the compiler enforces. The first rule is that each value in Rust has an owner. In this case, the value is a heap allocated string and its owner is the S1 variable. The second rule is that there can only be one owner at a time. So what happens when we create another variable and set it equal to S1? If we tried to print S1, we would get a compile time error stating borrow of moved value s1. This is because when we set s2 equal to s1, the value which is the heap allocated string is moved into S2 and S1 is invalidated. S2 is now the new and sole owner of the heap allocated string.
00:03:01.113 - 00:03:35.312, Speaker A: If we wanted this code to compile, we would either have to print S2 or we could explicitly clone S1. This will create a new heap allocated string and assign it to S2. Moving values also applies to functions. In this case, calling print string will move the heap allocated string out of S2 and into the s argument of the print string function. The third rule states that when the owner goes out of scope, the value will be dropped. Scope simply refers to the region of code between curly brackets. When our heap allocated string is created, its owner S1 is in main scope.
00:03:35.312 - 00:04:19.353, Speaker A: Then ownership is transferred to S2, which is still in main scope. Finally, ownership is transferred to the S argument of the print string function. At this point, the owner of the heap allocated string, which is the S argument, is inside the print string function scope. At the end of the function, S goes out of scope and the value which is a heap allocated string is dropped or deallocated or cleaned up, whichever word you want to use. As you can see, Rust ownership rules ensure that memory is automatically cleaned up without the need of a garbage collector. But while the ownership system provides a solid foundation for memory safety, there are often cases where we want to access data without transferring ownership. For example, let's say we wanted to call print string twice.
00:04:19.353 - 00:05:08.803, Speaker A: This results in an error because the first time we call print string, S1 is moved into the printstring function and then dropped at the end of the function scope. One way we can solve this problem is by cloning S1, but that requires extra memory allocation, which is not ideal. Another solution would be for the print string function to take ownership of a string, print it out, and then give ownership of that string back to the caller by returning it. But this is also not ideal. We don't want to be returning values from a function just to appease the ownership rules. What we really want is a way to access data without transferring its ownership, and this can be done by using references instead of the print string function. Taking a string as an argument will change it to take a reference to a string and update the print string call sites to pass in a reference instead of an owned value, and our code is now compiling.
00:05:08.803 - 00:06:14.625, Speaker A: We can further improve this code by making the print string function accept a string slice if you're not familiar with string slices, I made an entire video about strings in Rust, which I'll link in the description. Creating references in Rust is called borrowing because metaphorically the reference borrows access to the data from the owner without taking ownership itself, similar to how when you borrow something in real life, you're temporarily using it without taking permanent possession of it. And just like owned values must abide by the ownership rules, borrowed values must abide by the borrowing rules, and there are only two the first rule is that at any given time you can either have one mutable reference or any number of immutable references. To demonstrate this, we'll create two variables holding references to the heap allocated string. Both of these references, or borrows in Rust speak, are immutable, which means we're not violating Rule 1. However, if we made one of these variables a mutable reference, the Rust compiler would throw an error. This may seem like a strange limitation, but it ensures that if the value is being mutated, no other part of the code can be reading or modifying it at the same time.
00:06:14.625 - 00:06:50.221, Speaker A: To illustrate why this could be a problem, let's look at a more realistic example. Here we have a variable called X which stores a vector of numbers. We then save the last element in the vector, push a new element onto the vector, and finally print the saved last element. This code will not compile due to Rust borrowing rules. Why is that? When we call the last method, we get an immutable reference, which we later use to print out the last element in the vector. But in the middle of using this immutable reference, we call the push method, which takes a mutable reference to self. This overlapping use of immutable and mutable references is problematic.
00:06:50.221 - 00:07:34.323, Speaker A: When you push a new element onto the vector, it may need to reallocate the underlying memory to accommodate the new element. If it does reallocate the memory, our reference to the last element will be pointing to deallocated memory, leading to undefined behavior when we try to print it out. Luckily, the Rust compiler prevents us from making this mistake, and the fix is straightforward. We can simply move the call to push up one line so that the mutable reference or borrow doesn't overlap with the immutable borrow. The second borrowing rule is that references must always be valid. In this example, we create the variable R without assigning a value to it. Then, inside an inner scope, we create a heap allocated string and set R to be a reference to that string.
00:07:34.323 - 00:08:15.607, Speaker A: Finally, outside the inner scope, we print out R. This is a problem because S will be deallocated at the end of the interscope, at which point R would be pointing to invalid memory. Luckily, the borrow checker rejects this code with an error stating borrowed value does not live long enough. The way the borrow checker determines if the borrowing rules are being followed is by looking at lifetimes. A lifetime refers to the span of the program during which a specific piece of data is valid. The borrow checker evaluates the lifetimes of values to ensure the ownership rules are being followed to check whether the reference is valid. The borrow checker ensures that the reference's lifetime does not outlive the owned value's lifetime.
00:08:15.607 - 00:08:58.433, Speaker A: In this case, the lifetime of the owned value S ends at the end of the interscope, while the lifetime of the reference extends beyond the inner scope because we pass it to the printline macro. To fix this, we can simply remove the inner scope. Now the lifetime of S extends to the end of the main function, and the reference we pass into the println macro is valid. The second borrowing rule ensures memory safety by preventing you from accidentally accessing deallocated or uninitialized memory, all without introducing runtime overhead. In. In this example, it was easy for the borrow checker to evaluate lifetimes to determine if the code was problematic, but that's not always the case. Sometimes we need to help the borrow checker understand relationships between lifetimes.
00:08:58.433 - 00:09:35.925, Speaker A: Take a look at this example. We create two strings in main. We then create a variable called result, which is equal to the return value of calling the longest function. The longest function takes two string slices and returns a reference to the longest string, which we then print out. Let's think about this code from the point of view of the borrow checker. As the borrow checker, how would you know if result is not a dangling reference when we try to print it out? Remember, the borrow checker checks the lifetime of references to see if they are valid or not. But what is the lifetime of result? Well, the longest function returns a reference, but as the borrow checker, we have no idea what the lifetime of that reference is.
00:09:35.925 - 00:10:11.741, Speaker A: Remember that the borrow checker runs at compile time, and at compile time we don't know if A or B is going to be returned. That decision will be made at runtime. We also don't know the concrete lifetimes of A or B because again that will be determined at runtime. This is a situation where we have to help the compiler reason about the lifetimes of references, and the borrow checker lets us know this by throwing an error which states missing lifetime specifier. To fix this error, we have to understand the difference between concrete and generic lifetimes. So far we've seen concrete lifetimes. A concrete lifetime is the span of code where a value is valid.
00:10:11.741 - 00:10:56.409, Speaker A: But when we define functions or structs that operate on references, we don't know the exact lifetimes of those references at compile time. So instead we use generic lifetime annotations to express relationships between lifetimes, ensuring the function or struct can work with references of any valid lifetime. Going back to our example to aid, the compiler will specify a relationship between the lifetime of a b and the return value. First, we'll define a generic lifetime called a generic lifetime. Parameters or annotations in Rust are prefixed by a tick. Then we'll assign that lifetime to a b and the return value. We've just created a relationship between the lifetime of a b and the return value.
00:10:56.409 - 00:11:35.209, Speaker A: The relationship states that the lifetime of the returned reference will be equal to the shortest lifetime passed into the function. With this information, the borrow checker is now able to properly evaluate our code for memory issues. In this example, the lifetimes of the reference to S1 and the reference to S2 both continue on until the end of the main function, which means we can print result without any issues. But let's see what happens when the lifetime of references differ. In this example, S2 is created inside an inner scope. The lifetime of the reference to S1 still extends to the end of the main function. However, the lifetime of the reference to S2 ends at the end of the interscope.
00:11:35.209 - 00:12:17.209, Speaker A: Remember that the lifetime of the result variable is equal to the shortest lifetime passed in, which means the lifetime of result also ends at the end of the interscope. Printing result after the interscope ends is problematic, but luckily the borrow checker catches this issue and throws an error. With this fundamental understanding of memory management in Rust, you're well set up for the rest of your Rust learning journey. There's a lot more to cover on memory safety, things like common compile time errors and how to fix them or smart pointers. Unfortunately, that would make this video way too long. But if you guys want to see follow up videos on these topics, let me know in the comments section below. Before you go, make sure to get your free Rust cheat sheet@letsgetrusty.com
00:12:17.209 - 00:12:24.145, Speaker A: cheat sheet give this video a like and subscribe to the channel for more Rust content. Hope you've enjoyed the video and remember to stay rusty.
