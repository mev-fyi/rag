00:00:00.320 - 00:00:53.084, Speaker A: If you've ever struggled to understand Rust's features or how they work together, this video is for you. Rust has many unbelievably genius features, but these features aren't exactly unique to Rust. In fact, Rust deliberately borrows these great features from many other languages and combines them into a single masterpiece. Understanding where Rust's most important features come from, and how Rust has built on top of them is critical to use Rust effectively. So in this video, I'll explain Rust's most popular features, how other languages like C, Haskell, and JavaScript influenced them, and how Rust combined those features and built on top of them to become the most loved language of our time. Note that these features are sorted by complexity, so stick around till the end for Rusts most advanced features. This video is part of a series for the upcoming official launch of my Rust developer bootcamp, the all in one Rust learning program you've all been asking for.
00:00:53.084 - 00:01:44.566, Speaker A: The exact official launch date will be determined very soon. To join the waitlist, pause this video right now and visit let's get rusty.com boot camp first, let's talk about an amazing feature rust took from C the principle of zero cost abstractions. This principle can be summarized with the following what you don't use, you don't pay for, and what you do use you couldn't have hand coded any better. This means that high level language abstractions like generics and collections should not impose any runtime overhead or performance penalties compared to code using low level abstractions like loops and counters. In the c example, we create a vector of integers and then use a for loop to find the greatest element in the vector. In this example, we have to do loop initialization, condition checking, and element comparison, making it less readable and more prone to errors.
00:01:44.566 - 00:02:25.770, Speaker A: By using the iterator abstraction, the code becomes a lot simpler. Now we just have to call the max element function. The iterator abstraction encapsulates iteration and comparison logic, making the code cleaner, more concise, and less error prone without sacrificing performance. Here's how we would write the same code in rust. First we turn the vector into an iterator by calling the iter method, and then we find the greatest element by calling the max method. In this example, we're actually using a few zero cost abstractions in rust, the first one being the iterator abstraction, the second one is the option enum, and the third is pattern matching. The beautiful thing about rust is that it builds on top of the zero cost abstraction principle by further emphasizing memory safety and thread safety.
00:02:25.770 - 00:03:13.030, Speaker A: Going back to the c example, if we were to call the max element function with an empty vector, it would lead to undefined behavior. In rust, on the other hand, the max method returns an option type, so if we were to call it on an empty vector, it would simply return the none variant. The option type forces us to check whether the return type is the sum variant or the none variant, which makes our code a lot more robust while preserving blazingly fast performance. In other languages like Python, iterators are not a zero cost abstraction. Python requires additional runtime checks to ensure the integrity of the iteration process. Because collections can change in size or structure during iteration systems, programming languages like Rust can't afford this type of performance drag. Next, let's talk about one of Rust's most fundamental features, the ownership model.
00:03:13.030 - 00:03:54.698, Speaker A: Ownership is actually based on the resource acquisition is initialization design pattern. In C, the RAII pattern states that resources like allocated memory, file handles, and database connections should be tied to object lifetimes. When an object is created, it acquires resources, and when the object is destroyed, those resources are released. Here's a C example of opening a database connection without using the RAII pattern. First, we define the db and db name variable. Then we open a database connection, check to make sure that DB is not a null pointer, perform some database operations, and finally close the connection. Think about what would happen if we didn't close the database connection.
00:03:54.698 - 00:04:32.652, Speaker A: We would create what's known as a resource leak. Now, I know this is a simple code example, but imagine if there were hundreds of lines of code between the code opening the connection and the code that was supposed to close the connection. It's very easy for a developer to forget releasing the resource, which is why it happens all the time. Let's see what this code would look like if we use the RAII pattern. In this example, we've created a class called database connection. In the constructor, we acquired the resource, which in this case is a database connection, and then in the destructor we release the resource, which in this case means closing the database connection. Then in main, we simply create an instance of database connection passing in the database name.
00:04:32.652 - 00:05:08.956, Speaker A: We then make sure there's a database connection and perform our database operations. Connection is a stack variable, so it will be deallocated at the end of the main function. When it's deallocated, its destructor is called and the database connection is closed. As you can see, this pattern leads to convenient and reliable resource management, cleaner and more readable code, and eliminates resource leaks. In fact, this pattern is so useful that Rust integrated it directly into the language so you don't have to remember to use the pattern. The compiler will simply do it for you by enforcing a set of rules known as the ownership rules. The rules are actually really simple.
00:05:08.956 - 00:05:57.312, Speaker A: The first one is that each value in rust has a variable that's called its owner. There can only be one owner of a value at a given time, and when that owner goes out of scope, the value is dropped. Here's how the database example would look like in Rust, we have a struct called database connection, which holds a connection object. When a new database connection instance is created, we acquire a database connection and store it inside the struct. In main, we can create a new instance of the database connection, struct, and pass in our database name, and then perform any database operations we want. Unlike the C example, there is no destructor which releases the database connection. Instead, the connection variable will go out of scope at the end of main, and the database connection instance will be dropped, and any values database connection is holding will also be dropped.
00:05:57.312 - 00:06:49.352, Speaker A: This just happens automatically for you, like magic. But in reality, the rust compiler is simply following the ownership rules, which, as you can see, leads to very simple and clean code that avoids resource leaks. Rust further builds on top of the ownership rules by combining them with the borrowing rules. The borrowing rules state that at any given time, you can either have one mutable reference or any number of immutable references, and references must always be valid. Going back to the rust example, you can see that we can create multiple immutable references without any problem. But if we introduce one mutable reference, we would get a compile time error because we're mixing immutable and mutable references, which is against the borrowing rules. Now, you might be thinking, why are these rules necessary? By enforcing that resources either have multiple readers or a single writer, rust prevents an entire class of bugs known as data races.
00:06:49.352 - 00:07:29.802, Speaker A: And by enforcing that references are valid, rust prevents null pointer dereferencing. Ownership and borrowing are concepts that many beginners and even intermediates get stuck on or don't have a full understanding of. That's why I always recommend doing exercises or projects focused on these two subjects in the Rust developer bootcamp, which will be released very soon. I've created specific exercises and exams for ownership and borrowing, but more on that later. Next, let's talk about a couple extremely useful features Russ took from functional languages like Haskell. The first one is algebraic data types. Algebraic data types, or ADTs, are a type system concept commonly found in functional languages.
00:07:29.802 - 00:08:07.506, Speaker A: They allow us to create composite types using some types and product types. Some types, also known as variant types, let us define a type that could be one of several variants. For example, we can define a shape type, which could either be a circle, rectangle, or triangle. Product types, on the other hand, are similar to structures in c. They allow us to bundle multiple types together. For example, here we have a person type composed of a string, an unsigned 32 bit integer, and a floating point number. ADTs are useful because they allow us to model complex data structures and enforce constraints on data at the type level, which can help catch errors at compile time.
00:08:07.506 - 00:08:32.986, Speaker A: Lets look at how ADts are implemented in Haskell. Here we have an employee data type. This is a sum type consisting of two variants, manager and worker. Each variant can hold different types and amounts of data. A manager has a name and a list of subordinates, while a worker has a name and a single manager. Heres the same example implemented in rust. In rust, adts are implemented through enums and structs.
00:08:32.986 - 00:09:16.410, Speaker A: Enums are some types and structs are product types of. In this example, employee is a sum type, so we're using an enum. While the concept of adts is similar between rust and Haskell, there are some differences. Rust integrates adts into an imperative programming style, unlike Haskell, which is purely functional. Also, rust combines adts with other language features like pattern matching, lifetimes and the borrow checker to ensure memory safety and data race prevention. I've mentioned pattern matching a few times in this video, and this is actually another great feature rust took from functional languages like Haskell. In this example, were using the match expression to pattern match on an instance of the employee enum, which allows us to handle each variant differently.
00:09:16.410 - 00:09:57.318, Speaker A: Pattern matching in rust also enforces exhaustiveness, which means all variants of an enum must be handled, preventing potential runtime errors. Next, lets talk about one of the pillars of object oriented programming polymorphism. Polymorphism is the ability of an object or function to take on multiple forms or behave differently based on the context in which it is used. Some languages implement polymorphism through inheritance, but rust takes a different approach. In rust, polymorphism is implemented with traits and generics. Traits define a set of functions and methods that types can implement similar to interfaces in other languages. In this example, we have a trait called shape with one method called area.
00:09:57.318 - 00:10:34.980, Speaker A: We can then implement the trait on the rectangle struct and the circle struct, which calculates area differently. Note that types can implement multiple traits and traits can have default implementations for functions and methods. Generics, on the other hand, enables us to write code that is abstracted over types, which leads to reusable and efficient code. For example, here we have a function called print area, which takes the generic argument shape. In rust, generics can be bound by traits. For example, in this case, the generic t can be any type that implements the shape trait. In main, we create an instance of rectangle and pass it to print area.
00:10:34.980 - 00:11:19.880, Speaker A: We then create an instance of circle and pass it to print area. Our function can accept both arguments because rectangle and circle implement the shape trait the trait system in rust has its roots in haskells type classes, which provide shared behaviors for types. But rust builds on top of the concept of type classes by incorporating ownership, borrowing, and lifetimes into the trait system, which are central to rusts. Memory safety guarantees rust also supports dynamic dispatch with trait objects. A trait object allows you to treat different types that implement the same trait as interchangeable. For example, here weve created a vector of shaped trait objects that stores a rectangle and circle. The trait system in Rust has several advantages over classical inheritance.
00:11:19.880 - 00:11:59.678, Speaker A: It allows for more flexible code design and composition. Multiple types can independently implement the same trait, enabling flexible composition without relying on strict inheritance hierarchies. Traits are also non invasive. They allow behavior to be added to types without modifying their original implementation or inheritance hierarchy. Traits also avoid the fragile base class problem, where modifications to a base class can unintentionally impact derived classes. Lastly, Rust traits system uses static dispatch by default, enabling efficient code generation. Next, let's talk about a feature Rust stole from JavaScript, the async await syntax for asynchronous programming.
00:11:59.678 - 00:12:46.582, Speaker A: Asynchronous programming is a programming paradigm that allows tasks to run independently and concurrently without blocking the execution of the main program. In JavaScript, promises provide a way to handle asynchronous operations. A promise is an object that wraps the result of an asynchronous operation, allowing you to attach callbacks to handle the success or failure of the operation. In this example, we have a function called getuserdata, which takes a user id inside the function. We use fetch to make an API call. Because this is an asynchronous operation, fetch will return a promise. We can call the then method on the promise and pass in a callback, which will be called if the operation succeeds, and we can call the catch method and pass in another callback, which will be called if the operation fails.
00:12:46.582 - 00:13:17.420, Speaker A: Now, this code looks pretty readable, but imagine if we made the example slightly more complex. Our function is now called get postdata. It takes a user id and a post id. What we want this function to return is the user data, the post data, and the comments on that post. Let's imagine that in order to do this, we had to make three API calls that were dependent on each other. First we have to get the user data, then we have to get the post data, and finally we have to get the post comments. Only then do we have all the data we need to return.
00:13:17.420 - 00:14:06.912, Speaker A: As you can see, using promises can lead to deeply nested code, which is not very readable. Let's see what this example would look like using the async Await syntax the Async Await syntax is a language feature that simplifies asynchronous programming by allowing developers to write asynchronous code that looks like synchronous code, which makes it a lot more readable. The first change we made is added the async keyword before our function definition. Then inside the function we use the await keyword before every asynchronous call, and for error handling we use a try catch block. As you can see, the code is a lot more readable, but there's nothing special going on here. In fact, Async Await is syntactic sugar for working with promises, rust adopted a similar approach to asynchronous programming with a slightly different syntax. Just like with JavaScript, the Async keyword is added before our function definition.
00:14:06.912 - 00:15:01.626, Speaker A: Inside the function, we add await to every asynchronous call, and we use the question mark operator to propagate errors instead of a try catch block. Just like with JavaScript, the async await syntax in Rust is syntactic sugar for working with futures, which are similar to promises in JavaScript. Now, even though the asyncaway syntax looks similar in JavaScript and Rust, there are some big differences. One difference is that rusts async await model incorporates the zero cost abstractions principle in Rust. Futures are designed to be lazy, meaning they don't start executing until explicitly pulled by awaiting them. This means futures can be scheduled, composed, and combined with other futures without incurring unnecessary overhead. Futures are designed this way because of Rust's general principle of being explicit, which means favoring clear and unambiguous code that requires developers to be explicit about their intentions.
00:15:01.626 - 00:15:42.510, Speaker A: In contrast, promises in JavaScript are eager, meaning that they start executing immediately upon creation. When a promise is created, it initiates the asynchronous operation right away, even if the promise is not awaited yet. This can result in potentially unnecessary work and resource utilization. Another difference is that JavaScript is single threaded, which means concurrent operations aren't truly happening in parallel. Instead, JavaScript uses a non blocking event loop which can handle multiple operations almost at the same time, giving the illusion of parallelism. Rust, on the other hand, offers true parallelism. It can run concurrent operations in parallel by utilizing multiple threads.
00:15:42.510 - 00:16:23.344, Speaker A: Next, lets talk about one of rusts most powerful features, macros. But before we dive into macros, we need to understand metaprogramming. Metaprogramming is a programming technique that allows a program to manipulate or generate code during compile time or runtime. Macros are a language feature that allow developers to define custom syntax and perform code generation or code transformation. They enable metaprogramming by providing a way to write code that generates or modifies other code during compilation. Here's an example of a declarative macro in rust called map, which is used for creating hash maps. Declarative macros are defined using the macro rules keyword.
00:16:23.344 - 00:17:07.140, Speaker A: These macros take code as input, match it against a set of patterns, and generate new code based on those patterns at compile time. The first pattern matches when the macro is invoked with two type expressions separated by a comma as arguments. If the code passed in matches this pattern, the macro will generate code that creates an empty hashmap with the specified key and value types. The second pattern matches when the macro is invoked with a comma separated list of key value pairs separated by an arrow. The asterisk symbol denotes repetition, allowing multiple key value pairs to be matched. This pattern is used to create a new hashmap and populate it with the specified key value pairs. Here's an example of how this macro can be used.
00:17:07.140 - 00:17:55.956, Speaker A: Instead of creating a hashmap manually, we can call the map macro and pass in the types for key and value pairs, and instead of calling the insert method to populate a hashmap, we can simply call the mapmacro and use the arrow syntax. With just a few lines of code, we've been able to extend the rust language with some new syntax. One cool thing about rust macros is that they're hygienic, which is a feature rust took from scheme. Hygienic macros is a concept that ensures the variables and identifiers used within a macro do not accidentally clash with the variables from the surrounding code. In this example, we have a greet macro. The macro has one pattern which matches against any expression and expands into code that prints a greeting using the provided name. Notice that the macro captures the provided name in a local variable.
00:17:55.956 - 00:18:43.258, Speaker A: In the main function, we define a name variable and then invoke the greet macro passing in the name variable. This example demonstrates the hygienic nature of macros. In rust, the variable name used within the macro doesnt clash with the variable name in the surrounding code, thanks to the automatic renaming and scoping mechanisms of the macro system. Even if we change the value of the name variable inside the macro, it will not affect the surrounding code. If we run the program, you can see that John is printed, which is the value of the name variable inside of main. Lastly, let's talk about a feature rust stole from the world's most popular web framework. Before we get to that, keep in mind that gaining a deep understanding of these incredible rust features and how to use them in real world applications takes a lot of practice.
00:18:43.258 - 00:19:32.302, Speaker A: That's why I created the Rust developer bootcamp, which I'll talk more about at the end of the video. In 2009, Ryan Dahl revolutionized JavaScript by introducing Node JS, a JavaScript runtime that allowed JavaScript to break beyond the confines of the browser. This led to an explosion of JavaScript based backend applications. Alongside node JS, Ryan also created node package manager, or NPM for short, giving developers a powerful tool to manage dependencies and share code within the node JS ecosystem. Shortly afterwards, nPMJs.com was created, serving as the central hub for hosting and discovering public packages. Rust took this idea and ran with it by creating cargo and crates IO cargo is Rusts official build system and package manager.
00:19:32.302 - 00:20:22.114, Speaker A: It handles many tasks such as building code, downloading and compiling libraries, and managing rust versions and configurations. These operations can be performed with simple CLI commands like cargo build, cargo test, and cargo run, similar to NPM commands like NPM install, NPM test, and NPM start. In node JS applications, dependencies are listed in a file called package JSON. Similarly, in rust, dependencies are listed in a file called cargo tomlike. In node, public dependencies are pulled from NPMJs.com, and in Rust, public dependencies are pulled from crates IO. Cargo and crates IO enable reliable dependency management, streamlined project building, integrated testing, and simple package distribution, which are features the systems programming space has lacked.
00:20:22.114 - 00:21:00.022, Speaker A: This makes development so much easier that it might be my favorite rust feature. All these features make rust the incredible language that it is, but understanding how each feature works together and how to use them in practice can be very difficult. That's why I created the Rust developer bootcamp. You guys have been emailing me and asking me to create a high quality, comprehensive rust learning program that goes far beyond my YouTube videos. And that's exactly what I've been working on for the past year. The Rust developer bootcamp is the all in one rust learning program I wish I had when I was first learning rust. I've included over a hundred videos covering anything you ever wanted to know about Rust.
00:21:00.022 - 00:21:20.590, Speaker A: I've also included coding exercises, exams, and real world projects to help you internalize the lessons. Now, the Rust developer bootcamp is launching very soon, so to get early access, head over to letsgetrusty.com bootcamp. With that said, I hope you enjoyed the video, and I'll see you in the next one.
