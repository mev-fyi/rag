00:00:00.560 - 00:00:28.300, Speaker A: Welcome back, Rust Gang. If you're new here, my name is Bogdan and this YouTube channel is all about the rust programming language. So if you want to see weekly rust videos, go ahead and hit the subscribe button. In the last video, we started chapter 13 of the rustling book by talking about closures. If you haven't seen that video, make sure to check it out. In this video, we're going to continue chapter 13 by talking about iterators. So with that, let's get rusty.
00:00:28.300 - 00:01:11.086, Speaker A: Before we jump into code, let's talk about what the iterator pattern is. The iterator pattern allows you to iterate over a sequence of elements regardless of how the elements are stored. For example, the elements could be stored in an array, but they could also be stored in a hash map or a graph or some custom data structure that you create. Iterators encapsulate the logic for iterating over these different data structures. Iterating over an array is simple. You start at index zero and you increment the index. But iterating over a map or a custom data structure is not as obvious.
00:01:11.086 - 00:01:43.222, Speaker A: So again, iterators will encapsulate the logic for iterating over these data structures. This allows you to iterate over various data structures in in a uniform way. So with that background, let's jump into some code. In the following example, we create a variable called v one, which is equal to a vector, and then we create a variable called v one. Underscore iter, which will be an iterator over the vector, and we can create this iterator by calling v one dot it. Er. Note that in rust, iterators are lazy.
00:01:43.222 - 00:02:33.020, Speaker A: So on line four, when we create an iterator, nothing special happens until we actually use the iterator. So let's use our iterator in a for loop. We'll type in for value in our v one iter, and then we'll print out the value. Let's go ahead and run our program, and you can see we got our vector values printed out. Now, the nice thing here is our for loop was able to use our iterator without any extra code, and that's because iterators are part of rust standard library. Now, in this example, we're using a vector, but again, iterators could be implemented for any data structure. And notice that with our for loop, we don't have any logic that specifies how to iterate over our sequence of elements, because that logic is encapsulated within the iterator.
00:02:33.020 - 00:03:10.020, Speaker A: Now let's talk about how iterators work. All iterators in Rust implement the iterator trait, which is defined in Rust's standard library, and it looks something like this. Now notice there's some new syntax here. We have a type called item, and then we use our item type inside our option return value. This is called an associated type, and we'll learn more about associated types in chapter 19. This code is saying that when implementing the iterator trait, you also have to define the item type, and that type is returned from our next method. As you can see, iterators are pretty simple.
00:03:10.020 - 00:03:57.278, Speaker A: There's only one method you have to implement which is the next method. All the other methods have default implementations. The next method returns the next item in the iteration wrapped in sum, and when we get to the end of the iteration, it returns none. Notice that we also need a mutable reference to self, and that's because calling next changes the internal state of the iterator used to track where it is. In the sequence below our iterator trait, we can define a test function to demonstrate how the next method works. Here we create a vector with three elements, and then we create this variable to store our iterator. And notice that the variable has to be immutable, because again we're going to call next and next needs a mutable reference to the iterator.
00:03:57.278 - 00:04:46.524, Speaker A: Then we have a few assert equals statements. When we call next for the first time, we expect to get back a reference to one inside of some. In the next call, we expect a reference to two, then a reference to three, and finally none, because we're at the end of our sequence. Note that our iterator returns immutable references. If we wanted mutable references instead of iter, we would type iter, underscore mute, and if we wanted own types, we would use into iter instead. Let's go ahead and run our test function, and you can see that it passes. Now, the iterator trait has various methods which have default implementations provided by the standard library.
00:04:46.524 - 00:05:33.768, Speaker A: There are two broad categories of methods, adapters which take in an iterator and return another iterator, and consumers which take in an iterator and return some other type, such as an integer collection or any other type. Here's an example. Using the sum method, we have a vector of three elements. Then we create an iterator, and then we call sum on our iterator. Sum will repeatedly call the next method to get each element in the sequence, and then add those elements up and return the sum in this case, we're storing our sum in a variable called total, and we're asserting that total is equal to six. So let's go ahead and run our test suite, and this time we have two passing tests. Next, let's look at adapter methods.
00:05:33.768 - 00:06:21.090, Speaker A: One such method is map, which takes in a closure and creates an iterator which calls the closure over each element in the sequence. Notice we get a warning here which states that map is unused because map returns an iterator. And remember, in rust, iterators are lazy. So this won't actually do anything until we use a consumer method. Let's fix this by using the collect consumer method, which will take our iterator and transform it into a collection. Then we'll assert that all the elements in our vector are incremented by one. Now let's go ahead and run our program.
00:06:21.090 - 00:06:58.826, Speaker A: And it didn't panic, which means that we got the correct vector. In this next example, we'll look at using iterators with closures that capture their environment. We have a shoe struct, which represents a single shoe, and the fields are size, which is the size of the shoe, and style for the style of the shoe underneath. We have a function called shoes and my size, which takes a vector of shoes, and a shoe size. The goal of this function is to filter the shoes vector to only shoes that match the specified shoe size. Let's look at the function signature we take in parameter called shoes, which is a vector of shoes. And notice this is not a reference.
00:06:58.826 - 00:07:23.766, Speaker A: So we're actually taking ownership of the vector. And then we take another parameter called shoe size, which is an integer. And finally we return a vector of shoes inside the function body. We call into iter on our shoes vector, which will create an iterator that takes ownership of our vector. Then we call the filter method, which accepts a closure which will be called for. Every element in our iterator. Filter creates another iterator.
00:07:23.766 - 00:08:03.314, Speaker A: If the closure passed into the filter returns true for a specific element, then that element will be included in the resulting iterator. However, if it returns false, then that element will not be included in the resulting iterator. Finally, we call collect, which will take the iterator returned from filter and transform it into a collection. In this case, our collection will be a vector of shoes. Now, going back to filter inside this closure, we check that the size of the current shoe is equal to the shoe size being passed into our function. This is an example of how closures capture their environment. Shoe size is not defined within the closure, but we still have access to it.
00:08:03.314 - 00:08:35.122, Speaker A: Underneath our function we have a test module with one test called the filters by size. Inside the test we create a variable called shoes, which is a vector of shoes. The first shoe is of size ten. Then we have a shoe of size 13 and another shoe of size ten. Next we call our shoes in my size function and pass it the shoes we just created and the size ten. And then we store that in a variable called in my size. Finally, we assert that in my size is a vector that only contains shoes of size ten.
00:08:35.122 - 00:09:28.228, Speaker A: Let's go ahead and run our test suite and our filters by size test is passing. Now that we've learned how to use iterators, in this final section we'll learn how to implement our own iterator. For demonstration purposes, our iterator is only ever going to count from one to five. First we'll create a struct to hold some values. In this case, our struct is named counter and has one field called count which is an integer. And then we're going to implement a constructor function called new which will construct a new counter and set count to zero. The count field will keep track of where we are in the process of iterating from one to five, and the field is private because we want the field only to be accessed by our implementation block, and because we have this new constructor which sets count equals to zero.
00:09:28.228 - 00:10:04.726, Speaker A: We're enforcing that every time a new counter is created, count gets initialized to zero. Next we'll implement the iterator trait for counter. Here we've specified our item associated type and set it equal to an unsigned 32 bit integer. Again, we'll learn more about associated types in chapter 19. But all we're saying here is that our iterator is going to return items of type unsigned 32 bit integer. Then we implement the next method. And remember, next is the only method we're required to implement.
00:10:04.726 - 00:10:52.298, Speaker A: Next takes immutable reference to self and returns an option enum which holds the item inside the method body. We check if self count is less than five, and if so we increment self dot count and then return it. Otherwise, if self dot count is equal or greater than five, then we return none because we're at the end of our iteration. Next we'll add a test function that uses our next method. Our function is called calling next. Directly inside we create a new counter instance and then call counter dot next six times. For the first five calls we expect to get a number sequence from one to five and on the 6th call we expect to get none because our sequence is over.
00:10:52.298 - 00:11:40.798, Speaker A: Let's go ahead and run our test, and you can see we have a passing test. Now, the standard library provides default implementations for a lot of other methods on our iterator, so let's write another test that takes advantage of those. Now this is an extremely contrived example, but let's go through it. We're creating a variable called sum, which is an integer, and it's equal to this expression here. First we're creating a new counter, and then we're calling the zip method on it. The zip iterator will take two iterators and zip them up into one iterator containing pairs of values. The first iterator will be the iterator, which the method is called on, and the second iterator is passed into the method.
00:11:40.798 - 00:12:11.568, Speaker A: Here we're creating a new counter and calling the skip method, which is an adapter method, meaning it will return another iterator. Skip will create an iterator that skips the first n elements, n being the number passed in. So in this case, this iterator will skip the first element. Now zip will return an iterator. So then on that iterator we call map. Map takes a closure, which it will call for each item in the iterator. In this case, each item has a pair of values because we just called the zip method.
00:12:11.568 - 00:12:39.352, Speaker A: In our closure, we'll take these two items and multiply them. Then we call the filter method and filter to only the items that are divisible by three. And finally we call the sum consumer method, which will take all the items in our iterator and calculate the sum. And after all of that, the sum should be equal to 18. Let's run our test suite to see if this is true. And there you go, we have two passing tests. Now.
00:12:39.352 - 00:13:14.120, Speaker A: Again, this is an extremely contrived example, but it just goes to show that simply implementing the next method gives us access to all these other methods that have default implementations. That's it for part two of chapter 13. If you enjoyed this video, make sure to give that like button a little poke. In the next video, we're going to be using our knowledge of iterators to refactor the CLI program we made in chapter twelve. So if you want to be notified when that video comes out, and all the future videos after that, make sure to hit subscribe. And with that I'll see you in the next one.
