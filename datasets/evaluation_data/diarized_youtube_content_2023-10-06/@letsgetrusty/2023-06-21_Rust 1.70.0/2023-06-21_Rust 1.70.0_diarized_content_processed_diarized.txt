00:00:00.320 - 00:00:35.472, Speaker A: In this video well go over the latest release of rust version 170.0. Specifically, well cover the five big updates which are cargo sparse protocol being enabled by default once cell and once lock being stabilized. The newly stabilized is terminal trait named levels of debug information and enforced stability in the test CLI. Before that, make sure to get your free rust bootcamp training by heading over to letsgetrusty.com boot camp. And now lets get rusty. First we have cargo sparse protocol being enabled by default for cargo to determine which crates exist on crates IO.
00:00:35.472 - 00:01:10.414, Speaker A: It used to download an index from a GitHub repo which lists all version of all crates. This took a long time and only got worse as the index grew. In rust version 168.0 a new protocol was introduced behind a feature flag which fetches files from the index directly over HTTPs. Additionally, Cargo would only download information about the specific dependencies in your project, which provides a significant performance improvement. This protocol is now enabled by default, which means free performance wins for us. The second update in this release is once cell and once lock being stabilized in rust.
00:01:10.414 - 00:01:47.374, Speaker A: The cell smart pointer is part of the standard library and is used to provide interior mutability. This means you can mutate data even if you have an immutable reference to it, which would normally be disallowed by Rust's ownership and borrowing rules. In this example, we define a counter struct which has a count field of type cell. The counter struct has methods to increment the count and retrieve its value. By using cell, we can mutate the count in a safe manner, even though the counter itself is immutable. For example, in main, we can create an immutable instance of counter and call the increment method to update the count. Interior mutability is useful for several reasons.
00:01:47.374 - 00:02:40.766, Speaker A: For example, in scenarios where you need to share mutable data across different components, functions, or threads, or when you need to mutate data temporarily, even if the overall design emphasizes immutability. Once cell allows interior immutability similar to cell, however, it ensures that initialization only happens once, which is especially useful for lazy initialization, and once lock is the thread safe version of once cell. In this example, we define a database connection structural to simulate an expensive initialization operation. The initializeconnect function represents the initialization logic that creates and returns a new instance of database connection. In a real world scenario, this could involve establishing a database connection. We then create a static variable called database of type one SLOC holding a database connection. In main, we call get or init on database, passing the initializeconnection function as the initializer.
00:02:40.766 - 00:03:28.032, Speaker A: If the connection has already been initialized, it returns a reference to the existing value otherwise, it calls the initializer. This lazy initialization allows you to defer the expensive initialization of database connection until it's actually needed. The next update in this release is the newly stabilized isterminal trait. This trait has one single method called isterminal, which is used to determine if a given file descriptor or handle represents a terminal. This allows programs to determine if they are being run by a script or by a user. In this simple example, we are adding color to a program's output if the output stream is a terminal. The next update in this release is named levels for debug information the debug information compiler option controls the amount of debug information generated during the compilation process.
00:03:28.032 - 00:04:35.294, Speaker A: Previously, only numbers were supported, zero for no metadata about the source code, variables, types, or other debug related information in the binary, which results in smaller binary sizes one for minimal debug information such as file and line numbers, allowing you to see the source code, file and line number where the issue occurred during debugging and two for full debug information, which means you'd be able to inspect variables, types, and other debug related data much more easily when debugging. As of this release, these debug levels can be set by name, none, limited, or full, respectively. Also, two new levels, line tables only and line directives only, were added for more granular control. The fifth major update in this release is enforced stability in the cargo test CLI. Previously, when running cargo test, you could specify unstable options even when using the stable version of the rust compiler, which is not intended. This led to unstable options being used without direct user knowledge. For example, the unstable format JSON option was used in Intellij, Rust and other IDE plugins.
00:04:35.294 - 00:04:49.150, Speaker A: As of this release, unstable options are only allowed in nightly builds as intended. Before you go, make sure to get your free rust bootcamp training by heading over to letsgetrusty.com bootcamp like comment, subscribe and remember to stay rusty.
