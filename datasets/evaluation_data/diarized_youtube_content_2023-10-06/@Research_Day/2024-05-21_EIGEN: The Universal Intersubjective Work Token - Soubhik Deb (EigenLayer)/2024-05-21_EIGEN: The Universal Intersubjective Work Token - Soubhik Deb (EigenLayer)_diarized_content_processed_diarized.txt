00:00:07.240 - 00:01:00.702, Speaker A: Hi everyone, I'm Shabik from Eigenlabs. So recently we put out our token white paper where we talked about intersubjectively attributable false and how we can use Eigen token for resolving such faults in digital tasks. So today's talk from me will be on that topic. So Eigen layer's broad vision is to help in assuring open innovation in the digital space in a very scalable manner. So by scalability, what we mean is that not everyone has to do actual work in a digital task, but anyone should be able to monitor and resolve faults that can happen in the execution of the task. So some of the previous talks have already touched those things, and this approach is quite similar to the requirement that you need in the physical commons also. So something similar we also want in the digital commons.
00:01:00.702 - 00:02:03.120, Speaker A: So first, so what does it mean to be intersubjectively attributable false? To understand what intersubjectivity means, let's first go through a short explanation on the taxonomy of the digital tasks. First and simplest to explain are the objectively attributable faults. So such faults can be proven to be, can be can be accounted or attributed purely in terms of mathematics and cryptography. So examples are, for example, EVM code execution or double signing. However, there is a very broad class of tasks like data availability, where faults are not provable on chain, inside a virtual machine or in a smart contract, but is observable to any observer outside the chain. And there is a wide agreement among all the honest observer that such a fault has happened. So more such examples are, that is, one BTC is equal to one USDC or not.
00:02:03.120 - 00:03:03.734, Speaker A: So any rational, reasonable observer, an honest observer from outside can say that that's not true. Similarly, is AI inference correct, we within a margin or not? So any honest observer from outside can just run the AI inference engine with the same hardware, with the same random seed, and can check, that is, the inference output within that margin or not. And this can be done outside the chain. A common feature of both these categories is that the faults are widely agreeable among the observers. On the other hand, subjective faults have no guaranteed agreement among observers. So examples for such subjective questions will be is Paris the most beautiful city? Or what will be the price of a NFT such as bad kids NFT in one year? If you ask this question, you will have a wide variation in the opinion from the people whom you are asking. So with eigenstate staking what? Oh, this is the slide.
00:03:03.734 - 00:04:25.504, Speaker A: So with eigenstaking what we are trying to achieve is that we are targeting the intersubjectively attributable faults, while also ensuring that the execution speed is during the happy path is automated as possible, in contrast to having any manual human intervention in the happy path. So before I present our solution, let us understand the taxonomy of the current mechanisms that are being used for resolving inter subjectively attributable faults. The first one is majority voting, which Connor touched in his talk. So basically, in the majority voting, the stake of those operators whose response diverges a lot from the majority of the responses by more than a certain margin, they get slashed. The second type of solutions that are typically used is a trusted committee who who judges whether the response from the operators are on are true or not based on their own opinion, and those operators whose response are judged to be not true, they get slashed by the committee. Naturally, both these solutions are vulnerable to the tyranny of majority. In the first case, the tyranny of majority of the operators.
00:04:25.504 - 00:05:20.044, Speaker A: In the second case, there is a tyranny of majority of the committee members. Now, the third one is the slashing by forking. This is normally used in the context of proof of stake chains like Ethereum, where social consensus are in proof of work chains. Also where social consensus is used to determine the canonical fork of the chain for resolving the inter subjective fault of no chain growth. So for example, in Ethereum, if there is an attack on the chain, go, you use inactivity leak to slash these people. So using social consensus consensus to resolve intersubjective fall amounts to giving a free choice to the users in this unlimited and unsized group of ecosystem stakeholders in the social consensus. And this solves and mitigates the tyranny of majority problem.
00:05:20.044 - 00:06:51.274, Speaker A: So currently, slashing by forking is used only in the context of digital tasks pertaining to chain consensus. So given that the slashing by forking is not vulnerable to terrain of majority, a natural question would be can it be extended to any inter subjectively attributable fault or not? Second question, does social consensus mean users have to meet in person or in a discord channel to identify the faulty people? Because that is, that is kind of undesirable as it's leads to a lot of manual process in resolving this process. So instead it will be much, it will be very ideal if the faults are very self evident to the observers, to the users in the social consensus. So in the next few slides, I'll go over the core ideas that makes this possible with Eigen. So the first core idea is the concept of setup phase and execution phase. So the setup phase for any inter subjective system requires establishing the rules of execution that will be executed during the happy path and also codifying the set of rules that will be used for that is the rules of coordination that will be used for bringing an agreement among the observers about any fault in the execution of the task. Once the setup phase is over, it is the execution phase where the pre agreed rules from the setup phase are executed.
00:06:51.274 - 00:08:02.040, Speaker A: These rules must be such that the faults are self evident and self verifiable by any observer in the social consensus, such that it precludes meeting in person or in a discord channel. An example of a set of phase is the ratification of us constitution back when the nation was founded and now in the execution phase. Any law passed has to be compliant with the constitution. Similarly, an example of setup is in the context of blockchain is the longest chain consensus rule that was adopted at the genesis of bitcoin and now which is then used for determining the latest block in bitcoin. There are many more such examples in the context of blockchain, such as weak subjectivity and roll ups, standard roll ups, or the sovereign roll ups. The second core idea is slashing. So in slashing, any adversarial participant in a proof of stake network can be punished for their misbehavior during the execution phase by taking away their stake.
00:08:02.040 - 00:08:58.041, Speaker A: This lends to a crypto economic benefit to any POS network in the form of karma. To the best of our knowledge, the benefits of slashing were first explored by Vitalik in the 2014 article, and Cosmos built the first functioning implementation of slashing, and Ethereum 2.0 has also incorporated slashing in their POS protocol for double signing and for any attack on the chain growth in the form of inactivity leak. The third core idea is token forking. A core observation in tokenomics is that the value of a token arises from how much the social consensus of that token considers it to be valuable. We can use this fact to fork just the token without forking the chain state to induce crypto economic penalties on the malicious stakers. Consider this simple figure where Eigen is being used for staking in Eigen layer.
00:08:58.041 - 00:10:12.844, Speaker A: If majority of the eigenstakers were to turn malicious and cause an inter subjectively attributable fault in one of the AVss, then a new fork of the eigen we represent that in this figure with Eigen, Tilde will be spawned, will be birthed, where the malicious stakers will be penalized by restricting them from prevent from being able to redeem to equivalent the tokens from this new fork. As the new fork comes to be considered as canonical, if the inter subjective fault is really genuine, it will come to be considered as canonical by the social consensus of the token. And the malicious stakers who were prevented from redeeming tokens from this new fork will end up being penalized because their value goes down to zero as the other fork go. The value valuation in the other the original fork goes to zero. A core advantage by having eigens social consensus mediate on resolving this inter subjectively attributed fault in avss is that now it does not overload ethereum social consensus anymore. Our approach to token forking in eigen builds upon some major prior work that were done in the field. So some of the original work was done in the context of futarchy and truth coin.
00:10:12.844 - 00:11:17.224, Speaker A: And based upon that, Vitalik also published a series of blog posts that explored the idea of forking and his game theoretic implications. To our best of knowledge, Auger built upon all this previous series of work for the implementation of toking working in their wrap token. However, Auger's implementation had three big shortcomings. So first one is that augur was specialized in measuring profit from corruption for only prediction markets, so it was not generalizable beyond the prediction markets. The second shortcoming is that the every holder of the wrap token, even though they might not be actively participating in resolving faults in the prediction market, had to be aware of the folks in the wrap token. Third is that anyone can build parasitic prediction markets without being accounted in the measurement of the crypto economic security of auger. So with Eigen we get four core features, namely universality, isolation, metering, and compensation.
00:11:17.224 - 00:12:13.014, Speaker A: That resolves these shortcomings. So next, we'll go over them, go over these four features one by one. So the first core feature is the universality. So in contrast to Auger, the setup phase of eigen stipulates that Eigen can be universally used to resolve any inter subjectively attributable fault, and not just, and it's not just limited to prediction markets. Second, any AV's who wants to use the crypto economic benefits of Eigen must encode their rules of coordination that they have agreed in their respective setup phase. So these AV's specific rules, such as the slashing conditions, are akin to amendments to the meta setup phase of the eigen. Third, this slashing rules of the AVSs must ensure that any inter subjectively attributable fault in that AV's should be self verifiable beyond a reasonable doubt.
00:12:13.014 - 00:13:03.854, Speaker A: The second core feature of Eigen is isolation. So to appreciate this feature, consider this design where any fork in the token would require defi markets to be aware of the fork. And now the token is not usable for going into, say, long term defi positions, or say you want to take a vacation for one year. Now you have to be you like if there is a fork in this intermitting intervening period, then you lose those tokens. So it's a very bad design. So to avoid this undesirable consequence, Eigen has a two token model where the token bygon is used for staking and can be subjected to forking. On the other hand, any holder of Eigen who is using this token for defi or any non staking application can remain unaware of the folks in the bygone.
00:13:03.854 - 00:13:30.426, Speaker A: So let us dig deeper into how this isolation is being achieved in Eigen. So first we focus on 1st. 1st we focus on yeah, I think it's. Yeah, this will be messed up. So I'll try my best to explain. Yeah, so suppose. So we'll first talk about the wrapping and unwrapping.
00:13:30.426 - 00:14:18.354, Speaker A: And this will give this will illustrate what is the relationship between Eigen and big. So suppose any user holds ten bygone and it's not using this bygone for staking. So now it can instantly wrap or convert it to get ten eigen. On the other hand, suppose a user is holding ten eigen and it is not locked in some non sticking application. The user can then instantly unwrap to get ten bygone. So basically what it's saying is that if you have one eigenvalue that is backed by one bygan that is currently locked with the Eigen contract. So by the way, both Eigen and big n are ERC 20 contracts with some additional functionalities.
00:14:18.354 - 00:15:29.638, Speaker A: Now suppose there is a fork in big in order to penalize some malicious big and staker for some inter subjectively attributable fault. We represent this new fork with bygone Tilde here. Now, the redemption clause for any bygone staker who had delegated to a non. The redemption clause for any bygone sticker will be something like that. That if the bygone sticker had delegated to a non malicious operator, it will be able to redeem an equivalent number of bygone tilde tokens within a fixed window, while also retaining their bygone tokens. We call this window as the redemption period in our white paper, on the other hand, any bygone user will have the right to redeem an equivalent number of bygone tilde tokens at any time, while also retaining the right to unwrap to the bygone tokens. So this property results in this, in this, in this result that the value of one by one eigen is backed by the summation of value of one big and the value of one bigand tilde.
00:15:29.638 - 00:16:22.880, Speaker A: So what? So if you, if you assume that there is a clean inter subjectively attributable fork happens, then the bigand tilde will get all the value. So that will be backing all the one the eigen eigen. The one eigenvalue. If, say, the inter subject attributed fault was malicious, the fault, there was no fault, but it was a malicious challenge, then the bygone will still be considered as canonical, it will still retain all the value, and it will be backing the eigen. The third core feature is the metering of the social cost of resolving any challenge. So whenever there is an inter subjectively attributable challenge that is being raised, then there is a cost to the social consensus to resolve that fault, because they have to decide what is the canonical one. So we need to measure this social cost because people can raise vacuous challenges also.
00:16:22.880 - 00:17:11.593, Speaker A: So the first cost is that to raise a challenge, you need to put a bond in bygone denomination. So this is necessary in order to cover the social cost of rejecting a malicious evacuous challenge. The second one, a minimum amount of bygone stake, has to be classified as a malicious when you raise the challenge. So in the new fork, you have to state that, okay, this much, at least this much amount of bygone stake is malicious. So this is necessary in order to cover the cost of switching to the new fork in case of a genuine challenge. The fourth core feature is compensation. To appreciate it, we need to go through a short explanation of crypto economic security.
00:17:11.593 - 00:18:08.444, Speaker A: So, the traditional definition of crypto economic security just requires that the maximum profit that is extractable from attacking a system has to be less than the cost of corrupting the system. So there are three major problems with this definition. First one is that there is no way to measure the profit from corruption. The second one is that an adversary can engage in parasitic behavior outside the system's locus of measurement of the profit from corruption. The third one is that the harmed user does not get compensated for the value lost due to, due to the attack. So in the stake sure paper, we introduced a stronger definition of crypto security with better guarantees, namely, any harmed user should be compensated a pre specified value in the event of an attack on the user. So with Eigen, we guarantee this strong cryptoeconomic security to achieve this feature of compensation.
00:18:08.444 - 00:18:48.160, Speaker A: So to explain this feature of compensation, we will illustrate a simple example here. So for this simple example, we'll make some assumptions for simplicity. So here all operators have equal stick. We assume that. So second assumption is that each of this operator is opted into three avss, and operators four and five behave maliciously and succeed. Say it succeeds in harming AV's the first AV's the AV's one. Now, what the protocol dictates is that as part of slashing by forking, operators four and five will be slashed as part of the token forking.
00:18:48.160 - 00:19:37.620, Speaker A: So all of their stake will be slashed. So it's just not a simple small part, but all of their stake will be slashed. Now, out of the slash stake, a fraction of that stake will be burned. So this is the burn stake that is done in order to mitigate the problem of griefing. The remaining stake gets redistributed to each of the AVSs to which the operators had opted into. So in summary, the burning protects against griefing attack by just raising malicious challenges, while redistributing is used for compensating the harm parties. So with eigenstaking, now the Avss can have a mix and match of quorums.
00:19:37.620 - 00:20:40.784, Speaker A: So with ETH restaking Eigen layer enabled the state, the ETH that was staked into the ethereum's consensus to be used for resolving objectively attributable faults. So with eigenstaking, Eigen can be used for resolving intersubjective faults in avss. So this will be especially helpful during the bootstrapping phase of the AVSs when they want to want to tap into the pool security of the ETH and Eigen AVSs can also choose to have their own token quorum if they want additional security and additional customizability. So. So now what? All you can build with Eigen. So any service that involves writing complex dispute resolution contracts can just accelerate their development phase by tapping into Eigen as part of their MVP. Second, any service where the faults are only observable from outside, but cannot be provable on chain in a smart contract can readily use Eigen for resolving those faults.
00:20:40.784 - 00:20:50.964, Speaker A: So yeah, that's all my talk is. If you have any cool ideas about Avss that you can build with Eigen, I'm happy to chat with you. Thank you.
