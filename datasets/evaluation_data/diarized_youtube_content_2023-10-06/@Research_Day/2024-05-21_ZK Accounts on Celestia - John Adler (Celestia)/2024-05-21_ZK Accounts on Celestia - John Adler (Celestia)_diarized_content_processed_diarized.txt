00:00:06.960 - 00:00:25.916, Speaker A: Hi, everyone. I also, before I begin, I want to say that I actually lost my classes last week, which means I'm basically blind. If you see me kind of squinting, it's because I can't actually see. I can't actually see anything that's on the computer. Ok, so today I'm going to talk about ZK accounts. Name subject to change. Alan Celestia.
00:00:25.916 - 00:01:10.852, Speaker A: I will get to that name subject exchange part in a few slides. Several slides. Ok, so I'll start by kind of describing a way of looking at blockchains. We all know what blockchains are, but to kind of make sure that we all kind of start on the same direction of looking at blockchains, or kind of start by describing them as a timestamping server. Right, which is where, if you have some transactions, how do you know which transactions are valid or not? Enter blockchains, kind of how Sazoshi described in the bitcoin design paper. If you have some sort of total ordering of the transactions, then you can say the one that came. If there's conflicting transactions, the one that came first is the valid one.
00:01:10.852 - 00:02:10.276, Speaker A: The ones that came later can be ignored. This is kind of the central design principle of celestia, formerly known as lazy Ledger, which is that you don't actually need to execute all the transactions, you just need a total ordering of them. You can ignore all the ones that are conflicting that come later, but there's kind of a thing that's missing here, which is that this kind of describes a total ordering of transactions and how to determine which transactions are valid with respect to all the transactions. But it doesn't tell you which transactions, or it doesn't tell you how transactions can be valid themselves, or how transactions can be valid with respect to the state of the blockchain. That, of course, wasn't described really much in the bitcoin design paper, but it's of kind of critical importance to blockchains nowadays. So we're going to do a little quiz, which is chat. Can you tell me what makes transactions valid? Ethereum.
00:02:10.276 - 00:02:34.060, Speaker A: We'll start with a simple one. Feel free to shout out some things that make a transaction valid or conditions for transaction validity. Enough gas. No double spending. Well, Ethereum, okay, how would you do? No double spending on Ethereum. No taking account below zero. No taking account below zero.
00:02:34.060 - 00:02:52.180, Speaker A: Okay, so that's like enough fees the nonsense to increment. Okay, so that's how you avoid double spending on Ethereum. Okay, so that's good. Thank you, Chad. So I actually can't see because this thing is so small. Let's see what I wrote. Okay, so yeah, the transaction has to be well formed.
00:02:52.180 - 00:03:33.174, Speaker A: Of course. It can't be, you know, can't be complete garbage. It needs to have sufficient funds to pay for the gas fees or whatever, and, you know, send ether to the contract. Whatever else the nonce needs to be correct, needs to increment properly. And you also need a valid digital signature. Okay, we'll do a harder one now, which is chat. Can you tell me what makes a bitcoin transaction valid? Okay, so notable spending of utxos that needs to have a valid signature.
00:03:33.174 - 00:04:03.704, Speaker A: That may not always be the case, but. Okay, who else or what else script needs to verify? Okay, there we go. Someone got it. So the transaction first obviously needs to be well formed. It needs to have sufficient funds to pay. To pay not for gas, but to pay the transaction fees. And you have to make sure that the sum of the outputs must be at most the sum of the inputs.
00:04:03.704 - 00:05:02.296, Speaker A: Is it actually true for all bitcoin transactions? I don't hear anyone answering, so I'm going to say the answer is no, because the coin based transaction can actually create bitcoin out of thin air, obviously constraint. And then the last one is the script must evaluate the true. Technically, if you don't use a script, if you use like the old style bitcoin, I guess spend directly to a pub key, then you're in a signature. But for the more advanced ones it would be the script needs to evaluate to true. And we're going to talk a lot about this last thing here, because this thing is not a thing that exists on Ethereum. This is the thing that is very different than what Ethereum has. So what is, what are the script in bitcoin land? It's essentially an implementation of a predicate, where a predicate, you can think of it like a program.
00:05:02.296 - 00:05:30.124, Speaker A: It's not exactly a program in the sense that it has certain constraints, things like. It must be monotonically progressing. There's no loops, things like that. But if you think of it like a program, other than those constraints, it has byte code, it executes execute just like a vm would. Then there's a pretty good approximation. So it operates over some input. We'll get back to this input in a couple slides, because it's actually fairly subtle.
00:05:30.124 - 00:05:59.164, Speaker A: And it'll output either true or false. So it won't output a string, it won't output some number. It will output either true or false. Zero, one. That's it. Some Boolean and generally, in the case of blockchain, these predicates you want them to evaluate to true, they're approximately stateless in the sense that the output of a predicate should depend only on the predicate bytecode itself. And whatever it gets gets fed in as input.
00:05:59.164 - 00:06:38.594, Speaker A: Which if the only thing is getting fed in as input is stateless, then the predicate will be stateless, and thus its validity will be entirely stateless, entirely deterministic. But if you feed it in something that's not stateless, that's stateful. If you design a protocol that way, which, depending on how your protocol is constrained, is a possibility, has not entirely stateless. But generally you want to tend your predicates to be as stateless as possible. One important thing about predicates is that they have monotonic validity, and thus you only have to verify them once. Now you might say, well, I mean, obviously I only have to verify a transaction once, right? I see a new block, I verify it. I only verify it once.
00:06:38.594 - 00:07:36.840, Speaker A: So why is this important? Because transactions don't just exist in blocks, they also exist in mempools. And this whole thing that I'm talking about is transaction validity is important from the perspective of a mempool. You don't want the mempool to be a denial of service vector, where, for instance, a transaction may need to be verified a million times by every full node, and then end up just getting evicted from the mempool because it becomes invalid later. Right? So you want this notion of monotonic validity. You want to verify predicate only once, so that regardless of if you verify in the mempool or in a block, you've only verified it once. Technically, if you constant upper bound this, it doesn't have to go once, it could be some constant, but basically you want to upper bound this so that you don't end up with a denial of service vector again. And this is from the perspective of a mempool exists, and then from an implementation detail, predicates can be attached somewhere in a transaction for bitcoin, they're attached to inputs.
00:07:36.840 - 00:08:50.714, Speaker A: You could design a scheme where they're attached in other places too, but regardless. So why predicates? Why are they nice things that to have, that ethereum doesn't have? Bitcoin does have, other protocols have predicates, why are they nice to have, they actually allow the validity of a transaction, not necessarily its effects in the sense of, like I said, transaction. And then some dextrade will occur, but the entire validity of a transaction to be programmed by the user, as opposed to being a simple do you have enough gas? Which is very boring, that doesn't allow any programmability, and this allows you to. Without having to worry about how much gas you're using, without having to worry about variability in gas, without having to worry about transaction reverting, and thus without wasting block space or gas space. You can have things like native multisigs, you can have things like native nexus, things like this that operate entirely in predicate land. And this is kind of just the tip of the iceberg. You can have fairly complex things that operate entirely in the space of transaction validity that never get into running some vm that may revert later.
00:08:50.714 - 00:09:26.374, Speaker A: Okay, so what are the inputs? I said I'll revisit this. Because what you feed in as inputs to the predicate can kind of determine how useful it can be and how stateless or stateful it can be. So there's kind of two classes of inputs. One of them is unauthenticated. This one, the user just provides them. For instance, if your predicate checks that a digital signature matches some hard coded pub key, then the digital signature is provided as unauthenticated input. The user is just literally going to pass a signature.
00:09:26.374 - 00:10:05.034, Speaker A: The state machine of the blockchain makes no effort whatsoever to authenticate it. It's the script itself that determines whether or not the signature is valid. The other class of inputs are authenticated, and these are actually provided by the state machine. In other words, like the consensus rules in the case of bitcoin, or bitcoin in the case of ethereum, it's ethereum is provided by the state machine itself. So bitcoin has a whole bunch of the bitcoin script has a whole bunch of opcodes. Most of them operate either completely purely arithmetic or whatever. A few of them operate on fetching information from the stack, which is the unauthenticated inputs.
00:10:05.034 - 00:10:52.882, Speaker A: And some of them operate on the authenticated inputs. Chad, can you tell me if you know which opcodes in bitcoin operate on the authenticated inputs? Okay, no one knows, but I mean, I wouldn't know myself, but I had to look it up. So I'm kind of cheating here. But basically, out of all the opcodes that bitcoin has, unless I'm mistaken, there's only two of them that operate on authenticated inputs. One of them is, I think, op check time lock verify, and the other one is op check sequence verify. And there's only two of them out of all the opcodes on bitcoin. And those ones basically have the virtual machine pass in the bitcoin state machine pass in to the bitcoin script VM in an authenticated way.
00:10:52.882 - 00:11:59.054, Speaker A: In other words, where these inputs will be trusted as being correct fields from the transaction, as opposed to just something that the user provides, they're actually, fields from the transactions are put into the bitcoin virtual machine as it's executing. So that's an example of things that are interesting, that if you allow expressivity in these authenticated inputs, you can start doing very interesting things. And bitcoin only allows you to do two things, and both of the things are just time locks. So that's not super expensive. But you could imagine that you could do things like pass in other fields in the transaction, or potentially you can pass in, if you constrain it in a certain way, that the predicate is still potentially kind of stateless. Okay, I realize I'm actually kind of running short on time, but let's keep going. So what's an application of predicates in the context of celestia? One of them is you could have predicates to help with denial of service resistance, or rather improve denial of service resistance.
00:11:59.054 - 00:12:59.608, Speaker A: Okay, so one problem with celestia is the one potential, not vulnerability, but one potential method of some griefing vector is what is called the woods attack. I won't say the origin, origin of the name, but I'll let you guess. So the way a woods attack works is basically that an attacker or an adversary will essentially spam the celestial chain with a bunch of blobs that are invalid to the roll ups that will process them. So if we go back to the very first slide where we say, okay, the first transaction is valid, the rest are just ignored. Yes, that's true, but in order to ignore them, you still have to at least do some light processing on them. And this light processing on them is not free. So the way the wizard works is you basically just spam a whole bunch of blobs.
00:12:59.608 - 00:13:44.784, Speaker A: Sure, all of them. Potentially all of them are invalid, but it's still going to consume some resources on the roll up that still has to process them. But what happens if you have the ability to limit from a transaction validity perspective? In other words, is it even included on celestia or not? What happens if you had the ability to actually restrict this, to constrain this? So here's a sketch. The protocol. It's not a specification or anything, it's just a sketch of how such a protocol could look. Imagine you have a 32 byte namespace, which is where the blobs would be posted to some identifier for groupings of blobs. You say in the sketch of the protocol that the namespace is 32 bytes is the hash or the predicate bytecode.
00:13:44.784 - 00:14:23.356, Speaker A: You can provide the predicate bytecode either in the transaction itself, every time. This is how bitcoin does it. If you want to do something more stateful, you could also first initialize the predicate bytecode and then save it in the celestial state. And then you only need to provide it once ever. And then the predicate, as part of its logic can enforce things like only one transaction is allowed in that namespace, or can enforce that the only people that are allowed to post in this namespace have particular pub keys. Or it could be like a multisig whatever. It could be a sequencer.
00:14:23.356 - 00:15:38.574, Speaker A: You could have some logic in the predicate that also allows for rotation, so you can move it to a different namespace with a different set of pub keys, things like this. So this would essentially allow you to do with no, like no, no need for celestia to specifically support certain constraints, some certain specific constraints. Rather, the user programs certain constraints on the fly with no enshrinement from celestia that basically says, you know, whatever constraints they want. Right? And this can completely eliminate the wits attack and as inputs for the sketch, it would take in, you know, unauthenticated signatures. So it's a very simple, very simple scheme. Okay, now what's the problem with this? The problem is that now you've introduced smart contracts to celestia, which is kind of not something you want to do, because the point of celestia or other data availability layers is to be not have execution, and therefore not to have this complex virtual machine, not to have a complex state, et cetera. And once you start introducing some virtual machine to verify predicates, then where'd you end? You just end up having another evM.
00:15:38.574 - 00:16:09.104, Speaker A: Ok, so enter ZK accounts. They also have different names. There's things like snark accounts, smart accounts, things like that. The name has not been decided on. The one thing that is for sure, definitely do not call them snacks. That's the one thing you shouldn't do. Okay, so what's the idea of snark accounts or ZK accounts? It's basically saying, take everything that I said earlier about the predicate, how it can constrain transaction validity.
00:16:09.104 - 00:17:22.266, Speaker A: And instead of verifying opcodes in the actual state machine of whatever layer one you happen to be, just put that all into ZK land and the only thing the base layer does is verify ZK proof. This allows you to essentially hoist all the complexity of a specific virtual machine, and it allows you to have multiple virtual machines that are user defined. Like, the user is actually not just defining the predicate, but they're defining the virtual machine itself. And then you can just hoist it all into ZK land. And therefore this requires only one change, basically, to Celestia, which is, well, verify ZK proofs. So as inputs to verify a proof, you could pass in things like the hash of the predicate and the inputs of the predicate, and then verify that proof and the predicate itself, the predicate bytecode, you never really need to reveal it. You can just put entirely as private inputs in the proof, and then the proof only output a boolean zero, one.
00:17:22.266 - 00:18:02.724, Speaker A: And then you just have the jState machine basically determine transaction validity based on that. Okay, so next. So what's another application of this? Not just of, not just of ZK accounts, but predators in general, but with ZK accounts, it means you can get all this without needing complex data machines. One of them, you can have a trustless two way bridge with ZK rollups, or rollups in general, but ZK rollups are easier. So what's the problem? If you don't have some virtual machine in the base layer, you can't do a smart contract roll up. You can't have a two way bridge. So what you do is you actually have a.
00:18:02.724 - 00:18:25.248, Speaker A: Oh, sorry. You could add a virtual machine, but then your data availability layer becomes an execution layer. Not good. So, but what do we want? We want a settlement layer without execution. And how do we do it? Well, we do it with verification instead of execution. So watch the sketch of a protocol that does this. Imagine you have a new account type.
00:18:25.248 - 00:18:54.840, Speaker A: It's a ZK account. The account can keep track of some off chain state, like the state route of a ZK rollup. And then proofs allow you to, uh, proofs allow you to update this state. Right. Uh, you know, as long as the proof is valid, the new state is valid. Importantly, part of this state root and part of the state includes deposits into the ZK roll up and withdrawals from the ZK roll up. Right.
00:18:54.840 - 00:19:50.058, Speaker A: Uh, and therefore this allows you to have essentially a trustless two way bridge between celestial and the ZK roll up, where a lot of this logic is where all of the logic is verified in ZK land. So as inputs, you could have things like the authenticated previous state route, which means that the state would be kept track of by celestia, which is fairly cheap because they're just 32 bytes per account, per ZK rollup. It would pass in the unauthenticated new state route, which would not be known by the Celestia state machine, obviously, but it would be passed in by the user because they're updating it on the right. Then the authenticated deposits, underdraws. And this is kind of the important thing. And there's also what I was telling you earlier, that if you add the ability to pass in more authenticated inputs that are more than just, let's say, a time lock, then you can do interesting things such as this. And no one's stopping you from saying, well, I can pass in things that happened in this Leslie estate machine.
00:19:50.058 - 00:20:28.040, Speaker A: This Lastia state machine will keep track of those things and pass them in as authenticated inputs to this particular account when someone tries to spend from it. Right. And the. I'm not going to explain how to kind of make sure that the kind of deposits and withdrawals don't result in contention. Doesn't exercise that for the reader, but it can be done. So what do you get out of this? You actually get settlement without execution. You get settlement with only verification, which is kind of the holy grail of blockchains, right? When a lot of people are talking about things like the end state of many blockchain, it's verify proofs.
00:20:28.040 - 00:21:32.128, Speaker A: Don't do execution for the basis layers, of course. So this is how you get it. Okay, so last slide is kind of future thoughts, not necessarily the direction, but kind of future thoughts on what else can you do with this? What are kind of the limits with which. Limits to which you can push ZK accounts? One of them is what can you actually pass in as authenticated inputs, and how stateful can they be? You don't necessarily need to keep them entirely stateless. You can have some statefulness. You just need to make sure that, for instance, the properties of monotonic validity are kept, but you don't actually necessarily need to keep them 100%. You could, so long as you design the constraints properly, potentially relax that constraint, relax that need on absolute, perfect, hard monotonic validity, and instead make it so that instead of being a one, it's like an o, it's some constant, right? So it's still like o of one, but it's some constant instead of just being one.
00:21:32.128 - 00:21:50.074, Speaker A: Things like that. There's kind of some flexibility in the space here where you're not necessarily, you don't necessarily need to do things exactly like how bitcoin does it. There's flexibility in what you provide as inputs and how monotonically valid you want it to be. Okay, so that's it. Thank you for listening.
