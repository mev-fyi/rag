00:00:10.940 - 00:00:40.260, Speaker A: Hello everyone, I'm Josh. I'm the CEO of Astria. We're building a shared sequencer network and my talk is Shared Sequencing speed running the endgame. So I blatantly stole this title from John who referenced this in his last post. So what's a sequence? There just level setting and just noting I'm going to skip over what's a roll up. I'm assuming this room knows that, but what's the sequence there? So I'm going to argue that a blockchain is structured roughly like this. We have a mem pool, could be called a transaction pool, but it's unordered transactions.
00:00:40.260 - 00:01:36.184, Speaker A: We'll get too intense later in the talk and then it becomes ordered and you have a block and then it becomes executed and that results in a state DB and a state route that corresponds to that. When we talk about sequencing, for the purpose of this talk, we're just talking about the ordering bit. We are not talking about the executing bit. We can cover that in another talk or it's been covered elsewhere. Why do we want sequencers or like why would we have a sequencer for roll ups? I think Connor's talk did a good job of showing within sovereign roll ups and rolls more generally, right? The concept of like a base roll up, how you could have different fork choice rules, what actually determines the kind of canonical ordering of a given chain. But fundamentally why we use Sequencers is for speed because users like speed. Users want these fast commitments to the ordering of their data so they can kind of make their transaction say yes, okay, I clicked a button, I got a response.
00:01:36.184 - 00:02:08.016, Speaker A: There's a large depth of research going back to the when users click a button they expected to respond within one to 4 seconds or so. Over that 4 seconds they start to think something's broken. You get to like 12 seconds, they're just like, all right, I'm out of this thing. Doesn't work. So there is like a very strong UX reason for having speed when it comes to user. This is a very simplistic design of like a roll up sequencer. We can see that the roll up sequencer is giving a soft commitment to the user.
00:02:08.016 - 00:02:48.388, Speaker A: The user just submits to that sequencer gets a soft commitment. The sequencer is going to batch to a DA layer. That DA layer is going to give what we'll call like a firm or a hard commitment to the user. The presumption here is that the data layer is going to be run slower than the sequencer. But here's the situation we found ourselves in, right? We gave users fast soft commitments, but we made a trade off and we gave up decentralization for this, right? So you do get some guarantees from the base layer censorship, resistance. But fundamentally we're running singular nodes that are geolocated in a single place and a lot of arbitrage is happening because people know where they are. They're colocating, they're spamming them that's how we're doing kind of mev and Arbitrage against Binance right now.
00:02:48.388 - 00:03:18.664, Speaker A: And our general view is like, that's not fine. So this goes to what we're building, which is a shared sequencer. What is a shared sequencer? Roughly this. So we introduced this sequencing component that is in between the data layer and the roll ups. And the kind of core point here is that multiple roll ups can communicate with one shared sequencer network. This shared sequencer network is implicitly decentralized in our terminology. It just sounds worse if you say it's a shared decentralized sequencer network.
00:03:18.664 - 00:04:02.650, Speaker A: So we just called it a shared sequencer network. And really this is the key thing. We believe that roll ups should be decentralized by default. What we're seeing for roadmaps of existing roll ups, they launch, they're centralized, they put on their roadmap and say, look, we're going to do this progressive decentralization. But the reality is we're twelve to 18 months along and we're still running centralized nodes. If we believe that roll ups are the way we're going to scale, kind of the availability of block space for users, we can't go through this cycle of 1218, 24 months of every time a new roll up stands up, they say, okay, great, we're going to do our progressive decentralization in 24 months, we will be decentralized. And we have this kind of impending queue of decentralization to come.
00:04:02.650 - 00:04:33.060, Speaker A: If we're familiar from to put the boogeyman and talk about regulation, right? Regulators are slow to move for the first time, but they're usually pretty quick to send follow up things. So I think this will become prioritized a lot more. The first time someone gets a letter from an agency they don't want to get a letter from. We think about mev a lot when we're designing this. And I would consider this mev driven design. And really the thing is calling it to hasu here, it's all PBS. All of this design really is this proposer builder separation.
00:04:33.060 - 00:05:04.216, Speaker A: So this is a single sequencer, right? But in we'll say it's like a decentralized set, this is kind of what the PBS would look like, right? You're going to have a user, it's going to submit to an RPC. This RPC is going to have a mem pool. That mem pool is going to be looked at by searchers. Those searchers will produce bundles. Those bundles will be sent to builders. The builders will create blocks that will go up to the roll up proposer. That's when you get your soft commitment, that proposer will still send a batch to a data layer and that data layer will give you your firm commitment.
00:05:04.216 - 00:05:30.868, Speaker A: This is essentially how an L one works. There's really no structural difference here other than the last step of batching to a DA layer. If we look at this in this most simple case, say we have one roll up and it chooses to use a shared sequencer, we can argue over the terminology of whether that's really a shared sequencer. It's really the same. We have a shared sequencer mempool and we have a shared sequencer proposer, but the rest of the flow is kind of the same. Here, where this we can compare it here, right? Really quick. Right.
00:05:30.868 - 00:06:31.420, Speaker A: We just made two of the boxes blue, right? Where this gets kind of interesting, right, is let's say we have two roll ups, right? If we have two roll ups, we want to have mev markets on both of them, right? We have duplicated the entire call it mev supply chain, right? Henry would say this is just protocol design, but yeah, we have to duplicate the whole supply chain. Whereas if we go to a shared sequencer, we can have multiple roll ups and we have the one mem pool and we have the one shared sequencer proposer and we didn't have to duplicate everything. So going back to the question, what is a shared sequencer? Fundamentally, it's a single place where block builders within a proposer builder separation market can settle. And that term is overused and not great, but they can settle multiple roll ups in a single place. You can think of this as a single counterparty for settling your blocks that are proposed by right. Calling out James again, right? Stop saying settlement layer. So we're not calling it a settlement layer, but it is a single place, not a layer, where you can settle some transactions.
00:06:31.420 - 00:07:13.160, Speaker A: So going to John's recent good article, right? We have kind of a trade off here, right? These shared sequencers create what is termed super builders. Let's go through the flow here, right? Going back to we have this mev supply chain design where we have multiple roll ups. They're talking to a shared sequencer mem pool that's going through this whole flow. This is a little bit oversimplified. If we want to expand this into what this might actually look like in a more layered fashion, the users may talk to the individual roll up RPCs, because they may only want to send a transaction to one given roll up. They may each have their own mem pool. And then searchers may choose to look at just one of these roll ups.
00:07:13.160 - 00:07:51.264, Speaker A: They could be specialized, they could even be subspecialized beyond this. But we're not going to cover that in the diagram. Gets busy. We also have this concept of a cross chain searcher, but all of these searchers may push to a super builder because fundamentally, we have this one block that is being sent to this proposer. And so the problem here, or the potential problem here, is that this builder is now, assuming we have like, flow across heterogeneous roll ups here, they have a lot more work to right. Instead of saying, okay, I'm going to have an EVM, I have one state DB, right? I'm going to simulate my transactions against this. They say, okay, I'm going to have a lot of bundles coming in from different heterogeneous state machines.
00:07:51.264 - 00:08:32.956, Speaker A: And I want to simulate them against each other and figure out what are the profitable ways I can direct a block that just becomes something that is a higher resource problem. And this is where we end up with Ken Griffith of Citadel just being our super builder here. And we're right back to where we started. That's not really where we want to go, but we're just going to punt on that for now. We'll go back to that a little bit at the end. But what about composability? Right? Let's think about some upsides, maybe of a shared sequencer. Is our composability atomic? Well, let's again go back to this argument here, right? When we look at this flow, what we really want to know is what is happening within this mempool searcher builder shared sequencer.
00:08:32.956 - 00:09:22.700, Speaker A: Proposer what's happening in this bundle layer. And so zooming in on this, right? What is a bundle in this concept where we have multiple different roll ups utilizing a single mev supply chain with a shared sequencer? We're going to make the argument here that a bundle is a shared sequencer transaction. Again, I'm just going to use the word transaction. We're not going to get into intents yet. And so what's the bundle look like? Right, we're going to say we have two roll ups that just happen to be blue and red with their color scheme, they would produce a single shared sequencer transaction that would consist of both of these transactions that would get ordered into a single shared sequencer block. And then after the fact, when these roll ups actually try to pull their subblock out, they would get these roll up transactions that would be ordered. This is probably the simplest case to think of about where you get this kind of atomic composability.
00:09:22.700 - 00:10:22.816, Speaker A: Essentially, this model we can think is just simulating. You just did a top of block auction across two roll ups using a single shared sequencer. The nice thing here is we don't have what is termed like the hotel and train problem, right? You are able to say, you either got both of these in or you got neither of them in, and you can buy that top of block essentially for multiple roll ups if that's how you choose to construct your bundle, rather than trying to do some kind of arbitrage where you say, okay, I want to buy on this one. I want to sell on this one, and you land one and you don't land the other. And now you have we'll call it inventory risk. Who creates the bundles, though? So again, going back to this thing, when we're thinking about these bundles, right, we have the searchers, they're going to be the people that are creating these bundles and giving them to the super builders. But really what we're thinking about here, if we want to get into the kind of interesting composability options for a shared sequencer, is we're thinking about these cross chain searchers, and then we can expand and we'll say, okay, let's just think we just have a cross chain searcher.
00:10:22.816 - 00:10:54.860, Speaker A: We have a super builder, some stuff's happening on the back end with the proposer, but let's just use the users. We have suave or something else, but we have a thing there and we also have these roll up RPCs. Really what these cross chain searchers are getting is order flow. This is them just whether they do a payment for order flow or whatever. But the thing that the searchers want to get is order flow and then they are going to produce these bundles. So that's kind of just the flow here. And so what I will argue is that kind of the end game here is hotels, trains and intents.
00:10:54.860 - 00:12:01.124, Speaker A: And so when we say that is right, the key thing that you get with a shared sequencer in the shared proposer that resolve this hotel and train problem. Because going back to the idea of settling, you're able to settle multiple roll ups within a single proposer. And so it's actually really nice that Chris gave his talk before this, right? What is the fundamental thing that when we say a proposer that it has it's this supply side thing, right? The proposer has a monopoly on the right to order. We'll just say a block, right? Whether it's intents, whether it's transactions, but a proposer has the monopoly right on that ordering. And by sharing that we resolve this hotel and train problem. Because now the users, the searchers, the builders, the people that are actually producing or making a god, the words are not great proposing a block to the block proposer, right, that they have built, right? They only have to negotiate with a single counterparty, right? And that fundamentally resolves this hotel and train problem. And I'm going to try to remember, do I have another slide for intents? I do.
00:12:01.124 - 00:13:10.104, Speaker A: Okay, going into intents and kind of going into the end game more, we'll just simplify and let's assume that we have suave or something and we're not really worried about individual roll ups, having their individual RPCs their individual mem pools, right? We have users and they are somehow giving an intent to suave or something, right? And then we've replaced our searchers. We're going to call them solvers now, but we're still going with bundles to a super builder, we're still going to a shared sequencer proposer, we're still going to a data availability layer. And here is what I think is kind of the unsolved problem. I think uma's, talk went into a lot more detail kind of around this. But I still think it's an open question, how are users figuring out an know? I think we're a lot of kind of pretty niche research community in this room and we still generally don't have agreement on what we mean when we say intent. End users who are not changing the slippage on their uniswap orders on that UI, are not going to figure out how to construct an intent at all. They're just not going to figure out there's no syntax on Earth you can come up with.
00:13:10.104 - 00:14:21.872, Speaker A: They're going to click a button. So really the missing piece here is that we need some kind of user interface in between the users and whatever this suave place where we're sending the intents, call it the bulletin board here. And so this really leads to shout out to Mads and his recent post. This is where aggregation theory, I think, comes in and this is what we're going to see as a market. And from an investment perspective, this is probably like the largest open opportunity. What is aggregating this user intent or this actual user intent and presenting them an interface that they like to use, whether it's swapping trades, whether it's buying monkey pictures, whatever they want to do. But who is providing this Google esque front door to multiple blockchains? Right? Because right now we have a pretty poor UX, even when you're trying to use one chain to Zucky's Point, right? Like, we're not going to resolve this with just transactions and having these kind of explicit imperatives saying, okay, I want to send a transaction to chain one, and then I want to bridge from chain one to chain two to chain three, and then I want to go buy a thing.
00:14:21.872 - 00:15:54.860, Speaker A: They're going to use intents, but my argument is they're also not going to say, hey, I'm going to write out some syntax that says, I want some action to occur across some chains and I'm going to set again, they're not changing their slippage on the UI for what? 50% of all the flow going through all of DFI, they're not going to accept a more complicated UI that now has ten different parameters in a form field that says, okay, well, you define how you intend for your preference to be executed. And again, this goes to aggregation theory, right? If we think this comes from like, Ben Thompson is probably the largest or loudest kind of promoter of this, and Google is kind of a canonical example, right? It is the front door to the internet, right? You don't need to use Google. You could write your own script and say, I am going to go walk through all of the potential URLs or IP addresses and I'm going to try to find the information I want. But sophisticated users, no matter how sophisticated, is not going to do that, right? They're going to rely on someone else who has said, I have gone and found stuff. And as Tarun's Talk has pointed out, they now are the front door that controls the information flow and they will take advantage of that. This aggregation theory kind of acts as like a counterpoint almost to Chris's Talk, right? This is from the perspective of the protocol wherein the proposer has a monopoly on this ordering. This is something like a user from that perspective who now has a control on the incoming information to one or more chains.
00:15:54.860 - 00:16:53.456, Speaker A: There's no reason that you couldn't have a UI that abstracts away where a user's assets are. You could even satisfy the custodial thing and still have a single kind of like pane of glass where users go to use. Maybe this looks like an expanded block builder or something like that, but this is one thing I want to highlight that I think is kind of something that this room doesn't focus on a lot. When I think about engineers and talent we have in crypto, not a lot of front end people, not a lot of JavaScript devs, but fundamentally that's what users are using, right? Users are not going to get their CLI out and express their intents that way. So really what I think might be the interesting next step that is potential to see is a single UI with multiple chains. And my bias argument is potentially it's one block because that at least makes this kind of I'm just going to call it settlement problem dramatically easier to kind of execute. I don't know where I'm at for time.
00:16:53.456 - 00:17:00.270, Speaker A: That sounds like it was fast, but yeah. Website astria.org Twitter astria.org I'm josh, thank you.
