00:00:10.220 - 00:00:53.112, Speaker A: Hello, my name is Uma, and I'm going to be talking about how cross chain Bridging account abstraction, Intense and Suave are related. And I promise I didn't just throw together four of the most popular things that people are talking about right now. There's some actually interesting connections. So to start off with, I want to talk about how did we at Succinct get here? So Succinct, we're a company, we think about the future of Bridging. And we started by thinking a lot about how current bridges really suck. They're all multi sigs, they get hacked all the time and they generally have really bad security properties. And so the thing we first worked on was ZK Snarks basically for improving security properties of bridges.
00:00:53.112 - 00:01:18.240, Speaker A: But that's not what I'm going to talk about today. I'm actually going to be talking about the future of Bridging UX, not the future of security. And so there will be no fancy ZK math. So I'm sorry about that. But basically the thesis is bridge security is broken today, but also Bridging UX is broken today. And I think a lot of people really acknowledge that. And so we're going to walk through basically fixing Bridging UX in four parts.
00:01:18.240 - 00:01:51.036, Speaker A: So part one is going to cover why does current Bridging UX suck? The next part is going to talk about maybe fixing Bridging UX with account abstraction. Part three is going to be kind of a defense of intents and why having this intent language is important and why account abstraction isn't enough. And then the last part is going to be about Suave. Lightly touch on it and basically argue that Suave is actually really important for UX. And so this is kind of like the outline in meme form. Okay, so yeah, let's just get into part one. Current bridging.
00:01:51.036 - 00:02:13.812, Speaker A: UX really sucks. Okay, so say I'm a user and I go to GMX on Arbitrum and I want to do some levered. Okay? So I connect my wallet. I realize, hey, I don't have enough ETH on Arbitrum, but I do have ETH on mainnet. So then I go to the next tab. I'm like, okay, how do I bridge to Arbitrum? I go to the Arbitrum native bridge. I connect my wallet.
00:02:13.812 - 00:02:43.824, Speaker A: Then I realize I have to actually connect my wallet to a different network, so I have to switch it. And this is very intentionally painful, so I'm like drawing it out to show you guys the pain. Okay? And then I remember, oh, actually someone said the native Arbitrum bridge is slow. I want the fastest way to bridge because I really want to do my levered long right now. And so I looked that up and okay, the top result says something like synapse. Okay? So I go to Synapse protocols, like a new website, okay, I'll trust them. Why not? I have to connect my wallet once again, I have to do all this stuff.
00:02:43.824 - 00:03:01.928, Speaker A: Okay. Finally, I bridge. Okay? And then what happens? My money basically goes into a black hole. It disappears on one side, and then I wait a really long time, and then I really hope I'm getting my money. There's, like, very little transparency as to what's actually happening. Okay. And then I finally get my money.
00:03:01.928 - 00:03:26.744, Speaker A: Great. I go back to my original tab. Okay, now I've disconnected and it says, your wallet's not connected to Arbitrum. So I have to switch to Arbitrum once again to go back and do my original app. And at this point, I'm just really annoyed. Right? Maybe a very persistent user would push through, but maybe at any step of the way, I've given up. And this current Bridging UX, I think is very unacceptable.
00:03:26.744 - 00:03:53.752, Speaker A: I'm not going to go through all the bullets we had to go through, but basically, in short, we spent maybe, like, 30 minutes. We had five tabs open, and we had to connect our wallet three times with two different chains. And this is just, like, not going to scale. And I think actually these problems get a lot worse in a world of a million roll ups. So I think a lot of people here are big fans of Cosmos thesis, Celestia thesis. There's going to be an app chain. Everyone has a roll up.
00:03:53.752 - 00:04:38.208, Speaker A: And so why do these problems actually get worse? Basically, you have to keep track of gas money and dust across all these chains and ecosystems, and then you have to solve this bridge discovery problem for each new chain. And I think this is very unsustainable. There's been some incremental improvements for Bridging, so there's been these bridge aggregators that kind of help solve this bridge discovery problem. MetaMask now has this in wallet swap feature where, sure, yeah, maybe I pay a really extractive fee, but I don't have to open a new tab. But I think this is fundamentally broken and we need something different. The ideal flow is Bridging should be abstracted away from the user, right? Like, they shouldn't need to worry about transporting their money. And I think the ideal flow looks something like as follows.
00:04:38.208 - 00:05:07.090, Speaker A: A user wants to take an action on adapt. Then they sign one transaction for the action and also permitting any necessary money flow, the money gets routed and swapped to the right destination and the desired tokens, not by the user. This is happening all under the hood. And then the user action happens. And ideally, all these things happen basically instantaneously. So in the GMX example, I'd go to the GMX website, I would connect my wallet. I would just click, like, lever long, I would sign my transaction, and then it would just happen.
00:05:07.090 - 00:06:09.584, Speaker A: Okay, so how do we actually accomplish an ideal flow with something like this? Okay, so what is account abstraction? So, account abstraction, I think a lot of people kind of, like, talk about it. I feel like it doesn't get that much love in the research community because it's very user focused. But basically what it is is it's just a spec, it's ERC, four, three, seven, and it creates a standard for a very general smart contract wallet. So the goals of account abstraction are you want to enable very complex validation and execution logic that wraps around user transactions, and then you also want to decouple gas payment from the actual user who's sending the transaction. So just to go through some concrete examples of what this gets you. So if you have this validation logic, you can have things like social recovery where maybe if I'm a user, I still have a private key, but if I lose the private key, I can socially recover and not all my assets are lost. Or maybe I can have this more complex role and permissioning system where if I want to spend more than a certain amount of money, I require like three signatures.
00:06:09.584 - 00:06:57.628, Speaker A: I can also have a contract whitelist, blacklist, I can have rate limits. And then the gas abstraction part is basically as a user, I don't have to hold ETH or the native gas token in my wallet. I can just hold USDC or any, ERC, twenty S, and I can cover the cost of these transactions not using the native gas token. So all these things sound really great. And account abstraction kind of promises they have this protocol or standard that lets people implement stuff like this. Okay, so how does account abstraction actually work? Account abstraction is actually fairly complicated or like, it has a lot of parts, but here's a really simplified design. So before a user would just sign a transaction, which would just be like the action I want to take, like do this swap on uniswap.
00:06:57.628 - 00:07:36.850, Speaker A: Now a user signs a user op. So this isn't a signed transaction, it's a signed message. Very similar to how if you're using a Gnosis safe, you sign a message and then the transaction gets pulled once all the signatures from all the users of the safe are collected. And then there's an Executor, which is another entity that submits the user op. And then the smart contract wallet basically validates the operation using validate op. So it'll check there's like the appropriate signers, it'll check access control, it'll check rate limiting, and then it actually executes the op using execute op. And this results in transfer of funds, executing a swap, buying the NFT, whatever the user wants to do.
00:07:36.850 - 00:08:31.180, Speaker A: Okay? And then actually what's really happening behind the scenes is you have a lot of these users who have many user ops and they actually send them to an alternative mempool. And then there's many executors and bundlers who are bundling these user ops and sending them in bundles to this entry point contract, which then is like sending them to the smart contract wallet. So this will become important later, but it's just like good to keep in mind. So I think this smart contract wallet, the validate op and execute op kind of explains how you do things like the rate limiting and social recovery and all that stuff. But I actually didn't explain the whole gas abstraction benefit of account abstraction. So there's another part of account abstraction called this paymaster system that allows users to stop thinking about gas. So how does it work? Basically, you have this paymaster contract which is like another entity.
00:08:31.180 - 00:09:05.516, Speaker A: And then when the user sends their transaction, first the user op goes to the paymaster contract. The paymaster contract validates that it will actually pay for the transaction and sends the corresponding amounts of native gas token back. So that's like that ETH refund. And then the user operation actually occurs with validate op and execute op. And then the paymaster basically has this post user operation hook. And the actual system here is pretty complicated. Like, the paymaster has to stake and there's all these considerations around griefing and stuff.
00:09:05.516 - 00:09:42.596, Speaker A: But if we kind of walk through the code a little better or a little more the flow for a user, say I'm a user who wants to pay in USDC to cover the cost of my transactions because I don't want to hold e's for any reason. So if I'm a user, I'll withdraw USDC to my smart contract wallet and I'll send an approval for the paymaster to spend. Okay? And then the paymaster contract kind of looks as follows. It has two functions. The first function is validate paymaster op, and it'll just return whether or not the paymaster will actually pay for this transaction. So, for example, the paymaster might not want to pay for random transactions. That's very reasonable.
00:09:42.596 - 00:10:39.556, Speaker A: And then it has this post operation function, which is this hook that I talked about which is called after the user op is executed. So the user operation happens. They do their swap and stuff. And then the entry point, which is this ground truth trusted contract that everyone's agreed to, calls this function post op. And it calls it with this actual gas cost parameter, which was the actual gas cost of the function. And then, in short, what's happening here, and this is like skimming over a lot of details, is this particular paymaster is computing the actual gas cost, converting it to USDC, and then doing a token safe transfer from the user to the paymaster to take the user's USDC and reimburse the paymaster for the gas that it covered. Okay, so can we have a cross chain paymaster where basically, if I'm a user, I would draw USDC to a smart contract wallet on ethereum, but I want my paymaster to pay for my transactions on Arbitrum.
00:10:39.556 - 00:11:15.590, Speaker A: So now my paymaster lives on Arbitrum, and can we just make this work? And okay, surprise, surprise, the answer is no. Very naively. This doesn't work because in the post operation function, when the paymaster goes to transfer USDC from the user to the paymaster, the USDC is living on ethereum, but my Paymaster contract that's paying for stuff is actually living on Arbitrum. So the USDC lives on a different chain. So naively, this doesn't work. And the fundamental kind of like reason for this is I think account abstraction is not really like a cross domain protocol. It's really meant for this single domain in mind.
00:11:15.590 - 00:12:10.100, Speaker A: Okay? So you have to kind of work your way around this and figure out a solution for even taking account abstraction and adapting it to this cross domain use case. Okay? What's a really naive solution? So the problem set up is like, I'm a user, I want to do a user operation or take some action on Arbitrum, which is on the bottom. But then my smart contract wallet actually has all my gas money on the top, and then that lives on main net, let's say. So a very naive solution is, okay, if I'm a user, I'll sign one user op on chain A, which is the top chain to pay for gas. It'll pay for the gas and send the money to the Paymaster account. Then the Paymaster will wait for finality on chain A, and then I'll also sign a user operation on chain B to take whatever action I want. And then after the Paymaster has waited for finality, then basically it'll pay for my transaction and it'll settle within itself.
00:12:10.100 - 00:12:45.056, Speaker A: So it won't necessarily actually have to move the money from chain A to chain B. It'll just front me the money on the other chain and settle with itself later. This is not that much better than bridging the current Bridging paradigm, if we think about it. So let's go back to our own evaluation criteria. So here the user still has to sign two transactions, right? It's not signing transactions, but it's signing two user ops on two different chains. The money does get routed and swapped to the right destinations. So the Paymaster is kind of doing that work of managing its account balances on the different chains and settling with itself.
00:12:45.056 - 00:13:34.384, Speaker A: But also, it's not instant, right? Like the Paymaster, you still have to wait for finality. So this naive solution still has a lot of the original problems of current Bridging. Okay? So let's think about what a better solution could look like. So one solution that we kind of thought about and came up with is, okay, a user smart contract wallet on chain A has a piggy bank where basically funds can be withdrawn with a time lock, let's say like 6 hours. And if I want to take an action, y on chain B, basically what happens is I sign my user op on chain B and then the paymaster off chain basically verifies that I have enough money in my piggy bank to pay for this transaction. And then it'll just front me the money instantly if it sees there's enough in the piggy bank. And then when it's fronting the money.
00:13:34.384 - 00:14:37.568, Speaker A: Then the Paymaster contract will also send this cross chain message to chain A to basically say, hey, I paid this much to this user for this transaction. Okay, send a message that I paid ten USDC. And then when that message arrives to chain A, it'll automatically send the money from the piggy bank to the paid master's account on chain A. So why is this nice? So here the user only has to sign one transaction, which is their user op they actually want to do. And then what happens is the Paymaster can immediately, once they've done this, check of the user funds on chain A and make sure the user hasn't signaled they want to withdraw, right? Because otherwise, if the user can withdraw, that's like problematic because the Paymaster might not get paid because this message might arrive and then by that time, the funds are gone. So once the Paymaster does these off chain checks, it can just immediately pay for this transaction, front the money, and then settle later. So the money gets routed and swapped to the right destination with the right desired tokens, and it's instant.
00:14:37.568 - 00:15:47.304, Speaker A: And so this is super awesome because it feels like, okay, this is a much better solution for the Bridging paradigm, and it's much better than Bridging today. So one interesting thing to note here is you can use this not just for gas, but you can also do this to Front, like USDC or ETH or really anything else for more complex actions like, okay, do a swap or buy I want to buy an NFT or Arbitrum or I want to do a swap on Arbitrum. Actually, this Paymaster can front all the different money, all the different tokens for any action this user wants to take, and then it can just be settled later by withdrawing from the user account on their main chain and the user doesn't have to worry about any of this. All this is happening under the hood, and the Paymaster is like, doing all these conversions like necessary stuff. Okay, so one interesting thing to note is we were like, okay, this design is cool, but do we actually need account abstraction? And we realized that actually you don't fully need account abstraction. Actually, there's a clever way to do this where the user only needs to replace their RPC. So what can happen is the user replaced, say they replace their RPC and they sign a normal transaction.
00:15:47.304 - 00:16:36.136, Speaker A: So it's not a user op, it's just like a normal transaction. And then this transaction will go to an RPC and then our RPC, and this is like a somewhat centralized solution, will basically see, oh, okay, this user has basically given us has set up this smart contract piggy bank on their main chain. So I'm going to front run their transaction with enough gas money or whatever other assets they need, and then I'll send a message to deduct from their piggy bank. So basically, you're kind of replacing this smart contract wallet and this notion of a paymaster. And our RPC is doing a lot of the work and front running their user actions with the necessary transactions to send the user gas and other assets they need and deducting from the user's home chains wallet. And so we actually implemented this. So we made this RPC.
00:16:36.136 - 00:17:29.900, Speaker A: And you can see, like, okay, I have my Xerox five CB account connected on Gorely, and it shows I have zero Gorely ETH. But then if I switch to my universal RPC in MetaMask, we kind of hijack the RPC and we return that you actually have ten Gorely ETH because in reality, maybe you have like, ten Gorely ETH on another network that you've permitted us to spend, basically. And then what happens is, if I want to do a transaction so the text is a little small. Say I want to do deposit transaction. What we do when you send us your deposit transaction is we front run you with a transfer call from our wallet to yours to give you enough gas and enough assets, and then your deposit transaction goes in after. And of course, in a blockchain where there's blocks, we can make this like a bundle, and we can even have them in the same block. In our test implementation, it was just like two different transactions.
00:17:29.900 - 00:18:06.676, Speaker A: So this seems really nice, right? I feel like as a user, I'd personally use this. I don't have to worry about anything. I just give this entity some sort of piggy bank, and then they coordinate all my gas and all my assets on all these other chains I want to use. I never have to worry about dust and things like that. So what's the problem? Okay, the problem is actually kind of like the same problem as adoption of account abstraction. So the concrete problem we ran into was DAP frontends still use their own RPC. They don't actually use our special RPC, so they will show that you have zero balance and not let you do any action.
00:18:06.676 - 00:19:01.460, Speaker A: So here's like, the uniswap screen showing insufficient USDC balance, even though we know that we'll front you all the USDC you could ever want from your main account, the DAP front end doesn't know about this. And so I actually think as account abstraction gets adopted, basically, there will be these UX adaptations for this new paradigm where a lot of this stuff's abstract away from you and hiding behind the scenes. And so I think we actually do need account abstraction because you need these DAP developers and front ends to kind of adopt to these new paradigms where instead of the user manually bridging, a lot of this stuff's happening behind the scenes for you. And so my kind of thesis is with account abstraction currently, cross chain bridging today is very push. So the user is responsible for pushing money from the source to the destination right. The user has to figure out the best path. They have to choose their bridge.
00:19:01.460 - 00:19:49.370, Speaker A: This caused us like five tabs, three wallet connections, 30 minutes delay. It was really annoying because as a user, I had to do a lot of work and make a lot of decisions. And then with account abstraction, I think Bridging can be much more pull where you have this Paymaster and the wallet and kind of this account abstraction system, figuring out the best path for you, and then all these off chain actors who are not you are pulling your money to where you want. So as a user, I can just have one tab, I sign one user operation. The funds are fronted instantly by these Paymasters who are managing these account balances and then they settle with themselves later. So as a user, you still have your money on maybe one chain that you're most on, but then everything's taken care of behind the scenes for you. So I think this is like a really nice future.
00:19:49.370 - 00:20:37.316, Speaker A: Okay, so I just talked about why account abstraction is so great and you're like, wow, maybe this solves all the problems with Bridging. Do we really need intents? And all this other complicated stuff. So what even is an intent? I think it's been very popular topic. No one really knows what it means, and I'm going to do my best to define what it is and I'm not going to give a very precise or mathematical definition that's more philosophical, more of like a vibe. Okay, how do we compare an intent to a transaction? So transactions are this object we know and love, right? If you're a user, when you do a transaction, you're just specifying a specific action. It's like very declarative and intents instead specify a desired outcome or goal. So let's just go through some examples.
00:20:37.316 - 00:20:59.824, Speaker A: So a transaction is I want to swap 2000 USDC for at least one ETH on uniswap. Okay, you're saying I want to use this venue and I want to swap this for this. An intent version of this would say, like, I want to swap 2000 USDC for as much ETH as possible. That's like your goal. You're not specifying how to get there. You're just saying, here is my preferred state of the world after. Okay.
00:20:59.824 - 00:21:33.588, Speaker A: Another transaction example is like, I have ETH and I want to lend it on compound. An intent is I have ETH and I want to get the highest APY and maybe I only want to interact with a certain whitelist of lending protocols that I trust. And I actually think the lines are blurred in some cases. So for example, like today, a uniswap swap, I want to do a uniswap swap with a maximum slippage of 0.5%. So of course there's a transaction in there which is, I want to do a swap on this particular venue for these assets. But you also kind of have an intent. You're saying like the maximum slippage I will tolerate is 0.5%.
00:21:33.588 - 00:22:22.468, Speaker A: That's like not declarative, right? Unless you're getting sandwich and your max slippage is actually your actual slippage, you're saying this is the maximum that I kind of want and of course my preference is lower. So a lot of people, and I've kind of heard this, maybe not in this crowd is like, okay, do we really need intense? Intents is just account abstraction. Except the researchers are being pretentious again. They came up with these new names for old concepts. Okay, I actually think this is not true. And so here's my defense of intents. So one question to ask is like, okay, are user ops and the validation logic in a smart contract wallet, are they intense? So, okay, are user ops intense? Let's just go through our definition of intense versus transactions based on this kind of very loose definition we previously established.
00:22:22.468 - 00:22:51.408, Speaker A: So I actually think user ops are not intense. Usually user ops are very simple and declarative. They're basically a transaction and they want to say like, I want to trade X for Y on the venue. So they're basically transactions. I actually think there is some truth to account abstraction being related to intents. But I actually think this comes from the validation logic in a smart contract wallet. So I think the validation logic in a smart contract wallet is able to express and enforce very simple intents.
00:22:51.408 - 00:24:00.616, Speaker A: And what do I mean by this? So basically I think statements of the form rate limit x money leaving my account this month or hey, my address can only interact with uniswap and sushi swap. So like the whitelist blacklist system or USDC in my account can be used to pay the paymaster for gas, which is an intent to reimburse. I think all of these things are clearly not transactions, right? They're kind of like stating your goals and preferences over certain outcomes, but they're not declarative in the same way saying, oh, I want to trade on uniswap is or I want to swap X for Y on uniswap is. And so I basically think the validation logic in your smart contract wallet expresses and also enforces intents that can involve global reasoning about the user account. But of course, my smart contract wallet cannot reason globally about general state. Like in my smart contract wallet, I can't write logic that's like, give me the best price for this swap because there's no way for my smart contract wallet to know globally what the best price is. And so my claim here is that account abstraction is basically this handcrafted protocol that's in service of specific intents, so very simple intents.
00:24:00.616 - 00:24:43.592, Speaker A: So in account abstraction, the user can specify and enforce really simplified intents with their smart contract wallet when the intents satisfy very restrictive requirements. Like the intents can only be single domain, which is the domain your smart contract wallet is deployed on. It only can use and enforce information relating to the user account. So I can't really attest to information about other stuff going on chain or other transactions. And also I can do some gas reimbursement stuff because it's like hand tailored into the account abstraction protocol. And I think this is also why the account abstraction spec is a little ugly and the spec is very long and contorted. And it feels like the way they came about to this spec is the people who designed it.
00:24:43.592 - 00:25:33.460, Speaker A: They took really common user intents that they would think normie users would want, like rate limiting, social recovery, gas abstraction and things like that. And then they handcrafted a protocol to express and enforce these specific intents. So they kind of started with what are common things users want and then let's create a protocol to let it happen, let these intents be expressed and enforced. And it's like semi general, but it's very user focused, which I think is super awesome, but it's not that general. And I think there's actually many examples of intent specific apps. So for example, a lot of users have very common desires, right? Like I want the cheapest way to get frog coins or I want the cheapest way to get monkey pictures. And so you have these intents that look like, okay, I want the best swap or I want the cheapest JPEG or I want the best yield.
00:25:33.460 - 00:26:30.344, Speaker A: And then there's these classes of intent specific apps like dex aggregators, NFT aggregators, yield aggregators that help these users express and then actually enforce their desires for these intents. And so one question is like, okay, maybe account abstraction and intent specific apps are enough, do we really need this general language? Maybe all intents of users are generally pretty simple. They fall into these really simple buckets, why do we need this general abstraction? And I actually think even for really simple user use cases, intent specific apps have a lot of limitations in a very MultiChain world. So, say my goal is really simple. Like I have ETH. And I want to buy as much frost coin as possible using the liquidity across all the roll ups. So with account abstraction Bridging, and like the Bridging solution I described before, now I can really seamlessly and instantly use my favorite dex aggregator on any roll up.
00:26:30.344 - 00:27:21.188, Speaker A: But one problem is I still have to find the best dex aggregator across all the roll ups myself. So I have to know which roll up has the most liquidity. And then if the liquidity is really fragmented and spread across all these roll ups, then I'll have to manually go to each roll up and do the amount that I want. But with intent Bridging or like some form of generalized system, I can just tell the mempool, like I have ETH and I want to buy as much frog coin as possible. And then basically some really clever searcher who's put in a lot more work than me. In this multi domain dark forest, they'll just find a solution and hopefully be fairly optimal because they're being incentivized to do so. And so I think in this multi chain world, even if you look at really simple stuff like a Dex aggregator, it's really infeasible for one company who's running a Dex aggregator to integrate with all these new roll ups, all these new domains.
00:27:21.188 - 00:28:02.004, Speaker A: And so these Intent specific apps don't really scale that well in a MultiChain world. But I think having this general flexible language for Intents actually does scale really well because it's a more permissionless system. You don't need a whole company to be filling one, to be writing the world's Dex aggregator that incorporates every chain. Instead, you just have these pool of searchers. And maybe some searchers are specialized for a certain class of roll ups, and other searchers are specialized for other ones, and they're all competing to basically serve the user. And so, yeah, my final point is, like cross domain intents is actually really useful and it's much more powerful than vanilla account abstraction. And it's even very useful for even pretty simple use cases.
00:28:02.004 - 00:29:09.192, Speaker A: So I think Intents are really needed and there's definitely a lot of open questions like how can you show what's optimal? Is it even possible? What will the Intent language be? Is it just a variant of user ops? Will most intents be similar or different? Where will the cross domain intents get posted? Like, where does this all happen? How do the searchers know what to search for? Which leads me to my final part of the talk, which is talking a little bit about Suave. So I think Suave is basically like a way to make intents happen. I know there's some other proposals out there and yeah, a smart man who I believe is in the audience once said, suave is just a global bulletin board for preferences that sophisticated actors who understand the risk can compete to execute across domains. So here's our previous account abstraction diagram. But now I've really ugly done some really basic photoshop and shown a bunch of users in a very MultiChain world, right? Like, you have users on Arbitrum optimism mainnet. They all have these user operations. They're contributing them to this alternative mem pool.
00:29:09.192 - 00:30:00.648, Speaker A: And now you have a bunch of executors and bundlers who are bundling these user operations, cross domain and bundling them and basically landing them on chain. And if you squint a little bit and you see this picture, which I'm sure you guys have seen many times for what is suave, and this picture comes up a lot, you can kind of squint and overlaid those two things and you see that, okay, the account abstraction, alternative mempool and the user operations look a lot like this preference environment. Then the account abstraction bundlers look a lot like this execution market. And then the bundles of user ops look a lot like bundles. I don't have too much. That's very formal to say here, other than I think these ideas of MultiChain account abstraction and Suave and Intents are all very interrelated. So what's my main point here? And bring up Suave.
00:30:00.648 - 00:31:00.480, Speaker A: So I've noticed, and I think a lot of you would agree that a lot of discourse about Intents and Suave is very academic. It feels like there's a lot of researchers and then they often view Swab and Intense through this lens of the mev searcher and the power user. They're like, okay, there'll be this user, they'll really want to land their transaction across two different roll ups at the exact same time. And they talk about these users quite a bit. And I think I've never really heard Suave and better UX for the normie user mentioned in the same sentence. And I think my thesis with all this stuff is like the normies actually really need Suave too, like cross domain intense and Suave is critical for UX and I actually think it will make a big difference for UX and is really important for the average user, not the searcher. And so my final point is account abstraction has been really excellent at thinking about end users.
00:31:00.480 - 00:31:46.508, Speaker A: How they made this protocol is kind of like they took really common end user intents, like, okay, my normie user doesn't want to care about gas, my normie user wants rate limiting, my normie user wants whitelist, blacklist. And then they made this kind of complicated, somewhat ugly, like, handcrafted protocol to serve these common end user intents in mind, which is really great. And then Intents and Suave is kind of on the other end of the spectrum. It's this very general thing. It's very flexible. And basically I think a lot of those ideas are actually really useful in making something like account abstraction more general, more powerful and also a better UX. And so my kind of plea to all the flashbox people here and all the people thinking about Intents and Suave is please think about the normie users.
00:31:46.508 - 00:32:11.370, Speaker A: And I think in this world where Intense and Suave actually do end up thinking about the normie users, cross chain bridging can and will be like 100 x better in the future. And hopefully the normie user doesn't even really need to know what a bridge is. It's all very abstract and thing. All the money gets pulled and routed to where they want it to be and they just take the actions they want to take. Yeah. So that's my talk.
