00:00:09.800 - 00:00:46.038, Speaker A: Oh, hey, how's it going? My name's Connor, I'm a solutions engineer. I work on Celestia and I was only given two weeks notice for this talk. And that is so short that I almost had to pull out one of my pre prepared talks. I almost had to break glass in case of emergency and use one of my pre made talks. But I like you all too much to make you sit through something about atomic composability with shared sequencers. So here's the talk about oracles. So you might have heard of some of the traditional, really popular oracles.
00:00:46.038 - 00:01:39.790, Speaker A: Chainlink, switchboard, pith, teller, there's a bunch of others. These are application layer oracles. These are oracles which are built as apps deployed on general purpose blockchains. And fundamentally they all make an honest majority assumption that means, well, all right, maybe that's not the super proper technical term for what I'm trying to get at, but there is some group of people who can change the result of the data feed and attack the users and cause the oracle to be wrong. You can do fancy things, you can come up with new ways to try to improve your application layer oracles, but these are still the same, have the same problem. There's some group of people who can nuke these price feeds, cause them to be wrong. For example, there's the UMA, the optimistic oracle.
00:01:39.790 - 00:02:23.734, Speaker A: If there's a dispute, it goes to the governance and you can just be rich and spend a lot of money to manipulate that. There's John Adler's master's thesis, the Astraea oracle, which uses sealed, some sort of sealed voting thing where you're doing hash commitments. If you have a lot of, if you have enough money, you can still just nuke that thing and cause it to be wrong. There have been some other attempts to do app layer oracles that are better. A long time ago there was a protocol called Augur. Augur is a prediction market protocol, and they had this scheme. I think it worked like you deploy the contract and if the majority gets corrupted, you redeploy the contract in a way that socially slashes whoever was malicious.
00:02:23.734 - 00:02:49.386, Speaker A: And the value of the old ERC 20 goes down because that one's broken. And the value of the new ERC 20 goes up because that one works. This is great, this is very clever. And we do like these things pretty good. It's not a bad way to do it, but it doesn't prevent the attack entirely. It deters the attack. If the deterrent is you will lose money if you cause this attack, that's not as good as you just can't do the attack at all.
00:02:49.386 - 00:03:47.990, Speaker A: It's impossible. Layer one blockchains layer one blockchains also have an honest majority assumption of sorts. If the majority of the stake or hash power of your layer one blockchain is corrupted, there's some ways that they can mess with the chain. They can halt the chain if it's something like a safety favoring proof of stake. They can reorg the chain if it's proof of work or maybe aliveness favoring proof of stake. But they can never violate the rules, they can never spend funds out of your wallet, they can never violate the code in a smart contract, nothing like that, which is different than the oracle because if the oracle is corrupted, they can steal your money, they can manipulate defi, they can liquidate your positions, they can screw you over, cause all kinds of chaos. On a application layer oracle, you may have your chainlink running inside of Ethereum and it's going great.
00:03:47.990 - 00:04:35.350, Speaker A: It's going great. The chain link committee or the chain link multisig or whatever it is, they're being nice, they're giving you the correct price feeds, but then something happens, it goes wrong. Ethereum just progresses anyway. Ethereum does not care about the application layer oracles running inside of it being correct. They're probably not going to do another dao hack. Hard fork over this, it's probably never going to happen again. But what if you didn't do it this way? What if instead of having the oracle run as an application inside of a general purpose chain, what if you made it part of the chain that might look like this and we're going to do it, we're going to describe this in the hypothetical light client utopia because that's what I'm trying to build at Celestia.
00:04:35.350 - 00:05:50.434, Speaker A: So here you have your user and your user is running some kind of node, let's say for this example that it's a proper mature, trust minimized light client, where they're downloading block headers, the block headers are accompanied with a validity proof, the header is accompanied with random da samples. And additionally we're now going to also have the oracle value for whatever price feed your chain has enshrined in the header as well. And in addition to verifying consensus with the header, verifying the integrity of the execution with the validity proof, and verifying data availability by sampling, we're also going to have this user check the price feed with whatever sources that they trust. So maybe they trust binance, maybe they trust Coinmarketcap. And I put here the logo for local bitcoins because maybe they have some sort of local marketplace thing that's not centralized. And this is the far, far future where all of these centralized infrastructure collapses and it's dystopia. And now we have to have, like, now you have to buy crypto at the farmers market because, like, you could still, whatever.
00:05:50.434 - 00:06:31.326, Speaker A: So it's pretty nice. So like, now if the oracle and the header is ever wrong, the users can reject it and so funds will not be lost. Defi doesn't break depending on what consensus protocol the blockchain uses. Maybe there's a halt, maybe there's a halt, maybe there's a way to recover from halts. Consensus protocols vary and what's possible with that. And this is pretty important, right? We like our blockchains to not have honest majority assumptions for safety of funds. We tolerate the honest majority assumptions for reorgs or halting or liveness, et cetera, et cetera, because we can't really escape that, right.
00:06:31.326 - 00:07:40.724, Speaker A: That's kind of a fundamental part of blockchains that we can't get away from. But a lot of people use defi. That's a really important thing that we love and that we're trying to make possible. So ethereum, the number one blockchain for DeFi, where all the TVL is, why don't they just enshrine oracle? Why don't they enshrine eth USD? Well, this was discussed in 2020, so May 2020, I believe. Yep, May 2020. Justin Drake posts this long proposal on ETH research which suggested that Ethereum should enshrine price feeds for the ether asset denominated in a bunch of different foreign currencies and USD, basically to improve oracles, not to replace chain link or anything like that, but so that you could maybe have some sort of accountability for Chainlink and still build app layer oracles, but have them be kept in check by this enshrined oracle mechanism. And another part of this proposal was that the resolution of the oracle would be with finality, not per block.
00:07:40.724 - 00:08:22.786, Speaker A: It would be like part of Casper, not part of the liveness, favoring part of the consensus. And it was an interesting proposal. Didn't happen. There was, there were a lot of reasons why. So, okay, Ethereum doesn't want to, doesn't want to add all this bloat, right? Ethereum wants to be minimal. Ethereum wants to be verifiable, fully, objectively. Of course, there is the timestamp and there is the checkpoints.
00:08:22.786 - 00:08:57.228, Speaker A: From weak subjectivity and all that. But the general attitude in Ethereum is this is too opinionated. This compromises on neutrality, this compromises on really important things that we don't want to sacrifice, and that's fine. The app layer oracles, they work. They have been pretty reliable for the most part. Nobody's really worried about this threat that I'm describing. And even the intersubjectivity way, like the Auger way, is you can do a lot by just deterring, by just deterring these kinds of attacks.
00:08:57.228 - 00:10:05.800, Speaker A: And it's not the end of the world, but the enshrined oracle concept has survived. It's relatively common and accepted in the world of Cosmos terra, believe it or not, had a Luna USD price oracle. In the base layer. The terra validators were responsible for checking and verifying the Luna USD price as part of the protocol rules. Additionally, I'll shout out Skip, who now has the slinky product, which makes it easier for Cosmos app chains to build in oracles. So I think it's fair to say that while a lot of chains want to fight each other and that like, you know, there are, there are eth killers and there are people who are at each other's throats and competitors, I think it's fair to say that like, Cosmos and Ethereum are two different complementary strains of the cryptocurrency ethos. And for the most part, we coexist and we accept our differences and that like, you do different things in each ecosystem, you build different kinds of things.
00:10:05.800 - 00:10:48.994, Speaker A: And I think this oracle difference is a major way to observe the discrepancy between cosmos philosophy and ethereum philosophy. So subjectivity oracle is pretty cool, pretty nice. I like that you can make these apps that have unruggable oracles. I think it's pretty powerful and it eliminates this scary threat that Ethereum defi has. So how do you actually build it? Well, suppose you use a regular Cosmos stack. You use comet BFt and cosmos SDK or something like that. Tendermint or Comet BFT.
00:10:48.994 - 00:11:38.706, Speaker A: I used the tendermint logo because I think it is more of like a symbol that you can use as clip art and slides. And the Comet logo is a little bit more of a product logo. I don't know, I just thought it looked better. But shout out Comet BFT, the true, proper tendermint. All right, so you have, your validators are putting the price feed as part of the header and the users are running nodes and they're verifying the oracle feeds with the chain progression for each block, the users verify the oracle and make sure that they're not getting rubbed by the validators. But then here at the end, we have a obviously wrong, or maybe not obviously wrong, depending on how bullish on whiff you are. You have an outlier, like a crazy wick that no one agrees with.
00:11:38.706 - 00:12:14.800, Speaker A: They say that the coin is worth $9 million when it was worth $3 in the last slot. And all your sources, all your trusted sources disagree with that. And so you, the user running your node, you reject what the validator said because that doesn't look right. So in this scenario, you want a fork, you want to reject that block and you want to wait for another block that gives you the correct value or some value that's within your threshold that you trust. According to your sources. In tendermint, you can't do that because the chain halts. If all the validators are malicious, the chain halts.
00:12:14.800 - 00:12:41.876, Speaker A: So when you want to fork to fix this broken oracle, you also have to change the validator set. And this is something that I fear might actually get political. You might have people arguing over who should be the new validators, who gets to replace the malicious validators. So and so wants theirs to get in. So and so wants theirs to get in. Validator set is limited. So that's a obstacle towards doing this.
00:12:41.876 - 00:13:50.662, Speaker A: With tendermint. If you think about proof of work or maybe aliveness favoring proof of stake, it's way easier to see how this would work out. So in the proof of work example, you may have someone who spends some electricity on making it obviously wrong fork that no one's going to accept. And now if they want to sustain this fork that nobody accepts, they have to keep burning electricity to keep building blocks on this chain that no exchanges, no issuers, no users are going to care about because it's an attempt at an attack or something. So in the proof of work example, it's really easy to see how this can, we can kind of make this real. And now I'll show you guys an unexpected nice thing about the sovereign roll ups that we're trying to make possible at Celestia and in the rolekit team and in our ecosystem. So you actually kind of get this proof of work like property.
00:13:50.662 - 00:14:28.586, Speaker A: If you were to implement a subjectivity oracle for an app chain that's built as a base sovereign roll up like this. So there is no validator set if it's a base sovereign rollup. Instead, consensus is just determined by the order in which the blocks are sent to the chain verified by the users. So that's why the title of this talk is subjectivity. Oracles and sovereign roll ups are a match made in heaven because it's a really, really nice way to build these kinds of app chains. And it's very conducive to this mechanism. This does kind of break interops.
00:14:28.586 - 00:15:05.434, Speaker A: So if you have like with the terra example, the terra validators are also your bridge. If you're just using regular IBC, you're not going to get that with this. This is subjectively verified. So you pretty much need to have trusted bridges. You pretty much need to have like wormhole style or possibly different tendermint committees or something like that in order to make interoperability work. But it's not the end of the world and you know, it is a trade off spectrum, but it's not so bad. I think there is certainly a place in the world for these kinds of things.
00:15:05.434 - 00:15:31.624, Speaker A: And it's a very cool thing that's kind of made possible by this chain architecture. And I would encourage you guys to try it out and to build it and to check out, check out sovereign rollups, check out rollkit. And now you have only possible on such and such reason to do so. That's about it. Thank you.
