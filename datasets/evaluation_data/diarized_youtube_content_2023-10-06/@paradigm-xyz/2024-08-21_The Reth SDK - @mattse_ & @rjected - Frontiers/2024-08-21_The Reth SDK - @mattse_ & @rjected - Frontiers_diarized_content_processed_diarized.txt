00:00:00.280 - 00:00:03.810, Speaker A: Everyone, I'm Matt and this is Dan.
00:00:04.470 - 00:00:05.254, Speaker B: Hello.
00:00:05.422 - 00:02:13.942, Speaker A: We will talk a bit about ref SDK, the current state of it, and what we have in mind for the upcoming months, and what features we would like to implement and support. Why are we doing this in the chat room? We get a lot of questions that are when do we get support for chain x? When is this supported? Can I modify this component? Can I only use the networking stack, for example? And some of those are already possible, like most of our components are already modular. Especially networking stuff is useful on its own if you want to do some weird mev stuff. But all of this is still tied to the ethereum mainnet and we realized that there is demand for like an EVM centric node SDK. Because EVM is widely used, developers want to develop on the EVM and we want to provide the required building blocks so you can innovate on top of the EVM, essentially without forking the node, and then go through the troubles of rebasing it, maintaining a fork, keeping up with l one development and ideally there should just be some kind of plug and play of supported modules, crates and you put them together as you like, make some modifications and experiment with new features. But if we want to come up with an SDK, we need to support a node from scratch. And there are a lot of things in a node, lots of components.
00:02:13.942 - 00:04:02.180, Speaker A: There is the entire database layer where you store the state of all accounts, historical states. Big one are chain specific types. This is probably the hardest one because every network or every roll up improvement proposal kind of requires either a new transaction type sorry, or some modifications to existing ones, or some weird other transaction types that are not even signed. And then also on the EVM layer, ideally you want to support something like custom precompiles, custom logic, eventually also Ethereum object format which Dan will talk about later a bit. And maybe your node should not use the doesn't want to use the engine API that is currently used on optimism and mainnet, maybe something entirely different, which is perhaps just one request that allows us to change a big component of a node is also RPC. And especially RPC issues are very annoying. And it would be nice to have some very well maintained RPC crates or library where everything is already implemented, be it gas estimation, tracing, things like that.
00:04:02.180 - 00:05:31.680, Speaker A: And also p two, p and t xpool. Those are the biggest components that composer node. And it would be really nice if a user could just take some well maintained library, make some, introduce some new features and then compose them to their custom chain. Why I think this should work is because if we look at various EVM based chains, they are very similar, but there are lots of nuances. OpGif maintains a diff and if you look at the numbers then the diff is only like 5000 lines of code, but these diffs affect the entire node. Basically on the execution side you have a new transaction type, for example, slightly different engine API, different RPC types, but otherwise it's fairly similar but different. So there are very very few things that are exactly the same, but all of them are very similar.
00:05:31.680 - 00:06:56.230, Speaker A: So what we currently support is Ethereum, Mainnet, testnets of course, and DoP stack because it's close enough to Ethereum L1. We made some modifications to the engine API because on optimism it's slightly different. We made some modifications to the EVM so it can handle optimism, specific execution logic and custom types. The current drawback is that this requires feature flag at the moment, so we don't have abstract transaction types. And ideally we want to get to a place where this is no longer the case. So you could run Opstack and Mainnet in the same binary, even in the same process. Yeah, and what is currently supported on the SDK side of things is that you can introduce custom commands to the existing CLI extenders with new services, introduce new RPC endpoints, and also execution extension that Alexei will talk about in a bit.
00:06:56.230 - 00:07:18.390, Speaker A: Cool. Yeah, there are more talks about what is currently being built on top of rev, and I'm looking forward to the talks about Shadow ref, the rbuilder and SP one ref and Dan will now talk about two bots and actual ref SDK.
00:07:19.780 - 00:08:21.760, Speaker B: Cool. So yeah, I'm going to be talking about what we want people to be able to build in the future. So you could build a lot of different things with the rest SDK. It doesn't have to be a chain, you can build whatever you want. Some examples up here are what we have taken a look at seeing okay, what are the requirements for the SDK? How would you build it? We mentioned off breadth, which it's an optimistic roll ups, but beyond what you can already do, we've gotten a lot of requests for various things people would like to build. One example is transaction types. For example, the rip roll up improvement proposal on native account abstraction requires an entirely new transaction type.
00:08:21.760 - 00:08:46.210, Speaker B: So it would be great to natively support this in the ref, SDK header and block types. This is pretty common actually. People will add a field, they will change a field. So we of course want to support that. Custom consensus would be very interesting. I mean, optimism already modifies the engine API. You should be able to modify it too.
00:08:46.210 - 00:09:32.900, Speaker B: New execution environments. I'll talk about that later. When it comes to EOF and how that kind of enables adding very very crazy modifications to your chains or applications execution environment. But there are a lot of very interesting things you can do there. Finally, I'm going to talk about state commitment, which is right now the ethereum may not uses Merkel Patricia's tree, but you could use other things. Regular binary tree, you could use Verkle, you could use something that has cryptography that's more friendly to your ZK proof system. So beefe Cool to see what people build once we support this in the SDK.
00:09:32.900 - 00:10:26.302, Speaker B: Another thing that we want to really emphasize is that everything that we allow customization for will have native support for RPC, tracing, whatever, when you actually build your node with it, which is also going to be very very easy. Here are some other goals of the rest. SDK, some of which we are actively working on and are actually pretty close being done with, for example, no standard support. This is a very common request for ZK teams. They want to be able to run reth code in the ZKVM, which is more restrictive than a regular laptop. For example, fully modular crates. People should be able to use their stuff in a standalone component.
00:10:26.302 - 00:11:07.510, Speaker B: So if you just want to run the p two P layer, you should be able to do that. If you just want to have like an RPC layer and then proxy it somewhere else, you should be able to do that with the SDK. Finally, you should be able to customize everything when it comes to execution. So if you want to do something like shadow is doing, where you run stuff in between, a normal transaction that should be supported. So we make all this very easy to configure. So custom types are very, very interesting. I'm really looking forward to what people will build with them.
00:11:07.510 - 00:12:06.680, Speaker B: But yeah, here are some of the examples of what you might build. We did mention that Alphanet will have BLS and Sec p 256 r1 support, but right now it just has pre compiles. You could also imagine being able to submit a transaction directly with that cryptography. So if you just want to sign a transaction with your passkey, you wouldn't require a 4337 wallet, for example. You could just sign transactions just like you would a normal eOAE. Um, and so that is at least one compelling use case for uh, custom types like custom transaction type. Uh, usually if you're modifying this in op geth it would require you to go in, add a new transaction type and change a bunch of like switch statements that uh, switch on the transaction type and it becomes very, very invasive.
00:12:06.680 - 00:12:48.390, Speaker B: Additionally, if you were to try this with Reth right now, if you were to fork it, this would become very frustrating. Additionally, header and block fields, one example is millisecond precision block timestamps. Some chains run at lower than one block second block time, so you need more precise timestamps. Consensus is also pretty interesting. You could build ref anvil with it. If you've ever used anvil in foundry, it'd be nice to be able to use all of the things you can use with Reth and Reth. ABCI is also very, very interesting.
00:12:48.390 - 00:13:40.950, Speaker B: You could do some cosmos ret type stuff. And finally, this is partially enabled by the SDK and partially enabled by eofdemen. Um, so for a quick recap on EOF, uh, I know Oliver will talk about this later, is that you can have custom byte code. Uh, you can basically tell it, I have this new byte code format, it has this version, and it will sort of switch execution modes and do something different than the regular EVM interpreter. Uh, so what that would enable you to do is add 35 reals, which Leo alt built, which is very, very cool. It's a new execution environment. Check it out on GitHub.
00:13:40.950 - 00:14:10.920, Speaker B: You could do just RISC five, or you could have an l two with just like x 86 native code or something. Just ideas. But this would be very interesting. I want to see people experiment with it. Custom system calls and system transactions. This is pretty common actually, in rollups. The new Ethereum forks are also doing it.
00:14:10.920 - 00:15:17.810, Speaker B: You can basically have automatic transactions happen at the beginning or the end of every block. If you need your chain or validator to do something every block, this can be very useful. Finally, state commitment. I mentioned this before, but I think it would be really cool to see people experiment with a custom state commitment and sort of, if anyone is experimenting on it, we would love to know what you're building, what you need from the SDK. But if right now Ethereum uses Merck Patricia tree, and you need, you might want to have smaller proofs, or you might want to just experiment with the width of the tree to trade off IO or compute custom hash functions. If you're running a ZK roll up or something, verkle would be very cool. Or you could just get rid of it and not have a state commitment, which would be also kind of cool.
00:15:17.810 - 00:16:14.490, Speaker B: And the final thing I want to talk about is just, or really ask people is what would you want to build? If you could modify a chain, or if you are building for a chain that is kind of like modified Ethereum or even wildly different from Ethereum, how would you build your application in rust, or how would you like to build it? The rest SDK is not limited to just building chains. It's also for whatever application that you would want to build. If you're building on Polygon, even then, it'd be interesting to see what you need from the SDK. So I think people should think about what they want to change in Ethereum and let us know what you want to do and we will build the tools that are required. I think that's about it.
00:16:26.750 - 00:16:50.360, Speaker C: All right, thank you, Matt and Dan. So Matt was actually sick last night and he still did the talk, so extra kudos to him. So we have some time for Q and A. Make sure it is a question, not a statement, not anything other than one question. It can be a spicy question, but it has to be a question. So Tony here will pass around the mic and make sure to ask one question.
00:16:58.260 - 00:17:08.888, Speaker D: Thanks for the talk, guys. You mentioned on the previous slide the idea of avoiding merkelization or the Merkel state commit entirely. Can you speak to what you're alluding to there?
00:17:08.944 - 00:17:46.549, Speaker B: It's kind of interesting, really. It's just that like, I mean, if you like, the state commitment is required for mainly, like, clients and stateless clients, which are applications that love chains want. But if you don't want that, then you could get rid of the state commitment or have it be something that's more efficient, like just hash the state diff, for example. So yeah, it could be. I mean, if you care about performance and that's it, and you don't want, like clients, then I could see a good case for removing the state commitment.
00:17:51.529 - 00:18:07.010, Speaker E: Hey, thanks. Great talk. I'm curious how much of this exists versus future vision. I didn't quite get a feel, feel for where this project is at, I guess. And how can people help beyond telling you what kind of modifications they'd like to make?
00:18:08.430 - 00:18:26.090, Speaker B: So basically everything that I mentioned in this slide are things that are not currently supported, but we would like to support in the future. And then I think Matt can expand on what you can currently do.
00:18:27.480 - 00:19:00.030, Speaker A: Yeah, we are actively working on it, but it will still take some time. But we kicked it off. But the thing that blocks all these features are essentially abstractions over all those chain specific types, be it block header or transaction. Once we have that, this will unlock a ton of features that Dan went.
00:19:00.070 - 00:19:21.090, Speaker B: Over to give some examples of what you can currently do. Like right now you can add new Cli arguments, you can add new RPC endpoints. There are various things you can do if you're running P two P as a standalone service, but we'd like for all of these things to be fully integrated.
00:19:26.270 - 00:19:34.370, Speaker F: Do you think it's ready right now to run some private network with a consensus algorithm like QBFT, or what the lift would be for that?
00:19:35.830 - 00:20:35.130, Speaker B: So right now you could hack it together by calling into the engine API. For example, when a new block is finalized, you can just, there's basically three fields in the fork choice updated endpoint in the engine API. You would set those all to the same thing. I think this is how some BFT projects work with Ethereum clients right now, but we are currently working on a refactor to how we handle consensus messages that would allow you to really put whatever message type you would want in there. So anything related to BFT, you could have your own custom messages depending on what the consensus protocol does. That's not ready quite yet, but you could hack something together for now and then stay tuned for the full support. Cool, thank you.
00:20:35.130 - 00:20:57.140, Speaker B: Thank you. Is a pipeline a pipeline architecture supported on your roadmap? Meaning like interleaving, like transaction building, execution, stake commitment, storage?
00:20:59.280 - 00:21:38.890, Speaker A: Yeah. Perhaps a bit more context here is that pipeline architecture takes care of historical syncing, downloads, stuff from the network, executes, verify as hashes. This is just one component of a node, so you could already modify it. And essentially it's just one component, which is the backfill or downloading part. And you can also switch it out to something else if you want to use something different.
00:21:53.910 - 00:22:05.880, Speaker G: Say you were looking to build a sequencer that had custom logic or rules. Where in the SDK stack does that slot in? In an ideal world.
00:22:08.020 - 00:22:53.740, Speaker A: I think this belongs to the payload building component, which is also used by the Opstack payload builder. If it's a sequencer, then it's supposed to include transactions from the block. And the way the payload building component is written right now is that it lets you implement anything that eventually returns a block. So as long as it can handle the engine message, the payload builder attributes and returns a block when the consensus layer requests a block, you could introduce.
00:22:53.820 - 00:23:05.260, Speaker G: Anything that supports that and a small follow up. How does that slot in with decentralized sequencing and the sort of broader consensus around it.
00:23:08.200 - 00:23:09.300, Speaker H: Out of scope.
00:23:14.040 - 00:23:29.930, Speaker A: Building. As mentioned, you can plug anything in there, and if it just delegates the payload attributes to something else, and then eventually retrieves it over the network and returns it to the consensus layer. This is also possible.
00:23:41.670 - 00:23:56.270, Speaker H: Are there any plans to reduce the IOP's load that Reth requires, like switching to an optional treaty? For example, if I want to sync main net off a USB three drive or an underpowered Kubernetes cluster.
00:24:01.650 - 00:24:57.060, Speaker B: I think that's probably that's not super related to SDK, but we there aren't any current plans to do that. But if you have a list of requirements or have tried it out on something that's bad hardware, then we're happy to talk about it and see if there's a way that you could tune your node to maybe make it work. Yeah, it's a.
