00:00:00.120 - 00:00:09.650, Speaker A: I have Oliver, who was brave enough to do this talk on core development. So give it up for Oliver. And yeah.
00:00:14.150 - 00:01:07.332, Speaker B: Hey guys, first of all, thanks for coming out. And to people at home, thanks for tuning in. I was asked to do this talk about core development, which is a pretty broad topic, so I wasn't entirely sure what to present about. So I think what I'll do is I'll present what is core development, what is a core developer? Then I'll go over briefly what's in Pectra and then what's in the future. Like what are we excited for? So what is core development? It's to me, always been a pretty nebulous term. Essentially it's anything that improves the core protocol of Ethereum. So that's the execution layer, the consensus layer, and it's very multidisciplinary.
00:01:07.332 - 00:02:23.530, Speaker B: Right? Like you have researchers, you have community building ideas, you have the developers, you have an amazing testing team at the EF DevOps, you have user contributed testing and infrastructure. So there's a lot of stakeholders in this process, and by default it is essentially an open process. Right. The idea is that this is very inclusive, so anyone can submit an idea and hopefully anyone will be able to get traction for the really good ideas and it will be implemented at some point. I think one of the challenges here is that there are a lot of ideas, there's a lot of good ideas, but there's a pretty finite set of resources in terms of how many people can create test vectors, how many node developers are there, and things like that. So there's a limited amount of time to actually iterate on these ideas, which is something that the rest team is working on trying to make easier with the SDK, for example. So the process simplified is you get an idea, you submit an eap, anyone can do this.
00:02:23.530 - 00:03:30.758, Speaker B: Then you gather support, which arguably is one of the more tough parts of the process. Again, because there's not only limited supply of work and testing, there's also really a limited amount of mind share. So making sure that even if you have a good idea that it bubbles to the front and people are talking about it and thinking about it is pretty tough. And I think there's a bunch of different channels for this. I think most of the bigger uaps usually end up building a website and then usually also attach a meme to it of some sort, which is a really fast way to spread or to get mind share of your idea. What happens is once it gets support, usually there will be some sort of working group, for example, for Virkl there's a working group, they're building tests or building devnets. They're figuring out the details of how workload is going to work.
00:03:30.758 - 00:04:24.484, Speaker B: And it was the same with EUF and it's the same with most of the bigger eaps. Then these things are discussed on ACD, which is a biweekly call. Not biweekly as in two times a week, but as in every other week. And there's one for El and one for CL and they're kind of shifted. So one week you'll have ACD for the execution layer and then you'll have one for the consensus layer on ACD. Again, this is actually open, people will usually go over ok, what are the updates, what have we done, what's interesting? And then what are our concerns regarding specific eaps? And this is also where usually we try to reach consensus on what should go in the next fork. Once the next fork is sort of settled, we build devnets.
00:04:24.484 - 00:05:16.600, Speaker B: These are also publicly available and we test them. The devnets are like crazy. Like when I started on ref, I honestly didn't think there was as many tests and tools as there as there actually is. I was at Interop in Kenya earlier this year and I learned so much about kurtosis, which is like if you haven't used kurtosis and you're interested in client development, please go look at it. It is insane. And shout out to eth panda ops for this tool. And then after the devnet and things are stabilized and fast and everyone can reach consensus on the network, you end up doing a network upgrade.
00:05:16.600 - 00:06:05.910, Speaker B: So what is a coredev? Again, pretty nebulous. If you want to be super strict it would be anyone who contributes in some sort of fashion to client software that can sync to the latest block. But in practice it's a lot more inclusive. Right? Like researchers, in my mind at least, are core devs. But then you can ask okay, like which researchers? Teams that produce test fixtures and infrastructure are arguably also core devs, but again, which ones? I think it's more like a social consensus thing. I think maybe at some point you just get the vibe that oh, I think people think I'm a core dev and I think that's about it. So what's in Pectora Pektra is a pretty big upgrade.
00:06:05.910 - 00:07:10.288, Speaker B: First we have 7700 two, which I'm really interested in. It's the current account abstraction proposal and it essentially allows you, or it adds a new transaction type that allows you to use your eua as a smart contract so you can delegate, sort of like a delegate call. If you're familiar with the EVM, you can delegate your eua to use the bytecode of another account. And this used to be transient, but now it's like permanent in the sense that once you delegate, it's always delegated until you explicitly decide not to delegate anymore. So why did we go for a 7702? If you've been around in space for a long time, maybe you remember account abstraction talk in 2017. It's been on everyone's mind for quite some time, and there's been a lot of proposals. Even in Pectra we actually had, I think it was 3074, which was then replaced by 7702.
00:07:10.288 - 00:08:20.340, Speaker B: Because it's simple. That's the key phrase is like, how do you point with this? Wow, it's simple. And I think that's pretty important, both because that means it's simpler to test, it's simpler for users to grunk about, and it's easier to implement, and it allows all the crazy things. It allows transaction batching, account recovery, privilege de escalation, social recovery, multisix, really anything. And I'm curious to see if anyone is hacking on this here, and if so, please reach out to me or anyone else who knows about this and also let me scan your card so I can win the leaderboard. And then the next thing in Pectra is EUF, which is you can think of it as like a versioning for bytecodes. So it's a container format where it has a version and then it has sections much like a normal executable on an operating system.
00:08:20.340 - 00:09:16.500, Speaker B: And it allows a bunch of nice things like static, it introduces static jobs, there's changes in some behaviors, it's easier to deprecate instructions, and it's easy to extend in the future. Imagine you could add a new UF version with new kinds of crazy bytecode or new kinds of instructions and things like that. And the use cases are VMsheen better static analyzers. Probably also easier to create debug formats for this. For dev tooling, it's easier to analyze with JIT, there's no stack to deep, and we might be able to also with some additional work, remove the contract size limit and a lot more. So this is just for the execution layer. There's also a bunch for the consensus layer, but I'm not a consensus dev, so I won't have pretend like I know too much about that.
00:09:16.500 - 00:10:10.142, Speaker B: We're adding BLS precompiles, which is for signature aggregation and things like that. I'm not entirely sure myself. I was trying to think of, ok, what are some really cool things you could hack on here? I'm simply not creative enough to know what you can use BLS for. I'm sure people are like, there's some really smart people here. Who knows? Then we also added 29 35, which just stores a window of block hashes unchained. So this was originally going to change the block hash opcode, but that was pushed back on because it would make it more expensive and it wasn't really clear what the immediate use case was for it right now. But this is essentially preparation for vertical, the 7605, 7002 and 7251.
00:10:10.142 - 00:10:59.060, Speaker B: Or let me point with this, these are mostly in my mind like code organizational things. So we've essentially created a general way for the execution layer to talk with the consensus layer, which allows us to do consensus exits for validators. On the execution layer, it was also used in 7251, which increases the max effective balance for validators and allows you to consolidate multiple validators into one, which should be cheaper. So what's next? Or what are we excited about? So I guess you can't really see it. Everyone knows this picture though. I think this Vitalik's nice roadmap. I would say that we're in a pretty good spot.
00:10:59.060 - 00:11:52.180, Speaker B: Pretty much everything on this roadmap is being worked on in some shape or another, and there's like good progress across the board. Verkle is, I think, progressing pretty nicely as well. Yeah, I think in general we're in a good spot, so we might. Some things I'm really excited about is gas limit and repricing. We want to go really fast, which means we need more compute in the blocks, which means more gas giga gas teragas. So we might need to increase the gas limit if it makes sense. And I think there's a really great series of blog posts here by Georges and Storm, I believe, on how to raise the gas limits.
00:11:52.180 - 00:12:52.670, Speaker B: And it goes into all the limitations, like why is the gas limit as it is? It's both compute, but it's also state growth, history growth. And I highly recommend you read that if you haven't already. I also think there's a talk tomorrow called ref benchmarking, which will also go into some things about how we might be able to reprice instructions. How do we actually do that from a more data standpoint, rather than doing some benchmarks in isolation and just kind of going with it? Then there's vergil for L1. It's a bit unclear if it's the best for statelessness, but it's definitely a candidate. Personally, I think it's very complex to swap the state commitment live, so I'm not too keen on that. And there are also interest in alternatives for l one, like alternative state commitments that might also give us statelessness and might be good for CKD.
00:12:52.670 - 00:13:29.550, Speaker B: But on L two, Verkle is actually super interesting because you can do something called a shorted fault prover. Imagine that you have an l two. You're going really fast, like multiples of giga gas. As a fault prover, you would need to catch up or keep up with the chain while also doing some complex computations. If you use vertical where it's stateless, you could shard this process. So if you had a range of 100 blocks, you might want to do fault proves for, you could short it between 100 different fault provers because it's stateless and it's possible. It also helps on other things.
00:13:29.550 - 00:13:33.510, Speaker B: And that's it. Yeah.
00:13:39.930 - 00:13:45.070, Speaker A: All right. Any questions for Oliver IPS process points?
00:13:45.370 - 00:14:00.710, Speaker B: Oh, I also want to say if you have any questions on the erps in Pectra or any erps in general, like feel free to find me and we can talk about it. Yeah.
00:14:05.330 - 00:14:06.910, Speaker A: Well, Henry then, Sam.
00:14:11.450 - 00:14:40.534, Speaker C: Thank you for the presentation. I'm just curious about the process. From the moment you had this idea of creating roth, and then the moment is starting, getting more stable and you went to version one. I'm curious about what is this whole process of building a new Ethereum client and how do you get there? Because there's so many different clients that already exist, so many different teams, their team, foundation, etcetera. How do you get there?
00:14:40.662 - 00:15:36.386, Speaker B: Great question. It was actually tough, mostly because one thing I will say about this core development process is it's very distributed, which is nice, and it's very inclusive, which is also nice. But sometimes it can be hard to find specs for, like, it's hard to find, like there's no unified spec. Right. So if I start from scratch, where do I go? Usually you will read over the ips, but you will also reference what have other people done before me, because the specs aren't everything. There's a lot of de facto standards as well in Ethereum, so it was tough and we had a lot of issues getting started. But you persevere and you ask questions essentially, if you're unsure, every core dev ever is super happy to explain to you how every part of the stack works.
00:15:36.386 - 00:16:13.434, Speaker B: They're very passionate about it. So that was a great help. I think it was not only a team effort from the people who built with. It's also a team effort from the community at large, welcoming us and being willing to help us build with how long. So we started. Was it late 21 or something? Or late 22? Yeah. And in December of that year, we all met up and we were like so sure that we were ready.
00:16:13.434 - 00:16:42.604, Speaker B: Like we were almost about to sync and they would be awesome and then we could like optimize and everything. That was not the case. We had a lot of issues, stateroute issues, peering issues. I think it took an additional six months after that to have something that actually would sync. It was, I would say for an alpha, pretty stable, but we were still learning a lot of things. So it was not the most stable. And from alpha to 1.0,
00:16:42.604 - 00:16:45.040, Speaker B: I think an additional six months or something like that.
00:16:46.420 - 00:16:46.932, Speaker A: One year.
00:16:46.956 - 00:16:49.076, Speaker B: I think one year because we did.
00:16:49.108 - 00:16:54.492, Speaker A: Alpha 1 June 2023, then Beta February 24 maybe.
00:16:54.516 - 00:16:55.958, Speaker B: I'm thinking from alpha to beta.
00:16:56.044 - 00:16:56.594, Speaker A: Yeah.
00:16:56.722 - 00:17:01.270, Speaker B: And from beta to 1.0. Another flyer like a few months or something.
00:17:02.410 - 00:17:16.310, Speaker D: Hey, thanks for the talk. Yeah, over here. Sorry. You mentioned there's some alternatives to verkle kind of emerging. I was wondering what they are and do you have any hot takes? Do you think VRKL is going to get dropped and replaced with something else?
00:17:18.210 - 00:17:59.636, Speaker B: I don't know exactly the details of the alternatives. I've heard that Merkle is not super good for CK and that there's been a lot of progress on CK with actually Merkle tree. So it might be that we don't do anything in terms of will Verkle get dropped? It's hard to tell. Like I'm saying, there's a lot of good progress on it and there is. And there are like functioning devnets, but it's not like it's coming out in a few months or something. We're talking maybe the next hard fork or the hard fork after that. I'm not sure if it will be dropped.
00:17:59.636 - 00:18:09.200, Speaker B: We'll see from here to then when we're cfiing it for the next fork. Yeah.
00:18:18.310 - 00:18:32.406, Speaker E: Based on your first hand experience and conversations on the ground, what do you think the readiness is right now for pectra among the different clients? And rest specifically and particularly Eof? I'm really curious where that sits.
00:18:32.478 - 00:19:08.080, Speaker B: Yeah. So right now Pectra is tested in two separate kind of loops. You have picture without Eof and then you have picture with ef. I would say the picture without Eof. I'm feeling pretty confident about it. It seems like for the current iteration of the Devnet Devnet two, we did have a few issues, but they didn't seem too major and people were pretty fast to fix them. I guess we'll see on Devnet three, but generally I'm feeling pretty good about the state of Pectra without euF.
00:19:08.080 - 00:19:35.680, Speaker B: For EUF, it seems like. I know Rhett is ready. It seems like there's still some work to be done from some other teams. And I mean, it is. I would say arguably UF is probably the biggest part of Petra because it is not one eap, it's like multiple. So as for the readiness of UF, I'm not too sure. And there is talk about maybe delaying it and pulling it out of Pectra.
00:19:36.780 - 00:20:06.240, Speaker E: Yeah, it's a story we've all been through a couple of times now. Thank you. Small follow on 7702. I know there's been a little bit of back and forth on how the transaction noncing is going to be handled and some of the minor details around it. Happy to see something simpler getting proposed, but do you have a take on if those minor details have been worked out?
00:20:07.020 - 00:20:56.780, Speaker B: It seems like generally there's consensus that the spec is in a good state. I think there's still room for discussion around how the nonce works. Not necessarily for the authorization itself, but I think personally I'm a bit worried about the fact that currently you have this invariant where your nonce only gets bumped if you send a transaction. But with 7702, when you delegate an account for someone, the nonce is also incremented, which makes things like transaction pool design more complex. I wouldn't say it's a deal breaker necessarily, but it's definitely something that I would be willing to. To explore a bit further. Yeah.
00:20:57.360 - 00:20:58.260, Speaker E: Thank you.
00:21:00.280 - 00:21:13.580, Speaker A: We have bindings for so both EOF and 7702, and all the pectoral features are already integrated in foundry and alloy, so it would be useful to get people to try them out over the weekend.
00:21:14.880 - 00:21:31.410, Speaker B: And if you have questions on the mechanics of 7702 after reading a spec, please find me. And even if it's a question on how to use one of our tools for 7702, I'd be happy to help. Good.
00:21:32.390 - 00:22:55.550, Speaker A: All right, give it up for Oliver. Lunch is outside. Be back by 1230 and we'll have the external rest builders talks then, and we'll talk about what we're going to do after two. Thank you all for a wonderful morning. All right, we're back for the second half of the day where we'll have three ecosystem builders to tell us very exciting stuff that they've been building on. Redstack. So part of that first up and clabby form optimism.
