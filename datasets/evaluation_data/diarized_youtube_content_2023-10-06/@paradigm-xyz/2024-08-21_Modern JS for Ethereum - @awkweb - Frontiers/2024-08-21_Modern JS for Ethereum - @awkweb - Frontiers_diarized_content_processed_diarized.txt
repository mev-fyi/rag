00:00:00.880 - 00:00:40.910, Speaker A: Thanks for coming everyone. Super excited to have the only JavaScript typescript talk here today, so strap in, it's going to be a fun one. Usually when I give a talk, I like to go back and look at some historical things that went on, especially in Ethereum. Everything changes very quickly. And in the JavaScript world, there was this talk by nosensmeister of Uniswap fame where he was talking about like building apps at an ETH global event in New York in 2019. And modern back then, according to him, which. Getting definitions from other people is always the move.
00:00:40.910 - 00:01:35.438, Speaker A: You don't have to define stuff on your own. Yeah, dapps being very responsive, feeling alive, they're connected to blockchain, so having really good data and in your apps, making things feel up to date is really good for UX, really good for correctness. Like, you click a button, you get a quick response, stuff like that. So that's kind of like the frame in which we're going to view everything we talk about today. Yeah, and so the reason I decided to talk about modern j's stuff is we're getting close to the end of 2024. We're at like a conference that focuses on high performance bleeding edge software. So I was like, okay, what's bleeding edge today in the JavaScript world for Ethereum? And yeah, there's no better way than kind of taking a look at some history.
00:01:35.438 - 00:02:12.882, Speaker A: I think the history technology is really important. You know, when we build tools, it's really nice to understand the context of where things have been in the past. It helps you measure progress between different iterations and you know, maybe most importantly that someone said last night, if you don't respect your house, it will fall on you. So you can try to figure out who said that. But yeah, I just think it's really cool to look because, you know, a lot of the trends are the same. Like if we think about cars, it's like these are both like, you know, supercars. At the time, the one on the.
00:02:12.906 - 00:02:15.594, Speaker B: Top was like the best, but obviously.
00:02:15.642 - 00:02:27.026, Speaker A: No longer, but it still has a lot going for it. So yeah, a little disclaimer, this is not going to be comprehensive. I sort of like got involved, joined Ethereum in like late 2020.
00:02:27.098 - 00:02:29.410, Speaker B: So a lot of the historical stuff.
00:02:29.490 - 00:03:17.892, Speaker A: You know, if it was still around by then, I like have used it. But a lot of the things that were, you know, like 2014, 2015, like the back catalog maybe some of you have experience with, but I unfortunately wasn't able to play around that stuff directly at that time period. And yeah, if I missed something super down to hear more about it, probably not in the q and a like I put down here, because they have to be questions, not statements. But yeah, we'd love to chat, learn more about everyone's experience. So yeah, let's turn back the clocks real quick before we jump forward into the present and talk about modern day. April 2015, Web three js had its first major version. I'm sure a bunch of people have.
00:03:17.916 - 00:03:19.436, Speaker B: Used web3 js, whether it was.
00:03:19.468 - 00:03:39.812, Speaker A: In 2015 or more recently. Something that's really interesting with the context for web3 js is that while it was released 2015 April, the first commit was back in September 2014, which is wild. Ethereum wasn't in production yet for Mainnet.
00:03:39.876 - 00:03:40.840, Speaker B: Typescript.
00:03:42.900 - 00:04:25.230, Speaker A: Hadn'T even had a first version yet. The first commit for typescript was July 2014, if I'm remembering correctly. So very different world that this project was started in, which is really interesting to see where it's come to today. I guess next on this tour is something called Ethersim. Has anyone used Ethersim back then, or. Yeah, not super surprised, but Ethersim was really important because it kind of laid the groundwork for like a lot of future things. Ethersim was like a JSON RPC library you could use for testing or like in development.
00:04:25.230 - 00:04:44.862, Speaker A: It's kind of like test your changes in JavaScript and this kind of evolved further. Truffle suite came out of here, Ganache came out of here. So really cool that people were thinking about that not too long after Ethereum launched there and then, yeah, cut forward.
00:04:44.966 - 00:04:46.006, Speaker B: A couple of years.
00:04:46.118 - 00:05:53.440, Speaker A: Ethers J's, I think was a pretty big improvement on the web, three js of the time. And even if it wasn't, it was a different API, it was a different approach to problem solving, introduced things that were pretty interesting, like human readable abis and stuff like that. Performance was improved, and then on top of that there was type chain, which, you know, typescript has been around for a few years at this point, and there's like, you know, a bunch of JavaScript developers are starting to realize that strong types are, you know, pretty great. And so type chain made it a lot easier to then take your abis with your contracts and then spit out like a typed SDK, which then you can use to call whatever functions or listen to events. And it introduces a degree of precision and correctness that didn't really exist in the JavaScript world before. And especially with Ethereum, it's kind of dangerous. You might pass a value that is a much larger value than you want for a number and transfer things incorrectly.
00:05:53.440 - 00:06:25.242, Speaker A: Yeah, 2018 maybe building on some of the things from Ethersim fiddler comes out. Has anyone used this before? Oh, nice. We got one person at least. Yeah. And this was I think pretty important improvement for developers. It was like you could start building smart contracts and you didn't have to compile stuff on your own. It was like a whole framework built in JavaScript, a precursor to foundry in many ways.
00:06:25.242 - 00:06:30.630, Speaker A: And builder will come back up here in a couple of years. Down the line.
00:06:31.170 - 00:06:34.630, Speaker B: Web three webpacked is our first foray.
00:06:35.050 - 00:06:48.300, Speaker A: Maybe into more front end app specific related tools. If you're not familiar with Webpack, it's a bundler for the web that allows you to take some code, maybe it's.
00:06:48.420 - 00:06:51.556, Speaker B: JavaScript or typescript or some assets, svgs.
00:06:51.588 - 00:07:55.098, Speaker A: And then spit out a built bundle that maybe transpiled the typescript of JavaScript or minified the svgs or some other stuff. Web three webpack was a way to hook into webpack projects at the time and have an ethereum provider you could use. And a lot of this, I guess the order of this, you know, they came out around the same time. But eip 1193 was really important along this journey because, you know, it took like this chaos of like people shoving providers onto window Ethereum and kind of like standardized what an Ethereum provider API could look like, which then allows people to build a lot more cool things like wallet Connect kind of like came out around the same time, which is again like, I think a lot of people take it for granted today, but I mean I take it for granted today because I wasn't around pretty wallet connect, but it allowed you to like bring mobile into the equation and yeah.
00:07:55.114 - 00:07:56.714, Speaker B: It was like pretty big step forward.
00:07:56.882 - 00:08:29.770, Speaker A: Wallet Connect widget now is called web3 modal, but this was kind of like the first attempt at a Connect walleth modal, which like, you know, I think starts, you start to see like people get more into like the UX side of crypto. Clevis and Dapparatus. Has anyone ever heard of these tools? Yeah, you probably didn't because I made them up. I'm just kidding, I didn't. They're real. No, but these were like really cool tools. You know, I wasn't aware of these until I went digging back through the history.
00:08:29.770 - 00:08:43.758, Speaker A: Clevis was a way to run a node and do a bunch of changes to that if you wanted to go in and change the gas limit or.
00:08:43.814 - 00:08:45.090, Speaker B: Other type of stuff.
00:08:45.550 - 00:09:34.846, Speaker A: Apparatus was higher level components that you could use building a react app or something. So web3 webpack becomes web3 react. Noah Zinsmeister from earlier worked on web3 webpack, kind of formalized it more into web3 react as like work on Uniswap, like the OG, or like one of the most well known Dapps was getting worked on. And Scaffold eth is kind of like this iteration on Clevis and dapparatus, which I think a lot of people, me included, would get started with at like a hackathon or just like, you know, as a quick way to get building. Biddler becomes hardhat. And so it's really interesting, you kind of see like initial versions of these.
00:09:34.878 - 00:09:37.398, Speaker B: Tools get released because there was like.
00:09:37.414 - 00:09:49.148, Speaker A: A need, someone needed this functionality to build. And then you kind of see them like, you know, a bunch of people use them because there was nothing that existed. They're really good boon for productivity. And then you kind of see like.
00:09:49.254 - 00:09:50.968, Speaker B: Maybe like a year or two later.
00:09:51.104 - 00:10:14.140, Speaker A: Like another iteration on top of them. You learn all the mistakes that you made in the first version of the API. And hardat, I think a lot of people got started on it, works really well at the time for working networks and stuff like that. And so this is kind of like what the 2020 frontier looked like.
00:10:15.490 - 00:10:18.386, Speaker B: Got a couple JavaScript libraries for doing.
00:10:18.418 - 00:10:56.484, Speaker A: Lower level stuff, which is nice to have options. Maybe you don't like how one thing does something, or there's a bug, you can fork Mainnet, which is really great for quick iteration and development. With type chain you can code gen types, and you get all the benefits of typescript. In that way you can hook into react, which is important for building apps. Yeah, you have like a connect wallet modal, so you can get started. You don't need to build that stuff from scratch. There's like a bunch of quick start stuff in the ecosystem where you can get really quickly started at a hackathon or prototype, an idea which is really valuable.
00:10:56.484 - 00:11:42.360, Speaker A: And so this landscape is actually pretty incredible. Like there's ecosystems in crypto that don't have all these things today. So the fact that Ethereum had these in 2020, in these versions, it was pretty impressive. Yeah. So I got involved in late 2020, 2021 was building apps. And I think the big thing that was missing coming from more of front end worlds in web two stuff where there's a bunch of great libraries, bindings for react, and building user interfaces and stuff like that was something that was a little more stable. So I worked on wagming just as a side project.
00:11:42.360 - 00:12:06.752, Speaker A: I was wondering if there was some way to standardize and make things better. So it's a react hooks library. The most important thing for me was just having robust wallet connection using some other tools in the past for app development, it's like maybe there'd be a bug where you'd switch networks and then it would just randomly disconnect you or stuff like that. And that just wasn't a very good user experience.
00:12:06.856 - 00:12:09.900, Speaker B: So yeah, it supports all the usual suspects.
00:12:10.200 - 00:12:18.280, Speaker A: You can also plug in to other, you can write your own connectors and plug in there back in 2022.
00:12:18.320 - 00:12:18.900, Speaker B: Also.
00:12:20.600 - 00:13:27.108, Speaker A: The other thing too is there was just a lot of duplication in codebases. I'm pretty sure most projects that got started around this time would just go to Uniswap's codebase, copy all of the react hooks for Ens related stuff like sending transactions, signing whatever, and just pop them in their code base. So this just tried to standardize all the features that you would want to do in your app. The other thing that was really nice, at least as an open source author is in the past a lot of people would for more front end related libraries would test, would like mock a bunch of the other dependencies to their tests. And so at this time we started using hardhat forking for our tests. Eventually we switched to anvil, but this made it really easy to then reproduce issues and ship quickly without breaking things. So yeah, and then once Wagme was released, we started seeing a bunch of these pop up Rainbowkit, which a bunch of people here probably have used or seen before.
00:13:27.164 - 00:13:28.164, Speaker B: It was probably one of the first.
00:13:28.212 - 00:13:52.950, Speaker A: Libraries that built on top of Wagme. This is like the new modern web3 modal, but they had another iteration on that. Now we have libraries that do sophisticated account abstraction, smart contract, wallet related stuff, which is pretty cool. Improving ux.
00:13:53.100 - 00:13:54.670, Speaker B: There's like lots of these.
00:13:55.690 - 00:14:04.710, Speaker A: It's probably one of the most interesting spaces to look at. I feel like a lot of them copy features from each other. A lot of people create new features that are interesting.
00:14:06.050 - 00:14:08.310, Speaker B: Yeah, so there's a lot of cool stuff there.
00:14:09.010 - 00:14:49.816, Speaker A: So yeah, Wagme was released, but it didn't really have any answer for type chain at the time. You could use like Wag me's hooks for reading from contracts from like sending transactions, but you still had to like, you know, know what the inputs were for, you know, the contract that you'd be calling. And you could run into a situation where it like expects like, you know, a different value type and you give it another one and, you know, catching that at compile time was like an interesting idea, but didn't really know if it was possible. So worked on this library called ABI.
00:14:49.848 - 00:14:52.152, Speaker B: Type, which powers all of the type.
00:14:52.176 - 00:15:09.264, Speaker A: Inference and safety in WagMe and VM these days, and wasn't actually possible before September 2022 because typescript released this specific version a month prior, which allowed you to do some more crazy stuff with the type system.
00:15:09.352 - 00:15:11.104, Speaker B: But what ABI type does is really cool.
00:15:11.152 - 00:15:31.022, Speaker A: It takes an ABI, it also works for vip 712 type data, and it's able to like in the typescript type system, then infer function names, event names, which is helpful. Maybe you misspelled something, it catches that. It allows inferring different argument types, which.
00:15:31.046 - 00:15:33.878, Speaker B: Is helpful because if you forget a.
00:15:33.894 - 00:16:14.840, Speaker A: Certain value, it will kind of tell you and warn you ahead of time. Also responses it will do that is really robust. It works really well for even super complicated Abis like deeply nested tuples that have like arrays with other tuples inside of them, and it can pull out the different names of the properties and stuff like that. It also does pretty wild stuff like say you have two functions that are overloads of each other, depending on what parameters you pass in when you call the function. It's able to infer and narrow the return type.
00:16:16.020 - 00:16:17.300, Speaker B: So yeah, this is just like really.
00:16:17.340 - 00:16:27.868, Speaker A: Fun low level thing that powers a lot of the developer experience that we have. And so Wagme was originally built on ethers, which was great for getting started.
00:16:27.964 - 00:16:30.612, Speaker B: But for the web, which is the.
00:16:30.636 - 00:16:42.798, Speaker A: Context that wagme is used in, it kind of like demanded a little bit more out of the lower level library that it used. And so yeah, ethers is a bunch of classes, which is fine if you.
00:16:42.814 - 00:16:44.246, Speaker B: Like classes, go for it.
00:16:44.278 - 00:17:18.876, Speaker A: I think in the context of a modern web architecture that's tree shakeable and stuff like that, having a bunch of composable functions which you're able to remove if you're not using them in your code was really good. So yeah, our main goal with VM was to kind of like have an updated library that focuses on just like the building blocks that you need. You don't have to buy into like a specific opinions or structure for things, how things work. Most of the functions in VM and.
00:17:18.908 - 00:17:20.436, Speaker B: The way it works is just how.
00:17:20.468 - 00:17:24.714, Speaker A: It was written in like eips and various specs.
00:17:24.852 - 00:17:26.030, Speaker B: So yeah, this was like a big.
00:17:26.070 - 00:18:07.400, Speaker A: Exercise in reducing bundle size to try to improve websites and push developer experience further by adding ABI type to a lower level library. It also does some other cool things like has built in multicall support. No matter what chain you're on, if the chain supports multicall three, that works also just some other optimizations like it uses modern contracts that web3 and ethers didn't use like Ens universal resolver. So it was able to resolve and look up with like one RPC call instead of, you know, three or four, depending on what you're, I think the mic.
00:18:12.020 - 00:18:12.500, Speaker B: Test.
00:18:12.580 - 00:18:54.830, Speaker A: Oh no, I guess it's back working. Sorry, I don't know what I did. And yeah, has like built in anvil support works really well for that. So yeah, if you're using JavaScript and Anvil and you're trying to like, you know, set up some tests, maybe you're running end to end tests and you're using Anvil as like the backend for that, you can kind of like reset the network or you know, do whatever via VM and Anvil. So yeah, kind of like what we have been working on until now is we released like the second major version of VM and WAgMe. Wagme was like significantly reduced in scope.
00:18:54.910 - 00:18:56.326, Speaker B: So it really just is like a.
00:18:56.358 - 00:19:04.270, Speaker A: Thin reactive wrapper around VM now. Plus support for all the different connectors, which makes things a lot easier and.
00:19:04.390 - 00:19:06.142, Speaker B: A lot of cases it's like the.
00:19:06.166 - 00:19:39.200, Speaker A: Core of Wagme that you want to use is like the wallet connection and account management stuff. And then if you need to eject and to VM it's like really easy to do some more custom low level stuff. This was just something that we thought we should do was add support for another framework. React is still by far the most popular one in crypto. There's a bunch of projects, especially in Asia, that use Vue JS instead of react. So we figured we'd add it and kind of extend out into different libraries. Probably at some point we'll add svelte like adapter.
00:19:39.200 - 00:20:33.872, Speaker A: There's a bunch of other frameworks that maybe we'll consider at some point, but I think Svelte is next on the roadmap. VM's chain type is really cool, I guess similar to the previous talk alloy where it's talking about like the network types and how those kind of like determine the behavior of the library. Internally, VM is very similar. It's like the chain types are kind of like an inversion of control where they can define like their own custom rules for formatting a transaction, serializing it, whatever is specific to the network and that allows us to not have a bunch of if statements inside of VM and custom code, which works really well. We really strongly typed errors for VM recently. In the typescript world you don't really have strong error types. It can be anything, it can be thrown from wherever.
00:20:33.872 - 00:20:45.872, Speaker A: And this is kind of like an attempt to try to wrangle some of that, especially when you're calling RPC methods. You might get some esoteric error from a node, and we've tried to wrangle that together to make it a little.
00:20:45.896 - 00:20:49.176, Speaker B: Bit easier to either surface that error.
00:20:49.208 - 00:21:44.822, Speaker A: Up to a user in like an understandable way, or be able to like, you know, handle it in some more controlled fashion yourself, like recovering from it, retrying things like that. Another cool one that I don't think a lot of people know about is you can have your own deploy list reads, either via bytecode, which I'll go over in a sec, or a factory that's already deployed. Another really popular feature of VM is this ability to extend VM into whatever other features you want. You can basically call client extend pass in some additional functions to be defined, some values, whatever else. And there's a few first party VM extensions. We have one for account abstraction which.
00:21:44.846 - 00:21:47.662, Speaker B: Was released recently, the op stack, which.
00:21:47.686 - 00:22:36.052, Speaker A: Was a little while ago in Zksync, and it's really cool. You can build full on SDKs or other libraries. Basically on top of this, a lot of people have ones that use the internals of VM, but then expose whatever they have going on that's unique. We also have a bunch of experimental extensions under the VM experimental entry point, which is just a good proving ground to dump out a bunch of stuff that people might be interested in. So I would check that out and yeah, I think kind of like what we're working on now and for the future is like making sure this stack works really well with the alpha net that some people have talked about over.
00:22:36.076 - 00:22:37.360, Speaker B: The last couple of days.
00:22:38.340 - 00:23:34.126, Speaker A: And I think it's like an important component, because if features aren't in these JavaScript libraries like they often aren't used by app developers. And so by connecting Alphaneta to apps with Wagme or VM, hopefully it will be an exciting ecosystem where people are just trying a bunch of things out that you can send via URL to someone, they can test it out, as opposed to someone just being able to see something on the CLI or whatever. So yeah, where we are kind of like right now is we got a bunch of lower level libraries. I think there's a bunch of great things with hardhat in Anvil where you can fork and build your dapps. On top of that. I think we moved more towards static types instead of codegen.
00:23:34.238 - 00:23:39.438, Speaker B: It's just easier to set up. It just works with typescript, which a lot of people are using.
00:23:39.494 - 00:24:04.024, Speaker A: You don't have to run a separate CLI step. We have a few different, or a couple different front end frameworks that you can plug into. Wagme also works with vanilla J's, so you're welcome to use it with anything else. We have like a bunch of connect wallet modals. You can try out all of them. Since they're all built on Wagme, it's like pretty easy to switch between them, which is convenient. Got a bunch of quick starts and components.
00:24:04.024 - 00:24:08.696, Speaker A: I feel like the hackathons these days, like people are able to move really quickly and get started just because.
00:24:08.728 - 00:24:10.888, Speaker B: Because the stack is very obvious, what.
00:24:10.904 - 00:25:02.640, Speaker A: You'Re going to use, how you're going to build things. And yeah, there's a few other things that I wanted to share, but first, referencing back to this in order for things to feel alive and responsive and feel like you're connected, one of the most important things is data, which is why it was interesting to see Storm's talk earlier. And yeah, apps need data to have good experiences. That's like the one bullet point on this slide. And there's a few different libraries out there that I think are interesting that approach this in different ways that are, you know, some of them are more experimental than others. One of these libraries is called TevM, a bunch of EVM plus letters and yeah, Tevm's a really ambitious, cool project. It does a bunch of things.
00:25:02.640 - 00:25:07.128, Speaker A: You can execute an EVM locally in the browser, which potentially is really cool.
00:25:07.184 - 00:25:09.392, Speaker B: Just like xxs are really useful for.
00:25:09.416 - 00:26:05.598, Speaker A: Plugging directly into a node so you don't have to worry about network and serialization deserialization. Potentially being able to execute EVM locally in the browser, doing simulations and stuff like that potentially speeds things up. And also with node or demo or bun as well. I think one of the most interesting features is you can import solidity directly into typescript. Why do you want to do this? I don't know why not? I'll show you in a sec. And this enables something really cool, which I think the author of this library will calls bring your own view function. So yeah, imagine that you want to read the balance of a specific owner of ERC 721 in VM right now you do something that looks like this, pretty straightforward.
00:26:05.598 - 00:26:37.024, Speaker A: You get all the type, safety and stuff. The downside of this is it's two RPC calls. You need to get the owner, and then once you have that owner, then you need to plug it in and get the balance. Not a huge deal. But imagine if you're doing this a lot in your app, or if there's multiple steps in between. So instead of two RPC calls, you need to do ten because you need to resolve a bunch of stuff and then mash it together. Doing this directly in JavaScript is more expensive.
00:26:37.024 - 00:27:21.556, Speaker A: In time, it costs RPC credits, all this stuff. What you can do instead with Tevm is you can write your own view function. This one's called avoid like the request waterfall where you batch up all this stuff into like solidity function and then you're able to import that into your typescript project via tevm. It does like some bundling and stuff behind the scenes. And then on the second to last line, which I guess you can't, that's a bummer. Is there any way to move up the screen? Oh yeah, that's a good idea. Okay.
00:27:21.556 - 00:27:29.292, Speaker A: Anyway, what is missing there on the bottom is you're passing bytecode to the Vm read contract function, and that byte.
00:27:29.316 - 00:27:31.220, Speaker B: Code is like the compiled byte code.
00:27:31.300 - 00:28:03.980, Speaker A: From the balance of owner of functions. Then you're able to get all this stuff in one RPC call and do a bunch via the deploy list reads and calls that VM has enabled, which is kind of cool. Another project that's interesting right now I think is ponder if you haven't heard of it. It's kind of like this all in one back end framework for crypto apps written in JavaScript on top of VM. And it has a pretty good developer experience.
00:28:06.180 - 00:28:07.892, Speaker B: Really what you do is you set.
00:28:07.916 - 00:28:23.396, Speaker A: Up your config file and what you want to list here is any networks or contracts and stuff you're using, and you can create a schema for it. These are tables which either post grace.
00:28:23.428 - 00:28:25.804, Speaker B: Or sqlite, whatever the data will be.
00:28:25.812 - 00:28:31.404, Speaker A: Getting saved into for you to query later. And yeah, maybe not as fast as.
00:28:31.452 - 00:28:34.078, Speaker B: A rust CLI, but it's pretty fast.
00:28:34.214 - 00:29:13.374, Speaker A: You can just like sync up and index a bunch of data. And then there's a couple options. Either you can query that data directly via API functions that they have set up, or you can just like listen to new events as they come through and have some like custom logic. Maybe you send out like a notification to a different service. Here we're just saving it to like a database which you can reference later. This is all just like I think this is frontech related stuff. Another project which is doing some pretty cool things in the similar vein to ponder is mud.
00:29:13.374 - 00:30:25.168, Speaker A: Mud is a project that I think is all about high performance applications, primarily used in gaming and stuff like that. But a lot of these concepts can also come in to what people are working on in their normal apps. And because it uses the entire stack with VM and ABI type, you get all the strongly typed stuff involved in there. One of the really cool pieces of it that's unique is real time updates that you get. Similarly to ponder, it's like you define your table structure and set up, you create some methods to call into here. This is just for a simple counter contract, and then you have a component where you can just read directly from that value and then it updates in real time behind the scenes with some of the infrastructure that they've built. And this is incredible because front end developers and I think more JavaScript developers in Ethereum kind of like span, like the gambit in terms of experience level.
00:30:25.168 - 00:31:13.920, Speaker A: Like some of them are super knowledgeable about Ethereum, they've been in the space for a long time, they've used a lot of the tools that listed out before, and some of them are a little bit newer. They're interested in the space, but their skill set is building user interfaces or something. And it's not really about how to index data, how to query it, what the most efficient way, or what RPC methods should I use. This is really cool because you can get real time updates from the chain just by calling a react component and having that set up. That's how the landscape is laid out today. I think we're in a pretty good spot right now, but going to keep pushing and see what else we can come up with. That's it.
00:31:13.920 - 00:31:22.240, Speaker A: Any questions?
00:31:29.220 - 00:31:51.150, Speaker C: Hi, thanks for the talk. So you mentioned now real time data and response, and this is important for the feel of these applications and how VM is optimized for things like tree shaking to make the bundle faster. Have you looked at all using webassembly, either for the core parts of VM or for porting anvil for local simulations at all?
00:31:51.270 - 00:31:53.910, Speaker A: Yeah, we've looked into that a little bit.
00:31:53.950 - 00:31:55.462, Speaker B: Last year I gave a talk that.
00:31:55.486 - 00:32:16.312, Speaker A: Was similar with trying to bring in rust into the JavaScript world, and I think it's really promising. I haven't checked back in on what the current state of things is then, but that whole thought was like the things that people use via typescript that's.
00:32:16.336 - 00:32:17.592, Speaker B: Really valuable is the types.
00:32:17.656 - 00:33:08.360, Speaker A: So it's like if you can write the types in typescript and then you can have the runtime be something else that's really fast, then you could potentially have an incredible developer experience. Yeah, and I think combining those two things together is a little rough. And one of the biggest issues right now is that the bridge to waSm, it takes a decent amount of time. Also, when you're first downloading the code in the browser, it can be a little heavier. And usually a lot of the stuff that you're doing, maybe if you're executing stuff in the browser directly, you don't run into this. But a lot of the things with JSON RPC calls and networking and stuff is the bottleneck anyway. So yeah, I think there's probably going to be some interesting stuff there soon for sure.
00:33:12.260 - 00:33:29.038, Speaker D: Great talk. Thank you. The TevM example that you gave the TevM the balance of ownerov function, how is that different to a deploy list call where you would do an Eth call on chain with a state override where that contract is deployed?
00:33:29.174 - 00:33:36.330, Speaker A: Yeah, I'm not 100% sure how it would be different.
00:33:37.910 - 00:33:38.566, Speaker B: That's a good question.
00:33:38.598 - 00:33:39.750, Speaker A: Yeah, I need to look into that.
00:33:39.870 - 00:33:41.006, Speaker D: Or maybe it's just the same.
00:33:41.118 - 00:33:45.970, Speaker A: Yeah, I'm pretty sure it is, because you're just getting the bytecode passing that in.
00:33:46.630 - 00:34:06.810, Speaker E: The difference probably is that you do the simulation locally versus on the node. Like when you do the eth call with state override, the RPC must support state override, which some do not actually. And when you do it, you're actually running the compute on the server, whereas in the TevM example, the compute, the EVM runs locally, so it's not doing an ETH call in the TevM case.
00:34:07.270 - 00:34:09.090, Speaker D: Okay, cool. Thank you.
00:34:16.879 - 00:34:30.259, Speaker F: Hi. Great presentation. I was just wondering what your take was on how web development is sort of progressing with more rust frameworks. I don't know if you had a chance to look at rust frameworks, but if you had any thoughts on that.
00:34:30.639 - 00:34:38.219, Speaker A: Yeah, yeah, I mean, it is interesting. There's definitely a lot of potential benefits for performance related stuff.
00:34:38.879 - 00:34:40.551, Speaker B: Yeah. Like I talked about a little bit.
00:34:40.575 - 00:35:00.530, Speaker A: Earlier, I think a lot of it is just around developer experience. It's not great right now on the bleeding edge. It'd be hard for most people to build an app using something like that. But I think it's probably coming even just stuff like rendering the Dom faster. You can potentially speed up a lot by using rust.
00:35:08.470 - 00:35:26.580, Speaker G: How do you see the future of front end development? In a sense that is it going to be fully powered by indexers, or going to be a mix of RPC and indexers, or just some maybe more powerful rpcs or something like this?
00:35:27.200 - 00:35:59.516, Speaker A: Yeah. I'm personally really excited about, potentially, people being able to run their own nodes and indexers and stuff and make that more easy with Rothdeh and things like that on the horizon, just because I feel like most organizations, once they reach a certain scale for their apps, it's really hard to rely on rpcs to get what you want, especially when there's the trade off with costs and whatever. So I think the closer you can get things to your own services seems.
00:35:59.628 - 00:36:00.800, Speaker B: To be pretty good.
00:36:02.500 - 00:36:32.720, Speaker A: There's some, like, client stuff, which could be cool, that I don't think has been experimented with a lot in the browser, but, yeah, I feel like a lot of these things is just like, if you're interested, if you want to reach out to us and you want to explore with us, we're happy to, but I think there's so much opportunity just work on new projects on your own that push this stuff forward and then get it in front of people, because people want better solutions than just querying their RPC and mashing the data together.
00:36:43.470 - 00:36:47.970, Speaker B: Okay, next up we have Brian from base talking about ref benchmarking.
00:37:01.400 - 00:37:08.920, Speaker G: All right, thanks, everyone, for coming out on a Saturday, and I know we're getting close to lunch, so probably getting low on.
