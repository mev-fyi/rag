00:00:02.560 - 00:00:54.628, Speaker A: Hello, I'm John Becker, and I'm going to talk about Heimdall. Yeah, it's basically an advanced bytecode analysis toolkit. So what can it do? Well, it can decompile byte code which generate control flow graphs for bytecode, decode arbitrary call data, dom contract storage, and generate bytecode snapshots. I'll talk about what all those mean in a sec, but first I'm going to talk about symbolic execution. So, symbolic execution is basically a complex process of finding all the possible paths that a program can take. So it's pretty blurry, but up there, that's just bytecode. And then symbolic execution will run this bytecode with some call data.
00:00:54.628 - 00:01:39.050, Speaker A: And then every time it encounters a jump by instruction, we'll take both paths, and that allows us to trace what the actual evM is doing. You probably can't see that either, but it's a bunch of assembly. And then in between the assembly are lines and arrows to other blocks of assembly. And this is called the control flow graph. Basically what that means is if you start at that first block, it will follow the EVM and just continue executing things. And this basically represents all the possible steps that the EVM could take. And Heimdall is able to convert that symbolic execution into solidity code, which you also can't read.
00:01:39.050 - 00:02:19.760, Speaker A: Yeah. So now let's talk about what this powers. So this symbolic execution powers the decompile module, the CFG module, and the snapshot module. Let's talk about the decompile module. So, decompilation is the process of converting machine code or bytecode into a readable format like solidity. And we're able to do this from symbolic execution, like I said before. But basically you run Heimdall, put it in a contract address, you don't need to be verified, and it will execute that contract symbolically and then generate an ABI and some representation of the source.
00:02:19.760 - 00:02:58.810, Speaker A: It's very useful for pen testing or finding out what a contract does if it's not verified. Taking it a step back, control flow graph. You've already seen this a few slides ago, but basically it shows every possible path that the contract could take. The snapshot module is new. I added it a few weeks ago. It's similar to decompile, but takes another step back and will only show you relevant information. It'll run things and display gas consumption events, emitted custom errors, storage accesses, modifiers, access control, etcetera.
00:02:58.810 - 00:04:15.542, Speaker A: And it can actually resolve signatures from the four byte directory, which is pretty cool, which is how Heimdall is able to give you the exact ABI of any contract you put in. And then another module that does not rely on symbolic execution is the dump module, which basically will fetch all the transactions a contract has made or been interacted with, and replay them. And then give you a nice TUI format and CSV format of the storage slots within the contract, including things like mapping. And if you could read that, which you probably can't, this is the wrapped ether contract. And you can see the first three slots are wrapped ether, and then the decimals and stuff, and symbol. And then the last module I'm going to talk about is the code, which basically you can put in arbitrary call data or a transaction, and it will decode the call data using the four byte directory. So the first four bytes of the actual call data will be looked up, and then it'll take all those possibilities and attempt to decode them, and whatever succeeds will be the output.
00:04:15.542 - 00:05:17.090, Speaker A: So in this example, which, oh, you can read that this example is just a withdraw, I think it's also from wrapped ether, but put in the transaction hash, you don't need the ABI, it will just tell you it's a withdrawal of whatever the hell that Un is. And you can also explain what the call does roughly using GPT four. Ok, so what's next? I'm going to be working on a monitor module, which basically will just watch the mempool for some patterns and then call Cron or whatever you want it to do whenever something happens in the mempool. And then I have some improvements, like improving symbolic execution because it's rough, and loop detection is very hard. Breaking out of loops is hard. Improving the decompilation output so that you can actually recompile it, or just making it better. Recursive call data decoding, like multicall viper support is also going to be rough because it's different.
00:05:17.090 - 00:05:45.720, Speaker A: And then GPT four powered code cleanup is kind of on the back burner because AI is not deterministic and I don't like that. And then raw trace decoding will also be added. Eventually you can get in touch. This is very short, but it's technical. So if you want to talk to me afterwards about anything, feel, feel free. I also like otters, so there's an otter. Thank you.
