00:00:01.840 - 00:00:47.126, Speaker A: Hi, my name is Franso Garriot. I'm going to present work that's done mostly by Artem Charles Juke, and Mace Penczyk, who's somewhere in the room. Okay, so Nova is the reference implementation for one of the zero knowledge proof protocols that have exploded in the last year and a half to two years, and that are mostly called folding or accumulation schemes. And the general high level idea is that they, they help you make proofs of stuff that you repeat over and over again. Examples include things such as a ZkVM or executing instruction set. We've had a talk that exemplified one of those patterns today. Guess which one it was.
00:00:47.126 - 00:01:38.370, Speaker A: But decryptor is evolving very fast. That is, we have papers showing a new optimal protocol for this every three months, and that's going to come back as a problem. And all the references, the reference implementations are in rust, and we would like to have a verification on the EVM for one of those folding schemes. Sounds simple, right? It is actually not that simple, because the EVM cost pattern is one that has a big uncanny valley in the middle. You have certain ZK roll ups that are on the right here, that have, for time, adopted the approach of biting the bullet of 11 million gas paid on each verification, and then they've improved on it. Ask them. But.
00:01:38.370 - 00:02:27.940, Speaker A: And then you have the small ZK verification, which are the gross 16 plon class of protocols. Can you reduce something that is in the middle? Can we do something that is in the middle? Not only because we would like to, and it's an interesting research questions, but also because the traditional solution to go from the extreme right of this line to the extreme left is to stalk your verifier. That is, instead of verifying a proof, you're verifying a proof that your verifier ran and said that the proof was valid. That's cool, right? Nice idea. You put the verifier inside your verifier. There should be a Min zipit on this slide, actually. But what if your verifier changes? I said cryptographic protocols change every three months.
00:02:27.940 - 00:03:08.420, Speaker A: That's not going to. If we have to rewrite this project every three months, this is not going to work. We're a tiny startup. We don't have enough people to do that. So we are trying to dogfood our own silly ideas. That is, the Nova protocol as it stands finishes with a stock that is not really amenable to Ethereum cost verification. We're changing that stock, we're changing the cryptography so we are ourselves not only receiving the work from the community of cryptographers that is improving folding schemes, but we're revising the cryptography ourselves to make it more Ethereum compatible.
00:03:08.420 - 00:04:14.990, Speaker A: And initial obstacles that we've encountered are things such as the Nova reference implementation requires insanely huge public parameters. It's also implemented on a different curve cycle than what we have pre confiled for on the EVM. So the crypto is wrong, then there's a polynomial commitment scheme that has its own problems, and the compiled contracts are gigantic. And so the idea is, we know we are going to change the cryptography to make it more EVM compatible and then solve those problems. But this talk is not about how we solve those problems. But please do ask me after this talk is about how do you develop a solidity program that is chasing equality and compatibility with the Rust cryptographic protocol, while that rust cryptographic protocol is a moving target. And so some of those ideas are that why we are interested in this is that when it comes to recursion, of course, this improves upon some of the existing cryptographic protocols, protocols that have been used for their knowledge, proof such as hello.
00:04:14.990 - 00:05:00.986, Speaker A: And we're aiming to change the cryptography to make it way more compatible with where ethereum is. So I mentioned huge public parameters. You have to pass a lot of data to your verifier. One of the things that we do with foundry is generating that data on the fly from the contents that we extract from our rest reference implementations. But that data itself is too big. So now we create code generation that allows us to create solidity contracts, implement adding that data to the state, but in morsels, in pieces. That allows us to really dock food.
00:05:00.986 - 00:05:46.460, Speaker A: What the deployment of our eventual contract would look like for that code generation. Even though our initial project is in rust, we're using Python because this is what has given us so far the best development speed for the generation of that contract. So you get the python on the left and solidity on the right. Sadly, I have to report it's kind of the same thing. For the part that I did mention a bit earlier in this talk, such as the crypto, you remember, we were on the wrong curc cycle. So now our solidity verification has to implement operations that are, for one side, on which we're testing, not using precompiles, but reimplementing curve arithmetic. And on the other side, which has precompiles, we're reusing them directly.
00:05:46.460 - 00:07:06.276, Speaker A: A little bit of a problem, but code generation in Python saved us more than the classing in solidity that would not have exemplified the cost that we would get in the final product on the EVM. We even have some extreme data contract that access a lot of data on each iteration. The idea, though, is that the final product looks a little bit like this. We start from a rust program that generates, that has its own parameters and serializes them to JSON, and we use JSON as a data interface between the rust and the python, and all of the validity of our solidity deployment basically relies on that serialization pipeline on which we really hope there aren't any bugs. And it's a little bit sad in the sense that a lot of this is not necessary where our sources in rust foundry is developing. In rust, we would really like to have nicer pipelines for accessing that data without going through rust. JSON, Python solidity, four languages most of the development for what we're doing does not happen on the setup of the protocol.
00:07:06.276 - 00:08:06.860, Speaker A: It does not happen on the data itself. It happens at very specific moments, where essentially what we're doing is generation for a foundry development environment. If you are interested in extending foundry in that direction, please come call to me after so general high level summary. Cross testing the validity of solidity verifier with a rust initial proverb program is hard. We rely heavily on code generation, both for things like generosity, generation of crypto primitives and parameter data, including some of it at testing time. And it would sure be nice to have the hooks to allow this at testing time. Finally, what we've eventually converged to is instead of having this live generation, equipping an unveil node with custom data contracts for the purpose of that testing, Anvil and Foundry have helped a lot.
00:08:06.860 - 00:08:10.340, Speaker A: If you're interested in how they could help more, please contact me after.
