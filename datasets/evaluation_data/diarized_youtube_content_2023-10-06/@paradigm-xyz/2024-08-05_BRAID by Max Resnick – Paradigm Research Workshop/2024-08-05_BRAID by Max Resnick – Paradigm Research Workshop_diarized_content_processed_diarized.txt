00:00:03.320 - 00:00:16.742, Speaker A: Awesome. Yeah. So I think Siamak said that we can't rely on consensus. For censorship resistance. But maybe we can. This is going to be some early stage work. We're calling it braid.
00:00:16.742 - 00:00:44.436, Speaker A: You'll see why it's called braid. I thought it was very clever when I came up with that. It's really early stage joint work with Malesh Pie. Alberto Sonino, who is one of the co authors of the Mississetti paper. And, yeah, venture apologist. I guess I should have said venture apologists might also be in the audience. In this audience and some other people whose names carry more weight than my own.
00:00:44.436 - 00:01:06.686, Speaker A: So we'll leave them redacted for now. Before we finalize the design. So, why is censorship resistance so hard as Siamak alluded to? Because most blockchains are leader driven. And when you follow the leader. The leader ends up with a bunch of monopoly power. They decide what goes into the block. In which order it goes into the block.
00:01:06.686 - 00:01:26.608, Speaker A: And that gives them monopoly power. Which in turn, allows them to extract rents. And those rents can come in the form of stopping you from running your LVR reduction auction. Which is actually the problem that kind of stemmed this whole research direction for us. Was basically me and Elijah. Who were on this original censorship resistance. And on chain auctions paper.
00:01:26.608 - 00:01:52.248, Speaker A: Trying to figure this out the week before SBC, like, two years ago, of what to do about LVR. And obviously, the thing we wanted to do was run an auction. But it turned out that you needed something else, which was censorship resistance. Before you could do anything. So I think, Dan, you're going to be talking about this later. But I think the thing that we need. Before we can talk about what the ordering rule should be.
00:01:52.248 - 00:02:19.866, Speaker A: And how to run the auction. Is actually censorship resistance. And this is going to be a talk about how we get there. So why do we care about censorship? Because there's two things that people often talk about in Mev. There's censorship and reordering. And usually, actually, in the first few papers, kind of Diane at alchemy stuff, was talking about reordering. But actually, I would argue that it's basically all censorship resistance.
00:02:19.866 - 00:02:46.882, Speaker A: Because you can reorder the transactions. And execute them however you want. If you're the CTO of Reth, you can just execute them whatever way you want. So it's actually more important to make sure that the transactions that you want to execute are on chain. So that you can pull them out and execute in the right order. Than it is to make sure that the proposer doesn't have much ordering power and basically to allocate scarce resources. You want an auction.
00:02:46.882 - 00:03:32.770, Speaker A: So we're going to argue that we should build a system that lets you run an auction. So there's a bunch of stuff. I was going to print out the roadmap and rip it up for you guys, but I thought it would be a little melodramatic. So just imagine I did that. But there's a bunch of stuff, especially in the scourge part of the roadmap, which is kind of the mev part of the roadmap, which is kind of hinting at this. But our take is basically, we should take this head on, the censorship problem, and instead of trying to do a bunch of PEPC inclusion lists, deal with every single problem separately. Let's just eat the complexity, in Vitalik's words, of multiproposer, and basically do that and ignore all these other little gadgets.
00:03:32.770 - 00:03:54.394, Speaker A: Fossil mev, burn. What else? Execution auctions. Execution tickets. We're going to throw that all out. Instead, we're going to do multiproposer. And that's like our plan, basically our vision. So why should we care about multiproposer? Because it gives us censorship resistance.
00:03:54.394 - 00:04:47.130, Speaker A: What is censorship resistance? Well, it's a property that a public bulletin board has. What is a public bulletin board? It is a very abstract model of a blockchain that has two functions that you can do. One of them is write, which takes as input a message and a tip. It can succeed or fail. In particular, it can fail when a motivated adversary tries to keep you off the chain. And for the purpose of this abstraction, there's just a read thing which just says you can kind of read all the messages that have been successfully written to the bulletin board. So now that we have defined the bulletin board, we can say a bulletin board has a certain censorship resistance function, which is kind of agnostic of the details, but just says, when you do a write operation and you put in a tip, what is the cost? It would take a motivated adversary to pay to keep your transaction off.
00:04:47.130 - 00:05:41.272, Speaker A: So, for example, if you have a single block on Ethereum, that censorship resistance function is just the identity function. It's just if I pay a tip of $10, it costs the adversary $10 to censor me. In the PBS auction. And of course, one of the first things we did in the public sphere at SMG was to demonstrate this by censoring an entire block and paying basically the tips of all the transactions. And more importantly for this talk, we have a theorem in censorship resistance. And on chain auctions, which says if you have cake and current proposers, you can get a very strong version of censorship resistance, which means the tip that you put in gets amplified very heavily and gives you a lot of censorship resistance. So in some sense, your tip is going a lot longer of a way and protecting you a lot more.
00:05:41.272 - 00:06:35.610, Speaker A: And what that allows us to do is basically build a system where I, the proposers, don't get to take too much money out of the system. When a valuable item is on sale, for example, you might have a $100 item on sale. And if your censorship resistance is amplified by ten x, you can pay only, for example, $10 in tips. And so the amount of money that the proposer is allowed to suck out there is only dollar ten instead of dollar 100, like it would be in the current implementation. Um, so, basically, this slide is intended to introduce this key desiderata that we would like to have, which is simultaneous release. And of course, this is very hard if you know about timing games, uh, to get simultaneous release. But once you have simultaneous release, you get a simultaneous game where everybody acts at the same information set.
00:06:35.610 - 00:07:15.200, Speaker A: That's how you get that really strong censorship resistance that we talked about. And it's really the key desiderata in this design relative to other multi proposal designs. And the other thing that we're going to need, basically, is delayed execution, because it doesn't really make sense to execute everything as it comes in, when multiple people get a say in what the state is going to be. So this is something that I think Charlie's been talking about for a while. It's interesting that the RET team had a design that made calculating the stateroot hard. So they said, let's move the stateroot off the critical path. But I think it's a really good idea.
00:07:15.200 - 00:08:17.110, Speaker A: So we should probably delay execution, which means move the state route into the next block. And this will help us get to multiproposer, because we need to do that for multiproposer as well. So let me just talk about, like, what we shouldn't do and some of the stuff that we explored before we got to the final braid design that you're going to see on the next slide or the next two slides or something. So the first thing is, what if we just did LMD Ghost and we just had multi proposer? So this is the first thing we thought of, and it actually looks pretty good. So eventually you get, like, you can probably prove that this settles down, but in practice, the branching factor of the trees gets to be a point where you may have practical failure with the actual technical implementation, because you have now n proposers and you have two to the n possibilities for, like, honest proposer release. And then if you kind of take that a few steps down the line, you can get a huge tree that's maybe too big to store in memory. And then obviously, your implementation breaks if you can't store it in memory.
00:08:17.110 - 00:08:49.056, Speaker A: So maybe if we had the God computer that could store infinite stuff, we could do LMD ghost with multiproposertainous. But unfortunately, we do not have that. We have raspberry PI, so we're going to have to do something else. The other thing we explored is Mississeti, the reason that. So, first of all, mistst is kind of designed for 150 validators, which is not going to work for our purpose. So that's enough. But there's also some other things about Misticeti that were not great.
00:08:49.056 - 00:09:35.300, Speaker A: I think one of them was, it's such a departure from the design of Ethereum that it would take such an overhaul that maybe it's unlikely to get through core devs for good reason, because it would be a huge lift, basically. So that's one of the things that we also wanted, is something that was not so far away from the current design. And there's some issues with proposer blessing and some kind of MeV stuff that allow certain proposers to certain leaders to kind of censor some stuff. And it's a technical point, but it was certainly important for this, because the reason we're doing this is to try and solve MeV, basically. And so if we have something that introduces a new form of MEV that we're not sure how bad it is yet, we probably shouldn't do that. Okay, here we are. This is braid.
00:09:35.300 - 00:10:26.216, Speaker A: It's really stupidly simple, and we're suspicious about how simple it is, but we think it works. And it's not just us, the, the mechanism designers. It is also some consensus. People also are suspicious, but cautiously optimistic that this works. Basically, we're just going to run a bunch of chains in parallel, and we're going to use exactly the same consensus on these chains, and then we're going to do a finality gadget to get the finalization done, just like we do now, except instead of having one chain, we're going to finalize everything. And that's basically the design, not much more to say, basically run separate chains. Importantly, we're going to take the union of all the transactions in slot I from all the kchains.
00:10:26.216 - 00:11:05.150, Speaker A: So, for example, all the transactions in the slot three here, we're going to take them all, and that's going to be the execution block. And then the CTO of Reth is going to reorder them for us. So there's a few ways you might do that. Dan will talk about one of them later. Sounds like there's another thing that we repeatedly tried to get a very small EF grant for a year ago and did not get the grant. But basically to talk about alternatives, one of them is kind of this knapsack optimization, or you could call it distributed block building, where you have everybody submit their transactions. Then you have a builder.
00:11:05.150 - 00:11:54.710, Speaker A: All the builders look at the transactions that came in, and in the next time step in the next block, they submit their blocks, and we choose the block that kind of maximizes the objective function in. So maybe that would be good for our builders to keep their role, but it might be a diminished role at that point. And then another thing, which I have not released anything about yet, but I think is the kind of ideal rule. If we think everything is moving to auctions, if we think Ludwig is going to be making the new uniswap version, and it's going to be all auction based, then this execute as needed rule is basically, look at all the transactions. There's going to be some that have. This is Ludwig's auction bid flag, and we're going to go grab all of those and execute them all together. But again, that one I haven't written much about yet, but I will.
00:11:54.710 - 00:12:22.922, Speaker A: In some ways, this is a separate problem of what the deterministic rule should be. That's like a problem that we're happy to engage with as mechanism designers. But I think the more important problem, and where there hasn't been a ton of work, is on the consensus layer, providing censorship resistance. So some stuff that we're pretty sure is true. We have some sketches of proofs for. We're very sure that liveness is inherited from the liveness of the individual chains. I think that's pretty trivial.
00:12:22.922 - 00:12:55.020, Speaker A: The eventual consistency argument is a little bit more tricky if you have a consistency guarantee in t periods. It's obvious that braid has consistency in t periods. If you take that to infinity, you get eventual consistency. This is a good thing in practice. We're going to come in after a few slots and put the finality gadget on there. Okay, this is kind of my last slide, but it might take me a while to get through because there's a lot of details here. The first thing I will talk about is this free da problem.
00:12:55.020 - 00:13:51.590, Speaker A: So the free da problem, basically you have this issue where we have now K proposers. So we might have somebody make a transaction on one of the proposers, which is invalidating of the other proposer. Or for example, they say I'm gonna pay a fee of dollar ten, but they only have $10 in their balance, and they say they're gonna pay a fee of dollar ten on all five chains. And all of a sudden you have a free data availability problem because the other four are not actually able to pay the fee because there's not enough fee in the balance. Okay, so what do we have for the free da gadget? We can have a validity condition that says you must be able to pay at least k times your fee. And that way there's no problem of you agreeing to pay a fee on one chain, and because you already paid it on the other chain, you're no longer able to pay it. So there's some free DA gadgets that you can do that just basically involve escrowing some more funds.
00:13:51.590 - 00:14:24.106, Speaker A: So the other thing we need to do in the details is manage communication complexity. So this is something, this morning we decided to do this. Alberto and I were talking and we said, let's do one single vote. And that vote contains all of the votes on all of the chains. And this is good. At some point, each of these probably needs their own paper about it. But the nice thing about the this obviously is good for communication complexity.
00:14:24.106 - 00:14:53.210, Speaker A: It's also very good for some timing games properties that we'd like to have for the simultaneous release desiderata. We obviously are going to need to rethink TFM. What does block building look like? How do we prevent collusion? All of these we're happy to chat about. I think. Like I said, I think there's probably about 40 things that go into this that we're going to need to write a paper about. So there's a lot of work left to do and we're happy to chat with anybody about it. I mentioned the upsides already, but we're getting rid of the scourge if this goes in.
00:14:53.210 - 00:15:48.144, Speaker A: And that means we're not going to have epbs, we're not going to have inclusion lists, we're not going to have any of this tech debt stuff that's being pushed right now. We're not going to have base rollups. I guess you could still have a base roll up, but we are not going to optimize for it. We are not going to have pre comps why are we not going to have pre comps? Because no longer do you have a proposal monopoly, no longer do you have anybody who can give a pre comp because they don't have the power to give a pre comp. And, yeah, I think that's basically everything that I had in my talk. But happy to take any questions. Frankie, how likely do you think this is to induce, like, a multi boost? Okay, the question is, how likely is this to induce mev multi boost? So I will give an argument.
00:15:48.144 - 00:16:48.382, Speaker A: Currently, Coinbase controls about 30% of the stake. It is in Coinbase's best interest for the blockchain to be in the long run, a place where a lot of people want to transact that is Coinbase's interest. Maybe you disagree, but I think Coinbase is not in the business of short term gain by screwing over the network. We actually saw something like this play out, but I will not discuss it because it's private. But clearly, they've kind of demonstrated their commitment to the long term health of the chain at some stages at the expense of sometimes short term profits. And in this system, a validator with 30% of the stake actually becomes the proposer a lot of the time. And so what we have is a system where as long as there's some people in the system that are acting honestly and the probability that at least one of them becomes a proposer is high, then you don't have possibility of collusion, and inclusion is unstable.
00:16:48.382 - 00:17:17.907, Speaker A: And so it may happen. Hopefully Quintus doesn't build this as soon as we launch, but maybe Eden will or something. So I think it's something that we're prepared to take the risk of. There is a graceful failure argument that says, basically, if that happens, we come back to the proposer monopoly, and we're back where we started, with slightly more complexity at that point. I'm going to quit and go work on AI or something if that happens. Go ahead, Charlie.
00:17:18.043 - 00:17:49.836, Speaker B: This is, like, kind of a narrow question, but on the slide. On the slide where you talk about alternative approaches, I think it was LMD, ghost, and Mistisadie. I was curious. On the Mistisadie rationale, I would have thought that it would be because it's not simultaneous release, but rather basically a future leader referencing a set of current blocks, which seems to me like a very different argument than the prisoner's dilemma you set up. Do you disagree with that? Do you think Mister Sadie actually works for the censorship argument, or. Yeah, I was just curious why this was the rationale, basically.
00:17:49.948 - 00:18:09.800, Speaker A: Yeah. So the thing. Yeah, so I agree. I think maybe I didn't communicate this clearly, but this is kind of what I was trying to say of this leader's blessing thing, which is that the leaders in future slots have to include you in their ancestry in order for you to make it in. So I think that's really important.
00:18:10.180 - 00:18:25.548, Speaker B: And one other question was, so when you say once there's consensus on the union, then you can interpret the chain, does that mean after the finality gadget catches up to and reaches it, or do you think it's possible to interpret the chain in the unfinalized header?
00:18:25.644 - 00:18:37.890, Speaker A: I think in the happy path it's possible to interpret the chain, especially if you have a really fast client that is very good at executing quickly so that you can re execute if you need to. Okay, what do I guess?
00:18:39.670 - 00:19:26.946, Speaker C: So I had a question about where you said that ordering doesn't matter and censorship is all you need. Right. I'm operating under the assumption that here this is really for the purpose of on chain options. Right. But if you have, say like order agnostic applications, you have to operate in a non atomic model. So you'd have to have all of the transactions for a given application be submitted and then at the end somehow have like an execute function that then executes the entire thing and has its own specific sequencing roles. But that kind of implies that if it's in the same block, you're still order dependent in that last transaction being executed at the end of all of the other user interactions.
00:19:26.946 - 00:19:33.198, Speaker C: Or you have to do like cross block, which seems a bit inconvenient and like not great ux.
00:19:33.374 - 00:19:57.450, Speaker A: Yeah, so that's the point of this execute as needed rule is to try and make that more atomic. I'll let Dan talk about the atomicity. I think he has a nice argument there for the priority fee, the priority tax version. But I also think atomic execution is fake news. So, Benedict.
00:20:03.070 - 00:20:34.262, Speaker D: Thanks. So basically this censorship resistant model also has some welfare loss on the blockchain because these properties, if you have a centralized builder, then you pack a more efficient block, which is better for the clients, it's better for basically the data that is stored. In general, fewer reverts is in theory a good thing. How do you think about that trade off? What's the right way to think about how much complexity of the blockchain is worth this censorship resistant property?
00:20:34.406 - 00:20:46.742, Speaker A: Yeah, I think we were maximizing for efficiency and throughput. We wouldn't be building on Ethereum. We're maximizing for censorship, resistance for decentralization.
00:20:46.886 - 00:20:58.080, Speaker D: For credible, there's some decentralization cost. If you run like 16 blockchains in parallel. You need a lot more networking overhead, you need a lot more hard drives to store the data, right?
00:20:58.380 - 00:21:13.084, Speaker A: Yeah, I think so. I think we're going to have to do that sacrifice. I don't think we're going to have to get to the point where we need Solana level validator spec with 256gb of ram. But I think we're going to need to probably be somewhere around 32 gigs of ram or something.
00:21:13.172 - 00:21:19.482, Speaker D: So the right way to think about it is we see this as a non negotiable property of the blockchain and we'll just try to do the simplest version possible.
00:21:19.546 - 00:21:22.630, Speaker A: That would be my opinion, is that this is absolutely non negotiable.
00:21:24.210 - 00:21:38.390, Speaker B: Max, I have two questions real quick. First one is do you share a state across these subchains? And the second one is whether you can atomically interact in the same block between arbitrary subchains.
00:21:41.070 - 00:22:20.806, Speaker A: Each of these chains is responsible for proposing transactions which go into the execution block. So that transactions are the union of all the transactions in the execution block. And so we're going to dedupe them if they're duplicates. So they all are operating on one single state machine, which is like arbitrated by the execution layer. So the execution layer takes all of the transactions, applies a deterministic ordering rule like the one Dan is about to talk about, and sequences them that way. So there's no separate state on any of the chains. There's one state which is the state of the blockchain.
00:22:20.806 - 00:22:23.970, Speaker A: And these are just ways to get onto the blockchain.
00:22:27.070 - 00:22:35.208, Speaker E: How do you deal with timing games? And particularly the fact that every blockchain here has potentially a last look on proposing transactions.
00:22:35.344 - 00:23:10.260, Speaker A: My favorite question, Dan, my favorite. So what are timing games? Why are timing games important? Because in the current system you get an extra second, you get an extra second of monopoly. Okay, so just as a first order argument, if we're breaking up the monopoly, the value of being the proposer is lower. Okay, point taken though, because it's still important. Last look is still going to be important here. I would argue it's going to be less important than another 1 second of monopoly. But it is important because of the adverse selection, especially for sextext arbitrage.
00:23:10.260 - 00:23:54.160, Speaker A: There are some ways to mitigate this that we know of. One of them is missed slot penalties. And then another thing, basically because each validator or tester is going to provide a single vote which provides their view on all of these and they're not allowed to update their vote because that would be a double test fault and they would be slashed for this. Basically the validator is going to see what is available at one time. And so having your like, one of the problems with timing games is that it's kind of complimentary to be the proposer and have more validators. And so Coinbase can be potentially a lot more effective as a timing games person than like Mike Neuter's solo staking box. That's a problem.
00:23:54.160 - 00:24:06.300, Speaker A: But I think it's less of a problem because the incentive here is not as strong. And so we can kind of combat it by putting a big missed slot penalty on there. Big relative to the value.
00:24:07.000 - 00:24:15.500, Speaker E: Could you choose a different rule other than union of all transactions, like say a transaction has to be in at least one third or at least two thirds of blocks.
00:24:16.760 - 00:24:21.658, Speaker A: Yeah, I don't want to do that. I want one of NDE censorship resistance.
00:24:21.754 - 00:24:23.298, Speaker E: You get some censorship resistance, you'll end.
00:24:23.314 - 00:24:25.710, Speaker F: Up paying the cost of having that.
00:24:27.330 - 00:24:31.266, Speaker E: Sorry. We can, when people talk, by the way, grab the mic so we can get it on the recording.
00:24:31.458 - 00:24:47.274, Speaker F: If you do that, you'll end up with transactions on one third of. So you'll just be replicating. You won't get like, if you have five chains and you want them on anything on one third, you're only getting like five over three if the throughput. You're not getting close to five anyway. Close to additional throughput.
00:24:47.322 - 00:25:27.170, Speaker A: Yeah. This is another thing we explored in kind of the, in the first thing that Elijah put out, the multiplicity, it has a view canonicalizer. The view canonicalizer is in that case the proposer, and they just basically choose whichever two thirds of the vote extensions that they want to go in. And so you get what you're talking about. This is something that I very much did not want in the design, because I think it's like not enough of a bonus when you're not one of n to eat the complexity that this is going to be adding. So I think it's normatively, I think it's very important to be one of n rather than two thirds of n.
00:25:29.750 - 00:25:41.430, Speaker G: Could you elaborate on the differences between your parallel chain approach and the ghost modification? It feels to me that you're describing compatible things.
00:25:41.850 - 00:26:30.062, Speaker A: Yeah. So it's different because in the ghost scenario, you are basically, you're attesting to every single, so you're sending the same message, which is whether these things arrived in time. So that part, up to that point is the same it happens in the way that we process the votes. We're only going to process the vote on chain one. About chain one, we're not going to do any kind of cross chain voting. So in some sense, we're ignoring some of the information that's in these votes, and that is what allows us to inherit the properties of each of the single chains, because we're only going to do what we're doing is basically exactly what you do currently on an LMD ghost chain, on subchain one and on subchain two and subchain three.
00:26:30.206 - 00:26:41.858, Speaker G: Okay. And then if we move towards SSF or some much shorter window for finality, can we not trim that tree enough for it to be feasible to just do the LMD ghost modification?
00:26:42.034 - 00:27:09.680, Speaker A: Potentially. And I think we'll be in a spot where if we do get SSF, then, because we have already the information that we're just kind of ignoring it in the current thing that we're proposing, we'll be able to move to the full LMD ghost implementation where people vote on all of the chains and their vote counts on everything at the same time. Cool. So we'll be already ready for that if SSF comes.
00:27:11.060 - 00:27:21.652, Speaker H: Max, how do you think about getting around the n square all to all communication that you have among validators in the multi proposer context?
00:27:21.836 - 00:27:49.754, Speaker A: Yeah, so that's what I'm saying with you basically send a single vote that includes your message on everything. Maybe this, at least you're sending one message. It might be larger in proportion to the number of chains, but you're going to only send one message. It's just that it's going to be kind of larger in the number of chains. So it's going to be very similar in terms of the number of messages. The messages might be larger. Does that make sense? And I guess we have k proposals as well.
00:27:49.754 - 00:27:50.970, Speaker A: That's going to certainly be.
00:27:51.050 - 00:27:54.870, Speaker H: So maybe the claim is that instead of n squared becomes k multiplier.
00:27:55.180 - 00:27:56.644, Speaker A: Yeah, I think it becomes kn.
00:27:56.772 - 00:27:57.452, Speaker H: Okay.
00:27:57.596 - 00:28:04.720, Speaker A: Certainly, if it was, you have to do one for every. Yeah, that's a good way to summarize it.
00:28:14.540 - 00:28:28.550, Speaker C: If you're operating like, on the union, like global set of transactions. Right. And you have a single. How do you not have the. I'm not sure I fully understand how you don't have the same problem as the LMT ghost modification.
00:28:29.730 - 00:29:00.452, Speaker A: It's harder to make a. So first of all, you can have branching, but the branching is kind of, if one chain is falling behind, the branching factor of the tree is lower than in this system, where you're kind of having all of the, I would imagine, basically, just think of instead of this line, you have all of these lines as well. In the LMD ghost version with multi proposer.
00:29:00.516 - 00:29:34.626, Speaker C: I guess I understand how that would work in a context where the state isn't global, because then you have independent execution. Okay, subchain one and two can be executed. These transactions are valid independently of, like, the other chain. But here you're operating in global state. So then you still have the problem of, oh, subchain one and subchain two are included. You're missing subchain three. But it turns out that transaction in subchain three gets executed before the two other chains.
00:29:34.626 - 00:29:39.054, Speaker C: And so now transactions in subchain one and two are invalid. And then you have something.
00:29:39.162 - 00:30:34.830, Speaker A: So suppose like this bottom validator, this guy is malicious. He can split the view in this parallel chain version, but he can only split it on this one chain, whereas in the full LMD ghost version, this guy can split the view on everything. So we might lag on this one if this guy's malicious, and it's important because we have multi proposers. So the probability that we have, if you have a malicious staker with 5% of stake, and we have ten proposers, the chance that they're going to be able to fork stuff. So then say that this guy's malicious, and then this guy, he comes in as a validator, but the probability that he's on the right chain to continue the fork is low because he's probably on this one or this one. So the attacker has to basically fork the chain for a couple slots in a row to make the tree grow to terrible size.
00:30:37.210 - 00:30:48.590, Speaker C: But then if he's right, he's forked the subchain three. But now that impacts what is accepted as valid execution on subchain one and two.
00:30:49.130 - 00:31:10.560, Speaker A: Yeah, I mean, if there's disagreements and what it looks like, we're going to have to wait. That's how the blockchain is going to work. It's just a matter of how much, how many subtrees the validator has to store in their state in order to keep track of that disagreement. And here we're kind of taking off a bunch of subtrees. Happy to chat more about this.
00:31:12.260 - 00:31:13.280, Speaker F: One more question.
00:31:16.220 - 00:31:51.990, Speaker D: So imagine a situation in which there are two large groups, like Coinbase and then binance or whatever. They own 20, 30% of the stake, right? And they each come up for a chance to propose a new block on their respective chain. It's in their interest to kind of have all the other chains have a missed slot at that point because they're doing a bunch of interesting activity. It's better if they just kind of have more of a monopoly. So why would they not just kind of not vote with all their other nodes that are attesters? Why would they just not attest to the other chains try to force a bunch of missed slots and then kind of regain some like, monopoly power?
00:31:52.450 - 00:31:55.490, Speaker A: I mean, they're going to have some missed attestation penalty for that.
00:31:55.610 - 00:32:02.310, Speaker D: So you just have to create a high enough penalty to offset. But, like, you do it selectively. Right. In situations when there's like a high Mev opportunity.
00:32:03.530 - 00:32:12.746, Speaker A: Yeah, I think. I mean, if you have more than 33% of the validators, then. Or, I mean, it's. What are we doing if you're like 33% of the validators?
00:32:12.818 - 00:32:21.680, Speaker D: Well, yeah, I guess this, like, falls into some gray area that's not like, I'm overtly, like, byzantine, but I'm just like kind of. Oh, I didn't see the block.
00:32:22.100 - 00:32:39.400, Speaker A: Yeah, I think if we get to the point where validators have 33% of the stake, which we're kind of at, it's hard. I think Coinbase probably wouldn't do that because they'd probably get sued and they're a us entity and they're the one with 30% stake right now, so.
00:32:39.700 - 00:32:40.440, Speaker D: Sure.
00:32:42.830 - 00:33:11.380, Speaker F: Relevant. What you're saying would also be relevant in a single chain. If Coinbase knew they had the next block, they should do the same attack because, and with 30% of the stake, they're going to be the next proposal 30% of the time. And then they should just do that and get a 24 2nd block. So that attack works better in a single blockchain. Makes life slightly better, hopefully.
00:33:14.760 - 00:33:15.800, Speaker A: Are there any more questions?
