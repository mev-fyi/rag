00:00:01.040 - 00:00:26.790, Speaker A: Hello, everyone. Okay, I'm gonna. I'm Ferran, I'm from flashbots, and I'm gonna be talking about the art builder. The art builder is the new block building stack that we have developed at flashbots. So, how many of you know how PBS works? Place of hands? Not that many. So this is how PBS works here. So this is how block building works.
00:00:26.790 - 00:01:11.500, Speaker A: It doesn't point at the top. You have, in green, you have the normal block building workflow, you have the proposal which will delegate to the execution client the build of the block. So the execution client will use vanilla block building algorithms to return a valid block to be proposed. And here at the bottom is what we call the PBS, or proposer builder separation. Now we have two more actors. On one side, we have the builder. So builders will build blocks for the slots, and the proposers now will call the mapboostrelay to sort of serve as an impartial action to select which block is willing to bid higher for that slot.
00:01:11.500 - 00:02:01.440, Speaker A: So the members lay here. Also adds extra security in case of the proposer not being able, though they may be able at the end. But nothing been easy for the proposer to unbundle the block of the builder. So what I'm going to be focusing on this talk is that actor of there, the builder. So, all this stack was introduced, this previous stack was introduced by flashbots right after the POS. And we initially open sourced the MEV implementation, and then we also open source block builder implementation. So this was a fork of Go Ethereum with a more complex merging algorithm, and also all the bindings required to send bits to the Mapboost relay.
00:02:01.440 - 00:02:47.120, Speaker A: This sort of open competition got competitive at some point, and more sophisticated players started to enter the block building competition. So you'll have, for example, trading shops with custom order flow that could build more valuable blocks. Most of them will follow the same process. They will take the builder, or they will take AWOL four kit and add their own changes on top. These are the four main categories that we have seen so far, where they have introduced changes. They, as I mentioned before, they have internal order flow that they can leverage, so they modify the builder. For that, they may introduce new latency improvements, like connecting to the relay using web sockets.
00:02:47.120 - 00:03:30.468, Speaker A: They can use new bidding strategies to decide how much they want to bid for the block and to sort of combine all those three. They build custom merging algorithms, but again, all of them follow the same process. They take the client, they fork it, they add the changes, and they upstream. And I'm not sure how many of you have been in that situation? But that's really complex to do at scale. It creates some sort of psychological fear every time you try to create a new feature, because you don't know if Geth is gonna break some interface or what you're doing is gonna be available for the next release. Okay. Okay.
00:03:30.468 - 00:04:21.868, Speaker A: Yeah, so we were in the situation as well, and we saw how we were not innovating in block building. Right. At that point, we're thinking, okay, how we are going to update our builders, what's going to be our newest strategy for block building? And with the release of red, it was easy to think, okay, how we can leverage red for that. And the way we can leverage RTH is using its modularity. So it's important to note that go by itself, by the way go works, you can already take code from Goetherium and using it as a module. Most people use the AVM inside go Ethereum. But just because you can use that module doesn't mean that it's going to be easy for you or it's going to be maintainable for you.
00:04:21.868 - 00:05:18.980, Speaker A: There has to be some kind of contract in that API for you to safely and in a scalable way to use it. And that's what Ret offers. With the crates of RET, we are sure that they can be breaking changes at some point, that they acknowledge that modularity is a first class citizen in the system, so they are willing to put some API contracts there that they are not going to break those implementations. So following that, that's when we started the art builder. So the art builder is a modular block builder built on ref. It's built on rest. That means that as the common layer uses rest primitives, rest provider and the alloy types, and that helps us to remove a lot of extra code that we don't have to do anymore on the builder, like typings or encodings.
00:05:18.980 - 00:06:17.970, Speaker A: And it's modular in the sense that we want to bring the same innovation that redis, bring into the nodes, notes, client, into block building. We want to make it easier for people to take our builder and create their own sorting algorithms, merging algorithms add new functionality without having to go through the cycle of forking, merging, upstreaming. So how is it going so far? Oh, sorry. This is how the R builder works right now for the l one use case. So this is the same picture as before for the PBS example. And now we have the R builder that it's connecting with the rev database to sync all the state. So to do that, we just use the rest crates to connect and access that database and get a reference that we can pass to the AVM for the R builder.
00:06:17.970 - 00:07:21.880, Speaker A: So how is it going so far? As of now, as two months ago, we don't run any more go Ethereum nodes. We just deprecated all the go platform of the block building and we only use these R builders. They are way more efficient than it was before and half of them run in this TE platform. So te is another angle of flashblads that I won't go into detail, but if you have more questions, come talk to me afterwards. Tease is a special type of hardware that is a security enclave where you can run your applications. So half of our builders, and by the end of the day we want to be all the builders are running already in this TE platform and with negligible performance. We are talking about 5% to 10% loss in performance, which are the features that I want to highlight first, as I give a hint before, is a modular block building.
00:07:21.880 - 00:08:18.566, Speaker A: That means that there is a trait that you can implement to add your own custom merging algorithms. You might have new strategies for dag sorting, or some simulation or some heuristics that you can easily plug into the art builder, test them out and send blocks into the l one chain to see how it looks. Combined with that, we have backtesting so you can easily check how does your algorithm works, how is improving. You can take a range of blocks from Mainnet and see if you are increasing the value that you are generating also pretty easily. And the third point, and this is something we just open source a few weeks ago, we have a local deployment environment. As I showcase here. In order to test the r builder, you have to basically run these three and sometimes four different services.
00:08:18.566 - 00:09:02.292, Speaker A: So that was a huge struggle sometimes when we wanted to do local testing or some CI integrations. Now we have a complete local playground. It's on GitHub, it's called builder playground. That takes 8 seconds to deploy. All that setup all in memory, pretty easy to do. So that has helped a lot into testing new features and on the CI integration, and we hope to leverage that to increase more the coverage of the builder. So where are we going from here? These are the four major tracks that we are going to be working on for the next months.
00:09:02.292 - 00:09:53.050, Speaker A: First one, and that's the one I'm focusing on. We are in multi chain support the same way that ref can be a node for both mainnet and op chain op stack. We want the art builder to also be a builder for l one chain and also for op chains. So we are researching how we can make the builder modular to support these use cases. We want to improve block builder architecture. So we want to also research what is the most efficient trait architecture for the builder to support many different block building use cases. Third one, this was mentioned yesterday, is that Rev, it's not still as efficient as Goetherium doing a state root calculation.
00:09:53.050 - 00:10:44.980, Speaker A: In our benchmarks, we have geth blockbuilder at 15 milliseconds for hash root calculation. And right now, with our builder is 100 milliseconds. So we are merging in the next two months, a new hash root calculation improvement that brings down the number to ten milliseconds. And the last one, which I'm the most excited on, we are going to launch a block building competition. So we want to launch like a sort of kaggle block building competition, when people can send their own block building algorithms, train them in some set, some snapshot of training data, and then we'll run them on some test data and create a leaderboard on top of that. So, yeah, if anyone wants to try, be on the look for the competition. Yeah.
00:10:44.980 - 00:10:46.040, Speaker A: Thank you.
00:11:01.910 - 00:11:28.912, Speaker B: Hey, yeah, thank you for the presentation. I have a more general question about how you backtest. I'm curious because I've been talking with friends, or you just said it here, usually how you backtest is you take a subset of blocks and you replay them, and you see, like, how performant it was. I'm curious, like, it seems very constrained. Like, I'm curious if you have other ways to make, like to a test of the quality of your improvements.
00:11:29.056 - 00:11:49.402, Speaker A: So you don't test on a range of blocks. You have to test on the. You have to sort of replay the estate at which the block was built. Right. So you have to add point t. You have to start with state t minus one. And all the transaction does.
00:11:49.402 - 00:12:39.910, Speaker A: The mempool had at point t. Right, because that's the, that's the estate that the art builder used to create the block. Eventually, not all just transaction at point t are gonna be end up on the block, right? So we have something, a tool called mempool dumpster, which is also from flash watch, which just has. It's like an s three bucket that holds all the transactions that were in the mempool at different points in time. So if you combine that with an archive node, you can really start to replay a given range of blocks and see how your builder performs. So part of the thing that we're trying to do is sort of ease those requirements to run those backtesting, so you don't have to require an archive node. So we are testing like different strategies there to make it easy for people to run it.
00:12:40.370 - 00:13:06.552, Speaker B: But if you have a different behavior, wouldn't it mean that it would change also the behavior of potential other builders on the network or other actors? That would also behave differently if you had a different behavior, which means that your back testing is valuable in a sense, because in this contrived environment, you can say, okay, I'm x percent better, but it's not like real world testing. That's why I was just curious if you had like other ways of testing than that.
00:13:06.656 - 00:13:23.460, Speaker A: Yeah, I don't think we have way. We'll have you all have a way to test how your strategy plays out with different block builders. I think this bug testing is only to test what's your baseline, on top of which you can start to compete with other. With other builders. But that would be something, something different.
00:13:25.720 - 00:13:44.088, Speaker B: Thank you. In your diagram up there, I noticed that our builder communicates directly with the ref database. Can you elaborate on how the ref communication itself works? And why not just run in process with ref?
00:13:44.224 - 00:14:16.680, Speaker A: Okay, yeah, that's a great question. So. Well, the way you plug into database is because of MDX, you can just plug in read mode inside the database. And why we don't make it as a module. We are actively working on that. I think part of the modularity of the art builder will be on how you can create different flavors of it, and maybe one of those flavors run it as a module. This current architecture is helpful because the art builder does not depend on the chain syncing.
00:14:16.680 - 00:15:09.410, Speaker A: So you can have the rest running and syncing the chain, and then you can just restart the art builder as many times as you want, while if you have it in the same process and you stop the whole process and then you restart again, you'll have to wait for that chain to restart, even if it's like ten blocks. Right. So by having it separated, we don't combine those life cycles. But I agree that with making it as a module of ref, it brings like, other benefits, like piggybacking a lot of like, memory and cache improvements that they might do in the future. So that's something that we are actively researching. I think that's it. Thank you.
00:15:09.410 - 00:15:37.890, Speaker A: Okay, next up, we have Alex Stokes from the Ethereum foundation talking about Mebrs. Hey, everyone. Good afternoon. And yeah, this will pair well. It's a very similar take on.
