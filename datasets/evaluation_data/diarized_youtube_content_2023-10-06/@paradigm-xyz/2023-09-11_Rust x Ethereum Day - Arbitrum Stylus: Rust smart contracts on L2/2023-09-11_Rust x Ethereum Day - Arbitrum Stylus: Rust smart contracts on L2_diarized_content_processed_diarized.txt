00:00:00.720 - 00:00:36.298, Speaker A: All right, hello, everyone. My name is Raul Jordan, and I am one of the crazy people that's staking on mainnet with breath. And I'm here also a maintainer of the prism consensus client for Ethereum and also working now on l two technology. So really excited to talk to you guys about the arbitrum stylus and what we're cooking up. All right, so l two s on Ethereum are really awesome. They enable things that just weren't possible before. We can do so much more if basically, you know, we can get a lot of the guarantees of Ethereum in the fact that you can bridge over and you can also bridge back with fraud proofs.
00:00:36.298 - 00:01:15.234, Speaker A: And that gives us so much opportunity to explore just crazy things that otherwise would take years to do. On Ethereum l one, for good reason. Ethereum is this decentralized, kind of very secure base layer, and it cemented itself as a very strong data availability layer. If we want to keep, you know, if we want to really move and change some of its key features, that obviously takes a lot of time, and there's a lot of inertia behind it. So in l two, we can innovate, and we can do things a lot faster and oftentimes in ways we couldn't expect before. So I'm working on currently the arbitrum l two. And at a high level, how it works is that we run go ethereum state transition function.
00:01:15.234 - 00:01:56.360, Speaker A: So this is the same thing that happens when you process an Ethereum block. When you process an ethereum transaction, it goes through Geth. And what we do is that we compile all that code into this format called webassembly, which some might be familiar with, which then gets proven back on Ethereum with a delay of approximately seven days. So during this time, people can make claims about arbitrum state, and they can also dispute those claims. And always Ethereum will be the final arbiter of truth. So we'll figure out if somebody is lying or if a dispute was just completely incorrect. So why webassembly? What is this thing? Why are people talking about it? People also call it wasm is for short.
00:01:56.360 - 00:02:49.880, Speaker A: And the idea is that it's this compact binary format that's originally designed for the web. And the idea is that with this, we can run other languages than JavaScript in the browser. So we can do things like, for example, run c code, run rust code in the browser, and it's supported heavily by web standards committees. It's become an amazing tool that is already in production at many companies and many folks already have already had exposure to it. Coincidentally, it's also really great for L two s and for doing this kind of fraud proof verification game that we just spoke about. So originally, JavaScript was really all we had for developing web technologies, and today the ecosystem is a lot more mature. So browsers now support very robust experiences with Webassembly, and especially Rust has really awesome support, first class support with some of the tooling that exists out there today.
00:02:49.880 - 00:03:20.540, Speaker A: So something we asked ourselves is, hey, L two s, what they're actually doing is proving computation on Ethereum, right? We don't really say what kind of computation, but most of the time it's EVM computation. Ethereum computation. Right. It doesn't need to be that way, necessarily. And could we do more? Right. So, actually, the competition that we do is in WASM, and a lot of this comes from go Ethereum. But a question arises, can we do fraud proofs overdose, any kind of arbitrary user wasm? And the answer is yes.
00:03:20.540 - 00:03:56.654, Speaker A: So, question is, why not other binary formats, such as mips or Ris five? And really, it comes to the tooling and the community support. WASM has become so supported by standards committees that the tooling is getting better and better each year. And even the creator of Docker anticipated that WASM on the server was going to be the future. He said that if WASM existed back when he was creating Docker, they wouldn't have even need to create Docker in the first place. So that's how big of a deal this is. So, presenting arbitrum stylus. Arbitrum stylus is a next gen environment for developing smart contracts.
00:03:56.654 - 00:04:36.970, Speaker A: On arbitrum, you can write your smart contracts in rust, c, c, and really any language that compiles to webassembly and doesn't have a runtime. So are we choosing between EvM or wasm? No, this is actually fully composable. It's one chain, multiple vms. It's not a new l two, and we like to call it EVM. We actually have two vms running side by side, which is the EVM and also the Wasomer VM. And they can fully interact with each other, and they still go through one exact state transition function in one database. There's nothing like this that exists today.
00:04:36.970 - 00:05:43.564, Speaker A: Some of the breakthroughs that are possible with stylus is that a lot of execution becomes incredibly more performant, and that also means resource efficient and cheap. So, for example, benchmarking catch act shows a 73 x performance improvement when it comes to certain things, such as memory, we can see, gains as much as 500 x on certain memory types for applications that use medium amounts of ram, and the numbers are just staggering. What does that translate to? It translates directly to transaction costs for users and things that just weren't possible before within the bounds of the EVM. So when you have access to stylus, we get things such as amazing cryptography that can be implemented on arbitrum, gaming, AI, generative art, and even precompile research. So instead of waiting years to adopt a precompile, it can be implemented as a rust program directly. Most importantly, and what I'm most excited about is that you get to write pure rust. There's no crazy domain specific language, no wild, crazy chimera of languages that seems like rust but isn't rust.
00:05:43.564 - 00:06:31.156, Speaker A: No, you get to write pure rust, and you can use the tools you're comfortable with to interact with the EVM. We provide a very low level, syscall like API to get access to host functions. This means that you can implement really nice frameworks on top that provide nice types, use alloy, use, all kinds of things. The community can choose any way they want to go with this, even the most minimal entry point, you have a function that just takes in some bytes and outputs some bytes. This is just pure rust. You can go wild, do anything you want here, and you're not bound by the traditional gas limits or execution costs that EVM contracts would normally have. Can we add support for other languages in Rust? If folks here are curious about Zig, it took me about 16 lines of code to add full support for Zig for stylus.
00:06:31.156 - 00:07:03.562, Speaker A: And if you have any other favorite programming language that you want to write smart contracts in, you can go ahead. It's all up to you. When Stylus we have fully working fraud proving for stylus programs full EVM compatibility in Interop, and also ABi equivalence, which is really important. Rust is supported out of the gate, and a lot more is coming. The really cool thing is that when you interact with a stylus program, it looks just like a solidity smart program, a smart contract. You don't even need to know that it's in Rust. You get an ABI interface to solidity.
00:07:03.562 - 00:07:30.810, Speaker A: You call a function. You do a transaction underneath the hood. It could be written in rust, it could be written in Zig, or even in c, and basically, the world is your oyster. If you use Stylus, if you're an l two developer, if you're interested in smart contracts, if you like writing Rust, please find me after this talk and you can contact us. I want to give a huge shout out to the team lead and the mastermind behind Stylus, which is Rachel Bosfield from our team. And you can also contact me. So thank you, everyone.
