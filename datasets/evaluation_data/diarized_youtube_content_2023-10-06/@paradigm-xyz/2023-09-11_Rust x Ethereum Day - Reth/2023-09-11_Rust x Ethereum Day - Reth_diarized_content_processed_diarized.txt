00:00:00.600 - 00:00:21.918, Speaker A: The talk, we're calling it rust retinacence. We're making all the puns that we can. And let's see where we are going to land today. Here, you see that we have some stickers on the back. We have some new ones, some old ones. We have a Zora chain, NFT, that people are free to mint. It's an open edition, which closes on Sunday.
00:00:21.918 - 00:00:54.300, Speaker A: And we also have a farcaster channel. And it's been actually had an I interaction with someone today where they were like, hi, I know you from Warpcast. And that was interesting. Maybe, who knows? So, for the next two and a half hours, we're slightly behind, but we have a whole day ahead. We're going to do a few talks from very high context, people from our teams that have built a lot of our open source software. We're going to have some lunch. It's going to be pizza and sandwiches.
00:00:54.300 - 00:01:32.240, Speaker A: So if you want something fancier, Doordash is your friend. And then we're going to do an hour of lightning talks. We're going to have a community showcase of five minutes each from each attendee, without q and a, in the interest of time, where people will go over what they've built and then we can all sit and chat until the end of day. We will take the chairs out, we'll put tables, and it could be a hybrid of, like, a hacking socializing situation. This is an untested format, so we'll see how it goes. But overall, get the right people in the room and things happen. And the bar opens at four or five.
00:01:32.240 - 00:02:35.376, Speaker A: So the takeaway, like, what am I going to sell you today? Right? What am I going to convince you of, is that we want you to be building on Rust and Ethereum, and we also want you to be using rest from this talk, from the other talks, they will sell you other things. So rust is a language that we want to use in production, but we don't have enough people. But it seems like small groups of people are achieving great things with it. So clearly there is something there. And unreth, using that rust foundation, seemed to build something also exciting, which we also think has great potential for the future of the ecosystem. So maybe just to go back a little bit, in 2021, it was about a year in a library called ethersrs, where we started dare to dream, where we said, ok, we have ethers, rs. It's a good library for interacting with things.
00:02:35.376 - 00:03:42.106, Speaker A: What more can we build? And we had a very simple thesis that was, if you build everything to be very modular, very well tested and very well documented. Then we could hopefully get to the state where the cost of deploying a new application, a new system, a new startup even, would go way down. And we thought, okay, what is going to be our foundation? This guy, although these days he looks more like this. Just to be very clear, you don't fuck with. So why rust? So first and foremost, which is an underrated thing for production use, these batteries included, you download rust, you get the compiler, you get a very annoying teacher, which is the compiler end clippy, the linter, you get the formatter, you get the test framework out of the box. You get so many things. And the most important thing actually for production use is a mature ecosystem of libraries.
00:03:42.106 - 00:04:21.080, Speaker A: We have asynchronous APIs, we have databases, we have networking implementations. Everything, again, built with the lens of Rust, of being like this high performance thing, you get a lot of developer productivity. So there is this meme that, oh, Rust is hard, blah, blah, blah. But like every tool is a learning curve, and there is a productivity frontier that you get once you're past that learning curve. And everyone that has deployed Rust in production in this room knows that very well. If not, I think it's worth talking about and getting over that initial hump. Rust has a culture of documentation and inclusivity.
00:04:21.080 - 00:04:45.054, Speaker A: I find that to be very important. Note how we haven't talked about performance yet explicitly. The documentation is very important for onboarding people. The inclusivity is also very important for making sure we can get people on our code bases. It doesn't need to be hard, basically. It doesn't need to be complex. Everything can be simplified with the right abstractions, the right test, the right documentation, and that's how we have approached our software.
00:04:45.054 - 00:05:13.008, Speaker A: That's how most people in the rust community also approach their software, which is very different, let's say, to CR C community, where being able to write hyper optimized assembly that nobody can read is considered elite. I consider that to be an anti signal. You get the obvious things that everybody has heard about. Get safety and efficiency. You get performance and efficiency. Performance means I can do a lot of things. Efficiency means I can do them with little resources.
00:05:13.008 - 00:06:10.298, Speaker A: You also get safety, but you also get developer productivity. So how do you reconcile all of these? And that is where the rust language employed modern programming language techniques, mainly the bottle checkered, to give you a language that has very efficient memory allocation and very strict types and very eliminating a large class of vulnerabilities, while also giving you very high performance. It is portable, it's cross platform, which means that you can go to Linux, you can go to Windows, to arm, to whatever you want. You can even go to embedded, which is very convenient. And you also got the browser, which we'll hear some slide about from Tom and Wegman later. And, you know, we did some rewriting. The big con is that you need to learn a new thing, and learning a new thing has a perceived cost, and that is a very fair critique.
00:06:10.298 - 00:07:11.266, Speaker A: But take some risk and maybe you will be rewarded. For Rust and Ethereum, the motivation is very simple. If Rust is a high performance language and Ethereum is mission critical infrastructure, which demands safety and performance, we're going to use aerospace software for it. So in Rust and Ethereum, there's this big ecosystem of MeV, smart contract developers, indexers, RPC providers, a lot of things that custody big numbers. And these big numbers, one, they need to remain big because for the sake of our industry, or if there is any performance issues, we'll have trouble saturating demand. So, to the previous slide, Rust is a perfect fit almost for this kind of problem with this cost. But we're two, three, three and a half years in.
00:07:11.266 - 00:07:59.160, Speaker A: So what have we done so far to ameliorate this concern? So I have put together a small timeline of what has been shipped so far, just to paint a picture or to put things into perspective. So we started developing even before I joined paradigm Ethers RS, which later became alloy. At the time, there were a bunch of other rust ecosystem libraries from pyrity, because Pyrite was developing a pyrity ethereum later on called open Ethereum. But there was a lot of legacy code in these code bases. This was 2017 2018 rust before async await. So it was a very, very, very different world, and we wanted to take a fresh perspective at it. So after ethers, we built foundry.
00:07:59.160 - 00:08:33.976, Speaker A: Then we found which foundry is for testing. Then we found dragon Rekita, who wrote Revm, which unlocked the whole simulations game. Then we put Revm in foundry. Then we're like, okay, where else should we put RevM? Let's put in a node. Basically the thesis was, if we have a very fast operating system, that is the EVM, put it everywhere and things will get better. Smooth brain approach. Then we had observed a lot of issues with and tech debt with our software that was built from 2020 did.
00:08:33.976 - 00:09:15.400, Speaker A: So we did a rewrite of that and also achieved more performance. And most of the software on the left side on the prepared M roster are semi deprecated at this point. So we're kind of looking forward and storm later today will also talk to you about Cryo, which is our approach to data. So you can see how there's sort of like a full stack infrastructure approach here, and it's unclear what's going to happen next. It's possible that we want to move up to higher obstructions, whether it is like application layer infrastructure, like a shared sequencer or anything else, we don't know. If you have ideas, please come to us. We're happy to talk and collaborate.
00:09:15.400 - 00:10:01.212, Speaker A: This talk is all about Ret. So after a ten minute intro, we'll get to the topic. So Reth is a new Ethereum execution layer. It is Apache MIT licensed, which means that it's free for anyone to use fork. Do whatever you want with it, use it in your code basis, use it for commercial use, we don't care, just use it. The very non obvious thing about rhetoric is that we see it as an SDK for EVM infrastructure. What does this mean? It means that not only is it a node, it's a platform that you can build things and reduces the cost of shipping something that people would think was hard to a few days or weeks.
00:10:01.212 - 00:10:34.360, Speaker A: And we will hear from people today talking about it. We're going to hear about op ref, we're going to hear about mev ref, we're going to hear about ZK EVM using Reth, Rev, etcetera. There seems to be something going on here. Here I have two ips hosted on the same box, by the way. So we're running an archive and a full node on the same machine, or something like 500 or $600 a month, which is pretty cheap for what you're running on it. So if people want to hit that endpoint, feel free. Maybe it will crash, maybe you will.
00:10:34.360 - 00:11:29.014, Speaker A: So what? Performance is very encouraging. Contributors are excited, and we're still barely scratching the surface. And this is a slide that is two months old at this point. And we didn't do new benchmarks, but the rough trend remains the same. Ret outperforms other nodes, from two and a half x to I lost count, like 15 to sync and on database size. It also outperforms things that we thought were already on the efficiency frontier. And based on our most recent findings, it seems like we can do even better than that on the RPC performance, which is the read loads that many people are interested about.
00:11:29.014 - 00:12:16.110, Speaker A: For example, if you're an RPC provider, if you're an indexer or anything else, Ret also provides sustained throughput up to 16,000 requests per second. Which is a lot of queries. A high success rate and most notably in many cases one or two orders of magnitude better latency. So for point queries many times you will get a response basically instantly, whereas other times other nodes will go through long code paths for no obvious reason. So we're quite excited by that. And big kudos to the team for achieving this big feat. So we get asked all the time, is this production ready? Is production ready when Reth.
00:12:16.110 - 00:12:41.090, Speaker A: Whatever. So to be clear is Alpha software right now we're on the alpha seven release. We're going to have an alpha eight release soon. Sometime by Cancun we'll have a beta. And by the end of the year it will be hopefully production ready. Today it's not. So here we have Raul, who will also speak to us later today about his other adventures besides risking 32 ETH in Alpha software.
00:12:41.090 - 00:13:01.270, Speaker A: Risk, reward. Right? So yeah, Raul, one day he came to us and he's like, hey guys, I'm running this node. It's working great. And we're like, testnet, huh? No, he was on Mainnet. But you know, again no warranty. If you lose your money, it's your money. Nothing.
00:13:01.270 - 00:13:32.790, Speaker A: A quick case study. Again. We'll hear about that later. We have Opreth. Opreth is a set of patches on Reth similar to op Geth, which is a set of patches on Geth to enable usage of Reth in L2's. Specifically in optimism. Now what's special about what happened here is that we had a chat in mid July with some people from Coinbase, Roberto, who we have here, and some people from Op, which we also have here.
00:13:32.790 - 00:13:56.330, Speaker A: And basically we were like, this can't be that hard. It's a bunch of patches. Surely you guys can do it. Let's give it a try. And what happened? We set up a chat room and we did a weekly call, 30 minutes a week. Some effort from our team. But what was very impressive was how these people, like Roberto, I think, didn't know rust even when the project started.
00:13:56.330 - 00:14:39.990, Speaker A: These people figured out how everything works mostly on their own. And as of yesterday, we're almost at the tip of girly base in one month, when others would think that this would take until December, January, February, roadmap level things. Whereas this is a good example of how people are able to understand how not simple codebase works, get into it and modify it in non trivial ways while being safe, or hopefully not introducing new things. Matter of fact, we found a bug in op geth. As of last night, due to this small thing. Small thing. So we're building a platform, we're building an SDK.
00:14:39.990 - 00:15:05.410, Speaker A: What are the uses? Multiple ones. Personally, I'm most excited about the wave of experimentation this can enable. So it's not just that, hey, we have some existing use cases that will make better. That's great. We'll productionize them. This also enables you to dream more and many times your imagination is bound by the tools that you have available to you. And when that is unlocked, you start thinking bigger.
00:15:05.410 - 00:15:27.360, Speaker A: So what we can do, I do not know. Novel node architecture is particularly interesting to me. And in general, the introduction of more low level cryptography primitives on Ethereum. You can do this today, by the way. You can do ret equals git, whatever, and you can use reth. And I'll go over some examples. So we'll go over two examples.
00:15:27.360 - 00:16:12.134, Speaker A: One is direct DB access, which means this will get a bit more technical, but people should be able to follow. It is insane that we're querying nodes over JSON RPC. It's just insane. Like when you have an sqlite file, you don't spin up a rest API to talk to it, you talk to the damn file. So what we're going to see is that by having a good abstraction for querying the database directly, you can get a lot of efficiencies without requiring you to be an expert. And we will also see a perennial problem that exists in all node operators, which is, hey, I have a node, I want to add some functionality in it. I click fork on Go Ethereum, I add a bunch of spaghetti code.
00:16:12.134 - 00:16:52.904, Speaker A: And then when Geth releases the new release, you end up like rebasing for like a week or a day wasted time. So instead it would be nice if you're gonna extend the node and get the CLI and everything all good without having to fork it, because that way we have some canonical implementation we can all agree on, we don't waste time rebasing, and we have a unified ecosystem in the end. And that's the goal. So I don't know if this is visible from behind. I hope to some extent. Basically just to walk you through this snippet, you import four things. You define your main and the result type doesn't matter.
00:16:52.904 - 00:17:55.230, Speaker A: And you do a few very obvious things, right? You open the database, you query, you get a handle to the latest state to the database, and then you query the database. You say, I want to ask this address and this storage slot, what happened? Or if you want to query the historical state of the database given just a file, right? All I'm giving it here is a path to a MDBX file and that's it. No RPC, no nothing. I'm reading bytes and this shows a very simple example of how I can either query the latest state of ethereum or any historical state, which is really powerful. You see, this is like what, like 24 lines total? And you already know how you can iterate through any table, right? So this is just for state. You see, I am importing state provider, an account reader. You could import transactions reader and then you can imagine easily how you extend this to simulate, pass it to EVM, build block, make one.
00:17:55.230 - 00:19:04.956, Speaker A: Anyway, in practice we saw retindexer which may be not visible over here. Basically a guy that like is a VP at AavE who didn't know much rust, imported the library and in a weekend or a week had a POC retindexer that walks the entire logs table, skips non relevant logs based on the bloom filters. ABI decodes them, puts them into postgres, and outperform the hosted solutions by 75 x. Okay, that's money, right? People pay for this stuff. So if you can build things that outcompete or hosted things with open source code in days, that says something about how the infrastructure landscape will evolve in the next year. For CLI extensions, I'm showing you here the trait that we have implemented that basically says if you implement any of these methods, your node will get overridden functionality. And we have two methods, one called extend RPC modules, another called Spawnpayloadbuilder service.
00:19:04.956 - 00:19:45.918, Speaker A: Extend RPC modules add new rpcs. For example, let's say I want to add a paradigm RPC. I can define it, and I can get it very easily on the node without forking. And I can also spawn a different payload builder. So by default, nodes usually will query the mempool for transactions to build a payload when they need to propose a block, or if they're a builder. But maybe you want to add an alternative strategy and we'll hear from that later today. So just again, to give you an example of how simple the JSON RPC API is on the right you say hey, this is, I'm giving my API a transaction pool.
00:19:45.918 - 00:20:29.006, Speaker A: I'm implementing a method that I defined, I, and I gave the whole format for that. It should be called I define it, then I put it in my extend method, and things are working. And then now you can query txpool, the txpool API, Txpol extend API. Again, this is a powerful abstraction. For example, you're alchemy, you're in Fuhura, and you want to add some kind of extra bespoke RPC that you sell to your customers. You can use this very easily. The other in practice work where we have the developers off here is that basically you can build a builder and then you can shove it in the node without having to fork it.
00:20:29.006 - 00:21:26.642, Speaker A: Whereas if you look at other builders, they're all forks of Geth or the builder that are forks of Fairygon. Have even more edge cases in theme. So the next steps for us now are the following, and I realize this is a lot, so maybe we'll do fewer of them. But first and foremost, the goal of this event also is to foster an ecosystem. We want to talk to developers, we want to make sure that people, we're building something that people want first and foremost, and this is useful and it's going the right way, and we're going to provide all the support needed to make this happen. We have a new release coming soon, which has the full node as part of the proper node suite, which will allow people to be running it on lower end hardware and allows pruning depending on whatever table you want, whatever distance you want. So the goal being that you can get a tiny, tiny node just with what you need.
00:21:26.642 - 00:21:56.636, Speaker A: So if you're a Mav searcher, maybe you don't need all the receipts, maybe if you're, I don't know. Yeah, anything really that you want to customize on the database. Cancun is coming soon, the new big Ethereum upgrade. We're almost ready there. We want to clean up some tech debt that the node has internally, which is just a natural outcome of building it over time. And yeah, Oprah, more performance. We're exploring parquet files for our snapshots.
00:21:56.636 - 00:23:01.340, Speaker A: So if you're a data person or python rust, talk to us. And we're very excited about virus R and D that we're doing in particular three directions. One, which is a async IO database. So I O is the biggest bottleneck right now in every node, and building a database that is from the os level, async using a new kernel functionality called IO uring, is very powerful. We have good, not technical progress necessarily. We do have a proof of concept, but we have definitely understood the design space for parallel EVM, and we think we can make it happen. And finally, we have a vision about a very, very tiny node that holds only state and proxies to other nodes for any immutable data, and that's obviously like a serverless style deployment where you can deploy multiple compute, let's say clusters on the edges, while you have all your storage in a big GCPDB or whatever.
00:23:01.340 - 00:23:29.270, Speaker A: Yeah, that's it. Thank you for being here. This is going to be a great day. I'm very excited. I can take a couple questions and then we can move on to the next speaker. Do we have a mic? This one is off. Oh, that one.
00:23:31.970 - 00:23:42.786, Speaker B: Share a memorable bug that you faced while building reth? And was it a result? Was it because of using? How did rust also play into debugging or solving that bug?
00:23:42.938 - 00:24:20.080, Speaker A: Yeah, of course. So one bug or ten or 100? The most memorable bug was when we were implementing the stateroot verification algorithm. So the stateroot is a thing in Ethereum, where you take the entire Ethereum state, all the keys and values, you hash them, subject to the rules of the mercury Patricia trie, and then you produce a Merkle root that says, this is a digest. This is a certificate of the current state of Ethereum. The hard thing there is, all your data is hashes. So anytime you have a bug, it's a hyzen bug. You don't know where it is because all hashes look the same.
00:24:20.080 - 00:25:13.314, Speaker A: So the biggest issue in debugging these things always was due to mev bots and self destructs. Because mev bots, basically, when you're calculating the storage route, the issue, it comes around destroyed accounts when an account goes back to zero, etcetera. So there's a bunch of like, very domain specific activity which may cause edge cases that are impossible to debug. So our approach to debugging these very crazy corner cases was we had to figure out how to run the node on slices of the chain. So instead of rerunning the entire sink, have a very fast feedback loop around snapshot run for a million. If it bugs, go block by block. We basically did get git bisect, but in the node to be able to figure out the exact block where something happens.
00:25:13.314 - 00:25:37.090, Speaker A: And when you have git bisected, you usually find a problematic block. You go to the block you see, oh, mav bot self distracted a thousand times. That's probably where a bug is. So that would be the most memorable bug for me, at least. Now there might be others, but for me, that was a month and a half of very hard work. To get over it, let's do one more.
00:25:42.390 - 00:25:53.090, Speaker C: Hey, when you're thinking about getting rust developers, do you typically find just eager developers and get them to learn rust, or do you find more people who already have experience in rust contributing to things like rest?
00:25:54.430 - 00:26:16.444, Speaker A: Both. Right. So we have hired everyone that we work with out of the issue trackers. So there were people that already knew both Rust and Ethereum. It is the case that many times very talented developers will come up to speed on rust very fast. They can get productive. So I would say it's both.
00:26:16.444 - 00:26:30.060, Speaker A: Yeah. I don't think there's any reason why you shouldn't be giving it a try, though, if you care about performance. Low level. Okay. In the interest of time, thank you all for coming. And we will hear from our next speaker, Matt sides on foundry.
