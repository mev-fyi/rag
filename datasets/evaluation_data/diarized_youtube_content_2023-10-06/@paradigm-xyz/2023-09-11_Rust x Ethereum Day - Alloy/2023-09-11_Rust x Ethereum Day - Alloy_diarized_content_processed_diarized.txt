00:00:00.240 - 00:00:43.784, Speaker A: Go. All right, so I'm James Prestwich. I'm here to talk about alloy, which is the newest member of the Rust Ethereum stack. Still, I think Alloy was started early this year when we decided we just wanted to trash all of ethers and rewrite everything from the ground up, eliminate all parity dependencies, and use proper modern rust to do these things. The parity libraries had the unfortunate downside that they were in in 2015, and rust as a language barely existed back then. So these days, we have async await. We have gats, we have const generics.
00:00:43.784 - 00:01:23.020, Speaker A: We have all these nice features that we wanted to integrate into ethers, and we were just better rust developers than we were three years ago when we started this project. So alloy is now a collection of the most powerful, fastest, most intuitive libraries for Ethereum developers. It is a successor to the Ethers project and will eventually cover most of the scope of ethers. Some of the things like Ethers, Soulsea. We're going to punt right out of the project because I don't want to handle that. That's going to become evalir and Matt's project problem, I think. Yeah, thank you, buddy.
00:01:23.020 - 00:02:00.696, Speaker A: So right now, alloy is primarily me and Danny. Danny I don't think, was able to make it today, but over the last eight months, give or take, that we've been working on this. We've put a huge amount of effort into bringing it up to snuff. Alloy today is usable and useful. It's being integrated into places like optimism, arbitrum, risk zero, Zethe. It's making its way across the ecosystem pretty quickly, which makes us feel really good about ourselves. Alloy is a collection of libraries.
00:02:00.696 - 00:02:48.750, Speaker A: We've tried to keep this to low level, useful things. In the Ethereum ecosystem, we focus primarily on the interface between rust and the EVM. That means the primitive types of solidity type representations, JSON, Abi files, Abi encoding and decoding. We feel that we have done the best job of this out of any libraries out there in any language, no matter who that wrote them or what they do. And I'm going to talk a little bit about what the components we built are and why we think they're better than everything else by wide margin. And it's not just because of our egos. So the first thing we wanted to do was get away from parity's ethereum types.
00:02:48.750 - 00:03:29.744, Speaker A: These were written again seven, eight years ago, barely updated since then. They have a number of deficiencies and cause dozens of telegram support questions every day that we just have to answer with use the debug formatter. I've said use the debug formatter like 50 times a week for the last three years. So we decided to start with the primitive types. This means addresses, uints, signedints, fixed byte arrays, and dynamic byte arrays. We based it on Remco's work ruint, which I think he's going to be talking about in a little bit. So you're kind of going down through the stack here.
00:03:29.744 - 00:04:15.244, Speaker A: Start with Reth, work down through the alloy, and then into ruint. That everything's based on alloy primitives is substantially complete. We have a lot of support for different features and is being used in RevM, ref, and other places. After alloy, we wanted to get into Abi encoding, and we decided to shave the yak first. So we want to to make it really easy for rust and solidity to communicate. That means that we need an idea of what it means to communicate with solidity. And I'm going to get into why the solidity syntax parser is important in a minute.
00:04:15.244 - 00:05:02.030, Speaker A: But basically Danny just went out and one man armied an entire solidity ast representation, just parsing solidity source into tokens that rust can operate on effectively. So you can actually just load your contract into rust right now. We'll parse everything out. We won't compile it, but we will have an ast representation. Okay, we wanted to make Abi encoding easy and fast. Abi encoding is schema based, so the only way to build an encoder is if you know the types that you're encoding and decoding. So it kind of follows from there that the first thing you do is make a representation of the types that you're operating on.
00:05:02.030 - 00:05:45.630, Speaker A: In practice, this is all solidity types. You know, the bytes, 32 Uint, 256 solidity structs errors, events. So we went ahead and wrote a static representation of all of those types in rust. Anything that you can represent as a solidity type, you can now represent as a rust type. All of these types are zero sized. They disappear at runtime, and we use them to make very well optimized static ABI coding routines. Rather than like loading everything into some dynamic type representation, we just generate a coding routine at runtime for every type that you actually use in your program.
00:05:45.630 - 00:06:45.186, Speaker A: So you are actually representing your solidity type system that's in your contract in rust and letting the rust compiler hyper optimize your encoding routine. This makes us two to three times faster than the next best encoding routine, and more intuitive to use, because you can actually just write solidity. As you see here on the slide. We've got that. Bool two, we represent that solidity in rust, and that's what we work with. So in order to make this even easier, because you don't want to be writing fixed array, bool two, like the complex rust type name for this simple solidity, bool two, you just want to copy paste into your codebase. So we wrote a procedural macro that lets you just copy solidity into your codebase.
00:06:45.186 - 00:07:33.950, Speaker A: You can copy entire interfaces, contracts, everything into your rust code base. It will automatically generate all of the soltype types, expose them to you, and let you just move them around, use them like native rust types. And this is powered by the syn solidity astparser that we talked about earlier. We are moving towards a world in which you just point rust at your foundry project. It automatically loads up every type that you use and has a static hyper optimized encoder for everything. And you don't even have to think or worry about it. So it allows you to embed your solidity contracts in a rust code base and not even think about encoding decoding.
00:07:33.950 - 00:08:27.766, Speaker A: No more loading up JSON files to get interfaces, no more expensive runtime parsing of these things. It all happens at compile time, and it makes the fastest possible ABI encoder in case you do want to do things at runtime, because you need to do like a mevbot or you need to do EIP 712 signing or something like that. We also wrote a dynamic ABI encoder. This means a dynamic runtime representation of slow to do's type systems and values. The purpose here is to allow for the sign typed data RPC request, which I think is also Remco's fault. Somehow you don't know when you compile your signer what you're going to sign. That's just the way it works.
00:08:27.766 - 00:09:18.494, Speaker A: In order to handle that, you need to be able to represent those types at runtime. So while alloy Sol types has no runtime overhead from the type system, Alloy Dynabi lets you be a lot more flexible, operate on runtime types, but have all the overhead that comes with that. Nevertheless, we're doing the same thing that ETH ABi did, but we're doing it significantly faster. Danny optimizes everything just crazy, way better than I can. So even though we're not having all the benefits of static routines, it's still faster than the alternatives. So that's all of alloy that exists right now. That you can go out on GitHub and use and interact with and is ready for testing consumption still early beta pre 1.0
00:09:18.494 - 00:09:53.450, Speaker A: release. The thing I'm working on right now is alloy next. This is the part of alloy that replaces ethers provider networking JSON RPC stack. So this is the part of alloy that's actually going to talk to the nodes. The first component is alloy transports. This is like the HTTP, the websockets, the IPC code. The main thing we did here is we're swapping out custom network code for tower.
00:09:53.450 - 00:10:24.670, Speaker A: Tower is a commonly used service model in rust. It lets us get a bunch of ecosystem code for free, and we no longer have to maintain things like quorum or rate limiters in house. That's going to let us cut several thousand lines of code out of the ethers project, which I love cutting code. I love it when other people maintain useful code. Thank you. So this replaces ethers providers. The code is very generic.
00:10:24.670 - 00:11:07.924, Speaker A: It involves these huge tower associated type blocks. So I'm not showing it here. The next part of the stack is alloy networks. When building ethers, these people went out and very rudely started building other blockchains besides ethereum. We have these roll ups and stuff now, and everybody who made another blockchain decided to get clever and start changing the transaction formats. And that means changing the JSON RPC responses and arguments and everything. And before you know it, you have this data type explosion where every network uses a different transaction.
00:11:07.924 - 00:11:45.310, Speaker A: So you have to have a different object, and ethers is not built for that. Ethers middleware assumes every transaction is a transaction. It doesn't check that it's an optimism transaction or an arbitrum transaction. So new in alloy is the network abstraction. A network describes the types of the JSON RPC. So the optimism network type is free at runtime, but it includes the type information for the optimism RPC. It tells you what optimism says a transaction is, or optimism says a receipt is.
00:11:45.310 - 00:13:00.220, Speaker A: This lets us build alloy providers. The provider is abstract over the network and over the transport, so you can have a provider that connects to optimism via HTTP. If you look down here in the estimate gas, you can see that it uses the network's transaction request object. So when you estimate gas, you're providing the type that optimism says is a transaction request. This lets us use the same middleware methods and code, but swap out the actual types that you're working with so that you can specialize your code for optimism if you want to, or, you know, use Ethereum or provide your own network. The goal is to make the RPC commands that we must work with, because that's how nodes work more flexible in our code base. And the specific like user problem we're solving is as of today, you cannot use optimism and Ethereum in the same binary with ethers RS optimism is a feature.
00:13:00.220 - 00:13:48.520, Speaker A: In order to enable optimism, you have to make it not work for Ethereum anymore. After alloy providers with the network abstraction, you can have connections to both networks in the same program at the same time. And as a bonus, the traits are now object safe, so you can abstract over what middleware you're using and you don't have to manually manage that anymore. And every user facing part of the API gets simpler. So that's the slides for today. Does anyone have questions? That means I explained it really well, right? Yeah. Do we have microphones around who's carrying? I mean, if you shout at me, I can probably hear you.
00:13:48.520 - 00:13:53.840, Speaker A: There we go.
00:13:55.580 - 00:14:10.756, Speaker B: Hello. Hello. Yeah, it's very impressive to get the using the procedure macro to support solidity. I cannot imagine how many dirty hacks there, but any plan to support Yol.
00:14:10.868 - 00:15:03.540, Speaker A: Or so it's actually cleaner than you would think. It's about as clean as you can make a procedural macro. Due to the constraints of procedural macros, you can never make them really clean, but this one's not bad, relatively. We don't currently have plans to support any other languages than solidity, but we have discussed it, and the stack is designed so that you could write a syn Viper or a syn neural. If those languages support the rust token model as well as solidity does with VYPR. It's very complex because whitespace is significant and the rust token model doesn't support that. So you would need to do a lot more of the tokenization and parsing work than you need to do with solidity.
00:15:03.540 - 00:15:31.730, Speaker A: Our long term goal is to have essentially an intermediate representation, that you build these solidity things into the intermediate representation and then expand from there so that we can be a lot more flexible and build interesting transpilers and stuff. But we keep it at the code gen level. We're operating on asks. We're not operating on bytes.
00:15:32.270 - 00:15:33.290, Speaker B: Great, thanks.
00:15:42.390 - 00:16:52.400, Speaker A: Where does RLP and Ssz fit into alloy, or does it? RLP is part of Alloy. We have the RLP crate that we took over maintenance from Rethenne, which is a great implementation. So that is officially part of alloy as well. It's just significantly less interesting to talk about on stage. Ssz we have not in housed for alloy we may in the future. The focus for alloy is primitive types, and interacting with the EL and SSC doesn't directly further those goals, but it is the kind of low level pure primitive that we want to eventually support. One last are you keeping the middleware structure for customization, or have you played around with any other ways of doing that? We are likely to keep it but improve the abstraction.
00:16:52.400 - 00:17:39.490, Speaker A: This is another thing where we home rolled that middleware abstraction and we're not happy with it. So the idea is to have the provider's trait replace the middleware trait and to have a similar but better abstracted middleware stacking system. If anyone has an alternative to that. I do not love the middleware stacks that we produce. The goal of this is to make it simpler. So instead of a giant concrete type, we box, you know, or we type erase and make object trait trade objects. And that makes it a lot simpler to manage the types of your middleware.
00:17:39.490 - 00:18:11.968, Speaker A: We also have been experimenting with a tower like layering abstraction so you can have a layer builder that makes it easier to instantiate these things. But I don't love the core middleware abstraction. I just. None of us seem to have come up with anything better. Yeah, the middleware is all tech that blame 2020. If you have a better suggestion than middleware stacking, let me know. Please, someone please help.
00:18:11.968 - 00:18:13.480, Speaker A: Round of applause for James. Please.
