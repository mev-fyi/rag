00:00:00.840 - 00:00:02.206, Speaker A: Yeah, thanks for coming everyone.
00:00:02.358 - 00:00:03.790, Speaker B: Super excited to be here.
00:00:03.950 - 00:00:29.958, Speaker A: Thanks for paradigm for hosting this event. We're going to talk about two programming languages today. Any guesses which ones? What's that? Rust is one of them, not JavaScript. JavaScript is like, eh, like no one really likes it. We're actually going to talk about typescript, which is like, you know, a little different. And if you're not familiar with typescript.
00:00:30.054 - 00:00:31.534, Speaker B: It'S a superset of JavaScript.
00:00:31.622 - 00:00:58.418, Speaker A: It actually has a really important role in the crypto community, everything from Uniswap, ens friend. If you've used any of these things, they have front ends, which are primary ways that people interact with protocols and other really cool stuff we build. I just so happen to maintain a couple open source libraries. One of them is Wagme, which is.
00:00:58.474 - 00:01:01.110, Speaker B: A high level react hooks library.
00:01:02.090 - 00:01:11.210, Speaker A: If you've donated to the latest gitcoin round, you've used friendtech, you've registered a domain on Ens, anything like that, you've probably used Wagme.
00:01:11.250 - 00:01:12.938, Speaker B: It's pretty popular throughout the space, allows.
00:01:12.954 - 00:01:54.562, Speaker A: You to do stuff like connect wallets, send transactions and yeah, I mean it launched fairly recently and it's sort of taken over the front end worlds. Me and then my co collaborator Jake, who's in Australia, so he couldn't make it, started collaborating with paradigm in November last year. And yeah, just some examples of what you can do. Here's like really simple way to connect a wallet. You would think that this is easy, but there's so many different wallets out there, hardware like lots of other ones. And I, you know, if you do a little bit of configuration, wag me, and then just like put this code into your editor, you end up with something that doesn't look quite as nice.
00:01:54.586 - 00:01:55.458, Speaker B: As that because you have to write.
00:01:55.474 - 00:02:23.634, Speaker A: CSS, which is kind of disaster. But yeah, and then you can do other stuff too, like contract interaction. Here's an example from mint, fun. Just like minting nfts, pretty straightforward, not a lot of code. And so we had this like higher level reactive framework to build applications, but we wanted to move a little bit further down the stack. And so there's things like this that.
00:02:23.642 - 00:02:25.346, Speaker B: Have existed over the years, web, three.
00:02:25.378 - 00:03:11.904, Speaker A: J's, ethers, J's, and I feel like similarly to the rewrite it in rust mentality, we were sort of like rewrite it in typescript, like really, really good type safety and type inference. And so Vmdez, which is our effort for that, launched earlier this year, it's a lower level interface does JSON RPC requests Abi encoding and decoding signing it's kind of a cool thing to do because Wagme was originally written in ethers. J's we wrote VM, swapped out the underlying implementation, everything kept chugging along on all the dapps and stuff that we're using it. And so VM, you know, we've rewrote it.
00:03:11.952 - 00:03:12.624, Speaker B: It's pretty fast.
00:03:12.672 - 00:03:43.210, Speaker A: This isn't, you know, probably what you would see, you know, if you compared rust with these different JavaScript frameworks. But in terms of like encoding, it's like the fastest out there that I'm aware of right now that's used and very popular. And you know, it does some cool stuff like you can interact with anvil really easily, there's like wrappers for all the anvil methods you do use. And this is really popular and people using it in their front end like test suites and stuff like that.
00:03:44.550 - 00:03:46.446, Speaker B: This is the part that I get really excited about.
00:03:46.478 - 00:04:38.662, Speaker A: So basically everything up until this point has mostly probably just looked like JavaScript to you guys because it is, I mean, typescript is superset JavaScript and there's this really cool thing that you can do. Typescript is a terrain complete language and what you can do is you can take code. So in this case here we have like an ABI fragment which is a tuple, and then in the typescript type system you can transform it and then create static types which then, you know, add a lot of nice type safety, whereas JavaScript doesn't have any. And this is really important because you know, if you pass, you know, the wrong number value or you know, you're not passing in an address or something, people might lose money, something might break. It's not a great situation to be in. So here's an example. We have this Abi fragment and yeah.
00:04:38.686 - 00:04:40.410, Speaker B: You see a type error here because.
00:04:41.070 - 00:05:11.052, Speaker A: We know we've parsed that in the type system and then pulled it out and said, okay, this needs to be a bigint. And because it's not, it's throwing an error. Bigints in JavaScript, this would have been 420 and then an NDE after it. And you know, similar thing. You know, we don't just do types, we do like, you know, two fixed length tuples too. So here's one. The type system is really cool and allows us to do some like pretty complex stuff.
00:05:11.052 - 00:06:18.112, Speaker A: It's like a whole programming language in its own. And just to demonstrate something that, you know, I think is like even cooler, but that demonstrates the power of typescripts. This is like a function we have human readable Abis. This is a function called parse Abi, which takes basically you can just copy the signatures from your contract. It has two implementations, one at runtime, which will transform those strings into a JSON AbI, but then also a parallel implementation at the type level, which in your editor, you see I'm hovering over the symbol, it's transformed it, which is cool. So yeah, I think one thing that we've been trying to hammer on a lot is this concept of advanced developer experience, which, coming from the rust world, some of these things might look pretty similar, like making sure things are strongly typed, inferring types wherever we can. It's really nice to be able to just go into your editor and write some code and autocomplete your way to success.
00:06:18.112 - 00:06:30.976, Speaker A: And yeah, we support ABIs type data schemas. The Abis can be massive. If anyone has like a really large contract that they know of, you can tell me about it, because I'd love.
00:06:31.008 - 00:06:32.176, Speaker B: To try it out.
00:06:32.208 - 00:07:06.746, Speaker A: But this stuff works really, really well. You can just throw massive contracts at it and the type system is able to handle it all. Modular architecture. So we really care about making sure that all the functions that exist in VM and Wagme are low level enough that you don't have to do workarounds and things like that. And they're really composable and work well together. And then, because often this stuff is running in the browser, some people are building their APIs with VM and other backend related stuff.
00:07:06.898 - 00:07:08.434, Speaker B: But because a lot of this often.
00:07:08.482 - 00:08:15.010, Speaker A: Runs in the browser, making sure that it's as small as possible. Yeah, and we try to make contributing easy. Wagner, I think, has around 150 contributors. VM has I think around like 80 and yeah, really high quality docs tests, because that's the stuff that makes, I mean, that stuff can make your day job really painful if you're using library and makes it easy for people to learn. I think reading the VM docs has been really helpful for a lot of JavaScript people because it sort of introduced them to lower level concepts in Ethereum that were abstracted away before or they didn't really understand. We tried to use the same names for stuff like RPC methods, map those names, map to exactly the same names in VM for functions and stuff like that. The stuff we built has been pretty popular now for Rust, you know, writing typescript, there's some things that I am very envious of when I like, look at the rust world error handling JavaScript isn't the greatest.
00:08:15.010 - 00:08:21.486, Speaker A: One of my personal favorites is like pattern matching in rust. It's like really nice. I wish something like that existed.
00:08:21.518 - 00:08:22.702, Speaker B: There's libraries and stuff.
00:08:22.726 - 00:08:40.867, Speaker A: I feel like the JavaScript community has basically built libraries that are rust language features. Package management is another random one. Cargo is great. There's like three package managers at least that are popular for JavaScript, and then obviously performance. That's something, whenever you're writing something makes.
00:08:40.883 - 00:08:43.003, Speaker B: You feel good about it. So this is where we get to.
00:08:43.131 - 00:09:23.518, Speaker A: Maybe combining rust and typescript together. This is kind of like a blue, because typescript's blue Ferris cartoon version. And so it's something I've been thinking about is like how can you take some really great stuff, typescript types, and that's like the stuff that JavaScript developers are using in their editor and keeping things safe. And how can you pair it with something like using Rust at runtime? Maybe there are some libraries and stuff that you're lazy and you don't want to reimplement that in JavaScript. Maybe they're really solid, lots of people use them, they're extremely performant, stuff like that.
00:09:23.654 - 00:09:25.478, Speaker B: So yeah, this is just like an.
00:09:25.534 - 00:09:30.290, Speaker A: Exploration into typescript and rust via webassembly.
00:09:31.470 - 00:09:33.610, Speaker B: Sort of the goal here was to.
00:09:34.110 - 00:09:44.838, Speaker A: See if we can maintain the same developer experience, but then also like, you know, maybe reduce some things like bundle size and improve performance, like significantly, and.
00:09:45.014 - 00:09:47.038, Speaker B: Also give JavaScript developers access to the.
00:09:47.054 - 00:10:23.380, Speaker A: Rust community because there's a lot of great stuff happening. Yeah, and you know, you see the typescript logo here, it's not as great as Ferris. So unfortunate. Okay, so to set the stage, have a demo, it's going to be using ethers rs. Unfortunately I'm not familiar enough with alloy to have implemented that. And yeah, vm we're going to compare them together. So on the left hand side is ethers rs, and this is going to be signing some data which we'll look at in a sec.
00:10:23.380 - 00:10:39.200, Speaker A: And then on the right is VM. So yeah, I wonder which one's going to be faster. I mean that's pretty fast, right? Not perceivable, but it's rust. So definitely quite a bit faster there.
00:10:40.700 - 00:10:41.716, Speaker B: So what does this look like?
00:10:41.748 - 00:11:36.150, Speaker A: If you wanted to do this for one of your libraries, how would you do it? So there's some imports and stuff that's not here, and excuse my rust if it's not, something's a little funky with it here. So yeah, we're just signing some type data. So we're going to expose that method in a way that wasm can use, and then also we're going to be generating random wallet. So doing that as well. If you're not doing any crazy type level programming, which we are, in this case we are, you can just get typescript types to automatically work with this stuff without too much overhead. But in this case we're going to write some basic typescript using this library called abitype, which is one that we also work on, which does a lot of the type transformations. And so, yeah, I mean, there's not much here, it's pretty straightforward.
00:11:36.150 - 00:12:05.422, Speaker A: And yeah, and then in terms of what you have now, you run Wassimpack and now you have this library that you can use. This is in JavaScript now, and you get all the benefits of rust behind the scenes. And then you also get the benefits of typescript, really strong type safety inference, auto completion and yeah, works really well. So, you know, what does the future.
00:12:05.446 - 00:12:05.982, Speaker B: Of this look like?
00:12:06.006 - 00:12:58.216, Speaker A: WASm has been around for a while. No one's really used it. It's not like, I mean, it's not like a frequent thing that people are reaching for all the time. What are some reasons for that? Well, unless you're doing something extremely computationally expensive where you're okay with like having some maybe context switching between different languages and you're okay like going over the Wasm bridge and taking that hit, and then maybe loading some extra bundle size depending on what libraries you're using. Otherwise, you know, people have sort of stayed away. But some things that I'm excited about as stuff improves is maybe we can swap out some internals in vm, like we have our own AbI encoding decoding in there, which is pretty fast like you saw, but you know, it doesn't compare to rust. So if that becomes a bottleneck eventually, maybe we want to swap it out.
00:12:58.216 - 00:13:56.360, Speaker A: Another thing that I think is really exciting is maybe running anvil or something like it in the browser someday for simulation or other things like that. And another thing, I think it would be cool if for certain things that are applicable to a wider audience, maybe people that would use JavaScript libraries, that there's implementations that already exist in rust, adding typescript types and was unpacking your rust library because then you don't have to write that much JavaScript, you're only really writing the type level. And yeah, super down and chat about this more. I think it's exciting, and it will only get better if there's some cross pollination between communities and people are working on stuff, especially in crypto. I think there's maybe some exciting use cases. So yeah, typescript loves rust. So there's actually one more thing wanted to chat about here, which is this thing called Rivet.
00:13:56.360 - 00:14:43.288, Speaker A: I'm not sure if anyone's seen this, but we announced this this morning and rivet is. So right now we find ourselves in this situation where as developers, most of us are using consumer wallets and global test nets to write our software, which aren't really meant for this use case. At this point, consumer wallets don't necessarily have features that you need to debug stuff and iterate quickly. If anyone's tried to do stuff, run anvil and use metamask and have to reset nonces and stuff like that, it's not very fun to do. And then global public test nets, sometimes iteration speed is slower, you have to deploy things, you have to scrounge up some testnet eth and things like that.
00:14:43.424 - 00:14:46.112, Speaker B: So yeah, the goal of what rivet.
00:14:46.136 - 00:14:48.040, Speaker A: Is, is what if we built some.
00:14:48.080 - 00:14:50.496, Speaker B: Tools for developers to use?
00:14:50.608 - 00:14:56.488, Speaker A: And so that's what rivet is. It's developer wallet and devtools, sort of.
00:14:56.504 - 00:14:57.576, Speaker B: Like react dev tools.
00:14:57.608 - 00:14:58.880, Speaker A: If you've used that or any other.
00:14:58.920 - 00:15:01.216, Speaker B: Browser dev tools, it's a little bit.
00:15:01.248 - 00:15:31.714, Speaker A: Higher level, allows you to manipulate state of anvil so you can really shorten the feedback loop to doing stuff like send a transaction. Okay, now it's reset. Need to like add some balance or fund an account. Just click a button to do that and yeah, we're super excited to collaborate with paradigm on it. You can just go to this link if you want to try it out. It's in like an early alpha state and I'm going to show it to you here in this demo. So we're on uniswap.
00:15:31.714 - 00:15:58.534, Speaker A: This is Uniswap's website. We can connect to it, we can pick some eth amount, swap to USDC. The cool thing about this is you go to any website, start interacting with it. In this case, we're not going to confirm the swap right away. We're going to change our balance so you can see how it works. We're going to auto mine or manually mine here. So we switched our balance to ten and now we don't have enough.
00:15:58.534 - 00:16:37.840, Speaker A: So everything is updated appropriately. So let's add some eth back to our balance and mine that and then let's switch to interval mining so we don't have to manual press stuff anymore. And then yeah, we can just swap and it's done. Once it comes up to confirm. Yeah, and so yeah, we just swapped it. You can see the nonce incremented, we can see the transaction went through. Yeah, we're super excited to keep building on this and making sure that it's really solid and something that shortens iteration time for people, allows people to collaborate.
00:16:37.840 - 00:17:12.014, Speaker A: One thing that we're really excited for is this notion of time travel debugging, where you can just jump back and forth on the chain to reproduce issues that users are having and just move really quickly. So yeah, that's rivet. And if anyone has any questions, happy to. You can go to these links. If you want to learn more about our JavaScript typescript, we're going to do.
00:17:12.062 - 00:17:13.490, Speaker C: Two questions for Tom.
00:17:25.560 - 00:17:47.096, Speaker D: Maybe you can't answer this, but why do you think the Ethereum foundation isn't pushing forward a lot of these ideas? These ideas are excellent and badly needed. And how hard is it going to be to push these ideas back into the Ethereum foundation, if at all? I wonder? Maybe you can't answer that, but yeah.
00:17:47.128 - 00:18:18.710, Speaker A: You mean stuff like developer tools or Rastwan? Yeah, I mean, I think the Ethereum foundation is great. Like they set up some roadmap and things like that, but Ethereum is like a community, so people are just working on stuff that they find cool and taking initiative. So yeah, how does it get back in there? I don't know. I feel like community already does a decent job, but I think, yeah, sometimes it is good if stuff comes from like a respected trusted source too. So I don't know.
00:18:19.260 - 00:18:32.440, Speaker C: And maybe to add on that, that the EF is responsible for fostering an ecosystem, but ideally the ecosystem, it should be antifragile. The EF should be able to disappear tomorrow and the ecosystem should still move forward.
00:18:41.820 - 00:18:48.612, Speaker E: Thanks. I was curious, what's your experience with WASm and the maturity of it in terms of adoption in the browser? A little bit more?
00:18:48.756 - 00:19:28.720, Speaker A: Yeah, I haven't used it a whole lot other than just experiments around it. So yeah, I guess that's mostly it. I mean, from what I've seen, just based on diving into it really quickly, it's like the developer experience of me jumping in with no knowledge. There's a little bit of learning curve to figure out how to package these things up. But once that's done, this wasm wallet package, you can go to NPM, it's available there, or you can go to this website, Wasm Dash wallet Vercel app, and just try it out and it works pretty well. So stuff's definitely a lot better than it was, like, five years ago when I tried to hack on it then.
00:19:30.500 - 00:19:32.840, Speaker C: And one last question from James.
00:19:37.660 - 00:19:46.310, Speaker F: In the same vein. Have you done any bundle size comparisons for the wasm versus.
00:19:47.530 - 00:19:54.830, Speaker A: Yeah. So this specific case, the bundle size was actually increased a little bit, but there's a lot that you can do to try to, like, eliminate that.
00:19:55.570 - 00:20:12.500, Speaker F: And I'm asking because in the past, like, the reason I moved on from a lot of wisdom stuff is because the bundle size blew up and, like, webpack and the whole pipeline was not well suited did to ASm. So I have quite a bit of experience here if you need help.
00:20:12.580 - 00:20:13.028, Speaker B: Totally.
00:20:13.084 - 00:20:14.640, Speaker A: Yeah. Very interested.
00:20:15.860 - 00:20:16.860, Speaker C: Big uploads for Tom.
