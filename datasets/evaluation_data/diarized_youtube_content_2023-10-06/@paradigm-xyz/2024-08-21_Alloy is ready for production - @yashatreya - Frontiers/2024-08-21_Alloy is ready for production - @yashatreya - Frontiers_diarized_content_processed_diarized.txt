00:00:00.160 - 00:00:55.940, Speaker A: Ethers Rs. Alloy enables new API improvements and features that weren't possible in ethers before, and we needed to rewrite for a multi chain world. When ethers was developed, rollups were in their infancy, let's say. Now they're in their adolescence. So that's what we've designed Alloy for. So let's get started. So Alloy is right off the gate, already used by the best teams to develop state of the art products such as Ret Foundry, the SP one, ZKVM companies doing data infra mev stuff, and also the fraud proof implementation by optimism Kona one thing to note there is they have a no standard implementation, no stdin, and Alloy is still capable.
00:00:55.940 - 00:01:46.200, Speaker A: Because certain crates in alloy, like the Eips and the consensus types are no standard, it does not make sense for us to make networking related like provider and transport. No standard, obviously. So in this talk, I'll mostly go through an overview and highlight the most powerful features of ally. Now, when ethers was written, it was probably state of the art, and it was the best thing out there to interact with EVM blockchains in rust. But times have changed and so we're introducing alloy. And the first building, low level building block of alloy is the primitives, which are great and powerful. You can also write solidity in rust now with the Sol macro.
00:01:46.200 - 00:02:30.570, Speaker A: And to prepare for a multi chain world, we're introducing a network types abstraction, which enables you to interact with multiple chains easily. And lastly to override provider behavior, modify RPC requests and responses. Previously you had ethers middleware. The devx with that was cumbersome. I'll talk more about that later, later in the slides. But we've introduced a new way to do the same and achieve better results in an easier way, using what we call layers and fillers. So yeah, so right into alloy primitives.
00:02:30.570 - 00:03:42.160, Speaker A: Firstly, we've re exported Rowan's U 256, which is the big int for handling solidity U 256 types. And it has all the features, starting from exponential powers, math Ops, bitwise operations, even boolean comparisons and converting them to rust primitive types. That might make you lose some precision, but it's definitely better if you want to print some begins or display them elsewhere. So we have a type called fixed bytes in the alloy core grid, and that essentially is the fundamental unit of representing byte arrays in the EVM. Now in RevM, in ret, et cetera. And the way that it works is it's generic over the length of the byte, and you can. So the foremost example, let's say, is the address type from the alloy grid, which essentially is fixed bytes with a length of 20 bytes under the hood.
00:03:42.160 - 00:04:18.600, Speaker A: And you can see that Alice, the address of Alice is actually equal to fixed bytes. So now you can create your own named fixed types like we did for address. We even wrote a macro for it. It's called wrap fixed bytes, where you just pass in the named type that you want separated to avoid type confusion and. Sorry. Yep. So a little bit diving into the wrap fix by its macro.
00:04:18.600 - 00:05:01.430, Speaker A: So the problem you face in while developing an EVM land is that a lot of these things are represented by hashes, sometimes of the same length, sometimes of the different length. And the most common is the 32 byte hash. Now, it can be the catch act. Output is also 32 bytes. The Merkle tree item is also 32 bytes. Now, if you're using only fixed bytes to represent both of them, best case, you can have error prone software, some incorrect logic while decoding stuff, and worst case, your program panics. So to do that, you can use the wrap fix bytes to name and differentiate the fixed byte types.
00:05:01.430 - 00:06:26.456, Speaker A: So what we're doing here is essentially creating a catch hack output and a merkle tree item, and you can differentiate them while you're writing code well into the meat stuff. Now, alloy sol macro, this lets you write solidity in rust. It's a complete overall of the ethers Abi gen micro, which would only allow you to point to Abi JSON files or write Abi string representations and then create bindings for them. How we accomplish this is essentially because of the ally Sol types, compile type bindings, and the sole type traits. So, and we also use the natively written, it's part of the alloy code, the syntax solidity parser, and it's currently used by Forgebein Tim presented in the in the foundry position presentation that you can use the alloy flag to generate rust bindings for alloydeh. So the solidity macro essentially allows you to interact and deploy contracts very intuitively. So we've completely rethought how you should be interacting with solidity contracts when you're writing.
00:06:26.456 - 00:07:49.454, Speaker A: The best programming comes out when you're interacting with a system that has a different vm and a different language, but communicating with that system feels native. So to do that, we have the RPC and the bytecode attributes in the Sol macro, which essentially let you create bindings and communicate with the on chain contract. It can also let you deploy contracts if you specify the init code in the bytecode attribute. How does it do this? It uses the call builder type, which essentially is a wrapper around the ETH call and ETH send transaction RPC and it takes care of all the ABI encoding when you're passing it ARG's and sending your transaction or your ETH call. And it also decodes the return values so that the developing experience is intuitive and easy to use. Similarly, we have the event subscription. Now, without setting up filters for listening to logs or events, you can essentially just use the Sol macro, pass your event in solidity and create a filter for it.
00:07:49.454 - 00:08:36.736, Speaker A: It also provides you with the subscribe method for subscribing to a stream. And also you can use a watch method in case you want to poll the endpoint and not subscribe. It obviously uses the esubscribe RPC under the hood. And again Abi encodes and decodes the logs. So what you can see there you have a decoded ad log and the raw log itself, making it easy to interpret. So now in 2020, in October 2020, Vitalik wrote an article on the ETH Magicians forum. What would a roll up centric world look like? At the time, optimism arbitrum were in their infancy.
00:08:36.736 - 00:09:59.722, Speaker A: They were active on test nets and we didn't have the reality, what we have right now, which is we have n number of roll ups with companies like conduit, enabling us to deploy different stacks, l two s, l three s, et cetera. While it looks like a very vibrant ecosystem from the outside for users with billions in defi, TVL and Farcaster, decentralized social and everything, it's actually, it can be a difficult experience for developers since all these stacks and networks have n different transaction types, receipts and network specific implementation. So what it actually looks like is this. This is actually code from ethers rs, which is using different network implementation and transaction type and gating them behind the optimism flag. For example, the optimism deposit transaction, which has a deposit nonce field, which if you would use natively to deserialize without actually by just the vanilla implementation ethers, it would crash your program. And similarly, we had to write shallow middleware in ethers. This actually, you don't get to roast your boss's code everywhere.
00:09:59.722 - 00:11:34.072, Speaker A: So, yeah, and so people ask, can devs do something? And we did something. It's called the Alloy network trait, which essentially unifies and the consensus and the RPC types of different networks, and making the alloy library ready for a multi chain, multi roll up world. The network steroid essentially defines the shape of the network, so it lets you implement a type safe network representation for example, this is the network representation for optimism. The only difference from the vanilla representation of Ethereum is the op transaction receipt and the op receipt envelope, which essentially contains the extra field deposit nonce. And so now you don't have sword crashes anymore, you don't need to have CFG feature flags and different compilation configurations, et cetera. You can capture the network specific nuances such as the deposit nonce l one block number, gas user l one all into one and easy abstraction. But in case you don't want to write your own network implementation and you're not familiar with the network, but you still want to get started developing, what you can use is the any network type which we already have in alloy network.
00:11:34.072 - 00:12:35.520, Speaker A: It essentially serves as a catch all for all network variations, and it will consume all the extra fields that optimism, arbitrum, or any other network has and serve. Flatten it and put it into the other field. How does it do that? It leverages a type called with other fields which is generic over the transaction type. The inner field is the transaction itself. Any other extra fields in that network's transactions are passed to the other field, and you can easily write a small struct and just easily deserialize or serialize after the network request. Now, getting into the alloy provider, which is probably the most used part in ethers, you have to interact with the network. And especially now in a multi chain world, you want the provider to be generic over the network you're interacting with.
00:12:35.520 - 00:13:41.470, Speaker A: This would enable you to interact with not only one network, but two or three or even more networks at once in the same code base without feature flags. So here's an example of the provider builder, which is building two. One is Ethereum, which is the default provider in alloy, and another provider for op, which uses the optimism network implementation, which I showcased previously from the op alloy crate. The provider builder enables you to build a root provider with different configurations, not only networks, but layers, fillers, which I'll talk about in the next few slides. You'll see the builder pattern in alloy. Quite often we think it is the most intuitive and safe way for amateur developer to get started and build a provider. So ether is middleware.
00:13:41.470 - 00:14:24.270, Speaker A: It's a thing of the past. It used to help you modify behavior of the provider and your transport. So every time you wanted to sign a transaction and send it to the network, you'd write ethos middleware. Every time you want to send a flashbots bundle, write ethos, middleware, caching, gas, escalation, you name it. You need to write ethos middleware. This approach was great at the time, but it's also too error prone and it has cumbersome devex and it needed a rethink. Introducing alloy layers and fillers completely overhauls the ethers middleware framework, but achieving the same results in a better and easier way.
00:14:24.270 - 00:15:27.536, Speaker A: We build upon the tower like layer and service architecture where you can stack up multiple services. By the way, tower is a networking library, if people don't know, that allows you to stack multiple services like ray trilayer rate limit layer, concurrency layer. So we have built upon the similar principles of Tower and essentially separated the layers that you want to build, custom layers that you want to write into their own use cases and buckets. So the mental model how you should think about this is essentially three buckets. So if you want to write a layer that's independent of the RPC method, you're calling that. Essentially you want something like a retry layer or a rate limit layer, a cache all layer that caches all your responses. Or just simply a logging layer which just logs the serialized requests and responses that you send and receive.
00:15:27.536 - 00:16:33.240, Speaker A: So in order to do that, you'll write a transport layer implementation. We already have a retry back off service layer inside alloy that you can use, that currently is used by foundry to retry requests. And in case you want something more granular, in a case where you want to know the you want RPC method awareness, where you want to know which method you're calling and how the response or the request should be structured accordingly. So you'll write a provider layer implementation for that. An example of that is a multi data source layer. So let's imagine you want certain methods of the RPC to fetch directly from the network and certain methods to fetch the response from the cache if available. So you'd write a provider layer implementation that will let you do that and granularly override the provider trait and write the implementation for each RPC method you want.
00:16:33.240 - 00:17:17.530, Speaker A: Now, if you want to override the transactional lifecycle, which basically means you want to set gas params, you want to manage nonces sign transactions. So anything related to filling the transaction related fields should be managed by the provider filler. More on that in the next few slides. So layers again, like I said, it lets you modify and override behavior of the transport layer and provider. You can stack multiple layers on top of each other and have them work together at once. Fillers. So fillers manage the transactions lifecycle.
00:17:17.530 - 00:18:06.976, Speaker A: It essentially enhances and provides a frictionless experience. For example, we have a method called with recommended fillers on the provided builder, which essentially implements a gas filler, a nonce filler, a chain id filler. And in case you want to use a wallet filler, you can just do wallet and pass your wallet to it. What will happen next is every time you send a transaction request, you never have to fill in the gas parameters, the nonce, the chain id, or sign transactions manually. So what you see here on the. On your right, sorry. On your left is the with recommended fillers flow, and on your right is the vanilla flow that you do without flavors.
00:18:06.976 - 00:18:51.380, Speaker A: So you can see the difference in the lines of code. It's just six lines versus about 1520 lines. Yeah. So what's next? So currently, due to the limitations of the provider trait, you cannot override and write your own provider trait implementation, such as wrapping it over rest DB. So we want to enable that. And to do that, we are introducing something called, in the next few weeks, we're introducing provider call, which will let you fetch data from multiple data sources at once. And this would allow you to wrap your provider trait over the rest DB or any other DB.
00:18:51.380 - 00:19:26.346, Speaker A: And second is alloy multicol. We've had many requests to implement that. We've gone through the workflow, there are active issues over it, and we're hopefully, we'll be implementing that also in the next few weeks. And lastly, the alloy 1.0 milestone. So currently, even though Alloy is ready for production, we're rigorously improving it and finding new and different designs and architectures. So we essentially make breaking changes a few times or every few weeks.
00:19:26.346 - 00:20:30.620, Speaker A: So we'd like to get to a place where it's completely stable and only new eips likely may or may not break. Ally? Yep, that's all. Thank you. Questions? All right, thank you. Next up, we have Tom from WebM talking about modern j's on Ethereum. All right.
