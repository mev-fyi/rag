00:00:01.880 - 00:00:54.980, Speaker A: Well, thanks everyone for coming. So today I'll share the progress that has been made in foundry over the last two years, and I'll highlight some of the most impactful features that have been added that you may not have been familiar with yet. So what is foundry? Foundry is a smart contract development toolchain. It's written in rust. It manages your dependencies, it compiles your project, it runs tests, it deploys and lets you interact with the chain from the command line and using scripts, especially via solidity, it consists of multiple binaries. So we have forge, we have. So forge is the testing framework.
00:00:54.980 - 00:01:43.990, Speaker A: It's meant for compiling your smart contract code. We have testing unit test, fuzztest, invariant test. We have a debugger, scripts to manage your on chain interactions and deployments, and the verifying of your smart contracts. Next we have caste cost offers, a way to interact with EVM smart contracts on chain, which is like sending transactions, decoding on chain interactions, creating and managing wallets, that sort of stuff. We have anvil, which is like a local Ethereum node, especially for developers. And then we have chisel, which is a repl for solidity. So foundry currently has nightly releases.
00:01:43.990 - 00:02:52.114, Speaker A: And so to make sure that you stay up to date, you should run Foundryup very often, like on a regular basis. So it has become a bit of a meme, but you can set your alias, GM, to foundry app, and I run that on all my systems. So foundry has been growing steadily over the last two years, both in terms of individual contributors as well as adoption by developers. So we've seen a growth from like 1% adoption in 2022 to now, really becoming the default choice for any serious project. So for many, this is the tool that they use on a daily basis and for all their smart contract work, from like a first proof of concept to a final deployment on chain. And it's used by many smart contract developers, auditors, bug hunters, searchers, like everything in between. So really quick background on me.
00:02:52.114 - 00:03:40.818, Speaker A: I previously worked as a smart contract developer. I used foundry as my daily driver since the early days when foundry was still apptools Rs. In April, I joined the core team full time. But to put some numbers to it, Foundry has like 137,000 lines of code in rust, excluding accompanying crates, which we did quite a bit, splitting out things from core and into individual crates. So since the last conference last year, we've grown from 292 to 420 contributors. We went from 6000 starters to 8000 stars. And yeah, foundry has over 4000 merged commits.
00:03:40.818 - 00:04:46.340, Speaker A: So we've been doing a lot. So we're also seeing an increasing adoption by developers working on the major protocols that are pushing innovation across the space. This is one of them, but other names are like optimism maker, succinct, symbiotic, Euler, Lido. They're all using this on a daily basis and as part of their core testing flow. So anytime a project makes it to production, I feel is a potential for these best practices that are learned during the development and testing phase of these projects to be shared and ultimately be fed back into foundry, improving the developer experience for all and pushing this space forward. So building, because building better products ultimately requires building better tooling. So let's move on and talk about the features.
00:04:46.340 - 00:05:55.440, Speaker A: So as of now, Foundry has 411 individual cheat codes compared to the seven that dapptools originally had. So cheat codes are the way foundry enables you to do things. In got mode. We have cheat codes for things like creating a wallet, deriving a key, and signing. We have support for this new signed compact which allows you to have signatures that are 64 bytes instead of 65, which is useful for a lot of things. We have things like getting, setting, environment variables, EVM state dumping and loading of that EVM state from disk recording, storage reads, recording logs, directly interacting with an RPC endpoint, which is also really quite useful. We have things like interacting with JSON files, tumbl files, serializing, deserializing, broadcasting one or more transactions, including raw signed transactions.
00:05:55.440 - 00:06:53.200, Speaker A: That's a quite new addition, but this can be quite useful for private transactions and other things. We have string manipulations. Native assertions are certain things that like certain actions are performed, such as expect call, expect emit, expect emit anonymous, expect safe memory. So these are all things that, to make sure that you're not violating your assumptions. Other than that, we have many other utilities. Impersonating an address, creating a are computing your create to address, deploying a contract from an artifact, and random numbers, which is also quite a new and recent addition. Previously you had to use FFI for things like this, but now it's available directly inside.
00:06:53.200 - 00:07:51.600, Speaker A: Yeah, and to use these cheat codes, you use Forge Stdin. So we've added an entirely new way of adding cheat codes, and it's now really quite trivial. So I would like to walk you through the process of doing this. This is one of the reasons, by the way, why we have like 411 cheat codes now. So the first thing you do is define the interface of a function that you want to implement. So you define, basically you describe on a high level what the functionality in terms of parameters would be in this case start broadcast. Then you implement in the relevant section, this case the cheat codes directory.
00:07:51.600 - 00:08:46.530, Speaker A: And the nice part about this is that you implement the cheat code trade and then you simply describe the functionality and implement the logic. The self here holds the arguments that you describe in the high level interface. And then we have a cheats sub command that basically does some generation and after that it's available in your solidity. So it's really this simple and straightforward. So if you have any new ideas about cheat config functionality that you would like to see, it's that easy to add. So digging in now we have forking. A lot of you are familiar with this.
00:08:46.530 - 00:09:48.280, Speaker A: It's just something that I wanted to point out is that previously people were using fork URL, passing this into the command, but we now have cheat codes available that can do this in a much better way. So right now we recommend using vm create fork in your test setup and vmselect fork in the test body. It's especially useful when you're testing cross chain interactions. And with it you can fork at historical block numbers or even at a specific transaction hash. And if a transaction hash is provided, it will roll the fork of the block until the point that the transaction was mined. It's because the, the prior transactions are determined or determine the state of the transaction that you are executing. So that's relevant.
00:09:48.280 - 00:10:50.690, Speaker A: By using VMselect fork, you are easily able to switch between the different EVM forks, allowing you to test this behavior. And alternatively we have VM create select fork to just wrap this and do this in one cheat. Next we have isolation mode. So by default, the individual transactions inside of tests and scripts are performed as if they were part of one transaction. So for most cases this is actually preferable because the setup and tear down overhead of doing this otherwise is quite significant. So for some use cases, however, especially those related to accurately measuring of gas, another approach is required. So what isolate does is you execute all test and script level calls as if they were separate transactions.
00:10:50.690 - 00:12:03.720, Speaker A: You initialize them with like an empty journal stage. You're triggering pre and post transactions and clients cleanups. So this allows us to actually include the call data, the base 21,000 gas, the clearing of the transient storage, correct handling of your self destruct, et cetera, et cetera. And in this case, like the difference is 21,064, 21,000 from the base and 64 for calling the function. And. But yeah, an important point to note here is that like none of these values are hard coded and like it's, it is actually correctly as you would expect it executing things as individual transactions and therefore it can be considered like authentic and related to the request. So when running forge test with the gas report flag, the isolate flag is now enabled by default, and this solves the longstanding issue where gas reports were not accurately reported.
00:12:03.720 - 00:13:09.930, Speaker A: So foundry previously supported tracing of external calls, making it difficult to debug intermediary values and especially things related to the internal jumps. And we now support the decoding of these internal jumps. This flag is available in both cast a cast run and forged test. So let's look at an example of a transaction of an ERC 20 token swap using the Uniswap's universal router. So with the first decode internal with the decode internal flag enabled, we first execute the previous transactions from the block again to bring it into a state where, yeah, bring it to the relevant state. Then the next point is fetching.
00:13:11.630 - 00:13:11.918, Speaker B: The.
00:13:11.934 - 00:13:55.220, Speaker A: Verified contract source code of the contracts that are actually used in the trace. And then we compile them locally with their respective compilation settings. And as a comparison, this is without decode internal enabled, so it only describes the high level calls. It doesn't give you this introspection. It's good, but we can do better. And this is with internal tracing enabled. As you can see, we have internal function calls, internal storage lookups, intermediate values.
00:13:55.220 - 00:15:03.520, Speaker A: This is extremely powerful when you're doing your debugging. So this functionality is not enabled by default due to the overhead involved. But now you have a tool that you can reach to when you do need this level of introspection. So we've made many performance improvements over the last year in foundry. As a benchmark, I've taken Soledi, which is a popular library for optimized gas snippets by vectorized, and ran its extensive unit and fuzz test suite against the version of foundry from one year ago and from a recent release. And this is even like a naive kind of benchmark, but it's, it shows a speedup of at least two x, but more likely depending on your code base. So we have a new feature called Fuzz fixtures.
00:15:03.520 - 00:16:58.300, Speaker A: And fuzz fixtures can be defined when you want to make sure that your set of values that you're using as inputs for first parameters contain certain values, right? So to do so you use the fixture prefix on any variable or function, and when you define the first parameter in the test function you use the same name minus the fixture prefix, and by default you include or by default any values that you include that are included in this fixture are chosen 40% of the time, 10% of the time are edge case values, and 50% of the time are random values. But this helps you kind of guide your fuzzing. We now support a replaying of failures using the rerun command. It's available on forged test, meaning that upon encountering a fuzz failure or a failing invariant test, the fuzzer corpus is persisted to disk, and upon the next run, the corpus is used when replaying the first case. This really helps with the speeding up the iteration cycle during development. So when a failure is encountered in an invariant test, a process called shrinking is performed. And a failed invariant test can include many steps and conditions that aren't actually contributing to the failure case.
00:16:58.300 - 00:18:20.630, Speaker A: In order to reduce the failure case to a minimal reproduction, you iteratively remove unrelated cases and remove unrelated cases from the failure case. So foundry previously took an optimistic approach, but this was rewritten entirely from scratch, and the speedup is very impressive. And for you, this means that your minimal reproduction can be extremely small and generally allows you to iterate quickly, which is obviously crucial for your development process. So improvements like this make foundry not just a developer tool, but also a security tool. So we recently added the show progress flag to visualize the process of running your test more easily. So it shows your fuzz runs, it shows invariant test runs, but it also shows your shrinking runs upon encountering failure. So this is more yeah, so we have forged clone address.
00:18:20.630 - 00:19:48.090, Speaker A: Forged clone allows you to create a new forged project by cloning the source code of an on chain verified contract. It includes remappings, dependencies, and compiler settings used originally when the project was deployed. By default, the forged clone clones the contract from the Ethereum mainnet via Etherscan, and is also possible to do this for other EVM compatible blockchains that foundry supports by specifying the chain id. So we now have support for VYPR, which is a contract oriented pythonic programming language that targets the EVM. It's used by projects like yearn curve, but also libraries like Snackmate. So in the process of adding support for Vyprdez, we've abstracted the way that we how can I explain this either way? So we've obstructed the way that we interact with the compilers, opening a way to support languages other than the EVM. So in the last year, we've migrated entirely from ethers to alloy.
00:19:48.090 - 00:20:36.836, Speaker A: You can now run forgebind with the alloy flag to create alloy compatible rust bindings. This works for both solidity and Viper. So to wrap things up, we have a big thing that we're working towards, which is our first stable release. So in order to achieve this goal, we are focusing specifically on four areas. One of them is correctness, completeness, performance and stability. And this means that any tickets that come in, or any new ideas that we have, we evaluate how does it fit according to these goals and along these areas. So after 1.0,
00:20:36.836 - 00:21:19.510, Speaker A: instead of slowing down, we are actually going to accelerate. I'm particularly excited for two new updates that we're planning. One of them is Anvil on Reth, which is a rewrite of anvil from scratch to build a new developer node on top of Reth. Then we have Forge builder, which makes it very convenient to use forge as a library using the builder pattern. So please scan the QR code if you are. It's linking to the milestone ticket and subscribe to it if you want to stay up to date with our journey towards 1.0. Thank you.
00:21:19.510 - 00:21:27.070, Speaker A: Happy to take any questions.
00:21:30.970 - 00:22:02.560, Speaker C: It's really cool to see all the performance improvements to foundry. My question is, one of the slowest parts of solidity development is often just waiting for the solidity compiler, especially if you are in a situation where you have to turn on via IR. And I was curious, has the team thought about attempting to write a solidity compiler in rust or to do something like that? Is that just too hard?
00:22:05.500 - 00:22:25.756, Speaker A: It's something. It's definitely like one of the concerns, right, that we understand, and it's not something that we can, we understand.
00:22:25.908 - 00:22:45.210, Speaker B: We've been playing with the idea of doing one, so I'm over here. We have a parser that's really fast. We haven't gotten the cogen part yet. It is very top of mind. If there are compiler experts in the group that want to help with that, we might have a position, but let us know.
00:22:58.120 - 00:23:03.300, Speaker D: Hey, can you speak to the anvil rewrite? What are you excited about in particular?
00:23:04.080 - 00:24:03.930, Speaker A: Yeah, so Anvil currently is basically a full node implementation on its own, and it was written largely prior to Reth. So right now we have ret in place and it will avoid a lot of duplicate code. So right now we have prs open for handling full reorgs and enabling certain tracing kind of RPC steps and all that sort of things. People are adding that currently still onto Anvil, but hopefully once we have this unvo and ref, a lot of this will come out of the box and we can really push further. And it also opens up this idea of a lot of things were added on top of each other throughout the years. It gives us an opportunity to kind of rethink the interface and generally get a much more performant node implementation rather than things related to caching and all that. We get a lot of cool things out of the box, basically.
00:24:03.930 - 00:24:26.060, Speaker A: Okay, next up we have alloy is ready for production from Yash.
00:24:37.040 - 00:24:57.730, Speaker D: Morning, everyone. Thank you for coming out on a Saturday today. I'm here to talk about and declaring that alloy is ready for production. And thank you. Finally, for those who don't know, alloy is a complete rewrite of our previous framework.
