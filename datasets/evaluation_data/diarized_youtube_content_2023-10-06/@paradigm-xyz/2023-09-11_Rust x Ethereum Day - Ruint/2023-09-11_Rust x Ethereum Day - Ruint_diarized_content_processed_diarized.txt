00:00:00.280 - 00:00:48.976, Speaker A: Good. So welcome to the bottom of the stack. Let's start with some existential questions. What is it ruined is a rust beacint library for large fixed size unsigned integers. Fixed size here means that the size is known at compile time, unlike some other bigint libraries like GMP and Num biginthe, which are dynamically allocated and are therefore slightly less performant for the sizes we're using. In Ethereum, which is mostly a Uint 256, rust has a bunch of built in unsigned integers just like U 32, U 64, all the way up to U 128, but unfortunately the next one is missing. This is a rush choice, actually.
00:00:48.976 - 00:01:35.238, Speaker A: LlvM, the compiler backend, supports arbitrarily sized integers quite efficiently, but rust doesn't expose it, so we need to do it ourselves. And that is what ruin does. Heavy emphasis on developer experience I found that in some of the other existing libraries that are out there, the thing that annoyed me is that the function I needed wasn't implemented, and I need to somehow work around it, or some features weren't implemented hard to do. So I wanted a library that was just turnkey does everything you want. In particular, I made sure that it's a drop in replacement for something like U 64. All the standard library functions that you expect are there and do what you think they should be doing. It is also, unlike some other libraries, actively maintained.
00:01:35.238 - 00:02:20.240, Speaker A: And a big shout out to James and Georgios for this, because I got distracted trying to onboard the entire world onto blockchain somehow. Another question, why did I end up writing it? So one of the main reasons is Rust's orphan rule. If you build a library that exposes some important type, and this type doesn't have some trait on it, like, let's say, serdi, it is incredibly annoying to, as a consumer of this library, add this on, it's impossible. You either fork the library or you need to use a new type on some other weird construction. You don't want this. So that was the main motivation to build a library that has all the traits. Second is const generics.
00:02:20.240 - 00:03:10.426, Speaker A: We just got const generics, and I so wanted a library where I could do uint and angle brackets and tell it how many bits I wanted, and I wanted to see if I could build something like that. Turns out, yes, kind of. And I had some from a previous project, some really fast ports of GMP algorithms lying around that really needed a new home where people could actually use them. So that's the motivation for starting this project, starting with all the traits I made them all optional. They all have feature flags so you don't blow up your compile times if you don't need it. The way dependency resolutions works is that whatever is needed in your entire project automatically gets enabled, so that's cool. It's probably barely readable, but there's like a whole list of traits it implements.
00:03:10.426 - 00:04:35.020, Speaker A: Lesson learned along the way is that these traits, like, let's say Serdi or ARg FF, they upgrade sometimes, and that is technically a breaking chains, which would be really annoying because it multiplies over all these dependencies that are there. So we're working on a solution there to support versioning of implemented traits, and probably all these feature tags will also have a major version associated with them, so that you could implement let's say 32 and enable certi three, and even have both enabled concurrently if that is what your project needs. I said it was mostly compatible with STD, and indeed, if you find anything non obvious and different about these uints versus the built in native ones, that's a bug and you should report it. But there are a couple of changes. The standard operators, plus, minus, multiply, etcetera, they wrap by default kind of a design choice. The built in rust ones will panic in debug mode and then silently do undefined behavior in release mode, which is not a good idea. The other thing is that shifts in rust are a little bit awkward, because if you give it a shift amount that is larger than the type itself, it's also undefined behavior.
00:04:35.020 - 00:05:15.318, Speaker A: We don't want that. And then some technical constraints, like some functions, couldn't be made constant because of technical reasons. Anyway, recommend you read this part of the doc before you really go deep into it. Now I would be disappointing some members in the audience if I didn't present a little bit of moon math. So this is the moon math section. What this library actually implements is what in number theory is called a ring, which is the modulo the integers modulo two to the power something. This has addition, like a ring has addition, subtraction, multiplication, etcetera, as you've learned it in primary school.
00:05:15.318 - 00:06:17.772, Speaker A: But it also has an inverse, which is the anti multiplication element. It's basically a number that when multiplied, like if given a number, you can compare its inverse, and if you multiply the two together, you get the number one, which is kind of like division, except we don't have fractions here. So what does this number look like? I have an example on the right here. Like if we take the number 57 in u and 64 in this case I can compute its ring inverse, and then the result will be this really bizarre looking 64 bit number. But if you multiply that with a wrapping, multiply with the original number, the result is indeed one. And in fact, if you multiply by this number we just computed, it is kind of like dividing by the number 57. So I compute a number b here that is 57 times something, and if I take that result and multiply it by a, I get my original number back.
00:06:17.772 - 00:07:00.750, Speaker A: So yes, we've just divided by 57, doing a multiply caveat. This trick only works if the number is if this division is exact. If it is not exact, you get some really weird other number. Another caveat is that these inverses only exist if the number you're inverting is with your modulus, meaning in this case that it needs to be an odd number. So this only works for odd numbers, and only when the division is exact. But it's a really cool trick, and you can actually use it to optimize certain algorithms quite effectively, mostly because this inverse is actually also really easy to compute. So that's the moon mod section.
00:07:00.750 - 00:07:55.364, Speaker A: Another highlight, kind of along the lines of the of James's work as well, is like how do we abuse the proc macros to make things easier on the developers? One of the things, and this is partially a motivation for writing this library as well. One of the things I realized is that Rust's tokenizer actually supports arbitrarily sized integers. Like the token stream representation just has a string for the integer that is in your source code. So the unmar takes whatever rust source you give it. It finds all the integer constants and checks if it has a suffix that starts with a capital letter u. The standard library types have a lowercase u. If you do an uppercase u, it will get picked up by this macro.
00:07:55.364 - 00:08:53.244, Speaker A: It takes whatever is in front of it. It will parse it exactly the same way as Rust would do bye by itself, except it will do it in an arbitrarily sized type, and it will do this. It will then produce a constant and substitute it in the output code. So this basically allows you to just wrap a bunch of code in this unmar, and now you can write code using the ruined integers as if it's native rust. Another fun thing in the project is it has a little bot that I've been playing around with that automatically creates GitHub issues for any to do comments that are in the code. I'm a firm believer that you need to keep your project management as close to the source code as you can possibly do, and this one allows you to just do your to do management in the code system itself. Fun little hack other fun bits of code.
00:08:53.244 - 00:10:08.660, Speaker A: Like I mentioned, there's a couple of pretty sophisticated algorithms in there that I ported over from GMP. There's knut division, which is a efficient division algorithm, and lemur GCD, which is a greatest common divisor algorithm that is also used for modular inverses. This one is particularly fun because modular inverses are quite important in cryptographic applications, and I'm fairly sure that this one is more performant than anything that's out there right now, even in the crypto dedicated libraries. So it'll be fun to see that get a little bit more use. Another fun bit of code if you're exploring the library, is look at the postgres integration. I went quite overboard there, and I tried to implement every single column type that could remotely be interpreted as an integer, and in particular the one that's kind of obvious, actually, the numeric type, which is the arbitrarily sized integers that postgres supports. That seemed to make sense to implement, but it turns out that the format is completely undocumented, and I had to dig through the postgres source code to figure out how that binary format actually works.
00:10:08.660 - 00:11:07.210, Speaker A: That code hasn't been updated since 94, I think, and it uses binary coded decimal. So that was a good fun bit of history there. On the left, you see the function to compute the root like square root, cubic roots, and higher order roots. It uses a fun trick to speed up the process where basically it takes a double precision float approximation of the bigint, uses float operations to create a first approximation of the result, and then just does a couple of quick iterations to turn it into an exact value. This is a way of designing fast algorithms, and it's enabled by having another interesting piece of code that does a very precise conversion from a f 64 double precision float to an unsigned integer. So some concrete questions. What are the next steps here? Obvious ones are more optimizations.
00:11:07.210 - 00:12:02.658, Speaker A: Right now it's, I think, entirely plain rust, so very portable, but it doesn't have specific optimizations you can do in x 86 64, which has some fun opcodes like Mulx and ADX and ADDC. Similarly, Arc 64 Arm Wasm. All of them could benefit from more targeted optimizations. Interesting thing that came up recently is like, hey, maybe we should have a RISC V backend or a MIPS backend here, because it seems that people are now suddenly interested in compiling this thing to RISC, zero and Canon and other completely new architectures. More traits always welcome. If you want to implement traits, please do just submit a pr probably get included. It's kind of zero cost, it's just an extra feature flag and it will save people a lot of trouble because of the orphan rule.
00:12:02.658 - 00:12:41.622, Speaker A: A particular one that is still open and a nice beginner's task is num trades, which has a lot of fun little traits like is zero and is one and you name it. Another thing is maybe extended with more types. Right now it's just unsigned integers. Maybe we want signed integers too. It could be interesting. Like I said, it has fast modular inversions. Maybe we want to have a whole modular type where you have a compile time modulus and then you can just instantiate this ring and do algebra in it, or prime fields, even a runtime sized version.
00:12:41.622 - 00:13:56.500, Speaker A: Like I said, this one is compile time fixed size. Maybe we do want a version that can leverage the same algorithms that have already been implemented, but use a runtime sized type. So where this one is kind of an array of digits, that one will be a factor of digits. And right now if you peer under the hood, you'll see that it's uint bits limbs, which is a restriction of what rust generic can currently do. So you need to provide the number of bits you want, but also how many 64 bit limbs that requires it will panic if you give the wrong impossible numbers here, and it would be nice to make it automatically compile time compute how many limps it needs, but unfortunately this is blocked on rust upstream issues that have been open for a couple of years now, so that will not be resolved anytime soon. The other things though, contributions more than welcome. It's a fun little low stack, high impact project, should be fairly accessible.
00:13:56.500 - 00:14:25.830, Speaker A: So yeah. Hope to see your pr. Is there any questions? Hey, have you considered adding support for SIMD that would fall under architecture specific optimizations? Okay.
00:14:27.610 - 00:14:32.710, Speaker B: And for clarity, SIMD for parallel instructions was the question.
00:14:34.170 - 00:14:37.850, Speaker C: I have a quick one, just shout out for the GitHub action. That's awesome.
00:14:38.010 - 00:14:48.360, Speaker A: Thanks. Yeah, you should check it out. It also uses git blame to assign the GitHub issue.
00:14:50.580 - 00:14:52.320, Speaker B: You love that action, man.
00:14:53.620 - 00:15:01.200, Speaker C: Next, how does Warcoin use the roon library? Sorry, how is Warcoin currently using this?
00:15:02.740 - 00:15:20.150, Speaker A: I think we use it in some places in some of the crypto math, but the main usage will be when we move to an op stack on something like op redenn, and that whole thing will be built on top of all the foundations you've seen so far.
00:15:20.930 - 00:15:21.830, Speaker C: Thank you.
00:15:22.930 - 00:15:36.642, Speaker D: Hi. I was just wondering, well, first your blog and approximation theory changed my life, but I was just wondering, what is the most interesting or esoteric algorithm you had to implement for adding functionality to ruin?
00:15:36.786 - 00:15:41.710, Speaker A: Oh, for sure, the lemur GCD. That one is a wild one.
00:15:42.500 - 00:15:43.440, Speaker D: Thank you.
00:15:45.620 - 00:15:46.780, Speaker B: Round of applause for Remco.
