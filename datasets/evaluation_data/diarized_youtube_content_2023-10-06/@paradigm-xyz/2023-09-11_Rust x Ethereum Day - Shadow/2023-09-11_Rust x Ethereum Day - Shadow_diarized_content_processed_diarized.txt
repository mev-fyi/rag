00:00:00.400 - 00:00:47.270, Speaker A: Hi everyone, I am Emily. I'm the CTO of Shadow, and I'm going to be talking about shadow events today. So first, what is a shadow event? A shadow event is a gasless event logged in an isolated fork that shadows Mainnet. And why are they cool? Why are they valuable? You can think of Shadow as unlocking permissionless edit mode on any contract on Mainnet. So this means that you can add custom event logic that can include and access any on chain state, including internal state and private variables. And it's all gasless. And once you've written this new event logic, you can go back in time and backfill historical data that you didn't get before.
00:00:47.270 - 00:01:37.492, Speaker A: So what this means is that if you need on chain data, instead of writing convoluted SQL pipelines or assembly script, you can write code close to the metal directly in the smart contract in solidity to get the exact data in the exact format that you want. Cool. So how does it all work when you want to add a shadow event? The first step is to spin up your own shadow fork. A shadow fork listens to transactions happening on Mainnet and then executes all those transactions on your fork. And that's why we call it a shadow fork. And this is completely isolated from Mainnet. So gas costs and contract size limits are completely removed.
00:01:37.492 - 00:02:34.626, Speaker A: And you can go crazy here in the hosted product, your shadow fork is near real time and it has all the same exact state aside from the additional event logs that you added. And if you added any additional storage slots, that's the big difference, but everything else exactly the same as Mainnet. Second step is to edit the source code of this contract that you want to shadow. And you can shadow any verified contract, or you can shadow unverified contracts that you have the source code for. And then the third step is to deploy your shadow contract onto your shadow fork. And then once deployed, front fills start immediately, and then we will kick off a backfill process. And then finally you access your shadow events like you would your normal Mainnet data via JSON RPC.
00:02:34.626 - 00:03:26.740, Speaker A: We support all the standard ETH RPC data, JSON endpoints, and we also support other access models like GraphQL, webhooks and SQL tables and parquet tables. Cool. So using a shadow fork is pretty simple, but there's a lot going on behind the scenes and under the hood to make this really fast and really performant. And you know, forking Mainnet is not a new idea. You might actually do this multiple times a day when you run your foundry tests. So we took a lot of inspiration from foundry, and we're actually using certain crates in foundry to help us make this blazingly fast performant and paralyzable. So if you're building crypto native infrastructure, there's actually a lot of alpha in foundry that you should consider leveraging.
00:03:26.740 - 00:04:24.278, Speaker A: The one that I'm going to highlight today is called the backend handler, which is a highly multi threaded fork backend used in foundry to run multiple fork simulations. So when you do VM crate fork and run a simulation, this is what's happening under the hood. So basically what it does is when you spin up multiple forks, there is a single instance of the backend handler that is basically fulfilling all of the JSON RPC requests. And so this is doing really a lot of the heavy lifting. The backend handler uses Tokyo channels to de dupe inflight requests and then caches the previously requested results. And you can thank this module for not blowing through your alchemy compute limits every time you run your foundry tests. So here's just a little snippet of code.
00:04:24.278 - 00:05:09.076, Speaker A: In this snippet of code we are fetching for a storage slot at a particular address in the backend handler. So you can see it's pretty simple. Just first checks if the value is in the cache. If it is easy, we'll just send it right back. Otherwise it knows that we need to request this data. So once we know we need to request this data, what it does is it basically checks first if we have a pending in flight request, if we've already requested for this storage slot, and we don't need to send another request if we haven't seen it before, then we add it to the queue of pending requests to be processed. And then finally all this is doing is just pulling for all the requests that are in flight.
00:05:09.076 - 00:05:58.710, Speaker A: If it sees a request finally come back, it just sends it back to all the listeners via the Tokyo sender channel. So, huge shout out to Matt on the cord foundry team for designing and building all this code that I showed today. And I highly recommend reading through this code if you're building really complicated high I O systems. And if you need any weekend reading for this weekend, this PR, I don't know if you can see it, but it's PR 1715 and foundry. It's a really good one to read if you are curious about how forking works. And also it has an example of how a VM code works from front to back. So if there's one takeaway that I wanted to give to you guys for this talk.
00:05:58.710 - 00:06:30.520, Speaker A: Is that the name of the game for building an Ethereum is composability and composing on top of foundry, and Reth is the new meta for building crypto native infrastructure. So if you're building infra, you should really be thinking about using foundry and rethemeral as tools in your tool belt. And if you're interested in using these tools with us in prod systems, come find me afterwards and we can chat. And there's a lot more that we could have covered here. It was only five minutes, so feel free to find me afterwards if you have any other questions.
