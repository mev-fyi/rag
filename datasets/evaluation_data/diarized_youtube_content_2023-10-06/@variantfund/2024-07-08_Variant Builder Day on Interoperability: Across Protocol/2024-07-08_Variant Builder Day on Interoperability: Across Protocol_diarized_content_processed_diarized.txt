00:00:06.680 - 00:00:53.116, Speaker A: I have a feeling everybody in the room knows a lot about intents, but I still think it's useful for us to do a little presentation about our view on why we think intents are the right paradigm and design for cross chain interop. I believe everyone in the room is going to want fast, cheap, secure interoper. That's so seamless. You don't even know about this blockchain thing. That's our vision for how we're going to bring a billion people into web3. What my mental model is, a lot of people think about interop as it should be TCP IP, you should be sending messages between nodes or servers bridging. I think naively you think about it that way.
00:00:53.116 - 00:01:27.382, Speaker A: You have blockchain a, blockchain B, and we send a message between them to do actions. And the problem here is sending a message quickly, cheaply, and securely is basically impossible. Maybe it'll be possible some point with like single slot finality and really fast ck proofs. Maybe, but we're certainly not there yet. I'm not gonna be there for a little bit. So our solution is don't send messages. That's like, in my opinion, the core idea behind actually what's going on with cross chain intents.
00:01:27.382 - 00:01:58.750, Speaker A: So let's just not send messages. There you go. So the fundamental observation we have at across is that TCP IP, you're moving messages, you're moving bytes around in blockchains. You are mostly moving value. You're not exclusively moving value, but you're mostly moving value between chain a and chain b. And maybe you're moving value and doing an action. It's like, I want to move $50 worth of ETH and buy an NFT, but you're still moving money.
00:01:58.750 - 00:02:51.210, Speaker A: And that the kind of the follow on is value is fungible. Like, I don't care how my money gets between base and optimism, I just care that my money's there. And this is kind of the core reasoning for why we think cross chain intents work so well. The way I typically pitch the intense model we had chain a and chain B, and the naive interpretation for interop as we send a message between them. Here we're saying, don't do that. Instead, let's introduce a third party, the solver that's going to observe the deposit transaction on chain a and fill the user on chain b with their own capital. And they're able to do this because money is fungible.
00:02:51.210 - 00:03:11.250, Speaker A: The value is the same. They just move $50. It doesn't have to be the same $50. And they can do that. So the user gets filled without there being any message that gets sent between chains. Okay, I already said this. With intents, solvers move their own capital quickly and cheaply, get repaid later.
00:03:11.250 - 00:03:42.470, Speaker A: Great. So this is kind of our view of what the stack of cross chain intents looks like. You have like the intent layer where the order is initiated. You have the solvers that are competing to fill the order with their own capital and fill the order quickly and cheaply. And then you have the settlement layer, which is going to escrow the user funds and repay the relayer, or the solver, whatever we want to call it. I'm going to use the word relayer, solver, filler, market maker. I'm going to use them kind of interchangeably.
00:03:42.470 - 00:04:26.978, Speaker A: So the settlement layer escrows the user funds, and after we quote, unquote, verify the intent has been fulfilled, we are going to repay the solver for the work they did. All right, so we have some data here. So this is my whole pitch about why intents is the right architecture. Intents can be really fast. Across is one to two orders of magnitude faster than message based bridging systems. This is simply because solvers now are competing on speed, and competition is good in our system. In this design, the first solver to fill, the user gets the fee.
00:04:26.978 - 00:05:17.120, Speaker A: There's a natural market incentive to be fast. They're able to do that partially because solvers can take on some finality risk. If Nick's the solver, and Nick believes the optimism centralized sequencers pre conformations are valid, he can fill a user as soon as he sees that pre confirmation come back and he is taking on some finality risk, where if the optimism sequencer lies, he might be left holding the bag, but it's his choice, and the user is protected. The user is not exposed to that risk. And so some data, we have actually some pretty cool data analytics. We spend a lot of time and energy investing in this. This, to be clear, is Stargate v one, not their current system, but the fill times look to be about the same.
00:05:17.120 - 00:05:42.800, Speaker A: And we're segmenting this by l one, l two, l two to l one, and l two to l two. And this is where actually we're most interested. Our median fill time right now is about 5 seconds going between l two s based optimism, optimism to arbitrum, and we are far faster than the message based systems, like in this example, Stargate or CCTV.
00:05:43.820 - 00:05:44.600, Speaker B: Cool.
00:05:46.340 - 00:06:47.046, Speaker A: The second advantage, because, remember, we went back and we want Internet interop to be fast, cheap and secure. So, okay, we're fast. We can prove that we want to be secure. And the core observation here is this cross chain intense architecture separates the interop problem into the urgent part. I the user want a super fast fill, and we separate that from the complex part of how we actually send messages between blockchains, which can be complex. Again, we can't see, we can't see all the faces in the room, but I think you guys are probably working on these different technologies of like how do you securely send a message between blockchains? And there's lots of ways we could do canonical bridges, do ZK proofs, do optimistic systems, do avss, lots of different approaches. And we are kind of trying to take the approach where the intent architecture is actually agnostic to how you verify that intents are filled, how you send those messages.
00:06:47.046 - 00:07:27.360, Speaker A: We just do it slowly. We have the advantage of time to do the complex part after the fact. Now, the third advantage, we wanted interop to be fast, cheap and secure. We talked about fast, we talked about secure. Now let's talk about cheap. Why are intents cheap? We'll go a little bit deeper in this, but the core trade off here is solvers do have a cost. Solvers have to make a loan to the user, a short term loan, but it's still a loan to the user, and there's a cost of capital associated with that.
00:07:27.360 - 00:08:31.160, Speaker A: However, what we've seen is the cost of that loan is actually much less than the advantages we get from batching together many, many verifications into one structure, which we then message in a single object what across does, and maybe in the q and A, we'll go deeper on the architecture here. But what across does is we have a whole bunch of user transactions. User fills with Nick, the solver is going to loan money to fill all those users. And then every period, we'll call it an epoch, every period we gather together all those repayment instructions, we aggregate them, and we say, Nick is owed an ETH for all the fills he just did. And by doing that aggregation, we actually reduce a lot of the messaging and a lot of the repaying NIC costs, we reduce a lot of gas costs. And it turns out that the reduction in gas costs is worth more than the cost of Nick making the short term loan. Here's some other data.
00:08:31.160 - 00:09:18.150, Speaker A: This is like median cost of transfers. We're not normalizing for size, so we can look at this in a specific size range, but we're really cheap. And the cheapness again comes from the fact that we are able to do all this gas cost optimization because we do so little messaging for all the transactions we're processing. So this is a little bit of a theoretical example for how this works. And I'm picking on Stargate here because you guys might know on Twitter I tend to do that. But the theoretical examples, what's happening is if Nick is okay, conditions here were saying that were bridging 50 million of volume over 50,000 transactions. Nick is our relayer.
00:09:18.150 - 00:09:53.230, Speaker A: Hes going to make a 1 hour loan of $50 million at a 10% interest rate. A 1 hour loan is about $500 10% annualized interest rate. And then across is going to, because of this batching, we send ten messages. We literally send one message to each. We call them spoke pools. We send one message to arbitrum, one message to base, whatever. And we're just going to say, we have a messaging cost, and that's our total security costs for these 50,000 transactions.
00:09:53.230 - 00:10:46.244, Speaker A: And you compare that to the alternative of sending a message for each bridge transfer. And if I price these message costs at. Don't know if that's right or wrong, you guys can pick your own number, but there's a much bigger cost if you're going to send 50,000 messages over that period. The argument I'm trying to make here is what across is really doing is it's compressing the amount of messaging we do. We're compressing the amount of messaging into very few messages because we are making these loans and paying them back in aggregate. It's a cool example comparing this intense architecture to circle CCTP. Circle CCTP is free, but across is actually cheaper because the gas costs in circle are actually higher than what acrosses are.
00:10:46.244 - 00:11:30.960, Speaker A: And we can do a $100 transaction, we lose a bigger volumes. But $100 transaction is actually cheaper in across than it would be using circles native bridge. And it's far, far, far faster. All right, so that's my basic argument of why the intent architecture is cheaper, faster, more secure. And again, the cheapness comes down to this compression concept. So across can scale to transfer a billion dollars a day when only sending about 150. We use canonical messages right now, but if we did 1 hour repayments, we can send a very small number of messages to verify huge number of transactions.
00:11:30.960 - 00:12:08.610, Speaker A: And if you compare that to a message based system, you're going to be sending 10 million messages to support a billion dollars a day. It just, it seems expensive and difficult to try to do that. Okay, how am I doing on time? I think I'm doing okay and we're getting close. This is an old presentation I'm running through, and we just did our team off site. So we'll include a few new slides at the end. At the intent layer, across helps aggregators dapps wallets create and root intents. This is our vision for how this interop stack works.
00:12:08.610 - 00:12:43.602, Speaker A: The solver layer. We have established a standard for cross chain intents. We're going to touch on in a second, and we want to have maximal solver competition at that layer because it's best for the user. And then the settlement layer, the idea of we have a standard for cross chain intents. We can define one or more settlement layers that escrow user funds and release them back to the relayer after we verify the intent has been fulfilled. All right, there's a stack. We talked to some of the cake guys.
00:12:43.602 - 00:13:05.790, Speaker A: Some of you are probably in this telegram group. Cake working group. Kind of looks like a cake. Cool. So things we've done recently, we launched across v three a couple months ago, and we launched it as a settlement system for cross chain intents. Here's our architecture. Anyone can make this deposit transaction.
00:13:05.790 - 00:13:45.188, Speaker A: Any relayer can then compete to fill that transaction. And across functions is a way any protocol could plug into this settlement layer to verify that intent was before releasing it back to the relayer. We're really trying to make the bottom two layers here easy to use. Anyone can plug into them. Working with our friends at Uniswap, and maybe there's some of them in the audience here, we put together a simple standard, a completely agnostic standard. This is not benefit across in any way. Uniswap also has their own competing intense design.
00:13:45.188 - 00:14:43.160, Speaker A: But we put together a standard for cross chain intents. It's been named ERC 7683. And the idea here is to come together with a very simple but intelligent method for how we can define these cross chain limit orders. And I just said cross chain limit order because there's also a lot of talk around generalized intent frameworks, how we could write intents for anything. This standard is actually being opinionated of saying, actually, let's keep this pretty focused to just moving value, maybe doing a swap, maybe doing the same asset, but moving value between chains, that's what we want the standard to do. It includes some functionality to add in arbitrary data you could execute on the destination chain, but the overall architecture is meant to be. None of this isn't a generalized intent standard.
00:14:43.160 - 00:15:20.980, Speaker A: This is like a cross chain limit order. And you guys should all go and check out the standard. We have a simple website, ERC 7683 dot, specifying what it looks like. We want feedback. It's work in progress, meant to be a public good. So we'd love to hear what everybody has to say again, team offsite stole a couple of slides from our product leads deck. Things we're working on right now bringing the settlement layer to new blockchains we just deployed to lineate and mode recently.
00:15:20.980 - 00:16:05.310, Speaker A: There's about ten more chains in the pipeline that are coming very soon. The chart below shows across market share within aggregators we've actually been doing quite well in terms of the aggregator market share we have on the tokens and routes we support. And I think it's further evidence for this intent based architecture just generally winning our vision for where this goes. We want Dapps to be able to fill out order tickets. My mental model for what this cross chain intent looks like. So imagine you have an order ticket. It's like origin chain, origin token, origin amount, destination chain, destination token destination amount, maybe an action you want to do.
00:16:05.310 - 00:16:45.206, Speaker A: DaP fills out that order ticket, user signs it and it gets thrown to this infrastructure that just executes it. So that's kind of our vision for how Dapps can integrate into this framework in a form of chain abstraction. We're not there yet, but we're getting towards a place where users don't really need to see. Users can easily bring their funds from any chain into your application. That's something we're working on this quarter. A couple other fun slides that are just observations. Den Kun has really changed the game in Interop.
00:16:45.206 - 00:17:31.336, Speaker A: We go back before March 15, March 13 and bridging $50 cost you a couple bucks. Now, bridging $100, even $1,000 costs literally pennies. And the interop costs are just very, very low for bridging $1,000, which is 90% of all transfers. The interesting thing here is now bridges are not really competing on cost. I've been warning a little bit on Twitter with Stargate about costs, but the point is it's all within pennies. What's really mattering is speed. And this intent architecture in my mind, just purely because of the competitive forces, it has the clear speed advantage.
00:17:31.336 - 00:18:03.762, Speaker A: And I think users would like. They don't care about fraction of a penny differences. They care about a two second fill versus a 42nd fill. That makes a big difference. This is also just a fun chart that we talked about our offsite that I want to share with Den Koon and with transaction costs dropping so much, we're actually seeing the average bridge, bridge transfer size. The median bridge transfer size is dropping a ton. Before den kun, you had like a 0.1
00:18:03.762 - 00:18:23.936, Speaker A: eth, 0.15 eTH kind of average transfer size. It's now down to zero. One, five, about $50 worth of eternity. And I think this is a really, really good thing for our ecosystem. We're seeing that users are actually moving $50 worth of ETH around chains. And there are consumer use cases.
00:18:23.936 - 00:18:57.530, Speaker A: It's not just defi and whales and huge transactions. There's seemingly real consumer use cases that are popping up here. Small shell slide. This is from before Stargate V two was out, because Stargate V two is not in defi llama yet. But my point here is that, yeah, we're showing that across is doing good volume, but the other two bridges, other two fast bridges here, or three of the four fast bridges up here are all intent based. Orbiter is intent based. DBridge is intent based.
00:18:57.530 - 00:19:24.970, Speaker A: We are. And I think it's becoming pretty clear that this intent architecture is what's winning this kind of interop game. And I'm a believer that the best architecture will ultimately win in these crypto systems. That is our presentation. I'm on Twitter hel 2001, Nick's mountain water pie. And now we get fun Q and a and I'll stop talking.
00:19:25.470 - 00:19:33.930, Speaker C: Awesome. Thank you. Okay, we're going to do Q and a, and if you have a question, you're going to speak into this microphone so that they can hear it. So who has a question?
00:19:34.710 - 00:19:58.210, Speaker D: So you have the vision for applications. Like, you showed us the demo and talked a little bit about chain abstraction and just filling out order flow, like tickets, I guess, like pull that thread and five years out, ten years out from now, what are the implications downstream of that? What's going to be the end game here?
00:19:59.590 - 00:20:47.882, Speaker B: Yeah, maybe we have different takes, but I think maybe like a year ago, people thought that all the bridging volume would go through aggregators or maybe even on the bridge page itself. I think what we're seeing on the bd side and the trend right now, it seems that a lot of volumes can start shifting to the apps themselves that integrate the bridging behind the scenes. You might go to some app where you might mint an NFT or do some other defi trade. You will probably have to get your assets to that chain and that will involve a bridge. But you, as the user ideally are abstracted away from that experience. So I think that's where a lot of the bridging volume is going to be. And a lot of these transactions are very small usually.
00:20:47.882 - 00:20:52.590, Speaker B: So it is going to come down to speed and then integration speed.
00:20:53.610 - 00:21:22.006, Speaker A: Yeah, I guess, Jesse, what I'd add is, okay, so in a single chain context, what does the user do? They sign the transaction. Talking basic shit. So they sign the transaction. Heres exactly what they want to do. They sign it, it gets executed by blockchain. I really do think this cross chain intent, its not a very far mental leap for what adapt would do to be cross chain. Instead of signing a transaction, they sign.
00:21:22.006 - 00:22:38.536, Speaker A: I really like this mental model of an order ticket. They sign an order ticket that's like, okay, user assets are on this chain and we want to send them to this chain, this amount, and we want to do this action. And the Dapp just has the user sign that. Then instead of throwing that transaction into the mempool on a single blockchain to get executed, they throw that transaction into the intent solver architecture where you can maybe think of it as a mempool, mempool for intents, if we want to make the analogy. And solvers compete to fill that very quickly and very cheaply and the user gets the action done extremely fast in a way that feels, it just blends away the fact that it actually got executed on other blockchain. The gap here is actually executing that action on another blockchain. Might take some time, but we've filled that gap because the solver has fronted their own money to do that thing and they can do that thing very quickly because they take on finality risk and da da da da.
00:22:38.536 - 00:23:34.450, Speaker A: You ultimately think of it as an intelligent risk transfer where the user doesn't want to know how any of this infrastructure works. They don't care that they're supposed to wait for finality on their home chain and then wait for execution on their destination chain. They don't care about any of that. Instead, a more sophisticated actor, the solver, understands all those risks and they take on that risk and they go and do that action. And so adapt just fills out the order ticket like they fill out a transaction today and the action happens to go a little bit deeper on the chain. Abstraction ideas. What we can do today, and I'm not just talking about across, I'm talking about our ecosystem, is we can have the user pay for a transaction on a home chain and then have it executed on a destination chain and execute code there.
00:23:34.450 - 00:24:00.220, Speaker A: We can do the I go and buy an NFT on that other chain. We can do that today. And that, honestly, that seems like we're halfway to chain abstraction. You could literally just have all your funds on base. We'll call base your Venmo chain. I have all my funds on base and I'm just executing things on other chains that I don't even know they exist. I keep buying nfts on 50 different chains and I don't have to have any gas there.
00:24:00.220 - 00:24:44.484, Speaker A: There's no dust. Seems pretty great. And because we're getting the fill times down to about, oftentimes we have two second fills, it does feel like you're just operating on one chain. And we have the capacity to almost have that done at the speed of a single blockchain. So that seems really great. What we don't have figured out yet is how you go the other way. So if base is my home chain and I bought an NFT on some other chain and it's in my wallet on that other chain, how do I sell that NFT on the other chain from base? And that's where we need EIP 3074 or 4337.
00:24:44.484 - 00:25:16.090, Speaker A: We need some of these account abstraction or smart wallet things where then we could go the other way where the user could pay the gas cost to execute on that other chain and sign a message from base that is like a portable signature that they could execute on the smart contract wallet on the destination chain. And so I think what we'll see sort of in the next six months is completing a loop on chain abstraction. So I can sit on one chain and do actions both, like going there and coming back without ever having knowing that that other chain exists.
00:25:17.550 - 00:25:25.544, Speaker C: Thank you so much for speaking. You put your twitter, so that's how to reach out to heart and, yeah, thanks, guys, for taking time from your offsite.
00:25:25.742 - 00:25:26.508, Speaker A: Thank you, guys.
00:25:26.564 - 00:25:26.956, Speaker B: Thank you.
00:25:26.988 - 00:25:27.380, Speaker A: See New York.
