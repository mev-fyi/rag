00:00:06.960 - 00:00:42.030, Speaker A: Hey, guys, I'm Jack, one of the co founders of Turnkey. I'm the CTO. I was at Coinbase for a long time working on infrared security over there. That led to working on Coinbase custody. I was the first engineer working on Coinbase custody and built out the cold storage system that sits underneath Coinbase custody. And now actually all of Coinbase. I was intro into key management, crypto security stuff, went over to polychain, then did a ton of long tail asset work, asset custody work over to polychain, and that led me to build turnkey.
00:00:42.030 - 00:01:23.300, Speaker A: What are we going to cover here? A little bit just around the fundamentals of key management, things that are involved in the process. Going to spend a bit of time talking about things that I think are overlooked, trust assumptions in crypto and security considerations. And then basically what is turnkey and how are we doing things a little differently? Basic. Everyone in this room probably knows these three things. There we go. Management comes down to three different parts of the process. You have key generation, key storage, key access.
00:01:23.300 - 00:01:50.098, Speaker A: Storage and access go hand in hand in my book. And generation of keys is oftentimes super, super overlooked in my mind. It's very easy to get wrong. It's very easy to shoot yourself in the foot when you're generating keys. It's very kind of opaque when you're using bad. Entropy is sort of the TLtr on that. We have a guy at Turnkey who, his name is Lance.
00:01:50.098 - 00:02:30.110, Speaker A: He works on a lot of our kind of like really, really low level build systems, but he was responsible for finding the CVE last summer. That's called Milkshade. Definitely check it out if you guys want to take a look at this vulnerability. Milksat is basically issue in the generation of keys from this tool called BX. BX was a very commonly used swiss army knife crypto tool that's included in the mastering bitcoin book. So it's all throughout mastering bitcoin, there's this tool that's referenced and there's amples of using BX. The BX, like seed generation was just completely broken.
00:02:30.110 - 00:03:38.050, Speaker A: It basically would deterministically produce a crypto private seed based on the time that you were going to that you actually executed the call, like the Unix timestamp. And so if you just knew exactly when someone had generated a key, it would just produce the exact same seed phrase every time. So yeah, the name milksat actually comes from. If Younix epoch into Bx seed, you get a seed phrase that's like milk sad, something, something so anyways, a lot of funds have been lost over the years from people not realizing that they'd generated keys with an insecure sort of key generation RNG tool or something. And then funds ultimately just kind of being vulnerable in kind of an unknown way over a long period of time. Okay, origin, access, the other two major parts of this process, I said before they go hand in hand in my book, and what I mean by that is that access really dictates storage. So, for example, if you're building an application that is needing to touch a crypto private key 60 times a minute, that obviously means that you can't have humans involved in a cold storage recovery process.
00:03:38.050 - 00:04:14.130, Speaker A: On the other hand, if you're trying to store a billion dollars of crypto, and you're trying to do so for three years, not touch him in the meantime, it probably makes sense to store your crypto in a way that is like super disconnected from the Internet. You will never actually be able to have a software vulnerability lead to compromise, things like that. So they're very sort of attached in my mind. Okay, gonna talk about trust assumptions in a bunch of crypto things. So, metamask, great wallet, tons of people use metamask. I think, broadly speaking, people think of metamask as non custodial, secure. It's running on your machine.
00:04:14.130 - 00:05:03.064, Speaker A: Good metamask, great tool. It is an open source tool, which I think is a great aspect to it. It is a chrome extension, though, chrome extensions, especially in metamask case, it is by default auto upgrade the release engineers and consensus. And in metamask specifically, they more or less release of Metamask to most metamask users that will just automatically get upgraded the next time they open metamask. It's convenient for release processes, but you're putting a lot of trust in the release engineers who are actually developing metamask. And in my mind, that's a scary assumption. You're also putting a lot of trust in the browser itself.
00:05:03.064 - 00:05:24.564, Speaker A: You're putting trust in the hardware that you're running this on, the operating system you're running on. I think the point is, trust goes all the way down. Ledger is another really good example. People use Ledger. People think of Ledger as like a cold storage offering. I think arguably it kind of is, kind of isn't. Ledger's great and has been responsible for, I think, keeping a lot of the industry safe over the years.
00:05:24.564 - 00:06:09.344, Speaker A: But also Ledger uses completely closed source firmware. I don't know if people remember the kind of PR debacle from a year and a half ago, or whatever it was, I think a lot of people became aware at that time that Ledger did have the ability to push upgrades that can do things that seem like it would violate the constraints or what the device is supposed to do. In this case, they shipped a sort of product feature that let people kind of extract a seed phrase from the ledger. My guess is that pretty much everyone who uses a ledger just blindly upgrades the firmware anytime there is a new firmware. So you're putting a lot of trust in the ledger development team. MPC is another thing. I think that there's unknown and underground trust assumptions everywhere.
00:06:09.344 - 00:07:22.590, Speaker A: So people love MPC. I think there's a lot of value in certain architectures of MPC. But if your MPC signing system is just blindly signing any request that comes through, or blindly partially signing any request that comes through, and there's no difference in the people who control access to these different notes, and no difference between the actual machines that are running them. Well, basically, you've reduced something that has the potential to be distributed, and trust me, and distributed across a bunch of people, you've now reduced it down to the same set of vulnerabilities as a single machine trusted hardware. Also, tons of trust assumptions baked into that. Inherently, you're trusting the hardware, you're trusting the secure code processor of a piece of hardware like an HSM or a Te. Okay, what questions should you be asking them? So, what vectors of ATT and CK do I want to minimize when it comes to key generation, storage and access? And I think the operative word here is like, what do I want to minimize? So when you're building an application, like, what are the critical things that are important based on the access patterns and value that you're actually storing? That completely dictates the answers to these questions.
00:07:22.590 - 00:08:24.310, Speaker A: Actually, before I was talking about cold storage at Coinbase, we were working with clients that had billions of dollars of crypto. And obviously, I wouldn't ask that someone store that in a super, super hot fashion. But if you know that you're only going to access it every, I don't know, couple of years, keep it offline. So how comfortable am I entrusting a piece of software or hardware in generating, storing, and accessing keys? Also kind of, you know, we were talking before, there's just so many places that you are inherently trusting software and so much more software that you are trusting, typically that I think it's worth like, breaking that apart and breaking down what's super relevant and important to your business or application. And getting comfortable trusting that because you will trust it. Similar to hardware as well, I think. Then also, how do you actually verify that software or hardware is running as you expect? This is a problem that I think very, very few people consider.
00:08:24.310 - 00:09:08.488, Speaker A: It's something we've thought a ton about at turnkey. It's super hard, machines are super opaque, and there's oftentimes so much more running on machines than you think. If you look at all the processes that are running on this computer right now, it's hundreds of them, I'm sure. And so being able to confirm that a particular wallet or something you have running on this machine is doing exactly what you think it's doing is very, very challenging, usually. Lastly, what parts of cryptographic security should you build yourself? What can you bootstrap? What do you even want to build? Is super relevant question. I was talking before. It's very easy to shoot yourself in the foot when you're working on this kind of stuff.
00:09:08.488 - 00:09:47.270, Speaker A: And I also think important is that oftentimes crypto storage is not super differentiated work. So if you're building a product, it's not highly specific to your product, the generation and access specifically not super specific to your product. And so you basically, if you want to focus more on building your product, focus more on building your product. I think shill to turnkey, we do this very well. Get back to building your product. Let us do this kind of stuff that's not super differentiated for your product specifically. So turnkey is building verifiable key management.
00:09:47.270 - 00:10:48.180, Speaker A: So we are building APIs and primitives to do a lot of these components of key management in a very secure way and basically just allow you to get back to building the product that you're trying to build. We have this pretty crazy threat model where we say everything in our backend is either trusted or untrusted. A trusted thing is something that, or it has to be trusted. If it could touch user funds, it could manipulate data that could lead to a user's funds being in a more bonus position. Anything really like that, without fail, every single workload like that will run in a testable, trusted hardware. In order to facilitate this, we've created a custom operating system to deploy these secure enclaves. So we can, using a process called remote attestation, we can verify that the code running inside of our enclaves is basically exactly what we want it to be running and nothing else.
00:10:48.180 - 00:11:37.650, Speaker A: A little bit more of a nuance point. But that means that we also have removed any single point of failures in terms of access from this whole setup, there's no engineer at Turnkey who has full control over any of these systems. It's all this quorum based, consensus based upgrade process. Then we augment the trust by ensuring that applications only run on what we call verifiable data. Which basically means enclaves at rest are, there's no persistent storage within enclaves. And so there's always this kind of challenging moment of ingressing and egressing data between like that has persisted outside the enclaves, into the enclaves. And so we've built a very rigorous pattern on ensuring that the enclaves will only act on verifiable notarized data.
00:11:37.650 - 00:12:09.290, Speaker A: This turns into this like very crazy trial where we say basically every machine in Turnkey's back end other than the enclaves could be compromised and funds would not be able to be stolen. And yeah, so it's a very rigorous process and we've kind of thought about this from many different angles. Cool. Okay, so if you're curious to learn more, I'll be here for a bit. Docs dot turnkey.com comma. We have pretty robust documentation.
00:12:09.290 - 00:12:23.398, Speaker A: We're on GitHub Q and I'm on Telegram and twitter if you guys want to get in touch. Ok, sweet. We already have questions. Thank you.
00:12:23.414 - 00:12:32.742, Speaker B: Jack, you mentioned the upgrade mechanism is based on consensus and that's decentralized. Is that decentralized just across the team or outside of the team as well?
00:12:32.846 - 00:12:41.340, Speaker A: Yeah, it's currently just within the team. I wouldn't call it decentralized, really. It's like, but it's multi party is the critical thing. Yeah.
00:12:45.760 - 00:13:03.526, Speaker C: So is the hardware that you guys like, what kind of hardware are you deploying to? And is this like, and like the enclaves? Is that like pre aws nitro enclaves? Or have you, have you guys like, what's your guys view on nitro enclaves?
00:13:03.608 - 00:13:36.530, Speaker A: Yeah, so we're using nitros right now. We more generally are targeting the TPM 2.0 standard though. And so nitro is like, they started with nitro enclaves, now they're rolling out nitro TPM and they actually just released the first, the like last API. We need to do that transition. So eventually we'll target nitro TPM and then from there basically any machine that supports TPM 2.0. So the idea is eventually to be like totally agnostic to Amazon or any cloud environment and be able to target all different kinds of hardware.
00:13:41.470 - 00:13:53.022, Speaker D: Hey, can you explain the non custodial guarantees here? And if you guys are using some sort of MPC sharded situation combined with something else or what it is.
00:13:53.126 - 00:14:56.940, Speaker A: Yeah. Okay, so I was talking about that kind of like two part architecture. We have machines that are trusted and not run or trusted in every, all of those workloads are run inside of nitro enclaves and then untrusted workloads totally outside of nitro enclaves. The untrusted machines are like they could fully observe all the requests that come into the system and not be able to actually do anything to manipulate data, change aspects of users accounts, steal funds, anything like that. So the way that happens is that client side, a user uses an API key or a passkey or something like that, cryptographic key pair, client side, they sign the entire content of the payload and then that is ingested and only ever actually like within the enclave. The enclave will make a determination based on its understanding of the user and whether it has. It associates that public key associated with the stamp, that it gets to be in control and able to perform the action the user's trying to perform.
00:14:56.940 - 00:15:05.300, Speaker A: And so really then it's like the user's in control via this authenticator and that's enforced all the way down to the enclave, I guess.
