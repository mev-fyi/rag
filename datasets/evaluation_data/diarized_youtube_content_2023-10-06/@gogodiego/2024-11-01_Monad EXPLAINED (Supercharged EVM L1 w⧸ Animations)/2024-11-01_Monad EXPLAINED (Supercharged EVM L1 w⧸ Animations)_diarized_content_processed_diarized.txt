00:00:00.240 - 00:00:03.409, Speaker A: Monad Monad Monad Monad Monad of Monad.
00:00:03.457 - 00:00:05.625, Speaker B: And Monad Monad Monad.
00:00:05.705 - 00:00:13.793, Speaker A: Monad is aligning to be one of the biggest airdrops of 2024. A killer L1, a supercharged EVM.
00:00:13.929 - 00:00:19.065, Speaker B: Which chain can even push past Solana scalability? I would put Monad.
00:00:19.145 - 00:00:22.305, Speaker A: Keone Han, the co founder of Monad hey, doing well.
00:00:22.345 - 00:00:23.177, Speaker B: Thanks for having me.
00:00:23.241 - 00:00:30.981, Speaker A: Eunice is a co founder of Monad. Really appreciate you having me on. James Huntsaker, the co founder of Monad.
00:00:31.053 - 00:00:32.253, Speaker C: Thank you for having me.
00:00:32.429 - 00:01:11.755, Speaker B: Monad is a reimagining of Ethereum from the ground up to make the EVM extremely performant, offering over 10,000 transactions per second of throughput that gives everyone the best of both worlds. With full bytecode EVM compatibility. Ethereum processes about a million transactions per day and Monad is taking that throughput from a million transactions per day to a billion by redesigning both execution and consensus layers to introduce four major improvements. And Monad is doing that by introducing.
00:01:11.835 - 00:01:16.275, Speaker C: Optimistic execution or parallel execution. Is trying to utilize the full power.
00:01:16.315 - 00:01:20.579, Speaker A: Of the machine, the consensus engine, which is the heart and Soul of Monad.
00:01:20.627 - 00:01:25.019, Speaker B: BFT a completely new database that's built from scratch called MonadDB.
00:01:25.187 - 00:01:38.935, Speaker A: But correct me if I'm wrong, Monad still plans to kind of launch its own alternative layer ones. Why do we need another layer one? Why not just launch, as you know, one of 100 plus L2s? Why not make Monad in L2 if.
00:01:38.992 - 00:01:44.791, Speaker C: The L1 can handle all the transactions, why would you have an L2? That doesn't really make sense to me.
00:01:44.943 - 00:02:34.539, Speaker A: Monad The High Performance EVM L1 Monad supercharges the EVM by pioneering optimistic parallel execution. It has low fees and low hardware requirements with their own database implementation monadDB and they offer 1/2 block times with single slot finality with their custom consensus protocol Monad bft. But those are just the claims on the website. Is it a hidden gem? Solana killer? Does it actually have 10,000 transactions per second? Or is it an overhyped project that we'll all forget about in three years? You're going to have to figure that out yourself. But this video is split into three parts to actually talk about its core technology. One optimistic parallel execution how it compares with the standard EVM versus Solana's svm. Two, we're going to talk about their custom database implementation Monad and then three, we're going to talk about their consensus algorithm Monad BFT and its deferred execution.
00:02:34.539 - 00:03:09.039, Speaker A: The Monad team has reviewed and approved my explanation of their technology for accuracy, but they didn't see the end of my video where I share my personal opinions and just my overall feelings and opinions about Monad. So watch to the end and this video is sponsored by myself. I make high quality animated videos to explain blockchain technology and this episode is about Monad. So let's explain it. Parallel execution is hot and every smart contracting programming language has it. You have the ones who popularized it Solana with their C level vm. You have the ones who followed along like the Move language projects, Aptos suite and movement.
00:03:09.039 - 00:03:57.537, Speaker A: And there's plenty of other high performance L1s and L2s like SEI, Fuel and Eclipse. Parallel execution compared to single threaded execution means you're able to run more transactions in parallel, allowing for this new era of high performance blockchains. But the evm, the execution environment that Ethereum uses, the largest execution environment with the most developers, users, tooling and ecosystem doesn't have parallel execution and it's designed for the exact opposite. So how did Monad solve the impossible and supercharged the EVM with parallel execution? You can imagine execution of transactions like cars paying a toll road fee on a highway. Each car is a transaction trying to do something and go somewhere. Each lane is a thread or cord that can accept these cars AKA transactions. Each toll booth is doing execution and calculating the final fee.
00:03:57.537 - 00:04:40.769, Speaker A: You have multiple lanes allowing you for more cars and these transactions start in a pool and get directed on which lane they can use. Modern CPUs have multiple cores, aka multiple lanes of computation, and have an instruction set to manage and direct the computation across these lanes. So in 1999 you could get a Pentium 3 with only one core. But then in 2010 you could get a Pentium dual core with two cores. And now for 300 bucks you can get an AMD Ryzen 7 with eight cores, or spend more money at 600 bucks to get an intel i9 with 16 cores. So understand that more cores equals more lanes, which means more computation AKA faster. But also there might be bottlenecks in the director and their instruction set, and you're going to learn more about that later.
00:04:40.769 - 00:05:37.633, Speaker A: So let's compare single versus Multithreaded Multithreaded execution in crypto means the execution environment has a transaction scheduler with instructions that let you use multiple lanes. So they let red car use lane 1, yellow car use lane 2, green use lane 3, blue uses 4, and purple uses lane 5. If each lane can process one transactions second, then all five transactions are done in just a second, all while single threaded execution. Like infamously, the EVM means transaction scheduler instructions only let you use one lane, even though modern CPUs have multiple so we still have multiple lanes. But the instructions instead label each car in sequential order and only let one at a time. So the director only has one lane open and labels red car 1, yellow car 2, green car 3, blue car 4, and purple car 5. So in the same lanes that handle one transaction per second, these five transactions are done in five seconds.
00:05:37.633 - 00:06:16.427, Speaker A: So why doesn't the EVM just use all the lanes? Why is it so hard for the EVM to become a multi threaded execution environment? The difference is in the transaction scheduler's instruction set and how the transactions are executed. The reason why the EVM is slow and like this is because the instructions require transactions to be executed sequentially. And this is to prevent the collision of transaction state. Let's say these cars wanted to fill up on gasoline and they saw there's only $75 worth of gas at gas station. So yellow, purple and green car all try to buy $50 worth of gas. Yellow car paid for 50 and got $50 in gas. Purple car paid for 50 but only got $25 worth of gas.
00:06:16.427 - 00:06:49.133, Speaker A: And the last car paid for 50 but got nothing in return. And those two other cars that weren't in a gas war weren't affected. The reason why some cars got screwed over is because they were all running in parallel trying to access the same state. And when all these transactions are trying to read and write state at the same time, there can be a collision. If these cars were labeled sequentially and executed in the right order, you wouldn't have a collision trying to access the same state or resources. Yellow car would be labeled Transaction 1, see $75 worth of gas, pay for 50 and get $50 worth. Then the transaction state would be updated.
00:06:49.133 - 00:07:23.441, Speaker A: Purple car would realize he can only buy $25 worth and only pay $25. And the last car labeled number three would see this updated state and realize he can't buy any more gas. But notice that when you label everything sequentially, these other two cars that weren't getting gas stuck in line. So turns out ordering sometimes does matter if you're trying to be first. If you're in an auction scenario, and if you're doing things that are related and affect each other, you need ordering. But sometimes, like those last two cards, if you're doing something unrelated, then ordering doesn't matter. So now let's talk about Multi threaded parallelized execution.
00:07:23.441 - 00:08:00.981, Speaker A: So how do you make an instruction set to parallelize transaction execution? Remember, you need instructions to be sequentially when you're executing transactions that are trying to access the same state. And you can have them run in parallel if the state is separated. The pioneer of parallelized execution environment in crypto is Solana's C level runtime. They separate the transaction from its state and forces software engineers to program specifically and say which state they're going to access ahead of time. Solana's C level runtime pushes the responsibility of the transaction scheduler onto the engineer. When you're writing Solana smart contracts, you have to think about parallelization. Meanwhile, Solidity developers don't have to worry.
00:08:00.981 - 00:08:35.935, Speaker A: So although it's more complicated for developers, parallelized execution is dramatic, more efficient. So it's worth it to learn a harder, more stricter language for better execution. But how does Monad get the EVM and parallelize it? Because this should be impossible. Solidity was specifically designed for the opposite being single threaded. These two have two fundamentally different ways on writing and executing transactions. But Monad uses this clever, optimistic method to get sweep parallelization. What Monad does is magically make a single threaded execution environment, the evm, multithreaded by just making it multi.
00:08:35.935 - 00:09:18.051, Speaker A: Threaded. They get all the transactions, they run them in parallel, and if there's a collision, because transactions are trying to access the same state, all they do is label them sequentially and re execute them in single threaded order. So the problem with collisions isn't actually the collision itself, but it's adding the final results to the chain. So you add all the parallelized transactions that didn't have collisions, and the ones that do, you just relabel, re execute, and then add them in that order. And this is weirdly a really good way of doing this because the best case scenario, all the transactions just run in parallel. The worst case scenario, it's single threaded, like they would have to be anyways. And EVM developers can just deploy their code, have their transactions run in parallel without having to learn a whole new language.
00:09:18.051 - 00:09:53.019, Speaker A: This is such a cool idea, but Monad also applies these optimistic and parallel methods to their database and their consensus protocol. Now let's learn about monadDB. DB standing for database. Parallel execution is great, but it requires you to read the state you want to change and write a new one to it. Your state of the art parallelized execution environment can still be bottlenecked if the database is slow and single threaded. Using the lanes analogy, it's like an Old car on the road with old data, it requires the computer to dig deep inside its storage to pull out the state. Or maybe the vehicle is really large and in that case you have to pull out a lot of data.
00:09:53.019 - 00:10:25.457, Speaker A: But just like in the lane analogy, where some cars could be slow, some cars could be fast, there could be cars that are really fast only because they're light and simple. Think like simple payment transactions. Or this could be a really frequent driver, and in that case their state is already loaded up and cached in your computer's ram. Think about application state that's always being used like Uniswap. So we want our execution environment to be fast, but we also need our database to be equally as fast. But normal databases that are not in blockchains prioritize speed. This means normal databases are often organized in large nested collections.
00:10:25.457 - 00:10:53.663, Speaker A: But blockchains are not normal. They want to be verifiable. So they have a special data structure called a Merkle tree. So here's a quick recap why you have these leaves which are transactions, and on top of them are these unique tamper proof IDs called hashes. A merkle tree combines the IDs or hashes of two leaves to make a new hash which is a new tamper proof id. And then combine the pairs all the way up to the top. So you have the leaves in the bottom which are the transactions, you have the branches which are combining the hashes.
00:10:53.663 - 00:11:30.987, Speaker A: And at the top you have the root of the tree. And remember that that root of the tree has the hash of the previous root, and inside that block, that root of the tree has the hash of the previous one, and so on and so forth. So with this Merkle tree structure and these Merkle trees tied together, so if you cut off just one leaf or one branch, it modifies the rest of the hashes and every other hash after that. This makes a string of a verifiable tamper proof database. All blockchains use this because it's easy to verify, but it's also really slow. Ethereum uses a traditional database called Pebble DB and then stor those verifiable Merkle trees inside there. So trying to read and write state is pretty slow.
00:11:30.987 - 00:11:54.579, Speaker A: First you have to look inside a Pebble DB structure and then search through the Merkle tree to find a certain transaction. You can imagine that this is pretty slow. So Monad made a custom implementation called monaddb. They use the same Merkle tree implementation that Ethereum uses, a Merkle Patricia tree. But unlike Ethereum. This is not stuffed inside another database. MonadDB has native access to its its disk and RAM and allows you to have a really fast database.
00:11:54.579 - 00:12:32.761, Speaker A: But if you still had parallel execution, but not a parallelized database, you would still have bottlenecks. So Monad also applied parallelization to their database, which means Monad has asynchronous reads and writes, which this level of engineering is really cool. And now we're on to the third part of the video. To understand these claims of 1 second block times single slot finality and 10,000 transactions per second second, let's talk about Monad BFT and its deferred execution. Monad BFT is a derivative of Hot Stuff with some of these proposed improvements. It's a two phase BFT algorithm with optimistic responsiveness. And it has deferred execution, otherwise known as asynchronous execution.
00:12:32.761 - 00:13:10.679, Speaker A: So Monad BFT is based off the two phased Hot Stuff, which is inspired by three phase tendermint. Overall, it's more efficient than Tendermint and can support more nodes due to its linear complexity. Typical tendermint requires all to all communication and has a pre vote and pre commit phase. But Hot Stuff has made it more efficient by combining these phases into one. And leaders only have communication with the rest of the nodes, which is linear complexity versus tendermint's exponential. So it does communication directly because it's optimistic that the leader will respond. But if it doesn't, the fallback mechanism does all to all communication, like in Tendermint, to figure out the current state and then propose the next leader.
00:13:10.679 - 00:13:41.725, Speaker A: Next up, we're onto deferred execution. Monad also has deferred execution, which is also called asynchronous execution. And this allows Monad to expand the gas and execution budget. This is by decoupling the consensus from the execution and finalizing the execution later, AKA deferring it. So typical chains come to consensus on transactions, then they execute the transactions to finalize the block. This means you have a target block time, and let's just say it's 10 seconds. Typically you would be doing around 1 second of execution and 9 seconds of consensus.
00:13:41.725 - 00:14:23.331, Speaker A: But if you focus on consensus for the first 10 seconds, which is all the networking and communication, then you defer the execution for the next block. Now in that block you have 10 seconds to execute the transactions with your CPU while simultaneously during those 10 seconds doing the networking and consensus for the next block. So this expands the execution budget from 1 second to 10 seconds, allowing you to increase the block size and execute more transactions. All this without increasing the block times. The only small downside with the system is that finality is now minus one block. So both in action with deferred execution and monad bft, a leader proposes a block and directly sends it to the rest of the consensus notes. The nodes are executing the previous block while finalize it.
00:14:23.331 - 00:15:03.723, Speaker A: While they receive directly the block from leader A. They are also voting and then sending their votes to leader B while leader B then proposes the next block and then the cycle just repeats itself. You can see how this is more efficient with the leaders directly communicating and how pipelining with deferred execution lets them multitask and execute previous transactions while voting on the next one. Now we're on to my favorite part. Final Thoughts so Monad isn't the blockchain that's reinvented but actually refined, re engineered and retuned. The Monad team is a team of hardcore engineers, not researchers. They have understood the blockchain and have fine tuned every part of the stack to make it more performant.
00:15:03.723 - 00:15:59.665, Speaker A: And lots of big bottlenecks that blockchains have. They have dramatically reduced anything that's optimistic, asynchronous or parallelized. They apply to Monad. But my big question is that is it worth having another alternative EVM L1 chain Monad reminds me of Avalanche from last cycle. Avalanche was faster and better than Ethereum like Monad is now. Avalanche had a vibrant community of red colored animals like Monad does now, but purple and now Avalanche is sort of an empty ghost town that no one really cares about and everyone has cycled and rotated to better alt EVMs like Monad. So my overall feelings is Monad has super cool technology and they've applied all these hardcore low level optimizations but they apply this towards L1 technology and will this L1 still be relevant? So although I love Monad and trust me, I made a whole video about it, you're watching it.
00:15:59.665 - 00:16:26.275, Speaker A: Will we forget about Monad in the next cycle? I can't say for certain, but I feel like The Alt EVM L1 rotation cycle game is unsustainable and these amazing engineering efforts and hardcore low level optimizations could have gone to roll up technology. I don't know and only time will tell. But thanks to the Monad team for reviewing for technical accuracy and thank you so much for watching. Explain.
