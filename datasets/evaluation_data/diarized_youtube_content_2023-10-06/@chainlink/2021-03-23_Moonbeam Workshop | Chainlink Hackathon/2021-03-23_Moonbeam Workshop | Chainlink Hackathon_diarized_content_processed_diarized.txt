00:00:02.330 - 00:00:15.360, Speaker A: We are preparing to go live. We are probably going to be live any second now, if not right now. We are now streaming live on YouTube according to.
00:00:16.210 - 00:00:23.838, Speaker B: Oh, yeah, I see the live stuff here. There's like a countdown est like five minutes or so.
00:00:24.004 - 00:00:25.040, Speaker A: What's that?
00:00:25.850 - 00:00:27.462, Speaker B: Oh, wait, no, this is streaming now.
00:00:27.516 - 00:00:59.470, Speaker A: Yeah, we're streaming now. Hey, how's it going, everybody? I am here with the Moonbeam team. I'm here with Alberto and Kathy from Moonbeam. We're really excited to be going into this and learning more about the EVM compatible Polkadot chain Moonbeam, which I've personally tested out. And it's a really clean interface. Alberto had an awesome prizes video that hopefully all you guys checked out. But with that, I'm going to turn it over to the Moonbeam team and let them take it from.
00:00:59.620 - 00:01:19.202, Speaker B: Yeah, thanks. Thanks, Patrick. Yeah, I'm truly excited to be here. I really enjoyed the last workshop we did, I think a month ago or so. So it's a pleasure to be here once again and present in a chain link event. Right? Moonbeam is super excited to be part of a sponsor of the event. So, yeah, like Patrick mentioned, I'm Alberto.
00:01:19.202 - 00:01:49.322, Speaker B: I work at developer relations at Peerstake. And today I'll be presenting to you how to get started on Moonbeam and chain link oracles. So please feel free to always chime in questions in YouTube. And I have Kathy with me. She will share those questions with me over Zoom and I'll be happy to interrupt my presentation and check the questions and answer them as we go. All right, so, yeah, let's get started. Today's agenda, it's going to be a little bit of like, I really like self contained presentations.
00:01:49.322 - 00:02:24.218, Speaker B: So as always, I'll do a brief introduction of what is Moonbeam and we'll also go into some technical details and then we'll move to a demo time. And this time, I prepared some additional slides to show you guys how you can get started in Moonbeam. Like, different ways you can do so and so on. And of course, we also have a demo that includes some chainlink stuff that is running currently in our testnet called Moonbase Alpha. So I really like the meme on the right hand side because it tells you, like, Moonbeam brings Ethereum and Polkadot together. And I think it's a pretty nice image. So, yeah, let's get started.
00:02:24.218 - 00:03:22.750, Speaker B: And I guess the first question we have to ask ourselves, it's what? It's moonbeam. Right? So if you're not familiar with the Polkadot ecosystem or Kusama basically, Polkadot and Kusama are blockchains that are called relay chains, right? And the idea is that they provide shared security to a bunch of blockchains that will connect to it. And these blockchains that connect are called parachains. But the problem is that the relay chains, they don't offer smart contracts, capabilities, and they leave a lot of these features to this parachain. So Moonbeam is a smart contract parachain on Polkadot and Kusama. And we like to say that we're the easiest entry point for Ethereum projects because we are fully focused on deep Ethereum compatibility. And if we're going to talk about Polkadot, we have to talk about crushing integration because basically Polkadot, the main selling point is that you will be able to communicate with all the parachains that are a part of the ecosystem.
00:03:22.750 - 00:04:25.680, Speaker B: And if you're wondering where the name Moonbeam comes from, it's from the jazz standard polka dots and Moonbeam. So Moombeam's Ethereum compatibility help Polka dots in many ways, but we're going to only talk about, briefly about three of them. So first, of course, it provides an easy on ramp for existing projects and developers because we fully support web three and like the web three API, and we have an EVM. So existing projects can get started with working on polka dot with minimal effort, like Patrick mentioned, right? It's super easy and super straightforward to get started on Moonbeam in just a matter of minutes. In fact, and connected to this first point, we also offer the choice of popular Ethereum development tools. And this is part of our Ethereum compatibility package, right? So developers can use the tools that they know and love and have worked with them for several years to work on Moonbeam. So these tools include Metamask, remix, Truffle, hardhat, a lot of the most popular, like Ethereum libraries and so on.
00:04:25.680 - 00:05:18.530, Speaker B: But Moonbeam is more than just like an EVM on top of a substrate based chain, right? We extend beyond smart contracts and tools. We've also modified the underlying account system in a way that we only use the Ethereum style account format. So you will use your Ethereum account to not only sign EVM transactions, but you can also use it to do substrate or polkadot based features such as governance and staking. So this is actually truly exciting. And we also offer stuff like event subscriptions, and we're working on a debug API to help indexers work on Moonbeam and so on. So it's just more like a simple EVM layer. We've added a lot of features to become the most frictionless Ethereum environment in the Polkadot ecosystem.
00:05:18.530 - 00:06:36.602, Speaker B: So why does a multichain strategy make sense? And today I'm going to talk only about the first two discussion panels that we see on the screen. I mean, this is probably like a never ending discussion that you can have with friends, but basically the first one is the lost market opportunity. And we have discussed with multiple projects that, let's say you're a project that wants to do like an online game or whatever, and you need to roll a dice on chain for transparency issues, right? And so basically, if you want to roll a dice with a BRF on chain in Ethereum L one, it could cost you like $20, $40. So basically your use case is priced out because of current high gas fees, right? So there might be another like in a multichain strategy, you might deploy your game or whatever to a different chain where it just makes more economical sense for your project to live on. Right? The second point is first movers in new markets. And the idea is that you can draw new users and gain access to assets that are not natively available on Ethereum. And this just extends beyond Dot and KSM, which are the tokens of Polkadot and Kusama, but also a growing list of parachain based assets that is growing every month.
00:06:36.602 - 00:07:22.006, Speaker B: Right? So we have different exciting projects that are joining the Polkadot and Kusama ecosystems that will bring a ton of new parachain based assets. And by deploying your smart contracts to Moombeam, moomium can be your gateway to all these new asset pools that will become available. So yeah, welcome to the multi chain future. And basically how we envision this is that we don't see ourselves as an Ethereum competitor. We believe like in a multi chain future, there will be multiple chains coexisting with each other. And let's say that your smart contracts are solidity based and you actually have deployed them to Ethereum. And moreover, let's say that you're using a deployment tool such as truffle or hard hat.
00:07:22.006 - 00:09:12.622, Speaker B: You can actually just configure your deployment tool with an extra provider, right? So instead of being like an ethereum based provider, you can just point it to currently our testnet called Moonbase Alpha. And with that simple configuration that we're talking, that it only takes like five minutes or so, you can deploy your contracts so that they live on the Moonbase alpha test or moonbeam in the future. And with that you will have access to like I mentioned the whole Polkadot ecosystem, and this is truly exciting how we envision the multi chain future. So some of the projects that have been working on Moomium deployments include Sushiswap, balancer, ocean protocol, chainsafe, of course, Chainlink and some other projects, and I'm not going to go through them, but we're building a truly exciting ecosystem of projects that are deploying on moonbeam, and we're honestly excited about what's to come. So to get a little bit more technical, how do we bring Ethereum compatibility to a substrate based chain? And before we go into the details, let's just briefly review ETh JSON RPC communication method protocol. Right? So if you're an Ethereum user or developer on the left hand side, and you use tools such as Metamask, remix, Truffle, hardhead, the web three, Javascript library, and so on, basically what these tools allow you to is to communicate with an ethereum node in a matter of like, you make a request and then the Ethereum node will process that request and will send a response via like a JSON RPC. So let's say you have metamask connected to that Ethereum network, and basically metamask is making requests like, hey, can I know the balance of this account or can I know the latest block number? Can I get the chain id so I can verify that I'm connected to the right network? And so on.
00:09:12.622 - 00:10:08.042, Speaker B: Right? So every request that metamask does to the Ethereum node, you'll get a response specific to that request. So in Moonbeam, how does that look? So for that, we have to introduce a concept called Frontier. Actually, Frontier is a project by parity, and we've worked quite closely with the Frontier project that brings this Ethereum compatibility features to a substrate based chain. And substrate is a framework that we use to build moonbeam, that it was built as well by parity, and it's a framework that allows you to build blockchains. I would generalize this to Polkadot, which is not entirely true, but it's different, like a technology stack that gaff and Ethereum or open Ethereum. So the idea is this. Let's say you're once again an Ethereum user or developer, and you'll interact with Moonbeam as you would with a regular Ethereum environment.
00:10:08.042 - 00:11:07.466, Speaker B: Right? The thing is that you'll have frontier in the middle. And how I like to explain Frontier is like a black box definition, meaning that it's actually like a translator that will do the magic for you and you don't have to worry about, I'm working with Moomim. It's a different technology stack. How do I get started? It will feel just like Ethereum, but you'll have frontier in the middle doing the heavy lifting, if we can say it like that. But if we want to go into a little bit more detail, this is more or less how this looks at a very high level though. So let's say on the left hand side we have the Ethereum JSON RPC and we have or like truffle hardhead and other Ethereum libraries. What they will do is that they will actually interact with the Frontier RPC extension and this frontier RPC extension what has the web three Javascript compatible API or the 8th JSON RPC compatible API, and it would map all these calls to substrate runtime calls.
00:11:07.466 - 00:12:00.354, Speaker B: All right, so like I mentioned before, it's like a translation between what Ethereum understands and what substrate understands. And this works at par with the palette Ethereum and pallet Ethereum at a very generalized definition. It provides like Ethereum emulated blocks. Because when Frontier received a request saying I want to know this information from this block or whatever palette Ethereum will provide this emulated block for this kind of information besides other things, right? But at a very high level, this is technically how it works. Then we also have pallet EVM and the Rust EVM. And by the way, pallets are just, I like to think of them like building blocks or building lego blocks that you can put into the substrate based chain to add functionalities to it. So enough of the jibber jabber and the technical stuff.
00:12:00.354 - 00:12:54.914, Speaker B: What does this mean practically? Right? And just in very simple terms, let's say you go into the ETH wiki JSON RPC API from Ethereum and you make a curl command. You can run a curl command by, in this case, this HTTPs thing you see here is the HTTP endpoint of our moonbase alpha testnet. And this is a JSON RPC blob. Basically you can see that in methods we're actually requesting the ETH underscore get balance and in parameters we're passing the account that we want to query the balance from. Right? And in here we're putting latest just to make sure that we're getting the balance from the latest block available. And if we do that in a terminal, you will get this response and this response, it's basically this number in way and dev tokens, which is the tokens of our testnet. And this is basically the same thing.
00:12:54.914 - 00:13:21.498, Speaker B: You will see in Metamask. So metamask, actually one of the JSON RPC calls that it does is this exact one. Right. But this is against, like I mentioned, a different technology stack that it's substrate. So this is basically frontier doing its magic to provide you the same response that you would get as you would do against an ethereum node. And when I learned this months ago, I was truly mind blown. It's like the experience is just exactly the same.
00:13:21.498 - 00:14:10.022, Speaker B: And as we go with the demo, you will see exactly that, that it's very frictionless. I can do a demo for you and if I don't tell you that I'm on Moomi, you might not even notice. So yeah, I mean with all that accounted, let's go for the demo. But first I want to do some slides to explain some features, how you can get started and explain a little bit about the Chainlink module architecture models that we've deployed to our testnet. So let's say that you're a developer and you want to get started on Moonmeam like right after this presentation, right? That would be awesome. So there are like two ways you can actually do that. You can build a standalone node for yourself or you can go down the tested path, which is our tested, like I mentioned, is Moonbase Alpha.
00:14:10.022 - 00:14:52.294, Speaker B: So in a standalone node you have something called instanceal. And if you're familiar with ganache, instanceal is similar, meaning that only a block will be produced when there is a transaction on queue. And this is honestly super fast for development. If you're testing stuff, you're testing your smart contracts, checking them out if they work or not. I mean this is super useful because there is no lag between you sending a transaction and that transaction being processed in a block, right? Let's say you wanted to start with a standalone node. So you can actually start with a docker image which has the pre built binary of the node and you can run it in dev mode. And this is honestly the fastest way you can get started on the standalone node path.
00:14:52.294 - 00:15:29.090, Speaker B: Right? The other way you can do that as well is by cloning the repo that we have on GitHub, compiling the binary, and running that binary in dev mode. So the hash dev, it's a flag that in our case just basically runs the node in a standalone way. Let's say it like that. But this is one way of starting. What about the testnet? So yeah, the Testnet is accessible for all. And I would say it's even faster to get started on the Testnet because you don't have to even run the docker image or anything, it's like super fast. So we provide an HTP and websocket endpoint for the Testnet.
00:15:29.090 - 00:16:11.906, Speaker B: There is a token faucet as well. You can get dev tokens to get started, play around with the tokens and so on. And some features that we recently launched is the staking and governance features. And we're truly excited about this because like I mentioned, you can use your regular Ethereum account that you can create for example via metamask to sign transactions related to staking and governance on chain, which is truly exciting. So I mean, like I mentioned, these are the two ways you can get started. So let's go down the standalone node path. So the standalone node, if you run it with the default settings, you'll have an HTTP endpoint at port 9933 and a websocket endpoint at port 9944.
00:16:11.906 - 00:16:53.530, Speaker B: If you're interested in the Docker way, this is the one liner command. It's not one liner, it's four, but just because we have this slash. But basically it's like a one liner, like a thing that you can get started with a standalone node like super fast. And if I actually go to my terminal here and I do have the one liner, I mean I do have some extra flags, it's because I'm running it on windows. But this command that I showed on the slide, it's for Ubuntu for example, it's like straightforward. But I do have some commands because I'm running on windows. But you can see here that once I run this command I will get a standalone node running in a matter of seconds.
00:16:53.530 - 00:17:31.898, Speaker B: If you don't have the image, it'll just pull the image and so on. But it's super fast. If you want to clone the repository and build the binary yourself, which this actually needs, rust, you can clone the tutorial b six flag sorry, tag and then go into the moomium folder and run the init script. And this will make sure that you have the correct rust version, VLX rust toolchain. Then you can actually build the binary running cargo build release. And this process can take around 30 minutes. It really depends on your machine, but it takes a while, right? So that's why I personally prefer the Docker way.
00:17:31.898 - 00:18:10.566, Speaker B: But either way we provide both ways. And last but not least, once you have the binary built you can run it with the following command. Make sure that you add the flag. There are also extra flags you can use and I put them here. So that way you have like a source of information. If you want to get started with the standalone node, let's say that you don't want instant seal, you want to have like a regular block production time, and then you can use the sealing flag and provide a time in milliseconds. Another very useful flag is RPC trace flag.
00:18:10.566 - 00:19:07.018, Speaker B: And what this does is that it'll show you in the terminal every RPC call that the node receives, right? So this is super useful when you're like, I don't know, trying a front end and want to see if you're doing the right stuff or doing, you're calling the right methods, you can check at a node level what RPC calls are being received by the node. And this is quite useful. If you want down the clone Repo path and you want to create a temporary node, you can add the TMP flag. This is also true for, it can be true for the Docker image case, but I mean if you run the docker image with RM which removes the container once you are done, once you stop it, it's kind of like similar. You also have the no telemetry flag because it's in standalone. The telemetry exporter doesn't make a lot of sense. And actually there's some errors, warnings that pop up once in a while.
00:19:07.018 - 00:20:08.490, Speaker B: So if you don't want to see those warnings, you can add the node telemetry flag. If you're running the clone repo and want to delete the local chain, you can do so by using the purge chain command in dev. All right, so this is different than the TMP because once you stop this binary running, basically you'll have a fresh instance of the blockchain. If you restart in here, you're going to have like local storage, but if you want to purchase storage, you can use this command. And last but not least, this is quite useful. Let's say you're working in a shared environment and someone else is using already these two ports, the ports that I put on the top, you can specify custom RPC and websocket ports by using these two flags. All right, but now let's say that you want to start with the test set and not the standalone node, right? So basically what you can do is use the HTP and websocket endpoints that I put here on the slide and I just put some different examples.
00:20:08.490 - 00:20:55.230, Speaker B: Let's say you're using the web three Javascript library, then you would just pass on the HTP endpoint to the web three constructor. To create the web three instance. In the case of ether js I recommend using the static JSON RPC provider while you will pass once again the HTP endpoint and some information regarding the testnet. And last but not least, we have the truffle and hard hat as an example where you can define the provider in the truffle config file or hardhat config file. In the case of truffle, you can use the he wallet provider, for example where you pass in the private key, the endpoint and the network id. And it's very similar in the case of hardhead as you can see here on the screen. So yeah, this is like, I would say the fastest way to get started.
00:20:55.230 - 00:21:46.170, Speaker B: As you can see, it's just like minor changes that you can do to your code and all that. So it's quite a straightforward way to get started on moonbeam. All right, so in case of Chainlink, we do have two models implemented in our Moonbase Alpha test set. So we have the basic request model and price feeds. So before I show you this on a demo, I want to make sure that you understand the differences between each of these models. In the basic request model, basically you will have as a consumer, let's say you want to request a certain price, let's say BTC versus USD. So in your Kinglink client contract you will actually initiate a request with a job id that is specifically to that price pair that you want to request.
00:21:46.170 - 00:22:43.450, Speaker B: And then via the link token, this request will create an event in the Oracle contract. Right? This oracle contract, the event emitted by that contract will be fetched by the oracle node that it's an off chain worker. So this oracle node will then get the data from whatever API it uses and it will send another transaction back via the oracle contract through a callback function to the Chainlink client contract to write that data on chain. So it's like, let's say like a two way method, right? You send a transaction one way from the user to the oracle node and then there's another transaction from the oracle node to the user contract to write that data on chain. Currently in the model that we have implemented in a testnet, the link token payment can be set to zero. It's basically quite straightforward to use. But on the other hand, you also have the chain link price feeds.
00:22:43.450 - 00:23:29.150, Speaker B: The idea is that as a consumer you can use a contract that reads the data via a proxy in an aggregator contract. So you as a consumer do only read only operations. So you don't have to send a transaction to fetch that data from the aggregator contract. And this difference is quite important, as we'll see. I have another demo prepared where we will see this difference quite clearly. The oracle node, once again, that it's off chain, will send a transaction to write the data into this aggregator contract. In our case, we have configured this oracle node so that the price is checked every minute from the API and it's only updated on chain every hour or if the deviation is greater than 1%.
00:23:29.150 - 00:24:21.440, Speaker B: So they're like whatever comes first, right? And we prepared a D app example just to show you guys like a sample dapp of using chainlink oracles on Moonbase Alpha, our testnet, and I just called it Moonlink dashboard. So it's a very simple dashboard, nothing fancy that, to interact with Chainlink using our testnet, we have both Chainlink models. So the basic request model and the price feeds are included. And you can actually access it via this link down here that you can see on the slides. And we do have a repo with all the content of the presentation as well as the code of this Moonlink dashboard, as you can see here in this link. And I'll actually show you in a bit. So I guess, yeah, actually we're ready and let's go ahead and start with the live demo.
00:24:21.440 - 00:24:54.310, Speaker B: Before we do that, I want to show you guys this. Oh, that's actually a question. I understand that you're emulating the EVM on the parachain, but how you do interact with the actual ERC 20 protocol without incurring the expensive gas fees. All right, this is a good question. So basically you have to think that the ERC is a token contract, right? So it's a contract that will live on moonbeam. So at a gas level. So gas is a unit to pay for EVM execution.
00:24:54.310 - 00:25:48.934, Speaker B: Right? So currently, the model that we have implemented in moonbeam, at a gas level, it will be the same gas consumption to interact with an ERC token contract on moonbeam, that on Ethereum, what is different, and this is an important difference, is how much you pay for each gas unit. And that's the current problem that we see on Ethereum right now. So when gas prices are really high, it's basically how much you're paying. In Ethereum, the most famous unit to talk about gas prices is way, but like g way. So how much weigh are you paying for every gas unit that you consume? Right? So like I mentioned before, at a gas consumption level, it will be the same. What? It will be different is how much you pay for each gas unit. So currently in our tested, we do have a block gas limit of 15 million gas.
00:25:48.934 - 00:26:19.734, Speaker B: All right, just as a comparison, an Ethereum mainet right now has around 12,000,012.5 million, I think, per block. So we're talking about that we actually have a higher gas limit per block and we have further optimizations to do that can increase this gas limit per block that this is per block. Right. And we do expect to have a lower block time than an Ethereum. So we expect to target a six second block time. So this means there are two factors to account.
00:26:19.734 - 00:26:58.210, Speaker B: We'll have a higher block gas per block. Gas limit per block, sorry. And also a smaller block time. So we expect that this will make a fee structure model that is much lower than current Ethereum. Hopefully that answers your question. So in this repository that I showed on the link, basically what we have done is that if you go into this moombeam presentations repo, we've created a branch for every presentation that we have done. I think not all of them are there, but in this case you can go into the Chainlink hackathon and in here you'll find all the materials that will run through today.
00:26:58.210 - 00:27:57.730, Speaker B: Right? And you can see here you have the moonlink, Oracle's code of the dashboard, I'll show you in a minute. And also you have the slides, the presentation, I'll put the video recording of this presentation as well, the changling workshop, the Moon Builders workshop and the dashboard as well. So yeah, to get started on moonbeam, I think the easiest way is just to first visit our documentation site. So if you go to our website, which is Moonbeam network, and you click here on this docs link, it will take you to our documentation site. And in here you will find a lot of tutorials, a lot of integrations we have worked on. Like for example, you can go to integrations Oracles and then chain link, or you have the different eth libraries that we've worked and make sure that they work with Moonbeam with different examples as well. So in our case, what we need to do is click on getting started and you have local node and testnet.
00:27:57.730 - 00:28:30.960, Speaker B: In our case, let's go for the testnet. And in here you have three options. You can check the connect HTTP endpoint and the websocket endpoint. You can also check it's a tutorial on how you can get tokens from our faucet. And it's just like tutorials with pictures of how you can go to our Discord channel and we have a bot there that you can request tokens by sending this command. And last but not least, how you can connect with Metamask to our testnet. So let's actually do this right now.
00:28:30.960 - 00:29:05.894, Speaker B: So I do have Metamask here in my browser. And to connect to the testnet, what you can do is go in the top right corner, click on settings networks and then add network. And in here you'll need to fill in this information. And as you can see this information, it is available on the tutorial. All right, once you're done with this and you click on save, you actually will just connect Metamask to Moonbase Alpha, as you can see here on my screen. And I do have Alice as my account, and Alice has 49.95 dev tokens.
00:29:05.894 - 00:30:11.840, Speaker B: And actually if you remember the docker node that I was running before, you can see that this is running an instant seal because there's no blocks being produced right now. So I can go ahead and run once again the configure metamask to connect to my local node by providing the default HTP endpoint at port 9933. If you do that and you connect to it, you can see that I have metamask connected to my standalone node. It's pretty straightforward. And I can go ahead and import this dev account, which holds a lot of funds available in a local node, and I can go ahead and send a transaction. So before I do that, one thing that might happen often when you're developing is that metamask might have a different nons than the actual one that you're currently running on the network. If you want metamask to fetch fresh data from your account from on chain, you can go ahead and click on settings advance and then reset account.
00:30:11.840 - 00:30:47.900, Speaker B: So that way we're sure that Metamask will fetch latest nons and everything on chain. So I can go ahead and now transfer tokens in my local node. So let's go ahead and transfer from the dev account to Alice and let's put 1000 dev. I'll just click on this and I should be able to see this pretty right away. And I'll pop up my terminal and you can see that I have one block now because I send a transaction. So this is the power of instance like super fast for development. And it's like you don't have to wait for any transaction time or anything.
00:30:47.900 - 00:31:52.138, Speaker B: All right, so now that we're on the local node, let's go ahead and go to remix. And this is another tool that it's quite used by developers to test stuff out on the go, because remix is like a web interface that has a solidity compiler and a deployer as well. And just to show you guys that I created this hello world contract, which is super simple, it just stores this hello world word or string into this text variable. And if you go to the compiler and make sure you compile this, then I can go to the deployer and run transactions and make sure that I'm in the injected web three environment. And what this does is that Metamask will inject its provider to remix and will use metamask as a signer so I can go ahead and deploy this hello world contract. When I click deploy, Metamask will pop up as it would regularly on Ethereum chain. And I can just confirm this transaction once again because we're an instant seal, this is instantaneous.
00:31:52.138 - 00:32:37.440, Speaker B: And we can see we have, oh, actually I had an old instance here. You can see that I have my hello world contract and I can click on text and get my hello world string. So super fast, super straightforward. If I would have shown you this before I started the presentation, you might have thought that this is like an Ethereum node, right? All right, so with this first two very simple demos, I think we can go ahead and go to this that I have here prepared. We're going to go through a very brief demo on truffle and a very brief demo on hardhead, because those are very loved tools to deploy smart contracts and all. So what I've prepared is I do have a node running in this machine. This is a different machine than the terminal that I showed you before.
00:32:37.440 - 00:33:42.100, Speaker B: And what I do have prepared for you guys is the truffle config file that has, well, it has my infuria API key, it has my private key that the one that I use for demos. And I do have he wallet provider, as you can see here, I've defined a moonbase network and also a rinky b network just to show you guys how easy it is to change from one provider to the other. What we're going to deploy is an ERC 20 token contract. And I've named this Moonlink and the ticker is Moon L. And if we see the, actually, by the way, we're using open seplant ERC 20 token contract. And if we see the deploy the migration script, you can see here that I'm just deploying the ERC 20 token and this is actually 1000 tokens just in way, right? So I can go ahead and go into my truffle folder and I'll just run truffle migrate network and let's do rinky first. So let's just do ranky first.
00:33:42.100 - 00:34:24.730, Speaker B: I'd already compiled this contract, so this is not that important. As you can see, it will do a dry runner, a simulation first, and now it's actually doing the deployment on Rinkib. We do have to wait for a couple of seconds until this is included in a block. By the way, I'm using Alice's private key and I did have some Rinkabee eth on Alice's account. So as you can see, I have my ERC 20 token contract, as you would expect. But what if I just go ahead and instead of putting rinkab, I'll just put Moonbase. And it's just that simple.
00:34:24.730 - 00:35:15.060, Speaker B: Honestly, it's just one word and we have a bunch of partners, like I mentioned before, and we had great feedback, just like what Patrick mentioned at the beginning. It's like it's super simple to interact with Moonbeam and this is the experience we want developers to have. Right? So for us that's very important. As you can see right now, I'm deploying to Moonbase Alpha and what I'll do now is connect my metamask to Moonbase Alpha and I can go ahead and grab this contract address here and go to metamask and add it. Oh, I click in add token and then custom token and add the address here. And you can see Alice is the proud owner of a thousand moonlink. Well, Moon l tokens, right? And it is just that simple.
00:35:15.060 - 00:35:45.412, Speaker B: That's how easy it is to change from one provider to the other. The next example that I prepared, I don't think there's any questions yet. You're right. The next example I prepared is for the hard hat deployment. So if you're not familiar with hardhead, it's just another deployment tool. So I just basically define a hardhead config file. As you can see here, I'm going to use ethercs to deploy the contracts and everything.
00:35:45.412 - 00:36:12.540, Speaker B: I do have my Rinkibi API and my private key and I have defined different networks. Now I have Rinkib, I have Moonbase, and I have the standalone node that I'm running in this machine. As you can see, this is not the default port, but this is a different port. All right? And the contract that we're going to deploy is an NFT contract. So an ERC 721. So I think the NFT world is pretty crazy right now. So I thought it was cool to show this NFT contract.
00:36:12.540 - 00:36:59.704, Speaker B: So this is a simple ERC 721 from open sepling I've included the UrI storage module. So basically in the constructor we're defining the Moonlink NFT token ML NFT as a ticker. And then I've added the mint NFT function. What this is going to do, you can provide the Token URi and then it's going to mint the token and then it's going to be, basically the message sender is going to be the owner of that token and then it's going to set the Token Uri to the one that we provide as a string. If you go to the scripts, we have two scripts. One, it's going to deploy the contract and it's going to mint one token for you guys. So basically I do get a lot of stuff for like console logging purposes.
00:36:59.704 - 00:37:49.208, Speaker B: But you can see here that I got the designer so I can console log its address and then I fetch the contract file and then I create an instance and I call the deploy method. And then I just wait until the contract is deployed and once it is deployed we can print the address on the terminal just to see it. To mint the token, I first define the Uri as you can see here on line 18. And then I just use the mint function that I showed you before passing in the string, which in this case is NFT chain link hackathon and movement 2021. And then we'll just wait until that transaction is included and print some stuff on the terminal. It's super simple. The mint function, as you would expect, is basically the same as the mint function in the other deployment script, but it's just only minting.
00:37:49.208 - 00:38:26.010, Speaker B: We'll provide a contract address and we'll just mint a bunch of tokens so you guys can check that out. So I do have my local node running. So let's go ahead and mint and deploy our ERC 721 token contract in the standalone node first. So I'll do NPX hard hat run and then s network, oops, standalone and then scripts deploy mint NFt. Like I mentioned before, this is using instant seal, so it should be pretty fast. And I got already my contract address. So what I'll do is that I'll copy this, I already copied it and paste it here.
00:38:26.010 - 00:39:09.780, Speaker B: And I do have one token minted already. Right. But let's go ahead and in Metamask I'll connect to this local node, the one that I'm running on that machine, and I'll add this contract and as you can see I have one token, one NfT minted here in my balance. What I can do now is because I have instance seal, I can get crazy and mint, and mint a bunch of tokens, right? I can mint one, another one, another one. We can just keep going. I can do a loop even and just mint a bunch. And I wanted to show you guys how fast it is to interact with a standalone node and instance seal.
00:39:09.780 - 00:39:59.040, Speaker B: And as you can see, I think Metamask has not updated the whole bit, but I have now four moonlink NFTs tokens minted in our local node. So as you would expect, if I can run the deployment script but changing the network, I'm not going to do rinkabee. I'll just go ahead and do roombase. And yeah, you can see that this will use the same account, this is Alice's account to deploy the NFT, and it's going to first deploy the contract and then it's going to run the function to mint the token contract. And as you would expect, this is not using instance seal because it's a test set. So it usually takes a while to deploy the token contract. There are no pending questions.
00:39:59.040 - 00:40:44.942, Speaker B: Currently we're working with, this is the first testnet version that we've done. We have multiple external collaters and this is a great test for us. But we have seen that sometimes there is a little bit of lag with the transactions. We do have a new version coming up, I think next Friday that will fix a lot of this lagging. Sometimes you have transactions that they take 20 seconds or so to be included. This should get a lot better once we release the next version next Friday. So I do have the token contract now, and while it's minted, I can go ahead and connect metamask to Moonbase Alpha and I can add this token here and hopefully it is minted already.
00:40:44.942 - 00:41:37.370, Speaker B: As you can see, Alice has one ML NFT. And yeah, I mean, as you probably noticed, this might sound familiar to you guys if you're already familiar with Ethereum world. It's just basically pointing it to a different provider that is moonbase alpha or testnet, and it's just that easy to get started. So yeah, the last demo that I have for you, I'm actually super excited to show you guys. This is the Moonlink dashboard that we prepared for this demo. And this is like I mentioned, you can see the source code of this dashboard in the repo that I shared. Don't judge the code because I'm like the furthest expert from react and react that you probably know, but it's just to show you a cool interactive way of interacting with the Chainlink oracles that are launched on Moonbase Alpha testnet.
00:41:37.370 - 00:42:29.120, Speaker B: So the first thing you would notice is this table at the top, this is all the information regarding data price feeds. And like I mentioned to you, this is actually read only operations. So I can actually go ahead and go to an incognito window where I don't have metamask and I can load this dashboard. And even though I won't be able to connect metamask or send a transaction down here, this will show me the information that is available on the contracts, as you can see. So this is the bitcoin USC price, this is the price that is stored right now on the contract, and this is the last time that it was updated. So actually, if we're lucky, because almost 1 hour has passed, we will see this price change to 1548 or whatever when an hour has passed. Exactly.
00:42:29.120 - 00:43:03.354, Speaker B: All right, so in the dashboard what you can do is connect Metamask. Make sure that metamask is connected. And down here you have the basic request model. So I modified the contract a little bit so that it worked better with this interface because I wanted to have this information of the last updated and the job id. But as you can see here, the last transaction that it was done was to fetch the ETh USD price. So let's go ahead and get the BTC USD price. Before I do this, let's go back a little bit and think what we've just done.
00:43:03.354 - 00:43:41.286, Speaker B: Right? So Metamask has a nons for Alice and we'd use Alice's account on truffle and hardhat. So actually the nons increased. So what I have to do is go into, before I send this, I know that this is going to happen already, so I'll go into settings advance reset account. Always remember to do that. If you do have like a transaction that it's pending for a very long time, it's a gotcha. That always gets me. So once I've done that, I can go ahead and copy this job id and I can submit this transaction and you can see that metamask asked me to sign this.
00:43:41.286 - 00:44:22.034, Speaker B: And I'll just basically, you know, I've added a bunch of safety features that if you try to. Well, actually I have to wait until this transaction goes through. But because this is public, basically, if there is an ongoing petition, you won't be able to request for another one. Right, because anyone can just come here and bombard this with petitions. So the idea is that there's some safety features, like if you cannot put a number here or if there's already a transaction pending, you should not be able to send another request for another token price. I did not hear metamask. Oh yeah.
00:44:22.034 - 00:44:54.602, Speaker B: Okay, so I think it was already sent. So while we wait, let's go ahead and go up and see. You can see here that the bitcoin price was updated right after 1 hour of the last price. It was available on the dashboard. And while we wait for this price to update, I can show you a little bit of this code that it's on the repo that I shared. This is the Moonlink oracles. There is a brief readme of how you can clone this and get it running locally.
00:44:54.602 - 00:45:44.442, Speaker B: But basically the idea is that if you go to the Ethereum folders and web three, you will see that if Metamask is detected, it will use metamask as a provider, but if not, it'll just use the public HTP endpoint that we have. And that is why when you go into the website and it doesn't detect metamask, it's still able to read the information of the data feed and show it to you. So if we're lucky enough, yeah, we are. You can see here that we have the bitcoin price and it was updated at 1540 912. And this is the job id for that specific price feed. And yeah, like I mentioned, you can find the source code here. You can play around with this, build your own dashboard and modify it as you seem fit.
00:45:44.442 - 00:46:31.450, Speaker B: But I thought it was a cool demo to show like real on chain price data that is stored on the testnet in a nice looking, well, more or less nice looking interface. All right, so just before I let you go, I finish with the presentation. Let's say that, yeah, everything sounds great. Where can I learn more? Basically, you can go into our one stop shop that I showed you, which is our documentation site. In there we have a lot of tutorials regarding metamask remix, truffle and hard hat Ethereum libraries oracles. We do have a bridge that is running between Rinkib and coven and our testnet, our Moonbase alpha testnet, and we have a lot more information in there. Feel free to check them out and contact us via discord if you have any questions.
00:46:31.450 - 00:47:17.482, Speaker B: We also started a moon Builders workshop that it's a workshop that is going to run once a month. And in here we left the link to our first workshop that is similar to getting started with moonbeam just in case you need any extra information. So in terms of the Chainlink Hackathon challenge, we want you guys to use Chainlink on Boombeam, the idea is to build a D op that uses Chainlink oracles. In our testnet you can find more information regarding Chainlink. Like I mentioned in our website, we ask projects that must not be forked so only original's ideas will be the one that we'll check out. And we want this as a requirement as well. So we want you guys to document your experience.
00:47:17.482 - 00:47:55.590, Speaker B: How easy was it? Did you hit any roadblocks? And how we can improve for us, it's really important to provide the most frictionless environment for developers. So we were really eager to learn of how we can improve your experience to onboard on Moonbase Alpha or Moomim in general. And with that, yeah, how you can get in touch with us with the Moomim team, you can visit our website which is Moomium network. You can follow us on Twitter. We do have some GitHub that we're very active, some GitHub repos that we're very active. We're also active on Reddit, visit our Docs website. We have a telegram and Discord channel and also a YouTube.
00:47:55.590 - 00:48:16.890, Speaker B: If you have any questions regarding development or you're a developer and have any inquiries, you can visit our Discord channel. We're very active there and we're always open to hear your problems and give you the best help possible. So I hope to see you guys there and yeah, thanks a lot for listening to this presentation.
00:48:20.810 - 00:48:27.226, Speaker A: Awesome. Well, thank you so much for jumping on and thanks everyone for viewing and look forward to see everybody in the discord.
00:48:27.418 - 00:48:29.370, Speaker B: All right, thanks guys. Have a great afternoon.
