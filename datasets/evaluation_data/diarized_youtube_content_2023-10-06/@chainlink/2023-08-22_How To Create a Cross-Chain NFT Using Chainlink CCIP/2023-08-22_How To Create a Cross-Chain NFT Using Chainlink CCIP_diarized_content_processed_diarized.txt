00:00:00.170 - 00:00:31.746, Speaker A: Hey there. I'm Richard, one of the developer advocates here at Chainlink Labs. And today we're going to take a look at Chainlink cross chain interoperability protocol, or CCIP. And we'll learn how to mint an NFT from one chain to another. So let's dive in. If we take a look at this code here for CCIP cross NFT, we have an example that uses hard hat to do all of this. Now we're going to be doing this with remix.
00:00:31.746 - 00:01:23.638, Speaker A: I'll show you how to kind of port things over. It should be pretty straightforward. I didn't want to go through any complexities of dealing with hard hat in this tutorial, so I just wanted to keep everything as basic as possible and do them in remix. Why would we want to mint an NFT on one chain and have it show up on another? Well, in this example, we'll be minting from Sepolia onto the avalanche Fuji test network. And what if we had funds on Sepolia but we didn't have any funds on Fuji? This would allow us to do that process of minting an NFT on Fuji without actually transferring our funds over and then minting the NFT. And then if we had extra funds left, maybe we want to transfer them back, right? So that's one use case could be very useful for your project. How does Chainlink CCIP actually work? Well, to keep things very basic and simple, we have in the repository a diagram that kind of talks you through this.
00:01:23.638 - 00:01:58.382, Speaker A: Basically, the end user will interact with the DAP. From there, that Dap talks to the CCIP router. You can think of CCIP as a black box if you want. We have more information in our documentation. If you want to know how CCIP actually works behind the scenes, really what you need to know is it's a secure way of transferring tokens and data from one chain to another on the destination chain. Then the router interacts with your contract there and passes that information, those tokens along on the source chain. We talk to the router, the router talks to CCIP on the destination chain.
00:01:58.382 - 00:02:35.674, Speaker A: Another router reaches out to your contract and does the work for you there. That's the gist of how this works. We have in this documentation instructions for how to actually use it. If you wanted to use hardhat, you are more than welcome to use the documentation on GitHub and follow along with hard hat. I'm going to be taking some of the contracts out of this documentation and putting them in remix like I mentioned. So what are these contracts that we're going to be looking at? Well, if we head back to the top we have our contracts folder here and from this contracts folder we have four contracts that we're actually interested in. You may only see three right here, but there's one more hidden under utils that we'll need.
00:02:35.674 - 00:03:07.890, Speaker A: The first one I'm going to look at. I'm just going to follow the flow of the actual process itself. Right, so we're going to start at the source, then we'll go to the destination, then we'll go to the actual NFT itself. So we'll start with source Minter. We'll copy all of this information and we'll put it into remix. Before I get started there though, I want to take a moment to pause and say probably the most complicated part of dealing with CCIP is keeping track of what network you're actually on. I'm using one browser to do all of this, so you'll see me switching back and forth between networks.
00:03:07.890 - 00:03:30.378, Speaker A: And honestly that's the hardest part when it comes to CCIP is keeping track of that network. So we'll take this code here and we'll put it into remix. I've already gone through the copy and paste so we have here a new remix project set up. It was an empty project. I've copied my source minter. I've pasted it in here. There's one thing that you may note, it's this import withdraw from utils withdraw.
00:03:30.378 - 00:03:54.278, Speaker A: So we'll need that file as well. We'll need to create a utils folder. We can do that with new folder right here and within that we'll create a new file called Withdraw Sol. Inside withdraw we'll use the utils withdraw code that is here. This will enable us to withdraw funds from our sender contract when we finish things up. So back to remix and we'll take a look here. So we have our source minter Sol.
00:03:54.278 - 00:04:19.950, Speaker A: It's going to import a few things. It's going to import the link token interface, CCIP router and a client for CCIP as well. Now we're importing the link token interface because you can pay with either link or native tokens on the blockchain that you're using. So if you wanted to use the link option you absolutely could do that. In this example we're going to be going through using the native token though. But this contract is set up to use either one and then we would import our withdraw function. So let's take a look at that first.
00:04:19.950 - 00:04:56.474, Speaker A: So this withdraw function, it's basic contract that lets you withdraw if you're the owner of this contract and you can see here we have an error, we can't withdraw. We then take a look at the actual function itself. We're withdrawing and we will withdraw it to the beneficiary address. I'm assuming that's probably going to be your address, but you could send the remains to whoever you wanted. We get the amount that the address has and then we attempt to actually withdraw that amount. If something fails, we go ahead and revert with that error message above. And then we have our withdraw token which will allow us to withdraw specific tokens in this case.
00:04:56.474 - 00:05:20.530, Speaker A: That would be for the link that you funded this contract with, if you did that as well. All right, so let's take a look at source minter. It's a fairly basic contract. We have our contract here, source Minter. We have an enum pay in fees in and we can either use native or link. One thing to note, when we're actually using this in our deployed contract, that enum, we're going to reference those with zero or one. So zero will be native and one will be link.
00:05:20.530 - 00:05:44.506, Speaker A: It's what you want to pay in when you're actually doing the transaction. We then set a couple of addresses, one for the router and one for the link token address. We go ahead and set up those variables, we'll use them in our constructor. We have an event for when the message is sent in our constructor. You can see here that we take in the router and the link token address. Now the router is going to be the address of the actual router for your specific chain. We'll see that in the documentation where to find that information.
00:05:44.506 - 00:06:20.040, Speaker A: Once we go to deploy this contract, we also set up our link token interface and approve the router to spin tokens for us. We have a receive fallback and we have our mint function here. This mint function is what will actually allow us to mint an NFT cross chain. So our mint function takes the destination chain selector. That's going to be a value that lets us know what the chain ID is that we're going to. We have our receiver address, that'll be the address of the receiver on the destination chain. In this case, it's going to be the contract that we deploy on the destination chain to receive this information.
00:06:20.040 - 00:06:50.606, Speaker A: We have our pay fees in value. And again, this is going to be whether it's native zero or link one. Once we have that, we go ahead and create a message that will be sent to CCIP. So it has the receiver, it has the data. What is data? It's going to be the actual message that's passed across chains. In this case it's going to be a mint address and a message sender. So this will actually mint to the.
00:06:50.628 - 00:06:53.486, Speaker B: Address that you pass in, which will.
00:06:53.508 - 00:07:13.042, Speaker A: Be the message sender. So mint a token to whoever sends this message. Then we have the token amounts that we're passing along. Any extra args. In this case we're hard coding that to nothing. And then the fee token here, which depending on what we passed in, will either be link or the native token. We'll retrieve the fee that's required for this cross chain communication.
00:07:13.042 - 00:07:41.898, Speaker A: So we'll get what the fee is. In order to send it across. We create our message ID and then if we are paying in link, we pass one message. Otherwise we send our message along with the value of the fee included. And once this is all done, we'll emit an event that our message was sent. So it's pretty straightforward, right? We are creating a message and then we'll be sending it to the router address. The router will then go to CCIP and pass that information to the other chain.
00:07:41.898 - 00:08:03.158, Speaker A: So let's go ahead and actually get this deployed. So I'll be deploying the first contract on Sepolia. You can pick whatever contract you want and you'll see how easy that is to do here in just a minute. The first thing I need to do is I need to make sure that I am on Sepolia. All right, so I'm on Sepolia. So I'll go to the deploy tab. You'll notice I've already got this compiled because I have auto compiled turned on.
00:08:03.324 - 00:08:06.646, Speaker B: And I'll need to make sure that.
00:08:06.668 - 00:08:23.790, Speaker A: I'm deploying the correct thing. So I want to deploy source minter. And you'll notice I need to pass in the router address and link token address. So where do I find this information? If I head to docs chain link and go to CCIP.
00:08:25.490 - 00:08:26.078, Speaker B: We can look.
00:08:26.084 - 00:08:58.356, Speaker A: At supported networks and I'm doing this on Sepolia. So I'll go to Ethereum, Sepolia, we have our router address here and then we have our link token address right below. So I'll click on the copy button, I'll get the router address, I'll head back to remix, I'll put the router address in there. Then I'll get that link token address, put it in here and that's all I need to do. So I'll click the transact button and confirm the transaction. And just like that, our contract has been deployed. So that's all we need to do.
00:08:58.356 - 00:09:31.564, Speaker A: On Sepolio, we're ready to go. We've got our source minter set up. Now we're going to switch over to another window, just to help me keep track of everything, I suggest you do something similar and we'll deploy the destination minter and NFT contracts there. So we'll head back to remix and you can see I've done the same thing. I've copied over two different solidity contracts. Where did I get them? If we look here in our cross chain nfts repo under contracts, I've just copied the code straight over for destination mentor and Mynft. So on the source chain we need two contracts.
00:09:31.564 - 00:09:55.060, Speaker A: We need source mentor and the withdrawal contract. On the destination chain, we also need two contracts. We need the destination mentor and my NFT. So I've gone ahead and just copied those straight out of this repository, pasted them into remix. The first thing to look at here is destination Minter. So again, we're importing in some CCIP contracts the receiver and the client. We're also importing in our NFT.
00:09:55.220 - 00:09:56.088, Speaker B: So let's take a look at this.
00:09:56.094 - 00:10:15.020, Speaker A: NFT and see what it looks like. It's pretty basic. We have ERC 721, it's ownable. And then we've got our contract, my NFT. We store everything for the Uri and IPFs. If you're interested, you can take a look at it there. It's basically for a medieval version of Babe Ruth in his rookie years.
00:10:15.020 - 00:10:34.132, Speaker A: We've got our token ID, as you would expect on an NFT. Our constructor just sets up the basics of the NFT, giving it a name and a symbol. And then we go ahead and create a mint function which safe mints a token to the address that's passed in and sets the URI and then increments the token ID.
00:10:34.266 - 00:10:34.852, Speaker B: That's it.
00:10:34.906 - 00:11:06.376, Speaker A: It's pretty straightforward, right. It's a pretty basic NFT, but I think it helps kind of get the point across about what's happening with CCIP in the destination minter. What happens here? Well, we've got our imports, like we mentioned, and then we have our destination mentor contract, which is a CCIP receiver. We declare an instance of the myft contract. We set up an event for the mint call successful. We have our constructor where we set up the NFT is equal to my NFT and we pass in an address. So first we're going to deploy the Mynft contract.
00:11:06.376 - 00:11:36.548, Speaker A: Then when we deploy this destination mentor, we'll give it the NFT contract's address and then we have our CCIP receive function. This is going to be receiving that message in from the router. So what exactly does it do? Well, it takes the NFT address that we passed in before and passes along the message data which will cause it to mint an NFT. Then it will mint the success. If everything was successful, it's pretty straightforward. It's just receiving that message and doing a little bit of stuff with it. In this case, just passing along to the NFT contract.
00:11:36.548 - 00:12:07.728, Speaker A: Now one thing to know, when we deploy mynft we'll have the option to transfer owner. When you deploy it, you'll be the owner and only the owner is allowed to mint NFTs. Well the destination mentor contract needs to mint the NFTs. So we'll need to transfer ownership once we've deployed destination mentor to our mentor contract. So let's go ahead and do both of those. Now the first thing that we'll need to do is we will need to change our network. Remember I said this is probably the hardest part is remembering to change your network.
00:12:07.728 - 00:12:15.780, Speaker A: So I'll change it to avalanche Fuji. I'll change the injected provider here and first I need to deploy my NFT.
00:12:18.440 - 00:12:20.020, Speaker B: We'll get that deployed.
00:12:21.900 - 00:12:38.110, Speaker A: Confirm this transaction. Once that's deployed I'll be deploying the destination minter. So again we'll need the router and we are on Fuji. So we'll go back to the documentation here. Avalanche Fuji. We'll need the router address here.
00:12:41.600 - 00:12:41.916, Speaker B: And.
00:12:41.938 - 00:12:57.564, Speaker A: Then we need the NFT address. So my NFT is deployed. Now I'll copy the address for that, add it here and so we'll deploy our destination mentor on Fuji. Once that's done. Remember we do need to do that one last step of copying our mentor.
00:12:57.612 - 00:13:03.764, Speaker B: Address coming to our NFT contract and.
00:13:03.882 - 00:13:23.980, Speaker A: Transfer ownership to our NFT mentor contract. And at this point we should be good to go. All right, so we'll head back to Sepolia. So we'll change back to Sepolia. We'll change our wallet back to Sepolia as well.
00:13:27.460 - 00:13:31.520, Speaker B: And we will mint NFT.
00:13:31.600 - 00:13:55.736, Speaker A: So we need a few things here. We need the destination chain selector. That's going to be from the documentation. We need our receiver address and then we need to pay in and a value before we can pay though we have to fund this. This actual contract will be paying for the CCIP call. So we need to send it some funds. So we'll go to Metamask, go to send, paste in the address of this contract which I just copied.
00:13:55.736 - 00:14:15.520, Speaker A: We can send it something like zero, one ETH. That should be plenty for this transaction. We'll confirm that and we'll wait for this to be completed. All right, so that has been completed. Now let's go and get our destination chain selector. So our destination chain is going to be avalanche Fuji. So we'll copy our chain selector.
00:14:15.520 - 00:14:23.248, Speaker A: Paste that in here. Our receiver address will be the destination minter.
00:14:23.344 - 00:14:27.536, Speaker B: So we'll copy that address here, paste.
00:14:27.568 - 00:14:36.890, Speaker A: It in there, and we'll pay in. And remember our enum here at the top we have native and we have link. We want to pay in native, which would be the first instance would be zero.
00:14:38.460 - 00:14:42.852, Speaker B: We'll click transact and confirm our transaction.
00:14:42.916 - 00:15:12.100, Speaker A: How do we see this in CCIp? If we open up this debug menu, we can grab the transaction hash right here. And from here we can go to CCIP chain link, and that'll take you to the CCIP explorer. Since we can actually see all of the CCIP transactions if we paste in our transaction hash right there, press return. We should see our transaction here. Yes. And so now we're waiting for finality. So we'll wait for this to be completed and I'll meet you back here.
00:15:12.100 - 00:15:29.636, Speaker A: All right, so we can see now that our transaction has been successful, how can we actually see our NFT though? Well, there's a couple of ways to do this. If you just head to testnets openc IO and connect your wallet, you should be able to go to your wallet's.
00:15:29.668 - 00:15:33.196, Speaker B: Profile and from there you should be.
00:15:33.218 - 00:15:49.020, Speaker A: Able to see your NFT. So here's that rookie medieval Babe Ruth that I was talking about. We can see it's actually on the avalanche network. And we minted this NFT on Sepolia effectively.
00:15:49.180 - 00:15:49.648, Speaker B: Right?
00:15:49.734 - 00:16:20.390, Speaker A: So we did a transaction on Sepolia. From there, we actually were able to mint an NFT on avalanche. Now, I think that's huge. I think it's massively powerful to be able to do a transaction on one network and end up with results on another. So from here, you could use this tutorial to build your own cross chain NFT or whatever product you want to bring to the blockchain environment. I appreciate you watching this tutorial. I can't wait to see what you build and I'll catch you in the next one.
