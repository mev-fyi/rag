00:00:02.840 - 00:00:03.390, Speaker A: You.
00:00:05.280 - 00:00:24.056, Speaker B: All right? We are live. Hey, guys. Excited to be here. I'm Ganesh Swami. I'm one of the founders of Covalent. Covalent is an indexing and query protocol for Web three. And I'm going to let my colleague harish share the rest of the presentation.
00:00:24.056 - 00:01:13.420, Speaker B: But I want to kick this off with a little story about Covalent and how we got here. So today, Covalent indexes about 32 blockchains. And the magic of our indexing solution is the unified API, which means the same API works across all 32 blockchains. So you go integrate with, let's say, ethereum, and then you want to pull data from polygon or avalanche or any of the other 232 blockchains. It's literally just a single character change and everything just works as is. So this protocol or this middleware has about 25,000 devs today, thousands of applications across all kinds of use cases. So if you look at the wallet use case, everything from Rainbow wallet to XDFI use covalent.
00:01:13.420 - 00:01:35.512, Speaker B: We're big in the taxation space, we're big in the NFT space. So we have best in class in some of the use cases. That is very relevant in the web3 space today. But the journey here hasn't been a smooth line. It hasn't been straightforward. So we are one of the older protocols out there. We've been around for a very long time.
00:01:35.512 - 00:02:16.928, Speaker B: We've been around for four and a half years. And the bulk of covalent was actually built through the bear market. So a little bit of a flashback, a little bit of a story here. So I built covalent at a hackathon, not very different from the hackathon that you guys are participating in, and ended up winning that hackathon. And that point, there was no nfts, there were ERC, 20 assets. But it was very early. But I realized that there needs to be a way for these blockchain based systems to interact with other kinds of traditional tech stack.
00:02:16.928 - 00:03:09.744, Speaker B: And so if you understand how technology is adopted in industry and society, it always somehow takes the cheapest and the fastest way to adoption. What that means is that if you don't have to retrain or relearn tools or even change your tooling or even change your processes, that's the quickest way to adopt any kind of technology. So here, the underlying story was that by exposing regular web two style rest API, what we can do is we can have blockchain technologies reach a faster adoption cycle. So that's really what is going on. So we built this in 2017 right. I think it was November 2017, started the company covalent. The word covalent comes from covalent bonds in chemistry.
00:03:09.744 - 00:03:37.516, Speaker B: So I used to be a physicist before building cancer drugs. And so here we are, bonding databases and blockchains, or centralized systems and decentralized systems, whatever you want to think about it, that's the analogy. Even our logo are these two orbitals that go around an electron. So you can think of it. We just try to have a little bit of fun here. And so we started this in 2017, and lots of excitement there. This was the peak of the ICO stuff.
00:03:37.516 - 00:04:09.940, Speaker B: And then by 2018, I think things were starting to slow down. By summer 2018, things had come to a complete standstill. By late 2018, things were, like, dead. 2019 was again dead. But what we did is we just continued building the core infrastructure. The middleware just started fine tuning all of the bits and waiting for this payday, which would eventually come. Of course, it was just the conviction that we had that this tool was necessary.
00:04:09.940 - 00:05:15.820, Speaker B: We didn't really have any timing. So if you want to start a company, don't take my advice on market timing, because I have the worst record in starting companies don't start right before a bear market because it's going to be pretty painful. Or if you have the conviction, start in a bear market, because the best technology, including chain link, was built during a bear market. So then in 2019, the DFI summer hit, and from then on, our traction has just been through the roof. So we were right time, right product, right team, and then we've just grown to a team of about 60 people now, thousands of applications and 25,000 plus developers. So what this story is meant to share is that market timing doesn't really matter. As long as you have the faith and the conviction in the solution you're trying to solve, and as long as you've done your due diligence and on this problem is actually a genuine problem and is not something that is fadish, then you are going to succeed.
00:05:15.820 - 00:05:41.220, Speaker B: So, 2019, we started out, and then around early 2020, that was our second crisis moment. So we said we started to get some early traction. Pretty exciting. Let's go raise some fundraising. So until then, the company was completely bootstrapped. Right? Not because we wanted to bootstrap it, it's just that nobody was really writing checks. So we had no choice but to bootstrap the company.
00:05:41.220 - 00:06:10.160, Speaker B: And we had missed the ICO boom as well. So 2020, we go out and try to raise capital, and then COVID hit and the pandemic hit, and lockdown. There was a bitcoin, dropped by 40% in one day. It was just a mess. And so at this point, we realized, okay, we've been spending what we spent almost two and a half years on Covalent, and we had nothing to show for it. No customers, no traction, no revenue. But what we had was a cool technology.
00:06:10.160 - 00:06:29.332, Speaker B: We had a pretty solid team. The team was very thin. It was only three people. And what do we do now? And so I decided maybe the best way to make covalent succeed is to go out and try to make money. So let's make money. Let's float the company. Let's figure out who are these right customers.
00:06:29.332 - 00:07:04.400, Speaker B: And then what we did is we started going out and closing customers. So we closed consensus. Their security, token exchange, token distribution system was all built on Covalent. And then we made the company profitable. And then 2020, once we became profitable, suddenly everything was easier, right? We didn't need money. And the best time to raise money is when you don't need it. And then we went out and did our first round, a second round, a third round, and a fourth round, all within a year, and then aggressively deployed the funds to grow the product and the traction.
00:07:04.400 - 00:07:38.696, Speaker B: So that's really the story of Covalent. Now, I'll just go through a bunch of questions. There's a pretty exciting presentation that Harish has put together, but in which year did we build Covalent? It was in 2017. That was the initial start. In 2020, we decided that we are going to convert Covalent from a centralized company to a decentralized protocol. So we have some pretty exciting news to drop tomorrow. So it's actually one of the biggest bets we've made in the history of covalent.
00:07:38.696 - 00:08:14.436, Speaker B: And Covalent is now a public good. It's a decentralized protocol, and so there's going to be a network of validators running the Covalent protocol. So it's not the core team anymore. And anyone can go in, buy the token, and run parts of the infrastructure and earn fees for providing this service, the indexing service, and the query services. Covalent is L2. Covalent is not typically a layer one or a L2. What it is, is indexing and query services, and we rely on another L2 for the settlement, for the accounting.
00:08:14.436 - 00:08:47.056, Speaker B: Right, you say, which operator has answered so many queries? Which operator has done the indexing? A good job with the indexing. So we need a L2 to settle to make those accounting decisions. And there we picked moonbeam, which is a polka dot parachain, to do the settlement. All right? So if there are no further questions, I will head it off to harish. Okay, awesome.
00:08:47.158 - 00:09:41.584, Speaker A: Thank you, Ganesh, for that intro to covalent. And yes, we've got a pretty exciting announcement taking place tomorrow at 11:00 a.m. On our Twitter spaces. So do come check that out. I'm going to spend a little bit of time talking about our API and doing a little bit of a walkthrough of the endpoints and the on chain data that we provide. And then I'm actually going to walk through how you can use Chainlink's external adapter to make a call to the covalent API and pull in all sorts of interesting on chain data into a smart contract, and you're able to actually make a call to any of our endpoints and pull in all sorts of unique data feeds into a smart contract. So this might be things like NFT collection floor prices, it could be sort of liquidity volume information for Dexes.
00:09:41.584 - 00:10:30.496, Speaker A: So I know Chainlink's got all sorts of price feeds that they support natively. And so the idea here is how can you use Chainlink and covalent to pull in maybe sort of non conventional or other unique data feeds into a smart contract and then build out the automation in your contract with that. So that's what I'm going to kind of walk you through with some code examples. So if you go to covalenthq.com slash platform, you can sign up for an API key. I'm just going to talk a little bit about how we've structured our API. So we basically run full archive nodes for every single blockchain that we index, and that includes most EVMs.
00:10:30.496 - 00:11:22.740, Speaker A: And in terms of supporting balances, we also now support Solana. And so the classification of our endpoints is broken down into sort of two main categories with a third new category on the way. So, class eight, these are our sort of bread and butter suite of endpoints. You can pull balances, transactions, NFT data across, I think, over 30 plus supported blockchains. And the request and response setup is exactly the same. The only thing you're changing is this parameter known as the chain ID, in order to pull that same data, whether it's from Ethereum or Polygon or avalanche or any supported EVM or even Solana. You just do that by changing one parameter, the class B suite of endpoints.
00:11:22.740 - 00:12:20.616, Speaker A: That was sort of our initial foray to create these protocol specific endpoints. And we found out pretty quickly that with the growth in defi and some other web3 applications that for us to do this is not exactly sustainable. So what we've done is we sort of boiled the class B endpoints down into a core set of endpoints for some of the larger protocols. And then we have a suite of endpoints around what we call our uniswap clones, or xy equals k endpoints. And so you can use, I think there's like nine or ten different endpoints there to basically build out entire Dex dashboards by using that suite of endpoints. So that's the class B. And then what we're really excited about is the idea of our community helping build out some of the API endpoints that are of value to them.
00:12:20.616 - 00:13:38.080, Speaker A: And so we're building out the tooling which will allow developers to create their own API endpoints and essentially build it a marketplace where developers get rewarded for the API endpoints that they create. There's a lot you can do with on chain data. And so we get this question a lot like what can I do using covalent? And so we'll talk through a few different examples, but if you're looking to build out anything with wallets, with taxation tools, even gaming and Gamefi is a pretty popular application to build out reports and all sorts of interesting analytics. We've got Dao dashboard, so you can track and see what DAO members are holding and how they voted. Predictive analytics is an exciting, I think, upcoming area that our API is being used for. And of course NFT marketplaces and galleries. So there's a whole host of use cases and we've actually started building out templates so that if you want to build out any of these use cases, you've got a starting point as a developer and I'll show you the resources there shortly.
00:13:38.080 - 00:14:43.028, Speaker A: We've kind of categorized our users into sort of two buckets, obviously developers, but we've also got a focus towards analysts and so being able to export data easily using our API into typical or common business intelligence or BI tools. So we have added this mode called analyst mode. So if you want to export your data in CSV format and then use that in power BI or tableau or even Excel or Google sheets, you can actually do that quite easily. So we've actually got a pretty exciting series of things coming up over the next few months. Ganesh sort of talked about as covalent progressively decentralizes. We've got staking announcement happening soon there we are focused on the community helping us build out a suite of API endpoints that are valuable for their use cases. And we've also got a more focused analyst offering that is going to be coming out soon.
00:14:43.028 - 00:15:51.400, Speaker A: So we've been busy. Now, let's talk a little bit about how covalent and Chainlink work together. And the way to think about this again, as I sort of mentioned, is being able to bring in interesting on chain data feeds into smart contracts using the Chainlink external adapter. And so the idea is building out interesting use cases where perhaps you're using the floor price or market cap of an NFT collection to have the smart contract, then make decisions. We've seen participants in other hackathons build out all sorts of interesting betting games using this particular price feed or floor price feed. You can do stuff using trading volumes and liquidity around specific dexes. We've even seen users in hackathons build out sort of decision points based on certain balances of transactions made by specific wallets and then the skies.
00:15:51.400 - 00:16:25.684, Speaker A: There's no limit really with what you can do with log events. And so the ability to pull log events across multiple chains seamlessly allows you to then create all sorts of interesting data feeds that you can basically build into your smart contract. So we'll take a look at some of these examples of how you can actually do this using both covalent and Chainlink. So I'm going to do a little bit of a demo here. We're going to start by going to.
00:16:25.882 - 00:16:26.630, Speaker B: The.
00:16:37.100 - 00:17:23.028, Speaker A: Okay, so this is our API reference. When you sign up for an API key, you get a link to the API reference and it's kind of where you get all the core documentation and the ability to actually run queries directly from the browser. And so as mentioned, we've got sort of the class A, class B categorization of our endpoints. We even have a few pricing endpoints. But first, I'll just talk about some of the overview elements for using our API. So it is currently free for developers to use as we build out our decentralized network. So until then, the API is free to use.
00:17:23.028 - 00:18:58.528, Speaker A: It does come with some built in limitations, such as roughly five requests per second per API key. We've got refresh rates of two blocks in terms of what we classify as a real time API, and batched endpoints have a delay of 30 minutes. And in terms of basically pagination, you can set the page size and by default you get 100 items per request. The reason this is actually important is in the code examples that I'm going to be walking through and using some of the default oracles for developer relations, the response size that you can actually get back and have it processed is I think set. So the way you can ensure that you're not having the Oracle try to handle a very large response load, in which case it won't actually even process it, is to set the page size, for example. So you might find that instead of using or just having the default, you might need to drop this to like ten or something even smaller in order to ensure you're not running into the built in limit there. We've got a few global settings and that kind of applies across all endpoints.
00:18:58.528 - 00:19:40.240, Speaker A: So you can set your network. We've got again over 30 supported blockchains. You can set your currency, and then as mentioned, you've got sort of these two key modes, the developer mode, in which case you get your responses in sort of a standard json format, and you've also got analyst mode, in which case you get it in CSV and tabular format. So let's take a look at some of our Class A endpoints. So we've got four different sections that we've broken out your class A to. So balances. If you need to get your token balances, we support not only the ERC 20 standard, but of course your NFTs, both 721 and 1155 standards.
00:19:40.240 - 00:20:53.370, Speaker A: You can actually just run these sample queries directly in the browser, see what the response looks like. And as mentioned, you can get this both in JSON or if you switch this to analyst mode, you can get this in tabular and you can export this as a CSV. Some of our other sort of key endpoints under balances is being able to get the token holders for any token contract. You can get that for a particular block height, or you can get the change in token holders across a range of block heights under NFT category. So you can get all the tokens associated with an NFT contract, you can get the transactions, but we've also added a couple of new endpoints which are really interesting. So being able to get the NFT market caps for each of the networks that we support. So if you wanted to get this changes back to developer mode, if you want to get all the top collections and their market cap, you can get that data with this particular global view.
00:20:53.370 - 00:22:04.752, Speaker A: You can also get historical data for NFT collection. So if you wanted to get the historical floor price or volume and be able to trend that, you can also do that by specifying the particular NFT collection that you want to get that data for. So for example, we've got the board eight yacht club and you've got your time series data as well as the images for some of the, I think the first five NFTs of that collection, and then under our base category, so you can get all your log events by a contract address. You can also get log events by a topic hash, some of the more standard and base data that you might need for your application. So moving on to class B, this is where again we sort of started by focusing on protocols and building out a suite of endpoints for them. The main one I'm going to touch upon is this XY equals K, which is a category with a suite of endpoints. And again, this is to enable you to build Dex's dashboards very quickly.
00:22:04.752 - 00:22:48.456, Speaker A: You've got all your pool data, your balances, your tokens, all of that from just a standard suite of endpoints. These are all built on Uniswap V two clones. So any Dex that is a uniswap V two clone, we can basically support it with these suite of endpoints. So I know the likes of spirit swap and others use us quite heavily to be able to power their analytics. Okay. And then just some pricing endpoints. If you want to get historical prices or spot prices you can get that using this particular set of endpoints.
00:22:48.456 - 00:23:39.236, Speaker A: So that's a quick rundown of our docs and again, encourage you to go in and try out some of the endpoints, see what kind of response you get and how it might be useful for your application. I'm going to switch over now to our knowledge base, which is just@covilinthq.com docs. And this is again a resource for our ecosystem. So you've got content for developers, you've got a full list of all our supported chains and details about each of those networks. We've also got a section here for our network. So if you're interested to learn a little bit more about the decentralized network, you can actually go through the section here and get all those interesting details.
00:23:39.236 - 00:25:11.740, Speaker A: The area I'm going to focus on here is under developer and developer tools. So we've added in some documentation on Chainlink and how you can use the Chainlink Oracle network and the covalent API to be able to pull in interesting price feeds. So Chainlink's got a pretty extensive set of documentation around how to make these get requests to an external API, and I'm basically borrowing some of the code templates that they've got and adapted them for covalent and using our API in terms of the process. So this is kind of the steps that you would go through to use an existing sort of node and job to be able to process our API response data. Of course we could set up our own node and configure it to have sort of a dedicated chainlink external adapter. In fact, that's one of the proposed challenges that the community can work on. But in general, if we're using an existing node and job ID first, just identifying what that node Oracle address is, the job ID and the fee, and also the link token contract address for the network that you're using.
00:25:11.740 - 00:26:17.840, Speaker A: So in our example we're going to be using the COVID testnet, and so we just need to make sure we're also setting the link token contract address on that particular network. You'll then copy the full covalent API URL for the request that's going to be made by the smart contract. So one thing to note here is that with the chain link Devrel Oracle nodes that we're going to be using on COVID, the limit of the response size is approximately 28 kb. So that's for the response content. I assume with headers and stuff it's going to be around 32. So what that means is you want to make sure that when you're calling the covalent API, you want to set parameters such as the page size appropriately so that your response isn't larger than 28 kb. Otherwise you'll find that the node won't actually provide you with the response.
00:26:17.840 - 00:27:21.056, Speaker A: You then set the appropriate path to get the particular data that you want from the json response object. You'll then compile, deploy the contract, note the address, and then you'll have to send that address some link tokens which is paid by the contract to the node that is processing the request. And there's a pretty solid faucet that Chainlink has got. So for all their supported networks, both mainet testnet or for all their testnets, you can use a faucet to get some test tokens and then you'll just call your function, your smart contract function, which in turn then makes the call to the covalent API. So that's the process. And so we've got two code examples here. You can actually use these examples to basically pull data from any of our endpoints as long as your response is under that sort of 28 kilobyte threshold.
00:27:21.056 - 00:28:16.950, Speaker A: So we've got an example here for string data and we've also got here if you want to get pricing information as a UN 256, you can use this example here. And note that the job ID is different for the type of data that you're wanting to get returned. So let's go through the first one here, which is for a piece of string. And the API that I'm actually going to call is this one here. So in particular I am going to try to grab this string here, which is the floor price in way over the past seven days for this particular collection. And I'm just going to use remix to do this. So let me just share that screen tab here.
00:28:16.950 - 00:29:05.050, Speaker A: So here's the contract in remix. This is the floor price. And again what we've done is these are again sort of set by default at the end. I'll give a mention of where I'm getting some of this template code here, but there was actually a fix being pushed out to the chainlink documentations that I had to go into to find the correct job ID. So thanks to the developer who you push that fix as a PR, it actually made a big difference to get this to work correctly. So we're going to request the floor price. This is again mostly boilerplate here.
00:29:05.050 - 00:30:09.688, Speaker A: Here we set the API endpoint that we want to hit and then here is where we define the path to get our floor price in way. And so you just need to follow the path of your json response to get the particular data that you want. And then once this function runs, this fulfill function will then also be triggered here and we can then use this public variable floor price to actually get that value. So again, a lot of this contract is boilerplate and it's just been adapted to use the covalent API to get a piece of string. So you'll compile this contract and then what you'll do is you will deploy it. We're deploying this to the coven testnet here. And what you'll then do is you'll get to the contract address of where this contract has been deployed.
00:30:09.688 - 00:31:07.864, Speaker A: So then you'll have to send some link tokens to that particular contract and then you can start making the calls directly from the contract itself. So here we're going to request the floor price, so going to make that call and then we have to confirm that. And then depending on sort of the size of the response, this could take anywhere from a few seconds I've seen sometimes takes ten to 15 seconds here, but we should just be able to call the floor price variable and see the value. So here it is. And we can see that this will actually match the API response that we had by just trying the endpoint. So this is how you can pull the floor price into your smart contract using this adapter. And so similarly with getting the price feed.
00:31:07.864 - 00:32:12.480, Speaker A: So this is an example of being able to fetch data that's in UN 256. So we're going to get the price of Ethereum. Again, I know chain links got all sorts of price feed, so this may not necessarily be something you'd want to do, but it's just an example of how you might pull a piece of UN 256 data into your smart contract. So here we've got our sort of same set up, we've got our API endpoint, which is using our pricing tickers, and then we are just surfacing the price as a UN 256. So I've already deployed it. So the same process, you deploy the contract, you send it some link tokens and then you can make the corresponding function calls. So I'm going to hide this one, we'll call the request ETH price, confirm that and you can't see it, but I just get metamask popping up asking me to confirm the transaction and takes a few seconds for that transaction to complete.
00:32:12.480 - 00:32:52.830, Speaker A: And then if I check the price, you'll see that it's set here. This doesn't have the decimals of course. It's UN 256, so it's $2,824.96 in USD as the piece of data that I get back. So that's how I can use the API and chain link to be able to pull in some UN 256. So with those two examples, you should be able to pull any data that our API provides, and it'll be really interesting to see what use cases this leads to. Again, the documentation for that is on Docsrknowledge base.
00:32:52.830 - 00:34:02.060, Speaker A: Okay, so just going to jump back to the presentation. So for this hackathon we've got $10,000 in stablecoin that we are providing with a top prize of 3000 and a minimum prize of 500. And you can basically use any API and you have to obviously use chainlink. And so what we want to see developers build is some sort of DAP using a smart contract, pulling basically any on chain data. And here are just some examples of the ones that I've talked about that might be quite interesting to build all sorts of various use cases off of. So floor price, market cap, trading volumes, liquidity balance, transactions, log events, all of those I think are very interesting price or very interesting data feeds to pull into a smart contract. If you want, you can actually also create an external adapter specifically for the covalent API.
00:34:02.060 - 00:35:14.660, Speaker A: And I know there's a list here of all the different adapters that have been built and you can add covalent to this list of external adapters. So that would be one of the other bounties that you could take advantage of. So again, we got ten K pool here, 3000 for the top prize and 500 for just trying and experimenting and seeing what you can build. Really the idea is to incentivize many of you to try to use our API and pull interesting data feeds into your smart contract. Okay, so we talked about the API docs, we talked about some of the use cases, and we also talked about the knowledge base. And again, all of those are great resources for developers and in particular the knowledge base where we've got the chainlink examples that you can go through and try to build out your smart contract.
00:35:15.640 - 00:35:16.052, Speaker B: Cool.
00:35:16.106 - 00:35:52.560, Speaker A: So that's it. Thank you so much for joining, good luck with your builds. And I'm just going to look through the list here of comments. So do you support Polkadot chain? So currently we're actually launching our network on Moonbeam, which is part of the Polkadot ecosystem. So we do have support for moonbeam. We actually also have support for Astar Sheeden. So there are different parachains that we are supporting.
00:35:52.560 - 00:36:33.336, Speaker A: Most of them that have some compatibility with EVMs is sort of our starting point. So what data are we calling from? Chainlink versus data. We're calling from covalent. So chainlink of course has got all sorts of various price feeds, whether sports data, all sorts of off chain data. The idea here is to try to be able to use various on chain data feeds into your smart contract. And so the data that you're actually calling is using covalent for on chain data. And you get the standard request response format.
00:36:33.336 - 00:38:18.252, Speaker A: So you can actually make the call across a whole bunch of different chains, supported chains. And when you're coding this, you can kind of build that into your smart contract because the path will be exactly the same every single time, which is quite powerful, and then be able to have your smart contract then make decisions based off of that feed. So one example we've seen, for example, is somebody built a betting app where depending on predicting what the floor price of an NFT collection would be at some point in the future, and people would then make bets where the bet itself was an NFT and then when the time for the prediction was crossed, depending on which set of NFTs were on the right side of the bet, would also get minted, sort of a winning NFT and maybe even have a stablecoin prize offered. So you can build all sorts of interesting things and automate that using Chainlink and covalent hope that answers the question, can this API be used to pull in data from a. I mean, if it's on chain data for a game, you can absolutely pull this data. So we've actually done a bunch of analysis for some of the top games in the ecosystem. Again, if you go to our web page, you'll be able to see a link to that report, but you absolutely can pull in on chain data associated with a game into your smart contract.
00:38:18.252 - 00:38:22.370, Speaker A: Basically, if you wanted to use, again, covalent and Chainlink to do so.
00:38:25.220 - 00:38:25.536, Speaker B: Is.
00:38:25.558 - 00:39:53.230, Speaker A: There an advantage to not being open source? Good question. So again, the whole idea with how we've approached our product to date is a, ensuring that we built something that has product market fit, and B, being able to get that validation from the market to improve the product to a point where we can say, all right, we actually have something of value here. And that's also part and parcel of why we're now going through this progressive decentralization process, because there are obviously advantages of being open source. So everything from the block specimen spec that we've published, which is basically a data provenance model, so you can sort of track and sort of have this proof on chain about sort of the data that you're actually pulling or accessing. All of this, I think, contributes to ensuring that the data has got this transparency model behind it. And then in addition to that, these community class C endpoints is another opportunity to empower developers to basically build custom endpoints that other members of the community can take advantage of. So yes, there are obviously advantages, and that's a path that we're going down here.
00:39:53.230 - 00:40:48.550, Speaker A: So instead of me integrating my smart contract using Chainlink's VRF code, I could use COVID get that same data from Chainlink. Yes, exactly. So you can actually pull any on chain data using our API into your smart contract. So just like we did the floor price, if there's other on chain data that you need, you can pull that quite easily. Awesome. Okay, I know there's a lot that we covered there, and hopefully this was quite interesting and valuable. Let me just highlight a couple of quick things here before we wrap up.
00:40:48.550 - 00:41:51.744, Speaker A: So let me share. So I do want to just give credit where it's due here. There is this fix being pushed out to the chainlink documentation. So Amin and group who've done this, this example that they pushed out here with the correct job ID is basically what I use in order to be able to use the covalent API correctly. So I know this is hopefully getting pushed out into production shortly here, but I just wanted to call that out because it actually saved me a lot of time by being able to use this example that this developer put together. So just thanks there. But yeah, I hope to see some really cool projects come out of this.
00:41:51.744 - 00:42:24.114, Speaker A: And again, really exciting to see what the pretty awesome chainlink developer ecosystem comes up with. So good luck. We've got our discord, but I know I think we're also going to be part of the chainlink discord. So if you do have any with questions, that's the easiest way to reach us. Our discord is covilihq.com discord build. Okay, well, if there are no other questions, we'll leave it at that.
00:42:24.114 - 00:42:30.674, Speaker A: Thank you so much everybody for your time. Appreciate you joining us and look forward to seeing what you all.
