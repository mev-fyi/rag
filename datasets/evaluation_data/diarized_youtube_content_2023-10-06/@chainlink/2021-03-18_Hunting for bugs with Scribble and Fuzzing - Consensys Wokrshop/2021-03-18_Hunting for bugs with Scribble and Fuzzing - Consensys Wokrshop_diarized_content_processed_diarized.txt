00:00:00.570 - 00:00:03.680, Speaker A: It? Sure. Tell me when.
00:00:15.010 - 00:00:50.294, Speaker B: Awesome. Welcome, everyone. Let me share this link with you guys here in the chat, then drop it over here in these channels. Welcome, everyone. Yeah, we'll get started here in about 1 minute. Really excited to have Duran and the consensus team. Duran, your title is the diligence team, right? The security researcher and product lead for consensus diligence.
00:00:50.294 - 00:00:51.002, Speaker B: Is that.
00:00:51.136 - 00:00:52.086, Speaker A: Yep.
00:00:52.278 - 00:01:05.620, Speaker B: Cool. Yeah. Really, really excited to have you here and really excited to have consensus to be a part of this hackathon. Really want to thank you guys for definitely being a part of this. And let me just push this into.
00:01:10.260 - 00:01:12.450, Speaker A: Definitely happy to be here.
00:01:13.220 - 00:01:30.488, Speaker B: Um, we really want to make this interactive, so if you have questions throughout, definitely drop them into the chat. We'll be monitoring that otherwise drain. Yeah, I'll let you take it away.
00:01:30.654 - 00:02:31.108, Speaker A: Awesome. Thanks. All right, so the title of today's workshop was bug hunting with scribble and fuzzing. So what we're going to be doing is using this tool called Scribble that we released around December, I believe, to write these so called properties and then automatically try to find violations for them or exploits. So in short, it's going to be a scribble workshop and a real quick short intro. Hi, I'm going to be doing the presentation and my name is Johan and like Keenan, I think already introduced me. We are from consensus diligence and we essentially built this tool and we think it can bring a lot of value to smart contract development and smart contract testing.
00:02:31.108 - 00:03:22.190, Speaker A: So with me today is Dimo. Dimo is the main developer, or lead developer, I should say, behind scribble. So he will be able to answer the most technical questions that you have and he'll be hanging out in the chat to interact with you guys and make sure that if there's any problems that they get resolved really quickly. And I'm going to be going through this scribble workshop. I'm first going to do a short introduction about what properties are, what scribble is and how you could use it and why you would want to use it. And then there is two to three exercises. I'm not sure whether we are going to get to the third, most of the values in the first two, and we're going to have a short wrap up at the end.
00:03:22.190 - 00:04:30.224, Speaker A: So this introduction, it starts with properties, and we need to figure out what properties actually are. And really the most simple or shortest statement to describe properties is that properties are logical statements that you expect to be true. For example, some cars are red, or a function example only returns positive numbers in smart contracts. There are a few important aspects about this in that the properties that you would describe, logical statements that you assume to be true. And the key here is this assumption or expectation that they are true, because they aren't always true. And this is where undefined behavior comes from and where you'll get a lot of bugs. So you want to test and verify to make sure that the things you expect to be true are actually true.
00:04:30.224 - 00:05:11.692, Speaker A: And that is where scribble comes in. This tool that we recently released, or recently, it's already December. So scribble is two things. First, it's a specification language, and second, it's a runtime verification tool. And I'll go into these two topics. The specification language, what does that mean? Well, specification language is nothing else than a language, a domain specific language, essentially to write your properties in. We've based scribble mostly on solidity to make it easy to get started with.
00:05:11.692 - 00:05:54.440, Speaker A: And you write your properties as annotations in a smart contract. And I prepared a little example here of a token with a function. This cannot be hacked, and what it actually does isn't too important right now. But above the function you see a doc string comment which says if succeed, it then has a message, result is positive. And then you see like an expression saying result is bigger than zero. So this property tells us that we expect the result of the function. This cannot be hacked to be bigger than zero if it succeeds.
00:05:54.440 - 00:07:13.460, Speaker A: If there's some revert or abort happening in the context of the function, then the state is rolled back and we don't really care. But if it succeeds, we want the result to be bigger than zero. That's nice. Now we can define what we expect to be true about a contract, but we need this second step which where scribble comes into play as well as a runtime verification tool. What it does is a process we call instrumentation, and it will take these smart contracts with these comments, these annotations of properties, and it will interpret that and instead inject solidity code that checks the properties that you wrote down. This is really nice, because now we can use these off the shelf fuzzers and symbolic executors like mythrol, like myth eggs as developed by our team, and automatically check and verify or test whether a property is violated or not. What this process looks like can be explained using this same simplified example again.
00:07:13.460 - 00:08:19.796, Speaker A: So on the left hand side we have this example token again with the property that we just described. On the right hand side you see how a scribble would take that program, translate it, and inject an assertion at the end, saying that the result must be bigger than zero. Now, in this case, we have a simplified example, and usually the instrumentation is a little bit more complex than this, but it does highlight really well what the general approach is behind runtime verification. And in the workshop, actually in the first exercise, we'll have a look at what this actual instrumented code looks like so that you can use it to see what's happening. All right, that's the introductory part. Now, we get into the setup. In this workshop, we're going to use a few tools, primarily scribble.
00:08:19.796 - 00:08:59.796, Speaker A: Of course, you can use or install truffle. We've set up truffle projects for each of the examples, but it's not strictly necessary to have that installed. And then we're also going to use, like I mentioned, Mithro and Mythx. So Mithro is this symbolic executor. It's open source, and anyone can use it, basically, and we're going to use that on the first example. Mythx is our security analysis platform. It's not open source, but it uses various analysis techniques to hammer away at a smart contract to see if there might be anything wrong.
00:08:59.796 - 00:10:01.640, Speaker A: So these two tools are actually generalized or general security tools and can do much more than just look for property violations. But in this case, that's what we'll use them for. Yeah, so if you want to install these tools, these are the commands that you need to execute on your machine. And I'll leave them on the screen for a bit so it's easy to type over and maybe demo can put them in the chat for us. And I should add one thing here. So in this workshop, we're going to be using Mithro and Mythx ClI as diligence. We do these audits and property writing engagements where we set up extended fuzzing campaigns and a range of properties to make sure that a system behaves as we expect it to.
00:10:01.640 - 00:11:00.444, Speaker A: So for this, we actually use a component that is behind Mythx and use it with some custom setup. We call this fuzzing as a service to really dive deep into a system and its configuration and how different components interact so that we get a more complete model. But for this workshop, we're going to look at mostly like simplified or isolated examples. I shouldn't say simplified because we're looking at real world contracts, but we're going to look at tokens or like singular system. I hope everyone was able to execute the commands. If not, I hope they are in the chat. Then on this page there are a few useful links that I would recommend you check out, especially after this workshop because they have a lot of useful content.
00:11:00.444 - 00:12:01.040, Speaker A: So the first link points to the scribble documentation, and this shows you both how to use scribble as a CLI to do instrumentation and documentation on the scribble specification language. The second link is linked to the scribble repo. It's completely open source. If you have suggestions, if you find a bug or if you want to contribute, that's the way to go or the place to go. And then the third link is to Mythx IO. So if you want to follow along now or after the workshop to retry the second exercise, then you can sign up there. I'll put a promo code in the chat a little bit later that you can use to get like a free account because we want you guys to be able to do the scans.
00:12:01.040 - 00:13:01.152, Speaker A: All right, so then we go into the first example, which is a bubby ERC 20 contract. And for that I'm going to move to my other window, my editor, and go away from the slides. All right. Share a different screen. Yes. Okay, so we have this repo where we preset up this exercise and you can find it@GitHub.com consensus scribbleexercise one and exercise two is going to be at exercise two.
00:13:01.152 - 00:13:48.668, Speaker A: So I hope demo can put that in a chat so that you guys can go there and clone the repository. The repo has an extensive readme that describes all the steps we'll go through. So after the workshop you can go through it again. Or if I go too fast, or if I forget to say something, then the info should be there as well. There's also the links to the scribble documentation, mythics, everything there. So it's a really good reference material anyway. So in this repository, we'll find a directory with a single contract in there called vulnerable ERC 20 solo.
00:13:48.668 - 00:14:51.720, Speaker A: And this is a really simple token contract, nothing fancy. But there is a vulnerability in here. And we're going to find that vulnerability by just going in and writing some specifications or these annotations with scribble. And we're then going to use mithral to automatically find a situation in which the properties are violated, which then that effectively demonstrates that there is a bug. You could use this in two ways, essentially. One, as a developer, if you want to make sure that your smart contracts are doing what you expect them to be doing, or two, as an auditor or security engineer, you can write these properties and use a fuzzer or symbolic executor to find bugs. And that's essentially what we're going to do today, because this is not a development workshop.
00:14:51.720 - 00:15:43.196, Speaker A: And I'm going to go in and write some properties for the transfer function, because I know that's an interesting part of the contract. It's transferring value. So if something goes wrong here, it's probably bad, and I'll dive right in and just write properties about what I expect the contract to be doing. So I'll start by writing another, by writing an if succeed property. An if succeeds property describes what I expect to happen if the execution is successful. And that's the only way that variables change. So that's mostly what we want to talk about.
00:15:43.196 - 00:17:09.370, Speaker A: So if the transfer is successful, then I expect that the recipient of the transfer receives value, amount of your c 20 tokens or vulnerable tokens. I can describe this by describing the state before the transfer, with the state afterwards. And I use the old keyword for this, so let me quickly write it down and then explain what I'm writing afterwards. So I'm going to say that the balance two is the balance, the old balanced value. So I'll go through this again. I'm saying that the balance of two after the function succeeds is going to be the same as the balance of two before the function succeeds, minus or plus the value that was transferred. So the amount of tokens, and similarly, I want to say that the balance of the sender decreases it.
00:17:09.370 - 00:18:34.832, Speaker A: Now you might notice that this is not entirely true, because I've missed an edge case, namely in the case that you send tokens to yourself, some contracts might revert, this one doesn't. But I want to exclude the use case for these two properties, because if you send something to yourself, essentially nothing should change. So let me add a conditional implication which says that the message sender must not be equal to two. And if that's the case, if the sender of the transaction isn't two, then this property must hold. And we're just going to copy paste that down here. Cool. Now we actually missed, or we actually are missing one case, which we know, which is the case where these two are the same, in which case nothing should change.
00:18:34.832 - 00:19:58.300, Speaker A: So let me write that down as well. Ah, so it's the same then the balance of sender, which is the same as the recipient, is the same before and afternoon. All right, there is one more thing that we can do, which is we want to say that a transfer doesn't succeed if the sender doesn't have enough funds. This is usually implemented by a check. It is in this case, but writing it down makes sure that it's checked, even if there's an overriding implementation in some contract that inherits from the vulnerable year C 20, which forgets to introduce this check. So let's add it before the transaction. We want to know the state before the transaction, and we're talking about the balance and sender.
00:19:58.300 - 00:21:03.932, Speaker A: We want it to be higher than the value or equal to. That would be fine as well. All right, so I omitted doing something while writing these properties, and that's adding messages, which you do like this. You can add this structure to any property and by doing that the instrumentation will take the message and put it into the instrumented code. We do that because our downstream tools, our fuzzer and symbolic executor, know to look for this message and report it to us, the user, when they find a violation. This makes it much, much easier to interpret reports. Actually, let me not add a message and then we'll add one once we see a property being violated.
00:21:03.932 - 00:22:07.990, Speaker A: And to show how much better it is, some of you reading the code have already noticed that there is a vulnerability in the transfer function and will know why it's going to fail. But let's try to use Mithral to automatically find it anyway. So in the repository I've added a script which adds a bunch of parameters to mithral to automatically run this analysis. So let me quickly show that and execute that. So this command, what it does is it calls Mithral, the analyze command on our target with a transaction depth of ten and a timeout of 60. And I totally forgot one step, which is the instrumentation phase. And that's why Mithral doesn't find any vulnerabilities just yet.
00:22:07.990 - 00:23:11.456, Speaker A: So what we're going to need to do is make scribble take these annotations and turn them into assertions. You can do that in the following way. Scribble arm files, contracts. So what this command will do, it will arm the smart contract, which means that it will take the file and put the instrumented assertions in place. But it didn't work because I made a typo, a lot of typos actually, because I used the variable name balance, whereas the actual variable name is balances. So if you make mistakes like this, scribble has a full type checker behind it. So it will tell you, well, this identified that you're using doesn't exist.
00:23:11.456 - 00:23:54.680, Speaker A: So let's quickly change that and fix my properties. Done. And let's try again. Awesome. Now you see how a lot has changed. There is this new and weird transfer function which creates some old values calls into a function called original vulnerable token transfer which has our original implementation in there and then has a bunch of assertions. Now we can run Mithro again in this time.
00:23:54.680 - 00:24:35.104, Speaker A: Hopefully we'll find a bug. And while we wait, we see these different assertion field log emissions and these each correspond to the different properties that I wrote before. And this is also where that message is going to show up. So let's wait for a second. All right, so mithral find violation on line 55. So that's property two. Now you could go into this statement and see what it means, but it's much, much easier to add messages to your properties.
00:24:35.104 - 00:25:05.616, Speaker A: So let me do that. To return to the original file. I can call this arm and it will restructure everything like we had it before. And I know that it's this property that was violated. So I'm just going to add a message here. Sending to self doesn't do anything. All right, now there's a message.
00:25:05.616 - 00:25:31.460, Speaker A: Done. And let me rearm it again. All right, it takes a bit. It will do the instrumentation crunching. And you see here that the message showed up. And now I'll run again. And it doesn't take a long time for this contract because it's a single ERC 20 contract.
00:25:31.460 - 00:26:26.840, Speaker A: We only looked one transaction deep. But for more complex systems that are being built right now, this isn't sufficient. You're going to need to use more time or different techniques. And that's what we do when we use our own buzer with a custom setup. All right, so we see now that mithral finds an assertion filled again, but this time it tells us that it filled with this message. And now it's really easy to go back into the code, look at the property that was being violated and see where things went wrong. And when we actually do that, we go back, we see well, the property that sending to self doesn't change anything is violated.
00:26:26.840 - 00:27:36.540, Speaker A: Then we can dive into the actual implementation. And we see here that it's probably because we take a really weird approach to updating balances when we're transferring. And we do it in two steps, which completely fails when you're sending something to yourself. So let's fix that real quickly by just changing it to from minus equals value and two plus equals value. Now we'll prearm it again and run Mithra on it once it's done. And what's nice about this is that, well, we're first going to try to fix the vulnerability that we found by writing this property. Oops.
00:27:36.540 - 00:28:29.440, Speaker A: Yeah, now it works. We're trying to fix a property violation, but now we're going to run Mithro again to confirm that it works, our fix. But at the same time, we're going to check the properties that we wrote previously, like the one saying that transfer must happen, and we'll make sure that the fix that we made is actually correct, that it didn't change anything big. So let's see if that's actually the case or if I made another mistake. I didn't. So now everything executed successfully. We can be happy and continue our bug and doing journey.
00:28:29.440 - 00:29:04.110, Speaker A: Let me clean up, though. I restore everything. And now what I could do is set up a CI pipeline to automatically just test properties or run a fuzzing campaign each month or week. Each week is better, of course. All right, tech up one. Now let's go on to the next exercise. You'll find this at pretty much the same link, except you need to replace the one with the two.
00:29:04.110 - 00:30:15.616, Speaker A: It's called scrub exercise two. And here we're going to be looking at a vulnerable ERC seven, two, one. So an NFT, essentially. And we took the implementation, I think, from open Zeppelin's implementation, but we made one slight change, which is that we enable the mint function or we make the mint function public. And the reason we do this, let me just search for it. The reason we do this is because we need to set, or we need to allow the fuzzer to set up the ERC 72 token. In a situation where there are tokens, there are NFTs that can be passed around through the system.
00:30:15.616 - 00:31:00.160, Speaker A: And if we don't do this, then we'll need to set up a seed state for the fuzzer. And that's just a little bit more difficult for this example. And that won't work with mythx. That's only our internal buzer. So before we go into the contract and try to annotate every function, which we could do, I'm going to go right to the function that is vulnerable, just to save time. And the function that's vulnerable is for. From, um.
00:31:00.160 - 00:31:52.210, Speaker A: And there is again, a few properties that we could specify. So one best practice within many standards, actually is to not allow sending tokens to the zero address, because it's virtually the same as destroying them. And that is not necessarily something that you want. So how you could write this properties as follows. It's really easy. We say that the function if it succeeds two is not equal to zero address. I typed wrong.
00:31:52.210 - 00:32:58.484, Speaker A: Yeah. Now there is more that we can specify, namely similar properties that we did before. The recipient should receive the token. So I believe the ERC seven to one standard has an owner of method that we can use to get the owner of a token. So we can say that afterwards two equals owner of token id. We also want to make sure that the from address was Yolk's owner because otherwise we're just sending someone else's tokens that we don't have approval for. Well, there's a third thing that we could check, which is whether the sender is approved for from, but there is various edge cases to that.
00:32:58.484 - 00:34:30.100, Speaker A: And it's a little bit more complex to write down because there is, I believe, three cases. Either you are the owner or you're approved for a single token, like to send token with token id for the address from, or a third where the address from has created an allowance for the sender of a particular of this transaction to send all their tokens. Actually, let me just write that down. It shouldn't be too difficult. Um, so, okay, it succeeds. We're talking about like a lot of actions that the owner did of the token, but we're talking about the owner before because we're going to be referencing that a lot of times I'm going to use a let binding here. So I'm going to call it old owner and bind it to the old owner of Token ID in my further expression.
00:34:30.100 - 00:35:58.944, Speaker A: Essentially you can think of it as assigning to a variable. We called it binding because you shouldn't try to rebind a variable because it's an immutable thing or it needs to be immutable. So now we can use this variable to check different things that we want to check. So let's check this first case that I mentioned, which is a transfer from should be allowed when the from address is the actual owner of the token or is the actual from interest, in which case we think everything is fine. Then we want to see that maybe the sender has approved the, or maybe the owner has approved the sender for this particular token. And there is a function for this called getapproved which will return the address of the person that's approved for transmitting that token. And we want to see if maybe our sender is that.
00:35:58.944 - 00:36:52.960, Speaker A: Or the final case is when the sender is approved for all tokens of the prom address. So let's write that down. There's a function for that, too. Old owner sender. All right, nice. All right, now, we have stated various properties about this transfer from function, which, well, because I'm looking at it, probably is wrong, but we don't know what's wrong yet. And we're going to be running a short symbolic execution and fuzzing campaign on this.
00:36:52.960 - 00:37:22.380, Speaker A: It's going to take about 15 minutes. It won't take 15 minutes now because I've already done the analysis and we'll have a look at that. But if you're going to run this yourself, it's probably going to take about 15 minutes. And we're going to actually use for this one. And let me see. Open my terminal window again. New terminal.
00:37:22.380 - 00:38:02.452, Speaker A: All right, so we're back. Let me move to the right directory. Exercise two. So here we are. And I'm going to do the same thing again where I'm going to arm the contract. But actually, yeah, let me do that. So the command I'm going to use for Mythx and the command I will use for Scrabble, they're both in the git repo readme.
00:38:02.452 - 00:38:48.100, Speaker A: So if you want to do this again or do a copy paste, that's where you can look. So the first step is to do the instrumentation. So I'll invoke scribble again with the same arguments, except that I'm going to add one because in this case we want to say or state the compiler version if that's ever necessary. It's really easy. Just add a compiler version tag and then scribble will use that internally to do the instrumentation logic, and we'll focus it on contracts. Working sample. Wow.
00:38:48.100 - 00:40:00.620, Speaker A: I didn't make any typos this time. So transfer from. All right, so we see again these four properties that have been instrumented. I actually prepared these very same properties before, but in a different contract because that way I can cache the analysis or I can have mythx cache the analysis and we get some really quick and snappy response. So we do the same thing there with my pre made setup, can look for the same transfer from function. And you see here really the only difference is that I actually did the effort of writing the property descriptions. Now, we can submit this to mythx using the following command, mythx format, simple, which gives us a nice and readable output.
00:40:00.620 - 00:41:16.180, Speaker A: Analyze the targets, check properties. So the check properties tag will inform the text to only look for assertion violations and not all the other things that it can look for. This does two things. It reduces clutter because you don't see all the generic vulnerabilities that might be there. And two, because our tools don't have to look for everything anymore, they can run more optimized for these properties so you get some improved performance. And here let me also add the compiler version that's being used, and I'll run that and it will prepare a single job for me and it should be done relatively quickly. But while that's running in my terminal, I'm just going to hop on over to the NFX dashboard that has a nice visualization of how the fuzzing campaign performs.
00:41:16.180 - 00:42:10.096, Speaker A: It's this window. All right, so this is the report for our scan. It describes various things, so first it has the issues that have been found, and there are two. This is because scribble emits both a log message which is recognized, and an assertion. So mithecat actually will find both. There is a coverage graph here which shows how the fuzzer actually increased in coverage over time. So our fuzzer and symbolic executor are essentially simulating different ways of how the contract can be executed.
00:42:10.096 - 00:43:03.560, Speaker A: So in a similar way to unit tests, they will have increasing coverage, and the longer they run, the more they are able to cover up the contract. So this graph kind of shows you how far it was able to get and whether it started stagnating, because there's a lot of diminishing returns here. But in this case we see it's still going up pretty steadily. So if we fuzz for another, I don't know, hour, then that might be valuable. But we already found the vulnerability in this case, so we're good anyway. So then we can jump into the assertion that has been found. And actually, before we do that, I want to highlight what we show here on the left, these green bars.
00:43:03.560 - 00:44:35.460, Speaker A: These show which areas of the code were reached by our analysis, our dynamic analyses. And this gives you the insight into was the fuzzer or symbolic executor even able to reach my property or not? And we see in this case, in fact, that yes, most of the contract was covered and analyzed. The only part that wasn't covered are these two bodies of the properties that have never been violated. Which makes sense, right? These assertions are never reached or aren't reachable, and therefore they aren't violated. So then there is something really nice about using fuzzing and symbolic execution for testing these properties, which is that they are able to generate concrete counterexamples whenever they find a violation. So what does it mean? What is a counterexample? Well, essentially it just generates a test or test suite in a certain sense that covers the property violation. So you see here what the fuzzer and symbolic execution did to trigger this violation.
00:44:35.460 - 00:45:19.510, Speaker A: First, there is this undefined step, and this is the contract creation step. And that's why we call it undefined. The second step is a call to the mint function. It has the argument aaa and then a zero. This is the address that we use internally in our fuzzing as one of the accounts to simulate transactions coming from. And then there's a zero here, and this is the id of the token. So the second call is a transfer from the address from the fuzzer that holds the token to the zero address.
00:45:19.510 - 00:46:24.708, Speaker A: And the token that's being sent is token with id zero. And we know that it is violating our best practice. And we see here that indeed the property that's being violated is the property that says that you shouldn't be able to delete a token by sending it to the FS zero. So now we can dive into the code again and add a required statement stating that the transaction will revert whenever this is the case. It. All right, so since we have the time, I'm going to actually go into an example that unfortunately you won't be able to follow along with yet because we're currently developing this feature. But I really like the feature.
00:46:24.708 - 00:46:59.792, Speaker A: So I'm going to show you how it works. Anyway, so I'm back to the code. Oh yeah, by the way, the output of the CLI looks like this. And here again we see we cannot delete something by sending it to the. Anyway. Okay, so back to the example. So probably if you have done some smart contract development, you're going to be familiar with the ownable pattern design pattern.
00:46:59.792 - 00:48:04.440, Speaker A: I guess it's used for authorization and access control. Essentially how it works is there is a variable that stores an address. The address is the address of a person or other contract that is the owner of a contract. And then there is an only owner modifier which protects features that maybe do minting or some administrative features. What you essentially want to say is that whatever the contract does or like the contract that inherits from ownable does. I only want the owner to be able to appoint the next owner because otherwise someone might be able to steal ownership. And we're going to be able to do this with a feature that's hopefully going to be in our next release, which is called if updated.
00:48:04.440 - 00:49:37.030, Speaker A: And what you're going to be able to do here is write a property that needs to be true in case owner is written to. So even if owner is written to by the constructor of some downstream component, we can control like we can check our property. And what we want to say is that if the owner is updated then the old owner is the message sender and that's it. So this check will allow us to see is going to have scribble instrument checks that make sure that the owner variable is only ever updated by the actual owner. There's actually one more thing that I need to add to this before it's really correct, because there's one case in which we are allowed to set an owner when it's not the message sender that was the actual owner, which is in the case of the constructor or when the owner isn't set up yet when there is no owner. So I'm going to add that as an edge case and in this case the owner is going to be zero. So if the owner is nonzero, then only the sender can update it.
00:49:37.030 - 00:50:40.730, Speaker A: Then only the old owner can update it. So if the owner isn't set yet, like in the constructor, nothing will be violated, but afterwards everything will and we get to check this downstream. Now we have an article on making a detection module for this in Mithral, but without having to write this annotation. But this annotation allows you to describe the very same case much more concisely. So stay tuned for our next release. Let me now go back to our slideshow and then maybe jump into some q and a afterwards. All right, so a little bit of scrolling and share my screen.
00:50:40.730 - 00:51:34.870, Speaker A: All right, I hope that works for everyone. So in the summary we had a look at scribble. We did a lot of things. So we used function specifications, we used the old keyword. We've looked at how to use implication to do these conditional behavior checks, and we even use succeeds conditions to make sure that these preconditions are checked, for example that the two address isn't zero. We also use both Mithral and Mithx to automatically check the properties and find violations and then look through the results to see what's going wrong to see how we might be able to fix the property. And like I said, there is more.
00:51:34.870 - 00:52:22.450, Speaker A: So if you go into our documentation, there's a lot of things to learn there and in the repo you'll be able to stay up to date on any future updates on our website. We also have a blog where we'll probably be publishing development updates with new features and yeah, you can find us on Twitter as well. So with that, I'd like to thank you all for hanging out with us. Let me know how it goes trying out scribble. And with that, I'd like to open it up to a few questions if there are any.
00:52:26.580 - 00:52:47.188, Speaker B: Awesome. Thanks, Ron. Yeah, really appreciate that. That was fascinating. It looks like Demitar really took care of things over in the chat. If you have good questions, anyone else that's listening in, maybe later, might be at work or another time zone right now. Definitely hop into the consensus channel of the Chainlink discord.
00:52:47.188 - 00:52:51.370, Speaker B: Otherwise, yeah, really appreciate you taking the time. And, yeah, this is great.
00:52:51.740 - 00:52:53.960, Speaker A: Awesome. Cool.
00:52:54.030 - 00:53:01.480, Speaker B: Well, thanks, everyone. Again, if you guys have any questions, jump into the discord. Feel free to reach out to me anytime. And thanks again, Jerome.
00:53:03.060 - 00:53:04.940, Speaker A: No problem. Hector thinks.
