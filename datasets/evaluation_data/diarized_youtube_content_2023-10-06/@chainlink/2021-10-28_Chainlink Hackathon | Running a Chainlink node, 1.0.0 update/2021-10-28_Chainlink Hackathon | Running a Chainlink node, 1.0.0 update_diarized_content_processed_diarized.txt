00:00:22.200 - 00:01:18.798, Speaker A: Hey everyone. Today we're going to be talking about one of the most core parts of the chainlink protocol, the chainlink node, and we're going to figure out how we can one on one ourselves. Again, if you've miss some of my other demos, my name is Zach Ayush. I'm a developer advocate with Chainlink Labs. So before we just dive into a chainlink node, we will talk about what it is and then we'll do a little demo. So what is a chainlink node? A chainlink node is software that sits in between the blockchain and the outside world is the core piece of software for running a decentralized Oracle network. Or it can act as a standalone piece of software as a node on its own.
00:01:18.798 - 00:02:06.990, Speaker A: It's written in the programming language Golang. And again, many nodes can be combined to form a decentralized oracle network or a dawn. This is truly the core of how the chainlink Oracle network works. So what are the core components of a chainlink node when you're running it? Well, a chain link node can be essentially set into two different things, initiators and tasks, which make up jobs. This tells the node what to do. So nodes can listen for specific events emitted on the blockchain, and in response to these events they can perform the job. It is initiators that can listen for these events.
00:02:06.990 - 00:03:11.996, Speaker A: Initiators can do more than just listen to events. They can also start your node jobs with any arbitrary conditions that you may want. So a job is a series of tasks that a node must perform in response to those events. And how do we define those tasks? Well, we have very strict task definitions, so you might have a series of tasks that says, hey, go receive a UN in a json file using a git request, parse that data, take that un out, multiply it by some constant, convert it to an ethereum readable format, and post that number to the blockchain. Again, each of these atomic units of work is called a task. You can kind of see example of that on the right there with a task list. So I mentioned that there's all kinds of different types of initiators that can start off our job runs.
00:03:11.996 - 00:04:18.500, Speaker A: So what are some examples of the different types of initiators? First, we have cron, which runs the job on a set schedule, maybe every day, every hour. One of the most common, a direct request initiator. So again, this is when a smart contract actually emits an event. The node will listen for that event and start a job. In response, you have flux monitor jobs, which is for dons. These will look for a certain deviation in price data and start a new round. In a decentralized oracle network you have the keeper job type which will virtually run a method until it returns true, and then run a specific function on the blockchain off chain reporting, which is like flux monitor, but is part of an off chain aggregation protocol in the dawn.
00:04:18.500 - 00:05:48.980, Speaker A: And finally a webhook which can be initiated by HTP requests. And these HTTP requests could come from a user yourself or most likely an external initiator, which is a bot. So to dive in a little bit into, specifically into external initiators. Again, these are used in conjunction with specifically the webhook initiator to essentially allow your jobs to activate under any arbitrary conditions you wish. So within that external initiator, we can go in, we can program it, we can customize it, and we can say send an HTP request to our chain link node under any arbitrary conditions that we can program. For example, I could have an arbitrary external initiator that scans a pizza stores API for pizza deliveries, and once a specific pizza is delivered, it communicates with the node to start a job and post some data onto the blockchain, initiators talk to nodes via a thing called a bridge next to dive a little bit into tasks. Again, tasks are how we define how our node is going to do work and what work that node is going to do.
00:05:48.980 - 00:07:01.142, Speaker A: Tasks can be chained together within the node to form what's called a full job or a pipeline. Pipelines are a dag, a directed acyclic graph, and expressed in dot syntax. You can see an example of some task syntax up there on the top. Each task has a specific user specified ID or UID, and a specific set of configuration parameters and attributes. There are many built in task types such as HTTP mean and json pars, but you may want to make your own task that's not inbuilt with the Chainlink node software, and that's where external adapters or just customizable tasks come in. So just like external initiators, let us customize how we wanted to initiate our node. Job runs any way we wanted.
00:07:01.142 - 00:07:54.780, Speaker A: External adapters let us customize any kind of task that we want. External adapters are also required for any jobs that would require authorization at the API level. Like you need some API keys that you want to store within your node. And the cool thing is, because these are run separate from the actual node software, they can be programmed in any language you want. There are pre built templates available on GitHub in JavaScript and Python. Again, nodes communicate with external adapters to ridges just like they do with external initiators. And these external adapters send post requests, post HTTP requests to the EA to get them started.
00:07:54.780 - 00:08:49.210, Speaker A: External adapters really enable node operators and nodes do anything you can conceivably think of. So we'll jump into a demo. I don't think we'll have time to get into best practices today. I know that we had that in the first slide, but that could be a topic all on its own. And there's some great documentation on our Docs website for that. Okay, so this is what I have set up for running a node. We'll actually walk through a lot of this, but we're going to get Docker and have it running a free and Fura Alchemy account, postgres database, a metamask wallet in the browser, some testnet, ETH and Testnet link.
00:08:49.210 - 00:09:39.996, Speaker A: We're not going to be actually running any external adapters or external initiators today. We're just going to create a basic job pipeline and we'll get a node that runs a job in the docs that runs the same job in the docs in the any API section to get the ETH USD 24 hours volume from crypto compare. And so where I'm going to start is in the chain link docs for a lot of my demos. We go straight here because the chainlink docs have a lot of great step by step guides on how to do anything you want to do in the chainlink network. So let's go ahead and click on the docs. And it already takes us to the node operators section up here. This is where we'll want to be.
00:09:39.996 - 00:10:35.740, Speaker A: And on our left nav bar we're going to see node operators, an overview explaining how the node software is the core component of the Chainlink network. And we'll click on running a chain link node because that's what we want to do. So it's going to go ahead and give you the requirements. We can run this software from source. So if we click on these instructions here, it'll take us to the GitHub repo for the chainlink software and tell you how to run it from source. This is definitely a viable way to do it, but we're going to use Docker. The reason we're going to use Docker is because it already sets up a lot of our environment for us and is constantly updated with the newest versions that you can just pull from.
00:10:35.740 - 00:11:17.158, Speaker A: So we're going to follow the using Docker steps as recommended. And if you don't have Docker installed, you can run one of these commands depending on what your OS is. Or you can go to the Docker website, docker.com, and search until you find where the downloads are. We'll go ahead and say get started, and you're going to want to download Docker desktop. It's already selected for my computer. You can find one that fits the computer that you're running your node software on.
00:11:17.158 - 00:12:35.630, Speaker A: And this could be on the cloud as well if that's where you choose to run it. Okay, so one of the first steps it's going to have us do is create a directory. So let's open our terminal, and like most things in this hackathon, the Covan testnet is a great testnet to run on. So we'll go ahead and switch to here, and we're going to copy this command, go into our terminal and we'll paste it. I've already created this directory within my computer, so I'm actually going to hit enter. But if you just hit enter, it'll run, nothing will show, but it'll have created the directory it and we can check here, we'll see where we're at. I'm in my home directory, and if I do LSA and we look here, we can see Chainlink Covan, that's the directory you just created.
00:12:35.630 - 00:13:28.050, Speaker A: All right, so we'll clear out the terminal, scroll down, and the next step we're going to do is create an environment file. So this is what our docker image is going to read and it's going to tell it how we want our node configured. We see there's a bunch of different settings already set for us here. In this example UV file, it sets the ETH chain iD to 42, which points it to Covan. If we have it on this Covan tab, it tells us where the link token is located, some ports we want, if we want secure cookies. This is set to false. This is for demo purposes and just kind of practicing running a node.
00:13:28.050 - 00:14:21.282, Speaker A: Some of these you'll want to customize based on a production environment, and you can learn more about that in the best practices setting. But for now, we'll copy this command here. And again, you just go back to your terminal and you can just paste all of that and that'll do all the work automatically for you. And hit enter and it'll go ahead and create a env file. It's going to create it within that chainlink COVID directory and it's going to fill in that env file with everything that we say here. See here. Okay, so again, I've already run this, so hit enter, do it next.
00:14:21.282 - 00:15:09.970, Speaker A: This is where we're going to go ahead and put in our EV file a URL for our Ethereum client. And we can do it from an Ethereum client on the same machine. So we can run our own node and connect to that node, or we can use an external provider. We're going to go the external provider route today because that's much easier than running a chain link node. You can make that decision for yourself if you needed to go to production, but running a chain link node can be heavy on the computer's resources. So for this demo we're going to be using an external provider. So let's go ahead and get that URL.
00:15:09.970 - 00:15:37.704, Speaker A: Let's go to alchemy. I'm just going to type in alchemy blockchain on here. And one of the first things that's going to come up is alchemy.com. So we'll click on that. You can create an account for free. Click login, it remembers me from my cookies. And you see, I already have a couple of projects set up.
00:15:37.704 - 00:16:13.636, Speaker A: One called node operator demo. This is the one I'm going to be using. But if you want to make your own, you can click create app, name it, whatever you want, give it whatever description and make sure we're going to just put it on staging and connect. Say we want the Ethereum chain and the Covan network. You can create app and boom, you have it here. We're actually going to look at the node operator demo one. Go to view details, view key.
00:16:13.636 - 00:16:56.450, Speaker A: And this is where you can get your provider URLs. We're going to actually use the websockets URL here. So we can just go ahead and copy that or keep it up. We're going to keep it up for later. So you don't want to share this with others so they don't access your alchemy project URL and spam it. But I'm showing it to you, everyone, for this purpose of this demo. Okay, so if we go back, we're going to do Ethereum client as an external provider and we're just going to write one line to our EMV file located there.
00:16:56.450 - 00:17:45.010, Speaker A: We'll copy this command, go back to our terminal, paste it in and we'll scroll and we don't want to put ETH URL equals change me. We'll delete the changeme part. Go back to our alchemy. Make sure our websockets URL is copied in. Come here and we'll paste it in right there. Zoom in a little bit there. So make this a little bit more clear.
00:17:45.010 - 00:18:31.730, Speaker A: All right, hit enter and this will write this line to our env file and chain link Covan. Once again, I've already got my env set up so I won't actually hit enter. We'll clear that out and back to the dive. So see what our next steps are. Finally, we're going to need to tell the node software a database URL for the database we want to connect to. The database is going to store all of the permanent information we're going to want for our node operator, for our node software, like our job run history and the jobs that we've actually created. So this is a pretty important step.
00:18:31.730 - 00:19:33.030, Speaker A: As you can see again, this URL is just another line that we put in our env file. But let's look at there's a bunch of different variables we need to fill in here. Let's look at what they are. We have our username, the username for our database, the password for that database, our IP address of our server, our port, and the type of database we're running. So you can create a database on a cloud provider and if you want to do that you can click on connecting to a remote database and it'll walk you through some steps that you need to complete. We're actually going to run this database locally. So it's on our computer, the same computer we're running our node on.
00:19:33.030 - 00:20:18.932, Speaker A: And the steps are essentially the same. We're still going to write this database, this database line in our EMV file. We're going to write this line to our EMV file and we're just going to replace our server section with a local host. The local host our database is located at. So for the purpose of this demo, what the database I'm going to run is postgres and we can type in postgres. And in this case specifically I'm going to go to postgresapp.com. So this is a really easy way on Mac to get postgres running.
00:20:18.932 - 00:21:17.100, Speaker A: It gives you a very convenient GUI and also installs all of the postgres installations that we'll need. If you're not on Mac, you can just download a typical postgres download installation from Postgres SQL. It gives you a bunch of different instructions on how to download it. Some great documentations you can click download and pick the operating system of your choice and follow along with the steps. So I'm going to go through with the Postgres app. It's as simple as just downloading. You can click installing Postgres app, moving it to application folder, and once you get it installed and running, I already have it installed.
00:21:17.100 - 00:22:04.250, Speaker A: You can click on Postgres, get it going and you can actually initialize a new database. So if I stop this, when you first run your database you'll see an initialized step here. You can click on that to get a new database running and customize some of the settings you have. It'll walk you through on the download. But these are the default settings that our database is set to. And you'll notice that a lot of these are the same name as those variables we saw in our EMV file line. So we have our host, it's going to be localhost.
00:22:04.250 - 00:22:45.482, Speaker A: It's going to default to running off port 5432. Our user is going to be the same as my system's username. The database is the same as the user. It's not going to have a password by default. And it'll just give you the full connection URL here. So we can copy this command, go to our terminal, we'll paste it in and we'll make sure in our postgres app we have our databases running. This is the databases that it creates when you just initialize a new one.
00:22:45.482 - 00:23:23.230, Speaker A: This is what it defaulted to, one called postgres, an empty template and one based off of the username of my account. So everything's running. We're good. If you look at server settings it's running off of port 5432. That default we're talking about. You can see where some of our config files are located. Okay, so now let's actually fill in some of these variables with the variables that are local to me we will go to.
00:23:23.230 - 00:24:17.660, Speaker A: So we will go ahead and change our username. We're going to connect to the Zack database. So the username is going to be. Zach here real quick, double check to make sure this is all right. And so we do not have a password. So we'll just go ahead and get rid of the password field altogether. Now for our server import, this is where if you had an AWS database you'd put in the URL for that AWS database and the port.
00:24:17.660 - 00:25:02.060, Speaker A: But we're running this database locally on our machine. Here's the thing. We're running the database locally on our machine but we're running the node on Docker. So what this docker virtualizes, creates a virtualized environment for our node software to run on. So it's kind of like it's on its own little computer within our computer, and it isn't natively ready to communicate with a local host running on the main machine. So we can't just put in localhost 5432 right here. We actually need to put in server here.
00:25:02.060 - 00:26:06.744, Speaker A: So we actually need to put in, we want the add sign, we want host Docker internal. And for our port we'll say 5432. This will tell Docker to communicate with the local host on our actual machine and connect to that database we have running. Finally, for the database name, this is where you put the name of the database you're connecting to. And we're actually not going to connect to the postgres database. We're going to connect to the database called Zach here. So this is where you can put postgres or whatever it's called.
00:26:06.744 - 00:26:44.100, Speaker A: I'm going to put Zach. That's the database we want to connect to. Again, this will write a line to our env file with all this information, but we're not quite done right now. If we scroll back over here, we're going to see this important little call out in the docs. If you're testing, you can add this line to the end of our URL question mark. SSL mode equals disable. This will get rid of any SSL encryption going in between our requests, between our docker and our database.
00:26:44.100 - 00:27:13.762, Speaker A: This is what we want. Of course, it says, however, we should never do this in production. Of course you're going to want encryption. You want to make sure you have all your security in place in a production environment. But again, for this demo, we're going to go ahead and disable that to make our lives easier. We don't have to deal with certificates and all that fun stuff. So at the end we'll put in question mark SSl mode.
00:27:13.762 - 00:28:36.590, Speaker A: SSL mode equals disabled again, hit enter. It'll do its magic and it'll just go to the next line and go ahead and write this line onto our env file. Mine is already set up with this exact line, so go ahead and clear it. So once we got that, the doc said we can just start our chain link node and it gives you a convenient command we can run to just get it going and running, and it'll actually pull the docker image we need by running this command. If we scroll over, we can look at the command it changes into our directory, tells Docker to run on a specific port, and tells it what our env file is, where it's located, and what version we're going to want. That's important. So again, we'll copy this, go back to our terminal, we'll paste it in.
00:28:36.590 - 00:29:29.218, Speaker A: Now we're not going to run it as is, see what happens. If we do, it's going to say, hey, there's no version that's been made. So we'll hit up and we'll clear out our placeholder for version. And we're going to want to run the latest release of our chainlink node software. So how can you figure out what that is? Well, we can either go to the chain link GitHub, so if I type in Chainlink GitHub, it'll be our first link and we can see what the latest releases are on the right. We're at smart contract Kitchainlink, see what our releases are here. So version 1.0
00:29:29.218 - 00:30:01.826, Speaker A: is the latest version. So that's actually pretty exciting. We can run 10 in this demo. It'll give you some things that have changed and of course the source code right here that is zipped. But we're running this from Docker. So another place we can go is we can type in Chainlink Docker. This will take us to the Docker hub for Chainlink and go to tags.
00:30:01.826 - 00:30:56.570, Speaker A: And this will show us some of the latest versions we can pull from from Docker. And if you wanted to just pull it separate from running that command in the chain link docs, it'll give you the Docker pull command you can put in your terminal. But again it's shown the latest as 10, which is what we're going to run. So we'll come here and we'll go back to our terminal and we'll replace that version of placeholder with 10 and hit enter. So the first time you run this, it's going to ask you for a password for your key store. You're just going to make whatever password you want, make it something strong. The key store is what that stores all of your keys, including your wallet keys, where you'll have all of your currencies stored.
00:30:56.570 - 00:32:08.520, Speaker A: It'll store your keys for various off chain messaging like OCR, where the nodes can communicate with each other in an encrypted fashion. All of this is explained here. The next password you're going to username and password for the API or the GUI. So you'll see here in a second when we log in, when we get the chain link node running, there's going to be a convenient GUI we can go to and put our username and password and get into the chain link node via the GUI. So make all of these strong, maybe store them in a password manager. I've already created mine, so I'm just going to go ahead and get my password out. I actually store passwords in form, so I'm going to paste my password in, not going to share it of course it will hit enter.
00:32:08.520 - 00:33:13.822, Speaker A: And now we can see our node is running great, but we just have it running in this terminal here. We're actually going to want to interact with that node, create a job. So we're going to want to actually log into that GUI, move this terminal of the way and we'll see here that it's actually running on a local host. So we'll go ahead and click on our local host here and we should get our GuI showing. Awesome. Let's close out some of these tabs now. So again, I'm using a password manager here, one password to manage my passwords, make sure this is a strong password and just using kind of one of my old deprecated emails access account and this will pop up our chain link operator software.
00:33:13.822 - 00:33:45.866, Speaker A: We've got it running, it's connected to our database. Our GUI is showing and let's just kind of give it a short tour here. We have our chainlink operator logo here, which will take us back to our home page. We can look at any jobs that we have set up. I already have a single one set up. We'll set up a new one for this demo. Any runs chains that we have configured to connect to, in this case chain id 42.
00:33:45.866 - 00:34:26.114, Speaker A: We have it set to connect to Covan, which we set in our env file. Bridges we're not using any bridges. We're not going to talk to external adapters or external initiators. Some transactions that have been made, our key stores. These are very important. Of course this is something you would never want to share in real life if you're running an actual node for production. But for this demo, this is just kind of a test node and we can actually look at those configuration variables we set up in our env file.
00:34:26.114 - 00:35:17.338, Speaker A: In this convenient easy to read format right here we got our EqRl that we set to alchemy external initiators. All kinds of fun stuff actually. If you want to see that env file where it's at, we can quickly go there. We'll open a new terminal. I'm already in my root directory. We'll go and list out all the files we're going to want to change into this chainlink Covan directory that we made earlier in the demo. We want to type in CD, post that directory in here we can see all the files that we have within that directory that were made.
00:35:17.338 - 00:35:50.692, Speaker A: Got a couple of things, some logs, some cookies, but we're just going to open our env file. We'll type in vim env, and this is that env file viewed from right within our terminal. You can see all the lines that we set. Everything is as we set it. Awesome. I have one extra line here. Feature external initiators.
00:35:50.692 - 00:36:28.340, Speaker A: True. If you decide you want to use external initiators, you're going to need to activate this line in your env to get them to show up in your node operator software. All right, so let's go ahead and exit out of vim. We'll say we're out of there. All right, so back to our node operator software. So we've kind of given it a tour. We can log out here running version one.
00:36:28.340 - 00:37:01.120, Speaker A: Let's go ahead and get a job. We're going to create a new job and we're actually going to try to connect to our node. Go back to the docs. The next section in the docs after running a chain link node is fulfilling requests. And so we'll go ahead and go there. That's what we want to do. It's going to go through say, hey, we're going to need some testnet link and you're going to want a metamask set up to store that testnet link.
00:37:01.120 - 00:37:42.194, Speaker A: If you don't know how to do that, go to the beginner walkthrough. We have also some. Earlier in the hackathon, there was a beginner introduction to blockchain and solidity demo that I ran. You can go there and I walk through getting metamask set up and going through the faucets. I already have my metamask here connected to Covan, and I already have it loaded with some ETH and configuring an ethereum client. We are already connecting to the remote ethereum client and connecting to the database. We're all good there.
00:37:42.194 - 00:38:19.010, Speaker A: That's going to give us some explanations on the different type of addresses we have. When running a node. This is really important to understand. So we have the node address. This is the address that was generated in our chain link node that our chainlink node has its own wallet associated with it. If we come here if we go to keys here, this is that account address right here. This is our node address.
00:38:19.010 - 00:38:50.812, Speaker A: It has some ETH on it. I've already sent some ETH to this node. We'll send some anyway. So this is the address for our specific node and the wallet that it stores within. But we also have the Oracle contract address. Now this is what represents our node on chain. So we have this node software running on our computer, but that alone the blockchain doesn't know about it.
00:38:50.812 - 00:39:56.134, Speaker A: So we're going to actually create a smart contract and deploy it. And this smart contract is essentially going to represent our node on chain. That's the Oracle contract, our operator actually, and that's actually the smart contract that our node is going to interact with and post data to. And we also have an admin wallet address for OCR that stores and receives our link tokens. Okay, so we're going to go ahead and deploy that. Oracle, or operator is the new term for these contracts and we're going to go ahead and deploy one to the Covan network. So we're going to have to tell it where our link token is on that specific network.
00:39:56.134 - 00:40:58.630, Speaker A: It's going to give you that address, we're going to copy it and we're actually going to run through and we're going to deploy this contract on remix. So if we look right here, deploy your own Oracle contract says go to remix and open the Oracle sole smart contract. If we click on this hyperlink it will open remix in our web browser and automatically take us to the code we want. Now, we actually don't actually have anything showing here because it's just a straight up import of Oracle Sol from our chain link packages and that's all we're going to need to deploy. It's compiling successfully. We'll go to our deploy and run transactions page. We'll click injected web three.
00:40:58.630 - 00:41:35.790, Speaker A: My metamask is connected to Covan. Of course that's what's popping up. We'll make sure that it's pointed to the right contract here. We do want Oracle and we're going to post address of our link token that's required in the constructor right here. Again, I copied it from our docs and I made sure it's pointing on Covan. So we should be good. Click deploy and confirm.
00:41:35.790 - 00:42:23.822, Speaker A: All right, so we get the green check mark. We're all good here. If we go to our left, we see that we have all these methods that was in our import statement. If you want to look more into this code and see what's actually going on under the hood. This is all open source, so we can actually go back to our GitHub, we can go to contracts source and we were actually using V six. So version 0.6 and in version 0.6
00:42:23.822 - 00:43:09.078, Speaker A: this is called Oracle Sol. So we'll click on that and we can see all that code here that we are importing in. And you see a lot of those same methods, the constructor that requires the link address. All right, so this is the code if you would like to look through it and kind of understand what's going on under the hood, telling us to compile, deploy. We've done all of that. We got our valid transaction deployed contract. So now we have this smart contract on the Covan network.
00:43:09.078 - 00:44:07.258, Speaker A: We need to tell that smart contract, hey, this is the address of our chainlink node that we generated. That way the two are connected and only our node will run that smart contract. So the first thing we're going to do is we're going to go back to our node software running on localhost and we're going to copy our address of our account here. So here it says in remix we're going to call the set fulfillment permission function with that address of the node and we're going to put one other parameter in there and set it as true. And this will tell our smart contract, hey, this is the node that is going to be communicating with the smart contract. Let's limited it to that node. So we have set fulfillment here.
00:44:07.258 - 00:44:58.870, Speaker A: Click the arrow. We can just easily, we'll paste in our node address right here and we'll set this to true transact. We're going to write this to the blockchain, hit confirm. We can see down here that it looks like our transaction went through and it wrote what we want. And our metamass says the transaction went through. You can click is owner here to make sure it came up as true. So since we read that from our, our wallet, we set this value to true and we can click on owner and we can see it's set to the wallet address that we have for our node.
00:44:58.870 - 00:45:37.872, Speaker A: So great. Now our final step is we're going to actually define a node, a job in our node software. So we're going to copy all this. So jobs are a dag and they're written in the toml format. If we go and scroll. If you want to learn a little bit more about jobs, we have Oracle jobs here. In the past, Oracle jobs were written in JSON, but with 1.0.0
00:45:37.872 - 00:46:20.202, Speaker A: that has been deprecated and jobs are written in Toml now. And so if you previously run a node, we have a convenient migration doc, it'll kind of tell you, hey, this is how you translate some job types from JSON into Toml. This is the old json type node, job pipelines. This is the new equivalent version of that in Toml. And we can learn a little bit more about specific tasks and initiators here. It's just going to call in Toml in one point. It's going to call initiator, just jobs.
00:46:20.202 - 00:46:51.770, Speaker A: So at the top you're going to see a type and it's going to be job. We go back to fulfillment request. We were going to add this job to our node. We'll kind of walk through some of what it's saying. We'll copy it and we'll go back to our node account. We're going to go to jobs and we're going to click new job. It already has an old one that I have in here, but we'll go and clear it and we're going to paste in the one that we just copied.
00:46:51.770 - 00:47:49.140, Speaker A: So this is a job of type direct request. So it's going to again, listen for events that occur in our Oracle Sol file that we created and it's going to start a job. When it reads an event, we're going to call this job get un 256 because that's exactly what we're going to be doing. And one of our fields right here is contract address, your oracle contract address here. We're actually going to post that smart contracts address and we're going to paste it right in here. Let's go and delete this and we'll go on to remix and we'll scroll up and this is our deployed contract. We're going to copy this address right here and we'll paste it in.
00:47:49.140 - 00:48:49.056, Speaker A: So then it actually goes through and begins defining the work, the task pipeline that this node is going to do. So it's going to listen for the log, it's going to decode our log, it's going to run the decode seabore task. So you're going to get all that data. It's going to fetch from a specific URL, parse any JSON that comes back from that URL from a user defined path, get our un out of that JSON and multiply it by a specific value. We'll then encode that data so it's in the format that's readable by Ethereum nodes. And we will actually make that transaction. We'll encode the data, we'll encode the transaction.
00:48:49.056 - 00:49:34.132, Speaker A: And here under submit transaction, that's where we'll actually submit our transaction. And you can see the full chain written down here. Now after each of these, there's some customizable variables that we can put in. We're going to keep them at default again if you want to learn what each of these does. So for instance, maybe we want to learn multiply. We want to go through there and see how we can change up that task. You can go to the docs, we can look for the multiply task right here and it'll give you some parameters that we can customize.
00:49:34.132 - 00:50:14.052, Speaker A: So we have input the value to be multiplied and how much to multiply it by. In this case, it's going to get that data that we parsed and it's going to multiply it by 100. Down here we have one more place where we need to paste in our oracle address in the submit transaction field bus. Should be everything we need to customize here. We're going to click Create job. Let's see if it created it. Yes.
00:50:14.052 - 00:50:44.510, Speaker A: So right here it successfully created job seven. Click on it. And now we're within our job again. If you lose your place here, you can always click jobs up here. I clicked it twice, so actually created two of them runs. If your job is run, we'll see that in a second. But we'll go into job with ID number seven here called get UN 256.
00:50:44.510 - 00:51:16.264, Speaker A: If we want to delete this job, we can duplicate it and create another job just like it. Or we can just copy the job spec and we have that definition that we made right. Here's our proper contract address. We're going to double check to make sure that is correct. Everything's good there. Let's go back to fulfilling a request. We're almost there.
00:51:16.264 - 00:52:01.690, Speaker A: We're getting there. So we're at add a job to the node. So one other thing we're going to need here is we're going to need the external job ID. This is going to tell requesters who are going to request data from our node which job that they exactly want to request from. As you see, we have multiple jobs here. Each one should have its own job ID. Our external job ID is listed down here.
00:52:01.690 - 00:52:59.570, Speaker A: We're going to need this a little bit later. So we'll come back to this. Finally, we're going to need to actually send a, we're going to deploy a contract that sends a request to this node and see if it runs and gets the data that we need. So conveniently here we already have another contract that we can open up and remix. This is going to be the consumer contract again, the contract that sends the request. If we scroll through it, this is actually going to request the Ethereum price and it's going to build our request, send out a get request, tell our node the path, say yeah, we actually do want to multiply this by 100. So this is going to match the job spec that we made and it's going to send it out.
00:52:59.570 - 00:54:11.422, Speaker A: Now we have a function here fulfill Ethereum price, which our node will actually run, and it's going to send in our request ID and price and actually store our price in the state variable here, current price. Now remember, the node isn't actually going to run directly at this contract. What's actually going to happen is we're going to click request Ethereum price. That'll run, it'll make a request and it's going to send it to the oracle contract address that we have that represents our oracle on chain. And that contract is going to omit an event request received, and our node is going to hear that event. It's going to say, okay, it's going to decode it, do all that good stuff, and then it's going to post back to that contract. So you see, we have an event oracle request here, and we actually have a function fulfill oracle request.
00:54:11.422 - 00:55:21.782, Speaker A: This is what we're actually going to, our node is going to call and that will communicate back to the original smart contract to fulfill our request and store our data. All right, let's go ahead and deploy this again, no compiler errors, injected web three pointed to Covan. We're going to want the right contract, this case a testnet consumer deploy. Okay, so we have all of our methods here. Our current price is set to zero, which is initialized. We haven't made a request yet. And here we have request Ethereum change.
00:55:21.782 - 00:56:01.806, Speaker A: We're actually going to want to look request Ethereum last market. We have a couple of methods we can call. I'm going to call the request Ethereum price function. One of the things that you can customize in your node and per job is how much you're going to set your fee in link tokens. In our case, our node is set to take 0.1 link tokens. So we're going to go ahead and we're going to copy the address of this contract.
00:56:01.806 - 00:57:12.640, Speaker A: And our contract actually is going to need the link tokens, right. If we're going to make the request. We always need to load our contract itself with link tokens. So we'll go ahead and go here, click send, paste in our contract address, put link, and I'm actually going to send one whole link in. So we actually have the oracle payment being set right here multiplied by link divisibility variable so we can customize how much link we actually want here. Now all we have to do, we need to go back to our node software. We're going to want to check one more thing, and if you haven't already, you're going to want to send some ETH to our account.
00:57:12.640 - 00:58:02.126, Speaker A: It's not wanting to load our keys, but here you'll see that ethereum address that represents our node wallet and an ETH balance. I've already sent ETH to this wallet, so we're all good there. The node will be able to write to the ethereum blockchain. Okay, so we're basically ready to go. We're just going to need to put our oracle address and our job ID here. Our oracle address? Yeah, for our oracle contract that we deployed, we can get that here. This is where we deployed it, put it in and finally get our job ID, which again is in our job run.
00:58:02.126 - 00:58:56.350, Speaker A: Go to definition, we can copy this. We're actually not going to fill it in with the dashes. So I'm going to quickly clear out all of the dashes that are found in that job ID in my text editor to make this quick. And we'll copy that in and paste it. So no dashes in there. Click transact, confirm. This will send our link token, it'll send it to this oracle address and say, hey, this is the job ID we want and our node should find that job here in a minute and run our request.
00:58:56.350 - 00:59:57.768, Speaker A: Go to run. So see if anything hasn't picked up anything quite yet. Looks like our node is going offline, so real quick to see if it's run. We have our node software here, we'll click control C, that'll exit our node and we're just going to start it up one more time. Rerun that command, enter your password, get it running again. It go to our local host and you'll see right here that it did pick up that job. If we go to runs, we can click on it.
00:59:57.768 - 01:00:21.568, Speaker A: It completed successfully. So everything worked out well. You can see some of the output logs here. Awesome. If we go back to a remix for our consumer contract, we click current price. Boom. We have the current price of ETH in our contract and that's running a chain link node again, there's a lot more information.
01:00:21.568 - 01:00:53.930, Speaker A: There's a lot more to it. If you're going to run this in production, you really need to have your node operating and DevOps skills on top to be a top tier node operator. You can find some of the best practices in our documentation, such as enabling HTPs connections and more. And I'm actually going to suggest going to the discord chat. There's a node operators channel. We have a couple node operators that go there and they discuss some errors. They receive some of the best practices that they run.
01:00:53.930 - 01:01:40.804, Speaker A: You may find Link river, one of a top tier node operator in there answering questions. They're super helpful. And so I highly suggest if you want to run your node or you're interested in doing so for the hackathon that you get involved with that channel. So that was running a chain link node. Thanks for listening in. I hope that was helpful. Patrick, if you want to post the feedback form for the type form in the chat so our viewers can give some feedback, please let me know how I can improve on these talks and I hope that was helpful.
01:01:40.804 - 01:01:46.420, Speaker A: Thanks again for watching. See you around in the hackathon. Bye.
