00:00:12.090 - 00:01:00.442, Speaker A: Let's talk about just the concept of transaction fees and gas for a second. Remember how I said the blockchain is run by all these different nodes? Well, all those different nodes are running this blockchain because they actually get paid for all the transactions that happen on these blockchains. Whenever you make a transaction, there's a node or a miner or a validator, somebody running the blockchain software is going to get paid a tiny bit of ethereum or polygon or whatever blockchain that you're running on. They're going to get paid a tiny bit of that native blockchain currency. This payment is obviously to incentivize people to continue to run nodes, and they calculate how much you pay and how much the node operators get paid based off of how much gas you use. So there's this concept of gas. Gas is a unit of computational measure.
00:01:00.442 - 00:01:42.646, Speaker A: The more computation a transaction uses, the more gas you'd have to pay for. For example, we do hit click more. Just really quickly. We can see this section saying gas limit and gas usage by transaction. There was a limit of 60,000 units of gas on this transaction, and 21,000 were actually used. So this transaction used 21 units of gas. Now, for very simple things like sending ether, the units of gas are usually pretty cheap, but maybe for more complex things like minting an NFT, depositing to some DFI contract, et cetera, maybe those will cost more gas because they'll be more computationally expensive.
00:01:42.646 - 00:02:24.714, Speaker A: If this is a little confusing right now, don't worry too much about it, but just know that we use 21,000 gas here. And if we pull out the calculator 21,000 gas times this gas price right here times the gas price, we get the exact same as we see for the transaction fee. So gas price times how much gas you used is the transaction fee. So whoever sent us this 0.1 ether also paid zero point 55, et cetera rink B ether to make this transaction. Now, each blockchain has a different way of actually calculating how this gas stuff works. So that's basically going to be the high level of it.
00:02:24.714 - 00:02:53.166, Speaker A: So we're going to focus just here for now. There's a total transaction fee, and then there's obviously the gas price. After we cover how blockchain works, I'll explain what this burnt stuff is, these gas fees and all these other stuff. For now, just know that anytime you make a transaction on chain, you have to pay a little bit of what I call transaction gas. So, for example, if we go to our metamask, we have two accounts right here. We have account one with 0.1 Rinkbeth and account two with zero Rinkby eth.
00:02:53.166 - 00:03:27.850, Speaker A: If I were to send 0.5 rinkbe eth from this account to my other account, how much Rinkbeeth do you think I'd have left? Well, let's go ahead and try it. This will be the first transaction that you're actually creating that you are going to spend the gas for. So if we go ahead and hit send, we'll hit transfer between my accounts. Count two, we'll do 0.5. Next, we can see some information here about what's actually going on. Metamask has some new advanced gas v UI and settings.
00:03:27.850 - 00:03:59.602, Speaker A: We're also going to turn this on. So go ahead and click that, enable enhanced gas UI, turn that on, and then go back. And again, this is going to be the experimental tab, but it could also just be in the general settings tab. Depending on when you actually run this, we can see a little notification here. Again, this depends on what version of metamask you're using. And we get this little drop down that says here are some of the different type of gas fees that you can actually pay. The reason that gas fees might change, as you can see here, is that depending on how busy the blockchain is, you have to pay more gas.
00:03:59.602 - 00:04:34.430, Speaker A: If a lot of people are sending transactions, that means there's not going to be enough space for everyone's transaction to get through. That's a bit of an oversimplification of what's happening, but don't worry too much about it for now. Now, if we want to send the 0.5 ether to our second account, we can see this gas estimated section, which it's saying it's estimating we're going to pay 0.4792 gas in addition to sending the 0.5 e. So at the bottom we have amount plus gas fee, and this is going to be the total amount that we're going to be spending on this transaction.
00:04:34.430 - 00:05:00.538, Speaker A: 0.5 is what we're sending. And then we also have this gas piece. So we go ahead and confirm. We now see we have a transaction pending in our Rinkbee Etherscan, and if we click on it, we can even hit view on block Explorer and a rinkby transaction hash will pop up. And depending on when you click it, it might say indexing. This means that Etherscan has received your transaction and is trying to place it.
00:05:00.538 - 00:05:25.870, Speaker A: If you don't see anything here, it means that maybe the transaction hasn't gone through yet. Maybe you need to wait a little bit more. Or maybe you need to go back to the GitHub repo and pick the recommended testnet and faucet. So you might have to wait a minute or so for this to actually finish indexing. After a minute or so, we can see that this transaction has indeed passed. And we can see a lot of the same information that we saw on our last one, this time with 0.5 ether.
00:05:25.870 - 00:05:59.082, Speaker A: And now if we look in our metamask, we'll see we can see account one has 0.5, it's rounding up a little bit. If we click on the big button, we can see it actually has 0.4953, et cetera. And our other account, account two, does have exactly 0.5. This is because we spent a little bit of Ethereum on gas to send this transaction. And now with just this little bit of information, you know, how to actually interact with applications that use the blockchain, how to send transactions, and a lot of the non technical details.
00:05:59.146 - 00:06:34.566, Speaker B: Now, here's something that's incredibly exciting. With just this little bit of information, you now know how to interact with blockchains and interact with the Ethereum protocol. So if you don't want to learn how to code anything, you can go and you can start interacting with Ethereum and interacting with protocols with just this much information. However, I know most of you guys are here to learn how to code. So let's look under the hood of Ethereum and what is actually going on with these transactions and with these gas and with these blockchains and what's really going on. Let's learn all the fundamentals of a blockchain. Now, if you want to just go ahead and jump into the coding, go ahead and grab a timestamp from the description.
00:06:34.566 - 00:06:56.862, Speaker B: However, learning exactly how the blockchain works is going to make you an incredibly powerful developer. So let's take a look at that first. So we're going to be going through this blockchain demo on this site right here. Now, the creator of the site has a fantastic video and a fantastic walkthrough. Blockchain 101. It is right on their site. So if you're looking for another explanation, definitely check out his video.
00:06:56.862 - 00:07:41.710, Speaker B: It is absolutely fantastic. But the first thing that we really need to do in order to understand blockchain, in order to sound really anything and everything that's going on here, we first really need to understand this Sha 256 hash or hashing, just kind of in general, let's first understand what a hash is? A hash is a unique fixed length string meant to identify any piece of data. They are created by putting some piece of data into a hash function. In this example, the hashing algorithm used is Shaw 256. Now, Ethereum actually uses this right here for its hashing algorithm, which isn't quite Shaw 256, but is in kind of this Shaw family. But it's really just another way to hash things. And the specific hash algorithm doesn't matter so much.
00:07:41.710 - 00:08:40.674, Speaker B: So this example uses Shaw 256, but you can imagine it's the same as the Ethereum hash. They're just going to result in a different hash. So what's going to happen in this application here is whatever data, or whatever information we put into this data section here, as you can see below, this hash changes. So what's happening is this data is running through this Shaw 256 hash algorithm, and it's outputting this unique hash. So this hash is a unique fixed length string that's going to identify, like, a blank data piece here, right? So if I put in my name, know Patrick Collins, this is the hash that's going to represent Patrick Collins, right. And you can see, even when you know, tons and tons of data in here, the length of the string doesn't change, right? So it's always going to be the same amount. We can put almost any amount of data in here.
00:08:40.674 - 00:09:12.038, Speaker B: There is an upper limit on the max size of the data, but for all intents and purposes, we can pretty much put any length in here. And you'll see, too, that every time I type in Patrick Collins, this hash is always going to be this seven, e, five, b. Right? I'm going to delete it. I'm going to do Patrick Collins again. Seven, e, five, b. This unique hash is always going to be unique, right? It's always going to be this fixed length string here. So now we can take this idea of putting this data in here, and we can move on to this concept of a block.
00:09:12.038 - 00:09:48.226, Speaker B: So with this block concept, we're going to take the exact same thing with this hash, this data section, right? But instead of having everything just be in this singular data area right here, we're going to split this data up into block nuns and data. So what we're going to do is we're actually going to hash all three of these to get this hash right. We're going to put all three of these. We're going to say all three of these are combined together. We're going to put every, all three of them into this hashing algorithm to figure it out. So if I type a bunch of stuff here, we can see that block one. With this nuns and this data, we're going to get this hash.
00:09:48.226 - 00:10:11.114, Speaker B: And as you can see, actually, the screen turns red. This block turned red. Now, what happens when I hit this mine button? When I hit this mind button, it's actually going to take some time. It's going to think for a little bit. And we can see that the nuns here actually changed. The nuns is different from what it was before. And this hash now starts with four zeros.
00:10:11.114 - 00:10:45.354, Speaker B: Okay? And then the back turned green. When we're talking about mining, we're talking about miners solving some type of very difficult problem that takes a lot of time to do. Now, in this example here, the problem that the miners had to solve was they had to find a nunce or a value in this nunce section that when hashed with at block number one with this data, it would start with four zeros. So the problem here the miners had to solve was to start with four zeros. And the only way for them to really do that is kind of this brute force trying stuff. So they tried one. Okay, one didn't work.
00:10:45.354 - 00:10:49.834, Speaker B: Okay, two. No, two didn't work. Three. No, four. Five. Six. Okay, five.
00:10:49.834 - 00:11:12.766, Speaker B: Well, that started with 10, but it's not four. And they have to keep trying all these numbers until they get to this one where. Let's hit mine again, where it has four zeros at the start. Now, this specific problem changes blockchain to blockchain. Right. Ethereum has a different problem for miners to solve. Bitcoin has different problems for miners solve.
00:11:12.766 - 00:11:48.346, Speaker B: But this concept is going to be the same. So they have to take one block, is going to be. This concept is going to be all this data. It's going to be the block number, and it's going to be this nunce. Right? And so this nunce is the solution is going to be the number that they use to get the solution to the problem. Right? So if I go to one here and I do this again, we're going to hit mine. And the nuns has changed, right? It went from one to 33,128, because this is the nuns that allowed this hash to start with four zeros.
00:11:48.346 - 00:12:12.646, Speaker B: And so that's what's happening when blockchain miners are mining. They're going through this process, this very computationally intensive process of trying to find a nunce that fulfills whatever the problem is. So that's really it, actually. So that's a block, and that's really what's happening. When miners are mining, they're just looking. There's trial and error, brute force trying to find this nunce. Now that we know what a block is, let's go to the next step and figure out.
00:12:12.646 - 00:12:48.398, Speaker B: Okay, well, what's a block chain? So here we have an example of what a block chain is going to look like, right? We have a combination back here. In the block section, we have what one block looks like. Now, here we have multiple different blocks, right? Each one of these represents a different block, but we have an additional column here. Or we have additional variable here. So, like before we have block nuns and data. Right? We have block nuns data, but we also have this thing called previous. Right? And so this is actually going to be pointing to the previous hash of the last block.
00:12:48.398 - 00:13:30.490, Speaker B: So, for example, if we go to the last block in this blockchain, it says previous is ae eight. And if we look at the hash of block number four, it's eight. And then we look at its previous, it's four zeros, b nine. We have four zeros, b nine and so on, all the way back to our first block, which has previous of just all zeros, right? And so the block with the previous of all zeros is going to be known as the Genesis block. So you've probably heard that before. The genesis block, it's the first block in the blockchain where the previous hash points to a hash that doesn't actually exist. Now, as you can imagine, kind of the same as how this block worked, how the block nuns and data all go through the hashing algorithm in the blockchain.
00:13:30.490 - 00:14:26.466, Speaker B: The block nuns data and previous hash all go through this hashing algorithm to figure out what the hash is. Okay, so if we go to. Over here, for example, if I type in Patrick, obviously this is now no longer valid, right? Because this nuns combined with the block, the data and the previous hash aren't going to solve our problem of having four zeros at the start, right? So I'm going to go and fix that. And that's kind of an easy way to see it being broken. But let's take a look. If I break this block right here, what happens if I break the data in here? If I do like Patrick in here, you can see that both of these are now red. Both of these are now invalid, right? Because the block hashed with the nuns, hashed with the new data, which is my name, Patrick, hashed with the previous block, is now a brand new hash, right? And this block is still pointing to this previous hash, right.
00:14:26.466 - 00:15:09.022, Speaker B: Here is pointing to this previous block, and now it is wrong and it is messed up. And now its nuns with this previous hash is also wrong. Right. And this is where, when we talk about blockchains being immutable, this is exactly how it's immutable. Because if I go back and I change anything, if I just typed a right here, the entire blockchain is now invalidated because none of these are going to have nunces that solve this equation anymore. So this is why blockchains are immutable, is because anytime you change one thing, you ruin the rest of the blockchain. Okay? So however, though, if an a was here originally, we can go ahead and mine these.
00:15:09.022 - 00:15:42.106, Speaker B: We can mine all these. But as you can see, this is going to start getting very computationally expensive because I have to go redo basically the entire blockchain. And the farther and farther down the line you get, the harder and harder it becomes to rehash and redo all these different, different blockchains here. Now, this makes a lot of sense, right? So we have this blockchain. It's really hard to change something in the past, but if we do, we can just go ahead and remind it. Now, if I'm the one who controls the blockchain, right? If I'm the one who controls this and I want to change something in the past, well, okay, great. All I got to do is change this data here and then mine each one of these.
00:15:42.106 - 00:16:17.026, Speaker B: Obviously, it's going to be very computationally expensive, but it's something that I can do, right, if I'm the one who owns the blockchain. Now, here's where the decentralized nature or the distributed nature really makes it incredibly powerful. So we're going to go to the distributed tab here, which I also refer to as the decentralized tab here. And it's going to show us what a blockchain looks like in a decentralized manner. So we have this exact same initial setup here. We have distributed blockchain. We have our first blockchain, which is kind of exactly as the one from here, but we also have more than one.
00:16:17.026 - 00:17:10.486, Speaker B: So we have peer a, peer b, and peer c. And when people are talking about peer to peer, peer to peer transactions, they're really talking. This is kind of that concept that they're talking about, right? So we have a number of different peers who are running this blockchain technology. They're all weighted equally, right? Each one of these peers or each one of these nodes, each one of these entities running a blockchain has the exact same power as anybody else. Right? So the way that we can tell very easily which blockchain is correct or which ones are correct are by looking at this end hash here, right? Or by looking at where we are in the blockchain. Because, again, remember. Because again, remember, this hash in this last block here is going to encompass all of the blocks from before, right? Because this last hash is going to have the previous hash here, which includes the previous hash here, which.
00:17:10.486 - 00:18:01.506, Speaker B: This hash includes the previous hash here. So this last hash encompasses everything in here, right? And we can look at the hash of peer C, which is four zeros, and then e, four b. We can look at the latest hash of peer b, which is four zeros e, four b, and then peer a, which is four zeros e, four b. So all of these peers, all of these nodes, all of these decentralized, all these independent users running this blockchain software, they're all matched up. It's very easy for their nodes to look at each other and say, hey, great, we are all matched up. Now, let's say that a decides that something happened on the blockchain that they didn't like and they wanted to go back and change something, right? So let's say they change here. Obviously, the rest of their blockchain is invalidated and they have to spend a lot of computational power to catch up to speed.
00:18:01.506 - 00:18:13.526, Speaker B: So let's go ahead and humor it. Let's say that they did. They ended up catching up. They ended up catching up. They ended up mining everything. And now they have a valid blockchain. Right? It solves the equation.
00:18:13.526 - 00:18:43.522, Speaker B: Awesome. However, in block number three, there's something new, right? This is here. And it shouldn't have been here. This is something that peer a put in by themselves. All that happens now is we look at all the blockchains that are running the software and we're looking at all the hashes at block number five. So peer a has this new hash now nine BC, but peer B has a different hash. E, four b.
00:18:43.522 - 00:19:09.866, Speaker B: Right? So who's right? Is it peer a with their new stuff, or is it Peer B? Well, that's where the decentralized network comes in, because then we can look at Peer C. And Peer C also has e, four b. So peer B and peer C both say, hey, peer a, you're wrong. Get out. Right. And peer a will stop being able to participate in the mining rewards because they have essentially forked the blockchain and started their own little blockchain. Right.
00:19:09.866 - 00:19:40.082, Speaker B: With their own history because they're the only ones with this piece of data in block three, whereas peer B and peer C have nothing in there. So that really shows why in these blockchain worlds, in this decentralized world, there really is no centralized entity. Peer a might have been maliciously motivated to change this. Block number three, however, democracy rules, right? The majority rules in the blockchain. Peer B and peer C both say, hey, that's cute and all peer a. But you're wrong, right? That's not. Right.
00:19:40.082 - 00:20:25.266, Speaker B: Now, it might be a little abstract that you just look at data and us typing kind of random stuff in here and think, okay, yeah, that's data, right? That makes sense. Just kind of random strings in here doesn't really do anything for us. So if we actually go over to the token section here, this is where everything really starts to make a lot of sense. So we have the exact same setup here with peer a, peer B, peer C. Except the difference is instead of having kind of this data section, we have this TX, this transaction section, right? And this represents all the transactions that are happening in this block, right? So we're sending $25 from Darcy to Bingle or to Bingley, $2.27 here, 1922. And it's the exact same thing.
00:20:25.266 - 00:21:11.362, Speaker B: So all these transactions are going to get hashed in the exact same way that the data is going to get hashed. And this is why it's so powerful. Because again, if I want to be malicious, right, if I wanted to say, hey, I really wanted to give Jane a lot more money from Elizabeth, so I'm puree and I go back and I change it to 100. Well, now, not only does my whole blockchain get invalidated, because that was so long ago, but I'm not going to match any of these other chains, right? And so my blockchain is going to be excluded from the overall. And let's go ahead and fix this. And it's the same thing if down here. If I become malicious and I want Miss Audrey to have less money, maybe I want to send a dollar and I go ahead and mine it.
00:21:11.362 - 00:22:26.570, Speaker B: The same thing here, this hash, now this two a one is not going to match Pier B's, peer B's hash of BBA, and it's not going to match Pierce C's hash of BBA as well. So the two of them are going to say, hey, your blockchain is invalid. It's not matching the majority, you're out, right? So that's really how these blockchains work. At a low level and it all goes back to this understanding this hash idea, and using it in this very sophisticated manner to kind of cryptographically prove where stuff lies. Now, the way the blockchain works is instead of random stuff put in this data section, it's actually going to be solidity code in here, defining ways to interact with different blocks and different protocols that are on chain, or as we've said before, different smart contracts. Now, the next question that you might be asking is, okay, well, how do I know? How can I be sure that I'm the is. Let's say I'm Darcy, right? How can I be sure that Darcy was the one to actually send this money here? How do we know that Darcy sent $25 to Bingley? Well, this is where we get into private keys and public keys, and that's what we're going to go into.
00:22:26.570 - 00:22:57.486, Speaker B: Now, let's just do a quick recap of what we've learned in this section so far. Right? We've learned that Ethereum actually runs on this kit, check 256, but we used Shaw 256 for this demo. It doesn't really matter. We're just talking about hashing algorithms. So again, a hash is a unique fixed length string meant to identify any piece of data. A hash algorithm or a hash function is a function or algorithm that computes any type of data into a unique hash.
00:22:57.678 - 00:23:10.338, Speaker A: Mining is going to be the process of finding the solution to the blockchain problem. In our example, the problem was finding a hash that starts with four zeros. Nodes get paid for mining different blocks, and the problem is going to be.
00:23:10.364 - 00:23:48.558, Speaker B: Different blockchain to blockchain. A block in a blockchain is basically a combination of a block nuns transaction and a previous hash to create this unique hash for this block. And again, depending on the blockchain implementation, this might have a couple of other fields, or might have different fields, but this is essentially what's going on. Blockchains are decentralized and distributed because many independent users are going to run this blockchain software, and it will check and it will compare against each other to see which blockchains are acting honestly and which ones are acting maliciously. In the blockchain world, majority rules. The nuns. Here is the answer used, or the number used to get this hash.
00:23:48.558 - 00:24:40.306, Speaker B: Now, nuns is kind of an overloaded term. It's actually used for a number of different reasons. In this case, we're using it to solve this problem of getting four or five zeros at the stop of the hash. However, in Ethereum, it'll also be often used as the number of transactions from a given address. So now we're going to talk a little bit about signing these transactions and private keys and some other cryptography pieces, right? Because in this blockchain demo here, we can see we have these fantastic transactions, right? All these things went through. But how do we know that it was Darcy who was the one to send $25 to Bingley, right? How do we know that actually happened? And this is where all those pieces that we just learned about in our testnet, in our metamask account, are really going to start to come to life here a little bit here. So here we have an example of public and private keys.
00:24:40.306 - 00:25:30.086, Speaker B: Okay? At the top we have this private key, right, that was randomly generated. A private key, as it kind of states, is a key that you really want to keep secret because you're going to be using this as kind of your secret password for all your transactions, right? I can really pick any private key, anything that I want, and with it, this algorithm, they're going to use an algorithm for Ethereum and bitcoin. They both use this elliptic curve digital signature algorithm. It's a variant of just a digital signature algorithm, and it's going to create this public key. Right. I'm really not going to go at all into kind of this digital signature algorithm, but just know it does use some of the hash knowledge that we just learned, combined with some other pieces, to kind of get this public key here. So I'm not going to go too deep into it.
00:25:30.086 - 00:26:01.406, Speaker B: But we have this private key that we create, and we get this public key now, this public key, we want everybody to have access to, right? Yeah. Whole world can see this. This private key, we really want it to be private. We don't want people to see this. We're going to use this private key as like a password to, quote, unquote, digitally sign transactions, and then people can verify them with this public key. So let's see what this actually looks like. Let's pick a random key, a more secure key, right? Because the longer it is, the more secure it's going to be.
00:26:01.406 - 00:27:01.694, Speaker B: And if we go to signatures now, let's say we have this message that we want, let's say high world, right? We want this to be the message. What's going to happen is this private key that we've created we can use to sign this data, right? Remember how in the blockchain demo we were hashing stuff? We were using this Sh 256 hash to get this hash? Well, we're doing something similar, but instead of hashing. We're using this digital signature algorithm to create this message signature. Now, what's really powerful about how this algorithm works is that you can create this message signature with your private key, but somebody else can't derive your private key from the message signature. And that's what makes this really powerful. However, if we go to verify using this public key, right? And so this is that 40 three, this is that same public key. Using this public key, anybody can verify.
00:27:01.694 - 00:27:38.910, Speaker B: Let's go ahead and sign it again. Anybody can verify that this signature is yours. Right? So you have a private key just for you, so you can sign things and a public key so that anybody can verify something, right? So anybody can verify this. And let's say somebody tries to fake a transaction from you, they say, hey, this is their transaction. All they have to do is verify that this signature against your public key. And very easily this whole thing turns red because it isn't verified, right. The algorithm says, hey, that's wrong.
00:27:38.910 - 00:28:40.786, Speaker B: So we can go ahead and take that into transactions in this exact same way. So if I want to send money, if I want to send $400 from my address to another address using my private key, I can sign that transaction and anybody else in the world can then verify this transaction. Right? And this is why when people say hide your keys, protect your keys, this is what we're talking about in our accounts here. If we go to settings. And again, the only reason that I'm showing you guys my mnemonic and my private key is because this is a dumpster account. I'm going to throw this away at the end of this video or I'm just not going to put any real money in it. But when we look at our metamask here, we have this mnemonic phrase which allows us to easily get these different private keys, right? So mnemonic phrase combined with whatever account number will get us a private key.
00:28:40.786 - 00:29:38.130, Speaker B: So mnemonic phrase combined with one, we're going to get this private key. And this is when we look at account details, export private key, password, confirm, this is going to be the private key that we're going to use to sign our transactions, right? If anybody else gets access to this private key, they then can sign transactions for us and they can send transactions for us. And that's why we want to keep these private. So it works the exact same way. Right? So this is why it's so important to hide your private keys and hide your mnemonics. Now, your Ethereum address is actually a piece, is actually a piece of your public key. Now, to get our address in Ethereum, all we have to do is take this public key that we've created with our private key, hash it using that same Ethereum hashing algorithm, and then take the last 20 bytes, and that's how we'll actually derive to our address here.
00:29:38.130 - 00:30:14.334, Speaker B: Now, knowing the exact methodology of how to get the address doesn't really matter because it could change blockchain to blockchain and could even change an e two. But just know that that is essentially how kind of these addresses are derived, right? There's some derivative of the public key, right? Because the public key is public and using the public key in kind of any public way is totally fine, but not the private key. So that is how we sign our transactions. Note though, this isn't how we send the transaction. So this is just going to sign it, create a transaction for us to send. We'll learn later on how to send these transactions. So that was a lot of information there, too.
00:30:14.334 - 00:31:02.606, Speaker B: Let's do a quick recap. Your public key is derived by using a digital signature algorithm on your private key, right? And you want to keep your private key private at all times because you're going to use your private key to sign transactions, signing transactions with your private key. You are the only one who can actually do this because you can't get the private key from a message signature. However, using your public key, anybody can very easily verify that a signature that's signed by you is in fact signed by you. In our metamask, our private keys are located in this account details section. You just hit show private keys and type in your password and you'll get your private key here. A quick note here is oftentimes when using your private key somewhere, they want it in hexadecimal form.
00:31:02.606 - 00:31:31.220, Speaker B: So if we're going to use our private key for something like Brownie, which we'll go into later, we need to actually append a zero x to the front, but we'll get into that later. And the address of your account is, is derived from this. So if you think about it, your private key creates your public key, which then can create your address. And there's a little barrier here, or a big barrier here because your private key you want to keep private and your public key and your address can all be public information.
