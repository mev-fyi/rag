00:00:10.260 - 00:00:39.410, Speaker A: Right about now just getting the stream set up. Okay, great. Hi. Welcome everybody. Welcome to this workshop. We're going to be making a simple defi app and we're going to be doing a lot of introductions to new tools here. So if been following along so far, a lot of the tools that we've built and we've used we're going to build on top of and we're going to do a lot of really cool things.
00:00:39.410 - 00:00:57.060, Speaker A: So strap in, let's do this. Get excited. This will be definitely like an open seminar type deal. So feel free to ask questions. There's the Q A feature. I'm monitoring YouTube as well. I'll be bouncing back and forth.
00:00:57.060 - 00:01:54.356, Speaker A: I'll try to stop at specific times, but yeah, feel free to jump in. So let's do it. So just to quickly show you what we're going to be building, this is a really simple example of a Defi application. So you've probably heard of yield farming before. You've probably seen a lot of the different stuff that people have been making. People have been coming out with a simple defi tool that a lot of people can make is basically some type of staking application, right? So you stake your dai, you stake your link, you stake your eth, you stake whatever token that you want and in return you get basically like a reward for using that platform. So like for example, your nut finance has Wifi compound, has the comp token and these different basically thank yous that are also governance tokens.
00:01:54.356 - 00:02:53.452, Speaker A: So we're going to be going over a simple example of that. For example, I have my mock die in my application here. I'm going to stake 1000, going to confirm and we're doing this on the coven testnet. And so once that finishes deploying we're going to see our staking balance update and we'll just give it a minute to actually finish deploying. And once it finishes deploying, our staking balance will update and then we can reward tokens based off of the usage of the platform. So something that we want to keep in mind, and this is where the important piece of Chainlink comes in is we want to reward them based off of their value. Based off of some value.
00:02:53.452 - 00:03:25.852, Speaker A: So we're going to be pulling in the chain link price feeds. And again, if you haven't been following along, definitely go check out like feeds, chain link and the documentation for these. They're super powerful, but we're going to be pulling in the chain link price feeds. There we go. My staking balance is updated. We're going to be pulling in the chain link price feeds to give reward based off the value. So now what we're going to do is we're going to issue tokens, issue the reward token to this platform based off of the value of die in USD.
00:03:25.852 - 00:04:28.004, Speaker A: So we can even pull that up. We can see what it should be Di USD. So it's $1.34. So if we calculate this, you guys can see my calculator, except for we're just multiplying by we should get 1034 reward token because we want to be rewarded in our die token in USD so you can't see it. But I just ran the issue token script and again, we're on the COVID network here, so we'll just give that a minute to update and then our reward balance should be updated with the new reward token that we were just given. So we'll hang tight. This is what we're going to be building and we're going to be using truffle, truffle web three, the chain link price feeds and a couple of other tools.
00:04:28.004 - 00:04:57.090, Speaker A: Open zeppelin as well. I'll go into what all those mean in just a minute. So it looks like the price changed, actually. But we got our reward, which our reward in our fake token called DAP token. And this is really powerful because then we can give people rewards based off of the value that they contribute to our staking platform. So that's really fun. And this is pretty simple to do.
00:04:57.090 - 00:05:33.570, Speaker A: So all the code for this, actually. So one of our judges and sponsors is DAP University. So a lot of the code from this tutorial is going to come from his video. So Defi project. He probably has the code in there too, somewhere. I think I have it here, actually. So if you haven't seen the video, definitely go check it out.
00:05:33.570 - 00:06:19.400, Speaker A: It's a super thorough explanation of how to actually build this if you want to check that out as well. We're going to be doing a couple of different things here, including like modifying some of the code, but this is some great starter code. And again, Daphne University is sponsoring. So if you're brand new and you want to get a course, definitely go check them out as well and apply to opt into their prize. Anyways, before we dive into actually building this, let's talk a little bit about some of the tools out there to build these projects. So two of the most popular ones to get started are truffle and buildler. Right? And so a lot of the workshops we've been given so far, we've been using remix.
00:06:19.400 - 00:06:55.924, Speaker A: And the reason we've been using remix is because it's really easy to kind of see how stuff works and get started very quickly. But as some of you have started to notice that following along here, sometimes it gets a little bit. There's a lot, there's a lot of clicking around. There's a lot of manual work that you have to do. Writing tests is kind of tricky. So buildler and truffle are tools that allow you to write these tests really quickly and get spun up really fast. So if you're brand new, I would definitely recommend checking out build alert.
00:06:55.924 - 00:07:20.272, Speaker A: Definitely recommend checking out truffle. These are going to be tools that help you out a lot. We are going to be focusing on truffle today. Truffle is a framework for testing. If you come to the site, this is the truffle suite. Their testing framework is called truffle ganache. We'll get into that in a second.
00:07:20.272 - 00:08:01.292, Speaker A: And drizzle is a front end because a lot of what we're doing is we're building these smart contracts for the back end. This is what's powering our applications. However, anybody who uses our stuff needs to be able to use it in an interesting way. And so we need to have front end so that they don't have to go into remix to actually use any of your code. So front ends are going to be really important. Doing front end development is going to be important, too, but we're just going to do some simple stuff because we're going to do some simple front end devs because we don't need to go too in depth for this workshop. So these are some tools that we're going to go over.
00:08:01.292 - 00:08:30.840, Speaker A: I did want to point out a couple other tools as well. This is Scaffold eth by Austin Griffith. He's actually one of our judges for this hackathon. It's a great way to get started on a full stack dap. On a full stack dap. And this uses buildler and ethers js, which is really cool. And so you can get a front end and a backend deployed very quickly.
00:08:30.840 - 00:08:54.104, Speaker A: And by backend again, I mean smart contracts. So if you want something easy to get a full stack dap, check this out as well. I also wanted to bring this up. This is a Paul Arberg solidity template. It's also using buildler. It's also a really nice template for getting just the backend of your smart contracts done. There's kind of some different methodologies.
00:08:54.104 - 00:09:17.590, Speaker A: Some people think that your solidity backend and your front end need to be in separate repos. Some people think it should be the same. It's kind of up to you. You definitely don't want one to have to depend on the other. So this is just a back end drizzle. Again, this is part of the truffle suite. This is for doing front end work.
00:09:17.590 - 00:10:34.336, Speaker A: And there's also create ETH app, which is for doing more front end work. So the solidity template is kind of the back end crate eth app is more for the front end. These are awesome tools to definitely check out to get started. So with that, I wanted to jump into some truffle pieces just to kind of introduce you to truffle before we get into actually building what we're going to be working on today. So I'm going to switch to my terminal real quick. 1 second it it just realized that I had not cleared out my workspace yet from testing. Okay, can you guys see that? Okay, cool.
00:10:34.336 - 00:11:10.716, Speaker A: So to get started, there's a lot of different ways to get started with your full stack dap here. So one of the easiest ways is to use a truffle box and what you're going to do after installing truffle and NPM. And you can install truffle with NPM. Install truffle g, that's going to install it globally, and you'll also need NPM. A lot of the blockchain community works with node js. There's also some python pieces like Brownie and stuff. But we're going to be focused on node js here.
00:11:10.716 - 00:11:46.436, Speaker A: So after you install truffle, you can run truffle unbox, smart contract kitbox. And what this is going to do, it's going to download a whole bunch and it takes a couple of minutes. It's going to download a whole bunch of basic folders and files for us to use. That will give us kind of a really nice framework for testing and deploying our smart contracts. And again for the back end. Right. And these are tools meant to make as developers our life a lot easier.
00:11:46.436 - 00:12:32.292, Speaker A: Truffle has a lot of nice pieces and frameworks for doing everything. So this is going to be kind of the standard chain link box, making that simple API request. It's going to be all scripted out in these files here. We're going to go over everything that goes in. And yeah, again, it takes a couple of minutes, but if you don't want to unbox, you can always just add it to whatever you're working on. Let me pull up the chain link docs and flip back over to that real quick. So while that's unboxing, you can always just also add it like this.
00:12:32.292 - 00:12:47.690, Speaker A: Chain link. Excuse me, NPM install or use it with yarn. You can use the open zeppelin starter kit. Actually, that's another really good one. Truffle box. There's a whole lot of different features. Again, we're just going to be focusing on the truffle box for now.
00:12:47.690 - 00:13:17.232, Speaker A: But yeah, it takes a couple of minutes, it seems takes a little bit longer than anticipated. But yeah, once we get in here we can do all that, all the deploy fund our contract, write scripts so that we can test and iterate really easily. We're finished deploying. Let's go back here. Cool. Unbox successful. Sweet.
00:13:17.232 - 00:13:50.588, Speaker A: Fun little play on words. Clear. And let's actually, I'm going to open up, let me just flip back. Going to open that up in my vs code. Now we're going to flip back. All right, cool. So now we're in our vs code.
00:13:50.588 - 00:14:12.852, Speaker A: Or again, whatever text editor that you want to use. We have our console here so everybody can see that as well. Awesome. So here is kind of the basic layout of truffle. And I'm just going to kind of explain what is in this unboxing for this type of setup. And again, you can use whatever setup that you want. This is just kind of a quick and easy one to get going.
00:14:12.852 - 00:14:54.400, Speaker A: So our contracts file is going to be really our main file that we're going to work on. I'll talk about migrations in a second. Is this big enough? Oh, that's massive. If this isn't big enough, somebody just let me know. We're talking about migrations in a second, but mycontract soul is going to be where we're looking to really get started. So this contract defines everything in that make an API call documentation. So you know how we deployed it? With remix, we make an API call.
00:14:54.400 - 00:15:37.264, Speaker A: There's a couple other functions in here, but this is all the code. This is all written in solidity here we can see we have our create request to function where we do. Hopefully this is looking familiar to you. Now we create this where we send a chain link request, right. Instead of hard coding everything here, we just have a whole bunch of parameters being passable so that we can just pass whatever we want here and get any URL that we want, which is really powerful. We have a couple of other really helpful commands as well. But this is all of our solidity code.
00:15:37.264 - 00:16:36.404, Speaker A: Now something else to mention you'll notice that the imports look very different than that in remix. That's because with node JS we can use this fun at syntax, whereas remix you have to import directly from GitHub. So that is something that will trip some new people up. That's just something to keep in mind. So this at syntax is for node js, the other syntax is for GitHub, and the GitHub won't work here, and the at syntax won't work in remix. So these are doing the same thing though as this at syntax is doing the same thing as a GitHub import, and the GitHub import is doing the same thing as the at syntax, only these ones we install with NPM install open zeppelin contracts or whatever, right? When we do our NPM install, which all the node modules are actually already here. So there you go, they're already installed with it.
00:16:36.404 - 00:17:12.652, Speaker A: Cool. So that's kind of just the layout there. Migrations are going to be basically how it's defined that we're going to deploy our smart contract. So you can think of migrations and deployments as kind of the same thing. If you ever worked with database migrations, it's the exact same thing. We can define in these migrations Javascript files how we want to deploy our smart contract. This is kind of a little bit more involved, but basically we're just deploying our chainlink smart contract.
00:17:12.652 - 00:18:14.630, Speaker A: So this basically just defines how to deploy mycontract Sol. We probably don't really need to go over it, but if we want to do more interesting things, if we want to do like another deployment, we just do three new migration js. And then in here, usually I just kind of copy paste. And then in here we could just do deployer deploy if we had a new contract, new contract Sol and then whatever parameters for the new contract. And the reason that you want to do this is because sometimes when you're deploying, sometimes you need to have contracts depend on other contracts, or maybe you need to script of a whole bunch of things to get them connected. That's what this is for. We probably won't get into governance at all, but when it comes to governance and working with interfaces, this is really good for that too.
00:18:14.630 - 00:18:45.656, Speaker A: Long story short, this is what defines how you deploy your contracts. Node modules is node modules, scripts. These are going to be things that you can run to make your life a lot easier. And they're scripts. So we have a script that's actually going to fund contracts for us. So you know how in remix we had to click metamask, copy the address of the contract, send it. We can just run a quick script to fund contracts.
00:18:45.656 - 00:19:24.170, Speaker A: We can run a quick script to request data and read data. So this is all really fantastic. And testing is kind of what makes the whole purpose of truffle in the first place. Running tests is what's going to, as you're developing, make sure that your contracts aren't doing anything silly, right? So this is going to be really important as you're building to test, because otherwise you're going to have to kind of manually keep doing stuff. There's a whole lot of kind of like baseline tests in here. You can check it out. We'll go into developing some tests in this demo.
00:19:24.170 - 00:20:01.908, Speaker A: We're going to skip over kind of explaining what this one is doing for now, but tests are really good. And then the other important package or file to look at is this one, truffle config. This is what defines all of your truffle features. And yeah, this one's pretty simple, but you can go to the truffle documentation to learn more about what's in here. Kind of the important pieces to look at are the compiler version of solidity is 0.6.6, so this is one of the newer versions. And our networks here.
00:20:01.908 - 00:20:50.688, Speaker A: So if we have like a local ganache running, we can connect to ganache here. We want to connect to a Covid network for this demo. So the first two things that we're going to need, hopefully you're becoming familiar with process emv. This is setting our environment variables mnemonic and RPC URL. Mnemonic is our wallet mnemonic and RPC URL is like our infura URL. So to get these in here we could do export mnemonic. This is where you do like Apple, banana, hopefully I can spell that, pear, blah blah, et cetera, et cetera.
00:20:50.688 - 00:21:30.364, Speaker A: Whatever your mnemonic is, you can find that really easily in metamask or whatever other wallet you're using. Just look for the docs on how to find the mnemonic. And then same thing, export RPC URL. I already had these exported, so I'm not going to, and this is going to be like www, dot, infira, infura, IO, Covid, whatever. So those are going to be the pieces that you need to get this going. Now let's go into some of the commands truffle compile. This is how we are going to compile our contracts.
00:21:30.364 - 00:22:01.256, Speaker A: And this is something that you're going to do a lot because you want to make sure that your contracts are even good. If I do some random stuff here, then I run truffle compile. It should not compile. Great. Truffle compile is working. Cool. So now we can play with actually deploying some of these contracts so we can do truffle migrate.
00:22:01.256 - 00:22:25.408, Speaker A: This is going to be the command to actually do everything. And we're going to do truffle migrate network live. So this is the flag that we choose our network on. We're going to use live. And again, that's defined here in our truffle config. We are using a coven RPC URL. So this should deploy to the coven network.
00:22:25.408 - 00:23:00.604, Speaker A: So if we hit enter, it's going to compile our contracts, it's going to start doing our migrations. And if we wanted to, we can open up etherscan and grab these transaction hass, grab the contract address, grab the account, and see everything we're saving migration to chain here. So great. So it looks like we actually deployed these. Let's grab this contract address. Pull up ether scan coven. I'll flip to it in a second.
00:23:00.604 - 00:23:27.930, Speaker A: I know you guys can't see it. Hopefully you can see it now. But you see, we just deployed this, right? So that's like a fantastic script that we can use to deploy stuff really quickly. Okay, let's flip back. Wish there was a faster way to flip back and forth. So we can also do go into what's called the truffle console. And this is like truffle console network live.
00:23:27.930 - 00:24:22.570, Speaker A: And this is like a shell for working with all the truffle pieces. So we can do let contract equals await my contract deployed. And we can just type in contract and it'll show us all the information about the contract we just used. We can do contract address. We see the address of the contract, which is what it just gave us in case you run through all of your, what am I trying to say? You clear out your shell and you can't remember what the address is anymore and you want to check up on it. You can find all that information here in the truffle console. So it's kind of like the truffle's magic to make everything work, which is really nice.
00:24:22.570 - 00:25:05.140, Speaker A: Clear. Um, great. So now that we've deployed our, our simple contract here, we can do truffle. We can fund the contract, and we're going to fund it with one of our scripts here. We're going to use this fund contract script. So we're going to do truffle exec scripts, fundcontract js. And again, we got to use network live and it's going to fund this contract.
00:25:05.140 - 00:25:54.950, Speaker A: And cool, it looks like it funded the contract. We could double check in the console, but we could also just come here in ether scan. We'll give it a second to see if it actually gets funded. Yeah, I have a lot of fake stuff in here, don't mind all my fake coven tokens, but it's actually pulling from this. It's going to send it one link and great, after refresh we can see we've actually funded it with one link. I want to actually make it fund way more than that because I know I'm going to be playing around with this a lot. So I'm going to update it to ten link and I'm going to fund it again just so I can send it ten link real quick.
00:25:54.950 - 00:27:03.406, Speaker A: It, cool. So now, again, just to give you the basic rundown of requesting an API, we're going to exec the request data, request data network live. And again, this is just literally, it's just going to be calling that request data method in our smart contract and we see all these parameters in here, and then let's even toggle word wrap. That makes it worse. Maybe I should, if I do this, is that hard to see? I just want it to be easy to see for you guys. Maybe let's undo, hello, whatever, maybe it formatted it. Oh, that's formatting.
00:27:03.406 - 00:27:44.670, Speaker A: Yeah. Okay. Yeah. Anyways, you can see this is where kind of the more important stuff this is kind of just setting the variables up here we're doing constmc equals await. Mycontract deployed literally exactly what we did on the truffle console 2 seconds ago. And then we're going to make this transaction by doing mycontract create request two, which again is one of the functions in our smart contract, create request two. And then we're going to input the parameters specified on the my contract, which is going to be the oracle address, the job id.
00:27:44.670 - 00:28:39.038, Speaker A: And we use a little web three magic to make this string a hex because the job id needs to be sent in bytes. The payment we send, the URL which we're defining here is again kind of the simple API here, then the path and then times, and then hopefully you guys have been following along, so you know why we need the path, the times and the URL. So enter, we're creating the request. Great, it looks like it was successful. And again, remember we need to wait for the chain link node to pick up this request, go get the data, and then split it back on chain. So we also have this read contract file, which is much simpler because it's just a view, right. We're just going to call mycontract deployed mc data call.
00:28:39.038 - 00:29:25.006, Speaker A: In my contract, we have the price of ethereum, and this is just called data. Actually, let's close some of these. We're just going to call data, right? And so call is, call is something that you can use when you have a function that's just a view, right? So data is technically a function, it's just a view function, right. So that's kind of how you can think of that. And again, view functions are functions that don't take any gas and don't cost any transactions. So I'm looking at ether scanner right now. It looks like it's just about done.
00:29:25.006 - 00:29:57.914, Speaker A: So hopefully our read, excuse me, read contract. Our read contract will actually give us something or it'll just spit zero. So we probably need to wait another minute or so for the chainlink node to finish making that request. But this is probably a good stopping point while we wait for that. So I'm going to answer a couple of questions here. Size is fine, thank you. Okay, great.
00:29:57.914 - 00:31:06.000, Speaker A: Part of my project is users making several contracts with each other think like upwork, freelance jobs. Is it usually better to manage all that state on one deployed solidity contract, or have users deploy multiple instances of a contract class? What factors should go into making that design decision? That's a really good question. So you have two decisions here, right? You have one is where your smart contract contains every single piece of data in it itself. Right. Versus having what's called like a factory design pattern, where you have a smart contract, deploy other smart contracts, and it kind of depends on what you want to do for that use case. It almost sounds like the factory smart contract pattern would be better. Now that I'm thinking about when, which one is better, in what situations is one better than the other? I can't think of specific ones, but for that situation in particular, I think the factory contract is better.
00:31:06.000 - 00:31:57.278, Speaker A: That's a really good question, though. So now let's try to read it. And we should have gotten a response, and we didn't get a response. Maybe we need to just request again because it is a testnet and sometimes things don't work. So we're requesting again. Hopefully this time it actually decides it wants to return data. If we flip back over to ether scan again, we can see 18 seconds ago was that request that we just made.
00:31:57.278 - 00:33:04.534, Speaker A: And for this, we just have it set up to be one link. But again, it can be 0.1 link, it can be whatever the node operator charges. But, yeah. Any other questions so far? This is some pretty standard truffle set up, and then we're going to jump into building that dap. Have you responded yet? No, you don't want to respond to me? Maybe you want to respond to me now. All right, well, something's going on with my demo here, but can you please give a quick recap in meantime? Yeah, sure.
00:33:04.534 - 00:33:32.590, Speaker A: So in the meantime, there's a lot of tools out there to help you get started. We're working with truffle here. Again. We have, our contracts are all going to be on our contracts. File migrations are going to demonstrate how to deploy your contracts. Node modules is just your node modules. Scripts are going to be these useful scripts that help you interact with your contracts.
00:33:32.590 - 00:34:12.890, Speaker A: For some reason, my read contract doesn't want to work. So sorry about that. I'll have to figure that out later. What is the purpose of migrations? Soul? Yeah, this sets up, it's the migrations file. Yeah, this is how truffle works with to know when to actually migrate stuff and when to upgrade stuff. Because when you do truffle migrate, it won't migrate everything. It'll just actually migrate everything you do truffle migrate reset.
00:34:12.890 - 00:34:38.946, Speaker A: And that's how you kind of force it to upgrade everything. So maybe I just do a truffle migrate reset, although I don't think that would work. Read contract. Maybe I did something wrong for the read contract, but I'll have to figure that out later. But anyways, we're going to jump to the debt. One more question here. Okay.
00:34:38.946 - 00:35:22.850, Speaker A: All right, so, cool. So, yeah, if you have any other questions, feel free to jump on. Sorry that that part didn't work, but let's jump into the DAp now building this Defi app. Now that we know what the purpose of truffle is, why we're using it, and kind of a couple of the tools to actually use it, we're going to be pulling from the starter code again from Dapp University's starter code here, which is really powerful. Let me flip back over to this clear. We're even going to make DRR. We're going to call it Defi hackathon workshop.
00:35:22.850 - 00:35:59.726, Speaker A: Defi hackathon workshop. And then we're going to do, we're going to clone a specific branch of this repo. We're going to clone the start code branch. This is how you can clone a repo from the starter branch up. I cloning remote branch start braid not found in upstream. Did I do something wrong here? Get clone b up starter code. Excuse me.
00:35:59.726 - 00:36:57.120, Speaker A: I think that was what's wrong. Okay, CD CD D five tutorial and we should be on the starter code here. Now we're going to do get checkout master branch. All right, great. So now we're in this master branch and I'm just going to open this up. So my vs code has everything just flip real quick. Demos, defi, hackathon, defi tutorial, flip back.
00:36:57.120 - 00:37:37.820, Speaker A: All right, cool. So now we're in kind of this starter code. And the reason we want to start with this is because it also does some of the front end pieces so we can actually work with it for us. We're going to focus more on just the back end stuff here. But the front end pieces are really important, obviously to get anybody to be able to use them. The pieces that we really care about are going to be in this contracts file right here. And actually before we even do that, we need to do Npm install.
00:37:37.820 - 00:38:21.766, Speaker A: We install the packages for it so we can actually work with it. Give that a second here. And I'm also going to show you ganache. What that is, what it's for and what it looks like. Yeah, hopefully 2 hours is enough. We probably won't have time to go over everything because, yeah, this is kind of a jam packed, like introduction to truffle, introduction to defi, introduction to ganache. But yeah, what we're going to be doing is we're going to be opening up Ganache.
00:38:21.766 - 00:38:51.474, Speaker A: So Ganache is part of the truffle suite. It's a tool that allows you to have a local blockchain. So what we've been working with before is Covid or is a testnet. Right. But we want to be able to test locally sometimes because we don't have to go find the faucet for the COVID the faucet for the faucet. We can just deploy and test locally. So Ganache is going to be something that we can do to play with this.
00:38:51.474 - 00:39:22.670, Speaker A: And I'm just going to show you kind of what it looks like. So you can go to the truffle website, download ganache. Once you do, here's basically what it's going to be looking like. You can see like here's the different addresses. They each have their own private key which you can upload into your metamask to actually work with it. It'll show you the blocks, the transactions. Let me update my location.
00:39:22.670 - 00:39:56.242, Speaker A: Let's remove this project. Let's add a project. And now we can see there shouldn't be any contracts yet because I haven't deployed anything yet. But we can see all the contracts and stuff in here. So this is kind of like a nice UI to work with your own local blockchain. Something that you need to keep in mind is that we're working with Chainlink. Chainlink nodes are monitoring the real blockchain.
00:39:56.242 - 00:40:28.818, Speaker A: So if you start making requests to your local blockchain, it's not going to be able to pick anything up. You can fork the main Ethereum chain into your local ganache. And the truffle deep dive next week is actually probably hopefully going to go over that, which will be really exciting. But this is for doing local stuff anyways. Cool. So we have NPM installed. Let's go over what we want to do here.
00:40:28.818 - 00:41:08.400, Speaker A: So in our contracts we have these two tokens that we need to define. Now, these are ERC 20 tokens and this code in here is kind of like the boilerplate for an ERC 20. So you might have heard ERC 20 a lot in the past. ERC 20 just means it's like a framework for building a token. It just means, hey, they have this transfer function, they have this approval function, they have this balance of. It's just a way of a framework saying, hey, here's what it should look like. So in this starter code, there's all these functions that get these two actually started.
00:41:08.400 - 00:41:40.934, Speaker A: I am going to do a couple of things, actually. I want this to be, I want this to be v six. I want to use the latest and greatest. So I'm actually going to update these all to v six and we need to build these. This is going to be our mock die token so that we can stake on our platform. This is going to be our Dap token, which we're going to reward them for using. And then again, we have our migrations file.
00:41:40.934 - 00:42:30.540, Speaker A: So again, if I hit truffle compile, it might error out, it'll actually definitely air out. And you'll see this truffle is currently using SoC 0.5.16. We can actually fix that pretty quickly, but just by adding version two right here. So now it'll update so that we're using. We also want to, excuse me, something that you'll notice too is you'll have to delete. Where is it? It's an Abis. Oh, there's another one using this.
00:42:30.540 - 00:42:47.198, Speaker A: Did I not save I didn't save. Okay, never mind save. Now it works. Now we can truffle compile. Great. And they're all compiled successfully. And you'll see this Abis file gets made.
00:42:47.198 - 00:43:29.706, Speaker A: Abis in truffle, it's also known as artifacts, and it's the Abis of our smart contracts. Abis are the piece that we need to interact with any contract. Whenever you want to interact with another contract from inside your contract, you need its ABI and its address. So this just deploys our abis here so we can actually work with them. So when you hit truffle compile, it updates these. If you ever have an issue where it's being confused and it's being confused and it thinks something really weird is happening, you can just delete this file. Delete this file.
00:43:29.706 - 00:43:57.222, Speaker A: Excuse me? Delete, move to trash. And then you can just recompile and it'll re add those to the AbI's file. Cool. Boom. Awesome. So what do we want to do here? So we want our mock die to be able to be sent to be transferred into our platform. And this is kind of the boilerplate code.
00:43:57.222 - 00:44:37.380, Speaker A: To do this, I'm going to change something here to show you guys. It's even easier than this to get your ERC 20s deployed. So this by itself is a way for you to actually, like, you can make your own token right now. And it's super easy because all these tokens, chain link, bat, comp, die, they're all eRC twenty s, and they fall along this eRC 20 standard. So they all have the same functionality. So we probably should have a package that gets them all in for us. So we're going to use this.
00:44:37.380 - 00:45:07.820, Speaker A: Me. Let me just even delete everything. We'll just build it from scratch. We're going to be using the open Zeppelin package to make our DAP token because it'll make sure we don't mess anything up. Right. It's a really powerful package that we can use for our application here. So we're going to import this open zeppelin package, and then we're also going to need to install it here.
00:45:07.820 - 00:45:58.840, Speaker A: So do NPM install open zeppelin contracts. And this way we don't have to define all those functions ourselves. It'll just come natively with its ERC 20 sol, something to note you'll probably see, like, ERC 20 detailed. That was v two of open Zeppelin, where you're using the latest and greatest here, where they bundled everything together. Now we want to make our contract. DAP token is ERC 20 again, this is the inheritance of solidity here, and we're going to set up the constructor public ERC 20. Oops, did I do that right? Yes.
00:45:58.840 - 00:46:38.514, Speaker A: No, I didn't do that right. What do we want to do? We're going to give the name and the symbol dap token and also the app, and then we're going to give it the initial supplies with this mint. So we're going to send it. I see a bunch of questions. You're on ganache terminal. Okay, sorry, we're not. Let me switch.
00:46:38.514 - 00:47:17.634, Speaker A: Sorry about that, guys. No, wrong one. Can you guys see this? Sorry about that. I can go back over it. Okay, yeah, sorry about that. Let me just undo everything. How much did I miss? How much did I go over? I probably didn't go over too much.
00:47:17.634 - 00:47:52.330, Speaker A: Did you guys see me compile and delete the Abis? Right? You saw that? No, you didn't see that? Okay. No. Okay, sorry about that, guys. Thank you for bringing that up. See if this compiles. Okay, so you can use truffle compile before, if you didn't see this, these were version five. And if you do truffle compile with different versions, you're going to get this error.
00:47:52.330 - 00:48:14.882, Speaker A: I went into my truffle config, switched it to six. I guess I should look at the chat more. I just switched it to six. Just added this in here and changed all my three tokens here to v six. Right. And now I can do truffle compile. And this is going to compile all my contracts for me.
00:48:14.882 - 00:49:11.670, Speaker A: So, great, so they're all compiled and great, so again, this is some simpler boilerplate code to get your ERC 20 tokens going. And again, an ERC 20 token is just literally defining, hey, this is what the functions of an ERC 20 should look like. We can go ahead and just make this even easier by using open Zeppelin's package because that way we don't have to define any of this and we can be sure we're not going to mess anything up, right? Because we're going to use open Zeppelin's package to deploy these. So we import it right here. And if you guys didn't see it, we also need to install it like this. What happens if I install it twice? It's going to be fine, right? No, js, please. And then while it's installing, we're going to define our contract dap token.
00:49:11.670 - 00:49:50.340, Speaker A: I could also use yarn. Yeah, yarn, please. Contract DAP token is ERC 20. And this is, again, is the inheritance. So we're inheriting everything from this ERC 20 package which has all these functionalities because again, this is also an ERC 20 token. This die token, which we'll fix this one in a second too. It just doesn't have the name or the symbol, right? So contract DAP token is ERC 20 constructor public ERC 20.
00:49:50.340 - 00:50:18.646, Speaker A: We're going to call it depth token, comma d Dep. And this is where you just give the name of it. So we're calling it depth token. And then we can even see this in ether scan. And the symbol is going to be Dep. And then we mint the initial supply. So we're going to mint.
00:50:18.646 - 00:50:49.234, Speaker A: So this is how we started out. You could also do like Un 256 initial supply or whatever. We're just going to hard code it for now. And we want to say, hey, we only want 1 million DAP tokens, so we're going to do this for that. Which again, this looks like a massive number, but you got to remember everything on Ethereum is in way. There are no decimals here. So this is actually 1234-5678-1234-5678-9 ten.
00:50:49.234 - 00:51:11.020, Speaker A: You can look at it and see that it's in fact a million. Right? Just keep that in mind. Like just add 18 zeros. 1234-5678 910, 1234-5678 so great. So our initial supply of our DAP token is going to be a million tokens. Cool. And then we can do the same thing for our die token here.
00:51:11.020 - 00:51:38.914, Speaker A: Literally the exact same code. We just change a couple of things, do die token, and then we'll call it. What did I call it on my last one? Call it mock die token. Give it MDI for the symbol MDI. And we're also going to mint. Let's mint a lot more. Actually, no, let's just keep it the same.
00:51:38.914 - 00:52:00.810, Speaker A: Why not? So we're going to mint this. So this one will also have a million. So there will be a million of each one. And these are our contracts to start. So let's truffle compile. Got an issue here. Expected a semicolon.
00:52:00.810 - 00:52:33.126, Speaker A: Truffle compile. Did the other one also expect a semicolon? Probably, yes. Whoops, something else. So probably requires different. Oh, sorry, I actually need to make this 0.6 because 0.6.2, I think the import requires 6.2.
00:52:33.126 - 00:52:49.130, Speaker A: That's why it needs that. Okay, so we just update this to 6.6. Or we could even do 6.2. I'm just going to use 6.6 because I know there's a lot of stable stuff in 6.6 truffle compile and great, we are all set to go. Cool.
00:52:49.130 - 00:53:17.220, Speaker A: So our DAP token and our die tokens work great. And I'm going to briefly look at the questions here. There aren't any questions. Fantastic. Let's deploy this. Now let's figure out how to deploy these. So over here we have our, I got to speed this up.
00:53:17.220 - 00:53:48.160, Speaker A: We're going to do deploy contracts JS because again, right now we don't have a way to actually deploy these. Right? If we do truffle migrate, I think we're just going to get an error. Oh, actually I have ganache running. Never mind. So it's actually just going to run, just going to run this and yeah, that's all it ran. So nothing's actually going to happen. Let me actually make this an intelligent thing.
00:53:48.160 - 00:54:52.562, Speaker A: Deploy contracts JS and let's figure out how to deploy these so we can do const DAP token equals artifacts to fax require depth token. And remember, artifacts is just grabbing from our abis. So we have our DAP token in here. This is some truffle magic. We're saying, hey, grab that DAP token. We'll do const diet token equals artifacts require die token. And we're going to do, yeah, now we're going to do the kind of boilerplate module exports equals async function, just some deployer plate to actually start deploying stuff.
00:54:52.562 - 00:55:34.574, Speaker A: Deployer network accounts. And these are going to be the network to start is actually, we're just going to use our ganache just to start playing around and testing with these. We're going to use Ganache. And let me actually switch over to Ganache real quick to show you what it currently looks like. After I ran that initial migrate script in our local blockchain, we have our migrations file contracts. We have a migrations contract deployed, but not DAP or die. And the reason we don't have them deployed is because we didn't have it in this deploy script.
00:55:34.574 - 00:55:55.506, Speaker A: So this time I'm going to remember to actually go back. Okay, cool. Grab a couple of questions. Extension for second file. Yes, thank you. JS, not js apostrophe. Yeah, so now we want to actually deploy our contracts.
00:55:55.506 - 00:57:48.438, Speaker A: So we're going to do await deployer, deploy Dietoken because it's an async function here and then const die token equals await dietoken deployed. This is how we're, this is how we're actually going to deploy our die token and our DAP token here and then. Yeah, that's what we're going to do. So this will deploy it to our local blockchain again because when we're running truffle migrate, you saw how before we did truffle migrate network live, that was how we connected to Covid. This doesn't have anything specified, so it's just going to do our default which is going to be our local blockchain, which I have set up to be ganache at the moment. So let's go back to deployments. So now if we do truffle migrate, I will have an error.
00:57:48.438 - 00:59:03.302, Speaker A: Cannot access DAP token before initialize. What did I do wrong here? DI token die token deploy to deploy something with my case sensitivity probably. Okay, let's deploy, deploy depth token it. Did I mess something up here? Capital letter. Yeah, I figured it was a capital letter, but where is my capital letter? Is that it? No. Is that right? It's probably right. Right? Yeah.
00:59:03.302 - 00:59:43.220, Speaker A: Okay, cool, thank you. So cool. So now we deployed our depth token and our die token because we defined it in the script. Now if we flip back over to our local ganache, we can see that we now have an address for our DAP token and our die token. Now I want to go over tests because this is kind of one of the main things. That is why using truffle in the first place is writing these tests. But I'm just going to kind of speed through it actually because we're not really going to have a ton of time.
00:59:43.220 - 01:00:46.118, Speaker A: But when you're doing these you can also do like a new file or, excuse me, you want to make a new folder, test folder. Then in here you can define your tests to make sure things are actually going to be good. We're gonna call it new file tokenfarm test js and we're gonna do some, I'm just going to dump some, some boilerplate code in here. Yeah, I'm just going to dump some boilerplate code in here like really fast. Maybe I won't actually. Yeah, I think I'm just going to skip tests for now. If we have time at the end we'll go over tests, but they're really good because for building all this stuff you're going to have to constantly be checking to see.
01:00:46.118 - 01:01:28.706, Speaker A: Okay, did this do it right? So you really want to do tests while you're building these you can check out. I'm going to put the GitHub for this with more tests. I'm in the Ganache window again, thank you, thank you for that. I'm going to put the GitHub for this for both the DAP university code and the updated chainlink defi project code in the events. And we're probably going to have a blog and a blog coming out for this project as well, so stay tuned for that. We're going to skip tests for now, but please don't skip tests. It's really good to write tests anyways.
01:01:28.706 - 01:02:21.270, Speaker A: So we have our main contracts here, but we need our token farm contract. Token farm, token farm Sol. So this is going to be where am I in Ganache again? Oh no, I'm back now. Right, all right, I'm back. So this is where we're going to find all the functionality of our staking contract. This is going to be our yield farming contract. So again we're going to start with some boilerplate pragma solidity right here and then we're going to import, we want to be able to use these tokens.
01:02:21.270 - 01:02:48.414, Speaker A: Actually let's just open these. We want to be able to use these tokens. So the way that we can use them in our other smart contracts is by using their interfaces. So we're actually going to open. Zeppelin has a great way of working with this, with this IErc 20 soul. And what this file defines is the interface of the token. You can't actually import them like this and use them.
01:02:48.414 - 01:03:43.470, Speaker A: You have to actually import the interfaces because if you import the whole token it'll be confused, it won't know what you're doing. So we import the interface and I'll show you how to use that in a second. So now we're going to do our contract token farm string public name equals let's give it a name, DAC token farm. Then we'll do its address which will be public, the owner address which will be us. And now we're going to do IERC 20 public depth token. IERc 20 public die token and we'll get into how to use these in a second. So just to kind of get into it, let's do a constructor.
01:03:43.470 - 01:05:00.060, Speaker A: And I know that when I deploy this we're going to need to know the address of our DAP token and the address of our die token so we can actually use them. So we're going to pass the interfaces of our DAP token address, IRC 20 die token address and this is going to be our public constructor here. And inside we're going to do DAP token equals IERC 20 and this is how we actually can work with other ERC 20s inside of our smart contracts. We give it the address and we give the address to the interface and that's how we can actually work with this. So I ERC 20 depth token address. Um, and then die die token equals IERC 20 underscore die token address. And then we'll set our owner here.
01:05:00.060 - 01:05:22.640, Speaker A: Owner equals message sender. Okay, cool. Quick truffle compile. Cool. Stuff works. So this is kind of the beginning of our application here and we have like an hour left. So I got to really rip through this.
01:05:22.640 - 01:06:33.910, Speaker A: So what do we want to do here? We want people to be able to function, stake tokens. Probably a un mount, right? What else do we want them do we want them to be able to stake tokens? Let's think. We probably want them to be able to unstake tokens. We want to be able to issue our reward token. So we're going to call that function, we're going to call it issue tokens public. And then we're also going to want to function, we want to get the die USD price, which will be a view function. It's going to return a un.
01:06:33.910 - 01:07:16.440, Speaker A: So these are probably going to be the functions that we want it to do, right. We want our users to be able to come in stake token, unstake their tokens, get them back. We want to issue them this reward token, our DAP token, and we want to be able to get the DaI USD Price so that when we issue tokens, we can issue them based off of an actual currency here. So these are going to be the functions that we're going to go into. Hopefully I can rip through these quickly. And again, when you're doing this, you really want to be doing tests as well. In the interest of time, we're just going to kind of rip through it.
01:07:16.440 - 01:08:07.890, Speaker A: How would they stake tokens? So first we would probably want them to stake more than zero. So we're going to have them require amount is greater than zero, amount cannot be zero. And now we are going to want to transfer from, we want to transfer their die token to stake it. So for this one we're only me be focusing around staking die tokens. But you can get any ERC by just getting its address and popping it right here. We're just going to use our mock die for the moment. So we're going to use dietoken transfer from message sender address.
01:08:07.890 - 01:08:39.306, Speaker A: I'm going to explain what this does in a second. Address this and amount. So because it's an ERC 20 token. We know it has this transfer from functionality. And again, you can go to open zeppelin and see what all these ERC 20s have for their main functionalities. And we're going to say we're going to transfer from the message sender, which is the person who called this stake tokens method. And we're going to send it to this smart contract, which is our token farm smart contract.
01:08:39.306 - 01:09:04.210, Speaker A: We're going to send it to this smart contract. And with this amount. Right. So that's how we send it in. And that's pretty much how we send it in. Now we need to keep track of how much they've sent in so that we can issue them reward accordingly. And when they unstake, we know how much they unstake.
01:09:04.210 - 01:09:58.120, Speaker A: So to do that, we're actually going to have to do a couple of things. So we want to have a list of stakers, and then we want to have a mapping of those stakers addresses to a un of their staking balance. Balance. We also. We're going to need these too. Um, need the address to the boolean has staked. We're going to need these as well.
01:09:58.120 - 01:10:23.760, Speaker A: To another boolean public is staking. And remember, a lot of the code for this, a lot of the code is from that DAP university tutorial. So definitely go check out Dap University. Definitely check out everything that they do. We're making just a lot of kind of more. We're chain linking it up a little bit. So definitely be sure to check that out.
01:10:23.760 - 01:11:02.570, Speaker A: But we're going to need these. These started out, and now we can go to our staking. Um, we're gonna do staking balance of. Since we're doing a mapping here, we're gonna take the staking balance of the person who just sent it in and we're gonna update it. So now we're gonna do. We're gonna update their staking balance with the amount that they sent in. So we're going to do staking balance.
01:11:02.570 - 01:11:47.930, Speaker A: Their staking balance is equal to their staking balance, which will initialize a zero plus the amount that they just added. And this way we can keep track of it. Now we want to keep track of if they're staking or not. So if they haven't staked. Again, this is a mapping message sender. We're going to push them onto our stakers array. And the reason that we want both a stakers array and a mapping is because in solidity, you can't actually loop through a mapping like you can like in python, technically in a mapping, every single address exists.
01:11:47.930 - 01:12:39.746, Speaker A: So if you were to loop through a mapping, you would loop through every single address, which would be insane. So every single address exists in a mapping in solidity. So we also want to have this array so that when we go to check who is staking, we don't have to loop through every single address in existence, which would be impossible. So we're going to push it on, we're going to update it. Is staking. Sorry, there's some construction going outside if you guys can hear that. True is staked, excuse me, has staked truffle.
01:12:39.746 - 01:12:59.294, Speaker A: Compile it. And cool. So it looks like we're compiling. And this is why you really want to write tests though because we're not even sure that this is actually going to work. So you really want to write tests. But I'm just going to kind of rip through. So unstaking.
01:12:59.294 - 01:13:40.830, Speaker A: I'm actually just going to copy and paste to do the unstaking because I want to be able to show you guys the chain link feature of it. So we're basically just going to do the opposite. I'm literally just copying and pasting from my finished code. Um, that way we can kind of go a little quicker here. But yeah, we get the balance of the user from the staking balance. We require that they actually have to have something in here. And then we transfer, we give the balance back to the sender.
01:13:40.830 - 01:14:26.986, Speaker A: Something that's interesting is all your tokens are really just like a value in this die token smart contract, right? So everything is actually stored on there. So when we do this transfer function, it's actually getting updated in our die token smart contract. So that's something that's pretty interesting. Undo that tool. Okay, cool. So now we're going to do our issue tokens bit. So this is where we are kind of doing our more interesting piece because we want to issue tokens, but we don't want to issue any token based on whatever, we want to issue it based on the value of the dai.
01:14:26.986 - 01:15:33.730, Speaker A: So maybe we want to give them for their total assets in USD, we want to send them a reward token. This way if we update our application to take other forms of staking like link, USD, eth, we can actually send them tokens based off of the total value that they have instead of just how many tokens that they send in here. So we want to be able to issue tokens based off that. So we're going to set this up. So we're going to require a message sender equals equals owner comma caller must be owner. We're going to say that only the token farm who runs this can actually issue these rewards tokens. So this is what this says.
01:15:33.730 - 01:16:47.786, Speaker A: And now we're going to actually issue tokens to our stakers. So we're going to do four un I equals zero I is less than stakers length I plus plus going to get the address recipient equals stakers I. So we're going to get the address of the staker who's staking again. We're looping through all of our stakers here. We're going to get the UN balance equals staking balance recipient. And then we're going to say if they actually have a balance, if their balance is greater than zero, then we're going to send them our reward. However, we want to send them the reward based off of the Dai USD price.
01:16:47.786 - 01:17:36.252, Speaker A: So we're going to do. I haven't seen those four loops in a while. Yeah, right. So we're going to do Daptoken transfer recipient and the amount that we're going to send them is actually going to be. We're going to call a function called get. Actually, let's just call it get. What do we want to call it? Calculated amount.
01:17:36.252 - 01:18:17.024, Speaker A: Call it get calculated amount. And this is going to be based off of their balance. So I have this get USD price. We're going to call it get calculated amount and then we're going to take a UN 256 balance and we're going to figure out how much do we actually want to send them. How many tokens do we want to send them. So the way that we're going to do this is we're going to flip back over. And then if I forget to flip back, just let me know.
01:18:17.024 - 01:18:53.212, Speaker A: We can go over to the chainlink docs and we're going to go to our price feeds. So the price feeds again is this incredibly powerful, decentralized way of getting the price of different assets. So the code is really simple. We even have some web three pieces again if we want to use it. Since we're doing it in our solidity contract, we can just look here and in here. It even has the node JS syntax for us to use. So what we're going to do is we're going to copy and paste it over.
01:18:53.212 - 01:19:50.464, Speaker A: Don't worry. I know that we can't see me pasting it in, but I'm just pasting this at the top and we can literally grab the rest of this code and I'm literally just going to grab it, pop it into my method and I will flip back in a second and then we're going to edit. It's my flip back. Can you guys see me? Can I see me bouncing around? Hopefully you can. So this obviously isn't so I copied the import at the top. We import our aggregator V three interface. This is going to be how we're going to work with our price feeds here and we're going to figure out how to calculate the amount.
01:19:50.464 - 01:20:28.604, Speaker A: And I just kind of dumped a bunch of stuff in here so this isn't going to be any good. So this is for eth USD coven. Let's just clean this up for a second. Hold on. Sorry. I'm like just kind of stripping away some of the piece that didn't make sense right. Because I pulled in like a function and a constructor and a whole bunch of other stuff and I just said no I don't need any of that.
01:20:28.604 - 01:21:09.208, Speaker A: I just want it to be in our calculate price here. So let's even format it a little nicer. Can we actually do toggle word wrap? Thank you. Cool. So again we have our aggregator interface price feed which pulls this address in and then once we have our price feed here we can compile it. We can get the price with this method from the aggregator interface. Get latest round data.
01:21:09.208 - 01:21:36.530, Speaker A: So this will return all these values but we only care about the price so we're only going to return price. Something you'll notice here too is price is int. So we actually want to wrap it in a uint and just to see where we are. Let's even just do a truffle compile. Got an issue. Expected this but got that. Cool.
01:21:36.530 - 01:21:53.980, Speaker A: Add the semicolons in. Those are important. Looks like we got another issue. Interface internal. Oh sorry this cannot be internal. We can just do public here. Can't be internal.
01:21:53.980 - 01:22:50.464, Speaker A: This is a public view so we need this to be public too. There's another one we just expected but got do we just do this? Looks like yep we just do that. Cannot find chainlink contract I need to install this. NPm install chainlink contracts because it can't find our aggregator interface. These are some of the issues that you'll bump into as well. So I'm glad I'm bumping into them to show you guys that you will bump into them. Let's do tropical pile.
01:22:50.464 - 01:23:14.512, Speaker A: Probably should have done a tropical pile earlier to make sure everything was good and cool. So we have a couple of warnings. We're saying hey this hasn't been used. This hasn't been used, but that's fine. All of our files are compiled successfully. So great. So this still doesn't give us what we want, right? So this just returns the price and we want to get this calculated amount.
01:23:14.512 - 01:24:14.790, Speaker A: That's going to depend on how much value that they're putting in in our token farm, not just how much tokens they're putting in, how much value they're putting in. So again, I'm going to flip back over to brave browser here. And remember, feeds chain link, we want to get Di USD. So this here again is the Di USD price. So we know, like, if they send in 1000 mock die, we're going to reward them with 1034 DAP token because we want to reward them for their value, not just for the number of tokens. So we need to get this price feed into our contract. Now, since I know that I'm going to be testing on coven what I can do.
01:24:14.790 - 01:24:40.124, Speaker A: Price feed contracts. Let's look for die USD. Die USD. And this is going to be the main net one rinkby is this coven. Coven. Okay, so I know that this is what we want. So let's flip back to have like a million tabs open.
01:24:40.124 - 01:25:43.810, Speaker A: So it's like a little tricky for me to this one. What are you sharing? Is it this one? What's this one? Right, okay, cool. So I know I want to put that address here, right? We want to get the address of Di USD here. And something else that I know because I've done this a lot at this point, is I know that the die USD price feed has eight zeros as opposed to 18. So I actually want to get those extra zeros. So I'm going to do times ten raised to the power of ten. So this is just so that everything's standardized with 18 zeros and I don't have to worry about anything.
01:25:43.810 - 01:26:25.630, Speaker A: And you could check it out by pulling this data and, like, remix or something. I know it is eight zeros and I want it to be 18, just so everything is 18 zeros. And you're going to see why in a second. Because dividing is a little tricky in solidity, because, again, you can't divide, you can't have decimals, so you got to divide by whole numbers. So this is just returning the price. Let's even just do price equals. Let's call it.
01:26:25.630 - 01:27:15.496, Speaker A: Actually, no, let's call it calcuint 256 calculated amount. It's my python syntax. Coming in is going to be equal to this. And we want to multiply the balance times this price. And then we want to divide actually by those 18 zeros, right? Because again, we can't get any decimals in here. So we need to multiply those two together and get this massive number and then just divide by the 18 zeros. And we can do that since they're both denominated with 18 zeros.
01:27:15.496 - 01:28:04.700, Speaker A: And then we're just going to return, oh, just this please, calculated amount. I'm going to do a quick truffle compile and. Great. Okay, cool. So now we know we can issue tokens depending on the value that they've locked in. And this is great because now we have a way of, if we wanted to expand our platform to do more tokens like link, bat eth, whatever, we can reward them based off of the value of their token, which is really powerful here. So that's pretty much it for the token farm.
01:28:04.700 - 01:28:40.010, Speaker A: Now what we have to do is we have to deploy it. And I might skip ahead some of the writing up the code because we're running short on time. Where is my migrations? So in here. Um, we're gonna rip through now. Await deployer. Actually, I'm just going to copy paste because we're running short on time. We're not going to be able to do any of the front end stuff.
01:28:40.010 - 01:29:22.070, Speaker A: Deployer to deploy again, our token farm, we need to const. Token farm equals artifacts require token farm. And again, we can see that in our abis. Now we now have the token farm in here so we can use it. Great. Deploy to deploy token farm. Now we want to do await Daptoken transfer Tokenfarm address.
01:29:22.070 - 01:29:56.844, Speaker A: You'll see why I'm doing this a second. And we're going to send it all, everything. So we want our token farm to be the sole benefactor of having all of the DAP tokens in the beginning. So we're going to do DAp token transfer, send everything to Token Farm. And this way the token farm in the beginning is the only one that's going to be able to send these reward tokens out, which is what we want. So we're going to send them all out. And we can also send some mock die die token transfer accounts.
01:29:56.844 - 01:30:23.208, Speaker A: One, this is going to be your second account, metamask. We're also going to send it a whole bunch of diet. So now I'm going to show you that this isn't quite going to work. Truffle migrate reset because we have a new thing that we want to deploy. Oh, maybe it will work. Just kidding. It will work.
01:30:23.208 - 01:31:01.696, Speaker A: But it will work. But we can't actually get the price feed because this is an address on the real Ethereum chain and we just deployed it to our local blockchain. So I'm even just going to show you ganache and then I promise I'll remember to flip back. Now we have our depth token here. And again you can see some really cool stuff. This is on our local blockchain, which is great. We want to now test this on a real, on a real network.
01:31:01.696 - 01:31:37.744, Speaker A: We want to test it on Covid. So again, remember, how do we do that? Well, this networks in our truffle bit is how we define our networks. Right? So we want to add in here, we want to add in here our coven bit. So I'm going to cheat a little bit. And this is why it's also nice that we did not flip back. I just promised I would flip back. Flipping back.
01:31:37.744 - 01:31:55.336, Speaker A: Okay, cool. Thank you. You guys are really on the ball. Appreciate it. So now we're going to flip back. And this is why it's nice. I'm actually going to copy from that truffle unboxing that I did this live network, which again it's going to be the same rules apply.
01:31:55.336 - 01:32:22.540, Speaker A: We need our mnemonic and our RPC URL. Again, I've already done that. My mnemonic is going to be my test wallet. My RPC URL is going to be our coven RPC URL. Now if we do truffle migrate reset, we can also do network live. So this should work. And HD wallet is not defined.
01:32:22.540 - 01:33:00.604, Speaker A: Need to add that in here. Sorry, got to add this in here. And then we're also going to NPM install. This NPM install could also use yarn, but I want to just use one package manager per project. And I've already started with NPM. Cool. Now we're going to do truffle migrate reset network live and cool.
01:33:00.604 - 01:33:45.770, Speaker A: So it's going to take a little bit longer because we're actually deploying to the real Covid chain. And I'm going to flip over to Etherscan just to kind of show you a little bit more. So that's the Dai token, that's our DAP token token farm. And we're going to actually look at the token farm contract that we just made. And we have 25 minutes left. So we're pretty good. I think it's so token farm contract address right here.
01:33:45.770 - 01:34:14.516, Speaker A: Flip over to ether scan 1 second. And I will actually remember to flip back to neither scan. So this is the transaction hash of getting that token farm up. Let's see if we can. Great. So here's ether scan of our newly deployed 38 seconds. Newly deployed token farm smart contract on the coven network, which is really cool.
01:34:14.516 - 01:35:07.780, Speaker A: Remember you do need to have Covid eth to deploy because it takes gas. I have a ton in here, but yeah. And we can even see our token that we created is even listed on Etherscan. It says we have 1 million dap token, which is really cool. And you can see how easy it is to make these tokens and how simple it is. So now what we want to do is we need to write a script, a script so we can actually issue some of these tokens. So let me do a new folder, call it scripts, new file, issue token js.
01:35:07.780 - 01:35:35.820, Speaker A: Okay, cool. And we're going to do some of the same boilerplate. So we're going to do const token farm. Token farm equals artifacts require token farm. Thank you. Artifacts require token farm because again, we've deployed it. Oh my gosh.
01:35:35.820 - 01:36:04.664, Speaker A: Keep my promises. Keep my promises. Flip them back. Thank you for being so on the ball. Okay, so starting with some boilerplate const token farm artifacts that require token farm again because we have it in our abis here. And then again some of the boilerplate module exports equals async. Function, I spell things right.
01:36:04.664 - 01:37:00.804, Speaker A: Function callback. Let token farm equals await token farm deployed, deployed. And then await tokenfarm, issue tokens. Console log console log tokens issued. And then we do our callback. So now we can run truffle exec and this is how we do truffle scripts. Scripts issue token js.
01:37:00.804 - 01:38:05.740, Speaker A: We're going to do network covent and we'll see if it works. Oh, network live. Sorry. And since nobody's actually staking, FN is not a function, it forget to install something. It's, it's right. Oh, let's try that. All right, cool, so it looks like that's actually working.
01:38:05.740 - 01:38:30.470, Speaker A: What did I do wrong before? Export. It should have been exports. Whoops. Okay, my bad. Well, good thing I have my backup codes here too. Cool, so it looks like that works again. Nobody actually is going to get any token because nobody is staking it.
01:38:30.470 - 01:39:38.750, Speaker A: Cool, so that's the majority of the functionality, that's the majority of the functionality that we're doing here. You can then write some more scripts like stake token. Right, and unstake token. And we don't really have time to rip into building the front end here. Yeah, we don't really have time to rip into the front end here, but what we can do is we can now go back and see our flip over to the UI that we did make. And this is why having a good front end engineer is really important with your solidity products, because you're going to need someone who's strong in the front end to be able to make your application usable by other people. So let's flip back to the front end.
01:39:38.750 - 01:40:18.356, Speaker A: Let's flip back to the completed front end. And again, I'll post all the code in the events log so you guys can check it out. I'll post both the dappy university ones and the adjustments that I made with the ERC 20 and the value piece. We're getting the latest price from Chainlink as well. I'll also post those bits about the truffle and box and the truffle smart contracts too. But yeah, again, definitely check them out. It's got some great resources that make it really easy for you to follow along no matter where you are in your development journey.
01:40:18.356 - 01:40:55.396, Speaker A: Cool. So we're back in this UI here of the DAP token farm, which is connected right now. It's completely empty. We have our obnoxious amount of MDI and then I've been playing with a bunch of this. So I have like a whole bunch of weird stuff here. But we have our MDI here and let's stake 1000, let's take 25 stake metamask is going to pop up. And again, this is all with the front end work.
01:40:55.396 - 01:41:48.884, Speaker A: We're going to confirm, we're going to approve. Don't worry about this for now. We would hit confirm and we can see this on Etherscan whenever it finishes populating. Cool. So we sent it to, we sent it to this contract, excuse me, here and now it should be populated. Great. So we have 25 MDI now.
01:41:48.884 - 01:42:32.630, Speaker A: Again, we want to issue tokens and we're going to do that in our little scripts that we just made. So I'm not going to show that, I'm not going to flip back. But yeah, we just do that truffle exec script, issue tokens, network live script and we should get the reward balance of DAP token equivalent to the value that we have staked, not the MDI that we have staked the value in USD. And you could absolutely get like the value of MDI. You could have the reward be eth and be related to bat, be related to whatever currency that you want. We're just doing it for USD for simplicity's sake. But you could absolutely do whatever you want to do.
01:42:32.630 - 01:43:10.536, Speaker A: Great. So we got 25.75 DAP because the value of this in USD is $25.75 if mock die was die. So that's fantastic. And then we can unstake, which is us just pulling it out and that transaction is happening. And then we'll see that happen on ether scan as well interact with this, which is our DAP token farm.
01:43:10.536 - 01:43:54.844, Speaker A: And right now it has the 25 mock die. But since we just unstaked, now it doesn't happen anymore. Right? And it got rid of some of its DAP token because it gave it out as a reward. So we can see literally everything in here. We can see the ERC 20 transactions that happen with our mock die with our DAP token. We can't really see the contract because we'd have to decompile it, but yeah, so that's pretty much it for the tutorial here. Like I said, I'll post the code for DAP University's starter code, DAP University's end code, as well as the chain link parts and the chain link adjustments and the opens upline, and I'll post that all in the events page so that you guys can all take a look.
01:43:54.844 - 01:44:50.710, Speaker A: But yeah, thanks everybody for coming and happy to take any questions. In the meantime, the code that I'll post will have all the UI, the front end pieces, so that if you want to play with that, you absolutely can. Yes, this video will be available later. It'll be posted to YouTube if you want another really good video resource. Again, the DaP university resource is really good. It was his project that inspired this demo in the first place. So if you want another video, definitely go check them out.
01:44:50.710 - 01:45:26.060, Speaker A: This one goes into kind of the open zeppelin pieces a little bit more. It also goes over truffle with Chainlink, much more in depth. But yeah, definitely be sure to check that out too. If you want to see the inspiration. I have a question. Might not be related, but I would like to ask if an external adapter is later start. If an external adapter starts posting wrong data and the smart contract gets affected by it, how to verify data before going with it? Yeah, unrelated, but a really good question still.
01:45:26.060 - 01:46:25.008, Speaker A: So I kind of want to let somebody else answer because I feel like at this point I know a couple of you have been following along. What do you think is the answers here? If one external adapter is posting the wrong data, smart contract is going to execute incorrectly. How do we protect ourselves against that? I'm looking at both the YouTube chat and the Q a here. Anybody know? Feel free to type your answer in that q a feature. If one external adapter is returning bad data, if our smart contract is getting bad data from an external adapter, how do we know whether or not to verify it? What do we do? Smart contracts execute whenever data comes in. Decentralization. Yeah, exactly.
01:46:25.008 - 01:47:13.084, Speaker A: Decentralization. You never want to have one external adapter being the source of your smart contract for developing. That's fine, but you always want to have a decentralized source, right? You never want to pull from a single external adapter. You want to have a network of external adapters and that's how you can be assured that your data is good. Right? So you're going to pull from a number of sources, from a number of nodes, from a number of oracles, and that's the best way to do it. Again for the hackathon and for just getting started, using a centralized oracle is usually good enough just to get going, but when you move to production, those are going to be the issues that you are going to run into. How do I make sure my data is good? So you use a decentralized network of external adapters.
01:47:13.084 - 01:47:43.290, Speaker A: Use a decentralized network of data sources. So we always need trusted sources, like more, equal to 50? Yes. So you want to have all your sources be trusted. You don't want to have 51% of your sources be trusted. You really want to have as many trusted sources as possible. And again, the decentrality just protects you against the ones that won't be or the ones that get bribed. Good question.
01:47:43.290 - 01:48:28.490, Speaker A: And this is something that's really important when it comes to reputation of oracles and reputations of data providers. If an oracle is responding with poor quality data, you kick them off your network, right? You don't have them anymore because if they're not going to bring their best to the table, you don't want them to be on your network. So good question. One of the nice pieces again about the price feeds is that creating of the network is already made for you for that really common data like pricing data. So that makes it really nice and easy just to kind of not even have to worry about building a network or kicking people off your network or seeing who's answering real ivy. So that's a really good question though. Thank you for bringing that up.
01:48:28.490 - 01:49:23.944, Speaker A: Is it best practice to host your external adapters on the same lanvpn as your node or can you just host them on the cloud? I guess the latter case, the adapter would need to be served over TLS. You can really do whatever you want as the same. It's probably better practice to have them on different servers to host them in different places because if one gets hacked and then the other one is still okay. For external adapters in particular, it's usually pretty easy to do the serverless functionality because then they won't even be hosted on the same place. And every time your external adapter gets called, it'll be hosted in a different place because of how the serverless functionality works. I guess in the latter case the adapter would need to be served over TLS. Yeah, you can host them on the cloud.
01:49:23.944 - 01:50:22.844, Speaker A: It's kind of up to you. If you're really worried about best practices and security and you're going to run a professional node and you're reaching that professional node, professional API, professional external adapter. I would really look into some type of security audit and they'll give you even more information on how to best run it the most efficiently and the most effectively. So definitely a security audit. Any other questions? These are really good questions. All right, if there's no other questions, I'm actually going to jump into the hackathon chat for the next. Yeah, I'll be jumping into the hackathon chat for the next probably half an hour.
01:50:22.844 - 01:50:50.260, Speaker A: If you guys just want to chat or talk about anything. I think that this is our last. Oh no, just kidding. There's an AMA at five if you guys want to jump in there. I'll jump in the hackathon chat right after this for about five, till about 230 probably, then I'll jump back on at five. There's office hours tomorrow as well at noon if you want to go even deeper into whatever you want. If it's just, hey, here's my idea.
01:50:50.260 - 01:51:17.320, Speaker A: Hey, why isn't this working? Happy to give you a hand wherever you need, but yeah, this was the d five tutorial. I hope that you all learned something. Please leave me any feedback as well of what you'd like to see next or what you didn't understand so that you guys can be super successful here. Thank you for keeping me honest, Horatio. Thank you very much and I will talk to you all soon. All right, thank you. Bye.
