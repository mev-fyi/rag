00:01:35.280 - 00:01:48.852, Speaker A: Hello. Hello. What's going on, everybody? Welcome to another workshop. It's Friday. We are at the end of week one of the chain, the hackathon. Really exciting. Been seeing a lot of chatter in the discord, a lot of people building really cool stuff.
00:01:48.852 - 00:02:33.380, Speaker A: So we're just going to keep the party going and we're going to keep learning going to keep building and learning how to build these superior your digital agreements and take us to the next level and really bring us usher in that fourth industrial revolution, usher in this new age headlined by us, the pioneers of the development space, the pioneers of this new revolution. So really excited to see everyone chatting so much, see all the activity that's going on, and really excited to see it continue as the hackathon progresses. Like I said, we're going to get not like I said, per usual, we're going to give it a couple of minutes as people kind of stroll in. Hello, hello. Friday is just the beginning. Absolutely 100%. So today we're working on something very cool.
00:02:33.380 - 00:02:53.500, Speaker A: Obviously, we're running a local development chain link node. I actually have to edit the title to be a local development chainlink node. We're going to be doing a lot of cool stuff. The reason that we want to run a local development chain link node is obviously because we can test stuff and we can do stuff. So we're going to give it a couple minutes as people stroll in. Hello. Hello.
00:02:53.500 - 00:03:00.992, Speaker A: Good morning. Good morning. How are we doing here, Joshua. Hello, Mr. Duyn. Hello, clobine. Hello.
00:03:00.992 - 00:03:22.388, Speaker A: Hello. Good morning. It is Friday morning and I am excited, I'm jazzed up. I'm ready to go, ready to build me a chain link node real quick. Ready to do some fun stuff. Ready to do some cool stuff. Yeah, so welcome, welcome.
00:03:22.388 - 00:03:45.944, Speaker A: So it is 833. Think it's about time we start jumping in? I think so. Would be nice if someone linked previous talks workshops on the hackathon website so they're easily to find and accessible. Great suggestion. Great suggestion. Actually, we'll see if we can do that. So today we are going to be running a local development node.
00:03:45.944 - 00:04:33.100, Speaker A: Now, this is going to be a little bit different than if we were going to run like a production node, right? If you want to run a production node or you want to run a node that's really going to take jobs and have 100% uptime, you can 100% check out the docs on how to do that. There's a doc session section running a chain link node. That's great. We'll go into it more, but today we're going to be looking at building a local development chain link node. Okay, now why do we want to build a local development chain link node? And the answer is that it is great for testing and for spinning up jobs and spinning up workflows and doing things a lot quicker. Right? Again, we're engineers, we want to be able to build stuff, move. We want to be able to do stuff quickly, right? And that's going to help us do our trial and error a lot faster.
00:04:33.100 - 00:05:09.364, Speaker A: If we spin up a development node, we are able to do all this testing much quicker. Again, this isn't going to be going over Docker. We are not going to be doing Docker. Docker is awesome, like I said, for doing production stuff, but it can be a little bit finicky, right? It has specific, I forget what they're called, like Docker endpoints or something. Basically if you don't tell it exactly how to access the real world, it will be confused and not know how to do any of that. Right. For example, like localhost won't work on Docker unless you tell it specifically.
00:05:09.364 - 00:05:33.312, Speaker A: Hey, this is localhost. So we're going to be able to spin up things a little bit faster, running it like the way we're going to run it. So without further ado, let me share my screen. Hopefully I'm doing this right. Oh, I'm not doing this right. Sorry guys, give me 1 second here. There we go.
00:05:33.312 - 00:05:50.676, Speaker A: Sorry about that. So we are on the chainlink GitHub, right? So this is the chainlink GitHub. I'll zoom in a little bit just in case. And we have some instructions here. So this is the chainlink GitHub. Hello. Look at how beautiful it.
00:05:50.676 - 00:06:33.200, Speaker A: Yes, very beautiful. And we are going to scroll down to the install section, right, this is the section right here that we're going to be going over right now. And we're going to be using this to build our local development chain link node. Again, you want to do one that's like Docker ready. And with a little bit more of the bells and whistles you can go to this running a chain link node section which will go through everything that you didn't know, all the different versions. This will get you set up for success in every way. So again, the reason that we're doing a local development node is because we want to iterate kind of quickly on our testing.
00:06:33.200 - 00:06:55.870, Speaker A: We want to iterate very quickly. So let's jump into it. And these are the instructions right here. So the first thing we do is we need to install go. So I already have go installed. It even just popped up right there for me. And actually let's keep it kind of small.
00:06:55.870 - 00:07:31.156, Speaker A: Go version have at least 1.14, which is the version that we need for go. You can follow the instructions here on how to install go. This is the steps for Linux for Mac. Here open the package file. Yeah, we just click this big button. Hopefully that will do it for you or windows or whatever you're working on.
00:07:31.156 - 00:07:47.340, Speaker A: Right. So we want to install go. Important thing to note is we do need the path as well. Once we install it, we need to set the path. So if you install go and then you do go version and you get that. Great. We also need to set the path.
00:07:47.340 - 00:08:26.264, Speaker A: So you need to run this export path equals this for a macOS. Or you can put this in like your bash profile or your bash RC. This is setting the environment variable a path. So that includes this go path, right? So this is going to be really important when you're running your code for it to be like okay, where is go? I don't know, where do I find go? So install it, export the path and that's really it. And then again you can tell that you've done that part right if you do go version and it works. So that's probably it for the new stuff for you. That's actually not probably it.
00:08:26.264 - 00:08:58.240, Speaker A: So the next thing is you do need node Js and yarn. So again node Js, there's all these different ways to do it. Whatever you're on. Again, I'm on a macOS Node JS has actually really good docs for installing stuff. Here are whatever version you're working on. You can come here and find what version of Node JS and again node V. That'll tell you what version of node you're on.
00:08:58.240 - 00:09:37.336, Speaker A: You're also going to want MVM. So the reason that you're going to want MVM is because sometimes you want to have a very specific version of node for running this stuff. So again, you're going to want to install NVM. There are a couple of different ways to install NVM depending on what you're using. So node MVM and then MVM v. So you know what version of MVM you have. So you absolutely want node, you absolutely want NVM and then you also want all, I kind of think I bucket all these kind of into one because when you install node, you get NPM, but you don't get yarn.
00:09:37.336 - 00:09:56.852, Speaker A: So you do have to do like install yarn there's just kind of a lot of setup. There's a lot of setup that you guys got to do. Install yarn. Yarn is actually really easy to install Npm, install global yarn. Right. That's the easiest way to do it because when you install node, you automatically get NPm. So I know I'm kind of saying a lot of stuff.
00:09:56.852 - 00:10:16.904, Speaker A: Again, guys, please feel free to make this interactive. Ask questions in the chat if you're totally blown away. There's just kind of a lot of setup for getting this done because chainlink uses a lot of tools. So we installed go great. We installed node Js, great. We installed yarn great. We have Nvm, great.
00:10:16.904 - 00:10:28.092, Speaker A: And again, if you're like, I don't know if I have a go version. Great, got it. Yarn v. Great, got it. Node V great, got it. Mvm v great. I have all four.
00:10:28.092 - 00:10:59.240, Speaker A: Awesome. The only thing that's a little bit trickier to test is your path. You can do like a print eVm. I'm not going to do it because I have a whole bunch of stuff like print env. Then I'll tell you where all your variables are, all your environment variables, and if you see path and it has the go path in it, you'll be good to go. Right. The go path is going to be like this, right? So it's going to be users Patrick go.
00:10:59.240 - 00:11:22.432, Speaker A: So we can even less users Patrick go. Oops. So I have users Patrick go. This is where I have installed go and I have my path variable includes users Patrick go. So that's how you're going to test that. There. It's there.
00:11:22.432 - 00:11:36.160, Speaker A: So when you do print env, you can see the path variable. It'll have go in it. All right, cool. We talked about these. We talked about this. Great. So the next one that we need to install is postgres.
00:11:36.160 - 00:12:15.276, Speaker A: So there's a whole bunch of different ways actually to install postgres. Again, I'm on a Mac. I don't know what the popularity there is, but there's a whole bunch of different ways to, there's a whole bunch of different ways to do this. So we can go right to the docs, right to the link here, and there's a whole bunch of useful tips for installing postgres. You can also just do install postgres, whatever. Again, I'm on macOS and we come right to a package that says, hey, here's how you do it. You can do with homebrew.
00:12:15.276 - 00:12:51.710, Speaker A: This is actually what I did. Postgres brew install cask, postgres so there's actually going to be two different things that you're going to want to do. So you're going to want to install postgres, and you're probably also going to want to install the postgres cli. So that's going to be this pSql V Oops, psql. And this one's pretty easy. This is the postgres client. So install pSQL actually had a page up.
00:12:51.710 - 00:13:27.216, Speaker A: PSQl is postgres client. This is how you're going to interact with your postgres databases and then postgres itself. Postgres. Postgres help. I'll get the version, pipe it into less the help. Okay, postgres, sorry, I'm looking for version. Version.
00:13:27.216 - 00:13:57.388, Speaker A: Okay, postgres version. Those are going to be the two piece that you need. So you need this postgres command, and again you can test it by doing version. And then you need a client which is going to be PSQL version. So this is the postgres database, and this is the postgres client. So this is for interacting with the database, and this one's for interacting with the database. And this one is for setting up the database and running the database.
00:13:57.388 - 00:14:42.000, Speaker A: So a couple of questions here. Are you setting up the node on your personal computer here? Would it be better to install it on a dedicated one like a raspberry PI? Good question, yes. So if you're going to run a real node and then actually I'm hoping that this is big enough, I'll zoom in just a hair. Sorry, I realized that's a little bit small. That's enough for us. Yeah. So I'm running this locally, and the reason I'm running this locally is so that when I'm building my applications, my depths, I can actually test quickly and spin up stuff on my node and use my node as kind of this proxy for doing stuff.
00:14:42.000 - 00:15:17.036, Speaker A: So I am testing locally, this is kind of for my personal computer, so that when I'm building my applications I have something to test with really quickly and just edit without having to jump through all the hoops of having a production ready application. That's a good question. I think cloud. Okay, cloud is good, but having your own infrastructure is actually better. Scott to the rescue. Yeah, this is just for local development, however, so that you can iterate quickly. Exactly.
00:15:17.036 - 00:16:05.544, Speaker A: You would not want to use this or a PI for operating a node that others are using, correct? Yeah, it's kind of unrelated to this chat, but yeah, some people have said, yeah, I can do it on a PI. But if that PI goes down or that PI comes offline and your oracle is no longer servicing, you are quickly going to fall into the dumpster fire. That is your reputation. So I would highly recommend not running it on a pie. Why do we need postgres? Because that's what the chainlink software uses. You need a database to store your key, store to store kind of all your offline. Because at the end of the day, Chainlink is an off chain service that interacts with the layer one.
00:16:05.544 - 00:16:48.936, Speaker A: Chainlink is a L2 solution. So the chainlink node needs a database to keep track of stuff, to keep track of your keys, keep track of job runs, who's interacted with your node. You need a lot of this stuff. Good questions. So we need postgres. I like to have this little application, this little postgres application. Again, I'm running on a Mac, so this is kind of what I use usually to run my, it's, it's a little bit tricky to kind of go over all of them, all the different ways to install postgres, but install postgres and again, you can make sure that you've done it right.
00:16:48.936 - 00:17:09.948, Speaker A: Psql version, postgres version. If you have those, you're doing it right. So again, I'm using a Mac. So I did a whole bunch of this brew stuff. Yeah, I did a whole bunch of this brew stuff. Again, this is just for the client. And then I also did like postgres macOS application.
00:17:09.948 - 00:17:44.520, Speaker A: I think this is what I do. Yeah, I use this postgres app because it kind of just keeps track of stuff. Keeps track of a lot of stuff for me, which is really nice, but there's a whole bunch of different ways to install postgres. So once you get it up, you will be good to go. Cool. So postgres, you should configure postgres to use SSl connection. So this is good for doing a little bit more serious.
00:17:44.520 - 00:18:24.890, Speaker A: I don't have mine set up like this. And maybe I should even put a note in here. Yeah, I should probably put a note in here because I do a workaround to not have to worry about SSL because if I'm just testing locally, I don't really care. But for full on testing, you are going to want to do that just to make sure that you can actually connect to APIs and stuff. So I will show you kind of the workaround that I do though. So once we do that, we run, make, install, and I actually am going to run this even though I already have it installed. So we're going to see if this breaks everything.
00:18:24.890 - 00:18:53.424, Speaker A: Oh, sorry. Mvm use twelve point 18. We do want to be using node read twelve point 18 and that's why we want Mvm, so that we can easily switch from different node versions. Right. We can easily switch from node we're on twelve point 18. We can easily switch around node versions because we want to use node twelve for this. So once we have all this installed, then we can run make, install.
00:18:53.424 - 00:19:23.850, Speaker A: And this is actually going to. Should I make this bigger? Is this not big enough for you guys? Let's make this nice and massive. Boom, boom, boom, boom, boom, nice and big. There we go, make, install. And it's going to do a whole lot of stuff. So while it's installing, while it's doing all this stuff, let's look at a couple other questions. What happens when postgres database goes down or corrupts? Is it possible to use decentralized or like IPFs in place of postgres? No, not at the moment.
00:19:23.850 - 00:20:21.870, Speaker A: And you probably wouldn't want to do that because you're going to put your keys and stuff in your database. So you kind of don't really want to do, well things that can lead to what your key is. So you don't really want to do that actually and goes down or corrupt. I mean, this is why when running a production node, you want a super highly available redundant infrastructure, right? This is why when a lot of times when people say, hey, what's it take to run a chain link node? I usually just say DevOps, you need to be sick of DevOps. And again, that's for doing production stuff, right? That's kind of a more production node operator conversation. We're just focusing on a local development node. And the reason we're focusing on this is because if we run a local development node, we can start testing custom jobs, custom APIs, external adapters, which we built, which we will go over later today.
00:20:21.870 - 00:21:12.940, Speaker A: It's a good. And, and this is the other reason why Chainlink is a decentralized oracle network, right? Because if one node goes down, the network proceeds, right. The network goes on because there are multiple nodes that are providing data in the same way, like ETH, Ethereum. If a single ethereum node goes down, nobody cares, right, because there's so many other nodes, right? There's so many other nodes that make up the system. So if your database goes down or corrupts, that's obviously a little bit worse than if your Ethereum one does. But this is why you need a really highly available system. Yes, AWS has some really nice pieces.
00:21:12.940 - 00:22:00.284, Speaker A: All the cloud providers do have some really nice tools and tips and tricks to make life a little bit easier. The thing to note about AWS and any cloud provider obviously, is that if everyone is running on a cloud provider and that cloud provider goes down, well, that's our single centralized failure point. So it is a little preferable to run your own ETH client. It is a little preferable to run your own infrastructure. But again, that is outside of the scope of this call. We are just talking about local chain link node. So great, so we have it set up, we have it set up now so we can see if it's done.
00:22:00.284 - 00:22:19.292, Speaker A: If you get any errors regarding lockdown package for running yarn install before this step. Whoops. Well, we didn't do that, but if we run chain link help. Awesome. We can see all the commands here. So this means that we have successfully installed the chain link command and we can see the version 10.2. This is the latest and greatest.
00:22:19.292 - 00:23:11.440, Speaker A: We can see all these fun commands which we'll get to in a bit. All right, awesome. So what do we do now to start the node run chainlink node start now we can run through this if we want, but actually I believe it's going to actually, hold on, I think I have an EMV. Ls emV. Oh, it's my sample emv. Okay, so we can do chain link node start, but I'm going to not do that quite yet because I'm going to continue setting stuff up. So we have that installed.
00:23:11.440 - 00:23:44.700, Speaker A: So if we look at running a chain link node, someone wants to make a PR actually to this readme to make it a little bit more clear. Feel free. We've actually got everything kind of set up. What we need though is an environment file. The environment file is going to show us everything that we need to know. So yeah, if somebody even wants to make a PR saying hey, next thing you're going to want to make a env, maybe even a link to here, that would be a really simple PR. Nice way to get involved.
00:23:44.700 - 00:24:23.656, Speaker A: Anyways, we need an environment file. So this kind of just gives us the real basics of how to interact and how to work with a chainlink node. So we can actually skip this part, skip the root part. But let me show you what a sample env file is. You can copy paste that into here. And actually we're going to even go to here CD environments. Here is what a sample env file looks like.
00:24:23.656 - 00:24:45.200, Speaker A: So you can copy paste this into a env file. I just have mine in an environments folder. And let's go through what all these are and what they need. So etherl. This is our websocket connection to the blockchain. This is my test instance. I'm going to be running this chainlink node on coven.
00:24:45.200 - 00:25:10.248, Speaker A: That's what I'm going to interact with. So I'm going to be doing this on coven. And yeah, this is my fun testing infuria key that I'll probably ditch after this call. If you want to work with external initiators, you can set this to true. You probably can just leave it blank, defaults to false. Most of you probably aren't going to be working with that log level debug. This is to show you the different.
00:25:10.248 - 00:25:24.364, Speaker A: When you run the node you'll see the different kind of logs. Pull up ETH chain id. This needs to match what your ETH URL is. So COVID's chain ID is 42. So we're going to set that up like that. Minimum outgoing confirmations. You can set this to zero two.
00:25:24.364 - 00:25:42.132, Speaker A: Doesn't really matter. The link contract address does matter. This is the address of the link token on whatever chain that you're working with. So we're working on coat. We're going to be doing this on COVID. So we're going to do, this is our link token. Now again, if we wanted to run a local blockchain we could.
00:25:42.132 - 00:26:08.780, Speaker A: It can't be ganache or hardhat or anything like that. That doesn't work. The RPC calls aren't the same. If we were to run our own local geth blockchain we could do this, deploy our own link token and set this up differently if we wanted like a super full powered end to end. Like this is a true local testnet or a local development network. But we're going to be working with COVID here. This is a local chain link node working on the coven chain.
00:26:08.780 - 00:26:41.264, Speaker A: TLS port secure cookies allow origin. Don't worry about that. But the database URL we do worry about. This is why that postgres stuff is so important. And this is kind of my workaround to not having to do work with SSL. I just add a query param called SSl mode equals disable. So if we come back to here on the set, the remote database URL config because all these are really running chain link node ganache.
00:26:41.264 - 00:27:00.648, Speaker A: Oh yeah, perfect. Look at that. Don't do that. Oh, sorry, I skipped over something. So you can also set up a local blockchain. It doesn't even have to be like inferior, right? It doesn't have to be inferior. It doesn't have to be alchemy.
00:27:00.648 - 00:27:31.664, Speaker A: It can be whatever you want it to be. And there are some other docs here on the Ethereum client on the same machine, and you're going to want to kind of, this is for docker. This is for Docker. Don't worry about that. For the local development you can just use the HTTP endpoint of, of your geth or whatever. Anyways, so we do need this though. This is a database connection string for postgres.
00:27:31.664 - 00:27:56.440, Speaker A: This is how we connect to a postgres database. Just kind of anywhere you can see what the layout looks like here. So it's going to be postgres, your username, your password, server port and database. This is what the setup looks like. Mine's a little bit shorter because I don't have a password on my local database. So mine's just localhost port. Patrick.
00:27:56.440 - 00:28:20.820, Speaker A: But if you have like a password and everything, server port, my server is localhost. My username is postgres. Username. I don't have a username, apparently. I don't have a username or a password. Server is localhost, port is 5432. Database is Patrick.
00:28:20.820 - 00:28:45.612, Speaker A: Now let's actually even make sure we do this rather. So I have postgres running in this little app. You can get postgres running however you want, but this is why we need the client. You run psql and it doesn't connect to anywhere. You know you've done something wrong. Right? And I can also do dash u, Patrick, I think this is right. Yeah.
00:28:45.612 - 00:29:18.932, Speaker A: So u tells it which database to connect to. So we already have a database, Patrick. We already have a database, Patrick set up. But if we go into postgres, we can also do like create database coven demo. So again, we'll even drop that. Drop database coven create database coven demo. Oh my gosh.
00:29:18.932 - 00:29:50.644, Speaker A: Whatever. So now we have a database called Coven demo. And let's say you quit. What we can do here, change this from Patrick to COVID demo SSl mode is disable because we're going to be disabling SSL. We're not going to deal with that stuff. So it's running on my local host on port 5432. You can check a lot of kind of the different configs and stuff in here.
00:29:50.644 - 00:30:10.820, Speaker A: And there's the port that it's running on again, this is just for each, I think Windows has something else. I think Linux has something else. Or you can run it right from command line. This is just kind of the way that I like to do it. Database timeout. Don't worry about that for now. Flux monitor.
00:30:10.820 - 00:30:34.476, Speaker A: Don't worry about that for now. Minimum contract payment. This is for your run log jobs. This is for the API calls. This is the minimum payment that somebody has to make to your jobs. Okay, so this is in way. And this is going to be, what is this? That's going to be 0.1
00:30:34.476 - 00:30:45.696, Speaker A: link, basically. So this is 0.1 link. We're saying the minimum is zero one link. And we're going to run it in dev mode. So I'm going to, right, quit there. And I just created a new database, right? So I created a new database.
00:30:45.696 - 00:31:17.740, Speaker A: You saw me create the new database and that's the database that we're going to connect to here. Great. Once you have the database started, which I do. And if you ever are like, wait, it's not working. You can always just do psql u COVID demo and then you can even do the h. This is going to be the endpoint to get to it. Roll coven demo doesn't exist.
00:31:17.740 - 00:31:46.320, Speaker A: Maybe we did it wrong. Psql. We can even help psql. Is it u? Oh, pipe it into less. What does dash u do? Is that the right one? Oh, that's username. Whoops, sorry. That's username.
00:31:46.320 - 00:32:06.856, Speaker A: Port that host port. Username, it's D. So psql. Excuse me, damo. There we go. And now we're in there. So yeah, obviously u is username.
00:32:06.856 - 00:32:21.872, Speaker A: It doesn't make sense for that to be database. So we've proven that we can connect to it and that's how you're going to connect to it. You also do h. I think this works. I actually forget. Okay, that works. H.
00:32:21.872 - 00:32:48.024, Speaker A: This is saying like the IP address of what we're working on. Again, we're working on local. So if you can do this, you can connect to it. And this is the same command that you want to run when you're running like a full fledged chain link node to check to see, okay, is my database even alive? Right. That's probably one of the most common things I get people asking is, hey, I keep getting this weird error. I don't know what's going on. And it's like, okay, well, can you even connect to your database? No, I can't.
00:32:48.024 - 00:33:10.716, Speaker A: Okay, well, that's your problem. So once we have all that set up, we can just go and again, I'm kind of bouncing around a lot. Sorry guys, your ETH client. I should have said this first. Sorry guys, your ETH client, the ether round again. You can get this from infira. Like I said, you can get it from alchemy.
00:33:10.716 - 00:33:36.712, Speaker A: I'm not going to sign in, but you just want to make sure it's the websocket. So here's a sample of what it looks like you can copy paste from the docs. Let's do it. And once you have all that, we can just look at the chain link commands. Chain link node, local chain link node. It's going to give us all the commands here. Delete user import, blah, blah, blah, blah.
00:33:36.712 - 00:34:01.970, Speaker A: Start chain link node. Start. Stuff's going to happen. So this is basically the node initializing. It's saying, hey, we're getting startup, we want to do some stuff, let's do some stuff. So we have to create a new key store password. So when you create a node, you create a key, you create a wallet, right, for the chain that you're working on.
00:34:01.970 - 00:34:22.964, Speaker A: So because of that you need a new key store password. And this is going to be used to encrypt your key. So we're just going to call it password, I guess. I can't do password. Sorry. Oh, this is new. They basically said you can't have crappy passwords anymore.
00:34:22.964 - 00:34:36.680, Speaker A: Okay, cool. So we're going to give it capital. Oh gosh, now I have to remember password 101. Capital P. No. Okay. It must be longer than twelve three uppercase characters.
00:34:36.680 - 00:35:12.970, Speaker A: Okay, so we're going to do password 123-45-6789 lowercase characters. Okay, here we go. Pass is going to be uppercase word is going to be lowercase 123456. Okay, pass is uppercase word is lowercase 123456. Pass is uppercase word is lowercase 123456. Okay, enter API email. We're going to do test@test.com.
00:35:12.970 - 00:35:34.768, Speaker A: API password is going to be test. Let's enter a good password test@test.com. And the password is going to be the same. Actually we're going to do pa s is uppercase word. Lowercase 123456. And cool. So we have it starting and being kicked off.
00:35:34.768 - 00:36:06.524, Speaker A: So these are all the logs that are happening when a node is running. Now what we can do, go to localhost 6688 and we can see we have the chain link node operator Ui here so we can actually log in. Crap, I forgot. Test@test.com dassword 123456. And we can see we're into the Ui. We're here.
00:36:06.524 - 00:36:41.968, Speaker A: We did it. Great job. Can you link the sample envy file you're showing the one on chainlink docs? Seems different. Let's go back to the chain link docs. Where is the sampling be, is it in core? I can link that. You can also check the one here. This is basically going to be, I just have a couple of other parameters.
00:36:41.968 - 00:37:10.752, Speaker A: This is really what you want for whatever your network you're working on. I would say just use this one actually because, yeah, this one's actually much nicer. And then just add the ETH client and just add the ETH URL to whatever your ETH URL is. So I would say use this one actually for whatever network you're working on. Good question. So we have the dashboard and we're in the dashboard. Great.
00:37:10.752 - 00:37:40.424, Speaker A: What do we do now? So what we can do is start doing fun stuff. So let's go and add a job. So we can now add a job here. I usually just kind of scroll down to here. This is a really simple job. So this is going to be what a job looks like for a get un 256. Okay, so this is a run log job.
00:37:40.424 - 00:38:09.152, Speaker A: So run log jobs are the jobs that are defined by this make a get request bit here. Right. It's the one where people have to choose their oracle choose their job ID. This is going to be that type of job. So it makes an HTTP call, it JSon parses, the API call. And again, if you're new to the json parse, go check out the make an API video. Excuse me, make an API call video.
00:38:09.152 - 00:38:54.130, Speaker A: There's multiply, which multiplies stuff, turn the result into an Fu N 256 and then make the transaction on chain. Now the one part here, it's going to be like, wait, what is this address? Your oracle contract. So let's get that done. What the chain link node is really doing is it's listening to a very specific oracle contract and it's waiting for requests to go to that contract. So we need to tell our node to listen to a specific address on chain. So how do we do that? How do we get that set up? Well, we can come here, go to node operators fulfilling requests, and then you can just use this for whatever testnet is moving forward. That way you don't have to always redeploy it.
00:38:54.130 - 00:39:25.370, Speaker A: We can come here and remix, actually pretty much has it already all set up. Click that remix button. So this will explain more in depth too, on how to fill requests. Make sure you've done some of the stuff. You know how to use metamask. Again, you need your metamask set up, right? You need testnet ETH. I'm assuming you guys know you've watched some of the other videos.
00:39:25.370 - 00:39:54.790, Speaker A: So please, if you haven't, go watch the other videos. They're also really good. But we click the remix button, we can expand the gist menu and we see we have this new Oracle soul. So this is the Oracle contract that our node is going to be listening to to get requests. So if you guys want to deploy it on remix, you absolutely can. You can deploy it on truffle hard at brownie, whatever you want to do. Let's just go ahead and deploy it here so we can work with it right now.
00:39:54.790 - 00:40:17.080, Speaker A: So we're going to do injector web3. And again, if you're like, what is this remix thing? What's going on? Watch some of our other videos. They will go into it more in depth. So we need to deploy it with the coven link contract. We say this is the link contract here. We're going to deploy it. Confirm.
00:40:17.080 - 00:40:52.300, Speaker A: Is that the right account I want to be on? Probably, sure. You know what, why not? Who cares? So we're on COVID and this part is going to be the same as if we were running Mainnet, right? So we have our contract here. Great. So this is going to be our oracle contract. Now, how does our node know that it's our oracle contract? Well, we're just going to set, we're going to set a parameter real quick. So in our configuration it actually moved to keys. So for those of you on older versions of Chainlink, it used to be in configuration.
00:40:52.300 - 00:41:13.624, Speaker A: There was an address in here. Now it's in keys account. Address regular. This is our chainlink node account. This is the wallet that is associated with our node. Okay, so we're going to copy this address here. And in remix, there's a function called set fulfillment permission.
00:41:13.624 - 00:42:08.704, Speaker A: If I scroll it out, we'll show the whole thing. Yeah, set fulfillment permission. And we're going to say this node and fulfill out the oracle requests that come to this contract. Okay, this is obviously really important. This wallet address, which is the wallet address of this oracle that we just created or of this node that we just created, can fulfill the requests to this oracle contract. Now this is something that's going to confuse some people and we just need to remember the oracle contract that we just deployed is different than the wallet address that gets created when we spin up our node. So node node wallet or node account, oracle contract, node wallet, oracle contract, great, that's the difference.
00:42:08.704 - 00:42:48.030, Speaker A: So we're going to say our node wallet can fulfill stuff that comes to this. Oracle contract set fulfillment permission to true metamask pops up, confirm. Awesome, great. Now what we can do is we can grab this and we can set this like this. So now we have an API call. Now we have a job. Once I hit create job, we're going to have a job that gets kicked off from those run logs, again from those make and get requests from those API call jobs here.
00:42:48.030 - 00:43:19.920, Speaker A: And it has all these tasks, right. We can set parameters to these tasks if we want. We can do like params. This is where you'll put like body and stuff like maybe like header cat, whatever you want to do. We're not going to do that now. But this is kind of the bare bones job, right? It's saying these are the tasks they can do. You can do an HTTP get adjacent parse, multiply ethuan and then make an ethereum transaction back on chain.
00:43:19.920 - 00:44:10.004, Speaker A: You can mix these up, you can do whatever you want, you can have any type of jobs, and again you can list it on the marketplace, but we're not going to talk about that because we're just doing this for local development. When should I use JSon Parson copy? This is a great question actually. So if we go to the docs, this actually still confuses me sometimes, and honestly, I'll just check the docs if I get confused. So copy copy is a core adapter that walks the copy path specified and returns the value found in that result. If returning JSon from an external adapter, you will need to use this adapter. So copy is for external adapters and JSOn parse is for HTTP get htp post. So in our dashboard here we're using HTTP get.
00:44:10.004 - 00:44:45.248, Speaker A: So we're using JSon parse. If this was an external adapter, which we'll go over later today, this would be copy. Great question, really good question. So let's go ahead and create this job invalid Json. Oh no, I messed it up that comma. So I now have a job named get you into V six and this is its job id on a local chain link node, which is awesome, which is super fun. So what can I do now? Okay, great.
00:44:45.248 - 00:45:16.076, Speaker A: Well what you can do now is whatever you want to do. We can create external adapters, right? And that's going to be the biggest value add of running your own local node. It's creating external adapters. But let's run this as if it was like a real job. So what we're going to do again, my terminal is still running. If I turn this off it's going to kill it. Come back here.
00:45:16.076 - 00:45:52.320, Speaker A: I hit refresh. It's like, oh no, let's start it again. Passwrd 3456. We're back up. And actually to not have to do your password every time in your env file you can set like a password. We're not going to do that now, but it's somewhere in here. In your env file you can set like a dot password so that you don't have to always do that.
00:45:52.320 - 00:46:26.928, Speaker A: But any case, we're going to hit refresh and we're back in because the cookie is still up. Oops, sorry. So let's go ahead and try to get some data, right. We have this deployed, we don't need this anymore. You deploy the oracle contract once and you're good to go. You can always come back to it, right? You can always go back to it and actually let's even go back to it. Just this here, oh no, I lost it.
00:46:26.928 - 00:47:10.268, Speaker A: I don't have it anymore. How do I set new fulfillment permissions or how do I withdraw a link or how do I do this, that the other thing. So what you can do is grab this, you deploy it at this address. When you do at address you say this code, this is the code that is at this address. Remix is going to go, I believe you. Here's how you can interact with it and give us this stuff here so we could still set fulfillment permission on whoever we wanted, comma true, we can withdraw link, transfer ownership, renounce ownership, whatever we want to do. But let's go ahead and practice making an API call.
00:47:10.268 - 00:47:40.308, Speaker A: So we're going to come right to the docs here, make a get request, right, because this is what this is practicing, this is what this is doing. We'll hit this big remix button and in the gist we get API consumer and what you'll see is right here in the constructor. We have an oracle and we have job ID. We just deployed an oracle. I'm going to use my oracle. Use our oracle. Our oracle.
00:47:40.308 - 00:48:04.460, Speaker A: Boom, new oracle. Boom, new job ID, right? This is the oracle that we just deployed. This is the job ID right here. It looks like we have an issue. Invalid checksum. You got this, don't worry about this. Just go to ether scan.
00:48:04.460 - 00:48:22.772, Speaker A: Ether scan. Pop it in ether scan. We grab the real checksum. It just like changes the capitalizations and stuff. Cool. So I believe that this is the same type of job. So let's go ahead and test it.
00:48:22.772 - 00:48:36.744, Speaker A: Let's see if it is. Let's test it. So same thing. Same thing as every other deployment. So we're going to switch to injector web3. We're going to be on the COVID network. We have our ETH.
00:48:36.744 - 00:48:59.740, Speaker A: We have our link. So it's going to be just like what we normally do, except for it's going to be going through our node here. Okay, so I'm actually going to do this wrong the first time, just to show you an error that you might run into. So we're going to copy this. So I'm doing something wrong here. Try to spot the wrong. What am I doing wrong? We had the link.
00:48:59.740 - 00:49:25.576, Speaker A: Great, it's frozen on me. We're going to add the link. Actually, COVID might be slow because it's testnet. We're going to add the link to our contract here. All right, great, it worked. We're going to do request volume data, confirm. So we just kicked off a call to our oracle.
00:49:25.576 - 00:50:09.560, Speaker A: So if we did this right, we should see a run created just now on Oracle, which we do, which is great, but something wrong is going to happen. Something very wrong is going to happen. And I'm actually going to ask, does anybody know what we missed here? If anybody's run a node before, does anyone know what we missed here? Well, it looks like, well, it looks like I got raid limited, so that was the first issue. So we actually can't even use this API call here. So sorry. Let's use a different API. Let's use alpha vantage.
00:50:09.560 - 00:50:36.524, Speaker A: I got rate limited on my local machine. I've been using an API too much apologies. Let's do a different one. Exchange rates. Let's use this. So we're going to use this one and we're going to look for exchange rate. So we are going to grab this API.
00:50:36.524 - 00:51:06.764, Speaker A: So we're going to fix this on the fly, guys. So we're going to use this new API. It's actually going to be a nice, fun little test. We do have to add a path, however, because there's spaces and stuff in here and the paths that we need, we're actually going to do it a little bit different. We're going to go to adapters, core adapters. Copy. Right.
00:51:06.764 - 00:51:38.070, Speaker A: Because we want to use json parse. Use json parse here. We're going to do it like this because there are a bunch of spaces. Whoops. Boom, boom. Can you format? Thank you. And we see the path here is going to be real time currency exchange rate.
00:51:38.070 - 00:52:16.128, Speaker A: Zero is real time currency exchange rate. Then we're going to get exchange rate, add the path, we're going to do the multiply, we need to multiply this number because look at that number and boom. So this is what we're going to go for instead because I'm rate limited. So let's redeploy. So I did do something wrong, but I did something wrong that I wasn't anticipating to do wrong. So sorry about that, guys. But now we have a new one.
00:52:16.128 - 00:53:01.650, Speaker A: Let's refund it with link. We'll make that API call again and we'll see what is happened, what's wrong on our side. So if we do this call again, again, we go to our node, we should see another run coming sooner. Here it is. Here's the job that just came in and we did something wrong here. So I see a couple guesses. Auth no, not quite.
00:53:01.650 - 00:53:28.250, Speaker A: The value could be found for the key. Well, I'm making bad API calls. Well, this is also wrong. This is a two. So I'm doing a couple of things wrong. That's not what I intended to do wrong. So let's try this again.
00:53:28.250 - 00:53:55.882, Speaker A: So I made a string array of size four when there's only two things in here. So I don't think it liked that. One more time. Third time is a charm. Here we go. If we go over, is that okay? It's okay. If we go a couple of minutes over.
00:53:55.882 - 00:54:18.754, Speaker A: Okay, cool. So send some link. Let's try this. Third time is a charm. Confirm. You guys can actually see here why it's a little bit nicer to variableize your request. So if we had this like string memory URL, we wouldn't have to redeploy every time.
00:54:18.754 - 00:54:36.934, Speaker A: We just swap out the URL for something else, string memory URL. Maybe even like string path or something like your string memory path. That would make these a lot easier. So parameterized stuff, guys, it makes your life easier. So let's see if it worked this time. Okay, great. Here is the issue that I wanted to actually show you guys.
00:54:36.934 - 00:55:36.854, Speaker A: So everything worked, right. We added an API call, we parsed it down to get just this value. We multiplied the value, we changed this value from what it is to a FU 256 version of it. So a version that Ethereum can understand, but it's stuck. Oh no. Why is it stuck? What's going on? Now? If you google this pending out, pending outgoing confirmations, you Google this, pending outgoing confirmations, you'll get a great stack overflow answer that kind of goes over some of the different things that we could do and what you'll see. Excuse me, if you remember how I said we create our own node address and our node address is actually going to make a transaction back on chain.
00:55:36.854 - 00:56:22.970, Speaker A: Okay, so if you know that, that this node actually has to make a transaction back to the chain, what is it missing? What does this node not have? What does this wallet not have any of, if it needs to make a transaction, doesn't have any ethereum, doesn't have any gas to make that transaction. So we actually have to send this to COVID ETH. Yes, exactly. Yes. It doesn't have any ETH. So we need to have this address here funded at all times with ETH in order to make these transactions. So if we're going to be running our local node, we need to have it have some ETH to be successful here.
00:56:22.970 - 00:56:56.840, Speaker A: So now that I've just funded it, if we go back to runs in a minute or two, we'll see it actually go through. Unless I didn't give it enough ETH. So it's back to being in progress, and now it's completed. So that is how we do it. We can even do another quick end to end. We'll see that if we request moving forward, assuming 0.1 e is enough, now we should just see it go right through without us having to do anything.
00:56:56.840 - 00:57:36.814, Speaker A: And again, over here in our job, we'll see we actually get the response from our node, which is great. And then we'll just wait for this to come through. And once it comes through, depending on the speed of the network, remember, because we are working on a testnet, sometimes they're a little bit more finicky and. Yeah, I know we're going over a lot of stuff here. There's a lot of stuff to running a node. Yes, the web3 account is spun up. Great.
00:57:36.814 - 00:58:05.078, Speaker A: Yes, you got it. The web3 account is spun up when you generated the node and secured by a password. So when it said, enter this key store password, that was actually saying, hey, we're going to spin you up a wallet, can you give us a password so we can encrypt it? So that's spot on. Spot on. But now we see that it actually went through right away without us having to do anything. And now we can kind of be, and we can even see that it changed here. And now we can be hands off with the node.
00:58:05.078 - 00:58:41.074, Speaker A: Right. We just need to look at the ETH bounce from time to time, make sure it has enough stuff in it. But now we have some green check marks. Yay. And I know we went over a lot of stuff today, there's a lot of stuff to this, running a node, especially locally. But once you get it set up like this, you can really just kind of cruise control, cruise through and not have any issues and just kind of run your node, do your tests and have a blast. So again, this can be really helpful for external adapters.
00:58:41.074 - 00:59:22.546, Speaker A: And if you want to test locally, if you want to test your own node before going mainnet, you absolutely should, by the way, and you should probably even have some people using your node. But this is more for testing your daps, right? If you're going to want to get some custom data, maybe you want to test a crazy external adapter and you want to test it yourself. Here's a way to do this. So open to questions now, and I know, I'm happy to go a little bit over here if there are some questions. So this means that Chainlink nodes can capture and manipulate sensitive data between the contract and the API. I can't see how Chainlink can guarantee the quality of the data. Great question, actually.
00:59:22.546 - 01:00:00.734, Speaker A: So this is why, it's just that you need a decentralized network when working with this stuff. So this is a single node, right? In the same sense, if Ethereum was a single node, then yes, that single ethereum node could break the computation, change the state, do whatever it wants to do, right? So Chainlink is the exact same way if you have a single chain link node. Yeah, it can manipulate and be malicious. So this is why you need a network of Chainlink nodes. So making a single API call through one of these is no good. You're going to want to get a group, a network of these nodes to be delivering this data. Right.
01:00:00.734 - 01:00:40.054, Speaker A: So that's a really good point. And that's actually really important for working with the data on chain. So that's the answer there. You need to be in a network of chainlink nodes, and obviously the economic security there plays in. If a node is getting paid to make jobs and there's one node on a network that just keeps not returning correct data or keeps returning bad data, that history is tracked on chain, right? That's permanent. Every single response a node has ever made is always going to live on chain. So they have a permanent record of your behavior on the network.
01:00:40.054 - 01:01:01.730, Speaker A: So this is obviously really important. Great question. You need to manually contact people to use your node. Right out of the scope of this. Again, this is just for local development. You can do stuff on a marketplace, you can manually reach out to people, you can work with projects. But let's keep the questions focused on kind of running a local node.
01:01:01.730 - 01:01:33.306, Speaker A: But yeah, the answer could be yes. But yeah, you could also list it on a marketplace and just kind of have people reach out to you. You don't always have to manually reach out to people or you can list your job and just people will use it if they want to. Any other questions? I don't know if I missed any other questions. I think I did miss this one. So it's like when Oracle gets the data, it writes to the chain and contract using the associated wallet. Hence the reason for fulfillment.
01:01:33.306 - 01:02:04.306, Speaker A: Spot on. Yes. So you need to set fulfillment permission because exactly that the wallet of the node is going to be the wallet that's making the transaction back. And so we need to say, okay, yes, you're allowed to do this, otherwise that oracle contract just blocks everybody. So spot on. Great question. What other questions are there? We'll give it maybe 30 seconds.
01:02:04.306 - 01:02:47.334, Speaker A: I know we went over a lot of stuff here. Feel free to watch this video back. I know we kind of bounced around. The hardest part I think is really just getting, setting up like postgres and go and everything up correctly that first round. But then once you have it set up, then you can just kind of do that chain link local n and be good to go. Any other questions here? Let me move the questions up so I'm not like looking at the bottom of the screen, so I'm actually like looking at the camera. Thank you, I appreciate that.
01:02:47.334 - 01:03:32.594, Speaker A: So I know that there's a lot of stuff here, right? This is a great way to kind of test and run any customized data test with your own infrastructure, whatever you want to do. You absolutely don't have to, right. You can reach out to node operators, you can say, hey, I built this external adapter, hey, I'm looking for this data. You don't have to be the one to run the infrastructure. You absolutely do not. And if that's not even your forte, you probably shouldn't, right? If you want to just focus on DAP development, absolutely, just focus on DAP development and have another group of node operators run your data. And that's actually really ideal, right? Because you really don't want to be sending poor data, bad data or whatever to your blockchain.
01:03:32.594 - 01:04:04.654, Speaker A: So this is more, again for doing local development, for running a chainlink node for yourself, to kind of test, tinker, do whatever you want to do. With that. Thank you everybody so much for joining. We have an external adapters workshop later today with myself. We also have a couple other workshops. Oh, we have an awesome panel at noon est with UNESCO or UNESCO hopefully I'm saying that correctly on social impact. So you definitely don't want to miss that.
01:04:04.654 - 01:04:28.474, Speaker A: Definitely. Check that out. That's going to be a blast. But then after that, at the end of the day, we are doing external adapters workshop. This will show how to you to unlock that customization, that unlimited customization of your smart contracts, do all these interesting things. Can you show us bridge in next workshop? Yes, we're going to show you the bridge in the next workshop. You're talking about the external adapter talking about.
01:04:28.474 - 01:04:42.070, Speaker A: I'm assuming you're talking about the external adapter bridge. You're talking about the bridge tab in the UI, if that's what you're talking about. Yes, that is covered in the external adapters workshop later today, which I'm super excited to give. And I'll see you guys then. Thanks everybody so much for joining.
