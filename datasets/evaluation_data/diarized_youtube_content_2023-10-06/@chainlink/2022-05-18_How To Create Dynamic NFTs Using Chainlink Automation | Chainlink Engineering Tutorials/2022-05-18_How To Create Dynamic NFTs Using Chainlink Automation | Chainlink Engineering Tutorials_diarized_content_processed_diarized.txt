00:00:00.170 - 00:00:46.090, Speaker A: Pretty soon we should see another perform upkeep from our keeper. There it is. So at this point we should see if we request a refresh of this metadata, we should see on Opensea that our NFT is now a full set of blooms. Let's cross our fingers and boom, there it is. Same NFT, three different stages of growth. Hi, I'm Richard, one of the developer advocates at Chainlink Labs. And today we're going to take a look at how to take an NFT and make it dynamic using Chainlink keepers.
00:00:46.090 - 00:01:26.834, Speaker A: Most NFTs are static and that's good for the purposes that they're designed for. You want them to be static because they represent something like ownership. However, I think there's a lot of potential in NFTs and making them dynamic, making NFTs that change over time. Today we're going to take a look at one example of an NFT like that. So what are we going to be building? Well, let's take a look. When I think about dynamic things, I think about flowers as an excellent example of something that is dynamic. First of all, you have the seed and it grows over time into an entire plant with blossoms.
00:01:26.834 - 00:02:07.670, Speaker A: So we're going to make an NFT where the image and attributes change over time. It'll go from seed to sprouts and then to a blossom. How are we going to accomplish this? Let's take a look at a fairly simple and straightforward ERC 721 contract. This contract is based on open Zeppelin and they have some example contracts and a wizard on their website that will give you the skeleton for an ERC 721 contract. I've added a few things to that contract. Let's take a look at what I've added. The first thing that's different is this IPFs Uri array.
00:02:07.670 - 00:02:51.570, Speaker A: This array hosts the different stages of the NFT. We have the seed, the sprout and the blooms. If we take a look at what one of these contains, it's a json file. This json file contains all of the information about the NFT, including its name, description, an image that's also hosted on IPFs. The interplanetary file system, which is a distributed file system that allows you to ensure that the data behind the NFT doesn't change unless you want it to. What I mean is that this file within IPFs will never change. We can point our NFT to a different file and that's how we'll make it dynamic.
00:02:51.570 - 00:03:35.406, Speaker A: The image is also stored in IPFs and so these values are static, but we'll be changing which value our NFT actually points to. So what is behind this value won't change, but our NFT will change to point to this value as it grows. The second thing, speaking of growing, is a function called grow flower. All this does is it just changes that URI to point to a new value. So we want to make this NFT grow on its own. We want to automate it. If we head on over to the chainlink documentation, we can find the automate contracts documentation.
00:03:35.406 - 00:04:08.646, Speaker A: This is for Chainlink keepers. We need to make our contract keeper compatible. What does that mean? Essentially, we'll need to add two different functions to our contract. The first is check upkeep. That'll return a boolean that tells us whether or not we need to perform upkeep. Perform upkeep is the second function that actually runs whatever we need to within our contract to perform the upkeep to make those changes. This is how we'll automate our contract.
00:04:08.646 - 00:04:50.614, Speaker A: So what does this look like in practice? If we scroll down just a little bit, we can see both functions are here in this example contract. Now this example contract is going to be incrementing a counter. We don't want to do that, so we'll have to change things just a little bit. But copy and paste is a great place to start. If we head back to our contract, we can add these functions right here underneath the constructor, and we'll need to modify them just a little bit for our purposes. The first thing we'll need to do is understand what's going on with checkupkeep. So check upkeep returns a boolean.
00:04:50.614 - 00:05:35.414, Speaker A: Upkeep needed. That Boolean is generated by taking the current timestamp of the current block, comparing it to the last timestamp. That's going to be the last time that we performed upkeep and seeing if that's greater than an interval that we set. Last timestamp and interval are two values that this contract currently doesn't have, so we'll need to add them. They're both uns, so we can add them above the constructor. So we add interval, and then we also add last timestamp. And then we'll need to set them within the constructor as well as initialize the interval value.
00:05:35.414 - 00:06:12.558, Speaker A: I like to do that when the contract is deployed. So we'll create another value that's passed into the constructor, and then within this constructor we will set both the interval and we'll set that to the value that we just passed in and we'll need to set the last timestamp and we'll set that to the current block timestamp. Perfect. So we have our two values and that's all we need for checkupkeep. At this point. Check upkeep should be working just fine. Let's take a look at perform upkeep within perform upkeep.
00:06:12.558 - 00:06:37.642, Speaker A: It's highly recommended. Make sure you check. You actually need to run your upkeep again just on the OD chance that something has changed between check upkeep being called and perform upkeep being called. This is the function that's going to actually make a state change on the blockchain. So this is the function that's going to have a gas fee associated with it. So we check. Do we need to run this? We do the same.
00:06:37.642 - 00:07:09.862, Speaker A: Check the block timestamp minus the last time we checked. Is that greater than interval? If it is, then we need to update the last timestamp because we're going ahead and running this function. So our current timestamp that we're running at is now. And if you remember this example is updating a counter. We don't want to do that. We want to grow the flower. And grow flower is a function that takes in an integer that is the ID of the NFT we want to grow.
00:07:09.862 - 00:07:53.522, Speaker A: In this case I'm going to hard code it to zero, which is the first NFT that we will mint. And that's it. With those two functions, a couple of variables and we have turned our NFT contract into a keeper compatible contract. So let's go ahead and deploy this contract so that we can then let the keepers network know about it. We'll need to change to injected web three. That's going to take our metamask value here and inject it in. And we also need to make sure that we're deploying the correct contract on our deploy here we can see there's an interval and this is going to ask us for how often we want this to change.
00:07:53.522 - 00:08:22.912, Speaker A: I'm going to set it for 30. That's going to be 30 seconds. We deploy this contract, confirm the deploy, we'll wait for it to actually be deployed. We should see it down here in our deployed contracts and we should get a notification letting us know that it was actually deployed. Perfect. And now we can see we have our contract here. We haven't minted an NFT yet though, so let's go ahead and do that.
00:08:22.912 - 00:08:55.156, Speaker A: I'll mint one to my address and this will create an NFT in that seed phase. So there's a couple ways that we can watch this NFT grow over time. The first is we could look at the flower stage. This is going to be an integer. It'll be zero, one or two based on the index of those IPFS uris. We can also look at the actual Uri itself. So we'll see it change from seed to sprout to blooms.
00:08:55.156 - 00:09:20.828, Speaker A: If we take a look now at the flower stage for zero, remember that's the index of the NFT we just created. We should see it's currently a zero. And we can also take a look at the Uri and see it's a seat. Perfect. Let's head to Opensea and see if our NFT is there yet as well. We'll copy the address of the NFT contract. I'm running this on the Mumbai testnet.
00:09:20.828 - 00:09:49.848, Speaker A: So we need to head to testnets openc IO and we'll see if Opensea has it yet. It doesn't. Sometimes Opensea takes a moment to update everything. One other thing to point out is within Opensea we will have to refresh the metadata. Opensea caches metadata just to make things a little more performance friendly on their end. So we'll take our contract here and we'll head to keepers. Keepers chain link.
00:09:49.848 - 00:10:28.828, Speaker A: I am on the Mumbai testnet, like I mentioned. I'll connect my wallet so I can register a new upkeep. You'll need to fill out a little bit of information here. This is essentially going to let you be informed if you run out of link for your keeper. Link is how you incentivize the keeper network to do work for you. The last thing we'll need is the upkeep address, the address of our contract so we can copy that from remix head back here, paste it in. It won't be able to verify it because we didn't verify this contract on Etherscan or Polyscan.
00:10:28.828 - 00:11:00.224, Speaker A: So that's what's happening here. We know it's a keeper compatible contract, though. This is just letting us know that, hey, we can't verify it and then we'll register our upkeep again. We'll approve this transaction and once this transaction is approved, we should be able to take a look at the history of our upkeep and see what is going on there. So again, it'll take just a moment for this transaction to be approved. There we go. We can view our upkeep now.
00:11:00.224 - 00:11:31.200, Speaker A: So we have all the information. We have a balance of 0.5 link and we have our history here. So all we have so far is that we funded the upkeep. If we head back to our contract, we can see, hey, do we need to actually perform upkeep? We can run check upkeep ourself and you can see, hey, it's true. So upkeep is going to happen very shortly. While we wait for that to happen, let's go ahead and take a look at Opensea and see, hey, our NFT is now on Opensea.
00:11:31.200 - 00:11:46.368, Speaker A: Perfect. Here it is. You can see it was minted just a couple of minutes ago. It's a seed. And there's the image. Right, perfect. We're going to be bouncing around a little bit here between tabs, but let's go look at our upkeep and see if it's run yet.
00:11:46.368 - 00:12:05.200, Speaker A: It hasn't. Sometimes it takes a few moments for the keeper network to pick up the job, check for upkeep and then actually perform upkeep. So we'll give it a moment. We can check again. Check. Upkeep is now false. So that says if we look here, hey, we performed upkeep.
00:12:05.200 - 00:12:28.808, Speaker A: Perfect. Our keeper has grown the flower. Our flower stage is one. And our token UI has changed to purple sprout. Let's see if we can get Opensea to show us this change. We'll request it, refresh the metadata. Remember, opensea caches this, this is just kind of a interesting little thing on Opensea.
00:12:28.808 - 00:12:47.936, Speaker A: If you were to write your own front end, you could create within your contract an emit event on that grow that would say, hey, frontend, you need to update your data. So we requested that change. Hey, look at that. Our NFT has changed. That's awesome. You can see here the events. All we've done is mint.
00:12:47.936 - 00:13:10.972, Speaker A: It's still that NFT that we minted a few minutes ago, but now it's grown from a seed into a seedling. Awesome. Let's take a look and see if it's been 30 seconds yet. Okay. We're going to need the upkeep again pretty soon. We should see another perform upkeep from our keeper. There it is.
00:13:10.972 - 00:13:55.444, Speaker A: So at this point we should see if we request a refresh of this metadata. We should see on Opensea that our NFT is now a full set of blooms. Let's cross our fingers and boom, there it is. Same NFT, three different stages of growth. All we had to do was take our NFT, add in two fairly simple little functions, a couple of variables, and just like that, we've taken an NFT and automated its growth. Now, what can you do with this? This was a pretty simple example. We just grew a flower from a seed all the way to a beautiful blossom.
00:13:55.444 - 00:14:16.830, Speaker A: But what else could you do? These flowers, perhaps when the upkeep is performed, we take a look at weather data. Depending on the rain, maybe they grow, maybe they don't. Essentially, the sky's the limit here in what you can do once you've automated a dynamic nft with chainlink keepers. Thanks for watching, and I'll catch you in the next one.
