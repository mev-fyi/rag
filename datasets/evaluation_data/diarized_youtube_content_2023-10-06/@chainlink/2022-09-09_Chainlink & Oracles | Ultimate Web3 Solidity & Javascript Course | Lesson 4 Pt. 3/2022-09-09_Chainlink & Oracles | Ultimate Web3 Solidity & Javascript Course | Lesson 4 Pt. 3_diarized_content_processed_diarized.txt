00:00:11.130 - 00:00:34.822, Speaker A: So what we've done so far is great. However, we're checking message value in terms of Ethereum. We're looking for one whole ethereum. Instead of $50, we want to check that message value is greater than some number, like $50. Let's go ahead and first set the minimum USD value we want people to send along with the fund function.
00:00:34.956 - 00:00:46.300, Speaker B: We can do that at the top of our contract. We can say un 256 public minimum USD equals 50.
00:00:46.670 - 00:01:39.158, Speaker A: Now we have someplace to check for minimum USD. We're going to update this minimum USD to make it more gas efficient in a little bit. Now that we've set our minimum USD, we want to be able to require the message value is greater than, or let's say greater than or equal to the minimum USD. But minimum USD is in terms of USD and value is in terms of Ethereum. So how do we convert Ethereum to USD? This is where Oracles and Chainlink are going to come into play. The USD value of Ethereum is something that we've assigned outside of the blockchain to each Ethereum or any other layer, one currency or any other native smart contract platform currency. So in order to get this value that is outside the blockchain, we have to use a decentralized oracle network to get the price of one ether in terms of USD.
00:01:39.158 - 00:01:41.354, Speaker A: So before we can continue on here.
00:01:41.472 - 00:01:42.986, Speaker B: Let'S learn a little bit more about.
00:01:43.008 - 00:02:03.570, Speaker A: The architecture of these decentralized oracle networks and the different solutions that they have so that we can create this fundme contract in the most advanced way possible. As we've talked about, blockchains are deterministic systems, which means that they themselves can't actually interact with real world data and events. They don't know what the value of an ethereum is. They don't know what random numbers are.
00:02:03.640 - 00:02:05.058, Speaker B: They don't know if it's sunny outside.
00:02:05.144 - 00:02:28.038, Speaker A: They don't know the temperature, they don't know who's president, they don't know any of this information. These blockchains also can't do any external computation. Maybe you have some amazing artificial intelligence model that you want to integrate with a smart contract. Smart contracts by themselves can't do anything with that. As we've mentioned. This is because blockchains are deterministic by design. This is so that all the nodes can reach consensus.
00:02:28.038 - 00:02:55.022, Speaker A: If you start adding variable data or random data or values that return from an API call, different nodes could get different results and they would never be able to reach a consensus. This is known as the smart contract connectivity problem. Or the oracle problem. And this is bad news because we want our smart contracts to be able to replace traditional agreements, and traditional agreements need data and they need to interact with the real world. So this is where chainlink and blockchain.
00:02:55.086 - 00:02:56.674, Speaker B: Oracles come into place.
00:02:56.872 - 00:03:37.138, Speaker A: A blockchain oracle is going to be any device that interacts with the offchain world to provide external data or computation to smart contracts. However, the whole story doesn't even end there. If we use a centralized oracle, we are reintroducing a point of failure. We've done all this work to make our logic layer decentralized, but if we get our data through a centralized node or through a centralized API, or we decide we want to make the API call ourselves, we are reintroducing these trust assumptions that we've worked so hard to get rid of. We're essentially ruining the entire purpose of building a smart contract. So we don't want to get our data or do external computation through centralized nodes. Those are bad news.
00:03:37.138 - 00:04:22.010, Speaker A: Chainlink is the solution here. Chainlink is a decentralized oracle network for bringing data and external computation into our smart contracts. As we mentioned before, this gives rise to these hybrid smart contracts which combine on chain and off chain to make incredibly feature rich, powerful applications. Chainlink is a modular, decentralized oracle network that can be customized to deliver any data or do any external computation that you like. So for example, a lot of people say, oh, I can just make an HTTPs call to some API and we'll be good to go. The blockchain nodes can't make these HTTPs calls because they wouldn't be able to reach consensus. If they called the node at different times or they did something else, all the consensus would be broken.
00:04:22.010 - 00:04:50.562, Speaker A: So instead we need a decentralized network of Chainlink oracles to do this, and then in the transaction, this network of nodes will return the data to our smart contracts for us. Now, Chainlink networks can be completely customized to bring any data or any external computation that you want. However, doing the customization can be a little bit extra work. There are a ton of Chainlink features that come out of the box completely decentralized, ready to plug and play into your smart contract applications. What are those features?
00:04:50.626 - 00:04:51.638, Speaker B: The first one is going to be.
00:04:51.644 - 00:05:31.126, Speaker A: Chainlink data feeds, and that's the one we're actually going to be using for our application here. Chainlink data feeds, currently at the time of recording, are powering over $50 billion in the DFI world. The way they work is a network of Chainlink nodes gets data from different exchanges and data providers and brings that data through a network of decentralized Chainlink nodes. The chainlink nodes use a median to figure out what the actual price of the asset is and then deliver that in a single transaction to what's called a reference contract, a price feed contract, or a data contract on chain that other smart contracts can use. And then those smart contracts use that pricing information to power their DeFi application.
00:05:31.228 - 00:05:32.966, Speaker B: We can see an example, we can.
00:05:32.988 - 00:05:44.810, Speaker A: See an example at data chain link and you can change networks, you can change price feeds, you can change a whole bunch of information. To see some of the most popular price feeds, let's look at ETh USD for example.
00:05:44.960 - 00:05:46.826, Speaker B: On ETH USD we can see this.
00:05:46.848 - 00:06:13.582, Speaker A: Whole network of independent chainlink node operators that are each getting different answers for the price of ETH USD. They're getting aggregated by the network and then delivered on chain. We can see how often they're updated. These ones are updated for a zero five deviation threshold or a few hour heartbeat, whichever one hits first. We can see when the last update was. We can see the number of oracle responses, et cetera. We can see the contract address directly on chain.
00:06:13.726 - 00:06:23.558, Speaker B: We can even look at the contract on Etherscan. We can see some of the history, we can see all the responses of the different oracles. And then at the bottom we can.
00:06:23.564 - 00:06:25.906, Speaker A: See the different users and sponsors keeping.
00:06:25.938 - 00:06:30.114, Speaker B: This network up similar to transaction gas.
00:06:30.242 - 00:07:07.858, Speaker A: Whenever a node operator delivers data to a smart contract, the chainlink node operators are paid a little bit of oracle gas in the chainlink token. Right now these users of the protocol are sponsoring keeping these feeds up and are paying the Oracle gas associated with delivering this data on chain. Here's an illustration of what the current model of these data feeds look like. A network of these chainlink nodes each reaches out and gets the information about an asset and then signs the data with their own private key. In a single transaction. Then one node will deliver all the data with all the different signatures to a reference contract. If that node doesn't deliver the data, another node will send it instead.
00:07:07.858 - 00:07:27.850, Speaker A: Reputation is incredibly important when you're a chainlink node operator. If you miss data updates, if you forget to send transactions, you'll probably be quickly kicked off these networks and have no chance of making any more money in the future. These data feeds are used by some of the largest protocols in the space, such as Synthetix, Sushiswap Compound and Aave with several billion dollars each.
00:07:27.920 - 00:07:28.906, Speaker B: We can take a look at an.
00:07:28.928 - 00:07:33.058, Speaker A: Example over at Docs chain link work with EVM contracts.
00:07:33.094 - 00:07:37.934, Speaker B: We're going to hit EVM chains, scroll down to data feeds, we'll scroll down.
00:07:37.972 - 00:07:43.838, Speaker A: To the solidity section and we can see an example of an entire contract that uses and reads from one of.
00:07:43.844 - 00:07:45.182, Speaker B: These Chainlink price feeds.
00:07:45.326 - 00:07:47.346, Speaker A: We can even open this up in.
00:07:47.368 - 00:07:50.190, Speaker B: Remix and work with it in remix.
00:07:50.270 - 00:08:22.150, Speaker A: It looks like this example is reading from a price feed on coven. The reason we're actually going to use a testnet to see this work is that there's a set of Chainlink nodes monitoring the test network to show you exactly how this works out. Once we get deeper into the course, we'll show you how to actually run tests and work with Chainlink nodes without actually being on a testnet, which will make your development much faster. But I highly recommend walking through this section along with me so that you can see firsthand how this actually works. So let's go ahead to faucets, chain link slash coven.
00:08:22.230 - 00:08:28.954, Speaker B: We're going to switch to the coven network and we're going to get some coven eth. But remember, look at the network flag.
00:08:29.002 - 00:08:33.758, Speaker A: And use whatever network is in the documentation. So to get some coven, we're going.
00:08:33.764 - 00:08:35.058, Speaker B: To come to the faucet, we're going.
00:08:35.064 - 00:08:36.946, Speaker A: To turn off test link, we'll just.
00:08:36.968 - 00:08:42.622, Speaker B: Stay with ETH, I'm not a robot, and then send request.
00:08:42.766 - 00:08:46.626, Speaker A: Once our coven Ethereum has reached our wallet, we can go ahead and close.
00:08:46.728 - 00:08:48.514, Speaker B: And we can take a look in.
00:08:48.552 - 00:08:54.194, Speaker A: Our wallet and see that we do indeed have 0.1 eth on coven. Now let's go back to our remix.
00:08:54.322 - 00:08:57.014, Speaker B: We'll compile this contract, we'll go and.
00:08:57.052 - 00:08:59.094, Speaker A: Deploy this on injected web three.
00:08:59.212 - 00:09:00.538, Speaker B: And again, the reason we're going to.
00:09:00.544 - 00:09:02.534, Speaker A: Use injected web three instead of Javascript.
00:09:02.582 - 00:09:05.386, Speaker B: VM is that there's no network of.
00:09:05.408 - 00:09:08.582, Speaker A: Chainlink nodes watching our little fake Javascript VM.
00:09:08.646 - 00:09:12.038, Speaker B: There are a network of Chainlink nodes watching the testnet.
00:09:12.214 - 00:09:16.686, Speaker A: So we'll scroll down, we'll switch contract to the price consumer v three and.
00:09:16.708 - 00:09:19.246, Speaker B: We'Ll hit deploy metamass will pop up.
00:09:19.348 - 00:09:52.898, Speaker A: And after a brief delay we can see our price feed consumer down here and we can hit get the latest price which shows us the latest price of Ethereum in terms of USD. You may be wondering why the number looks so weird. That seems like a really large number for the price of Ethereum in terms of USD. And this is because decimals don't actually work so well in solidity and we'll get to that in a little bit. There's a decimals flag associated with this price feed address that tells us how many decimals to include with this price. It's also in the documentation. However, I know that this one has eight decimals.
00:09:52.898 - 00:10:01.390, Speaker A: So this is saying the value of Ethereum right now is $3,262. It may of course be different when you go ahead and try this.
00:10:01.460 - 00:10:02.654, Speaker B: Now, there's a number of things that.
00:10:02.692 - 00:10:24.594, Speaker A: Happen in this contract that I'll explain in our fundme example, but if you want to take a look now and see if you can figure out what's going on, I recommend you do so. Price feeds are one of the most powerful out of the box decentralized features you can use in your smart contract to level them up, especially for decentralized finance. If you're looking for different addresses of different price feeds, you can check the contract addresses section of the documentation, choose.
00:10:24.632 - 00:10:26.706, Speaker B: The network that you want and then.
00:10:26.728 - 00:11:12.498, Speaker A: Scroll down and then look some of the different addresses of the different price feeds. For example, this address will give you the price of one inch token. In terms of Ethereum, this address will give you the price of the Apple stock in terms of USD and so on and so forth. The next decentralized application right out of the box is going to be chainlink VRF or Chainlink verifiable randomness function. Once we do our lottery example a little bit later, we'll talk about how randomness can be manipulated in blockchain. Blockchains are deterministic systems, which by definition means that they can't have randomness. If you can determine what a random number is, it's not really random anymore, is it? So we need a way to get a provably random number by looking outside of the blockchain, and oracles are perfectly positioned to do exactly that.
00:11:12.498 - 00:12:07.762, Speaker A: Chainlink verifiable randomness function is a way to get provably a random number into our smart contract. To guarantee fairness and guarantee randomness of applications, many protocols like pool together, axie Infinity, ether cards, avagoches, and more, use chainlink VRF for lotteries, for randomizing, nfts for gaming, and for more. We're going to do an example of Chainlink VRF in a later section once we get to the lottery section. If you want to see if you can play with the randomness yourself right now, I recommend you going to docs chain link evm chains and scroll down to get a random number. And this will teach you how to get a provably random number into your applications. The next decentralized out of the box feature of Chainlink is Chainlink keepers, which is decentralized event driven execution. As you've seen, in order to kick off some type of transaction, somebody needs to spend the gas and somebody needs to sit down and hit the go button or hit the transact button or hit the send button.
00:12:07.762 - 00:12:51.362, Speaker A: This is obviously a centralized vector if you have a decentralized application that needs to run at specific times or after specific events are triggered. Chainlink keepers are the solution to this. Chainlink keepers are chainlink nodes that listen to a registration contract for different events that you specify to fire. Maybe you say every ten minutes you want to do something, or once a week do something. Or if the price of some asset hits some number, or maybe a liquidity pool is at a certain level, whatever event that you want to code, you absolutely can. The chainlink nodes constantly listen for these triggers to happen and check the different contracts for these triggers. Once a trigger returns true, the chainlink nodes will then perform whatever action that you tell the chainlink nodes to do.
00:12:51.362 - 00:13:07.286, Speaker A: We're also not going to go over the chainlink keepers examples right now because we're going to get to them in a later module. However, if you want to try them out, go to docs, chain link, ethereum and go to making compatible contracts. And feel free to read the documentation and try it out yourself.
00:13:07.388 - 00:13:08.626, Speaker B: The last out of the box feature.
00:13:08.658 - 00:13:30.174, Speaker A: Of Chainlink is the most customizable, but also the hardest to get correct. End to end reliability is the ultimate promise of our smart contracts and we want and need them to be able to do anything. We want to be able to take any input and get any output. Making HTP get HTP post requests is an easy way to customize our chainlink nodes to be able to do anything.
00:13:30.292 - 00:13:32.234, Speaker B: Remember how we talked about making API.
00:13:32.282 - 00:13:59.794, Speaker A: Calls that blockchain nodes themselves can't do that? Well, Chainlink nodes can do that. Chainlink nodes can make direct requests to any API that you specify. In order to do this, you both have to choose the Chainlink node and the URL data to send the request to. This is a little bit trickier than Chainlink VRF keepers or price feeds because you then have to be responsible for creating the chainlink network that gets data from many different Chainlink nodes and many different data providers.
00:13:59.842 - 00:14:03.598, Speaker B: But let's look at an example in remix anyways for this section.
00:14:03.634 - 00:14:11.562, Speaker A: Feel free to just watch since we are working with a testnet here. And testnets as we've seen, can take a little bit of time as long as you're familiar with what this process looks like.
00:14:11.616 - 00:14:12.362, Speaker B: That's good enough.
00:14:12.416 - 00:14:14.478, Speaker A: You don't actually have to try it if you don't want to.
00:14:14.564 - 00:14:16.730, Speaker B: So we'll open up in remix, we'll.
00:14:16.810 - 00:14:22.890, Speaker A: Read through it looks like this example is on the Coven network. So we'll go ahead and compile API consumer.
00:14:22.970 - 00:14:24.570, Speaker B: We're going to go ahead and deploy.
00:14:24.650 - 00:14:26.158, Speaker A: On the injected web three.
00:14:26.244 - 00:14:27.806, Speaker B: We're going to make sure that we're.
00:14:27.838 - 00:14:29.598, Speaker A: Back on the coven test network.
00:14:29.694 - 00:14:31.758, Speaker B: We're going to scroll down and we're.
00:14:31.774 - 00:14:33.346, Speaker A: Going to change the contract to the.
00:14:33.368 - 00:14:36.462, Speaker B: API consumer, and we're going to go ahead and hit deploy.
00:14:36.606 - 00:15:03.510, Speaker A: We're going to deploy this contract to the coven testnet. And now we can call this function called request volume data to actually make an API call. Now, like I mentioned before, whenever we request data from a chainlink node, we have to pay a little bit of Oracle gas or link token. In order to pay some link token, we're going to need to have link token in our API consumer contract. This is what's known as the basic request and receive model. To get link token, we go back.
00:15:03.520 - 00:15:05.466, Speaker B: To our faucet and this time we'll.
00:15:05.498 - 00:15:09.258, Speaker A: Select ten test link for our contract. Let's go ahead and verify that we're.
00:15:09.274 - 00:15:11.338, Speaker B: Human and we'll hit send request.
00:15:11.514 - 00:15:25.586, Speaker A: This time, instead of sending us ethereum, they're sending us ten test link, which is what's known as an ERC 20 token, or more accurately an ERC six seven seven. We'll get to understanding that a little bit later. We can see the asset in our.
00:15:25.608 - 00:15:29.778, Speaker B: Metamask by importing the token. In order to get the token, we're.
00:15:29.794 - 00:15:31.346, Speaker A: Going to come back to the documentation.
00:15:31.458 - 00:15:38.450, Speaker B: And we're going to look up link token contracts like that. We're going to go to the network.
00:15:38.530 - 00:15:41.690, Speaker A: That we just got the tokens on which for us was coven.
00:15:42.030 - 00:15:47.050, Speaker B: We're going to copy this address, we're going to go to Metamask, hit import.
00:15:47.120 - 00:15:49.994, Speaker A: Tokens, paste that address, and hit add.
00:15:50.032 - 00:15:52.838, Speaker B: Custom token, and then import tokens.
00:15:52.934 - 00:16:05.266, Speaker A: And now we can see in our account, one, we both have ethereum and ten link. Now that we have our link or our Oracle gas, we're going to send it to our API consumer. We're going to copy the address of.
00:16:05.288 - 00:16:10.786, Speaker B: The API consumer, open up our metamask, we're going to hit send, paste the.
00:16:10.808 - 00:16:17.846, Speaker A: Address of our contract, switch the asset to link. For now, we'll just send 0.2 link.
00:16:18.028 - 00:16:23.046, Speaker B: We'Ll hit next, we'll hit next and we'll hit confirm and we'll wait for.
00:16:23.068 - 00:16:27.254, Speaker A: This transaction to go through. I chose 0.2 link because in this.
00:16:27.292 - 00:16:30.898, Speaker B: Contract there's a fee character which tells.
00:16:30.914 - 00:16:46.170, Speaker A: Us how much making an API call for this is going to cost. This one is actually 0.1 link. I send 0.2 just in case we want to make that API call twice. Everything that's going on in this function will explain in a little bit later section, but for now I just want to show you what it looks like to dos.
00:16:46.250 - 00:16:47.406, Speaker B: Once we send the link to our.
00:16:47.428 - 00:16:49.454, Speaker A: Contract, we can first check to see.
00:16:49.492 - 00:16:53.678, Speaker B: What the volume is. Volume is zero. We want to get the volume of.
00:16:53.684 - 00:17:08.962, Speaker A: The last 24 hours of the Ethereum asset. We're going to be calling this API, which has a ton of raw data, including one in specific called volume, over the last 24 hours, which is going to be this number right here. Say we wanted to get this into our contract from this API.
00:17:09.026 - 00:17:10.566, Speaker B: We're going to make an HTTP get.
00:17:10.668 - 00:17:14.486, Speaker A: Call to this API, and what's going to happen is we're going to make.
00:17:14.508 - 00:17:17.654, Speaker B: The request in one transaction, and in.
00:17:17.692 - 00:17:27.494, Speaker A: A second transaction the chainlink node is going to return the value and store it in this volume variable in the global scope. So let's go ahead and hit request volume.
00:17:27.542 - 00:17:30.826, Speaker B: Data Metamask is going to pop up. We're going to go ahead and hit.
00:17:30.848 - 00:17:35.998, Speaker A: Confirm, and you'll notice right away volume doesn't update. This is again because we actually need.
00:17:36.004 - 00:17:37.978, Speaker B: To wait two transactions.
00:17:38.074 - 00:18:04.370, Speaker A: We're sending a transaction for the request, and then in a second transaction the chainlink node is actually going to respond. And after a slight delay, the Chainlink node has indeed responded with the result of making that API call back to our contract. We'll go over this process a little bit more in depth in later sections. The reason that I wanted to show you specifically the API calls is because we're going to show you a real life example of how to use Chainlink VRF and Chainlink keepers. In a later lesson.
