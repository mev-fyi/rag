00:00:00.330 - 00:00:47.530, Speaker A: Welcome to Chainlink Research Reports, a YouTube series featuring research across the web, three industry and academic fields with scholarship that expands our understanding of decentralized technologies. I'm Dr. Jason Anastasopoulos, a researcher at Chainlink Labs and an assistant professor of public policy and statistics at the University of Georgia. Today I'll be joined by Dr. Thomas Kerber, a technical architect at input output IOHK, who will be presenting his paper entitled Kashina Foundations of Private Smart Contracts. The paper provides a rigorous theoretical framework for privacy preserving smart contract design and implementation. Specifically, this paper proposes Kashina a protocol for deploying and securing privacy preserving smart contracts, which encompasses previous systems.
00:00:47.530 - 00:00:59.470, Speaker A: Kerber then demonstrates how Kashina can be used to create a contract that implements privacy preserving payments along the lines of zcash, which is provably secure. And now here's Thomas Kerber.
00:01:06.230 - 00:02:10.806, Speaker B: All right, I'll be talking about Kachina today, which is a paper on private smart contracts by myself and my co authors, Aglos Chias and Michael Kolweis. It was completed while I was at the University of Edinburgh and with the support of input output global. So before I get into anything else, I really want to give an overview of what I mean when I talk about privacy and smart contracts. In particular, I want to compare with some of the solutions that have previously been proposed and talk a bit about the trade offs and the issues you tend to run into when you try to build anything related to privacy and smart contracts. I'll then hopefully be able to argue why Kachiner is a better foundation and can help contract developers build private systems. So to start off with, I want to make sure we're on the same page with what we understand as smart contracts. And there's a couple of mistakes you can make here.
00:02:10.806 - 00:02:58.354, Speaker B: You can try to be too concrete and you can look at what are people doing now, what are Ethereum smart contracts? And then try to do small increments and add privacy that way. And unfortunately, this doesn't help us figure out what we would actually like to achieve, and it only gets us part way. The opposite side. You can go much too vague with this. You can go back to Nixavo's original conception of smart contracts, and you can think of them as programmable legal contracts, which is a very powerful notion and gives you a goal to strive towards. But it also doesn't tell you anything about how you could possibly get there. So instead, what I want to focus on is the notion of reactive state machines.
00:02:58.354 - 00:04:16.640, Speaker B: And in practice, we see that all smart contract systems nowadays are instances of reactive state machines. You have a central machine, which is usually called the smart contract, and multiple users interact with this. The contract is a contract in the sense that it governs how users may interact in a programmable way. Now, there's an interpretation of this as just a computer science construct of a state machine with various channels interacting with this. It's not a particularly standard state machine and that it has different channels for inputs and outputs, but it's something that can be formalized quite well. But I also want to note that this model is conceptually very close to the architecture that underlies really the majority of the Internet, and that is the client server architecture. And the reason I point this out is because it shows what smart contracts are competing with, and it also shows that if you compromise too much on what you can do, then you just end up with client service systems and no longer with a decentralized system.
00:04:16.640 - 00:05:06.480, Speaker B: And for this reason, I think that decentralization is really the key aspect to focus on with smart contracts. So if you don't care about decentralization and you want an auction contract, just go to eBay. If you want to have matching of buyers and sellers, that's your Amazon. It seems a little silly to talk about a centralized social network when decentralized ones really haven't taken off. But every decentralized system has a centralized alternative because we've had client server architectures for decades now. One important difference is that in a centralized system, your privacy relies on trust. And you can see in particular how in the case of Facebook, for instance, that might not be a particularly great idea.
00:05:06.480 - 00:06:01.070, Speaker B: Now, unfortunately, the privacy story doesn't actually get better in the decentralized case. And the reason for this is how the decentralized smart contracts are usually realized. So they usually start with a blockchain system, which essentially means you have some ordered graph of blocks containing transactions. And then specifically for smart contracts, these transactions have a very specific structure. They simply contain the message that you are sending to the reactive state machine. So if Alice wants to bid in an auction contract, then a transaction would just be a message saying Alice bids some value, in this case $5. And the problem with this is it by design, gives no privacy.
00:06:01.070 - 00:06:57.874, Speaker B: And this limitation might seem somewhat inherent. And I'm going to argue further into this talk that at least in part, it is inherent, although there are certainly things that can still be done. So one of the very early works that tried to add privacy in any degree to this was hawk. And this showcases one of the common patterns when it comes to adding privacy to smart contract systems, and the pattern of hawk is that it decides to recentralize in terms of privacy. So specifically, Hawke nominates a party, which they call the manager, to hold your private data on your behalf. This party can't cheat, it has to abide by the rules of the contract. So in particular, it has to prove to everyone else that it handled your private data in the correct way.
00:06:57.874 - 00:08:00.114, Speaker B: And this means that you still get something above centralized systems, because you are not in a situation where the manager can say steal your funds, they can steal your data. And this is arguably something which is a bigger issue in centralized systems. I would usually trust large corporations to do what they claimed they do, but I would not trust them not to also take my data and sell it to a third party. And you notice a similar pattern with various other things. And so often you find privacy almost by accident. So this is the case in say arbitrum, where the primary goal is to move computation off chain and to say, parts of a smart contract don't actually need to be executed by everyone. A side effect of that is if they're not executed by everyone, then not everyone needs to see it, and you get privacy.
00:08:00.114 - 00:09:10.234, Speaker B: In an optimistic case, if everyone who's in the committee in arbitram is trustworthy, then you also get privacy for free. Related but still conceptually different approach is that of using secure hardware. And I always find it amusing when I cycle to this slide, because I could not find a good logo of Intel SGX. I'm not particularly sorry for it though, because it lets me make my point more clearly. There's a number of very notorious exploits that allow exfiltrating data from secure hardware enclaves, and plunder vault is one of those. And seemingly every year a couple more of these come out. And this is a particular issue in the case of smart contracts, because if you have a system where not only does your transaction contain private information, and it needs to be handled by a secure hardware system, but also it needs to be replicated, which means you need to send it to anyone who asks for it.
00:09:10.234 - 00:10:19.486, Speaker B: So not only does someone get a chance to extract meaningful information from it, they get the opportunity to try again and again until they succeed. And to my mind, this makes anything that uses secure hardware a non starter, until these systems are much more robust. So it's bears mentioning that there is quite powerful cryptography that can actually do exactly what we're looking for in terms of privacy and smart contracts. So in particular, we want an arbitrary reactive state machine. The same as I showed before, to somehow be implemented in a decentralized way. And importantly, in contrast to systems like Ethereum and Cardano, for this not to be to reveal anything about its operation, besides, of course, what the state machine reveals by its own accord. And there's a cryptographic primitive that does this, and it's a secure multiparty computation, or MPC.
00:10:19.486 - 00:12:03.998, Speaker B: And in particular, if you run this, say, on a committee based chain like Algorand, or if you combine it with recent works on blockchain friendly multiparty computation protocols, such as I believe you only speak once you get this kind of construction, where for every contract call, you just have everyone who is a member of this either fixed or spontaneous committee, however it is managed, participate in computing the result, the only drawback, is that this is orders of magnitude more expensive than traditional smart contracts, which we already have scalability issues with. So this is something which, in the vast majority of cases, it doesn't seem like an appropriate solution. So how can we start thinking about the domain where appropriate solutions might be? And for this, I revisit the idea of decentralization. And in particular, one of the problems of the MPC idea is you attach very complicated machinery, or you attach multiple pieces of very complicated machinery to each other, and you get a multiplicative increase of complexity. Not only do you need to have consensus between everyone, but now you also need to compute the state of a contract between everyone. Now, this is in contrast to traditional smart contract systems, where things operate on a transactional layer. The blockchain itself has difficult time in agreeing on the ordering of transactions.
00:12:03.998 - 00:13:04.930, Speaker B: But after you've agreed on that, the computational part of smart contract execution is relatively simple. It's made hard by the fact that everyone has to replicate it and do the same computations for all interactions with a system. So my point is, if we want to build a blockchain system, there is an inherent structure that it implies. It implies that we make transactions, and that these transactions can be then later evaluated and we can find out what effect did a transaction we made in the past have. And it might come as a surprise that just this setting of having a blockchain system, which is transaction based, inherently limits the privacy that you can have. And I'll illustrate this on a small example. So you may be aware of a contract called the king of Ether.
00:13:04.930 - 00:13:53.800, Speaker B: And if not, then I'll explain it here anyway, because I'm making a slight variation. And the basic idea is that of a Ponzi scheme. There is a fro, and you can buy the frohne off the previous owner, provided you pay a multiplicative increase over what they paid. And one slight change that I'm going to make is I'm going to say that you have to pay at least this multiplicative increase so you can pay more if you want to, and you don't get a difference refunded. You just either succeed in getting the throne or you don't. Now, let's assume that we were able to make this variant perfectly private. Then this contract should hide what the value of the throne is at any time.
00:13:53.800 - 00:14:47.798, Speaker B: It should also hide who is holding it and when the phone was obtained, it should hide all of these just by virtue of the contract itself, never revealing them. All it reveals is whether you acquired the throne or not. Now, it turns out that it can't hide this. And the reason for this is essentially a quirk of the transactional model of smart contracts. It's that you don't have to transmit a transaction to be able to see what effect it would have. So, in particular, if I'm coming along at the end of this chain of blue, green, yellow and pink transactions, I can make a transaction without ever transmitting it in which I try to acquire the phone. Let's say I bid $20 for it.
00:14:47.798 - 00:15:31.160, Speaker B: I can then move ahead and say, I got it. I can lower my bid without again translating the transaction and seeing what would have happened had I bid $10. Maybe I don't get it. Well, let's try 15. Essentially, you can perform binary search to find, to arbitrary precision, what the value of the throne is now. But also you can start modifying history, and you can start checking at which point it acquired this value. And in essence, you can find out not only what its current value is, but what its value was at any point in time, something that we explicitly said you should not be able to find out.
00:15:31.160 - 00:16:31.770, Speaker B: So what does this mean? Essentially, this means we have to restrict ourselves in the types of privacy we are able to achieve and what we are able to express. And Kachiner is an attempt to capture what we can do and how to reason about it. So the core observation that we start off with in Kachin is that there are two tools that we have at our disposal. The first of these is the blockchain. This is a very powerful tool, but it provides no privacy by design. Everything that goes on chain is public and is shared by everyone. The second tool that we have is users have their local machines, and this is something which they can store private information on, but which cannot be accessed by anyone else, which you might argue is part of the definition of private.
00:16:31.770 - 00:17:46.254, Speaker B: But it's not immediately obvious that private information cannot be interacted with by anyone else, just that they can't extract any meaningful information from it. It turns out that of course, this is the simplest way to model privacy, to say that if it never leaves your machine, then it is of course private. And this is the premise that we build off for Kachina. So if we revisit the original design of state machines, there's actually a quite natural interpretation of this. And that is that if we have a bunch of users and they are all labeled x in this figure, then each of these users interacts with a shared public state representing the blockchain consensus sigma, but also interacts with their own private state, Row X, which represents what they locally store on their machine. Now, how would an interaction with such a state machine look like if we wanted to write it as a program? Well, start off with we start with what we want our program to be doing in the first place. We want it to take some input and eventually produce some output.
00:17:46.254 - 00:18:47.160, Speaker B: And part of how this will operate on chain is that this will be placed in sequence among other similar smart contract executions. And perhaps the output produced will depend on where it is placed in the sequence, perhaps not. Now, we want this interaction to be somewhat stateful. It's a bit boring if this is a simple function execution. So what we want is to be able to interact both with our public state, but also with the private state that I just discussed. Now, we model this in Kachiner as a series of queries and responses, where each of these queries asks something about the public state. So, for example, if we were interacting with an auction contract, we might ask, what phase is this auction in? Has it closed yet? Are we able to withdraw our winnings? Or it might ask, what is the winning bid? If of course, the auction contract isn't written with privacy of the winning bid in mind.
00:18:47.160 - 00:20:01.226, Speaker B: On the other hand, there are also queries to the private state of the smart contract. And in the case of an auction system, this might be, have I bid anything in the past? And if so, what? And clearly, simply by an interaction, as a series of queries and responses, you can express anything that you want in terms of how to interact with these states. One thing I forgot to mention, that's assuming, of course, that these queries allow you to update the states as well. So for example, a query might also be please place this bid on this auction. So the next question then is, well, what are these queries and responses actually doing? We can write queries all we like and define how we want responses to look like, but there must be something mechanically going on to facilitate this. Now, the way this is modeled in Kachina is with universal machines. And specifically, these are machines which are instantiated with the current state.
00:20:01.226 - 00:20:49.020, Speaker B: So in the case of the public state, it's instantiated to Sigma. In the case of private state, it's instantiated to row the term z. Here is the context which I include for completion, but I will not be going into it in this talk. And these universal machines can interpret some language of queries as a function to execute against the current state, producing a new state and a response. Now, what this language is does not matter. For Kachina, however, you could set this either to be specific to a smart contract, or to be generic and as arbitrary as you like. So, for example, you might choose the language of lambda calculus, if you want to be as general as possible.
00:20:49.020 - 00:21:53.970, Speaker B: Now, this structure induces a separation of concerns that we have part of this diagram, namely that which is concerning our private state, and the central part of the contract execution itself, which we would like to be private. We would like to hide what is going on in here and not reveal it to anyone else. But on the other hand, we obviously cannot hide what's going on on the public side. These are pieces of information which necessarily have to make their way on chain. Otherwise, the public state is not actually public, and it is not actually represented by the onchain state. On the other hand, we also want to be able to trust part of our contract, and we want to know that this part of the contract works reliably. This is not something that we can say about what a user arbitrarily does on their own machine.
00:21:53.970 - 00:22:55.106, Speaker B: Now, we can say it with certainty about things that we replicate in the network. That is in particular going to be the universal machine dealing with the public state and the queries and responses that are going to be executed against it, which I will go into in a moment. But as I will say, it can also be applied to the central part of a contract. And this is facilitated through the powerful cryptography of zero knowledge proofs, where we can show that we are doing the right thing without showing how we are doing it. So I'll go into that a little bit now, and as a technical requirement for this, we need to be able to separate this diagram. Again, these can't just be streams of data talking to each other, but they need to be seen as separate functions that are executable, separate from each other. To do that, we capture what data actually flows through them.
00:22:55.106 - 00:23:52.360, Speaker B: And this data needs to be fixed. We capture it in two transcripts of queries and responses. Transcript of private state on the left, the transcript of public state on the right. Now, having these transcripts allows us to again say, well, what happens if we get rid of the interpretation of state itself? What we are left with is a description of the behavior of the central part of the contract, the part that is the meat, the rules of the contract. And in particular, we can prove the correctness of this. What this means is that we prove that given a certain input, a contract will make the corresponding queries, so long as also it gets the responses it expects. Notice that we don't actually prove anything about the output, because this is something that only the author of a transaction actually cares about.
00:23:52.360 - 00:24:51.900, Speaker B: On the other hand, you can also view this from the onchain perspective, where the question is, if you have the series of careers and responses, and by virtue of what we just proved, you know, that it was generated in a legitimate way, what effect does this have on the state of the chain? The answer is quite simple. You just try and replay these queries against the current state. Now you check every time whether it produces the expected response. If it doesn't, then something went wrong and the transaction is marked as invalid. If it does, you continue until the end, at which point the transaction is valid. You have an updated state to work from. You can do the same thing on the private side, although it's a little more subtle as to when you actually have to do this and is related to having.
00:24:51.900 - 00:26:11.060, Speaker B: It's related to cases where the transactions you made make it on chain in a different order. So it only really matters for your unconfirmed transactions to be able to do this. Now finally, I want to briefly touch on a point, and that is that most smart contracts don't naturally fit within this separation of shared public and local private states. So what we also show is a way to construct a blueprint smart contract, which I have here on the right hand side labeled private payments, which works in a setting where you do have a shared and private state. Now this is not a realistic assumption, but this is an assumption which lets you specify how you would like a contract to behave, and you can then also specify your actual implementation of the contract, which works in the setting which we know how to implement. That is that of a shared public state and a local, non shared private state. So in this case, for the situation of private payments, our work was already done for us here in that the zero cash protocol gives us an example of how you can build this.
00:26:11.060 - 00:26:33.100, Speaker B: And what we showed is that you can fit the zero cash system into our model and demonstrate that it's equivalent to the notion of the private payments contracts working with shared private state. So that's all I have for you for the presentation. Thank you for listening, and I will happily take your questions.
00:26:36.110 - 00:27:08.200, Speaker C: Thanks, Thomas, so much for that great presentation of this fascinating work. I have two quick clarifying questions and one big picture question that I hope you wouldn't mind answering. So I'll start with the clarifying questions. So you introduce state oracles which perform actions on the basis of the current public and private state of a smart contract at any given time, kind of like the graph. Do state oracles differ from currently existing oracles in a fundamental way, and if so, how?
00:27:10.170 - 00:28:07.878, Speaker B: Right? Yeah, thanks for the question. So this is an unfortunate clash of terminology in that using the term oracle in the context of smart contracts unfortunately brings to mind oracles where you're trying to get external data on chain. Now, they're conceptually somewhat related, but they're also quite different in how they're used. The way it was used in the Kachina paper was more in line with other cryptographic literature, where oracles are usually just used as a means of abstracting interaction with information. So you see things. For example, you might hear talk of encryption oracles in the definition of the security for encryption schemes. And what's meant there is just, you can ask someone to encrypt a message, but you don't know their secret key.
00:28:07.878 - 00:29:02.780, Speaker B: And it's a similar case here where the oracles of Kachina are a case where you're saying you can ask someone to operate on some state in a way, so you can ask them to retrieve some information from that state or to update it in some way, but you don't have access to the state itself directly. Now, you might spot some parallels in that this level of indirection is also present for onchain oracles. What's a mark of difference, I think, is that in on chain oracles, it's quite important to also capture who is able to change how this oracle behaves, and that's usually a much bigger focus there, while state oracles are very much just a technical abstraction. Thank you.
00:29:03.470 - 00:29:24.610, Speaker C: In the paper, smart contract interactions are assumed, as I understand it, to be between non malicious smart contracts. Can you explain what a malicious smart contract is and provide an example of how a malicious smart contract might interact with non malicious smart contracts.
00:29:25.750 - 00:30:26.466, Speaker B: Yes. So there's two things here, and I think the first is that in Katrina, we really didn't focus very much on smart contract interactions in the first. So this was kind of our cheat card here that we said, well, if you do want to interact between smart contracts, you should have a picture of everything that's going on, and you should know the whole view of what effects your transaction will have. Now, an example of where this isn't necessarily the case would be in the reentrancy bugs that caused the Dow hack. So there it was an example of the Dow itself was, at least to some definition, secure. It's just in interactions with a malicious contract that things broke down. And specifically, it was in an interaction with a malicious wallet that would again, reenter and try to withdraw funds.
00:30:26.466 - 00:31:01.120, Speaker B: So this is the kind of thing that we were trying to exclude when we were talking about only having interactions with non malicious contracts. What you can do if you know that you're in a non malicious setting is you can say, let's look at the set of all contracts that we know of in our setting, and let's consider them as if they were a single contract. And that's something you can't do if you allow malicious inputs there. It's harder to do in that case, at the very least.
00:31:02.870 - 00:31:03.570, Speaker C: Understand.
00:31:03.720 - 00:31:04.580, Speaker B: Thank you.
00:31:05.270 - 00:31:33.580, Speaker C: So for the big picture question, because this is a very big picture paper, and it's very fascinating. In the paper, you provide the theoretical foundations for private smart contracts. Generally speaking, foundations require new infrastructure as well. So I was wondering if you foresee any technological, political, or other obstacles towards implementing the private smart contracts as they've been conceptualized here.
00:31:34.990 - 00:32:37.086, Speaker B: That's a very interesting question. There's obviously multiple angles to that politically. Let's start with politically, because maybe it's something where there's interesting things to say, but also, I'm not the person to say them, but I think there's certainly a danger, or let's rephrase that. There's a risk that there may not be the political appetite to actually have a good foundation for privacy, for smart contracts. So to some extent, you already see that with privacy coins, that there's questions of how far should you go with this and how far is too far. And there are very reasonable questions as to how much should be possible to hide from, say, law enforcement agencies. And there's good discussions to be had there, but I'm unfortunately not the best person to have them with.
00:32:37.086 - 00:34:13.950, Speaker B: Now, from a technical level, you're absolutely right, that there will need to be new infrastructure developed around this kind of thing. And I think one of the big dangers, specifically with privacy, and I try to highlight that with Kachina, is it's hard to think about privacy, and it's hard to think about privacy to the extent that you actually end up with a private system. So there's a danger that even with the best foundations, developers may inadvertently, or just simply by not caring, make systems which harm users privacy. And this is a tough one for me because I know from experience how hard it is to design private systems. So I cannot fault anyone for making mistakes in that, but also, it's a fundamentally hard problem. So part of the observation in Kachino is that we can't solve it for every case, and that means that it becomes even harder to find the edge cases where it can be solved and to make sure that they're being solved correctly there. So I see there as being a lot of technical problems that have to be solved, essentially for each individual problem or each individual contract problem that you want to solve, you'll probably be facing unique challenges.
00:34:13.950 - 00:34:27.710, Speaker B: And, yeah, I think the challenge is I'm not sure if there will ever be a thriving community around solving these kind of problems or if that's even something that's desired.
00:34:30.690 - 00:34:38.950, Speaker C: Well, thanks, Thomas. That's all the questions I have. Thank you so much for your time and for this really fast, fascinating paper and excellent presentation.
00:34:39.610 - 00:34:40.820, Speaker B: Thank you for inviting me.
