00:00:00.250 - 00:00:12.750, Speaker A: Ethereum smart contracts are built using the solidity programming language. This will be a brief overview of solidity and remix, which is a powerful web ID that we can use to deploy and test smart contracts really quickly.
00:00:12.820 - 00:00:14.302, Speaker B: There are some great free and paid.
00:00:14.356 - 00:00:18.478, Speaker A: Resources out there that will go a lot more in depth than what we're going to go into here.
00:00:18.564 - 00:00:19.722, Speaker B: Links will be in the description.
00:00:19.786 - 00:01:02.110, Speaker A: The demo that we're going to go over today is going to be how to get the data from any API into your smart contract. And if you're new here, this will not only be your first smart contract deployed, but also your first smart contract that interacts with Chainlink. Oracle let's build whenever you deploy a smart contract, you deploy it right on the Ethereum chain. Each smart contract has a balance of Ethereum, chainlink or other Ethereum based token. It has data that it stores there, and it also has some code. When you deploy a smart contract, you deploy it on whatever network that you're on at the moment, for example mainnet, Roxton, Rinkby, or other testnets. To get started deploying smart contracts, let's check out remix.
00:01:03.090 - 00:01:30.418, Speaker B: This is remix. We're using it because it has a great GUI for interacting with contracts. Once you get strong, you can move on to using whatever text editor you like, since you can even programmatically interact with the blockchain using web3 tech, which we'll go over later. All code for this can be found by hitting the remix link in the description. It gets imported via a gist and you can come and view it by hitting this little gist button. Click the gist and then click the file name. Before we even hit that, though, we need to come to environments and hit solidity.
00:01:30.418 - 00:01:59.330, Speaker B: Now it knows we're going to be coding in solidity. If you want to make a new contract, just come over to the file Explorer and hit the plus button. The solidity language uses SOL files, and unlike other languages, one of the biggest considerations is that the more processing your contract does and the more data your contract stores, the more gas you're going to pay. Ethnodes. Similarly, the more API calls you make, the more oracle gas that you'll use. Here's a sample contract that we're going to use. The code in the description will have a lot more notes for you to follow along so you can understand what's going on.
00:01:59.330 - 00:02:28.790, Speaker B: The first line of every solidity contract is going to be the version of solidity. This is how the compiler knows what version of solidity you're using. This next line is how we import code from other repositories and other projects. As you can see here, we're pulling in from the Chainlink repository. This contract, Chainlink example is how you define a contract. You can think of this as classes in other language, and this is Chainlink client is basically solidity's version of inheritance. You can think of contracts as being analogous to classes.
00:02:28.790 - 00:02:55.586, Speaker B: When you deploy a contract, you're deploying an instance of that class. In this case, when we deploy this contract, it'll be an instance of the Chainlink example contract. After that, we can define instance variables or think global variables. For this contract, there are a lot of different types in solidity. We have UN 256, which is an unsigned integer. We have addresses, which are contract and wallet addresses. We have strings, and there are a few others as well.
00:02:55.586 - 00:03:20.662, Speaker B: You'll notice some of the visibility keywords here, such as public and constant. You can go into the solidity docs to learn more about those. Whenever you define an instance variable, it's going to be considered a storage instance variable. We'll talk about that in a minute. After that, we have the constructor. You can think of this as a constructor, as the same as every other language inside our constructor. Here we have an instance of calling a function which was inherited from Chainlink client.
00:03:20.662 - 00:03:50.146, Speaker B: We're also setting one of our global variables, or instance variables to message sender. Message sender is a keyword in solidity, and for this contract, it means the owner of this contract is going to be whoever created it. Now we get into defining function. We call it a function by using the function keyword, the name of the function, in this case request, ethereum price. The input parameters it has, we don't have any for this one, the visibility and permissions, and then a special term called a modifier, which we'll get into.
00:03:50.168 - 00:03:51.206, Speaker A: It a little bit as well.
00:03:51.308 - 00:04:23.530, Speaker B: We're not going to go too deep into what's going on into this function, except for one thing that's really important to note is that you can see here, this looks like it's creating a variable of type chainlink request. But we have this memory keyword, and the name of the variable is rec. Memory is a keyword. Memory means that we are not going to store this variable after this contract is executed. This will save up some storage on the contract. Then last at the bottom, we have what's called a modifier. You can think of these as wrappers around function.
00:04:23.530 - 00:05:11.422, Speaker B: So this is our only owner modifier, which we saw was used for our request Ethereum price function this modifier is requiring whoever uses this function to be the owner of the contract. So basically we're saying only the owner of this contract can call this request Ethereum price function. Once you've made your edits and you feel strongly about your contract, you can go to this completely compiler, choose your version type, and hit compile. This is compiling your code into computer readable code as well as an API, which we'll talk about later. Once it's compiled, we can come to deploy and run transaction. For the moment, we're going to ignore JavaScript VM, we're going to move to injected web3, which means that we need to verify our metamask account. Make sure your metamask is on a test network and not on a main net.
00:05:11.422 - 00:05:37.618, Speaker B: Whatever Ethereum network you're on is going to be the network that you're interacting with we want to test. So we're going to stay in the Ropson test network. It inputs our account right into remix as well. For this contract, we don't have any parameters next to deploy that we need to define along with our contract. So we can just go ahead and hit the deploy button. Make sure you have some testnet Ethereum from our last video so you have some gas to actually deploy and we can hit the deploy button. Metamask will pop up and ask us if we'd like to confirm.
00:05:37.618 - 00:06:15.086, Speaker B: We'll get a link to etherscan showing us the progress of our transaction. Once the contract has finished deploying, we'll actually get an interface at the bottom that we can click and open up to see all the functions that we have and all the variables as well. We can click on the variables and see their values for each one. We can also interact with some of the functions we're going to interact with the request Ethereum price, and we're going to get a common error that you'll run into. This gas estimation failed means that you don't have enough gas to run this transaction. Maybe your contract is written really poorly and it would use too much processing power than gas that you have allowed. Or maybe you forgot to fund your contract.
00:06:15.086 - 00:07:06.594, Speaker B: Since I know this contract is using a Chainlink node to request data, I know that I have to fund it with Oracle gas, we can do that really easily. We're going to have to send our contract some chainlink token so we copy the address by hitting this button. We enter metamask, we choose link token, we hit send, we paste the address, type the amount of link that we want to send, choose the transaction fee and speed. Next, confirm and Metamask will also give us a nice hyperlink that we can view on Etherscan. Once this one's completed, we can come back, and if we hit the current price now, we'll see that the price of Ethereum has actually been updated. Just note that since it is only a test network, sometimes it's a little bit finicky. And if something doesn't work, feel free to just try it again.
00:07:06.594 - 00:07:13.174, Speaker B: But congratulations, you have just deployed your first solidity contract, and you've interacted with your first chainlink node. That's awesome.
00:07:13.292 - 00:07:17.910, Speaker A: Now, you may be wondering, why did I need to interact with this chainlink node to make this API call?
00:07:18.060 - 00:07:19.266, Speaker B: Why can't I just make an API.
00:07:19.298 - 00:07:26.580, Speaker A: Call like I can with any other language? Well, this is actually a critically important question, and we'll answer why in the next video. See you there.
