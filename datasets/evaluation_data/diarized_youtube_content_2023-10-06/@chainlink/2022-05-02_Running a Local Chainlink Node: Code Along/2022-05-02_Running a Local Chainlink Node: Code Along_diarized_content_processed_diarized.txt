00:00:03.640 - 00:00:20.316, Speaker A: All right, think we're going to get started here in just a moment. Welcome to another workshop in the chainlink hackathon. Today we will be talking about running your own chainlink node and how to.
00:00:20.338 - 00:00:23.048, Speaker B: Do it with Docker.
00:00:23.224 - 00:00:29.990, Speaker A: So we'll give a couple seconds here for everybody to get gathered, maybe about 30 seconds, and then we'll get started.
00:01:03.920 - 00:01:05.788, Speaker B: All right, so let's get started.
00:01:05.874 - 00:01:16.672, Speaker A: Let's talk about running your own chain link node. You've been working through the hackathon, the workshops. You want to run your own node. How do you do that?
00:01:16.726 - 00:01:17.788, Speaker B: What's involved?
00:01:17.964 - 00:01:19.824, Speaker A: Today we'll take a look at the docs.
00:01:19.952 - 00:01:21.972, Speaker B: It's the place I like to start.
00:01:22.026 - 00:01:49.932, Speaker A: For everything chainlink related because the docs are always up to date and have the best information as far as what you need to do. I will give a small caveat that I personally am going to deviate from the docs a little bit because I like to run two docker nodes. The docs will talk about running one for the actual chainlink node. I like to run a second one.
00:01:50.066 - 00:01:53.068, Speaker B: To host the database as well.
00:01:53.234 - 00:02:11.140, Speaker A: And so we'll take a look at how to do that. I'll be doing all this on a Mac laptop, but since it's in Docker, the same stuff should apply if you wanted to run it in AWS, GCP, on your personal machine, anywhere, just as long as the specs meet the requirements.
00:02:11.560 - 00:02:12.996, Speaker B: We should be good to go.
00:02:13.098 - 00:02:15.508, Speaker C: So let's take a look at the.
00:02:15.514 - 00:02:38.540, Speaker A: First place you go, and that is the docs. When it comes chainlink. Docs chain link is the go to place. And before I get too far, good morning to everybody. GM. So we go to docs chain link. We have a lot of stuff getting started.
00:02:38.540 - 00:03:11.080, Speaker A: The different chains for running a node. We're interested in this one node operators. From here we can just go into setting up a chainlink node. I like to click on running a chain link node. It'll walk you through what the nodes are and fulfilling job requests, adding adapters. We'll do a little bit of job requests as well, just to kind of make sure that our node is up and running. And yeah, if you have questions, feel free to drop them in the chat as we're going through.
00:03:11.080 - 00:03:43.868, Speaker A: We have Alex here. He's from the community developer advocates as well, and so he will be trying to help answer, bringing things to my attention. If you have any questions, I'm more than happy to make this interactive. It is live, so that's one of the benefits, right? And we can go from there. So we come to the docs, we go to node operators. We want to run a chain link node. So from here we have a few requirements.
00:03:43.868 - 00:04:20.524, Speaker A: The first is that we're going to need some link while we can run it without link. In order to go through this entire workshop, we'll need two things. We'll need some test link as well as some test ETH. So in order to get test link or test ETH, you can head on over to faucets, chain link and here you can pick the network in this walkthrough. We'll be using Rinkabee. You can get a little bit of link and ETH as long as you're not a robot. I already have some of this.
00:04:20.524 - 00:04:56.490, Speaker A: I'm going to leave it there in the faucet. Feel free to head over there and grab some of that which you will need later on. The other piece of technology that you will need is Docker. If you head to docker.com, click on getting started. You can pick where you're going to be running this on the desktops, what I'm doing, and from here download it, install it and you should be good to go. I already have Docker running, but I don't have any containers installed in my docker, so we'll be starting from scratch there.
00:04:56.490 - 00:05:06.076, Speaker A: All right, so let's take a look. We'll need to make sure that we.
00:05:06.098 - 00:05:07.340, Speaker B: Meet these requirements.
00:05:10.160 - 00:05:29.408, Speaker A: And we'll also need to have a postgresql database. Like I mentioned, the docs here, they talk about using an existing postgres database. We will set that up ourselves inside of Docker. And so we will actually have two different docker instances.
00:05:29.584 - 00:05:30.932, Speaker B: We'll walk through how to do that.
00:05:30.986 - 00:05:42.730, Speaker A: How to make sure that the postgres database is up and running before we get to running our chainlink node. We'll set them up to kind of both run at the same time.
00:05:45.260 - 00:05:46.570, Speaker B: So let's get started.
00:05:47.500 - 00:05:52.216, Speaker A: Oh, sorry, one other thing. We will need a way to access the blockchain.
00:05:52.408 - 00:06:24.180, Speaker B: The docs talk about using an ethereum client or a third party service. Almost forgot. Another key piece of this besides docker, is alchemy. In this example, doesn't have to be alchemy, I'm just using Alchemy for this example. Alchemy provides you a entrance point, an on ramp into the blockchain essentially. And this will allow us to actually interact with the blockchain. So we will need something like Alchemy to interact with the blockchain.
00:06:24.180 - 00:06:58.480, Speaker B: You can sign up and once you're signed up you can create an app and this app will allow you to interact with whichever blockchain you want. You can see I have a few different ones here. One thing to note, this key, it's a private key. The API key for this you don't want to share. It's not necessarily as private as your wallet private key, but being that it's a private key, you don't want to share it. So I'll be doing all of that bit off to the side of the screen. But yeah, never share your private keys.
00:06:58.480 - 00:08:03.798, Speaker B: All right, so walking through the docs we have here using Docker, we talk about how to install it in different places and then we get to actually creating the place that will hold the information for our chainlink node. These instructions are all going to be based on the command line. So you can literally copy and paste these into a terminal and they'll work just fine. I will probably use vs code for most of this in order to kind of talk through as we are doing this, what's being added and just to make it a little more user friendly you can again copy paste or you can follow along. So the first thing we have to do is we need to make a directory for this information to be housed in this case. One thing to point out on most Linux based systems, dotted files are kind.
00:08:03.804 - 00:08:05.030, Speaker C: Of like hidden files.
00:08:05.530 - 00:08:25.966, Speaker B: So this directory, you wouldn't see it if you just typed ls to list out the directories, you'd have to do like an ls a which shows all of them, including dotted files. So just kind of keep that in mind if you're following along and you take a look at your directories and they're not there. So we'll take these instructions, we'll give.
00:08:25.988 - 00:08:43.730, Speaker C: Them a quick copy, pop them into our terminal and copy paste. Whoops, looks like I already have it there. Let me get rid of that one. We'll get rid of the dot in this case. There we go.
00:08:43.880 - 00:09:25.860, Speaker B: All right, so we make a directory, we call it chainlink Rinkobee. I will CD into that directory. CD just means change directory and then I'll open up vs code. So from here I'll be using vs code to create files and edit the files. But if you wanted to follow along again, just remember you can with the actual docs as they stand on the website. First thing that we'll need to do is we'll need to create a env file. This is going to host or house the information for the chainlink node that we'll be running.
00:09:25.860 - 00:10:02.576, Speaker B: So a few things to note here for Rinkabee has things like the chain id being four. If we went to coven, for example, that chain id is going to be different. Another thing to note is secure cookies is false. This is set up for testing purposes. So we're going to do a few things that make it easier for development and testing. In order to make our lives easier, we're opting for slightly less secure options. If you were doing this in production, you'd need to probably take a look at those, change those.
00:10:02.576 - 00:10:17.830, Speaker B: And also my passwords are going to be the world's most amazing passwords, like password and secret. Don't use those passwords in production. All right, so we're going to go to env and we're going to just put this information in here.
00:10:19.480 - 00:10:30.010, Speaker C: So we head back to vs code, new file env, paste it in, give it a save. Always make sure you save things.
00:10:32.720 - 00:11:15.076, Speaker B: Alex, thank you so much for answering the questions in the chat. You're like crushing it. Can I use polygon to deploy a node? Last question I see here, you can deploy a node to talk to different chains. That information, as far as like configuring it and setting up for different chains is in the docs. It's going to be some of the things like the chain ID that will need to be changed as well as you'd need to have some sort of RPC to get into the chain that you wanted to interact with. So we've got our env file set up. We need to set up our ethereum client URL with an external provider.
00:11:15.076 - 00:11:33.790, Speaker B: So it's going to be something like this. Second option, this is if you're running an actual ethereum client on the machine. If we're using a third party client like alchemy, we'll be doing something like this. And within alchemy, the thing that you're going to get, it's going to start.
00:11:36.260 - 00:11:40.370, Speaker C: With a URL that looks something like this.
00:11:43.140 - 00:11:52.500, Speaker B: And then here, this is going to be your API key. I'll fill that in in a minute with mine. Again, that's the piece that you don't want to be sharing.
00:11:56.880 - 00:12:00.976, Speaker C: That again comes from alchemy right here.
00:12:00.998 - 00:12:07.264, Speaker B: If you just click view key, you will be able to obtain a URL like this that you can pop in here.
00:12:07.302 - 00:12:15.764, Speaker C: That'll give you access to the blockchain. So going back to the docs, we.
00:12:15.802 - 00:13:12.416, Speaker B: Also will need some sort of database URL as well. And the database URL is going to be fairly interesting in that we're using postgres and then it has a bunch of values, our username, our password, where it is, what port it is, and what the database is actually named. So in this case, we are going to be using a second docker image to host our database. So what that would look like is something like this. So we have postgres sql that's going to tell what we're using. We have our username, which is postgres. In this case, our password is going to be secret.
00:13:12.416 - 00:13:55.060, Speaker B: Again, just for tutorial demo purposes, do not use a password like secret in production. We have this bit here is going to be the actual name of the Docker image. So it's going to be chainlink Rinkob. This is what I'm calling it. You could name it whatever you wanted and then the name within the docker set of images of the actual image itself. So postgres chain link is what I'm calling it, the port 5432. And then the name of the database itself, chain link Rinkabee is what I'm calling it here.
00:13:55.060 - 00:14:35.790, Speaker B: And then we have this extra bit after the question mark that says we're going to disable SSL. Again, this is a flag to turn off SSL in production. You would want to make sure that SSL is enabled and you had a certificate, everything like that. So that's just kind of a, I'm harping on these bad practices that I'm doing for ease of development and tutorial. Just so that you understand, if this was a production node, you do not want to do things like turning off SSL. You definitely don't want a password like secret. That's terrible.
00:14:35.790 - 00:15:28.138, Speaker B: Okay, so we've got our ETH URL and we've got our database URL. What else do we need? Head back to the docs and take a look. So according to the docs at this point, we're ready to go ahead and just start up the chainlink node. This is where I, in this demo in this workshop, am going to take a little bit of a sidestep from the docs because we're going to set up two docker images. So how do we go about doing that? Well, we've got this place to kind of house everything we're doing with our chain link rinkabee node. Let's go ahead. And first we're going to create another env file to house the database environment.
00:15:28.138 - 00:15:57.538, Speaker B: So this will be used for holding the user password and database name that we'll be using within the chainlink node itself. So database emv within here we'll need just a few things. We'll need the postgres user postgres, its password secret and the database name chain.
00:15:57.554 - 00:16:00.666, Speaker C: Link ring can be cool.
00:16:00.768 - 00:16:46.200, Speaker B: That one's pretty simple. The next one is a bit more involved and that's going to be a docker compose yaml file. What this does is this is going to house the information that tells Docker how to start everything up. So what do we need in here? We need a few things. So services is going to tell us what we're starting up. The first is that PG chainlink. Remember, this is the name that we provided in our env file for the database.
00:16:46.200 - 00:17:16.940, Speaker B: Right, PG chainlink. So this is the name of the image that we're going to host our postgres stuff in. Yeah, Ben, you're not too far, we're not too far in. So you could probably catch up at this point. We've just been following the documentation, if you're just joining now. And this is where things are starting to get interesting and we're kind of taking a bit of a sidestep from the docs. All right, so we have our Docker compose file.
00:17:16.940 - 00:17:25.988, Speaker B: We're going to call this image, we're going to call it PG chainlink. And then we need to tell Docker what actual docker image to use. So the docker image that we're going.
00:17:25.994 - 00:17:27.460, Speaker C: To use is postgres.
00:17:29.640 - 00:17:53.144, Speaker B: And we want to tell it. So I have GitHub copilot on. That's where it's getting all this information from. If this gray stuff is crazy, sometimes GitHub copilot is amazing, other times it's not quite there. So we have our image postgres. We're going to tell it which ports to expose. Which ports to map and expose.
00:17:53.144 - 00:18:12.676, Speaker B: So we need to map and expose 5432 from the docker image to 5432 on my local machine. We're going to give it an environment file. This is going to tell it what environment variables to set up. In this case, we're going to give.
00:18:12.698 - 00:18:15.670, Speaker C: It that database env.
00:18:18.460 - 00:18:56.604, Speaker B: That's going to be this information. So it's going to set this information within our Docker image, set those variables. This next bit is important, but also is going to be different for you. So we need to set a volume, we need to map within Docker. We're going to map a directory from Docker to our local machine. And the reason this is important is that the Docker images are kind of ephemeral in that when you shut down the Docker image, it just disappears. It's like that machine gets destroyed.
00:18:56.604 - 00:19:53.030, Speaker B: And if you were to start up a new one, it's a brand new fresh machine. So if we don't have a way to store information, store data between instances, anytime that Docker image got shut down, we'd lose our database, it'd be gone. So we need a way to keep information between Docker images starting up. The way that we do that is we will use a directory on the local machine and map that to a directory within the docker container. So we need to let Docker know about that. And this would be different for you, unless for some crazy reason the user that you're using on your machine is also RG and you're also in the development directory, but probably not, right. So what we're saying here is we're mapping a local directory, so I need to make a new folder here and we'll call it data.
00:19:53.030 - 00:20:10.360, Speaker B: We're taking that directory and we're saying within this docker image, we're going to map that to Varlib postgresql data. So that's kind of like a bridge between the ephemeral docker image and our local machine.
00:20:12.240 - 00:20:12.700, Speaker C: Cool.
00:20:12.770 - 00:20:52.810, Speaker B: And then at this point this should be everything we need to get postgres up and running. But we also need to let Docker know about chainlink and how to run the chainlink node. So let's go ahead and define a chainlink service as well. And this is where it's pretty amazing, but we'll type it out. So the image that we're going to use is actually going to be smart. Contract chainlink and then you can define the version that you want. I'm just going to use one 30.
00:20:52.810 - 00:21:14.610, Speaker B: Again, this image is just telling Docker which image to go and grab. So in this case we're grabbing the chain link and we're grabbing version one 30. And then we're also going to again define an environment file. In this case it's going to be.
00:21:16.260 - 00:21:18.130, Speaker C: The env.
00:21:20.900 - 00:21:22.544, Speaker B: That is, remember this first.
00:21:22.582 - 00:21:23.696, Speaker C: File that we set up.
00:21:23.798 - 00:21:57.644, Speaker B: Remember, if you are following along, this should be your private key. I'll change it in a moment. I'm also saying that to remind myself so that when I save this and things don't work because I haven't put that key in there, I'll know why. So we've got our environment file and then this next bit depends on this tells us that don't start Chainlink until we have the postgres instance up and running. Chainlink does require that database to be there in order to run the node. So we need to have that postgres image up first. So it's kind of just saying start it.
00:21:57.644 - 00:22:45.400, Speaker B: After we start our postgres from here we need to tell it which ports to expose. And for chain link that's going to be port 6688, we'll just map that straight through. And then again we're going to map a volume across to kind of give us the ability to save information between instances. And so again, this is going to be different for you. On the left side of the colon it'll be whatever directory you want to have for you. And here again we're creating another directory. So I'll go ahead and make another new folder.
00:22:45.400 - 00:23:28.472, Speaker B: This chain link volume is going to house a few things, which will be the data, the logs, it'll also hold. We're going to have a password file in here as well as some API credentials. So we're going to use a command to start everything up. So the command that we're going to use is node start. We're going to use the password that's defined in our password text, which we need to create under this chain link volume. This slash chainlink is referencing this chain link for the Docker image. And then we also have the API credentials that we need to create.
00:23:28.472 - 00:23:52.290, Speaker B: So let's go ahead and make those two files underneath our chainlink volume. The first is password text, and the password that we'll be using here is the password for the postgres database. So that was secret, the world's most amazing password. Again, don't use passwords like secret or password in production. It's a bad idea.
00:23:53.700 - 00:24:05.460, Speaker C: And then the second one was API credentials, text, everything right there. Get nervous with spelling.
00:24:08.620 - 00:24:43.840, Speaker B: Okay, API credentials within API credentials. This is going to be when our chain link node is started. We will have a GUI exposed on port 66 80 that we can log in. We can do things like create jobs and everything in there. In order to log in, we need to define our login credentials and that's what's defined in this API credentials text. So you can do something like your email@address.com and then an amazing password like password.
00:24:43.840 - 00:25:05.688, Speaker B: Fantastic. So we have our docker file created. We have defined within our docker file everything that we need to get going. And I think at this point we're ready to give it a try, cross our fingers and hope that everything works.
00:25:05.774 - 00:25:23.150, Speaker C: So if we just say docker compose up line 19. What is wrong with this picture here? Oh, need to tab that back one.
00:25:28.240 - 00:25:39.190, Speaker B: Okay, so error response ports are not available. All right, so I think I have another instance of postgres running.
00:25:50.440 - 00:26:03.548, Speaker C: Let me stop this real quick, see if that.
00:26:03.634 - 00:26:39.300, Speaker B: Okay, so if you get something like this, this is essentially saying that the port is already in use and it can't bind to it because it's already in use. So only one process can use that port at a time. LSOF is looking for ports, and we're saying we're looking for this specific port. This sudo bit here is just saying do this as a super user so that I had permission to do it. We found the port, and then this process ID is what was holding it open. It was postgres, so I just killed that process. All right, so let's try docker compose.
00:26:39.380 - 00:26:53.556, Speaker C: Up again, see how things go. Okay, so it looks like things might be working just fine here.
00:26:53.578 - 00:27:05.290, Speaker B: So we have two, you'll notice there's kind of two colors here. The first is that postgres instance, and the second is the actual chain link node itself running.
00:27:05.740 - 00:27:08.936, Speaker C: If we take a look here, looks.
00:27:08.958 - 00:27:10.410, Speaker B: Like we're starting up.
00:27:14.720 - 00:27:25.804, Speaker C: And we're getting some transactions, and it looks like we had an error. Let's take a look at actual docker.
00:27:25.852 - 00:27:36.230, Speaker B: Too, and see within the docker desktop, you can see here we have postgres running. It's green. Chainlink is not happy.
00:27:36.920 - 00:27:38.228, Speaker C: So what happened here?
00:27:38.314 - 00:27:39.988, Speaker B: Let's take a minute and take a.
00:27:39.994 - 00:27:44.390, Speaker C: Look, see if we can troubleshoot this bad boy.
00:27:53.390 - 00:28:37.320, Speaker B: You know what it was, I reminded myself, chat. What did we do? So let me go ahead and pop my actual API key in here real quick, and we'll see if we get this working. All right, I put my API key in there. So we're going to stop Docker. We're going to run it again, see what's going on.
00:28:37.930 - 00:28:38.246, Speaker C: Okay.
00:28:38.268 - 00:28:50.830, Speaker B: Okay, this is looking better. This is looking better. Tons of stuff going past. You can see it's actually like getting calls. It's using the Rpc to make the calls.
00:28:52.050 - 00:28:54.350, Speaker C: How can I make this a little bit larger?
00:28:55.970 - 00:28:56.654, Speaker B: Zoom in.
00:28:56.692 - 00:28:57.600, Speaker C: Is that better?
00:29:00.690 - 00:29:02.754, Speaker B: Oh, Docker desktop is hard to see. I agree.
00:29:02.792 - 00:29:03.986, Speaker C: Docker desktop is hard to see.
00:29:04.008 - 00:29:06.398, Speaker B: Does this one zoom in too? I don't know if I can zoom.
00:29:06.414 - 00:29:07.700, Speaker C: In on this one as well.
00:29:09.210 - 00:29:10.118, Speaker B: Zoom in on this one.
00:29:10.124 - 00:29:10.840, Speaker C: I'm sorry.
00:29:13.050 - 00:29:24.410, Speaker B: We'll just use this. So you can see here we've got all these transactions coming through. So that looks like our chain link node is up and running. Let's take a look and see if.
00:29:24.480 - 00:29:28.778, Speaker C: Localhost 66 80 is up.
00:29:28.864 - 00:29:48.226, Speaker B: And it is. It didn't have me log in because I've already logged in before. What you should see is something like this. Okay, so at this point, this is going to be the credentials that we stored here in API credentials. So again, an actual email address is.
00:29:48.248 - 00:29:49.300, Speaker C: Probably a good idea.
00:29:49.670 - 00:29:52.398, Speaker B: And a real password that's not password.
00:29:52.574 - 00:29:54.642, Speaker C: Is also a good idea.
00:29:54.776 - 00:30:11.398, Speaker B: But once we get in, we log in. We can see a few things to note here. So we have the balance of this node. This node has an address, it has no link, it has no ETH. We'll fix that in a minute. We can see jobs. We have no jobs.
00:30:11.494 - 00:30:12.970, Speaker C: We'll fix that in a minute.
00:30:13.550 - 00:30:19.820, Speaker B: No runs. We can see which chain we're on. So chain ID four. You'll remember that's frinkabee from when we set things up.
00:30:23.230 - 00:30:25.070, Speaker C: Pardon the dogs in the background.
00:30:25.570 - 00:30:57.634, Speaker B: So let's go ahead and see. We've set up a node. What can we do with it? Right, what is next? So we've gone through this, we're running a chainlink node. Fantastic. What do we do with it? Well, let's take a look at the next thing in the box. Let's look at fulfilling requests. So what we're going to do now is we're going to set up a test job that will create a job that will take an API call to get the price of ETH on Rinkabee and return it to a smart contract.
00:30:57.634 - 00:31:20.830, Speaker B: So we're going to do a few things. We're going to create a smart contract. That's the Oracle contract. We're going to create another smart contract that calls that Oracle contract. We're going to create a job that fulfills the requests from the Oracle contract. It's a lot of different things, but as we walk through it, it should be pretty simple. Before we get going, we will need to have a wallet.
00:31:20.830 - 00:31:58.006, Speaker B: Most of the documentation talks about metamask. I'm using the brave browser, which has a built in wallet. From everything I can tell, it functions just like metamask. So that's going to be something slightly different with this workshop is my wallet is going to look different than yours if you're using metamask, but the functionality is going to be the also. So we've got our ethereum client configured in that we have that RPC URL from alchemy. We've got our chainlink node up and running and it's connected to a supporting database. Sweet.
00:31:58.006 - 00:32:44.806, Speaker B: We've got that requirement done and then we're going to need to fund the address of our node in order for it to do stuff. So the reason that is when we make a request to our node, in this case, we're going to be talking about price feeds. That node is then going to go out and off chain, grab the price. It's then going to submit that price to a smart contract. When it submits the price to a smart contract, that's going to be making a change to the blockchain. And we know that anytime we make an actual change to the blockchain, that's going to incur a fee, right. We have to pay the gas fee.
00:32:44.806 - 00:32:56.046, Speaker B: So our node needs to have a balance of ETH so that it can pay those gas fees. So we'll need to make sure that our node has some ETH. So let's go ahead and do that.
00:32:56.148 - 00:32:56.800, Speaker C: First.
00:32:57.250 - 00:33:00.334, Speaker B: If we head back here and we.
00:33:00.372 - 00:33:03.486, Speaker C: Take a look at home, we can.
00:33:03.508 - 00:33:11.986, Speaker B: See our account balance here, right? This is the actual ETH balance for this node. So we'll grab our address and we'll go ahead and let me make sure.
00:33:12.008 - 00:33:35.720, Speaker C: I'm on Arinkabee, send it a little bit of ETH. I'll just send 0.1. Cool, confirm, and then we'll hang out and wait just a moment while that happens. We'll go ahead and back to the docs and we'll take a look.
00:33:36.970 - 00:34:00.522, Speaker B: So we've gone ahead and we've given it some ETH. We found the address. It talks about the faucets. Remember faucets, chain link, it's awesome. We have all of these networks where you can get link, most of them you can grab like the native token as well. Not necessarily all of them, but you can definitely get link here if you need it. And then we'll go to deploying our own oracle contract.
00:34:00.522 - 00:34:38.490, Speaker B: So the oracle contract is going to be kind of like that. Bridge that connection from our node to the blockchain. So let's go ahead and just follow the instructions here. So if we go to remix and we open the oracle smart contract, you can see it's maybe the world's most simple smart contract. Yes, this is it, three lines of code. Because what we're doing here is we're importing one of the chainlink contracts already. We're just defining a license, what version of solidity we're using, and then we're importing this contract.
00:34:38.490 - 00:34:40.954, Speaker B: So we'll go ahead and deploy that.
00:34:40.992 - 00:34:41.482, Speaker C: Right?
00:34:41.616 - 00:34:47.930, Speaker B: And we'll need the link token address. This address defines.
00:34:48.270 - 00:34:50.330, Speaker C: I think I'm blocking it a little bit there.
00:34:50.480 - 00:35:24.374, Speaker B: This address defines link on Rinkopey. So this is where the actual link token is defined on the Rinkopey network. We'll need that when we deploy. So if we head back to remix and if you're not familiar, remix is essentially a web based IDE for smart contracts. It's awesome. As you start to get more complex, you might look at some of the starter kits that we have on GitHub for things like forge, truffle. There's several different other ones, Brownie, hard.
00:35:24.412 - 00:35:26.946, Speaker C: Hat for more complex projects.
00:35:26.978 - 00:35:47.738, Speaker B: But when we're doing something like this where there's only a couple contracts involved, remix is awesome. If we head down here we can actually deploy it. You need first to make sure that you select the environment of injected web three that's going to take our wallet information and inject it into the browser. And so then we're using that to deploy.
00:35:47.834 - 00:35:56.670, Speaker C: So that'll use whatever network we're on, stuff like that's.
00:35:57.270 - 00:36:16.794, Speaker B: And then the other thing when it comes to remix, always make sure that you are deploying the correct thing here. So we need to deploy Oracle and when we select Oracle you'll notice that we now need to provide the address of link. So that is from the docs here.
00:36:16.832 - 00:36:20.074, Speaker C: I just copied and pasted and we.
00:36:20.112 - 00:36:24.074, Speaker B: Can click deploy and we'll give this.
00:36:24.112 - 00:36:25.450, Speaker C: A moment to run.
00:36:25.600 - 00:36:58.498, Speaker B: While that's running, head back here, give this a refresh. Hey, our node's got some ETH, so we're good there. All right, so we've got our Oracle contract deployed, we've told it about the link token, we can see when it's officially deployed. We can double check on that and we'll actually get a address for it. We'll need that Oracle address here to add it to our node. So once this is deployed we should see here down in deployed contracts.
00:36:58.674 - 00:36:59.346, Speaker C: Fantastic.
00:36:59.378 - 00:37:21.230, Speaker B: So we'll need the actual address of this contract. So our node has an address. Our contract has an address. We need to let our node know about our contract. So how do we do that? If we go into the gui or. Sorry, I said that backwards. We need to let our oracle know about our node.
00:37:21.230 - 00:37:46.146, Speaker B: So if we go to the GUI and we find under keys page the account address section, we'll say these keys are not necessarily something that you would want to share. This node is going to disappear after this workshop, so I'm not too worried about that. So if we go to our keys.
00:37:46.178 - 00:37:46.870, Speaker C: Section.
00:37:49.640 - 00:37:53.190, Speaker B: We'Re going to need this EVM chain account. So we're going to need this address.
00:37:54.520 - 00:37:54.884, Speaker C: Right.
00:37:54.922 - 00:38:16.536, Speaker B: So we go there and then we'll need to add the address to the fulfillment permissions and we'll need to set it to true. So we're letting our contract know about our node and we're saying, hey, contract, this node has permission to tell you information. So it's set fulfillment permissions.
00:38:16.648 - 00:38:24.376, Speaker C: That's what we need to look for here. This a little bit bigger. I believe it's this one. Yeah, set fulfillment permissions.
00:38:24.488 - 00:38:29.520, Speaker B: So we'll put the address in there of the node and we'll set it to true, saying, hey, this node has permission.
00:38:30.500 - 00:38:32.560, Speaker C: We'll confirm this transaction.
00:38:33.300 - 00:38:59.640, Speaker B: Just on a side note, when you're in remix, if you see the orange color, that means it's going to cost you money because that's some sort of interaction that's going to modify the blockchain. Sorry, cost you gas. And if you see blue, those are read transactions. They're generally free to execute. Okay, we got our green check marks. That means this actually happened. So we've let the contract now know about the oracle.
00:39:02.710 - 00:39:03.218, Speaker C: Awesome.
00:39:03.304 - 00:40:02.770, Speaker B: At this point we're going to go back to the node and we're going to create a job. This job is going to have a consumer contract called a testnet consumer that's going to use it to fulfill the oracle request. So what is it going to do? It's going to do a fetch that's going to grab the value of ETH from an API. It's going to do a little bit of stuff to it. It's going to multiply it times 100. This is just because within solidity there is no concept of decimal places. So in order to have less than whole numbers, the way that's kind of dealt with is you multiply the number out a bit to make it larger so that you can effectively have decimal places without actually having decimal places.
00:40:02.770 - 00:40:12.758, Speaker B: So we're kind of just moving the decimal place over a bit and then you're aware of how many times it's been multiplied so that when you need to display it with a decimal place, you can put that decimal back in.
00:40:12.764 - 00:40:16.520, Speaker C: There where it belongs. So we'll copy this.
00:40:22.800 - 00:41:21.890, Speaker B: There's a question here about Rinkopi is deprecated. So yes, Rinkopey is kind of reaching the end of its lifecycle, I guess you could say. And that's definitely something that we are looking for, where the next network is going to be for testnets and stuff like that. It still works just fine for now. And all of the chainlink products are there so we're using it for this. But yes, long term it's not going to necessarily be the place that you want to be doing things, but it's fine for testing on now. Okay, so we've got this job, we're just going to copy this directly and we'll go into our node again, go to jobs, we're going to click new job and we'll paste it in there.
00:41:23.780 - 00:41:27.250, Speaker C: And we'll create our.
00:41:29.720 - 00:41:54.712, Speaker B: Oh, didn't follow instructions. So your oracle contract address. Right, what do we need to put there? Let's take a look. Paste in the job and then we need to replace that. There's two places that we need to replace it with the address of our oracle contract. This is kind of like connecting both ways. We're telling the oracle contract about our node and now we're telling our node about our oracle contract.
00:41:54.712 - 00:41:58.780, Speaker B: So we'll need to grab the actual address of our oracle contract.
00:42:01.040 - 00:42:12.050, Speaker C: So put it in here and then where's the other spot? Right here. Cool.
00:42:14.500 - 00:42:45.350, Speaker B: Create a job. Successfully created our job. It's called job one. Awesome. So we've got our job. Once that's done we'll need to get the external job ID value and save that for a bit later, but we'll get there in 1 second. So now we need to use the testnet consumer contract and deploy it.
00:42:45.350 - 00:43:44.550, Speaker B: So we'll click on that link, it'll take us to another instance of remix and this one's a bit more interesting. So what is going on here? We'll do a quick walkthrough of this contract. This is essentially the contract that's going to interact with the oracle and via the oracle, our node, what it's doing is we're going to request the Ethereum price. So it has a bunch of different requests, right? Different things to look at. If we just look at request Ethereum price, you can see we're creating a chainlink request and we're passing in things like the job ID and address and we're adding to our request a git. Here's that API that we're looking at in the response from this API. So if we take a look at this API, you can see it's a json response.
00:43:44.550 - 00:44:12.740, Speaker B: And this is a pretty simplistic json response in that it has one item, so we have one item USD and we're going to multiply it times 100. That'll essentially give us back this value, right. We'll move our decimal over so that we're not having to have a decimal place in there. And then we're taking this request that we just built and we're sending it to our oracle.
00:44:13.960 - 00:44:14.710, Speaker C: Cool.
00:44:15.420 - 00:44:21.700, Speaker B: Let's go back to the docs and take a look. So we open this and we'll compile it mindset to autocompile.
00:44:21.860 - 00:44:23.048, Speaker C: So we'll deploy it.
00:44:23.134 - 00:44:25.636, Speaker B: So we need to deploy this contract. Testnet consumer.
00:44:25.668 - 00:44:26.810, Speaker C: So let's do that.
00:44:27.260 - 00:44:31.756, Speaker B: So mindset to auto compile here, if you don't see a green checkmark you.
00:44:31.778 - 00:44:34.668, Speaker C: Can click compile and I'll compile it for you.
00:44:34.754 - 00:44:36.430, Speaker B: Just lets you know everything is good.
00:44:37.460 - 00:44:56.690, Speaker C: Injected web three and then a testnet consumer. So we'll deploy this contract. We'll give it a moment. There it is.
00:44:57.700 - 00:44:58.960, Speaker B: Fantastic.
00:45:00.580 - 00:45:01.344, Speaker C: Come back here.
00:45:01.382 - 00:45:49.912, Speaker B: So we have the chain link node, it has some ETH, right? It's ensuring that we have that because remember this is going to make a change to the actual blockchain. It's going to store this value via our smart contract. So we need to make sure that our node has that ETH. We can double check that by looking here. We have some ETH balance we need to fund this contract that we just deployed with some link. So in the same manner that it costs something for our node to make a change to the blockchain, we are paying for that change. Essentially we're incentivizing the node to do it by paying the node in link.
00:45:49.912 - 00:45:56.036, Speaker B: So our contract is going to need some link, this one that we just deployed, the atestnet consumer.
00:45:56.068 - 00:46:10.990, Speaker C: So we'll need to send it some link. So we will change this to chainlink and we'll just go ahead and send it. I don't know, one link should be enough, but I'll send it five because just to be sure.
00:46:17.250 - 00:47:03.420, Speaker B: So this will give, our contract itself will now have a balance of link and then we funded our contract. We funded our node, we've got the contract deployed. At this point we should be able to create a request. So we'll need the address of our oracle contract. That's the first contract that we deployed and we're also going to need a job ID. This is going to be the job that we created within our node. Now one thing to note, this job ID, it has dashes in it.
00:47:03.420 - 00:47:15.246, Speaker B: When we provide the job ID to the contract, we need to make sure those dashes are gone, hyphens, dashes, whatever you'd like to call them. So I'm just going to take them.
00:47:15.268 - 00:47:16.240, Speaker C: Out real quick.
00:47:18.310 - 00:47:21.540, Speaker B: And then we're going to do request Ethereum price.
00:47:22.950 - 00:47:30.770, Speaker C: So Ethereum change latest market price.
00:47:30.840 - 00:47:38.710, Speaker B: So our job ID, remember, remove the dashes and then we need the address of that oracle contract. So that's the first one that we deployed.
00:47:39.290 - 00:47:40.486, Speaker C: We'll copy that.
00:47:40.588 - 00:48:08.066, Speaker B: We'll put it in. At this point we should be able to transact and this will get the current price of Ethereum. So if we look now, the current price is zero. So our contract doesn't know what the price of Ethereum is. We transact. So we're requesting the Oracle contract to run the job on our node. If we come here we can see there's no job runs in just a.
00:48:08.088 - 00:48:35.250, Speaker C: Moment, though hopefully once this completes. I don't know what happened. There's. Oh no, we lost our contract. We'll reload that in 1 second.
00:48:35.780 - 00:48:49.750, Speaker B: So we lost our contract. I don't know what happened with the remix there, the actual run. I can go grab it here in just a minute. But you can see here we have one recent job run. This is going to be that request that we just made.
00:48:50.460 - 00:49:13.582, Speaker C: So let's go ahead and let me look real quick and see here. So we sent e that address. Transaction has from two. Let me grab my contract address, put it in here.
00:49:13.636 - 00:49:36.534, Speaker B: So this time we are not deploying. We're actually saying, hey, remix, I've already deployed this. I went and grabbed the address for the contract that was deployed. And I'm saying instead of deploying it, just load up the functions that are defined within this contract so I can interact with it. So if we get the current price.
00:49:36.652 - 00:50:15.870, Speaker C: Now up, it's still zero. May take a moment. Where's this? I may have grabbed the wrong contract address. Let's just go ahead and deploy this thing again. We'll just start overloading. What's going on? We'll run it one more time.
00:50:20.960 - 00:50:22.412, Speaker B: I may need to just give it a second.
00:50:22.466 - 00:50:28.066, Speaker C: You're right. We can run through it again.
00:50:28.168 - 00:50:34.020, Speaker B: It's all good. So we're going to fulfill the ethereum price. We need to grab the.
00:50:39.360 - 00:50:49.184, Speaker C: Oops, that's the wrong one, right? Request the Ethereum price.
00:50:49.222 - 00:50:51.520, Speaker B: We need to grab the oracle contract.
00:50:52.180 - 00:50:54.576, Speaker C: Which is this one. Put it in here.
00:50:54.598 - 00:51:02.870, Speaker B: We need the job ID again. We need to ensure that the job ID doesn't have the dashes in it.
00:51:13.420 - 00:51:21.290, Speaker C: Run the transaction. Oops, am I in the right place? Yes.
00:51:35.390 - 00:51:36.974, Speaker B: And while we're waiting on this one.
00:51:37.012 - 00:51:43.906, Speaker C: To go through, let's see if our.
00:51:43.928 - 00:52:04.678, Speaker B: Current price is fulfilled. It is. You are right. Rink could be slow. Just give it a second so we can see here our price is 2818 and $0.81 which is going to be probably what this was whenever this ran. Yeah, so you can changes every time because the price fluctuates.
00:52:04.678 - 00:52:43.890, Speaker B: But we've got our price. We need to add our two decimals here. At this point we have gone from taking our oracle node, creating it. We created a job within that oracle node. That job takes in a few things, like the address for the API, what to look for within the response. It's then run that job on the oracle node. The oracle node has then submitted the response to our oracle contract, and our oracle contract has stored the price so we can have the current price of ETH on chain from an API.
00:52:43.890 - 00:53:39.030, Speaker B: This is the same basic process you'd use for any API. And there was a question earlier of why you'd want to run your own node. Defining jobs like this gives you access to creating requests for APIs in any fashion that you want. So while you can use existing nodes and some of them have APIs that you'd want access to, if there was something you wanted to add to it, another off chain data source that you wanted, having your own node in the Oracle network is a great way to have the ability to access any information that you want. I don't know. Alex, are there any questions that we haven't gotten to? I know that you all have been doing fantastic job of answering each other's questions. Alex, you've been a massive help, I guess, too.
00:53:39.030 - 00:54:52.188, Speaker B: What questions do you all have about any of this? As we're kind of wrapping this up because we're coming up on time, someone's wondering about running on hard hat instead of Rinkabee. I'm assuming that question is about this environment here. Is that what the question is? Are Brownie a foundry? So I'm a little confused by that question. If it's not just about these different providers here, because Ringabee is a blockchain, hardhat, foundry, brownie, those are all different frameworks for developing and testing smart contracts. You can connect them to any of the blockchains. So hopefully that answers your question. I haven't messed honestly much with the hard hat gnosh provider here, so I'm sorry, I'm not super familiar with that.
00:54:52.188 - 00:55:25.644, Speaker B: But yeah, if you want to take a look at more like doing something like hard hat, I'll be having another workshop on Thursday, building out a NFT based game using foundry. So if you have questions or wanted to see what that looks like. Hard hat is great. Truffle is good. Hard hat's great. In just my personal opinion. They're both great projects, but foundry is like new and I'm really liking it.
00:55:25.682 - 00:55:27.244, Speaker C: Maybe it's just because it's the new.
00:55:27.282 - 00:55:55.476, Speaker B: Thing, I don't know. New toys are always fun, but foundry. One thing that I personally like about foundry is the tests are written in solidity too, and so my brain can just stay in solidity when I'm doing development work instead of hopping back and forth between what is it? Mocha, which is a JavaScript framework, and solidity. We had a question, how to connect to a remote chain link node from a local chain link, say inside of.
00:55:55.498 - 00:56:00.170, Speaker C: A Kubernetes cluster, and looks like.
00:56:00.620 - 00:56:24.930, Speaker B: I don't know that I can necessarily answer that in the time that we have left here. If you want to follow up, my Twitter is right here and reach out, we can chat about that. I can get you the docs that you need to do that. If you have questions, I guess too, like anybody else. Any questions, comments? Want to just chat? Hit me up on Twitter. The DMs are open. So happy to talk about all of this stuff and everything.
00:56:25.620 - 00:56:29.424, Speaker C: So yeah, I don't know, I think.
00:56:29.462 - 00:57:05.720, Speaker B: That we may just call that a wrap. But before we go, one important thing real quick, there is a survey and it would be super duper helpful that up there, that QR code, if you can fill that out, it would be super helpful. I think Alex posted a link as well in the chat earlier. But yeah, it's awesome to know like what can we do better, what can I improve? What did you like, what should we do differently? Stuff like that. There's the link. Thank you Alex.
00:57:06.140 - 00:57:08.292, Speaker C: Yeah, I guess that's a wrap.
00:57:08.356 - 00:57:18.880, Speaker B: At this point we have a full functional inlink node and a postgres node up and running on a machine, taking requests from the real blockchain.
00:57:22.980 - 00:57:27.500, Speaker C: So thank you very much. And yeah, have fun in the hackathon.
