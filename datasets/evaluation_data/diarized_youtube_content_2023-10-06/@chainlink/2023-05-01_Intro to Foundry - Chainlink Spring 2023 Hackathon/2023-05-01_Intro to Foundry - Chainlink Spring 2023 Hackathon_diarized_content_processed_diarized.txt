00:00:01.210 - 00:00:18.720, Speaker A: Hello, everybody. I think we're live. If we are live, give me a thumbs up, let me know, let me know where you're from. Good morning, good evening, GM. Good afternoon, good time of day to you. I'm not seeing things show up on the YouTube, though. There we go.
00:00:18.720 - 00:00:42.684, Speaker A: We are live. Fantastic. So there's a few of you here. We're going to look into foundry. I'm going to try something new today. I've pre recorded a bit about foundry, just kind of speed things up. But I will be hanging out in the chat and then I'll pop back on here after the video to answer any questions that you all have.
00:00:42.684 - 00:00:58.400, Speaker A: So hopefully it's kind of the best of both worlds. You don't have to watch me stumble through typing and do anything silly. But if you have questions, I will be here, I'll be in the chat, I'll pop back on after, like I said. And. Yeah, hello. Wow. We got people from Nigeria, Pakistan.
00:00:58.400 - 00:01:12.090, Speaker A: Fantastic. All over Australia. It's probably like pretty late in Australia, I think, right now. Anyway, thanks for showing up. So I'm going to start this video and then, like I said, questions in the chat and I'll be back.
00:01:15.810 - 00:01:45.846, Speaker B: Hey, I'm Richard, one of the developer advocates here at Chainlink Labs. And today we're going to be taking a look at foundry. Now, what is foundry? It's essentially a smart contract development tool chain. It lets you write your smart contracts, compile your smart contracts, test your smart contracts, and even deploy your smart contracts, all using solidity. It's pretty awesome. If you've used something like hard hat in the past, it's similar, except for you don't have to do anything but write solidity code. And I think that's kind of great.
00:01:45.846 - 00:02:28.386, Speaker B: Now, it does come with some minor limitations, like you can't reach out with JavaScript, hit an API to get a result back when you're doing things like testing. But the fact that you can keep your brain all in the solidity space, I think is a massive advantage. So how do we get started with Foundry? Well, if you head to book Getfoundry sh, you'll see this website, it's foundry's documentation and it is a great resource and walks you through everything you need to get started. So let's look at this and see what all we need. First thing we'll do is we'll head to installation. We need to install foundry now, it asks you to curl a script and run it in. Bash and I always like to double check and see what exactly these scripts are doing.
00:02:28.386 - 00:02:56.430, Speaker B: So if you look at this URL, you can see here what it does, right? And you can kind of look through this if you want to read through it more thorough and make sure there's nothing crazy and malicious going on. That's always a great idea when it comes to running someone else's code on your computer. But I've looked at this before, it looks pretty good to me. So we'll just copy this command and we'll head to vs code. Now I'm going to be doing all of this in vs code. You don't have to, you could use a terminal for these steps. You can use whatever editor you like.
00:02:56.430 - 00:03:21.826, Speaker B: I've got a folder for foundry already set up. I have vs code open. You can see there's nothing in the folder in the terminal. I'll go ahead and run this curl foundry and pipe it into bash. It says here, hey, you've got your preferred shell set up as Zsh. That's the default on macOS, and you need to add this to your foundry. It says go ahead and run this command here to source that, because we've added it to your path.
00:03:21.826 - 00:03:54.274, Speaker B: So we'll source that at this point we should be able to run foundry up and that will go ahead and check and make sure and install everything that needs to be installed for foundry. So we should be good to go there. So we've done that it has here for Linux macOS users to use this bash RC. I think that's maybe slightly out of date, given what we just saw in the script. So we're good there. So at this point we should have access to things like forge cast anvil and Chisel. We'll be talking about forge a bit, not so much the other ones.
00:03:54.274 - 00:04:14.434, Speaker B: Again, their documentation is fantastic if you want to look at those as well. So we've got this installed. We're ready for our first steps in Foundry now. So let's take a look. So just to double check that we have forge installed, we do. It requires more options than that. So we've got forge installed, so we can do forge init.
00:04:14.434 - 00:04:37.450, Speaker B: Now this will create a default project called hello, Foundry. I would like to just do it within my foundry project here. So if we say forge init and the dot means here where we currently are and we're currently in the foundry directory, you'll see over here. Now we have a ton of stuff that just showed up, right? So this is the basic foundry project. Let's take a look. Let's tour through this really quick. We have a git ignore.
00:04:37.450 - 00:04:54.206, Speaker B: Always important to ignore things, not commit them to git. Especially things like env files. If you have private keys and stuff like that in there, you never want those going to GitHub. We also have git modules. It's kind of like package management. It has some paths for where things will be. We have foundry toml.
00:04:54.206 - 00:05:13.610, Speaker B: This is the config for foundry. We also have in here a source directory. This is where our contracts will go. You can see that it has a super basic contract here. And they've actually updated this since the last time I looked at foundry, which is great because it used to be this contract was just a contract with nothing in it. Now it's a counter. That's great.
00:05:13.610 - 00:05:27.870, Speaker B: So we've got our counter contract here. This basic one has a public number. It sets the number with a function. You can also increment the number. Sweet. We have a test folder over here. What do you think lives in the test folder? That's right, it's tests.
00:05:27.870 - 00:05:50.342, Speaker B: So we can see here a basic foundry test, how this is set up. Again, it's all in solidity. So we import the testing framework. We also import in that counter contract that we saw just a moment ago. Looks like this sets up a counter contract called counter. We do that in the setup. So counter is a new counter, and then we set the number to zero.
00:05:50.342 - 00:06:12.726, Speaker B: So what does set number do? Let's take a look here. Both of these side by side. So set number will set the number for our initial starting place with that number. Great. So that happens in setup. One thing to know about foundry is this setup will run before the tests are executed. So how does this setup work? It runs before each of the tests.
00:06:12.726 - 00:06:38.678, Speaker B: Basically, when I say basically, what I mean is the actual block state of the setup gets run, and then it gets to be like a pin put in that block state. It'll run a test, things will change on the block, and then it'll revert back to that block state. That saves a lot of time, so you don't have to reset everything. You just basically rewind history at each one of your tests to make sure you're back at that initial starting point. I think that's super cool. It's one of those things that foundry does that makes things just go super fast. We've got our first test here.
00:06:38.678 - 00:07:13.566, Speaker B: It's test increment. What that'll do is it'll run this increment function, and then it will assert that the counter number is incremented by one. Right because it started as zero and it should be one now. And then we have a test set number and this will run counter set number and asserts equal to that value. So how do we run this? What do we do here? Right, so, like, if we look at forge and we look at the options that it has, we have options like forge build, that's going to compile this contract. So we could run that. That would compile the contracts in our source directory.
00:07:13.566 - 00:07:40.406, Speaker B: Forge test, which will run the tests. So let's try that first. So let's run forge build. Let's make sure everything works. So it's compiling all our files and it ran successfully. Right. What if we had something like an error in here? So function and this is going to just return a return error.
00:07:40.406 - 00:07:54.286, Speaker B: Right. What happens here? This doesn't look like it's probably going to work. Forge build. Hey, look at that. We get our parser error, so this will let us know where the error is. What's going on? Cool. Let's go ahead and get rid of that.
00:07:54.286 - 00:08:08.926, Speaker B: We'll save it. We'll run our build again, make sure everything's good. Awesome. How do we test forge test. So this will run our tests, and they've really done a great job with foundry. This is definitely different than last time. I ran through the init.
00:08:08.926 - 00:08:21.590, Speaker B: We've got here our first test. Test increment. It passes. Cool. That means that we can increment this value by one. We also have another test test set number. And this is awesome.
00:08:21.590 - 00:08:49.498, Speaker B: It's a fuzz test, like, built in to the starter boundary project. Now is a fuzz test. What is a fuzz test? Fuzz testing is where you throw random values at the contract. What does that mean when I say random values? Well, if you notice here, it takes in this uint, 256 of X. Nowhere in this file is X defined. Right. So what foundry will do is it will go and then run 256 different random values.
00:08:49.498 - 00:09:19.340, Speaker B: It'll just throw them in there and make sure that it works. Right. Because we pass in, say, 123 and we set the number to 123 and we expect the counter to be 123. That's pretty cool. What else could we do? Let's write a new test real quick. Let's say function, test, set and increment, and we'll make it a fuzz test. We'll say un 256 y public.
00:09:19.340 - 00:09:41.810, Speaker B: And in here we want to say counter set number two y. If you notice that gray stuff down there below, that's going to be GitHub copilot. So then we'll increment once. And then we'll assert that our number is equal to Y plus one. Right. So this is kind of a little bit more involved test. We make sure that if we set to a random number, our increment also works.
00:09:41.810 - 00:09:58.454, Speaker B: We'll give this a save. We'll run forge tests one more time. Oh no. What happened? Something happened here. Arithmetic overflow, underflow counterexample. I'm betting what happened is that the data that was passed in. Yeah.
00:09:58.454 - 00:10:36.498, Speaker B: So this number here is going to be at the top of what's available as a Un two five six. So how do we fix this problem and ensure that the y that we're passing in is at least one less than the maximum? Well, we can first do something like this. We can set a Un max int for ourselves. So what this is saying two to the 256th power minus one. So that's going to be the max value of a un two five six. Now we can use Vm assume. What this will do is it'll ensure that the input value from our fuzz testing is at least less than the maximum int.
00:10:36.498 - 00:10:53.750, Speaker B: So what we want to do is we want to say Max int minus one, right? So it gives us that little bit of headroom so that we can increase it by one. And we're going to say that y has to be less than that. We'll give this a save. We'll run our tests one more time. Great, it passes. But this shows the power of fuzz testing. Right.
00:10:53.750 - 00:11:20.586, Speaker B: We need to make sure then that our increment. Right. Maybe we want to in here, ensure that the value can't be at the max for a uint two five six. If we're going to be incrementing it, that's something we could improve in this contract. This is just a basic super fast tour of setting up a contract and tests in foundry. If we look in the out folder, we can see all of the compiled files as well. If we look at counter Sol, we'll see the JSOn.
00:11:20.586 - 00:11:47.318, Speaker B: So this is going to be that Abi. If you ever need your ABI for something, it's going to be in that out. Once you've compiled it, it's great to know where this is, especially if you're interfacing with a front end or some other contract that needs that ABI. So you've got your foundry set up, you've got Ford set up, you've made some contracts, but you want to take it to that next level. How do we do that? Well, if you head to the foundry starter kit. So smart contract kit. Foundry starter kit.
00:11:47.318 - 00:12:28.754, Speaker B: We have a starter kit for Foundry, which basically will take all of the chainlink abilities and give you a place to get started with them. So what does this look like? I've gone ahead and followed the instructions here to get started. I've cloned this onto my local computer. But one thing to note, if you don't want to clone it onto your local computer, you can click this gitpod button, and you can open this in your browser, in a vs code emulator in your browser and run it on Gitpod. Gitpod is a great tool if you don't have the ability to run things locally. But I've gone ahead and I've already cloned this locally myself. Now I've got the readme here, because this is that entire folder, and we can just kind of follow along with the readme and install foundry.
00:12:28.754 - 00:12:59.152, Speaker B: We've got git installed. We've cloned this to our local directory. We've got it all set up. I'll go ahead and open a terminal here, and it says the first thing that we need to do is run make test, or forge test. After we run make. So make installs all of the dependencies. So we run make, you can see here, it's removing the git modules, it's reinstalling everything, ensuring that we have the right versions of everything.
00:12:59.152 - 00:13:07.572, Speaker B: Everything is afresh in this install. All right, so everything's installed. We can look at the make file and see what other options we have.
00:13:07.626 - 00:13:07.892, Speaker A: Right.
00:13:07.946 - 00:13:44.832, Speaker B: So makeall runs clean, remove, install, update, and build. So what does clean do? It actually just runs forge clean behind the scenes, remove removes these files, install runs forge install for a few different contracts, and then it runs build. So that runs forge build. If we run make test, it's the same thing as running forge test, but let's run maketest because it's a little bit shorter to type. So we run maketest and we see, wow, look at all these tests. Right? We have tests for price feeds and API and VRF consumer and keepers. That's a lot.
00:13:44.832 - 00:14:14.020, Speaker B: Where are all of these? They're in the source directory under test. And here you can see all of our different test files. One thing to remember in foundry is that test files have this t in the name. That's how it knows that it's a test file. So you can see the link here between these two, we have an API consumer and API consumer T. If we wanted to look at something like VRF, when we have tests for VRF and we look at the tests here, it's really interesting. We pull in these mocks.
00:14:14.020 - 00:14:58.528, Speaker B: Now, what are mocks? Mocks allow you to run a mock version of VRF. So when you're testing locally, you don't have all of the Chainlink Oracle network available to you. That's where the mocks come in. So this way we can mock, we can pretend to have an oracle that we can get a response from. So what do those look like? If we look in here under tests and mocks and mock VRF coordinator, you can see it's setting up a few things and it's importing the VRF coordinator mock from our contracts that we're importing from the Chainlink contracts. That's really cool. What this does is it gives you the ability to act like you have a VRF call that's happening on a real blockchain.
00:14:58.528 - 00:15:27.020, Speaker B: The same thing goes for price feeds for keepers and for the API consumers. We can see here all of the different mocks and how they work. There's also some utilities here. Cheats, sounds bad, right? What cheats do is they allow you to manipulate your local blockchain. So if you want to do things like change the block timestamp, that's going to be this warp functionality. If you want to give different values, different contracts, stuff like that. That's another thing that's built into foundry's testing suite.
00:15:27.020 - 00:15:48.980, Speaker B: So we head back to the documentation here, things to look at, right. We've got our first steps here. We didn't really follow this, but we kind of did. We ran the build and we ran the test. We can look at the different ways of creating projects when it comes to writing tests. It'll walk you through everything you need to write tests. I know we kind of brushed past it, talked about it slightly.
00:15:48.980 - 00:16:15.148, Speaker B: Their documentation is fantastic. They'll also be the discord if you run into problems when it comes to cheat codes. These are those ways of manipulating your local version of the blockchain. Explains all the different cheat codes. The foundry documentation is really thorough and really great. I really appreciate the work they've done putting this out there. And personally I love foundry when it comes to just writing smart contracts that are pure smart contracts.
00:16:15.148 - 00:16:52.248, Speaker B: And all I want to do is put my brain in solidity mode and just code. So, yeah, other than that, if you take a look at the foundry toml, you'll notice there's some other options here. There's one other file that I think is really important, and it's this remappings TxT. Now, when we take a look here at something like this at Chainlink line, you'll notice it says at Chainlink equals lib chain link Brownie contracts. Right. That's weird. What does that mean? Well, if we go and look here at one of our import statements, it's basically remapping this at chain link to point to lib chain link Brownie contracts.
00:16:52.248 - 00:17:26.132, Speaker B: Then we have contracts, source v eight interfaces. You can see where this is going, right? So this is just basically remapping your normal import statement to point to this lib directory. But it's something that's really important because if you miss out on this or you're trying to import another library, you're going to have a problem unless you remember to add it here as well. So, yeah, that's foundry in a nutshell. It's a super fast introduction to it. If you have questions, feel free to reach out in the discord. I love to hear your questions.
00:17:26.132 - 00:17:31.050, Speaker B: Love to see what you build with this. And yeah, good luck in the hackathon. I can't wait to see what you built.
00:17:34.960 - 00:17:38.620, Speaker A: All right, so that was the pre recorded Richard. This is the current Richard.
00:17:39.200 - 00:17:39.948, Speaker B: Yeah.
00:17:40.114 - 00:18:06.568, Speaker A: I have a question for you all who watched this? Did you like the pre recorded version? Was it weird to have it like pre recorded, not doing it live? Thoughts on that? Something new I'm trying out. And also, any questions that y'all have, I'll hang out here for a bit and answer them. Yeah, thanks for watching. That's all you've got in you this morning or afternoon or evening, wherever you are. I appreciate it. And we'll be on the discord to answer any other questions you have as you run into them. But let me know if you have any questions now.
00:18:06.654 - 00:18:27.956, Speaker B: And I'll be hanging out for a bite.
00:18:28.068 - 00:18:45.330, Speaker A: Yeah, I was trying to with the pre recorded to keep it compressed so I didn't ramble as much and spend too much time looking around. Can you explain in detail the remappings text in case I want to add a new. Yeah, sure. So let's take a look at remappings real quick. Let me rejigger my screen real quick.
00:18:57.040 - 00:18:57.500, Speaker B: It.
00:18:57.570 - 00:19:19.140, Speaker A: All right, so we've got here, this is the starter kit, remappings text. Basically what you want to do is when you import something. So if we take a look at the make file here and we look at this install command, for example. Right. It's going to run forge install. It's installing the smart contract kit contracts. It also installs like soulmate.
00:19:19.140 - 00:19:29.028, Speaker A: But this example is what we'll use just to kind of walk through this, right? So we install these. Where does it install them? It installs them in lib chainlink brownie contracts.
00:19:29.044 - 00:19:29.224, Speaker B: Right.
00:19:29.262 - 00:20:15.464, Speaker A: So lib chain link Brownie contracts is where this gets installed. The remappings is basically just remapping. Anytime we use at chainlink, point to that lib chainlink brownie contract. So if you wanted to install something like the open zeppelin contracts, you would do the same type of thing, and you add in like at open Zeppelin lib openzeppelin slash. Right? Maybe I got too many spaces in here, but does that kind of make sense how you would map those across? Hope it does. If doesn't, let me know in the chat what else we got myself on screen. Explain.
00:20:15.464 - 00:20:52.996, Speaker A: It's cool. Didn't figure out it was pre recorded. Well, it's good. I'm glad you didn't know it was pre recorded. Can you smart contracts test in script JS, like in hard hat or truffle? So this question, when it comes to foundry, your tests have to be all solidity. So foundry is like 100% solidity, even if you look here in the starter kit. And let's take a look at one of the scripts for deploying a contract, right? So even the deployment script, you'll notice this is written in solidity too.
00:20:52.996 - 00:21:24.524, Speaker A: So it's pretty crazy. When it comes to foundry, everything is solidity. So all of the tests are written in solidity. It's a plus and a minus when it comes to foundry in my mind, because one, you get to just stay in solidity land. And from a learning solidity standpoint, it can greatly help that. And you have to context switch between two different languages. Downside is, if you need to do anything outside of what a smart contract can do, like hit an API, for example, to check a value.
00:21:24.524 - 00:22:17.152, Speaker A: You can't do that like you could in hard hat, right? Because hard hat's tests are based in JavaScript, so it's a plus and a minus. How to put. Yeah, this is a great question, how to get foundry online. So if we take a look at their documentation, they have here a section for deploying and verifying. So this is the official foundry way to do things. You'd be running forge create, and then you'd be passing in the different values for your RPC URL, stuff like that. You could also take a look at the smart contract kit starter and like our deploy down here for go early, which don't use go early anymore.
00:22:17.152 - 00:23:00.240, Speaker A: Use Spolia, we should probably update this in our starter kit, but it will run this script and then it also runs some of the deploy information. That script is just going to pass in information to help deploy. So if you look at under scripts and we're looking at the contract, we'll just pick a different one here, VRF consumer, you can see it pulls in some different stuff when it's actually running. It has some things like the link address, description, ID and stuff like that that you'll pass in as well for that deployment. Just to make things easier. Can we fork Mainnet? I'm pretty sure you can. I don't know how to do it off the top of my head, but I'm guessing in here that they will have a section on that.
00:23:00.240 - 00:23:21.582, Speaker A: So yes, it looks like you probably could from here. Where can I find more info about Maxinth that was used in the fuzz testing? Where did Maxint come from?
00:23:21.716 - 00:23:22.062, Speaker B: Sure.
00:23:22.116 - 00:24:23.860, Speaker A: So when I was testing here, this test, so if we take this out real quick, run forge test, make this bigger, I realize my video, my screen wasn't super big. We get this error message, right, and it says that we have this overflow and it shows you the argument that was being used to test. So this is like if you were to do 256. So what this line here from accent is saying is UN 256 is going to be an integer with 256 bytes, right? And so two represents that one byte times is going to be an exponent. So it's saying two to the 256 power. So this value here, whoops, this value here will be like the maximum value of a UN 256, and then we'll subtract one from it because it's technically going to be one more than the maximum value with doing this like this. Hope that answers your question.
00:24:23.860 - 00:25:12.718, Speaker A: Pardon the dogs in the background. Does it have a testnet? So your question, I'm assuming you mean like can you actually deploy this to testnets? Yes, you can. You can deploy it to testnets for sure. Does foundry still have problems with the M One Mac processor? I don't think so, because this is a M one Mac, so everything works just fine for me. I know it used to, though. That's a good question to ask, because when the M One Max first came out, it definitely had problems. So, yeah, any other questions for you all? Thanks for showing up.
00:25:12.718 - 00:26:07.764, Speaker A: Thanks for asking questions too. It makes it more interesting when there's some interaction. Forge test would run locally, so it spins up like its own instance of a blockchain and runs that locally. Answering this question, it runs locally. And too, to that point, you'd want it to run locally. Because if we had to wait for this to run on Sepolia, for example, man, this would take forever just to run like these three tests, right? Because we'd have to deploy our contract, wait for confirmation, and then we'd have to run our first test, wait for confirmation, run our second test, wait for confirmation, and then the second and third test, these two fuzz tests, they actually run 256 times. So you have to wait for 256 block confirmations to go by.
00:26:07.764 - 00:27:08.224, Speaker A: That'd be pretty crazy. It's point too, about the testnets. That's why in the starter kit, having those mocks to let you actually mock the different things that would be deployed on a test network are important, right? Because for example, the VRF, like getting back the response from VRF, you need to make sure that that works without having actually deployed and running it locally. You need some way to emulate that. Are there any big projects developed using foundry? I don't know of any off the top of my head, but I would be willing to bet there definitely are. It's definitely a framework that is growing in popularity when it comes to using it. The cost of switching from foundry to hard hat.
00:27:08.224 - 00:28:03.770, Speaker A: For example, if you decided to start with foundry and then you wanted to end up using hard hat, you'd have to change a few things, probably about the layout of your project, all the stuff that you do, right? Like creating these contracts, for example. Well, not this one, that's a test, but like the actual contracts, all of these would just transfer right over. So you just copy these directly into another development framework, no problem. That's also the nice thing about the import remapping, because this is how hard hat would import things and having that remapping. So it's just like, I copy this and put it into remix, which remix is like an online IDE, and deploy this contract in remix and it would work. So that's one of the nice things. It's not like we're going from a front end framework, like we're changing from react to svelte or something like that, where there's going to be a lot of work that has to change.
00:28:03.770 - 00:28:37.016, Speaker A: So it would be pretty easy to switch between the two. But hopefully that answers your question. This is one of those questions too. Like, should I switch from hard hat to foundry? If you're using hard hat and it's working fine, stick with hard hat. There's nothing wrong with hard hat at all. It's kind of like saying, I have one brand of drill that I'm using, and there's this other brand of drill. Should I switch? You can if you want.
00:28:37.016 - 00:28:57.424, Speaker A: Like, if what you're using is working, stick with it. Like, hard hat is definitely super popular, very widely used as well. Foundry is probably honestly less used widely, but it's growing, right? It's newer than hard hat is. And again, it depends on how you're testing and what you're testing for, which one you'd really want to use there.
00:28:57.462 - 00:28:57.616, Speaker B: Right.
00:28:57.638 - 00:29:30.570, Speaker A: So if you're just living all in smart contract world, maybe foundry is the way to go. I like it when I'm setting up smaller projects for larger projects. Hard hat scrape, too. So it really is up to you. There's not a bad choice between the two. So, yeah, no, it doesn't really answer your question fully of, like, should I switch? It's up to you. These are all great questions, though.
00:29:30.570 - 00:29:57.688, Speaker A: Well, cool. I will, I think, sign off then. Unless there's any other questions, show up in just a minute. If you do have questions, there is the discord. You can reach me on Twitter as well. I'm at r. Lieber.
00:29:57.688 - 00:30:24.936, Speaker A: Let's pop it here in the chat. If you want to reach me on Twitter, my DMs are open, so feel free to reach out if you have questions and stuff like that. But, yeah, can't use discord chats. How to interact, look for a partner. Oh, that is a good question. Go ahead. And if you can use Twitter, reach out to me there.
00:30:24.936 - 00:31:08.850, Speaker A: If not, reach out. I'm sure there's a link other than Twitter or discord. Let me see real quick what's on the hackathon website. Yeah, if you can reach out to us on any of the other socials that are on, like, the hackathon website down at the very bottom, we can definitely work on getting you help with that, too, and getting connected. I know most people are using discord, though, for kind of getting partners and stuff like that. But we'll see what we can do. All right.
00:31:08.850 - 00:31:23.740, Speaker A: Well, with that, good luck in the hackathon. And, yeah, I can't wait to see what you build. Like, I'm excited. So, yeah. Talk to you all later. Bye.
