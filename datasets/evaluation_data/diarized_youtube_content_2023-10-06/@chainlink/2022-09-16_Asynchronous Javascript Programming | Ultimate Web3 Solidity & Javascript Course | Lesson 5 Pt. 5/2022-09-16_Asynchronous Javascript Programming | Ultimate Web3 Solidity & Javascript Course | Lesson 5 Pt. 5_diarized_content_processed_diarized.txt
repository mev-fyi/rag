00:00:16.320 - 00:00:44.632, Speaker A: But I do want to give you a quick background on asynchronous programming. So far, the programming that we've done has been synchronous, and solidity is an example of a programming language that's synchronous. Synchronous means it just goes one line after another. If our code looks like this, this is synchronous, right? Our main function is the first thing that actually gets called. Then we do console log, let variable equals five, and then console log again. This is synchronous programming. In JavaScript, all of our solidity is synchronously programmed.
00:00:44.632 - 00:00:49.148, Speaker A: There will be some exceptions to this when working with oracles, but for now everything is synchronous.
00:00:49.244 - 00:00:52.656, Speaker B: JavaScript can be asynchronous, meaning that we.
00:00:52.678 - 00:01:46.192, Speaker A: Can actually have code running at the same time. Good example I like to use to understand the difference is with cooking. In synchronous programming for cooking, you might put popcorn in microwave, wait for popcorn to finish, and then maybe you'll pour drinks for everyone. And now this is synchronous programming. Now it might be a little bit weird for you just to put the popcorn in the microwave and then just stare at it, waiting for it to finish, and then pour the drinks. You typically can pour the drinks while your popcorn is in the microwave, and this is where asynchronous programming comes in. If setting up for this movie night were asynchronous, what you would do is you'd put popcorn in the microwave, and while the popcorn is in the microwave, pour drinks for everyone, and then you'd wait for popcorn finish, since there's nothing left for you to do.
00:01:46.192 - 00:02:15.896, Speaker A: But it doesn't make sense for you to wait for the popcorn to finish to pour your drinks. You can just go ahead and pour the drinks right away and then wait for the popcorn to finish. So asynchronous programming is way for us to do stuff without waiting around for things to finish. And this is really advantageous. And JavaScript by default allows us to do this asynchronous programming. However, sometimes we do want to wait for our popcorn to finish. For example, if instead of just pouring drinks, maybe the next thing instead of pouring drinks was place salt on popcorn.
00:02:15.896 - 00:02:49.736, Speaker A: Of course, if we want to place salt on our popcorn, we do have to wait for the popcorn to get out of the microwave. So even though placing popcorn in the microwave has this wait time, we need to be able to tell our code. I want you to actually wait for it or know you're good. You can go on and do another task. So that's kind of the difference here, and I'll leave some links in the GitHub repo associated with this course to understand this a little bit better. Functions that have functions that come with this waiting period return something called a promise. If put popcorn in the microwave was a function in javascript, it would be a promise based function.
00:02:49.736 - 00:03:27.056, Speaker A: A promise can be either pending, fulfilled or rejected. And this is how we know if our popcorn is done. If our popcorn was a method, putting popcorn in the microwave were a function in JavaScript, when we're waiting for the popcorn to finish, it's in a pending state. When the popcorn is finished, it would be fulfilled, and if we aborted halfway through and we stopped waiting, it would be rejected. So putting the popcorn in the microwave returns a promise. With this promise we have to tell our code, hey, we want you to wait for the popcorn to finish, or you can go ahead and you can just keep doing stuff. So let's put this all together with.
00:03:27.078 - 00:03:39.024, Speaker B: Some Javascript syntax here. Let's say again, we're going to be setting up this movie night and we need to cook popcorn, pour drinks for everybody, and then we need to start a movie. So let's write some pseudocode to pretend.
00:03:39.072 - 00:03:40.416, Speaker A: What this code would look like if.
00:03:40.458 - 00:03:55.480, Speaker B: This was actually a function. So we'd create some function called setup movie night. And in here we would say, okay, what's the first thing we need to do? Okay, we need to cook popcorn. So let's say we have some cook popcorn function. So we'll say, okay, cook popcorn.
00:03:55.560 - 00:03:57.308, Speaker A: Then the next thing we're going to have to do is we're going to.
00:03:57.314 - 00:03:58.600, Speaker B: Have to pour drinks.
00:03:58.760 - 00:03:59.784, Speaker A: Pour drinks.
00:03:59.832 - 00:04:24.196, Speaker B: So we'll call some poor drinks function. Now here's the thing, we only want to start the movie once our popcorn has been cooked and once our drinks have been poured. So if either one of these returned a promise, so if either one of these returns a promise like cooked popcorn, for example, we would need to tell our code here to actually wait for the popcorn to finish, because cooked popcorn is going to be a function where.
00:04:24.218 - 00:04:27.248, Speaker A: We could say let status equals cooked.
00:04:27.264 - 00:04:51.756, Speaker B: Popcorn, and while the popcorn is being cooked, the status is going to be pending. Once the popcorn gets cooked, it'll be fulfilled. If the popcorn breaks, the microwave explodes, the status would be rejected. But we don't want the status to be in a pending situation before we move on. We only want to start our movie once these two functions have completed. And let's say both of these return these promises things. So we need to tell our code.
00:04:51.756 - 00:05:34.100, Speaker B: Hey, you have to wait for cooked popcorn and for poor drinks to finish. So what we can do now, without getting too deep into the weeds on how all of this works, one of the easiest things that we can do, and you'll see us use this syntax quite often, is we'll turn this function into an async function. When our functions are async, we get access to a keyword called await. The await keyword tells any promise based function to wait for that promise to be fulfilled or rejected. So we say, okay, we want to await for our popcorn to cook, and then we want to await to pour our drinks, and then we can just go ahead and start the movie. And we only start the movie here once these two have been completed.
00:05:34.180 - 00:05:37.704, Speaker A: And this is why throughout all of our code, you'll see this await keyword.
00:05:37.752 - 00:05:42.856, Speaker B: Used a lot, but it can only be used in async functions. So basically, whenever you see this await.
00:05:42.888 - 00:05:44.556, Speaker A: Keyword, just know, ah, okay.
00:05:44.658 - 00:05:52.284, Speaker B: The function that's being called is promise based, and we don't want to move on to the next step until that function has completed.
00:05:52.332 - 00:06:35.804, Speaker A: So that's a little bit more about promises and asynchronous programming. Hopefully that's clear. If not, like I said, there's some links in the description to learn more about asynchronous programming. The reason I wanted to go through this is because most of the functions that we're going to be working with are going to be asynchronous. For example, when we deploy a contract, what do we have to do? Well, we have to wait for it to be deployed. If we don't use synchronous programming and we just leave our function main like this, what would happen is we would write some code like contract deploy and we wouldn't wait for it to finish. Obviously, if we don't wait for it to finish and we try to run some code on a contract that hasn't finished deploying yet, it's not going to work.
00:06:35.804 - 00:07:17.110, Speaker A: So we want to do this. We want to have our main function be an async function so that we can wait for our contracts to deploy, we can wait for things to happen, we can wait for our popcorn to finish. We can have the flexibility to tell our code to either wait for our popcorn to finish or continue on. So now that we have our main function as an async function, we're going to add some code to our main function down here, and the code that's added here is some syntax we're working with asynchronous functions. And if this part is confusing, I'm just going to say for now, absolutely don't worry about this. If you want to try to understand it later, that's fine. But for those who are following along, we're just going to add at then catch.
00:07:22.690 - 00:07:23.354, Speaker B: The error.
00:07:23.402 - 00:07:50.406, Speaker A: Error. You can follow along typing this yourself, or you can just copy paste it into your code. Basically what this allows us to do is we have our main function. That's an asynchronous function. So when we call the main function, this is some other syntax for waiting for it to basically finish and then printing any errors it gets. And that's why we do this. But again, if this big lump of code, if you're like, what is going on with this big lump of code? Honestly, for now, just copy paste it.
00:07:50.406 - 00:08:14.910, Speaker A: So great, we have our asynchronous function main. We have some code and then we have this lump of code which basically just calls our main asynchronous function. Okay, great. I'm going to delete all this for now, but you can still find that comment in the GitHub repo associated with this course. Awesome. Okay, so now that we have our real basic setup, let's go ahead and start coding. And if this setup part is confusing and the async await stuff is confusing, don't worry too much about it.
00:08:14.910 - 00:08:16.490, Speaker A: It'll make more sense as we progress.
