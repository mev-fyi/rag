00:00:09.330 - 00:00:22.614, Speaker A: All right. Hello, everybody. My name is Rory. I'm the community manager with Chainlink. I'd like to welcome you to another one of our virtual workshops. We've been putting on quite a few of these, both during our virtual hackathon. And this is really the first one after that.
00:00:22.614 - 00:01:09.302, Speaker A: And you can expect these to be occurring on a relatively regular basis. As always, if you have any topics that you'd like to bring up that you'd like Dan to cover, or you find some interesting people in the community, be it a node operator or one of our integrations, please feel free to reach out, and we'll be more than happy to have them on as a guest, have them do a workshop and things like that as well. So this is really community driven, so please feel free to take a role in that. That being said, so what will today's workshop be? Well, today Dan will be demonstrating some tools and workflows. To help you experiment locally with the Chainlink node, Chainlink external adapters, and Chainlink smart contracts. So I've also included the agenda in the Zoom chat, if you would like to take a look at that. We'll also post that in the video links, obviously, once we get that video posted up on YouTube as well.
00:01:09.302 - 00:01:16.166, Speaker A: So, Dan, if you'd like to take over, thank you again for hosting this. And please feel free to start the workshop.
00:01:16.278 - 00:01:46.926, Speaker B: Awesome. Thanks, Rory. Yeah, so, as Rory said, as usual, we're going to be working off kind of one of these documents that I created. So let me just go ahead and share my. Oops, sorry, that's not the button that I wanted to push. Let me go ahead and share my screen and we will get right into the demo. Okay, so, like Rory said, what we're talking about today is some different things that you can do to help you experiment with Chainlink.
00:01:46.926 - 00:02:30.082, Speaker B: I think that's a really great word to describe what it is that we're going to be talking about today. Basically, as developers, hackers, whatever you want to call us, we're people who like to take things apart, potentially break them, see how they work. And it's wonderful that we have resources like the Robson testnet, which is a great place to do stuff like that. But sometimes it's better to even get a little more sandbox than that. So you can feel a little bit more comfortable breaking things and even be more in control of the things that you can break. So there are existing tools out there to support these kinds of concepts. I'm certainly not the first person who's ever felt like I wanted to break something.
00:02:30.082 - 00:03:04.640, Speaker B: I hope that you're that kind of person too and that's why you're here. So yeah, there's something called Ganache that you're probably familiar with. It's basically like a mock Ethereum blockchain that you can run locally and then you can use it to kind of engage in Ethereum development. And so we're going to use things like that today to make us feel a little bit more comfortable breaking stuff. So I hope that's exciting to you. Let's just go over the first part of this document here. Just make sure that we understand kind of level set where we're coming from.
00:03:04.640 - 00:03:49.590, Speaker B: Keep in mind that because this kind of project that we're working with is literally designed to help you break things and not have to worry about them. You never want to take this that we're doing today and deploy it out to production. This is just one step along that way. But so many of the things that we're doing to allow us to break things locally, you would never want to deploy it out to production. So keep that in mind. These kinds of tools and workflows will give you the opportunity to potentially interact with a completely custom version of the chainlink node if you want to. But it's not going to give you best practices for running in production.
00:03:49.590 - 00:04:37.254, Speaker B: So just kind of understanding where we're coming from here. So as this environment section states here, this project right now I'm pretty sure it's only going to run on Linux. And that's because I have a Linux machine. In order to get the things working that I wanted to get working I had to make some changes that are specific to the Linux operating system. Specifically we're going to be working with Docker today. And Docker is kind of like a little computer inside your computer. And so in order to network the processes running within Docker with the processes running on your computer which is called the host machine there's kind of different ways that you need to do that for different operating systems.
00:04:37.254 - 00:05:44.080, Speaker B: And so the way that I have done that in this repository is very specific to Linux. I would love for someone out there that has a Mac machine or someone out there that has a windows machine to fork the repository that we're going to be looking at today and help me make some changes so that this is a more cross platform, more useful set of code. At the end of the day though, what I'm working on right now is figuring out how a lot of these tools that we're going to be looking at today can be lifted out of this kind of very specific toy project that we're going to look at and become libraries of code that you can pull down from NPM just like you may be used to, and make it really easy for you to do these things in a much more general fashion. So that's kind of level setting where we're coming from, I guess. Before I really dive into the workshop, are there any questions about kind of why we're here, what we're talking about? Rory, any questions coming in on the Q A?
00:05:45.330 - 00:05:46.702, Speaker A: Nothing so far, sir.
00:05:46.836 - 00:06:21.194, Speaker B: Okay, cool. If you have some, I'm just going to keep talking, but if you realize, like, oh crap, I do have a question, type it in the Q. A warrior will interrupt me, no big deal. But in the meantime, let's just kind of look at this repository that we're going to be playing with today. It's called delivery link because ostensibly speaking, it's meant to be a project that would implement secure decentralized payment on command on secure decentralized payment on delivery. Excuse me. I think what you'll notice is that this hasn't been fully implemented yet.
00:06:21.194 - 00:07:08.410, Speaker B: These capabilities haven't been fully implemented yet. As I continue to build out the tools that I'm using, it will be much, much easier for people like you and I to build these things out super duper quickly. So that's kind of the types of capabilities we'll be exercising in the smart contract that I'm deploying. But really what we're talking about is all the tools that enable us to do this locally. So we already talked a little bit about Ganache and Docker, actually, which are two of the tools that I'm going to be using. We talked about the fact that this is only for experimenting, this isn't for production runs on Linux. Kind of talking some more about the dependencies Docker and Ganache.
00:07:08.410 - 00:08:21.246, Speaker B: One thing I haven't mentioned yet is we're going to use an external adapter as part of this workshop, and that external adapter is going to use the easy post API. So we can take a look at that right now. This is a restful API that allows you to get information about the delivery status of a package and it requires you to use an API key. And that's something that you kind of need to use an external adapter right now in order to use that capability. And so having the freedom to create and deploy and totally manage external adapters with respect to your chainlink node and your smart contracts, that's something that I think is going to be very useful for all you chainlink developers out there, all you people building with Chainlink out there. So in order to exercise the capabilities of this project that rely on the easypost API, there is this expectation that you have an easy post API key and you can follow along, click on this link and get that when you follow through on the steps of this workshop later on your own. So we're going to jump right into the steps of the workshop.
00:08:21.246 - 00:09:07.354, Speaker B: Now, I have already installed the dependencies because as you know, I've run through this workshop a million times, so that it's a good workshop for you guys who are all watching it. And I have already updated my environment file to have the correct API key. I don't want to show you that because that's something private. And you'll see that that value is stored here in this n file and its value right now is change this. So you'll want to change that value. It's not just a clever name, that's what's going to be read by the easy post adapter process. And you'll notice that that file is, oh, I guess it didn't make it into our git ignore.
00:09:07.354 - 00:09:44.054, Speaker B: It should be in the git ignore, and I will make sure to do that. But once you put your API key in there, you don't want that to go up onto GitHub. And I haven't put mine on GitHub, and I'm not going to show you mine on this workshop either, because you should keep that value private. So let's jump right into the workshop. I'm going to go ahead and start Ganache. And because Ganache is created by the same people who create truffle, it's very easy to add a truffle project to that. To Ganache, truffle is a framework for building smart contracts.
00:09:44.054 - 00:10:22.742, Speaker B: And so as I've been talking about throughout these workshops, what I want to do is create tools that play nicely in this ecosystem because that's going to make us all more effective. So let's go ahead and start Ganache. Oh, I already have Ganache running. That's okay. I don't have a blockchain started yet. So I'm going to add the truffle config and then I'm going to just make this one setting here so that it's listening on all interfaces, the truffle server, and that's so the chainlink node running in Docker can access it on the host machine, which is something we already talked about a little bit. So let's do that and then I'll save the workspace.
00:10:22.742 - 00:11:09.590, Speaker B: So just adding the truffle config, making this small update to the server. All this is described in detail on the document. So now what you'll see is ganache is running. It exposes this lovely GUI where you can see that you have ten accounts all funded with 100 E, which is fun for one thing. And that would take a really long time to get set up on the Robson test network, even on the Robson test network. So this is a huge reason why you may want to do things locally like boom, you're in complete control of these ten accounts, they're fully funded, you're ready to go. So now we have done that.
00:11:09.590 - 00:11:53.814, Speaker B: Now let's go ahead and run NpM start and it's going to perform these steps that are described up here. So I'm going to run it and while it's running we'll go through the steps of what it's doing. Okay, so I just want to convince myself that that's often running in the background there. And so what's happening is we're migrating some contracts to our ganache blockchain. So step one here. And so that's going to be the link token contract, the chainlink Oracle smart contract and a client smart contract that we're going to use to interact with our chainlink oracle. Then it's going to deploy a pre configured chainlink node using Docker which we talked about.
00:11:53.814 - 00:12:26.814, Speaker B: Chainlink node is going to be all hooked up to ganache. We're going to launch an external adapter using Docker. So that will be running and it'll be all networked together very easily for the chainlink node to access. And I can show you that here in a second. And then we are going to run some truffle scripts to do more work for us. We're going to fund the client contract that we wrote with 100 link tokens and I'll show you in a second why we were able to do that. It's kind of fun.
00:12:26.814 - 00:13:08.800, Speaker B: We're going to give our chain link node access to the Oracle contract that we deployed. We're going to fund the node with some ETH so that we can write transactions to our Ganache blockchain. We're going to add jobs to our chainlink node and configure the smart contracts to use those jobs, all this kind of stuff. And we'll look at this in more detail. I just want to run you through what's happening there. So we just ran NPM start and let's go take a little bit of a closer look at what just happened so you can see that everything ran successfully. That's the goal of NPM start to package up all these commands for you.
00:13:08.800 - 00:14:10.718, Speaker B: And so let's just see what happened. So we compiled our contracts, we deployed them to the ganache blockchain. We spun up Docker and the external adapter, excuse me, we spun up the chain link node and the external adapter using Docker we transferred 100 link to our client smart contract. We set the fulfill permission, we sent the ETH to the node and then we did all that work with adding the jobs and configuring the client contract. So let's look at the Docker compose file that allowed us to do this. Docker is works with this concept of containers. And so what a Docker compose file allows you to do is define a set of containers and the configuration with which you want to spin them up and get it all hooked up for you very easily.
00:14:10.718 - 00:14:59.806, Speaker B: So I'm pulling the Chainlink docker image from the Docker hub container repository, configuring all the ports that it's running, pointing it to the right environment. I don't want to walk you through this exhaustively because the project is meant to kind of abstract a lot of this away from you. And so I don't want to get into the nitty nitty gritty of it, but I want you to understand that this isn't magic. This is where you go to learn about how the docker is set up. I hope that you fork this repository and pull it down and break it, and we'll talk about some ways, hopefully that you can do that moving forward. And again, if you have specific questions, please ask them. In a nutshell, this is the Docker compose file.
00:14:59.806 - 00:15:32.426, Speaker B: This is how we define our Docker environment. Now let's go and check out how we're able to fund our client contract with so much link. And to be honest with you, this isn't really like quote unquote useful. It's just kind of fun. So I'm going to my wallet here. That's part of my brave browser. And so this is actually a different account.
00:15:32.426 - 00:16:21.810, Speaker B: You can already kind of see where I'm going with this, but let me remove this account that we're looking at and I'm going to add a new one here. So I want to add the account from my ganache blockchain and Ganache makes that super easy for me to do. I can get the private keys. And you can see that I'm kind of okay showing you this private key because it just belongs to this ephemeral Ganache instance, which is going to go away really soon. And so it doesn't matter to me if you have this because it's not live anywhere other than my local machine. So I can grab that private key and then I can use that to import this account into my wallet, metamask or whatever you use. So you can see now that it has the exact same amount of ETH that it's showing on ganache.
00:16:21.810 - 00:16:52.550, Speaker B: And now let's add the link token. And because we hooked up Ganache and our truffle config, if we go here to contracts, you can see all the contracts from that truffle project that were deployed to our Ganache blockchain. So let's get the address of the link token contract. There we go. And let's add that token here. You're probably familiar with this process. See, got that all added.
00:16:52.550 - 00:17:28.770, Speaker B: And that's just really fun to see that you have that much link. It's kind of cool. Obviously it doesn't mean anything because it's only on this fake little ganache blockchain. But one of the fun reasons why it's fun to do this all locally and why do we have a billion less 100 and not 1 billion? It's because we sent 100 to that client contract. And so you can see that we did that. Where did we do that? Yeah, that happened right up here. Okay, now let's continue following along with our workshop.
00:17:28.770 - 00:18:12.774, Speaker B: So we want to sign in to the web Ui of the chainlink node that we spun up using Docker. So let's go ahead and do that. I'm going to close my wallets because we don't need those anymore. I pre configured the credentials which are there in the readme so we can log in and we can see that we have some jobs created for us. This is this part of the output here where we're creating these jobs. And you can see that the ID of this first job is DF five three three something or other. And so here's this job, DF five three three.
00:18:12.774 - 00:19:38.900, Speaker B: And we can go and we can inspect it. And let me show you the part of the project where this is actually happening because I want to make sure that you feel comfortable with this. So if I go into truffle and I go into my scripts here and I find this add jobs script, I can see that I'm making use of this clutils library that I created, which is local to this project. But very soon this is going to become something all on its own that you can pull down from NPM and use in any project. And what I'm doing is I'm hooking into some of these helper functions that it exposes to create a job. So I'm returning the kind of bare skeletal JSOn that you need, or the raw skeletal JavaScript object that you need to create a job, and then hooking into some helper functions to configure them with the appropriate tasks and then actually calling into the chainlink node rest API to post the job here, you know, pretty straightforward node request using HTTP whatever. And so we created the job.
00:19:38.900 - 00:20:15.498, Speaker B: We created a bridge. One of the jobs that we created, in fact leverages the bridge that we created. So we got this all kind of hooked up. And again, all this was happening when we ran that NPM start command, which is defined here in our package JSOn under the start. And you can kind of dig into the guts there a little bit if you want to, but we're not going to get that down deep in stuff right now. So let's see where we are. Oh, one thing we didn't do is we didn't look at the logs of the chainlink node.
00:20:15.498 - 00:20:59.546, Speaker B: So there's a helpful command defined in the package JSON which we just looked at that we can use to view the logs of the chainlink node. So I'm going to use NPM run chain link logs and this is just a helper command that I wrote to get the logs out of Docker for you and so you can review them here. And if you've broken something, this is where you go to figure out what you've broken. So we have those running and so now we're actually going to start interacting with the smart contracts that we deployed. So let's use remix to do that. And many of you are probably familiar with remix, you've probably seen it in my workshops before or used it even before that. So I'm not going to spend too much time explaining it.
00:20:59.546 - 00:21:47.188, Speaker B: I'm just going to kind of use it. And again, this is another great time for questions, if you have any. But in order to help me get started with remix, I have another command that I defined in my patents, Json. Just going to connect remix to my local file system as you've seen me do before. And now I want to go check out the client contract that I deployed. So that's this delivery link contract. Again, this is supposed to be secure, decentralized payment on delivery.
00:21:47.188 - 00:22:29.782, Speaker B: Got to make sure that we're using the right compiler version. I'm waiting for my favorite remix error. There it is. And now I'm just going to compile it one more time to get over. Um, so now what I want to do is I want to actually connect remix to the Ganache blockchain. I don't want to use Robston or I want to use the Ganache blockchain. So I select web3 provider and then I select the port that Ganache is running on.
00:22:29.782 - 00:23:12.986, Speaker B: And now you can see that this account that's loaded up here, FF five DB, it lines up with the first account and then 9338, we have all those other accounts that are loaded there. And so now what I want to do is I want to interact with this delivery link contract that I've compiled and it's already been deployed. NPM start did that for me when we deployed our contracts. And so I just need to get the address that I deployed that contract to. So I'm going to click that and boom, there's my deployed delivery link contract. And let's take a look at where we are. So we have loaded the deployed instance of the delivery link contract.
00:23:12.986 - 00:23:43.230, Speaker B: So everything that I just did kind of went through those steps. And now we can use remix to inspect some of the values that we configured this contract with. Namely we configured it with the address of the oracle that we deployed. We set up the job Ids. So that's all pre configured. And maybe this is something you want to do in a real world smart contract, maybe it isn't. This is again just this kind of stuff that I'm doing as part of this workshop.
00:23:43.230 - 00:24:43.486, Speaker B: So we can look and we can see that the address of the chain link Oracle here, d five edd, it actually lines up with the Oracle contract address that our chain link node is configured with. This was all done when I ran that NPM start command. So we can see other things like the address of the chain link token, the job IDs that we configured things with. And let's just look really quick at how I set that up. This was the pattern that I used. You may want to use a different pattern when you're doing your own development, but I have only owner modified functions here that I can use to set the package carrier and then any, sorry, like the job IDs. I have only owner functions that I use to set those job IDs.
00:24:43.486 - 00:25:29.760, Speaker B: And then there are functions that anyone can use to get them just to view them and see what job ID is being used. And then theoretically you could use something like chain link Explorer to go check out that job if you wanted to. And then there's other helper functions here for some of the other variables that we've exposed. So we checked those out and now let's see what the timestamp variable is. So that's going to be a variable that has not been set yet. And the reason that hasn't been set yet is because that's something that we're actually going to get from our chain link node. So if we look at the timestamp job Id we can see it's this DF five three.
00:25:29.760 - 00:26:04.342, Speaker B: So let's go to the chain link, we'll find this and we can look at the definition. We can see we're going to do. This should look very familiar to you. HTTP get json, parse, convert it to an ETH 256 and then write it back to the blockchain. And so this is going to get us a timestamp. I figured this might be something useful for secure decentralized payment on delivery. So this is the data that we're going to get back through the chain link node.
00:26:04.342 - 00:26:41.858, Speaker B: It has this one Unix timestamp property. So we're going to get that path and then convert it to an e view in 256 and write it back to the blockchain. So right now that value is zero. We're going to do the request current timestamp. And you can see I don't need to add any parameters because it's all already been configured for me with the job ID and the address of the oracle that I'm using. So that's been executed. And now I can go to my chain link node, see that that job ran, it ran successfully.
00:26:41.858 - 00:27:18.290, Speaker B: I can view all of that. I can go to Ganache and view that if I'd like to. I'm not going to do that right now, but you can if you want to. And now when I look at the timestamp, boom, that value has been updated. Let's go ahead and exercise the external adapter that we deployed, which is this easy post adapter. And so we'll look at where the easypost adapter lives. It lives here in this adapters directory as part of our project.
00:27:18.290 - 00:28:19.080, Speaker B: And there's an easy post subdirectory and there's a Docker file here that tells us how we want to build this easy post adapter into a Docker image. And so it's really super simple. When I want to use Docker compose. To launch this adapter I just specify the location of the docker file in the build tag of my docker compose. And so now what you can imagine is if I want to make concurrent developments on my smart contract and my external adapter, I can make those changes to the source code here of my external adapter. And then when I run NPM start it'll automatically build that docker file and deploy the updated version of my code. And now boom, I can write a smart contract that exercises those functions kind of all wrapped up and packaged in a nice easy to use little container for you.
00:28:19.080 - 00:28:55.310, Speaker B: So now we want to exercise those capabilities. It's running at easy post six two one and that was configured because the docker file for the easy post adapter, it exposes port 6221. So that's where it's running. So hope that kind of explains how the external adapter is all set up. I don't want to go off too much on a tangent there. Let's exercise those capabilities now. So I did not fully configure the job that we're going to use to request the delivery status.
00:28:55.310 - 00:29:46.610, Speaker B: It expects these package carrier and package code values that have not been configured yet. So we're going to use remix to configure those values. Again, just a different pattern of development, just kind of showcasing different ways that you may do things. So we are going to use some test values that easy post provided to do this. So we are going to set package carrier and that's a string value. So we're going to use and that succeeded. And then we're going to set the package code again with this dummy value that's provided to us by easy post for their API purposes.
00:29:46.610 - 00:30:43.430, Speaker B: So that's been configured. Before I get too far ahead of myself, let's see what the delivery status is right now it hasn't been set because we haven't executed this delivery status function that's going to go out and make this request to the easy post adapter and then write the value back to our blockchain. Let's just check out what it looks like here. Very similar easy post adapter because the adapter returns a JavaScript object as opposed to a JSON string. We use copy as opposed to json parse. Then we convert the string value that we're parsing out into an e bytes 32 and then we write that value back to the blockchain. So now we should have everything configured.
00:30:43.430 - 00:31:18.450, Speaker B: I can use my helper functions to determine that package carrier has been set. Package code has been set. Let's go ahead and request the delivery status. We can go to our chainlink node and see. Now we have another job that executed successfully. And now when we go back and we get the delivery status, we can see that we're in pre transit. So that's the status of this package that easypost puts out there for development.
00:31:18.450 - 00:32:47.290, Speaker B: So that takes us all the way through the end of these usage steps and we have a good amount of time left, which is awesome because there's some additional capabilities that, not really capabilities, I guess, but just showing you how you can continue to build on these capabilities to add additional functionalities to your client application, your client contract. But now is a really good time for me to pause for questions, if there are any questions. Okay, I'm going to go ahead and get started on this next part of the workshop here. But Rory, if any questions come through, please feel free to interrupt me. So let's see, what I'm going to do is I'm going to show you how easy it is to add another external adapter to this whole setup that we got going on here. We're going to do the good old fashioned crypto compare example where we look at the Ethereum to USD exchange rate. But we're going to do that with another external adapter because I think that's really at the end of the day for developers of Chainlink smart contracts, that's the primary value add that this project in its current state brings.
00:32:47.290 - 00:33:45.662, Speaker B: It provides a really easy way for you to be in complete control of everything down to the external adapter. So adding external adapters, I think, is an important part of what we're going to do here. So that's what I want to show you. And so let's go ahead and just bring everything down again, just so we're starting from kind of a clean slate that means Ganache and everything. So just get rid of what we were using before. And so I have prepared a branch to kind of help with this, and we can look and see the differences between this branch and the one that we were just working on. So what we do is we add another docker file to the docker compose that we were looking at, and we'll look at where this docker file comes from in a second.
00:33:45.662 - 00:34:50.658, Speaker B: And you can see that unlike easy post, I had to configure the ports. And then I just made some very simple changes to the client contract to exercise these capabilities. This should look very familiar to you. These are getting the Ethereum to USD exchange rate and then that script that we were looking at that added the jobs to the chainlink node and configured the client contract to use them. That has been updated to use more of the capabilities of the rest client and the helper functions. So you can see pretty straightforward changes that allow you to focus on the specific capabilities and values that you're bringing with whatever DAP it is that you may be working on. So you don't have to worry a lot about the infrastructure when you're in the experiment stages of figuring out how your DAP is going to work.
00:34:50.658 - 00:35:56.762, Speaker B: When you go into production, there will be a whole nother set of questions that you need to ask yourself. So let's go ahead and switch to this branch. I'm going to stop remixd, so I think everything should be shut down and I'm just going to use visual studio code to check out this workshop branch. So that should take just 1 second. So now I'm there and let's look at where that adapter is coming from. So if you remember the external adapter workshop, we use the Bridges library. And in the Bridges library, which is a go library for creating chainlink external adapters, there's a few examples in here, one of which is this cryptocompair adapter that we're going to use right now and it has a Docker file in it.
00:35:56.762 - 00:36:53.898, Speaker B: And so in order to get things working, what I had to do was replace the docker file in the root of the bridges repository. I had to replace the main docker file basically with the docker file of the Bridges adapter. It looks like it wants to be in this parent directory as opposed to in the actual directory that it's located currently. So maybe that's a pull request I can make on the bridges repository. But for the sake of this workshop we're just moving the Docker file into the root of the bridges repository. And you can see that unlike the easy post adapter Docker file, this one does not expose a port and so that's why we need to have that configured in our Docker compose. So just wanted to show you where that was coming from.
00:36:53.898 - 00:38:15.066, Speaker B: I'm going to close this instance of visual studio code now, so hopefully now you understand where the Docker file for bridges is coming from. And now what I'm going to do is just go back through those steps and I'm going to do it pretty quickly because it should be all very familiar to you now. Just waiting to make sure everything's set up, running NPM start again. And now because we made the changes to the Docker compose file, the client smart contract, and the add job script that's going to be run as part of our NPM start command. All of these changes are just going to be automatically deployed. And so that's what the NPM start command is doing for us now, wrapping that all up into one nice easy command. Spinning up the docker containers right now.
00:38:15.066 - 00:40:03.030, Speaker B: You can see that there's now an additional docker container there. This cryptocompair docker container starting to run through our truffle scripts. Now we're adding those new jobs. So you can see the output here will be a little bit longer than it was last time. And when we go and look on our chainlink node this time, going to use the same credentials to log in and we look at the jobs, there's now three jobs, there's two bridges. So all these changes were just made for us with NPM start. So now what I can do is I can go ahead and run remix, connect to our ganache blockchain.
00:40:03.030 - 00:40:43.060, Speaker B: Want to interact with the delivery link contract at its deployed address. We're getting the Ethereum price in euros this time instead of USD or yen. And we have the ID set up for that. It's six one three. We go over here to jobs, we can scope that out. Going to use the crypto compare adapter. And now let's just take a look there.
00:40:43.060 - 00:41:04.330, Speaker B: Don't need to configure anything for this. This is all then set up. We already have the job ID and then I have the path and the multiplication. You should again be familiar with this job already. I'm not going to talk a year off about that. But let's just prove to ourselves that that value hasn't been set yet. And now we're going to request the price in euros.
00:41:04.330 - 00:41:38.130, Speaker B: We can go to our node, we can see that that job was successful. And now we can go and see that we have the current Ethereum two euro exchange rate. So that's it. Those are the capabilities and the tools that I wanted to show you. I hope that you found that useful. I'm going to stop my screen now, and if there still aren't any questions, then that's all I have. So, yeah, thank you, Rory.
00:41:39.610 - 00:41:40.070, Speaker A: Absolutely.
00:41:40.140 - 00:41:40.486, Speaker B: Thank you.
00:41:40.508 - 00:42:11.794, Speaker A: Yeah, guys, we'll hang around for about another minute or so. If you guys have anything, please feel free to share it, either the QA or the chat. I'll be happy to read it out. Otherwise, as I mentioned before, we'll work to have this posted here in the next day or two on YouTube, and then we'll provide those links as well. So if you guys would like to review it or have any questions, of course, you can certainly ask there as well. But thank you again for joining us, and we look forward to the next one. As always, if you guys have any ideas of things you'd like to see or things you'd like Dan to cover, please feel free to let us know.
00:42:11.794 - 00:42:40.762, Speaker A: And if we can work it into the schedule, then we'll certainly be happy to do so. All right. Well, thank you so much, guys. Again, enjoy your Thanksgiving. For those of you that are there in the states, and we'll probably pretty busy in the chain link team here for next couple of weeks. So I'm assuming maybe mid December we'll try to put on something else for you, but probably definitely pick up full steam again after the new year. And you can see these kind of rolling out every couple of weeks.
00:42:40.762 - 00:42:44.360, Speaker A: But until then, guys, thank you again for joining us and have a great day.
