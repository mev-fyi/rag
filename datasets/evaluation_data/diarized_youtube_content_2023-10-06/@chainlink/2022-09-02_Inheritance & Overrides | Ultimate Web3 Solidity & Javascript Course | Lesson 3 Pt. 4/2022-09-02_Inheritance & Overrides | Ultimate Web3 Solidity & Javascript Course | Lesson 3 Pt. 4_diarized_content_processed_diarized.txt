00:00:10.170 - 00:00:50.750, Speaker A: Now, let's say that we really like the simple storage contract, but it doesn't do everything that we want it to do. Maybe we want it so that whenever we actually store a value, it doesn't store the favorite number, it stores the favorite number plus five. For some reason, you want to contract that everyone's favorite number is five numbers bigger than what they think it is, but you really like everything else that this contract has to offer. Let's create this new contract, and we'll call it extra storage. So we'll say extra storage Sol and we'll create this new contract. We're going to set it up the exact same way we normally would. SPDX license identifier, going to be MIT.
00:00:50.750 - 00:01:44.686, Speaker A: We'll give it Pragma solidity, and we'll just do 0.8.0 with the carrot. And we'll say contract extra storage, like so if you save or compile, you'll get the green check mark. So what could we do? Well, the first thing we could do is we could copy paste all this code back into here and then modify our extra storage contract as we see fit. This seems a little bit redundant and a lot of work, though. So what's another way we could actually get our extra storage contract to be like our simple storage contract? Well, this is where we can do something called inheritance. We can have our extra storage contract be what's called a child contract of our simple storage contract, and we can have extra storage inherit all the functionality of simple storage with two lines of code.
00:01:44.686 - 00:02:29.898, Speaker A: So first, in order for our extra storage contract to know about simple storage, we once again need to import it. So we'll say import simplestorage Sol and we'll say our contract extra storage is simple storage, and we save or compile. Now, our extra storage contract is going to be the exact same as simple storage, and it's going to do what's called inherit all the functionality of simple storage. And we can actually even see that. Let's go ahead and make sure this is compiled. We'll go and deploy this. And now in our deployed contract, we can see we have extra storage deployed with all the functions that simple storage has.
00:02:29.898 - 00:03:18.522, Speaker A: If you want a contract to inherit all the functionality of another contract, you can just import it and say your contract is that other contract. Now we can add additional functions to our extra storage contract that'll include all the functionality of simple storage. Now, let's say that we inherit simple storage to extra storage. However, one of the functions in simple storage, we don't really actually like so if we go back to our simple storage contract, our store function, all it does is take a favorite number and then it assigns the global favorite number to whatever new number that we give it. In our extra storage, we want the store function to do something different. We want it to add five to any number that we give it. How can we achieve this? Well, we can do something called overriding the functions, and there are two keywords that we're going to use.
00:03:18.522 - 00:03:55.378, Speaker A: Those are virtual and override. Right now, if I were to try to implement a store function for extra storage, let's see what happens. We'll say function store un 256 favorite number. It'll be a public function. And let's say instead of just storing favorite number, we'll say favorite number equals favorite number plus five. If we try to compile this right now, we'll actually run into two different errors. First, one is going to say overriding function is missing override specifier.
00:03:55.378 - 00:04:39.174, Speaker A: If the parent contract, which in our case is simple storage, has that same function, we need to tell solidity that we're going to override this store function and instead we're going to use this store function. But additionally, we get this other error saying trying to override nonvirtual function. Did you forget to add virtual? In order for a function to be overridable, you need to add the virtual keyword to the store function. Now it can be overridable. However, if we save and compile, we still have this issue. Overriding function is missing override specifier and then all we need to do is add override to our store function. Now if we save, everything compiles correctly, let's go ahead and deploy this.
00:04:39.174 - 00:05:01.838, Speaker A: Let's delete our old contracts Javascript VM write account great, we're going to choose extra storage. Let's go ahead and deploy. And here's our extra storage contract. Right now if we hit retrieve, we get zero. Previously, our store function would store the exact number. However, if I were to store five, it'll store five plus five. So we should have ten stored here.
00:05:01.838 - 00:05:13.450, Speaker A: Let's go ahead, call store. Looks like that went through and we'll hit retrieve now. And we do indeed see, ten is in here. So this is how we do inheritance and we override functions.
