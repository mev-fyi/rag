00:00:08.810 - 00:00:43.254, Speaker A: Lesson ten, DFI and Ave. Now we're starting to give you industry specific information and understand composability and all these fantastic pieces that really makes the blockchain way different than any other industry you've ever been a part of. So in this lesson, we're going to learn how to work with Aave and learn how to work with these DeFi protocols from our pythonic interface. Learning the tools here can give rise to careers such as being a DeFi quant or DeFi quantitative engineer. So I'll leave it right there. This one is absolutely insane. Best of luck.
00:00:43.254 - 00:01:29.526, Speaker A: I'll see you on the other side that we know a little bit more about DeFi and why it's such an amazing, amazing technology that only works in the blockchain world. Let's look at this site, Defi Pulse. Or if you want to look at another one, there's another fantastic one out there called DeFi llama, which also shows a lot of these different protocols in here. So DeFi Pulse is an application that shows some of the top DeFi projects based on how much total asset is locked into each protocol. Ave, which currently is the number one ranked DFI application with 9.32 billion in assets under management in terms of USD, then we have some fantastic ones like curve compound, Maker, instadap, et cetera. Now, we're going to be looking at two of these protocols in particular.
00:01:29.708 - 00:01:32.254, Speaker B: The first one of course, being Ave.
00:01:32.402 - 00:01:37.658, Speaker A: The second one is going to be a type of what's called a decentralized exchange. To get started with Aave, we're going.
00:01:37.664 - 00:01:43.034, Speaker B: To go to testnet aave.com slash dashboard, and it'll bring us to a screen.
00:01:43.072 - 00:02:16.866, Speaker A: That looks something like this with please connect your wallet and everything will be pretty empty. Parasop is what's known as a Dex or a decentralized exchange. It allows us to trade tokens, incredibly easy on the blockchain. Now, there's not a whole lot of testnet dexs that actually work, so we're just going to look at them and simulate as if we were working on them. For example, if I wanted to trade one ETH for some USDT, or maybe some wrapped bitcoin or some dai or some Ave or link, or really any token that we wanted, all we would need to do is connect our wallet.
00:02:16.898 - 00:02:20.134, Speaker B: Here and a swap button would show.
00:02:20.172 - 00:02:48.798, Speaker A: Up and we would go ahead and hit swap. Some other really powerful these Dexs and really popular ones are going to be curve finance uniswap. And it's a really, really easy way to go ahead and swap your tokens for one another, depending on what you're looking to do. Ave is incredibly powerful, and it's going to be one that we're going to be working a lot with because it has pretty much all the fundamentals of working with the DeFi protocol that we're looking for. And it has a testnet that we can go ahead and test and simulate actually working with some of these protocols.
00:02:48.894 - 00:02:50.306, Speaker B: So we're going to first work with.
00:02:50.328 - 00:03:10.366, Speaker A: The UI or the user interface, and then we're going to do everything here programmatically. First things first, if you don't already have it, make sure you have some testnet Ethereum at least. And again, you can get some testnet ethereum from looking at the link token contracts and going to coven this one. Indeed, the testnet of Ave right now is only on coven, so we're going.
00:03:10.368 - 00:03:12.970, Speaker B: To go ahead here, we're going to.
00:03:13.120 - 00:03:25.390, Speaker A: Copy our address, paste it in, I'm not a robot, send me 0.1 test eth. And remember, use this link token contracts page because this is going to have the most up to date faucets here.
00:03:25.460 - 00:03:27.246, Speaker B: Once we see some eth in our.
00:03:27.268 - 00:04:06.214, Speaker A: Coven testnet here, we can go back to Ave. So whereas paraswap allows you to simply swap between assets and do a lot of buying and selling of tokens, Ave is a lending and borrowing application. So we can actually put down a token as collateral and we can borrow and we can generate some yield from interacting with this protocol. Borrowing and lending is a critical piece to doing any type of really interesting financial applications or financial instruments such as short selling, being exposed to more assets, et cetera. You can also gain some percentage back. If you look at APY, it'll tell you how much percentage over a year you'll actually get in returns from staking.
00:04:06.262 - 00:04:07.958, Speaker B: Or depositing an asset.
00:04:08.134 - 00:04:09.642, Speaker A: So here's what we're going to go ahead and do.
00:04:09.696 - 00:04:12.854, Speaker B: We're going to connect to the application using metamask.
00:04:12.902 - 00:04:24.834, Speaker A: And you'll see on the deposit tab here, we'll see our balance be 0.1 e because that's how much I currently have in my wallet right now. What we can now do is click on Eth here, click this max button.
00:04:24.872 - 00:04:30.222, Speaker B: To deposit some ethereum. We'll hit continue and a little dashboard.
00:04:30.286 - 00:04:42.306, Speaker A: Will pop up asking us, okay, would you like to deposit? Clicking this deposit button will actually have us deposit right onto the Aave contract on the coven testnet. Make sure once you hit deposit here that you're actually on a testnet.
00:04:42.338 - 00:04:42.582, Speaker B: Here.
00:04:42.636 - 00:04:47.154, Speaker A: It looks like I actually have some insufficient funds. So I'm actually going to go borrow.
00:04:47.202 - 00:04:52.362, Speaker B: A little bit more from the faucet here. Grab a little bit more from the faucet here.
00:04:52.496 - 00:05:32.962, Speaker A: We're going to come back, we're actually going to go back. We're going to refresh. And now it says I have 0.1, we're going to deposit 0.1, continue deposit, and metamask is going to pop up saying, hey, are you sure you want to do this right? We can check our data, we can grab this address even if we want, pop it onto Covid Etherscan, paste it in here. We could even double check to make sure that this is indeed the right contract that we want. Funnily enough, you'll see that this is the WEF gateway.
00:05:32.962 - 00:05:43.750, Speaker A: When we deposit our covenant eth, it actually gets transferred into an ERC 20 version of our ethereum and then it'll go ahead and deposit it into the ave contract.
00:05:43.830 - 00:05:45.222, Speaker B: So we're going to hit confirm.
00:05:45.366 - 00:05:57.130, Speaker A: Now we're going to get this pending here. We have a link to the Explorer which shows us this transaction that's going through, and then we'll see that we've indeed successfully deposited our ethereum.
00:05:57.210 - 00:05:58.286, Speaker B: Now down here you'll see a little.
00:05:58.308 - 00:06:00.842, Speaker A: Button add aeth to your browser wallet.
00:06:00.906 - 00:06:01.758, Speaker B: And we're going to go ahead and.
00:06:01.764 - 00:06:10.466, Speaker A: Click this and this will automatically add this token to our wallet. So we're going to hit add token. And we see now in assets we.
00:06:10.488 - 00:06:12.580, Speaker B: Have this aether down here.
00:06:13.350 - 00:06:20.134, Speaker A: We could also have manually hit added token, got the contract address, but Avi was nice enough to just go ahead and add us a little button.
00:06:20.172 - 00:06:21.318, Speaker B: That does it for us.
00:06:21.484 - 00:06:47.518, Speaker A: Aether is what's called an interest bearing token and it goes up in real time. You'll see if I sit here long enough, you'll see this number actually continually going up. This is the profit given to us from other people borrowing the ETH that we've deposited into Ave. If we go to our dashboard now, we can see we have 0.1 ETH deposited and if we roll over it, you'll constantly see the amount go up and up and up.
00:06:47.604 - 00:06:54.170, Speaker B: We can go ahead and withdraw our ETH, which will convert our A ETH.
00:06:54.250 - 00:07:09.682, Speaker A: Back into ETH with the additional interest that we got from depositing. So depositing into Ave will give us interest back as a payment for other people borrowing the ETH that we've deposited. We can also use this eth as what's called collateral. So if I go to this borrow.
00:07:09.746 - 00:07:12.242, Speaker B: Tab, I can actually use the ETH.
00:07:12.306 - 00:07:27.130, Speaker A: To borrow some other asset. Maybe I want to borrow dai, which is a stablecoin meant to always equal $1 USDC, and USDT also are meant to always reflect a dollar. We can borrow what's called wrapped bitcoin, which represents the bitcoin price.
00:07:27.200 - 00:07:30.074, Speaker B: We can borrow some ave token, some.
00:07:30.112 - 00:08:00.230, Speaker A: Bat token, some link token. We can borrow all these different tokens. Now borrowing an asset is incredibly, incredibly powerful. By borrowing, you are allowed to obtain liquidity without selling your assets, and borrowing is one of the first pieces in order to actually short sell. Borrowing in default protocols is absolutely massive because it allows you to frictionlessly short sell obtain liquidity without closing your position gain yield on some deposited collateral. You can do a massive number of new things only in the Defi world.
00:08:00.300 - 00:08:01.890, Speaker B: Such as flash loans.
00:08:02.050 - 00:08:29.194, Speaker A: Now an important note on borrowing assets on main net. Since we're just borrowing it on testnet and this isn't real money, this is 100% okay to experiment with and work with. However, if you borrow an asset and you do not pay attention to how much you have for an underlying collateral, you could get liquidated and lose some of your funds. So be very careful and pay a lot of attention if you're going to do this on an actual network. Now, let's say we want to borrow the ave token.
00:08:29.242 - 00:08:31.166, Speaker B: For example, we click here and we.
00:08:31.188 - 00:08:33.226, Speaker A: Can choose the amount that we want to borrow.
00:08:33.338 - 00:08:34.658, Speaker B: Now here's the thing.
00:08:34.824 - 00:09:06.886, Speaker A: Since we've placed down some collateral, right? 0.1. If the amount that we borrow ends up being too high, we'll actually get what's called liquidated. Every time we borrow an asset, we get some type of health factor. The health factor represents how close to being liquidated you are. Once your health factor reaches one, the collateral that you've actually deposited will get liquidated and somebody else will get paid to take some of your collateral. This is so that the ave application is always solvent. Being solvent means it's never in debt.
00:09:06.886 - 00:09:13.882, Speaker A: So when I want to borrow, I want to choose some amount that might be a little bit safe here and so that I'm not going to get liquidated.
00:09:14.026 - 00:09:16.720, Speaker B: So zoom in a little bit.
00:09:17.650 - 00:09:22.174, Speaker A: I'm going to choose some number where I see a health factor, maybe like 5.6.
00:09:22.292 - 00:09:23.134, Speaker B: We're going to continue.
00:09:23.252 - 00:10:04.214, Speaker A: Now, we'll have to choose our interest rate. When we borrow an asset, we actually have to pay some interest. This payment is actually going to go to the people who are depositing die or depositing the asset. The interest rate that we're going to pay is actually going to be paid to those who are depositing the asset that we're borrowing. So, like how we're getting interest on our deposited collateral, others are getting interest on their deposited collateral based off of how often people are borrowing it. We can choose a stable APY, which will always be 4%, or a variable APY, which will change based off of how volatile and how in demand this asset is. For now, I'm going to choose variable, but you can pick whatever you want, especially for this demo.
00:10:04.352 - 00:10:05.600, Speaker B: We're going to hit continue.
00:10:06.130 - 00:10:10.046, Speaker A: I'm going to zoom out just a little bit, and this same interface is.
00:10:10.068 - 00:10:10.942, Speaker B: Going to show up.
00:10:11.076 - 00:10:18.110, Speaker A: We're going to go ahead and hit borrow. Metamask is going to pop up and ask us if we really want to borrow.
00:10:18.190 - 00:10:20.126, Speaker B: We're going to go ahead and hit confirm.
00:10:20.318 - 00:10:26.434, Speaker A: And now we've successfully borrowed Dai into our application. We can even hit this little add.
00:10:26.472 - 00:10:30.898, Speaker B: Dai to your browser wallet. To add the token to our wallet.
00:10:31.074 - 00:10:52.994, Speaker A: Now, if we hit the button, we go to assets. We can now see die is indeed in our token assets here. Now, if we go back to our dashboard, you'll see we have a health factor score here. This is a really important score. If you click on this little I thing, it says the health factor represents the safety of your loan derived from the proportion of collateral versus amount borrowed.
00:10:53.142 - 00:10:55.706, Speaker B: Keep it above one to avoid liquidation.
00:10:55.898 - 00:11:18.178, Speaker A: And we'll see all of our deposits here. So we still have 0.1 in ETH deposited. We also have 28 die deposited. You can see a whole lot of different stats here for working with our application. We can withdraw our dai, we can withdraw our ETH, we can borrow more dai, or we can go ahead and repay. We can either repay from our wallet balance or from our current collateral.
00:11:18.178 - 00:11:22.726, Speaker A: Yes, we could repay with our collateral. Let's go ahead and do from our.
00:11:22.748 - 00:11:26.806, Speaker B: Wallet balance, we'll hit max, continue, and.
00:11:26.828 - 00:11:35.530, Speaker A: We even get this little thing that says you don't have enough funds to repay the full amount. Well, why is this the case? We just borrowed this amount. It's because already since depositing.
00:11:37.870 - 00:11:38.694, Speaker B: We'Ve accrued.
00:11:38.742 - 00:11:48.346, Speaker A: A little bit of extra debt. Remember, we hit that variable APY, and every second it's going to tick up just a little bit. So let's go ahead and pay back what we can with our wallet.
00:11:48.458 - 00:11:50.494, Speaker B: We're going to confirm, we're going to.
00:11:50.532 - 00:11:53.486, Speaker A: Approve our die to be spent, and then we're going to go ahead and.
00:11:53.508 - 00:11:55.566, Speaker B: Hit the repay button and. Great.
00:11:55.668 - 00:12:05.086, Speaker A: Now if we go back to our dashboard, you can see we've repaid almost everything here, but we have a little bit left. So let's just go ahead, hit repay with our current collateral.
00:12:05.198 - 00:12:08.274, Speaker B: We'll hit Max, continue, and this will.
00:12:08.312 - 00:12:10.338, Speaker A: Use our ETH to pay back the.
00:12:10.344 - 00:12:16.742, Speaker B: Collateral instead of the die, and then we'll hit repay. This way we'll have no more debt. Great.
00:12:16.796 - 00:12:34.094, Speaker A: Now if we go back to our dashboard, we can see we have no more debt, which is fantastic. Ave is one of these applications that relies on the Chainlink price feeds in order to understand the ratio between how much you have deposited as collateral and then how much you can borrow and take out. If we look in our wallet now, we can see we still have some.
00:12:34.132 - 00:12:37.086, Speaker B: Aeth, we also have some ETH, and.
00:12:37.108 - 00:12:41.598, Speaker A: Now we have zero die because everything's paid back. But we're still gaining interest on the.
00:12:41.604 - 00:12:42.902, Speaker B: ETH we have deposited.
00:12:43.066 - 00:12:44.850, Speaker A: Let's go ahead, just reconnect.
00:12:45.430 - 00:12:48.820, Speaker B: Let's go ahead back to Testnet, ave.com.
00:12:49.750 - 00:12:52.530, Speaker A: And let's just withdraw all of our ETH.
00:12:56.510 - 00:12:58.506, Speaker B: Now, keep in mind we're working with some of this.
00:12:58.608 - 00:13:13.714, Speaker A: This is a testnet, right? And working the way we're working right now is just on a testnet. So sometimes the testnet doesn't work quite as well as a main net because it's just for testing and doesn't have the exact same support. We were just working on the testnet. But if you want to go to.
00:13:13.832 - 00:13:16.546, Speaker B: Ave for real, you can go to.
00:13:16.568 - 00:13:20.146, Speaker A: App ave.com, connect your wallet on the.
00:13:20.168 - 00:13:23.346, Speaker B: Ethereum main net, connect your wallet, move.
00:13:23.368 - 00:13:49.622, Speaker A: To the Ethereum mainnet, and interact with it exactly the way we just saw. Now, if we're on the main net here, we can see some additional pieces. When you deposit something like die, yes, you get 2.3% back as interest paid to you for depositing the die. You also get a little bit of what's called a governance token. You also get a little bit of AAve token. I know it's really small here, but this is an additional incentive that Aave has given the users for working with their protocol.
00:13:49.622 - 00:14:41.162, Speaker A: Since Ave is a decentralized protocol, in order for anything to be improved or anything to be updated on the protocol, it actually has to go through a decentralized vote. So these governance tokens actually dictate and decide how the protocol improves. Moving forward. Now that we understand how to work with all of that through the UI, let's actually learn how to interact with AAVE and interact with Defi all from our scripts, learning how to do it. This way will get us one step closer to being a quantitative defi engineer or defi researcher. This is someone who programmatically does algorithmic trades, algorithmic modeling, and just does everything in a programmatic sense, making them much more efficient and powerful. Interacting with Defi now, all the code that we're going to be working with here, it's in this Ave brownie pie application and you can always refer back to it in the link, in the description or in the link in the GitHub repository and see all the code written yourself.
00:14:41.162 - 00:14:51.994, Speaker A: So with that, create a new folder and open up your vs code to that folder and let's get into it. And Ave has some fantastic documentation that we're going to use as well. Link here is also in the description.
00:14:52.122 - 00:14:55.762, Speaker B: Let's go ahead and start with our.
00:14:55.816 - 00:15:23.530, Speaker A: Basic brownie setup, just with brownie init and we got a new brownie project. We got all our folders in here and we are good to go. Now for working with Brownie, we're actually not going to really be deploying any contracts because all the contracts that we're going to work with are already deployed on chain. All of them are just going to be working right with Aave here. Create a quick readme MD so we can know what we're doing here. Number one, we're going to try to deposit some eth into AAve.
00:15:24.750 - 00:15:30.830, Speaker B: Then we're going to borrow some asset with the Eth collateral.
00:15:32.450 - 00:15:34.206, Speaker A: And then if you wanted to, I.
00:15:34.228 - 00:15:38.270, Speaker B: Challenge you to actually sell that borrowed asset.
00:15:39.890 - 00:15:46.340, Speaker A: This is what's known as short selling, but we're not going to do that here. And then we're just going to repay everything back.
00:15:49.030 - 00:15:49.442, Speaker B: Great.
00:15:49.496 - 00:15:56.214, Speaker A: And this will be the full functionality of working with Aave in this deployed contract. Everything that we're going to learn here will teach you how to work with.
00:15:56.252 - 00:15:59.266, Speaker B: Other contracts as well, such as paraswap.
00:15:59.298 - 00:16:06.754, Speaker A: Or Uniswap or any other type of swapping contract that will allow us to buy and sell. So let's just go ahead and create a script.
00:16:06.802 - 00:16:09.902, Speaker B: We'll call it ave borrow py.
00:16:09.986 - 00:16:22.906, Speaker A: Let's go ahead and create a function called Def main and we'll just do pass for now. The first thing that we need to figure out how to do is deposit some f into ave when we actually deposited our f via the UI.
00:16:23.098 - 00:16:31.806, Speaker B: You can actually see when we call this deposit function. If I hit this deposit button here, odly enough, if we go to this.
00:16:31.828 - 00:16:35.118, Speaker A: Contract address on the coven ether scan.
00:16:35.294 - 00:16:43.426, Speaker B: We'Ll see that this address is actually what's called a WeF gateway. What Ave is doing, like I was.
00:16:43.448 - 00:16:47.090, Speaker A: Saying before, and let's go ahead and actually cancel this for now, reject.
00:16:47.250 - 00:16:49.430, Speaker B: What Ave is actually doing here is.
00:16:49.500 - 00:17:00.506, Speaker A: Swapping our ethereum for weth again, weth is an ERC 20 version of ethereum, and this allows it to easily work with all the other ERc 20s on.
00:17:00.528 - 00:17:06.022, Speaker B: The AVI protocol, like Dai, USDCoin, ampleforth link, et cetera.
00:17:06.166 - 00:17:14.650, Speaker A: So we actually have to do that as well. So the first thing we're going to need to do actually isn't deposit some of our eth.
00:17:14.810 - 00:17:15.806, Speaker B: The first thing we're going to need.
00:17:15.828 - 00:17:21.678, Speaker A: To do is going to swap our eth for weth. So let's even just put this in.
00:17:21.684 - 00:17:32.658, Speaker B: Its own little script. We'll call it get weth py. So we're going to have a function, def main. We're just going to do pass for now, but we're actually going to want.
00:17:32.664 - 00:17:35.498, Speaker A: To use this getweath function in our Ave, borrow py.
00:17:35.614 - 00:17:36.726, Speaker B: So we're going to actually have a.
00:17:36.748 - 00:17:40.390, Speaker A: Main and we're going to have a def getweth.
00:17:41.930 - 00:17:48.282, Speaker B: And our main function is just going to call getweth. So how do we actually convert our.
00:17:48.336 - 00:17:52.886, Speaker A: Ethereum to weth or wrapped ether? We'll even do a little doc string.
00:17:52.918 - 00:17:56.214, Speaker B: Here mince weth by depositing eth.
00:17:56.342 - 00:18:05.434, Speaker A: Now to save gas, we could actually interact with this weth gateway for Aave. But I'm going to teach you guys how to just get weth in general. So we can look up the weth.
00:18:05.482 - 00:18:15.666, Speaker B: Contract ether scan, the weth coven contract ether scan, and we'll see here we have this wrapped ether page and we.
00:18:15.688 - 00:18:18.610, Speaker A: Can go to the contract and we can see that this is indeed verified.
00:18:19.430 - 00:18:41.978, Speaker B: The way ath works is there's a withdraw and deposit. We deposit eth into this contract and it transfers us some weth. So this is the first contract that we actually want to interact with. So we need our script to be able to call this deposit contract. So per usual, the two things that.
00:18:41.984 - 00:18:42.858, Speaker A: We need to do this are going.
00:18:42.864 - 00:18:45.740, Speaker B: To be an ABI and an address.
00:18:46.190 - 00:18:51.482, Speaker A: For this weth contract. I really like just doing Everything directly from the interfaces.
00:18:51.626 - 00:18:56.126, Speaker B: I've already copy pasted the interface into this here.
00:18:56.228 - 00:18:59.546, Speaker A: So we're going to go to Wethinterface Sol and we're just going to copy.
00:18:59.578 - 00:19:05.518, Speaker B: All this right here. So in our interfaces create a new file.
00:19:05.614 - 00:19:23.720, Speaker A: We're going to call it iweth Sol. We're going to paste it in. You can see this has all the exact same functions has our deposit contract symbol name transfer. Pretty much everything you would expect from an ERC 20, plus this extra deposit piece.
00:19:25.050 - 00:19:26.642, Speaker B: We'll call this iweth.
00:19:26.786 - 00:19:33.094, Speaker A: It's a common naming standard to just have I in the name of what your contract is when you're talking about an interface.
00:19:33.222 - 00:19:39.546, Speaker B: So we have an interface now and we also have an address, but again.
00:19:39.648 - 00:19:48.986, Speaker A: This is our address on the COVID network. Since we know ahead of time that we're probably going to be using this on different networks like Mainet and Coven and et cetera, we're actually going to create a new file.
00:19:49.098 - 00:19:50.830, Speaker B: We're going to add our brownie config.
00:19:51.810 - 00:19:53.978, Speaker A: Hopefully this is starting to look a little familiar to you.
00:19:54.004 - 00:19:57.234, Speaker B: Now we're going to go ahead and add our networks in here.
00:19:57.432 - 00:19:59.582, Speaker A: In here we're going to go ahead and add coven.
00:19:59.726 - 00:20:10.390, Speaker B: And in here we're going to write weth Token. And we're going to add this address of the weth token, paste it in here.
00:20:10.540 - 00:20:26.790, Speaker A: While we're in here, we're going to add the rest of our pieces. We're going to add wallets from key, private key. And that's all we really need for now. Speaking of which, we probably are still going to want to test this locally.
00:20:26.950 - 00:20:28.574, Speaker B: Now since we've done some work with.
00:20:28.612 - 00:20:32.606, Speaker A: Testing, we know that for testing we.
00:20:32.628 - 00:20:38.830, Speaker B: Can do our integration tests, integration tests.
00:20:39.650 - 00:20:48.866, Speaker A: On Covid because there's an integration test there. What about our local tests? Well, this is something good that we're thinking about right now.
00:20:48.968 - 00:20:51.986, Speaker B: We know that Aave actually has all.
00:20:52.008 - 00:20:54.882, Speaker A: These same contracts on the main net as well.
00:20:55.016 - 00:20:56.258, Speaker B: And we also know that we're not.
00:20:56.264 - 00:21:16.758, Speaker A: Going to be working with any oracles because of that. We don't actually have to deploy any mocks ourselves. We can if we want to, but we don't have to. What we can do is for our unit tests, we can actually just use the Mainnet fork network and just fork everything that's on the main net into our own local network. So instead of actually using mocks, we'll.
00:21:16.774 - 00:21:18.986, Speaker B: Basically just mock the entire main net.
00:21:19.088 - 00:21:41.010, Speaker A: And one more time, just so that we absolutely have it here, if you're not working with oracles and you don't need to mock responses, we can just go ahead and use a mainnet fork to run our unit tests. If you are using oracles, then it makes a lot more sense to do the development network where you can mock oracles and mock oracle responses. With this in mind, we know that we're going to be doing a lot of our tests on Mainnet fork.
00:21:41.350 - 00:21:46.374, Speaker B: We can go ahead and add a main net fork network here and then.
00:21:46.412 - 00:21:48.386, Speaker A: We can just add the mainnet weth.
00:21:48.418 - 00:21:59.660, Speaker B: Token for Mainnet Fork. So we'll look up weth token Etherscan, weth token Etherscan, and we'll grab this contract address.
00:22:00.750 - 00:22:07.286, Speaker A: Remember absolutely, positively, if you want to double check that the contract address that you're working with is correct, I highly.
00:22:07.318 - 00:22:09.178, Speaker B: Recommend you do so, because if you.
00:22:09.184 - 00:22:14.400, Speaker A: Get it wrong, you could accidentally add some money to a contract address that you don't want.
00:22:15.090 - 00:22:27.086, Speaker B: So we're going to have the mainnet fork address be the weth token address. And in our terminal we can do brownie networks list and see that indeed.
00:22:27.118 - 00:22:30.914, Speaker A: We have a Mainnet fork here that's going to use the Ganache ClI to.
00:22:30.952 - 00:22:32.466, Speaker B: Fork Mainnet for us.
00:22:32.648 - 00:22:46.940, Speaker A: There's a link in the description to refer back to the section where we actually set this up. So now that we have the interface, we know that we can actually compile it down to the ABI. So back in our getweath here, first thing we need to do to make any transaction obviously, is get an account.
00:22:48.270 - 00:22:50.266, Speaker B: Well, this is where we can go.
00:22:50.288 - 00:22:52.090, Speaker A: Back and make our helpful scripts.
00:22:54.590 - 00:22:58.506, Speaker B: So we can go ahead do def get.
00:22:58.528 - 00:23:04.670, Speaker A: Account index equals none, id equals none, same as before.
00:23:04.820 - 00:23:06.238, Speaker B: And if you have your get account.
00:23:06.324 - 00:23:09.694, Speaker A: Function from our last demo, you can just go ahead and copy paste it in here.
00:23:09.812 - 00:23:10.510, Speaker B: All right, great.
00:23:10.580 - 00:23:14.382, Speaker A: Now we have our get account function, so we can do account now equals.
00:23:14.526 - 00:23:28.646, Speaker B: Get account, but we have to import it in here. So we'll do from scripts helpful scripts import get account, and depending on your.
00:23:28.668 - 00:23:33.586, Speaker A: Python version, we'll add an init py just so that python recognizes that scripts.
00:23:33.618 - 00:23:35.414, Speaker B: Is indeed a module. All right, cool.
00:23:35.452 - 00:23:40.554, Speaker A: So we have our account where we can make some transactions with. Now let's go ahead and get our.
00:23:40.592 - 00:23:43.226, Speaker B: Weth contract to do this, we can.
00:23:43.248 - 00:23:47.918, Speaker A: Import interfaces from brownie, from brownie import.
00:23:48.004 - 00:23:51.966, Speaker B: Interface same as we did before, and.
00:23:51.988 - 00:23:59.758, Speaker A: We can do weth equals interface. I weth. And the address here is going to.
00:23:59.764 - 00:24:06.030, Speaker B: Be from our config config networks network.
00:24:06.110 - 00:24:07.250, Speaker A: Show active.
00:24:09.030 - 00:24:12.130, Speaker B: And then west token.
00:24:14.250 - 00:24:20.600, Speaker A: And we also have to import config from brownie and network as well.
00:24:23.130 - 00:24:26.998, Speaker B: Now you might be asking why aren't we using the get contract function here?
00:24:27.164 - 00:24:29.174, Speaker A: Well, you can absolutely 100% go ahead.
00:24:29.212 - 00:24:31.014, Speaker B: And use that get contract function, but.
00:24:31.052 - 00:24:32.026, Speaker A: Since we're going to be testing on.
00:24:32.048 - 00:24:33.958, Speaker B: Mainnet fork here, I know that we're.
00:24:33.974 - 00:24:35.958, Speaker A: Always going to refer back to the config.
00:24:36.054 - 00:24:40.666, Speaker B: So I'm confident that I'm not going to be deploying any mocks. It's better practice to go ahead and.
00:24:40.688 - 00:24:43.358, Speaker A: Use that get contract function. But for this one we'll just make.
00:24:43.364 - 00:24:45.630, Speaker B: It a little simpler and use the config.
00:24:46.130 - 00:24:49.982, Speaker A: And now in a brownie config, if we're on the COVID network we're going to use this one.
00:24:50.116 - 00:24:54.674, Speaker B: If we're on Mainnet or Mainnet fork, we're going to use this one for.
00:24:54.712 - 00:25:02.050, Speaker A: Going to Mainnet or to real production. You could also have a main network and it'll just be an exact copy of the mainnet fork.
00:25:02.710 - 00:25:08.066, Speaker B: And remember we're going to want our env, our env file, our environment variables.
00:25:08.098 - 00:25:13.926, Speaker A: To get pulled from that env file. So we can just set it like this. Now everything in our env file will.
00:25:13.948 - 00:25:15.282, Speaker B: Get pulled in automatically.
00:25:15.426 - 00:25:23.526, Speaker A: Great. So we have an address and we have an ABI which comes from the interface. Now we can just call this deposit.
00:25:23.558 - 00:25:50.238, Speaker B: Function where we deposit ethereum and we get weth. So now we'll just do transaction equals weth deposit and we'll do from account value is going to be, let's just say zero one. So 0.1 times ten raised to the 18.
00:25:50.414 - 00:25:55.262, Speaker A: So we'll deposit zero one and we should get zero one weth.
00:25:55.326 - 00:25:57.750, Speaker B: In return do a print f string.
00:26:00.410 - 00:26:08.610, Speaker A: Received 0.1 weth. This doesn't even need to be printf and then we'll just return TX.
00:26:08.770 - 00:26:12.374, Speaker B: Now per usual, if your environment variables.
00:26:12.422 - 00:26:20.606, Speaker A: Aren'T set, such as private key, we're going to want to do that. So in our env we're going to do export private key equals zero x.
00:26:20.628 - 00:26:22.558, Speaker B: At the beginning right here we're going.
00:26:22.564 - 00:26:48.146, Speaker A: To export web3 infura project id. We'll want to add our web3 infura project id, which we've got before. If we want to use our etherscan token we absolutely can. And since we're putting a whole bunch of stuff in the env, we want to make sure in our git ignore we have env. So we don't actually push this up to GitHub. Again, if you're nervous about having all.
00:26:48.168 - 00:26:50.342, Speaker B: These envs in here, you can absolutely.
00:26:50.396 - 00:26:56.522, Speaker A: Do the accounts add or whatever other methodology you like to set your environment variables. Anyway, let's go ahead and run this.
00:26:56.576 - 00:27:04.566, Speaker B: Script now so we can do brownie, run scripts, get wet Py network coven.
00:27:04.758 - 00:27:10.880, Speaker A: Generating the APIs from our interface and we have a little transaction hash that we can use.
00:27:11.250 - 00:27:26.450, Speaker B: Pop into the coven ether scan and we can see the transaction going through in our wallets, we'll get minus zero one eth and we'll get plus zero one west. We can see it's actually been successful.
00:27:27.030 - 00:27:32.894, Speaker A: To add this and see this on our metamask. We're going to grab the contract address here. We're going to go back to metamask.
00:27:33.022 - 00:27:35.762, Speaker B: Add token, paste it in here, add.
00:27:35.816 - 00:27:44.454, Speaker A: Tokens, and you can see we now have 0.1 weth. If you want to switch back your weth to ethereum, you would just hit this withdraw function.
00:27:44.572 - 00:27:48.418, Speaker B: Or we could programmatically add a withdrawal function in here.
00:27:48.524 - 00:28:00.538, Speaker A: This withdrawal function will withdraw our ethereum, withdraw and take our ethereum out of the contract and burn the weth and replace it with weth. So you need to swap your weth back to get your eth out.
00:28:00.624 - 00:28:01.018, Speaker B: Awesome.
00:28:01.104 - 00:28:19.140, Speaker A: We have some weth and now we have an ERC 20 token. We have an ERC 20 token that we can use to interact with the ave application. Now that we've got this getweth function, let's go ahead and start borrowing. So let's go ahead and start with our account. It's going to equal to get account.
00:28:19.750 - 00:28:23.460, Speaker B: Which now we're going to want to import right at the top, like so.
00:28:23.910 - 00:28:26.274, Speaker A: Then we're going to get our weth address.
00:28:26.472 - 00:28:27.638, Speaker B: Or we can even just do our.
00:28:27.644 - 00:28:41.210, Speaker A: ERC 20 address because the weth token is an ERC 20 and maybe we want to deposit some other ERC 20. We'll do config networks network showactive.
00:28:43.550 - 00:28:47.306, Speaker B: Weth token. And of course we're going to have.
00:28:47.328 - 00:28:49.230, Speaker A: To now add from Brownie.
00:28:51.330 - 00:28:53.450, Speaker B: Import network.
00:28:53.610 - 00:28:58.346, Speaker A: And now we'd want to call this getweth contract just in case we don't.
00:28:58.378 - 00:29:08.866, Speaker B: Already have weth, we would just add another from scripts getweth import getweth. But we don't actually need to call.
00:29:08.888 - 00:29:13.474, Speaker A: It right now because we already have some wrapped ethereum in our coven address.
00:29:13.592 - 00:29:14.806, Speaker B: Now if we want to test this.
00:29:14.828 - 00:29:20.854, Speaker A: Though, on our local Mainnet fork, we probably will want to call this getweth. So I'm just going to add a little.
00:29:20.892 - 00:29:21.480, Speaker B: If.
00:29:23.210 - 00:29:28.810, Speaker A: Network showactive is going to be our main net fork.
00:29:33.310 - 00:29:33.946, Speaker B: We should go.
00:29:33.968 - 00:29:36.282, Speaker A: Ahead and call this getweath function.
00:29:36.416 - 00:29:37.818, Speaker B: And for Brownie we're also going to.
00:29:37.824 - 00:29:38.934, Speaker A: Want to import this config.
00:29:38.982 - 00:29:44.430, Speaker B: We'll also have to add Mainnet fork to our local blockchain environments.
00:29:47.620 - 00:29:48.610, Speaker A: Like so.
00:29:49.620 - 00:29:51.680, Speaker B: So that when we call get account.
00:29:51.750 - 00:29:56.848, Speaker A: In our scripts, it actually knows that it's a local environment that we're working with and it will just return account.
00:29:56.934 - 00:29:58.944, Speaker B: Zero instead of us having to actually.
00:29:58.982 - 00:30:10.344, Speaker A: Load a private key in every single time and we want to actually wait for our transaction to complete here. So we'll go ahead and add this, wait and then do TX, wait and wait for this transaction to actually finish.
00:30:10.382 - 00:30:19.300, Speaker B: Otherwise Brownie will get it a little bit mad. So now that we have that, we can run Brownie, run scripts, ave, borrow.
00:30:19.380 - 00:30:35.964, Speaker A: PI network, Mainnet Fork. So you can see that actually in this case, testing everything on Mainnet fork is going to give us a really, really accurate view of what doing this on Mainnet actually is going to give us. We don't have to do any mocking. We can literally just fork all of.
00:30:36.002 - 00:30:37.532, Speaker B: Mainnet and go from there.
00:30:37.586 - 00:30:57.184, Speaker A: We are still going to test on coven though, in a little bit, just so we can see all the transactions that go through, how long it takes for stuff to happen. So now that we've gotten some weth here, we actually need to go into our second bit. We're going to deposit some f or in our case some weth into Ave.
00:30:57.312 - 00:30:58.840, Speaker B: So how do we actually do that?
00:30:58.990 - 00:31:00.808, Speaker A: Well, everything that we need is going.
00:31:00.814 - 00:31:04.552, Speaker B: To be in this ave documentation here.
00:31:04.686 - 00:31:24.572, Speaker A: Where we deposit and borrow from in Ave is in their contract. This lending pool you can see here, the lending pool contract is the main contract for the protocol. It exposes the user oriented actions that can be invoked in solidity in web3 libraries. And these have all of the functions that we need. It has deposit where we deposit our asset as a collateral, withdraw where we take it back.
00:31:24.706 - 00:31:27.984, Speaker B: We have borrow, we have repay and.
00:31:28.102 - 00:31:34.016, Speaker A: We have swap, borrow rate and a couple other interesting ones which we'll go into later. But for now we just really need.
00:31:34.038 - 00:31:39.708, Speaker B: To focus on repaying, borrowing, withdrawing and depositing.
00:31:39.884 - 00:31:48.356, Speaker A: So as you probably guessed, deposit is the function that we're going to work on right now. And since this is the contract that we're going to work with, as always, the two things you need when working.
00:31:48.378 - 00:31:49.636, Speaker B: With a contract are going to be.
00:31:49.658 - 00:31:53.924, Speaker A: The ABI and the address. So we're going to get this lending pool contract.
00:31:53.972 - 00:31:57.444, Speaker B: We're going to say lending pool equals.
00:31:57.492 - 00:31:58.616, Speaker A: And we're actually going to even make.
00:31:58.638 - 00:32:02.300, Speaker B: A function called get lending pool.
00:32:04.080 - 00:32:08.140, Speaker A: So down below we're going to do def get lending pool.
00:32:10.320 - 00:32:12.536, Speaker B: Lending pool, not poll.
00:32:12.648 - 00:32:24.288, Speaker A: And we're going to get the lending pool address in the lending pool contract so we can interact with it down here. Now, something about this lending pool is that the lending pool address can actually change a little bit depending on a.
00:32:24.294 - 00:32:25.404, Speaker B: Lot of different pieces.
00:32:25.532 - 00:32:42.184, Speaker A: So there's actually this address provider which gives us the address of a specific or particular market. If we go back to this ave UI, there's actually different markets. So there's different types of ways we can interact with Ave. We're just going to work with the basic Ave v two because it's easily the most used.
00:32:42.222 - 00:32:43.320, Speaker B: On main net as well.
00:32:43.390 - 00:33:02.460, Speaker A: The address provider registry will give us, so this address provider will give us the address of the lending pool for our market. If we want to go across different markets, we'll have to go to the address provider registry to find it. But the addresses in here don't change and the addresses in here don't change. It's just the lending pool address itself might change. So we just have to go to.
00:33:02.610 - 00:33:04.444, Speaker B: This address provider here.
00:33:04.562 - 00:33:23.060, Speaker A: And there's just one function that we need to work with. It's this get lending pool, which will give us the address of the actual lending pool. So don't let this confuse you too much. Basically all we're trying to do is we're saying, hey, where is Ave located right now? And Ave has a contract that will always tell us where the main ave contracts are.
00:33:23.130 - 00:33:25.412, Speaker B: And that's this addresses provider right here.
00:33:25.466 - 00:33:29.764, Speaker A: So this is another contract that we have to work with. And again, when we have a contract.
00:33:29.812 - 00:33:33.400, Speaker B: What do we need? We need an ABI and we need.
00:33:33.470 - 00:33:56.544, Speaker A: An address so we can absolutely, once again, we could go ahead and copy paste like Abi equals whatever the ABI is. But we're just going to use an interface because life is great with an interface. So a couple of great things about interfaces too. If we know we're only going to work with one or two functions, we can actually just make the interfaces ourself. So an interface, we could do new.
00:33:56.582 - 00:34:13.472, Speaker B: File, we could do I lending pool addressprovider Sol and we could just add it in here ourselves. So we'll first do SPDX license identifier.
00:34:13.616 - 00:34:22.170, Speaker A: And then we'll do like MIT or something. We'll do pragma solidity 0.6.6 or whatever we want to do.
00:34:22.860 - 00:34:38.140, Speaker B: And then we'll do interface I lending pool addresses provider. Excuse me, this should be lending pool addresses provider.
00:34:39.280 - 00:34:40.716, Speaker A: And we know that there's only one.
00:34:40.738 - 00:34:45.020, Speaker B: Function called get lending pool.
00:34:45.760 - 00:34:50.032, Speaker A: And we're not exactly sure what Getlending pool is defined as.
00:34:50.086 - 00:34:58.828, Speaker B: But what we can do is we can go to Etherscan, Etherscan Ave lending pool addresses.
00:34:59.004 - 00:35:05.600, Speaker A: You can see here, this is actually the lending pool. But what we can look at is the Ave protocol. We can go right to their GitHub.
00:35:05.680 - 00:35:08.504, Speaker B: We can go to contracts we can.
00:35:08.542 - 00:35:10.920, Speaker A: See they have an interfaces section.
00:35:12.780 - 00:35:13.096, Speaker B: And.
00:35:13.118 - 00:35:16.148, Speaker A: They have this lending pool addresses provider.
00:35:16.324 - 00:35:17.316, Speaker B: Get lending pool.
00:35:17.348 - 00:35:22.356, Speaker A: And kind of as we expected, it's an external view and it returns an address. So we can literally just copy paste.
00:35:22.388 - 00:35:24.936, Speaker B: This into here and we could run.
00:35:24.958 - 00:35:30.236, Speaker A: With this and this would work perfectly fine. But this leads us to the next point. We might as well just grab the.
00:35:30.258 - 00:35:32.268, Speaker B: Whole thing this way we know for.
00:35:32.274 - 00:35:33.804, Speaker A: A fact we're not getting anything wrong.
00:35:33.922 - 00:35:38.512, Speaker B: But yes, if we wanted to, our interface could be this, right?
00:35:38.566 - 00:35:40.416, Speaker A: Because this is going to compile could.
00:35:40.438 - 00:35:42.848, Speaker B: Be this, because this interface is going.
00:35:42.854 - 00:35:50.596, Speaker A: To compile down to an ABI. And the ABI is going to say, hey, there's a function here. And that's all the ABI is really doing. It's just telling us how we can.
00:35:50.618 - 00:35:52.464, Speaker B: Interact with a contract.
00:35:52.592 - 00:36:07.492, Speaker A: But let's just go ahead and add everything so that if we want to interact with more things, we can. So now we have the ABI. We also now need an address, which we can definitely find from the Ave documentation. We can go to their deployed contract section.
00:36:07.556 - 00:36:14.030, Speaker B: We can find lending pool addresses provider, which is going to be right here. We're going to copy that.
00:36:15.280 - 00:36:19.448, Speaker A: And where are we going to put this? Well, as you know, we're going to put this in our brownie config.
00:36:19.544 - 00:36:27.904, Speaker B: We're going to do lending pool addresses provider. We're going to paste that right there.
00:36:28.022 - 00:36:29.728, Speaker A: And since we know we're also going.
00:36:29.734 - 00:36:43.156, Speaker B: To do Covid, we can also grab from Coven here. So lending pool addresses provider. We're going to copy this here and.
00:36:43.178 - 00:36:45.488, Speaker A: We'Re going to add this addresses provider.
00:36:45.584 - 00:36:48.496, Speaker B: For coven as well. Boom.
00:36:48.608 - 00:36:50.224, Speaker A: Now we have it for both Coven.
00:36:50.352 - 00:36:54.344, Speaker B: And for Mainnet Fork. Awesome. So we can keep going now.
00:36:54.382 - 00:37:12.184, Speaker A: Now that we have an ABI and we have an address for both Coven and for our main net mainnet fork, what we can do now is we first get the lending pool addresses provider. It's going to be from our interface.
00:37:12.312 - 00:37:26.084, Speaker B: Which again, we're going to grab from brownie Interface. I lending pool addresses provider, which the.
00:37:26.122 - 00:37:27.364, Speaker A: Address of that is going to be.
00:37:27.402 - 00:37:43.620, Speaker B: Config networks network showactive lending pool addresses provider.
00:37:43.780 - 00:37:45.784, Speaker A: And then we're just going to say.
00:37:45.982 - 00:37:52.220, Speaker B: Lending pool address is going to be equal to lending pool.
00:37:52.720 - 00:37:55.484, Speaker A: I'm just going to copy and paste instead of typing the whole thing.
00:37:55.602 - 00:38:09.344, Speaker B: Addressesdividor provider get lending pool. Right, because again, this address provider has this get lending pool, which returns this.
00:38:09.382 - 00:38:15.484, Speaker A: Address, which is the address of the lending pool. Then now that we have this address, we can actually return the lending pool.
00:38:15.532 - 00:38:24.224, Speaker B: Contract by once again getting the ABI and the address of the actual lending pool.
00:38:24.352 - 00:38:27.364, Speaker A: So we have the address check.
00:38:27.562 - 00:38:29.812, Speaker B: We just now need the API, which.
00:38:29.866 - 00:38:31.572, Speaker A: Once again we can work with our.
00:38:31.626 - 00:38:38.808, Speaker B: Wonderful interfaces here, do new file I lending pool and there's only going to.
00:38:38.814 - 00:38:48.316, Speaker A: Be a couple of functions we're going to work with here. But Ave actually gives us the interface right here. And Ave actually even gives us the interface of the lending pool address provider for us.
00:38:48.338 - 00:38:51.596, Speaker B: So we can go ahead and copy this, pop it over into here.
00:38:51.698 - 00:39:15.300, Speaker A: Now we do need to actually change one thing in here as well. This interface imports locally with this dot slash. So we actually just need to change these imports to actually import directly from GitHub instead of importing locally. Luckily this is something we already know how to do. So let's go to our brownie config, and up at the top we're going to add this dependencies bit in dependencies.
00:39:17.240 - 00:39:33.690, Speaker B: So we're just going to work with Ave's protocol right from GitHub. So we're going to work with Ave protocol v two and let's see what their latest version is.
00:39:34.140 - 00:39:35.220, Speaker A: Looks like they got a couple of.
00:39:35.230 - 00:39:55.568, Speaker B: Different versions here, 1.0.1. So let's go ahead and work with this one at 1.0.1 and then with compiler sulk remappings per usual we're going to say at Ave is going to.
00:39:55.574 - 00:39:57.200, Speaker A: Be equal to this dependency.
00:39:58.500 - 00:40:00.832, Speaker B: This way Brownie will download this right from GitHub.
00:40:00.896 - 00:40:04.230, Speaker A: And now we can just use this at Aave instead.
00:40:04.680 - 00:40:38.688, Speaker B: So back in our ilendingpool Sol, we can just change this to poll right from GitHub. And if we look in GitHub, we go to their contract section, we go to their interfaces section. Ilending pool we know that we can pull this from atavecontractsinterfaces because we see this ilending pool addresses provider right in here. And then this data types bit, you.
00:40:38.694 - 00:40:43.312, Speaker A: Can actually look in contracts and this I know because I've been through already.
00:40:43.366 - 00:40:50.676, Speaker B: It'S in protocol libraries types and here.
00:40:50.698 - 00:40:53.332, Speaker A: It is, data type sol. So we can just take this exact.
00:40:53.386 - 00:40:57.860, Speaker B: Path again and do atavecontracts.
00:40:59.080 - 00:41:13.224, Speaker A: Protocollibrariestypesdatype sol okay, great. So now that we've actually imported this interface for us to use, we can go ahead and compile just to make sure that everything is working correctly.
00:41:13.352 - 00:41:18.806, Speaker B: Brownie compile and perfect.
00:41:18.908 - 00:41:24.978, Speaker A: If these interfaces had an issue, they actually wouldn't compile through brownie here. So we know that they're compiling correctly.
00:41:25.074 - 00:41:26.646, Speaker B: But great so now that we have.
00:41:26.668 - 00:41:35.446, Speaker A: An interface, we know that these interfaces compile down to the ABI and we already have the address here. So to actually interact with the lending.
00:41:35.478 - 00:41:56.514, Speaker B: Pool, now we can just do lending pool equals interface I lending pool and we'll add this lending pool address lending pool, and then we can return lending pool. So now we have a function that.
00:41:56.552 - 00:42:03.990, Speaker A: Goes through the lending pool addresses provider from the ave documentation and returns this lending pool contract that we can now interact with.
00:42:04.060 - 00:42:21.334, Speaker B: And we can even test this out by just printing this lending pool address in our script. So we'll do brownie, run scripts, ave borrow network, mainnet fork and. Perfect.
00:42:21.532 - 00:42:31.982, Speaker A: We can see the address here is printed out and there are no errors. So we know we're doing it right. So now that we have the actual address, what we're going to do now is we're going to take this wrapped Ethereum that we've got this ERC 20.
00:42:32.036 - 00:42:33.982, Speaker B: Version of Ethereum and we're going to.
00:42:34.036 - 00:42:36.894, Speaker A: Deposit it into this contract just like.
00:42:36.932 - 00:42:39.386, Speaker B: What we did in the user interface.
00:42:39.498 - 00:42:58.178, Speaker A: In order to actually first deposit it, we need to approve this ERC 20 token. ERC 20 tokens have an approve function that makes sure that whenever we send a token to somebody, or whenever a token calls a function that uses our tokens, we actually have given them permission to do so. So that's the first thing that we're.
00:42:58.194 - 00:43:02.434, Speaker B: Going to actually have to do is we're going to have to approve sending.
00:43:02.482 - 00:43:09.674, Speaker A: Our ERC 20 tokens. And this resembles. So since I know that we're going to have to approve a lot, I'm actually just going to go ahead and.
00:43:09.712 - 00:43:14.810, Speaker B: Make an approve ERC 20 token function.
00:43:14.960 - 00:43:16.666, Speaker A: Similar as to what we did with.
00:43:16.688 - 00:43:18.250, Speaker B: The get lending pool.
00:43:18.590 - 00:43:21.146, Speaker A: So we're going to need to approve this ERC 20.
00:43:21.248 - 00:43:28.638, Speaker B: So we're going to need to approve this ERC 20. So let's go ahead and make a function. We'll call it def approve ERC 20.
00:43:28.724 - 00:43:30.014, Speaker A: So how do we actually call this.
00:43:30.052 - 00:43:39.070, Speaker B: Approve function on a token contract? Well, as always, we're going to need the ABI and the address of the token contract.
00:43:39.230 - 00:43:40.978, Speaker A: Same as always. I told you I was going to.
00:43:40.984 - 00:43:41.858, Speaker B: Be saying this a lot.
00:43:41.944 - 00:43:52.662, Speaker A: Now we could create our interface ourself looking at all the functionalities of the ERC 20 tokens. So we could go to eip 20, look at the token standard, find all.
00:43:52.716 - 00:43:56.322, Speaker B: The different functions and put them into our interface.
00:43:56.466 - 00:44:05.562, Speaker A: Or we can go ahead and just cheat and just grab it from my GitHub repository here. So I already have an IERC 20 sol right here.
00:44:05.696 - 00:44:13.398, Speaker B: And we're just going to copy everything in here and add it in a new file called IERC 20 sol and.
00:44:13.424 - 00:44:15.278, Speaker A: Paste it in here. So you can see there are a.
00:44:15.284 - 00:44:22.606, Speaker B: Number of different functions in here. We can check the allowance, we can check the balance of different addresses, how.
00:44:22.628 - 00:44:33.730, Speaker A: Many decimals a token has, the name, the symbol we can do some transfers and transfer from. And then the function that we're going to be using is this approve function. So right here we can already see.
00:44:33.880 - 00:44:38.486, Speaker B: The parameters this approve function takes. We're going to need to have a.
00:44:38.508 - 00:44:44.454, Speaker A: Spender of who to approve can spend our tokens and then how much they can actually spend.
00:44:44.572 - 00:45:03.134, Speaker B: So if we come back over to approve ERC 20, we know that for input parameters we're probably going to need an amount, a spender address, the ERC 20 token address. So which token we're actually allowing to spend and then an account, right?
00:45:03.172 - 00:45:05.040, Speaker A: Or this is going to be that from.
00:45:07.170 - 00:45:08.270, Speaker B: Account bit.
00:45:08.420 - 00:45:11.798, Speaker A: So we'll just have this be passed as part of the function parameters.
00:45:11.914 - 00:45:24.246, Speaker B: So let's go ahead and code this. Let's first just do a quick print line so that people know what this transaction is doing. We'll say approving ERC 20 token, and.
00:45:24.268 - 00:45:26.098, Speaker A: Then we'll get the ERC 20 token.
00:45:26.194 - 00:45:35.666, Speaker B: By saying ERC equals interface, same as always I ERC 20. And then we'll give it whatever ERC.
00:45:35.698 - 00:45:40.026, Speaker A: 20 address that we pass to this function. And now we can actually interact with.
00:45:40.048 - 00:46:01.518, Speaker B: This contract and we can call that approve function. So we'll say transaction tx or again, TX usually stands for transaction equals ERC 20 approve. And we're going to approve this spender for an amount. And then we'll say from account we'll.
00:46:01.534 - 00:46:05.490, Speaker A: Do a tx wait. We'll wait one block confirmation for it to finish.
00:46:05.640 - 00:46:13.794, Speaker B: And then once it's done we'll do print approved and we'll return the transaction. Awesome.
00:46:13.912 - 00:46:19.650, Speaker A: So now we have an approve ERC 20 function that we can use to approve any ERC 20 token.
00:46:19.730 - 00:46:23.814, Speaker B: So back up in our main function we can run approve ERC 20 for.
00:46:23.852 - 00:46:48.446, Speaker A: Some amount which right now we don't have defined. The spender is going to be this lending pool, but the address of the lending pool. Because remember, lending pool is the entire contract. We just want the address. The ERC 20 address of course is going to be the ERC 20 address. And the account of course is going to be our account. The only thing we don't have defined right now is some amount, which we can make it really whatever we want.
00:46:48.468 - 00:46:49.998, Speaker B: To be to keep things standard.
00:46:50.084 - 00:46:52.446, Speaker A: Let's just go ahead and do 0.1.
00:46:52.548 - 00:47:03.426, Speaker B: So I'm going to make this a global variable. Say amount equals 112-34-5678 910, 123-4567 and.
00:47:03.448 - 00:47:06.146, Speaker A: We can go ahead and do amount.
00:47:06.328 - 00:47:07.654, Speaker B: We're going to of course web3.
00:47:07.692 - 00:47:19.738, Speaker A: All these zeros incredibly disgusting. So we're just going to refactor to do from web3 import web3 then instead of always. And we'll just do web3 two way 0.1 ether 0.1 which is the.
00:47:19.744 - 00:47:31.786, Speaker B: Amount that we actually want and we'll say ether. Now we can run Brownie, run scripts, ave borrowed a Py network main net fork and we can go ahead and.
00:47:31.808 - 00:47:46.562, Speaker A: See that our approval function is working as intended. Network that will always doing this fine. Whenever we run any type of forklide can get a little annoying. We can do. So let's go ahead and change our default network to mainnet fork Mainnet. So we don't have any network in our browning. Let's go back to our ave borrowing section now.
00:47:46.616 - 00:47:50.274, Speaker B: So we have everything approved. Now we just need to go ahead.
00:47:50.312 - 00:47:52.530, Speaker A: And deposit it into aave.
00:47:53.270 - 00:47:54.786, Speaker B: Since we know we're probably going to.
00:47:54.808 - 00:47:55.634, Speaker A: Use this a lot too.
00:47:55.672 - 00:47:58.486, Speaker B: Let's go ahead and create a deposit function.
00:47:58.588 - 00:48:09.362, Speaker A: Since we have everything approved, we can now go ahead and use the lending pool deposit method and we can check the documentation here or look on GitHub or etherscan to see what the parameters.
00:48:09.426 - 00:48:10.282, Speaker B: That it takes are.
00:48:10.336 - 00:48:11.626, Speaker A: So I'm even just going to go.
00:48:11.648 - 00:48:24.846, Speaker B: Ahead and copy all this, bring it over here. So what we can do now is we can do lending pool deposit and.
00:48:24.868 - 00:48:26.638, Speaker A: Then all these parameters, let's go ahead.
00:48:26.644 - 00:48:28.110, Speaker B: And walk through them one by one.
00:48:28.260 - 00:48:31.406, Speaker A: So first thing is going to be the address of the asset, which we.
00:48:31.428 - 00:48:44.198, Speaker B: Know is going to be our ERC 20 address. Boom. The amount of the token which we can go ahead with our amount variable address on behalf of is just going.
00:48:44.204 - 00:48:46.038, Speaker A: To be our account address.
00:48:46.204 - 00:48:54.386, Speaker B: We're depositing this collateral for ourselves and then referral code. So referral code is, so the referral.
00:48:54.418 - 00:49:01.194, Speaker A: Code is actually deprecated and fur codes don't actually work anymore. So we're just always going to pass zero here. And just to make sure we know.
00:49:01.232 - 00:49:13.454, Speaker B: That this is what we're doing, we're going to go ahead and print depositing. One, two, three. And then after we're done, we're going to do print deposit and whoops, looks.
00:49:13.492 - 00:49:14.862, Speaker A: Like we forgot to add that final.
00:49:14.916 - 00:49:22.910, Speaker B: Dictionary here of from account. Ah, one more thing here.
00:49:22.980 - 00:49:24.594, Speaker A: Let's go ahead and do TX for.
00:49:24.632 - 00:49:27.470, Speaker B: Transaction equals lending pool deposit.
00:49:27.550 - 00:49:31.774, Speaker A: And we're going to go ahead and once again we're gonna wait for one block confirmation.
00:49:31.902 - 00:49:43.654, Speaker B: Wait one transactions still being processed. So now if we run Brownie, run scripts, ave borrow Py, we can see that this actually went through fine.
00:49:43.852 - 00:49:56.374, Speaker A: All right, now that we have some collateral deposited, we can go ahead and actually take out a borrow, we can go ahead and borrow some other asset. The question is going to be how much? How much can we actually borrow?
00:49:56.502 - 00:49:58.166, Speaker B: How much should we borrow?
00:49:58.358 - 00:50:03.854, Speaker A: What would result in a positive health factor? Well, maybe we should actually pull off.
00:50:03.892 - 00:50:05.658, Speaker B: Chain some of our stats.
00:50:05.754 - 00:50:07.530, Speaker A: How much do we actually have deposited.
00:50:07.690 - 00:50:09.902, Speaker B: How much collateral we have, how much.
00:50:09.956 - 00:50:18.190, Speaker A: Debt we have, and so on and so forth. That way in the future, when we don't start clean, we can take some inventory of where we stand with our collateral and our debts.
00:50:18.270 - 00:50:27.038, Speaker B: At the Aave documentation, we can go ahead and see this function called getuser account data. This is going to return the user.
00:50:27.054 - 00:50:29.138, Speaker A: Account data across all reserves.
00:50:29.234 - 00:50:30.502, Speaker B: So it's going to get the total.
00:50:30.556 - 00:51:18.662, Speaker A: Collateral that we've deposited in terms of Ethereum, it's going to get our total debt in terms of Ethereum, how much we can borrow, the borrowing power that we have, the liquidation threshold, or how close to that liquidation threshold will be, the loan to value ratio. And again, this health factor, this health factor is obviously incredibly important, because if it drops below one or reaches one, users can call this liquidation call. Now, this function returns all these variables, but for now, we really only care about how much collateral we have, how much debt we have, and how much we're available to borrow. So let's go ahead and write a function that will actually sort that out for us. We'll call it get borrowable data. Borrowable data. So let's go ahead and create this.
00:51:18.796 - 00:51:24.198, Speaker B: Def get borrowable data, and we're going.
00:51:24.204 - 00:51:30.234, Speaker A: To pass in the lending pool as a first parameter and then the account as a second parameter, because we're looking.
00:51:30.272 - 00:51:32.326, Speaker B: To call this function on the lending.
00:51:32.358 - 00:51:35.370, Speaker A: Pool from an account. So let's go ahead and just call that function.
00:51:35.440 - 00:51:38.726, Speaker B: So we'll do lending pool, get user.
00:51:38.758 - 00:51:42.910, Speaker A: Account data, and we'll pass in account address.
00:51:43.060 - 00:51:49.694, Speaker B: Because if we look at the API again, all that it needs is a user's address to get started here, and.
00:51:49.732 - 00:51:54.750, Speaker A: It returns 123456 variables.
00:51:54.830 - 00:52:27.408, Speaker B: So we can go ahead and get all of them with this tuple syntax here. So we'll say total collateral eth, total debt eth available borrow eth, current liquidation threshold loan to value and then the health factor. So it's with this syntax here that.
00:52:27.414 - 00:52:42.676, Speaker A: We can actually get all of these variables with this one call. And again, this getuser account data is a view function, so we don't need to spend any gas. All of these variables are going to return in terms of way. So let's just go ahead and convert these from way to something that makes.
00:52:42.698 - 00:52:44.004, Speaker B: A little bit more sense to us.
00:52:44.122 - 00:52:47.448, Speaker A: So we want to get this available borrow eth so we can figure out.
00:52:47.454 - 00:53:23.108, Speaker B: How much we can borrow. Let's get that in terms that we can actually understand. So we'll do from way available borrow eth in terms of ether. We'll do total collateral eth equals web3 from way and we'll do total collateral eth ether and then we'll do total debt eth equals same thing web3 from way total debt eth terms of ethers, and let's even do a.
00:53:23.114 - 00:53:24.804, Speaker A: Little printf statement for each one of these.
00:53:24.842 - 00:53:28.772, Speaker B: So we'll do print f. This f.
00:53:28.826 - 00:53:30.516, Speaker A: Allows us to put variables inside the.
00:53:30.538 - 00:53:46.076, Speaker B: Print function and we'll say you have total collateral eth worth of eth deposited. We'll even copy paste that a couple.
00:53:46.098 - 00:53:47.564, Speaker A: Of times and we'll change this one.
00:53:47.602 - 00:53:58.028, Speaker B: To total debt eth and we'll change this one to available borrow eth. So we'll say you have worth of.
00:53:58.034 - 00:54:00.844, Speaker A: Eth deposited, you have total debt eth.
00:54:00.892 - 00:54:14.804, Speaker B: Worth of eth borrowed and you can borrow available borrow eth worth of eth. And then we're going to go ahead and return again.
00:54:14.842 - 00:54:16.176, Speaker A: We're going to use this tuple syntax.
00:54:16.208 - 00:54:18.016, Speaker B: So we can return two variables.
00:54:18.208 - 00:54:19.940, Speaker A: And we're going to say a float.
00:54:21.320 - 00:54:29.496, Speaker B: Of this available borrow eth and a float of the total debt eth. The reason that we have to add.
00:54:29.518 - 00:54:33.588, Speaker A: This float variable here is that without it, some of the math that we're going to try to do later won't.
00:54:33.604 - 00:54:34.472, Speaker B: Pan out as well.
00:54:34.526 - 00:54:38.940, Speaker A: So now we have this function, get borrowable data. We're going to pass the lending pool.
00:54:39.280 - 00:55:12.288, Speaker B: And we're going to pass our account here. Since we're returning the borrowable eth and the total debt, we can say borrowable eth and then total debt equals that function right there. So let's go ahead and try this out with Brian and run scripts. Ave borrow defy PI again, because in our config we have a default network of main net fork. Things seem to be approving, things seem.
00:55:12.304 - 00:55:14.010, Speaker A: To be depositing and awesome.
00:55:14.940 - 00:55:19.736, Speaker B: We have our output here. We deposited 0.1 worth of f. We.
00:55:19.758 - 00:55:43.948, Speaker A: Have zero f borrowed, and we can borrow 0.8 worth of f. Yes, this is correct. Even though we have 0.1 f deposited, we can only borrow 0.8. This is because the liquidation thresholds of different assets are different. In this risk parameters documentation here we can see the different liquidation thresholds on the different assets.
00:55:43.948 - 00:55:51.984, Speaker A: We can see that Ethereum has an 80% loan to value. So with Ethereum we can only borrow up to 80% of the deposit assets.
00:55:52.032 - 00:55:55.140, Speaker B: That we have, and if we have.
00:55:55.210 - 00:56:03.376, Speaker A: More than 82.5% borrowed, we'll actually get liquidated. It also tells about the liquidation bonus reserve factor and some other helpful pieces.
00:56:03.408 - 00:56:04.052, Speaker B: In here as well.
00:56:04.106 - 00:56:28.812, Speaker A: But now that we have this borrowable eth amount, we can go ahead and actually borrow some dai. So let's do a quick print saying let's borrow. Now, in order for us to borrow some dai, we also need to get the conversion rate. We need to get dai in terms of f. So we're going to have to use some price feed here. Luckily, we already know how to work with Chainlink and how to get price feeds. Ave uses the chainlink price feeds as well.
00:56:28.812 - 00:56:38.464, Speaker A: So we're using the exact same conversion rate tools that Ave is going to use. So let's go ahead and create a function to get us this conversion rate. We'll say the die to Eth price.
00:56:38.662 - 00:56:46.896, Speaker B: Is equal to get asset price. And then in here we'll pass the Di price feed.
00:56:47.088 - 00:56:51.556, Speaker A: This will be the address of the diethherium conversion rate. Let's go ahead and create this function.
00:56:51.658 - 00:56:56.596, Speaker B: Call it def get asset price, and.
00:56:56.618 - 00:56:58.000, Speaker A: The parameter it needs is going to.
00:56:58.010 - 00:56:59.448, Speaker B: Be the price feed address.
00:56:59.534 - 00:57:03.764, Speaker A: So the first thing that we're going to need is we're going to need to get this dieth price feed.
00:57:03.892 - 00:57:05.290, Speaker B: Where can we get this?
00:57:05.760 - 00:57:19.272, Speaker A: As we know, per usual, head over to the Chainlink documentation. We'll go to Ethereum price feeds, we'll find main, grab this, and we'll paste it into our config for Mainnet.
00:57:19.336 - 00:57:20.236, Speaker B: So we can go ahead and add.
00:57:20.258 - 00:57:24.668, Speaker A: The dice feed in here and paste.
00:57:24.684 - 00:57:26.224, Speaker B: It into our config again.
00:57:26.262 - 00:57:27.216, Speaker A: If we want to test this with.
00:57:27.238 - 00:57:41.826, Speaker B: Coven, we can obviously just scroll down for coven, find the dieth right here and grab that address and pop it in for coven. And then we can get this the.
00:57:41.848 - 00:57:43.250, Speaker A: Same way that we got the address.
00:57:43.320 - 00:57:48.678, Speaker B: Of the weth token. So I'm just going to go ahead and copy this, paste it here.
00:57:48.764 - 00:57:50.486, Speaker A: But instead of having weth token in.
00:57:50.508 - 00:57:55.446, Speaker B: Here, we'll do di price feed and.
00:57:55.468 - 00:57:57.094, Speaker A: Now we have a way to change.
00:57:57.212 - 00:57:59.942, Speaker B: The price feed address depending on what network we're on.
00:57:59.996 - 00:58:04.730, Speaker A: So in our getasset price function we're going to do the same exact thing that we always do.
00:58:04.800 - 00:58:09.530, Speaker B: We're going to grab an ABI and an address to work with the contract.
00:58:09.890 - 00:58:11.818, Speaker A: So again we can get the ABi.
00:58:11.914 - 00:58:27.246, Speaker B: By just working directly with the interface. So we'll say di f price feed equals interface dot aggregator v three interface.
00:58:27.358 - 00:58:28.658, Speaker A: Because this is the name of the.
00:58:28.664 - 00:58:31.458, Speaker B: Price feed interface which again if we.
00:58:31.464 - 00:58:33.938, Speaker A: Look in our interfaces it looks like we don't actually have.
00:58:34.024 - 00:58:35.746, Speaker B: So what we can do is we.
00:58:35.768 - 00:58:37.006, Speaker A: Can go to the chain link GitHub.
00:58:37.118 - 00:58:39.286, Speaker B: Or as you guys are already starting.
00:58:39.308 - 00:58:45.110, Speaker A: To figure out all my example code has all these interfaces as well. But we can go right to the source too.
00:58:45.260 - 00:58:53.194, Speaker B: What we can do, we go here, we go to contracts, we get it at source, we'll do 0.6, we'll do.
00:58:53.232 - 00:58:56.582, Speaker A: Interfaces and right here is the aggregator v three interface.
00:58:56.726 - 00:59:03.126, Speaker B: So if we want we can just copy this whole thing, move back over to our interfaces new file and this.
00:59:03.168 - 00:59:15.006, Speaker A: File is actually named aggregator v three interface. You could call it I aggregator v three or aggregator v three interface. You could keep it with IAG reggatorv three sol to keep with the convention.
00:59:15.038 - 00:59:23.906, Speaker B: That we have or you can just call it aggregator v three interface sol to keep in line with what the.
00:59:23.928 - 00:59:31.094, Speaker A: Chain link code is actually called it. I'm going to call mine aggregator v three interface. You'll notice a couple of different projects have a couple of different conventions but.
00:59:31.132 - 00:59:32.694, Speaker B: Now that we have it saved we.
00:59:32.732 - 00:59:41.466, Speaker A: Can do interface aggregator v three interface and we'll pass it this price feed address. Now this dieth price feed is going to be a contract that we can.
00:59:41.488 - 00:59:43.626, Speaker B: Call a function on and again we.
00:59:43.648 - 00:59:45.146, Speaker A: Can always refer back to the get.
00:59:45.168 - 00:59:48.794, Speaker B: The latest price documentation to see how to actually work with it.
00:59:48.832 - 00:59:52.162, Speaker A: There's even some python code here for working with it in web3 we're.
00:59:52.166 - 00:59:54.094, Speaker B: Going to go ahead and call this.
00:59:54.132 - 00:59:58.174, Speaker A: Latest round data function which we can also find in our aggregator v three.
00:59:58.212 - 01:00:01.322, Speaker B: Interface this latest round data which returns.
01:00:01.386 - 01:00:04.106, Speaker A: A round id answer started at, ended.
01:00:04.138 - 01:00:05.534, Speaker B: At and answered in round.
01:00:05.662 - 01:00:11.582, Speaker A: All we're really concerned with is this answer bit here. So the way we can do this is we can say latest price equals.
01:00:11.646 - 01:00:19.302, Speaker B: Diath price feed latest round data and instead of grabbing all five of these.
01:00:19.356 - 01:00:22.758, Speaker A: 12345 what we can do is we.
01:00:22.764 - 01:00:25.686, Speaker B: Can actually just grab the price which.
01:00:25.708 - 01:00:29.642, Speaker A: Is at the one index. So round id is at zero, price.
01:00:29.696 - 01:00:43.038, Speaker B: Is at one start at two, et cetera. So we can just say at the first index. And then we can return a float of this latest price.
01:00:43.204 - 01:00:46.730, Speaker A: We can even print another printf statement.
01:00:46.890 - 01:00:58.270, Speaker B: The DI F price is latest price. So let's go ahead and run this. And great.
01:00:58.340 - 01:00:59.806, Speaker A: We have the Di F price feed.
01:00:59.838 - 01:01:02.338, Speaker B: Here, which of course, we know that.
01:01:02.424 - 01:01:09.118, Speaker A: Looking at this right now, this isn't in the right units. We know that dieth price feed has 18 decimal places.
01:01:09.214 - 01:01:10.822, Speaker B: So what we can do then is.
01:01:10.876 - 01:01:22.618, Speaker A: We know that this number would be 1234-5678 910, 1234-5678 this number is really 0.4.
01:01:22.704 - 01:01:24.214, Speaker B: Blah, blah, blah, blah, blah.
01:01:24.342 - 01:01:26.330, Speaker A: So maybe we don't want to return.
01:01:26.400 - 01:01:28.138, Speaker B: It like, so maybe we want to.
01:01:28.144 - 01:01:30.266, Speaker A: Say the dieth price feed is and.
01:01:30.288 - 01:01:31.886, Speaker B: We add a little bit of web.
01:01:31.908 - 01:01:34.478, Speaker A: Three PI to make this make a little bit more sense.
01:01:34.564 - 01:01:43.250, Speaker B: So we'll say web3 from way, and we'll add this latest price bit in here, comma, ether.
01:01:43.910 - 01:01:49.646, Speaker A: Maybe we'll even do a converted latest price, which is going to be equal.
01:01:49.678 - 01:01:55.830, Speaker B: To web3 from way latest price ether.
01:01:56.170 - 01:01:58.086, Speaker A: And we'll print that out instead.
01:01:58.268 - 01:02:07.046, Speaker B: So let's go ahead and run this again. All right, that looks a little bit more accurate. Perfect. Okay, great.
01:02:07.148 - 01:02:32.878, Speaker A: Now we have the dieath price. We're getting really close to being able to borrow this actual asset. And let's even return this converted lated price here just so that we're always working in units that we understand. Okay, now we're getting somewhere. Now we can calculate the amount of dai that we want to borrow. We can find this by doing a little bit of math. We're going to do the reciprocal of the die eth price times our borrowable eth.
01:02:32.878 - 01:02:39.422, Speaker A: And just to be safe, we're going to times it by zero point 95. So this line, we're converting our borrowable.
01:02:39.486 - 01:02:43.902, Speaker B: Eth to borrowable die.
01:02:43.966 - 01:03:13.838, Speaker A: And then we're timing it by 95%. We're timing it by 95% because we don't want to get liquidated. So we're going to be a little bit more cautious. Remember how we slid that sliding scale around to make it safer and less safe? Well, the lower percentage that we actually borrow, maybe we even borrow 50% of our collateral, the safer that we're going to be. So keep that in mind when you're deciding how much to actually borrow if you want to run this in a production environment. So now that we have this amount die to borrow, let's even print it out. Let's say print f.
01:03:13.838 - 01:03:15.614, Speaker A: We are going.
01:03:15.732 - 01:03:23.860, Speaker B: To borrow amount data, borrow die, and then we're finally going to do it.
01:03:24.470 - 01:03:26.290, Speaker A: Now we will borrow.
01:03:28.390 - 01:03:28.978, Speaker B: Looking at the.
01:03:28.984 - 01:03:41.090, Speaker A: Ave documentation, we can look at their borrow function and we can see the API here. Let's go ahead, let's go ahead and call this function. So we'll do borrow transaction. It's going to be equal to lendingpool borrow.
01:03:41.610 - 01:03:43.042, Speaker B: Let's look at those parameters.
01:03:43.186 - 01:03:49.778, Speaker A: So the asset that we want to borrow die address. So first we should get a die address which we can once again will.
01:03:49.804 - 01:03:56.026, Speaker B: Want to put in our config. So we'll go over to our config and we'll add a dai address or.
01:03:56.048 - 01:04:00.374, Speaker A: A Dai token here which we can find on Etherscan die token.
01:04:00.502 - 01:04:02.378, Speaker B: It looks like this is the token right here.
01:04:02.464 - 01:04:16.798, Speaker A: So we'll copy this address for Mainnet. Remember, if you want to run this on coven, you're also going to need to have a diet token for coven. Now on testnets, Avi actually changes up where the tokens for its testnets are actually going to be. So if we go to their documentation.
01:04:16.894 - 01:04:21.762, Speaker B: We go to deployed contracts and we go to coven here, you'll always see.
01:04:21.816 - 01:04:28.386, Speaker A: This little flag thing pop up. Say always ensure you're using the latest lending pool address. Since COVID is updated from time to.
01:04:28.408 - 01:04:30.134, Speaker B: Time, it's going to be the same thing.
01:04:30.172 - 01:04:36.918, Speaker A: If we scroll down for tokens, they have an up to date list of COVID addresses in a JSON file here.
01:04:37.004 - 01:04:40.666, Speaker B: So it looks kind of gross. But if we look up die, we.
01:04:40.688 - 01:04:52.922, Speaker A: Can see symbol Dai and the address of Dai on the coven testnet. So sometimes this does change. So if you run into an issue, maybe it's because the DAI token that you were working with on their covenant testnet has actually changed.
01:04:52.986 - 01:04:55.310, Speaker B: Then we're going to do config networks.
01:04:57.730 - 01:04:59.550, Speaker A: Network showactive.
01:05:02.290 - 01:05:03.454, Speaker B: Die token. Great.
01:05:03.492 - 01:05:04.466, Speaker A: Now let's move on to the next.
01:05:04.488 - 01:05:11.074, Speaker B: Parameter, the amount which we just figured out here. Amount die to borrow, which we do.
01:05:11.112 - 01:05:14.322, Speaker A: Need to change back to way. So we're going to do web3.
01:05:14.456 - 01:05:17.890, Speaker B: Two way mount die to borrow ether.
01:05:18.390 - 01:05:23.160, Speaker A: Because right now amount die to borrow is in our human readable version which we need it in way.
01:05:24.010 - 01:05:26.406, Speaker B: Then our interest rate mode, which is.
01:05:26.428 - 01:05:48.670, Speaker A: Going to be stable or variable. Stable is where the interest rate will always be. Exactly the same variable will change depending on a lot of different things going on with Ave for safety, we're just going to go ahead and add one here. Then we're going to do a referral code and on behalf of. So referral codes no longer exist. So we'll leave zero and it's going to be on behalf of ourself.
01:05:49.330 - 01:05:56.626, Speaker B: So we'll do account address and then of course we have to do a from account.
01:05:56.808 - 01:06:07.510, Speaker A: Then we'll wait for this transaction to complete. And if we've done this right, we should have borrowed some die programmatically from the Ave protocol. So let's even print.
01:06:09.210 - 01:06:11.110, Speaker B: We borrowed some die.
01:06:12.890 - 01:06:24.986, Speaker A: And we can once again call our get borrowable data function since this get borrowable data function will print out our new count information for how much we borrowed. So let's go ahead and run this.
01:06:25.008 - 01:06:30.382, Speaker B: On Mainnet fork again. Awesome.
01:06:30.516 - 01:06:46.066, Speaker A: So if we've done this correctly, we now see that we've borrowed some die. So we can see here we now have 0.1 worth of eth deposited zero point 59 nine worth of eth borrowed and we can borrow a little bit.
01:06:46.088 - 01:06:47.482, Speaker B: More worth of eth.
01:06:47.646 - 01:06:53.202, Speaker A: This 0.7599 is actually the die that we've borrowed.
01:06:53.266 - 01:06:55.458, Speaker B: So we've deposited some EtH and we've.
01:06:55.474 - 01:07:14.974, Speaker A: Borrowed some die and Ave is telling us how much of that die converted to eth is there. So we actually borrowed 160 die, which is great. All right, we've now learned how to borrow everything, which is fantastic. Let's go ahead and actually repay that back. So we're going to call their repay function and let's just put this into.
01:07:15.092 - 01:07:20.158, Speaker B: Its own function called repay all and we'll give it the amount that we.
01:07:20.164 - 01:07:23.582, Speaker A: Want to repay the lending pool address and our account.
01:07:23.716 - 01:07:27.470, Speaker B: So let's call, let's define repay all.
01:07:27.540 - 01:07:30.210, Speaker A: Where we're just going to repay everything that we have.
01:07:30.280 - 01:07:38.202, Speaker B: And again we're going to add an amount lending pool and account for parameters.
01:07:38.366 - 01:07:51.306, Speaker A: So if we're going to pay back this network, first thing that we need to do is actually call the approve function and approve that we're going to pay back. So the first thing we're going to have to do, per usual, is we're going to actually have to approve that ERc 20.
01:07:51.408 - 01:08:02.986, Speaker B: So let's say how much we're going to approve web3 two way amount ether to the lending pool and we'll.
01:08:03.018 - 01:08:04.430, Speaker A: Grab it from the config.
01:08:07.660 - 01:08:19.650, Speaker B: Networks. Network show active and this is going to be the die token again.
01:08:21.060 - 01:08:43.400, Speaker A: And of course with our account, I believe our approve ERC 20 already calls. Wait, so we don't have to call it here. So once we approve, we're going to be using this die that we borrowed to pay most of what we have borrowed back. Now we're going to call the repay function. So we'll say repay TX equals lendingpool repay.
01:08:44.700 - 01:08:47.288, Speaker B: First we need the asset that we're.
01:08:47.294 - 01:08:49.108, Speaker A: Going to use to repay, which we're.
01:08:49.124 - 01:08:50.280, Speaker B: Going to use config.
01:08:55.620 - 01:08:56.720, Speaker A: Networks.
01:08:58.900 - 01:09:22.776, Speaker B: Network show active dietoken, the amount which is going to be passed in here amount, the rate mode which we've hard coded to one, and the address on behalf of which is going to be account address. Then of course, we always have to do from account.
01:09:22.958 - 01:09:29.428, Speaker A: Then we're going to do repay TX. Wait. We're going to wait one block confirmation.
01:09:29.604 - 01:09:32.440, Speaker B: And then we'll print repaid.
01:09:33.260 - 01:09:36.940, Speaker A: And if we've done all this right, we'll do one more print line saying.
01:09:37.090 - 01:09:48.400, Speaker B: You just deposited, borrowed and repaid with Ave, Brownie and chainlink.
01:09:50.100 - 01:09:52.252, Speaker A: All right, moment of truth.
01:09:52.396 - 01:10:03.020, Speaker B: Let's see if this works. Who we did it repaid.
01:10:03.100 - 01:10:11.236, Speaker A: You just deposited, borrowed, and repaid with Ave, brownie, and chainlink. Awesome work. Now, if you want to, what we can also do is we can see.
01:10:11.258 - 01:10:15.044, Speaker B: If this will work with our wallet address here.
01:10:15.162 - 01:10:16.516, Speaker A: So what I can do is I.
01:10:16.538 - 01:10:24.504, Speaker B: Can copy my address, go to coven ether scan and paste it in here. And right now we can see that.
01:10:24.542 - 01:10:27.080, Speaker A: I have a whole bunch of link and some ether.
01:10:27.680 - 01:10:35.900, Speaker B: What I can do is actually test everything that we just ran through on the coven testnet and see everything happen.
01:10:36.050 - 01:10:40.856, Speaker A: Right on this ether scan address. So if we've been following along correctly.
01:10:40.968 - 01:10:44.704, Speaker B: And we've added contract addresses appropriately, we.
01:10:44.742 - 01:10:48.780, Speaker A: Should be able to run the exact same script on the coven testnet.
01:10:48.860 - 01:10:51.360, Speaker B: I'm going to do one additional thing here, though.
01:10:51.510 - 01:10:55.668, Speaker A: I'm going to have us not repay. So we can see us with a.
01:10:55.674 - 01:10:56.820, Speaker B: Little bit of debt.
01:10:57.160 - 01:10:59.200, Speaker A: So let's go ahead and run brownie.
01:10:59.360 - 01:11:02.144, Speaker B: Run scripts Ave Bartapai.
01:11:02.192 - 01:11:12.244, Speaker A: And we'll change to network coven. And now it's going to take a lot longer, as we've seen before, because we're actually making these transactions on a real network.
01:11:12.372 - 01:11:12.836, Speaker B: Whoops.
01:11:12.868 - 01:11:14.056, Speaker A: It looks like I got one of.
01:11:14.078 - 01:11:16.868, Speaker B: The dieth price feeds wrong for Covid.
01:11:17.044 - 01:11:18.456, Speaker A: So I can once again just go.
01:11:18.478 - 01:11:31.604, Speaker B: Over to the documentation di and it looks like this is the real address for Covid. So we'll copy that, paste it in here. Whoops.
01:11:31.672 - 01:11:34.124, Speaker A: We should also probably have some weth token.
01:11:34.252 - 01:11:49.460, Speaker B: So first, let's go ahead and run our getweth script for Covid. And we're going to change this account to get account Brownie. Run scripts, getweth py network coven from our helpful scripts.
01:11:51.000 - 01:11:54.160, Speaker A: That way we can actually use our wallets correctly.
01:11:54.240 - 01:11:54.872, Speaker B: All right, great.
01:11:54.926 - 01:11:57.864, Speaker A: So now we have 0.1 weth and.
01:11:57.902 - 01:12:10.476, Speaker B: Actually again, what we can do is grab this address here, add token, paste it in, add tokens for the weth token and now we can see we.
01:12:10.498 - 01:12:15.192, Speaker A: Have 0.1 weth which is perfect. So now that we have some weth.
01:12:15.336 - 01:12:24.800, Speaker B: We can run the borrow script Ave Brownie run scripts Ave borrow network coven.
01:12:30.760 - 01:12:40.612, Speaker A: And wow, we can see that everything went through correctly and successfully. So since I actually comped out this repay function, we still should have die.
01:12:40.676 - 01:12:47.816, Speaker B: In our address here in our wallet here. And again we can see that by going to our brownie config, grabbing this.
01:12:47.838 - 01:12:51.300, Speaker A: Die token address, add token, custom tokens.
01:12:51.380 - 01:12:53.884, Speaker B: Next add tokens and we can see.
01:12:53.922 - 01:13:02.284, Speaker A: We do indeed have 160 die in our wallet. We have no weth since it'll be in Ave now and we have borrowed die instead.
01:13:02.402 - 01:13:06.544, Speaker B: You can also see that we now have this awath if we added it.
01:13:06.582 - 01:13:10.688, Speaker A: From when we were working with the UI. We have this interest bearing weth instead.
01:13:10.774 - 01:13:12.904, Speaker B: Of regular wrapped ethereum.
01:13:13.052 - 01:13:39.496, Speaker A: Let's look at one of these transactions. We can see that our borrowed transaction gave us some stable debt bearing dai and also some dai. So we owe aave some dai from this debt. We got some debt, we got some dai and we gave out some Ave interest bearing dai to the rest of the Ave protocol. You'll notice now if we go to testnet ave.com dashboard, we'll see exactly what.
01:13:39.518 - 01:13:42.956, Speaker B: Our script just did. We have 160 die borrowed and we.
01:13:42.978 - 01:13:45.256, Speaker A: Have 0.1 eth deposited.
01:13:45.368 - 01:13:49.932, Speaker B: If we want to repay our funds, we can do it with our current.
01:13:49.986 - 01:13:52.712, Speaker A: Collateral or from our wallet balance.
01:13:52.856 - 01:13:54.416, Speaker B: And you'll notice something, if I try.
01:13:54.438 - 01:14:01.216, Speaker A: To repay everything from my wallet, all the die that I've actually borrowed, you'll notice we don't have enough funds to.
01:14:01.238 - 01:14:02.576, Speaker B: Repay the full amount.
01:14:02.758 - 01:14:12.032, Speaker A: This is because since we actually borrowed a little bit, we've accrued some of that interest. So we actually owe more back than we originally borrowed.
01:14:12.096 - 01:14:13.300, Speaker B: That's how the loans work.
01:14:13.370 - 01:14:27.352, Speaker A: So when you're designing this repay functions, be sure to have that in mind. You can also have your repay be minus one to repay the entire debt. It's recommended to send an amount slightly higher than the current amount borrowed. But in any case, maybe we say.
01:14:27.406 - 01:14:29.192, Speaker B: We want to do from our current.
01:14:29.246 - 01:14:37.036, Speaker A: Wallet we'll hit Max, but maybe we want to actually just repay with our current collateral. We can go ahead and repay the maximum amount. Again, we could do this all from.
01:14:37.058 - 01:14:39.644, Speaker B: The UI we'll approve and this is.
01:14:39.682 - 01:14:43.740, Speaker A: Exactly what our repay function actually did. And now we're all repaid up.
01:14:43.810 - 01:14:47.104, Speaker B: If we go back to our dashboard and we hit refresh, we'll see.
01:14:47.142 - 01:14:51.116, Speaker A: We just have a tiny bit of ethereum and no more borrowed assets.
01:14:51.228 - 01:14:51.600, Speaker B: Awesome.
01:14:51.670 - 01:14:53.456, Speaker A: You've essentially learned everything that we need.
01:14:53.478 - 01:14:54.756, Speaker B: To go through for here.
01:14:54.938 - 01:15:37.968, Speaker A: This is a massive step forward in teaching you how to become quantitative Defi wizards and build really robust applications and really robust financial applications in the DeFi world. Now, something I want to point out, even though this isn't a python course and we're teaching more about solidity and smart contracts, it's still in your best interest to test these functions. Yes, I know they're python functions, but it's still going to be in your best interest to test them to make sure your application always works as you expect it to. Now, I'm not going to go through this testing suite that I put here, but it's a really simple testing suite to test some of the different functions that we created. It can be really helpful, especially for something like getasset price, where the math might be a little bit off and.
01:15:37.974 - 01:15:39.308, Speaker B: You want to make sure it's correctly.
01:15:39.404 - 01:15:40.944, Speaker A: Again, link in the description to seeing.
01:15:40.982 - 01:15:42.140, Speaker B: Some of these tests.
01:15:42.300 - 01:16:13.992, Speaker A: This is actually going to be even easier than that lottery contract that we did, since we're just testing Python functions. And again, you can test these all with brownie test. All right, you are all doing fantastically. Now is another fantastic time to take a break, go for a walk, get some food, because our next session, our next lesson, we're going to be learning about nfts. How to build them, use them and deploy them. Amazing work. Learning about Aave, learning about DeFi from this project, from this lesson here.
01:16:13.992 - 01:16:26.700, Speaker A: Fantastic. In our next lesson, we're going to learn about nfts. I'll see you there. It's.
