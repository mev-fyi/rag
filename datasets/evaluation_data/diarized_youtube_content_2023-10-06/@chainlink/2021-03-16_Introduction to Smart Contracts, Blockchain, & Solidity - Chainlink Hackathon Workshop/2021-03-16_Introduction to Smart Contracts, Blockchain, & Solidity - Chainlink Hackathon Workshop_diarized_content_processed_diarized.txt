00:00:50.960 - 00:01:16.350, Speaker A: You. Hello, hello. How are we doing, everybody? Just waiting for a couple people to jump on and then we can go ahead and get started. We are going to be doing the introduction to smart contracts. We're going to talk about blockchain, we're going to talk about solidity. We're going to talk about remix. And what is all this stuff I got to not duplicate myself.
00:01:16.350 - 00:01:44.260, Speaker A: Yeah, and what is all this stuff? So I'm going to be checking the comments as well. Would love to keep this interactive so that we can all kind of learn, learn and grow. Awesome seeing some people jump in the chat. Hello. Hello. There's a little bit of a delay between where I'm recording in the chat, but I will get to the comments here. So just going to wait, give it a few minutes, let a couple more people join.
00:01:44.260 - 00:02:02.744, Speaker A: Hello. Really excited for this one. If you're brand new here, this is perfect. This is exactly where you should be. Want to learn about smart contracts, solidity, blockchain. We're going to go over everything. Make sure to ask questions.
00:02:02.744 - 00:02:42.240, Speaker A: Make sure to ask questions because everyone's starting off on a different pace. So we are going to just make sure everyone is up to speed. Here's great. I'm going to start jumping in a couple more people. A couple more people starting joining. Welcome. Share my screen here.
00:02:42.240 - 00:03:24.096, Speaker A: Hopefully that looks. I wish there wasn't this delay between YouTube and. Hello, hello, welcome. Yeah, that looks good. Cool. All right, guys, so let's go ahead and jump in now. So everything that we want to go over is basically going to be in this beginners, the basic documentation in the chain link doc.
00:03:24.096 - 00:03:57.180, Speaker A: So this is docs chain link docsbeganertutorial. So this is kind of where if you're like, I'm totally lost. I don't remember anything from that workshop. This obviously is going to be recorded. You can come back to it later, but this is really where you can kind of get started for everything. So I'm going to explain some stuff, I'm going to give some demos, but again, please ask questions. So let's talk about what is a smart contract? And before we even do that, we need to talk about what is a blockchain.
00:03:57.180 - 00:04:39.340, Speaker A: Right? So a lot of people here, this is like brand new stuff. People go, what is a blockchain? Well, a blockchain is literally just a massive kind of linked list database of transactions, right? And it's this distributed thing and there's all these pieces to it. Let's kind of break it down. So the first thing that makes blockchain work is cryptography. So whenever we have a piece of data, we can actually hash it, and we get a unique hash of this data. So this is called the shade 256 hash. It's basically a unique algorithm that takes this piece of data, which right now it's like cat.
00:04:39.340 - 00:05:37.372, Speaker A: We'll have the data be cat, right? It takes this unique piece of data, this cat, and it hashes it. And we get this kind of unique identifier for the data. So according to the shade two, v, six hash, this hash right here represents cat. And then if we do, like dog, this hash represents dog. And so it's a great way to get unique data, right. And this is really important because once we learn we can hash data, we can actually start to figure out blocks of data, right? So we're going to take cat again, here's an example of, like, a block in a blockchain, and we want to mine it. So basically, mining is when we do that same exact hashing thing, but we do it with the intent to find a solution.
00:05:37.372 - 00:06:26.416, Speaker A: So you see how at the beginning of this hash, it has four zeros. So what these computers are doing when they're mining is they're doing this exact same thing as we were doing here. They're hashing this cat, but they're doing it in a way in combination with what's called a nunce, where if the nuns plus the data makes the hash have four zeros at the beginning. Now, that doesn't have to be the problem. It could be kind of whatever. It could be any problem. But what the computer needs to do is it needs to keep trying different nunces until it figures out a hash that has four zeros with this data right here.
00:06:26.416 - 00:07:09.324, Speaker A: So when a blockchain is mining stuff, they're just trying different nunces to get this down here. So they're saying the nuns plus the data equals a hash that starts with four zeros. And so the computer just has to keep trying. It's just a huge trial and error. And this is why when you hear about mining and you hear about blockchains mining, they're doing just a ton, a ton of trial and error until they can finally, eventually get to this answer where it has four zeros at the beginning. Again, that's not always what the challenge is. Maybe it's ten zeros, maybe it's two zeros or whatever, but some sort of challenge that the computers can reach.
00:07:09.324 - 00:07:42.724, Speaker A: Some sort of challenge. So this is hashing. This right here is hashing. When you take this algorithm, you apply it to this data and you get this hash. And then this is kind of mining where you hash a nunce and the data to get this hash. Anybody have any questions so far? And, yes, this is the proof of work. Algorithm e two will be proof of stake.
00:07:42.724 - 00:08:46.012, Speaker A: Good point. But, yeah, this is kind of the basics there. Now, what is cool, obviously, in solidity and with Ethereum, you can actually add Function, do something public. You can do the same thing with, like, code. So this is a way to store code on chain, and then we can actually have these things do things for us, which is really powerful. So what is a nunce? So a nunce is just kind of this number that they use in combination with data to get the hash to solve the puzzle, basically. So basically you add this Nunce to your Data to try to get your hash to have four zeros at the beginning or whatever challenge it is.
00:08:46.012 - 00:09:20.280, Speaker A: Eight zeros, 100 zeros, two zeros, whatever you want it to be. None says just a number. Yeah, exactly. None says just a number. So once you have the hash, once you have the block, we kind of go to the blockchain and you can see, if we do this many Times, every new block is going to include the hash of the previous block. Right. And you need to hash everything in here, the Nuns and the previous hash.
00:09:20.280 - 00:10:04.086, Speaker A: Right. So we're going to get a new hash for this one. You see, it takes some time for us to actually mine. But so this hash right here is the combination of the previous hash, the data and the nuns. Right. And so this is what makes blockchain so powerful, too, because let's say, let's go ahead and mine this one, let's mine this block. And this is what makes it so immutable, is if I go back to this block right here and I change something, the hash is going to be different.
00:10:04.086 - 00:10:45.060, Speaker A: So now the rest of the blockchain isn't validated. Right. And so once you get into what's called the distributed part, we'll have all these blockchains that match up. If I change one now, this blockchain on this peer a, which could be anybody in the world who's running it, they no longer match everybody else. So everybody else says, okay, peer a is wrong, and kick them out, basically. So that's kind of the basics of blockchain and how kind of mining and how the cryptographic part works. It's actually simpler than a lot of the people kind of make it out to be.
00:10:45.060 - 00:11:23.646, Speaker A: This is just kind of like. What is all this cryptography stuff. It's kind of less important in my mind to really understand the math behind this and how it really works. The cool part for me is really the solidity stuff in the smart contracts, which we'll get to in a minute. But for those of you who are like, I don't even know blockchain, this is kind of the simple explanation of what it looks like. And I will even post a link in the comments right now and we'll add it to the description if you guys want to visit this and check it out yourself and kind of play with it a little bit. But this is really blockchain in simplest form.
00:11:23.646 - 00:12:07.070, Speaker A: So I'm looking at the comments now. It's four zeros for nuns. No? So the four zeros is like the challenge, right? So if cat is the data, the challenge is how do you get four zeros at the beginning of the hash? Using some nuns. Right? So again, if we hit mine, the answer is if we do 14,132 as the nuns and we hash that with the cat, then we get a hash with four zeros. Right. So the nuns is what we're using to combine with the data to get to beat the challenge. And the challenge here is have four zeros at the beginning of your hash.
00:12:07.070 - 00:12:49.566, Speaker A: Who defines the nuns? When you're mining, you define the nuns. But if the question is who defines what the challenge is, the challenge is actually based on the blockchain itself. All right, cool. So that's blockchain at basics. Now, this is really cool because, like I was showing you, it allows you to actually store code on the blockchain. So you have immutable code that will permanently be there and it'll be run in a decentralized manner. Right.
00:12:49.566 - 00:13:37.434, Speaker A: What does it mean when we're run in a decentralized manner? So, actually, back to the blockchain demo. If we go to this distributed section, we see that these blockchains are actually run by different peers or different people, right? So these blockchains are distributed, meaning multiple people run the software that has all this stuff, right? Yes, exactly. The nuns is the right answer. The miner discovers and waves around to the other miners service to get the reward, and it pushes the block. But, yeah, that's spot on. So all these peers are running these programs, and they all execute this code and run these transactions at the same time. And you can see if somebody reports something wrong.
00:13:37.434 - 00:14:09.014, Speaker A: You see how this lights up red? It doesn't match what all the other blockchains have said. And so this one's now disqualified or kicked out, basically. Right? So this is how blockchains run in a decentralized way. You don't have to trust a centralized point of failure, right. Because there are all these different individual entities running the code and producing data. And if one says, oh, I'm going to screw it up, I'm going to say Patrick actually has zero. Actually, let's even do this.
00:14:09.014 - 00:14:50.350, Speaker A: Let's say Patrick has $1. Patrick has $1. Let's just mine this real quick. Mine this, save this one's Patrick has zero. Well, it's green, actually, because all the hashes match. But this blockchain will say Patrick has $0 while all these other ones will say Patrick has $1. You can just check the hashes.
00:14:50.350 - 00:15:29.902, Speaker A: We'll see. The hashes of these two blockchains are different than this top one. And this top one will get kicked out, basically saying, oh, you're clearly doing something malicious, you are lying, we're going to kick you off. So that's how it stays decentralized and stays trust minimized, if you will, which is really powerful. So that's blockchain, and that's kind of the simple level blockchain. Now, what can we do with this? Well, okay, now that we have a way to provably and in a decentralized manner run code and store data, this is how we can build what's called smart contracts. So these smart contracts are on these blockchains, pieces of code.
00:15:29.902 - 00:16:25.680, Speaker A: And again, it's going to show red because I'm changing stuff. We can write code like function, do something, and maybe like give Patrick money. Obviously, this is pseudocode, but we can have these functions and they'll get executed in a decentralized manner. So each one of these nodes, each one of these individual peers will run and it will execute the code, and they will all check to see if they all match up. And if they do, it'll execute and move forward. So, a couple of questions in the chat. Can't the user set the nuns as well as something like metamask? Can't the user set the nuns as well as something like metamask? There's a couple of question doesn't quite.
00:16:25.680 - 00:16:52.970, Speaker A: So a miner can set the nuns right, but if I try to do like one, you see the hash doesn't have four zeros. So this nuns would be wrong. Same thing. Two, this nuns is still wrong. Three, this nuns are still wrong. So you got to keep trial and erroring to get the right nuns. And then again, we're hitting mine, which is just the computer trial and erroring until it gets 30,874.
00:16:52.970 - 00:17:14.846, Speaker A: So that the hash is correct. Okay, nuns comes from proof of work, simply just a number, any number incremented by one until the node finds it. It's proof that the new block was created in a legitimate way by using proof of work method. Spot on. Yep, that's spot on. Since metamask user is not engaged with mining activities. So metamask is not a miner.
00:17:14.846 - 00:18:08.622, Speaker A: Metamask is kind of like a wallet that's built on top of the blockchain that tells you what your balances are and stuff. So again, in some of these blocks, there's going to be, Patrick has like one USD or something, right? That's going to be in a block. It's going to be like Don has four USD. So Metamask is basically just a way to kind of read and be connected to the blockchain in this manner. So what are we going to do in the hackathon? So code has many copies in different peers or does it have copies in all peers? So yes. So it has copies in all peers, right? Each one of these peers, each one of these different chains. And it could be like me running a blockchain node in my house, you running a blockchain node in your house, it's going to have everything, every transaction that's ever occurred.
00:18:08.622 - 00:18:48.538, Speaker A: Otherwise, like we saw right here, it's not going to be a valid chain, right? Because the hashes aren't going to be equal across all chains. So if I'm missing a hash or something, I can't add to the chain, I can't move forward because I'm going to be missing crucial data. Should I do yield farming? Let's not for this demo. If data is high demand, running a chain link node is something. That's it. Okay, cool, great. So let's move on to smart contracts.
00:18:48.538 - 00:19:42.298, Speaker A: So now that we have a way to store data in this way, we can also write smart contracts that are stored on chain as well. And these smart contracts are going to get executed in this decentralized manner. And this is kind of really the power that blockchain has, is executing these transactions in a decentralized manner, executing the code that we wrote on chain across all peers. Right? So that's what a smart contract is. A smart contract is just code on the blockchain that's being executed in a decentralized manner. So smart contract, obviously a contract is like any agreement between people. Another way to say smart contract is DAP or decentralized application, because it's an application where all the computation is run in a decentralized manner, and this is obviously highly beneficial because we don't have to rely on a centralized intermediary.
00:19:42.298 - 00:20:30.880, Speaker A: For those of you who were here when Sergey was giving his talk yesterday, having these trust minimized agreements and applications is highly favorable and highly important for a lot of things. And one of the biggest examples is with everything that happened with Robinhood and GameStop and all that. So smart contracts are these decentralized applications that we can build and we can run, and they can do a lot of really cool stuff, and they're written in solidity. Solidity is the language of the smart contracts, at least on the Ethereum chain and every EVM compatible chain. Don't worry about what that means right now. But solidity is incredibly powerful, and it's what we're going to be working with today. So this is what a really simple solidity smart contract looks like.
00:20:30.880 - 00:21:20.720, Speaker A: Let's even play with it and go to remix. So this is remix once it pulls up. So this is remix. Remix is a web ide or a web integrated development environment. It's a way for us to test, deploy and visualize our smart contracts that we deploy, and again, we're deploying them to the blockchain that will get executed in this decentralized manner. So we'll come here, we're going to hit solidity so that it knows we want to work with solidity. I have a bunch of stuff in here because I use it a lot, but we're going to go ahead and create a new file and we'll call it chainlinkworkshop sol.
00:21:20.720 - 00:21:55.466, Speaker A: My fat finger at the end there, call it chainlinkworkshop sol. And I just pasted the code in here, right. So to kind of explain what this is, is this is some really basic solidity syntax here. So first we need to define the version of solidity that we're working with. So we're going to work with 0.6.6, the current version, and this is how you do a comment here which doesn't get executed. I think the current version is 0.8.2.
00:21:55.466 - 00:22:22.334, Speaker A: We like to use 6.6 for now because it's a pretty stable version. But yeah, solidity moves pretty quick. More versions are coming out quite often, and they all have very nice features and improvements. Then we have contract hello world. This is basically how you do a class in solidity. So you can think of contracts as classes, if you're familiar with Java JavaScript.
00:22:22.334 - 00:22:47.366, Speaker A: Really any object oriented programming language. So we're going to do contract hello World. This is the equivalent to doing like class hello world. And this whole thing is what gets deployed when we specify like a contract to deploy. We take this and we drop it into the blockchain like I was showing in that demo. String public message. This is how you define a string.
00:22:47.366 - 00:23:09.438, Speaker A: Basically it's a string, it's public visibility. There are four different types of visibilities. There's public, private, internal and external. You can learn about those later. And we're calling this variable message. So this is a global or a contract variable called message. It's initialized to an empty string.
00:23:09.438 - 00:24:06.454, Speaker A: Unlike other programming languages, when you define a variable, it just gets initialized to whatever the empty version of it is, which in this case it's like an empty string. So then we have a constructor, and this is what's called when this contract is deployed, the constructor is always called, you don't need a constructor, but it's usually good to have one, and constructor parameters. So when this contract gets deployed, it calls the constructor function. For those of you who are brand new to programming, that might be a long conversation. What a function is. This is something that you can call to do stuff. A constructor is called, we add the initial message into the R constructor and we set this global variable message to initial message.
00:24:06.454 - 00:24:32.974, Speaker A: So we're just setting this global variable here and then we have update message, which is a function that takes a string as a parameter. It's a public function which means anybody can call it. And then we're just going to set message to new message. So let's go ahead and compile this. So we'll come to the compile tab, we'll hit compile. And did you intend to add public? Yes, I did. Sorry.
00:24:32.974 - 00:24:58.418, Speaker A: So this one's also public. So we're going to compile this and then we're going to go to this deploy tab. This button right here is deploy and run transactions. We're going to stick with JavaScript VM for now, but for a lot of these we're actually going to use injected web3. But for now we're just going to stay with VM. I'll tell you why in a minute. But we're going to deploy our contract.
00:24:58.418 - 00:25:38.734, Speaker A: And you see here it takes a parameter called initial message. So let's say the initial message is hello, this is our initial message and we're going to deploy it. What you'll see down here is you'll get deployed contracts and you'll get the functions that we have. You can see we have update message, which is one of our function, and we also have message here, which is a function that calls this message variable so we can read what the message currently is. The message is currently hello. Right, and this is going to be on the blockchain. There's going to be a string called hello in this message contract.
00:25:38.734 - 00:26:25.178, Speaker A: And then if we want to update it with goodbye message now we click message and it now says goodbye. So I'm going to look at questions real quick here. Hey Patrick, is solidity backwards compatible? Kind of, yeah. So if I'm using like compiler six point twelve and I'm using a carrot 6.6 or carrot 0.6.6 then yes, kind of. So you don't have to rewrite all your contracts whenever you update versions.
00:26:25.178 - 00:26:44.582, Speaker A: So yeah, you're okay. Is it recommended for you 6.6 hackathon then? Yeah. To be honest, I would recommend using 0.6.6 for the hackathon. There's a lot of good tutorials and workshops with 0.6.6. Can we get rid of real estate with smart contracts? Really vague question.
00:26:44.582 - 00:27:04.094, Speaker A: I mean, I feel like people are always going to buy and sell property. Can a smart contracts help? Okay, interesting fun fact. Initial message is stored memory when the function is called. That's right. Then the data is copied into message property of the contract, which is stored on chain. That's how data is persisted. Correct.
00:27:04.094 - 00:27:43.660, Speaker A: What is memory in the code and why is it needed? Good question, actually. So strings, they need this memory. So there's two different things you can have here. You can have memory or storage. I wouldn't worry about it too much for now because for example, if this was like a UN, or an integer, you wouldn't need memory here. But it's basically saying this data is only going to persist for the time being that this is executed. So initial message only exists while this function is called and then you can't call it again.
00:27:43.660 - 00:28:06.642, Speaker A: We're setting it to message though, and message is a storage variable. So message does stay on chain permanently. But yeah, just know for strings you need to have. For functions you pretty much need to have memory. The real full explanation might be a little longer there. Memory is keyword that specifies where the variable stored. Yes.
00:28:06.642 - 00:28:29.900, Speaker A: Do you envision, is it just memory computation? Yeah, exactly. Memory is in computation stack. Exactly. And then storage. Storage is another one you can specify. This one is defaulting to storage, basically. What do strings do? Strings are like text.
00:28:29.900 - 00:28:46.320, Speaker A: So when it says like string memory, initial message. It's like text here. Like, this isn't a string, this is a number. This is a string. Cool. Good questions. All right, now we're actually going to do something a little bit more interesting.
00:28:46.320 - 00:29:30.086, Speaker A: Now we're going to actually move to injected Web three. So, injected web3, I know a couple of people were asking about Metamask. How does that fit in? Injected web3 says we want to connect to a real blockchain. The JavaScript VM is basically pretending we're on a blockchain. When we deploy contracts with JavaScript VM, we're pretending, we're saying this is what it would look like. There's an algorithm on the back that's running and says, yeah, if you were to deploy it, this is what it would look like. But when we do injected Web three, this is, we're actually going to deploy to a real network and we're saying we're taking whatever Web three provider that we have, we're sticking it into the browser.
00:29:30.086 - 00:30:04.126, Speaker A: So the web3 provider that I'm using is metamask. Excuse me, can you guys see this here? There's like a delay on my YouTube, so I'm hoping you guys can see my metamask. Okay, cool. Yeah, you guys can see it. Great. So we're sticking it in and we're actually going to interact with whatever blockchain that we've defined on our web3 connection. So you can see here, this is metamask.
00:30:04.126 - 00:30:48.894, Speaker A: If you don't have metamask, we highly recommend getting it. It's just a web browser like you kind of saw there. Make sure you're at Metamask IO. You can hit download now and then it'll bring you to, hey, download, install it to your browser, install it to chrome, install it to whatever you're working with, and this will get you set up. This will get you this here. Also on the chain link, YouTube, we have a video that kind of shows you how to do it a little bit step by step if you get totally lost. And yeah, everybody who's here, definitely check out the engineering tutorials.
00:30:48.894 - 00:31:03.880, Speaker A: They'll put you in a really good spot. But this one right here, install, configure and fund metamask. It's a really good video. Just switch from. It mentions using Robston. Switch to coven. I'll show you that right now.
00:31:03.880 - 00:31:53.154, Speaker A: Anyways, yeah, so smart contract, smart contract, smart contract deploying. We'll get into oracles in a second. We'll just take you through remix or metamask real quick. So once you actually get this browser extension, now you can actually start interacting with the blockchain. So we have here, you can see this is the coven test network. So a test network is a way to deploy your smart contracts in a realistic environment, but not cost you any money, which is really nice because we don't want to spend any money. So the reason we need to have Ethereum in here is because whenever we make a transaction on chain, we actually have to spend what's called gas or Ethereum gas.
00:31:53.154 - 00:32:25.310, Speaker A: So doing computation on Ethereum or any smart contract platform. Again, we have a whole bunch of different sponsors at this hackathon that aren't Ethereum. You have to spend a little bit of ETH to deploy your smart contract. So if I go ahead and hit deploy, deploy, now that I'm connected to COVID, what's going to happen is metamask is going to pop up, actually. Yeah. What happens is metamask is actually going to pop up and ask me if I'd like to deploy. So it says, hey, so you're looking to deploy this.
00:32:25.310 - 00:32:57.802, Speaker A: That's great. Here's how much it's going to cost you. It's going to cost you 0.1251 ETH to deploy this smart contract because we need to pay the miners a little bit of money to store our data properly, basically. So the miners are taking this fee here to actually deploy this so we can go ahead and hit confirm. And what's going to happen then is down here, it says creation pending, and we get this little link and it looks like it already. Great.
00:32:57.802 - 00:33:30.450, Speaker A: So we get this link to the transaction and it's being mined. Right? Remember how on that example, before the wheel had to turn, the miners are trial and erroring, creating that nunce for this? And that's what's happening behind the scenes when it's mining. So it looks like it has been included and it will be reflected in a short while. It's usually a few seconds, but. Great. So we can see this is the transaction hash that defines us deploying this contract. This is who it's from.
00:33:30.450 - 00:34:10.500, Speaker A: It's from my unique wallet address, and I'll talk about that more in a second. And then here's who it's to. You can see some more cool stuff. So etherscan is a really popular block explorer, which kind of goes through and shows us all these different things. Now that it's deployed, we can see down here again, we can see that it's deployed, we can see the message string, hello. And if we want to update the string. Since we're actually updating the blockchain, when we update the string, because remember, when we hit this update message function, we're actually setting this message variable to something else.
00:34:10.500 - 00:34:33.278, Speaker A: We actually have to what? We have to pay gas again. So I'm going to set it to Chainlink is the best update message. And again, metamask pops up. It says, I see you're looking to do some computation. I see you're looking to change state of the blockchain. Here's how much gas it's going to cost. So we go ahead and hit confirm.
00:34:33.278 - 00:35:05.726, Speaker A: We get another transaction hash. And you can see again it's pending. The miners are going. I got to figure out that nuns. I got to figure out the nuns. And once it's done, which is probably now, once it's done, we hit message again and we see the string is updated to Chainlink is the best. And again, this is mimicking what would happen on a real blockchain.
00:35:05.726 - 00:35:46.340, Speaker A: So this is metamask. Like I said, we're on the coven test network. If we wanted to switch to Ethereum, Mainnet, this is my test account, so I'm broke here. We could actually deploy stuff on Mainnet as well. So there's a ton of different test nets and there's even like Mumbai, which is matic, you can run a local testnet, but we'll stick with COVID Testnet for now because it's really simple. The way we can get some coven testnet in our metamask is actually, we can just come to a faucet again because I said this is free stuff. It's free to run this stuff.
00:35:46.340 - 00:36:15.034, Speaker A: If you go to the chain link documentation on the link token contracts, there are some faucets for different test nets here, which is really helpful. So for my crypto, it says, hey, give us your address. Pop my address in me. It's connected to your metamask account. So I'll pop my address there. Request assets. I'll do.
00:36:15.034 - 00:36:45.060, Speaker A: LNC submit. And success. The test ether has been sent, so it's going to send test ETH. So send test ether. And same thing again, because we're changing state of our balance, we get a transaction hash that says, hey, we're going to update your balance. Here's how you do that. So before I continue, I'm going to look at some questions.
00:36:45.060 - 00:37:22.150, Speaker A: Sorry, I know I'm going through a lot. Here. Are smart contracts being executed by the miners or is it executed by a separate group of servers? It's all by the nodes. So the miners are validating what every other node, for simplicity's sake. Yeah, the miners are executing the transactions. Do the not equal test nets implement not equal features? Which one should I use? I'm not sure what that question means. I'm sorry.
00:37:22.150 - 00:38:13.220, Speaker A: Um, will gas always cost the same amount? Does it fluctuate? That's a good question, actually. So the gas costs, again, like, when we're in here, actually, when we even hit this and metamass pops up, we can change the gas price. So the gas amount is how much computational effort it takes to run, and then every unit of computational effort, we can kind of set the price. As many of you have seen, for example, we would check out like Etherscan. That's COVID's ether scan. Let's go to mainnet. Ether scan, or ETH gas station.
00:38:13.220 - 00:38:38.124, Speaker A: We can see here kind of the current prices for ethereum. Oh, look at that. Help build chain link. Look at that. That's awesome. We can see kind of the different prices here of how much it costs to make a transaction on the chain. And these prices fluctuate depending on how much network demand there is.
00:38:38.124 - 00:39:11.170, Speaker A: Right. Because only so many transactions could get processed by so many miners. So gas prices do change. That's a good question. If gas prices are higher than when you test, but the smart contract is deployed, does the amount you pay for each execution change? It can, yes, actually. So if gas prices super spike, the amount of gas, or your total computation will still be exactly the same, but the gas price might actually change. That's a good question.
00:39:11.170 - 00:39:34.170, Speaker A: All right, cool. Great questions. Keep them coming. Keep them. Absolutely, keep them coming. What does deploying mean? Deploying is when we actually put it on chain and then we're going to go into oracles. Do I need to go over anything else? Oh, the other thing, actually, that we're going to need.
00:39:34.170 - 00:40:02.288, Speaker A: We're going to need a chain link token from the chain link faucet. So what we're going to do is same thing. We're going to come place our address in here, hopefully. I'm a human, send me 100 test link. Now, I've already added it to my metamask, but they actually don't show up right away. What you actually have to do is hit add token, custom tokens, and then add the link. Token address.
00:40:02.288 - 00:40:41.970, Speaker A: I already have it, but we're going to go ahead and show you anyways in order to see your actual balances again. I already have mine here. We have to go. Add token, custom token. Add it here. Token has already been added because I already added it, but normally like Link will show up here, you'll hit next and then you'll be able to see the assets down here. So we need this to interact with chain link orgles, which we probably won't get to today, but having both ETH or matic or Moonbeam or DSC or whatever token that you want in there, that's really important.
00:40:41.970 - 00:41:35.264, Speaker A: All right, cool. So why are Oracles important? So as we see here, we can kind of interact with the smart contract. We can do stuff, we can have fun, it's grand old time, but what we can't do is we can't actually get access to the real world. And I'm going to be going over why Oracles are so important and why chainlink is so important later today in our everything chain link workshop, which is tonight at 430 Eastern, I believe. So I'm not going to go into that too much now, but we will go over it later today. So I do want to do want to show you guys this though. So here's kind of a bigger smart contract that we're going to work with right here.
00:41:35.264 - 00:42:11.470, Speaker A: We'll probably also go over this later today. So a few other things with this is that we're actually importing now. So importing, we're importing this aggregator V three interface Sol from the chain link smart contracts. And what this does is it takes another contract and sticks it at the top of our solidity contract here. That way we can use the different functions, we can use the different variables in this other solidity smart contract. Plopped it right at the top of this solidity smart contract. So this is incredibly useful for us.
00:42:11.470 - 00:43:02.776, Speaker A: Let's talk about what's happening in this smart contract. So this is an example of a smart contract that actually, if we use this, if we use this JavaScript VM, this stake virtual environment, we actually wouldn't be able to do any, we wouldn't be able to interact with any smart contracts. We wouldn't be able to interact with any smart contracts that are actually on chain. And this is an example of smart contract that we do want to interact with things on chain. So if we go ahead and try to deploy this, sorry, let's compile real quick. If we try to deploy this to the JavaScript VM, we're going to get our function and it's not going to do anything and it's going to be like what are you trying to do? You are crazy. So we are going to have examples of smart contracts that need to be connected to other smart contracts somehow.
00:43:02.776 - 00:43:50.892, Speaker A: So we actually do need to deploy them to the testnet that's specified. So this one obviously is for COVID, right? So now if we deploy it to COVID like I just showed you, now we hit get latest price, we actually get a response here. So it's important to know kind of the difference between injected web3 JavaScript VM, again, injected web3 you're deploying to a real chain, whether it's a testnet or a main net chain, and then it's defined by whatever you're on here. JavaScript VM is kind of like a fake pretend environment, which is really good for testing stuff quickly. But if your contract specifies that it needs to connect to things, it won't work. And then web3 provider is kind of your own web3 provider. It's not injected web3.
00:43:50.892 - 00:44:18.710, Speaker A: Again, it's coming from Metamask. And then web3 provider is kind of like whatever you specify, which we're going to go ahead and not do that. But let's look at some of the other things in this remix. Actually, let me ask a couple of questions. Answer a couple of questions. Whole proof of stake validate that might be a longer conversation. What is gui? Okay, this is actually a good question.
00:44:18.710 - 00:44:54.752, Speaker A: It's actually a really good question. So ether, or ETH is divided. Well, the smallest amount of one ether is one way. So this many ways equals one e. You can think of it like 100 pennies equals a dollar. This many way equals an ETH. And guay is just kind of like the midpoint basically.
00:44:54.752 - 00:45:42.210, Speaker A: So this many guay equals this much way, which equals this much ether. So one way is equal to zero, one ether. The reason that this is important though is because solidity and smart contracts can't understand decimals. So when we specify like an amount, we actually need to specify it in way. The reason that you hear guay so much is because oftentimes the cheapest gas price is going to be in guay. So for example, if we go back to the ETH gas station, we have 137 guay, 160 guay, 161 guay. So we can even copy this.
00:45:42.210 - 00:46:23.852, Speaker A: Excuse me. So when we say the price is 137 guay, we're really saying the gas price is 00137. And the way that I kind of remember this, like how many zeros to put in is, I usually just count 18 zeros. So I'll go 1234-5678 910, 1234-5678 and I go, okay, so this is one e. So it's 18 zeros. 18 zeros is something to remember. GwE has 123-45-6789 like I said, it's the halfway point.
00:46:23.852 - 00:47:00.692, Speaker A: So 18 zeros, nine zeros, no zeros. That's actually a really good question. Okay, where's the link for the documentation reared from? It'd be helpful to fall along the way. Good point. So I bounce all over the docs because I live in the docs. Let me post. I just posted the documentation.
00:47:00.692 - 00:47:32.608, Speaker A: This is kind of the beginner tutorial. It'll take you through literally everything that you need to know. Awesome. And it will do this first chain link smart contract, which is really powerful here too. So let's actually even go back to that other chainlink workshop. Sol let's go ahead and write a new function, right? Let's do a function called add do function. And then we have twelve minutes left, so good time.
00:47:32.608 - 00:48:00.910, Speaker A: So we'll call function add, right? So we're going to create a new function and we'll call it add. And we'll do this on the JavaScript VM because we're not going to interact with any other contracts. So we don't need to use COVID or anything. We can spend a little bit quicker. So we have our function add if we go ahead and hit save now. And actually let's even just start scratch, start from scratch. So we have a function add.
00:48:00.910 - 00:48:25.472, Speaker A: If we hit save control s or compile, you'll see we get this error. Syntax error, no visibility specified. Did you intend to add public? Yes, I did. Thank you so much. So public means that anybody can call this. If we go ahead and deploy this now we'll see. We have this function add here.
00:48:25.472 - 00:49:12.224, Speaker A: If we were to go ahead and make this like private or internal, and then we deployed it and then we deployed it, you see we have nothing here now, right? So public means that people can actually interact with it. There's also external, internal. You guys can read more about those. So what do we want our ad to do? We're going to create a global number, a UN 256 public number. So we're going to create a global variable called number. UN 256 stands for unsigned integer, which means it's an integer that isn't signed, so it's not like a negative or positive 256. We could also just do this 256.
00:49:12.224 - 00:49:38.730, Speaker A: This is kind of like the size of the integer. So it's UN 256 public number. And if we go ahead and deploy this now, we'll see that we have this number which gets initialized to zero and we'll have our add function which doesn't do anything right now. So we have number which is zero. Let's go ahead and make this add thing do something. So we'll do number equals number plus one. And then you need to add this semicolon at the end of these.
00:49:38.730 - 00:49:55.424, Speaker A: Let's go ahead and compile this. Compile. Let's delete our old contract here. Let's deploy it. Now we have number, which is zero. And now add should do number equals number plus one. So if we hit add, this should be one.
00:49:55.424 - 00:50:32.372, Speaker A: After we hit it, add one, add two, add three, boom. And so now we have a really simple smart contract that can add stuff, which is nice. A couple of comments. Now there is 18 zeros. Yes, one guay is ten raised to the 9th. What would the closest language to solidity be? So I think it's Java or JavaScript. I think those are both pretty good, but it's really any kind of object.
00:50:32.372 - 00:50:56.812, Speaker A: Yeah, Java, JavaScript, it's really any object oriented programming language though. I mean even Python is pretty similar. It's just this has like semicolons and stuff. I think even go is similar. Probably Java or JavaScript though. Good question. Do smart contracts support vectorized operations? That's a good question.
00:50:56.812 - 00:51:18.690, Speaker A: I mean you could probably build stuff to do that. That's a good question. I'm not entirely sure. Solidity is strict type system. Yes. So solidity is a statically typed language. I can't do like public number, right? I have to specify the type.
00:51:18.690 - 00:52:05.170, Speaker A: Would you recommend learning Java before solidity? No, I think having some object oriented programming experience is definitely good and definitely really important. Would I recommend learning Java before solidity? I think having some object oriented experience is definitely going to be helpful, but it's not required. What is external public view in solidity? Good question. So public means anybody can read it. Actually we can just do visibility solidity. Actually, let's go to the docs. So the solidity docs are really good.
00:52:05.170 - 00:52:40.620, Speaker A: Let's go to the latest version, private, and then it says everything right here. Functions have to be specified as being external, public, internal, or private. For state variables, external is not possible. External functions are part of the contract interface, which means they can be called from other contracts via transactions. An external function, f, cannot be called internally. IEF does not work, but this f works. External functions are somewhat more efficient when they receive large arrays of data, because the data is not copied from call data to memory.
00:52:40.620 - 00:53:11.780, Speaker A: Public functions are part of the contract interface and can be either called internally or via messages. Internal these functions and state variables can only be accessed internally without using this. Private functions and state variables are only visible for the contract. They are defined in and not derived contracts. So hopefully that answers that question. So this is really kind of the really simple, like welcome to smart contracts. Welcome to Solidity.
00:53:11.780 - 00:53:50.988, Speaker A: We have some really fantastic tutorials in here this beginners tutorials, the basics. If you don't know anything and you want to deploy a smart contract that uses Chainlink like follow this, this is going to get you set up really quickly. We're going to teach you about remix. This is really the place that everyone, well, I think everyone brand new to the space should start. It lets you kind of visualize and work with everything really easily. Once you get comfortable here, then you'll want to move to like a hard hat, a truffle, a brownie. These are smart contract deployment frameworks which you can use in your code editor.
00:53:50.988 - 00:54:39.570, Speaker A: That's not kind of in this online ide, but I think if you're just going to start out, this is definitely where you want to start out. You can even build pretty much your whole project here. Obviously you want to do a front end as well. Putting a front end would need to be done kind of in your environment, but you can really build entire blockchains, entire projects in remix if you want. But I think the more sophisticated environments are going to be once you move to hard hat or truffle or brownie, whatever. What if ethereum? That's a super biased question. What would you recommend as an ID to check your programming errors? Bug fix.
00:54:39.570 - 00:55:12.588, Speaker A: So I think remix is a decent place to start, even though I just said you really want to move off of it. But you can also, I use visual studio code a lot. I really like visual studio code. I think Adam has an interesting plugin that you can use if you're familiar with Adam, that works really well with solidity. But I think visual studio code is good. I mean, they have solidity plugins as well. And then you just do hard hat compile or brownie compile or truffle compile or whatever.
00:55:12.588 - 00:55:30.240, Speaker A: It'll show you all your errors too. Good question. Thanks for sharing. Yeah, for sure. That's most of what I wanted to bring you guys through. What is a blockchain? What are smart contracts? Intro to solidity. Intro to remix.
00:55:30.240 - 00:55:51.960, Speaker A: Yeah, I'm here for questions. Now, for the rest of the time here, what is an Abi? Good question, actually. So every smart contract has two really important things for interacting with them. So they have an address and actually, I didn't talk about this. They have an address, for example, right here. Actually. Let's deploy something to coven's ether scan.
00:55:51.960 - 00:56:14.352, Speaker A: So injected with three. We're going to deploy this to COVID and we're going to get our coven transaction here. Cool. It looks like it's done. Got our transaction. So each contract has an address. It's this thing.
00:56:14.352 - 00:56:35.260, Speaker A: It's obviously truncated. We can copy it by hitting that copy button. But then we can see all the interactions with our contract. Here we see there's only one transaction, which was the contract creation. We can go ahead and do this add thing now. Confirm and we'll see in our contract address on Etherscan. If we refresh.
00:56:35.260 - 00:56:59.416, Speaker A: There's a pending transaction going on right now. So the address is the first thing. We didn't know. We didn't know where this thing is. Right? So this is where this smart contract is. The other thing that we need to interact with it is we need the ABI. If you go to the contract, since this isn't verified right now, it's just a ton of jarble, right? Like a human can't.
00:56:59.416 - 00:57:32.120, Speaker A: I don't know what that means. If someone was like, hey, can you call a function in the smart contract and they send me this? I'm going to say, I don't know what we're talking about. There's nothing to me that don't mean anything to me. So what we need, and computers do the same thing. They come to here and they go, okay, cool, so how do I work with this? What do I do? So what we need is the Abi. The ABI is the application binary interface. And I believe remix actually has a way to grab the ABI.
00:57:32.120 - 00:58:03.072, Speaker A: Unless they got rid of it. Is this it? Nope, I'm drawing a blank. I forget how to get the ABI here. Abi. Boom, right here. So this is an example of an ABI. We'll commented it basically, like I said, it's the application binary interface.
00:58:03.072 - 00:58:38.464, Speaker A: And it defines how to interact with this contract, right? So we see we have this function called add. It takes no inputs, no outputs. It doesn't have a return type. It's non payable. And this is all we need to know to interact with this add function. We also have this number variable, right? And we see it does have outputs. It returns a Uint 256, which is really cool.
00:58:38.464 - 00:59:05.444, Speaker A: It's a view function. You'll learn about that a little bit later. But to interact with contracts, you need their address and their ABI remix already kind of handles that for us. And you'll see having the ABI is really important when kind of moving off chain when working with visual studio code and whatnot. So that's a really good question. Stands for the application binary interface. This is one what looks like, and it defines how to interact with your smart contract.
00:59:05.444 - 00:59:40.640, Speaker A: And it's really important for building really cool stuff. Last part isn't a great explanation, but yeah. What if I write a contract and somebody else calls a function in that contract to modify it? Wow, that'd be horrible. Right? We don't want that so we can actually add on what's called access controllers. So there's this thing called a modifier. In solidity, one of the most popular modifiers to make is called only owner. And I'm not going to go ahead and make it right now.
00:59:40.640 - 01:00:03.092, Speaker A: But you do like modifier. Actually, I'm not going to make it right now. And what it does is it means only the owner of this smart contract can call this function. So these are called access controls. And you can make access controls on your function. An easy way to do it would be require. This is something that runs in solidity.
01:00:03.092 - 01:00:49.156, Speaker A: Require message sender equals equals owner. And then we would set like address public owner. I guess I am going to make it then constructor public message sender equals owner. Okay. I guess I am just going to basically make it so. Oh, backwards. So what this would do, I know I just kind of coded a whole bunch of stuff and I know we're at time is it would set this owner variable to message sender.
01:00:49.156 - 01:01:28.688, Speaker A: So this is a keyword in solidity. We're saying whoever called this function, it's going to be the message sender and we're going to set that person up to be the owner. Then in this add function we have this require method which says this needs to be true in order to keep moving forward. We're requiring whoever calls this add function again, this is the new message sender has to be the owner. So this is a way to add access control so that only the owner of this smart contract can actually call the add function. Good question. Isn't chain link blockchain agnostic? Yes, it's very blockchain agnostic.
01:01:28.688 - 01:01:52.748, Speaker A: So I can't imagine that migrating to a different chain wouldn't be impossible. Yes, it's blockchain agnostic. You can work with any chain where Chainlink is, I would say check out the docs to kind of see where stuff currently is. Is there a good end to end course for solidity? Who's already familiar with Java. I think there's a great one on udemy, the ultimate guide to solidity or something like that. I think that one's great. I think cryptozombies is very good.
01:01:52.748 - 01:02:26.712, Speaker A: DAP University has some good stuff as well. There's a lot of good courses out there. What are events logs and states? I don't have enough time to go over that, but that is a great question. Is Dep University offering some deals? They are. They're actually offering some winning prizes if you win. So if you're looking to learn more about celebrity after the hackathon, definitely apply to the depth university prize. Is it possible to make curl requests through chain links on a smart contract? Yes.
01:02:26.712 - 01:03:05.652, Speaker A: Go to our workshop tonight and we will teach you. How do I implement an ERC 20 token? That is a longer question than what this has time for, but I would say check out open, check out open Zeppelin's ERC 20. Check this out. This will pretty much give you what you want to know. If you can do a walkthrough of what does a link node usually do, that will be tonight at 430. So we are past time, everyone. Thank you for your questions.
01:03:05.652 - 01:03:26.664, Speaker A: Thank you for coming. Thank you for asking such fantastic questions. If you have more questions, feel free to leave them in the discord as well. Really looking forward to seeing what you guys built. If you're just getting started here, you've come to the right place. We didn't go too deep into solidity or smart contracts. We really just kind of showed you the main tools that you're really going to want to use.
01:03:26.664 - 01:03:54.704, Speaker A: And again, if you're brand new, if you're like, what is going on? Check out those chainlink engineering tutorials on the chainlink YouTube that will walk you through step by step. Some really easy ways to do on they are using Robston. We will be using coven for most of the example. So if you want to stay easy, stick with coven. But the docs here also walks you through step by step, everything you need to know. So feel free to just start with this. Beginners the basic.
01:03:54.704 - 01:04:09.970, Speaker A: This will also get you going. So awesome. Thanks everybody so much and we'll talk to you soon. Once I learn how to turn this off, I hear.
