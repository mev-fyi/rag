00:00:00.810 - 00:00:05.694, Speaker A: Aaron to go live says we're streaming. Oh, hold on. It doesn't actually stream right away. You got to.
00:00:05.732 - 00:00:07.360, Speaker B: Oh, this is fake. These are.
00:00:13.650 - 00:00:17.662, Speaker A: We might be up now. Iron to go live. Okay. We are going live.
00:00:17.716 - 00:00:20.110, Speaker B: Okay, we're live now. We're live.
00:00:20.260 - 00:00:21.118, Speaker A: And we're live.
00:00:21.204 - 00:00:23.022, Speaker B: Awesome. I'm ready.
00:00:23.156 - 00:00:26.438, Speaker A: All right, cool. I'll post a tweet out as well.
00:00:26.524 - 00:00:27.174, Speaker B: Yeah, let me.
00:00:27.212 - 00:00:31.190, Speaker A: Hit me with something to retweet live with at Austin.
00:00:31.690 - 00:00:43.754, Speaker B: I kind of like the idea of doing some introductory solidity stuff. Just like kind of getting our footing, kind of getting a feel for writing some smart contracts and then. Absolutely. Oh, yeah. Here we go. Got it.
00:00:43.872 - 00:00:47.194, Speaker A: Excellent. Retweet people are coming.
00:00:47.232 - 00:00:47.914, Speaker B: Here we go.
00:00:48.032 - 00:00:52.406, Speaker A: I'll be monitoring the comments for us. We're good to go. Let's do it.
00:00:52.448 - 00:00:54.110, Speaker B: Bow tie. Let's do it. Okay.
00:00:54.180 - 00:00:56.302, Speaker A: Actually, maybe we should give it a couple of minutes. Give it a couple of minutes.
00:00:56.356 - 00:00:58.590, Speaker B: Okay. Hello.
00:00:58.660 - 00:01:04.706, Speaker A: Welcome, everybody. We're doing a little warming up. We're warming up.
00:01:04.728 - 00:01:09.026, Speaker B: Waiting for stirring the cauldron during the pot. Yes.
00:01:09.128 - 00:01:11.550, Speaker A: We're going to cook us up some sick solidity.
00:01:11.710 - 00:01:13.380, Speaker B: Yes. That's right.
00:01:15.670 - 00:01:16.660, Speaker A: Love it.
00:01:17.350 - 00:01:24.040, Speaker B: Awesome. Should I make sure I can share my screen? I'm sure I could share my screen. We're good. Yeah, we're ready. Whenever you're ready.
00:01:24.730 - 00:01:26.454, Speaker A: Let a couple of people roll in.
00:01:26.572 - 00:01:27.522, Speaker B: Sounds good.
00:01:27.676 - 00:01:38.602, Speaker A: We have rolling in. Rolling in. Oh, my God. These back to back workshops. Okay. The discord is rolling in, too. Okay, people, rolling in.
00:01:38.602 - 00:01:40.254, Speaker A: Awesome. All right. Yeah.
00:01:40.292 - 00:01:40.542, Speaker B: Awesome.
00:01:40.596 - 00:01:44.122, Speaker A: Let's do it. Let's talk. Let's do some scaffold ething.
00:01:44.266 - 00:01:46.666, Speaker B: All right. It's time to scaffold ETH.
00:01:46.858 - 00:01:47.886, Speaker A: I believe it is.
00:01:47.988 - 00:02:30.698, Speaker B: Cool. Awesome. All right, so programming in Ethereum is hard, right? There's so many tools. The mental model is so rough that the idea here is let's have something that's freestanding, let's have a Dap that's standing on its own, that works, that has a smart contract back end and a react front end, and they're all glued together real nice. But this allows us to just make small changes, make small changes in the solidity, make small changes on the front end. And we're going to do some of that today and really just kind of like go through prepping someone with a very early project. But then we kind of get weird with it toward the end and see if we can integrate maybe some VRf or something like that.
00:02:30.784 - 00:02:59.294, Speaker A: Yeah. For everybody who is watching, Austin Griffith is fantastic resource. He makes awesome content on solidity and Ethereum and everything. We're going to be going through his scaffold ETH right here. And as he was saying, it's a great way to kind of tweak things and visualize things. And a lot of you who want to submit like a cool project, but aren't really sure how to connect to a front end, this is a wonderful tool to help really visualize everything and see stuff there. So we're going to be going through scaffold ETH.
00:02:59.294 - 00:03:11.100, Speaker A: And like he was saying, if we have some time towards the end, we're going to mix it up, do something weird with Chainlink. But I know everybody here is kind of like looking to get their bearings with solidity, and then we'll start there.
00:03:11.550 - 00:03:28.042, Speaker B: Okay. Yeah. So I'm at Austin Griffith. You can hit me up on Twitter, slide into the DMs with questions. There's a great chat room for scaffold ETH. Lots of great chat rooms for all of Ethereum all over the place, too. We're a very decentralized ecosystem.
00:03:28.042 - 00:03:58.182, Speaker B: But come find me in the Austin corner. So this is Scaffold ETH. If you Google Scaffold ETH, you will end here and it will just redirect you to the repo, because this is what you need, is the repo right? You can watch some content. I've kind of done an introductory stuff, but just to dive in, I'm just going to set it up locally and we'll get you set up. You will need node and yarn and git, and you'll probably have to wrestle with that node version a little bit. Usually node twelve is the way to go. I have like a couple of installers just like sitting on my desktop ready to go.
00:03:58.182 - 00:04:23.018, Speaker B: Hey, do you need node twelve? Oh, maybe you need node ten. So there is some set up, but go for node twelve. We're going to clone down scaffold ETH. We're going to CD in and we'll yarn install and then a yarn start and a yarn chain. So yarn start is going to bring up that front end. It's going to be a react front end. And then yarn chain is going to bring up a blockchain for you powered by hardhat.
00:04:23.018 - 00:04:40.198, Speaker B: This is kind of a special blockchain that gives us some extra inspection into what's going on. You could do things like console logs, you can see stack traces and they just do a good job of exposing what's going on. All right. And then finally we're going to do a yarn deploy. Oops. I closed my window. Bring it back.
00:04:40.198 - 00:05:04.810, Speaker B: We're going to do a yarn deploy, and that will deploy our example contract. And it also takes the artifacts, once it's deployed to our chain and inject it into our front end. So we kind of see this full loop happening and then our front end will reload and we have a new contract. So let's just do that again, nice and easy. A nice yarn deploy. Watch your contract over here in the front end. We should see a new one.
00:05:04.810 - 00:05:24.162, Speaker B: E seven, f one, come up over here. We should get a new address. There we go. So you kind of get in this mode where you can kind of just iterate where you've got your smart contract here. And let's bring that up a little bit more. And if we look at the scaffold e three repo, it's going to kind of just like walk us through some learning solidity. Right.
00:05:24.162 - 00:05:27.958, Speaker B: So first of all, you've got. Yeah, let's go for sure.
00:05:28.044 - 00:06:01.006, Speaker A: So everybody who's watching, who's kind of like a little bit newer, what you see on screen right here, this yourcontract soul. This should obviously look pretty familiar from the remix that we did before. It's a really simple contract. He's using this package called Hardhat we see at the top. It says import hardhat console Sol. It allows you to do console logs and basically print statements in your smart contracts. And different from remix, he's actually compiling everything locally on his machine using hard hat, which is really cool.
00:06:01.006 - 00:06:31.062, Speaker A: And you saw that with yarn, I think it was yarn compile or yarn deploy or whatever he was doing. Those are like node JS syntax. So you do need node to work with this and to compile everything. But he does have in his repo, he's got a sick readme that you kind of follow step by step that will go over everything there. But yeah, you will need node JS, but it just compiles your smart contract. So if you're like, wait, I'm not familiar with Node JS, I'm a little confused. No worries.
00:06:31.062 - 00:06:52.270, Speaker A: Go into the contract. Use that to fiddle around, install node, do follow steps. Yarn deploy or, excuse me, yarn compile, yarn deploy. And you'll see it rendered on a front end so you can kind of interact with it and be iterative there. So I got a question here. Can you explain what scaffold ETH is? We just did a quick explainer. It looks like you showed up a little bit later.
00:06:52.270 - 00:07:27.254, Speaker A: Scaffold is a great tool to iterate over testing, deploying smart contracts and working with smart contracts. Once you run, as you see here in this interface, it's showing his contract a really minimalistic view of it, but in a visual sense. So we can actually create front ends for our projects, right? Because when we actually submit projects, we want them to look nice, we want them to have a front end. We want them to be usable by people other than just engineers. So basically, it's for the purpose of making development and buggy easier. Austin, what would you say? Is it for the purpose and building apps?
00:07:27.382 - 00:07:45.578, Speaker B: So it's a freestanding app, right. It's a decentralized app in a box. And so you can get over here and we can write this. Oops. You can quickly iterate on some solidity, right. I just put in it, while you were talking, I put in a counter, I set it to five. I put in a new function called decrement that's going to decrement that counter.
00:07:45.578 - 00:08:11.098, Speaker B: And so now we're going to see that this interface will change, right? So going back to just like hello world here, when I call set purpose here, it's going to trigger a console log. And we should see over on our chain that I triggered that hello world. Oop. I didn't have enough funds. So first thing you want to do, hit this big call to action right here and grab some funds from the faucet. Second thing, hit that hello world purpose. And there we go.
00:08:11.098 - 00:08:41.954, Speaker B: So I'm actually crafting up a transaction. I'm sending it to my smart contract. I'm updating some storage variable in this set purpose. I'm setting this purpose and we're console logging. So when you're in your solidity and you're screwing around and something's not working right, you can kind of set up a console log and you can come over here and see it. So it is good for just debugging and testing. But also you're going to have a freestanding app by the end of this and you can deploy this thing as like here is not only the token I just deployed, but the app to interface with it.
00:08:41.954 - 00:08:44.030, Speaker B: And I can push that out to a public server.
00:08:44.110 - 00:08:51.554, Speaker A: Yeah. So the commenter Nick said it's a basic ready to go Ethereum application with react front end. So it's like, yeah, exactly. I think that's.
00:08:51.602 - 00:09:37.986, Speaker B: And hard hat back. So, so now we're kind of tinkering around, right? We've kind of got our basic anytime we want, we can do a yarn deploy and we're going to get a fresh contract and we've got our contract here. Now let's just think for a second. Like what does ethereum look like? Right? A lot of people want to put it in. It's like boxes that are pointing to each other. But I think a better way to think of it is it's a decentralized set of machines, right? If we think of decentralized machines all over the world when we want to deploy this contract, the mental model here is like we put a transaction out there and it gets mined in a chain. But basically now every node, every server on thinking of our back ends right now we have like this giant mess of thousands of back ends that all have the exact same copy of our back end.
00:09:37.986 - 00:09:57.254, Speaker B: And when we want to set this purpose, we have to get a transaction. Mining, we have to pay for it. And all the miners on the network have to update that. All the nodes on the network have to update that value. So it's like this weird distributed database that's really expensive, but we get some really neat things out of that settlement layer. So we're sending a purpose. We're setting a purpose.
00:09:57.254 - 00:10:39.350, Speaker B: Let's see what this counter does, right? I put this counter in here and I've got it set to five and I've got this decrement function and I'm slowly decrementing what's going to happen when I get to zero. What if I go one more? What is going to happen? Right? We have to think of this little machine that's out there that everybody holds. It's like this real intricate thing. And when I turn that dial one more time, 255, we get underflow, right? It's a demo I like to do all the time, kind of show what's going on with those bits under there and kind of get a feel for you're kind of building this little execution, this little state machine over here. And it's expensive, but it's really cool and powerful. Then you've got your front end and you're interfacing with that device, that back end. Smart contract.
00:10:39.350 - 00:11:13.042, Speaker B: So let's dive in here and let me maybe look through some solidity. Just kind of like take it easy with solidity, but go through, I think maybe like a mapping might be the next thing we look at. We figured out we've got uns, right? If I put this un in here and I use 256 bits instead of eight bits, and I redeploy that and I re underflow it, we're going to get a really big number, right? So un eight means we're going to get a 255. Un 256. It's going to be a gigantic number. But let's test our assumptions, right? Let's make a small change. Let's come over here and let's decrement down to.
00:11:13.042 - 00:11:26.006, Speaker B: Oh, get out of here. Gigantic number, right? Like, bigger than I can display. Cool. Awesome. So I'm thinking maybe mappings next. Anything you think. Is that.
00:11:26.006 - 00:11:32.874, Speaker B: Okay, Patrick? We just kind of, like, I've got this learning solidity section, and I think we could just kind of go into it a little bit.
00:11:32.992 - 00:11:39.450, Speaker A: Yeah, we can rip through some. I think that'd be helpful. So we got another question. Where do you change the front end of the app? Maybe we'll get.
00:11:39.520 - 00:11:59.038, Speaker B: Okay, let's do that real quick. So your back end is kind of like your contract, your front end, and this is in the repo. It kind of explains this right as you get started. But the front end is an app, JSX. So you'll have. Let me just shrink everything down. So we're down to, basically, you've got three packages.
00:11:59.038 - 00:12:14.434, Speaker B: Hard hat is your back end, and react app is your front end. And then there's some subgraph stuff there, so you can use the graph eventually to parse your events. It's there for you when you need it, but not yet. We don't need it yet. We'll just fire events. Right? Okay. And then source and then app JSX.
00:12:14.434 - 00:12:36.058, Speaker B: So there is our front end. And so if we wanted, this is just like a contract object, we could come down here and find that contract. And let's just put an H one of hello in there just to prove that we've got a front end here and we can kind of make it. What did I do? What does that have to go inside the route?
00:12:36.154 - 00:12:37.680, Speaker A: No, other way.
00:12:39.410 - 00:12:58.230, Speaker B: Come on, man. Come on, dude. First HTML I overwrote, I think it was in a Claris works kind of thing, in the mid 90s. You would think I'd get my H one, right. Here we go. I think we got to do h. I think it's got to be a lowercase.
00:12:58.230 - 00:13:17.574, Speaker B: There we go. Now we're going to have a nice hello there. But this is the magic here. This contract object is automatically updating to whatever new things we add to our. Now we have a hello in there for some reason. Okay, let me carve that out, and let's go back to our smart contract. Now we've got our front end, and we can do some front end stuff.
00:13:17.574 - 00:13:44.866, Speaker B: We can set up some buttons, but this kind of scaffolding is here. For us at first, so we can get our footing and we can kind of understand what we want our solidity to look like. And we put in a counter and let's go ahead and take out that counter and go ahead and redeploy and it should clean that stuff up. So back to learning solidity. We've got primitives and data types. If you're a programmer coming into the space, these are going to look pretty familiar to you, right? You've got a bool and it can be true or false. You've got un eight s and un two hundred and fifty six s.
00:13:44.866 - 00:14:01.610, Speaker B: And we've seen how you have to be careful about those overflows. In solidity 8.0, it'll revert on that overflow. Or if you use a safe math library, it will revert on that overflow. So you can protect yourself from that with some libraries. But this is a real interesting one. Look at this address.
00:14:01.610 - 00:14:28.100, Speaker B: They've just got a zero X, just hexadecimal just thrown in there willy nilly. We've got no quotes around it. All we've got is this address. But this is really cool because what we can do is, I can say, okay, let's set up a public address owner, and let's just set it equal to yes, I'm going to grab my funding address. I'm going to paste it in and just hit save and hit go. And what we should see is a new owner show up. What did I do? Public.
00:14:28.100 - 00:14:48.066, Speaker B: Oh, address man. Public owner. And let's not do public first. I'm doing it. If you don't put that public in there, it's not going to show up on the front end. So it's not like it's private because this is a public blockchain. Everything's public but public as in the access for the app to access your smart contract.
00:14:48.066 - 00:15:12.206, Speaker B: So here we go. We've got owner and now it's me. And what if I don't even know? Okay, let's talk accounts real quick. So in scaffold ETH, you have an account in the top, right, and that's auto generated for you. So if I open up an incognito window, we should get. Look at that, a new account. So you get an account on page load and let's send some from one account to the other.
00:15:12.206 - 00:15:47.482, Speaker B: I'm doing a bad job here. Okay, so let's see, let's copy this guy's address and let's pull up this wallet. So kind of like, why scaffold ETH in your front end. When you're building an app for a hackathon, say you're going to have an address input, right? You're going to need to take in someone's address. Wouldn't it be nice if that just did Ens resolution out of the box? If that did reverse resolution out of the box. If you could hit scan and scan a QR code, right? Like you just want an address input that does this. So when I paste in here, this address, I can clearly visually line up that blocky and say, yeah, for sure, that's that person.
00:15:47.482 - 00:16:11.278, Speaker B: And then maybe I want to send $5. You can switch it back and forth between USD, but it's just a nice to have this kind of box here where I can just say, yeah, Austin Griffith, $5, shoot it. And there we go. We see $5 show up over here and that button kind of disappears. Now, this guy can also interface with the contract, right? Cool. Okay, so this address is really interesting. What we can do is set up a rule.
00:16:11.278 - 00:16:49.486, Speaker B: So now that we're tracking this public address owner, let's set up our first rule in here. And let's require that the message sender, which we'll get to, it's basically a global variable. It's whoever's accessing our function has to be equal to the owner or we're going to throw a fit and say, not the owner, and everything will break. Right. It will all revert. All right, so now what we've done is we've crafted a contract where only we can set the purpose and we're going to get in there and we're going to set it. We're going to use this kind of bad guy over here, this second incognito window, and make sure that user can't set it.
00:16:49.486 - 00:17:17.590, Speaker B: But just like very simple stuff to get our footing, we should be able to set this right. And if I come over here and this is a different dude, this guy can't set it right. We should get some error that we're not the owner. Cool. So there's our first rule, our first require statement. I'm thinking we'll do a require, we'll do set value and we'll bring some money in and have someone set the value. How are we doing here, Patrick? Any big questions or should we just hammer away at that?
00:17:17.660 - 00:17:21.670, Speaker A: We're doing good. Yeah, I'm answering questions as they come along. You're doing well.
00:17:21.820 - 00:17:39.118, Speaker B: Awesome. Great. Okay, so what we're going to do here is we're going to say instead of message. And by the way, let's dive into that message sender, global units, right? So if you go to the scaffold ETH, repo or you just Google global units for us. Oh, it's not even here. I thought I had a link here. Maybe it's down here.
00:17:39.118 - 00:17:50.066, Speaker B: Yeah, here we go. Solidity by example. There it is. Solidity. Globals and units. You're going to have these global units. You can use things like one ether to define that.
00:17:50.066 - 00:18:32.634, Speaker B: It's one to the 18 way, and we'll dive into that in a second. But you also have all these global variables. Whenever you're executing inside solidity, you have all this cool stuff like message sender, whoever is the address that's getting into your function, or message value, how much money they sent in. Or maybe you could do message timestamp, right? They sent in this much money at this timestamp and they're withdrawing it over here at this timestamp. Let's calculate some interest that they earned or something like that. So we've got these globals and we're in here in our smart contract and we're saying instead of message center, we're going to check the message value this time and we want it to be greater than or equal to 0.1. And I'm going to use another keyword there, ether.
00:18:32.634 - 00:19:06.634, Speaker B: So now I could put this in in way and we'll get the mental model in a second, but I'm just going to put it in in ether. And the other thing is we need to make this function payable. So things in solidity are safe addresses you can't just send money to until you make them payable. Functions you can't just send money to until you make them payable. Even contracts, if a contract doesn't have a receive function, I before e, except after C. There we go, the French. If it doesn't have a receive function, then it's not.
00:19:06.634 - 00:19:32.094, Speaker B: What does this need to be? External payable. If it doesn't have this function, this contract can't even accept funds. If we were to try to send money to this contract, it would fail until we put in that receives. So we're going to put a payable function in. We're going to say this function can accept value and we're going to ship it. Let's see how we do. Compiling, compiling, deploying.
00:19:32.094 - 00:20:01.286, Speaker B: It should deploy over here. Now we're going to have an owner. And now we all see that a new transaction value thing. Okay, so we're not the owner, but we should be able to set this if we're willing to spend 0.1. And how much do we have? We have barely enough, but we should have enough. So you as the developer, there's a button here where you have to take that times ten to the 18. It's a clunky button, but I make you do it in this scaffolding.
00:20:01.286 - 00:20:37.014, Speaker B: I want the developer to have to hit that clunky button every time, to have to take it two way, because that's what the smart contract wants to see it in. So if I were to bring that over here and I were to paste that in right here, it's the exact same thing, right? So I can have this or I can have this same exact thing. But if we're humans, we want to read it like this, right? A human, if we had an extra zero in here, would notice right away. So we're going to have it in a decimal form with ether after here. But when we send it into those machines, they're intricate, small, little evm babies. They got to go everywhere and they got to execute correctly. They don't want to f around with floating point numbers.
00:20:37.014 - 00:21:04.458, Speaker B: So we've got this giant whole number here and there we go. We send and we set the purpose. We paid for it, right? Something really interesting has happened here. This third party, random rando. All they had to have was an Internet connection and a little ETH, and they were able to set this purpose and pay for it. Now, something else interesting has happened. Our contract now holds value, right? Ethereum is like the greatest massive multiplayer RPG ever created.
00:21:04.458 - 00:21:46.874, Speaker B: And now our contract is just another player in the game, right? It's this vending machine in the sky that anyone can access. And if they're willing to pay for this, they can update the purpose, whatever that means, right? It was like a personal attestation thing, and now it's more like a public vending machine attester or something like that. But now we've set up payable functions. One last thing we need to do here is we need to create. Our money is stuck in here, right? We need to create a withdraw function that only the owner can call, right? So I'm just going to copy this line here. We've already kind of tested it and we're going to make sure that the owner is there. And then if so, we're going to do a message sender.
00:21:46.874 - 00:22:10.882, Speaker B: Watch this transfer. What is this? What are we doing? We're transferring to the message sender. And if I were to put a one in there, it would transfer one to the message sender. But what we want to do is transfer in. We need to get the address of this contract balance. Super weird line of code. But now we've got this cool withdraw function that will get the address of the contract balance.
00:22:10.882 - 00:22:32.442, Speaker B: So we get the balance of the contract and we transfer that to the message sender. If they're the owner, we've got ourselves a withdraw function. Let's make sure this works. Let's push it out and then we'll get in over here. Let's send this guy some more money. Anytime you need to send more money to an account, you can just come down here to the faucet and hit send. Oh gosh, where did I go? Oh, telegram support.
00:22:32.442 - 00:22:44.398, Speaker B: There's a nice support button. If you want to know how ludicrous the gas prices are, that's there too. But you can also open up this wallet and send yourself like 1000. Oh, wow. Okay, we're doing that. Cool. So now we should get a bunch of money there.
00:22:44.398 - 00:23:00.502, Speaker B: So we have plenty of money trying it now. And we're going to set our purpose and we're going to pay for it. There we go. So now some money should go into the contract. Now if this guy tries to withdraw, not the owner. Right. We got to go back to this homie over here.
00:23:00.502 - 00:23:16.778, Speaker B: D 75 B and D 75 B should be able to withdraw. Goes from seven dollars to eight dollars and thirty seven cents. Whoo. All right, I'm thinking now we could just dive into a little bit more syntax. Maybe look at mappings, maybe look at structs. What do you think?
00:23:16.944 - 00:23:25.406, Speaker A: Yeah, I think looking at mappings of structs is good. And then probably after that, we could probably mix it up and do crazy stuff too. All right, let's do it.
00:23:25.428 - 00:23:46.514, Speaker B: All right, so let's do a quick run on learning solidity at home. You've pulled this down. There's this kind of, basically what we just did is play around with primitives and data types, right? We took this first page. We looked at what an un can do. We looked at what an address can do. So you'll want to look at mappings next. I even have a homework assignment in here.
00:23:46.514 - 00:24:22.250, Speaker B: Is basically building a decentralized bank, right? Which sounds pretty big, but really you just want to set up a deposit function that's payable, let someone pay in. But you're going to use this mapping. If I can make this a little bit bigger, you're going to use this mapping. And this mapping is explained here. It's a storage for given some address or given some data type, we'll map it to another data type. So we have here, we're going to map, given some address, we're going to map it to a UN 256. So basically this is just like keeping track of someone's balance, right? Or a lot of individuals balances.
00:24:22.250 - 00:24:49.270, Speaker B: We can't iterate through it, but we could do a quick lookup. So first, homework. Learn mappings. Build a decentralized bank, set up a deposit function, keep track of individual balances with a mapping, and then set up a withdraw function that doesn't let someone withdraw someone else's money, right? Like you need to write your require statements correctly. Then learn about events. Learn about how events can be triggered in a smart contract. They're sort of like cheap storage.
00:24:49.270 - 00:25:08.590, Speaker B: They're really handy in your front end. Then you'll dive into, let's see, I think we get into structs. Let's go back to the learning real quick. Yes, structs are next. Learn how to keep a struct of other data types. Learn how to keep them in an array. And look at this, this is so cool.
00:25:08.590 - 00:25:34.546, Speaker B: Push through that array. So let's say you're setting up a Dow and you're going to need proposals. You're going to have a proposal struct, and then you're going to have an array of all the open proposals. And you're going to need to iterate through that with a for loop and be able to see how many proposals are open. How many votes does this proposal have? Things can get pretty intricate, pretty quick. These are like the primary data types that you need, right? Learn mappings, learn structs. Learn arrays of structs.
00:25:34.546 - 00:26:28.600, Speaker B: And you can build so many different smart contracts and so many different things. Some quick things to hit, modifiers you can put function modifiers in. So like that ownership thing where we did a require, you can set up a modifier for only owner and then you can stick that on every function. Then we talked about events. Inheritance is really great, and I think that we'll just dive into that and inherit something from one of your contracts. But just like I kind of wrote this ownership pattern, it may be better if I were to just say, this is ownable and bring in open zeppelin stuff. And then instead of me saying instead of this line here, we would do only owner, right? And now instead of me writing the code to make sure that I have this ownership pattern correct, now the smart contract itself will inherit the ownership pattern from a smart contract that a lot of other people have looked at.
00:26:28.600 - 00:26:45.326, Speaker B: Looks like I've got something solidity compiler version. So right in here I probably need to add. Should have added this earlier. I may not even do. See, let's see. It's right here. It's right here.
00:26:45.326 - 00:26:52.430, Speaker B: Come on, Griffith. Right here. What does it need? Six, seven, something along those lines.
00:26:53.330 - 00:26:54.062, Speaker A: Please work.
00:26:54.116 - 00:27:10.946, Speaker B: Second try. Okay, now we've got something else. Something about it doesn't like my constructor. That's easy. I think this needs to be marked as public until version, like one version doesn't want it to be public and one version wants it to be public. I think we're going to be good now. But now we have a different ownership pattern.
00:27:10.946 - 00:27:34.062, Speaker B: So our contract is going to deploy. It's not going to be using my ownership code anymore. It's going to use open Zeppelin's ownership code. And the owner is actually this dude here who is the first account of our covered, let's see, we've covered primitives, mappings, structs, modifiers, events, inheritance. We looked at a payable function. We kind of messed around with that fallback function. Get in here.
00:27:34.062 - 00:27:52.046, Speaker B: Take it slow. Learn through all of this stuff. Really like tons of work we've put into this. So you just get a nice app out of the box and if you're installing new packages, you have to CDN. It's using your own workspaces, but eventually you can deploy. There's challenges. A decentralized staking app and a token vendor.
00:27:52.046 - 00:28:06.546, Speaker B: There's a bunch of examples. The branches are so rad. Watch this. We're going to dive off onto a branch right now. I think we're going to go to one of the NFT branches. But let's just look at the simple NFT example. This is one of my favorites.
00:28:06.546 - 00:28:31.822, Speaker B: So all of these repos are going to kind of be a tutorial for you. They're going to talk you through how to get it installed, but then they're going to talk you through like, okay, you got to go change this and then you got to run this mint function and then it'll mint your collectibles for you and you can kind of just follow that. Let's just look for chain link real quick since we've got a very chain link. There we go. We've got one, two, three. I think this third one's no good. I think this third one is me.
00:28:31.822 - 00:28:43.294, Speaker B: Yep. Okay. But these two, two chain link demos that I think will take you through. Nope, here it is. Here it is. This branch is called Chainlink tutorial one. Yours.
00:28:43.294 - 00:28:59.782, Speaker B: We tweeted yours, Patrick. And it's a really good one, too. But here's another one that comes off the master branch that takes you through, I think, let's see, getting a random number and I think maybe getting a feed. Yep. API consumer. Awesome. So it really kind of walks you through a lot of stuff there.
00:28:59.782 - 00:29:22.942, Speaker B: Awesome. Okay, so I'm going to kill this one and we're going to dive to a nifty or a branch, right? So scaffold ETH is just full of tons of branches, just bonding curves and all sorts of weird things. Honey pots and dos examples. Okay, so what we're going to do is we're going to bring this guy over here. Same thing. This is the buyer mints NFT branch. I'm going to yarn install.
00:29:22.942 - 00:29:43.282, Speaker B: I'm going to yarn chain, and I'm going to yarn deploy. Actually, I think there's an extra step with this one. Let's go to the readme. So this is the buyer mints NFT. There's going to be a nice readme here that explains what's up. And I think what we need to do after we bring up our chain. Yep, we need to do a yarn upload.
00:29:43.282 - 00:30:12.606, Speaker B: So what's cool about this branch is it takes the NFT branch, but it sets it up so you don't have to mint all of your NFTs. You basically deploy the NFT contract and that's it. And you put in a bunch of fingerprints of a bunch of your artwork in that deploy. And then anyone can come along and buy a piece of art. And if it matches the fingerprint, it's allowed to deploy. And we'll look at the contract here, too. But let's go ahead and actually it starts right here.
00:30:12.606 - 00:30:30.434, Speaker B: It starts right here at this artwork file. I've set up this artwork file in the repo, I put in a bunch of my artwork. So now what I need to do is yarn deploy and. Yep, there we go. I've already uploaded. I think we need to do a yarn upload. I feel like let's follow the steps.
00:30:30.434 - 00:30:53.806, Speaker B: Yarn upload first and then yarn deploy. So what it's doing now is it's taking all of my artwork and uploading it to IPFs and getting the fingerprint back of that manifest. And that's what we'll put into our nifties. And now we could do a yarn deploy. And now our app should come up and it'll be a full gallery of NFTs without having to mint anything. But that original contract. There we go.
00:30:53.806 - 00:31:08.050, Speaker B: There's all of our NFTs and these are not minted yet. And again, we go to the faucet, we grab funds. This looks and feels just like scaffold ETH. Put it into dark mode if you want. Bring up your wallet like it's going to be the same stuff. Right. Okay.
00:31:08.050 - 00:31:24.742, Speaker B: So we can debug our contracts. We can look at things just like we were in that very initial example where we have everything from our contract and we could ask the balance of some address. Right. I can put that in and it's zero. Right. We can talk to it. There's some IPFs stuff.
00:31:24.742 - 00:31:37.034, Speaker B: If you want to upload something to IPFs and then bring it over here and download it. I've kind of just built that in. We're seeing transfers. There aren't any yet. And then my collectibles, there are none. We're at the gallery. We need to buy some.
00:31:37.034 - 00:31:49.486, Speaker B: I think I need to give myself some more money real quick, though. And then if we have time, let's build some VRF into it. What do you think? I don't know how much time we'll have, but it would be cool to import in some chain link.
00:31:49.588 - 00:31:55.054, Speaker A: Yeah, I think we might actually have plenty of time. We got 25 minutes left. I think we can do it.
00:31:55.092 - 00:32:05.806, Speaker B: Let's do it. We could go to main net. All right, so I'm going to make sure this works. Look at that. It's minting me. It's minting that one. Let's mint the Godzilla.
00:32:05.806 - 00:32:24.682, Speaker B: And they should be showing up now in my collectibles. Now let's do the same thing where we bring some incognito Gibroni in here. Some other dude does not have any ETH, does not have any collectibles. Let me just copy their address. And let's send them the buffalo. And let's send them the zebra. There we go.
00:32:24.682 - 00:32:49.266, Speaker B: So we're minting nfts sort of counterfactually. And then once we've minted them, we can send them around. Very cool. But what I want to do is give them some. Let's look at the contract. Right? What I want to do is give them something special in the contract. Really? A lot of these NFT platforms, or even like decentralized Ethereum platforms, a lot of them are small tweaks on existing things, right.
00:32:49.266 - 00:33:31.390, Speaker B: There's tons of composable blocks in the space. And someone finds a blind spot, fills it in with a new block and everyone else can kind of build on that block. So the little block I want to add here, basically we're bringing in ERC 721 from open Zeppelin. We're bringing in their counters library to create an ID, even though we could probably do it with IPFs. But what I've added to their contract is this for sale mapping. And then in our constructor we loop through setting all of these items to be set for sale but not actually deploying or minting the NFT and spending all that extra gas. Right.
00:33:31.390 - 00:33:55.270, Speaker B: So what I want to add in here is some VRF. It would be really cool if when we minted this we have some. And here's the small change I want to make. So let's see, it would be for any given token, right? I think in our, we did luckiness, but let's just call it strength or something like that, right? We're just going to have token strength.
00:33:56.730 - 00:33:57.480, Speaker A: Awesome.
00:33:59.390 - 00:34:22.798, Speaker B: Strong nFts. Strong nFts. I like it. All right, so for any given IPFs hash, we are going to have a un eight for some reason that's going to be token strength. And then these things can fight and maybe it'll get a random of their strength and whoever's is higher, like winner takes all wins the other NFT. Right? We've got ourselves a whole NFt battling platform. Here we go.
00:34:22.884 - 00:34:26.654, Speaker A: Somebody please make that for the hackathon, actually.
00:34:26.852 - 00:34:49.670, Speaker B: Okay, so just to start off with, we're just going to set our token strength to one. So that's one out of 255. Let's make sure all of this compiles and then we can kind of move to bringing in the VRF stuff. Oh, no, token strength. Oh, yeah. So it's token strength and then it's the Uri hash. There we go.
00:34:49.670 - 00:35:07.582, Speaker B: There we go. There we go. Okay, so now they're all being deployed with a strength of one. That's not very interesting. We want them to kind of roll the dice and get a random number and then have that random number be the random number they use for their token strength. So let's go to Patrick's branch. Where is it? There it is.
00:35:07.582 - 00:35:21.938, Speaker B: Patrick has. If you want to dump this in the notes or something. I don't know. We put it out on the tweet. Right. It's this file right here that I'm looking in. Awesome.
00:35:21.938 - 00:35:32.710, Speaker B: You've brought in this. So I'm going to import this. Chain link contracts, VRF consumer base. Do I need to? I just yarn install this, actually.
00:35:32.780 - 00:35:35.062, Speaker A: Chain link? Yeah, chain link contracts. You just yarn install that.
00:35:35.116 - 00:35:44.218, Speaker B: Exactly. Okay. I'm going to kill my web server. CD. Two packages react, no packages. Hard hat. Right?
00:35:44.384 - 00:35:45.146, Speaker A: Yes.
00:35:45.328 - 00:35:49.482, Speaker B: And yarn install. Yarn add. Right.
00:35:49.536 - 00:35:50.862, Speaker A: Yarn add. Yeah.
00:35:50.996 - 00:35:53.390, Speaker B: We're going to bring in the chain link contracts.
00:35:54.050 - 00:35:55.870, Speaker A: Excellent. We're doing this real time.
00:35:56.020 - 00:35:56.880, Speaker B: That's right.
00:35:58.050 - 00:35:59.566, Speaker A: This is real life.
00:35:59.748 - 00:36:03.390, Speaker B: I'm out of coffee though, man. I know.
00:36:03.540 - 00:36:06.180, Speaker A: Are you going to start like you start slowing down?
00:36:08.310 - 00:36:15.874, Speaker B: Yeah, I hope not. Let's go. Okay, so once we have this installed, I'm going to kind of copy paste here.
00:36:15.912 - 00:36:16.980, Speaker A: Yeah, go for it.
00:36:18.550 - 00:36:25.750, Speaker B: So you have a couple of storage variables, the key hash and the fee. I'm guessing these are kind of, and then they're.
00:36:27.690 - 00:36:35.420, Speaker A: Um. We're going to default to the COVID network because these are all kind of hard coded to coven, but makes it a little bit easier for the demo.
00:36:40.350 - 00:36:48.154, Speaker B: Going to bring. So these are hard coded addresses that basically initialize the VRF contract.
00:36:48.202 - 00:37:12.950, Speaker A: Yeah, exactly. So the first one is the VRF coordinator's address and that's the smart contract on chain that verifies that the number is like cryptographically provably random. And the second one is the link token. And that's obviously the token that has the transfer and call and is needed to interact with the. Yep. Then you have the key hash which defines the oracle as well, and it's part of the verification process. And then you have the fee, which again is how to interact with the oracle.
00:37:14.730 - 00:37:54.510, Speaker B: Okay, so we're going to call get random number, and then we're going to call fulfill random number and random result is going to get set. And we're going to kind of fake it a little bit because you need to set up some state machine stuff here where only one person can get the other person's random. What's interesting is there's like an ID here, this request ID. My instinct is I would store some kind of mapping with the request ID and the randomness, but we're just going to save it just to straight up this one random result and only one person at a time. But that'll work for what we want. And then once we have the random result, we'll need to mod it to a. Unh.
00:37:54.510 - 00:37:55.220, Speaker B: Right.
00:37:55.850 - 00:37:59.026, Speaker A: Yeah, you can just wrap it, cast.
00:37:59.058 - 00:38:04.840, Speaker B: It like that, and it will be a random of 255.
00:38:05.690 - 00:38:06.438, Speaker A: Yeah.
00:38:06.604 - 00:38:07.320, Speaker B: Okay.
00:38:08.890 - 00:38:11.340, Speaker A: Do we want to do like out of 100 or something we could mod.
00:38:11.950 - 00:38:18.938, Speaker B: Okay, yeah, that might even be better. Do a mod 100 there and typecast it to un eight.
00:38:19.024 - 00:38:23.440, Speaker A: Yeah, well, that'll be zero out of 99. Right. Do we want to do modded plus one?
00:38:25.810 - 00:38:41.042, Speaker B: Sure. Like that. Yeah. Is that okay? Maybe like this. I think this is what you wanted it to be, right? Okay. And another question is, does this need to be on Covan? Yeah, I'm deploying this to Covan. Okay, cool.
00:38:41.176 - 00:38:44.446, Speaker A: So we're going to stop the local machine. We're going to do this all on COVID.
00:38:44.558 - 00:38:48.342, Speaker B: Okay. So, yep, let's kill my hard hat node, and then I'm going to point.
00:38:48.396 - 00:39:15.550, Speaker A: My hard hat at Coven for everybody who's watching this. Actually, this is a sick idea. This is something that I've been waiting for somebody to build kind of this gamified version of these NFTs that they can battle. They have stats. And when you do it with provably randomness, you have a way to create digital scarcity. Right. Because only certain characters are going to have certain specs and stuff.
00:39:15.550 - 00:39:20.478, Speaker A: So you can't just mint super powerful, super badass ones. What's that?
00:39:20.644 - 00:39:41.574, Speaker B: This is an instant wallet IO. It's built with scaffold ETH. When I select COVID and I hit send here, it's going to give me the same exact UI that we're seeing with Scaffold ETH right now. Come on, give me a zoom. And I'm going to hit scan and I'm going to bring up the QR code that you get out of the box. And I'm going to scan this QR code and then I'm going to send it. What .1
00:39:41.574 - 00:39:43.078, Speaker B: COVID. Is that going to be enough?
00:39:43.244 - 00:39:44.374, Speaker A: Yeah, that should be fine.
00:39:44.492 - 00:39:58.838, Speaker B: I hope so. Here we go. Okay, so we should have our COVID. We should be on compile. We need what? We need some COVID length link. Oh, yeah. So does the deployer need it? Probably our front end address is going to need it.
00:39:59.004 - 00:40:05.098, Speaker A: Yeah, got. It's the contract that's going to need it. Okay, so once we deploy the contract.
00:40:05.194 - 00:40:11.038, Speaker B: Okay, I'll get you the address of the contract. I feel like we're doing some. What am I doing wrong here?
00:40:11.124 - 00:40:16.974, Speaker A: Let's see. Something about undeclared identifier.
00:40:17.022 - 00:40:22.178, Speaker B: Oh, you know, I didn't say is I need to do. Is VRM that right there? Right.
00:40:22.264 - 00:40:22.900, Speaker A: Nice.
00:40:24.390 - 00:40:37.526, Speaker B: Oh, I did a yarn account again. Yarn compile. Give us a compile. We probably should have fired this off locally just to make sure it works, but we are really rocking it in production. Yarn deploy to COVID. Yeah.
00:40:37.548 - 00:40:41.062, Speaker A: And then if you send me the address, I have a ton of coven link that I can send.
00:40:41.116 - 00:40:49.686, Speaker B: Okay, awesome. Okay, so you want to put that. I'll send you that right you'll put some Covan link in our contract.
00:40:49.798 - 00:40:50.860, Speaker A: Perfect. Yeah.
00:40:51.230 - 00:41:07.182, Speaker B: I'm going to edit our front end now. So we kind of changed our back end satellite and tweaked it toward Covan right here. You have target network in your front end. So if we go look at our front end right now, it's probably kind of busted. It's on localhost. It probably can't even talk to the chain. Oh, let's do a yarn.
00:41:07.182 - 00:41:23.142, Speaker B: Let's bring it up first. Whoops. This was buyer. Yes. And then we want to yarn start. My brain is like, where's that coffee? Okay, here we go.
00:41:23.196 - 00:41:24.566, Speaker A: Back in it. We're back in it.
00:41:24.668 - 00:41:44.754, Speaker B: We're starting our dev server again. Like you said, we killed off our chain, right? We're not running a local chain anymore. We're only talking to Covan for this. But I'm going to have to put in here. I'm going to have to put in Covan. So we changed our deployment location here and we changed our front end location here. And all of a sudden now we have an app that runs on Covan, right? You change that to matic.
00:41:44.754 - 00:41:59.246, Speaker B: I think Polygon is a sponsor. You change this right now. It's matic still, but you change that to Maddox, you're deploying to Maddox. You change that to Mainnet. You're deploying to Mainnet. So it's all right here. All EVM compatible networks.
00:41:59.246 - 00:42:16.646, Speaker B: And I think there's even a network constant file you can get to. But let's see now it's saying no network, but I think with a reload, we should have a network and it should be Covan. All right. Okay. Now we need to yarn. Wait, why we should have. Oh, there they are.
00:42:16.646 - 00:42:36.154, Speaker B: They just took a little bit. Took a little bit. Okay, so we've got our buffalo here. But to mint right now, if I were to mint one right now, our randomness number would be zero. So anything I mint right now is going to have a strength of zero. Oh, you know what we should have done is we should have cleared the randomness variable. It's already deployed.
00:42:36.154 - 00:42:53.006, Speaker B: It's already live. But we should have cleared it down here. Okay, whatever. We brought in some new stuff and we can go to debug contracts and we can go look at our contracts and we can see, oh, look, there's this new get random number, and there's this new fulfillment. No. Fulfilled randomness is actually called back from chain.
00:42:53.038 - 00:42:53.570, Speaker A: Exactly.
00:42:53.720 - 00:43:12.330, Speaker B: So what we need to do is this get random number first. Right? We need to trigger this random number. We can close. Let's. And obviously, we would build this into the UI. You would make a nice, pretty ux that says, okay, player, time to roll the dice for how much strength you get. And then they hit one button and it does all this for them.
00:43:12.330 - 00:43:20.990, Speaker B: But behind the scenes, we need to provide some kind of bytes. 32. Wait, I'm going to need some. Oh, wow. I've already got COVID. All right, we're ready.
00:43:21.060 - 00:43:21.390, Speaker A: Thanks.
00:43:21.460 - 00:43:33.874, Speaker B: Wait, does this need to be. Oh, just some random number, right? Yeah. 867530. Wait, 867-5309 isn't that the number?
00:43:33.912 - 00:43:36.420, Speaker A: All right, here we go. You got it.
00:43:39.670 - 00:43:51.282, Speaker B: We're on Covan. We're sending our random number. Oh, no. Okay, let's try connecting our metamask. Let's level this thing up. Ooh, a nice little network error. You get that right away.
00:43:51.282 - 00:44:05.050, Speaker B: Isn't that nice? If you build on Scaffold ETH, you don't have to build your own network error in there. It does that for you. All right, we got plenty of Coban random number. Okay, what are we doing here? Invalid. Oh, invalid. Of course. ASDF.
00:44:05.050 - 00:44:10.620, Speaker B: But is. One, two, three. We've got something going on here.
00:44:11.950 - 00:44:12.698, Speaker A: Let's see.
00:44:12.784 - 00:44:24.500, Speaker B: It's a little delayed. Maybe we need to hard code how much when we call this, get random number. Maybe we need to put in some.
00:44:26.950 - 00:44:30.820, Speaker A: Boy, I didn't see the error. Actually.
00:44:31.190 - 00:44:47.282, Speaker B: It's just getting some. You know what? I think maybe. Is there any chance the link token. Are we sure this is Covan? Let's check this. So our contract is out on Covan. But is this dog. Yep, it is.
00:44:47.282 - 00:44:57.142, Speaker B: Wait, but it only has three transactions. We should double check that this is the right link token on Covan.
00:44:57.206 - 00:44:57.866, Speaker A: That's what we're saying.
00:44:57.888 - 00:45:07.822, Speaker B: Yeah, I sent you the address there. I feel like this. Wait. Yeah, I don't think that's the right link token, man.
00:45:07.876 - 00:45:11.902, Speaker A: Yeah, hold on a second, because there's a decent chance, actually, that that's the rinkby stuff.
00:45:12.036 - 00:45:20.260, Speaker B: Oh, let's go to Rinkabee. Let's go to Rinkabee. Let's see rink. What do we have three minutes left or something like that?
00:45:20.630 - 00:45:21.954, Speaker A: We have 1313 minutes left.
00:45:21.992 - 00:45:23.474, Speaker B: 13 minutes. Okay, 13 minutes.
00:45:23.592 - 00:45:24.434, Speaker A: We got time.
00:45:24.552 - 00:45:28.690, Speaker B: All right. Rinkabee. I don't want Rinkabee openc. I want Rinkabee ether scan.
00:45:29.270 - 00:45:30.834, Speaker A: Oh, yeah, that's the rinkby stuff.
00:45:30.872 - 00:45:37.574, Speaker B: Actually, it's Rinkabee. We're going to Rinkabee. Okay, so we can change our contract too, while we're at it. Right. There was that one thing where it's like, okay, once you set.
00:45:37.612 - 00:45:39.010, Speaker A: Yeah, sorry about that. That's rinkby.
00:45:39.090 - 00:45:52.750, Speaker B: Oh, no, it's great. So, let's see. We're setting our strength to random result, and then we're going to set random result equal to zero again. So they only get one random. Okay, now we're going to change this to Rinkabee.
00:45:54.450 - 00:45:59.066, Speaker A: All right, let me see. The VRF coordinator and key hash.
00:45:59.098 - 00:46:08.626, Speaker B: Yeah, key hash is two. Ed, coordinator is B, three.
00:46:08.808 - 00:46:11.666, Speaker A: Sorry, my bad. That's rink, B. Here we go.
00:46:11.768 - 00:46:15.010, Speaker B: All right, yarn. I need to give myself some Rinkabucks real quick.
00:46:15.160 - 00:46:15.678, Speaker A: Rinkabuck.
00:46:15.694 - 00:46:24.520, Speaker B: So I'll use a fancy. Look at that. I'm just going to select Rinkabee. I've got all these different networks. I'm just going to say I got ten rinks. Here we go.
00:46:27.950 - 00:46:30.140, Speaker A: And I'll send that some rinkby link.
00:46:30.590 - 00:46:31.242, Speaker B: Perfect.
00:46:31.376 - 00:46:32.630, Speaker A: Some linkabee.
00:46:32.790 - 00:46:42.686, Speaker B: Linkabee. That's great. All right. Zero point eleven rink. That's probably enough. What does it take? About 15 seconds on Rinkabee? Yeah. Oh, yeah.
00:46:42.686 - 00:46:49.040, Speaker B: You've already got the address. Rinkabee link to D one. Df or something like that. I may have generated a new account.
00:46:51.010 - 00:46:53.710, Speaker A: Oh, no. So I need the contract address, not the.
00:46:53.780 - 00:46:59.982, Speaker B: Oh, the contract. Right. And you got that already? Oh, no. New contract. New contract. We haven't deployed. We haven't deployed.
00:46:59.982 - 00:47:20.090, Speaker B: Here we go. Am I even wearing pants? No one knows. All right. Our collectible deploying. There we go. So you need d three, a five. Oh, interestingly, it's going to be the same address because it's the same nonce on a different ethereum.
00:47:20.090 - 00:47:27.770, Speaker B: Okay, cool. So now we should definitely be deployed. Okay, we need to point our front end at Rinkabee.
00:47:30.910 - 00:47:40.090, Speaker A: Yes. And then we just got to switch metamask over. And then I got to actually send you some Rinkabee or some linkabee.
00:47:40.250 - 00:47:55.540, Speaker B: Linkabee. Okay, now do we have our gallery up? It's probably going to take. I'm worried about my infuria key. Is it going to hang on? No, it is not hanging on. It's trying hard. Okay, debug contracts. We go to our get random number.
00:47:58.470 - 00:48:00.774, Speaker A: Hold on 1 second. I got to send you the link.
00:48:00.892 - 00:48:05.320, Speaker B: Oh, you got to send. Oh, we still need link in the contract. Yeah. Not enough link. Awesome.
00:48:05.690 - 00:48:10.486, Speaker A: Oh, that's perfect then. And now that means we're doing it right.
00:48:10.508 - 00:48:11.738, Speaker B: Still getting not enough link.
00:48:11.824 - 00:48:19.802, Speaker A: Yeah, it's still sending. I have the gas happening. I had the gas fee set to one, which isn't going to get you anywhere on link of.
00:48:19.856 - 00:48:26.240, Speaker B: Yeah, I'm going to need an inferior key, too. We'll see how this works. See if we get by with.
00:48:31.090 - 00:48:34.094, Speaker A: Still in flight. Still in flight.
00:48:34.142 - 00:48:38.194, Speaker B: Okay. I like having my metamask connected just because we see the dialogue come up.
00:48:38.232 - 00:48:38.722, Speaker A: Yeah.
00:48:38.856 - 00:48:46.034, Speaker B: Okay, so we, as a user, supply some randomness, right? We supply our own randomness.
00:48:46.082 - 00:48:51.030, Speaker A: Well, hold on. Got to be a number. Yeah, number. Perfect.
00:48:51.180 - 00:48:54.066, Speaker B: Then. Is one guay okay for rinkabee?
00:48:54.098 - 00:48:56.998, Speaker A: No, it's got to be like 50 or something.
00:48:57.164 - 00:48:57.638, Speaker B: What?
00:48:57.724 - 00:49:01.674, Speaker A: Because I just tried three times with one and it was not happy with me.
00:49:01.792 - 00:49:19.310, Speaker B: Okay, so now we've sent a transaction to post the random number or post the request to the chain link network for some adapter to give us a random number and call back into our function. It will call back into this fulfill.
00:49:21.650 - 00:49:43.270, Speaker A: So this is, if you notice, it's an internal override function. So technically the node is actually calling the VRF coordinator address. And that's why we need to give it that address, so it knows who to call back. The VRF coordinator is checking. It's going, is this really random? I'm just going to make sure. And then once it does, it goes, okay, this is random. Then the VRF coordinator is actually what calls the fulfill randomness.
00:49:43.850 - 00:50:03.834, Speaker B: Got it. Now, we sent a transaction 30 seconds ago. It did go through. We did see some link transfer. Now what are we checking? We're probably checking for our random number. We're waiting for this random result to show up. And my clunky UI is going to cause a reload.
00:50:03.834 - 00:50:06.798, Speaker B: Okay, so this could take a second, right?
00:50:06.964 - 00:50:21.438, Speaker A: Yeah, we could chat for like a second because we got to wait for two transactions, right? We're doing request and receive, right? We're requesting the link or requesting the round of number. So that's one transaction and then we're getting one back. So that's actually a second transaction.
00:50:21.534 - 00:50:40.680, Speaker B: And you know what I can do is I can plug in a better inferior key while we wait. So we could get, let's see, just so we could hit that back end a little bit harder and not have it fall over on us. Let me just go grab another one here.
00:50:41.610 - 00:50:43.510, Speaker A: We pretty much have it too, though, actually.
00:50:43.660 - 00:51:03.520, Speaker B: Is there a random number? Oh, it's there. We got a random result. It's back. Okay, so now when we mint, what's going to happen is it's going to take this random number and it's going to mod it by 100, and it's going to add one to it. Because Patrick needs that extra one added to it.
00:51:04.130 - 00:51:06.254, Speaker A: We don't want that to have zero strength, right?
00:51:06.292 - 00:51:22.578, Speaker B: That's right. Someone needs to have 100. Yeah, that's right. I'm with you. I'm with you. Okay, so now we could call Mint from here, but now we should be able to just trigger the Ui, and it should give us a zebra with some strength, right? Oh, boy. Man, I'm nervous.
00:51:22.578 - 00:51:35.162, Speaker B: I'm nervous. Let's see, 51. Does it really need 255? There we go. Oh, I like that block native. Look at that little spinny clock. We can probably go click here and go see the transaction. Very nice.
00:51:35.162 - 00:51:36.678, Speaker B: Very nice. Block native.
00:51:36.774 - 00:51:39.722, Speaker A: Let's get our strong zebra. Let's see how strong our zebra is.
00:51:39.776 - 00:51:51.838, Speaker B: How strong is our zebra going to be? Okay, you should give me an address of yours on Rinkabee so I could send you the collectible at the end with the strength built into it.
00:51:51.924 - 00:51:52.318, Speaker A: Wow.
00:51:52.404 - 00:52:12.114, Speaker B: Rinkabee owned by me. Yes. Okay, so now the zebra is owned by me. Now, we're going to have to do some debugging here to figure out what we want to know is the token strength, right? Okay, so the token uri for token one, I believe. Yes. Is this. Okay, so this is our zebra.
00:52:12.114 - 00:52:20.166, Speaker B: So now if I do Uri to token ID. That should have worked. Darn it. There's a little quote.
00:52:20.278 - 00:52:21.498, Speaker A: Yeah, there's a quote there.
00:52:21.584 - 00:52:37.790, Speaker B: Get them out of here. Get them out of here. Token. I just want to test this to make sure we've got that right. That should give us ID one. No. Okay, let's try token strength just in case.
00:52:37.790 - 00:52:55.762, Speaker B: Oh, no, it's the hash of it. Darn it. Okay, so we need to grab. Let's see. Who is this guy? Yes, I think it's this hash right here. So a lot of stuff would need to probably be done in the back end to make this a nice experience for your front end user. But there it is.
00:52:55.762 - 00:53:16.042, Speaker B: Token strength of 49. All right, our zebra has a token strength of 49. Our random is probably set back to zero. Right? We would have to go through that dance again to get a new random. But now I have this zebra that has strength of 49, and I want to send it to you. I probably could just put in Patrick here, right? Or something.
00:53:16.096 - 00:53:22.400, Speaker A: What's your actually Patrickalphac e.
00:53:26.530 - 00:53:35.850, Speaker B: Transferring it to you on rinkabee. It's a 49 string zebra. Oh, what I just confirmed, too. I don't even know what I just confirmed.
00:53:36.010 - 00:53:37.326, Speaker A: That means, like, six zebras.
00:53:37.358 - 00:53:56.358, Speaker B: All right, we did it. There we go. In a little bit. You should have a zebra on yours. So just to recap, Scaffold ETH is a great starter point. It's like kind of an existing dap that stands up for you. There's tons of branches and tons of things that other people have been working on.
00:53:56.358 - 00:54:05.574, Speaker B: If you get into Scaffold ETH, you go to the repo. Just follow the readme from the top. But once you're ready to really dive in, there's challenges. There's.
00:54:05.622 - 00:54:05.994, Speaker A: Got it.
00:54:06.032 - 00:54:06.742, Speaker B: Other branches.
00:54:06.806 - 00:54:07.926, Speaker A: One, YCB.
00:54:08.038 - 00:54:31.522, Speaker B: What is YCB? Your collectible. Yeah, I guess if we go to Opensea, if you go to testnets openc, and then you look up your collectible, you can see a lot of people deploying these. Whoops, I did not spell that right. Collectible man. Still not. Where's that coffee? Here we go. Fourth try.
00:54:31.522 - 00:54:40.822, Speaker B: Come on. There we go. So, yeah, G. All right, where is our. I know you would know. It's probably here somewhere. But we could probably.
00:54:40.822 - 00:54:46.066, Speaker B: No, we wouldn't be able to find the strength because it's not. We would need to have a custom metadata.
00:54:46.178 - 00:54:46.840, Speaker A: Exactly.
00:54:47.210 - 00:55:13.070, Speaker B: That's delivering the metadata from the contract. But we need the strength to be written into the contract, not some JSON Bs. We want that to be in the contract so we can have a battle contract that can extend these permissionlessly. Right? Like, we don't even have to give them permission. Someone else can write a battle contract that lets these funny animals go to battle with each other using their strength. And it'll be on chain. All permissionless permissionlessness.
00:55:13.070 - 00:55:23.982, Speaker B: Permissionlessly. Thank you for having me, Patrick. Good luck. Chain link hackers. Go get them. Go build something awesome. Slide into the DMs.
00:55:23.982 - 00:55:30.934, Speaker B: Head to the scaffold e chat. I'm sure you guys have a big discord or something going for it. Awesome, man. Very cool stuff.
00:55:30.972 - 00:55:39.686, Speaker A: Awesome. This was so fantastic. Per usual, expect nothing but the awesomeness. Although you were saying coffee energy is going down.
00:55:39.788 - 00:55:41.880, Speaker B: I don't see the all time low. Yeah.
00:55:42.490 - 00:55:48.730, Speaker A: Wait, so we do have, like, two minutes left here. If you don't mind, we have a couple of questions. You want to get a couple questions? All right, cool.
00:55:48.800 - 00:55:49.660, Speaker B: Heck yeah.
00:55:51.390 - 00:55:57.440, Speaker A: So this random function is part of the ETH network. Somehow there's some way to verify randomness. Okay, this question for me, actually.
00:55:57.810 - 00:55:59.054, Speaker B: Yes. Yeah.
00:55:59.092 - 00:56:29.906, Speaker A: So the chainlink VRf, there's a coordinator contract called the VRf coordinator. And this is actually verifying that the chainlink VRf node is actually responding with true randomness. So it is a randomness verifier, which it took me a long time to wrap my head around because I'm so, like, what? There are some incredibly smart people who can verify randomness. Godzilla may lose to zebra. If Godzilla has a lower power score or strength score, then, yes, Godzilla would lose to zebra. When you say strength, does that mean random?
00:56:29.938 - 00:56:30.230, Speaker B: Yeah.
00:56:30.300 - 00:56:37.322, Speaker A: In this example, the strength we got was a random number. So we returned a random number. We modded it. Sorry, Austin, I'm jumping it up.
00:56:37.376 - 00:56:37.980, Speaker B: Please.
00:56:38.750 - 00:56:49.710, Speaker A: We modded it by 100. The random result were over 100. So the strength was actually the random result, but modded to be between zero and 100. Something with more strength is more rare.
00:56:52.130 - 00:57:18.534, Speaker B: I don't know. The rarity in the IPFS manifest, we put what the background color was, and they all had googly eyes. And opensea parses that information directly. And they could tell you like this one, actually. Screen share. Should I do it? Should I do it? Screen share. If we go to testnets openc and we go to your collectible again, and I spell it.
00:57:18.534 - 00:57:30.826, Speaker B: Almost got it. I almost got it on the first try. We go to your collectible, and we click into one of these buffaloes. We should see that it actually has these properties. Yeah. So 100% of them have googly eyes. Right.
00:57:30.826 - 00:57:47.074, Speaker B: So we set them up to have googly eyes in the manifest. But only 17% of them have a background of green. And openc figures that stuff out. We put that into the traits in the JSON in this artwork file. We said, yeah, it's going to have a background of green. It's going to have googly eyes. Oh, and I put in stamina, too.
00:57:47.074 - 00:57:58.734, Speaker B: Look at that. That's probably in here somewhere. Stamina. Yeah, look at his stamina. Nice. But this stuff is in the manifest. It's not in the full contract.
00:57:58.734 - 00:58:07.270, Speaker B: Right. And you want these numbers to be in the contract. If you want other people to be able to permissionlessly build new things on top of them and use that logic in their contracts.
00:58:08.810 - 00:58:29.774, Speaker A: Awesome. Well, there are a couple other questions here, but we are at time. We have our next workshop with Solana right after this. Austin Griffiths, ladies and gentlemen, once again, thank you so much for being here. I hope everyone took away a lot from here. Yeah, we went through a lot of really cool stuff. Both solidity, scaffold ETH, smart contracts, randomness, your collectible, everything.
00:58:29.972 - 00:58:39.630, Speaker B: I'm going to deploy this. I'm going to deploy this to surge right now. So anybody could go and mint their own with the randomness and tinker around with it. What should we call it? It needs to be something surge.
00:58:40.530 - 00:58:42.234, Speaker A: Your strong zebra surge.
00:58:42.282 - 00:58:52.262, Speaker B: Just kidding. Your strong zebra, no spaces surge. I'm deploying it. Go check it out. In a second. Your strongzebra surge. Sh.
00:58:52.262 - 00:58:57.286, Speaker B: I'm deploying it. I just had to do a yarn build and a yarn surge. And it's gone. It's up.
00:58:57.388 - 00:58:59.700, Speaker A: Awesome. All right, guys, well, thank you all so much.
