00:00:00.250 - 00:00:47.462, Speaker A: Chainlink's verifiable randomness function, or VRF, gives developers better scale, flexibility and control. Hi, I'm Richard, one of the developer advocates here at Chainlink Labs. And today we're going to take a look at Chainlink's VRF. The big important thing to know about VRF is you're funding a subscription which is based an account that allows you to fund and maintain balance for multiple consumer contracts. I like to think of it as a bucket that all your contracts can pull from. Let's dive into the docs and see what using VRF looks like and feels like in order to show that, let's dive right into getting a random number from the documentation. So we'll take a look at the documentation.
00:00:47.462 - 00:01:25.254, Speaker A: Now if you head to docs chain link, you'll see this page and we have data feeds, functions, automation, and VRF. If we head to the VRF documentation, we'll go directly into getting a random number. Now the documentation does cover a lot of other information that is very useful to know, but for this tutorial we're skipping right to getting a random number. You can read about subscription management here and how it works. Instead of reading through this, we'll actually just walk through this process. If we click open subscription Manager, we'll see the subscription manager and we'll need to create a subscription. Now you can give it your email and project name if you like.
00:01:25.254 - 00:01:50.542, Speaker A: I won't for this example, but we'll be creating a subscription. And you'll notice here that we're prompted to actually confirm this on a test network. Now something to note, I'm doing this on the sepolia test network. Most of the Chainlink documentation references the sepolia network as the default test network. So that's what I'll be using just to make life a little bit easier. You can use other test networks that are supported if you like. You will need some ETH and link tokens for this.
00:01:50.542 - 00:02:10.486, Speaker A: If you don't have those, you can head to faucets chain link to secure that. And we'll take a look at that here in just a moment. So we create our subscription, we'll need to add some funds. Just click add funds and it'll take us to the next page. And I mentioned the faucet right here. If we need link for testing, you can get that from the Chainlink faucet. It's at faucets chain link.
00:02:10.486 - 00:02:28.614, Speaker A: You'll need to connect your wallet. I've already done that. Once you have, you'll pick the network that's applicable. Remember, we're using Ethereum sepolia. In this example we can request link and ETH. If you do need ETH, you will need to verify via Twitter. But for link itself you'll just need to complete a captcha.
00:02:28.614 - 00:02:50.414, Speaker A: So once you've done that, you should be able to get your link. So we'll need to add some funds. For this example, I'll just use five. It's going to be more than enough. We'll approve that transfer as well. And our link has been transferred now we'll need to add consumers and this gets to an interesting point in creating VRF. So we've created that bucket, right, that subscription.
00:02:50.414 - 00:03:22.240, Speaker A: We have funded it with Link and we have what we need there. But we haven't actually deployed a contract yet. And the way that VRF works, a mental model think of besides the bucket of link for our subscription, is that you need to let your subscription know about the contract you're deploying. And when you deploy your contract, you're going to need to let that know about your subscription. We'll see what that looks like, but basically they need to know about each other in order to function properly. So at this point we'll head back to the documentation. Let's leave the subscription manager right here on this add consumer page.
00:03:22.240 - 00:03:58.450, Speaker A: As we scroll through the instructions, we'll see deploying a VRF V two compatible contract. And there's this awesome open and remix button here. We'll click that and from here it'll take us to remix. So Remix will allow us to deploy and interact with this contract on the blockchain. Let's take a look at the actual contract that we'll be deploying. Briefly at the top here you can see that we have our imports of the coordinator interface. Our consumer base and confirmed owner coordinator interface is going to be what allows that coordination of reaching out to the Oracle network to get the actual random values.
00:03:58.450 - 00:04:26.750, Speaker A: Consumer base contains some functions we'll be importing and using within our contract, as well as confirmed owner, which will bring in information that allows us to ensure that only the owner of this contract can do certain functions. If we look at the contract itself, you can see we declare some events. We have a struct for the request status that let us check the status of our request. We have a mapping for those request statuses. We have our subscription iD. This is what I was mentioning. We need to let the contract know about our subscription.
00:04:26.750 - 00:04:55.498, Speaker A: So that's what will store that information. We have a few variables for the request IDs, we have a key hash. Now this key hash is important because this is specifying the gas lane that we'll be using. It's basically how much we're willing to pay as a premium for gas. For faster responses on the testnets, there's only one. If you take a look at the link there in the documentation you can see the different gas lanes that are available on the different networks. Each gas lane will have its own address, so that's something to keep in mind.
00:04:55.498 - 00:05:23.074, Speaker A: We also have the callback gas limit. The way that VRF works is it goes and makes a request to the Oracle network. And when it makes that request, the Oracle network goes off, generates the random numbers, and then comes back. Right. And when it comes back that's when you need to actually do something with the random values that are returned. If you don't do something with them, as soon as you get them back, then they're stored and that information becomes public. So they're not really as random as you would like.
00:05:23.074 - 00:05:53.146, Speaker A: Now when it comes to that callback gas limit, that's going to be the maximum amount of gas that is available to be used in that callback function. And we'll see that callback function here in just a moment. We have the number of confirmations that we would like to have. This is how many block confirmations need to go by before those values are returned. The way I like to think about this is the lower this number, the faster you'll get your response back. But the less secure the higher it is, the more secure, but the slower. So it's a trade off.
00:05:53.146 - 00:06:22.920, Speaker A: You need to balance it with what's important for your project. And then we have the number of words when it says words here. If you were to look up words from a computer science standpoint, you'll find that's technically the correct term for the values that we're getting back. I like to think of them as just random numbers because it makes my life a little bit easier when I'm thinking about them. So this is a number of random numbers that you'll be getting back. In this case we're getting back two, but it can be more than that and it can be as little as one. So you can get multiple values back in a single transaction, which is really cool.
00:06:22.920 - 00:06:56.754, Speaker A: So we have our constructor here where we set things up. We give it the coordinator when we deploy this contract, we'll give it that subscription ID and then we have the function request, random words. Again, this is going to be reaching out to the Oracle network to make that request. So we store a few things in here like the request ID and we get that information and we meet the event. Then once everything has happened within the Oracle network, we get our random numbers back. The way it comes back into our contract here is through the fulfill random words function. Now this function doesn't do much, right.
00:06:56.754 - 00:07:22.218, Speaker A: It just stores the information. This is where though you would want to actually do anything with those random values. Think if you are assigning traits to an NFT or something like that, you'd want to do that here. As soon as they come back into your function, we have one last function, get status request just to see what's going on with our request. So let's deploy this contract. Now. We'll need to make sure that we change it to our injected provider and then we need to give it our Subscription ID.
00:07:22.218 - 00:07:49.282, Speaker A: If we head back to our subscription, we'll notice here iD is 1923. If you're following along doing this yourself, your ID is going to be different. Most likely paste our ID in here and click deploy and confirm this transaction. All right, so our transaction is confirmed. We have our contract down here. Now we'll need to grab the address of this contract and head back to our subscription. This is going to be the consumer address.
00:07:49.282 - 00:08:12.150, Speaker A: So we'll paste it in here and we'll add a consumer. All right, so our consumer has been added. Let's look at our subscription. Now we can see here a brief History of what's happened, right? We created our subscription, we funded it, and we added that consumer. Now when we actually make a request, we should see it here in our subscription that the request has happened. So let's go do that. Now back to remix.
00:08:12.150 - 00:08:46.670, Speaker A: And we will request random words. We'll confirm this as well and then we can head back to our subscription and take a look. But we'll need to wait for our transaction to actually be confirmed before we'll see anything here. All right, so it's been confirmed. If we take a look at this page now, we'll see that we have a pending transaction right now. Remember, depending on the network you're on, depending on how many block confirmations you said, this can take a while. So we'll wait for this to go through and then we'll see it actually in the history here that we have completed our transaction.
00:08:46.670 - 00:09:19.242, Speaker A: While we wait for the transaction to be completed, if we take a look here and we say last request and we copy this ID to get the status we can see has actually been fulfilled. While I was checking this. So our boolean is fulfilled is true, and we have our random values. Now, the thing to note is that we asked for two random values, right? And if you look closely right here in the middle, there's a comma. So we have one number here and the second number afterwards. So that's it. This is what it takes to get random values back using chainlink vRf.
00:09:19.242 - 00:09:36.040, Speaker A: Now, from here, you have tons of opportunities with what to do with this, right? It's everything from determining randomness when it comes to game assets, NFts, anything that you like, really. So, yeah, I can't wait to see what you'll build with this. And I'll catch you the next one.
