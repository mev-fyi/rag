00:00:19.990 - 00:00:27.738, Speaker A: And we are live on YouTube as of now. If there's some solid questions that come to YouTube, I'll relay them over to you as well.
00:00:27.904 - 00:00:28.620, Speaker B: Cool.
00:00:29.790 - 00:00:30.450, Speaker A: But cool.
00:00:30.480 - 00:00:30.674, Speaker B: Cool.
00:00:30.712 - 00:00:52.440, Speaker A: David, whenever you're ready, everyone. Thanks for coming. Thanks for watching. I want to introduce David from the graph. He's going to be going over a lot of really cool tools that you can build with the graph and how you can work with the graph and empower yourself to make and build really cool things for this hackathon. So with that, I'll pass it over to David. Thanks so much for being here.
00:00:53.370 - 00:01:10.270, Speaker B: Awesome. Thanks, Patrick. I will share my screen. Do you guys see my Google right now?
00:01:10.420 - 00:01:11.214, Speaker A: Look good?
00:01:11.332 - 00:01:33.870, Speaker B: Okay, perfect. Yeah. So I will be explaining what we do with the graph today. And as you guys know, we're part of the chain link hackathon. It's a good place to start. So if you see here, we're offering two prizes of $1,500 each for two different categories of subgraphs built. The first one would be the best new subgraph.
00:01:33.870 - 00:02:53.930, Speaker B: And even if you use a chain link orgle in your subgraph, you could get both bounties in that scenario. And there's an example of Mellon's Chainlink subgraph, which we can share with you later. But it's just a good example of something that uses a subgraph as well as Chainlink's oracles and to kind of dive into what we do with the graph. So the graph is an API that allows you to get any kind of smart contract data and put it into this thing called a subgraph, which allows, and within a subgraph, we actually allow you to get data from Ethereum or ipfs. And what it really does is allows you to index and query data from Ethereum, from ipfs in a really easy manner. And it's a really good use case for something like Adapt, where maybe you have a bunch of Ethereum data that's in these contracts, and you can't query Ethereum directly because it's super slow. So what you end up doing is you build the subgraph, you have all this historical data in it, and it allows you to have a really good way to get a good view of what's going on in a blockchain.
00:02:53.930 - 00:03:49.520, Speaker B: And we've been doing this for a few years now, and we're going towards a decentralized network, and that will be happening soon. But right now we run this thing called the hosted service, and right here you can see it if you go to the Explorer, there's all these examples of subgraphs that actually are using the graph right now, and some of them are using them in production apps. Guys like Ave are using it in their app and Uniswap using it in their DAP. So we have all these examples of great teams that are already using subgraphs, and we've seen a ton of growth in the last few months. This is what is called the graph Explorer, and it allows you to just go in and look at any data on smart contracts. So this is some data on uniswap. I won't get into it because it's just an example, but I'll show you a little bit more in depth later when I go through an example.
00:03:49.520 - 00:04:35.070, Speaker B: So yeah, I'll hop into the documentation. Now, the documentation for the graph is where this is really where everything is explained for how you can build a subgraph. Also, what the graph is kind of a more in depth example of what I just explained. And if you start diving into the documentation, actually it starts to go through an example. So there's a quick start example here, and I'll actually go through this on my own in a few minutes. But this is just a great reference. If you're building in the hackathon and you're building on the graph, come to the docs here, or come find us in discord.
00:04:35.070 - 00:05:09.606, Speaker B: We're always available on there. We're super helpful. So we're really looking forward to people building anything on the graph for this hackathon, and especially connecting it with Chainlink. So that's good. Maybe a good way to describe. Yeah, I'll describe how we define a subgraph. A few key components of a subgraph that we should get into are the fact that what it does is it uses GraphQL.
00:05:09.606 - 00:05:47.720, Speaker B: So I don't know how many people are familiar with GraphQL, but it's a really popular kind of like API for storing data through entities. And we'll see all that when I build it out for everybody. And as well as assembly script, that's another piece of technology that we use. Assembly script compiles to waSm, which then we upload to the graph node and in this case, the hosted know. It's very similar to typescript. It just has less features, basically. And so now would be a good time to get started, actually.
00:05:47.720 - 00:06:30.546, Speaker B: So what you guys can do, the first way to start would just be running NPM. Install global at graphproteocolgraph cli. And that's actually in the documentation as well. I already have this installed, so I won't install it right now. But essentially you install that and then you can go to, so once you go to the graph.com you can log in, it's GitHub oauth and then you'll get to this dashboard that you have. So this is my account and we will provide you guys an access token when you create an account.
00:06:30.546 - 00:07:37.378, Speaker B: So that's what you run graph auth with graph auth. So you type in the URL for the API that we use for the hosted service and then use your authentication key that we just gave you and it'll say access token set, which is perfect. So now we have this thing called graphenet. So Graphenet has a few options you can do from example and we won't go through this one, but it basically just creates a really simple subgraph from an example called Gravitar. And it's a super simple smart contract and it's very useful if you just want to start from scratch. But what we'll actually do is one called from contract and the way to use this is to go to etherscan and find a contract that you actually want to use for your subgraph. So what I did is I went and found some of the chain link price feeds.
00:07:37.378 - 00:08:09.374, Speaker B: So if you go to chainlink docs and price speed contracts. So I clicked through to here and found the ETh USD one. Now I actually clicked through that because there's a couple of proxies on this contract. So once I clicked through there were two proxies, then I got to this contract right here. So as you can see it's an aggregator contract, has a bunch of code right there. But importantly, what I went and looked for is to see if there's actually events being emitted here. So this one, as you can see has a lot of the chain link events.
00:08:09.374 - 00:08:46.880, Speaker B: Response received, answer updated. So I knew this is one of the contracts I wanted to get in the subgraph. So once you realize that you go and you just copy the contract address and paste it there and this should work. So we'll just name this subgraph, chain link hackathon. Okay? Yeah. So they want you to prefix it with your GitHub name first and then type it in and we will create that. It's on main net, that's the contract address.
00:08:46.880 - 00:09:44.242, Speaker B: And so now it fetched the API from Etherscan and it's kind of building the scaffold for the subgraph folder. And luckily all this is done for you very easily to get you set up and then we'll have some files in there and I'll explain to you what's going on in all those files and do a pretty simple example of how to just get a subgraph started, build one of the entities from a chainlink subgraph or from the chainlink contracts, and then deploy it to the hosted service. So yeah, at this point we have the folder built. I will open it in vs code. So we have the code there. And first what we'll want to do is go back to the graph explorer. And so we're building this on the hosted service.
00:09:44.242 - 00:10:34.558, Speaker B: So you want to create a subgraph there. And we'll just name this chain link, hackathon and subgraph example for hackathon. And there's some other fields here that you can fill in. You can hide the subgraph if you want, but I'll leave this one so that everybody can see it and we create it. So now we're at this place where you have an undeployed subgraph. There are some instructions here explaining what you need to do, but I will also be able to show that as I go through the steps here. So this is the graph init folder that was created by running that command.
00:10:34.558 - 00:11:04.570, Speaker B: It is basically connected to that contract that I found on Etherscan. It pulled this Abi from there. And what it did is it auto generated some files, some typescript files that we can use. And essentially we have like a base subgraph right now. So first place to start, look at the package JSON file. We have a couple scripts for you here. And so this is graph Cli.
00:11:04.570 - 00:11:40.070, Speaker B: Graph code gen essentially creates the auto generated files based on the abis that you pulled from Etherscan or wherever else you got them, as well as it creates these entity types. And the only one we have right now is the example entity. But we will make our own entity very soon based on some of the chain link events. So yeah, we got that. We have graph build and also graph deploy. So we'll run graph deploy later. And that's what actually takes the subgraph code and pushes it to the hosted service in the explorer.
00:11:40.070 - 00:12:28.514, Speaker B: And we're using graph ClI and graph ts as dependencies here. Next good place to look is the subgraph manifest. So this is basically just a file that explains to the subgraph what we're doing, what we're indexing. So the data source is an ethereum contract. We're on main net, you give it the actual contract address. And so this stuff here was now auto generated by the ABI. So these are all of the events that are actually abinted so this is kind of a basic, when we run graphenet, it's more of a basic kind of just, it takes the ABI and creates entities out of the event names.
00:12:28.514 - 00:13:10.002, Speaker B: And it also has event handlers down here. Now, what we're going to do is we're just going to make an example for an entity called round to make it simple, because graph init really is just a way to start. But really you should be looking at the contracts yourself, figuring out how you want to build out your subgraph. And it's going to actually takes a little bit more effort on your own to build it out. And then here's all the event handlers. So, with the graph, you can trigger on events, which is usually the typical way that I've seen subgraphs built. And most smart contracts out there actually have events at the end of a function to explain what happened.
00:13:10.002 - 00:13:17.158, Speaker B: And this makes it really easy to do subgraph development. Sometimes there are contract functions that don't have any.
00:13:17.244 - 00:13:21.190, Speaker A: David, just real quick, we can't quite see your terminal.
00:13:25.530 - 00:13:27.180, Speaker B: Like. Like this one.
00:13:28.590 - 00:13:30.666, Speaker A: No, still not quite.
00:13:30.768 - 00:13:31.980, Speaker B: What can you see?
00:13:32.350 - 00:13:35.290, Speaker A: Chain link. The graph. Hackthong workshop.
00:13:36.590 - 00:13:38.220, Speaker B: Oh, okay. Interesting.
00:13:39.230 - 00:13:43.200, Speaker A: It looks like maybe if you pull it over, pull the terminal window over to this screen.
00:13:44.370 - 00:13:46.000, Speaker B: Which screen are you seeing?
00:13:47.010 - 00:13:50.160, Speaker A: We can see where your mouse is right now. Your mouse moving around.
00:13:50.630 - 00:14:02.514, Speaker B: Do you see, like my. Oh, wait, now do you see my terminal? Yeah. Okay, sorry.
00:14:02.552 - 00:14:03.006, Speaker A: We got it.
00:14:03.048 - 00:14:03.670, Speaker B: Sorry about that.
00:14:03.740 - 00:14:04.182, Speaker A: No worries.
00:14:04.236 - 00:14:38.830, Speaker B: Yeah, so I'm not sure if you guys saw this stuff before, but essentially this is the graph explorer right here, and I've created a subgraph. Got everything working there. Now I'm working in vs code. I got basically the subgraph started up here. What I've kind of explained. Yeah, I went on Etherscan. I got the file from Etherscan, the ABi, and this was all auto generated.
00:14:38.830 - 00:15:23.002, Speaker B: Now we have this basic subgraph, and what we can do is we can start actually building it out. So if we go to Etherscan, this is just going to be a really simple example. But here's the code for the contract that I pulled. And there's an event that I want to work with called new round. Yeah, so as you can see, there's this event called new round, and we can trigger on all these events and store this data in a subgraph. So this is a pretty simple one. If we go here, got this entity called round.
00:15:23.002 - 00:16:02.554, Speaker B: Now we got to create it in the schema. So this is graphql, what I was talking about before. And this example entity is just one that gets created automatically, so we don't actually need it. What we'll do is we'll go type round and just do something really simple. And there's only two fields on this event, so we will keep it simple. And an id is something that is always needed in graphql or at least in how we're using it. So you'll see that in a second.
00:16:02.554 - 00:16:49.594, Speaker B: So now I have a simple entity type. We have named it in the subgraph manifest right here we have all these handlers for events. And now this is where a lot of the heavier kind of work is for the subgraph. So as you can see here, this is all example code that was auto generated and it kind of just explains what's happening. You'll get this when you do graph in it. But essentially this example entity that we got rid of, you're just loading it, creating a new entity here if it doesn't exist. And you're just taking some of the event parameters and saving them to the entity and then eventually writing save to the store.
00:16:49.594 - 00:17:16.302, Speaker B: And this is a pretty basic, I'm going to rewrite this code for the example we just did. And we can do that. And then there's some more detail here. And this is all in the notes, of course, or, sorry, in our docs. But essentially what we're doing is we're triggering on events and we're pulling event data. That's pretty normal. What you can also do is when an event triggers, you can call directly into a contract.
00:17:16.302 - 00:18:00.160, Speaker B: So right here we have contract, which is just a generic name created by graphene, it for the chainlink aggregator contract that I imported from Etherscan. And you're binding it to the event address. So whatever contract emitted the event, that contract's address. And now you can go to that contract and start calling any of the public functions or external functions on that contract. So you can get latest round, latest timestamp owner, whatever you want. So really the good thing to note is like you can really get any data you want from a smart contract. You just need something to trigger on, which could be a call handler or an event handler, which are the two most common that we use.
00:18:00.160 - 00:19:02.530, Speaker B: So I will delete all this. If you remember, we were looking at the new round event. So what I'll do next is we'll run yarn code, or first we'll just run yarn to install the dependencies they might have already been installed, but we'll do it again. And then you run yarn code gen. So code gen essentially just makes auto generated code, you will see it in the generated folder. And the schema one is creating this round entity that I created over here, which makes it really easy for us to set and get for these kinds of entities. And then the contract file, this is based on the Abi, this is where we get all the public function calls, this is where we get the event parameters.
00:19:02.530 - 00:19:34.062, Speaker B: So luckily you don't really have to look at this, you just have to understand how to use it. And if we go here we just ran yarn code gen. So example entity no longer exists because we deleted it from the schema. But round does exist. So we'll import round from the generated file and handle new rounds. So if we look at it we'll just go event params. So you see there's two event parameters on this event.
00:19:34.062 - 00:20:32.622, Speaker B: It's the round id and started by round id is obviously just the number of the round for this chain link aggregator. And started by is probably an address of the person who started the round or the node operator. So whenever a new round happens you would probably want to make a new round and you have to set the id. So when it comes to setting ids with a subgraph, you have to just think what is a unique id that I can attribute to this entity. So a large chain link subgraph might actually have multiple contracts that we're using. So we're only using the ETh USD contract here or the price feed. And so you could imagine you're using all the chain link price feeds, in which case they will all have around with the number ten.
00:20:32.622 - 00:21:35.958, Speaker B: So you have to make it unique. So what we're going to do is we're going to use the contract address. So we start off with event address of this specific contract. We make it two hex string. So these are just parts of graph ts from the dependencies that we installed. And then we're just going to make it into a string with a dash here and then we're going to concate it again and we will use the round id and also make it into a string because all ids must be strings in a subgraph. So now we have the id, we're creating a new round and we're going to run round started by is equal to event params started by and then we save it to the store, which is exactly what we want to see.
00:21:35.958 - 00:22:24.562, Speaker B: So this is very basic mapping. It's going to store this round, we're going to see it in the subgraph. But there's a lot you could do here and this is where basically most of your work will come in. And there's so much room here to build interesting applications. Some, like the uniswap subgraph are massive and have so much data in them. I'm sure there's a ton that we can do with Chainlink and anything else you guys can think of. But essentially, yeah, we're at this point now and one other thing I would like to do is you'll see this in the documentation, but essentially we can set a start block for the subgraph to start indexing data.
00:22:24.562 - 00:23:29.574, Speaker B: So this is like a hint to the subgraph of where to start, because otherwise if we don't pass this parameter, it'll actually start at block zero because the subgraph doesn't necessarily know when this smart contract was put on the Ethereum main net. So easiest way to do that is just go to Etherscan, go to the creation transaction and copy the start block there and we'll put that right there and should be good to go. And at this point now what we want to do is, yeah, we're going to run yarn deploy. So what this means is we're going to build the subgraph because deploy also builds it. We're pushing it to the hosted service node as well as the hosted service ipfs. And this is going to my GitHub name as well as a Chainlink hackathon. And that is what I created right here in the dashboard when I did add subgraph.
00:23:29.574 - 00:24:14.920, Speaker B: So you do add subgraph, you give it a name, you get here, and at this point I can go yarn deploy. So this is pushing it to our hosted service and uploading it to ipfs so that the graph node can grab those files. What it's doing is pushing up webassembly files that were compiled from the assembly script code that I just wrote. So perfect, it looks like it was successful. You can click through and go to your subgraph right here. And as you can see, yeah, I put in block 9.20 something million and it's already skipped syncing all of those blocks because that's exactly what we told it to.
00:24:14.920 - 00:24:47.698, Speaker B: This is a basic subgraph. What you can see here is it'll always come up with an example query for here. Luckily we only have a single entity around. So it's saying first five rounds and what you do is you press play and you're querying it. So right now I have this round id. Here's the contract address. Exactly what we set in the, exactly what we set in the mapping id equals event address.
00:24:47.698 - 00:25:12.166, Speaker B: Plus the round id, and then started by as one of the fields. And you can see that's exactly what we have here. This is the event address. It stored it for round two, and it was started by likely this node operator. And so that's a basic subgraph that's working. There's a lot more you can see here. Here's all the logs of what's happening on the subgraph.
00:25:12.166 - 00:26:01.580, Speaker B: So it's scanning all these blocks, it's looking for events, and when it finds them, it triggers on them. And you have a lot more info if you want to go into it here. And you'll see a lot more rich kind of logs when you actually have more handlers running, more data being stored. And if you ever run into an error where your subgraph doesn't build, you will actually see it here and it'll stop syncing, or it'll just say error, and it'll give, usually an explanation in the logs here. And you can kind of see and you can debug from there. And if you ever have any questions, you can always come into our discord, and we're always here to help. We have people online there all the time, so definitely just ask us any questions.
00:26:01.580 - 00:26:57.702, Speaker B: And so this is where you can see a little bit of the power of graphql. We don't have a lot of data here, but you can query by a lot of things here. So we can do specifically this id right here, and it'll show up as just this round. And you can also do, this is all in our documentation as well. But you can do more complex things, even though this is still very simple. You're basically filtering on fields when you use the where filter and started by. So you got to do rounds if you want to use the where filter.
00:26:57.702 - 00:27:46.758, Speaker B: But as you can see, this will also return. And this is very powerful. People use it like, if you're running a front end application, a really good example of one that's working right now. So Uniswap is, hopefully a lot of you are familiar with Uniswap, but it's just a simple protocol with basically add liquidity, adding liquidity, removing liquidity to a uniswap pool, and then trading. But all this rich data has been built with a subgraph. Essentially, every single handler for the subgraph has a ton of information in it, and it's building every single trade into some sort of historical data. And it's calculating the volume for the last 24 hours on raft ether.
00:27:46.758 - 00:28:33.100, Speaker B: It's calculating the liquidity right now. It's doing all this information. So the sky is really the limit when you want to build a subgraph and you have all this rich data to actually index. And there's a ton that you could build with Chainlink and that's what we'll be getting into soon. But essentially, yeah, I mean, that's a basic subgraph. If you go through the documentation, there's a lot more detail here and I'll quickly go through it just to give you guys some ideas. So this is kind of all the stuff I've stepped through in the example.
00:28:33.100 - 00:28:58.740, Speaker B: Some other things to note. Like I said, call handlers. These are when you want to trigger on just a function call on a contract and you don't have any events to act on. You might not have to use those for the chain link contracts. I looked through them briefly and there's some good events emitted, so that probably won't be needed. But we'll see. It depends on what other contracts you want to tie in.
00:28:58.740 - 00:30:00.610, Speaker B: We also have block handlers, which basically trigger on every single block that happens in Ethereum. And another thing that can be done is you can basically interact with any file on ipfs. So that's how you can get a lot of kind of more metadata into your subgraph. And we use it a lot for scenarios when you maybe have account data or some sort of organization data that is just like name, country, a description. And you don't want to store all that data on chain because it would take so much space. So what you do instead is you have an event in your smart contract. You pin an IPFS hash in an event on that smart contract and then the subgraph can actually read that ipfs hash, take it and then go query ipfs, get the data that we stored at that ipfs file location and then inject it into a subgraph.
00:30:00.610 - 00:30:55.486, Speaker B: So this really makes for a strong scenario where you can build real dapps that have both metadata, which is cheap to insert, as well as expensive smart contract data like asset values and ERC 20 tokens and all of that. And more explanations about how to query on the explorer. Ton of good documentation here. The Graphql API, what you can query. Here's more of the filters that we use, order by order direction. And really this stuff is when you're building a subgraph, definitely refer to this resource as it'll be very helpful. And that's pretty much the basics for a subgraph.
00:30:55.486 - 00:31:56.620, Speaker B: And what I would say at this point is there's a lot of things you can build with it what we're hoping to see for the hackathon, like we said, two subgraphs or two prizes, $1,500. A best new subgraph would be amazing. So you don't have to use chain link, but this is the chain link hackathon. And if you build a chain link, Oracle, you're going to have, or you build with the chainlink, Oracle, and you use a subgraph, you have a good chance to win both prizes. And the kind of things that we would be really interested to see would be something like, anyhow, this is the Chainlink website where they kind of show all the feeds that are running on chainlink. If you go here, they have a ton of them already here. The epusd one might be the one that has the most node operators on it.
00:31:56.620 - 00:32:44.054, Speaker B: And what's happening here, all these node operators are there posting a price. They get aggregated to this single price. There's all this metadata on the side here. But essentially this is really rich information already on the Chainlink network running on Ethereum. But with a subgraph you could get all of this data and put it into a subgraph as well. And so I'm not sure how Chainlink is running this right now, but you could run something like this, get all this data, and then you could also use the subgraph to dig into these specific oracles and give rich data on them. So in that kind of scenario, maybe link pool, you could get all their historical posts.
00:32:44.054 - 00:33:12.850, Speaker B: What time they post, did they miss any? And then you could get really rich. So you could be a cool dap, would be something interactive like this where you could maybe see all the oracles in their historical data. You might even be able to see the historical price of ETH USD and how Chainlink has reported on it and all their node operators. And there's really a ton of data that could be, there's always a ton of data that could be extracted from these smart contracts.
00:33:14.070 - 00:33:56.450, Speaker A: I just wanted to add one thing here as well. You're making a lot of really good points. If anybody came to Thomas's AMA right before this, you heard him talking about the different reputation sites. One of the big ones right now is going to be reputation link. And having something like the graph to kind of query the reputation of oracles and query who's getting selected as the medium answer or the median answer here would be really interesting and really insightful information. So that alone would be like one really cool use case is building your own third party reputation site using the graph.
00:33:58.070 - 00:34:29.314, Speaker B: Yeah, that would be really cool stuff like that. Really interesting. There's so much you can build with the graph and reputation like that is something that's really hard to show on chain just manually. But a subgraph makes it really easy to do. So something like that. Reputation, the chain link price feeds. So this is just ETH USD, but your subgraph could include all of these BTC USD.
00:34:29.314 - 00:35:21.854, Speaker B: And each single price feed has a certain amount of actual node operators that are submitting prices. So there's a ton of data here. You could build that out. Something else that would actually be interesting as well is just even the chainlink network from a different perspective, this is just looking at the price feeds, but we could look at the chainlink network and maybe how much link is being spent to put these oracle results on chain. So throughout the history of Chainlink, as long as it's been running, there's obviously been people who have been paying to post these feeds in the fee that is charged in link. And you could see some kind of historical data. Maybe back in 2018 it was only a couple of $1,000, but now it could be up to tens of thousands of dollars, I'm not sure.
00:35:21.854 - 00:37:07.690, Speaker B: But you could show some sort of historical kind of maybe like health of the network or usage of the chainlink network, which would be super interesting to see as well because I'm sure it's grown a ton in the last few months, especially with all the defi stuff that's going on. And Chainlink is one of the largest oracle providers for all of those. So it'd be really interesting to see how much use has gone through there. And a third example that I think would be really good would be I'll just find this blog that we posted in the past. Yeah, actually I know where it is. It, yeah, so this is a blog we posted about basically how well that chain link in the graph can benefit each other. And something that we described here is using Chainlink oracles to actually put, or the way to describe it would be use a subgraph to take data from smart contracts, index it on a subgraph, and then have that indexed subgraph data actually be put into chainlink or to a node operator through something called an external adapter, which maybe Patrick can comment on in a minute or so, and basically kind of route that data from the subgraph to a chain link node operator.
00:37:07.690 - 00:37:33.942, Speaker B: And then that node operator can actually post it on chain. Essentially it kind of looks something like this diagram. Something happens on a blockchain, the graph indexes it. You get that index result and then you pass it to a chainlink oracle, and that Chainlink Oracle can actually put it back on the blockchain and you get this kind of loop here, which gives us a lot of power to do a lot of things.
00:37:34.076 - 00:38:10.114, Speaker A: Yeah. For those of you. Yeah, exactly what David, just know building an external adapter for the graph would allow you to do all this off chain analysis through the graph. Again, you're seeing how powerful of a tool it is here. And then use that data that you just generated back on chain in your smart contracts using an external adapter. So tomorrow there's a workshop on building and working with external adapters and how to use those. We also just put a video out on the Chainlink engineering tutorials, literally doing step by step how to do it.
00:38:10.114 - 00:38:24.120, Speaker A: It's also in one of our latest blog posts and it's in the documentation. So if you're looking to build an external adapter with the graph, there's a ton of resources out there and you can always ask in the discord as well for more support there.
00:38:25.870 - 00:39:37.630, Speaker B: Yeah, and it's really cool. If you use the graph and chain link in combination, you can almost get a kind of like a layer two kind of network to do the computation off chain, which is pretty interesting because something happens on chain which the graph indexes. And when the graph is a decentralized network, it would be more reliable that nobody has injected incorrect data into the subgraph. But essentially, yeah, if you can know exactly what the subgraph will return, that means you could send that data to Chainlink. You know, the chainlink node operator will post it on chain and then all of a sudden you're doing computation off chain but in approval way that you can get it back on. Is that working as an actual layer two is probably far in the future, but we can do it right now and at least get that data on chain and see that loop happen, which would be really interesting for both the graph and chain link to see. Those are three examples of what we really want to see.
00:39:37.630 - 00:39:48.820, Speaker B: And other than that, if you guys have any questions right now, I'd love to answer them and hopefully clear up anything in the presentation that was unclear or if you have any questions.
00:40:03.110 - 00:40:49.380, Speaker A: You cool. Well, it looks like we finished a few minutes early here and it looks like nobody has any questions, which means that we're all going to see some really cool graph stuff. So for those of you watching again in the discord, we have a support channel for the graph as well. You can leave your questions there and yeah, really excited to see all the cool stuff that you can build, because as David just showed, it's a really powerful tool you can use to enhance your smart contracts to do even more interesting things. Thank you, David, so much for being here. And, yeah, like I said, thank you, all the attendees for being here and looking forward to see what you build.
00:40:50.070 - 00:40:53.860, Speaker B: Thanks, guys. Yeah, just talk to us in discord if you have any questions.
00:40:54.950 - 00:40:55.890, Speaker A: All right, awesome.
00:40:55.960 - 00:40:57.362, Speaker B: Thanks, Patrick. Signing off.
00:40:57.416 - 00:40:59.630, Speaker A: Thank you, guys. Bye.
