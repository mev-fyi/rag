00:00:10.820 - 00:00:33.984, Speaker A: So, thank you, everybody, for joining us to our Chainlink external adapter workshop. My name is Rory. I'm the community manager for Chainlink. Joining us here today. Our speaker panelists are Dan Forbes, who's our Chainlink developer advocate, and then Johnny Huxtable, who works on the development team for Chainlink. And, of course, is a co founder of Linkpool. And I'm sure he'll discuss kind of a little bit more about that as well.
00:00:33.984 - 00:01:00.596, Speaker A: We'll be talking about some cool things that Linkpool has done to sort of make this process easier on everybody. And then last but not least, Thomas, who's here. He may or may not speak. I'm sure he'll pop in when necessary. But he's our integration engineer at Chainlink, and his job is really to deal with these sort of integrations, all the cool projects that you see that are working with us. His job is basically to help them make that as seamless as possible to integrate Chainlink. So, kind of a brief summary of what we're going to be discussing here today.
00:01:00.596 - 00:01:42.912, Speaker A: The purpose of this workshop is to showcase the power of Chainlink external adapters and their ability to extend the capabilities of the chainlink node, as well as explore their role in the Chainlink ecosystem. Participants will be guided through a process of creating Chainlink external adapters and using it to request real world data from a Chainlink node. This workshop will feature the Linkpool Bridges library. Again, a link is available in the description as well, which makes writing Chainlink external adapters in the go programming language easy. Johnny Huxable of Linkpool, co founder, tech lead, and member of the Chainlink Core development team, also offers insights on external adapter development, the Linkpool Bridges library, and the marketplace for external adapters. So, again, thank you all for joining us. I'm going to go ahead and turn it over to Dan and Johnny to present.
00:01:42.912 - 00:02:04.300, Speaker A: If you have any questions, feel free to ask them in the sort of chat. And as there's a moment to, I'll be happy to pause. Dan or Johnny, we'll answer that question. And then again, we will have a little Q a time as well. So if you can't get it in, no worries. And if you don't feel comfortable sharing in here, please feel free to do so in our discord as well. So, thank you, Dan and Johnny, it's all yours.
00:02:05.120 - 00:02:42.120, Speaker B: Awesome. Thanks for that great introduction, Rory. We're really excited to be here. Is everyone able to see me? Am I showing up, or is it still okay? Cool. So, yeah, this is kind of our first official chainlink developer workshop. And so this is very exciting for me. We're really looking forward to using these as an opportunity to kind of engage with the community and everything and share some of the cool tech with you and walk you through some of these things that may seem a little bit, maybe not like something you've done before, but that's kind of what I'm here to do is help it seem a little bit more accessible.
00:02:42.120 - 00:03:59.090, Speaker B: And the thing is that a lot of these things I'm kind of doing as well, and I'm having to ask people questions. And so I definitely understand that you will probably have your own questions as you go through and you do these things. And so I'm really hoping that as you watch these workshops, what you're encouraged to do is kind of come into our discord channels, join the community, ask questions, ask me questions, and then eventually start answering questions. So that's really what the hope of all of this is, is to increase knowledge and make you all more knowledgeable than me eventually is the goal of this. So I think Rory gave a really great introduction, know kind of what we're doing today with external adapters, just kind of a little background into external adapters to kind of start kicking things off. The Chainlink node exposes capabilities related to requesting real world data, and there are some built in capabilities, functionalities that it has, like reaching out to HTTP endpoints and doing that kind of stuff. But I'm sure that as many of you are learning as you're going through your hackathon submissions, we have our virtual hackathon going on, right.
00:03:59.090 - 00:05:05.620, Speaker B: Know it's likely that you're going to want to do some kind of more complicated or custom stuff. And so that's where the external adapters really come in, is they allow you to kind of extend the capabilities of the chain link node, as Rory was saying, in kind of a custom way, so you can build in lots of business logic and all that kind of stuff. So what we're going to talk about today is how you create an external adapter from scratch, how you kind of hook it up to your chainlink node and then actually using it to request data from the Chainlink node to the real world. So Rory did a great job of going through kind of the first paragraph here, but let's just kind of talk about what you might see as you continue to go through the workshop link that Rory put there in the Zoom chat. If you're watching on YouTube, this will be in the YouTube description or whatever. So this is a document that's going to live on for better or for worse. It will be there for people to reference.
00:05:05.620 - 00:05:49.344, Speaker B: So we're going to be using AWS to host our external adapter. External adapters are just like little pieces of code that encapsulate this custom functionality that you want to write. And so they need to run somewhere. Just like your chainlink node needs to run somewhere, your external adapter needs to run somewhere. And AWS has this really cool product called lambda, which allows you to run little pieces of code very easily. And so that's what we're going to use for this workshop. Now, one of the ways that we make these workshops digestible and accessible and that kind of stuff is by scoping them appropriately.
00:05:49.344 - 00:06:26.610, Speaker B: And so the scope of this workshop is really focused on external developer, external adapter development and usage. So you will see me interacting with the chain link node, and I just kind of have that running locally. So that is not within the scope of this workshop. This workshop kind of assumes that you know how to run a chain link node. If you don't, that's cool. I'm here to answer those questions for you, but just maybe not within the context of this workshop. So that would be a great opportunity for you to join Discord and learn more about how to do that.
00:06:26.610 - 00:06:58.452, Speaker B: You'll also see that we're building on a previous workshop, which I linked to. You can find a similar document there and the recording all right there in the document. And so that's what this document is going to be too. So as Rory said, we're going to be using bridges to build our adapter. And Bridges is a go library. Go is a programming language that was written by Google. Programming languages are actually kind of like programs.
00:06:58.452 - 00:07:32.164, Speaker B: And so this is a program that was written by Google and they call it go. And then in order to kind of get your adapter out into AWS, you need to zip it up, you need to create an archive of it. And so we're going to use this tool called Zip to do that. And so you should have that on your computer as well. So just like the previous workshop with remix, I'm just using some good old fashioned code that I found on GitHub. It's actually right there in the Linkpool Bridges library. And we'll take a look at that here in just 1 second.
00:07:32.164 - 00:08:13.244, Speaker B: I promise I'll share my screen and you'll stop having to look at my ugly mug here in just a second. But one thing that I wanted to say as part of this workshop. I'm sure that a lot of you are people who may not have written a lot of code in the past or have interacted with a lot of code in the past. I encourage you to become accustomed as like viewing code as a resource, just like any other documentation that you find out there. You should kind of think in terms of reading code just like you would an article or something like that. And it's really a very useful and powerful way to understand these concepts. So with that in mind, I'm going to share my screen and you don't have to look at me anymore.
00:08:13.244 - 00:08:20.230, Speaker B: And we can actually start looking at code, which is the cool stuff that we're here to look at. Okay, so is everyone able to see my screen?
00:08:21.240 - 00:08:21.892, Speaker A: Looking good.
00:08:21.946 - 00:08:40.372, Speaker B: Thumbs up. Cool. Thank you. Okay, so let's just go ahead and click here and we'll see the code that I'm talking about. This is the code that we're going to start with. And as I said, it's part of this bridges library that we're going to be using. So this is all out here on GitHub.
00:08:40.372 - 00:09:17.012, Speaker B: So this is kind of friendly documentation, which you absolutely should read. I needed to read this as I was preparing for this workshop. Basically, all that I'm doing is kind of reiterating what you find here. But of course, I had questions along the way, and so I went into this examples directory and I used this cryptocompair example to kind of help me answer some of my questions. And in fact, this is what we're going to use as the starting point for our workshop today. So let's go ahead and do that. We're going to save the code to a file called Main go.
00:09:17.012 - 00:10:09.000, Speaker B: And just like in the previous workshop with remix and chain link, I'm just going to be working right on the desktop today because this is pretty simple in terms of the code, pretty simple setup. So we're just going to work right on the desktop and keep things very simple for ourselves. So I'm going to save the code onto the desktop, and I'm just going to. Looks like you can tell I've been preparing, so I'm just going to save it as main go. Okay, there we go. Okay, so now you can see in visual studio code, which is an integrated development environment that you can run on your computer. We talked about it a little bit in the last workshop, and it's something that I encourage you all to use.
00:10:09.000 - 00:10:20.330, Speaker B: I like it. It's useful. You should learn to find it useful as well. Let's see, just giving myself a little bit of space. Oh.
00:10:22.700 - 00:10:29.372, Speaker A: And Dan, if you can, can you make the text a little bit bigger or kind of enlarge the text when you're looking at the code at all?
00:10:29.426 - 00:11:04.170, Speaker B: If you can at the code, I will definitely do that, yes, and thank you for that, Rory. That's a great tip. Okay, so the next step here is we're going to use, like I said, go is a programming language, but it's also kind of a program itself. So we're going to use the go program to kind of initialize this project for ourselves, get the go programming language ready to work with the code that we just downloaded. So, let's see, is that still kind of difficult to read?
00:11:05.580 - 00:11:07.128, Speaker A: That's decent for me.
00:11:07.294 - 00:11:08.328, Speaker B: If you could make it a little.
00:11:08.334 - 00:11:10.490, Speaker A: Bit bigger, that'd be great, but that's okay.
00:11:11.200 - 00:11:18.892, Speaker B: Okay, let me just see if I can. I'm assuming that's better.
00:11:19.026 - 00:11:20.588, Speaker A: That is better. Thank you.
00:11:20.754 - 00:11:21.870, Speaker C: Okay, cool.
00:11:22.480 - 00:11:55.624, Speaker B: So, just going to copy that command that I got right out of the workshop document into the integrated console here. That's part of visual studio code, and we can talk about this for a second. So we're using the go programming language, and we're saying that we want to initialize a new Go module, which is just like a little unit of go code. And I'm just calling this module cryptocompair adapter. Just dead simple. You don't want to do this in real life. You want to give it some unique name.
00:11:55.624 - 00:12:27.888, Speaker B: So in real life, I would call it like cryptocompairadapter, because that's a domain that I own, and so I know that that will be unique. But for this, we're just going with the simple route, and we're going to call it cryptocompair adapter. And you can see that was indeed very simple. We created the new module just like that. So now we're going to use go to get all the dependencies for this project. And let's talk about what that means exactly. The dependencies are described here in the import section.
00:12:27.888 - 00:13:12.988, Speaker B: So you can see that one of the dependencies is the bridges library, the repository of code where we actually got this example from. And then we also need to use the HTTP repository because this external adapter makes HTTP calls. So before we go further, let's look at this external adapter for a second and actually see what it's doing. So you may have noticed that it was called cryptocompair. So it compares the price of cryptocurrencies with other currencies. And so we are using the bridges library. It exposes these kind of helpful interfaces and functions for creating external adapters.
00:13:12.988 - 00:14:04.384, Speaker B: So here we're kind of hooking in to the bridges capabilities and we are making an HTTP call. This is the business logic that we're doing in our adapter, making this HTTP call, getting the exchange rates for Ethereum to USD yen and euros, and then we just return that result. So this is very simple. This really doesn't add much value on top of the capabilities that Chainlink already exposes, to be quite honest. But that's kind of the point. The point here is to give you the structure to build your own adapter. So when you're building your own adapter, you're going to want to potentially change the name of this struct here.
00:14:04.384 - 00:14:52.128, Speaker B: So it's called something other than cryptocompair, something a little bit more meaningful here in the run function. This is where all your magic happens. This is the main implementation that's going to return the response. So maybe you're reaching out to multiple endpoints and aggregating those values in some way, or I don't know what you may be doing in your adapter. This is where all the magic is going to happen and so this is where you're going to get creative and make some cool stuff happen. OpS is just a very simple way of kind of telling the chainlink ecosystem about this adapter that you're creating. It's just a way that the Bridges library kind of exposes it and then the main function is what kind of bootstraps everything and gets this all running for us.
00:14:52.128 - 00:15:18.776, Speaker B: So we start a new server and it's going to serve this external adapter functionality. I'm going to pause here and ask Johnny if there's anything that he would like to add. Johnny is like the tech lead for Linkpool, the company that created this library. So I'm sure he has a lot of stuff to add and I look forward to hearing what he has to say.
00:15:18.878 - 00:16:25.424, Speaker C: Sure. Thanks Dan, and great run, really. You know, Bridges was built as a common library and interface to be able to help any developer build an adapter without needing to have the knowledge behind the scenes of how Chainlink manages the schema, request response to and back from the adapters. It allows you just to focus on what you're doing within the adapter without worrying about how to build your adapter. So it actually works with ChainLinkit abstracts a lot of the complexities out of building an adapter to begin with because the idea for bridges really came around when earlier on I've been building adapters, like various adapters over time in different languages from JavaScript and Golang. And I had the idea I'm sort of reinventing the wheel every time I build an adapter. I'm always building the web server, I'm always building how to handle the request and response from the chain link node and back.
00:16:25.424 - 00:17:47.400, Speaker C: So that's what kicked the idea off for bridges, because you only have to worry about what data you get, what you do with that data, your business logic within the adapter, and you don't have to care about anything else. The good thing is about that as well. Like you said, with running on Lambda you've got built in support for Lambda and GCP as well. Gcp functions, so it makes running external adapters within serverless frameworks very easy. James, unfortunately not. There's not one for Node JS, but if you was looking to build an adapter in Node JS, I'd look at some of the examples under the smart contract repository. There's some good simple examples there on how to build an adapter in general, I'd say Node JS is like if you build an adapter from scratch, Node JS is slightly simpler than using Golang, but I'd say Golang overall the time it takes to response like the latency is quicker and it's a lot more hardened and it's not as resource intensive in my opinion.
00:17:47.400 - 00:18:44.030, Speaker C: But yeah, for me the overall point of bridges is really to abstract a lot of the complexity and just to let the developers focus on the logic and the data you're getting in your adapters rather than anything else. Ever since writing it, the adapters I've built over time I've reworked to support within bridges and like Dan showed the readme as well. And there's some good along with the crypto compare example what we're looking at now, there's some other examples as well. One of them is the asset price adapter, which is a far more complicated example which calls, I think at the minute it's got like up to, it supports up to twelve exchanges and it aggregates the price based on the weighted average of volume. So that's an interesting one if people want to check out for more of a complex adapter use case.
00:18:46.000 - 00:18:51.340, Speaker B: Awesome. Looks like we got another question here in Zoom.
00:18:53.700 - 00:19:00.240, Speaker C: Neil's it's up to the node operator to be able to specify their credentials.
00:19:01.460 - 00:19:07.316, Speaker B: So for example, if actually Johnny, for the people who may be watching on YouTube, can you repeat the question?
00:19:07.418 - 00:20:01.190, Speaker C: Oh, yeah, sure. So the question was, if you use authentication on a request, does the node operator need to specify their credentials to which? Yes. So, for example, if you're subscribing to rapid API, which is like an API marketplace, which has a plethora of different sources on there, you'll need to provide your own rapid API key as a node operator. So each node operator who you are calling will use their own credentials for the request. In the future, when secure enclaves become a thing in the chainlink network, and that's further along developed, then potentially you could use encrypted API keys, which are stored on chain for requests, rather than node operators needing to specify their own.
00:20:02.280 - 00:20:12.120, Speaker B: But at the moment, like in this example, we would use like an environment variable in AWS Lambda, typically to have the queue correct.
00:20:12.270 - 00:20:16.970, Speaker C: You might use your own secret manager, for example, for bolstered security. But yes.
00:20:19.260 - 00:20:41.490, Speaker B: These are great questions. This is a great time to ask other questions. If anyone has them, you have a hotline to Johnny Huxtable. This is a rare opportunity, guys. Okay, Rory, I'm going to kind of get back to sharing my screen. Please, as always, feel free to interrupt me. Let me just make sure.
00:20:41.490 - 00:20:50.502, Speaker B: How do I do this? Oh, resume, share. Okay, can everyone see my screen again?
00:20:50.636 - 00:20:51.350, Speaker A: Yep.
00:20:51.870 - 00:21:20.702, Speaker B: Okay, cool. So hopefully you kind of understand the gist of what's going on here. We've kind of talked about adapters a little bit. So let's get back into the workshop, and what we're going to do is we're going to fetch our dependencies. So go get, you can see it's going out. It couldn't be more evocative, right? It's going out and getting the bridges library. So that was very straightforward.
00:21:20.702 - 00:21:57.070, Speaker B: Now we're going to use the go command to build this code. So building it. So taking this source code and turning it into something that a computer can run. And what this o means is we want the output of that operation, the actual program that we're building. We want it to be called cryptocompair adapter, and we're going to put it in a directory called build. So there we go. And then if you look over here, what you can see is that we created a directory called build with something in it called cryptocompair adapter.
00:21:57.070 - 00:22:38.618, Speaker B: And let's actually see what happens when we run what we just built. So I'm just saying, okay, from the directory that I'm in right now, let's go into the build directory, and I want you to execute the crypto compare, adapter, application program, whatever you want to call it. And you can see if you were kind of listening to what Johnny was saying. We're running a server now, so this is basically like a server that's there listening for, I think probably post requests. I'm not exactly sure exactly what's going on in bridges. I think post requests, so it's listening for post requests on port 80 80 and then it's going to serve up this functionality that we are asking it to. So I'm just going to stop that.
00:22:38.618 - 00:23:05.860, Speaker B: That was just something that I was doing for demonstration there. So we have built our code. We saw what we just built. Now let's go ahead and create that zip archive that I was talking about. Okay, so we're using the zip command and I'm going to talk about this j flag here in a second. Johnny and I. The J command doesn't stand for Johnny, but Johnny helped me figure out what it meant earlier today.
00:23:05.860 - 00:23:46.050, Speaker B: But so we're using the zip command. We're going to create an archive that we're just going to call cryptocompairadapter zip. And we want this to contain just one file and it's going to be that binary that we just built, the executable that we just built. And what the J means is, I think it actually stands for junk the path here. So if you don't use this j flag in the zip file, it's going to have a directory called build and then cryptocompair adapter in there. So by providing the J flag, we just put cryptocompair adapter right into the zip file, not under any directory or anything. So let's go ahead and execute that.
00:23:46.050 - 00:24:20.538, Speaker B: There we go. So you can see we now have this zip and let's just go ahead and actually take a look at that. So we can go to our desktop and we can go to crypto compare adapter and you can see there it is, just all by itself, the binary that we built. So I'll close that. Okay, let's see what the next step in our workshop here is. All right, so now we get to go on to AWS Lambda and create our new function. How exciting.
00:24:20.538 - 00:25:02.440, Speaker B: We get to deploy our code. Exciting and scary exciting from scratch here for you. I don't have any functions deployed, so we're going to create a new function. We're going to call it cryptocompair adapter and we're going to use the go one x runtime. So let's see here. Cryptocompair adapter and find the go one x runtime. So function name runtime create function.
00:25:02.440 - 00:25:07.904, Speaker B: Dana, go ahead.
00:25:07.942 - 00:25:12.130, Speaker A: Yeah, I have a question for you. When you have a moment to break or if you can answer it now.
00:25:13.780 - 00:25:14.252, Speaker B: Cool.
00:25:14.326 - 00:25:39.530, Speaker A: All right, I'll read this out loud. Just so everybody has this, the only way to use my adapter is to force the node operator I'm using to run it on its node. So question. So the only way to use my custom adapter is to run my own chain link node or directly write and or persuade other node operators to add my adapter? Or is there some central space where we can push our adapter and all chainlink node operators fetch from there? Thanks for the webinar. Chainlink is amazing.
00:25:41.360 - 00:26:07.830, Speaker B: I couldn't love that question more. That's what we're here to talk about today. So what I'm going to ask is to put that aside for 1 second because that's what johnny is here to really talk about. Link pool is a marketplace for external adapters. It's a very important part of the Chainlink ecosystem. Excellent question. Let's get back to deploying this external adapter and then we'll give Johnny some time to talk about that.
00:26:07.830 - 00:26:45.612, Speaker B: Okay, so we have deployed, sorry, we've started creating the AWS function. Now we have to add the code to our function. And one thing that I did want to say is that in the document here, I talk a little bit about using AWS and you're going to need a credit card to sign up for it. That would be one of the things that I would kind of term out of the scope of this workshop. I encourage you to sign up for AWS, but that's your decision. So we're going to upload a zip file, the zip file that we just made. We're using the go one X runtime.
00:26:45.612 - 00:27:24.956, Speaker B: Now, the handler here, this is the name of the application that we want to execute. And so remember that the zip file contains a single file, one application called cryptocompair adapter. So that's the name of the handler. And then we're just going to upload that zip file. And now we're going to come down here to the environment variables and we're just going to set the Lambda environment variable to true. This is something that was specified in the bridges documentation. So it is always very important to read the documentation and make sure you're following every step.
00:27:24.956 - 00:27:56.432, Speaker B: That's going to solve a lot of problems for you. So I'm going to save what I have now created there. We go and let's just see how we're doing. So we uploaded the zip file with the go runtime. We gave it the right name, we set the environment variable, we saved our changes. Now we have to create a trigger for our function. So we're going to create an API gateway trigger.
00:27:56.432 - 00:28:38.680, Speaker B: We're going to have to create a new API because we're doing it all together here and we're going to use open security. So add a trigger, we're going to do API gateway, we're going to create a new API and we're going to do open security. So all that's in that document. So boom, there it is. API gateway added to our lambda function. Wouldn't it be great if it were that easy? Unfortunately, there's one additional step that we have to do. This is why we have workshops about these.
00:28:38.680 - 00:29:10.066, Speaker B: So let's not worry too much about this right now. This is the magic of AWS. It makes all this easy for us. I loved how Johnny was talking about how Bridges is something that you really shouldn't have to think about. I'm in kind of a funny position because on the one hand I want you all to use Chainlink, but I never want you to think about it. I want it to be so easy that you never think about it. And so that's what AWS is doing for us here.
00:29:10.066 - 00:29:32.474, Speaker B: And so let's take advantage of that. I don't want to think about this. It's complicated. We're thinking about the external adapter right now, but we have to make this one little change. So we're going to go in here and we're going to remove Lambda proxy integration. The adapter doesn't like this for some reason. Honestly, I don't know why I'm letting AWS make it easy for me.
00:29:32.474 - 00:30:02.100, Speaker B: So I removed the integration that went ahead and loaded and now I have to deploy these changes. So I changed the stuff out there on AWS and now I have to deploy it. So it already created the deployment stage for me, which know if you want to have multiple deployments, you can manage it that way. Again, don't worry too much about this. This is all AWS mumbo jumbo. We're just going to deploy these changes. So now we're good to go.
00:30:02.100 - 00:30:39.470, Speaker B: And so let's see how we're doing here. We used the AWS management console to remove the lambda proxy integration and then we deployed the changes. And so the next thing that we're going to do is we're actually going to log in to the chainlink node and add things to the chainlink node. But because I do like to hear myself talk, I'm just going to do one more step to kind of make sure that everything's working so you can test your lambda functions right in AWS. And so I'm going to create a new test. You can see this is a very simple test, so I'm going to give it the name. Simple.
00:30:39.470 - 00:30:56.278, Speaker B: There's no parameters. Our adapter is simple. Just want to make sure that everything works. So now I have that test configuration set up. No parameters, just going to run it. That's a relief. We got some information back.
00:30:56.278 - 00:31:39.358, Speaker B: So this is already a good step. We haven't quite involved the chainlink node yet, but we're really close. So we have built some code, we've packaged it as an archive, and we've exposed it on AWS. And so actually now I can even just go right there in my web browser and just see it working just like that if I wanted to. So that's cool in and of itself, that's like one of those magic moments as a programmer. Like, whoa, I wrote code and now it's running on the interwebs. Okay, so now what we get to do is see this working with our chainlink node.
00:31:39.358 - 00:32:15.520, Speaker B: So I already have the chainlink node running. As I said, that is kind of out of the scope of this workshop. We're just talking about external adapters today. So I'm just logging in to my chainlink node. And what's the first thing that we need to do? We need to add a bridge. So basically Chainlink nodes have this concept of tasks, which are things that they can do. And so we talked about how the chainlink node has some built in capabilities, like related to getting HTTP endpoints and stuff.
00:32:15.520 - 00:32:41.160, Speaker B: So what we're going to do is we're going to add a new type of task. We're going to add this external adapter as a type of task. And the way that we do that is by using a bridge. You may see this timeout error here at the top of my screen. Not material to today's demo. This has to do with the Ethereum network, which we're not touching today. So just ignore that.
00:32:41.160 - 00:33:10.410, Speaker B: Seeing it went away. Isn't that nice? So now what we're going to do is we're going to create a new bridge. And, wow, I think that it probably did this because I think maybe this is chrome or something doing this, but we'll just delete everything. So we're starting from scratch. So the name is going to be cryptocompair. There we go. And the bridge URL.
00:33:10.410 - 00:33:34.450, Speaker B: I really hate doing this to you all. I always try to avoid putting things in these little angle brackets in my workshop demos, because that means it's something that you have to fill in yourself. So one thing, don't ever just copy these angle brackets directly as they are. I've done it before. Other people do it all the time. But don't let it happen to you. It always means fill this in with something that you're providing.
00:33:34.450 - 00:34:11.582, Speaker B: And in this case, there's really no way to escape that, because what we're going to be using is this API endpoint that we created. And as you can see, it's not really user friendly. It's kind of just a unique identifier that you have to know, and so you're going to have to get that and copy that in. But good news is you just copy it and paste it right there. So just making sure that it looks the same and it does, and just leaving minimum contract payment and confirmations as they are not material to this workshop. Going to create bridge. We successfully created the bridge cryptocompair.
00:34:11.582 - 00:34:58.162, Speaker B: So now what that means is that our chainlink node knows about this cryptocompair task that it can execute, and it knows that in order to run that task, what it has to do is activate this endpoint, just like you saw me activate that endpoint in my browser or by hitting the test function in AWS lambda. Okay, so we got our bridge all set up, and now we can create a job, uses this bridge. So a job is the thing that tells the chain link node to invoke the task. So we're going to add a new job. Jobs are described as simple Json blobs. So let's unpack this a little bit. A job has an initiator, which is the thing that starts the job.
00:34:58.162 - 00:35:48.690, Speaker B: So in a lot of cases, this would be like the run log initiator, which is what you would use if you're activating the job from a smart contract. But because today's workshop is very tightly focused on adapters, we're just going to use the web initiator, which means that you can hit an HTTP endpoint to tell your node to activate that job, to run that job. And the only task that we're running is this cryptocompair task that we created. And so you'll see that this task has the exact same name as the bridge that we just created. That is not a mistake. If I change the name and I try to create the job, it won't do that because there is no task named Cryptocommair. So we'll change that back to cryptocompair.
00:35:48.690 - 00:36:04.822, Speaker B: There we go. Now it's successfully created the job. So now what we can do is we can go to the job page. Let's just make sure we're following around. Yes. So the next step is just to run the job. But let's just take a look at what we have.
00:36:04.822 - 00:36:56.694, Speaker B: Here's the definition of the job as JSon. More or less looks like what we created before. And so what you'll see is that because we created this as a job with a web type initiator, we now have this run button available to us. And anytime that you're creating a new job, anytime you're creating a new job, you should always test it out with the web initiator first. Like a lot of people seem to want to run to the cron initiator, bad idea. That means that you are telling the computer to do something many times on a schedule without knowing exactly what that's going to do. So you always want to start with the web initiator, because that way you control when the job is activated, and you do so by hitting this run button right here.
00:36:56.694 - 00:37:17.374, Speaker B: So I'm going to do that. I'm going to activate my job. You can see that we successfully created the job, and these jobs are asynchronous. So when the job is first created, it's in progress. The chain link node doesn't know at that moment exactly what's going on, but we can click into the job run to learn more about that. And you can see that it completed. It's asynchronous, but it doesn't take very long.
00:37:17.374 - 00:37:59.530, Speaker B: And you can also see that there are green arrows here, which is like, such a sigh of relief for me. That means we made it all the way through the demo without any technical difficulty. So big thanks to Johnny and everyone else who helped me get here. And so what we can do is we can actually look at the JSON of the run result and see that we're getting our results back from the cryptocompair adapter that we wrote. So now that's where, here on the workshop, I have these little rocket ships. This is where you guys go crazy. Build out your adapters, add all kinds of features to them, and then maybe in our next workshop, what we'll learn about is actually creating a job spec to hook that up to a smart contract.
00:37:59.530 - 00:38:20.580, Speaker B: That probably deserves a workshop of its own. So that's kind of all that I got. I am going to stop my screen share and then turn it over to Johnny for any additional context that he'd like to add, specifically with respect to the marketplace for adapters and such.
00:38:21.270 - 00:39:57.970, Speaker C: Thank you Dan. So I'll start off by answering the questions, what have been left open? Niels, sorry if I'm pronouncing your name wrong. I don't know if it's Niles or Niels, but good technical question there, asking in context around the Google blog post how they was using Bigquery. Okay, asking around Bigquery and if you put app engine in front of bigquery to perform the request through app engine which are authenticated, and then building a public get endpoint for those jobs to interact with, the question is if they create an adapter for it instead and provided every node with a service account or credentials with access to read from Bigquery, it would be cleaner or better secured. I'm working with marketing data in Bigquery for the hackathon and I've just created an app engine in front of it like the blog post, but it seems that if I attempt an adapter, it'd be cleaner. Yeah, Niels, I'd agree with you. To be honest, I think if you build the adapter which has service credentials to be able to read from Bigquery, then you could use bridges gcp functions functionality to then host in GCP serverless, which then would remove a layer and you could just simply feed that data from Bigquery within that bridges adapter rather than needing an extra layer on top of that engine.
00:39:57.970 - 00:40:17.530, Speaker C: So yeah, I'd agree with you there. James asked if anything was updated on chain. Unfortunately not, James. The scope of this workshop is just to show adapters working rather than using it within a contract on chain.
00:40:19.790 - 00:40:23.500, Speaker B: That'll be the next workshop. Great question.
00:40:24.590 - 00:41:34.370, Speaker C: And yeah, the last question there is can the cron job you mentioned update a smart contract on the timer? Yes, that's what it's for. That's sort of what you see right now on the aggregator contract in Mainnet. So that's on a cron what runs every five minutes. So yeah, I will just get my local set up working because I'm going to show you the marketplace. So let me just share my screen. Yeah, right. So the marketplace which is at market link is a marketplace that we as Linkpool built or started building earlier this year and we've designed it as a central hub for everything Chainlink we see it as the entry point and a search engine for the Chainlink network.
00:41:34.370 - 00:42:12.160, Speaker C: Similar to think of it as like a block Explorer esque tool for Chainlink. But rather than seeing what's happened already, it's for you to find everything, to be able to build your contracts and to connect them to external data feeds. So adapters are important. And this really ties in to the question that was asked earlier. I can't find the question now around, the question was around forcing node operators to run.
00:42:12.770 - 00:42:16.682, Speaker B: It's in the group chat, Johnny. It's not in the question and answer section.
00:42:16.826 - 00:42:28.146, Speaker C: All right, okay, let me just bring that up then, right? I don't know where my, I know.
00:42:28.168 - 00:42:29.538, Speaker B: It can be so hard to find it.
00:42:29.624 - 00:43:20.370, Speaker C: There we go. But yeah, the marketplace was designed to solve that problem or at least help it. So at the minute as a node operator you pick and choose the adapters that you want to run. And if as a developer you want to build an adapter, then you can of course run it on your own node with no problem. But then you really need somewhere to host that adapter, to advertise it to other node operators so they can find it and they can essentially run it themselves. And then when any contract creators come along and want to use your external adapter for a contract, they're building what needs it, then you can essentially find it and find all the nodes that support that adapter. So just to give a quick run through for people who have not seen the market before.
00:43:20.370 - 00:44:11.250, Speaker C: So this is for anyone to use, anyone can sign up, anyone can add their nodes, jobs, adapters and data sources. At the minute on the main search screen for nodes, you'll see all the nodes listed by their job runs. So is our link pool node at the top fuse, guys underneath chain layer and then on and on. So all these guys on the first couple of pages are all the ones you'll see on the aggregator. So if you go to the heartbeat page, the EUSD chain link, whatever the page, you'll know which one. I mean you'll see all the nodes from there and you can search and you've got links between the two. So to go into adapters you'll see a list of the adapters that the marketplace currently has and people have added.
00:44:11.250 - 00:44:55.650, Speaker C: So you'll see the, if we go to the second page, these are all the built in inbuilt adapters in the chainlink node. So it's the notation of core adapters which are the ones what are developed into the chainlink node themselves. Like the default base inbuilt adapters. These are very primitive, very essential adapters like converting to different data types for the Ethereum network, performing HTTP get copying values for example, and performing like Ethereum transactions as well. And then you'll see the other adapters. So for example the crypto compare external adapter, what Dan showed earlier.
00:44:57.670 - 00:44:58.098, Speaker B: It'S a.
00:44:58.104 - 00:45:52.590, Speaker C: Different adapter, it's not the bridges one, but adapter for a similar purpose. If you delve in, you'll see the readme, you'll see the data source it uses, and then it gives you steps on how to run it yourself and then the responses it gives. So do I. So if I go back and just show other adapters, there's the asset price adapter. This is one I mentioned earlier in the hackathon. And this will aggregate price data from all these different exchanges and it will automatically fetch new pairs on exchanges. If a pair gets added to a new exchange, it'll automatically get updated and then those prices can get queried.
00:45:52.590 - 00:46:58.586, Speaker C: It uses a weighted average of the price based on volume. It's also built with bridges, so you can check that out again, like data sources you can see. So this really is a hub for everything adapters. So for example, with the asset price adapter or any other adapters, you can click in and see supported nodes. And then if you go on there, you'll see a list of all the nodes what support those adapters. So as a developer, if you build an adapter and then people find it of use, you can add it into the marketplace, everyone can see it themselves, and then you can add it to your nodes and other people can add it to their nodes and then you'll find jobs as well which are then supported of that adapter. So for example, if I delve into the Linkpool node under jobs, you'll see here we have an asset price job, an API aggregation alpha vantage, all these the crypto, compare one as well.
00:46:58.586 - 00:47:52.102, Speaker C: At the top, all these are using external adapters. So if I hover over the tasks, so these tasks align with what Dan was showing in the job specification, it just shows it a little bit simpler for end users. You'll see the first one is the asset price adapter, then it uses the copy core adapter, multiply unit 256 in each transaction. So if I go into that job, you'll see it lists all the job specifications, the task list, sorry. You'll be able to see the job spec, which is exactly what Dan was showing earlier when adding it to your node. So you can just copy this JSOn, tweak the address for yourself or change it to a web initiator and then just use it yourself. Then you can also click as well and then find all the similar jobs.
00:47:52.102 - 00:49:10.542, Speaker C: And the similar jobs are jobs that use the same adapters on that request. So as a contract creator, if you was going in and say, right, I want a bunch of nodes and jobs that are calling the asset price adapter because I want to fetch the price of link to USD, for example, then you can go in, find the asset price adapter, find all the nodes that support it, find the job, and then get a list of all the nodes which also support the same job. So that's a one stop shop of being able to build a contract which has many chain link nodes. It's a decentralized request that uses external adapters, calls many data sources, aggregates it based on volume, and then returns the answer back on chain. So as a contract creator, adapter creator, sorry. To simply list an adapter on the marketplace, all you need to do is just define a yaml file in your repository. And we've got some documentation on that within the linkable documentation.
00:49:10.542 - 00:49:17.182, Speaker C: So I'll just show that to show that.
00:49:17.256 - 00:49:53.950, Speaker B: Johnny, while you pull that up, I want to highlight a question and see if maybe Thomas can jump in and answer this one. Will there be more native adapters in the future? Yes, of course, as necessity rises. Cool. And so if people are interested in if you have ideas for native adapters, I just created GitHub issue templates for the chainlink repository. So fill out a feature request. We'd love to hear it. Another quick question.
00:49:53.950 - 00:50:03.490, Speaker B: If you have three APIs you want to return data from, is it better to create an external adapter for each one or include all three calls in one external adapter.
00:50:05.990 - 00:51:22.474, Speaker C: At the minute, it would be better to create an external adapter that calls from all three, and then you can use your own logic to aggregate those values as you see fit because the json return from these endpoints are going to be different. And at this point it'd be simpler to just build an external adapter which then aggregates those values how you see, wish how you wish, and then returns it back to the chain link node. So yeah, just to build from the marketplace, again, to add your adapter onto the marketplace, you just simply define a YAml file in your repository, give it a name, description of what it does, the node identifier. So to explain the node identifier a little bit, this is what Dan entered when he was adding the bridge within the chain link GUI. So that is like the unique identifier for that adapter. So that can be anything you want it to be, but it's got to be unique. There can't be an existing adapter on the marketplace with the same node identifier.
00:51:22.474 - 00:51:54.950, Speaker C: It's got to be unique then the platforms it supports. Currently the market will only allow you to list Docker, AWS, Lambda and gcp functions. If we start seeing adapters that are natively supporting other platforms, of course we'll add them in and we're open to any suggestions as well. For people wanting to add any other platforms, what they're working on. You can define an array of data sources. So just very simple here. I've just said example and obviously example.
00:51:54.950 - 00:53:01.180, Speaker C: But if you're building an adapter which pulls from crypto compare or pulls from binance or wherever it's pulling the data from, then you can list where the data is being pulled from there, which then gives visibility in the marketplace, which then allows people to see exactly what your adapter is doing, where it's pulling from. And then people can compare adapters that pull from the same data sources. There's the parameters as well. So one of the nice things about adapters is they let the contract creators pass in parameters to those adapters. So in context of like when I've been speaking about the asset price adapter that has two parameters, the base currency and the quote currency. So they are the two parameters you'd use to define which trading pair you want to get the price off. So for example, you could give it or, you know, Ethereum to BTC for.
00:53:01.180 - 00:53:28.310, Speaker C: Yeah, and once you've got that defined, then you can just simply log into the marketplace, then log into your GitHub account on the marketplace and add your adapter and then it will appear on there for everyone to see. Other node operators can then run your adapter, they can say on the marketplace that they support it and you'll advertise your adapter that way. That's it really, from me. Thank you, Dan.
00:53:31.050 - 00:54:31.574, Speaker B: Awesome. Any questions for Johnny? While we wait for any questions to roll in, I just want to kind of unpack from my point of view a few things that Johnny said. I love that people were asking questions about this before we even started talking about it because I knew and I hoped that that's what would happen, is that y'all would be developing these external adapters. And then you're like, and now what? And so this is, and now what? Linkpool and other services like it are the chainlink community and the chainlink network brought to life. And so it's really exciting to see stuff like that and what an awesome job Linkpool the marketplace does of making things easy for people with the task UI and everything. That was really cool to see. So keep in mind that for the hackathon that's going on right now, if you're participating in that, you don't need to think in terms of like oh crap, I need to actually get node operators picking up my external adapter.
00:54:31.574 - 00:55:12.280, Speaker B: You should be creating some kind of deployment system that allows you to emulate that locally. So use something like Docker and I can potentially try to create some content around that. But hackathon, the submissions are coming to an end and we got lots of workshops to do. So I encourage you all to learn about docker and stuff like that for how you might kind of package up these hackathon submissions on your own. But I hope that as a result of the hackathon link pool is just flooded with new external adapters. You should all be super excited to put your external adapters up there on link pool. I love being a part of the chainlink community because it is a community.
00:55:12.280 - 00:55:52.482, Speaker B: To me it's a lot like NPM in that we provide this framework for you guys to do all this development. But really it's up to you. We wouldn't be here without you guys. So I'm so excited to see the submissions. I really appreciate Johnny and his time and his input and all the amazing work that he does with not only chainlink but also link pool. We do have another question, so let's get to that really quick. Are there any known privacy concerns currently with using Chainlink? What do we do if dealing with highly sensitive? So I mean, I'll provide my interpretation here.
00:55:52.482 - 00:56:39.378, Speaker B: I would welcome Thomas or Johnny or anyone else to do the same. There should always be privacy concerns. Anytime and always there should be privacy concerns. Any application developer, any smart contract developer should always have privacy concerns. Chainlink exposes a set of capabilities that allows people to address those privacy concerns, and we are constantly working on adding to those capabilities to give smart contract developers more tools in their toolbox to address privacy concerns. What do you do if dealing with highly sensitive API data? You compose the Chainlink capabilities in a way that makes sense for you and your use case. And if you have questions about how to do that, that's what we're here for.
00:56:39.378 - 00:56:47.320, Speaker B: But that's kind of my general, it's a great question and that's kind of my general take on it. Thomas or Johnny, do you have additional context to add?
00:56:48.730 - 00:58:34.680, Speaker C: Sure, I can go yeah. If you're dealing with highly sensitive data before there is SGX support at know you shouldn't post the highly sensitive data back on chain in plain text, because then obviously it's there for everyone to see. You can build an adapter which does some computation on that highly sensitive data and then only returns the actual answer back on chain. And you'd want to drill the answer down. So it's potentially either true or false or just like a specific number, for example, an answer, which means you can then add simple logic within the contract to trigger a certain action, whether that's payment or any really other type of output, or if the data is that sensitive that you don't want people to be running it on their nodes, in the sense of that you don't want even the node operators to find out what data is being computed, then ideally you need to wait for SGX because that will give the hard protection as you will be able to run certain types of computation and even the node operators won't be able to find out the values or any of the secrets that you're working with there. And then you can do more clever things as well, like encrypting data with enclave keys so it can be decrypted by certain parties and things like that. There's a couple of options you can do, but it depends on how sensitive it is really.
00:58:35.950 - 00:59:02.122, Speaker B: That's correct. Sorry, go ahead, Thomas, anything to add? No, I just said that's correct. Okay, excellent. That's a great addition. Appreciate the confirmation. Another way to kind of look at my answer is that security is hard and kind of everything that Chainlink does is related to security and privacy. And so that is kind of connecting some of these thoughts together.
00:59:02.122 - 01:00:02.434, Speaker B: That is why we are here, is to expose capabilities so that you guys don't have to think too hard about the security and privacy stuff. But obviously the fact that you're using Chainlink, it means that you're already thinking about it, which you should be, because these are very important concepts to blockchain development. And so just like everyone else in this space, we are hard at work building out additional capabilities to make privacy more available to. Yeah, I mean, be thinking about these things. Excellent question. And continue to follow our blogs and our Twitter to learn more about the awesome capabilities that are coming out, like SGX support or whatever. So I think from my point of view, I don't see a lot of other questions coming mean if we started at three pass, we're now at exactly an hour, so I don't have anything else to say.
01:00:02.434 - 01:00:05.700, Speaker B: Rory, I'm happy to kick it back to you to kind of close things out.
01:00:06.950 - 01:00:30.282, Speaker A: Yeah, absolutely. Thank you guys so much again for joining us. Looks like we had roughly 25 to 27 attendees at various times, so great turnout. So thank you guys so much. We've recorded this. I'll do my best to get it up as quickly as possible, and then, of course, we'll share that in as many places sort of as we can. Again, we've done some previous workshops as well, smartcontract.com.
01:00:30.282 - 01:00:52.738, Speaker A: Twitter is a great way to see us when all those workshops come live and everything else, as well as in the discord. And we have some more plans. So just let you guys know, we do have finance X presenting a workshop that's going to be tomorrow at 11:00 a.m.. Eastern, very similar to this time. And so they'll be doing that on how to connect to sort of their API. So if you're interested in that. And of course they have some fellowships available as well.
01:00:52.738 - 01:01:17.914, Speaker A: And then later in the week, we're also looking to create another workshop kind of in similar to this one. So hopefully there's something that you'll see consistently from us as we're working to build this out. But again, I just want to thank Dan, Johnny Thomas for being here, for presenting this. If you have any questions, hit us up in the discord as well, or on any other channels that we're on and we'll do our best to answer. So without further ado, thank you guys so much. Have a great day and keep building. Thank you so much.
01:01:17.914 - 01:01:18.118, Speaker A: Bye.
