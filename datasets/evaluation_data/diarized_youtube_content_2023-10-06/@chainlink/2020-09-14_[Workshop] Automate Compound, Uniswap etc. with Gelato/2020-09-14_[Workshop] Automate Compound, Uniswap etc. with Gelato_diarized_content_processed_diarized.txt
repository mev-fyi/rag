00:00:00.170 - 00:00:02.126, Speaker A: Me reasonably well.
00:00:02.228 - 00:00:03.760, Speaker B: You sound perfect.
00:00:04.370 - 00:00:05.520, Speaker A: Okay, great.
00:00:08.370 - 00:00:10.720, Speaker B: We are going live on YouTube. Right?
00:00:13.970 - 00:00:15.760, Speaker A: Great. Okay, cool.
00:00:20.370 - 00:00:26.310, Speaker B: Sorry about that. Okay, cool. We are now live.
00:00:26.460 - 00:00:26.918, Speaker A: Hello.
00:00:27.004 - 00:00:43.642, Speaker B: Welcome, everybody. Thank you for. We're really, really excited for this workshop. We have Lewis here from the gelato network. Something I wanted to point out in particular is that gelato actually came from a hackathon and now they are sponsoring one.
00:00:43.696 - 00:00:44.058, Speaker A: Hello.
00:00:44.144 - 00:00:44.940, Speaker B: How are.
00:00:46.670 - 00:00:47.420, Speaker A: Everyone?
00:00:51.790 - 00:01:17.540, Speaker B: I was just going to say, so it's really exciting to be in this space. You can get up to speed really quickly and go from hackathon to being one of the ones who are actually sponsoring the hackathon. So we're really happy that Lewis and the gelato team is here for the hackathon. Really excited to see this workshop and learn more about how to automate our smart contracts, which is a really powerful feature. And, yeah, thank you so much for being here.
00:01:18.470 - 00:02:04.100, Speaker A: Thank you very much for having me. And, yeah, it's actually quite cool that I'm talking here today now, because it wasn't too long ago that actually last year in the before times, right before Corona, it was when we, with early gelato back then, won a prize at East Berlin in August 2019. And since then, actually, we chatted with Johann and with other people from Chainlink more and more. Now we know you too, Patrick. And yeah, actually Chainlink is now also an integral part of gelato. We use it in our live system to settle on a fair gas price for everyone. So actually, we were also not only a sponsor at the hackathon, we're also sponsoring one of the reference contracts, the public ones, together with tornado cash.
00:02:04.100 - 00:02:42.078, Speaker A: Yeah. So actually, it's quite cool that we are here at the hackathon. It's the first hackathon we're actually at. We are also sponsoring a prize, $1,000. At the moment, we think the best option for gelato is to give it to one winner because gelato is fairly complex and I think it only makes sense to try to get the gelato bounty if you're also willing to put up some substantial amount of time. Because definitely, as you will see now, it isn't exactly super easy. We do have some documentation now, finally.
00:02:42.078 - 00:03:07.718, Speaker A: Also not well documented, but we are definitely online. I'm going to be online until the end of the month. You can hit me up on telegram anytime. And I'm going to be really also happy to help you get my hands dirty and really help you with the code. So that's the good site. And now for today, I think I'm just going to walk you through the documentation that we have online. It's only been up like a week or so.
00:03:07.718 - 00:03:31.920, Speaker A: We made it for the hackathon to at least have something. So there's going to be errors in there probably. But again, just jump in our telegram community channel and we should answer most of your questions there very quickly. All right, let me share my screen. Good. Is that all clear for you? The screen.
00:03:35.830 - 00:03:36.914, Speaker B: Looks good.
00:03:37.112 - 00:03:40.050, Speaker A: All right, cool. You see the gelato documentation?
00:03:40.390 - 00:03:41.186, Speaker B: Yes.
00:03:41.368 - 00:04:11.900, Speaker A: Great. Okay, so, yeah, I think, well, it's going to be a bit dry because I'm going to walk you through the documentation. I would like to answer questions on the fly as well. I'm not quite sure how this is possible, Patrick, but anyways, I'm just going to start, and if people have questions and if this is possible, I would like to answer them. I don't have to wait until the end. It's fine.
00:04:13.310 - 00:04:22.846, Speaker B: Do you see the Q A button at the bottom with the little red one? Yeah. If you hit that, you can see the answers come in and then answer live or type the answer there.
00:04:23.028 - 00:04:35.220, Speaker A: Okay, great. Okay. Yeah, I have it open already. I'm going to look over there every now and then and see if there's new questions. All right, cool. So cool. Let's start.
00:04:35.220 - 00:05:22.222, Speaker A: Gelato is Ethereum's automation protocol. So if you think about smart contracts, they have this promise of autonomous logic being executed safely on Ethereum. Right. But actually automation is very hard because you always need this external impulse. So if you want something to be executed in a smart contract, you need a transaction, right? So you need to, for someone to be online, usually that would be you on like uniswap interface or wherever, and you sign and send a transaction to the Ethereum network and then something happens. This is obviously quite problematic if you want to automate something because, well, you need to be there. You need to sign the stuff with your keys.
00:05:22.222 - 00:06:01.278, Speaker A: And what if you are offline? What if you are sleeping? What if you're on holidays? You can't be there all the time, right? You probably know, maybe you've already missed some nice opportunities or even incurred some losses, like a CDP liquidation, for example, because you weren't online and manually did something, which is really stupid if you think about it, because we're so futuristic here. You really shouldn't have to do this stuff manually. And to be frank, many people don't do it manually. Right. Like there is a lot of people running bots. These bots kind of outcompete normal users that don't run. So Gelato wants to solve that.
00:06:01.278 - 00:07:08.354, Speaker A: And what gelato basically does, it gives DAP developers a very easy toolkit and a finished audited smart contract protocol and a very easy to use on chain API, very actually similar to what Chainlink does for decentralized Oracle. So our goal is to be really developer friendly, make it very easy for them to just outsource all those automation needs to gelato. What does that mean? That basically means that if you are building a DAP from the scratch, or if you want to automate an existing DAP like uniswap or other daps, and some aspects of that should be automated, well, you can basically submit your chart to Gelato and you don't have to run the infrastructure yourself anymore. Like Gelato is a network. At the moment we are running relay services, but there's also other people joining the relay network soon. And basically you don't have to worry about all this infrastructure stuff. You don't have to worry about your depth being centralized, you being the centralized point of failure for your depth.
00:07:08.354 - 00:08:03.750, Speaker A: And you can just write your depth code, solidity or javascript for example, and then have this small chunk of code that just submits your task to Gelato. And that can be anything, that can be any smart contract functionality. And Gelato will take care of executing that logic as specified by your condition. So one very specific thing about gelato is that it has these conditions, we call them conditions. So you can specify what condition needs to be true in the Ethereum market and network for your automation to take place. And then when that condition is true, Gelato will automatically execute that transaction for you. So for example, when a certain price is reached on an automated market maker like Uniswap, you can already submit like schedule a transaction beforehand, and then when that price is there, Gelato will move the funds on your user's behalf or on your behalf.
00:08:03.750 - 00:08:47.510, Speaker A: So Gelato is this very easy to use, out of the box automation solution for you. And basically you can sleep well at night knowing that you don't have to run the servers, you don't have to run the bots in order for your users to be able to have access to a host of automated features and new products, basically. So we definitely are developer product. That's why we also don't have a famous UI or anything like that yet. We're focusing really on helping developers build some of the stuff. That's why we're also at the hackathon. We want to help you understand depth automation, how it can be done in a decentralized fashion and how you can do it very easily with Gelato.
00:08:47.510 - 00:09:37.390, Speaker A: So let's dive a bit more into maybe first some examples if you can't really think of use cases yet. So recently we launched an app that automatically mints chai gas tokens. These are these tokens that can save you gas when gas prices spike. So this gelato dap basically was built by an italian team. They're called Hill, and they basically use gelato on their UI to enable their users to schedule chai minting when the gas prices drop. And this was actually quite nice. I think you also have some dollar cost averaging, right? If you want to do like, say, for example, buy some eth every Friday, you can do that with gelato very easily.
00:09:37.390 - 00:10:05.310, Speaker A: And there's many more use cases. So gelato really doesn't have an opinion about what you build. As long as it exists in solidity on chain, you can combine it into a gelato task. And obviously it has to be bug free for it to work. But if you don't have any bugs, the automation will work. All right, so let's walk through the steps of what it takes to build an automated depth. By the way, you can find these bugs online.
00:10:05.310 - 00:10:58.270, Speaker A: Of course, we've posted a link to them in the discord, in the gelato support channel of the hackathon discord. So creating an automated DAP. Well, in gelato, the first important concept that you need to think about, and this is also actually one of our data structures, very simple one is a task, and a task is just a transaction that should be executed at some point in the future. And the task basically consists of a condition when the transaction should be executed. For example, you might want to execute stuff based on price or based on time. Then what kind of transaction should be executed? That's the action. And then also who should call this transaction? This is usually your user proxy.
00:10:58.270 - 00:11:36.614, Speaker A: So what's very important in gelato as a general concept is because this stuff is supposed to happen in the future on a conditional basis. This is the hard part about it, because that means that you can't do it, right? Like you don't want to do it. You might want to be on a holiday or whatever. So your keys obviously also shouldn't be exposed here. Like, gelato is non custodial. So that's why in gelato we generally deal with the concepts of user proxies. Normally this would be gnosis or any smart contract wallet, and those will be the entities that interact at execution time with the gelato network.
00:11:36.614 - 00:12:18.760, Speaker A: And all the depths for your users. So this normally we will dive into this a bit later, but this normally also means that in order to be able to use gelato, your users have to do like a one time setup where you can choose any smart contract wallet you like. May that be agnosisafe, may that be ethereum or whatever else is out there these days. DS proxy from maker, for example. So a task is a condition, an action, and basically also a user proxy. So let's look into conditions a bit more. And conditions are a bit special because here we do have some standard interface that you need to follow.
00:12:18.760 - 00:13:04.680, Speaker A: And in the docs we have a very simple condition, a valid one, that is tracking time. And all it does, if you can see it here, is it really just like you basically pre specify at what timestamp you want something to occur and then the gelato network of bots will check if a timestamp is there and as soon as it's there they will send the transaction for you. So this condition is very simple. You can see it has a gelato specific thing that you need to override through basic inheritance by just inheriting our standard basic stuff. And this is like probably the simplest condition out there. But conditions could also be a lot complex, more complex. Like you could write conditions to track different prices and compare them.
00:13:04.680 - 00:13:41.362, Speaker A: The basic idea always is that you define a condition in a smart contract. You don't have to write that yourself. Technically. You could also reuse existing condition contracts if you like, some of them, but if you want a custom one, you would write that and deploy that. That contract has to abide by a gelato standard interface, which is just this function. It has to need to have the signature, and then in that condition you can really do basically just read stuff. And this is actually where chain link could also be really interesting, right? Because obviously a lot of on chain data isn't, first of all, there isn't that much variable data on chain, or it's easily manipulatable as we've seen in the past.
00:13:41.362 - 00:14:37.538, Speaker A: So I think condition in gelato is actually one of the areas where you could really do some cool stuff with Chainlink oracles as well, like reading things from Chainlink Oracles and then doing stuff automatically based on that. So for the conditions, again, if you are interested in for the hackathon doing something based on an exotic condition, I'm very happy to help you write that condition and deploy it and all of that. Just let me know in our telegram chats or in the discord channel so we have a question how the automatic tasks can be stopped. Okay, let me already go to that. Fabio asked how the automatic tasks can be stopped. First question, quite easily. So you submit these tasks to the network writes, and that just means, okay, you have a bunch of data that you packaged up as a gelato task.
00:14:37.538 - 00:15:18.226, Speaker A: That just means this information basically has the condition, the action you want and some other stuff. And now what happens is if funds should be moved around, you will also probably have some approvals to funds somewhere. So the cleanest way to stop automatic tasks is just to cancel them. Gelato has a cancel API that you can use to cancel tasks. Technically, you could also do it indirectly. If you revoke the approval of tokens, then obviously gelato won't be able to move them around because the approval is gone. So there's multiple ways of doing it.
00:15:18.226 - 00:16:02.254, Speaker A: But in general you should use the cancel API, which we have, and which is very easy to use. How gelato network signs transaction without having ethereum private keys this is actually probably my favorite. Yeah, this is probably the best question to ask, because this is basically the whole design we have is built around that, right? How do you execute something in the future without having the private keys of the user? Obviously we don't want to have the private keys of the user because that would be custodial. So how do we do it? Well, let me first say how we didn't do it. One of the obvious answers to these questions are meta transactions. They were quite popular in the last two years. They still are.
00:16:02.254 - 00:16:52.410, Speaker A: They are pretty amazing. They can do a lot of nice stuff. Why we didn't choose them with gelato. So meta transactions, basically they are kind of similar to what we do in gelato, but not 100% similar. So meta transactions do this by message signatures, right? And then with a message signature you can prove, okay, whoever holds the keys, you can prove without knowing, without having the keys, that someone has signed this message and the transaction is fine and the relayer can execute it. With gelato it's similar, but the data is not in form of a signature, the data is in form of a hash of the task. So the nice thing about this is that with a meta transaction, you would have to make sure that the message signature is shared among all the network, and you would have to do that offline.
00:16:52.410 - 00:17:44.174, Speaker A: We leverage Ethereum as like an accessible, highly available database for anyone to be able to pick up any tasks that are submitted and to then be able to execute them. And that's why we use it this way. So basically what you do with Gelato is you just submit the data that determines your tasks to be automated. Like for example, sell on uniswap. If this price is this using this user proxy, and then because the user still has the keys controlling their smart contract wallet. Remember I said that users in gelato always have to have a smart contract wallet, so the user has the keys to control that smart contract wallet, and they can, for example, approve gelato to move funds. And this approval is all that's needed at execution time.
00:17:44.174 - 00:18:14.954, Speaker A: Gelato will have the approval, and gelato will then only be able to execute as per the user specification. Because gelato, the executors come with the data and they need to hash it. And there's a hash check. So if the hash doesn't match, that means whatever the executor is trying to do is not what the user specified. So the hashes really need to match. If the hashes don't match, it means the data is invalid and the executor in the smart contract code will get a revert. So that's what the gelato core is there for.
00:18:14.954 - 00:18:51.014, Speaker A: That's what our core protocol is there for. It's there to validate and verify that the data is correct. And that means that at execution time, who is actually signing the transaction with a private key is the executor. They get compensated for it, but they cannot do anything with the user's fund. They can only do specifically what the task the user submitted in the past is specified. Because we hash the data and we compare and we store the hash of the user, and the executor has to resubmit the data and make sure that the executor resubmits exactly the same data as the user specified. And that way we know the payloads will be fine.
00:18:51.014 - 00:19:45.800, Speaker A: That way we know only things can happen that the user has specified. How do you watch the blockchain for changes? That's a question from Travis. So, just to give you some context, these are questions that you as a developer normally don't have to worry about, right? The whole idea about Gelato is that you don't have to worry about this. The network does it for you. But it's always good to have these questions. So at the moment, we use events because they are a cheap way of persisting data on ethereum, right? So at the moment, whenever a user submits a task through your UI or whatsoever, the gelato executors, the relayers will pick it up, they will store it somewhere off chain. They pick up these events and then they will continually ping the gelato contracts to see whether a transaction has become executable or not.
00:19:45.800 - 00:20:24.446, Speaker A: All right, I think that would be the questions. Yeah, so we have the condition. Let's move to the action. So actions are really where they're not as gelato specific as conditions. I think they're really smart because you can basically reuse existing stuff. You can use gelato and as your action, just define the existing uniswap functions. So there's two operations.
00:20:24.446 - 00:21:08.722, Speaker A: Use solidity. Developers will know that it's a call or a delegate call. And you can use gelato actions and specify them using like a call method and just call any function on existing smart contracts. Like for example, you could write your own time condition or use our existing one and say every Friday. And then in your action you just specify contract address, uniswap call a function on there, you specify the payload for the function and then you already have it. You don't need to write an action contract, you don't need to invent the wheel yourself. With gelato you can really reuse so much existing stuff out there and you just Lego style combine it and compose it and automate it in the end.
00:21:08.722 - 00:22:01.970, Speaker A: There is a caveat. Like sometimes you have to make sure that some data has been validated for gelato. This might be, for example, that the user proxy has enough funds because obviously when the user is on a holiday and for example with a Uniswap case, when the price is then there, the user proxy, the user smart contract wallet, still needs to have the funds in order to make the trade. So maybe you need to write like a wrapper, a small wrapper around a Uniswap function. And that way you would then use delegate call and just to do some data validation before. That might be automation specific, that might be specific to the way gelato works, but a lot of stuff can be just reused if you're too lazy to write your own action. You could also just write a condition checking for example, that enough balance is in an address.
00:22:01.970 - 00:22:38.414, Speaker A: And then you can just combine the task, like using this condition and using an existing Uniswap function raw. And then you have the security. You do know that the funds will be there at execution time from the condition. And you do know that you can just use a uniswap function without writing and deploying your own wrapper contract for it. So there's many ways of designing this. And again, some are probably complex to think about. If you haven't thought about this stuff before, because scheduling stuff in a decentralized way in Ethereum in the future is not easy, and we're here to help, really.
00:22:38.414 - 00:23:08.070, Speaker A: Don't be afraid to ask questions in the telegram. I'm happy to jump on video calls with you on an individual basis. Even so, we're happy to build with you, so don't worry if you don't get everything right now. So an action, for example, as you can see here, this is just a normal uniswap contract. You could just literally use that uniswap function in your action in JavaScript without needing to write any solidity. Or you could. So that would look like this in Javascript.
00:23:08.070 - 00:23:55.362, Speaker A: You basically have an action here. You can use our class for it. In our library you just have the address of the action. You encode some data for the payload that obviously needs to match the function signature. You define what operation, then there's some more advanced stuff. And then you could also have your custom actions that wrap existing, like either they're completely new stuff or they wrap existing uniswap functions, for example, and for example batch transactions, right? You could for example, sell on Uniswap and then use the proceeds and do something with it, put them to compound or. Yeah, I guess the essence of it is that you combine conditions and actions into a task.
00:23:55.362 - 00:24:35.010, Speaker A: You can also have multiple conditions and actions in one task. So for example, you could say, if the time is this and the balance is this, then sell on uniswap, use the proceeds and put them into my compound account. It can get really big, it can get really complex. What you want to do. I'm going to try and keep it with the smaller examples today because there's probably enough questions already to be answered. All right, so one special thing about gelato task is one question that you always need to ask yourself is, all right, okay, gas, right. Normally you pay for gas because it's in the present, you're there, you submit the transaction, you pay for gas.
00:24:35.010 - 00:25:21.506, Speaker A: Well, with gelato someone still needs to pay for gas. You always need to pay for gas. The miners are greedy, right? So obviously with gelato, the executors pay for the transaction gas. But the way Gelato works is gelato is basically the core contracts are like a service agreement between you, the user, or the dev developer and the executors. And the contract is kind of like Gelato's contracts are like an escrow, and at execution time it will be calculated how much gas your automated transaction actually consumed. And then the executor will be refunded their gas costs based on how much gas your transaction consumed and a little incentive. And this is actually where we use chain link.
00:25:21.506 - 00:25:57.754, Speaker A: So you might wonder, all right, the executor might just come and use a 500 weight gas price and bankrupt you, right? No, the executor can't do that. At least they can do that, but it would be stupid for them because their payout from your balance is determined based on the chain link gas price. And we use fast way at the moment. So basically this means executors are incentivized to use the current fast gas price. So you do have to pay them. So this means that before you submit tasks and if you want them to be executed, you have to keep a balance on Gillette. So you can top up that balance anytime.
00:25:57.754 - 00:26:35.430, Speaker A: You can withdraw that balance anytime. If you've used monolith before, you can think of it as like your gas tank that you have on gelato and that's just eth you put in there and that eth eventually when there is a successful task execution for you in the future and you are happy because, well, you were on holiday and someone automatically traded for you. Awesome. Then you will have a little less eth on gelato afterwards because some of it will have been used to pay that executor for the transaction. So there is some more stuff in the task object. If you look into the code. If you look into the classes in the JavaScript class or in the solidity struct, you will see some more fields.
00:26:35.430 - 00:27:19.474, Speaker A: Some of them are, for example the self provider gas limit and gas price seal. This is just where you basically specify, all right, this is how much gas the executor should use. And this is the gas price ceiling under which I want to transact, which is actually also really cool. You can let your latter know, hey, I want this automated trade, but only if the current fast way price isn't above a threshold. Like I don't want this trade to go through at a gas price of 200 way. I only want maximum 100 way. So this means that actually gelato will automatically transact for you when the gas prices are right, right? So they will do this transaction if the price is right and if the gas price is at like 80 way, but they won't do it if it's above 100 way.
00:27:19.474 - 00:28:21.454, Speaker A: Actually, this was leveraged by the hull team when they built the automated child token minter because they just basically said all right, we use gelato, we use the task data structure to just specify hey a user wants to mint at 20 gray, so they put the self provider gas price ceiling at 20 gray, which means gelato will only mint child tokens for them automatically when the task way is 20 gray. So this is actually also not only a nice feature for any task, but it can actually be leveraged as kind of like a condition. Like, you can make this field the gas price ceiling a gas price condition, if you will. All right, there is a column going off in the street. That's annoying. Let me quickly close the window. All right, here I am again.
00:28:21.454 - 00:28:53.846, Speaker A: I hope you don't hear too much of that background noise. Cool. So you might already wonder, okay, what's a self provider? What are these terms that I've been throwing around? Well, submitting a task to gelato means you need to specify who will pay for the execution. A self provider just means that the user basically pays for themselves. So that basically means you as a depth developer, you ask your users on your UI, hey, make sure to top up some balance. Make sure to have some east on gelato. You can withdraw it.
00:28:53.846 - 00:29:24.414, Speaker A: You can top up, but I won't pay for you. You have to pay for your automation guys. And this would be a self provider. And there's also the concepts of external providers. So external providers basically means that you, as a depth developer, you take care of this gas payment management for your users. So you have a balance on gelato. Basically, you pay the executors for when they execute your users tasks, and you make your money elsewhere.
00:29:24.414 - 00:30:36.018, Speaker A: Right? Like you could charge your users off chain if you're good at solidity, you could easily define a task that your user submits in such a way that you gain some of the users proceeds. So you could take, for example, a small cut from their trading fees from the trading proceeds. So there's these two. There's in general, in gelato, a task has a provider, which is just a person that pays for the execution. And we have this simple division between cell providers, which just means the users themselves pay for their automation, gas, or external providers, which means that some dev developers will pay for their users and care about getting the money from the users in a different fashion, which might be good for user experience, right? You might not want to burden your users with locking up some ETH and keeping a balance on gelato in order to pay for gas, because that also means that they always need to have enough, right? Like if the gas price spikes, you might have to send them a notification saying, hey, your balance is too low. Your task won't be executed. Make sure to top it up in order for gelato executors to execute your task.
00:30:36.018 - 00:31:39.994, Speaker A: But I think in general a gas tank is still a good way. I think users probably won't mind it too much, so it's up to you. And it's definitely easier to start with users as self providers what happens if a task perpetually this is a question from the Q A from ED. What happens if a task perpetually fails or is predicted to fail? Do you executors eventually ignore it? Also a really interesting question. I see a lot of people are really interested in the execution part, which is actually the part that we want to abstract obviously from you at the moment, the way we build our relayer. If a task perpetually fails, at the moment the relayer gets a refund, and if there was a revert, the task is then deleted from the gelato system immediately. So as a relayer you can't get unlimited refunds even though you wouldn't probably be incentivized to.
00:31:39.994 - 00:32:21.686, Speaker A: But when a task is somehow faulty, you will get a revert. Gelato will detect the revert on chain and issue a refund for the revert cost to the executor and then just delete the task. And then basically you on the UI level have to somehow use we actually have a subgraph for that. But you can use monitor your users tasks and make sure that your users have or at least you are notified when something is wrong with the task. That usually means that there's a bug or just a code mistake somewhere. Probably not. If you're using uniswap, probably the mistake isn't there.
00:32:21.686 - 00:32:53.422, Speaker A: If you are using your own custom wrapper, maybe there's a mistake there. It just means you have to do some debugging usually, but it isn't too bad. Obviously for your users. It wouldn't be great if they really hope for that task to be executed. But that's why we test beforehand, right? That's why it's important to test this stuff beforehand. Long story short, the task, once it reversed, it's deleted from the system. If in the weird case where gelato core is built in a way to catch these reverts and then handle them gracefully.
00:32:53.422 - 00:33:38.174, Speaker A: However, if there's an edge case that we haven't thought about, so there's a revert that we haven't caught, which should be the case. We've audited it, we've tested it, and every line is covered but might happen. And in that case it's only bad for the relayer. In that case, the relayer will probably, we would eventually ignore it. I don't know what other relays will do in the network, but if a task simply is wrong, there's something completely wrong about it, not foreseen by the protocol even then. Probably it's just dropped by the network eventually, but that shouldn't happen normally. We've not seen this yet, and it should be very easily mitigated and preemptively prevented by just testing thoroughly beforehand.
00:33:38.174 - 00:34:44.270, Speaker A: Right. All right, cool. So we have tasks, we have providers. And let me make a quick break again and open the window because the car alarm has gone off now and it's getting hot in here. All right, so gelato providers, this is just the concept of someone has to pay for the user's gas, usage on gelato for their automation gas, basically. So one last important concept is user proxies or in general that your users have to do a one time gelato setup. And this basically just means that, as I said before, gelato only works in most of the cases through smart contract wallets.
00:34:44.270 - 00:35:22.720, Speaker A: Someone asked Fabio asked the question how gelato network signs transactions without users ethereum private keys. Well, part of the answer is it works because of smart contract. Yeah, for Gelato. Basically, Gelato doesn't know about the user. As in the metamask, externally owned account, Gelato only knows the user through their smart contract wallet. So that as a depth developer, you have to make sure that on your depth you have some capacity to endow your users with a smart contract wallet. It's very easy, to be honest, we have a lot of void applate code for that.
00:35:22.720 - 00:36:14.266, Speaker A: The best go to place, in my opinion, is, for example the GnosiSave proxy SDK. Very easy to use. It handles all the stuff like proxy deployment, transaction, batching, signatures, blah blah blah. It handles it in a library for you, depending on, for example, if you want your users to pay for themselves for their gas, then you will have to make them aware of it anywhere. You will have to have a gas tank, they will have to deposit some eth on Gelato. And you can also ask them to basically first set up Gelato by deploying a proxy. And basically everything they do with Gelato, like even providing the funds for their automation gas, they will have to do it via their proxy already submitting their tasks, they will have to do it via their proxy.
00:36:14.266 - 00:36:59.926, Speaker A: And because Gelato only knows your user as a smart contract, Gelato doesn't understand UAS really well. So Gelato assumes that any direct interaction with it as in submitting a task, or as in canceling a task or providing funds to pay for a task. All of that will have to be done through a smart contract wallet that proxies your user. Usually what happens is every user that uses your app for the first time, they deploy a proxy. If you want to be really smart about it and reduce the number of transactions your users have to go through initially, you can also batch this. Usually there's magic that allows you to provide the funds. Set up Gelatos, deploy the proxy, all of it in one transaction.
00:36:59.926 - 00:37:30.066, Speaker A: You can do that if you want to, but you can also do it step by step, like ask your users for the first time, like deploy a proxy please, or whatever you want to call it. And now set up Gelato and submit a task. Before the task gets executed, your users have to complete a one time gelato setup. That's the key takeaway. You can see some boilerplate code for it here. We have some scripts already that make it easy for you on chain. Basically you deploy your user proxy and then you submit.
00:37:30.066 - 00:38:02.878, Speaker A: We have this function, this API on Gelato called multi provide. It handles some stuff for you, for your users, like selecting the executor network. Gelato is completely permissionless and open, so anyone can spin up an executor or run an executor network. So you can pick one. At the moment we have our default network. Obviously you should pick that because that's the best one. With the multiproide action, you also provide the funds to pay for future executions.
00:38:02.878 - 00:38:35.386, Speaker A: Remember, if the tasks don't get executed, you can always withdraw the full amount back to your user's account via your user proxy. Yeah. And then that's it. Basically. One last thing I want to mention about task is, and the reason I don't mention it immediately is because it's a bit more complex to think about, but it's actually probably one of the best features of Gelato is you can have infinite task chains. So for example, we have this repo called Gelato Kaiba. You should check it out, actually, if you haven't done so already.
00:38:35.386 - 00:39:00.862, Speaker A: I think at the moment the trade didn't work because I already talked to the Kyber developers. It seems like one of the reserves on rinkby might be down it's using. So the Kaiba Gelato Kyber repo, check it out, read through it. It also explains a lot. Check out the code there. And that is actually doing dollar cost averaging on Kyber. Like it's buying KNC every whatsoever.
00:39:00.862 - 00:39:38.022, Speaker A: Like you can for example, think about like buy KNC or buy Eth every week for the rest of your life. And you as a user using Gelato and as a dev developer for your users, you only have to set it up once. Like set up Gelato once and submit this task and it will infinitely resubmit itself into the future. So that's actually a really cool thing about gelato. We call them task cycles. Gelato already has this capability. If you want to go a little crazy, if you don't want one time tasks, like buy at this price, but if you want to build a dap, for example, that buy at this price and then sell at this price, and then buy at this price, sell at this price, like between two spots.
00:39:38.022 - 00:40:29.026, Speaker A: Like for example, set protocol does it, but you can do it customizable with gelato without pooling. Obviously that comes with negatives and positives, but whatever you want to build, build it with gelato. Just know that if you want to go crazy, if you're thinking about infinite task chains or task cycles, like do something every then. Or for example, you want to trade between two price points continuously, like a day trader almost. Or you want to do like interest rate refinance and back and forth between lending rates, gelato allows you to do that. Like submit the task once, specify the task in such a way, we call it a task cycle. Let me help you do it if you're interested in it, and then have that task be continuously functional, continuously executable into the future without your user ever having to come back and resubmit it.
00:40:29.026 - 00:40:45.542, Speaker A: So that already works as well. I think that's it from the dry documentation walkthrough I have for you today. I hope it wasn't too dry. I know. Like, scrolling through a website with code seems a bit. Wow. Yeah.
00:40:45.542 - 00:41:04.700, Speaker A: Hopefully you aren't asleep. Yeah, I think, Patrick, I'm really ready to go into A-Q-A-I don't know if something like this works like active Q A, even with voice. I'm not sure if this is how it works on the chain hackathon, but yeah, I'm happy to answer questions.
00:41:05.790 - 00:41:15.520, Speaker B: Yeah, I don't know if I caught this, but did you look into the Q A at the bottom button there? It looks like there was a couple questions in.
00:41:18.210 - 00:41:28.914, Speaker A: There. Okay. I think I answered most of the open ones, or actually all of them, I think. Right?
00:41:29.112 - 00:41:30.806, Speaker B: I think you did too. Okay, great.
00:41:30.908 - 00:41:31.560, Speaker A: Yeah.
00:41:34.730 - 00:41:43.900, Speaker B: If there are any other questions, feel free to jump on and ask. Unless actually we're getting some feedback that you were very clear so maybe there won't be any questions.
00:41:45.550 - 00:42:22.440, Speaker A: I can definitely also talk a bit more afterwards, maybe, about how to start, because I, as a developer, I hope you aren't intimidated by it. Let me assure you that if you go through some of the examples we have, we have some boilerplate plate code ready. I think you will catch on quite quickly. But it's definitely a steep learning curve in the beginning, I think, and then once you've seen it once or twice in the test code we have, and so on. I think from there on, the design space is really open to you.
00:42:25.850 - 00:42:56.906, Speaker B: Awesome. And I'm looking on YouTube, it doesn't seem like there are any questions. Seems like it's fairly straightforward. Yeah, the boilerplate code looks fantastic. I mean, just having that copy paste ability so somebody can just get started really quickly seems fantastic. So if there aren't any other questions, then I guess I will thank everybody for coming. This seems like there's a lot of good feedback here, and hopefully we'll get to see some really cool, smart contracts that are automated using gelato.
00:42:56.938 - 00:42:57.086, Speaker A: Right.
00:42:57.108 - 00:43:26.730, Speaker B: This is a super powerful tool for you guys to use. And like Lewis said, they're putting a $1,000 bounty on it. And again, just an extra special thank you, because it's crazy to think that, like, a year ago, this came from a hackathon yourself. So congratulations on getting here. I know that there's still a lot of work to be done on your end, but it seems like there's a lot of interest here for integrating with gelato. So thank you so much for being here.
00:43:26.880 - 00:43:56.206, Speaker A: Thank you very much. And maybe as a last thing, if you look into the documentation and into our repo, I think one very good place to start is looking at the gelato Chai repo. We've linked it in the docs. You will find that we've pasted the link also into the Discord channel. I think the gelato chai repo is a good place to start. It's a bit of an OD cookie because it uses the gas price functionality. Like, it kind of leverages it and uses it as a condition.
00:43:56.206 - 00:44:16.540, Speaker A: But I think check out the repo there. Look at the test files. Run the yarn command that's in there. I think the gelato chai is a good place to really start looking into the code. And maybe actually, if I. You should just go there and maybe read through the test file in there.
00:44:17.790 - 00:44:20.060, Speaker B: You heard it here first. Just go there.
00:44:24.050 - 00:44:59.080, Speaker A: Yeah. So the test file, basically, I can share one moment. This is the repo and if you go into the test folder, no, actually not this one. Let's go because this one is on rinkby, actually. But if you go into the one TX onboarding, this is like a longer test. I will actually paste it. Can I paste it somewhere? Let me see.
00:44:59.080 - 00:45:29.066, Speaker A: I will paste it into the chat later. But this is a longer test. And I think from the structure it goes like consecutively through all of the steps that you kind of have to think about when using gelato. These are a couple in the beginning, definitely, especially for local tests. But yeah, check out that file, the one TX onboarding. And this has this magic I was talking about earlier where all the setup, like funding your gelato account, deploying a proxy. In this case, it's a gnosisave.
00:45:29.066 - 00:46:06.940, Speaker A: All of that stuff is done in one transaction. If you are the kind of person that worries about user experience, like you want to reduce the amount of transactions users have to do the first time they interact with your interface here, you already have an answer to how you do all of that stuff in one transaction with using the gnosis save proxy SDK. Yeah, I think this is a dense, like, it won't be easy, but it's a dense, but a good file to start if you want to have the whole kind of detailed overview. All right, awesome.
00:46:07.550 - 00:46:12.730, Speaker B: Well, thank you again so much for being here, and we're looking forward to seeing everyone's submissions.
00:46:13.150 - 00:46:18.820, Speaker A: Thank you very much, Patrick. All right, thanks, everyone. One for joining. Looking forward to hearing from you.
00:46:19.430 - 00:46:21.678, Speaker B: All right, signing off. Bye, guys. Bye.
