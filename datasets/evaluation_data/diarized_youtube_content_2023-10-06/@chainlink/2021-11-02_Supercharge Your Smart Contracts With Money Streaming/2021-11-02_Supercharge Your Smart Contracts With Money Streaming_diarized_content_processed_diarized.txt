00:00:20.730 - 00:00:57.470, Speaker A: I guess we're live. So, hi, everyone. I'm Francesco, one of the founders of Superfluids. And with me, there's Sam, who leads our developer relations. And today we're going to talk a bit about how you can use superfluid in conjunction with Chainlink to create some very interesting real time finance applications. So, first of all, I'll give you an introduction about superfluid, and then I'll pass it on to Sam, who will delve much deeper into development, how to organize your app, how to kind of design your app. And we'll show you some code as well, so that you can hit the ground running with your integrations.
00:00:57.470 - 00:01:10.420, Speaker A: So, let me share my screen here. I'm going to show you short presentation. So, Sam, can you see my.
00:01:12.310 - 00:01:13.182, Speaker B: Yep.
00:01:13.326 - 00:01:38.790, Speaker A: Yep. Okay. Well, superfluid. What we do at superfluid are digitally native, programmable cash flows. So this is streaming money. So money transferred from one account to another over time with no capital lockup, which means that the funds are always available and accessible to their owners and fully programmable on chain. Now, programmability, as the chainlink community knows, is super important because it's a difference between bitcoin and ethereum.
00:01:38.790 - 00:02:16.360, Speaker A: It's what enables us to build these complex defi applications that we're so excited about. So why are we building superfluid? Well, we believe that the Internet is to information what blockchain is to value. Right. The blockchain is this great way of moving value on the Internet, and the same way the Internet has sped up the speed of propagation of information, the blockchain is doing to value. However, services still don't flow in real time. Right? So when you sign up to a service, imagine Netflix. Or imagine even when you're providing services to your employer, you're providing those services every second.
00:02:16.360 - 00:03:04.386, Speaker A: Your service is flowing in real time, but the payment is still coming in a lump sum at the end of the month through very slow, kind of inefficient channels. Right. So what we're doing at superfluid is trying to bring those payments into a real time flow the same way services are. And we do this through money streaming. So, money streaming is this continuous payment which flows frictionlessly from one account to another in an open ended connection. Open ended means that once you open a stream, it will stay open until you close it or run out of funds. It creates a real time link between the service provider and the payer in a way that allows you to pay for every second of service provided.
00:03:04.386 - 00:04:00.742, Speaker A: And this is extremely interesting, because what it does is it eliminates all unpayment risk. If you're paying for every second of a service, the moment that service stops being provided, you can stop paying without ever overpaying or underpaying for the services you're using. And this also means there's no delays in payment, right? Imagine every time your employer pays you a couple of days late, and that throws you off because you need to now reorganize your expenses. If you get paid every second, you get paid every second, there's no delays possible. And this allows you as an individual or as a company, to much better plan your finances and run with much smaller capital, because you never have to make up for those risks, right? You always get all the liquidity that you've earned, exactly when you earn it. So it's much easier to budget. Now, we do all of this on chain, on the blockchain, so there are no intermediaries.
00:04:00.742 - 00:04:59.370, Speaker A: And this obviously means you can innovate permissionlessly, you can build applications with no gatekeeping, and you can basically just transact peer to peer online, but with this new way of transacting, which is these peer to peer open ended money streams. So how does superfluid work? Well, basically the superfluid protocol is a new token standard which enables accounts to create on chain open ended agreements between user balances. So these balances are connected by agreements where the transfer of funds is calculated every second. So if you think of a normal bank ledger or a normal ERC 20 token balances are stored. Right. What this means is to change them, you effectively need to make a state transition, right. You make a state transition, and when the state transition happens, then the balance changes.
00:04:59.370 - 00:05:45.626, Speaker A: In the case of superfluid, state transitions inform us of how the balance will change in the future. But balances are calculated, and the clock is a very important part of how this balance is calculated. What this gives us is transactions that initiate streams but don't actually move funds. Funds are moved by the clock over time, and the resulting balance is calculated every second with no gas. So when you open a stream, you pay the gas once, and after that, funds will be transferred to the counterparty every second without any further transactions and without any gas. And this will literally look like your balance slowly ticking up every second. And if you were the payer, your balance slowly ticking down.
00:05:45.626 - 00:07:04.340, Speaker A: Now, how does this work? Well, basically we have a concept of super tokens. Super tokens are our new ERC 20 standard, which are extended, which can make use of these open ended agreements, and super tokens can either be created directly, so you can create, instead of creating a normal ERC 20, you create a super token, or you can create what we call super token wrapper. A super token wrapper wraps an existing ERC 20 so that you can have your USDCX, which is super USDC, that can stream. Superfluid is built around this concept of the host, which is the orchestrator of all other operations, and the agreement library, which basically enables us to provide new functionalities to the tokens. We generally mostly talk about money streaming, but that is actually only one of the agreements available. If you look more deeply into the protocol, you'll find there's a lot more that you can do with super tokens. So, programmability when we say programmability in the context of super tokens, what do we mean? Well, basically you can build smart contracts which not only hold a balance like normal smart contracts do on the blockchain, but they can also make payments in the future.
00:07:04.340 - 00:08:04.322, Speaker A: So if you think of your normal smart contracts, all they can do is do things when a user interacts with them, right? When a user makes an operation, they can transfer some tokens or they can receive some tokens. In the case of superfluid, you can make a smart contract that is receiving funds every second and is sending funds every second to a third party. So you can basically create these smart contracts to react to incoming streams and react when those streams are edited or stopped. As a result of this, you can create these basically smart contract money routers, which receive funds, send funds, and do a lot of interesting things. In the meantime, Sam will give you a great example of this. I think he came up with a really cool application which he built specifically for this workshop. So I think you'll understand more clearly what kind of potential this has in his presentation.
00:08:04.322 - 00:09:22.842, Speaker A: So just to give you an idea of what a superfluid app can do, we have three main things that are your touch points, which are basically callbacks, right? When a user opens a stream, updates a stream, or closes a stream to your superfluid app, it can execute custom logic. This means you can, for example, start accounting for a stream when it's received, and you can stop accounting for it when the agreement is terminated, right? So you can build these custom applications. On top of this, we also have a very simple to use JavaScript SDK, which means when you're building a front end, you can interact with the contracts without needing to go too deep and with a very simple interface. So if you're wondering what the experience of using superfluid is like, obviously you can build your own interface, but at the same time, we also have a visual dashboard, so you can go there right now. If you check in from a testnet, you'll be able to get some free tokens to try it out. Open your first stream, see the balance ticking up, ticking down. And it's really cool experience when you basically see that you made a transaction, and then money keeps moving on its own, right? That's the real power of superfluid.
00:09:22.842 - 00:09:53.942, Speaker A: And you can test it out on your own by going to our dashboard. We're also live on Polygon and Xdai, and we will soon be live on other EVM chains. So, yeah, stay tuned for that and go and test it out. So you have a feel of it. Now, for this hackathon, we have two major prizes and a pool price. The pool price is $3,000, and that will be spread across everybody hacking on superfluid. Our top prize is $3,500 for a collateralized lending protocol.
00:09:53.942 - 00:10:43.686, Speaker A: So think, compound. Are there something where I can deposit a collateral and borrow against it? But what we want to see, obviously, with superfluid is we want to see streaming, right? So we want to be able to borrow in streams. We want to be able to refill our collateral in streams. Right? Now, why is it interesting to borrow in streams? Well, let me give you an example. Imagine I'm a DaO and I have a lot of ether, but I want to pay my salaries in USDC. What I could do is put that ether into a collateralized lending protocol and borrow USDC to pay those salaries as I need it, right? So from this sort of lending protocol, I could open a tap and start paying salaries. So we're very excited to see this, and there are some immediate use cases and users.
00:10:43.686 - 00:11:19.686, Speaker A: So it's a very interesting product that can turn into something bigger afterwards. We also have a prize of $2,000 for the best use of chain link oracles and off chain computation. So if you have an idea that isn't part of this collateralized lending, you can still build it, and there's a great prize for you. So we're very excited to see kind of the crazy ideas that always come out of hackathons. Superfluid itself came out of a hackathon. So I can assure you hackathons are the best place to create new ideas and test them out and see how far you can take them. So to qualify, you just have to use superfluid in some way.
00:11:19.686 - 00:11:33.580, Speaker A: So, yeah, really looking forward to your hacks. And yeah, I'll leave it up to Sam now to take you through the rest. Thanks for joining us and join our Discord know more direct communication with the team.
00:11:35.230 - 00:11:57.140, Speaker B: Awesome. Well, thank you, Fran. I will share my screen here in just a second. All right, share. So we'll get much more into the technical side here. All right, can you guys see my screen? Yes, looks like we can. Perfect.
00:11:57.140 - 00:12:38.494, Speaker B: Perfect. All right, so let's go through specifically one, how we can actually use the protocol from a developer point of view. And then the cool application that Fran mentioned that we're going to walk through is an options contract that uses both superfluid and Chainlink price feeds. So before we get into the fancier things, let's just talk through using the protocol at a more basic level. So Fran touched on this briefly, but to interact with the superfluid protocol, you really need to keep three things in mind. One of them is the host contract, is the main contract you're going to interact with when making calls to different agreements. Right.
00:12:38.494 - 00:13:03.506, Speaker B: You can think of the host contract like the brain of the protocol. Then we have various agreements, so we're going to add more in the future. But right now we have two key agreements. One of them is a constant flow agreement that enables the money streaming that Fran was talking about, and another is an instant distribution agreement. We're not going to walk through the instant distribution agreement today, but it's pretty cool. You should check it out. It lets you send transactions to large numbers of recipients with really no marginal gas costs.
00:13:03.506 - 00:13:48.054, Speaker B: So would definitely recommend looking at it, even though we're not going to go through it today. And the other thing you need to interact with when dealing with the protocol are super token contracts. So some super tokens are native super tokens that are just meant to live within our ecosystem. And then other super tokens are essentially wrappers around existing tokens. Right? So we have an ethx token that is a super token version of ETH. We also have ERC 20 wrapped tokens like Dix, right, things that you can just essentially easily wrap and pull into our ecosystem. So to get a super token, what you can do is you can either call the upgrade function on the super token contract itself, or you can use our dashboard, which I'll go into later on.
00:13:48.054 - 00:14:27.710, Speaker B: But the upgrade function on the super token contract is simple. You just deposit the underlying contract, essentially wrap it, and then are minted a one to one amount of the super token version of whatever that ERC 20 was. And then if you ever want to downgrade and exit the ecosystem. To get your underlying ERC twenty? S back, you could call the downgrade function, which will essentially just burn those tokens and you'll receive the underlying asset you had there. Back again. You can use our dashboard for this. On the right hand side of my screen here, you can see with this, plus sign here in the deposit or withdrawal column.
00:14:27.710 - 00:15:06.826, Speaker B: You can deposit funds that way, and that will allow you to essentially mint new super tokens. When it comes to interacting with agreements, though, and this is more on the developer side, this allow you to do some more interesting and creative things. And we'll do this later on. You'll want to go through this workflow to interact with an agreement. So normally, if you're interacting with any kind of smart contract, typically the first thing you think of is to call a function specifically on that contract. So in our repo, you might see in the constant flow agreement contract, which I have here in the upper right portion of my screen. Normally you just call the function on the contract, and that will allow you to do things with superfluid.
00:15:06.826 - 00:15:48.490, Speaker B: You have to go through the host contract first, right? The host contract, like I said, is like the brain of the protocol. Everything is very decentralized still. But you have to make the call to the host contract, which will then make the second call to the agreement you want to interact with. So, for example, you will pass arguments to a function on the host contract called call agreement. You can see that in the left hand side of my screen there, that will in turn perform an action that you specified on the agreement contract you want to interact with. In this case, the constant flow agreement here. And then what that call to the constant flow agreement contract will do is open up a money stream, or a flow, as we call it, from the sender to the receiver.
00:15:48.490 - 00:16:26.838, Speaker B: The other thing you need to understand if you want to build really cool applications with superfluid, are super apps. So this is something Fran went through, so I won't touch too deeply on it here. We'll just go a little bit more deeply into it when it comes to actually architecting our app. But the thing you need to really understand is that these are essentially just smart contracts with superfluid specific callbacks. And these callbacks can essentially listen for events that happen on super agreements. So the three functions you get are after agreement created, after agreement updated, and after agreement terminated. These all run when an action is taken with the super agreement and the super app at the same time.
00:16:26.838 - 00:17:30.422, Speaker B: Right? So, for example, if I send money, if I send a flow of funds, into a super app contract, this after agreement created function will run. You can have nothing in that callback if you want, if you don't want anything to happen, but if you want cool things to happen, if you want to use that money router kind of example that Fran mentioned, you can have logic that's arbitrary. It could be whatever you want inside of the after agreement created callback that will run whenever you open up that flow to the contract. So one really good example of this that we have in our repo that we've used quite a bit in different tutorials and workshops and things, is this tradable cash flow NFT. This is something you'll see in the super apps portion of our docs that I will link in the Chainlink workshop support channel we have after the call. But essentially how this works is it follows the same workflow we saw a couple of slides ago where we open up a stream from the sender to the receiver. Except in this case, the initial receiver is not an external account, it's actually the super app contract.
00:17:30.422 - 00:18:27.920, Speaker B: So we send a flow of funds from us, the sender, to the super app, and then what happens is the super app callback is triggered. So the after agreement created callback runs this callback here you can see in the bottom right hand portion of the screen. And that callback has logic inside of it that will allow you to just send 100% of the funds that are coming into the contract to the owner of the NFT. And because it's an NFT, you can trade this around. We have logic that you'll see if you ever go dig into our repo that will essentially just redirect all the funds to the new owner of the NFT whenever it's traded. So what we'll do with this is extend upon it to build a tradable cash flow option contract. So this is really just going to be a smart contract that uses superfluid streams as a way to pay for the option premium, so the cost to essentially keep the option open.
00:18:27.920 - 00:19:30.570, Speaker B: So to recap, to zoom out, for those of us, a lot of us are all involved in DeFi and finance and things. So many of you might already know this, but just to review what an option is, it's a derivative asset that gives a buyer the right, but not the obligation, to buy or sell an asset for a specific price on or before a defined future date. So what we'll do is build this out. Our specific example will be a call option related to buying a specific asset in the future. But we think this is a potentially interesting application for both superfluid and chainlink, to be honest with you, because of the capital efficiency portion here, right? So we all know that in DeFi, if you can hold on to your funds and earn interest on them over time, there's value in that, right? The capital efficiency is really important when you can earn money on funds you hold for any period of time. Right. If you have a large pool of capital like a Dow does, this gets even more valuable.
00:19:30.570 - 00:20:22.494, Speaker B: Right? And in terms of different applications, I can see just to kind of plant some seeds here to see if you guys want to build on this at all. There are applications both for the put option version of this and the call option. Like I mentioned, our example today is just going to be around a call option, but it's going to be trivial to convert it to a put option if you want to do that with a put option, they're often used as insurance. So a lot of hedge funds, a lot of big corporations, they will hedge against their portfolio or specific things on their balance sheet or different materials they might need in the future by using puts. So a put option is the option to sell an asset at a specific price at a date in the future. And this could be interesting for a Dow treasury, for example, because I actually just found this out recently. But many dows hold the majority of their treasury in their own token.
00:20:22.494 - 00:21:02.720, Speaker B: So they're extremely dependent on the market for their particular governance token for the value of their treasury. So we think it could potentially be interesting for a Dow treasury to use something like this tradable cash flow option to hedge against the risk that something bad happens to the market for their governance token and need to somehow have a hedge risk against it or hedge themselves against that risk. On the call option side, this is more on the defi trader side of things. It's a good way to speculate on future prices. Got to be careful with them. None of this is any investment advice. We're just dealing with code, not trading tips here.
00:21:02.720 - 00:22:24.646, Speaker B: But maybe you have some Michael Burry's in the audience and you guys want to play around some different options, know, try your hand at the trading game. So we'll get into some code here in a second. But I want to go over what this cash flow option is going to have in terms of a few key things, right? So it's going to have an owner who locks an underlying asset inside of the contract will have a function that they can call to set option parameters, like the strike price option price, and also the expiration date, the option price is going to be denominated in a superfluid flow rate. So the amount of tokens per second that the buyer needs to send to this contract to keep the option open. Secondly, the buyer is going to have to start a stream to the contract which will then in turn, just like in tradable cash flow NFT example, send 100% of those funds basically through the contract to the owner of that option or the owner of the NFT. If the buyer of this option wants to exercise the option, they need to be streaming at least the amount of tokens per second that was defined in the option price. So if the stream is greater than or equal to the option price, the option will be active.
00:22:24.646 - 00:23:39.342, Speaker B: And if the option is active and the option is in the money, meaning in our case with the call, if the strike price of the option is below the market price, at any point the buyer may exercise that option, and when that option is exercised, the contract will then send the buyer the funds that were locked up inside of the contract, and the buyer will then send dai to the owner of that NFT. So we will essentially facilitate that transfer and settle the option on our end. So again, we'll get into some code here, but I just want to let you know that you can fork this example by going into our protocol monorepo inside of our GitHub, head to examples, and then go to streaming call option. We have this right now in a separate branch. I will put this link to this repo inside of the superfluid support channel in the chain link hackathon Discord channel. So just to preface that, don't feel like you have to memorize things, you'll be able to fork this and play around with it yourself as well. So getting into the architecture here, we'll walk through what this looks like, and then I'll open up my text editor and show you how the functions are actually defined.
00:23:39.342 - 00:24:20.382, Speaker B: Right. So we can see that this architecture looks pretty similar to what we saw in the tradable cash flow NFT, with a couple of differences. So we can see here that instead of the sender we have the option buyer, and instead of the receiver we have the option seller. We also have two new contracts there on the right hand side of the screen. One of them is going to be the link USD oracle, which is going to give us a price feed of the value of link. And we also have the link token contract in our example. We're going to create an option around the link token, right? So the link token is going to be the underlying asset for this option that the buyer will have the option to purchase in the future if the option is in the money.
00:24:20.382 - 00:25:12.126, Speaker B: So what the option seller will do to start is they will mint the NFT and then they will call a function to set some key option parameters. So what's the price of the option, what is the expiration date, what's the underlying asset? All those things will be specified there. And then they'll go out and they will approve the tradable cash flow option contract to spend their link token so that whenever the option started, the funds can be sent from the option seller into the contract. So they'll be locked there. So that when the option is actually settled, we can easily send those from the contract to the buyer. So the next thing that will happen is the option buyer, if they decide to engage in this, what they'll do is they will open up a money stream or a flow into the contract that meets the minimum flow rate. So the minimum flow rate is essentially, like I said, the option price, right.
00:25:12.126 - 00:26:10.930, Speaker B: In our case, what we'll use is $100 per month. And in this step, if in this function that the option seller calls, if they have $100 per month as the required flow rate, and the option buyer sends that minimum amount to $100, the option will then be activated. So when the option is activated, that money stream, that $100 per month will be sent to the option seller. So they'll be receiving that option premium over time. And then the link will be sent from the option seller into the option contract. Next, what will happen if the option buyer decides to exercise the option, they will first need to approve the NFT contract to spend their DAi, which will be the underlying asset that will be used to, they will essentially send Dai to the seller in exchange for the link that's locked up in the contract. So they'll approve that.
00:26:10.930 - 00:26:54.586, Speaker B: They'll approve the contract to facilitate that transaction. And then what we'll do when they call exercise is check if the option is in the money by using the link USD Oracle. So using that price feed to check what the actual current market price is of link. If we determine if the option is then in the money, we'll then settle the option. So we'll send the underlying link to the buyer and then the contract will facilitate a send from the option buyer to the seller for the die at the predetermined price. So we'll go back to this and recap later, but what I want to do first is we'll zoom out and we'll actually go through step by step what this code looks like. As I mentioned here, you can find this inside of our repo.
00:26:54.586 - 00:27:39.870, Speaker B: So if I go to our repo here, you'll be able to click on protocol Monorepo and then head to examples. And the streaming call option example will be in there. So if we look at what the code actually looks like, let me pull this up, we will see that we have a couple of key contracts here, right? So one of these clean this up a bit. One of these contracts is just going to be the overall NFT contract that will inherit from the call option and also the ERC 77 21 standard. This will let you just initialize and mint the NFT, but the key logic will be inside this redirect all call option contract. Right. So this is where we'll actually see the bulk of our logic.
00:27:39.870 - 00:28:20.700, Speaker B: So we're importing a lot of superfluid related dependencies here. You can see that up top. We're also importing a specific chain link contract that will let us get the price of link. And then we'll see here we have a few variables that we have sort of state variables in the constructor. What we'll do is we'll set a couple of key superfluid variables. So we'll get the address of the host contract that we need to interact with, the address of the constant flow agreement contract we're going to interact with, and we'll do things like also set the receiver or the owner of the NFT as well. So the first step here is going to be calling create option.
00:28:20.700 - 00:29:02.570, Speaker B: So I'll walk through that a little bit deeper. In a second, when the option is created, it'll be able to be started, right. So the option will be then ready to then start. And then when a flow is created into the contract, this function will be run, which will facilitate that transfer of link into the contract and then enable the option to be active and then exercise. So we'll get a little bit deeper into this in just a second. But to zoom out on this particular example, repo, you'll see that this is a hard hat project. So for those of you that have used hard hat, you might see this as familiar, but we have a pretty simple setup that ideally will help make this easier for you to then play around with.
00:29:02.570 - 00:29:43.298, Speaker B: So if you go to this deploy folder, you'll see we have a script here that will let you deploy this contract pretty easily. We're using a helpful library that somebody built around hardhat, called Hardhat deploy so this is just a deployment script. We have a couple of variables we're storing up here just to make sure that we're deploying this to the right addresses on rinkby. So we're using the rinkby test network here. I also have an alchemy URL set up. So in this environment variable file, I've got a rinkby alchemy URL. So I have an archive node here that I can use to actually make live calls to the Rinkbee testnet.
00:29:43.298 - 00:30:15.250, Speaker B: And then I also have a private key that I'm using to sign transactions. So you'll place your own private keys and URLs and things like that in this environment variable file. Just be careful with it because you never want to push a private key to GitHub. That's a huge no no. Don't do that. So if we zoom out and we actually get into deploying the contract, what we can do is run this nice little handy script. So here I can run NPX hard hat deploy and we'll reset just so we have a new instance.
00:30:15.250 - 00:30:24.050, Speaker B: What this will do is it'll compile our contracts and it'll give us just the address that it was deployed at on the Rinkbee testnet.
00:30:24.550 - 00:30:28.646, Speaker A: Sam, sorry to interrupt. Somebody is asking if you could zoom in.
00:30:28.828 - 00:30:29.880, Speaker B: Oh yeah, absolutely.
00:30:30.250 - 00:30:32.582, Speaker A: And maybe expand the page.
00:30:32.636 - 00:31:01.598, Speaker B: Absolutely. Let me do this here. There we go. That should be a little bit better. So we should see this deployed here. We have a new address that this has been deployed at. And then what we can do is then we can use this for some of our approvals later on because we need to approve different transactions to happen, both with the link token, which is our underlying asset, and then also die in just a second.
00:31:01.598 - 00:31:37.370, Speaker B: So now that the contract's been deployed, the first thing we need to do is we need to actually create the option and kind of initialize it, right? So like I mentioned, we'll go back into this redirect all call option and we'll look at the create option function. So we can see here we have a few key parameters we need to pass to this to set up the option. One of them is the underlying asset. Another thing is the underlying amount. Another key one is the price. What's the address of the price feed contract, and then some other things around expiration date, what the required flow rate is, and then the strike price of the option. So we'll settle these things here.
00:31:37.370 - 00:32:14.658, Speaker B: And I have a nice handy script you can use in this createoption Js script that will pass some values you know as the underlying asset. I'll pass in the address of link on rinkby. We'll use just one link token in this option, right? So that's the amount of the underlying asset. The link token has 18 decimals. This here is the link USD price feed. We have this as the flow rate, which is $100 per month. And something to keep in mind about flow rates is that this is the amount of tokens you're sending per second denominated in 18 decimals.
00:32:14.658 - 00:32:42.254, Speaker B: So this is the amount of funds that are going to be sent per second. It's going to be not very much, but it's going to accumulate up to $100 per month. We have a timestamp here for what the option expiration date is. This is, I believe, 12:00 p.m. Eastern time on December 1 of 2021. And then we also have the strike price, right? So we have $28 as the strike price. So right now, I think link is somewhere in the.
00:32:42.254 - 00:33:46.466, Speaker B: We'll be able to then exercise this option in a second after we deploy this, but we also are converting this to an 18 decimal value as well, because the link token is denominated in 18 decimals. So if we run this script, so MPX hard hat, run create option. This will take a second to run, but when it does run, we'll be able to use this read option data script to get some information about the option itself, right. We'll be able to verify that things all look the way we want them to. And if I go briefly into that script here, we'll see that I'm just getting things like underlying asset, what it is, what the address is, making sure we have the right underlying amounts and things so we can run that script here, read option data. Yes, this will just show us. It'll verify, okay, that we have the right information here that we want.
00:33:46.466 - 00:34:40.582, Speaker B: We have set the right things to the contract state, and this will help us make sure that we did the right thing in our create option script. So as a next step, what I have to do is I have to approve this contract to spend the link token as the creator of the option. So let's go do that in Etherscan really quickly. Let's go pull this up. So here, what I can do is go to this link token address on rinkby on Etherscan, and we can use this nice helpful approve method here. So I'll go up, I'll make sure that I copy the value of the address for the contract. We'll go back out here, expand a bit, then I will paste this in and we'll write this transaction so we'll approve the contract to spend one link.
00:34:40.716 - 00:34:46.040, Speaker A: Sorry, Sam, I'm showing up again with a request to please zoom in. And.
00:34:46.570 - 00:34:47.350, Speaker B: Sorry about that.
00:34:47.420 - 00:34:49.862, Speaker A: It's great. Make it all big. Make it all big.
00:34:49.996 - 00:34:51.994, Speaker B: Make it huge, make it huge. Here we go.
00:34:52.112 - 00:34:53.594, Speaker A: Make it huge. There you go.
00:34:53.712 - 00:34:55.658, Speaker B: There we go. Sorry about that, guys.
00:34:55.824 - 00:34:58.970, Speaker A: Can you go full screen maybe with the browser window itself?
00:34:59.120 - 00:35:15.220, Speaker B: Yeah, that might help. Let me do this here. I'll just expand a little bit more so I can still go back and forth, but we can see here. All right, we're writing this transaction. Let's check on it. This is indexing. So we'll refresh this.
00:35:15.220 - 00:35:51.990, Speaker B: But the next thing we'll do after we have this created is we'll actually use the superfluid dashboard to create a flow into our contract. So we'll wait on this for just another second. But the next thing we're going to do here, we'll zoom in on this browser window as well, help you guys out. Next thing we'll do here is use our dashboard to create a stream into the contract itself. So let's go back in. Let's check real quick on the status of this approval. Still indexing, but usually that means it's been included.
00:35:51.990 - 00:36:20.680, Speaker B: So it'll just be another second. While we're out here, we'll also check on the price of link just to make sure that the option can still be in the money. And just as a recap with a call option, if the price of the underlying asset is greater than the strike price, we'll be able to exercise that option. So we can see here that the price of Chainlink is at $32. Right now. Our strike price is 28. So we'll be able to actually exercise that.
00:36:20.680 - 00:36:45.182, Speaker B: Looks like this works. So we've actually done the approval. And as a next step, we will then open up that flow into the contract. So to do this, we can use our superfluid dashboard. I'm going to go in and I'm going to grab that address for the contract and open up a stream from another account into the contract itself. Let's go do that right now. To do this, it's very simple.
00:36:45.182 - 00:37:15.942, Speaker B: On our dashboard, right? We can just hit send here, we can enter an address. So in my case, I'll just enter the address of the contract. We use die, and then we're going to send $100 per month to this contract because that's the minimum required flow rate. We'll approve this. This will execute this transaction for us. And it's nice in the superfluid dashboard because you can manage all kinds of streams here. So I can click on this stream, I can see who it's streaming to.
00:37:15.942 - 00:37:41.230, Speaker B: Zoom in a bit. I can see who we're streaming to. I can see what the amount is per month. I can see what the actual flow rate amount is per second. And we can see here that this was just activated. Our transaction was successfully confirmed. So back inside of our code itself, we can check using the read option data script once more to see if the option is active.
00:37:41.230 - 00:38:19.190, Speaker B: So this will then be true in just a second if we run this script. All right, we'll see here that this is true. So our options active. If I go back into my other browser, which is the browser that I have this other metamask account in, I used to have seven link in this account, right? I'm doing a little bit of hand waving here, but you have to trust me. I used to have seven link in this account. We now have six. And the reason we have six is because one link was deposited into our tradable cash flow option contract.
00:38:19.190 - 00:38:58.150, Speaker B: It's sitting there in escrow until the contract is actually executed or it's exercised. I'm sorry. So, okay, we'll go back out of here next, what we'll do is we will approve the test die token to spend, I'm sorry, we'll approve the contract to spend our test die balance. Right? So I can go back in, I can grab our contract address. We'll approve the contract to spend our die. So here I am on ether scan again. I'm approving it to spend at least 28 die and a little extra just for good measure.
00:38:58.150 - 00:39:25.794, Speaker B: So we'll approve this transaction. Click confirm. There, we'll view it as well. And while this one waits, what I also want to show is the superfluid console. So this is a nice developer tool that our team has also created as well. In addition to the superfluid dashboard that will let you search addresses and kind of manage, like sort of an address book and get more information on flows here that you're interacting with. So here I am.
00:39:25.794 - 00:39:50.018, Speaker B: If I search this, we can see that there's an account on rinkby that's used superfluid streams. This is the contract address. Here. We can view it. We can see different data on this particular token itself. And you can get a lot here, right? So we're basically using the graph. We're pulling information from the graph on particular tokens.
00:39:50.018 - 00:40:14.400, Speaker B: You can get information from the graph on particular accounts. And very soon we're also going to have an instance of what the graph playground has. We can write your own queries actually inside the console itself and get your own custom data here as well. So that's coming very soon. Still pending here. Looks like it was successful. So the contract has been approved to spend our die to facilitate the settling of the option.
00:40:14.400 - 00:41:10.498, Speaker B: So the final thing we have to do is we actually have to exercise the option itself, right? So if I were to go and call our final script, which is very simple scripts, exercise option we'll get here is the option will be exercised. So this script is very simple. Inside of exercise option, we're calling one function here. All it is is exercise option, right? And what this is going to do is it's going to settle our option for us. So if I go back into our contract itself and we take a look at this exercise option function, there are a few checks that happen, right? We make sure that the current time is not greater than or equal to the expiration date. If it is, that means the option was expired and we'll deactivate the option. So we'll kind of just basically turn the entire option off.
00:41:10.498 - 00:41:41.866, Speaker B: We'll send the escrowed funds back to the options owner and just shut things off. We'll also use this helpful function from Chainlink, which let us get the actual price feed data to check and see if the options in the money. We'll run a nice little black magic trick here to convert decimals. This is very technical. You're welcome to take a look at this if you'd like. But this just kind of is a helper to help us convert different decimal values. And then in these final three checks, what we do is we just check to see if, okay, what the current price is.
00:41:41.866 - 00:42:20.906, Speaker B: We make 100% sure that it's not greater than the strike price, or we make sure that it is greater than the strike price. And then we make sure that the current flow rate sent into the contract is greater than or equal to the required flow rate defined by the options creator. If that's all true, what we'll do is we'll facilitate that transfer of Dai from the buyer to the seller, and then we will transfer the underlying asset. So in this case, our link token from the contract to the buyer. And then we'll turn the option off. We'll set these both as false and our option will be settled. And it's kind of a conclusion here.
00:42:20.906 - 00:43:04.002, Speaker B: What we can see, if I go back out to my browser and I take a look at our initial account here. This added one link to our balance. Again, I'm doing a little bit of hand waving, but I promise you we had three link in this account's address here. Now it's four because the option has been settled, right? So the option has been turned off. We can verify that by reading the option data, right? So if I run that read option data, this should be shut off here. These are both false. So option ready and option active are both false.
00:43:04.002 - 00:43:44.574, Speaker B: The option is now inactive, it's been settled, and everything's complete. So if we recap here back in our little presentation, here's what we did right. We deployed the contract using hard hat deploy. Then we ran the createoption JS hardhat script that you're welcome to use as well. After forking the repo, this will set the basic option parameters like strike price, option price, all that good stuff. Then we approve the contract to spend our underlying asset using the link token contract on Etherscan on the Rinkbee network. The option buyer then created a flow into the NFT, our tradable cash flow option, which started the option and transferred the link from the seller into the contract.
00:43:44.574 - 00:44:19.600, Speaker B: So it was held there in escrow. And you can use the create flow script that I have in the code example I gave you, or the superfluid dashboard to create that flow. The option buyer then approves the contract to spend die using Etherscan, which we did. And then finally we can run the exercise option script to exercise the option from the buyer's account. And in the contract we use a chain link price feed to check if the option is in the money and then transfer those funds and settle the option. So that's our application. There's a lot that I tried to pack in there.
00:44:19.600 - 00:44:58.346, Speaker B: So we'll take some time to do some q a right now on anything superfluid related at all. But before we do that, what I just wanted to say is we are here to help you build. This is something that many protocols say, right? We all say that we win when you guys build stuff on top of our protocols and things. But one of the beautiful things about hackathons is we are all, every single sponsor of this event. We are all incentivized to help you build stuff on top of our technology, right? We want to see amazing apps get built on top of superfluid, and we're willing to invest a lot of time and resources into helping you do that. Right? In the end, whatever you build is going to be your responsibility. To run and eventually take the market if that's what you want to do.
00:44:58.346 - 00:45:32.150, Speaker B: But we really try to facilitate and provide a lot of help. So please reach out to me on discord. That's my handle. Like I said, I'll put a message in the superfluid support channel after this whole workshop ends. And you can also hit me up via email as well if you prefer to reach out to me that way. So yeah, I think, Fran, what we can do right now is we can kind of open things up, we can do Q and A if there are questions and then take things from. Yeah, I think you muted Fran.
00:45:33.450 - 00:46:21.910, Speaker A: All right, sorry, yeah, there have been a few questions. A couple of times we heard people saying the font was too small. I hope we fixed that soon enough. Is this real or just a test project? I guess it's a test project. Somebody takes it and makes it real. Manuel was asking where the code for all of this is and I'm just going to drop the link into the chat so you can address it. At the moment it's in its own branch, but soon it will be merged and you will be able to find it directly in the normal repository.
00:46:21.910 - 00:46:28.870, Speaker A: Fidel asks, can you expand on creating super tokens?
00:46:30.990 - 00:46:33.626, Speaker B: Yes, friend, you want to take that one or you want me to take it?
00:46:33.728 - 00:46:34.780, Speaker A: Go for it.
00:46:35.310 - 00:47:06.900, Speaker B: Yeah. So we have a couple of contracts that will help you deploy your own custom native super token if you want, and if you want to deploy any other super token contract, you can do that as well. So we have quite a few super tokens that are created right now. So let me go to our docs. In our network directory you can see some addresses. Do you mind if I share my screen real fast? Yep, let me do that. Let me share real quick, show you where to find these.
00:47:07.430 - 00:47:08.180, Speaker A: Okay.
00:47:08.550 - 00:47:39.040, Speaker B: All right, so here in the network directory, you can see here on various different networks we have like on Matic for example, we have the address of each of these token contracts. These are deployed by community members of ours. So you're welcome to deploy your own super tokens as well. We have a whole section of the docs to allow you to do this. Right. You can either make calls, like I said, to existing super tokens to upgrade, or you can actually go through and create your own super token as well. So we have an additional section of the docs here that lets you do this.
00:47:39.040 - 00:47:56.194, Speaker B: So you're welcome to come in. I will put this link here in the chat as well, and you guys can run through this as well to actually deploy some of these, your own custom super tokens, and also just existing tokens as super tokens themselves. I think this should be helpful.
00:47:56.322 - 00:48:55.618, Speaker A: To deploy tokens, there's two main ways. In one of them you need to basically use a script, so you download it, it's part of the repository, and you can just execute that with some parameters and it creates token for you. But it's even easier to use basically ether scan directly. So you can just go there, interact directly with the smart contract, and there's a contract called the super token Factory. And by simply inputting a couple of parameters, you can create a token in less than a minute. So it's extremely easy to wrap tokens after that. Like Sam said at the beginning of the presentation, you can either call the function called upgrade, which is in the super token contract itself, or you can do it through the dashboard, which might be easier if you're on testnet through the button that says deposit.
00:48:55.618 - 00:48:58.730, Speaker A: So either way you can get some super tokens.
00:49:00.830 - 00:49:36.658, Speaker B: Fidel, I saw your question about wrapping assets and you mentioned that I use normal dye in the example. There's a good differentiation to be made there. So I actually use two forms of dye in our example. I should clarify that, right? The token that's being used to send funds into the NFT contract using a superfluid constant flow agreement. That money stream, that token that I used was the super token Dai, right. So that's the asset you need to wrap. Because in order to use any kind of super agreement, you have to send super tokens to be able to do that.
00:49:36.658 - 00:50:03.840, Speaker B: The normal die that I used was just to settle the option contract, right? That's what I use there. You can either use super token die and just do a normal transfer, like an ERC 20 transfer with the super token if you want, but just for the sake of the quick example, I use normal die to settle that transaction. So I hope that makes sense. Cool.
00:50:05.010 - 00:50:31.240, Speaker A: Well, I hope it was helpful for everyone planning to build on superfluid. We still have a few minutes if anybody else has any questions around how to build an application, how to architect it, how superfluid works. Yeah, if anybody has any questions. If not, obviously it means we did a great job and explained everything perfectly, but that's not usually the case.
00:50:32.250 - 00:51:22.120, Speaker B: Yeah, one last thing I'll say as well is we are continually putting out tutorials and documentation examples. So one, feel free to check those out if you have any questions on how to actually start building. And two, if you have any suggestions or things that were confusing at all as we walk through this example, or as you start getting into the protocol itself, please feel free to reach out and I can try to create more scalable good examples around those specific things that were confusing. So I came to superfluid as a superfluid community member at first. I got involved with the team by just making tutorials at first because there were things that I ran into that were confusing. So any feedback you guys have on that, please let us know and we'll include those things in our docs and also spend some time with you one on one to help you make sure that you're understanding how you want to build the applications you want to build. So just wanted to say that as well.
00:51:22.970 - 00:51:31.850, Speaker A: So Carlos is asking, after the buy option is executed, does the flow or channel automatically close and delete?
00:51:32.190 - 00:52:18.662, Speaker B: Good question. So in our example there that you'll see in our repo, it does not, right? It'd be pretty easy to add that as additional functionality for the sake of speed and brevity, I focus specifically on the option settlement more than the actual closing of the flow. But one thing that might be interesting for you to add is that automatic closing of the option. So that's one thing I think you can add. And then in terms of other interesting things you might want to add to that, I mentioned that forking it and also including a put option functionality as well could be very cool. Specifically for some of those insurance use cases I talked to earlier. And yeah, there are plenty of other interesting DFI related things I think you could probably do using that as a base.
00:52:18.662 - 00:52:26.460, Speaker B: You could play around with expiration dates if you want to. So yeah, we're looking forward to seeing what you guys build on top of it.
00:52:29.360 - 00:52:41.090, Speaker A: But yeah, just more in general, you can execute custom logic when a stream is closed, so should be quite easy to add that if you want.
00:52:45.720 - 00:53:48.516, Speaker B: Can you withdraw a stream before it ends? I'm not sure what you mean by that in terms of a stream itself. When you create a stream, it's just going to be ongoing until either, I guess, the sender or the receiver of the stream, both sides can close a stream. So the flow, as of right now, if you create a stream, it will stay open indefinitely until somebody executes a transaction to close it. And when you as the receiver are receiving the funds there, those are your funds instantly, right? With a normal superfluid money stream, there's no lockup, right. If you want to take those tokens out of the superfluid ecosystem immediately, you can do that too and send them to a different defi application on mainnet, or if you want to bridge things across different chains, you could do that as well. But, yeah. The point around the money streams is that they're very capital efficient.
00:53:48.516 - 00:54:00.590, Speaker B: They don't require you to lock anything up. Cool. Let's see.
00:54:01.840 - 00:54:22.770, Speaker A: One cool thing people are doing now with superfluid, for example, is that as they receive their salary and streams, they send the funds into investment products built on superfluid, right. So you can literally send the money as you receive it. So it's very capital efficient. You can spend it immediately. There's no need to wait or do anything.
00:54:24.980 - 00:55:00.492, Speaker B: I'm actually an interesting case study of this, right? I'm fortunate to be a guinea pig who's getting paid in streams, so I get paid per second. It's kind of awesome. But I can take those funds and immediately dollar cost, average those into different assets using something like ricochet, who's in our community, right. They're a dollar cost averaging investment platform, right? So I can immediately. People talk about, hey, pay me in crypto so I can immediately invest in different assets. Because we're all believers in the space, I can do it in an incredibly efficient way, and it's pretty cool. Thanks.
00:55:00.492 - 00:55:48.104, Speaker B: And if a channel stays open, can it be reused? So if a channel stays open, can it be reused? I am assuming what's meant there is. If you have a flow that's staying open, can you change the flow over time? Can you delete it, recreate it? And the answer to that is have. Let's say Fran and I have a flow together, right? So he's sending me funds, and he decides to turn off the money stream. Right. He can then reopen the flow to me and start a new flow at any time. They're very fluid like that. And they do require a transaction to set up and to change the state of that flow.
00:55:48.104 - 00:56:09.990, Speaker B: Right. If you want to update it, change the flow rate or things like that, it's pretty easy to just change what the flow rate is or to turn things off and turn it back on. And you can see that on our dashboard as well. If you go around and play around there, you can create a stream, edit it, delete it, reopen it. So you should be able to see that there. I hope that answered your question.
00:56:11.880 - 00:56:49.570, Speaker A: Yeah. And another question we had from Amir was, is it possible to force a dual off for closing streams? This is a very interesting question, and when we were designing the protocol, we tried to keep things very simple. Right. So the protocol isn't opinionated. It's not built for a specific use case. It's built to be a generalized system, and as a result, it is possible to do anything. Right? So the answer to your question is yes, you can do anything, but the protocol doesn't enable it, so you have to build it on top.
00:56:49.570 - 00:57:41.250, Speaker A: So the specific use case you mentioned is, is it possible to build it so that I guess both the sender and the receiver have to agree before a stream is closed? Well, the protocol doesn't allow that in the sense that the protocol always gives the users a lot of control. So both the sender or the receiver can always close the stream. And at the same time, you can't really build an application that blocks the user from closing a stream, because for us it's important that the user is always in control of their funds. So it's possible to build exactly what you said, but you have to get a bit creative and you have to build basically a smart contract which opens a stream. And the smart contract has specific permission systems that allow the use case that you want, but you couldn't be able to do it from user's account.
00:57:43.700 - 00:58:25.760, Speaker B: Fidel has a good question. Can you dynamically increase the flow rate, for example, in a use case where someone upgrades their subscription before the end of a previous flow on a lower subscription? So you can increase flow rates at any time? Right. Like I mentioned earlier, you can always update the state of the flow to increase the flow rate. But right now those are going to be manual transactions that have to happen. And when I say manual, I just mean you have to actually send a transaction to the chain. We have been presented with some very interesting ideas around flow rates that can increase logarithmically or increase kind of asymptotically. Right down closer and closer to zero.
00:58:25.760 - 00:58:56.248, Speaker B: Right. We're thinking about including that as like a new kind of agreement in the future. But we have really no ETA on that or anything like that because it gets very complicated in terms of accounting. Right. We need to make sure that everyone is solvent with their balances and with their flows. And whenever you introduce constantly changing flow rates, things get very complex very quickly. So if you have a particular use case in mind for that, please feel free to reach out.
00:58:56.248 - 00:59:09.548, Speaker B: We can look into it because there might be other ways to create this dynamic kind of functionality without having the flow rates that are constantly changing. Fran, do you have anything to add to that?
00:59:09.714 - 01:01:00.060, Speaker A: No, that's perfect. Martin is asking, does it cost anything to change the parameters of a flow? Yes. So because superfluid streams are on chain, whenever you change a parameter, which means create, update or delete, there's gas cost, but between those operations there is none, right? So the moment you create the stream, you don't pay again and you can keep transferring money forever. But the moment you change those parameters, so the moment you stop the stream or you update it, then you have to make a transaction and there are costs. So you generally want to, whatever you're building, try and build it with the minimum amount of user interactions possible, right? So for example, to pay somebody's salary, maybe you need only one transaction and then you keep paying them forever, right? That's a great user experience. The moment you start requiring the user to come to your app every day and making a transaction, then the user experience degrades, right? But this is where Chainlink becomes very interesting, right? Because you have your off chain computation, you have your off chain keepers, and you could build your smart contract to enable a keeper to do operations, right? So just going back to the previous question where you want to have one of these flows changing the rates every now and then, well, what you could do is build your smart contract authorizing a chain link keeper to update the flow under certain circumstances, right? And by doing that, the user still has a great user experience where they don't have to do any manual operations, but the stream is somewhat dynamic and changes when the market, for example, changes. So that's one idea that you could build for the chain link hackathon.
01:01:00.060 - 01:01:41.020, Speaker A: And as we said, our second prize is literally using the keepers. So that could be one use case if you can find a cool application for it. All right, well, if we have no further questions, anything from the Chainlink team? Are you guys there? Okay. All right, well, let's wrap it up there. Thanks a lot, everyone. It was a great session. Thanks for all the questions.
01:01:41.020 - 01:02:15.814, Speaker A: One last thing, I'm going to drop our discord link into the chat. So if you have any unanswered questions, or if you have any ideas you want to discuss, join our discord. It's the best place to come and talk with us and get one on one help. We are always down to schedule calls and stuff like that. So just reach out, come and chat with us and build something really cool. As I said in the talk, superfluid was born at a hackathon. Just no better place to experiment, come up with crazy ideas and see what the market thinks about them.
01:02:15.814 - 01:02:22.726, Speaker A: Generally, the crazier the better in my experience. All right, thanks everyone.
01:02:22.908 - 01:02:24.390, Speaker B: Awesome. Thank you guys.
01:02:24.540 - 01:02:29.650, Speaker A: Thank you. Bye.
