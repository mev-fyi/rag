00:00:08.570 - 00:00:33.206, Speaker A: All right, great. So we've deployed to rinkby using hardhat. This is fantastic. Now, something that we notice once again is, oof, our contract isn't verified. Do we have to go back through and do this verify and publish and all that stuff again? Lucky for us, we actually don't need to do that. So what can we do? Well, back in our deploy script, we can add some code to automatically verify right after we deploy. So let's go ahead and do that.
00:00:33.206 - 00:01:12.686, Speaker A: Right below our main function, we're going to create a new function called verify. We're going to say async function verify, and we're going to have this function get passed some arguments. We're going to have it get past a contract address and some arguments for the contract. Since our simple storage doesn't have a constructor, the arguments for simple storage are just going to be blank. But in the future, when we have contracts that do have constructors, the arguments are going to be populated. And when we get there, you'll see what I mean. We need at least the contract address, and we're going to add some code in here to automatically verify our contracts after they've been deployed.
00:01:12.686 - 00:01:59.374, Speaker A: This auto verification process works on block explorers like Etherscan. It might not work on block explorers like ethplore or other block explorers, but if you want to verify on these other block explorers, I'm sure they have an API to allow you to do that as well. Now, Etherscan and most other block explorers have a section on their website called API documentation or something to do with APIs. These are ways for us to programmatically interact with Etherscan and do stuff with them. One of the main things that we can do is we can actually verify our contracts through this API. Etherscan even has a tutorial in here called verifying contracts programmatically, and a link to this will be in the GitHub repo. They have an API endpoint that we can make some requests to to go ahead and verify our contracts.
00:01:59.374 - 00:02:44.718, Speaker A: Now, we could absolutely make the Raw API calls and follow the tutorial here, but there's actually an easier way than even going through this tutorial here. Hardhat is an extensible framework, meaning you can add something called plugins to it. There's even an advanced section in the documentation called building plugins. If we scroll down to the bottom, we can see some popular plugins that the nomic labs team or the Hardhat team has created, and also a number of community plugins as well. One of the most used hardhat plugins is going to be this hardhat etherscan plugin that makes this verification process much much easier to install it. You can just run NpM, install save dev at Nomiclabs hard at etherscan and then add it to our hardhat config. Since we're using yarn, we're just going to go ahead and use yarn.
00:02:44.718 - 00:03:49.730, Speaker A: So back in our code we'll do yarn add dev at nomiclabs Hardhat scan now that we have this plugin, we can go to our hardhat config, scroll to the top and add this plugin in. We'll do require at Nomiclabs Hardhatscan now that we have this plugin, the hard hat documentation has some more information about the usage, how to actually use this plugin and how to run different commands with it. In order for us to use this verification, we actually need an API key from etherscan. This is basically a password for allowing us to use the Etherscan API. So we're going to come to Etherscan and we're going to go ahead and sign in and actually we're going to click to sign up and create an account. And we'll go ahead and create an account. We'll go ahead and verify our registration by clicking the verification link and we'll click the login.
00:03:49.730 - 00:04:33.938, Speaker A: Now that we're logged in on left hand side, we can scroll down to API keys and we can go ahead and create a new API key. We can call this hh FCc, which stands for hard hat freecamp. We'll create this new API key. We'll copy this and we'll go back to our code and we'll add this somewhere. Since this API key is basically considered a password, where do you think we should add this? That's right in our env. So in our env we're going to add a new entry called Etherscan API key and we're going to add that API key that we just got. Now that we have our API key back in our hardhat config, we're going to create a new section in our module exports to tell Hardhat that we have this etherscan API key.
00:04:33.938 - 00:05:11.390, Speaker A: Our new section is going to be called Etherscan. And in here we're going to say API key is going to be etherscan API key that we're going to define up here the same way we define these other keys. So we'll say const etherscan API key equals process env etherscan API key. And if something like this pops up, you can generally just hit enter and it'll autocomplete it for you, which is awesome. Great. So now we have an ether scan API key back in the hard hat documentation. It tells us by adding this we actually get a new task called Verify.
00:05:11.390 - 00:05:47.114, Speaker A: Let's try that out. Let's open our terminal back up and we'll do yarn hard hat and let's see what pops up. Wow, we did get a new verification here. When we run yarn Hardhat, Hardhat actually looks into our hardhat config js and checks for any plugins. If there are new plugins there, it'll add them as a new task that we can do. You can manually verify your contract by doing yarn or MpX hardheadverify network, the deployed contract address and any constructor arguments yourself. But we want to be a little bit more programmatic than this.
00:05:47.114 - 00:06:27.750, Speaker A: So what we're going to do is we're going to go back and create this verification function. It is good to know how to do it via command line so that if you want to verify something in the future manually, you can. Let's build this verify function though. So we're going to take our contract address and some arguments, and for our sake we're going to do console log verifying contract just so that we know we might have to wait for a little bit. And in our code we can actually run any task from hardhat using a run package. So up at the top we're actually going to import run from Hardhat as well. Run allows us to run any hardhat task.
00:06:27.750 - 00:07:16.946, Speaker A: So in our code here we're going to do await run and then we can do there. If I now hardhat allows you to add different parameters as well in this run, and it's usually best that you go ahead and add them in here so that we're really specific with what we're doing. If we do yarn hard hat verify help, we can see what parameters we can actually pass. Well, it looks like we can pass the verify parameter, so we'll do colon verify. If you go to the actual GitHub for the verification task, you can actually see you can do more than just verify. You can do verify, get minimum, build verify, get constructor arguments, verify verify, which is what we're going to be working with and a couple of other subtasks as well. The second parameter that goes inside run is going to be a list of actual parameters.
00:07:16.946 - 00:08:11.798, Speaker A: This second parameter here is just kind of the subtask, if you will, of our verify task. And this is going to be an object that contains the actual parameters and this is where we pass in an address which is going to be our contract address, and then our constructor arguments, which is going to be args. Now, normally just this right here should be enough for us to go ahead and use this verify contract in our main function. But we're going to add one additional thing to it, because in practice sometimes there's some errors that can come up. One of the errors that often comes up when running await is that the contract has already been verified. And you'll actually likely run into this because etherscan will go smart enough by seeing enough bytecode that is exactly simple storage, that it'll start to just automatically verify any bytecode that looks like simple storage. And then this await will throw an error which we want to avoid.
00:08:11.798 - 00:09:07.578, Speaker A: So what we can do is we can add a try catch onto this await. So outside of the await, we're going to add a try and we're going to add these little brackets that wrap around our await and then we're going to put a catch e. This is known as a try catch, and solidity also has try catches. But basically this e is going to be any error that this section throws. So what we're going to do is we're going to say if this message is already verified, then we're just going to continue. So we're going to say if e message two lowercase, we're going to make sure it's two lowercase includes already verified, then we're just going to do console log already verified like that. Otherwise we're just going to console log e.
00:09:07.578 - 00:09:32.302, Speaker A: The reason we do this is because if this errors, our verification function will break and our whole script will end. And we don't want our whole script to end. We want our script to keep continuing if the verification doesn't work, because it's not really a big deal. So I know this might seem like a lot of code. Feel free to copy and paste it from the GitHub repo to just move along, but. Awesome. So we now have a verify function using the verify task in hardhat.
00:09:32.302 - 00:10:05.950, Speaker A: Let's go ahead and use this. Now in our main function right below our deploy, we'll do console log deployed contract two and then the contract address. But before we call this main function, let's think for a quick second. What happens when we deploy to our hard hat network. Well, remember, if we deploy to our hard hat network, will our contract need to be verified on ether scan? Well, we know there's a rinkby ether scan. We know there's a coven ether scan. We know there's a mainnet ether scan, but is there a hard hat ether scan? No, of course not.
00:10:05.950 - 00:10:45.210, Speaker A: Right. The hard hat runtime environment is a network local to our machine, so it doesn't make sense for us to verify a hardhat network deployed contract on etherscan. So we actually don't want to call this verify function when we're working with our local network. This is where these chain ids are going to come in quite useful. What we can do is we can check to see if the network that we're running on is a live network or it's a testnet, or it's a network that actually can be verified. We can actually get network configuration information by importing network like this. And we can do something like console log network config.
00:10:45.210 - 00:11:35.178, Speaker A: Now if I run yarn hardhat, run scripts, deploy js on our hardhat network, since I'm not passing a network flag, we get this massive output that looks like this. Our network config contains a ton of information about the current network that we're on. You'll see here that the chain id of the hardhat network is actually 31337. We have gas price, which gets set to auto block gas limit, the current fork of Ethereum that we're working with and all these other pieces here. This chain id is really important because we can use this chain id to figure out which one is a testnet or which one is a live network. And remember, running the script is going to be the same as doing network hardhat. You'll see our chain id is still 31337.
00:11:35.178 - 00:12:20.030, Speaker A: Again, that's because the default network in our hardhat config is hardhat, which is the same as saying every single time we run a script we're secretly running it with network hardhat. So now we only want to verify on our testnet. So what we can do is we can say if network config chain id equals equals equals four, which is going to be rink b. And in javascript equals equals equals is nearly the same as equals equals. Except no type conversion is done, which just means in JavaScript four equals four. And four equals equals the string of four, but four. But if you were to use four equals equals equals four, this is false.
00:12:20.030 - 00:12:39.710, Speaker A: So this is true. Equals equals four equals equals would be true. Four equals equals to the string of four would also be true. But four equals equals equals to the string of four is going to be false. So you can kind of do whatever you want here. Equals equals or equals equals equals. So we want to say if the network config Trinity is four.
00:12:39.710 - 00:13:31.678, Speaker A: So if we're on rink b, then we can go ahead and actually verify. But we also want to make sure we only verify if our etherscan API key exists. So we can also in here is say and this double ampersand means and we can say process env etherscan API key. This is some boolean tricks that we're doing here, basically. So our first conditional we're saying if network config chanity equals equals equals four, this section can be true or false, obviously, right? The chain id that we're running on can be the hard at network, which would mean this doesn't equal four, or it would be rinkby, which means this does equal four. But there's no conditional on this side. So how does this side work? In JavaScript, if an object exists and you try to cast it as a boolean, it'll be converted to true.
00:13:31.678 - 00:14:27.714, Speaker A: If it doesn't exist, it'll be converted to false. So in Javascript, basically if Etherscan API key exists, if we have this in our env, this will be true, and if not this will be false. So another way to read this line here is saying if network config chain id is four, aka if we're on rinkby and our Etherscan API key exists, then do some stuff and that's what we're going to do here. So in here we'd want to run verify our verify function and pass it the contract address, which is going to be simplestorage address, and the constructor arguments, which we know are going to be blank. And since our verify function is an async function and it deals with promises and stuff, we want to add the await keyword here. Awesome. So we've added a way to actually verify our contract, but we're not quite done.
00:14:27.714 - 00:15:22.382, Speaker A: See, on Etherscan and all these block explorers, the instant we deploy the contract and the instant we send the contract, Etherscan might not know about the transaction yet. It might take a hot second for Etherscan to be up to speed with where the blockchain is. So it's usually best practice to wait for a few blocks to be mined until you actually run your verification process. We've actually learned how to do this already with the deploy transaction, so before we actually verify, we want to run await simplestorage deploy transaction wait six. So we will wait six blocks and then we'll run our verification process. Now, if you want to go and test this out right now, you absolutely can. I'm going to keep going though, because again, testing all these on a testnet takes a little bit of extra time.
00:15:22.382 - 00:15:34.180, Speaker A: So I'm going to finish the rest of our main function and then I'm going to run everything all together close.
