00:00:04.410 - 00:00:28.626, Speaker A: All righty, I think we're live. Let me double check the YouTube real quick. We are fantastic. What's up? Good morning, everybody. Gm. Good time of day, wherever you are. I'm Richard, one of the developer advocates here at Chainlink Labs, and this one's going to be a bit different than the other ones I've done during this hackathon.
00:00:28.626 - 00:01:09.780, Speaker A: If you've caught those, I'm going to keep things a bit more laid back, unplanned. Talking about adding web3 chain link stuff to your existing projects. When it comes to things like games or mobile apps or web two apps in general, I've got an example to walk through with you. All of something I did for a project a while back. And going from there, just planning on answering questions. So if you're here in the chat, like congratulations, most of this is going to be left up for time for you all to just ask questions, how to do things, thoughts on things. Maybe we can do some brainstorming, planning together.
00:01:09.780 - 00:01:35.804, Speaker A: So in the chat, let me know where you're from, where you're tuning in from, so I can kind of get an idea of what's going on. And yeah, I'll give it just another minute or two for people to gather and then we'll get started. Asheville, North Carolina. Nice. I'm in Texas. New York City. Oh, man.
00:01:35.804 - 00:01:51.904, Speaker A: We got the USA crew today. India. There we go. Some global representation. I love it. Normally it's like all over the world and hardly ever see anybody from the, you know, it's kind of backwards today, I guess, but yeah, that's awesome. Cool.
00:01:51.904 - 00:02:33.816, Speaker A: So if you have questions, thoughts, stuff like that as we are going through, pop into the chat, I will do my best. I am by no means a streamer, so I'll do my best to keep up with the chat and everything like that. But let's dive in. So let me share my screen and we'll talk through something I put together a while ago. Tire screen. So when it comes to games and stuff, one of the easiest, probably simplest games out there is flappy bird. And a while back, I needed to make a game for a demo, and so I started with flappy Bird.
00:02:33.816 - 00:03:02.244, Speaker A: I personally love svelte when it comes to web development. I just like how easy and straightforward it is to understand. And so I found this great little demo tutorial to go through. How to make flappy word in svelte. Man, it's hard to talk this morning, so it walked me through everything and we came up with that. And let me see here so we had this basic game, right? And it looks okay. We got our little dude here flapping away on the screen.
00:03:02.244 - 00:04:13.340, Speaker A: It's a little square, it's got some bars, but it's basically flappy bird, right? And I thought to myself, how could I make this more web3 enabled, use some chain link services? What could I do? So I started kind of brainstorming and I thought, okay, so what if your score was stored on chain? That'd be cool. What if we actually stored that score in an NFT? That'd be even better, right? So then you'd have some way to actually prove that you had that score and you get something from it. What if that NFT changed over time? Like as you got a higher score, you got a different NFT. What if you use that NfT image to actually be the character that you were playing as all these know, started brainstorming all this. And so with all know, there's a lot of changes that would be made to this project. So what does that look like? Where did I start? Well, I started with using, I believe it was. Which one was it? Dolly, I think, to make some assets.
00:04:13.340 - 00:05:01.384, Speaker A: So using Dolly, I made some assets, like a little bird to flap. I thought, okay, so we've got a bird, but how should it start? Like when you're a new player? Well, we start as an egg, right? And so using dolly, because I am not a graphics designer nor a pixel arts person, I did that. And know final mode, we're going to need like an eagle with a crown. And dolly came up with an eagle with a crown for me, and we were good there. I've stored all these things on IPFs, so why did I put them on IPFs? Well, IPFs is decentralized storage, right? So it'll always be there. And you know, they're not going to change when they're there because you get this unique hash for all the files that you upload. I did that using pinata, which is just a service, like a gateway to access IPFs.
00:05:01.384 - 00:06:02.040, Speaker A: So I created a pinata account, uploaded some stuff there for my images, and I created a couple other images with Dolly for the background. But that's kind of where I started, right? It started with the basic piece, because then I could replace this square with that bird. And that makes it more interesting. And then I started thinking about, okay, how do I actually build this into a contract for the purposes of storing score and the image and all that? So let's take a look at that. It looks like I accidentally closed down the vs code. I had one secondary. What's up? Good morning, everybody.
00:06:02.040 - 00:06:35.802, Speaker A: Look at vs code here. I took a basic ERC 721 contract. Where did I get that from? Well, I went and got that from open Zeppelin. So open zeppelin, if you're not familiar, is like the standard when it comes to contracts. And they have this amazing wizard right here where you can basically generate a ERC 721 contract. Pretty straightforward. You can name it if you have like a URI for the images you can put in there, but you can make it mintable, burnable, add that URI storage.
00:06:35.802 - 00:07:09.580, Speaker A: The URI storage is going to be where you're going to store the information for the actual NFTs, the information about it, and this gives you the basic contract. You can copy this out. So you've got your mint functionality, your token Uri here, and we'll take a look at this. And the better way to do this, because setting and updating the Uri, I don't know, it's something that isn't necessarily apparent at first. One of the better ways to do it. So I went to open Zeppelin, got that ERC 721 contract, and you'll notice, like, this contract looks nothing like that contract. Right.
00:07:09.580 - 00:07:40.082, Speaker A: The reason is because I also went to chain link stocks and got some stuff for VRF. Now, as I was looking at that game, we have flappy bird. We have him flapping on screen. I thought, okay, so we could do something with VRF. What could we do? We could maybe change the color of the bird like when you first mint your NFT based on VRF. But that didn't seem very interesting. And then I thought it might be more interesting to actually just have like a score multiplier based on VRF.
00:07:40.082 - 00:08:24.690, Speaker A: So we could multiply our score based on a VRF thing and maybe just have that change like every couple of minutes using automation. And I thought if you were like, being competitive about this game, having a score multiplier that changes on like a five minute interval is a pretty terrible thing, because then you'd be wanting to check back every couple of minutes. But to see is it the super high multiplier yet. And so I can play and actually get the ridiculously high score. So I combined those three things, right. So an ERC 721 contracts, Nft the VRF contracts, and then using automation. So if you look at this now, it's going to look a lot like the VRF example.
00:08:24.690 - 00:09:13.022, Speaker A: Let's go take a look at that. So we had the docs chain link, and we head on down to VRF and we look at getting a random number, it'll walk you through everything you need here as far as like setting up subscriptions, creating that contract. So if we actually open this contract, example in remix, you'll see. Now this is starting to look a little bit more like what we have over there, right? We have our key hash information. We've got our key hash. So I literally used what I consider the most powerful tool in any developer's arsenal, the copy paste, and started from there. So I set up this contract by combining those two other contracts.
00:09:13.022 - 00:09:46.234, Speaker A: I also had to do some mapping here because we've got. Yeah, thanks for popping those links in there. We've got the need to map like an address to a token ID. So like when you mint it, we're going to need to keep track of what your token ID is because then too we'll need to use some things from that token ID. We've got the image, URL, score, name, stuff like that as well. We set this up with the basic multiplier of one. We have a subscription ID from VRF.
00:09:46.234 - 00:10:44.078, Speaker A: So the way that VRF works is you create your subscription and then you need to let your subscription know about the contract. But when you actually deploy your contract, you need to let it know the subscription iD. So basically you have to kind of set up both so that they can talk to each other and that's how you authenticate your contract. In order to use VRF, we set up a couple of events like score changed, we set up another mapping for the NFT owner to the token ID. We've got our key hash here with VRF, the way that works is you reach out to the VRF coordinator contract and that's one event, and it goes off and generates that random number for you. Then it's going to reach back into your contract and actually run a function within your contract, which you'll see here in a moment. When that happens, there's going to be a callback gas limit as well as the gas lane that you want to use.
00:10:44.078 - 00:11:09.218, Speaker A: So what you're willing to pay for a gas price, if you look at the documentation here, it can explain that normally on the testnets there's just the one gas lane, but when it comes to main nets, there'll be multiple. So if you want your transactions to run faster, you can put them in a higher gas lane. Of course that'll cost more. We have our callback gas limits. That's how much gas can be spent when it comes back. In this example, we're just updating that multiplier. So it's a very small gas limit.
00:11:09.218 - 00:11:39.060, Speaker A: You can run into problems when it comes to having a gas limit that is too high or having a gas cost that is higher than your gas limit. Right. So if you're doing a lot of stuff in that function, when you call back in, that can be an issue for sure. So just keep that in mind. So we have our request of confirmations. How many block confirmations go by before we get our random words back? Random words, random numbers. And then we have the number of random values that we're getting back, which is one.
00:11:39.060 - 00:11:59.846, Speaker A: We set up our contract here with the constructor, let it know that consumer coordinator, the VRF coordinator's address. And then we set up our contract. Right. We set the scription Id. We increment our token counter to one. This is weird. Normally NFTs start at zero.
00:11:59.846 - 00:12:31.422, Speaker A: I found that when I was creating this that having it start at one was a little easier to get that information into the actual game. Maybe I did something wrong somewhere else. Just a weird little oddity. We have our mint function where we actually mint the player's NFT, right? So maybe now's a good time to see what this actually looks like when we get closer to being done with it. So we have this new flap on chain thing. We attach our wallet here, maybe. Oh, I stopped this one.
00:12:31.422 - 00:13:15.546, Speaker A: Let me start this back up it. What we got going on now? Oh man. Every time I do that, does it bother anybody that little fox watches you type your password? I don't know. It bothers me. So when we get there, this here is my actual NFT. You can see it has my previous high score up here in the top. And I apologize, this is tiny.
00:13:15.546 - 00:13:57.280, Speaker A: Let me make it bigger so we can see as my previous high score, it has the current score multiplier, right? I could reset this NFT back to its egg state, or I can just play the game and flap away my little bird. And it's pretty cool. I also use dolly to generate the, using the, using the computers to do all the work for me. So I could view this NFT and we can actually see it on OpenSea. We can see our high score here a little bit about it, right? So we've got that NFT created. So it's a big step up, right from our original flappy bird game here. But the mechanics behind it are the same.
00:13:57.280 - 00:14:19.560, Speaker A: So we mint that NFT, we have our update score function. This is going to be like when you finish that game, it's going to call this function to actually update that score. You can do that here. Let me reset the NFT real quick back to the first state. We'll give it a second. It may not change immediately. It takes a second to change sometimes.
00:14:19.560 - 00:14:46.286, Speaker A: Just depends on how fast the network's going. Yeah, it's pending. When this resets though, we'll see. There's another button here, if you will, that will let you actually update your NFT because it's a change to the blockchain. Right. So we're going to need to actually confirm that with Metamask you can see now. Okay, so we switched back the egg, right? And so my score is one.
00:14:46.286 - 00:15:23.626, Speaker A: And so it's a new high score so I can update my NFT and I can save that score as my current score on chain. So that's what update score does. And then based on that, it's going to set some things for that actual value. Now I'm setting all these things, right. I'm setting the name, which you can see here, there's like high score achiever, regular player, new player. I'm setting the image URL for that actual nft id. The reason I'm doing that here is because when we look at the token URi, if you remember in the open Zeppelin contract, where'd it go back here.
00:15:23.626 - 00:16:29.438, Speaker A: This token Uri returns the token Uri for the token id. And when I first started messing with NFTs, the way that I saw to update this would have been to actually update the token URI for each NFT when it changed, which that takes a lot of gas. And if you're doing that fairly often, that's like no good. So what you can do is you can override the token URI function and you can actually have it come back and create that token Uri JSON object right here. And what's great is it's a view function, right? So it doesn't cost gas if you're just calling it off the blockchain. So we're setting things like the name and the image URL and then we're using those to inform this function what the actual json object is coming back, which to me that was huge. It looks like in the chat too, there's somebody who is offering to be a back end developer.
00:16:29.438 - 00:16:58.518, Speaker A: Just hit him up. He's looking for a team for the hackathon. Always good to have another teammate. So we return that token UI, we get all the information. That's what lets you have your name, your description, that URL for the image, any attributes here we're just using the score for that iD. We also have the request new multiplier function. Now what this does, this is what we'd call with something like automation.
00:16:58.518 - 00:17:57.178, Speaker A: So to request that new multiplier, that's going to be a request to VRF to get a new value back. You can name the function that calls VRF that calls request, random words, anything you want. It is important though, if you're using something like VRF, or if you're using VRF that you have fulfill random words, because that's going to be the function that it's looking to call back to when it actually has those random values. So here you can see I'm just doing a multiplier and doing it modulo ten to get that value between one and ten. And then we have our burn functionality. So this is the basic contract that powers the NFT, right? So this contract is what's giving us these NFTs. And I think too if we refresh this one, we should see here, since I reset, it's no longer the eagle, now it's the bird because I saved my high score and it's more than zero.
00:17:57.178 - 00:18:33.782, Speaker A: So our actual NFT is changing. I think that's pretty cool. I think it's a pretty cool use case for gaming and stuff like that. We've got a question. What is VRF? It stands for a verifiable randomness function. If you go to our documentation here, we'll go back to the main docs page down here at the bottom or in the middle ish bottom we have vrf which is going to be getting those random numbers that are verifiable on chain. Got some other questions here.
00:18:33.782 - 00:18:51.280, Speaker A: What is the first argument of a fill request? It doesn't appear to be used. It's like a quiz question. I don't know what it is off top of my head. Let's take a look. Request new multiplier. The key hash is the first value. So that key hash that's going to be.
00:18:51.280 - 00:19:35.840, Speaker A: Where's the best place to show that? If we look up here, we set it. So the key hash is going to be what that gas lane is, right. So this is going to be the gas price to bump to when you're making your request. So if you look here at these ported networks, you can see different networks have different ones. But like on the main ethereum one, for example, we have a 200 way, 500 way and 1000 way key hashes that you can do. This is the gas lanes that you're willing to bump up to for your transaction it. Okay, so we talked about how we made this smart contract, right? And we have our NFT going.
00:19:35.840 - 00:19:59.036, Speaker A: Oh, so you mean the second argument. Sorry. Let's get this sorted out in the callback function. Oh, the fulfill random words. The second argument, I don't actually know off the top of my head. Let's go take a look at that. Getting a random number.
00:19:59.036 - 00:20:34.556, Speaker A: We opened it in remix right here. So it's, the request ID is what's coming back. So I'm not using that. But that will be a way to map between the two values. If you, for example, had a NFT, if we're doing something with the NFT, right? And we wanted, like when we minted the NFT, we wanted to get a random value and then come back in. The request ID is how we do that. So when we make our request, the request, random words will return that request Id.
00:20:34.556 - 00:21:07.144, Speaker A: So we'd map that request Id to our NFT ID, and then when we came back with fulfill random words, we'd map the other way. Right? So we'd map from the request Id to the NFT Id, and then we'd change things with that NFT. Hopefully that makes sense. So that's kind of how you could keep track of your request if you had multiple requests going out. Since in this case, I'm just changing the multiplier. I don't care if it gets hit like multiple times, it's always changing the same value. Good questions though, for sure.
00:21:07.144 - 00:21:25.688, Speaker A: Okay, so we've got our contract, right? And we've got that. Oops, this is getting confused here. There we go. Too much code. Got our contract set up right, and then we've got our basic spelt application here. I don't know if you're familiar with svelte at all. It is its whole different animal.
00:21:25.688 - 00:21:55.668, Speaker A: I really love it though, because it keeps things simple. Basically, the way svelte works is there's like three main parts to a spelt file. There's a script, there's like your HTML part in the middle, and then there can be css at the bottom if you want that. Maybe a good example of that is bird here. So we have our script tag up here, we've got our HTML in the middle, and then we have our Css down below. So I like it just because it's simple. Everything is here altogether but speltworks.
00:21:55.668 - 00:22:30.224, Speaker A: By starting off with this page at the top of routes, this is going to be like your index, essentially. In here we have all the different imports. We've got our contract address and we'll use this to do the game and the wallet connection. Now, when it comes to interfacing with walLets, there are a lot of great tools out there. Like Wallet Connect is fantastic. I've just written my own very small one here that just doesn't do much other than expect you to have metamask installed and then it can connect you to Fuji. And that's it for this example.
00:22:30.224 - 00:22:54.196, Speaker A: But it's pretty basic. So this would be the first thing that I had to change, right? I had to add some of this Web three props. Here is how I'm keeping track of everything. I had to add my contract and I have to connect the wallet. That's step one if you're adding anything to a Web three space. So we've got this set up. We connect to Fuji.
00:22:54.196 - 00:23:17.776, Speaker A: For this example, I just use Fuji because it's the avalanche testnet because for demo purposes it runs really quick most of the time. So I don't know, that's why I was using it. So we set that up right and we connect our wallet. There's not much to it other than that. That's all that this does. It just connects our wallet from there. Once your wallet is connected, then it'll load game.
00:23:17.776 - 00:23:47.272, Speaker A: And we have this game typescript file here. This is going to be from that example that I was using to actually create everything. This is all the logic behind the game. Basically we look at game spelt here. We have a bunch of stuff here for getting the score. So we connect to the wallet that lets us actually connect to the blockchain. From there we can get the token ID and then we can load the image, the score.
00:23:47.272 - 00:24:23.924, Speaker A: We can also load the multiplier from the contract. And we convert our NFT ID into a plain number because it comes back as a big number. So we load up our score and then we're just doing the same stuff that we were doing before, right? There's not much to it except for in this game, like when it's over, then we can update our score. We can know update NFT. If we click on that button, we can reset our NFT. Or if you don't have an NFT, you can mint one. So I added this stuff in here.
00:24:23.924 - 00:25:48.630, Speaker A: I know this isn't like an in depth tutorial, but I just kind of thought that would be more interesting to just kind of treat this as a. How do you start to add web3 into something that already exists? Instead of it being like one specific tutorial. So I know I'm just kind of like throwing all of this at you, but what questions do you have about how this works? You all been asking some great questions already. Gm, melody, how's it going? I guess while we wait for any questions to come in, I'll pop back over and we'll just kind of walk through the flow. If you don't have an NFT, just kind of show what that could look like. Refresh here, attach the wallet, make things a little smaller so we can see the whole game. So I don't have an NFT on the second account, right? So if I go to mint NFT, they'll actually create the NFT for me.
00:25:48.630 - 00:26:21.500, Speaker A: Let's wait for that to be created, man. It wasn't a tutorial, but there's no questions. I am doing fantastic, evidently. So it's minted. I've got my little egg here, right? And so we can play our game, we can go check it out, this new NFT hazard. See, we've got a couple now. Pretty cool.
00:26:21.500 - 00:27:24.318, Speaker A: I mean, if there's no questions, this can just turn into like a gaming stream here and we can try to max out our score. That's a good question. So how can you prevent someone from spoofing a transaction with a high score? That's a good question. Because the way I have this set up right now, if you take a look at update NFT, this function, it's just calling straight in, right? With like update score. If we look at the actual contract itself, which. Where did that go? Look at the actual contract itself, update score here. You can see it's just public.
00:27:24.318 - 00:28:07.754, Speaker A: Anyone could call it. So how do we do this? Maybe we could limit this to a require and ensure that there's some piece of information in here that we have as like a key or something like that when we're actually making the call to do that. I don't know. That's a good question. I don't know what the best way to do that would be, but you definitely have to do some sort of key to have that ability. Because normally the way that I would approach this would be I'd require only the owner of this contract, for example, to make that call. And we can't do that in the way this is set up.
00:28:07.754 - 00:28:33.394, Speaker A: Right? So that's a good question. I don't know. I hadn't thought about that too much. So, yes, you definitely could, if you were savy, set your score to like 1 million pretty easily. That's a good question. What refreshing polling rate can chain link support. Is it processing done on local chainlink node? So I'm not sure in regards to this, I think you came in late, you're saying here.
00:28:33.394 - 00:29:16.474, Speaker A: So when it goes to refreshing polling, I think probably the answer that you're looking for here is that things happen once per block. So that's going to be dependent on what chain we're talking about. So I said, for example, that I was using Fuji because it's faster, it goes through blocks faster than something like sepolia. And so that's going to be dependent on the actual chain between chain link polling and updating the blockchain. Yeah. So I guess we take a spin here to something like data fees, for example. Or we'll use automation.
00:29:16.474 - 00:29:30.774, Speaker A: Right. So automation checks every block if you need to run that automation. And so every block that goes by, it checks. And then it would be the next block that it's going to actually execute that update on. Right. Because it's one block, it's checking, it gets back. Yes.
00:29:30.774 - 00:29:47.514, Speaker A: I need to run it the next block. It will go ahead and run it. Hopefully that answers your question. Good question. Man, it's too early. I haven't had enough coffee for this question about preventing transactions, though. I'm mulling on that.
00:29:47.514 - 00:31:06.802, Speaker A: Anybody have any ideas in the chat? Like how you could prevent someone from spoofing a transaction with a high score? With the way this is set up, how would you approach it? Curious. Maybe we require. So like only the owner can update, right? Like, I don't know. Maybe you could hash the score with some sort of, in the game itself, you could have like an environmental variable set up, hash that score, pass that in as well, and verify that that hash is correct with a separate function in here. I don't know. That seems spoofable too. Maybe browser proof of time, Ssl.
00:31:06.802 - 00:31:32.690, Speaker A: Okay, that's an interesting solution there. Yeah, I'm here with King, though. I'm feeling this. Like, I can't think of anything right now. This is a good question, though, for sure. That would be the hard part about gaming. I wonder how other games kind of solve this problem when it comes to things like allowing mints and stuff like that.
00:31:32.690 - 00:32:06.350, Speaker A: Because in those games out there, when you find an item like you get that NFT and stuff like that, I wonder how they're handling that. Maybe they already have them minted and they just do the transfer event and they base that on something you're doing in game. I don't know. It's like the old, like if you can read the solidity code. It's basically cheat codes. It's like idkfa, if you know what that is from doom. It's good times.
00:32:06.350 - 00:32:46.228, Speaker A: Yeah. Cool. What other questions you all have? There's only 14 of you right now, it looks like. So prime time to ask those questions. If not, I guess we can call it a session here. It was booked for longer, but this is a great question. Can nFTs be merged? Say you had a crafting feature in a game, so you definitely could do that, right.
00:32:46.228 - 00:33:48.680, Speaker A: And the way that comes to mind, I would think of that working is if you had a, I don't know, iron NfT and a wood Nft, right? And you wanted to combine them to make an axe or something like that, you could check that you have both those types of NFTs. And then if you did have both those types, generate a new NfT to merge them together, because you'd need to at least burn one, right? So you need to get rid of one and generate that new one. You could update one and burn the other one if you wanted to do that. If you didn't want to generate a full new NFT, I do know. So I haven't spent as much time as I probably should investigating ERC 1155. But it's kind of a combination of ERC 20, which is just tokens, and ERC 721 NFTs, where you can have kind of both. And maybe there's a better way to do that.
00:33:48.680 - 00:34:44.516, Speaker A: With ERC 1155, I'm not sure, but I think with the 721 you definitely could. Yes, I think that's atomic minimird. So, yeah, doing that in one transaction, right? So the craft function would take in two NFTs and then burn them and generate a new one. This technology be able to use cross chain like gala games. So what we're looking at here, there is no cross chain component to it as far as what I set up. But fundamentally it's very basic stuff. If you had a way to get them cross chain, some sort of wormhole or something like that, you could move your tokens across chain.
00:34:44.516 - 00:35:44.804, Speaker A: I guess by updating one we can simply change its image URi. So you can definitely do that, right? So nfts, I don't know, something that was like mind blowing to me when I first got into this was like when I first heard about NFTs, it was like, oh, it was like digital art. And they're static assets, right? They don't have to be static assets at all. I'd often joke that you'd be really mad if you bought a piece of art like a Picasso and you came home and everybody jokes so my five year old can draw that Picasso and your Picasso was replaced with somebody's five year old drawing, you'd be super upset. Right? When it comes to NFTs, if you expect them to be static and always show the same thing as like a piece of art, you definitely should make sure that that's how the contract is set up. Because this contract, for example, we saw the NFT go from the egg to the bird to the eagle back to the egg, right? So you can definitely do that. You can change image Uri.
00:35:44.804 - 00:36:33.770, Speaker A: So the token Uri. So in this instance we're changing the URL and we're also changing the score. But literally you could change everything about the token Uri and return whatever you wanted. You could return the names now like King is the king of flap on chain, whatever you want there. Senior using avalanche what networks would be best for games? What features would you look for? That's a very weighted question there. When it comes to what networks, it all depends. There's so many trade offs, right? Like I mentioned, I'm using Fuji right now just because for me, historically it's been really fast.
00:36:33.770 - 00:37:15.512, Speaker A: I also am just living in testnet land, so nothing that I do with demos and stuff like that matters. It's all monopoly money out there, right? Depending on what you want is going to depend on what network you want to use. Some networks are going to be more decentralized and more reliable. They'll always be there. Like as long as one node is running, that network is alive, right? And so if you invest a lot of time into that, you could invest in running a node and keep that network alive and ensure it would always be there. Other networks are going to be more secure, but slower. Some are going to be faster, maybe a little less secure, some will be a little bit of a blend of both.
00:37:15.512 - 00:37:57.380, Speaker A: So that's kind of a hard question to answer as far as which one would be best for games. There's also the cost component, right? Like the gas costs do matter depending on the type of game that you're doing. If you have a game where you're not doing a lot of transactions, but the transactions have a lot of value associated with them, you might be okay with a slower network that has higher reliability and security. If you're doing a lot of transactions and they're just for things like inventory items in the game that don't necessarily have a lot of value attached to them. But you're doing it a lot. You're going to want that to be a faster. So it just.
00:37:57.380 - 00:38:12.824, Speaker A: It all depends on what you're looking for. I know it's kind of like a non answer answer. Yeah. And DNFT is dynamic. NFT. That's what I normally talk about there. It's a great question.
00:38:12.824 - 00:39:21.830, Speaker A: It's a good conversation. I really like it. What else are y'all wondering about? Anybody planning to make a game for their hackathon project? That would be awesome. Evan's going to come back like in the hackathon, submit a project and be like, I made crisis for the blockchain where every single pixel is on chain. I'm going to be blown away. I had to create a new blockchain, too, just so it'd run fast enough to calculate every pixel and save it all on chain. Any games using chain link functions? If so, how did you incorporate it? So I haven't built any games yet using chain link functions.
00:39:21.830 - 00:40:18.620, Speaker A: How would I incorporate it? I guess I'll answer how would I? Right? Instead of how did I. So chain link functions, it gives you anytime you would access an API in a game, you could do that, right? So I don't know, you could have the score multiplier. In this example, we're using VRF, right? Maybe you could use the current weather from an API call to affect that score multiplier. So if it's raining right now, that's not great for flying in. Right? So have that change that. Or in this example, maybe you have achievements for your flapper where based on that weather, flew in the rain, flew on a windy day, that kind of stuff. You could definitely do that and have it affect things as well.
00:40:18.620 - 00:40:42.254, Speaker A: Functions, it opens up the entire Internet to you, essentially. Right. Because you can make API calls. So what all you could do with it is basically limitless. I don't know. There's a ton to do. Building a wellness platform for the hackathon.
00:40:42.254 - 00:41:07.258, Speaker A: That's awesome. I'm looking forward to seeing that. Did you cover database for game user profiles? So, no, I didn't cover database. Basically, I'm using the user profiles and stats. I'm just using the blockchain as the database here. I do know there's a project space and time, for example, that allows you to connect databases to your smart contracts. So if you want to look into them.
00:41:07.258 - 00:42:12.936, Speaker A: I know that I've seen some of their stuff and that's pretty cool for doing that. But yeah, the database I'm using is basically the blockchain for this one tiny little NFT piece here, if you got to bigger, more extensive stuff, you probably would want to look into some other solution for sure. It's a great question, Solana, when it works, is a great chain. Yes, it's very fast. Not sure I understand your question here about the data we need to get the reward. So this example is set up was to basically use get the NFT for connecting and minting. There's no reward piece.
00:42:12.936 - 00:42:44.820, Speaker A: I guess the reward piece could come from as you progress. Right. Your little character here can change. So from the little egg to the little bird, the eagle. Give it a second here. We'll see if we can get this to refresh. Yes.
00:42:44.820 - 00:43:06.140, Speaker A: Now we got a little bird. See, that's the only reward we have in this case is just kind of upgrading the NFT itself. These are all great questions, though. I really like this conversation. It's great for y'all who are here because you actually ask questions and stuff. If you're watching this later, afterwards. Sorry you weren't here.
00:43:06.140 - 00:44:14.150, Speaker A: What other questions y'all have? We haven't really actually used the score multiplier at all, but it, you could integrate it in with some sort of hardware device and then you could have jump on chain and you could have to jump instead of flap. I don't think that would work in real time. That'd be really terrible. What if your little bird could pick up potions or something like that? How would you code that? So if you wanted other things to happen, like as you're going along. Right. So that would probably exist. You need to account for that actually in the game logic to spawn those potions.
00:44:14.150 - 00:45:24.630, Speaker A: You could integrate it in with something like VRF or you wanted to affect the randomness of the potions, like what type of potion appeared. And then within the game logic itself, I guess it's in here. The logic in here basically accounts for when you run into the pipes. You could do the same type of thing for when you run into the potions. When you ran into the potions, then you could have a function for mint potion or something like that, and you could mint that potion to them. The only thing that you run into with trouble, I found, and I'm sure there's a way around this I just haven't thought of it, is when something happens like that, you're going to want to make that state change on chain, which means you have a gas cost associated, which means that you're going to need to confirm that in your wallet so that could be kind of a rough experience. Maybe you could do it at the end of the level like you then get all your potions that you collected during the level, but from like a user experience perspective, that could be rough.
00:45:24.630 - 00:46:32.180, Speaker A: Probably with some sort of proxy contract actually paying for it. You could do that, but the actual minting piece as you're playing the game can be a little bit roughly. So since you're using blockchain for the profiles, using an array of wallets. So the way this is working here is this have a mapping, right, of the user's address to their token ID? Sort of, but it's not an array, it's a mapping. And so when you come in, it'll check for your address and the token ID. Yeah, now I'm starting to be. I was excited about King's wellness project here, but now we're turning into a black Mirror episode and I don't know, he's going to combine it with some sort of know chat GPT and then it'll accidentally take over a Boston dynamics creature and it's going to be bad.
00:46:32.180 - 00:47:27.916, Speaker A: Maybe you should abort, King. Yeah. Confirming transactions will be drawing. I'm sure there's a way to get around that, though, because obviously there's projects that do that, right? Like all the gaming blockchain, gaming apps, they do that for sure. So there's got to be a way to do it all. Wonder about questions, thoughts? Yeah, man. Now I'm like know I'm going to see King's name in the hackathon judging.
00:47:27.916 - 00:48:52.282, Speaker A: I'm going to click connect wallet to his app and there's going to be like a knock on my door or something and old robot's going to be out there waiting for Daniel. Your app, it takes all kinds, right? Boring stuff like that is super useful and great. I think it looks like most of the questions have dried up. I'm getting scared by this black Mirror episode, so might have to cut it off. Any other questions though, before we go? See, my game is not perfect either because the box around the image is definitely a square around the image or rectangle around the image. I didn't hit that corner. Yeah.
00:48:52.282 - 00:49:14.474, Speaker A: Cool. All right, well, if y'all have questions, feel free to reach out on Twitter. Discord on Twitter. I'm at rgottliber. I'll post it here in the chat. If you have any questions, feel free to reach out there. We have our discord for questions about the hackathon.
00:49:14.474 - 00:49:32.440, Speaker A: There'll be more people than just me, probably people smarter, funnier, better looking, hanging out in our discord. Awesome. Well, thanks you all for tuning in, and, yeah, I'll see you around. Good luck on your projects. And I'm looking forward to judging them. Maybe a little bit scared now, though. I'll be honest.
00:49:32.440 - 00:49:39.730, Speaker A: Have a good one. Bye.
