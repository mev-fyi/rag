00:00:15.160 - 00:00:57.944, Speaker A: Excellent. Welcome to smart contract automation masterclass number four. Today we are going to be talking about Defi circuit breakers using proof of reserve. I'm joined by Sam Friedman, one of our subject matter experts in Chainlink automation. And today we're going to walk through what proof of reserve is, what Chainlink automation is, and how you can leverage Chainlink automation to verify reserves. At the end of this talk, we're going to be joined by Ave and they are going to explain their use case for Chainlink proof of reserve and chainlink automation in production. So what is proof of reserve? This is a very timely topic and there's a lot of different flavors to proof of reserve.
00:00:57.944 - 00:01:39.144, Speaker A: The way Chainlink proof of reserve works is by bringing visibility onto the collateral assets that back liabilities. So you can think about tokens issued on the blockchain as a liability, and the chainlink node network pulls the reserve assets on chain for everyone to verify any given token's backing. There are different types of asset tokenization as we've seen. There's off chain assets. These can be things like stablecoins, precious metals, different structured financial products, and there's a lot of benefits to tokenizing these fractionalization, programmability. But they also come with a risk. The risk is that we can't see natively on the blockchain what they're backed by.
00:01:39.144 - 00:02:22.790, Speaker A: We also have cross chain assets. These are things like wrapped assets. There is no native bitcoin on ethereum, so we have wrapped versions of bitcoin to give people exposure. But these derivative assets carry the same risk as off chain assets and that we can't natively see what they're backed by. So this is where Chainlink proof of reserve comes into play, and we really categorize it by two different implementations. There's cross chain proof of reserve, which is the ability for the chainlink node network to pull reserve verification from another blockchain. And there's off chain proof of reserve, which leverages auditors and custodian accounts to verify the collateral in web two, and traditional financial custodial services.
00:02:22.790 - 00:03:11.568, Speaker A: When we think about who proof of reserve benefits, we look at three categories. One is the token issuer. These are the people issuing both wrapped assets and off chain collateralized assets to them. This provides additional guarantees that they are fully backed and they can even implement proof of reserve into their minting function to show that they can only mint what they have backing for. And we also think about DeFi developers and dapps. So a lot of the talk around proof reserve lately was around exchanges and centralized institutions, and DeFi was largely unaffected. But we see these same institutions deploying these liquid tokens, wrap tokens, and off chain collateralized tokens into DeFi, and it's important that DeFi is able to protect themselves and they can use proof of reserve as a circ breaker.
00:03:11.568 - 00:03:34.430, Speaker A: The last, of course, is for token holders, people who actually hold these assets. They want to know that the assets they hold are fully backed at all times, and they can do so using proof of reserve. We're working with a number of great projects on this bringing transparency, including AavE, Gemini trust token, and the rest you can see listed here. I'll pass it over to Sam to talk a bit more about what Chainlink automation is.
00:03:35.680 - 00:03:36.780, Speaker B: Thanks Max.
00:03:37.280 - 00:04:22.504, Speaker C: Next slide please. So we're already familiar with smart contracts and their ability to provide cryptographic guarantees to power all kinds of contracts that were previously not guaranteed. But they do have some limitations. So the first key limitation of smart contracts is next slide please is they can't execute themselves. So a smart contract needs an externally owned account, typically a user with a wallet or maybe a system running an application to execute the smart contract. So there's no sleep function or wait function in a smart contract. Next slide.
00:04:22.504 - 00:05:36.476, Speaker C: Thank you. So the way chainlink automation solves this is by providing a trigger mechanism for any arbitrary on chain condition or off chain condition. So good examples might be time or calendar has a certain amount of time passed? Is it a specific day, week of the month, last Saturday of the month, for example? Or it can be an on chain condition like has a price reached certain threshold? Or does a custom function in a contract return a particular value? Or even something more complex, like a combination of multiple factors like function return values, price, oracle price return values, or next slide please. So the second limitation of smart contracts is all computations cost, some amount of gas token, and on some chains that can be expensive. Or even on non expensive chains or low gas fee chains, frequent executions can add up and add a lot of cost. So chainlink automation solves this problem. Next slide please with off chain computation.
00:05:36.476 - 00:06:33.930, Speaker C: So off chain computation might be as simple as testing the complexity of some trigger condition, like testing if a certain amount of time has passed, or a combination of things like has time passed and is a certain value or state changed to meet a certain condition. I could also do things like loop through large data sets, perform calculations, or manipulate data. So a good example might be an auto compounder might have 50 different vaults and checking which vaults are ready to be auto compounded, or have their rewards harvested and redeposited would be an expensive proposition to do on chain with chainlink automation, all of this can be performed off chain. Create a data structure like an array with the index ids of all the vaults that are ready to be auto compounded, and then pass that value to an onchain function.
00:06:34.460 - 00:06:35.560, Speaker B: Next slide.
00:06:36.620 - 00:07:47.630, Speaker C: So with these two capabilities of being able to trigger based on onchain or off chain conditions and perform calculations off chain at no gas cost, there are virtually unlimited number of use cases that are now available. So things like limit orders, distributing rewards, optimizing yield are all really good examples. Algorithmic trading is a very common example right now. So you can create delta neutral strategies that manage or that monitor debt ratios or collateral ratios and automatically rebalance and adjust positions without risk of liquidation. And then one final and key use case that's enabled by smart contract automation is circuit breakers. So automation could detect a rare event like a black swan event. It might be user defined, or it might be something pretty standard, and then perform some sort of remediative action, automatically letting users sleep at night, or just giving users a peace of mind.
00:07:48.100 - 00:07:49.200, Speaker B: Next slide.
00:07:51.380 - 00:08:27.704, Speaker C: The way chainlink automation works is there are three main components. The first component is the user's upkeep contract that might be an existing contract with a public function or external function that needs to be called, or it might be a new contract created specifically for automation. The second part is the Chainlink automation registry, where users would register their smart contract and fund it so that it can be serviced by the third component, which is the automation network. So this is a decentralized oracle network. Each node in that network monitors upkeep contracts.
00:08:27.832 - 00:08:28.940, Speaker B: Next slide.
00:08:30.880 - 00:09:25.464, Speaker C: The user's upkeep contract would have two main functions. The first is a checker which checks for the trigger condition, and this is checked every single block. It can perform off chain computation and there are no gas costs for anything done in the check upkeep or checker function. Any data or data structure created or value calculated in the check upkeep can be passed to the second function, which is the performer which defines the onchain action or what transaction is submitted on chain. So a good example might be a limit order where the checker function checks all the pending orders to see which ones are ready for execution, meaning the price has been met and maybe additional criteria like the market is open, and then pass in the ids of all those limit orders to the perform upkeep function to be executed.
00:09:25.592 - 00:09:26.044, Speaker A: That way.
00:09:26.082 - 00:10:11.740, Speaker C: We're not looping through large data sets on chain. Next slide, please. So here we have an example of the process. The automation nodes take turns monitoring all the users upkeep contracts that have been registered. And basically that means they call the checker function or the check upkeep function. If that check upkeep function returns a boolean false, then nothing happens and the very next block that function is checked again, or that upkeep contract is checked again. When any of those functions return true, then the result of any value calculated in it is passed to the perform upkeep function and that transaction is submitted on chain.
00:10:11.740 - 00:11:15.410, Speaker C: So the benefits of smart contract automation are primarily the user doesn't need to deploy or maintain any infrastructure. They don't need to stand up servers, they don't need to pay for cloud services, they don't need to hire system administrators, write custom code, have operational maintenance, or system administrators to maintain those servers or that code. There are no additional skills required to write a different type of code like bash scripts or python scripts, or know how to manage AWS accounts. There's also the benefit of reduced costs because a lot of the work can be performed off chain. We've eliminated a single point of failure, which might be a cloud service having an outage or a Linux server going down. And there's an increase in security because we've eliminated a risk of having to store private keys on a server or a third party service.
00:11:16.420 - 00:11:24.910, Speaker B: Thank you max. Great.
00:11:24.980 - 00:11:30.510, Speaker A: So let's chat a bit about how we can combine these two solutions to add more security to any protocol.
00:11:34.840 - 00:12:37.156, Speaker C: All right, so black swan events happen, and they might be the types of events that we all expect, like a pegged coin losing its peg. It might be a collateralized position becoming under collateralized. It might be something customer specific to a particular protocol or user like maybe suspicious trading activity in the governance token. It might be price feed or price exhibiting a particular pattern of volatility or instability, or maybe staleness has been detected. Without any type of automated triggering mechanism. Then the next logical event would be some sort of failure, a catastrophic consequence, like a shortfall event liquidation, hopefully not cascading liquidations. In the event of maybe suspicious trading of a governance token, it might be a governance attack or something worse.
00:12:37.348 - 00:12:38.440, Speaker B: Next slide.
00:12:39.340 - 00:13:28.868, Speaker C: With automation, a user can detect these conditions again, every single block. Chainlink automation would test the trigger condition for one of these black swan events, and if it's not detected, do nothing. But when it is detected, it can perform whatever function the user has designated would be their preferred critical intervention. That might be stopping borrowing on a particular asset. It might be halting or slowing down trading. In a dex, it might be pausing one particular vault or a number of vaults that are exposed to a particular asset that dpegged or anything else that the user decided. So again, without this, someone would need to either manually or automatically monitor and then wait for manual intervention or response.
00:13:28.868 - 00:13:37.340, Speaker C: But with Chainlink automation, these events can be automatically detected and responded to by a decentralized oracle network.
00:13:39.840 - 00:13:41.020, Speaker B: Thank you, Max.
00:13:42.240 - 00:14:35.336, Speaker A: Yeah, and I think one of the benefits of working with protocols across the ecosystem is that we get to see firsthand a lot of these black swan events and how they affect protocols and what protocols are thinking about. To defend against these. Want to talk a bit now about bridges and how proof of reserve ties into bridges? Because this year alone, we've seen now over 2 billion in bridge exploits. So bridges can be a great utility to the ecosystem in that they allow these assets to move, cross chain and enter new markets, but they also carry substantial risk. And so with automation and proof of reserve, we can actually address some of the risk that applies to protocols using bridged assets. What we've seen over the last few years is two main types of attacks. There's the source chain exploit and the infinite mint.
00:14:35.336 - 00:15:38.124, Speaker A: So on the source chain exploit, we can use this diagram to understand exactly how this operates and who's affected. Ideally, in a perfect world, as you can see in stage one, we have 100 tokens locked up on a source chain, blockchain A, and 100 synthetic or wrapped tokens minted on blockchain B. Now, with proof of reserve, we're relaying the amount of tokens locked up on blockchain A at all times. So assuming you're checking the token supply against the pur feed, the token supply should always be less than or equal to the Por feed for that wrapped or bridged asset. When there is a source chain exploit, the attacker is able to somehow gain access to the tokens locked up on blockchain A, usually by a bridge EoA. Now, in this case, blockchain B, is not aware that these tokens, synthetic wrap tokens, are no longer backed proportionally. But with proof of reserve, the feed, the proof of reserve feed can update to inform protocols developers and users that, hey, these tokens are now only partially collateralized.
00:15:38.124 - 00:16:32.528, Speaker A: And if you see the check down in the bottom right, you'll notice that now the token supply is no longer less than or equal to the por feed. The other area I mentioned is infinite mints. So this is the case where the derivative token or wrap token has a supply increase greater than what is correspondingly locked up on the source chain. If you're using proof of reserve, you can verify that, hey, the token supply is now greater than what is locked up, and you can perform whatever preventative actions you need to prevent. So we've seen, I think, just offhand, a number of these mechanisms used to exploit protocols, and this ultimately affects the user. So if you're a defi developer for a platform working on a chain that uses bridge assets, this information is valuable to you and it's valuable to the security of your users. Now, using Chainlink automation, you can actually check this against a proof of reserve feed.
00:16:32.528 - 00:17:28.800, Speaker A: So as Sam explained, the check upkeep function runs every block. And what you can do is verify that the token supply here is essentially less than the proof of reserve feed. So if the token supply ever exceeds the proof of reserve fee, then you know that some preventative action needs to be performed. And so if this condition is ever essentially failed, then you can, as soon as the next block, perform some preventative action, like shutting down lending, preventing borrowing, decreasing LTV ratios, or transferring into a different asset. Whatever preventative action you need to perform, you can essentially have access to in as short of time as the next block. So we have a number of users who are integrating this to protect their users, and one of which is Ave. And now we are very fortunate to be joined by Ernesto from BGD Labs, one of the lead development firms on the AAve protocol.
00:17:28.800 - 00:17:42.380, Speaker A: Ernesto wanted to ask you a few quick questions about your implementation of chainlink proof of reserve. Together with automation, maybe we could start with learning a bit more about what the AvE use case is for proof of reserve and automation combined.
00:17:43.920 - 00:18:33.264, Speaker D: Yeah, thanks for having me here, Max. Yeah, like you say, I co founded DGD Labs. We are like a development firm that is contributing to the ecosystem. And yeah, we are integrating chainlink proof of reserve into Ave. So basically, as you can imagine, the Ave protocol relies quite heavily on different types of assets. Some of those assets are backed by some type of reserves. So those reserves can be like both something like reserve in the bank, or it can be also like breached assets from one network to another where the reserves are in the origin chain.
00:18:33.264 - 00:18:51.680, Speaker D: So I think those are the main two use cases for the Abbey protocol of using chain link proof of reserve. And our solution is more centered at the moment into the second one. So, bridge assets on deployments of Abeli, for example, in avalanche.
00:18:52.820 - 00:19:05.380, Speaker A: Yeah, that's great. This year alone, to your point, we've seen over 2 billion in bridge exploits would love to get into more of the details. Could you maybe elaborate on how exactly this mechanism works inside the Ave protocol?
00:19:06.360 - 00:19:07.350, Speaker B: Yeah, sure.
00:19:08.200 - 00:20:04.360, Speaker D: Basically, to put a bit of context on bridge assets, how it works is that usually, let's say, in the abbey B three version deployed in avalanche, there are multiple assets. The big majority are breached from Ethereum, and even there is like BTC, which is breached from the bitcoin blockchain. So what that means is that there is like assets locked on the region chain. So ethereum or bitcoin that get a tokenized representation on the destination chain. That is where the average deployment lives. Something that is quite fundamental is that the value of those assets that are represented into avalanche is the value, factually, of the assets are locked on the region chain. And it's also really important for the protocol to understand that those assets are completely safe.
00:20:04.360 - 00:20:42.420, Speaker D: What allow us to have, with proof of reserve, like proof of reserve, as I guess like people is familiar, is a feed that tell us in real time to the other protocol or to any other defi application using those assets, how much is the backing of those assets in the origin chain. So in our case, like, let's say high level, we use it to do validations and to act with risk protections over the protocol. If the protocol observes any type of problem with the reserves on the origin chain, that's great.
00:20:42.490 - 00:20:57.130, Speaker A: That makes very clear. I guess maybe one final question. If I'm an ave user, a lot of things, these things happen in the background. They may not be aware, why is this important to ave users, even though they may not see this, what additional security is this providing to them? Why is it important?
00:21:00.220 - 00:22:19.430, Speaker D: Well, what is quite important is that if at any point, and hopefully it doesn't, but if it happens, like any type of exploit affecting the reserves in the origin chain, or even affecting especially the minting mechanism in the destination chain, the protocol should at least understand that this situation is happening and react in consequence to whatever mechanism the protocol has. So in the case of Ave, what we don't want is that if, for example, there is minting that is not a legitimate one, in the destination chain, we want to act and not really allow more entrance of capital of that affected asset, or exit of capital via, for example, borrowing mechanism of the protocol. At the same time, it's really important that if we notice that the reserves were exploited somehow in the origin chain, we also need to understand that the value of the asset is in question at that point in destination chain. So kind of similarly, we need to stop the entering of the asset and the collateral power, let's say, of it.
00:22:20.680 - 00:22:23.796, Speaker A: Ernesto, we know you're very busy. Really appreciate you taking the time to.
00:22:23.818 - 00:22:26.070, Speaker B: Talk to us today. Thanks.
00:22:32.300 - 00:22:39.000, Speaker A: Great. Well, we were very fortunate to have Ave join us and now we have some time for questions from the audience.
00:22:41.500 - 00:23:20.004, Speaker C: I see. One question. We've already developed our smart contracts. Do we need to create and audit new contracts to use automation or proof of reserve? That could get expensive. The short answer is you do not need to create a new contract. So if you already have contracts with public or external functions that do the job that you want, then all you need to do is create something like a wrapper contract that calls your existing functions. You could create that contract, call your functions, register it with the chainlink automation registry and that would be it.
00:23:20.004 - 00:23:23.480, Speaker C: So any existing code you created would be reusable.
00:23:26.220 - 00:23:53.230, Speaker A: Yeah, Sam, just to jump on that, I think the cool part about this with automation is the flexibility. Everybody's protocol is different. There's different mechanisms that you may implement for safety. An example of lending protocol, you may want to disable borrowing against the asset, disable deposits, pause the protocol or lower the LTV ratio. And that's really up to you in the control mechanisms that your protocol has available. Good question.
00:23:55.840 - 00:23:57.590, Speaker C: See if we have any other questions.
00:24:10.380 - 00:24:26.590, Speaker A: Sam, maybe on the topic of how costly audits are, maybe one of the benefits of talking about the reserve plus automation combo is the cost. Can you maybe walk users through kind of the benefits of this system and the cost?
00:24:27.760 - 00:24:55.616, Speaker C: Yeah, absolutely. So with Chainlink automation, you only pay when work is performed, when transactions are submitted on chain. So if you have a condition that you want to check for every single block, there's no cost to you. That check will run indefinitely. Check every single block, checking for the condition. If it's not true, then nothing happens. If it is true, then the user is charged.
00:24:55.616 - 00:25:09.240, Speaker C: And the way they're charged is when the user registers their upkeep. They fund their registration with link token, and those link tokens are used to pay for the gas of any performed action.
00:25:15.280 - 00:25:19.970, Speaker A: Got it? See if we have another question.
00:25:20.660 - 00:26:32.840, Speaker C: I see one right over here. What kind of support does Chainlink provide? Developers that want to use automation or proof of reserve? So we have a team of solutions architects. That's my primary role at Chainlink. So typically when a user is interested in integrating one of our oracles, whether it's proof of reserve or automation price, feed, VRF, they could start any number of ways. There's a wealth of knowledge on stack overflow and we've got a public discord with channels for each of our different oracles and then we have a team of solutions architects that are available. So if you reach out to the website, you would have the opportunity to work with an expert in various different types of protocols and use cases of our oracles and we can solutionize. Talk about risks, capabilities, limitations of oracles, what you're trying to accomplish with your decentralized application, even kind of walk through iterations of your solution until you think you have it right in development environment or testnet.
00:26:32.840 - 00:26:40.280, Speaker C: So there are all kinds of options for support. Max, I don't know if you want to add anything for proof of reserve.
00:26:41.900 - 00:27:29.544, Speaker A: Yeah, I think Sam listed a lot of great resources, also highlight our know. I think we put a lot of effort into making our docs as easy to use as possible with as much information as possible. So definitely check out the documentation and also the Chainlink GitHub is an open source repository, so you're welcome to go in. We have example contracts in there as well and that's a great place to get started, which I guess ties into our next question. How long would an integration, I mean, I think if you ask a different developer you might get a different answer. This definitely depends on the team, but from our perspective, we've tried to create all these resources available, including code examples, to make this as seamless as possible. But I think it'll probably vary from project to project.
00:27:29.544 - 00:27:48.000, Speaker A: The great thing about proof of reserve is it uses the same aggregator model as Chainlink data feeds. So if you're already familiar with price feeds from Chainlink, the proof of reserve feed is going to be essentially the same interface to access that information. So I don't know, Sam, anything? Have you had any experience with developers and timelines with automation?
00:27:49.060 - 00:28:13.530, Speaker C: Yeah. So it depends on the use case and what already exists. Again, if sometimes the contract already exists and we're just automating it. And in a previous master class we did a live integration of a user's existing contract that was done in about ten or 15 minutes. And then we have more complex use cases that are maybe combining oracles that would take more development and more iterations and could take days or weeks.
00:28:15.980 - 00:28:35.090, Speaker A: Awesome. I think we're winding up on time here. We've got a ton of resources that we laid out. All those will be available in the description of this video. Want to thank BGD labs for speaking today and appreciate everyone who tuned in. We hope to see you all at the next master class.
00:28:36.900 - 00:28:39.100, Speaker C: Thank you, bye.
