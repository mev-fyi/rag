00:00:10.490 - 00:01:06.174, Speaker A: Okay, great. So now that we have a minimalistic interface which will give us the ABI, how do we actually go ahead and get the price here? Well, documentation has a good example if you want to play with it and try to reverse engineer it as well. Here's how we're going to do it in our code. We're going to create an aggregator v three interface object called price feed. An aggregator v three variable called price feed which is going to equal to aggregator v three interface contract at address this address exactly the same as what we're doing down here. We're assuming a contract at this address is going to have all the functionality of this aggregator v three interface, which again means it has this decimals function, this description function version, get round data and the important one, latest round data which has the latest price at this answer piece. What we can do now is we can call that latest round data function on the price feed.
00:01:06.174 - 00:01:51.502, Speaker A: So we'll say price feed, latest round data. Now if we look at the interface we see that this latest round data actually doesn't return one variable. It returns a whole bunch of different variables and that's what we're going to return in our contract. So we're going to put these parentheses and we're going to say un 80 round id. We can even look right at the documentation to see what else it returns. Int price started at un timestamp and then un 80 answered in round. Now there's a lot of code here.
00:01:51.502 - 00:02:32.776, Speaker A: Since this function returns so many different variables, we have to set something up to capture them. However, all we care about is price. We don't care about round id started at timestamp or answered in round. So what we can do is just remove them and just leave the commas. And now we have int price equals price feed latest round data. The reason that price is an int 256 and not a UN 256 is because some prices or some data feeds could be negative here so that it's an int 256 so it can stay flexible. Now that we have the price, this is going to be price of eth in terms of USD.
00:02:32.776 - 00:03:16.204, Speaker A: And we saw an example of this before it was around 3000 and it returned this number because solidity doesn't work with decimals for a number of reasons. But we just need to know that there are eight decimal places associated with this price feed. If you want to double check how many decimals there are. This contract has a decimals function that you can call as well that will tell you exactly how many decimals are in this price feed. Now as we know, message value is going to have 18 decimal places. Why does it have 18 decimal places? Well, because one ether is equal to 1234-5678. 910, 1234-5678 is this massive number in way which has 18 zeros, which is equivalent to 1.12,345,678.
00:03:16.204 - 00:04:02.068, Speaker A: 910, 1234-5678 so we want these to have the same decimal places, right? Because right now this has eight, this has 18. They're different units right now. So to get them to match up, all we need to do is return price times one e ten, or one raised to the 10th, which is equal to 112-34-5678 910. Message dot value, though is going to be a UN 256. And right now price is an int 256. So how do we convert this value from an int 256 to a Un 256? Well, we can do what's called typecasting. All we need to do is add un 256 and wrap this whole thing up between these two parentheses.
00:04:02.068 - 00:04:34.548, Speaker A: You can't typecast anything, but there are some values like int 256 and Un 256 that can be easily converted between the two. Now, of course, since we're not modifying any state with this get price function, we can make this a view and say it returns a u into 256. And if we save and compile, we go ahead and we get that checkmark. Now, math can be a little bit tricky. The first couple of times you do it in solidity, but the more you do it, the easier it becomes. And in the future, we can always reference a function like this to figure out. Okay, here's the easiest way for me to get this number.
00:04:34.548 - 00:05:12.668, Speaker A: Awesome. So now we have a get price function, which is going to return a UN 256, which is going to be the price of ethereum in terms of USD. All we need to do is convert the message value from Ethereum to terms of dollars. Let's create this get conversion rate function. For this one, we're going to take an input parameter of UN 256 of ETH amount. It's going to be a public view function and it's going to return a UN 256. We're going to pass it some eth amount, and on the other side we're going to get how much that EtH is worth in terms of USD.
00:05:12.668 - 00:06:03.676, Speaker A: So we're going to do a UN 256 EtH price equals get price. So first we're going to call our get price function that we just created to get the price of Ethereum. Then we're going to do un 256 eth amount in USD equals eth price times eth amount and then we're going to divide it by one e 18. When you're doing multiplication and division math in solidity, you always want to multiply and add first and then go ahead and divide. Since ETH price and EtH amount both have 18 additional decimal places, if we were to just let them rock without this, they would have an additional 36 zeros tacked onto the end. So we need to divide by one e 18. Now, when we get to the hard hat sections of this course, testing all this math is going to be a lot easier.
00:06:03.676 - 00:06:38.088, Speaker A: And if you're really struggling with some of the math bits right now, I wouldn't let that slow you down, because once we get to hardhat, it's going to become a lot easier to actually test this than working on a testnet. And this ETH amount in terms of USD is the number that we're looking for. So we can just go ahead and return Eth amount in USD. This needs to be returns here and boom. Now we have a get conversion rate function. To walk you through the math real quick, let's say the EtH price is going to be $3,000, so it's going to be 3000, but it's going to have an additional 18 zeros tacked on the end. It matches the method value way units.
00:06:38.088 - 00:07:20.776, Speaker A: And let's say, for example, we send one eth or 112-34-5678 910. 1234-5678 eth into this contract. One ETh should equal $3,000. So to get the price, we're going to now do the EtH price, which is 3000 times the eth amount, which is this one, and then divide by one raised to the 18. So math it out, we'll do three. 1231-234-5678 910, 1234-5678 times 3000. 1234-5678-1234-5678-9 ten times 1123-4567-8123-4567-89 ten.
00:07:20.776 - 00:08:00.576, Speaker A: And now we divide that by 1123-4567-8123-4567-89 ten, which equals 2.99 e 21, which the calculator kind of messed up the math a little bit. But 2.99 e 21 means this has 21 decimal places. So it'd be 2.12,345,678. 910, 1234-5678 910 one or 1234-5678 910, 1234-5678 2999.99. And this is actually exactly the reason why we don't do decimal math.
00:08:00.576 - 00:08:38.832, Speaker A: In solidity, our calculator saw that massive number was having a hard time getting it, so it ended up rounding that number to 2.99. When we work exclusively with whole numbers in solidity, we don't have a chance of losing that precision. And in solidity, this is going to return exactly $3,000, which is correct. One ethereum at $3,000 per ethereum is going to be $3,000. And like I said, since we're building this contract, assuming we're going to be working on this testnet, we're not going to test this function on the testnet because we're going to have to wait for that transaction to go through. If you want to go ahead and deploy this and play around with it yourself, you're more than welcome to. Okay, great.
00:08:38.832 - 00:09:23.644, Speaker A: Now we have a function called get conversion rate that we can use on our fund function to make sure we've sent enough message value in our fund. So what we can do now is all we need to do is do get conversion rate of message value needs to be greater than the minimum USD. Of course, right now our minimum USD is just in terms of 50. And we know that get conversion rate is going to return it with 18 zeros to represent the decimal places. Our minimum USD amount needs to be upgraded to ten, 250 times one e 18, or again one times ten raised to the 18th. I'm going to deploy this to a testnet just to demonstrate it, but again, you don't have to if you don't want to wait for this. So I'm going to go ahead and deploy this confirm.
00:09:23.644 - 00:10:00.716, Speaker A: And now we have this fund me contract. If I don't say anything in value and hit the fund button, we're going to get this gas estimation error failed. This is kind of a blanket error, basically saying, hey, you can go ahead and send this transaction if you want. It's highly likely that it's not going to work. And the reason that remix knows that it's probably not going to work is because it can see this require and simulate the transaction and say, hey, you didn't send enough money with this. However, even if we send some money like 5000 way, it'll still give us this error because that's not enough. Let's do the calculation right now based on what the price of ETH is, so we can actually go to data chain link.
00:10:00.716 - 00:10:35.880, Speaker A: We look and see approximately what the price is. So it looks like the price of Ethereum right now is about $3,000. And this might be different for you depending on when you do that. So if the price of Ethereum is $3,000 and our minimum is at least 50, we could do 50 divided by 30000 point 16 ETH should be approximately enough. So if we go to our Ethereum converter and we do zero point 16 we'll get how much that is in way. Let's do 0.2 just to make sure that we're going to be over the amount.
00:10:35.880 - 00:11:06.278, Speaker A: So we'll paste that in, we'll change this to way. And now if I hit the fund button instead of us getting that error popping up it's going to actually go ahead and let us do the fund function and we could confirm it and it wouldn't fail. I'm going to reject it for now just because I don't really feel like waiting for the transaction to go through. But great. We we've confirmed that our get conversion rate is working as intended. Awesome. Great workload channel our.
