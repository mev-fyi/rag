00:00:52.340 - 00:02:26.678, Speaker A: Hey Patrick, the audio. Hey everyone, and welcome to the first demo of the Chainlink Fall 2021 hackathon. I'm super excited and honored to be hosting this event. As you all start or continue on your smart contract track journey, the fact you are here means you are on the cutting edge of technology. Chainlink and smart contracts are set to revolutionize the Internet and agreements as a whole. You'll probably hear me say this a lot, but if you're a complete beginner to smart contracts, blockchain, or even just development, don't worry, there's somewhere around 200 to 300,000 solidity devs out there right now, just a rough estimate and around 13 million JavaScript developers. That's a huge difference.
00:02:26.678 - 00:03:29.480, Speaker A: And just goes to show we're all learning as we go, and new tools and techniques pop up in this industry every day, so we really are all just learning. So that being said, let's jump right into it. So if you don't already know me, my name is Zach Ayesh. I'm a developer advocate for the Chainlink protocol. A developer advocate is someone who helps engineers and anyone using or building with a technology, in this case chainlink, be successful and make sure they have an awesome developer experience. So first we're going to go over some really important concepts to give you a solid foundation for when we delve into deeper concepts later in the hackathon. Why? Well, I want to quote our good friend Plato for if your starting point is unknown and your endpoint and intermediate stages are woven together out of unknown material, there may be coherence, but knowledge is completely out of the question.
00:03:29.480 - 00:04:23.530, Speaker A: So basically, you really can't become the best smart contract developer you could be unless you have an idea of how it all works under the hood. We also kind of want to go over why you as a developer want to focus on smart contracts and what the value add is. I'm a big proponent of thinking from first principles. I think if you gain that ability and you really understand what you're working with, it kind of unlocks like a superpower in your brain that allows you to troubleshoot and understand concepts at another level. So we're going to start with blockchain and we're going to go over what is blockchain and get a good understanding of that, because that underlies all smart contracts. We'll then move into smart contracts and then dive a little bit into Ethereum and more solidity specifics and go through a demo where we make our first smart contract code. All right, so let's dive into blockchain.
00:04:23.530 - 00:05:02.870, Speaker A: What is a blockchain? A blockchain is a network of computers all around the world that store data and transactions in a shared ledger that isn't controlled by anyone. That sounds a little complicated, but essentially you can think of it as a database that has been replicated over many computers all over the world and is secured by cryptography and game theory or math. Bitcoin is popularly known as the first blockchain. You may have heard of it. Blockchain is also decentralization. You're going to hear me say this word a lot throughout this presentation. Decentralization.
00:05:02.870 - 00:05:46.920, Speaker A: So let's go walk through a simple example. Bob wants to transact with Alice. So Bob goes to his bank, his banking website, and sends Alice a transaction, the bank, for $5. Let's say the bank gets his transaction for $5. They custody those funds for a bit, and then they move those funds to Alice's account, but it's still in the bank's custody. On the other hand, Bob could use the blockchain, in which case he sends his transaction to this distributed network of computers all around the world, and no one custodies their funds. They move the transaction to Alice, and it's done in a completely decentralized way all the way through.
00:05:46.920 - 00:06:40.242, Speaker A: So what is decentralization? Let's dive into it a little deeper. I like to split up decentralization into three types, architectural, political, and logical. These were kind of made popular by a blog post by Vitalik, the creator of Ethereum, a while back. But I find these very useful in understanding the different types of decentralization. So let's look into architectural this is what most people think of when they think of decentralization. How many physical computers the system is made up of? How many of those computers can the system tolerate breaking down at a given single time and the system still work? The second is political. How many individuals or organizations ultimately control the computers that the system is made up of? And finally, logical.
00:06:40.242 - 00:07:27.762, Speaker A: This one is a little bit harder to understand. But does the system act like a single monolithic object, or is it kind of undefined in a vague swarm? An example I like to use is language like the english language. So in my head, I have the english language that I speak. And if I was to make a dictionary, I'd probably put in some slang words that I have. It would include a lot of blockchain slang, and you may have your own version of the english language with your own slang. I'm from America, maybe you're from the UK, and you speak more british english language is a great example of a logically decentralized system. One simple test is for software.
00:07:27.762 - 00:08:11.540, Speaker A: If you can cut the system in half, including both the hardware and the users, we'll both have continue to operate as fully independent units. So what benefits do we get from creating a decentralized software system? One is fault tolerance. Decentralized systems are less likely to fail accidentally because of the way they're architected. There's just so many computers running the software around the world. If any one of them is encountering bugs or goes down, it's not a big deal. Attack resistance. Decentralized systems are way more expensive to attack and destroy or even manipulate because they lack sensitive central manipulation points.
00:08:11.540 - 00:09:09.800, Speaker A: A lot of times when you're working with your bank, they have central servers that attackers can target. If it was a blockchain, there are no central servers, so it's much, much more difficult to attack. And finally, we get collusion resistance. When you have all these separate actors around the world running this software, it's much harder for participants to collude, to act in ways that benefit them at the expense of other participants, because there's just so many of them and they're all spread out. So let's go into a little bit more detail on how blockchains work. We're going to go to this awesome demo online from a great guy named Anders Brownsworth. I highly recommend going through this demo after this presentation if you feel like you want to get just mess around with it some more and get a good understanding of how blockchains work.
00:09:09.800 - 00:09:42.720, Speaker A: So let's go into some technical concepts on what a blockchain is. We're going to talk about hashing first. So, hashing is a method of cryptography that converts any form of data into a unique string of text. Any piece of data can be hashed no matter its size or type. So let's just go ahead and type something in here bigger. So I'm just going to type in my name, Zach Ayesh. You see, it created this string at the bottom.
00:09:42.720 - 00:10:26.830, Speaker A: That is the unique hash from my name, Zach Ayesh. Let's type in chainlink, we get a unique hash. In traditional hashing, regardless of the data size, type, or length, the hash that any data produces is always the same length. So you see, all of these hashes are about the same size, and every input always generates the same hash. So if we delete chain link, you see it's nine C, nine eight. I see, that's where it begins and ends with seven eight, seven, a. If we type in chain link again, we get the same hash, and just about every input will have its own unique hash.
00:10:26.830 - 00:11:10.590, Speaker A: We can really think about hashes as digital fingerprints for every piece of data, since they all have a unique hash. Now let's move on to blocks, pun intended, the building blocks of the blockchain. So we're going to clear out this field for now. What is a block? A block is essentially just a collection of data that has been signed, and miners build blocks. So how do they build blocks? Well, first they're going to need data to put into the block. They could put no data in there, but we're going to fill up this block with some data. We're just going to type in.
00:11:10.590 - 00:11:36.820, Speaker A: Bainlink is awesome. And you see, as we're building this block, this is block number one. We're generating a hash. This hash is for the entire block. So the block number, this field called the nonce, which we're about to cover, and the data. But this block is red, and red usually means something's not going right. And you may have noticed a nonce is blank.
00:11:36.820 - 00:11:58.190, Speaker A: So what we're going to do is we're going to start guessing a nonce until the hash produces a string with four zeros at the beginning. At least four zeros. So let's go ahead and go. We're going to put in one. No, nothing there. All right, let's put in two. No, we got 10.
00:11:58.190 - 00:12:19.120, Speaker A: Let's put in three. Okay, so obviously, we're not getting anything. I mean, we could do this all day. We're not getting anything. This is why we're going to use an algorithm. There's a mine button here, and it's going to find a nonce for us. The first nonce that produces a hash with at least four zeros at the beginning.
00:12:19.120 - 00:12:48.278, Speaker A: Let's click it. All right, so we got a nonce, 93,868. And it produced a hash, as you see, with four leading zeros. We're good to go. This is what miners do. They basically just guess nonsense using an algorithm really fast until they find the right hash for the block. Once they do that, they can post the block with all the data that's in it.
00:12:48.278 - 00:13:22.960, Speaker A: And that's how a blockchain is built. All right, so we know what a block is. What's a blockchain? Blockchain hint is a chain of blocks. So what we just went over is totally applicable here. It's just all these blocks are connected. So block one, we'll just put ASDF and we'll mine it and we got the right nonce. We'll put JKL semi and block two mine it.
00:13:22.960 - 00:13:58.760, Speaker A: Now I want you to notice something about the blocks. They actually point to the block before it, except for the first block, which is called the Genesis block, which would just put zeros in there. Pages is getting a little slow. Why is this important? We'll see in a second. Let's go ahead and mine a couple of more blocks. Mine four of them. All right, so we have four valid blocks.
00:13:58.760 - 00:14:39.880, Speaker A: Let's say I'm a miner and I download the blockchain and I get all four of these blocks and I say, okay, actually, you know what, I don't like that. Block two says JKL semi on it. So I'm going to change it and I'm going to put ASDF back on there. All right, well, look, it actually ruined all of the blocks that came after it that originally had a good nonce and were valid blocks. This is what makes a blockchain so hard to alter. Now the miner will have to go back and find a proper nonce for each of them. So you may be asking, okay, that doesn't seem that hard.
00:14:39.880 - 00:15:20.336, Speaker A: When you click the mine button, it's actually finding the nonce relatively quickly. Let's go to distributed. You can also think of this as decentralized guy I was saying earlier. Okay, so we have in this tab three peers, peer A, peer B and peer C, each with a copy of the blockchain. You can think of these peers as those copies of the blockchain spread out around the world. So people are running blockchain software and they have a full copy of the blockchain. So these three are somewhere separate around the world and they all have the same block.
00:15:20.336 - 00:15:41.240, Speaker A: Right now, they all have the same copy of the blockchain. But maybe pier A says, hey, like we said earlier, he doesn't like this copy of the blockchain. Right now. All the data is blank. This is what they have agreed the blockchain should have. So we're going to put some erroneous data in block two. He's going to try to mine it.
00:15:41.240 - 00:16:29.236, Speaker A: He's going to say, okay, well, now all my other blockchains are broken. All my other blocks are invalid. So he's going to mine these blocks, but he has now a different copy of the blockchain from peer B and Peer C. And guess what? Two rules better than one. These peers will communicate using something called a consensus algorithm, which is how these peers come to agreement on what the blockchain should be. And they're going to say, hey, man, peer a, you don't have the right copy of the blockchain. So that is how blockchains make sure they all agree on the state of the blockchain.
00:16:29.236 - 00:17:09.384, Speaker A: And what makes it so hard to alter, because they have to come to agreement. And if one erroneous user of the blockchain decides to alter it, it's not going to get accepted by the other peers. Finally, we'll talk about tokens a little bit. So we've just been putting random data into the blockchain block so far. But really you can think of it as the most basic form of data that goes into these blocks is transactions. So cryptocurrency is one of the most popular use cases of blockchain. We hear about that term all the time on the news.
00:17:09.384 - 00:17:57.720, Speaker A: And so usually within the blocks, the data we put in is transaction data. So we're sending some amount of value to different users. And that's really the only difference here. Now instead of just putting random data, we're putting value transfers, and that is the blockchain. This is exactly what bitcoin does. And that whole process of finding the nonce, that's called proof of work. Finally, to reward the miners who are the ones that assemble these blocks, we can put in what's called a coinbase transaction into the block, which just gives the miner reward where they can give themselves some money.
00:17:57.720 - 00:18:32.676, Speaker A: This is set in the protocol so they can't just give themselves any amount of money, but that is the Coinbase transaction. All right, great. So we just covered a lot of information on what a blockchain is. I'm going to go and look at the comments and see if we have any questions here, see what we got. Hi, from Carl. How's it going? Would love to go along with it. Don't worry.
00:18:32.676 - 00:19:20.980, Speaker A: We're going to have a demo later and I'm going to try to go along, let you guys go along with me there. What is the difference between this nonce and the ether scan nonce? Okay, so there could be a couple of nonces that are showing up on Etherscan, most likely. Let's just go on Etherscan right now, Etherscan IO. And we'll talk about Etherscan a little later. If you're not familiar with it, we'll click on a block. Let's see if it gives us the nonce. Here we have the block height mined by.
00:19:20.980 - 00:20:20.550, Speaker A: Here's the nonce. So this nonce right here, we're looking at a specific block. This nonce is the nonce that they mined that we were showing earlier. There's another nonce called account nonce that's associated with keys, but we'll go into that later. Is it likely that the nonce can be repeated in different blocks? Not very likely. It's possible, but because of the nature of hashes and how each one is unique and they change really rapidly, it isn't super likely, but it will happen statistically eventually, just not very often. How does proof of stake or pos differ? In nods.
00:20:20.550 - 00:21:01.592, Speaker A: So I'm not too versed in the details of how proof of stake works, but they're not solving. I don't think they're brute forcing the nonce. In that case, it's his own thing. And I really recommend looking into the details of proof of stake. Right now, Ethereum is proof of work. So that's where we kind of focus on why four zeros in the hash? That was just an arbitrary rule that we put in the example. In reality, the mining algorithm is a little bit more complicated than that.
00:21:01.592 - 00:21:35.910, Speaker A: The target changes based on this thing called difficulty. We don't need to go into the details. I just wanted to cover kind of a basic example that gave you an idea of how mining works. All right, great question, guys. Keep them coming. We're going to go ahead and move on to the rest of the presentation. All right, so we've talked a little bit about blockchains and how they're built.
00:21:35.910 - 00:22:14.290, Speaker A: Now let's move into this thing called smart contracts that you're going to hear a lot throughout this hackathon. Before we move on to smart contracts, let's talk a little bit about regular contracts. I think we all have a little bit of a familiarity what a contract is. It can be defined as a binding agreement between two or more persons or parties. Traditionally, we think of them as a legal document that states and explains a formal agreement between two different parties or groups. Now, usually we think of contract, we think of something that's enforceable in a court of law. So contracts have evolved over time.
00:22:14.290 - 00:23:08.432, Speaker A: Back in the day, they've been written on things like stone and paper. We've then moved on to telegraph agreements, telex machine agreements, and today we're really in the era of digital agreements, where most of our agreements are codified over the Internet. You can think of like a Netflix agreement as an example, where Netflix agrees to give you access to their streaming library for a certain amount of money a month. And currently, we're moving to a smart contract, our blockchain based agreement paradigm. And we're going to talk a little bit about what makes those so great in a second. But let's talk a little bit more about digital agreements because that's where we are today. Digital agreements really underpin almost all aspects of our daily lives.
00:23:08.432 - 00:23:52.130, Speaker A: Today, if you've ever logged into your bank, there's digital agreements that underlie your banking system. The Netflix example we just went over, insurance agreements are stored digitally. We literally tend to sign contracts. If you've ever signed a contract on docusign, and even maybe your favorite crypto exchange has agreements that underline the technology. But I want you to think about the relationship with these companies and institutions and these digital agreements. There's one common aspect, and that aspect is there's really one party enforcing and executing these agreements in determining the outcome. And these are the institutions and companies that created these agreements to begin with.
00:23:52.130 - 00:24:47.890, Speaker A: And because of this, the relationship between the users and the agreements are not what a lot of people think they are. This creates high risk and low control for the users and monopoly rent being extracted by institutions and platforms. This is kind of an unfair deal for the users. We can call these digital agreements or these traditional style agreements, brand based agreements. You may have heard Sergey talking about this yesterday in hackathon kickoff meeting. Really, we're hoping that these institutions act in good faith and the law isn't always there to help you. Suing someone and going to court can be a very costly and timely endeavor that the average person just doesn't have time to go through.
00:24:47.890 - 00:25:52.600, Speaker A: And you can't always get these institutions to change the terms and conditions written within the contracts. So these are brand based trusts. Trust my brand, trust that I'm going to continue acting in good faith just because. But if push comes to shove, if they want to, they can and have taken advantage of this position of power that they're in in regards to executing and enforcing their agreements. To dive in a little bit more specifically, we're going to talk about financial digital agreements, or we'll call it CFI, centralized financial agreements. You can think of financial agreements as anything that underpin financial products you'd use online, like logging into your bank, accessing, checking your savings account, and going to a crypto exchange, anything that deals with money. These are built off of financial digital agreements, or CFI.
00:25:52.600 - 00:26:27.440, Speaker A: These products work well in predictable market conditions. But when these conditions change, and in the ever more interconnected world that we live in, these often do change and they get a little bit more chaotic. This can change. These stable conditions can change very quickly. So I want to dive a little bit into a specific incident. You may be familiar with Robinhood. This was really big a year or two ago, and if you're not, Robinhood is a trading platform for equities like stocks.
00:26:27.440 - 00:27:29.830, Speaker A: Their digital agreement stated, or the users thought it stated, that they could buy or sell stocks anytime the market was open and they could buy them at their preferred conditions. So a bunch of users got together online all at the same time, and decided to exercise what they thought was their digital agreement to buy GameStop stock at the same time. But the reality was Robinhood's digital agreement was not what the users expected, and they blocked their service from the users and thus stopped them from buying GameStop stock when they wanted to the most. And this meant a lot to them. This is despite again, what they thought. The digital agreement said. We can consider this a brand based agreement that failed, and we can't always expect these brand based, and in this case, CFI financial digital agreements to support the average users out there.
00:27:29.830 - 00:28:36.130, Speaker A: So enter smart contracts. What is a smart contract? A smart contract is a self executing contract without the need for a third party. It is basically code. Bitcoin can be thought of actually as a very basic form of a smart contract where the code only allows the transfer of value. Smart contracts today typically refer to code written on top of a blockchain, such as Ethereum. So what smart contracts really allow is the movement from brand based agreements that we were talking about earlier, like the Robinhood digital agreement to math based digital agreements. Remember, one of the key differences between these traditional digital agreements and smart contracts is that smart contracts run on top of decentralized infrastructure.
00:28:36.130 - 00:29:27.430, Speaker A: And what would that decentralized infrastructure be? A blockchain. It's really enabling us to rethink and change the way in which we execute and enforce agreements. So the big shift is that the contract execution and enforcement is done by this decentralized infrastructure that has nothing to do with the people or entities participating in agreements. So Robinhood could put their agreement on the blockchain, and they will not have any control of how their digital agreement is executed or enforced. That'll take us into the benefits of why smart contracts are superior digital agreements. So one, security. Many blockchains have been live for years without incident, and a well designed smart contract cannot easily be changed after it's been deployed to the blockchain.
00:29:27.430 - 00:29:59.280, Speaker A: Two, reliable, guaranteed execution. Traditional agreements are executed, enforced by a party in the agreement who may not execute the terms of the contract. Immediately after the terms are event. I like to use the example of insurance. In insurance, the contract isn't immediately executed after the conditions have been met. Rather, a lengthy and timely review process is initiated. It could be months to even years before the contract is paid out.
00:29:59.280 - 00:30:41.930, Speaker A: Transparency so blockchains and smart contracts are transparent by default. Blockchains are open. Anyone can run a blockchain client and get all the data that's on there, and with that they can get the smart contract data as well. Traditional agreements can be much harder to get. They can be stored in someone's shelf somewhere in a high rise. And this can create issues such as the 2008 financial crisis, which was largely created due to opaqueness and contracts. Fourth, trust minimization.
00:30:41.930 - 00:31:47.800, Speaker A: So again, because we have this decentralization running in the middle, executing the contract code, we don't have to trust a third party even to enforce our contracts. These contracts are going to run based on the code that we put in them. And finally, efficiency. So due to everything I described earlier, these can create a more efficient and automated processes that save businesses costs. So I want you to think about how big the legal teams in a lot of these giant banks and giant corporations must be to make sure that they're writing and enforcing their contracts appropriately or in the best benefit of the company costs a lot of money. All of these are automating these processes and can save users and businesses tons of money. So just to reiterate, we've talked about brand based guarantees and how they have high counterparty risk and low transparency.
00:31:47.800 - 00:32:26.320, Speaker A: We're now talking about math based guarantees in smart contracts that have low counterparty risk and very high transparency. We're moving from band break. The move from brand based trust to math based trust is already happening and will continue to grow and continue to happen. This results in a better experience for end users, who always end up winning out into in. And this demand from the end users because they're going to say, hey, we're winning, we're getting better deals. This is way more fair for us. This is going to continue to push organizations to continue adopting these math based agreements.
00:32:26.320 - 00:33:34.454, Speaker A: So you imagine a world where, and this is a silly, simple example, but imagine a world where if Netflix went down today and I didn't have access to my streaming library, because today I need to rewatch squid game for the fifth time. If it went down, I get paid back some of the money I spent for my service that month. Immediately, it's just back in my account. That would be awesome. Okay, we're going to move into Ethereum and solidity, but I'll look through again and see if we have a couple of more questions. How much time do I need to become a proficient blockchain developer? Starting from few years back in dev experience and zero knowledge on blockchain, I would say if you already have some development experience, you're already there. There's a lot of great resources online that can teach you the blockchain side of things.
00:33:34.454 - 00:34:09.940, Speaker A: You already kind of have the ability to think like a developer. There's a lot of good resources online. My colleague Patrick has a great free camp video that's free to view on YouTube that will really take you from zero to hero on blockchain as a whole and becoming a developer. So I really recommend watching that. It's hard to say. Like, I can't give you a specific period of time. It's really up to you how much time you have to give to learning this and how much you really want to understand what you're going through.
00:34:09.940 - 00:35:00.334, Speaker A: What if two people arrived at the same time, finding the nonce and both of them had different data? So going back to the blockchain example, we're going over which one will be included in the chain. Great question. So this does happen occasionally where two people solve the block at the same time. And when that happens, we call that a temporary fork of the blockchain. And so they'll transmit their blocks throughout the blockchain and the miners are going to do their thing and start building on that block. But eventually, one of those blocks that both of those miners submitted is going to have more blocks in front of it. And the one with the longest, the most blocks in front of it will eventually become the ultimate blockchain.
00:35:00.334 - 00:35:38.992, Speaker A: That's the one that ends up winning out in the end and becomes the blockchain. We call this the longest chain, fourth choice. I don't understand what announce is. Is it something like data that was before coding in Shaw? 250 by 256. Yeah. So the nonce is just, you can think of as a number, like I was showing earlier, 123456 maybe represented in bytes, but it's just a number that the miners are guessing over and over and over and over and over again until they find the right ones. That's it.
00:35:38.992 - 00:36:05.800, Speaker A: That's what announces. Yes. Good game. For the fifth time. I know it's addicting, it's going around the world, but I had to throw in a reference there. All right, so let's go ahead and move on to Ethereum and solidity. It's kind of getting to the meat and potatoes of creating smart contracts.
00:36:05.800 - 00:36:57.640, Speaker A: So what is Ethereum? You've heard me talk about Ethereum a little bit already. Ethereum is a permissionless public blockchain, much like bitcoin is. But Ethereum has one special feature on it that bitcoin doesn't have, and that's a virtual machine or the ability to execute code. This means Ethereum has the ability to store and execute smart contracts. Essentially, you can think of Ethereum as a state machine. It moves between states and stores data based on inputs that are put into it. This allows us to do more complex transactions than just value transfer that we do in bitcoin.
00:36:57.640 - 00:38:15.896, Speaker A: Currently, Ethereum uses proof of work consensus mechanism, which is what we discussed about in that demo where the miners are going through and they're guessing this nonce, but it is moving towards proof of stake. So what are some very important terms for Ethereum components that you should know? So we have nodes, accounts, transactions and pending transactions in the memvol. A node is one of those peers that we saw in the previous slide when we were going through that blockchain. Example, a node is just someone who is running what we call the client software or the blockchain software on their computer and is one of many around the world. If we click on the node here, it'll take us to this nifty website where we can see account of certain Ethereum nodes being run right now and how much these Ethereum nodes, our client software, makes up the total composition of the blockchain. We have accounts. Accounts store data on the blockchain.
00:38:15.896 - 00:38:58.040, Speaker A: And that data could be how much cryptocurrency you're holding in your wallet. That's called an externally owned account. Or it could be a smart contract account which stores smart contract data to execute the code written in that smart contract. So let's click on accounts. Here we see on Etherscan, which is a blockchain explorer. And Etherscan allows us to look at all the various accounts and blocks being created on the Ethereum blockchain and kind of explore them and see what's going on there. And we have a list of the top accounts by the amount of Ethereum or ETH that's stored in them.
00:38:58.040 - 00:39:26.512, Speaker A: And we see the first one. Number one is one that's named wrapped ether. This is actually a smart contract. So if we click on this account address, we'll see that it's labeled contract and we'll see there's a whole bunch of transactions and we can actually look at the contract code here, that is an account. This is a contract account. And here it looks like we have one. That may not be a contract account.
00:39:26.512 - 00:40:02.242, Speaker A: This is just an externally owned account. So someone or some entity owns this account and it has ETH stored in it, a good amount of it. So there's no smart contract code stored in this account. Next we have transactions. So transactions are those things that allow us to change accounts. So if it's my account, it's my personal account and I have five ETH in it. A transaction is what lets me tell the Ethereum blockchain, hey, I have five ETH, I want to take one of those five ETH and I want to send it to Alice.
00:40:02.242 - 00:40:45.906, Speaker A: So now she has one of my ETH. So it'll subtract this transaction will subtract one ETH from my account and add one ETH to Alice's account. We can also use etherscan to look at specific transactions. So here's a list of transactions that were just created on the blockchain. And we can click on the transaction hash so we know what a hash is. Now, this is just a specific identifier for all of that data in the transaction. If we click on it, we can see the details of this transaction, we can see the hash, we can see that this transaction was a properly formatted and good transaction.
00:40:45.906 - 00:41:41.634, Speaker A: It was mined, what block it's in, what time it was mined, approximately who mined it, where the transaction was going and how much money was sent in this transaction. This seems like it was a simple transaction that did not interact with any smart contract, just transferring value. And finally, we have this example of pending transactions or the mimpul. So of course, earlier we talked about blocks and transactions go in blocks in that data field, but blocks actually have a limit. And we're going to talk about this a little bit, in a bit. But you can't just put an infinite amount of data. And so when a block is completely full, transactions sit in the mem pool where they're pending.
00:41:41.634 - 00:42:23.896, Speaker A: They're just kind of waiting for miners to pick up their transaction and add them to a block. So we mentioned that Ethereum can run smart contract code. We even saw one of those contracts in Etherscan. And so the magic on how it does all this is called the Ethereum virtual machine or the EVM. So you can think of the EVM as an application platform. All nodes running the Ethereum client software, those peers, they also run and execute the Ethereum virtual machine. This is what really enables those smart contracts on Ethereum again.
00:42:23.896 - 00:43:18.192, Speaker A: So it's a turing complete 256 bit machine, and it determines the outcome of executed contract logic. So contracts are typically programmed in a higher level language, such as solidity. There are other languages such as Viper, but solidity is by far and away one of the main languages used. But that's not actually what the EVM reads. Solidity is compiled, and the EVM actually reads bytecode, which is much more difficult for us humans to read, but the EVM understands. We also want to talk about Ether or ETH. When we were looking at ether scan earlier, you saw us transferring ether.
00:43:18.192 - 00:44:05.590, Speaker A: I mentioned that when we're transferring value on Ethereum, a lot of times it is in ETH. So ether is the native currency of the Ethereum blockchain, just like bitcoin is the native currency for the bitcoin blockchain. But ethereum, we don't call the currency ethereum, we call it ether. So ticker symbol is ETH, and it's used for transaction fees and computation. You may hear it called gas. So why do we call it gas? Well, I like to think of an analogy of driving a car from point A to point B. If we want to take our car from point A to point B, we have to fill up that car with gas and use that gas to get there.
00:44:05.590 - 00:45:09.000, Speaker A: In east, we want to move the state from point A to point B. So that might be me sending value from myself to someone else, or that might be executing a smart contract and changing some of the data stored in it. That's moving the state of the EVM from point A to point B, and it requires gas, and that gas is the ETH currency. So if ETH is the native currency of Ethereum, you may have heard about all these other currencies that are on Ethereum. These tokens, tokens do exist on Ethereum on top of ETH, and they are representation of any tradable good or service, essentially a unit of account. A token is actually really just a smart contract that means stay in state. It maintains a copy of everyone who owns any of the tokens and how many tokens are in existence.
00:45:09.000 - 00:46:13.816, Speaker A: One of the most popular token standards is the ERC 20 token standard. By far and away, most tokens on ethereum are ERC twenty s. And it's just a very specific type of contract with a very specific way on how you should code it. You can go on sites like open Zeppelin, and they have very standard templates and great explainers for ERC 20 tokens. The chain link token, which is the native currency of the Chainlink ecosystem is actually an ERC 677 token, which inherits all of the functionality of the ERC 20 token contracts and adds in a little bit of its own functionality called transfer and call. So again, let's dive a little bit into solidity, that high level language that compiles down to EVM bytecode. Again, it's one of the most popular and main languages used for creating smart contracts.
00:46:13.816 - 00:47:23.460, Speaker A: On Ethereum today, the argument for creating a new language for blockchains is that many compilers aren't optimized for storage, and storage is done a lot on blockchains. Even the simplest C plus plus programs optimized and compiled can be greater than 4 kb. Also, the EVM compilers have a very strong focus on security, which a lot of other compilers don't necessarily care as much about. So solidity is a contract oriented, high level programming language. So syntax is very similar to JavaScript or C sharp or Java if you've ever programmed with any of those languages. And it supports all those object oriented programming paradigms like inheritance. And there's lots of libraries we can use for solidity online and available today since it's so popular, like Openzepland that I mentioned earlier.
00:47:23.460 - 00:48:33.816, Speaker A: So when solidity is compiled to bytecode, it's actually not just bytecode that's generated, but something called the ABI. The ABI stands for the application binary interface. So the application binary interface is this file that allows us to easily understand what that contract is, what it's composed of, what data is in there, and more importantly, not just for us to understand what's in there, but for programs outside of the blockchain to understand what's in that contract. So maybe I want to make a program that interacts with the blockchain. I'm going to need the ABI to tell that program, hey, this is the shape of the blockchain, this is what data it takes in, and this is the data outputs, and this is where it's located on the blockchain. So again, you have bytecode and you have ABI. Bytecode is the logic that allows the EVM to, is the logic that the EVM executes.
00:48:33.816 - 00:49:24.430, Speaker A: And we have the AVI, which tells us and other programs what exactly that contract is and where it's stored, and allows us to access that contract. So let's dive a little bit more into this concept of gas. And if this is getting a little like, I know we're going into a lot of concepts, if you're new to blockchain or development. We're going to see this live in the demo, so don't worry about this. If this feels like this is a lot of info, but I just want you guys to have an understanding of the terminology I'm using for when we go into the demo. So, executing smart contracts in transactions isn't always free. On the blockchain, execution can cost gas.
00:49:24.430 - 00:50:18.090, Speaker A: So gas is the internal unit for keeping track of execution costs on the blockchain. It measures how much computation a given computational resource is going to cost all these nodes, because all these nodes are going to have to run our transaction and compute them, and that's going to cost electricity, and it's going to cost them time. So gas costs measure the computational resources consumed. So, yeah, each CPU instruction in the EVM costs gas. And every time we want to store data on the blockchain that costs gas, gas cost is always static. Doing the same thing will cost the same amount of gas. Now, right now, we're thinking about gas separate from ETH.
00:50:18.090 - 00:51:05.070, Speaker A: We're going to get there. But just remember, every computational action on the blockchain, if it's the same computational action, goes through the same steps, it's going to cost the same amount of gas. This is like saying if you're going to travel from town a to town B, that's near you every time you travel there, not including traffic, it's going to cost about the same amount of actual gas in your car. So then we have this concept of gas price. What we're talking about is gas cost. Gas cost is how much computation our transactions are giving the nodes. Gas price is how much we're willing to pay for that computation per unit gas.
00:51:05.070 - 00:52:20.780, Speaker A: So if a computation took 300,000 gas, I can say, hey, for each unit of gas you as a node or miner are going to incur. By running this transaction, I'm willing to pay one east for every unit of gas. That's gas price, how much I'm willing to pay for each unit of gas, and that's what's paid in ETH and only payable in ETH on the Ethereum blockchain. So, like I said, gas is measured for and paid for each contract execution is set by the person who is sending that transaction. We can go to gas calculators like ETH gas station to look at what the current gas prices are, and they have it conveniently set into fast, standard, and low. We're going to cover why we have these different levels of gas costs in a minute, but it's conveniently put in dollars for us. Again, they're just converting it from the amount of ETH used.
00:52:20.780 - 00:53:16.388, Speaker A: So the gas limit is the maximum amount of gas that we can fit into a block. Remember I said it earlier, we just can't fit an infinite amount of transactions in a block. There is a limit, and in ethereum, that limit is set by how much total gas can be put into that block, how much total computational exertion can be put in a single block. There is a gas limit for every block. And this is what causes transactions to wait in the mem pool and not be including the blockchain. So when a block is full, it's like, that's it, we're done. You have to wait until the next block is sent out.
00:53:16.388 - 00:54:05.600, Speaker A: And the reason blockchains have this limit is because if the blocks just fit an infinite amount of data, they would get really big, and it'd basically be impossible for anyone to actually run a blockchain node. You'd need like a supercomputer to do it, and it would kind of become a centralizing force. Yeah. So we already talked about why we have a block limit. Each block has a 15 million gas limit, which roughly equates to about 150 to 200 transactions every block. And blocks are mined roughly every 15 seconds. So most operations cost gas on the blockchain.
00:54:05.600 - 00:54:55.220, Speaker A: That includes reading to contract storage, sending ether from one account to another. Because in a way, we're just changing storage on the blockchain and execution of contract logic, and writing anything to the blockchain. Free operations include anytime we need to just read data out of the blockchain that's just free. We can just do that locally. We don't need all these nodes to also read that data for us. So we're going to go through a little analogy on full blocks and the gas price. So you can think of this bus as a block, the driver as the miner, and the people in this scenario as the transactions.
00:54:55.220 - 00:55:40.640, Speaker A: So in a normal scenario, let's say the bus is pretty empty. So everyone just kind of pays the same amount every time to get into the bus. There just isn't enough people to fill the bus, so they pay this baseline amount. But what if there's way more people waiting for that bus than there is room on that bus? So there's more transactions than there is room in the block. In this case, we're going to set up a system. We're going to say, hey, all right, we're going to let you guys bid. How badly do you want to be on this bus? Let's say it's about a 20 minutes walk for you.
00:55:40.640 - 00:55:56.890, Speaker A: You can do it. You'll get to work on time. Not a big deal. So you're willing to put $5. But everyone else, they're like, man, I have to get to work in ten minutes and I'm willing to pay $20 or $30. I need to get on that bus. Work is an hour and a half away.
00:55:56.890 - 00:56:31.910, Speaker A: The highest bidders are going to get on first. This is what happens in blocks. Whenever we want to get a transaction included, we determine that gas price and we can look at what the gas prices are using resources like ETH gas station and see in that fast section on ETH gas station. That's what the people like, those people who really want to get to work and have a long drive and willing to pay a lot of money to get on that bus. That's what those people are paying in the fast section. And there's some people that are like, hey, I'll wait for the next bus. There'll be less people.
00:56:31.910 - 00:57:02.670, Speaker A: It won't be rush hour. That's the slow gas prices. This is basically how what we call gas price auctions work on Ethereum. And this is how transactions get included in the blockchain. It's changed a little bit recently, but we don't need to go too far into the details. This is gas auctions. All right, so I know that was a ton of information.
00:57:02.670 - 00:57:35.690, Speaker A: We're going to jump into a demo now and we're going to get to coding and downloading things and all this cool stuff. Super excited for it. But let's go again. Let's look at some of the comments and questions I have here. All right. ETH gas fees are so horrendous right now. Yeah, they're getting pretty bad.
00:57:35.690 - 00:58:02.128, Speaker A: It's just because there's a lot of demand. People really want access to these smart contracts because they provide all this awesome value. So Ethereum is one of the first blockchains that enabled smart contracts and has become one of the most popular. And there's just a ton of demand for the block space. That's why the fees are so high. There are alternatives you can go to. Polygon fees are very cheap there.
00:58:02.128 - 00:58:54.300, Speaker A: All these new roll ups are coming on board where fees are cheap and newer blockchains like salana. There's a lot of options avalanche, possibly unrelated to this workshop. But maybe someone in the comment won't the ETH V two rollout help with gas fees? Or did that already happen with no real thing so, yeah, the roll ups are very new. They will most likely help out with gas fees due to how they scale and kind of spreading out gas onto all these different blockchains. But they're still very young. They're just getting released. You can look at arbitram or optimism as examples of roll ups.
00:58:54.300 - 00:59:39.092, Speaker A: So hopefully in the next year or two, we'll see some good reduction in gas fees from them. What if a person pays the entire 15 million gas fee alone? Would the block be created with only one transaction? Great question. Yeah, that's completely possible. If one transaction covered all 15 million gas and they paid a high enough price, they could get in and that could be the only transaction for that block, the miners included. All right, great. Hope you guys are doing good. Let's move on to the demo.
00:59:39.092 - 01:00:33.270, Speaker A: Let's build a smart contract, let's deploy it to Ethereum blockchain and go through all of that fun stuff. So we're going to need to get some stuff and add them to a browser. I created a fresh browser so I could go along and do this with you. I highly encourage from this point on that if you have the ability to, to open up a browser and kind of follow along, follow these steps with me and we'll go on this journey together. So we're going to first download metamask, and if you're not familiar, Metamask is a crypto wallet which stores our private keys that allow us to move money on the blockchain. Private keys are what allow us to create transactions. They're very important.
01:00:33.270 - 01:01:18.640, Speaker A: You don't want to share your private keys with anyone. This is like your master password. If anyone gets your private keys, they have the ability to move money around. Remember, the money and all the value is not stored in our crypto wallet, actually, just the keys, all the value stored as data within the blockchain that our private keys in the wallet let us create transactions to move around. All right, so let's go ahead and download metamask. So you're going to go to Metamask IO, HTTPs Metamask IO, and you'll see. Just kind of explaining.
01:01:18.640 - 01:01:52.416, Speaker A: Metamask is a very popular browser based wallet. There's a lot more crypto wallets, but this allows us to easily interact with blockchain apps, it says here. So we'll click on the download link. I'm on Chrome right now, so we're going to install Metamask for Chrome. And so it's actually an extension. We want to make sure that it's the actual real metamask that we're not getting fished or anything. So you see, it's offered by metamask IO we can go through.
01:01:52.416 - 01:02:36.968, Speaker A: Looks legit, lots of reviews. I really recommend that when downloading a wallet like metamask, you do extra diligence to make sure it's legit. People do try to fish and create fake metamasks, but yeah, we'll go ahead and add this to chrome. Click add extension. Great, we've got metamask and it's going to go ahead and pop up and we're going to follow these prompts and get started and get it all set up. So click get started and it's going to give you two options. If you have a previous wallet with a seed recovery phrase, which we'll go over in a second, you can import it, but we're going to go ahead and get set up with a brand new wallet.
01:02:36.968 - 01:02:56.020, Speaker A: So we're going to say create a wallet. Let's go ahead and help them improve metamask. That's up to you. If you're sensitive about your data, feel free to put no. And we're going to create a new password. Make this something strong. This is your wallet.
01:02:56.020 - 01:03:41.648, Speaker A: This will hold funds if you decide to interact with the main Ethereum blockchain. Make it something strong. I'm just going to go with a simple password for this demo because I'm not actually going to use this wallet for anything important or personal. So we'll go ahead and create. Once you have our wallet, they give you this awesome video on how we can secure our wallet and it's going to go through what is that secret recovery phase. So let's say you lose your wallet or your computer breaks your computer with the browser that you had your metamask wallet on breaks, you can't get that wallet anymore. And if you had money on it, that money is gone.
01:03:41.648 - 01:04:21.380, Speaker A: That would kind of suck. A secret recovery phrase allows us to recover that wallet from anywhere, at any time. It really is the master recovery phrase. It generates all those private keys we were talking about stored in metamask anytime. It's super imperative that you take your secret recovery phrase, don't share it with anyone, keep it somewhere very secure. And yeah, just make sure you're not typing it into your computer unless you absolutely have to. This is a common mistake.
01:04:21.380 - 01:04:41.270, Speaker A: It happens to all of us. It's happened to me. Back when I was first just getting into blockchain and blockchain development. I typed it in once. I thought that it wasn't stored anywhere turns out it was. And someone got access to my wallet. Not a fun experience.
01:04:41.270 - 01:05:17.904, Speaker A: So security is very important when we're custodying our own funds. So we're going to go ahead and go through here. We just kind of gave the explanation, so it's going to have us reveal our secret words again. Don't reveal this to anyone. I'm not going to use this wallet for anything, so I'm going to go ahead and show it here, but never do this in real life. All right, so we got our secret recovery phrase. I'm going to go ahead and copy and paste this.
01:05:17.904 - 01:05:58.700, Speaker A: You should write it down on a piece of paper. I don't have a pen or paper near me right now, or I would. Yeah, write this down on a piece of paper, put it somewhere secure, don't show it to anyone. Next, it's going to make sure that we've written it down and we know what it is, since this is our backup. So I'm going to put in my phrase link drawer. Betray, crack, rather save. Coil.
01:05:58.700 - 01:06:15.350, Speaker A: Piano. ICE. Snake. Loop. Federal. All right, so that matches the order of all the words I had click confirm. And we're set up.
01:06:15.350 - 01:06:41.516, Speaker A: So now our metamask wallet is there we can click. All done. And it's just giving us little updates on what's going on with metamask, how we can recover our seed phrase and we have a metamask wallet. Awesome. Let's go ahead and keep this pinned to our browser. Great. There's no money in it.
01:06:41.516 - 01:07:24.840, Speaker A: You see, it keeps track of all of our accounts. We can tell it what blockchain we want to look on then how much money we have and what our account address is. So we took this account and we went to Etherscan IO and type it in there. We can actually look at our account from Etherscan and all the transactions. Okay, so we've got that set up. Hopefully you've got yours set up, too. The next thing we're going to need to get is you notice that we have no money and we need ETH to pay for all those gas fees.
01:07:24.840 - 01:08:25.340, Speaker A: So we're going to get what's called testnet ETH. So what is a testnet? A testnet is kind of what it sounds like. It's like a clone of the main ethereum chain that's kind of free to interact with so we can test our smart contracts out before spending and risking any actual money on the main ethereum chain or the main chain on metamask. If we click on our browser extension here again, I showed you where we could switch chains. We're going to switch to the Covan testnet. Now, our metamask is pointed to that we have zero covan ETH, but to make it an accurate simulation, we still need ETH to pay for gas fees. So on a testnet we can go to something called a faucet, which just allows anyone to go get free testnet ETH, which has no actual real world value, just so we can test our smart contracts.
01:08:25.340 - 01:08:53.350, Speaker A: So we're actually going to go to a faucet. It's going to be at faucets chain link up here. Just type it in so I know going at a similar pace. Faucets chain link. And this is an awesome faucet. We can get link tokens. We'll deal with this in a future demo.
01:08:53.350 - 01:09:23.984, Speaker A: For now we're going to get ETH. We won't get any link for now. And we're going to need to give it our testnet account address. So again we can go in metamask, we just copy it right here and we're going to paste it in. We're going to complete the captcha so it knows we're not a bot and click send request. So sending 0.1 testnet ETH to our account.
01:09:23.984 - 01:09:49.610, Speaker A: It may not sound like a lot, but remember testnets are purposely made very cheap to interact with. There's no real value there, so gas prices are very cheap. This 0.1 e can take us pretty far, and if you ever need more, we can come back and request more. All right, so let's look at our wallet now. Bam, we got the 0.1 e, we're loaded up, we're ready to go.
01:09:49.610 - 01:10:30.042, Speaker A: Let's do this. All right, finally we're going to do all of our programming in something called remix Ider. An IDE stands for integrated developer environment. It's essentially just a place that allows us to easily write and deploy smart contracts on ethereum. So let's go to the remix ide. It can be found at remix ethereum.org. So remix ethereum.org
01:10:30.042 - 01:11:18.014, Speaker A: and you'll hit enter and you'll get there. And if it's your first time logging on to remix, you should see some basic little tutorials showing you the layout. You can go through that. Okay, so we're going to go ahead and we're just going to jump in and we're going to start writing a smart contract and refer back to the presentation as we need. Okay, so up here under default workspace, you're going to see a little page icon. I'm going to see if I can zoom in a bit. Okay, you're going to see this little piece of paper page icon.
01:11:18.014 - 01:11:58.860, Speaker A: We're going to click on that, that's going to create a new file for us. We're going to call this my first smart contract Sol for Dot solidity. We're going to write this contract in solidity. Okay, great. Now you see, it opens up a section in the ide, just this blank area where we can start writing our code. So the very first thing we're going to write is what's called the pragma solidity. Pragma solidity.
01:11:58.860 - 01:12:36.190, Speaker A: We'll put this little upper carrot sign 0.8.7 semicolon. Okay, what we're doing with this line is we're telling the solidity compiler, hey, we're going to be running some solidity, and this is the version of the language we're going to be writing in it. So now the solidity compiler knows what to expect next. And the semicolon, you're going to see me put a lot of semicolons. This is telling the solidity compiler, hey, we're done with that line. There's nothing more there.
01:12:36.190 - 01:13:23.150, Speaker A: So every time we need to terminate a line, we're going to put a semicolon. So we're going to type in contract, my first smart contract. We're defining the name of this contract within the code. We'll then put curly braces. Whenever we make a curly brace, that means hey, something is going to go inside this curly brace. In this case, we're going to put all the logic for our smart contract called my first smart contract, hit enter to go to the new line and it conveniently creates the closing curly brace. So all of our smart contract logic is going to go in here.
01:13:23.150 - 01:14:08.468, Speaker A: Okay, let's jump back to the presentation real quick. So we're going to talk a little bit about the structure of a smart contract, if you have previous programming experience. Again, contracts and solidity are like classes and object oriented programming. Contracts and classes can kind of be roughly split into two main sections, data and functions, or stake and functions. And again, contract execution is paid for with gas. So in our state we're going to define these things called state variables. These are the variables where we're going to store data that will permanently be there, always be on the blockchain.
01:14:08.468 - 01:14:34.560, Speaker A: The state can be changed if we allow it, and then the next part of state is the constructor. So we may want to initialize our state to certain values when we deploy it to the blockchain. That's what the constructor allows. So the two main parts are state and constructor. State variables and constructor. Those make up kind of our state. And then we have functions.
01:14:34.560 - 01:15:06.784, Speaker A: Functions are executable line of code within a contract. They allow us to do things. It could be with that state, it could really be anything. We'll look at state in a second. So let's go ahead and go back to our code and let's learn a little bit by doing this. We're going to define some states. We're going to define a un and we're going to talk about what this is.
01:15:06.784 - 01:15:38.168, Speaker A: This is a type we're going to call UN 256 and we're just going to call it number. All right, we have some states. That's it. Let's talk about what that un means. So we have basic data types in solidity. Data types say hey, we're going to store some state here. In our case, it's an unsigned integer, r u n.
01:15:38.168 - 01:16:07.524, Speaker A: Unsigned integer basically means it's an integer that is only going to be positive. And that's the only type of data that can go there. That's what we're telling the compiler. There's a bunch of other data types, basic data types. In solidity we have regular integers and unsigned integers. There are no floating point or decibel numbers in solidity. So we're going to be sticking with un.
01:16:07.524 - 01:17:03.430, Speaker A: You have your boolean, which can be a true or false value, a one or a zero, a string, which is just text. An address which is very specific to blockchain world and Ethereum world. That's an Ethereum address, kind of like our public address up here for our account. Then you have an enum, which is enumerated type that allows us to go through and just kind of define like up, down, left, right. Those would be associated with 0123 and define our own kind of enums there. So yeah, those are some basic data types and solidity. And as you see here, we've created one, we created one called number and it is a UN 256.
01:17:03.430 - 01:18:02.140, Speaker A: So we have state. Let's go ahead and make. Go in and talk about functions a little bit. See why it exited out of here for some reason. Sorry about this, just getting some slide errors here while I get this up and running. 1 second. It basically keeps exiting out of this for me.
01:18:02.140 - 01:18:34.690, Speaker A: All right, we're going to get this. It's always got to be some technical problems here. All right. Okay, so we're back. Always got to fight with the slideshow itself, never the code. All right, we talked about basic data types and solidity. Let's go ahead and write some functions.
01:18:34.690 - 01:19:25.742, Speaker A: Remember, functions are what allow us to mess with that data that we're storing on the blockchain or really do whatever we want. So we're going to make a function called type in function, change number. So with functions we can pass in what are called arguments. We define them as parameters. These are things that we pass into the function and kind of can allow us to customize what we want to put into it when we run that function. So in this case we're going to pass in an integer, so a type. We're going to define new int 256, and we're going to call it underscore.
01:19:25.742 - 01:20:11.810, Speaker A: So we know that this is an argument that goes into a function num, don't have to put underscore, but just a nifty little convention. We're going to dive into what public means here in a second and we're just going to say number. We're referring to that state variable, number equals underscore, whatever we pass into this function. No. And then we're going to put our semicolon to say the lines over. So everything, all the logic for this function again is put in the curly braces. And so the function ends where we put the closing curly brace.
01:20:11.810 - 01:21:07.920, Speaker A: This function will take any number we want and any number we put into it and change our state variable. Our next function is going to be, we're going to make one more and we're going to call it get number. This isn't going to take anything because we're just going to read a number so we don't have to pass anything in. We're going to read our state variable, called number and call this public again. We'll talk about what these mean, view returns. And since we're reading something, this function needs to give us back a value when we run it. And since we're going to read our state variable number, we're going to say, hey, this is going to return a variable of type uint 256.
01:21:07.920 - 01:21:42.920, Speaker A: If I didn't explain what 256 means, you could just put you in there, it defaults to 256. 256 means 256 bits. So our state variable here can store up to 256 bits. Okay, so we're not actually going to do anything. We're just going to say, hey, this function, all it does is it returns return number, our state variable. That's it. All right.
01:21:42.920 - 01:22:25.698, Speaker A: This is a really basic smart contract, but we got it working. Let's go ahead and get a quick win and let's just deploy it and mess around with it. Do something fun. So state two functions, change a number, get a number, we'll move on to our compiler. So this is what we'll tell it to compile our contract, you probably don't have autocompile on it, doesn't default to it, so you'll have to come here and click compile my first smart contract. It can be convenient, but sometimes annoying to turn on autocompile that way. As you're writing, the compiler will do its magic.
01:22:25.698 - 01:22:53.854, Speaker A: That's why we've seen it kind of come up with errors until I actually make my code correct and complete. So I'll keep auto compile on. We're not getting any warnings, like bad warnings. We get this kind of informational warning about our license, no big deal. Only red warnings are like compiler warnings are important. That means it's not able to compile something is wrong with our code. We're not getting any of that.
01:22:53.854 - 01:23:32.540, Speaker A: So let's go ahead and click on this Ethereum ETH symbol here and we can define where we want to deploy our smart contract. Right here in the environment section we're going to start out and we're going to deploy to the JavaScript VM. What is the JavaScript VM? That's just a local version of the blockchain all on our browser. We're running it. It's not even a testnet. It drainates accounts, gives us money, and this allows us to deploy our smart contract and not have to wait for the miners to mine that block and go through all that time consuming work. We just want to kind of quickly iterate right now.
01:23:32.540 - 01:24:05.830, Speaker A: So we'll make sure it's pointed to a JavaScript VM. For now we have our account, we can set that gas limit how much we are willing to pay. Like if our contract expends more gas, or the transaction we're going to run expends more gas than this. It's not going to let it go. And finally we're just going to make sure it's pointed to the correct contract. My first smart contract is pointing to it. Let's click that big orange button, deploy, let's get that out there and bam, that's what makes JavaScript VM so awesome.
01:24:05.830 - 01:24:36.960, Speaker A: It's there, we got it, we're working. All right, so cool. We have our git number method and our change number method, our function. If I click get number right now, what do you think it's going to show, see zero, it's showing, hey, this is a Un 256 and it's zero. That's because we didn't initialize anything. We actually never created that constructor. We'll do that in a second.
01:24:36.960 - 01:25:04.280, Speaker A: Let's look at change number. Okay, let's click change number. Wait a minute. If we look at the terminal here, it's a little small. It's giving us an error. That's because remember we said, hey, if we want to run change number we have to pass in a UN 256 and we call it underscore none. So we can pass in any UN 256 we want into this function.
01:25:04.280 - 01:25:31.620, Speaker A: We'll click on the arrow here just to get a better look. And let's pass in seven, seven, seven. All right, we're going to hit transact. And because everything is all instantaneous, it's already gone through. And now if we click get number, fingers crossed it should show seven, seven, seven. Bam. All right, so we've read a number and we've changed that state.
01:25:31.620 - 01:26:05.020, Speaker A: I see we're kind of catching up on time here. We're getting through this. We're going to have to go a little bit over, I know, because I'm running the next demo at eleven. So we can run over a little bit here. I'll make sure we get all these juicy bits in. Okay, so we've got it, we've got our contract, it's working well. Let's add a little bit more to it.
01:26:05.020 - 01:26:56.356, Speaker A: All right, so we will now add in, let's add in that constructor so we can initialize our state as something. So right after our state variable and right before our functions we're going to type in constructor. And a constructor kind of works like any other function. We can pass in some arguments into it. So when we actually deploy we have to pass in arguments. So every time we deploy we can deploy it with something different. So we'll say un 256 and we'll also just call this argument num, make our curly braces because that's where our logic is going to go.
01:26:56.356 - 01:27:25.890, Speaker A: And we're going to say our state variable number is equal to num. Again with the semicolon. All right, we're good. All right, so let's hit the X here and remove this deployment and we're going to redeploy again. Click deploy. And now look, we're getting an error because now we've defined a constructor that takes a number. So we have to in our deploy put in that number, seven, seven.
01:27:25.890 - 01:27:58.298, Speaker A: And before we can even deploy our contract this time. So we'll hit deploy. Okay, we have our git number and change number again. So this time if I hit get number, what do you think will happen? Let's go ahead and click on it. It's showing seven, seven, seven. So yeah, our constructor work. It initialized that variable.
01:27:58.298 - 01:28:12.702, Speaker A: If we want, we can now change it. One, one click change number. Transaction went through. All right, it's changed to one. One, one. Great. Now we actually kind of have the basic structure of our smart contract.
01:28:12.702 - 01:28:53.244, Speaker A: We have a state, state variable, we have our constructor, and we have two functions. Awesome. So let's talk a little bit about what some of these keywords use here. Public view. What do these mean? Those define our function visibility. So what we're saying is, hey, who do we want accessing these functions and variables? So public can be called by anyone. It could be outside the blockchain.
01:28:53.244 - 01:29:47.120, Speaker A: An externally owned account from a metamask could be another smart contract. If we make a variable and we label it public, it's going to create a function for us automatically that allows us to read that function. That's called a getter function. There's external, that means this function is designed to be externally called by other contracts and systems outside of our actual smart contract. We have internal, which means, hey, only contracts that our contract and contracts that inherit our contract can access this function. And then we have private, which only the contract that we're currently writing can use this function. It just kind of makes everything more clear and allows us Liddy to compile it to optimize our gas.
01:29:47.120 - 01:30:43.830, Speaker A: We've kind of already gone over function parameters and return values and what those do. So we'll go ahead and go over that, and we'll go over arrays in a second. So let's go ahead and go back to our remix ide and let's add in a public. Let's define our Un 256 number as public autocompile compiles. We'll go ahead and deploy this. Now it's giving me an error. Let's see what compiler error we may be getting.
01:30:43.830 - 01:31:34.700, Speaker A: I forgot to put in my constructor. So put in seven, seven, seven deploy. All right, so we deployed a new smart contract down here. If you look at it now, we have that gitter function we're talking about. So instead of writing our own git number function, we can simply just put public on our state variables and bam, we can read it. Just another quick type of function I want to go over and just to show how the true power functions. And what we can do, we're going to say function, add number, we're going to make a new number, a new function.
01:31:34.700 - 01:32:20.348, Speaker A: This is going to take in two numbers and it's just going to add them and return them. So we're going to say, okay, we're going to say one thing, it's going to take in one number. It's going to be a UN 256. We're going to call it num one, underscore num one. Then we're going to make another Un 256, underscore num two. Say this is public so anyone, any contract or account can access this and it's going to return a Un 256. Okay, then after our return we'll put our curly braces and dive into the function.
01:32:20.348 - 01:33:11.150, Speaker A: And all we're going to say here is, hey, this is going to return, we're going to add num one plus num two, semicolon. And what's this little informational warning? Hey, it's saying, look, you aren't actually changing any state here. You're not actually doing anything. You can actually call this another visibility identifier that I didn't mention called pure. And if you're just going to do some math with some numbers we pass in and doesn't even really interact with the blockchain, we just call it pure and say, hey, it's kind of like view which we have up here which says, hey, we're just returning a number. This says, hey, you're not even reading out of state. You're just doing this calculation locally on your own computer.
01:33:11.150 - 01:33:44.150, Speaker A: Great. So we'll go ahead and delete that previous deployment. We're going to deploy again. Seven, seven, seven. Deploy. My first smart contract and now we see we have our add number function there and we'll click on the arrow and you see it takes in two arguments, num one and num two. And we'll say one and we'll say num two is two and we'll hit call and look, it returned three.
01:33:44.150 - 01:34:36.802, Speaker A: Awesome. Okay, so we'll go ahead and go through back to the presentation. There's another data type called an array. For the sake of time, I'm not going to dive deep into arrays and kind of code it up. But you can see that basically an array is, an array is you can think of it as an indexer where we can store a bunch of different values in and they're stored via an index. So you can think of it like cubbies if you're back in school. Maybe it's like labeled 012345.
01:34:36.802 - 01:35:21.920, Speaker A: And within those cubbies we can store whatever we want. So in zero I want to put in the number three, and in one I want to put in the number seven, seven and so on and so forth. So we can store a bunch of numbers and they're all kind of grouped together in that array. I'll show you how you can define an array since I think it's pretty important. So you're going to type in UN 256. So we're saying, hey, in this array we're going to type in, this is going to store only Un 256. We're going to put empty brackets.
01:35:21.920 - 01:36:17.492, Speaker A: We could define it with a number in there and that would say, hey, this array can only fit so many values. But empty brackets means we can put as many numbers as, as many un 250 sixes as we want. And we'll just call this numbers array. That's how you create an array with a type. If we wanted to actually add a number to this, we can make another function, function add num. Let's see, we'll call add number to array. It's going to take a Un 256 num like we have been.
01:36:17.492 - 01:37:13.584, Speaker A: We'll make this function public, give it a return value braces and put the logic. So if you want to actually add a number to array, you have to call the array numbers array. So we're going to type in numbers array and we're going to put in push and we'll put in our parameter underscore num semicolon. And we'll return numbers links so our numbers has some properties on it. We can find the length of the array using this. It's giving us a compiler error, sorry, not numbers array. Always read those compiler errors.
01:37:13.584 - 01:37:44.436, Speaker A: They can give you some useful information. All right, great. So we'll deploy again. Can't forget the constructor deploy and. All right, so we have our add num to array. We'll just add num seven seven seven to that array. Click Add num to array and boom.
01:37:44.436 - 01:38:40.682, Speaker A: So we've added seven seven seven to that array. If we wanted to read that number, all you would have to do is say, instead of, we could return, you can access your array by going to numbers array and putting in zero for the first element. And that's where our seven seven seven is number we put in because that's the first thing we put in that array. So it's going to look at index zero, pull out that seven seven seven and access it. So that's an array I'll actually go back and keep it at what we had it. What errors are getting it? Oh, yeah. So we got to parse it there.
01:38:40.682 - 01:39:21.560, Speaker A: Okay, cool. Now, the last thing in the demo is I just want to take this smart contract and actually deploy it to a testnet so we can see what actually interacting with a smart contract in the real world would kind of look like. So we're now going to switch the environment to injected web3. And what this will do is it'll tell remix. Hey, let's look at Metamask. Metamask is actually going to inject all its information into our remix ide and it's going to communicate to the blockchain through our metamask. So we'll click injected web3.
01:39:21.560 - 01:39:55.358, Speaker A: We're going to get a prompt from Metamask like, hey, this website is trying to connect to me. Do you approve it and what account? So we're going to say, hey, yeah, we're connecting with remix. Double check all of this and hit next. It just wants to view the addresses of our accounts. So we'll say, that's fine, we'll connect, and it's connected to my metamask. And you'll see here it's showing, hey, Metamask is set to Covan and it's reading that. And indeed our metamask is set to Covan.
01:39:55.358 - 01:40:28.414, Speaker A: So now we can do everything that we've been doing, but now we can do it and deploy it to a blockchain testnet. And this will simulate exactly what it would be like to just put it on the Ethereum main chain. So again, we have all of our contract code ready to go put in our constructor argument. Not going to forget this time. And you see, it's pointing to our account. Now we want to make sure it's pointed to the right account. So our account one looks like it's the same address and we have 0.1
01:40:28.414 - 01:41:00.866, Speaker A: ETH in there. Great, we're going to click deploy now. Metamask is going to come up again. Remember that whole gas thing we were talking about? Well, now that we're actually interacting with the blockchain, we have to spend some gas deploying a smart contract that stores data on the blockchain, and it costs money and costs computational resources for the miners. Metamask is really good at estimating the gas fees. Once you get a little bit more advanced, you can start editing the settings here. But we're just going to go with the default.
01:41:00.866 - 01:41:45.590, Speaker A: This is a testnet. We're going to hit confirm. So this is going to say, hey, actually, before we hit confirm, I just want to go over this is going to say, hey, we're going to spend this much ETH estimated to execute this gas and you can go in and look at what the gas actual gas use and what the gas price is. We'll click confirm. And testnets are still very fast, not quite as fast as our local JavaScript VM, but it's deployed our smart contract to the COVID testnet just like our local. We have all the same functions. Let's try to read number.
01:41:45.590 - 01:42:04.640, Speaker A: Right, so we deployed it. We set seven seven seven to the constructor. It runs seven seven seven. And you'll notice metamask didn't pop up. That didn't cost any gas. We're just reading the state of this smart contract from remix from the blockchain. So that costs us nothing.
01:42:04.640 - 01:42:33.030, Speaker A: Let's do something that may cost us some money. Let's change our number. So we'll go to change number and we'll put one, one one in. We'll click change number. And now Metamask is popping up. This is going to incur computational costs on the nodes and the miners. That means that computational costs are going to be measured in gas and we're going to pay that gas in ETH.
01:42:33.030 - 01:43:04.910, Speaker A: Again, metamask is kind of estimating all this for us. This is a testnet. We'll go with it and we'll hit confirm. All right, see, our transaction went through, so now our number says one, one, one. If we go to our metamask and we look, we actually have less ETH than we started with because we've been spending our ETH on those gas fees. So, yeah, on the main chain, you need to be careful with your gas fees. They can drain very fast.
01:43:04.910 - 01:43:43.180, Speaker A: Like a comment said earlier, demand on the Ethereum main chain is very high and the gas costs can get quite expensive sometimes. If we wanted to do this on the Ethereum mainnet, it's as simple as just switching our metamask now to Ethereum mainnet. Bam, we're done. Now we can do all of this and we can do it with real money. I'm not going to do this here. I'm not exactly keen on spending actual money at this moment, but that's how easy it is. And with that, we are done with our demo.
01:43:43.180 - 01:44:28.682, Speaker A: That was fun. So a quick summary of what we went over in this demo, in this presentation, we kind of went over a summary we've built up from the fundamentals of blockchains and smart contracts to understanding how Ethereum and solidity work. And we even made our first smart contract. Awesome. Now you have everything you need in your toolbox to make amazing math based agreements, not brand based. Well, almost. You may have noticed something was missing in this demo, and that'll be in our next demo and section here in about 15 minutes.
01:44:28.682 - 01:45:16.298, Speaker A: Introduction to chain link this is the chain link hackathon. And so we're going to see how important that is. And if anything didn't make sense to you or you need to review anything, please do. Please go out and Google, go on our discord. If you want to have a discussion with other people, our engineers out there, go to stack overflow and ask if you have any specific technical questions. And something we say in our team, and that's been told to me, and I have to remind myself, is be aggressively curious and aggressively resourceful. Go out there, don't be afraid to ask questions.
01:45:16.298 - 01:46:09.130, Speaker A: Don't be afraid to sound silly. The fundamentals are super important. Even I forget the fundamentals sometimes and I have to go back and remind myself, so go out there, don't be afraid. I really want to make sure you understand what's going on here. And with that, thank you so much for following this demo, for building your first smart contract. Let's go and look at a couple of questions here before we take a short break for the next demo. Yeah, I see some people are having some trouble.
01:46:09.130 - 01:46:54.340, Speaker A: They're getting some compiler errors again. Feel free. This video is going to go back up on YouTube so you can kind of watch it at your own pace and follow along and just make know all the syntax is there. So what's the difference between view and pure Ilya as this? Why didn't we specify them to function that returns nothing? Great question. View functions tell the solidity compiler, hey, we're going to actually go into the blockchain state and we're going to pull a value out and return it. We're not going to do anything else, we're just going to pull that value out. Pure says, hey, we're not even going to pull values from the blockchain state.
01:46:54.340 - 01:47:50.126, Speaker A: We're just going to take two numbers you want, we're going to do a calculation, we're going to return it to you, only you or the user running this function. So that's what pure does. Yeah, I see a bunch of people had looking at the SBDX warning, it's just a license line, not such a big deal. It's something you can ignore. And I see Constantino here is killing it with the awesome replies. Thank you for helping people out. Okay, well, I think we're good.
01:47:50.126 - 01:48:18.580, Speaker A: I see they've referred to the docs. I didn't mention that. The chain link docs are an amazing place to go to find resources, and we've just got the link posted there. So thank you so much. We're going to take a quick break, come back, and we're going to go through chainlink and how chainlink is really going to take these smart contracts and supercharge them in creating hybrid smart contracts. So see you soon. Thank you.
