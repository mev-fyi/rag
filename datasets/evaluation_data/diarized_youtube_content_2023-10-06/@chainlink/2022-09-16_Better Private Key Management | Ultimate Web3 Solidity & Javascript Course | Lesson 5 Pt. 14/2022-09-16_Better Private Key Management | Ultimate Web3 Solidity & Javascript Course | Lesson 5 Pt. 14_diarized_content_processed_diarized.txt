00:00:10.730 - 00:01:02.350, Speaker A: Now, if you're really paranoid, there's something else you can actually do when running your scripts and running your commands. Let's say you didn't even want to put your private key into a env file because you were nervous that you would accidentally push it up or something. What you can do is you can add your private key and your RP URL as environment variables right in the command line. So before you run node deploy js, what you can do, you can say RpC URL equals paste your Rpc URL, and then you can say private key equals and then paste your private key and then do node deploy Js. Setting these right before we run our script is the exact same as if we had set them in a env here. And if we hit run, we see the exact same output, which means that our RPC URL and our private key went through successfully. This way for key management is fine, but all right, doing this is going to be much better.
00:01:02.350 - 00:01:51.998, Speaker A: But it still makes me a little bit nervous in our development environments with our fake private keys, having our code in a env file like this is okay, right? Because we don't really care if this key gets hacked, like nobody's using it. But when we move to a more professional setup, this can be a little bit scary. So how can we make this even more secure? Well, what we can do is actually we can encrypt our private key and store our encrypted key locally. That way, if for some reason somebody does get into our account, our private key isn't just sitting around in plain text, it's encrypted, and you'll need to know a password that only you know to get into it. So how do we add that? Well, first we're going to create a new file called Encrypt key js. And this is some code that we're going to use to actually encrypt a key. And we'll store that locally instead of our private key in plain text.
00:01:51.998 - 00:02:17.442, Speaker A: This will make us even more secure so that we don't have our private key just hanging around in plain text here. So let's go ahead and build this script to encrypt our private key. So we're going to use the exact same setup as we did for our deploy script. So we're going to do an async function main, and then down here I'm just going to go ahead and copy from deploy js. We're going to use this exact same setup and paste it. Okay, great. We're going to be using ethers js in our env again.
00:02:17.442 - 00:03:14.410, Speaker A: So we're going to add these in const ethers equals require ethers const fs equals require fs extra and then require env config. All right, so right now in our env, we do have this private key. And again, if you don't want to have the private key in there, what you can just do is you can do private key equals and then node whatever script you want to run. So we're going to set this script up to run our encrypt key one time, and then we can remove our private key from anywhere in our workspace so that it's no longer in plain text anywhere. So what we want to do is we want to say Const wallet, and we're going to create a new wallet, but a little bit differently. We are going to say it equals new ethers wallet process env private key. So we do need our private key to stick in here.
00:03:14.410 - 00:03:56.162, Speaker A: But then once we create this wallet, we're going to say const encrypted JSon key equals await ethers encrypt. This encrypt function is going to return an encrypted JSON key that we can store locally and that we can only decrypt it with the password. And it takes two parameters. It takes a private key password and a private key. So in our env, just for right now, we're going to create a private key password, and I'm going to say it's password. But obviously this is a terrible password and you should never use password as your password. But for now, we're just going to leave it as password since I'm encrypting this fake key anyways.
00:03:56.162 - 00:04:35.010, Speaker A: So we're going to encrypt it by passing the password process env private key password, and we're also going to pass the private key. It's not going to be ethers, it's going to be wallet encrypt. We're also going to pass it process env private key. Now let's go ahead and run this right now, and then we'll console log out this encrypted JSon key and see what happens when we run this. So to run this, we're going to do node encrypt key js and hit enter, and we'll see what happens when we console log it out. This Json object here is what our key looks like encrypted. So it's got the address.
00:04:35.010 - 00:05:15.954, Speaker A: This Id version. All this other stuff, and all this other stuff is the encrypted version of this key. If somebody gets into our account and they see this, they'll have to know the password to decrypt this private key. They'll need to know the password to decrypt this JSOn object back into a private key. So what we're going to do, now that we've encrypted it, we're going to save it. So we'll do fs write filesync, we're going to pass it to encryptedkey JSOn comma encrypted JSOn key. So we're saving it to a new file called encrypted Key JSON, and we're passing it this encrypted key that we just made.
00:05:15.954 - 00:06:03.442, Speaker A: So if we open up our file explorer and we run this command, you'll see we get a new file called encrypted Key JSOn and it's this encrypted key here, which is awesome. So now what we want to do in our git ignore is add encrypted key JSon so that we don't accidentally push this up to GitHub. And now we have an encrypted key and we can go to our private key and delete this from our env file. We can also delete our private key password from our EMV file so that the password isn't just hanging around in plain text. Now that we have an encrypted key back in our deploy script, we can change the way that we actually get a wallet. So at the top we're getting our wallet just by passing in the private key like this. We're not going to do that.
00:06:03.442 - 00:07:11.190, Speaker A: We're going to use our encrypted key that we just created. So what we're going to do is we're going to say const encrypted JSON equals fs read filesync encryptedkey JSOn comma utf eight. This fs read filesync is just going to read from our encrypted key JSOn into this encrypted JSON variable here. Next, we're going to create a wallet from this encrypted key. We're going to say let wallet equals new ethers wallet from encrypted JSOn sync. And all these commands that we're working with ethers, we can of course find them in the documentation from encrypted JSON sync takes the encrypted JSON and a password and returns a wallet object. So we're going to pass it that encrypted JSON that we just read, and then we're going to pass it our password, which we're going to do process env private key password.
00:07:11.190 - 00:07:52.226, Speaker A: And then finally the reason I use let here is because now we have to connect this wallet back to our provider. If you look here, we're not connecting our wallet with the provider. When we make our transactions with our contract factory, we need to make sure the wallet knows about the provider here. So we can just say wallet equals await wallet connect provider. And now if we run our deploy JS with our private key password as an environment variable, it should still deploy so we can do private key password equals password, which yes, we know is terrible, but that's what we're using for now. Node deploy JS, we should get the same output we've been seeing this whole time. And we do.
00:07:52.226 - 00:08:30.426, Speaker A: We're able to no longer have our private key in our env file, not in plain text anymore. It's in this encrypted key, so that just in case somebody hacks our computer, they still won't be able to send any transactions unless they know the password. This is awesome. One more thing to note, if you type history, if somebody got into your computer, a hacker could actually see private key password equals password in your batch history. If you run history C, you actually will clear your history. Now, if I type history, I can just see that the most recent command I wrote was history. This is really just some of the bare minimum for encryption and keeping your key safe.
00:08:30.426 - 00:09:06.294, Speaker A: And it might seem ridiculous that somebody might be able to hack your computer and read your encrypted private keys and everything. But as your projects get bigger and bigger, it is really important to know about private key security and private key safety. And for this course, we're really just giving you the bare minimum here and showing you how to encrypt keys and how to be a little bit safer here. Now for the rest of this course, we are going to be just using this syntax with our private key in a enview file. The reason why we're doing it like this for the rest of the course is it is a little bit easier. I'm really hoping hardhat adds some additional features to make private key encryption much safer and also easier to use in the future. And they probably will.
00:09:06.294 - 00:09:51.670, Speaker A: And the other reason that we're okay to do this here is because you've solemnly sworn that you're not going to use an account that has any real money in it. For the duration of this course, you're only going to use private keys that have test on Ethereum or our fake private keys like this one that we got from ganache. In fact, just to really hone this in in the smart contract kit, full blockchain solidity course Js GitHub repo in the discussions tab, if you go to announcements, I've created one called the env pledge because recently I've seen too many people follow a tutorial that doesn't tell them about the security risks of doing this. And I've made this env pledge. I would love everyone to jump on and read, and if you agree at the bottom, leave a comment saying I will be safe. I will be safe. Make sure you read and you understand what's going on in here.
00:09:51.670 - 00:10:51.178, Speaker A: And I'm not doing this to scare you because again, at the end of the day, if you use a metamask that only has testnet funds for the duration of this course, you will never have to be worried because if your key gets compromised, it's just testnet, so who cares? This is if you're using a metamask or you're working with a metamask that has real funds. So I'm going to read out the pledge because it is really important you understand this when you're working with real funds. And if you're like, hey, I'm not working with real funds, I don't care, great, move past this, whatever. But when you do work with real funds, when you do decide, hey, I actually want to deploy this to a real network now I need real money to do that. Come back to this pledge, scroll to the bottom, say I will be safe, and make sure you read and you understand this. Okay? So the pledge is, I solemnly swear that I will never place a private key or secret phrase or mnemonic in a env file that is associated with any real funds. Basically, you basically never have your private key or mnemonic phrase in plain text anywhere.
00:10:51.178 - 00:11:40.746, Speaker A: You'll only place private keys in a env file that only have testnet eth link or other cryptocurrencies. Because again, if your private key has only testnet funds, then that's great, I don't care. We are aware that if we forget a git ignore and we push our key phrase to GitHub, even for a split second, or even show our key phrase on the Internet, wherever it may be for a split second, it should be considered compromised and you should remove all funds immediately. So even if you deploy your private key to a website and then immediately delete your website and think, oh, nobody probably got to it, you should consider that private key compromised and you should remove all your funds. And again, this is just for real funds. If your private key with only testnet funds gets compromised, well, who cares? I do that all the time. You've been seeing me do that all the time because it only has testnet funds in it.
00:11:40.746 - 00:12:27.094, Speaker A: If at the end of this course you want to steal all of my testnet funds, I mean, have a blast. It would be annoying to me at worst. If I am unsure if my account has real funds in it, I will assume it has real funds in it. So if you don't know if it has real funds, assume it has real funds and you will not use it for developing purposes. And then finally, I am aware that even if I hit add account on my metamask or other ETH wallet, I will get a new private key, but it will share the same secret phraseneneumonic of all the other accounts generated in the metamask or other ETH wallet. So if I'm in my metamask here and I hit create account, I will get a new private key with the new account. However, all of these accounts that I've created with this Create account button have the exact same mnemonic phrase or secret phrase.
00:12:27.094 - 00:12:54.798, Speaker A: If I import an account with a private key, it's going to have a different mnemonic phrase, but all of the ones that I generate inside that wallet are all going to have the same phrase. Okay, great. Hopefully that'll make sense. I have some pledge additions here. For this course, I will only use funds associated with a brand new, never before used metamask or other eth wallet. Again, this is not to scare you. If you just work with a brand new metamask, you don't have to worry about any of this and just refer back to this when you start looking at real money and real private keys.
00:12:54.798 - 00:13:33.550, Speaker A: I'm aware that my account associated with my private key is the same on testnets that it is on mainnets. So like I was showing you, my private key on rinkby is going to be the same as my private key on a main net. If I must use a private key associated with real funds in the future, until I am 100% sure what I am doing, I will always either use one of the encrypted methods that Patrick showed, use some better encryption stuff that I didn't show, or use the command line way to pass private keys and then delete the command line history right after. If I'm never actually deploying anything to mainnet myself or work with a private key with real funds, I do not need to be concerned. Take a look at this. Read this. Internalize it.
00:13:33.550 - 00:13:48.510, Speaker A: This should make you confident. Now, again, I'm not saying this to scare you. I'm saying this to instill confidence in you that these are some of the things that we want to think about. Okay, great. In here, I will be safe. Boom. I will be safe.
00:13:48.510 - 00:14:08.280, Speaker A: And if you want to copy paste this on Twitter, put this in a huge tweet thread, go for it. The more people who know about this, the more people who understand the security risks of their env files and their private keys, the better. So thank you for listening to this. I know I definitely belabored the point, but it is really important. Let's continue with the course.
