00:00:52.500 - 00:01:18.656, Speaker A: You. Hey, everyone. Welcome back. Long time no see. All right, well, thanks for participating in the last one. If you did, and if you're new here, welcome to the demos. In the last demo, we kind of built up to the basics of blockchain and smart contracts included our first one, but we didn't actually use is the technology.
00:01:18.656 - 00:01:55.590, Speaker A: Just hackathon is all based around Chainlink. So let's dive right into that introduction to chainlink. If you missed it in the last one, I'm Zach Ayesh. I'm developer advocate for the Chainlink protocol. All right, so today we're going to go through a couple of topics. We're going to talk about the Oracle problem and how Chainlink solves it, and then we're going to go over a couple of Chainlink products, our service offerings. We have the Chainlink data feeds.
00:01:55.590 - 00:03:08.850, Speaker A: We're going to be automating smart contracts with keepers, accessing any API we want with Chainlink, and then obtaining a verifiably random number using the Chainlink VRF. So let's jump right into it. The Oracle problem and chainlink. Okay, so after the last demo, we talked about smart contract math based agreements are awesome compared to our traditional brand based digital agreements. But it turns out that these smart contracts aren't quite that smart, at least on their own. And their biggest limitation is smart contracts are not able to connect to external data or the outside world outside the blockchain. So why can't a blockchain just connect to an API outside data source? Well, remember in the timo before, we were talking about how blockchains, they all have this copy of all the blocks in the blockchain and they have to come to agreement on what the real blockchain is.
00:03:08.850 - 00:03:40.446, Speaker A: This is called consensus. And because of this consensus and the programmability of it all, they have to be deterministic. So this ensures that everyone's able to come to agreement on what the true blockchain is. And if we made an API call, then each node could get different results. So let's look at this image real quick. On the left side, we have the good, nice deterministic blockchain as we know today. Maybe it's just going to calculate a value, one plus one.
00:03:40.446 - 00:04:26.502, Speaker A: All the computers know how to calculate one plus one. They all calculate them the same, they can easily reach agreement. On the right side, we have this nondeterministic blockchain that is connecting to the outside world and by blockchain node. These are the nodes, these are the peers, these are the people running the blockchain software, this peer over here, they're trying to call an API and maybe it's an API that's like the weather in Charlote. That's where I live. And so it gets 76 degrees Fahrenheit. This node calls the same API and gets 75 degrees Fahrenheit.
00:04:26.502 - 00:04:51.934, Speaker A: Just a second later, maybe the reading on the server changed. Well, now they can't reach consensus. This is why we can't just connect a blockchain to APIs or outside data sources. It would break the consensus of the chain. We can call this the smart contract connectivity problem. Smart contracts. So blockchains can't connect to outside data resources.
00:04:51.934 - 00:05:53.950, Speaker A: Smart contracts can't connect to outside data resources. And now we're limited. So this limits smart contract functionality really to only things that can be done within the blockchain, which kind of boils down to the moving of tokens, performing payments are just kind of representing ownership of things like NFT. But another way we can call this problem is the oracle problem. So what is an, you know, in ancient times the Greeks, an oracle was someone who could kind of tell the future and give you an answer based on any question that you wanted. They kind of knew the truth of the world. And in the blockchain sense, an oracle is an entity or software that knows the truth about the outside world and knows what the temperature is outside of the blockchain in Charlote, North Carolina.
00:05:53.950 - 00:06:46.190, Speaker A: So any device that interacts with off chain world to provide data or connectivity to smart contracts, that's what it is. In blockchain learning, they can report the results of any outside data or computation on chain. So blockchains can keep their deterministic nature. They're a separate service that lives on top of the blockchain, a middleware, so to say. So now, instead of having the blockchain connect to those APIs, as we saw in the last slide, we can connect to an oracle which will handle connecting to all those outside data sources. So great, we have a problem to the solution to the smart contract connectivity problem, also known as the oracle problem. We'll create a blockchain oracle.
00:06:46.190 - 00:07:35.674, Speaker A: But the naive way to do this is just have a single oracle that reports all of our truths. And this creates a. If we just make a centralized single oracle node, this creates a centralized point of failure. And remember, when talking about these blockchains, what gave them all their and smart contracts, what gave them all their awesome properties, was the fact that this was like a decentralized system. So we have this highly secure blockchain, decentralized, but we're triggering events. We're getting data of events to trigger events on the blockchain from a single node, a single point of failure. And that reduces the whole security properties of the blockchain down to that single node.
00:07:35.674 - 00:08:41.360, Speaker A: That's what we're relying on then, to end security of a system is no better than its weakest link, pun intended, in this case, the oracle. So we have this super secure blockchain no one can hack, and this very hackable central node. What do we do now? We create a decentralized oracle network, or a bunch of decentralized oracle networks. This is Chainlink. Chainlink is designed to be a modular, decentralized oracle network for getting secure and reliable data on chain and for triggering off chain events based on on chain conditions. So it can communicate both ways between the on chain and off chain world. And because it's decentralized, it preserves all those awesome properties that we love about blockchains and smart contracts.
00:08:41.360 - 00:09:46.370, Speaker A: So we bring in data to trigger external computation in a decentralized way. By doing this, we solve this problem by extending the decentralization and trust minimization that we found on blockchains so we could build a chain link network with as many or few nodes as we need to make sure we have good guarantees on our outside data. This is what really gives us the full end to end reliability. That was the promise of smart contracts that we really wanted to build to begin with and does it all in a decentralized way. So let's look at this example real quick. We can make a decentralized oracle network, and this would be comprised of chain nodes, just like blockchains are comprised of blockchain nodes, and they're all retrieving the price of a certain asset. We'll say like Tesla stock, for instance, and they all have to get that price.
00:09:46.370 - 00:10:43.794, Speaker A: And then they have their own kind of consensus algorithm, just like blockchains do, where they come to agreement on what that actual price is, then post all their observations and their final agreement that they came to onto the blockchain so we can write some awesome smart contracts around that. So now, by combining on chain contract code with off chain resources and oracles, we have what we can call a hybrid smart contract, an even more powerful version of those awesome map based agreements that we've been talking about this whole hackathon. These are smart contracts that rely on existing on chain code. Combine it with any critical off chain computations. We've kind of just thought of smart contracts as just code up until now. Now we're kind of redefining what they are. Smart contracts aren't just code that lives on blockchain.
00:10:43.794 - 00:11:28.198, Speaker A: Smart contracts is code that lives on the blockchain and anything else we can get access to in the outside world. These hybrid smart contracts truly are supercharged versions of smart contracts. And they're already starting to redefine the smart contract industry as a whole. And they continue to go on and continue to redefine how we are doing our traditional agreements. So important thing about Chainlink is it's blockchain agnostic because it's this middleware. Because we have this oracle network that sits on top of the blockchain. It can actually connect to any blockchain that needs data.
00:11:28.198 - 00:12:27.654, Speaker A: And today there's a lot more blockchains that run smart contracts than just Ethereum. We have, of course, Ethereum. There's polygon, Solana, Xdai, you have Roostock built on top of bitcoin, all kinds of blockchains. And Chainlink can interoperate with all of them to make sure that they get the most reliable off chain data that they can have. So I'm going to start talking about the Chainlink data feeds a little bit. This is a particular service that we can make out of Chainlink, Oracle networks. So we talked about, in the last demo, we talked about the flaws of traditional agreements, went through a very specific example, Robin Hood, and showed how math based agreements can solve all of this.
00:12:27.654 - 00:13:26.470, Speaker A: Well, in know I talked about CFI or centralized finance, which were these financial digital agreements kind of traditional that you would get when you log on to your bank or go to your favorite crypto exchange and do anything financial in today's a lot of the most popular applications today. Well, DeFi is totally redefining that market. DeFi, unlike CFI, centralized finance, is decentralized finance. And it's taking all of these traditional financial, digital agreements and making them decentralized financial, putting them on the blockchain. This provides those also properties like transparency. So now we can look into how these DeFi smart contracts are written and see the exact code that's written in that contract gives you control of your assets. No bank or exchange has to custody your funds.
00:13:26.470 - 00:14:34.590, Speaker A: And these DeFi apps are even giving some awesome yield compared to traditional savings account and my savings account, I think I get something like 0.1.1% interest and certain DFI apps. They're getting 5%, 6%, 7% interest in part because of all these awesome efficiencies that we're creating. So we're getting all these awesome advantages of DeFi and redefining how we're looking at financing decentralized financial digital agreements and kind of replacing. But the thing is, a lot of these DeFi contracts, financial contracts, they need to know price data. They need to know what the price of certain assets are. So if you wanted to build an exchange on chain, this exchange would have to know what the price of all the assets are that exist outside of the chain.
00:14:34.590 - 00:15:34.418, Speaker A: Ether exists on chain, but even the Ethereum blockchain doesn't know what the price of ether is in dollars. Dollars is this concept that's kind of outside the blockchain. And so to do this, we can create a chain link network, a decentralized oracle network, or don, that will grab the price data of all of these assets that we want to represent on chain, and it'll pull them in in that trustful, decentralized way. And so you can kind of look at this diagram. And we have all these centralized, traditional CFI exchanges here. Maybe these are all crypto exchanges, and you have data providers that aggregate this data. And then you have our Chainlink decentralized Oracle network, which connects to these data providers and maybe even some of the exchanges themselves.
00:15:34.418 - 00:16:58.468, Speaker A: And they themselves, each node, they'll aggregate that data to achieve what they think is the true price of that asset, what they calculate is the true price of that asset. Then they'll share among each other and come to consensus and aggregate their own answers to come to a final guaranteed truth about what the price of that asset is. And they'll post it on chain here into what we call a reference contract that any kind of other application that's been on the blockchain can use. Now, we can build these awesome defi smart contracts and primitives that take advantage of this price data, and it really lets us take it to the next level. So why are we harping on why we need to use decentralized oracle networks or doms for these oracle functions? Well, there's already been plenty of attacks on smart contracts in the blockchain space that targeted specifically centralized oracles. Like we said earlier, a centralized oracle makes a pretty easy attack target. And these attacks have lost users and creators tons of money and reputation.
00:16:58.468 - 00:17:51.188, Speaker A: That's not cool in crypto since everything is open. If you have something that can be exploited and money will go into it. And in crypto, money flows fast. Someone will find an exploit and try to take that money. So we can actually go to data chain link and we can view these decentralized Oracle networks live, posting data for a whole bunch of different data here. You know, we have cryptocurrency data sets, we have a bunch of different chains we can go look at right now we're on the ethereum main net, so let's look at ETH USD. All right, the trusted answer.
00:17:51.188 - 00:18:34.320, Speaker A: This is the answer that all the nodes most recently came to agreement on. It's saying $4,036 right now. And these are all the nodes that are working to get this data. There's a lot of them, and they're all doing their own aggregation, like I mentioned earlier, to make sure that they post the best possible answer. Because we can see each answer, you can look at each node and see the individual answer that they posted. So if a node starts acting a little funky and they want to post 400 instead of 4000, that's all going to be visible. All these nodes have their reputation at stake as node operators.
00:18:34.320 - 00:19:17.064, Speaker A: We can scroll down, we can see the price history, and we can look at the individual nodes and what they've been posting, their ether scan addresses, all this awesome information. And we can even see the users look at how many defi apps are using this data to do cool stuff. And they actually sponsor some of this data. They're getting a lot of value out of this. So they help pay and secure all of this data being posted on chain. So yeah, that was data feeds. We just went over that.
00:19:17.064 - 00:20:14.620, Speaker A: Each node aggregates their own data and then that data is aggregated within the nodes themselves to get the final answer. So let's just go ahead and jump into a demo and see what programming with these data feeds is like live. So again, you're going to see this a lot. What do I have installed? What do I have? We're just going to need a metamask wallet, we're going to need some testnet ETH, and we're going to go ahead and start at the chain link docs this time. So from the last demo, I already have some testnet ETH in my wallet, so we're good to go. If you need a refresher, please feel free to watch the last demo I did to see how we got all that set up. Okay, so let's go ahead and go to the chainlink docs.
00:20:14.620 - 00:20:51.700, Speaker A: Okay, so this is the official chainlink documentation. It's all open source, a really great resource if you ever want to do anything, Chainlink and really smart contracts in general. But we're just going to go right now and we're going to look, we have an introduction section on the left nav bar and we have a section called using data feeds. So we click on introduction to data feeds. It's going to give us a quick explanation of how data feeds work. We're going to go ahead for this demo and we're going to go ahead and go to get the latest price EVM. So we're going to do this all on Ethereum for now.
00:20:51.700 - 00:21:25.470, Speaker A: If you want non EVM chains like Solana, they're being added. So right now we have another one for Solana. We're going to focus on EVM Ethereum for now. So it tells us where these data feeds are available. And look at this. It gives us some completed demo code that we can use to get the latest price. We're going to use the data feed to get the latest price of ETH USD and use it in our smart contract.
00:21:25.470 - 00:22:01.416, Speaker A: And if we keep scrolling you'll see a button deploy this contract with remix. Let's go ahead and press that. Okay. All right, we're back in remix and it automatically loaded up that code for us. Let's go ahead and zoom in a bit. Okay, cool. Okay, so here we have that smart contract and just like in the previous demo you'll see a lot of the same terms.
00:22:01.416 - 00:22:37.920, Speaker A: The pragma, something new here is the import statement. This means it's pulling code in from somewhere else that we can use in our smart contract. In this case it's pulling in a file called aggregator V three interface. Sol this allows us to interact with price or data feeds in our smart contract. So again we define the contract name. We have our state variable calling it price feed. It's a custom type called aggregator v three interface.
00:22:37.920 - 00:23:29.092, Speaker A: It's taking that from this import statement. We have our constructor which initializes our state and this time it's taking that aggregated v three interface and pointing it to the reference price data for ETH USD on the Covan network, the testnet. So everything is kind of set there and we have one function, get latest price and it's going to call that, and it's going to recall this function from our price feed that we set here. It's going to call another function on that called get latest round data. And get latest round data is going to return all the information about the latest round that that decentralized Oracle network posted data for. It's going to tell you the round ID. It's going to say hey, this is the actual price.
00:23:29.092 - 00:23:57.710, Speaker A: Tell you when that round started, the timestamp of when the data was posted and giving you the data of what round that data was put into the blockchain app. And then what? Really all we're going to care about is the price right now. So it returns price. Great. So now we have our smart contract. It's using the chain link data feed. We're going to go ahead and compile and deploy this.
00:23:57.710 - 00:24:21.972, Speaker A: So let's go ahead and compile it. Let's turn on auto compile again. All right, so everything is working fine. We get a couple of these informational warnings again. If it's yellow, no need to worry about it. It's saying, hey, unused local variable, we're not using any of these other things that we're returning, we're only using price. But that's okay, that's all we need for now.
00:24:21.972 - 00:25:02.720, Speaker A: So nothing big, no red warnings that say, hey, the compiler is not able to read this code, so let's go ahead and deploy this. Now remember this is set up for the Covan testnet to get us going. So we're not going to use JavaScript VM, we're going to switch to injected web3. That'll connect us to our metamask again, say connect, make sure everything is good there. And it is remix. And our metamask is set to Covan Testnet. And so that's what our remix is reading, Covan Testnet.
00:25:02.720 - 00:25:27.880, Speaker A: It's looking at the right account. It shows my ETH balance there. That is indeed my account. Our gas limit. We're good there and we want to make sure that we're pointing to the right contract. You see now there's two contracts here because it's loading in this contract from our import statement right here on line four. That's not the contract we want to compile.
00:25:27.880 - 00:26:08.100, Speaker A: We want to compile our price, consumer V three contract. This is the one we wrote and it includes that other contract that we're importing in our constructor. Doesn't take any arguments, we're good there, we can just deploy it. We are deploying. So metamask is going to come up, say, hey, you're changing state on the blockchain, going to cost some gas. We're all good there, confirm, and boom, that was quick. We have our contract, so now we can click get latest price and it should show us the latest price of Ethereum.
00:26:08.100 - 00:26:54.564, Speaker A: And bam, it shows us the latest price of Ethereum. There's no floating point decimals in solidity, so it gives it to us as Integer 256. There is a function that tells you where the decimal point is. But this is how we can access price feeds or data feeds from within our smart contract and start building all kinds of cool stuff. So now we can use this method and start making some cool contract logic around it in our contract to do cool stuff. And so that was basically just a basic introduction of Chainlink price feeds. Again, if you ever want to know more details, the docs are a great place, as you see.
00:26:54.564 - 00:27:26.960, Speaker A: I basically just went straight to the docs and follow the demos here. Our demos, we put a lot of work into. They're really great. I still use the demos all the time and we're going to continue doing that throughout this demo. So if you have any questions about price feeds, any details, you can read the docs. We can figure out how to get historical price data. There's a registry of where all our data feeds are, all kinds of great information and some chain specific addresses.
00:27:26.960 - 00:28:00.280, Speaker A: Where are addresses on Ethereum and on the hackathon. They'll probably be posting a lot to test. You know, you have Covan testnets, rinkby testnets also. Rinkbee is also here. Covan is awesome though. I love testing on Covan if you can. But yeah, you can also have Binance, smart chain feeds, polygon, Xdai, huawei, ecochain, avalanche, phantom, arbitram, harmony, solana and optimism.
00:28:00.280 - 00:29:07.596, Speaker A: So if there's a data feed, you can find it here and you can find all the addresses to use in your smart contracts. Awesome. All right, so let's go ahead and will, before we move on, do we have any questions? Take a sip of water. Can we use any API with the data fees? That's a great question. So the data feeds are already curated, decentralized oracle networks that do all the heavy lifting for you and connect to all the APIs and do aggregation that we talked about. So there's some data that you need to get and isn't available in the data feed. We can actually use the chainlink.
00:29:07.596 - 00:29:40.796, Speaker A: Any API solution. A lot of people opt to use this for their hackathon. It's a great way to MVP your application. We're going to go over that later. So if you want to connect any API, we will handle that. A little confused by the syntax of get latest price function. All right, let's go back and let's look at that again and kind of go over the syntax first.
00:29:40.796 - 00:30:03.990, Speaker A: I'm just going to go through it. So all bases are covered here. We say function that defines that. We are writing a function, get latest price. That's just what we're going to call it the name, right? And it's not going to take any arguments. We're just going to use this to read data and we're going to make this function public. So any account or any other smart contract can actually call this function.
00:30:03.990 - 00:30:33.980, Speaker A: We're going to say view, say hey, we're not actually accessing state or we're not writing anything to state, we're just going to read data from state. So we're not actually going to do really any hardcore computation. We can label it view. That makes this function gasless. It doesn't cost anything gas. And finally we're going to say it returns an int and we'll define what that int is going to be. But this function in general returns an integer.
00:30:33.980 - 00:31:34.768, Speaker A: And so we put our curly braces, this is where we put the body of our function. And to make this a little easier to read for right now, I'm just going to cut this out. So now we're saying, hey, I'm going to call this variable price feed which we defined and initialized in the constructor and we're going to call latest round data that comes from that variable and that's going to return a bunch of values. When we call that not just price, it's going to return a bunch. So we need to take those values and we need to put them in some kind of variable and store them so we can use them. That's what we're doing here inside the parentheses. So we're saying, hey, get latest round data is going to return a bunch of data.
00:31:34.768 - 00:32:09.070, Speaker A: Take the first unit of data it returns and store it within round id. Take the next data unit of data returns and put it in price. Take the next so on and so forth and stores it in there. And finally we say, hey, all we really care about in our smart contract is the price. So we stored all that data, but really we're just going to return the price. And these data feeds do put in like the price feeds are put in as integers. And again, remember int is synonymous with int 256.
00:32:09.070 - 00:33:18.320, Speaker A: So there you go. That's kind of the structure of that function. What's the name of that data structure? An array? No, this is just a bunch of different variables altogether. We're just kind of creating these variables in memory in the function and storing them there. Okay, I think these feeds are sponsored, but will they at some point become non public unless you pay for it? Great question. There's no plans that I'm aware of at the moment to make these feeds non public we know how important these feeds are to building these important d five primitives, and we want the space to continue growing. So for now, they are public.
00:33:18.320 - 00:34:25.804, Speaker A: Okay, last question. Two questions, actually. I'll take these two. What restricts the oracle nodes from providing wrong data? Again, that whole aggregation property and their reputation, this whole subject of designing these systems called crypto economics, how do we incentivize actors in this distributed system, this decentralized system, to act in the best interest of the users and the important parties that are using it? You can go into a lot of detail. There's a lot of good resources online. You can Google on how Chainlink is secured through crypto economics. But in a nutshell, they all have to go through this consensus algorithm.
00:34:25.804 - 00:35:05.260, Speaker A: They all have to figure out what the truth is. They're all aggregating data. Remember when I showed you data feeds link? Their reputations are on the line. Everything they post goes on chain and is available forever. And the link token comes into account and kind of keeps them in check. So in a nutshell, that's how these kind of nodes are restricted from just providing any data. And finally, can we have current time as a data feed? We can make a data feed for anything that exists, any kind of data that these nodes can access.
00:35:05.260 - 00:35:40.576, Speaker A: So basically everything. I don't think the current time is a current data feed. It's certainly one you can make. So all of this software is open source? Chainlink is open source, so anyone could make a feed. The Chainlink labs team can help make a know if there's a lot of demand, but yeah, we can make a feed for anything. All right, let's go ahead and move on in the presentation. All right, so we're done with data feeds for now.
00:35:40.576 - 00:36:29.916, Speaker A: Let's go ahead and move on to the next thing, which will be automating our smart contracts using Chainlink keepers. I kind of want to put this early on because this is one of the newer services that Chainlink enables and really shows how powerful this oracle paradigm can be. It doesn't have to just be about getting data and putting it on chain. We can do all kinds of crazy off chain computations and we'll go into what keepers does. So another thing that's kind of limiting about smart contracts, and we talked about that oracle problem and how they can't connect to outside data and resources, but blockchains can't actually really execute their own code arbitrarily. They need an outside actor to initiate it. Right.
00:36:29.916 - 00:37:03.636, Speaker A: So as we've been deploying our contracts, if I want to run, get latest price. I have to click that button, get latest price. I have to run that code. We have to run our functions. And so chainlink keepers allows us to create a decentralized oracle network that will arbitrarily run our code whenever we want. We can define the conditions. We can even define some computation that the keepers will do and then they'll execute our functions when the time is right.
00:37:03.636 - 00:38:11.920, Speaker A: When we define, they should run the functions. Of course, it's a decentralized oracle network, so it does so in a decentralized way, preserving those awesome properties of the blockchain. So one example of where this is useful is in DeFi loans. So back to defi. Almost all loan applications in DeFi are called over collateralized loans, meaning that when we put assets into DeFi and want to take out a loan against those assets, we have to actually put up more collateral in terms of like US dollars, for example, in there, then the loan that we take out is worth. And if that collateral's price and that price is being determined by chainlink data feeds, of course falls below a certain price point, those loans need to be liquidated. Someone has to take out that collateral and say, hey, look, this loan isn't working out.
00:38:11.920 - 00:38:53.310, Speaker A: I'll pay back that loan and I'll take out that collateral. But traditionally, you kind of just hope that people will liquidate the loans and that this will happen. And in times of high gas fees and chaos, when the markets are going insane, this can be tough. Gas prices skyrocket. Gas prices can go above the gas costs. People are just kind of panicking. So we can employ the chain keepers network to come in, monitor those loans, and liquidate them as they need be, making sure that these financial systems don't break down.
00:38:53.310 - 00:39:29.550, Speaker A: It's not in here. Missing one slide. But another cool use case for keepers is time based smart contracts, which we're about to do in the demo. So maybe you have a smart contract that wants to run every hour or every day. We could use the chain link keepers to run that function on a timely cadence. So now, again, let's learn by doing. Let's hop right into the demo.
00:39:29.550 - 00:40:14.840, Speaker A: So what do I have installed for this? I have metamask wallet. I have testnet ETH. We're going to start with the chain link docs. We are missing one thing, though. We're actually going to need to get testnet link. So just like ethereum requires ETH for gas, the chain link services require link tokens to pay for the computational resources that the link nodes are going through. The data feeds are sponsored, which means that the users and the big defi apps that are sponsoring them, they pay those feeds for the users to keep an open ecosystem so we can continue building awesome defi apps.
00:40:14.840 - 00:40:58.730, Speaker A: But for something like the chain link keepers, we're going to need to get link to pay for this service. So I actually don't have any link in my metamask right now, only ETH. So we're going to go ahead and do that. So where I have tested ETH, we're going to click on that because it's going to take us to the chain link faucet. False chain link. And instead of just ETH, we're going to get some link this time. So we'll get our public key or our address and we'll put in our address, pass the captcHa, not a bot, and ask for link.
00:40:58.730 - 00:41:32.580, Speaker A: All right, so we have tin test link on the Covan testnet. Great. It gives us the transaction hash to show go to metamask. What? No link? What's going on? Yeah, so metamask, remember all these ERC 20 and links case ERc 677 tokens are smart contracts. Metamask can't feasibly keep up with all those smart contracts that exist on ethereum. So we need to add the link token contract address here. It'll know where to look.
00:41:32.580 - 00:42:16.208, Speaker A: So to do that, we're going to go back to the docs. So we're just going to go to type in docs, chain link and I'm already here, just want to type it in and we're going to scroll down and we have developer references here. Here we can see link token contracts. This is where all the link token contract addresses are stored for all our chains that link token exists on. And we see here we have Ethereum, Mainnet, Covan, Rinkbee, Gorelli, other EVM compatible chains, you name it. We're deploying everything on Covan. So we're going to take this address and we're going to copy it.
00:42:16.208 - 00:42:55.820, Speaker A: Control C or command C for my fellow Mac users. And also it gives us a handy link because it knows probably if you're here you're going to want to get some funds from the faucet. So we're going to go on our metamask, we're going to click import tokens and we're going to paste this address into the token contract address. So it's reading that smart contract says, hey, I know this is link. How many decimal places are there? We'll add custom tokens and look, it's showing that tin link. So click import tokens. And now my wallet will display my link tokens as well as my ETH.
00:42:55.820 - 00:43:26.916, Speaker A: Great, so good there. And we'll head back into, we'll leave remix for now. And we're going to go back and so now we're going to start the demo. We're going to use chain link keepers and we're going to automate our smart contract. So functions will run in our smart contract even without us having to run them. So first again, start at the chain link docs. Boom, back at the chainlink docs.
00:43:26.916 - 00:44:05.508, Speaker A: Docs. Chain link, come here live. And we're going to go to using chainlink keepers. Again, there's a little introduction here that explains to us the value of Chainlink keepers and how it works and gives us a little detail on how we need to onboard. We're going to go ahead and go to making a keeper compatible contract. So there's two major parts to making keepers work. We need to make our contract be able to work with keepers and then we need to actually go to the chainlink keepers contract itself.
00:44:05.508 - 00:44:37.674, Speaker A: That determines all the jobs that keepers work will get there. So making keeper compatible contracts again, if we scroll down it gives us some code, some code and then finally an example contract. Again, we can deploy using remix. So let's go ahead and click deploy using remix. All right. So again, we already have our set up, smart contract. I'll skip going through the beginning.
00:44:37.674 - 00:45:32.914, Speaker A: We already know pragma, import, contract, state variables, constructor. But now we have two particular functions that are too big, that are unique to smart contracts in general. We have check upkeep and perform upkeep. So Chep, these are two functions we're going to need to put into every smart contract that is going to interact with chain and keepers. Check upkeep is going to tell our smart contract. It's going to tell the keepers when they should actually perform the work they need to perform, when they need to call perform upkeep. So check upkeep actually doesn't ever need to be called by any users or the developers themselves.
00:45:32.914 - 00:46:11.850, Speaker A: Check upkeep is just for the chain and keepers. They're actually going to take this function and they're going to virtualize it on their own nodes and they're going to run it there until the conditions are met. So it's not actually going to cost any gas, but we need to include it. In this case, the upkeep is, we say is upkeep needed. So we need to return our bool. True or false is the upkeep needed. And we're going to say hey, we're going to access this inherent variable on study block timestamp.
00:46:11.850 - 00:47:40.054, Speaker A: This is going to say hey, what time was the latest block created? And if we subtract the current block timestamp from the last block's timestamp that was created and it's greater than a certain interval, we define and we're going to define in the constructor then perform upkeep, let's say, all right, our block timestamp minus the last timestamp ends up being greater than interval chain. The keeper will see that, say great, and it's going to run perform upkeep on this contract and we can pass in call data. So if we want to customize each run of our upkeeps we can actually tell, hey, actually we want you to pass in this data and to perform upkeep we'll call a call data doesn't have to be used and that'll pass in data to the smart contract and we can do some cool stuff with that. And we can actually have within checkupkeep we can have the keepers nodes do computation on that data before they post it. Okay, great. Let's go ahead and deploy this contract again. Everything's compiling.
00:47:40.054 - 00:48:02.382, Speaker A: Okay. Just a couple of informational warnings, nothing red. We're going to switch to injected web3 again because we're going to deploy this to a testnet. It's connected to my metamask already. Covan Great write account. And again, make sure it's pointing to the right contract. We don't want the interface.
00:48:02.382 - 00:48:30.010, Speaker A: The interface is what we're importing. We want to say counter encounter. Our contract has a constructor that update interval. So when we deploy this contract we have to tell it like hey, what's the update interval? And then we're going to use that again for the keepers to say when they need to perform upkeep. We're going to store it in this state variable interval. And this is an immutable state variable. So let's put it there.
00:48:30.010 - 00:49:05.190, Speaker A: It's not going to change. And we have last timestamp and we have counter. So we're going to initialize our counter at zero. Every time we perform upkeep the keepers perform upkeep. It's going to increment that counter by one. We need to define our constructor. How often do we want the keepers to run perform upkeep? I'm going to say every 10 seconds.
00:49:05.190 - 00:49:34.462, Speaker A: We'll put ten. This constructor is a Un. All right, we should be good deploy. We're pointing to the right contract, not the one we're importing. Pay our gas fee. All right, our contract is deployed to the Covan testnet and if we click on counter it's at zero. So where we started it out at, if we click on interval it's at ten.
00:49:34.462 - 00:50:07.130, Speaker A: That's what I put in. So 10 seconds is what this is defaulting to here. And so every 10 seconds it'll check and the last timestamp will just get the block timestamp that we deployed this at the constructor. Cool. All right, now we've deployed our keeper compatible contract. We're all good there. We need to now go to the second part of this and register it with the keeper registry.
00:50:07.130 - 00:50:40.210, Speaker A: Guess what? We're going to go back to the docs and figure out how to do that. Register upkeep for a contract. This is part two. And again, if you forget all these steps you can go to the introduction explains everything, will walk you through all of this. And so this is still all done on chain. We're going to say we need to tell the keepers now that we deployed our contract, it's good to go. We need to tell the keepers, hey, this contract exists and you need to start looking at it and performing your keeper duties.
00:50:40.210 - 00:51:42.354, Speaker A: And all this is done still on chain in a smart contract where we can say, hey, this is the address of our contract. But there's this convenient chain link keepers app we can go to which will help us go through this whole process and see some information about Chainlink on Mainnet. And we see some buttons and we can see some contracts that are on chain linkeepers right now. Right now we have it pointed to Covan Testnet because that's what our metamask is on. So you see a bunch of nonsense test upkeeps as people are just kind of testing out their code and making sure everything works fine. You can switch to Ethereum Mainnet and see some really cool legitimate projects that are using chain link keepers live. Now back to Covan testnet.
00:51:42.354 - 00:52:06.670, Speaker A: That's what we're working on and we're going to click register new. Ah, you must connect your wallet before adding a new upkeep. So my wallet is not connected. And you'll see up here in the top right there's a button for connect wallet. We'll click that, you'll see it's communicating with our metamask. We see this is indeed keepers chain link. That's what we want to talk with.
00:52:06.670 - 00:52:32.400, Speaker A: Hit next. They just want to see our addresses. Cool. All right, we're in. This is my wallet address here. Let's go ahead and start registering that new upkeep. So we're going to have to put in an email address, an upkeep name, upkeep address.
00:52:32.400 - 00:53:05.098, Speaker A: So I'll just put in one of my old deprecated emails for now, a yahoo. And we'll call this hackathon demo. That's what we'll call this upkeep. Now we need to upkeep address. This is the address of that contract we just deployed. So where can we get that? We had it in remix. Right? So if we just go to remix again, we have the address here.
00:53:05.098 - 00:53:50.550, Speaker A: We click on this double page icon that copies the address of this deployed contract. Come back here, we can paste that in there. The admin address that has control of this upkeep, it defaults to my wallet that I'm doing this with. That's what we want to do. A gas limit. So the keepers, they're going to be running all of these functions and that's going to cost them gas. And we're paying for these keepers now those gas costs, since we need it, we're paying for them.
00:53:50.550 - 00:54:43.658, Speaker A: We're sending this in terms of link tokens to the keeper nodes. And so if the gas gets expensive, our keeper's upkeep gets very expensive. So we may want to put a gas limit on a gas limit so that the keepers don't get too expensive. If something happens with our computation and it gets too expensive, if we go to the docs, it kind of explains more on how all these fees are calculated. You can read it here, but for us to say the gas limit is two, we'll just put in 200,000. Yes. Okay.
00:54:43.658 - 00:55:27.800, Speaker A: And if we wanted to put any check data in there when we run check upkeep, we're not going to today. And we needed to start funding our contract with link, so we're going to pre fund it. So every time these keepers run our functions again, they're going to look at how much gas costs, it costs them. And there's this formula again you can read in the docs and then they're going to take out some of that link and get paid. So we need to pre fund it so they can continuously run their functions. And let's go ahead and let's put all ten of our link in there. We can always go back and get some more link.
00:55:27.800 - 00:56:02.202, Speaker A: So we'll register upkeep and it's going to ask me to confirm again, pay the gas. We're going to have to pay some gas to register it in the first place and it's going to wait and confirm. Awesome. So our upkeep registration has been submitted successfully. It's on chain and here's the transaction. And we can actually view that upkeep. Okay, so it's active.
00:56:02.202 - 00:56:29.330, Speaker A: It gives us the address. Here's our current balance of link we pre funded it with and some details on the upkeep, what our ID is when it was added. My wallet is the admin address and the gas number we set. It'll also show you the address of the last keeper that ran your upkeep. But you'll notice something. We're getting a warning. This upkeep is underfunded.
00:56:29.330 - 00:57:14.740, Speaker A: If you are the owner, consider addering funds. So to make sure that the keeper is always getting paid when they do their upkeep, we don't want the balance to fall to zero. So it is required to put in a minimum balance of link to make sure it runs. I only had ten links. So we're actually going to go back and we're going to go back and we're going to get some more link so we can hit that minimum balance. We can always go to link token contracts and it'll link us to the right faucet for the network we want. So we'll go ahead and go to faucets, chain link, COVID and send me ten more link.
00:57:14.740 - 00:57:50.470, Speaker A: Got to put in my address. Okay, so this will get us some more link. Great. We have ten link again. So now let's go back to the keeper, the upkeep, and we can click on the button right here. Add funds. To make sure we get above that minimum balance.
00:57:50.470 - 00:58:33.390, Speaker A: Let's actually add in eight more links. We'll have 18 link. It can run maybe a couple of times and we'll click confirm. Now we actually have to send that link over and it's going to go through a bunch of confirmations allowing it to run. So my link token got sent over. Now we have to confirm everything again with the keeper's contract this time say, okay, good. All right, our funds were added and look, it looks like it's already running.
00:58:33.390 - 00:59:07.192, Speaker A: We already had a keeper that fast. Now that we've hit the minimum balance run. So let's go back to our contract. Let's see what's been doing here. All right, remember, what are they doing when they perform upkeep? All they're doing is every time the amount of seconds passes they check it, they run perform upkeep and they increment our counter by one. So we have counter equals counter plus one. Now our counter was initialized at zero.
00:59:07.192 - 00:59:39.324, Speaker A: That's what we're still showing down over here. If I click on it now, hopefully it should have incremented some, let's see, four. It's already run four times. Awesome. And now every 10 seconds these keepers will keep running and they're going to run through my link balance and they'll keep running. Maybe we can come back at the end of the demo and see how many times the keepers have run. Awesome.
00:59:39.324 - 01:00:35.444, Speaker A: So that was trailing keepers, that was automating our smart contracts using them. Let's go into the comments and see if there's any questions. Why is a check upkeep function not having a return keyword? Let's go back there and let's look at check upkeep. The reason it doesn't is because we're not actually returning anything in this function. We're not. It can return a bool. But remember, the check upkeep is something really for the chain keeper nodes to run.
01:00:35.444 - 01:01:27.604, Speaker A: We're never going to have to interact with this, so it's not too important. How often should I deploy to a test net? Henry here looking for a best practice in this question. Is remix robust enough to write complex smart contracts and fully test them without deploying them to a test? Awesome question. So remix is great, especially when you're starting out. It's great to quickly get a quick win, go in there, deploy your contract onto a testnet, see how it works. But a lot of the power in developing smart contracts is done locally in these deployment frameworks. So you have hard hat, Brownie and truffle.
01:01:27.604 - 01:02:29.500, Speaker A: Those are three of the biggest ones. And that's where if you get a little bit more experience with programming, you can mess around with them. That's where you can really write robust tests all locally. You don't do it in your browser, you can fork the blockchain and make a local instance and test it there and write all these awesome scripts to automate everything. That's where most developers actually do a lot of their work when they're developing production grade smart contracts. And we conveniently have these starter kits that already come preloaded with a bunch of some initial tests and chain link smart contracts. If you want to see them, just have to type in GitHub, wrong browser, do it over here, just type in chain link GitHub.
01:02:29.500 - 01:03:05.336, Speaker A: You can click on this. This will take you to the main chain link node stuff, but we're actually going to go to smart contract kit organizational account here and we're going to click on one of these. We'll click on hard starter kit up here. You see there's also truffle starter kit and chain link mix, which is brownie starter kit. And so you can work with one of these if you already have some experience. We'll talk about a little bit about them later. But these are great places to go.
01:03:05.336 - 01:04:01.730, Speaker A: Feel free to clone, fork whatever you need to do and work with your smart contracts there. Concert crypto. Yeah, I see. Like using truffle and get Nash. Those are awesome choices to do things locally. Can you explain again the input parameters of the keeper's function? Yeah, we have this bytes call data, right? Or check data. We can tell the keepers, like when we were registering our upkeep, we can tell the keepers, hey, here's some check data, go in there.
01:04:01.730 - 01:05:13.706, Speaker A: And every time we make a new upkeep we can customize it for different inputs. So maybe I have this one contract and I want an upkeep that starts with a check data parameter of zero and then another upkeep registry that starts with a check data of one. Then the keepers will start the check upkeep with different initial conditions and can even work and use that data to do some cool stuff and then pass that data on to perform upkeep as call data. So then we can make one contract, deploy to the blockchain, and then have multiple upkeeps that start with different initial conditions and maybe even do different off chain computations. Awesome. Great questions guys, let's move on. So we've already gotten some questions about this, so let's go ahead and move on to accessing any API using chainlink.
01:05:13.706 - 01:06:12.320, Speaker A: Again, this is a powerful tool. If you just want to get MVP for some data that isn't already on a chainlink, don decentralized Oracle network or you don't want to go through the effort of because it is quite difficult to spin up a can be quite a lot of effort, I should say, to spin up a chainlink network. So yeah, we can connect to any arbitrary API using chainlink. We call the solution any API cleverly enough, and it could be anything. Could be a web API, enterprise system database, Internet of Things censored, or an API enabled physical device such as a car. There's a cool hackathon winner who now works on my team, Harry, who actually connected a smart contract to a Tesla. So that's awesome.
01:06:12.320 - 01:07:05.120, Speaker A: So you can find a bunch of nodes to do this work. So we do this by going through a node, we go back here, we do this by going through a chain link node that can relay this information back and forth between the blockchain and the real world. And if we want to find these nodes, we can go to a great website, market link, where we can find a bunch of different chain link, what we call jobs, adapters, data sources, feeds, basically a lot of different things for the chainlink network. But in this case we can find nodes that will do our work for us. And we're going to talk about nodes and jobs in a second. But just to give you an overview of market link, let's click here. And so yeah, you see here we have market link.
01:07:05.120 - 01:07:28.760, Speaker A: We can say, hey, I'm a data provider, I want to list my data here. I really need this particular data. We can request some new data. I'm going to go here and click on nodes. And we have a bunch of networks here and these are a bunch of chain link nodes. Some of these are in the feeds like in the ETH USD feed we were talking about. And we can click on them.
01:07:28.760 - 01:08:09.794, Speaker A: Let's look at link pool. You can see some metrics on these nodes, the kind of jobs that these nodes will run for us, a bunch of good stuff. And if you want anyone can come here and they can list their node and their jobs. We'll talk about adapters in a second. All right, so any API we're going to go ahead and go through the demo. You already know how it is. We're going to go through.
01:08:09.794 - 01:08:43.840, Speaker A: I have my metamask wallet, I have testnet, ETH and testnet link stored in my because we will need link from here on out. Every service other than data feeds is going to require us having link. Maybe I need to stock up though. And we're going to start on the chain link docs again. Back to doc chain link. This time we're going to scroll down till we see using any API again. We get an introduction explaining how this works.
01:08:43.840 - 01:09:26.344, Speaker A: We're going to make a get request though. So one of the most simple things we want to do is we just want to make an HTTP get request to an outside API and we want to see what data it returns and posts that on chain. All right, so let's go ahead and deploy this contract using remix. Close out some of this. Keep our faucets open in case we need it. We keep our keepers, we'll close this remix instance. Okay, so we have our API consumer contract.
01:09:26.344 - 01:10:23.360, Speaker A: Now that's what we're going to call this API consumer and it imports Chainlink client soul. So just like we had an import for keepers to interact with keepers to interact with any API, we need to import chainlink client and we're going to say, hey, this API consumer inherits from Chainlink client. So if you're used to object oriented programming that just says hey, this is taking in some of those methods of this parent class. And we have a couple of state variables, volume. So we're actually going to use this any API solution, get the volume of ETH USD from an exchange or a website and a couple of state variables, oracle job Id and fee. So this is why I'm going to explain to you what these are. So remember in market link we were looking and I was showing you about all these different oracle nodes that are listed.
01:10:23.360 - 01:10:58.988, Speaker A: These nodes have an address associated with them that actually represents that node on chain. And so if we want to make a request through that oracle, we need to know the address, the ethereum address that represents that oracle on chain. That's what the oracle here is. And then job ID. So that oracle, that specific node may do multiple things. It may have a job to get a git request from any website you want. It may have a job for a very specific website.
01:10:58.988 - 01:11:31.456, Speaker A: Like this is weather data aggregation job and it just does that. So it can have multiple jobs that do many things. And so we need to define a job ID. And so when nodes go on market link and they list themselves on like hey, this is my node, this is my address. They'll also list the job IDs they have and what those job Ids do. And finally a fee. So again we're requesting something from these nodes.
01:11:31.456 - 01:12:19.424, Speaker A: We need to pay them in link token for the work that they're doing since this is the chain link network. Okay, so real quick I actually just want to show you a job. We'll go back to market link, we'll go to jobs like I was saying. So you see all these different jobs and what networks they're on and what node is running on them. This is for on ethereum, Rinkbeat, Testnet, some Instagram impressions job that's pretty know, copies some data, multiplies some gets the number and posts it on chain. That's cool. Gets Instagram impressions.
01:12:19.424 - 01:12:55.632, Speaker A: So you really can't do anything with these, any API requests. All right, so we're going to go back like looking at the code. So we initialize this demo code we have in the docs automatically initialize us to a specific oracle address and a job ID. These are already set for the job we're going to do, which is just make a git request and the fee is set. We only need to pay 0.1 link to get there. So then we have our function request volume data.
01:12:55.632 - 01:13:35.764, Speaker A: This is where we're going to send a request to that chain link node and say hey, I want you to grab us some data. It's public, anyone can run it. It returns a byte 32 call to request that we'll get there. So first we need to build the request. We need to tell that chain link node where we want to go to get the data and how to get it. So we'll do request add and we'll say hey, we want to make a git request and we want to make it to this URL. So this is actually an open URL.
01:13:35.764 - 01:14:29.210, Speaker A: If I make this get request, if I just push this on my browser, my browser should make a get request to it and we return all of this data in json format. And so yeah, we're saying hey, make a get request, send it to this URL. Then we're going to say, remember that big list of data? That's a lot of data in there. We need to tell what data we want to extract from all that json object. So we're going to say, hey, we're going to say the path for the JSON is this, it's going to go through that JSON. It's going to say it's going to find raw, then go into the value for there and it's going to find e, go to the value for there, USD, so on and so forth until it gets to volume 24 hours. So it's going to extract that particular data value that's within volume 24 hours.
01:14:29.210 - 01:15:16.090, Speaker A: And then we're going to take that and we're going to say, hey, we want the node to multiply it by a certain number to get rid of the decimal places. And then we'll actually add that to our request and we'll return the actual function that sends this request out to the oracle. And this function comes from that import chainlink client. So say send chainlink request to, we'll put in the oracle address this request that we've been building with request add, request add. This continues to build a request. So this will send out our full request and what we set to be the fee 0.1 link.
01:15:16.090 - 01:15:59.530, Speaker A: When this function runs, it actually returns the ID of that request, the request ID and that's in bytes 32 form. So that's why we have a return here for bytes 32 request id that we're calling request ID. When this runs, the compiler will run this code here and say okay, replace this with the request ID that gets sent out and it'll return it. Awesome. That's what will happen. And then we have fulfill, so just like keepers, they have to have a function to run after we send the request out. This node will then run, will send data to this fulfill function.
01:15:59.530 - 01:16:58.900, Speaker A: So that'll run this fulfill function here and pass in that request id. This should be the same request ID that was generated when we made the request. And the actual answer, in this case the answer will be un 256 and we'll call it underscore volume. This is public, but we have this, what's called a function modifier that comes with it that will help make sure that our chain link node is the one that fulfills this function. Okay, that's basically what's going to happen. We're going to send out the request by calling this function. Chain node will then do its work and fulfill that request by calling this function and it will take that data, put it in volume, it will take volume and it will store it in our state variable called volume.
01:16:58.900 - 01:17:34.624, Speaker A: So we will now go to the compiler, compiler is giving us a green check mark, not even any warnings. And again, we'll make sure we are pointing to the right contract. Our list is getting kind of big now. API consumer, that's the name of our contract, API consumer and we'll go ahead and deploy. We don't have any arguments or parameters for our constructor so we can just straight up deploy it. But I deployed it to JavaScript VM. That's not going to work.
01:17:34.624 - 01:18:18.580, Speaker A: We want ejected web3 API consumer deploy confirm. Awesome. So our contract is now deployed down here and we have our volume, which initialized at zero. We didn't set anything to initialize it with, so it defaults to zero and we have a request volume method and fulfill method. We're not going to actually call the fulfill method, we'll never need to call it just like perform upkeep. This is for the chain link node to call. So let's look at volume cat's estimation.
01:18:18.580 - 01:19:06.464, Speaker A: Yeah, so remember we need to pay the chain link nodes and link tokens. So we need to actually fill the contract itself with link tokens to get this to work because then the contract will say hey, I can package this link token and send it over to the oracle. So yeah, we'll go ahead and not send that transaction out. And the first thing we're going to do is we're going to copy the address of our deployed contract. We're then going to come here to our account and we're going to click send and we're going to paste in that address up there. We're then going to switch from ETH to link and it only costs 0.1 link to send a request.
01:19:06.464 - 01:19:44.290, Speaker A: We'll give it a little bit more, we'll say 0.3. My metamask is just estimating zero point 29 and we'll hit next and pay the gas fee to send link confirm. Now we have to wait a second for the link transaction to go through. This is the disadvantage for using Covan takes a little time compared to local environments or JavaScript. So our link is sent. We should be good. Now if we hit request volume, what happens? That went away, we're good.
01:19:44.290 - 01:20:08.680, Speaker A: It's giving us the details, how much estimated gas fee we're going to need to pay. We're going to go ahead and confirm that. Great, our request is sent, it's been included. Let's check the volume. There's nothing there, still zero. Why? Because remember we're sending this request to a chain link node. That chain link node has to do work and then post that data to the blockchain.
01:20:08.680 - 01:20:37.860, Speaker A: So it's going to have to make a transaction itself, pay gas fees, all that good stuff, and then you have to wait for that transaction to be included in the blockchain. So it could take some time for this data to be posted. And boom, now it's posted. May not be instantaneous, but it can be relatively quick. And yeah, we have this volume, this big number. This is the volume of ETH USD from cryptocompar.com API.
01:20:37.860 - 01:21:31.568, Speaker A: So yeah, that's in the API. Again, there's some jobs that are very specific, like maybe you want to get this weather data from open weather consumer. This already helps you get set up and how to basically a lot of the same steps, pointing to the oracle job ID and requesting the weather temperature, how to do that. Also a new feature that's really awesome and really well requested. Really requested is multivariable responses and large responses. In the past you could only send one request and get one response back from a chain link node and that response had to fit within 32 bytes or 256 bits. If it was anything bigger than that or required more than that, you would have to make multiple requests.
01:21:31.568 - 01:22:21.280, Speaker A: But now there's a way we can get multiple variables with one request. This will be a great resource if this is something you want to do in the hackathon, and also large responses if you have a very big chunk of data that you're returning back on chain. Again, this will let you go beyond that 232 byte to 56 bit limit. Find existing jobs, it's going to point you to market that link. So yeah, that is any API. This is where you can really power your smart contracts with any kind of data that may not be available as a decentralized Oracle network. Again, you can make a decentralized Oracle network if you want.
01:22:21.280 - 01:23:30.174, Speaker A: And for production, that's what we want, right? We don't want to run all of our data through a single chain link node. We're introducing a centralized point of failure. But this can be really great for hackathon projects and for testing and generating an application that may not have an existing decentralized oracle network without you having to go through all the effort of building one and just focusing on your application logic at first. So very handy and useful tool. All right, let's go back to the comments now. Yes, I see there's some discussion going on. Patrick's answering some awesome questions about mocking.
01:23:30.174 - 01:24:53.486, Speaker A: Yeah, so if we're going to do this all locally, if we were to use one of those starter kits, hardhat, Truffle, Brownie, and we were to do this locally, or even switch to JavaScript VM within, remix those chains, there's no nodes looking at those chains because those chains only exist on our computer. No one else knows about them. So there are no chain link nodes, there are no keepers, there's no VRF there. So what if you want to test your smart contracts locally but those things don't exist, you can mock these services and in fact these mocks have been put into our starter kits, especially the hard hat and the brownie starter kits where you can test it that way. So you kind of just make this contract that represents the keepers or make a contract that represents any API or VRF, and then you can act as the keeper or any API node and that way you get all the power of testing locally. And yeah, we've got some really good questions. There is a way to make any API call where a TLS certification is required.
01:24:53.486 - 01:25:59.014, Speaker A: And is there an automated way to keep that? An up to date certificate? So this is going to be covered a little bit more in future demos. But nodes have this ability. If we go here and we'll just get a little sneak peek here and we'll go to node operators for people who want to run nodes, and there's this thing called external adapters. External adapters allow nodes to add basically any kind of logic, customize any kind of logic the node wants, and connect it to the main node software. And within this external adapter you can put a TLS certification if you need that, any API keys, all that good stuff. We can make an external adapter and place it there and we can make that external adapter public. But of course we're not going to want to share if there's API keys, if there's sensitive information, a TLS certification with private keys in it, we may not want to share that with everyone.
01:25:59.014 - 01:26:59.558, Speaker A: So we can kind of put the structure of the external adapter, but the nodes, when they run that external adapter, they'll put in their own API keys and all that good stuff. So that's how you kind of connect to these data sources, how the nodes connect to data sources that require a little extra authentication. Harry's going to be running a great demo on external adapters later in the hackathon, and I'll actually be running a demo as well on running a node, so we'll cover more of these topics later. How would you make an oracle? Yeah, same thing. We're going to go over that, and I'll be actually going over that in a future demo on how you can run the chainlink node software. Is there versioning of contracts? What if there are bugs and a new version is required? Great question. Yeah, of course you have the solidity.
01:26:59.558 - 01:27:23.780, Speaker A: Not to confuse people, you have the solidity version which is up top. This just again tells the compiler what language of solidity to look at. But let's say we wanted to update our contract and go to a new contract or change something. There's a bug and we want to update our contract and fix the bug. Remember, the blockchain is kind of immutable. That's one of the properties of the blockchain. Once we deploy something, it's really hard to change that.
01:27:23.780 - 01:28:27.104, Speaker A: And so there's some workarounds this we can make functions that allow a special address to change certain things. It's kind of naive way to be very dangerous because it can give someone a specific account way too much power over that smart contract. This could be a topic all on its own, but I really suggest looking into proxy contracts. That's how most developers today do upgradable contracts. There's a lot of nuance, a lot of detail. It could really be its own workshop. But yeah, so look into proxy contracts for that, if the data is pushed to the chain, what stops you from reading Oracle API data from the chain without paying the fee? Well, the Oracle isn't just going to put the data on there.
01:28:27.104 - 01:29:09.276, Speaker A: We had to send that request earlier. And to send that request, we first had to load the contract with link tokens, and then that contract is going to send the request to the note along with the link token. This is actually why the link token has its own standard, ERC 677 that inherits from ERC 20. There's a function called transfer and call. So it sends all this all at once? It sends the token, it sends all the data for the request, and then the oracle will push the data on. And what stops other people from running it? If you make that data public on the blockchain there, it'll be easy for other contracts to access it. But if, you know, like, hey, I need this data for my contract.
01:29:09.276 - 01:29:46.350, Speaker A: My contract paid for it. You can store it in a private variable, a little detail there, private variables, those determine who can access it. But everything in a blockchain is public. So even if we store that data in a private variable, if someone's running the blockchain node software, they can still dig in and find that data. It's just not going to be easier. And other contracts and other accounts won't be able to access it by default. They'll have to run a node and dive in and be a ton of work.
01:29:46.350 - 01:30:39.440, Speaker A: Okay, awesome. Yeah, you guys are just coming up with great questions. Love it. All right, we're going down to the last service available for now, the chainlink VRF, our verifiable random function, randomness function. So as we've seen, Chainlink is a little bit more than just getting data off chain on chain with keepers. We had this really cool way to automate our smart contracts and even do some off chain computation with our check data inputs. But one of the more pressing needs for off chain computation was to implement a verifiably random number generator.
01:30:39.440 - 01:32:10.940, Speaker A: And so random numbers are used all the time. A lot of times in games, if you've ever played in the lottery, where they roll the balls and stuff, trying to get a random number there, there's a good example, flipping a coin, rolling a dice. A lot of times randomness is used somewhere where we want fairness, where we want everyone to have an equal chance of being selected. And so computers have random number generators built into them. But randomness by its nature is supposed to be something that's unpredictable, in this case, something that's unpredictable, hard to see what it's going to be and generating random numbers because of the nature that it should be unpredictable, nondeterministic. Getting random numbers on chain is really hard because remember, the on chain world is deterministic. And so some old school naive when block Ethereum and smart contracts are still coming out, ways to get randomness was like to read the latest block timestamp and hash it, or just any on chain hash are connecting to making your own centralized oracle and connecting to some off chain resource that can be hacked or manipulated.
01:32:10.940 - 01:33:05.580, Speaker A: And those were hacked and were manipulated. The reason using on chain randomness is so dangerous is because while you might be using the block timestamp or anything from the block header to generate that, some on chain hash, the miners, remember, they build the blocks and they're going to see what that answer is before everyone else, before they transmit their block. And so you're giving the ability to the miners to begin manipulating that randomness. So if it's like a lottery, they can say, hey, I'm not going to submit any block until it gets a random number that selects me to win of that lottery. That's not what we want. So enter the chain link VRF the chainlink VRF brings a solution to bring provably random numbers to the blockchain. So we're going to remember this is about math based agreements.
01:33:05.580 - 01:34:04.080, Speaker A: We want to prove that what we're doing is good using math. Math is cryptography. So when a contract requests data from the chaining VRF, that contract can verify using cryptographic methods that the number was indeed generated randomly. So it takes some data, it takes some C data within itself and generates random number and posts that on chain along with the proof. So, yeah, a lot of interesting use cases come from this true fair randomness on chain. Now, one commonplace we're seeing this is nfts. So using randomness to create randomly generated NFTs with randomly generated stats on them.
01:34:04.080 - 01:35:16.280, Speaker A: So you can prove like, hey, you built this, this is a randomly generated NFT. And actually another demo I'll be doing later in the event involves this. So, yeah, and like nfts gaming, you can see a lot in games where this would be useful. Random number generators are used in games all the time to create sources of chaos, to create fairness, all kinds of things. Maybe you're opening a digital NFT pack, and this digital NFT pack give you skins and items for a game you want to give your users if they're going to be paying for these packs, you want to give your users the assurance that, hey, if there's a one in 100 chance that you get this pretty rare sword, you want to give them that guarantee that it's actually going to be one in 100, that you're not manipulating it on the back end, that something shady isn't going on. So players aren't actually getting these rare items. And that's where the chain link VRF enables very powerful and fair applications.
01:35:16.280 - 01:35:48.192, Speaker A: So let's jump right into the demo then. Same old, same old metamask, Testnet ETH and Testnet link, which we are good for. And we're going to start out the docs, of course, doc chain link. Say it a million times. Yeah. So we're going to go to using randomness. We'll get our introduction, explains basically how it does it.
01:35:48.192 - 01:36:32.640, Speaker A: And if you're interested on the details of the cryptography and stuff, there's some good blog posts. You can read the introduction here and kind of see how all that works. Okay, so we're just going to go ahead and jump right into it. Let's go ahead and deploy the example contract in remix. All right, we have the import statement for this contract which brings in the VRF consumer base. So just like Jalen client, just like the keepers consumer, we have this contract we need to pull in and our state, we have a couple of things here. We have a key hash and fee, which we're going to initialize in the constructor.
01:36:32.640 - 01:37:10.344, Speaker A: And we have our random result where we're going to store our randomness. So VRF and any API work very similarly. They work asynchronously. So we have to make a request and wait for a response to come back. So in our constructor we're going to say, hey, we're taking in this VRF consumer base, we're inheriting from it and we want to initialize that contract we're inheriting from. And we're going to point to the VRF coordinator. This is like the node address in any API.
01:37:10.344 - 01:37:41.716, Speaker A: This is the address of the VRF coordinator on Covan. In this case, detail is here. And then we have our link token address. We need to tell it, hey, this is the link token that exists on Covan. This is the address of that contract. And we need something called the key hash, again, specific to the VRF on every location. And the fee on testnet, the fee is set to 0.1
01:37:41.716 - 01:38:24.790, Speaker A: link. You can always go to the docs to check what the fees are for whatever network you're on. Okay. And just like any API, we have two functions, get a random number and fulfill randomness. Get random number just like any API will send that request out to the chainlink VRF. We have a little require statement here that makes sure that this contract has some link tokens in it because again, making a request we need to pay link to the VRF for the work it's doing. And just like the any API request, after we send it, it's going to return a bytes 32 the request ID of the request that we send out.
01:38:24.790 - 01:39:21.600, Speaker A: Once that request is sent out with a link token, the VRF will compute a random number along with a proof, and the proof will be verified on chain. That will happen in the back end and the VRF will call fulfill randomness, put in the request ID which should match the request ID of our request and also give it that randomness that we requested and it calculated. We'll then take that randomness and we'll store it in our state variable random result. So I'm sure you're getting used to this workflow. Now let's go ahead and do this compiler isn't throwing any errors, have it on autocompile. Let's go ahead and switch our environment to injected web3. Since we're pointing to Covan, it is picking up Covan gas limit and make sure we're pointing to the right contract.
01:39:21.600 - 01:40:11.986, Speaker A: We don't want any of the ones we're inheriting here. We want random number consumer constructor doesn't take in any arguments. We're good, let's deploy confirm. Okay, so we have random number consumer deployed on Covan now and we have our functions again, we won't need to touch fulfill randomness, and this is actually showing up as raw fulfill randomness on this button. That's because we're inheriting from this VRF consumer base and overriding the raw fulfill randomness function. So if you're familiar with object oriented program, that'll make sense. Basically we're just kind of customizing it from that contract, but we're never going to need to call that, that's what the VRF is going to call.
01:40:11.986 - 01:40:47.006, Speaker A: So let's look at a random result. Now we didn't set it up to anything, so it's set to zero. Let's call get random number, let's go. Of course, always, always got to send the link token to the contract. I forget this sometimes, everyone forgets this sometimes. Unfortunately the gas estimation error doesn't give you too much detail about what's going wrong. But if you see that the first thing you should think is, have I loaded my contract link tokens? It can be easy to forget sometimes when you're just in the midst of everything.
01:40:47.006 - 01:41:22.300, Speaker A: So we'll copy our token address from here and let's go ahead and send this contract some link tokens. Again. We'll paste in our address, switch it to link, we'll send 0.3. Again, it's just going to do this metamask thing and put it at zero point 29. We'll say send, confirm, and we'll have to wait for our link token to actually get included in Testnet blockchain. It's waiting in the mim pool, waiting for some testnet miner to pick it up. All right, we're good, we're in.
01:41:22.300 - 01:41:56.470, Speaker A: So our contract has link tokens in it now, enough to pay the fee. Everything's set up. Let's get random number, pay our gas fee. All right. And again, if we click random result right away, it's not going to show because we have to wait for our transaction to get included. We didn't have to wait for the VRF to see the request generate the random number, which it does all of those relatively quite quickly. But the real time consuming part is waiting for the VRF transaction itself with all the data to be posted on chain.
01:41:56.470 - 01:42:59.096, Speaker A: So the VRF can take some time. There's ways to get. No, check this out. This might take it a minute here. Yeah, while this is updating, actually, you know what, I'll just move into comments and look at questions and when we go through we'll come back and we'll see what the random result is. Mike. So Mike says, I don't think it's fair to charge for VRF calls.
01:42:59.096 - 01:43:41.420, Speaker A: I know it'd be cool if this could be free and open and anyone could just make a VRF call for free. But remember, the node is doing actually a lot of cryptographic work on the back end and computation. If we want to make a sustainable ecosystem, there's got to be a way to incentivize node operators to do all that work and run all that infrastructure and have that computation run. But yeah, I feel you. It is like super needed function on the blockchain. Can I use Chainlink VRF from Polygon smart contracts? You sure can. It's actually very popular on Polygon.
01:43:41.420 - 01:44:48.570, Speaker A: A lot of NFT projects and gaming projects go to Polygon because the fees are very cheap there. Blockchain is pretty fast, so if we go back to the docs, we can actually under using randomness we can go to contract addresses and we can see the addresses. And look, Polygon is like one of the first ones that comes up. Polygon mainet polygon, testnet, binance, smart chain, ethereum, Mainet, Covan, Rinkbee that's where the VRf is going. If you don't see a chain here that you want to use right now, it's constantly being integrated with new chains. Always check back in the docs and if not, you can always deploy it. Like if it's an EVM compatible chain, you can always deploy it to another chain or a testnet somewhere else until the VRF is available on the chain you need humanizer says DDoS prevention, correct? Yes, good point.
01:44:48.570 - 01:45:45.684, Speaker A: These fees prevent these nodes from getting spammed. This is a big reason why fees are a thing in general in blockchain, that if things were just open and free, people will and can just spam the service until it goes down, unfortunately. So by adding just a fee, it prevents them from doing that without going broke. If you don't secure millions, you can make your own random numbers on chain. It's not secure, but for low stake applications, doable. Yeah, I see your point, but I'm going to counter there and say that if it's something on chain and there's user value stored in it, that it is important. Under no circumstances should we sacrifice user security to save some money.
01:45:45.684 - 01:46:41.284, Speaker A: So if it's getting a little too expensive, maybe look into ways to sustainably fund your defi app. There's a lot of cool ideas out there. Go to a chain where it's very cheap. On Polygon, I believe the fee is like yeah, the fee is like. So that's really nothing. You can even have the fee it might sacrifice on Ux, but you can have your users load the contract with link tokens and put that cost up to your users. Is there any danger of attack in the time between requesting and receiving random value? That's a great question.
01:46:41.284 - 01:47:57.896, Speaker A: I'm definitely not a blockchain security expert. You can go really in depth with blockchain security, but I can say that the fulfill randomness function, because it's inheriting from this VRF consumer base, it has some safeguards to assure that only the VRF calls fill randomness. It checks the request IDs, make sure they matches. So it is very secure to use amber. What's the incentive to make API calls on chain paying for them versus making the API calls in the JS layer of the app for free? That's a good question. So like I said earlier, any API, since it's using a centralized node for the most part, you can make it where it uses multiple nodes, but that's going to take a lot of effort. Not highly recommended, but since it is going through a single node, this is not something you really want to use in production because we don't want to have a centralized node controlling all the Oracle functions.
01:47:57.896 - 01:48:59.314, Speaker A: You really want to make a decentralized Oracle network. So when you're making it on chain, when you're making any API, it's really useful for hackathon projects, for making MVPs for where you're saying hey, this is going to be a chaining node. Eventually I'm going to put a decentralized oracle network there and they're going to be pushing data or whatever, and it'll be more transparent too than doing it from the JavaScript layer. Remember, the blockchain is all transparent, it's all open, everything will be there, all the logic will be there. You're not obfuscating how the Oracle functions are working behind your JavaScript app. And last, what is the chainlink token used for? Please subscribe as you did. Yeah, so as we've gone through the demo, the chainlink token is like ETH to Ethereum.
01:48:59.314 - 01:49:44.040, Speaker A: It is the kind of gas like token of the network that powers all these chainlink nodes. It gives them the incentives to act properly, it pays them for their work, for their computation, and it prevents DDoS attacks on the nodes, lots and lots of uses for the token within the network. You can google all these things online. Again, the chain link token is not just a regular ERC 20, it is an ERC 677 token. So it adds in its own functionality called transfer and call that helps make all this oracle magic happen as well. All right, thanks for all the question, guys. This has been fun.
01:49:44.040 - 01:50:40.694, Speaker A: Let's move on. So again, summary of what we've gone over today. We talked about the Oracle problem, aka the smart contract connectivity problem, and how Chainlink solves that using decentralized Oracle networks. We talked about DeFi and how Chainlink data feeds really enable the future of really power the engine of DeFi. We need financial data for all these defi apps, and chain link data feeds aren't just price data, they can be any kind of data. We talked about how smart contracts can't just run their own functions, and how we can use keepers to automate running these functions in a decentralized way. We showed how you can access any API using Chainlink nodes and market link.
01:50:40.694 - 01:51:51.662, Speaker A: And finally, we talked about the problems of generating on chain randomness and using the chainlink VRF to generate secure provable randomness and putting it on chain in our smart contracts. That was a lot, but now you understand all of this stuff and now you actually have the tools. I know I've said this before and I joked around about it, but now you actually have the tools to make really powerful math based agreements, the future of the Internet and agreements as a whole, hybrid smart contracts. And I think if you haven't already, once you start doing it, it's addicting. You realize how much potential there is in these smart contracts and all that you can make now that you have the chain link network connecting your smart contracts to outside world. So again, if anything in here didn't make sense to you or you need to review this, this will be back up on YouTube. Please do take your time.
01:51:51.662 - 01:52:21.206, Speaker A: Go at your pace for any of the coding demos, go back to the docs. You see, I went to the docs a know go to stack overflow where ask specific technical questions. We often monitor stack overflow and try to answer them in a pretty timely manner. Go to discord, have discussions, talk with engineers, ask questions there. And yeah, happy building. I hope this gave you the foundation that you needed. I hope you enjoyed this demo.
01:52:21.206 - 01:52:53.774, Speaker A: I had a blast. I love teaching this stuff. So yeah, stay curious out there and I believe a link is being posted for a type form. If you could fill that out, that would be great and give us some feedback on how these demos were. Be critical, let us know. Let me know where I could have done better and what could have been made more clear for you. So thanks for listening and congrats for completing the first day of demos.
01:52:53.774 - 01:52:55.490, Speaker A: See you around in the hackathon.
