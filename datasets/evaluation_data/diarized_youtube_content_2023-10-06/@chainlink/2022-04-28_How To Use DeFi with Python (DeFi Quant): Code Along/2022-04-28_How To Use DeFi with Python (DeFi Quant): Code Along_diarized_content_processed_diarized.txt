00:00:08.690 - 00:00:26.070, Speaker A: Hello, hello, welcome, welcome. We're going to get started in just a minute here. I'm going to post in the discord. Good morning, GM. GM from all over the place. Hello. How are we doing today? Just going to go ahead and finish getting set up here.
00:00:26.070 - 00:01:23.956, Speaker A: Send a little discord announcement. It hopefully everyone is doing fantastic today. Welcome. Hope you're excited because I am. Give a couple of minutes for people to join. How are we doing? We got a couple of people in the chat, excited for this one. Excellent.
00:01:23.956 - 00:01:52.826, Speaker A: You should be. I am too. Welcome. Excellent. Let's jump into it. Hello, everybody. Welcome.
00:01:52.826 - 00:02:24.878, Speaker A: Welcome to the Defi Python quant section. Let me move this mic out of the way. The Defi quant Python workshop. We're going to be learning some really cool skills. We're going to be learning how to programmatically interact with these blockchains, with these defi protocols using Python. Now, I know we've been doing a lot of Javascript throughout this hackathon and throughout these workshops. And the reason that we're going to be using Python here is a, because I love Python and B, because Python is what the traditional fintech world works with.
00:02:24.878 - 00:02:55.230, Speaker A: Anyways, Python is an incredibly powerful language, and if you go to any hedge fund, any quantitative engineering place, any data analysis place, guess what they're using? They're using Python. So that's what we're going to be using here. We're going to be learning how to interact with these Defi protocols in a programmatic way, which is going to be a ton of fun. So seeing a whole bunch of people in the chat excited about Python. All right, great. I hope you're all as excited as I am. Got my giant water bottle here, so I will be hydrated.
00:02:55.230 - 00:03:25.274, Speaker A: And how long is the session? This is an hour long, right? Hack chain link, I believe this is an hour long session. If it's an hour long, I better hop too. Oh, this is a two hour long session. Okay, well, gosh darn well two hour long session. We might go a little bit quicker than that. And by might, I mean we will. Hopefully we go a little bit quicker than that.
00:03:25.274 - 00:03:48.906, Speaker A: But with that being said, let's just jump into it. Let me switch over to code here. I was promised 2 hours. Yes, and once again, got a whole bunch of nothing here, so let me give you something. There we go. Okay, cool. So I'm in my terminal here, but that's not what I want to show you anyways.
00:03:48.906 - 00:04:17.570, Speaker A: This is what I want to show you. The entire code base for what we're doing is on my GitHub, Ave Brownie PI. And this is how we're going to actually be able to go through and work with some of these protocols. Now in my GitHub, I have another repo defi. Where is it? Defi mix. It's another repo that I have. It hasn't been updated in like a year, but it's still solid.
00:04:17.570 - 00:05:14.982, Speaker A: And in here we're working with a couple of different protocols. We do uniswap, some chain link stuff, some aave stuff, so if you want to check out that one alternatively, you absolutely can. But in the repo that we're going to be working out with today, we're going to be programmatically interacting with the Ave protocol. Okay, Ave, now who here is unfamiliar with Ave? Who here is unfamiliar with Ave? I hope people are familiar with Ave, because Ave is probably one of the coolest protocols ever. And if we go to Defi llama and we scroll down, we turn all this stuff on. Ave is consistently one of the largest protocols by total value locked in all of d five. Right now it has almost $2 billion in total value locked across a couple of different chains, which is fantastic.
00:05:14.982 - 00:06:00.538, Speaker A: Avia is what's known as a borrowing and lending protocol. So it allows people to earn interest, borrow assets and build applications. And if we go into the application, which it's hosted on ipfs, and if you want to learn how to host your own website on ipfs, by the way, 100%, go to the workshop tomorrow, because tomorrow morning and tomorrow afternoon, we are going to be going over building a full stack application, hosting it in a decentralized manner on ipfs, which is what Ave is doing here. Good job, Ave. Clap, clap, clap. We can see if we connect our wallet, connect to our Metamask here, let me switch this to mainnet. I believe they have a testnet variant as well.
00:06:00.538 - 00:06:44.654, Speaker A: We can actually come in here and we can borrow and lend our assets, right? So if we scroll down here, we can supply different assets to earn some interest, right? So if we deposit busd, we'll earn 2.5% plus an additional 6% in ave tokens. If we put down die, we'll earn rewards. Faye, frax all this stuff. And if we scroll down, that seems wrong. Yeah, okay, that's definitely wrong. But we can place all these assets down as collateral and gain some percent return on them, which is really exciting.
00:06:44.654 - 00:08:05.858, Speaker A: And then once we have some collateral down, we can take out loans, we can borrow, we can borrow different assets. Now, ave docs, why borrow actually, the Ave docs have some pretty good why would I borrow instead of just selling my assets? So one of the biggest questions when people see this, and this is kind of one of these financial products, is people might say, okay, well, okay, I understand depositing understand depositing money. If I deposit money in here, that makes a lot of sense to me. That cool, that's great, but why would I borrow money? What does that do for me? And whenever you sell assets, you're closing your position on that particular asset. So let's say I have like, let me even jump into a readme here, readme MD because we're going to be learning a lot of finance stuff. So let's say I have one ETH, let's say I have one EtH, and let's look at some other asset. I'm looking at the CRV token and I'm going, wow, that CRV token looks awesome.
00:08:05.858 - 00:08:30.130, Speaker A: I really want to do that CRV token, however. But I don't want to sell my eth. I don't want to sell my eth because if I wanted to invest in CRV, I would have to sell my eth because this is all I have. This is all the money I have in the world is one eth. Oh no. So sad. I would have to sell that one Eth or sell some of it to get curved dow token.
00:08:30.130 - 00:09:18.054, Speaker A: And I don't like that because my investment strategy says I don't want to do that. My investment strategy says I always need to have one eth. I want this one eth. So what can we do? What can we do in this situation? Well, what we can do is we can deposit our one eth into ave. When we deposit it into ave, we'll use this one eth as collateral so we can use this one eth as collateral to borrow, to borrow some assets. And maybe we want to borrow something like die a stable coin so we can deposit our one eth and then we can say, okay, cool, now that I've deposited this one eth, I'll borrow $500 in die. So one eth is going to be about right now, it's like what, two or three grand? We'll say two k.
00:09:18.054 - 00:10:01.974, Speaker A: So I deposit one eth, which has a value of two k, and it lets me borrow $500 in die. And the reason ave lets me borrow $500 in die is because we've deposited our two k. Our two k and eth. If the price of e tanks to something like $499, the Ave protocol is going to take all of your deposit. Sounds crazy, but that's what happens if you don't put down enough collateral. So when you are working with these protocols, you always want to make sure you have enough collateral. Otherwise, it's going to take your money to stay what's called solvent, to stay in the money.
00:10:01.974 - 00:10:31.326, Speaker A: Right. If they're giving out more money than they have, the math doesn't work out. The world doesn't make any sense. Sorry, my quality keeps changing and running around. So we're going to borrow $500 in die, and then we're going to sell die for CRV. And boom, we've just bought die without selling our ETH. So now our total money will look like we have two k eth.
00:10:31.326 - 00:11:04.346, Speaker A: We have $500, $500 in CRV, and then we have negative $500 in die. Boom. Now, it's called being exposed to CRV without loot, without having to remove some of our exposure to ETH. Right. And so maybe this is your investment strategy, this is something you might want to do because you say, hey, price of Dai, which is the dollar coin, I don't think that's going to do very well. I think EtH is going to do well. I think CRV is going to do well.
00:11:04.346 - 00:11:39.026, Speaker A: So I want to leverage up on these assets. So that's one of the biggest reasons that you use a protocol like this. Additionally, technically, when we're doing this in a weird way, we have shorted die. We're betting that the price of die goes down. Let's say the price of die. Let's say we've borrowed 500 die, right? So we've got 500 die borrowed, and the price of die shoots down to a penny or something. Now, we will have $5 of die borrowed.
00:11:39.026 - 00:12:25.682, Speaker A: So it's also a way to short assets, right. If we think they're going to go down in price, we borrow those assets, we sell them, and then we hold other assets. So it allows us to do really advanced financial stuff and do really cool stuff. It allows us to be just way more dramatic with our financial moves. And again, if you don't want to do any of that, you could just deposit your money in here and earn the APY. How is the APY earned? Where is this magical Internet money coming from? How is this APY happening? Well, when you have stuff borrowed, right, let's say when you have your 500 I borrowed, you're actually getting charged interest. So it's going to be plus interest, it's going to be really smaller amount of interest.
00:12:25.682 - 00:12:57.502, Speaker A: And if we look at the borrow section. This APY is how much interest is being charged on people who are borrowing these assets. So you can see how much interest is being charged for people borrowing these assets. And this interest gets paid to the people who deposit. So if you deposit, you can see BuSD is getting an API of 2.5%. So if you deposit busd, you get two per 5% interest gained. If you borrow BusD, you get 3.82
00:12:57.502 - 00:13:22.646, Speaker A: interest lost. So that's how that works. And that's why this is so stinking powerful. Now, something else that I want to point out is Uniswap, one of the most powerful and most widely used dexes, or decentralized exchanges. We are not going to go over how to work with Uniswap. However, Uniswap is a commonplace. It's like basically a household name in web three.
00:13:22.646 - 00:14:12.998, Speaker A: I wanted to point it out because Uniswap is a way to swap assets, right? So let's say you deposited the DAI, excuse me, you borrowed your die and you wanted to go sell it for CRV. You could come to Uniswap, you could say, hey, I borrowed 500 die from Ave, I want to now sell it for crv curve token, and boom, that's how you would do it. So we're not going to be looking at how to use Uniswap in this demo here. However, in that other one that I was showing in this d five PI mix, if you go to scripts swap, you have a swap. I made a swap function. You can check it out, you can use uniswap or sushiswap or whatever router you want to do to just programmatically swap stuff. And it has a short sell function.
00:14:12.998 - 00:14:42.606, Speaker A: I haven't used this in a while. I'm sure it still works, but I have the hiccups. But it's something you can check out too. So we're going to become defi quants today. We're going to learn how to do some really crazy stuff with Python. So I used to work at a hedge fund, and this is pretty much exactly what hedge fund people do, right? They have all these python scripts to buy and sell programmatically. They have these crazy algorithms that run where they figure out, okay, here's what the price of this asset is.
00:14:42.606 - 00:15:20.558, Speaker A: We're going to buy, sell, we're going to short, long, we're going to do this stuff. And Ave would be exactly the type of protocol they would need to be successful there. So we're going to learn all these crazy cool quantitative investment strategies. We're going to learn how to programmatically invest, programmatically work with these protocols, and just be super badass. So, any questions before we start? I know I kind of went over a lot of stuff right here very quickly, but again, the takeaway Ave is a decentralized protocol. Defi is just like this amazing thing. I really can't understate that.
00:15:20.558 - 00:15:59.050, Speaker A: Defi literally allows us to engage in finance in a censorship resistant way, in a truly fair way, and in a transparent way, a more accountable way, and it just fixes finance in so many ways. So I'm going to give you the skills to go out there and go do amazing things. We're not going to talk about flash loans. If we have time, we'll talk about flash loans, but we're not going to talk about flash loans. Okay, any questions? What happens if I deposit ETH and borrow CRV, and again, deposit that CRV and borrow other assets many times can be done. Great question. So, for most of these, they have what's called a loan to borrow or a loan to value ratio.
00:15:59.050 - 00:16:56.794, Speaker A: And this is to, once again, make sure the protocol never lends out more money than it has. So if I deposit $100 in ETH, I usually can only borrow to a maximum of something like $80 in die, right? If I could do $100 in ETH and borrow $100 in die, I could just use the $100 in die I borrowed to put down more eth to borrow more die to put down more eth to borrow more day, and do that infinitely, which could be potentially catastrophic for the protocol. But so they have these loan to borrow ratios where the max amount you can borrow might be like $80 or less. And you can usually see those in the docs, you can see it directly on chain ave docs, borrowing faq. How do I borrow? How much can I borrow? Check out depositing and earning FAQ section. How much do I earn? Blah, blah, blah. Is there a maximum minimum amount to deposit? No.
00:16:56.794 - 00:17:15.486, Speaker A: How do I withdraw? It's somewhere on here. Liquidations, flash loans, blah, blah, blah. It's somewhere on here. Risk parameters. Here we go. Okay, here we go. So something like die, it's cool.
00:17:15.486 - 00:17:43.098, Speaker A: Finance d, you can't use it as collateral. There's no loan to borrow ratio. Oh, this is ave v two. All right, whatever. But something like die, 75% loan to value. So if you put down $100 in die, you can borrow $75 and people can liquidate you at 80%. So if you have more than 80% of your collateral borrowed in die, somebody can liquidate you and take your money.
00:17:43.098 - 00:17:58.590, Speaker A: So that's how that works. Hopefully that's clear. And that's ave v two. Oh, they got rid of. Did they get rid of ave v one or v three? Oh, whatever. Those are the docs. So cool.
00:17:58.590 - 00:18:11.860, Speaker A: So cool. I love this. Me too. Infinite money glitch lamau. It will be less and less. Yes. Are the triggers on chain for swaps, et cetera? Triggers for what? I'm not sure.
00:18:11.860 - 00:18:38.214, Speaker A: Triggers for what? I'm not sure I follow. Anyways, let's get into this. Let's build a protocol that allows us to borrow and deposit money into aave to do this. All right, cool. So we're going to zoom out a little bit and let's do it. So again, we're doing this in python. So I have an example on how to do this in web three py.
00:18:38.214 - 00:19:00.542, Speaker A: If you want to do that again, that's going to be in my GitHub. But for this one, we're going to use brownie because brownie is awesome. And to get started with brownie, we start with brownie. Init directory is an empty because I got to read me in here. So we'll do brownie init force, force it to create a new brownie project. Okay, cool. Code triggers are the triggers for chainswap.
00:19:00.542 - 00:19:20.710, Speaker A: So you can make code triggers if you want, right. You can trigger swaps. You can have some type of service running to trigger swaps. And if you want to do it in a decentralized context, that would be something like chain link keepers would do for us. Yeah, something like. Yep. Oh, and then one other thing that's super fantastic about Aave.
00:19:20.710 - 00:20:06.726, Speaker A: I mean, everything is open source. You can go to the GitHub. But one of the main things that Aave has is it needs to be able to price your collateral. It needs to know how much collateral you've put down and to do that, and to figure out how much money you've invested in their protocol so that they can figure out how much they can loan out. Guess what they're using? They use chain link price feeds on the back end. So when we're teaching you chain link price feeds, when we're teaching you how to build these smart contracts using data feeds, using keepers, using BRF, we're teaching you the exact same tools that a protocol with almost $20 billion has in it. Right? So we're teaching you what these massive, massive protocols have in it.
00:20:06.726 - 00:20:33.966, Speaker A: Compound is another one, about almost $10 billion is another one that use chain link. Oh, ave V three has its own thing, 6 billion, that's also chain link. So a ton of these massive DFI protocols are using chain link on the back end. Sushi swap uses it for leverage trading using chainlink on the back end to make sure that the applications stay what's called solvent. Yes, thank you. That's my GitHub I'm working. Nice shirt.
00:20:33.966 - 00:21:14.906, Speaker A: Love that shirt. Evan, we're working on getting some of these into a smart contract kit, repo as well. So I've talked for 20 minutes. Let's code for much longer than I've talked for. So in our readme here. So what are we going to do? What do we want to do? What do we want to do? Well, let's start by learning how to deposit money. Deposit money, take out a loan and then repay it all programmatically, all with Ave, all just interacting directly with the contracts.
00:21:14.906 - 00:21:42.902, Speaker A: Right. We could 100% go to the front end and do all this stuff, but we want to automate it, right. We want all this to run based off some algorithms. So we're going to automate this whole thing. So to get started, we're going to be focusing on scripts instead of actually contracts. I know we've worked with Brownie to do contracts, but for this we're just writing scripts. We're just interacting with protocols instead of building these contracts ourselves.
00:21:42.902 - 00:22:08.450, Speaker A: So let's go ahead and we'll get started. So we're going to create a script, new file called Aveborrow Py. And this is going to be our script that's going to borrow these assets for us. And to create a script in Brownie, we do def main like this. Oops, not like that main. And we can do like print. Hi.
00:22:08.450 - 00:22:38.650, Speaker A: And then to run this I would run Brownie, run scripts, Avebar py. And I have a local blockchain running. I got to turn that off. That's kind of really annoying. Sorry, 1 second. Let me switch to the bumper. I just always have a node running at all times, at all seconds of the day because I'm just always doing stuff, you know.
00:22:38.650 - 00:23:10.304, Speaker A: Okay, I think that's good. I think I turned it off. We'll come back. All right, cool. So now if I run it, it's going to spin up our ganache node, which is going to be empty, and we're going to do running scripts, Ave main, et cetera, et cetera. And we got this high thing sput out, which is great. So let's write some scripts in here up.
00:23:10.304 - 00:23:29.452, Speaker A: And I lost my, sorry. One more second. There we go. Okay. And we're back. Okay, so first thing we want to do, like we said, is we want to deposit money. And please ask questions as we're going along.
00:23:29.452 - 00:24:13.928, Speaker A: And please stay tuned for the feedback form at the end of this. We'd love to get your feedback. So we want to deposit money. Well, what do we need to deposit money? Well, we first need the account that is going to call the function brownie, if we're working with a local chain, comes built in with some stuff built in with some fake applications that we can use. And if you're following along with here with my repo, I do this thing called get account. It's like this custom function that I made for working with a real network or fake network. We're going to do all of this for working with kind of a testnet or a forked network.
00:24:13.928 - 00:24:50.070, Speaker A: And you'll see what I mean by that in just a minute. But to do this, we're going to say from Brownie, import accounts. And so this will give us a whole bunch of fake accounts work with. And then we'll just say account equals accounts zero. So we'll say, great, we'll grab the first account that Brownie gives us and then we can even do a little print count that address, run our script again. It'll spin up a little ganache thing and it should just print out this account. Oh, account equals, excuse me, accounts zero.
00:24:50.070 - 00:25:16.224, Speaker A: Run this one more time. And this is just going to be our account that we're going to use for pretty much everything, for depositing, selling and everything. So we get this kind of fake little account here that Brownie has given us. Cool. So we have an account. Now what do we need to do? Well, if we go to the ave docs, we can go to the developer docs, which are phenomenal. We'll switch to v two for now.
00:25:16.224 - 00:25:37.030, Speaker A: I know v three just came out. Well, kind of recently came out, but all my examples are in v two and it's pretty much the same anyways. But we need to call some of these functions. We need to call, excuse me, not borrow. We need to call this deposit function. So they have a smart contract that has a deposit function. Here's what the function looks like.
00:25:37.030 - 00:26:22.644, Speaker A: So it takes a deposit function and takes the asset, the token that we want to deposit, how many of those tokens that we want to deposit, who is depositing them, and then a referral code, which is the mug. So we can just leave that at zero. What is going on? We're doing defi quant stuff. I would like to know a real life example of uses of the protocol, like how could this protocol benefit me? Thanks. You are amazing. Hopefully you didn't miss the intro because I went over pretty much how this would benefit you. Doing really advanced finance stuff or just depositing some money to gain interest.
00:26:22.644 - 00:26:52.000, Speaker A: Right. So that's what it does. So we have accounts equals account zero. We know we have to call this deposit function. However, if you've been following along, we know that if we're going to deposit in ERC 20, we're going to need to approve sending the ERC 20 to this contract first. So first thing we're going to need to get is the ERC 20 address. We're going to need to get whatever token that we're going to deposit.
00:26:52.000 - 00:27:19.370, Speaker A: Now, we're going to work with the weth token, weth ether scan. So we're going to deposit what's called wrapped Ethereum. Is this the actual token address? Sure. Doesn't really matter because we're going to do it on a fork chain anyways. We're going to be working with the weft token and we're just going to use the mainnet address here, even though we're not going to go on Mainnet. Right. If you want to, in the repo that I have, I've set it up where.
00:27:19.370 - 00:28:00.676, Speaker A: Let me go back over. I've set it up where it pulls from a config and it picks the address based off the network that you're on, which is really cool. But we're going to use a forked blockchain and I'll explain that in a minute. So doing that, we can just use the main net address. So the main net address of WEF is going to be this address right here. And weth stands for wrapped ether. And weth allows us to use ether as if it were and ERC 20.
00:28:00.676 - 00:28:47.264, Speaker A: And why is it good? Why do we want a rept? Why do we want to work with our ether as if it was an ERC 20? Well, because the rest of the Aave protocol works as if you're using an ERc 20 and just kind of standardizes everything. So west stands for wrapped ether. West allows us to use ETH as if it were ERC 20. And here's the address of that token. You can easily switch between Weth and ETH, no problem. Now what we're going to want to do is we're going to want to call, we're going to want to approve the weth token to be deposited to Ave, we're going to need to call prove on this token here. Now, in order to do anything on the blockchain.
00:28:47.264 - 00:30:00.376, Speaker A: And if you've been following me, you know that I've say this a hundred times, you always need the ABI plus the address to call any that. And before we can even approve, we should get some weth, right? We should get some weth token. So if you go to this wrapped ether contract, go to the contract. We can see some of the functions in here. The way that we get wrapped ether is we just deposit ether and we'll get the weth token in return. Whenever we want to switch back from weth to eth, we call withdraw and how much we want to withdraw and we just burn those weth tokens. So before we can even approve anything, let's create a new script called Getweth Py.
00:30:00.376 - 00:30:42.490, Speaker A: And this is going to get us some weth. And just in case, depending on your Python version, we're going to do underscore, underscore, init, underscore, underscore py to tell Python that there are some packages in here that it can do stuff with. And in here we'll create a function called Def getweth and then we'll have it passed an account. Print high. Actually, not print high. We're going to print getting west. And so we're going to get some wrapped Ethereum from our account here.
00:30:42.490 - 00:31:26.170, Speaker A: Now in order for us to call. So we're assuming you have some ethereum in order for us to call this deposit, what are you going to need? We're going to need the ABI and the address. Always going to need those two. So how do we get the ABI? Well, one of the things we can do is we can populate this interfaces folder with the interface and then compile it. When you compile an interface, you get the ABI just by doing that. So I'm going to cheat a little bit because I already have the interface. I'm going to go to interfaces and I'm going to go to wethinterface Sol and I'm just going to copy this and we're going to go interfaces, new interface iweth Sol.
00:31:26.170 - 00:32:02.568, Speaker A: It's an in. I'm going to change the name from weth interface to iweth like that better. But this has all these functions in here to interact with the weth contract allowance approve. These are kind of all the ERC 20 stuff, plus these two specific ones to weth and to make sure that it actually compiles, we'll run Brownie compile and project has been compiled. And if we go into build contracts, interfaces, we see iwith JSON has successfully compiled. Okay, great. Oh, this is in init py.
00:32:02.568 - 00:32:35.804, Speaker A: Sorry. Let's put this in getweth. There we go. Now that we have that interface, we can import it into here to get some weth. So we say from brownie import interface and we can say weth is equal to interface iweth. And then all we need to do is pass it the weth token address, which again I'm just going to grab from mainnet here. But again, if you're following along with the GitHub repo, I do some pretty cool stuff.
00:32:35.804 - 00:33:16.536, Speaker A: So we can run it locally, we can run it this, that, and the other way testnet. We can run it a million different ways. And now this is going to be a weth contract. So we can now say Tx equals weft deposit and we call the deposit function. We'll say it's going to be from count and then the value we'll say is 0.1 times one e to the 18th it's just going to be zero. And then we'll do tx weight one and then we'll print 0.1
00:33:16.536 - 00:33:51.908, Speaker A: weth. We're going to use this getwith function to get some wrapped Ethereum, that ERc 20 version of Ethereum so that we can deposit into Ave. So back in our ave borrow. We're going to import that in here we're going to say from scripts get weth import at weth. And we're just always going to get weth. So before we do any improving, we'll say get weth. We'll pass the account.
00:33:51.908 - 00:34:42.980, Speaker A: So this will always get us some weth. Now we can test this. Now we want to test this. We want to test that this getweth is actually working and we're going to test it on once again what I call the main net fork. So what is Mainnet forking? So far we've been deploying to a local network or a real network like a testnet or a main net. Right? We haven't done a fork. What is a fork? What is a forked chain? What's going to happen is we are going to point to a real chain and make API calls and make transactions as if it were a real chain.
00:34:42.980 - 00:35:23.516, Speaker A: But we are just going to simulate it. We're going to simulate transactions being sent and we're going to simulate them on a local chain. We're going to have a local chain. We're going to have our own local blockchain using ganache. And what we're going to do is when we send our transactions, we're going to send them as if they're going to a main net, but our local chain is going to actually run them. So our local chain is going to run these transactions. It's not going to send them to a real main net, but it's going to run them locally.
00:35:23.516 - 00:35:57.740, Speaker A: So we're going to pretend that we're on a real main net. And that's why we can use all these main net addresses because we're going to simulate running the real blockchain on our own local blockchain. Now to get that set up, we create a new file. We'll do Brownie config Yaml. And we're going to create a networks bit in here. And in here we're going to create a network called Mainnet Fork. And then we're going to have the default network main net fork.
00:35:57.740 - 00:36:34.628, Speaker A: And this is where we would put all our weird addresses if we want like some address. And then blah, blah, blah, blah, whatever. You can actually see, you do Brownie Networks list. You can see all the networks that Brownie comes built in with. It has a hardhead fork, a main net fork, all these other chain forks that we can run to fork blockchains. And it comes built in, which is really powerful. Now, Brownie by default works with Infuria.
00:36:34.628 - 00:37:22.040, Speaker A: So in order to get it to work, in order to get this all to work, you can create a env and do export web three infura project ID equals blah, blah, blah, blah, blah. Whatever your web three infuria project id is. However, I prefer to work with alchemy myself. So I'll do like export alchemy alchemy URL. And this is where I'll put like my main net alchemy URL. Right? Any questions so far? I know I'm kind of going over a lot and why don't we just head over to alchemy right now? Over to alchemy. We'll log in.
00:37:22.040 - 00:38:13.320, Speaker A: Actually, I'm going to do switch real quick. I'm going to use one of my dummy profiles, but do the dummy profile for my upcoming hard hat alchemy, my upcoming hard hat video, which is going to be awesome. And now let's switch back. Anyway, so this is what alchemy is going to look like for Mainnet, right? And I've labeled my new thing called forking chain. I could view the key. I'll grab the HTTP key. And what I'll do is I'll head back over to my code and I'll say like alchemy URL equals paste that in here.
00:38:13.320 - 00:38:49.358, Speaker A: And then what I'll often do is I'll do brownie. Networks modify, modify main net fork. Host equals that, I believe that's right. Networks modify host equals that. Fine. All right, cool. So now if I do mainnet fork, I'm going to point to my alchemy RPCrl instead of inferior.
00:38:49.358 - 00:39:31.800, Speaker A: So it's going to use this thing right here, which is great because that's what we want it to do. Cool. And I don't even need to have this env anymore because we just directly updated the network. Cool. So now though, what I can do is I can see if our getwef script actually worked. So what I'll do is I'll run Brownie, run scripts, ave borrow network mainnet fork actually don't even need to do network fork because our default is mainnet fork. So I'm going to delete that and let's see if it worked.
00:39:31.800 - 00:40:48.140, Speaker A: We're going to spin up our ganache chain, which is forking a real main net chain, and we're going to fake running transactions on it. And the first one we're going to do is we're going to fake getting some, depositing some, oh, we into an issue here. Did our RPC call go through fork chain, listening on SEO, dear little print statement here, print getting wealth that again, forking mainet here. And it went ahead and forked, but it didn't. Okay. Able to launch every single but unable to connect. Oh, so it's having a hard time connecting to this for some reason.
00:40:48.140 - 00:43:18.620, Speaker A: Did I get the wrong key? That was the right key, right? It's 1 second here, trying to see if I got the wrong key. It, it's because the, oh, I see, oh, that's why I messed up. Okay, I see what I did. 1 second it I need to change the command. That's what I need to change one more second because instead of host, the host needs to be local host still. And I need to just change the fork instead of the host. Sorry.
00:43:18.620 - 00:44:08.754, Speaker A: Instead of modifying, let's just make a new host. Let's just do that. That'll be easier actually. So instead of modifying the main network, I'm just going to make a new one. So we'll do brownie networks add development, call it cl hack fork, and we'll do CM command equals ganache host equals HTTP 127.0.0 .1 fork equals.
00:44:08.754 - 00:44:37.830, Speaker A: And that's where we're going to put our alchemy URL. On our free tier, we'll say accounts equals ten. Mnemonic equals brownie. And then port equals 85450. No fields. Sorry. Brown networks add development.
00:44:37.830 - 00:44:50.934, Speaker A: Host equals fork equals. Counts equals port. Let's see. Let's spell port, right? What do you think? Port equals that. Great. Now we have this new fork. Seal hack fork.
00:44:50.934 - 00:45:22.760, Speaker A: We're going to use that as our default. We'll go back to config, do seal hack fork. And we can just do that. And now if we run this one more time, we'll do brownie run scripts, ave borrow. And now this should work. Sorry about the. Because now we're going to fork correctly from alchemy, and the host is actually going to be correct as well.
00:45:22.760 - 00:45:54.880, Speaker A: So we're going to make a call. And I still messed up. Does alchemy. A little confused here. Sync requests. Unable to connect. Said I've made eight requests in the past 24 hours to this.
00:45:54.880 - 00:46:44.940, Speaker A: Hmm. Fork equals u key copy paste. Then let's just change the name of this to add a new chain. We'll call it seal hack. Seal hack. That looks fine. Seal hack.
00:46:44.940 - 00:47:15.780, Speaker A: No, it can't find Brony hack or seal hack. Oh, because there's no. It worked that time. Did y'all see what I did differently? I don't know what I did differently. I did some different stuff. Network settings can be edited. Yes.
00:47:15.780 - 00:47:31.420, Speaker A: It's all python. Don't see MVM connection. No. So ganache is running in node. Yeah, that's just for w. So two typo port. So I fixed it, but I'm not sure why I fixed it.
00:47:31.420 - 00:47:49.360, Speaker A: Maybe I would just did a typo somewhere. All right, well, whatever, it's working now. I did something weird there, but we're working now. So thanks alchemy, for being able to connect. And, yeah, if we do a little refresh on the alchemy page here, total request is now ten. Awesome. Cool.
00:47:49.360 - 00:48:39.040, Speaker A: And we were able to successfully get some weth into our application. Now that we've gotten some weth, what do we want to do now? Now that we've gotten some weth, did some live troubleshooting, and I don't know exactly what was wrong, but we fixed it. So, Hazar, now that we've gotten some weth, now we can actually approve weth to send to Ave. So we're going to create a new function called approve ERC 20. And this is going to take an amount a lending pool. A lending pool address. So the address of the ave lending pool, the ERC 20 address that we want to send and then the account.
00:48:39.040 - 00:49:13.340, Speaker A: I can close this now because we don't need to do any more stuff. So we need to pass an amount that we want to approve. Lending pool address. This and this. Now if we go back to the, oh, sorry, now we're on the wrong. Oh no, that is upsetting. What happens when I do that? Oh, that's kind of fun.
00:49:13.340 - 00:49:41.010, Speaker A: We go back to the Ave lending pool. We need the address of Ave, basically. So where is the address of Ave? We'd find the address of Ave. It's somewhere in the docs. But I'm going to cheat because I already have it. So we can find the address of Ave. We'll go to our Browning config and in Mainnet fork.
00:49:41.010 - 00:50:27.074, Speaker A: The lending pool address provider is here. And this is where it's a little bit confusing again because before we can get the lending pool, aka the address of Ave, we have to go to what's called the lending pool address provider. And we can find that in the docs. There's this lending pool, this addresses provider. The lending pool addresses provider. So this is the contract that we need to call to get the address of the ave lending pool because sometimes they change the lending pool address provider. Lending pool address provider here, this address.
00:50:27.074 - 00:51:09.866, Speaker A: And we need to use the lending pool address provider to get the lending pool address. So before we even create this function, we're going to create def get lending pool. And it's not going to take any parameters and we're just going to do, we're going to copy this, paste it down here. Lending pool address provider equals that one. And then to get the lending pool address, we're going to say lending pool equals and we have to call a function on this lending pool address provider. It's got a function called, like, what is it called? It's called get lending pool right here. Get lending pool.
00:51:09.866 - 00:51:31.522, Speaker A: That's the function that we're going to call. And of course to do this, to call getlending pool on the contract, we're going to need its interface. So we're going to copy the interface here, scroll back over to here. In interfaces, we're going to do new file I lendingpool address provider. Sol paste that in here. Boom. That looks phenomenal.
00:51:31.522 - 00:52:21.558, Speaker A: Okay, cool. We're going to say interface I lending pool address provider. At lending pool provider address lending pool address provider. Address lending pool address provider address. There's a ton of words we'll paste that in here, say lending pool address provider is going to equal the interface plus the address. And then we're just going to call, we're going to get the lending pool address by saying lending pool address provider get lending pool. And that's how we're going to get the address.
00:52:21.558 - 00:53:29.594, Speaker A: And then we can get the actual contract by taking this address and sticking it onto a lending pool interface. Now, the interface in the docs do some imports from some local ave stuff. So I'm going to save you all the trouble. I already have it resolved, if you will, in outlandingpool Sol, where we change it to actually calling from AavE contracts. So I'm going to copy this, this whole thing, and I'm going to do interfaces, new file ilendingpool Sol and paste that in here. Of course, since we see that we're doing app Avi contracts, we're going to need to change our dependencies. So if we go to our config config here, we're going to add some dependencies, so we're going to say dependencies and we're going to import from Ave protocol at protocol v two at 1.0.1.
00:53:29.594 - 00:54:42.670, Speaker A: This is the GitHub repo, this is the GitHub organization repo and version. So we're going to download that Ave protocol and then we're going to say compiler, sulk, the mappings. We're going to tell Brownie that anytime it sees at Ave should point to that ave protocol two at 1.0.1. Now in our script Ave borrow. What we can do is we can now with that lending pool address, and now with the interface of the lending pool, we can do lending pool, aka like the ave contract that has the borrowing and lending equals interface lending pool of the lending pool address, and then we'll return lending pool. Boom. So now up here, back in our main function, we can now just say lending pool equals get lending pool.
00:54:42.670 - 00:55:05.260, Speaker A: Cool questions so far. I ran the code a couple of days ago and got some error messages when trying to borrow USDC. USDT fracs or wrap bitcoin. Do you mind addressing that? Sure, Eddie. Let's check Ave. Let's see if Ave even allows you to do that. What the.
00:55:05.260 - 00:55:38.962, Speaker A: Sign me out. That's really annoying. This is my burner account, but we'll give it a password in here anyways. So you tried borrowing USDC, let's look at borrow. Can you borrow USDC? You can borrow USDC, USDT Frex. So they're on here. So they're on here and make an issue.
00:55:38.962 - 00:55:59.210, Speaker A: Right. What is the error you ran into? So figure out what the error was and make an issue on the repo ask question on stack overflow to help debug whatever you're running into. So good question. Thanks for asking any other questions here. Cool. You're all doing phenomenally. Okay, so now we have this lending pool.
00:55:59.210 - 00:56:36.070, Speaker A: Have the address we can finally approve sending our weth to the lending pool. So we're going to create this new approve function down here. We'll do a little print proving ERC 20. Say ERC 20 to call the approve function. We're going to need what? We're going to need the interface. So we'll say interface IERC 20 ERC 20 address. Course we're going to need the IERC 20 to save you the trouble.
00:56:36.070 - 00:57:55.006, Speaker A: Guess what? I already got it in my repo here. IRC 20 sol copy paste interfaces IRC 20 sol paste it in there interface I ERC 20 of the ERC 20 address, which is going to be the wet token. We'll say TX equals ERC 20 approve and we'll pass the lending pool address amount, we'll say from do tx weight one, and then we'll do print approved. Now we'll approve approve ERC 20 that amount, some amount which I don't think we've defined yet. Let's say amount equals what do we want to do for an amount here? Do 0.1 so we can do web three two way 0.1 ether because we're only getting 0.1
00:57:55.006 - 00:58:39.016, Speaker A: on our get weth and I'll do this. Amount equals that. So we'll do amount, lendingpool address, your c 20 address and account. Now, if we run this and simulate what it would look like on a main net or some other chain, we got to download Ave first. So I take it back. We're going to download Ave first while this is downloading. Any thoughts, comments? Questions? So far, interface is not defined.
00:58:39.016 - 00:59:04.560, Speaker A: We got to import interface from brownie, too. Excuse me. Lending pool versus lending pool addresses provider. Lending pool address provider. Did I spell it wrong? I did. Sorry. Lending pool addresses provider.
00:59:04.560 - 00:59:32.450, Speaker A: Excuse me, I spelled the name wrong. All right, lending pool, let's update the names here again. Then I'll answer your question, I promise. Freddie lending pool. Yep, there's no lending pool. There's an I lending pool. So we got to do that instead of lending pool.
00:59:32.450 - 00:59:57.180, Speaker A: Try again. It web three is not defined. Yeah, I got to import web three. Import web three. Excuse them. From web three. Import web three.
00:59:57.180 - 01:00:20.664, Speaker A: Brownie comes built with the web three package. Web three python package. Lending pool address is not defined. I put too many s's. One more time. Here we go. And bada bing.
01:00:20.664 - 01:00:43.300, Speaker A: Okay, so now it's successfully running. We're approving. Yes. So lending pool versus lending pool addresses provider. So in the ave docs, we have a lending pool addresses provider. So this is a contract on chain which points to the different lending pools. So each one of these borrowing and lending pools, each one of these borrowing and lending assets are in what's called like a pool.
01:00:43.300 - 01:01:01.132, Speaker A: And each one of these contracts is at a different address. So we want to ask the lending pool addresses provider first. Hey, where are the lending pools at? Where are the lending pools? It's a good question. Interface. Interface. Stupidly simple. Just learned it.
01:01:01.132 - 01:01:22.072, Speaker A: I use to fetch code from Explorer. Awesome. Yes, that is really good too. Brownie and ApewX have that built in. I'm showing kind of how to do it a little bit the more raw way, but yes, that's kind of like the more advanced but also kind of easier way to do it. Posted the issue to web Ave. Web three pyro.
01:01:22.072 - 01:02:24.176, Speaker A: Awesome. All right, cool. So now we've approved this token, we can finally deposit, print, depositing, deposit. We can call the deposit function on our lending pool. So we'll say lending pool, deposit pass at the ERC 20 address, lendingpool address, not the line, pool address, the amount, the account address, zero. And then we'll say from account. Right, because we're calling lending pool, we're calling deposit, posit address, asset amount, asset amount on behalf of referral code, address amount on behalf of referral code.
01:02:24.176 - 01:02:45.768, Speaker A: And boom. So that's how we're going to deposit. And then we'll do print. Done with deposit. This is the minimalistic code. We just need to deposit code or deposit our tokens. Let's now do some borrowing.
01:02:45.768 - 01:03:39.336, Speaker A: So now let's borrow. Now, there's a function in Ave called, what is it called? Getuser account data. And this tells us pretty much everything we need to know about a user get user count data. It tells us how much collateral they have down in terms of ETH, how much debt they have down in terms of ETH, how much you're available to borrow in terms of ETH, and then your health factor, which this is the number that decides if your loan to value ratio is too low and you can be liquidated. So the health factor is kind of like, hey, you can be liquidated or you can, but we want to get this available. Borrows eth. We want to figure out how much we can borrow in terms of ETH.
01:03:39.336 - 01:05:48.630, Speaker A: So what we're going to do is we're going to call that get borrowable data function, and we're going to call it in a new function. We'll do def get borrowable data, and we'll pass it lending pool and an accounting, and we'll have this call that get borrowable data function. So what does it return? It returns the total collateral. Actually, I'm just going to copy paste because it's a whole bunch of stuff, right? Returns the total collateral in ETH, the total debt in ETh, the available to borrow ETh, the current liquidation threshold, the total loan value and the health factor. So we call lending pool, get user account data with our account, and that's going to get all that stuff. And what we want to do is we can say print f you have, and we can do in some little string interpolation, web three from way total collateral etH, comma, ether, GitHub, copilot, you're being a little aggressive here, buddy. Let's make this a little easier read.
01:05:48.630 - 01:06:47.400, Speaker A: We'll say total collateral, human readable equals web three from way total collateral ether. We'll do the same thing with available to borrow ETH. So, available to borrow ETH, say available borrow, available borrow, human readable equals. And we'll do one more do total debt. So we'll grab total debt in ETH. It's it here, total debt, and eth, we'll say human readable, you have total collateral, human readable eth in collateral copy paste this. You have available borrows, human readable ETH, available to borrow.
01:06:47.400 - 01:07:28.020, Speaker A: Copy paste this once more. You have total debt, human readable etH, borrowed. And then we'll return available to borrow ETH. We'll return this number here. And just to make sure we get it as a big number, we'll wrap it as a float. So we'll get this borrowable data. We'll say avail to borrow equals get borrowable data.
01:07:28.020 - 01:07:59.354, Speaker A: Lending pool and account. And if we run this now, lending pool is not defined. Let me pull. Oh, my goodness. It's because I put all this in the wrong area. Let's fix that. Sorry, that needs to go up here.
01:07:59.354 - 01:08:29.400, Speaker A: Whoops. Here we go. Being our main function where streaming can be kind of annoying. I'm used to coding on a smaller screen, but I got to do it nice and big for the video. So we'll run it again. We're now doing depositing, and we ran into an issue here. I know what the issue is.
01:08:29.400 - 01:09:15.198, Speaker A: TX equals we'll do tx eight one again it, and all these are API calls to alchemy running all these transactions. And great, you have 0.1 eth in collateral, 0.825 eth available to borrow, and you have zero eth borrowed. Perfect. So let's go ahead and borrow some stuff now. So to get pricing here, we're going to need to figure out what asset we want to borrow.
01:09:15.198 - 01:10:27.050, Speaker A: What do we want to borrow here? Let's borrow die. Right? Let's borrow a stable coin because that's pretty common here. So we'll say we'll borrow our stablecoin, but before we can borrow it, we need to know how much dai we can borrow in terms of ETH, not in terms of the, in the GitHub repo. I have a little script here which explains it's called get asset asset price, which grabs the price from Chainlink feeds, which does the exact same thing that aave does in the interest of time. We're just going to hard code it. We are just going to hard code it here and we're going to borrow, um, if we have, you saw we had 0.825 eth to borrow, going to eyeball it a little bit, open up the calculator 0.8
01:10:27.050 - 01:11:10.930, Speaker A: times. What's the price of ETh right now? 2500 EtH price 2900. Cool. So if we have that much to borrow, we're just going to say we're just going to borrow 200 I we're going to borrow $200. We're going to do I to borrow is going to be equal to do the same thing that we did for amount here. Web three two a 200 ether. We're going to borrow 200 die here.
01:11:10.930 - 01:11:42.910, Speaker A: And then we're going to create a new borrow function. Actually, we're not going to create a new borrow function and then we're going to borrow it. So we also need the DAi address so we can find the DAI token address on Mainnet for EtH plore. That works too. We're going to just copy this one. Die address going to be right here. Now we can say lendingpool borrow.
01:11:42.910 - 01:12:37.690, Speaker A: We'll pass the die address. Then again, we can find this in the Ave docs here. Look for borrow address amount, interest rate referral code on behalf of so address amount is going to be die to borrow interest rate mode. One is going to be stable, two is variable. We'll just do stable referral code going to be zero because there isn't one. And then on account of account address say from TX equals TX weight one, then print. You did it.
01:12:37.690 - 01:13:15.582, Speaker A: You borrowed some stuff. Let's run this again. We'll zoom in and whoops, that's weird. There we go. It's a little formatting there. We'll run this again. It depositing approved.
01:13:15.582 - 01:13:37.994, Speaker A: Done. That's how much we have to borrow. And now it's the moment of truth. And you did it. You've borrowed some stuff and we can verify by recalling this function available to borrow and seeing how much we have available to borrow. Thank you for your content. You have helped me build a prototype blockchain game with Godot and Brownie.
01:13:37.994 - 01:14:02.790, Speaker A: Awesome. Will this video be recorded and posted? It will absolutely. It'll be on the Chainlink YouTube so we did it. We've done some borrowing. Now we probably want to be able to repay it back. So let's learn how we can actually repay now. The thing is, we won't be able to repay everything right away because the instant we take out a borrow we're going to start accruing interest.
01:14:02.790 - 01:14:52.582, Speaker A: So we'd have to go to some exchange and we'd have to exchange our tokens to die to get back that interest that we have. So now we'll do some repaying before we can give those tokens back. Give those Dai tokens back. Guess what we have to do? We do indeed have to approve giving those die tokens back. So we'll say approve by to borrow lending pool address I address account and then we can call the repay function. So we'll say TX equals lendingpool repay. And the repay function.
01:14:52.582 - 01:15:42.486, Speaker A: Repay takes the address of the asset, the amount, the rate mode and on behalf of because you can actually repay anybody's. So we will repay the die token address so the DAI address, the die to borrow amount. We're just going to pay exactly how much we borrowed. We won't have paid everything back because there will still be some interest accrued, say stable borrow. So we're going to do one and then this is on behalf of account address and then of course from count and then that will be it. We will be all done here. That is the last thing that we have to do.
01:15:42.486 - 01:16:10.338, Speaker A: So let's just run get borrowable data one more time to see what this ended up being. Run this and let's see how we did. We coded it right this time. I sure hope we did. Done with deposit. You have collateral, you've got this, that, the other thing. You did it and I forgot to do TX weight.
01:16:10.338 - 01:16:38.500, Speaker A: Oh no, I did do TX weight? What does it matter me for? Oh, no, it data. Txt wait. Get barable data. I did TX weight. Oh, I got to do TX wait. Here. TX wait.
01:16:38.500 - 01:17:00.102, Speaker A: Cancel that now let's do it. So we're getting Wes. We're approving the Wes. We're depositing the Wes. We've deposited the weth. Here's what we currently have. You did it.
01:17:00.102 - 01:17:19.630, Speaker A: Oh, it just went way too fast. So you did it. Here's how much we have borrowed when we do that initial borrow, right, we have this much eth in collateral. And now you might be saying, hey, that's more than we originally had. You're right. That's because we've gained interest. We've gained money by depositing our ETH.
01:17:19.630 - 01:18:04.126, Speaker A: We have this much available to borrow and we have this much borrowed, right? So we've borrowed some eth here. Now we go ahead and at the end we repay it all back. And you see, we have this much eth borrowed, which is a crazy, crazy small number. So basically that means we have 1234-5678 we have this much eth borrowed, which is a crazy small amount because we've gained interest just by borrowing it. Right. We've gained interest by borrowing it. We've also gained interest by depositing it and we've repaid most of it back.
01:18:04.126 - 01:18:50.286, Speaker A: So we're back to almost that zero point 85, but at 0.8299 and some change because we gained a little bit of interest. So that's pretty much it for the video here. So this is how you can start programmatically doing finance, doing these advanced, doing exactly what the web two world does, what the financial world does, but in web three and do some really cool stuff. So with that being said, and I said, this is going to be under 2 hours, and it was under 2 hours, but obviously I knew that we were going to go more than 1 hour, so I left a bunch of time here. Any questions on any of that while I sip from my ginormous water bottle. Any questions? Hopefully that was clear.
01:18:50.286 - 01:19:31.418, Speaker A: Hopefully that made sense. Oh, and before you all drop off, hold on, before you drop off, please take a look at whenever I bring it up, please fill out our feedback form. It's really helpful. It lets us decide if we want to keep doing workshops like this. Which workshops? Everybody like the best. And my computer is not happy with me for some reason. Not letting me post for some reason.
01:19:31.418 - 01:19:40.110, Speaker A: Here we go. Boom. Please click this. Please click that. Survey. Take the survey. It's very helpful.
01:19:40.110 - 01:20:12.200, Speaker A: Or scan the QR code. I should just put this QR code into streamyard, right? I can do that. I can just do this, right? Oh, cool. All right. The logo at the top, right. Please scan that. That'll be the QR code for the feedback form.
01:20:12.200 - 01:20:32.586, Speaker A: Okay. Questions here. Could you explain again how forking works? Yes. So what we do is. And again, QR code right here for feedback, let us know. Feedback, forking. We build a local blockchain.
01:20:32.586 - 01:21:11.050, Speaker A: We spin up a local blockchain, and we have it connected to something like alchemy. Right. Whenever we tell our local blockchain, hey, go to address y, what actually happens is brownie will go, oh, address y. Hey, alchemy, what's the contract? At address y, Alchemy will return the data, and we'll add it to our local blockchain. And so it'll simulate as if we were on that main net, because we're saying, hey, alchemy, could you send us the data from that contract? We want to simulate some stuff. Alchemy sends it back, we run our simulations, and we move on. So that's what forking does.
01:21:11.050 - 01:21:33.630, Speaker A: It allows us to run as if we were on, like, a main network or another network without actually sending those transactions. So it's really, really powerful, especially for stuff like this where we can kind of test out our d five chops. So it's a really cool tool. Hopefully that makes sense. Patrick saying, flattered. Thank you. I don't swim.
01:21:33.630 - 01:21:42.782, Speaker A: I lift, though. I do cross it. I hit 335 on the bench yesterday. That felt pretty cool. Filled out the form. Awesome. Cool.
01:21:42.782 - 01:22:11.614, Speaker A: Any other questions? It. Any other questions? You all right? Cool. Thank you for filling out the form. All right, if there are no more questions here, we can jump off. I'll give everybody a couple more minutes. I know we went through a lot. Hopefully this made sense again.
01:22:11.614 - 01:22:47.270, Speaker A: You can follow along with the repos to get the information. Yeah, I was pretty pumped about that. It was the ugliest bench ever. Ganache, can you walk me through what that is, specifically the testnet simulator? Yes, I can do that. I absolutely can. Ganache Cli. So Ganache is what's known as kind of like a local blockchain, and it's recently been depreciated for Ganache.
01:22:47.270 - 01:23:16.240, Speaker A: It's by the truffle team, the consensus team, and it's just kind of like a local blockchain. So instead of connecting to a real blockchain, it's just a tool for us simulating blockchain transactions. Very similar to hard hat. If you're familiar with hard hat. It's kind of like a fake local blockchain. What is the autocomplete plugin you are using? I'm using GitHub copilot. It's really cool.
01:23:16.240 - 01:23:51.978, Speaker A: Does Chainlink have an internship? I don't think so, actually. Good question. I don't think so. But to be honest, if you're part of the community, if you're engaging, if you're coming to these Hackathons, to me, that's basically an internship. I mean, the chain link hackathon, for example, we've hired a ton of people who've done well at chain link hackathons. To me, you're kind of at one of the internships, and I actually like the web three space for internships way better. I like the web three space in terms of internships and getting jobs and stuff way better because you can actually collaborate with people much easier in web three than in web two.
01:23:51.978 - 01:24:26.914, Speaker A: In web two, if somebody's working at a company, they're going to be kind of closed off about what they're doing. In web three, everything's open source. So you can jump on, you can contribute to packages, you can contribute to issues, you can say, hey, I have this really cool idea. I want to improve your documentation, improve your this, that, the other thing. And that's how a lot of people get jobs and get into the spaces. Right. In my mind, in web three, internships are kind of an outdated thing because you being a part of the community is basically the same thing, and you're going to get way better experience than any internship.
01:24:26.914 - 01:24:57.970, Speaker A: Right. Because at an internship, you're going to be like a desk jockey. You're just going to be way more successful engaging with web three than getting like a traditional internship. I think we have an advocate program, which is very similar, I take it back. And chain link labs also has an advocate program, which is really cool. But I would definitely recommend just jumping into the community, answering questions. Yes, thank you, Evan.
01:24:57.970 - 01:25:36.030, Speaker A: Engage, apply for an advocate position, post educational content, et cetera. Yes, Alex and Evan, spot on. So basically Python just has its own version of ethers, but other than that, it's the same as js, basically. Yeah, I would say the other way around. I would say Javascript is basically the same as Python, but to each their own. Any other questions? These have been great questions. Are there any pros or cons using web three versus brownie? It's really preference, whatever you like.
01:25:36.030 - 01:26:08.710, Speaker A: I like working with Brownie or apeworks just because I really like the framework and it allows kind of me mentally, every single project kind of just uses the same setup, but they both kind of do the same thing. I mean, brownie is built off of web three Py. So to me, brownie is kind of like the higher level abstraction. To me, doing stuff in Brownie is a lot easier. Again, it's built off of web three Py. So web three Py is basically the entire back end. But yeah, it's really just preference.
01:26:08.710 - 01:26:25.310, Speaker A: Do you use brownie with arbitrum? Yeah, I use brownie pretty much everywhere. Again, if you're here, fill out the QR code. It's in the chat as well. Be great. Give us that feedback. Go Python. Agreed.
01:26:25.310 - 01:26:49.542, Speaker A: Cool. All right, everybody. Well, this has been fantastic. Hopefully you all learned a lot. If you haven't filled out that feedback form, QR code right here, please scan it. Fill out the feedback form. Helps us a lot, helps us decide which workshops are good, which workshops are bad, and look forward to you next time.
01:26:49.542 - 01:27:19.660, Speaker A: Tomorrow we've got two amazing workshops. We've got a number of amazing workshops for tomorrow. The ones at the beginning, at the end of the day are run by me and we're going to be doing introduction of full stack. So if you want to build a website using all this stuff, if you want to build a web three application, you 100% want to go tomorrow, because those are going to be fantastic. So with that being said, I'll see you all soon. Good luck on the hackathon, and, yeah, take care.
