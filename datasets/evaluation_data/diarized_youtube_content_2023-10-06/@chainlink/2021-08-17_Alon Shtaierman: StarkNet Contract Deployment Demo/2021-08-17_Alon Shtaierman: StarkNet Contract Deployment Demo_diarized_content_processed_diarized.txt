00:00:05.130 - 00:00:45.850, Speaker A: Hi everyone. Now that we're done with that high level overview of exciting stuff in Starknet, it's time to roll up our sleeves and get down with some playing with contracts. So I'm alon, I'm from the Starkware teams engineering team, and I'm going to show you how to write and deploy your first Starknet contracts. First things first. These contracts are written in the Cairo language. It's a language that's been developed in Starkware and is open source and available to everyone. Don't be alarmed if you're not familiar with the language, because we're not going to dive too far into the fine details of the implementation.
00:00:45.850 - 00:01:54.420, Speaker A: But a few words before we start is that the car language was selected because it's optimized to write stark proofs. It's characterized by having immutable memory, which makes it easier to generate these stark proofs, but on the other hand, makes things like writing loops a bit harder. To that end, you'll often see recursion used for loops in the code, much like other functional languages like ML. So next up we're going to be reviewing a very simple startnic contract. It's going to be this very basic template that simply implements a storage for a given balance and allowing us to change its value and read it accordingly. We'll show how to compile and deploy this contract to the Starknet system. We'll show how to track the transactions within that system via the CLI and the Voyager block Explorer, and we'll also discuss different types of interactions with the contract, namely the call and invoke Cli commands which allow you to use the functions you define in the contract itself.
00:01:54.420 - 00:02:45.790, Speaker A: So with that, I'm going to switch over to my vs code. So you should all be seeing this very simple template for our contract. I find it to be a very good example, primarily because it fits on a screen without having to scroll down too much. So what are we looking at? First things first, we have this Lang directive, the Lang Startnet. This is simply to indicate to the Cairo compiler that this code should be compiled for a starknet contract. There are a few differences in the way the Cairo compiler compiles starknet code, most notably that you don't require a main function for this module to compile. We have inclusions of built ins and imports, so imports are relatively self explanatory.
00:02:45.790 - 00:03:26.110, Speaker A: Built ins are just dedicated modules for Cairo that implement some non trivial functionality in an efficient way. Let's get down to the more interesting parts of the contract. So first off, we have our first storage variable here. Now, storage variables that are tagged with this storage VAR are our way of containing information on our contract. In this case, this contract will just hold a somewhat arbitrary balance value which we will manipulate. Next up we have our function. So this contract has two functions, increase balance and get balance.
00:03:26.110 - 00:04:29.220, Speaker A: Now for the external functions here, these are functions that a user is able to interact with in order to change the state of the contract. So in this case, if we look at this storage variable balance, we're able to change its value by calling crease balance. This is what the external tag allows us to do. Now the nice thing about storage variables is that they implicitly implement the two functions which are read that we use here to read the current balance and write which we use to increase the balance by some amount that we pass as an argument to this function. Similarly, we have get balance down here which will allow us to read the value. Now this function doesn't change the state of the contract itself, so we can designate it as a view function right up here. And this allows a user to call this function via the CLI and guarantees that again the state will not be changed by calling this function.
00:04:29.220 - 00:05:45.382, Speaker A: Okay, so we have this basic contract all ready to deploy. So how do we go about and actually uploading it to the startnet system? So I'm going to switch to my terminal and the first thing we're going to want to do is we're going to use the starknet compile command in order to compile our contract. So this command receives our contract contract Cairo as input and produces two outputs, the first being the contract compile JSON which is just our compiled code and the second being our contract ABI which contains information about function declarations and the likes and allows us to then interact with our deployed contract. So we hit here, we can see that we have our compiled code ready to go. So we'll move on and use the deploy command in order to send this contract to the Starknet system. Now note that when I use Starknet deploy, I just provide it with my contract compile JSON, and I get this indication that my contract was sent to the system. So we're going to want to save this contract address because we're going to use this in order to send transactions to the contract.
00:05:45.382 - 00:06:28.150, Speaker A: But for now I've sent a transaction to the Starknet system and I want to keep track to know when my contract is deployed and ready to go. Now there are two ways I can go about doing this. The first is via ClI I can simply use the Starknet get transaction command and provide it with my transaction id given up here. And once I call this just going to wait a few moments and I get information about my transaction. Now note that this transaction is currently pending, which means it's already passed a sequencer. On L2, the final stage for transactions is being accepted on chain. This is when the verifier on layer one has actually accepted the proof generated for a batch of transactions.
00:06:28.150 - 00:07:19.802, Speaker A: Like so. Another way I could have viewed this transaction. So I'm just going to quickly copy this transaction id is via the Voyager block Explorer for Starknet. So this is the explorer specifically for the Starknet planets Alpha. It was made by the very talented netromite team, which are doing a stellar job at constantly upgrading it with our rolling updates to this alpha. Now, just down here I can input my transaction id, and very nicely I can just keep track of important things about my transaction, like the block it was included in, how long ago it was accepted, and so on and so forth. So with this information, I now know that my contract was successfully deployed and I'm ready to interact with it.
00:07:19.802 - 00:07:59.990, Speaker A: So I remind you that we have two functions in this contract, the first being get balance and increase balance. So let's start with get balance. So in order to use a view function, I remind you that get balance is a view function and therefore does not change the state of our contract. I can use the sarknet call command. In order to do so, I want to provide the address of our contract, which I luckily have up here. So I'll just copy it over. I provide it with the contract AbI that we produced when we compiled the code and designate the function that I want to call, which in this case is get balance.
00:07:59.990 - 00:08:34.366, Speaker A: So let's see what we get. All right, so as expected, our current balance is simply zero. So in order to change this, we'll now use the invoke command. So unlike call, invoke allows us to actually send a transaction to the contract and potentially change its state. So once again, I'm going to have to put this contract address down here. Same API. The function that I call is increased balance.
00:08:34.366 - 00:09:17.534, Speaker A: Now, unlike get balance, increased balance receives an argument as input, which is the amount we want to increase the balance by. In this case, we'll just arbitrarily increase this amount by 4000. Okay, so our transaction was sent. It will take a few moments for it to be accepted in the system. I just want to show you that for this same function that supposedly allows us to change the state of the contract. Instead of calling with invoke, we can actually use darknet call on the same function. Now what happens when I use call? So unlike before, when we got this confirmation of a transaction sent to the system, this time nothing dramatic is going to happen.
00:09:17.534 - 00:10:04.080, Speaker A: This is because I simply ran this function locally and didn't commit any transaction to the system. So in fact, even though here I supposedly tried to increase the amount by another 4000 because I didn't send it to the system via starknet invoke, I didn't commit it to the state. It's a good way to dry run certain functions in order to make sure you're not making any mistakes. If I did something that would be illegal for this function, it would also give me the error in advance, which is a nice feature to have. Okay, so let's try and call in, get balance again and see if our balance has changed. Great. As expected, our balance storage variable has increased from zero to 4000.
00:10:04.080 - 00:11:03.098, Speaker A: All right, back to the presentation. So with that, this was a very simple and basic example of starknip and usage. But the possibilities are numerous. We can add users to the system because having just one balance variable isn't very interesting. It would be more interesting to see several users in tracking the balance. For each user individually, we can support signature authentication to make sure that only a given user that provided a valid signature is allowed to increase their balance. We can run much more complicated business logic, integrating inputs from multiple data sources from layer one, for example, in order to make decisions on L2, for example, aggregating prices from various oracles in order to determine the progress.
00:11:03.098 - 00:12:03.602, Speaker A: And the possibilities are numerous and endless. One of our team, our very own Diora Goldberg, implemented a game on start not long ago. So for now I'm just going to switch back to our toy example here, and we'll just take one part of these suggested improvements and add the users to this. So supposedly we want now, instead of having just this one balance variable that keeps track of one global balance, we want a balance for each user. So how do we go about doing this? It's actually easier than it sounds, because all we need to do is we go to this balance variable and we'll add an argument for a user. Now, the one thing I didn't mention about storage rambles when we discussed them earlier is that a storage ramble actually works like a key value store where it maps the given input to a given output. Here it's something simple, it's just going to map a user to their given balance but you can make this as complex as you want.
00:12:03.602 - 00:12:59.770, Speaker A: We can map several arguments to several outputs and we can even create a map to a map and so on and so forth. Of course, now that I've added user to the balance, I also have going to have to add users to the other functions as well. So I'm going to add it as an argument to the increase balance function accordingly to the balance read and write. And likewise I'll add it as an argument to get balance and the read function for balance here. Okay, so in the interest of saving time, I've already went ahead and compiled and deployed this improved contract on Starknet. So to demonstrate, let's increase the balance of some user. So note that this time I'm calling Startnet, invoke on this new contract.
00:12:59.770 - 00:13:35.780, Speaker A: So I have this new address up here. I'm supplying it with its own ABI, which is this time it's just called contract two. Abi I'm going to call increased balance, which this time receives two inputs. So let's take user one, two, three and increase their balance by 4000 and send that to the system. Okay, so our transaction was sent momentarily. We should be able to see the change in that user's balance. Just to illustrate that we have several users in our system, I'm going to call get balance for the user that corresponds to number one and see what their balance is.
00:13:35.780 - 00:14:13.070, Speaker A: So as we can see, their balance is 1000. This is just something I've set up for this example. And if instead of one we provide the user one, two, three, we should see that their balance has increased to 4000 by now. Great. Now again, this allows me to increase the balance of any user I want. Ideally, maybe later on we'd want to add signature authentication, so only a given user is able to increase their own balance and so on and so forth. Let's switch back to the presentation.
00:14:13.070 - 00:15:04.142, Speaker A: Okay, so this is all well and good, but we don't want to just interact with this fake monopoly money. We want to actually work sometimes with real layer one assets. This is where layer one and L2 interactions come into play. So the way layer one to L2 interactions work is this way we have on the left side layer one, which would hold some solidity contract that we wrote, and on L2 we'll have our startnet contract that interacts with it. So the way the interaction works is double sided on one end of the interaction. We have the solidity contract that sends messages to L2. And it uses the startnet core send message to l two function on the left here as input, this function receives the L2 contract address.
00:15:04.142 - 00:16:34.646, Speaker A: We're interested in interacting with the function selector, which is an identifier that allows the operating system to find the relevant function that we want to interact with as well as a payload that contains the information we are interested in sending to that function. Now on L2, in order to receive that interaction we need to designate an appropriate function via the l one handler designator up here. This takes function foo and creates a unique selector for it based on the function name, which is what we pass as an argument to the send message to l two function. So then once the layer one contract sends this message to L2, the startnet operating system will trigger the appropriate layer one handler corresponding to this message and run whatever business logic we incorporate into that function. Accordingly, on the other end of the interaction, when we want to send information back from L2 to layer one. So we have this on the right side, we have the function bar here, and we have the function send message to layer one which as input receives the layer one contract we want to interact with as well as a payload and the size of the payload itself. This function, what it does is it sends this actual message to a dedicated layer one contract.
00:16:34.646 - 00:17:57.910, Speaker A: And then our own layer one solidity contract is then able to invoke the starnet core consume message from L2 function here in order to consume this message after it was delivered. So this is the basics of this interaction. Now we went ahead and we've already written both the L2 contract side which is an expansion on the example we've already seen with the addition of two functions. One is withdraw which allows the user to withdraw funds that they have on L2 back to layer one and the second being our layer one handler which is deposit that allows the user to lock funds on layer one and then redeem them on L2 for their usage. We also implemented the appropriate solidity contract which is actually deployed and we'll show how to use it shortly. But this also implements a withdrawn deposit functions that use the layer one, L2 interactions to pass the information back and forth accordingly. So with that in mind, in the interest of saving time, I went ahead and compiled and deployed this contract and I've already invoked the withdraw transaction up here in order to withdraw 1000 tokens from some arbitrary user.
00:17:57.910 - 00:18:48.150, Speaker A: Now moving back to my browser, we'll move to Etherscan. So on Etherscan, what we're looking at is our deployed solidity contract on layer one. This is just a rope send testnet, but you're all able to use and interact with this contract. We'll go to the functions down here and let us invoke the solidity contract withdraw transaction. So again, this is the L2 contract address from which I withdrew funds. I'll provide the user that I withdrew funds for, which is this arbitrary user here, and let's withdraw these 1000 tokens that I withdrew from L2. So when I hit this, I get this confirmation prompt from metamask and I hit accept.
00:18:48.150 - 00:20:00.362, Speaker A: And if I move on to this get user balance function here and I query, once this is accepted, which will take a few moments, I should see that my balance has increased accordingly. Secondly, once I have these balances back, I can then send the information back to L2 by including my contract address from here given back to that same arbitrary user, and instead of 1000, I can send back 600 of this random asset just to see. Oh, there we go. So now if we read the user balances, we can already see that our balance has actually increased to 1000 as expected. And if I just hit this now, I'll get another confirmation prompt and these funds will be sent back to the system. So here back to my toy interaction with the contract. I can use the get balance method here.
00:20:00.362 - 00:20:44.360, Speaker A: In order to read the balance for the given user, I just need to make sure I provide it with the correct contract address. So I'll just copy it over from what I've written on this contract. There we go. So the user had some balance beforehand, but after withdrawing and depositing it's a bit less of a round number. So I hope that demonstrates that. Okay, so that brings us to the end of this hands on example. Before we depart, a few words.
00:20:44.360 - 00:21:21.844, Speaker A: So this example and many many more are all available in the startnet's documentation. We have an ever expanding resource library available. It teaches things like how to write code in tyro. Deploying and writing startnet contracts includes open source libraries and video examples and much more. And you can find it all if you visit the ww cairo lang.org. Furthermore, we have an ever expanding community. There are upcoming online workshops to be announced via Twitter, so you're welcome to follow us there.
00:21:21.844 - 00:21:34.250, Speaker A: And also we have discord available for developers questions? So join us today. And that's it. That concludes our talk. We'll now have a short q a with the time we have.
00:21:45.580 - 00:21:51.710, Speaker B: Just Ryan Morning is asking you why Starknet over other options?
00:21:54.880 - 00:21:56.750, Speaker C: Why Starknet over other options?
00:21:57.120 - 00:21:57.870, Speaker B: Yes.
00:22:00.800 - 00:22:05.456, Speaker C: As I said, I think it's the. Can you hear me?
00:22:05.638 - 00:22:07.010, Speaker A: Yeah, we can hear you.
00:22:07.380 - 00:23:08.304, Speaker C: Great. I think it's the only scalability solution they offer a new paradigm to. How do we offer scalability in the sense that we don't require. Yes, sorry, I just missed my hi, it does not require the execution of the transaction. So if you actually want to, I don't know, to host Nasdaq or the equivalent of Nasdaq, and still be able to allow anyone to participate in the network, the requirement for the execution of the transaction is just not feasible. So in my point of view, all other scalability solutions right now are near term solutions until they will actually reach the scale limit. And Startnet is the only future proof.
00:23:08.304 - 00:23:08.950, Speaker C: One.
00:23:10.680 - 00:23:32.270, Speaker A: Should also mention that as new Starnet versions are being rolled out, we're making the system more and more decentralized as we go along. Right now, Windows Starknet Alpha, there's just one sequencer, but as we approach the universe release, we're planning to have it as a fully decentralized any other.
00:23:36.900 - 00:23:42.080, Speaker B: I guess lumber asked what was the main idea behind building Starknet?
00:23:44.740 - 00:24:24.670, Speaker C: What was the main idea? So as I've said, we started with Starkx, which was a specific application ZK roll up, and then what we actually understood that the main thing that is missing is the ability for anyone, any developer, to just come write contracts and be able to participate in a scalable environment. So the motivation was to take what we learned in Starkx and to actually expand it into a scalability layer that allows anyone to participate in it. Any more questions?
00:24:25.360 - 00:24:43.190, Speaker B: Yeah, Henry asked, is there an example of an l one contract community directly with an l two contract on Starknet? For example, how can I work with my existing solidity contracts and then offload them for lower gas fees to L2 when needed?
00:24:44.360 - 00:25:52.180, Speaker C: Okay, so great question. It's a little bit two different. So one question is, if I understand correctly, is if I can take my existing solidity code and just port it to Starknet, or how can I use it in stark? So the way we see it is that for the first explanatory like exploration phase, you will be able to use a compiler. But if you would actually want to build a system that use the full capabilities of a L2, which is exactly the example I gave at the beginning with Uidx, you would probably want to write it. But for anyone who wants just to port their code or to have some minimal work and test it, then the compiler will suffice. And with regards to the interaction between n one and l two, then as salon said, you have the documentations and there we have a deployed contract that interacts with an l two contract. So you can see the full flow that alon described and demonstrated live on Rockstone.
00:25:52.260 - 00:25:52.504, Speaker A: Right.
00:25:52.542 - 00:25:55.950, Speaker C: And you can expand it, deploy yourself, do whatever you want.
00:25:56.880 - 00:26:22.020, Speaker A: I want to reiterate that this demo that we presented is point for point. The first few steps of the hello starnet tutorial which we have available. And there are many more subsections following this with more and more examples and ramping up both the complexity, but also the features that you're able to use with this. Just the tip of the iceberg.
00:26:23.480 - 00:26:34.410, Speaker B: Fantastic. There's a couple of questions. One I'll highlight. If you wanted to get feedback from developers watching this presentation, where would they be able to send that to you?
00:26:36.380 - 00:27:11.780, Speaker C: Okay, great. First of mean, you can join the discord if it's okay with you, Dustin. I will post the invite link in the chat so we'll be able to. So you can post it there and also you can dm me. I will also send my handle, which is the handle in every, I don't know, I think everywhere. So you can just reach me through the handle.
00:27:14.920 - 00:27:35.950, Speaker A: Fantastic. I just want to say that we not only provided, but we are looking forward to hearing from you all because every note you have questions are very valuable to us. It helps us fine tweak all these features to make it more readily available and easier to understand for everyone.
00:27:38.080 - 00:27:40.444, Speaker C: Awesome. Another question.
00:27:40.642 - 00:27:41.790, Speaker B: I'll go ahead.
00:27:42.160 - 00:28:29.660, Speaker C: No, I mean, this was my main motivation for deciding to go with the alpha. Even though it's not like you don't get the full experience. Things can get pretty hacky, but we still wanted to release it as soon as possible so people will be able to exactly give us the feedback on what things are expectable, what are not expectable. For example, I can give one concrete question. So we implemented the l one to l two interaction in a specific way. And I would very much like to people to try it out and hear for them. Is this the correct way? Maybe we can change something because now it's a very good step to give those feedbacks because we can change it quite easily.
00:28:32.560 - 00:28:47.250, Speaker B: Fantastic. Yeah, definitely get that feedback to them. Another question is, how are you feeling about the regulatory landscape based on the latest news? Yeah.
00:28:52.020 - 00:29:17.420, Speaker C: I mean, it all depends, I think on token. I mean just the Zika roll up that operates as layered on top of Ethereum. I'm definitely not a lawyer, so I don't know, but I don't think there is any problem with it. I don't know. Once the system wants to have a token, then again, this is a question for the lawyers.
00:29:19.920 - 00:29:29.440, Speaker B: I would say less around token generation and just as a usable interface in the regulatory framework, because it's a ZK based protocol.
00:29:29.860 - 00:30:16.910, Speaker C: Okay. So again, as I've said in the presentation, we internally use the term validity roll up because ZK roll ups, as they are today, do not offer any zero knowledge properties. Right. So the privacy is the same privacy that you have today on any blockchain. Having said that, it is very much more efficient to implement recursive proof verification in a roll up. So the ability to build privacy applications on top of starknet makes much more sense because again, it will be 100 x cheaper or even more.
00:30:20.000 - 00:30:34.150, Speaker B: Fantastic. I guess a lot of people are asking why did you ultimately decide to go with Cairo as opposed to other languages or frameworks that are out there?
00:30:34.760 - 00:31:36.872, Speaker C: Yeah. So I think that the most interesting question is comparing to EVM, right? We had the possibility mean there were some ways to approach it. Jordy made a great talk on ECC about how they plan to approach this decision, but we also had the option to just implement an emulation of the EVM or stuff like that. But this takes me back to the first question, right? Why to use tartmet? So a lot of the design decisions that we made were made from the perspective of how can we generate efficient proofs? Because if you want to use a ZK roll up, which at the end allows you to, I don't know, generate a proof for ten transactions, 100 transactions, you don't actually get scalability. So if we want to offer a scalable solution, then a lot of the design choices that lead us is how can we still make sure that we are able to.
00:31:37.006 - 00:31:41.210, Speaker B: I think we're generating for a second, Tom, just wait a moment.
00:31:42.220 - 00:31:43.930, Speaker C: We're back. Yes.
00:31:47.920 - 00:31:51.340, Speaker B: Could you take us through more around that?
00:31:51.410 - 00:32:50.130, Speaker C: Yeah, we're back to l two. So things can move smoothly. Now I will answer from the beginning. So the question, as I understood it was why do we chose to rely on a new virtual machine, specifically the Cairo virtual machine, and not go with the EVM with Ethereum virtual machine? So it goes back to my first answer on why choosing Starknet. Right. If we want to actually have a future proof system that allows us to scale to really big number of transactions, then part of the design of the things we need to think about in the design choices is what can allow us to generate efficiently proofs. And Cairo is exactly this sweet spot between expressibility and the ability to write whatever logic that we want, and also being super efficient on the proof generation side.
00:32:50.130 - 00:33:31.384, Speaker C: So this was the main reason for us to go death route. And we said, okay, we can go and implement an EVM emulator. And we still, it's, I won't say it's easy, but it's very feasible to implement an EVM emulator on Cairo. One of our devs is like halfway through there and he spent a weekend on it. No, I'm kidding. Anyway. But if we look forward and wants to actually scale and be able to generate huge proofs to huge number of transactions, then those considerations need to be taken in at a very early stage.
00:33:31.384 - 00:33:34.430, Speaker C: So this was our way of thinking.
00:33:37.360 - 00:33:53.430, Speaker B: Fantastic. We got just a couple of minutes left. Is there anything that you would like to highlight at the conclusion of this? To want to either get people excited where you need help, how people can contribute, anything like that? That's top of mind that you would like to leave the audience with.
00:33:56.200 - 00:34:39.010, Speaker C: Again? For me, it's very interesting to build something which is developer facing. I mean, last week or two weeks ago, a project that built on top of Starknet won like a second place in the hackathon. And I mean, it might be minor, but it was very exciting for me. I think the best question, I mean, no offense to anyone else, but the best question is what feedback are you looking for? So I would very much like people to start using it, give us feedback and get on the train as early as possible because I don't know, it's going to be fast pretty soon.
00:34:41.640 - 00:34:46.950, Speaker B: Fantastic. Aylan, do you have any other, any closing remarks that you'd like to leave everybody with?
00:34:48.120 - 00:35:22.290, Speaker A: Only that. Again, we're looking forward to seeing interactions with this alpha and the next versions as they roll out. Our engineering team takes a lot of pride in the work that has been going on and is still ongoing with this development. We're very excited about it. Personally, I love doing these presentations because I get to play with Starknet Mora often and yeah, I'm really hoping to hear from a lot of you in the coming days.
00:35:23.540 - 00:35:45.130, Speaker B: Fantastic. Well, thank you both, Aylan, Tom, for spending your afternoon with us and really appreciate the work that you're doing. And it has to be super exciting to see it out in the wild and being used and excited to see what the next few months and into next year really looks like for you guys. So again, congrats for getting here.
00:35:45.580 - 00:35:46.490, Speaker A: Thank you.
00:35:48.060 - 00:35:54.670, Speaker C: Thanks for this event. It feels like somehow a real conference. So, yeah, well done.
00:35:56.000 - 00:35:57.820, Speaker A: It's not an easy feat.
00:35:58.240 - 00:36:15.640, Speaker B: Yeah, there's so many great people working on it. It's been incredible well, thank you both for contributing to this and making, and being a part of it's.
