00:00:00.330 - 00:00:31.730, Speaker A: Hey. Today we're diving into the world of Ethereum tokens, focusing on the multifaceted ERC 1155. We'll be creating a participation token framework that will be able to airdrop to participants, giving them a token, demonstrating that they completed the event. We'll even have a one off NFT for a special participant. Let's get started. Before we into ERC 1155, let's quickly recap ERC 20 and ERC 721 tokens. Now, ERC 20 tokens are fungible.
00:00:31.730 - 00:00:48.650, Speaker A: That means they're identical to each other. They're interchangeable, like coins. You care about how many you have, not which ones. ERC 721 tokens, on the other hand, are nonfungible tokens. Nfts. Each token is unique, like a collectible or a piece of art. Which specific one you have is important.
00:00:48.650 - 00:01:16.962, Speaker A: The ERC 1155 is like a swiss army knife of ethereum tokens, combining the best of both worlds. It allows for creating both fungible and nonfungible tokens within a single smart contract. So how do you create an ERC 1155 contract? It's pretty straightforward. Let's take a look. So here we have a basic ERC 1155 contract. This example comes from open Zeppelin and it uses their contract as well. Now, open Zeppelin is an industry standard.
00:01:16.962 - 00:01:45.230, Speaker A: If you're not familiar with them, you should definitely check out their contracts. They are battle tested and probably the most widely used contracts for things like this out there. When it comes to this contract civically. Let's walk through what we do. So we import the token standard for ERC 1155 and then we have our contract called game items. Now this contract is going to create both fungible and nonfungible assets. We have things like gold and silver, common things that would be coins in a game.
00:01:45.230 - 00:02:16.338, Speaker A: And then we also have Thor's hammer, which is a unique item. That would be the NFT. And you can see here in our constructor that we create our ERC 1155 and we pass in this URL. Now this URL is going to be where the metadata lives for the different objects. And you'll notice that we have this mint function here. The mint takes in an address that we're minting to, an id for the type of token that we're minting, the number and then some additional data. So we mint the gold and silver and you can see that we're minting a whole lot of gold and silver.
00:02:16.338 - 00:02:41.162, Speaker A: And we pass in our mint function, pass it in the message sender. So that's whoever's creating this contract, they'll hold those tokens. For now we pass in gold. That's referencing the constant above the id of that specific token, and then the quantity, the amount. When it comes to Thor's hammer, you can see there's only one being created and that's going to make it an NFT, right? It's not fungible. There's not a bunch of the same thing being created. It's unique.
00:02:41.162 - 00:03:30.446, Speaker A: So this is a very simple contract that demonstrates how you can both mint fungible and non fungible tokens all within one contract using ERC 1155. But what if we wanted to do something a little more interesting? Like I mentioned, those participation tokens and also that unique token that would be similar to Thor's hammer. How would we do that? Well, let's take a look at a little bit more complex example. Before we dive into that. We need to understand the properties behind our token, the Uri, what is going to be behind each of these different items for creating. So I have a few different JSON files here that we'd need to host on something like ipfs in order to have them in a distributed manner. So we have our collection JSON just to tell us information about the collection itself, what it is, what it's for, an image for that collection, and a link.
00:03:30.446 - 00:04:06.038, Speaker A: If we have an external link in this case, we'll need to take this as well as the JSON for the two different objects. So we have a zero JSON, which is going to be the actual participation awards. This is the thing that will be the fungible token. There'll be a lot of these and we'll have the individual award as well. Now you see that they each have a link to an image here. So what are those? If we take a look at these images, we can see that the unique award is this golden trophy. And if we head back and look at the participation award, you can see that it's a bronze trophy.
00:04:06.038 - 00:04:29.362, Speaker A: Now I just created these using mid journey as something to be a placeholder. But again, this could be whatever you want. So we have our two images, we have our descriptions and our names. We'll need to host these on something like ipfs. Like I mentioned, I'll use a service called Pinata to do this. Now, pinata is basically just a gateway to ipfs. It allows you to interact with ipfs, which is an interplanetary file system.
00:04:29.362 - 00:05:02.538, Speaker A: It's a distributed way of hosting files. The nice thing about ipfs is it gives you a hash when you upload the files so that you know that the file that you're referencing is the one that was uploaded and nothing has changed. If anything changes in the file, then it changes that hash as well. So we'll need to upload those different files to ipfs. We can do that through Pinata, like I mentioned, I'll upload an entire folder and we can see it here. Now, one thing to note, when you're using something like ipfs, it does take a minute for it to propagate. So sometimes it takes a while for this to return.
00:05:02.538 - 00:05:21.966, Speaker A: All right, so once that's uploaded, we can see them here. We can see the different values that what we've uploaded. The important thing to note is this hash id. So we'll be using that momentarily in our actual smart contract. So we had to remix. It's probably the easiest place to deploy a simple smart contract like this. And we have here the basics of our smart contract.
00:05:21.966 - 00:05:40.226, Speaker A: Right, we've got our imports and we've got our contract declared. Now we're importing a few things. We're importing the ERC 1155 standard. We're importing a burnable extension for that so that we could actually get rid of those tokens if we want. We're importing strings and ownable, and we'll see why in just a moment. We then define our contract. Demo pop.
00:05:40.226 - 00:06:04.878, Speaker A: I'm calling it pops for proof of participation. And we have this ERC 1155. It's burnable and ownable. We set up two constants, the pop and the lucky NFT. Those are just ids that we'll be using and they make things a little bit easier for us. So the first thing we need to do is we need to create our constructor. Now, when you create an ERC eleven D five, you'll have a base URi that you're setting for the entire token standard here.
00:06:04.878 - 00:06:27.362, Speaker A: And you'll notice that we have a hash here. We'll replace that in a minute because we'll replace it in several different places in this contract. This is using an IPFS URL. It could be any URL you wanted. Again, we're talking about things in a distributed manner in a trustless environment. So IPFs is a fantastic option for doing that. Our constructor then goes on to mint 100 of the participation tokens and one lucky NFT.
00:06:27.362 - 00:06:59.006, Speaker A: Next, we'll create a URI function to override the one that's already baked into our ERC 1155 standard. Now, the reason we do this is because we want these to be displayed on openc. And OpeNC wants things a little bit differently than the base token standard. So here we'll return the string with the token id baked into it. That way you don't need to do any sort of conversion and replacing id. So when you check for the token id's Uri, you'll get back the specific string for that token id. Next we have a contract level uri.
00:06:59.006 - 00:07:38.778, Speaker A: If you remember, we had the JSON file for the collection. That's what this will do is it'll give us that information for the entire collection. Again, this is something that's a little bit more specific to Opensea and what they're expecting, just to make things show up and be more accessible for the end user. Then we have our airdrop functionality. And this is probably my least favorite part of this entire project, simply because it's not the most elegant, but it's what it needs to be. So we have our airdrop, we pass in the token id. Remember, that's either going to be the proof of participation token or the lucky NFT, and then an array of addresses for the recipients.
00:07:38.778 - 00:08:09.986, Speaker A: So this will let us iterate through an array of recipients. That way we can, one at a time, send them their individual tokens. We'll transfer it, and if the balance is 90, that means we transferred ten and we have one lucky NFT still that hasn't been transferred away. We'll just give it to that person as well. So basically we're setting up that if you're the 10th person to get a participation token, you also get that lucky NFT. We could do whatever we wanted with it, but I just thought it was a fun thing to include here. Now, Erc eleven D five s are normal tokens.
00:08:09.986 - 00:08:43.502, Speaker A: And when it comes to a normal token, you'd expect to be able to transfer it around, right? But we're talking about something like a proof of participation. I don't think it's quite right to be able to say, hey, I went and got this thing, but then I'll give it to you and you can make it look like you were there. So we're going to make them soul bound. That means that the person who receives the token is the only one who can have it. They can get rid of it, but they can't give it to anyone else. So how do we do that? We have this before token transfer function that's part of the ErC eleven D five contracts from open zeppelin. And what those will do is they'll allow us to insert a piece of code that's run before any token is transferred.
00:08:43.502 - 00:09:06.726, Speaker A: Now, it's important to note token transfer includes minting the token. So we need to think about that when we're actually creating this code. When we look at this, we run super before token transfer, what that says is run the existing code that's already there. We want to keep that in place just in case there's anything that was there. And there is. You can look into the Openzeppelin documentation if you'd like to know more. But there is a few checks that are run before token transfers.
00:09:06.726 - 00:09:35.634, Speaker A: Then we require that either the message sender is the owner of this contract, that means the person who deployed it, or that the two address is address zero. That will allow you to burn the token. If not, we throw this error, that token can't be transferred, it can only be burned. Now, one other thing you'll remember, we imported burnable. That allows us to actually have tokens that can burn. You can't just straight transfer the token to the zero address, you have to burn it, which essentially does the same thing. So our contract's basically done.
00:09:35.634 - 00:10:01.290, Speaker A: But there's one last thing that we need to do. We need to go and change the hash here to the actual hash values for our ipfs. So we'll do that now. We'll come in here, we'll grab this value from ipfs, we'll add it to our contract where it says hash here. All right, so we're ready to go. So we'll actually deploy this contract now. And we should see our transaction being confirmed here at the bottom.
00:10:01.290 - 00:10:35.426, Speaker A: Fantastic. At this point, we've actually deployed our contract and we've created those FTs and NFTs, those fungible tokens, the regular tokens and the NFT tokens. If we head to testnets openc IO, we should be able to see them. Now if we paste in that contract address now, sometimes it does take a minute. So we'll come back when this is ready. Opensea has actually seen that transaction and sees the NFTs on their side. All right, so we've refreshed, and now Opensea does actually see these items.
00:10:35.426 - 00:10:56.080, Speaker A: And what's cool here is that you can kind of tell when something's an NFT and when it's not even in this interface. Right. We have our proof of participation. And you'll notice in the top left hand corner there, there's a 100. That means there's 100 of those. And on the lucky winner, there's only one. Right? So from here we can transfer them we can move them around, we can see what that looks like.
00:10:56.080 - 00:11:41.750, Speaker A: So if I go and grab a different wallet address real quick and I open up my contract here, you'll notice we have the safe transfer from, we also have airdrop. And I wanted to show you what airdrop looks like. So we have Airdrop, we have the token id. So our token id for the participation token is zero. We'll put that in here, and here's where you could pass in the recipients. So we'll pass in just the one, but I could pass in multiple if I wanted to. I'll run this transaction, and now I can take this address and I can look at the balance of function.
00:11:41.750 - 00:12:15.634, Speaker A: So this address and token id, zero. And you'll see that there's one now. So they own one of those tokens. If we head back to Opensea, give this a refresh, take a look here at this. You'll notice now there's two owners. That's pretty cool, right? We can see who owns this participation token. Now if I wanted to switch back to the owner of that single token and I wanted to transfer that token, right? So I want to transfer it from myself to a different address.
00:12:15.634 - 00:12:44.074, Speaker A: So I'll go here and I'll grab my other accounts address. There's a lot of account changing when you're moving stuff around. Token id is going to be zero, the amount is going to be one, and we'll pass in no data. And I try to run this, you'll notice I get this gas estimation error and it's going to say that it's going to return. A token cannot be transferred, only burned. So this is where it means I can't send it to someone else. That's really cool.
00:12:44.074 - 00:13:14.336, Speaker A: I think it's awesome to have it kind of stuck with the person who has it. So what if I wanted to get rid of it? I wanted to burn a token. So here we say what account do we want to burn from? And that's going to be the address that we have transferred to. The id is going to be zero and there's going to be one of them. So we can run this transaction and actually destroy that token. So we'll confirm this, we'll wait for the confirmation and then we can take a look and see if that token is actually owned anymore. So it's been mined.
00:13:14.336 - 00:13:34.924, Speaker A: We've got our confirmation there. If we look at balance of and we check again, we can see it's changed to zero now. That's great. So we've actually burned a token that means it's gone. It's gone forever. By burning, what you're really doing is you're sending it to that zero address, but essentially you're destroying the token. So here we have created an ERC 1155.
00:13:34.924 - 00:14:05.668, Speaker A: We demonstrated that we have both a fungible and non fungible token in one contract. And it's really cool that you can kind of link the logic together too, right? That's really powerful. And I think it's really amazing that we can do all of this in one single contract. The other thing is that we have batch transfer and batch burning. We can do things in large quantities. That means that we can do them in one single transaction, which stays as gas. So really, ERC 1155 may start to be the thing that I use more and more.
00:14:05.668 - 00:14:39.070, Speaker A: When it comes to any time that I would like to have two different types of tokens for a single project, why not put them all in one place? So yeah, let me know what you think. Feel free to leave a comment down below what you think about Erc eleven d five s. Are they the future of tokens when it comes to smart contracts? Or is this just some sort of flash in the pan thing? If you haven't already, like and subscribe for more content like this. Speaking of more content like this, what would you like to see in the future? What kind of things, questions? Projects would you like to see built? Let me know in the comments down below and I'll catch you in the next one.
