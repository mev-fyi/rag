00:00:05.050 - 00:01:02.270, Speaker A: I'm going to talk today about fair sequencing services, a platform we're developing as a product at Chainlink Labs. As the name suggests, the goal of the system is to order transactions in a way that is fair, beneficial for users. Before I get into details, let me provide a little background. How are transactions ordered today? The transactions, of course, are submitted by users to a mempool and then taken up by miners. When a miner successfully mines a block, it includes transactions in it. And an important thing to know is that the miner gets to determine how the transactions are ordered in the block, and it does this unilaterally. What this means is that existing systems are centralized, centralized in this temporary and limited way, but nonetheless, they are at least partially centralized.
00:01:02.270 - 00:01:45.962, Speaker A: Well, so what? So these decentralized systems have a touch of centralization in them. Why does this matter? It's not as though miners, for instance, can tamper with transactions. Well, it turns out that the order of transactions, the ordering of transactions, matters a lot. And let me explain this by way of example. Suppose that Alice wants to buy a token on an exchange, say an automated market maker. For example, she'd like to buy some Bob's bubble token, or BBT, for ETh. She submits a transaction to the mempool, and that works its way on chain, and she obtains some quantity of BBT.
00:01:45.962 - 00:02:43.658, Speaker A: So, for instance, she may obtain a price of one eth per BBT. And if the Amm parameters are right, her transaction will cause the price of BBT to rise. Well, this is all well and good, but when Alice submits her transaction to the mempool, it's of course observed by all miners, and it's known of course to the miner that mines her transaction. This miner can take advantage of this knowledge and its ability to order transactions to do the following. It can create two transactions, a buy transaction and a sell transaction, and order its buy transaction before Alice's and its sell transaction afterwards. This is what's known as a sandwiching attack. What's the effect of this? Well, the miner's buy transaction will do exactly what Alice's transaction accomplished originally.
00:02:43.658 - 00:03:35.918, Speaker A: To say, the miner will get 1000 BBT, as Alice would have if the miner were not present, and the price of BBT will rise. Now, Alice's transaction gets processed and she gets some BBT. But the price of BBT has risen, so she gets a little less BBT than she would have otherwise. Her transaction also causes the price of BBT to rise. Now, the miner turns around and sells the tokens that it acquired, and it makes a profit because Alice has helpfully caused the price of BBT to rise between the two transactions submitted by the miner. What's the effect of all of this? Well, Alice is getting fewer tokens, in this toy example, 25 fewer tokens than she would have gotten otherwise. And the miner is making a profit.
00:03:35.918 - 00:04:32.500, Speaker A: Miner sold its tokens for 1025 eth, but only paid 1000. Where's the miner's profit coming from? Out of Alice's pocket, of course. The value exploited by the miner here, extracted from the user, has come to be known to the community as Mev, or minor extractable value. This is a term coined in a paper that my academic group published, led by Phil Diane back in 2019. Now, there are many forms of MeV, and loosely speaking, some are good and some are bad. For example, certain forms of arbitrage are useful in that they communicate price information across markets, across contracts, across chains, or whatever. But things like sandwich attacks and related attacks like front running, which sandwich attacks incorporated are for the most part, clearly bad.
00:04:32.500 - 00:05:06.954, Speaker A: And they're not a hypothetical concern. They happen today all the time. Miners are doing exactly what I described in conjunction with arbitragers. In our paper two years ago, we included examples of the plaintiff cries of users who had lost money, in that case to bots, but equivalently today, potentially to miners. And some of these are really disturbing. Stay at home parent. I day trade to keep my family above water, but this was a mistake.
00:05:06.954 - 00:05:42.410, Speaker A: In order, please send my money back. I have faith in you. This was an accident. I'm a single parent, and so on and so forth. And there's a litany of these online. Perhaps the most disturbing was this one from Rajesh, who gathered up rupee in his village and rolled the dice on a transaction in Dex and was front run by a bot at that time and lost all the money. And one shudders to think what happened to this poor fellow.
00:05:42.410 - 00:06:55.090, Speaker A: So, as I said, this is not a hypothetical concern. What can we do about it? We probably can't eliminate all bad mev, all exploitation of users of this kind, but we can at least build tools that help mitigate the problem by enacting policies for users that are fairer in the sense of reducing the opportunities for miners to take advantage of the ability to order transactions. And this is the goal of fair sequencing services. Just a reminder, in the current model of transaction ordering, it's the miner that decides unilaterally how transactions get ordered. In FSS, the goal is to replace this miner with a collection of nodes, with a set of entities in particular, a decentralized committee to determine how transactions get ordered. And this ordering happens off chain. Natural question to ask is, where are we going to get this committee? Where are these nodes going to come from? Well, it turns out that decentralized oracle networks are actually great ready made committees.
00:06:55.090 - 00:07:40.270, Speaker A: They provide the trustworthiness that is required for this operation. And also, as it turns out, reporting on observed transaction ordering, ordering transactions is a very natural oracle functionality. After all, what do oracles do? They observe off chain behavior or activity. They reach consensus on their observation, and they report their observation on chain. And that's exactly what FSS is doing. We plan to deploy FSS in two phases. In the first phase, we're going to implement what's known as secure causal ordering, or more formally, secure causal atomic broadcast.
00:07:40.270 - 00:08:35.278, Speaker A: The intuition here is that this type of ordering involves no nodes seeing the payload of a transaction, the actual substance of a transaction, before the transaction is ordered. And this idea is actually decades old, dates originally to, I think, the PhD thesis of Mike writer back in the do we accomplish this? Well, very simply using encryption. So here's the idea. Transactions are submitted to the committee in encrypted form. They're encrypted under the public key of the committee. The corresponding private key is secret, shared among nodes in the committee. The committee then decides how to order these transactions and decides collectively on definitive ordering of those transactions before it decrypts them.
00:08:35.278 - 00:09:15.680, Speaker A: The committee performs a threshold decryption once the transaction ordering has been decided upon. This is great because it's hard to front run or otherwise attack transactions you can't see. And by the time the transactions are revealed, it's too late to squeeze in additional transactions. So even a rogue committee member doesn't have the power to extract med from users. It works very well, but it has a couple of limitations. The first is that metadata are not encrypted. For example, you can't encrypt the address from which a transaction has been sent.
00:09:15.680 - 00:10:19.090, Speaker A: And metadata can convey enough information for an adversary to extract value from users to mount attacks roughly like the type that I've described. The other thing it doesn't protect against is what I'll call blind front running. So suppose, for example, there's an ICO and one node in the committee, or some other adversary wants to be the first to buy tokens in that ICO. Well, there's nothing in the properties of secure causal ordering that prevent the adversary from squeezing transactions at the front of a block before other users transactions. So these two limitations of secure causal ordering suggest that it doesn't give us everything we're looking for. Note, interestingly, that secure causal ordering doesn't actually specify the ordering of transactions. It merely says that they need to be ordered before they're decrypted, but it doesn't tell you how they should be ordered.
00:10:19.090 - 00:11:07.294, Speaker A: And this observation is the springboard for the second phase of development we're planning, namely the addition of the Iquitos family of protocols. Iquitos is a set of transaction ordering protocols, actually consensus protocols, with ordering developed within my academic group in work spearheaded by Mahimna Kelkar. And the intuition here is that transactions get ordered according to the time that they're received. In particular, the time they're received by a supermajority of nodes. It's a little bit more complicated than that, but that's the idea. That's the intuition. So if we put iquatas together with the scheme I just described, the secure causal ordering scheme.
00:11:07.294 - 00:11:49.642, Speaker A: Here's what FSS, or the FSS architecture looks like. Transactions are submitted in encrypted form, and they're ordered by iquatos again, roughly according to the time that they're received, then they get decrypted. By putting these two approaches together, we get some nice properties. Iquitos, in particular, prevents attacks of the type that I described earlier against secure causal ordering. Iqitas prevents metadata based and attacks, and to some extent, blind front running. But iqitas does have a limitation. It's potentially stronger than secure causal ordering.
00:11:49.642 - 00:12:45.934, Speaker A: It is in certain network models, but it's sensitive to network adversaries and somewhat complicated to implement. On the other hand, iquatos, as I said, is, in principle, when it's working well, stronger than secure causal ordering. If things go well, iquitos gives you exactly the type of ordering of transactions you're after. If Iquitos fails, though, by also implementing secure causal ordering, we ensure that there's a strong backstop. So if a network adversary is able to manipulate transaction ordering and bypass the security properties of iquitos, secure causal ordering still presents a barrier to manipulation of user transactions. FSS can be used in a couple of different settings. It can be used as a preprocessing stage.
00:12:45.934 - 00:13:31.546, Speaker A: For l one, for example, you can associate particular smart contracts with FSS, or an FSS enabled particular smart contracts. Ordering, though, is increasingly taking place off chain in l two systems. As with the rise of l two systems, the power of miners to order transactions is being the locus of transaction. Ordering is shifting away from miners to l two systems, like roll ups. Well, FSS works equally well for l two systems. L two systems include transaction sequencers, and those transaction sequencers can be FSS enabled. That's it for my presentation.
00:13:31.546 - 00:13:53.010, Speaker A: If you're interested in learning more, I'd encourage you to have a look at the chainlink 20 white paper at the URL given there. Or you can take a look at the two academic papers that I mentioned in the presentation. Thank you. Thank you so much Dr. Jules. Appreciate that presentation.
