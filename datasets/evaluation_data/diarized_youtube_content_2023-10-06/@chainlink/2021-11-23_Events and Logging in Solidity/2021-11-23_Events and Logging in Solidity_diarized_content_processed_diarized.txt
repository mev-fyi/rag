00:00:00.250 - 00:00:17.982, Speaker A: Now, if you've worked with solidity, you've probably seen these things called events before. Or maybe you haven't seen something like events, but you've always wondered how Chainlink or the graph or some of these other off chain protocols work under the hood. And in this video we're to learn about logging and events in solidity, viewing those events on Etherscan and then working.
00:00:18.036 - 00:00:20.426, Speaker B: With them in Hardhat, if you prefer brownie.
00:00:20.458 - 00:01:03.146, Speaker A: We have a separate video on Brownie, and we also have a blog on working with Brownie for this as well. It's the Ethereum virtual machine, or EVM, that makes a lot of these blockchains tick like Ethereum. And the EVM has this functionality called a logging functionality. When things happen on a blockchain, the EVM writes these things to a specific data structure called its log. We can actually read these logs from our blockchain nodes that we run. In fact, if you run a node or you connect to a node, you can make a f getlogs call to get the logs. Now inside these logs is an important piece of logging called events.
00:01:03.146 - 00:01:39.386, Speaker A: And this is the main piece that we're going to be talking about today. Events allow you to print information to this logging structure in a way that's more gas efficient than actually saving it to something like a storage variable. These events and logs live in this special data structure that isn't accessible to smart contracts. That's why it's cheaper, because smart contracts can't access them. So that's the tradeoff here. We can still print some information that's important to us without having to save it in a storage variable, which is going to take up much more gas. Each one of these events is tied to the smart contract or account address that emitted this event.
00:01:39.386 - 00:02:16.470, Speaker A: In these transactions, listening for these events is incredibly helpful. Let's say for example, you want to do something every time somebody calls a transfer function. Instead of always reading all the variables and looking for some to flip and switch, all you have to do is say, listen for event. So a transaction happened, an event is midded, and we can listen for these events. This is how a lot of off chain infrastructure works. When you're on a website and that website reloads. When a transaction completes, it actually was listening for that transaction to finish listening for that event to be emitted so that it could reload or it could do something else.
00:02:16.470 - 00:02:54.910, Speaker A: It's incredibly important for front ends. It's also incredibly important for things like Chainlink and the graph chainlink. For example, in the Chainlink network, a chainlink node is actually listening for request data events for it to get a random number, make an API call, or et cetera. Sometimes there are way too many events and you need to index them in a way that makes sense so that you can query all these events that happen at a later date. The graph listens for these events and stores them in the graph so that they're easy to query later on. So events are incredibly powerful and they have a wide range of uses. They're also good for testing and some other stuff, but you get the picture, they're really sick.
00:02:54.910 - 00:03:20.618, Speaker A: Now that we know what events are, let's look at what they look like, how we can use them, and how we might use them in our smart contract development suite. Now here's what an event is going to look like. We have an event here called stored number. So we have basically a new type of event called stored number. We're saying hey solidity, hey smart contract. We have this new event thing. We're going to be emitting things of typed stored number in the future.
00:03:20.618 - 00:03:57.026, Speaker A: When we emit this event, it's going to have these four parameters. It's going to have a unit 256 for called old number, a UN 256 called new number, a UN 256 called added number, and an address called sender. Now, for the astute people here, you might have noticed that there is another keyword in here, the indexed keyword, and this is a really important keyword. When we emit one of these events, there are two kinds of parameters. There are the indexed parameters and the nonindexed parameters. You can have up to three indexed parameters and they're also known as topics. So if you see a topic, you know that that's going to be an indexed parameter.
00:03:57.026 - 00:04:36.546, Speaker A: Indexed parameters are parameters that are much easier to search for and much easier to query than the nonindexed parameters. In fact, way back in that f getlogs function, it even has a parameter allowing us to search for specific topics. So it's much more searchable than the non indexed ones. The non indexed ones are harder to search because they get ABI encoded and you have to know the ABI in order to decode them. Now this just told our smart contract that there is a new type of stored number, a new kind of event here. We need to actually emit that event in order to store that data into the logging data structure of the EVM. To do that, we need to do something that looks like this.
00:04:36.546 - 00:04:52.746, Speaker A: This is what it looks like when we emit an event. It looks very similar to calling a function. So you call emit and then the name of the event, and then you add all the parameters in there that you like. Here's the full example of a smart contract that has an event and is going to be the example that we.
00:04:52.768 - 00:04:54.294, Speaker B: Walk through in hard hat.
00:04:54.342 - 00:05:24.914, Speaker A: Now, in this smart contract, whenever anybody calls the store function, we're going to emit this event. Here's an example of a transaction where we called the store function with a value of one. Let's look into the logs to see what this event actually is going to look like. An event is going to be broken down like so. The address of the contract or account, the event is omitted from. The topics are the index parameters of the event data. This is the ABI encoded, non indexed parameters of the event.
00:05:24.914 - 00:06:09.662, Speaker A: What does this mean? This means that we took those parameters that were non indexed, we matched them together with their ABI or application binary interface, pumped them through an encoding algorithm, and boom, this is what we got. If you have the ABI, they're very easy to decode. If you don't have the ABI, they are very hard to decode. These non indexed parameters cost less gas to pump into the logs. Now, in this particular contract, since we have verified the code, we've verified the contract, etherscan knows what the ABI is, and we can view this in Deek or decoded mode. Hex mode is obviously the non decoded mode or in its raw hex or hexadecimal or encoded mode. You can read more about the layout of these events in the solidity docs.
00:06:09.662 - 00:06:18.818, Speaker A: All right, now that we've learned about what events are, let's actually jump into hard hit, jump into our code to see what these look like and see how to work with them in our code.
00:06:18.904 - 00:06:45.790, Speaker B: So here we are in our code editor. There are a couple of prerequisites for us to actually work with this technology. We're using visual studio code, of course, but you can use any code editor that you enjoy. We are also working out of this GitHub repository. Link will be in the description, and this also has everything that we need. So we need node js, yarn and git. You can do everything obviously with node version, git version, et cetera.
00:06:45.790 - 00:07:15.590, Speaker B: Additionally, we're going to be working with hard hat. The documentation for Hardhat is also in the GitHub link here. So you can go ahead and work with that. If you want. You can just go ahead and git clone this repo and work from it from there. But we're actually going to set it up from scratch in our repo and set everything up here. So we're going to do Mpx hard hat, and hard hat is going to say hey, what do you want to do? And we are just going to just create an advanced sample project.
00:07:15.590 - 00:07:36.206, Speaker B: You can absolutely use typescript as well. And we're just going to hit enter a whole bunch here, import everything. All right, perfect. Now we have our Hardhat project created. We're going to go ahead and start creating our contract in the contracts folder. So I'm going to go ahead and delete greeter Sol. We're going to create a new contract in here.
00:07:36.206 - 00:08:14.540, Speaker B: We're going to call it simple storage Sol. And this we're going to make our contract to have all these events in here. So first we're going to do an SPDX license identifier of MIT. Then we're going to do pragma solidity carrots 0.8.7 and then we're going to create our contract. So we're going to do contract simple storage and we're going to create a couple of variables in here. We're going to do a unit 256 public favorite number.
00:08:14.540 - 00:08:47.702, Speaker B: And then we're going to create a function called store function. Store un 256 favorite. Or let's do new favorite number in the GitHub repo. It's going to be like underscore favorite number. We'll make this a public function and all we're going to do with this store function is we're going to set favorite number to equal new favorite number. Oops, new favorite number. And.
00:08:47.702 - 00:09:33.614, Speaker B: Perfect. So this is the minimum we want for our contract here. Now we could also additionally add a retrieve function, and that's actually what's in the GitHub repo because this is not public. When it doesn't have visibility specified, it's automatically internal. But we're just going to make it public for the demo here and it'll be the exact same. Now we have this function store, right, but let's say we want a front end or we want maybe even like a chainlink node or some device to get up to date or to listen or to do something. Whenever this happens, we can go ahead and create this event for whenever this number is updated.
00:09:33.614 - 00:10:27.122, Speaker B: Okay, so the first thing that we're going to do is we're going to create an event stored number and we're going to give it its parameters. So we're going to give it a unit 256 indexed old number. And so since this is indexed, it's going to be a topic, right. When we look at it on ether scan, we're going to do a Un 256 indexed new number and just to kind of have some samples for data, we're going to do a Un 256 added number, right. And so this one isn't indexed and then we're going to do address sender. So now we have this new type, basically called stored number. And once we have this, we can actually go ahead and omit this in our store here.
00:10:27.122 - 00:10:58.622, Speaker B: Now typically you'd want to omit after you do the update. We're just going to do it before to keep the code nice and simple. To omit it, we just do emit stored number and then we pass in the parameters, right. So we're going to do the old number which is going to be favorite number here. We're going to do the new favorite number, which is going to be new favorite number. We're going to do the addition of them together. So we're going to say favorite number plus new favorite number.
00:10:58.622 - 00:11:24.870, Speaker B: And then we're just going to do message sender and. Perfect. This is exactly how we can emit an event. So let's go ahead now, and in our scripts we're going to create a new file. I'm actually just going to go ahead and delete this one. We're going to create a new script to actually deploy this contract and then call this store function, right. So we can see what this looks like.
00:11:24.870 - 00:11:52.790, Speaker B: And we could absolutely run tests, but we're not going to run tests here. So we're going to create a new file. We're going to call it deployandstore js. And actually, before we even do that, let's just do a quick sanity check, MPX hardhat compile just to make sure it's compiling correctly. No, looks like we ran into an issue. It's the solidity version. So we're going to go into our hardhat config js and we can go right here to solidity.
00:11:52.790 - 00:12:15.350, Speaker B: We'll do 0.8.7 so it knows to actually compile with the correct one. And perfect. Let's deploy this contract. Let's call this store function and we'll console log those events. Okay, so first we'll do constant hardhat runtime environment. It's going to equal require hardhat.
00:12:15.350 - 00:13:02.134, Speaker B: So we're going to get that hardhat runtime environment and then we're going to do async function main. And this is what's actually going to run when we call this script and then the way that we'll call it, it's going to be down here. So we're going to do main catch error. And this is just kind of the basic syndics for running this recommended by hardapp console error error process exit code equals, equals one. And actually when you start your project it'll be the same thing. And it's mad at me because it wants me to do it like that and it's going to be the prettier. The way I like linting and the way this likes linting are very different, but that's fine.
00:13:02.134 - 00:13:35.534, Speaker B: So first thing we want to do is we're going to do await hard at runtime environment run compile. We're just going to make sure that everything is going to compile correctly. And it's mad at me again because it wants me to do, wants me to do all this stuff. I should update my formatters for this. But then we're going to grab and deploy this. So we are going to deploy this. So we're going to do const simple storage.
00:13:35.534 - 00:14:17.422, Speaker B: Simple storage equals await hard at runtime environment ethers get contract factory. Factory simple storage. So this is going to get our simple storage contract from the contract factory. Then we're going to do const simple storage with a lowercase s equals await simplestorage deploy. And this is all we need to deploy it. Once we deploy it, we're going to do awaitsimplestorage deployed. So this is going to wait for those blocks to go through and everything, and this is really all we need.
00:14:17.422 - 00:15:14.656, Speaker B: You know what? I'm just going to, we're just going to delete all these for now, move to trash so it stops yelling at me. Okay, cool, there we go. So I just got rid of all my formatters and let my vs code do the formatting, so yours might look a little bit different. But in any case, if we go ahead and this MPX hardhat run scripts deploy and store, it'll spin up a local hard hat instance and it'll error out for us because I spelt semi impulse storage, which is definitely not how you spell it, run scripts deploy, it's going to spin up a local hardhat network and we're not printing anything and it's just going to say, cool, you did it, great job, and that's it. Cool. So now what we're going to do though is we're going to actually deploy. We're going to call this store function.
00:15:14.656 - 00:15:55.618, Speaker B: So we're going to do const transaction response equals await simplestorage store one. So we're going to store one. And once we get the transaction response, we're going to wait for the transaction receipt. Transaction receipt. Transaction spell this right too. Receipt equals await Transactionresponse wait. And it's this transaction receipt.
00:15:55.618 - 00:16:45.174, Speaker B: Once we've waited for the blocks to confirm, that's going to have all our events in it. In fact, we could do a console log here, console log of this transaction receipt, and we could see what this transaction receipt even looks like. So it's this massive thing here, right? And again, this is on a local hard hat that automatically gets spun up in the background. And it's got a ton of stuff in it, right? It's got to, it's got from, it's got logs, bloom, block, hash. And then obviously what we're looking for here, which is this logs section. So we have this topics object, which is going to be array, and then we have data, which of course is going to be our data, our unindexed parameters of our event. And if we scroll down a little bit in the events section, we can see actually all the events here.
00:16:45.174 - 00:17:57.710, Speaker B: Again, we can see data, and in here is this object called args or arguments, which is also an array. And this is what we're going to be looking at. In any case, what we can do then is we can do console log, transaction received of events of zero. Since we're only emitting one event args and we can see all those args, right? Old number, two string. Maybe we also want to see new number, maybe we want to see added number, and maybe we want to see sender, right? And then additionally we could do like transactionreceip events just to kind of see everything in the events here. So if I pull this down and I zoom out just a hair, this is our full script here to work with all these events and everything, right? So now if I run this and we'll zoom in again, deploy and store nothing. Compile.
00:17:57.710 - 00:18:14.200, Speaker B: Boom. Sorry, I printed out the events again. Yeah, sorry, I printed out all the events. Let's make this a little easier to read, actually. So it'll just be those arguments. Right. Now let's go ahead and run this.
00:18:14.200 - 00:19:00.594, Speaker B: Now we see exactly what we'd expect. Old number is going to be zero, right? New number is going to be 10, plus one is one. And then we see our address here. And that's perfect. And that's everything that we want to know about events. Events are particularly helpful when you're doing testing as well. For example, in the hard hat starter kit, if you look at some of the tests, whenever we call a chainlink node contract or a chainlink node address, we can see, we can actually get request ids from the events, right? So using events is incredibly important with Chainlink, especially because that's what these chainlink nodes are listening for.
00:19:00.594 - 00:19:42.850, Speaker B: They're listening for the topics, they're listening for these indexed parameters on specific contracts, and that's how they work. And if you want to learn more, you can jump into the smart contract kit chainlink repository, head over to the contracts to see kind of what these all look like. Now that we have everything set up here, let's actually deploy this to a testnet so we can see what this looks like in Etherscan. So in order to do that, we're going to come down to our hardhet config and we're going to add a couple of things in here. So first we're going to add our coven testnet. I'm just going to go ahead and replace Robston with coven here. We're going to add a coven Rpc URL and a private key.
00:19:42.850 - 00:20:29.774, Speaker B: Now, in order for this to work, you're going to need a coven RPCrl and a private key in something like a env file. So we do something like private key equals zero x, blah, blah, blah. And Covid Rpc URL equals blah, blah, blah. Your private key is going to be a private key from your wallet, like metamask, for example. You'd come in, you'd come to metamask, you'd go to account details, export private key, put in your password, you'd grab it, and then you'd place it right in here. Remember to put a zero x at the top. And remember, do not test, do not fiddle with code with a private key that has actual money with it.
00:20:29.774 - 00:20:57.046, Speaker B: Okay? Also, please do not push this to GitHub. Make sure in your git ignore you have env. Please be very careful with sharing private keys. Do not publicize a private key with actual money. I have a separate account for all of my testing that has no money associated with it. And then your coven RPC URL. This can be something like alchemy where you'll log in, you'll create an account, and they'll give you a coven RPC.
00:20:57.046 - 00:21:32.006, Speaker B: It'll be like HTTPs alchemy.com something. Coven something. Once you have those, and once we've updated this to be Covid, you're going to need some testnet, some testnet coven. You can go to faucets, chain link, scroll down to Covid and we can just grab some eth here. Sometimes faucets change from time to time, so be sure to check this page to see what the most updated faucets are. But I've already got some eth in my account, so we're going to go ahead and run this now.
00:21:32.006 - 00:22:06.960, Speaker B: So we're going to do MPX hard hat, run scripts, deploy and store network. Coven. Awesome. It looks like it worked, but let's just be a little bit more explicit. So we'll do console log simplestorage address just so we know where the address of the contract is. Let's run that again. Now that we're going to console log the address, but looks like it's already gone through.
00:22:06.960 - 00:22:31.110, Speaker B: So we're going to grab that address and we're going to go to coven ether scan. We're going to paste that in here and we're going to be able to see our transaction. And we're going to be able to see our contract. So it might take a minute or two for it to actually update. Right. We got to wait for the blockchain to verify everything. But if we refresh, we can see our transaction hash here.
00:22:31.110 - 00:22:52.606, Speaker B: Now if we click it, this is going to be the transaction hash with those events. So if we go into logs here, we can see that's exactly what we do see. Right. So we see topic zero, which is going to be the signature of the events here. And we see index, topic, old number is going to be zero. Old number is going to be zero. Right.
00:22:52.606 - 00:23:24.174, Speaker B: And that's exactly what this stands for. New number is going to be one. And that's what this stands for. And then we have data here which we can look at as a number and an address, which is one because this is going to be our added number, zero plus one. And then sender. Right? So sender is going to be that contract address that sended this. Now, if you want to see this with all the names of the variables and everything, what we can do then is we can actually verify this contract.
00:23:24.174 - 00:24:02.110, Speaker B: So to verify it actually says it right in the readme. We can run this script here. All you'll need is an etherscan API key. So same thing in your env. You'll do etherscan API key equals blah, blah, blah, blah, blah. You'll go to Etherscan, you can sign up for an API key and then just pop it in right here. But once we have it, we can go ahead and run MPX, hardhat, verify network, coven and deployed contract address, which we know is this paste.
00:24:02.110 - 00:24:42.280, Speaker B: And what hardhat will do is it knows that this address is of type simple storage. So it'll stick simple storage into our verification process. And now that it's verified, what we can do is go back to this transaction, go back to the logs, and we can now see, we have everything in here, right? We have stored number, we have the topics, we have these already decoded for us, and we even have the names of all of our data section in here because it's already decoded. Remember, if it wasn't decoded, it would just be this hex thing. But there we go. That's everything about events. I hope you learned a lot and see you next time you.
