00:00:00.090 - 00:00:38.760, Speaker A: Hey, I'm Richard willing, developer advocates here at Chainlink Labs. And in this video we're going to take a look at how to automate a smart contract based on logs. So what does that mean? Within smart contracts you have the ability to emit a log. This is a great way to pass information between one smart contract and another. And we will use logging to emit a log from one contract and cause automation to run in a second contract. So let's dive into the code and see what that looks like. All right, so here we have a very basic simple contract that doesn't do anything except for emitting an event.
00:00:38.760 - 00:01:04.938, Speaker A: Now this contract is called Count Emit log. It has an event wants to count that keeps track of the address of the message sender. The constructor is empty. And then it has a function emit count log, which emits that event that we defined above while sending the message sender along for the ride. Let's go ahead and get this deployed. We've got our injected provider of metamask set up. We'll go ahead and click deploy and we'll confirm this transaction and our contract has been deployed.
00:01:04.938 - 00:01:36.086, Speaker A: Now this contract, let's go ahead and take a look at it on etherscan and we'll take a look at here's the contract that was created and we have our contract. You'll notice it's matching because it's similar to source code that was deployed before and verified. I've already deployed some examples like this. So that's why we're seeing all of this and it lets us know what's here. We can also read the contract and write the contract from ether scam. We'll go ahead and connect our wallet. So we've connected our wallet.
00:01:36.086 - 00:02:12.454, Speaker A: Let's go ahead and emit a log now and see what that looks like. So confirm this transaction and then we should see that show up in this events tab in a moment. All right, I refreshed the page and we have this event wants to count. If we take a look at it, we can see the message sender is my wallet address. Now one thing to know here, the index topic one is a message sender that's going to be important in our actual contract that we'll be automating using this log. We'll head back to remix and we'll look at counter log. Now this contract is definitely more complex than the one that emits the log.
00:02:12.454 - 00:02:44.154, Speaker A: We have a struct for the log structure. We have an interface for log automation that has two functions, one for checking the log and one for performing upkeep. Checking the log is going to be a function that's going to return a boolean and perhaps some data as well to pass along. If we want to actually run our perform upkeep function and perform upkeep is going to be that one that actually does something when we're automating. Our contract is an ilog interface and it has an event counted by. So this contract as well will emit an event. They'll let us know that who counted.
00:02:44.154 - 00:03:19.242, Speaker A: It's kind of to show how information can pass from the log that we're taking in through our contract and as an event out the other side as well. The counted variable is what we'll be actually incrementing. So that's what we're going to be dealing with and automating in this contract. We set it to zero and then we have our check log function, which takes in the log data as well as any additional data that you need here. We're not using it, so it's blank. It's going to return a boolean of upkeep needed as well as perform data. If we need to pass data to our perform upkeep function within this function, we're going to always return upkeep needed as true in this example.
00:03:19.242 - 00:03:54.870, Speaker A: This is a great place. If there's any sort of checks or validations that you want to do with the data coming in from the log, this is where you do that and then you return an appropriate value for that boolean. We're also going to take the log topic one. Remember, that's going to be who called the function to omit the event in our other contract, and we'll save that sender information and pass that into the perform data. So we check the log, we get true back that says, hey, we need to actually do something in perform upkeep. So now we run perform upkeep and perform upkeep takes in that perform data that we're passing from checklog. We'll go ahead and increment counted by one.
00:03:54.870 - 00:04:12.694, Speaker A: We'll get the address of the log sender out of the perform data, and then we'll omit that counted by event. We have our function to convert bytes 32 to an address here at the end. That's just a little helper function. We don't really need to worry about it. All right, so we've got this contract. Let's go ahead and get it deployed as well. All right, our second contract is deployed.
00:04:12.694 - 00:04:42.018, Speaker A: Let's go ahead and take a look at it on ether scan as well. So here we have it. And again, we've got the same thing where this contract is verified because it matches some similar code that's already been verified on Etherscan. If it wasn't verified, you can go through that process yourself. Our contract has a read functionality to check counted and you can see it's currently zero. So now that we've got this deployed, let's go ahead and go to automation chain link and get started registering a new upkeep. We're going to use a log trigger.
00:04:42.018 - 00:05:04.154, Speaker A: This time. We'll click next. And now we need the contract to automate. So this is going to be the one that we want to automate that has the counted value in it. We'll copy the address, we'll put it in here, and because it's verified, it says, hey, this is an automation compatible contract. We'll click next. Now we're going to need the address of the contract that will be emitting the logs.
00:05:04.154 - 00:05:40.434, Speaker A: So we'll grab that from Etherscan as well. We could also grab this from remix if we wanted, click next. Since this is verified, it can also grab the AbI and say, hey, it's got this log called wants to count. Is there any sort of filtering that you want to do on this? We're going to leave that blank so that every message that sender comes through, we'll provide a name, a starting link balance, and we'll register our upkeep. All right, our upkeep is registered. We can now view it and we can see our history here. We can see the trigger information as well.
00:05:40.434 - 00:06:14.458, Speaker A: Now let's go ahead and emit a log. We've already minitted one. That was before we registered our upkeep. So it's only going to take action on logs emitted after it was registered. We'll head back to our contract, we'll go to write contract, we'll connect our wallet again and we can emit that value. Once that transaction is complete, we can take a look at events again, give it a refresh and we can see, hey, we've got our second event here once to count. It looks just like the first event with the same message sender.
00:06:14.458 - 00:07:00.182, Speaker A: If we now take a look at our automation history, give this page a refresh, we can say, hey, look at that. We've got a perform upkeep that took place because of our log trigger. So we head to our second contract, the one that has the value counted and we were to refresh this information counted is now one so the log trigger from the first smart contract has caused this smart contract to update itself. Also, we should have emitted an event, right? Counted by and we've gone ahead and passed through my wallet address into this contract. So we know who activated this automation from a log trigger. So I think this is really powerful. You can now automate your contracts based on the log output of any contract on a blockchain.
00:07:00.182 - 00:07:06.700, Speaker A: And that's huge. Thanks for watching this video and I'll catch you in the next one. You.
