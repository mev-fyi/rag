00:00:00.570 - 00:00:00.878, Speaker A: It.
00:00:00.964 - 00:01:15.854, Speaker B: So we got some people joining. We are live. Let me share this link with you then. Cool, thanks. Everyone who's joining us on YouTube, really excited, going to be building a Fortnite external adapter today. Just dropping this link. Sweet.
00:01:15.854 - 00:01:41.414, Speaker B: Welcome, everyone. Yeah, what is this? Yeah, so we're going to be building a chain link external adapter. So these are how you're able to connect different APIs, different data onto your smart contracts. We'll be getting started here about two minutes or so. Some more people join in. Yeah. Thanks a lot, everyone who's joining.
00:01:41.414 - 00:02:01.780, Speaker B: Really excited to have Harry. Might remember him from the link, my ride hackathon project. Going to be building a Fortnite external adapter today. If you have questions throughout, definitely drop them into the chat, try to get to them at the end.
00:02:04.950 - 00:02:05.566, Speaker A: But otherwise.
00:02:05.598 - 00:02:11.300, Speaker B: It should be pretty straightforward. Yeah, and I could follow along as well if you.
00:02:19.350 - 00:02:19.822, Speaker A: Cool.
00:02:19.896 - 00:02:27.910, Speaker B: Welcome, Mark. Thanks for joining. It's just starting the day for you, right, Harry?
00:02:28.070 - 00:02:30.250, Speaker A: Yeah, 830 in the morning here.
00:02:30.400 - 00:02:34.490, Speaker B: Nice. Yeah. Thanks a lot for starting the day with chain.
00:02:34.830 - 00:02:35.980, Speaker A: That's all right.
00:02:38.110 - 00:02:51.280, Speaker B: Salt in your eye. Yeah. Fortnite. I bet your nephew. Nephew would have loved this one. Someone's asking, how long did it take you to build the link, my ride project?
00:02:52.930 - 00:03:06.680, Speaker A: Well, we did it in two weeks, Matt and I. But in terms of hours, yeah, it was a lot of work, lots of hours, because there's just so many moving parts to it that you had to get working and then we had to test it against the real car.
00:03:08.570 - 00:03:11.366, Speaker B: Did it work the first time on the real car?
00:03:11.548 - 00:03:39.342, Speaker A: No, we had Duncan on the phone with us and he kind of gave us a token to use the car for. We said, oh, hopefully we only need it for ten minutes. But the first time it ended up being a couple of hours to get everything correct with the authorization and things like that. But then once it worked the first time, subsequent times were pretty smooth. Cool.
00:03:39.396 - 00:03:44.990, Speaker B: Well, welcome, everyone who's joining us. Yeah, we'll get started here in 30 seconds. Are you ready to go, Harry?
00:03:45.150 - 00:03:45.860, Speaker A: Yeah.
00:03:47.110 - 00:04:03.686, Speaker B: Sweet. Well, yeah. Thanks a lot, everyone who's joining us on YouTube. Really excited to have Harry Papas joining us from Australia. You might remember him. He won the Chainlink hackathon twice. Two different hackathons that we've done.
00:04:03.686 - 00:04:32.786, Speaker B: He's won a prize and really talented developer within the chainlink ecosystem who's here to show people and help people grow within our community. Today he's going to be building a Fortnite external adapter. So external adapters. Harry will get into this, but it's a way for you to be able to connect any sort of data source to your chainlink. Smart contract. Yeah, and really excited to have you, Harry, and thanks a lot for joining us.
00:04:32.968 - 00:05:02.614, Speaker A: No worries. Thank you. Okay, so just quickly I'll go over the agenda for today. We're going to just quickly brush over what an external adapter is. Then we're going to build an external adapter based on a fortnight API and we're going to test it locally. Then we're going to deploy it to, in this case Google cloud to run as a serverless function, which I'll go through. And then we're going to try use that adapter in a smart contract.
00:05:02.614 - 00:05:55.514, Speaker A: So we're going to actually deploy it to a chainlink node and then create a job spec that uses it and then create a consumer contract. So if I can just share my screen share. Cool. So like Keenan said, an external adapter is basically a way for Chainlink to connect to any API, whether it's payments API or a gaming API or anything. And the way it does this is the external adapter is actually an API in itself. And it's structured in a way so that one side of the API adheres to a certain format that the chainlink node knows about and can communicate with, as you can see here in the Chainlink docs. And then the other side of the API, it's all custom, it depends on what you want to connect to.
00:05:55.514 - 00:06:52.938, Speaker A: So that's just quick overview of what a external adapter is. But there's more info in the Chainlink docs here. So the first thing we need to work out is what are we going to connect to? So in this case, there's a cool little site here called Fortniteapi IO. So everyone knows about the battle royale game Fortnite. What these guys have done is reverse engineered some of the APIs the game uses and they've created an API themselves where they can actually obtain a whole bunch of data from the game. And as you can see, there's a free option here that you can sign up for, which I've done, and there's a whole bunch of endpoints that you can get all kinds of data. So in our case, for the purposes of this demo, we're going to just focus on these two search by account id, and then get global player statistics, and specifically this second one that gets the statistics for a specific player.
00:06:52.938 - 00:07:57.262, Speaker A: So in a real world scenario, you can do a whole bunch of stuff with this data in the kind of gaming world. And just a couple of cool things I thought of just earlier was you could have sort of betting or gaming apps on the blockchain that look at this data and pay, or pay out winnings and things based on who wins matches and things like that. And another thing is you could actually even run a whole esports tournament within a smart contract in terms of the payments. So you can have all the payments in a contract and the contract can then look at the results and then pay prize winnings and bonuses for certain players who maintain kill to death ratios and things like that. But yeah, in this case, we're going to focus on those two APIs and specifically the second one which returns this here. So as you can see, this is the data that it returns. And we're going to focus specifically on getting a where's Qs, on getting the Qs onto a smart contract.
00:07:57.262 - 00:08:38.240, Speaker A: And then the idea is that you're going to do something with that data. So now that we kind of know what API we want to use, you need to basically sign up to this site and you get a free API key. So that's kind of what I got here. So once we've done that, the next thing is now we need to start creating an external adapter. So an external adapter is to use one of the chainlink templates on their GitHub. So they've got multiple templates and in this case we're going to use the one for node Js. But you can actually build an adapter in any programming language you want.
00:08:38.240 - 00:09:23.552, Speaker A: But we're going to take this node Js template that the chainlink guys have made and we're gonna basically use that and modify it slightly to connect to this fortnite API. So the first thing that you need to do is we need to clone the repository for that template. So first we're going to go into. Cool. So there's the command to clone the repository. Okay, so that's all done.
00:09:23.706 - 00:09:31.790, Speaker B: Maybe Harry too. If you could zoom in a little bit on the command, people can kind of see.
00:09:32.240 - 00:09:34.190, Speaker A: Sure. How do I zoom in?
00:09:34.880 - 00:09:38.620, Speaker B: I think if you command plus if you're on a Mac.
00:09:40.480 - 00:09:45.952, Speaker A: There we go. Is that a little bit better?
00:09:46.086 - 00:09:48.050, Speaker B: Yeah, that's a lot better.
00:09:50.420 - 00:10:50.990, Speaker A: I can post this cheat sheet after, or if you want to post it, I sent it to you on the zoom. Okay, so once we've extracted the template into a directory here, we're going to now install the dependencies with yarn. So you'll need yarn for that. Otherwise you can just do NPM install. So once all the dependencies have been installed, we can now start building our adapter. So I'm just going to open it here in my preferred editor, which is visual studio. Okay, all right, let me just open the folder.
00:10:50.990 - 00:11:25.514, Speaker A: Desktop Fortnite. That's better. Cool. So all of the code that you kind of need to focus on in the template is in this index Js, and it's pretty well explained in the GitHub readme for the template. But just quickly I'll go over a couple of things. So you can define custom error messages here. Custom parameters that the external adapter accepts coming in can be defined here.
00:11:25.514 - 00:12:22.902, Speaker A: And then basically you build up a request, you can build up a URL, you need to specify a job ID with every external adapter request and you then pass in parameters to the request which are defined. And then all of that gets put into a final config which then gets sent in a request to the given URL here. And then you get a response back and then you can parse the result to kind of get what you want. And then you do a callback to then return to whatever called the external adapter, or in our case a chain link node down the bottom. There's a few helper functions for cloud service providers, which we'll go into later, but let's just don't worry about them for now. So the first thing we need to do is we need to use this API key that we got from the Fortnite API dashboard here. But we don't want to put it in the code and we don't want to put it on chain.
00:12:22.902 - 00:13:40.050, Speaker A: So a really popular solution is to use what's called this M package in node Js and there's instructions on how to use it here. And essentially what that allows you to do is to store the API key in a file which then gets referenced in the code so you don't actually have the key in the code itself. So to do that I'll just work off the terminal here. We're going to install the m package and once that's installed we are going to create a file, an EMV file, and in that EMV file we are going to put our API key. So now we've got this EMV file here that contains our key. We can actually now use that in our external adapter. So the way to do that is we chuck in a couple of lines of code right at the top of our external adapter.
00:13:40.050 - 00:14:37.094, Speaker A: So this basically says to use the env package and this is the key in the env file. So it's basically saying store the contents of the API key value in this API key variable here to be used in our external adapter. So the next thing we need to set in our adapter are the parameters that are going to be used. So we're not going to worry about these ones. So we're going to throw in some new ones. So looking back at the API for those two functions, sorry, those two endpoints we have search count ID and get global player stats. So the way that I've designed it in this case is we're going to have an action which is either going to be lookup or account and then a value which is going to either contain the username or the account ID hash or whatever that thing is there.
00:14:37.094 - 00:15:24.214, Speaker A: So here is where they've been defined. So action and value is what we expect. So the next step is to now set up the request. So we need to define a validator which essentially validates kind of everything that we send in the request, the job Id we need to have because every chain link request needs a job ID. And then we're just going to replace the rest of these with action value and we're going to define an endpoint. And I've got a bit of logic here which basically says if the action is username set the endpoint to this. Otherwise if it's account, set it to that.
00:15:24.214 - 00:16:22.954, Speaker A: And then based on that we then build up a final URL that we're going to call through the external adapter and we don't actually have to pass in any other parameters to it because it's all in the URL. The only other thing we need to sort out now in the request is the authentication. So in the case of this one we need to pass it in as a header in that format. So what we can do is back in our code we're going to define a header object. So here's the authorization tag and it gets the API key from that EMV file we created earlier. And then we're going to add the header object to the final config. So the last step in creating our external adapter is basically to then do the call.
00:16:22.954 - 00:17:29.262, Speaker A: So the call is done here. And essentially we're just going to change one line here to say in the response, we're going to say if the action is the account action, we're going to return what basically the value that's along this json path which I'll show you in a second. So if it's the other API endpoint, we're just going to return the player ID. Otherwise we want to traverse the JSON and go global stats solo queues. So if we look at my example output here, you've got global stats solo queues. Okay, now once that's done, I'll save that, that should be ready to go. So I've started it with yarn start and it's now running locally on my computer listening on port 80 80.
00:17:29.262 - 00:18:09.546, Speaker A: So the next thing we need to do is test the adapter locally so we can use kel commands in a terminal to mimic a chain link request. So in this case I'm going to do a Kel command. I'm doing a HTTP post to my localhost 80 80 where the adapter is running here we're sending out JSON and this is the JSON here. So like I said earlier, we need to send an ID, but in this case we're going to send zero because we're not a chain link node sending the request. And then in the data section we need to adhere to the spec that we created in the external adapter. So we've got an action and we've got a value. So in this case the action is username, the value is ninja.
00:18:09.546 - 00:18:44.460, Speaker A: We want to see the output of the, we want to find the account of the username ninja. So in this case we got a response here, HTTP 200. And you can see the response here too. We get the account ID back. So let's now test the other endpoint. The. So this is the account one and in this case we're passing in that account ID that we just returned from the previous one.
00:18:44.460 - 00:19:37.158, Speaker A: And as you can see, we got a whole bunch of JSON back. But the final result, as you can see, 49,219 is the kills for this ninja player. So as you can see, the response comes back here successfully. So we now have a completely working external adapter. So once you have this and you want to use it, you can ask someone on the Chainlink discord to host it for you. Or if you have a chainlink node yourself, you can host it yourself or you can also list it on market link here once you've completed it. There's a whole bunch of adapters already on here, ranging from real estate data to, I think there's another gaming one for Halo as well, bitcoin adapters.
00:19:37.158 - 00:20:21.866, Speaker A: So once if you finish an external adapter, you can apply to have it listed on here for others to use it as well. But in our case, what we're going to do is we want to deploy it to a cloud environment to run as a serverless function. So in my case, my preferred cloud provider is Google. And if you go to Cloud, google.com, you can sign up for a free tier account which gives you $300 worth of free credits, I think. And that lasts you for quite a while. So the first thing you need to do to deploy it to a cloud environment is to zip it up.
00:20:21.866 - 00:21:09.954, Speaker A: So we've got our zip command here and once that's done, we now have a zip file that we can upload. So if I go to my cloud environment here. So the benefits of running an adapter on a cloud environment as a serverless function is essentially you don't have to then manage that server. It's running on Google Cloud or Amazon or wherever. As a serverless, it's actually a low cost solution that scales a lot better than running it constantly on an actual server. So the way it works is when someone requests to use your API or function, Google will spin up an instance of it in a VM and then execute. And then when that request is complete, it will then shut it down so you don't constantly have it sitting there waiting.
00:21:09.954 - 00:21:58.460, Speaker A: So it's actually more efficient and a greener solution I guess, too. So there's definitely some benefits into doing that. So in our case, we want to create a Google cloud function and we're going to call it Fortnite EA external adapter. I will deploy it in my region here. We're going to say it's unauthenticated just for the purposes of this demo. Now, very importantly, that API key variable we created earlier in the M file, we need to actually specify it here for Google Cloud to recognize it. So I'm going to go back to my dashboard here and obtain that key again.
00:21:58.460 - 00:22:52.426, Speaker A: Okay, I'm just going to make sure that that's correct. Yes. So the next step is the entry point. So if you remember these functions down here in our adapter that were used for cloud deployments, there was one here called GCP service. So this basically acts as a wrapper so that you can easily run these functions in a serverless environment. So we just need to put this name here in the entry point. And in our case, we don't want to manually type in the code here.
00:22:52.426 - 00:23:58.974, Speaker A: We want to upload a zip file which we created and it should be here. And you need to specify a stage bucket which you can create one if you haven't got any already, and then you go deploy. So that will take probably a minute or two to create. So in the meantime what we'll do is we'll move on to the next step before we test. So I've got a chainlink node running on Google Cloud here and what we're going to do is the idea is to then take this adapter and add it to a chain link node so that we can then use it in requests. So the first thing that we need to do is we need to basically add what's called a bridge so that the node can recognize it. So when you deploy a function in Google cloud you get given a URL basically.
00:23:58.974 - 00:24:53.234, Speaker A: And what we've done is we've taken note of that URL and we've created a bridge here where you just give the bridge a name and then you just put the URL in and you can set confirmations and minimum contract payments if you want. But for the purposes of this demo we'll leave it as is. So that's all you need to do. So now this chain link node can recognize the external adapter and you can actually use it to create jobs. So let's see if our adapter has been deployed. So what we're going to do next is while that's still deploying we're going to actually add this adapter that we've deployed on Google cloud to a new job specification. So what I'll do is I'll put this in first and then I'll talk through it.
00:24:53.234 - 00:25:46.710, Speaker A: So on your chainlink node you create a new job. So what this job does is it looks for incoming requests from this is the oracle contract that my node is using. So it looks for requests coming in from this oracle contract and it passes them through to the Fortnite EA adapter that we defined in the bridges section. Then it converts the result to an ethiopian two five six and then sends the response back on chain to the smart contract that requested it via the oracle contract up here. So before we run that, this should be now deployed. So what we can do is we can actually test the external adapter now that it's deployed on Google cloud. So once again in our terminal we're going to mimic a chain link node request.
00:25:46.710 - 00:26:37.670, Speaker A: In this case though it's slightly different because we're now connecting to the URL that the cloud function gave us and we're going to do the account endpoint. Cool. We got back a similar result and you can see the kills here. So that looks all good. So now we've deployed our external adapter to a cloud environment and we have added it as a job to our chainlink node. So the last step is to basically use it. So in the documents you can basically take a template consumer contract.
00:26:37.670 - 00:27:28.652, Speaker A: So API consumer here. So we can actually deploy this contract using remix. So this is a template contract for connecting to external data via a chaining node and we only have to change a few things in here. So the oracle variable needs to be set to our oracle contract for our chain link node and the job Id needs to be set to this job id that we just created. So I'm going to change the job Id here and I'm going to set the oracle to my oracle contract. Cool. We'll leave the fee at 0.1.
00:27:28.652 - 00:28:26.070, Speaker A: Link. Now this function is the one that actually does the requests. It's going to take an account variable and I'll call a request kills. And essentially all we need to do is add our parameters in so the request gets defined up here. We don't have to change that. But then we're going to get rid of all of this and we're going to put in our request parameters. So we're going to specify an action which is account and the value is going to be taken from the parameter passed into the function and we're going to change the name of this to kill count.
00:28:26.070 - 00:29:21.476, Speaker A: And in the fulfill function which gets called when a response comes back from a chain link, Oracle, we're going to take a QS parameter and we're going to set kill count to be queue. Now I think that's it. Let me just double check. So once we've done that we can then compile the contract that's compiled. Now we're going to deploy it onto the coven network. So confirm that. So that would give us a smart contract address that we need to then fund with some links.
00:29:21.476 - 00:30:28.808, Speaker A: So this might take a minute or so. Okay, so I've got my API consumer contract has been deployed here. You can see the kill count is currently zero. But before we can do a request to our chainlink node and external adapter, sorry, we need to fund the contract with some link. So I'm going to get the contract address here and I'm going to send some test link here, send one, we'll wait for that to send. So once that's done, what we're going to do is we're going to do a request to get the amount of queue that this account ID has. So going back to our deployed contract here, we have request queues.
00:30:28.808 - 00:31:20.520, Speaker A: I'm going to put that value in and it should get sent in the value parameter to the chainlink node. So let's see. Okay. All right, that should be ready. So if we call request cures, confirm the transaction, so that will send the request to the chainlink node which should then send it to the external adapter to process. So if we go back to our job and we go here, we can see it's created an instance of this job and pending incoming confirmation. So we'll give a couple more seconds to process the incoming request.
00:31:20.520 - 00:32:02.932, Speaker A: So if we go to the Fortnite EA task, we can kind of see that the Q's value has kind of been returned and you can see all the data actually that gets returned by that API endpoint can be seen here. And if I just wait another second. So we're just waiting for the outgoing confirmations now. Cool. So this job is now completed. All tasks have been successful and you can kind of see the output of each task here. So we should be able to go back to our deployed contract here and call this queue count getter function and hopefully there we go.
00:32:02.932 - 00:33:03.812, Speaker A: So the queues for that account in Fortnite are now on chain in a smart contract and you can now do whatever you want with them. So there you go. That's kind of it really what we've done here is we've explained what an external adapter is and we've created a external adapter to a Fortnite API based off one of the chainlink templates. Created that here. We've tested it locally and once we tested it locally we then deployed it to Google Cloud as a serverless function so that a chain link node can make use of it. And once that was done, we added the external adapter to a chain link node and created a job specification that uses it. And after that we created a consumer contract that makes use of that job to get the Fortnite data on chain.
00:33:03.812 - 00:33:56.920, Speaker A: And we did all of this in less than half an hour. So we literally changed a few lines of code in the consumer contract and added and changed a few lines of code in the external adapter template. So that just shows how easy it is to kind of get external data on chain into your smart contracts using Chainlink and specifically the external adapter functionality that it has. So I think it's a really powerful and cool thing and once you kind of know how to use it, you can do a whole bunch of interesting things with the data once it's on chain. And definitely if you create an external adapter, add it to market link so that others can use it as well. But that's kind of it for now. If anyone has any specific questions, I'm on Discord as Harry P.
00:33:56.920 - 00:34:12.824, Speaker A: On the chain link channel or Twitter as Pappas nine nine nine I think it is. And I'll clean this adapter up and list it on market link if anyone wants to add some of the other endpoints and play with it. But for now, I'll pass it back to Keenan.
00:34:12.952 - 00:34:26.480, Speaker B: Yeah, thanks a lot, Harry. That was very informative and great demonstration. Really appreciate you taking the. Yeah, I have one question here from Matt. How are you doing, Matt?
00:34:28.900 - 00:34:30.860, Speaker A: Is it Matt from Link Myriad?
00:34:31.020 - 00:34:45.720, Speaker B: It is the Matt from Link Myride. When running your own node, can you configure it to not require any payment to perform jobs? Or do you always have to fund your contract with the link token?
00:34:46.780 - 00:35:31.700, Speaker A: I think you can configure a minimal payment in the node config settings. But just keep in mind that every time you send a response back to your oracle contract to then send it back to the contract that requested the data, you're actually performing an ETH transaction. So your node needs to have ETH. So if you say you don't need to send me any link to process requests, then each request you get is actually costing you ETH gas. So the link token payment kind of offsets some of that cost that the nodes are actually incurring to fulfill requests. So just a heads up. Cool.
00:35:31.770 - 00:35:58.832, Speaker B: Yeah, thanks for that answer. And if anyone else has questions, definitely drop them in there. If not, join our discord. I'll make sure to put all these links, including the template, the cheat sheet, all the documentation. So for those that will be coming back and listening to this after, you guys can take a look at those in the description. Otherwise, maybe just to wrap things up too. So, yeah, you made this look incredibly easy.
00:35:58.832 - 00:36:10.070, Speaker B: 30 minutes to put this together. And so what would be like a creative application that someone now could go use with something like this?
00:36:12.280 - 00:37:08.596, Speaker A: Yeah, I think it'd be cool. Esports is a huge thing, and there's a whole bunch of money in prizes and stuff these days. I'm sure there's a lot of administrative nightmares in kind of organizing those things. You could potentially have all prizes and bonuses paid out on chain via smart contracts by using an endpoint like this, where you could program specific bonuses to be paid out based on certain conditions, like kill to death ratios or consecutive kills or anything like that, or even just prizes based on did they come 1st, 2nd, third, et cetera in the competition and at the click of a button, once games or matches have finished, the smart contracts can automatically process all of those things and then do the payouts based on the data and the rules in the contract. So I think something like that would be pretty cool.
00:37:08.778 - 00:37:33.196, Speaker B: Sweet. Yeah, that sounds really exciting. Awesome. Well, yeah, everyone who's listening in too. We're going to start doing a lot more developer workshops, so definitely stay tuned. Check out the website. Next Tuesday Patrick will be giving a technical workshop on securing your defi contracts, preventing them from these different price oracle attacks that keep happening.
00:37:33.196 - 00:38:09.460, Speaker B: Other things too. Definitely join our discord and we're going to start giving out pope tokens and NFTs for people that are contributing within the discord. So if you see something and someone asks a question that you know the answer to, definitely jump in there. You'll be able to use these to get swag and some other cool items and there'll be more information about that coming out. But definitely go participate in the discord. Help people. Similarly to Harry, he's just taken his time to come and help the chainlink community learn more about external adapters and build cool things.
00:38:09.460 - 00:38:15.852, Speaker B: So appreciate every one of you and appreciate you Harry, for joining and yeah, this is really exciting stuff.
00:38:15.986 - 00:38:18.620, Speaker A: No worries. Thanks for having me. Cool.
00:38:18.690 - 00:38:23.550, Speaker B: Well everyone have a good rest of your day or evening wherever you are, and we'll see you next time.
00:38:24.080 - 00:38:24.650, Speaker A: See you guys.
