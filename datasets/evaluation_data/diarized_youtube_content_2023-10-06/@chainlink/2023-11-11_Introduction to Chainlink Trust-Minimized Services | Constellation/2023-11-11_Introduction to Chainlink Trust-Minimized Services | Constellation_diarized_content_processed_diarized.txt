00:00:18.650 - 00:01:34.964, Speaker A: Hello, everyone. Hi, everyone. Can you hear me? Good morning. Good morning, Rosh. Morning, Vicky. Morning, everyone. Okay, thank you.
00:01:34.964 - 00:02:25.264, Speaker A: Thank you, Vicky. Yeah, I think we will wait for like two or three minutes for everyone to come to the workshop and we can. Morning Sa. Morning, Crystal. Morning, Yuchana. Good morning, Jane USA. Thank you for coming to this workshop.
00:02:25.264 - 00:03:00.492, Speaker A: And I know the time is about 09:00 a.m. In the eastern time in New York City. Yeah. Okay, so it's already nine, three a. M. On it's the time, so I think we can start. Okay, cool.
00:03:00.492 - 00:03:52.450, Speaker A: So let's just start. Hello, everyone. Thanks for coming to this workshop. And my name is Frank and I am a developer advocate from Chainlink Labs. So my work is just to reach as many as the developers as I could and tell them how to use Chainlink, how to use the Oracle technology to integrate this kind of technology to your smart contract in order to extend the smart contract to a hybrid smart contract. And do you know what is a hybrid smart contract? It is kind of the contract not only handle the data and logic natively on the blockchain, but also handle the data and a service from the web two world. So that is also the job, the chain link, Oracle can help you to do.
00:03:52.450 - 00:05:07.652, Speaker A: So in today's workshop there are going to be three sessions. In the first session I'm going to share what is oracle problem and how we can solve that and what is the role chainlink plays in this industry. And in the second session I'm going to talk more about Oracle data service, including the data fee and functions. So do you know Datafeed? The data feed is a service to help you to just get the price data from the Oracle network. And if you are building something like DeFi, the decentralized finance, I think there is a very decent chance for you to just know the price of the asset collateralized on your protocol. And the second one is called chain functions. So if you want to get some on normalized data, like transportation data, like advertisement data, like weather data, if you want to get this kind of niche data on normalize the data you need chaining functions and you can write your own request to just make a restful request to a specific API and then the oracle will just feed the result back to your smart contract.
00:05:07.652 - 00:06:07.416, Speaker A: And by doing this you can just bridge service or any data from the web, two to the web, three smart contract. And at last I'm going to introduce chain computing service. So for the data service we also provide some computing service, including the VRF, which means the verified random function. So with the VRF you can get a random number and to do some airdrop for your NFT collection or decide who is a winner in some gaming project. And except for the VRF, the last service I'm going to introduce today is called automation. So automation is another web three service to allow the user to just call the function or trigger a function in any smart contract. So if you want to just trigger your functions periodically or based on some predefined conditions, maybe automation is the right tool for you to achieve this.
00:06:07.416 - 00:06:31.712, Speaker A: Okay, so these are all things I'm going to cover tonight. And after the theoretical part I'm also give the demo. So if you have your laptop on your hand, maybe just code along with me and you can learn how to use all of these services. And actually it is very easier for the developer to start using the chaining services. Okay, cool. So let's start. Yeah.
00:06:31.712 - 00:07:11.560, Speaker A: Good morning. Good morning everyone. Good morning. Thanks for your time. Thanks for coming to this workshop. So let's start from answering question what is the oracle problem? So simply put, the smart contract on the blockchain are unable to just get any data or services from the web two world. And in order to help the smart contractor to fetch the data from the web two from the API out of the blockchain, we typically need an infrastructure called Oracle to help the developers to relay the data and services to the on chain smart contract.
00:07:11.560 - 00:08:14.712, Speaker A: And maybe your next question is that why the smart contract cannot get the data from the off chain world directly? Right? Well, the short answer is the blockchain is actually a deterministic system. And you know that it's a decentralized system. But also the blockchain is a determinist system. And what does that mean? So as we all know, actually the biggest features for the data saved on the blockchain is that every single piece of the data saved on the blockchain is actually saved in the node across the whole network. So there is not a central authority that has a power to remove or update or change any data uptreated. Because the data is actually not saved in a single database, it is saved in the databases in the different node under this network. So in this scenario, in order to keep that every node keep the same data, save the same data on their database, we have a process called consensus.
00:08:14.712 - 00:09:13.504, Speaker A: So consensus is like this. So if there is any data supposed to be updated or added to the blockchain, there must be a node on the network to just make a proposal to tell everyone, hey everyone, I just have the transaction and I execute this transaction and get a result A and I save a under my database. And can you guys just check the transaction described in this proposal to see if you can get the same result. If you can get the same result, just save and update your database correspondingly. So if the different node under the network do as they told and everyone can keep the same data. So after this proposal broadcast it to the whole network and every different node under the network will just execute what is the described in this proposal to see if they can get a same result. So if they get a same result they just save this data in the database.
00:09:13.504 - 00:10:35.548, Speaker A: And if the majority of the nodes maybe 50% or the 75%, it really depending on the consensus algorithm you are using in the system. So if the majority of node agreed and received the data, actually we call that this block goes through the consensus and this data is finally updated on the blockchain and the status of the blockchain is updated. Right. But think about this scenario. So if I want to just get some data out of the blockchain, if I want to get the temperature data from the web two API, how we can do that? So like before, there must be a node under the network to just call an API outside the blockchain and get a result. Maybe they want to know the temperature of the New York City and it may be like 25 degree in Celsius and the node will just make a proposal to say like hey everyone, I just checked the API and I know the temperature for the New York City is like 25 degree instels and can you guys just check this API and to see if you can get the same temperature data, right? And what are going to happen next is like before. So every different node under the network will read this proposal to check this API outside the blockchain.
00:10:35.548 - 00:11:25.912, Speaker A: And let's first, assuming that every different node can have the same access to this API, but in the different time slot, different people, they check the same API, they might get different answers, right? Maybe you check that on the 02:00 p.m. And he check that on the 10:00 p.m. So if the time is different, the people is different or the service might go down. So they may get the different answers. So the answers, if the answers are the different, this block just cannot go through the consensus, right? And the block cannot be added to the blockchain and the status of the blockchain cannot be updated. So that is what we're saying, that the blockchain is a determinist system. And for the deterministic system, and only the deterministic transaction can be executed.
00:11:25.912 - 00:12:17.468, Speaker A: So what is the deterministic transaction? For example, like one plus one. So no matter who, and no matter when the one plus one is calculated, the result will always be two. Right? But if you want to get a random number, and if you want to get some data from the outside API, it is not a deterministic. So different people who just calculate the random number maybe call API or do some other algorithm to get a random number, each of the node will get a different one, right? That is the meaning of the random. So if everyone can get the same number, it is not a random number. And if the different node cannot get the same data from the API, it is also called indeterministic transaction. So all of this kind of the transactions cannot go to the consensus on the blockchain.
00:12:17.468 - 00:13:31.636, Speaker A: And that is what we're saying, that the blockchain cannot execute the indeterminate transaction. Okay, how we can solve that? So when the oracle, this concept, oracle concept forcely introduced to this industry, there were a lot of the centralized oracle in the market. So actually the process for the centralized oracle is pretty straightforward. And you just set up a server off chain and you write some script in your server and this server will just start monitoring the status of a specific smart contract on the decentralized network. And if the status of the blockchain, status of the smart contract, I'm sorry, if the status is updated by some end user, it will be considered as a new request. And this new request could be detected by the centralized oracle node. And after this request is sent by the end user, the centralized node will just execute a script and get the data from its own data sources and then fulfill this data back to the smart contract on the blockchain.
00:13:31.636 - 00:15:00.726, Speaker A: So that is the whole process. The end user send a request to just express, they want to get the data from the web two, and the request will be detected by the oracle node and oracle node will help them to get data. So everything sounds good, right? But here is a big problem called a single point of failure. So if, think about the whole reason you want to use the blockchain to deploy your smart contract. You want to build a decentralized application, you want to bear with a high transaction, thousands of or even hundreds of the nodes, to promise that your app is just a secure, just a transparent and just temper proof. So you can promise your users they will have the access to your DAP and you will promise your users that you will not change the rules of your smart contract, right? But if you get connected to the outside data source through a single node, oracle actually, you just compromise the security of the whole system. So if this single node is exploited or tampered or attacked by some malicious users, the data to your smart contractor could be controlled by someone else.
00:15:00.726 - 00:16:38.142, Speaker A: And if you rely on some wrong data, actually, if you're building the DeFi or building the gaming, the user of your smart contract may lose your money, may just get some wrong data and do some wrong transactions, right? So it is very important for you to get data from the centralized, decentralized manner and promise the database is just secure and just transparent. So the solution for this single point of failure is called decentralized oracle network. So for the decentralized oracle network, you can see here, instead of the single node, we have the multiple node under a network called Don. The full name of the Don is decentralized Oracle network. So every time, if there is a request emitted from the smart contract, the DoN will just detect this request and every node under this network will go out and reach out and get some data from its own data providers. And after this data is fetched from an API, every different node under the network will just talk to each other and aggregate all the answers into a final report with all of their signatures, and finally submit this report to the onchain smart contract. So in the blockchain, the smart contract will just do some verification for the report to say if the result is illegal and if everything is fine, the aggregate of the result will be saved on the smart contract.
00:16:38.142 - 00:17:30.006, Speaker A: And this kind of data could be consumed by the consumer, users, consumer smart contract. So by doing this, we kind of mimic the trust minimization the blockchain has today. So we just use a multiple node and apply this feature to the oracle layer, or we can call it data delivery layer. So it will make the data fetch processing data fetch process is just decentralized. You can fetch the data in the decentralized manner. And in this scenario, if some malicious user want to attack and control the data provided by Oracle, it is very hard for them to do that because they need to control more than half of the nodes under this network. It will cost a lot of the fees or cost a lot of the money.
00:17:30.006 - 00:18:25.986, Speaker A: So if they do not have this money, or if there nothing on the blockchain can be tacked and can be attacked, they will decide not to attack the decentralized oracle network. So the security level is much, much higher than the single node oracle infrastructure. Okay, so actually the chain link is a decentralized oracle network. And based on the decentralized Oracle network, and we provide some web three services and the data service, computing service, and a cross chain service. And in tonight's workshop we will focus on the data service and computing service. And I believe we have another workshop to introduce and do some demo for the cross chain. It is also a new service we released in this year, but for this workshop I'm going to cover the data and compute.
00:18:25.986 - 00:19:30.070, Speaker A: So for the data service, as we talked before, we have the two different types of the data services from the chain link. The first one is a data feed and the second one is the functions. The data feed is a service to allow the user to just make the use of the price data of the particular asset. And this kind of data is actually fetched from a decentralized manner from a lot of the hundreds of or even thousands of the data sources. And for the functions, it's for the users to get some niche data or get some unnormalized data. So if you want to know the gaming data, you want to know the stock market data, you just need to write your own API and write your tokens into your URL and send this rEstful request to the specific API. And the chaining Oracle network will help you to do that and get this data in the decentralized manner and do the aggregation and then feed it back to your smart contract.
00:19:30.070 - 00:20:43.422, Speaker A: Okay, so let's just go through the data feeds first. So as you can see here, the data feed, we have this do and the decentralized oracle network. And as we talked before, the different node under this network will have its own data providers and each data provider will just have its own data source. So when there is an update for the data feed in this workflow, every different node under the network will just go out and reach the data providers and get the data from substance of the data sources and then they will just talk to each other and aggregate the price data, maybe get a medium value of all the price data and then write your signatures to generate a report and transmit this aggregated report to the chaining data feeder smart contract. So the chaining data feeder smart contract will in the first place to check if the report is legal or not. And then if everything is good, if the necessary verification go through, the data will be saved in the chaining smart contract. And that can be consumed by the user.
00:20:43.422 - 00:21:43.494, Speaker A: So by users consumer smart contract. So that is the workflow of the data feed. So if you are building something like Defi, you definitely need some data price, need some very secure data sources for the price data to let you know that what is the value of the asset collateralized on your protocol? What is the value of the asset user want to trade in your protocol? So it is very important for you to know how to use that data feed if you are building Defi. Okay, cool. So if you want to take a closer look of the data feed. So what does it look like? You can directly head to the data chain link and actually I can go through this website with all of you. And if I go to the data in link and you can see here we have actually the UI is just updated and never mind.
00:21:43.494 - 00:22:46.950, Speaker A: Actually we can have different feeds and this is the latest feeds we added for the data feed. And when you scroll down you can see all the networks, we support it. And if you are building the application on these networks, you definitely can use the datafeed provided by chainlink. And this is a category you can see we have a cryptocurrencies, we have a commodity, we have a gas, we have the fiat, we have some indices. And for example, if I click this one, the ETH to USD, this will tell you the Ethereum price current in current timestamp. So as you can see here is oracles, actually this is a decent oracle network and each node will be operated by the entity and all of them will just use your own data providers to get the price data and then aggregate this data into the final report. And the final report will be submitted to the chainx smart contract.
00:22:46.950 - 00:23:34.758, Speaker A: And after the necessary verification, this data will be shown here. And you can see that the data for Ethereum for now is 2074. Right? And there are also two parameters I want to mention that is called trigger parameters. So as you know, every time, if you want to update the status of the blockchain, you need to write some data and you need to pay the gas fee. So it will be very inefficient for the data feed to constantly update the data price for the different asset. So we only trigger the update for the data feed when either of these parameters or either of these conditions is met. So the first one is the division threshold.
00:23:34.758 - 00:24:13.974, Speaker A: It's like if the price of the particular asset alternate by this threshold, like 0.5%, there are going to be a new update triggered for the data feed. And the second parameter is called a heartbeat. So the heartbeat were like the 45 minutes or like 1 hour. If this time expired, there are going to be a new update triggered for the data feed. So either of these predefined conditions is met, an update will be triggered for the data feed. Okay, so this is just, this is what the data feed looks like.
00:24:13.974 - 00:24:41.578, Speaker A: And if you want to learn more go to this website, data chain link. Okay. And the data feed architecture. So it sounds like a little bit complicated to understand all the definitions and how we can use that. But actually as a developer, if you want to use the data feed, it is very easy. So in order to help the developers to use that, we have the two smart contracts. The first one is called aggregator.
00:24:41.578 - 00:25:32.138, Speaker A: This smart contract is used to receive the price data submitted by the off chain oracle network. So the different node get the price and the aggregate. They will submit the report to the aggregator. Aggregator do the verifications. And the second smart contract deployed by Chainlink is a proxy smart contract. So as a developer, if you have the smart contract, as a consumer, you only need to know the ABI of this proxy and you need to know the address of this proxy. And then you can create a handle, you can instantiate an instance for the proxy in your smart contract and then you call this method, I'm sorry, the function latest run data and you can get the price data submitted by the off chain oracle network.
00:25:32.138 - 00:26:13.590, Speaker A: And this also has already been verified by the aggregator. So only the address and ABI you can call the function and get the price data. Okay, so I'm going to give a very short demo how to use data feed from chainlink. So if you want to use the datafeed or any other services from the chain link, the first thing is go to the box chain link. This is the official documentation from the chain link. So everything I talked tonight can be found on this official documentation. And because we are talking about the data feed.
00:26:13.590 - 00:27:34.450, Speaker A: So go to this one, the data feed, click that button and we will be redirected to the data feed. And for here you can see on the left panel we have the content. Go to the getting started. And in the getting started usually we will provide a sample code to teach the developers how to use this service. And in the getting started we have this sample code, right? So copy this code and open an online IDe for the solidity called remix ethereum.org. So if you are new to the selective smart contract development, it is a very good practice for you to verify your files or to do some practice on the online ID because this online ID will hide a lot of the configurations and there's like a wallet like private key like RPC endpoint behind and you can directly click a button to create a file and write a code and compile light and then to just deploy it on the blockchain. Okay so the first step we need to go to here, you can see here the file explorer and click this button to create a new file.
00:27:34.450 - 00:28:14.722, Speaker A: Let me give the name called date demo. So by doing this actually we have our first smart contract and we paste the sample code here and there are going to be an alert pop out because you copies everything and paste everything remix. Just want to make sure that you know what you are doing. So copy that smart contract in the remix and compile that. So if you are using the windows system control plus S and if you're using the macOS command plus s, you can compile this file. Let me just zoom in so everyone can see what happened. Yeah.
00:28:14.722 - 00:28:56.026, Speaker A: When you see this green check marks that means the smart contract is compiled successfully. And let's just focus one method, one function of this smart contract that is called getchainlink data feed. Latest answer so this is a function in the data consumer, the consumer smart contractor to help the project to get the price data of the particular asset. So remember what we talked before. First we need the API so we need to import this aggregator interface. And second we need address for this particular asset. And this address is for the USD.
00:28:56.026 - 00:29:54.174, Speaker A: If you want to check more the asset you can actually go to the documentation and we have the feed addresses here and click this button. It will show all the addresses we supported for now. And you can see here the networks. So for example if you are using the application on the BNB chain, you want to build your DAP on the BNB chain click the BNB chain and if you want to know the Ethereum price just go to the ethereum, this one. And you can see the address is here. But for our demo the address written here is hard coded and that is a BTC to USD price on the supportia blockchain. So by doing this we actually instantiate a new data feed to get the price data of the BTC on the supportion.
00:29:54.174 - 00:30:39.726, Speaker A: So we need to just switch the configurations on where metamask from the n one we are using to the supportion. So don't forget this task because I have already done that. Yeah. After that is compiled successfully, go to this tab, the deployment tab, and before deploying we need to switch the environment from the remix VM to the injected provider. By choosing the injected provider we will ask the metamask, I'm sorry. We will ask the remix to use whatever the configurations in our metamask. And when we change that we can click the deploy to deploy our smart contract.
00:30:39.726 - 00:31:34.100, Speaker A: And you can see here, I don't know if you can see this. Okay, looks like this is not shown. Let me do the share again. Share screenplay I think you can see everything on my screen, right? Okay, so in order to deploy that we need to click this button. Deploy. When we click this button, our metamask will pops up and then click confirm to deploy this smart contract. And maybe after several seconds we can see the smart contract deployed.
00:31:34.100 - 00:32:15.990, Speaker A: Let me see if you have any questions. So if you have any questions just type your question in the chat box. And when we wait for the smart contract is being deployed by the blockchain, I can answer some questions. So can we create our. Let me show that. Can we create our own data feed with chain link? Yes, you can, but actually that is the permission. If you want to create your data feed for your tokens, you need to contact the business team from the chain link and to talk with them what kind of the token you want to add in the data feed.
00:32:15.990 - 00:33:21.286, Speaker A: Okay, so if you see here under the deployed smart contract we can see our smart contract is deployed. And here is functions we write in our smart contract. Get chaining data feed latest Answer if I click this button, I will get this number. So because there is not the floating data type in the solidity. So I think there will be eight numbers, eight digits that is actually after the point. So the actual price is like 1234 should be this one, the 36,952. Okay so by doing this we can see how to use chaining data feeder to get the specific asset and get the price data of this particular asset in the smart contract.
00:33:21.286 - 00:34:04.290, Speaker A: So if you want to get any other asset on the different blockchain, go to the documentation to check the price feed address. You will see all the network supported by chaining for now and all the tokens supported by chaining for now and choose your address and import the interface. And then you can instantiate a handle to cut functions to get the price data. Okay cool. Let's move on back to our slides. So the use cases. So as we talked before, the biggest and the most obvious use case for the chaining data feed is defined.
00:34:04.290 - 00:34:54.214, Speaker A: So if you build a lending and a broadening, you want to know that the asset collateralized on your protocol. How much is that and what the value of this asset. And if the price data is incorrect, maybe the other users in your protocol will lose their money in the pool. Right? And except for that, the mirror asset. The original idea of the mirror asset is to allow the users to treat like, not only treat the token or the asset natively on the blockchain, but also treat the asset from the webtoon world like a stock market. So it is also very important for the mirror asset to know the price data of the asset listed on the mirror asset on the protocol. Okay.
00:34:54.214 - 00:35:42.134, Speaker A: And for the stable coin based on the collateralization asset on the protocol. And you need to know the value of that. And then you will decide how many stable coins can be issued based on the collateralized asset on the protocol and also for the asset management and derivative exchange. And you will know it is very important for this kind of protocol to know the price to know the value of the asset staked or custodied on this project. Okay, cool. So let's move on to the next data service provided by Chainlink. That Chainlink functions, actually the Chainlink functions is a new service released in this year, in the first half of this year.
00:35:42.134 - 00:37:10.354, Speaker A: And we released that, I think right after the IFCC. And the reason we want to release the chaining functions is to help the developers to get any data they want from the web two API. And as we all know that with the groups of the ecosystem in the web three, we want to just build more business logic on the blockchain with smart contract, maybe we want to build a web three version of the insurance. We want to use the greenhouse gas emission data to just create a carbon asset on the blockchain. We want to do some prediction market and we want to track the asset and macroeconomic data and just track that on chain, do some derivative product on the blockchain. But if you want to do all of this stuff, it is very important and necessary for you to get the niche data or get on normalize the data from some specific API, from some data providers to allow your smart contract can be triggered, can work, right? For example, if you want to build a web three version of the insurance for the flight delay. So if the flight is delayed, actually you want just create, just offer the payout to your client, right? But it is very important for the smart contractor to know if this flight is delayed or not.
00:37:10.354 - 00:38:03.682, Speaker A: And for this case you need to just get data from the flight company's API to tell the smart contractor that the flight is delayed or not. That is a prerequisite for you to build this kind of the decentralized application on the blockchain. And the chaining function is the correct tool for you to use to get any data from the API true world. So if you check the workflow of the chain link functions, you can see that it is quite similar as the data feed. But actually there is one difference. The chaining functions from the chain link data feed is that in the chain link functions you need to make a request that is on demand service. So as an end user you will have your consumer smart contract here and you need to send your request to the smart contract.
00:38:03.682 - 00:39:29.162, Speaker A: And the smart contract of the consumer can just send this request to the chaining function smart contract. Then a function smart contract will rack your request with other necessary data and then emit this data into an event. And if this event is emitted by the function smart contract, it can be detected by the decentralized oracle network that is also the core of the training. So if the request is detected by the DoN, the apple node under the DoN will execute what you want them to do. You can write your requirement in the request and maybe it's do some computation off chain or it may be some use case you want the node to get some data from the API, make the restful request to any data providers, and after this calculation or the API call is finished, the node under the network will aggregate the answers and transmit this report back to the function smart contract. And after the verification, the chain link function smart contract will fulfill this request, fulfill this data into your smart contract. And actually the beauty of this is that you don't need to care about all the servers, set up all the configurations, you just write your request.
00:39:29.162 - 00:40:29.234, Speaker A: Maybe you want to make a restful call, you just write a JavaScript file and wrap this JS code with your request and send it to the chain function smart contract. And after several seconds, or maybe after several blocks, you just get a response from the outside API and to write it back to your smart contract, you write a request, send a request and you get a response that actually make your smart contract flexible. As any web two app has today. You can get nearly every data you want to get in the web two world to move nearly every business logic from the web two world to the web three world. Maybe build a web three version of the insurance, gaming or transportation, the management or the carbon asset generation. You can nearly do all the business in the blockchain by using the chain function to get the data from the API in the real world. Okay cool.
00:40:29.234 - 00:41:14.926, Speaker A: So this is actually the chainx functions architecture. So different from the data feed, you need to use a consumer contract to send the request. So in the consumer smart contract you will have two functions. The first is the execute request to help you to send a request to the chaining functions and the second one is called a fulfill. That is a function is supposed to be called by the chaining functions and to be used to receive the result from the chaining functions. So the whole workflow is like this. The end user makes the request and the request is going to call the send request onto the oracle smart contract.
00:41:14.926 - 00:42:27.290, Speaker A: Then it will start bidding and then it will image your request in the event log. And after this log is detected by the decentralized oracle network, the oracle will do what you ask them to do in the request and then fulfill the result back to the oracle contract. And then stop the bidding and fulfill this result to your consumer smart contract. So as a developer, what you need to do is just write this smart contract and add these two functions in your smart contract. Then you can get nearly every data you want to get from the web two world. Okay so let me do a demo like before. So this time I just want to go to the, we still go to the documentation here and in the documentation on the top bar you will see here is a doc and to the functions here click functions and we will be directed to the functions page and read the docs.
00:42:27.290 - 00:43:15.110, Speaker A: And here is the introduction of the chaining functions. And as you can see here it is still in the backend. That means if you use that for the first time you need to sign a term of the use. So when we go to the getting started and we can see here is a simulation. So I just want to show there is some tool for you to use chainlink functions and to test your JavaScript file that is called a chainlink playground. If you click this link you will go to the chainlink playground. And as you can see here we offer this playground to other developers to test the JS code you write and you want a chaining node to do in this default one.
00:43:15.110 - 00:44:20.894, Speaker A: You can see here we actually have a parameter called a character Id and we need to input a number like one, two or three. And the second we will make an API call using the functions make HTTP request. Then we get a response. And in the response if everything is good we just got the data from the response and we need to print everything in the console. And finally we encode the name in this data in this response. Okay so if I click this button run code and you can see here the result is returned from the API and that is a json file and because I just username use this specific information in this json file. So I think the output the Luke skywalker actually this name is here.
00:44:20.894 - 00:45:00.986, Speaker A: So in the json file we have a bunch of information and what we really need is a name under this json file. So we add this path here and encode this one and fulfill that one to the smart contract. So we can see that we get the result as this is. I hope this gives you a feeling to how to use chaining functions. You can write everything here. For this example you are just make a request to the restful API, but you can also do some computations in the JS code. You send this request through the chain functions and get a result back.
00:45:00.986 - 00:46:01.982, Speaker A: Okay, so if we really want to use that in the use case we can go through and to check if there is a sample code. And here, let me see, deploy a function consumer smart contract on the polygon moonbank. So under this title we have a sample code. So let me just open that remix, let me close this remix and switch to our second remix and close that one. Yeah, this is a sample code of the chainx functions and the smart contract is called getting started functions consumer and as we talked before, you see we have the two important functions under this smart contract. The first one is a send request. This function is used to send a request to the chaining function and to ask chaining function to do whatever we want them to do.
00:46:01.982 - 00:46:51.626, Speaker A: And then we have the second function called fulfill request. This function is used to receive the result fed back by the chaining oracle network. And after the response is received we do the following execution for this response. For example, we want to save the response to the s underscore last response and we can just convert the type from bytes to string and saved into the variable called character. And this is what we can do in the fulfill request. So as we talked for in this workflow, this is a consumer smart contract and it is shown in the remix. This is a sample code and if you want to know where we send our Js code, we have a variable called source.
00:46:51.626 - 00:47:37.662, Speaker A: So actually we send this JS code to the request and this one will be executed in the chainlink oracle node environment. So every oracle node will execute this source code and do whatever we want them to do. So we give the capture id, we ask them to make a restful API call, and then we verify the response and we get the data and we give it the path to just get that exact attribute under the json file and encode this json file and return that into the chaining function. Okay so let me just compile that one. Oops, there is error. The source bar request different compiler. Let me see.
00:47:37.662 - 00:48:16.730, Speaker A: Oh yeah, that is 0.8.19. Go to this one and compile that again. Yeah it is compiled successfully. So next we can compile our sample code because when we check the hard coded address here, that is for the moanbuy. So I need to just switch my network from the supportia to polygon by here. Click that one and switch to the injected provider. Yeah we're ready to go and compile that again.
00:48:16.730 - 00:49:22.234, Speaker A: Make sure the smart contract showing here is a getting started function consumer and click that deploy button. Click that button and a metamask pops up. And like before, confirm. Okay, the smart contract is compiled and deployed and if we want to send a request, and actually you can see here we have to impute two parameters. The first one the subscription id and the second one argument we need to impute for this Js file and where we can get this subid. So every time, if you want to use any service provided by Chainlink, you need to have some subscription and add some batteries to this subscription. And then you need to just add your smart contract as a consumer under this subscription to tell that subscription that this smart contract is to use a balance in this subscription.
00:49:22.234 - 00:50:42.450, Speaker A: Okay, the way to create that is to go to the functions chain link. This is the UI we provided for developers to create a subscription and click this button. Create a subscription and it will automatically read your address from the metamask and you can just input your email address. If there is something wrong, we will send an email to your address and click check this checkbox to just sign the privacy policy and create a subscription. And Metamask pops up and click confirm. Maybe we need to wait for like 1 minute or 30 seconds. Let me see if there is any, oops, the second one, I sign it again and we need to add some funds, maybe add a five link token, add this font.
00:50:42.450 - 00:51:45.822, Speaker A: So now make sure your metamask has enough data. Click confirm. Yeah, I will answer some questions. So for this one. John Smith but how can you really trust it through, I mean really trusted? I kind of understand your question. You mean that if the data source, if this API is wrong, even if we get it from the decentralized manner, the data is still wrong? Well, this is kind of the problem cannot be solved by the blockchain, cannot be solved by the oracle. You have to trust someone, right? You have to trust someone in the world.
00:51:45.822 - 00:53:27.226, Speaker A: So they give you the data and you just get this data in the decentralized manner and you save that on the blockchain that could be verified by everyone else. And yeah, that is. I hope I answered your question. Okay, and let's just add a consumer. The consumer smart contract has already been deployed. Let me just switch to the remix and click this button to copy the address of this smart contract and go to the functions UI to paste the address here and add a consumer and click confirm. Is that possible for chaining functions to not just generate but store secret data, say for the order of the cars in the quarter deck for a poker game? Actually the secret data cannot be held on the chaining functions that we will keep this data for a period of time and maybe after the ten minutes or maybe after the 20 minutes I will just give you the data because if you want to build your onchain game or you want to use a decentralized application on the blockchain, actually the data should be verified and public to other users of this blockchain.
00:53:27.226 - 00:54:35.382, Speaker A: And if you really have some secret data, my suggestion is that you only just use this secret data when you want to trigger these functions. And if the function is supposed to be triggered, you just trigger that in the transaction and use the secret data in your use case and everyone will just get the result. And there is no need for you to see the secret data for somewhere in some time period. Okay, the consumer is added successfully. And let me just view the subscription here. As you can see here we have a subscription and the subscription Id is 604 and under the consumer we have one smart contract and we have the balance as a five link. So for now we are ready to send a request to this subscription of the chain link functions and to ask them to just do the job we want them to do.
00:54:35.382 - 00:55:21.650, Speaker A: And I go back to our remix and we have our sub ID as 60 four and actually we need to give it a number. We give it once and we know that it's a skywalker loop. Right. Let me just transact to send this request the metamask pops up and click confirm. So by doing this we actually send air request to the chain links functions and we should able to see there is a request detected here. Maybe we need to wait for more time. Yeah, for now the transaction is confirmed and the function, the oracle node will detect this request.
00:55:21.650 - 00:55:55.002, Speaker A: And as you can see here, it is appending. So the chain link oracle network is just fetching your request from the event and it is just doing the job in this request. So the status of this request is pending. Let me refresh that again. It's still pending. Maybe wait for more time. Okay, so the character is actually returned.
00:55:55.002 - 00:56:46.702, Speaker A: So I think the UI is a little bit delayed and because in the fulfill function we get a response and we just convert the response and save it to the character. And for now we can see that the character has a value like Luke Skywalker. So this is the way we use the training functions and you need to get consumer smart contract. You'll just send a request with JS code. You ask Oracle node to do what you want them to do and then you will get the result back to the smart contract. Okay, so this is the second one I want to introduce for the chaining data service. And one more thing I want to tell everyone is that as you can see the smart contract here for the source code.
00:56:46.702 - 00:58:15.162, Speaker A: The source code, if you save the source code with a smart contract and deploy this smart contract on the blockchain, it will cost you more gas to do that because you save more data on the blockchain. So there is another way to use the chain function that we have a, let me see, we have a starter kit for the chaining function and if you want to use that go to our GitHub repository and search function and you will see here the function hard hat starter key, click this one and you can see here in the smart contract you will have the function consumer and there is no source code saved in this smart contract. And you can use some JS code to write some tasks under the hard work hard framework, I'm sorry. And then save your JS code in another folder. So every time when you send a request you just write the JS code into the transaction and call the standard request by just automatically pass the source code into this function. And by this way you don't need to save the source code with the smart contract and deploy that on the blockchain to cost more gas fees. And if you want to learn more about how to use that directly go to this one.
00:58:15.162 - 00:59:17.242, Speaker A: And we have a very detailed documentation to instruct the users how to use chaining functions in a more proper way. If you want to test it or if you want to integrate this service into your product, maybe consider about this hard hat start kit. Okay. And another one is that if you want to check the use cases contributed by other developers, we have a website called usechainingfunctions.com. On the website we give the users some use cases like you can connect the smart contractor to the AWS data exchange. The AWS data exchange as far as I know is the biggest data market all over the world and it provides all kinds of the data. So you can just give your smart contract ability to reach the data sources from the AWS.
00:59:17.242 - 01:00:25.602, Speaker A: Or you can use the Twilio API to send some email or to the text to the users who have already bind their web two, identity with the address on the web three, you can just do some web two transactions to send some text based on the user's behavior on the blockchain. And for the Google Cloud bigquery, it can be used to get the data of the website, it can be used to get the data for any public database. And you can just get Google Cloud Bigquery to help you to get the real data from the web two and fulfill it to the smart contract using the chaining functions. And if you are interested in how to bridge the data from the web two to web three and directly go to this website and check the use cases we have already contributed. Okay, and next we will move on to the computing service. In the computing service we have two services. The first one is called the VRF verified random function and the second one is automation.
01:00:25.602 - 01:01:22.374, Speaker A: So for the verified random function it is a service for the developers to get a random number and a proof from the Oracle network and use this random number. In some use cases like NFT giveaway like gaming to just drop some asset to the different users in a whitelist or something like that. And from very recently, getting a random number on blockchain is quite an issue and there are usually two ways for the users to get a random number on the blockchain. The first way is that you can rely on some on chain data, for example like the block hash of the next block. So no one will know what transactions will be included in the next block. So no one will know the transaction hash of the next block. So you can use this as a random number.
01:01:22.374 - 01:02:42.174, Speaker A: But the problem for this method is that if the miner has more than 51% of the mining power of the decentralized network, it actually have the power to decide which transaction could be included in the memory pool, which transaction could be included in the next block if the transaction can be decided. Actually, basically the miner can decide the random number you received using this method. And except for this, you can also rely on some centralized API to just fulfill a random number to your smart contract. But we all know that is not the most reliable way you can get a random number, right? So here is one solution for the problem. The verifiable random function. This algorithm is actually invented in last century, I mean in the 1990s. And in order to allow the random number generator to prove that they do not cheat in the verifiable random function, we have three steps to generate a random number and a proof to prove that.
01:02:42.174 - 01:04:04.646, Speaker A: So in the first step, every oracle node to provide this service need to generate a private key, I'm sorry, the public key and a secret key, and keep the secret key under its environment and publish this public key on the blockchain. And after that, if a user want to get a random number, the user need to send a request to the offchain oracle node. And by sending a request they need to give a seed, maybe it's a block hash or something like that. So after this request is detected by the off chain oracle node, the oracle node need to use the secret key in their environment and the seed sent by the requester and then generate two things. The first thing is randomness, and the second thing is approve and then submit these two things to the onchain smart contract. And that we come to the step three, verify and on chain smart contract need to verify the randomness with approve to see if the random number is generated from the people who hold the secret key. And also the number is generated with the seed because one character of the BRF is the uniqueness.
01:04:04.646 - 01:04:59.094, Speaker A: So from the one seed only one random number can be generated. So the oracle node cannot just get a seed and generate a lot of random numbers and choose one on its preferences. And if the result is true, that means the random number is actually generated by the secret key holder with a specific seed and with a predefined algorithm. So that is a one to one algorithm to generate a random number. But if the return value is false, that means the verification failed and we will not use a random number generated by the VRF. Okay, so the workflow for the viewerf is that this is also an on demand service from chainlink. The user need to send a request and with the seed to the oracle node.
01:04:59.094 - 01:06:35.020, Speaker A: Oracle node, obviously the public key and the private key has already been generated and the oracle node need to get this seed and request, and then generate a randomness and approve and submit that to the VRF coordinator. The VRF coordinator is a smart contract to help to verify the validity of this random number. And then if the random number is verified, this can be saved on the smart contract and can be consumed by the user's consumer smart contract. And when it comes to the architecture, it is quite similar as the different oracle services you have the consumer smart contract as before, you have two functions as a request function and a fulfill function. In the request function you send a request to the coordinator. The coordinator just wrap your request and emit that to the event log. And after the event log is emitted the oracle node off chain will get a block hash as a seed and get the necessary data from your event and generate as I mean this seed is a pre seed but oracle node need to use everything here to generate a seed and based on the seed and its security a randomness and approved will be generated through the VrAF and all of this stuff will be submitted to the coordinator and a coordinator will just serve as a coordinator for the user to verify the validity of this random number and finally fulfill this random number to your smart contract to the fulfill random words function.
01:06:35.020 - 01:07:30.602, Speaker A: Okay, so this is a workflow and architecture of the chain linkerf and lecture four. Let me just give a short demo how to use the chainx VRF. So go to the documentation and this time we need to choose the VRF here, right? So the documentation is a home for the developers. If you want to learn more about the training, if you want to get the latest update of the training service, just keep looking, keep reading our documentation and you will learn everything. I talked to today and I read the documentation. Go to this one, the overview and getting started. Yeah, we have a tutorial, video tutorial for the chaining BRs, but for them we need to check these two things.
01:07:30.602 - 01:08:35.730, Speaker A: So the first one is a subscription method. So if you remember how we use the chaining functions, we need to create a subscription for the chaining functions. And every time if the user want to make the use of the chaining functions, the user has to send a request to the subscription and then this request can be processed by the Oracle services. And in the VRF we can still use in the same way to send the VRF request to the Oracle network. But except for that we also provide another way called direct funding method because chaining token is actually a USA six seven seven and you can just send a token and then ask the virtual machine to do some following instructions. So you don't need to always set up a subscription for the viewer app. You can directly save some tokens in your smart contract and you send a request with the tokens and after the request is processed, the token will be paid for the chaining node.
01:08:35.730 - 01:09:37.160, Speaker A: But my recommendation is for the subscription method because if you set up the subscription method, the subscription, let's just call it a sub. So the subcontractor will just do some verification, do some steps for you to successfully send a request. But every time if you directly use a directly funding method, you need to do all these steps by yourself and that means you need to pay more gas fees. So let's just try this sub method and go to the get a random number here, let me zoom in and I think there is a sample code. Create and deploy a VfB two compatible contract. And let me open that in remix so we have our bird remix. Let me close this one.
01:09:37.160 - 01:10:36.674, Speaker A: Yeah, for this remix we already have this sample code for the VFV two consumer and if you are familiar with the chaining project, if you're familiar with the oracle service, you will know what I'm going to see. You will have the two functions. The first one is request random words. That means you need to make an on demand request to the oracle node and the next is a fulfill function. In this case it is called fulfill random words and this function is used to receive the result fetched by the oracle node oracle network. And after you get this result you can do whatever you want with this random number. Okay, so let's just compile and there are several other parameters called the key hash.
01:10:36.674 - 01:11:21.682, Speaker A: That is a gas land. You can choose a different gas land if your request is very urgent. You just want to get a response maybe in five blocks and in very short time you need to set the high gas fees. And another one you need to care about is that Nam words. So that means you can request more than one random number from the VRF per request. And I think the maximum number for the words is 500 which means that you can require 500 random number per request. Okay, we will set the key hash at this one and we will request the two random member per request.
01:11:21.682 - 01:12:33.290, Speaker A: And for the hard hat code. Here it is for the supportia and let me compile that everything is good. And let me go to the metamask. What is that? Sorry, go to the metamask and because that is the supportia I need to switch to the supportia, go to this one and the remix will use the supportia network configured in my metamask and go to the deployment, compile that select injected provider and we have this one and we deploy our smart contract. But before the deploy as before we need to give a sub ID to our smart contract and go to the VRF chain link to create a subscription. And when you come to this UI click this button. So create a subscription and the email address optional, project name optional and we skip that create a subscription metamask pops up, click confirm.
01:12:33.290 - 01:13:25.878, Speaker A: Let me see if there are questions. Yeah, thank you Frost. Will your presentation deck be available? Yeah, after this presentation is done I think the recording will be published on our YouTube channel tomorrow. And I will add a link to the slides in the comments. No worries. And the subscription created. And then we can add fonts and maybe add five links.
01:13:25.878 - 01:14:23.912, Speaker A: Click add fonts and click confirm several seconds. Sometimes the UI is a little bit lag from the real status on the blockchain because the transaction on the blockchain should be injected first and then the UI can get the real status of the blockchain and the funds added successfully. And we can add consumers because we have not deployed our smart contract yet. So we do not have the consumer address here. So I will click this button. I'll do it later. Yeah.
01:14:23.912 - 01:15:21.784, Speaker A: As you can see here we have our ID and we have the consumer, we have the history and then we can deploy our sample code for the VR SV two consumer. And in the constructor we can just input our sub ID here. It's this one. Copy the ID and switch back to the remix paste added here and transact to deploy that confirmation. The transaction is done. Yes it is done and we have already successfully deployed our smart contract. And then don't forget to add consumer to the subscription and then click this one to copy the address of our consumer smart contract.
01:15:21.784 - 01:16:49.208, Speaker A: And in the viewer app we click this button, add consumer and paste the smart contract address here and click add consumer. And we need to confirm in our metamask to just lattice transaction on blockchain it. Yeah, for now the consumer is added successfully and I close that and refresh the page. And similar as the chaining functions we have the id, we have the balance and we have the consumer addresses listed under the consumers. And we can see all the history event of this subscription and the subscription created and subscription funded. And also we added our consumer into this sub and I think we are ready to make a request to the dun to just get a random number. So the function we are going to use is this one, the request random words.
01:16:49.208 - 01:18:28.840, Speaker A: And if you check the statistic code you can see the transactions here. And what we're doing is that we use the instance of the coordinator and call the request random words under the coordinator smart contract. And then we give it a key hash which means gasoline we choose and subscription ID which means which Id we can use the balance and of the request confirmations, callback, gas limit and net worth. That is the configurations we set for our request and then this one will be sent. This request will be sent and we also have this one, the fulfilled random words and this request I think oh that is internal but I think yeah, that is internal I think because we have already implement the VREF consumer base v two and there will be a function used to receive the data received returned by the chaining VRF and then the function in that base contract will call the internal function here in the fulfill rent words and we can get this rent words and for now let me click this button to send a request. Metamask pops up and click confirm to send a request. Let me check if the transaction is confirmed or not.
01:18:28.840 - 01:19:47.372, Speaker A: Yes, the transaction is confirmed and since our request has already been sent so the event will be imaged by the coordinator and in the UI of the VRF we should able to save the request here. Yeah, like this one because the VRF needs some time to calculate the random number. So we need to wait for this request to be done and then the randomness can be fulfilled to the smaller contract of our, I mean the consumer small contract. And let me wait for some time for this to be done. This request is a request we just sent to the VRs. Maybe wait for some time and in the remix I can check the last request Id. This is last request and if you check the request here using the ID you can see the status of this request and the first one is fulfilled.
01:19:47.372 - 01:20:13.812, Speaker A: True. And if it is true that means this request has already been fulfilled by the VR app. And again I think this app is a little bit delayed. Let me refresh that. The request disappeared under the pending. So I think the request is successful and there should be some log for the request. But I think the front end.
01:20:13.812 - 01:21:12.444, Speaker A: Yeah, we can see here the recent fulfillment. So for now this request is moved from the pending to the recent fulfillment and the status is a success. And then we can check if we receive this random number in our smart contract by using this one get request status using the ID and we can see we got a result at this one. This one is the first one here is a little comma here. And if you can see here is a little comma here. So because we set the configuration of the name words as two, so we actually request two random words in this request and as a result we have the two random numbers. The first one is this number, a bunch of numbers and the second one is this number, the bunch of numbers.
01:21:12.444 - 01:21:41.516, Speaker A: So by doing this we can just get a random number and in the fulfill functions you can actually use this random number to just do whatever you want. Maybe for the gaming, maybe for the IDU platform and whatever you want to just distribute asset to the users. Okay. Yeah. And think that is good. Yeah. The next one is the use cases for the VRF.
01:21:41.516 - 01:22:57.580, Speaker A: So for the VRF, the obvious use case is NFT creation and distribution. So if you want to publish that NFT and the user want to mint your NFT, it is not fair to just tell them you can only get these unrear features on your NFT. You need to just distribute the different type of NFT to the different users in the random manner. And if the users can pay the same money they get the different NfT under this collection, it will be a safe meet and it's a fair distribution. And if you want to build a raffling or want to build a platform to allocate the asset or incentive to the different users, maybe in a whitelist or something like that, maybe you can leverage on the random number provided by Chainlink to just do a fairly distribution to other users in the platform. And here we have a blog article to just introduce the different use cases for the random number. And if you're interested in that, just go to our blog and to check out the use cases we introduced for the chain VRF.
01:22:57.580 - 01:23:44.364, Speaker A: Okay cool. I think we have already been together for one and a half hours. And let's move on to the last service that is called a chain link automation. So for the chaining automation, chain link automation is quite an interesting service because it actually allows users to trigger any function in any smart contract. And think about a scenario. You want to just trigger a function every 1 hour or every two hour or maybe every week. How you can do that? You maybe rely on some front end running or maybe you want to just use some service in the back end.
01:23:44.364 - 01:24:57.140, Speaker A: You know, that is a centralized way and there is a single point of failure in this kind of method. So we can provide a service and allow the users, allow the developers to employ the decentralized oracle network, check your smart contract and to call the functions in the smart contract if necessary. So in order to use the chaining automation in your smart contract, you will have the two functions. One is a function for check to check if the smart contract should be triggered or not. And the next one is the perform. In the perform function, it is the real instructions, the real business logic you want to be triggered when the predefined conditions are met. So for the chain automation, the decentralized oracle network, for every block there are going to be a new node selected to check your smart contract to see if this smart contract should be triggered or not, if the predefined conditions is met or not, and if the answer is no, maybe in the next block another node under the decentralized network will be select and do the same thing to check if this smart contract should be triggered out.
01:24:57.140 - 01:25:54.284, Speaker A: But if the result is true, if the check function give the result as a true, the node will just call the perform functions you defined for your smart contract and then the functions can be triggered, right? And here is the chaining automation architecture. So as before we have the two parts on chain part and off chain part. Off chain is a decentralized oracle network and on chain part we have a lot of the different smart contract. But as individual developer or as a developer, you only need to care about your automation compatible smart contract. So in order to employ any off chain oracle network, you need to make your smart contract the automation compatible. Which means you need to have these two functions, the check up give and the perform upgape. So you define your predefined conditions in this check up gift.
01:25:54.284 - 01:27:06.904, Speaker A: Maybe after several blocks, maybe just when this variable is reached some number, maybe when some flag is on or some flag is off. In your smart contract, you can set whatever you want as a predefined conditions under this function. And every time the node under the network will check your functions here to see if the perform upgive function should be triggered or not. So if the return value from the check up give function is true, the node will just trigger your perform upgive function through the automation registry. And we have the register and registry to just tell the offchain oracle which smart contract it needs to trigger and where you can just deduct the balance like before. Okay yeah, let me just give the last demo for the chaining automation. And as before we go to the let me close that, close that, close that and go to the documentation.
01:27:06.904 - 01:27:59.570, Speaker A: And this time we are going to use the automation. So we select automation here and read the documentation. Yes, for here you can see that we have a lot of the introduction for the chaining automation. And as before we can go to the getting started. And if you have any questions about which blockchain automation is supporting or how the bidding, how the transaction fee is calculated, we have all of this stuff under this documentation and getting started tab. We have a lot of the articles and instructions how to use that and where we can just get a sample code. Let me check.
01:27:59.570 - 01:30:04.420, Speaker A: Create automation compatible contract yeah, here example, automation compatible contract using the custom logic trigger. So here we have a sample code and let me just copy that one and go to the remix and we don't need this, let me remove all of this stuff and go to the file and we create a new file called automation demo validity and paste the sample code here, let me click that one and everything. Everyone can check the functions under this smart contract and I compile that and in this one contract. So as before, if you're familiar with Oracle services, you need to know that here is a check update and here must be a perform so because every time, if you want to use any power of the oracle, the oracle is off chain in the first step, by which means you need to just let the oracle know there is a request on chain and then you will also have something like a form of a few or something like that to receive the data sent from the oracle network off chain. So nearly for every different oracle service you will have these two types of the function, send request and receive request. But for the chain automation, it's actually not a request, it's actually a check function to allow the decentralized oracle network to see if your smart contract needs to be triggered or not. So if you check the logic under the check active function, you will see that the logic is that the block timestamp for now minus last timestamp is greater than interval.
01:30:04.420 - 01:31:22.892, Speaker A: Then it will return true, which means if the time period expires and this expires for the internal maybe 100 seconds or 20 seconds. If the 100 seconds elapse the oracle node, check this function and it will return true value to the oracle. And if that true value returned, another node under the network, under the oracle network will just trigger this function to just add a counter to do an increment for the counter and we can just check if it is triggered by verifying this counter is increment or not. Okay, so let me check the hard coded, actually there is not a hard coded address here because you deploy your smart contract, you register your smart contract on the subscription and let me just do that first compile that successfully and go to the deployment tab and make sure the automation demo is showing here. And you need to deploy this model contract. And in the constructor we need to give that parameter called update interval. That means how much time you want to wait for the next trigger.
01:31:22.892 - 01:32:18.000, Speaker A: Let me give it like maybe 100 appliances, that means like two minutes, so 120 seconds and compile that and deploy that. Confirm and let me see which network I am using. Testapodia so I am actually deploying this smart contract on the supportia. The transaction is pending and that is deployed. And under the deployed smart contract we can see we have all the functions we defined under our smart contract. If we check the counter here the value is zero. So if this smart contract can be triggered by the oracle node by the chain automation successfully, we will see the value here will be one, two, three or four.
01:32:18.000 - 01:33:28.088, Speaker A: Right? And in order to make this automation to trigger this smart contract we need to create a subscription. Okay, go to the automation blockchain link and we will come to the app for the Phoenix automation and let me click this button register new upkeep and you actually have the three options. You just can use the time like every two minutes or every three minutes as a trigger, as a flag to call your smart contract functions. Or you can do some customer logic, you can set some predefined condition in your smart contract and based on the return value from your predefined condition you can trigger these functions or not. Also you can just rely on some log to trigger the functions. And in this demo we will select the customer logic and next and you need to input your contract address. Switch back to the remix, click this button and copy the address and paste it here.
01:33:28.088 - 01:35:07.226, Speaker A: Go to next and give it a name. Let me call that automation automation demo and it's just read your address from the metamask, set it as the admin address and you give the gas limit. And you also need to add some fonts to this subscription. Let me add five links and do we need a check data? I think no, for this use case and the project information or optional we can just register this update metamask popped up and click confirm the question can we use the NFT? Yeah, actually for the dynamic NFT it is impossible for you to just update the metadata of the NFT based on some conditions or based on some real world data. So you can use the chain automation to trigger and to update the metadata of this dynamic NFT. Or you can use a VRF to just allow the users to mint this NFT and after several intervals and maybe users can just change the metadata based on some randomness. Thanks for the question.
01:35:07.226 - 01:36:35.380, Speaker A: It's a very good question. And after the registration is submitted successfully and we can view this upkeep and this one is upkeep we just create for our smart contract for that automation demo smart contract and when we check the history we can see that we found the upkeep and then upkeep has already triggered the perform function once because after we deployed our smart contract and the two minutes passed. Right, and after the two minutes passed we create our upkeep. And when this upkeep is created in the first phase, the check upkeep function returns true because 120 seconds passed and so based on the return value it actually triggered that check function. That is the reason we will see that perform upgive is already here. If we go back to the remix to check if this counter click that again, we can see the value is one. For now it's updated from the zero to one, which means upgive has already been triggered by the chaining automation and its contrary is increased white.
01:36:35.380 - 01:37:22.462, Speaker A: Okay, if we patiently enough to wait another two minutes, actually we can see there will be another form upkeep. But we don't need to waste the time on this. And be careful. If you just create automation and you don't want this automation to keep triggering your smart contract, you can just go to the action and post this up, give it will post for some time. And until you just restart this upkeep, no functions in your smart contract can be triggered in some use case. It will help the developers to save some gap. Okay, so I think all the demos are done and yeah, let's just continue the slides.
01:37:22.462 - 01:38:13.234, Speaker A: So this is the last service I introduced and demoed for tonight's workshop and for the use case of the chain and automation. Actually we have a lot of things to do with this service. The first one, you may want to use this in the yield harvesting and compounding. Sometimes if you have experience to do some liquidity mining, you just stake some of your tokens in the protocol and you get some yield. You want to claim your yield and then reinvest your yield into your staking and increase your money in the compounding rate, well you can use the chain automation to do this set of the transactions and it will be triggered in a very decentralized manner. And if you want to do some limit order for the Dex, Dex means decentralized exchange. So this is different from the centralized exchange.
01:38:13.234 - 01:39:32.586, Speaker A: In the dex there is not a central agency central engine to keep watching if your orders should be taken or not. So for example, if you want to buy a token, if the price drops from the $15 to the $5 you want to buy that you just cannot do this limit order on the deck because there is not an ending for you to see if your order should be taken or not. But if you use the chaining automation to set the predefined condition to see like if the price dropped from the 15 to five. And define this logic in your perform function, in your check function and in your perform function you just add an action like a swap, the token and by doing this and chain automation will serve as that engine. Keep watching if your order should be taken or not. And for some defi protocol maybe sometimes when the price of the asset dropped greatly, they want your asset liquidity and they want someone to keep watching the price and it just triggers a function to liquidate this kind of the asset. You can also use the chain automation for this logic.
01:39:32.586 - 01:40:12.086, Speaker A: And last one is the dynamic NFT. That is also my favorite one. If you want to bind some conditions in the real world, or if you want to change the metadata of the NFT based on the time or based on some conditions, you can use automation to automatically update your dynamic NFT. Okay cool. So these are all the services I want to cover tonight. And next one I will just spend a little bit of time to share some channel. You can talk with the chaining team during the hackthon.
01:40:12.086 - 01:40:54.162, Speaker A: And the first one if you have any technical questions you can directly go to the docs chain link. You can find everything I talked tonight in the documentation. You can find every service on the documentation. You can find the sample code, the configuration information, and you can even find the video tutorial in the documentation. So if you don't know how to use any of the service from Chinix, just go to the documentation and get some help. And if you really have some specific question, or if you want to debug your smart contract, we have two channels. The first one you can post your question in the stack overflow.
01:40:54.162 - 01:41:38.706, Speaker A: That is a QA website for the developers and post your questions here. But don't forget tag the chain link for your question. And if you tag chain link for your question, we will definitely answer your questions. And if you want to talk with some node operators, you want to find some developers who want to talk with George, talk with speaker, go to the chain official discord and we will be there. And you can also check other news about the chain link in the discord. And if you want to contact me, here is my handle in the axe and LinkedIn. And I hope everyone have a good time in this hacksaw.
01:41:38.706 - 01:42:08.630, Speaker A: And I'm really excited to see your project in this hacksaw. And good luck to everyone. That is all I want to talk for this workshop. And thank you everyone. Thanks for your time. Thanks for coming to this workshop. Yeah, thank you everyone and let me see if you have any questions? Okay, looks like there is not a lot of questions.
01:42:08.630 - 01:42:30.510, Speaker A: Yeah. Thank you, Frost. Thank you, Raj. And thank you, the four lights. Thanks, everyone. If you have any questions or if you want to contact me or you want to ask any team members from the chain link, go to the channel I listed it here. And hope everyone have a good time.
01:42:30.510 - 01:42:35.290, Speaker A: Hope everyone have a good rest of the day. Thank you very much. See you.
