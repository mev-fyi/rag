00:00:01.130 - 00:00:15.774, Speaker A: All right. Hello, everyone. Thank you all for coming. So, I'm Joanne. I'm a product manager and developer evangelist at Chainlink. So today I would like to discuss the problem that you are solving at Chainlink. So the smart contract connectivity problem.
00:00:15.774 - 00:01:01.082, Speaker A: First off, why do smart contracts matter? Why do we like smart contracts? Why is they super practical and super, well, revolution array? First, smart contracts have some really key properties. They are deterministic, they are reliable, they are temper proof. Whatever input you have into a smart contract, you will know the output. Now, that's a big change from the digital agreements that you have today. So in today's world, for a derivatives contract, for an insurance contract, for trade finance, it can always be delayed, right? So let's say a payment needs to be done once the package is delivered. Well, for some reason, this payment could be delayed by a third party, which could act maliciously or just be unreliable.
00:01:01.146 - 00:01:01.422, Speaker B: Right?
00:01:01.476 - 00:01:48.160, Speaker A: So basically, digital agreements of today are quite unsure. They are unreliable. And if we have a choice to basically have our world economy turn into something that is better, that is more secure and more reliable, then we should probably do it, right. So smart contracts are great, but why are we not using them today? Why today? Don't you have all the enterprises, the businesses using smart contracts? Well, currently smart contracts cannot communicate with the outside world. It means that the real world data, so market fields, IoT data for trade, finance, for insurance, all of this stuff is not accessible on smart contracts. So basically they are siloed. And that's where the interoperability aspect comes.
00:01:48.160 - 00:01:58.898, Speaker A: If you don't have access to real world data, you have access to nothing. Basically, you have access to the data that's on the blockchain. This data is not going to change over, you're not going to make a.
00:01:58.904 - 00:02:00.034, Speaker B: Lot of stuff with it. Right.
00:02:00.072 - 00:02:40.682, Speaker A: So let's go over the history of smart contract to basically see where we came from and where we want to go. So at first, when bitcoin came, we had multisig. So basically multisig, if you had multiple signatures, you allow the transaction to happen. So here you got a couple of inputs which were the signatures and the outputs, which would always execute, was allowing the transaction to happen. Then we got protocol upcode, smart contract. So basically you had a smart contract, you wanted to embed it into the protocol. You had to contact the protocol developers for them to kind of implement your smart contract.
00:02:40.682 - 00:02:55.730, Speaker A: So that's a very bad approach because first it's very lengthy, it takes time to implement, and it's very insecure because you have to modify the protocol, control the protocol codes each time. You don't want to start touching protocol code every time you want to implement something.
00:02:55.800 - 00:02:55.998, Speaker B: Right.
00:02:56.024 - 00:03:14.810, Speaker A: It's very unsecure. So then we got ethereum, the savior basically, which created a ten x improvement on what you had before. Now you are able to have smart contracts which could be rolled up in a few, well hours, few days, and without needing any protocol change.
00:03:14.880 - 00:03:15.546, Speaker B: Right.
00:03:15.728 - 00:03:42.738, Speaker A: So when this happened, we saw the wave of tokens emerging. So basically people had the freedom to start coding up tokens, releasing them on the blockchain. And that's what happened. If you give developers tools, they'll start building and they'll start creating stuff that you didn't think of before. So that's what happened. We had a lot of tokens being created and that's fine, that's great. However, it didn't change the word, right? Like nothing got disrupted, really.
00:03:42.738 - 00:04:30.430, Speaker A: It kind of created a movement. But if we want to take it further, if you want to kind of disrupt, to kind of create something better, more transparent, more secure for the enterprises, the businesses, then we need to go a step further. What is a step further? It's basically allowing smart contracts to have access to real world data. So real world data, what are those? Well, market prices, insurance, like basically everything that can be in a digital agreement. As of today, we need to have it on the blockchain. We need all the important inputs to be fed into smart contracts to trigger reliable contracts which can basically allow you to have services which you had before in digital agreements, but which were unreliable.
00:04:30.510 - 00:04:30.802, Speaker B: Right.
00:04:30.856 - 00:05:20.834, Speaker A: So basically, to kind of explain what I was saying here, we have basically data providers, which would be market prices, which would be IoT data. And basically those will allow you to have smart contracts. For instance, if you want to track the package delivery of a package, right? So you have multiple API endpoints which are feeding you, which are tracking a certain package. Once this package gets delivered, you will have access to a payment, right? So you want to do a payment, let's say, in bitcoin. So basically, in this case, you need to have access to the price of bitcoin. So you need multiple data fins to provide you with this price. So that's what I'm saying.
00:05:20.834 - 00:06:08.638, Speaker A: Basically it's having inputs which will basically allow you to trigger a smart contract, which will do a payment which will basically generate an output. And in this case, you need for the insurance contract. I was discussing the tracking of the delivery of the package delivery and the price of bitcoin, for instance. So you have multiple use cases with Shannon, you have the inputs, the outputs, and being able to communicate across blockchains, basically all of this is fine. We want secure input, we want secure outputs. And how do we achieve it? Well, first let's talk about how not to achieve it. Let's say currently if you were to use centralized Oracle to trigger a smart contract.
00:06:08.638 - 00:07:02.466, Speaker A: So let's say you have one Oracle feeding data into a highly secure, highly decentralized computation system which is built on Ethereum, a smart contract. Now this system doesn't make much sense, right? Because you have the middle piece, the smart contract, which is very secure, and then you have the input which relies on one centralized oracle, which means that if your input gets corrupted, gets hacked, or is just malicious, then your contract will be triggered for no reason whatsoever. So you basically don't want to have an architecture where the middle part is very secure, where the inputs and the outputs are insecure or centralized. So in this case we strongly advocate against such a system, which wouldn't make sense. You want end to end reliability. Your system is as secure as the weakest part of your system.
00:07:02.568 - 00:07:02.978, Speaker B: Right?
00:07:03.064 - 00:07:44.654, Speaker A: So how do we have end to end reliability? Now at chainlink we have multiple approaches to it, right. Our main approach that you are using right now is decentralization. So very similar to Ethereum to bitcoin, where you have multiple actors. Each of these actors has a version of the state of the network. So basically of the block that should be appended to the blockchain. Well, here each oracle has a version of the data that should be fed into the smart contract. And probabilistically we can assume that if most oracles have the same version of the data, then this data is probably reliable.
00:07:44.654 - 00:08:28.954, Speaker A: It's probably the right data, right? Very similar to consensus in bitcoin or in ethereum. So we are using decentralization to find out what the right data point is, what the source of truth that you'll be using in your smart contract is. So that was the example I was talking about previously, but I forgot that I had the slide here. So too bad. Well, just to go over it, you have a delivery package API, which is easypost, which will feed data into your smart contract. You have multiple oracles to do this. Basically, having multiple oracles feeding you the same data source is important because if you had only one, if it was taken down or malicious, it could probably lie.
00:08:29.002 - 00:08:29.214, Speaker B: Right?
00:08:29.252 - 00:09:14.218, Speaker A: So having multiple ones is an insurance for security and for reliability. So once your package got delivered, something will be triggered inside the smart contract which says, okay, package got delivered. I should make a payment. How do we make this payment in bitcoin? So you have multiple oracles, each one of them using data provider, which will basically feed the right price for bitcoin. And you can now make this bitcoin payment from your smart contract. So that's basically how we envision. That's a simple use case, right? But you have so many out there, like let's say for insurance, you could have, the new Tesla cars have a black box in the car, right? So you could have IoT data feed data to your smart contract.
00:09:14.218 - 00:09:27.710, Speaker A: Whenever a Tesla car gets into an accident or something similar, the black box will signal it to the smart contract and you'll be able to reimburse automatically using an insurance contract the person who got into the accident.
00:09:27.790 - 00:09:28.130, Speaker B: Right.
00:09:28.200 - 00:10:16.862, Speaker A: So that's another example. And you have so many out there, basically every digital agreement can be transformed into a smart contract. Basically our line of body of work at Chainlink is creating multiple chain links, multiple oracle and data providers, which can allow you to have all the functionalities that basically currently iOS developers or Android developers have. Whenever you create. Uber was created, for instance, you had access to Google API, right? You had access to SMS API, to payment API. Well, we want to have the same for smart contract developers. We want to give you guys the tools to have access to whatever API you need to build complex systems which can one day disrupt and revolutionize digital agreements.
00:10:16.862 - 00:10:25.654, Speaker A: Basically, it's about making smart contract the main form of digital agreements in today's societies. And for this you need the right tools to do it.
00:10:25.692 - 00:10:26.280, Speaker B: Right.
00:10:26.970 - 00:11:17.218, Speaker A: So that's basically our vision now on our security. We have multiple approaches, right? But the more secure the better. If you are going to trigger smart contracts where basically billions or trillions of dollars could one day depend on, you need very highly secure inputs and outputs. So decentralization is one approach, we have another one which is called the TE, trusted execution environment. So Chenlink recently is working with IC three, basically ic three developed towncryer. Towncryer is basically an oracle, which is using the trusted execution environment to feed data into smart contracts. So tes have some very interesting properties.
00:11:17.218 - 00:11:49.454, Speaker A: First one is they have a very small attack surface. So whenever you're using zote, it cannot be accessed by the os or the application. So there is a very small attack surface on this kind of hardware which is trusted execution environments. And how does it work exactly? So what is the TE and how do we use it? Like Towncryer for instance. Let's say you want to feed data into a smart contract. So you'll have a town crier contract on the blockchain. It will get a request from a user's contract to provide data.
00:11:49.454 - 00:12:18.778, Speaker A: It will ask the node operator, which is running a trusted execution environment, to provide this data. And this node operator, like zote, is composed of an enclave, and an enclave is a part of the trusted execution environment, basically, which guarantees you confidentiality and integrity. So no one can see what the node operator is running, and even the node operator cannot see what code he's running.
00:12:18.864 - 00:12:19.114, Speaker B: Right?
00:12:19.152 - 00:12:55.330, Speaker A: So basically it allows you to be fully confidential in what you're doing. And this property of confidentiality and integrity allows to have many use cases. The first one is basically off chain computation, where you can send encrypted codes to the trusted execution environment. It will decrypt it, it will compute it, and then it will send it back. So that's one of the properties. Another one is being able to manage credentials. So now that you know that trusted execution environments allow you to be fully confidential, fully private, even the node operator cannot access it.
00:12:55.330 - 00:13:37.262, Speaker A: It means that basically you can send credentials to it and no one will be able to see what these credentials are. So let's say you want to do a payment using a banking API or PayPal, whatever, you'll be able to send these credentials to the trusted execution environment for it to be processed. And it's the same for private keys. I think a very nice property which you should be able to appreciate is basically being able to use private keys which can be managed by node operators running tes. And since no one can see this private key, it can just be sent, and it can allow to sign transactions on other blockchains.
00:13:37.326 - 00:13:37.794, Speaker B: Right?
00:13:37.912 - 00:14:18.906, Speaker A: Using the nice property of confidentiality that trusted execution environment offers. So, yeah, let's not go too much into this. Yeah, basically, I think that's mostly what I wanted to discuss. So just quick recap, I think it's important to understand that inputs and outputs, like what we are trying to do at Chainlink is really securing and connecting the real world data to smart contract to the blockchain world. So you can never be too secure to do this. That's why we want to use defense in depth approach. We use decentralization, we use threaded execution environments, and we are going to use many other solutions.
00:14:18.906 - 00:15:26.494, Speaker A: So we are thinking about many other ones. So we want to be able to connect all the real world data into smart contracts for you guys to be able to develop compelling applications which can one day disrupt today's digital agreements. So basically, our mission is to give you guys the tools to build stuff that currently can be built with applications such as iOS and Android, be able to build these applications on the blockchain and leverage the smart contracts which have such nice properties, such as not relying on third parties, being deterministic and so many others. So it's basically building tools which can allow to build more secure, more transparent and more efficient systems for developers. That's about it. Also, we've been on the mainnet for I think two weeks, so we are currently ramping up more and more on our integration site. So I don't know if you guys saw the Google announcement recently where Google will be using Chainlink to provide bigquery data into Ethereum.
00:15:26.494 - 00:15:58.734, Speaker A: So basically Chainlink is used as a middleware to do this. And we have partnerships with Swift, we have partnerships with many crypto companies and blockchains. And we want to make this vision come true, which is to basically interoperate between crypto and the real world. We want to kind of take crypto out of the intranet where it is currently. Basically it's very siloed and it doesn't communicate with the real world and take it to something that can really kind of change the world, basically. So, yeah, that's it. Thank you.
00:15:58.734 - 00:16:00.640, Speaker A: And if you have any questions. Happy.
00:16:05.010 - 00:16:18.438, Speaker C: Hey, thank you very much. It was a great talk, this tee trusted execution environment. It's something like super revolutionary to me. Is it already something that works? Can I see it somewhere in the code?
00:16:18.524 - 00:16:40.826, Speaker A: Yeah. It has a lot of promises. It also has some vulnerabilities. Currently many companies are working on it. Intel SGX arms also is using its own implementation. So you can go to Tanquire website and see basically in production use cases. But it's, I think too early to have contracts rely with billions of dollars on it.
00:16:40.826 - 00:16:59.060, Speaker A: So it has a lot of promises. It could really revolutionize a lot of stuff we are doing currently, but still takes more time. I think it's the second layer of the defensive depth approach. The first one that you have to remember is decentralization. Second one, which is very nice to have is t. If it works. It's huge.
00:16:59.590 - 00:17:10.070, Speaker D: Just wanted to confirm a bit the architecture really quick. So Chainlink has its own network. It's its own chain and it has permission to write to contracts on Ethereum with real world data.
00:17:10.220 - 00:17:19.474, Speaker A: Yeah, so sorry, Chainlink is not its own chain. So basically chainlink deploys smart contract on Ethereum. Currently we are doing Ethereum, but we are blockchain agnostic.
00:17:19.522 - 00:17:19.686, Speaker B: Right.
00:17:19.708 - 00:17:46.874, Speaker A: So we want to be on every big blockchain where smart contracts are developed. So there is a smart contract on Ethereum, this smart contract, which will receive a query from a user contract. The user contract wants to get some piece of data, market prices, IoT data, whichever, you know. So it queries a chain in contract, which will query an oracle node, which is off chain. And this oracle node will query data source, will fetch data from an API endpoint.
00:17:46.922 - 00:17:47.182, Speaker B: Right?
00:17:47.236 - 00:18:06.902, Speaker A: Or multiple API endpoints. So that's the way it is. And so it's not its own chain. However, we have node operators to run these nodes, basically, these oracle nodes we are talking about. So it's not its own chain, but it has its own kind of economic system and game theory system. Yeah. Great.
00:18:06.902 - 00:18:08.200, Speaker A: Thank you. Thank you.
00:18:10.170 - 00:18:11.460, Speaker C: Okay. Thanks so much, John.
