00:00:02.730 - 00:00:50.898, Speaker A: Gm. Gm. Everyone, welcome, welcome to one more constellation Hackathon. Hope you guys have been having a great week. While I'll give a minute for everyone to settle in, feel free to drop in the chat where you're watching us from. How's your hackathon project going? We're so excited to see what you guys build. And with me today, I have sahil sen from quicknote and he will show us a step by step tutorial on how you can build a cross chain NfT that are minted in one chain and transferred to another chain using the one and only chainlink CCIp.
00:00:50.898 - 00:00:55.950, Speaker A: So sahil, with that, the floor is yours.
00:00:56.370 - 00:01:47.774, Speaker B: Thank you so much Sophia, for that great introduction. And thank you so much chainlink and constellation hackathon team for having me here. So yes, as Sophia already mentioned, today we will be seeing how one can mint an NFT on one chain and then how that NFT can be transferred to another chain. And all of this will obviously be facilitated with the use of Chainlink's CCIP network or the cross chain interoperability protocol. So before starting, let me give you a really quick introduction about myself. I am Sile Sen and I work at the Quicknote team on the developer relations team where we create a lot of educational content. Where we create content for people to help them.
00:01:47.774 - 00:02:25.958, Speaker B: Getting started with web3. Getting started with different, different new technologies just like CCIP and yeah, that's what we do and that's what I am going to do today. I will show you all how to mint NFTs across chains. So for the purpose of the demo, I have created a GitHub repository. I will also link this repository in the chat. So I'll just give the link to the chain link team so that they can paste it in the chat as well. And the first step would be to obviously clone this repo.
00:02:25.958 - 00:03:07.480, Speaker B: So I'll quickly clone this and don't worry, I'll explain all the parts of the repo. Like what are the contracts, what are the scripts and everything which we have in the repo. So first of all, I will do NPM install to install all the dependencies which we have in the repo. And let me then also explain what are the dependencies which we have used in the repo. So this is how our code base looks like. We have. Let me zoom in a bit.
00:03:07.480 - 00:03:58.882, Speaker B: Okay, we have three contracts and contracts in the Utils section. By the way, this is a hard hat smart contract deployment environment. We have few contracts. Three contracts over here, one contract in the utils part, we have few tasks which we will be using to deploy our contracts, deploy our NFT across the chain and to get all the constants of CCIP we will go through each and every file. But I'm just giving you a brief overview how the structure of this directory looks like. And then we have a hard hat config file which is a custom hard hat config file. And then these are the packages which we have used to create this repo.
00:03:58.882 - 00:05:09.610, Speaker B: Obviously the chain links contracts. We have imported the ChainLinks contract library, the ChainLinks CCIP Contracts library, the chainlinks encoded environment variable library and the hard hat toolbox which will be used to interact or deploy the smart contracts, the ethers library to interact with the smart contracts and to interact with the blockchain in JavaScript and of course the hard hat main library because our entire project is based on hard hat. So first of all, let's go to the hard hat config file. Let's see what it's all about and how it looks like. So over here we are importing the encoded environment variable of chainlink and then just importing the config from n file. We haven't created the N file yet, but this is all we will require to import things from the N file. And then we are just importing the hard hat config and the hard hat toolbox.
00:05:09.610 - 00:05:47.254, Speaker B: We will also need to import the tasks folder once we have compiled our smart contracts. But we don't need it now. So that's why it's commented right now. Then we will import these three files or these three variables. I'm sorry, these three variables from the environment variables. The first will be our private key which will be used to deploy and interact with the contract. The second will be the polygon Mumbai RPC URL which will help us to interact with the CCIP routers on the polygon Mumbai testnet.
00:05:47.254 - 00:06:54.622, Speaker B: The second will be the avalanche Fuji RPC URL which will help us to interact with the routers and chain link contracts on the avalanche Fuji chain. And then we are just initializing the variables by giving them chain id and everything. So polygon Mumbai's chain id would be 8001. Avalanche fugit's chain id will be 43113 and then we are just exporting default all the config. So now for an NFT we first need asset and then a metadata file. So our NFT metadata file will look something like this where we will have name, description, image attributes, traits, values, et cetera. So we also have it in here and our NFT the image for our NFT we will be using this image which is just an abstract note sticker.
00:06:54.622 - 00:07:41.630, Speaker B: So this will be the asset. And to upload it on IPFs let's just use the quicknote IPFs product because it's simpler. We just need to drag and drop the files or assets whatever we have to upload to IPFs. So as you can see, our NfT image is already uploaded. This was the image asset png. Let me quickly copy the IPFs URL and check if the image is accessible via IPFs gateway or so as you can see our image is accessible via the IPFs gateway. Lead Thai foreign this is our IPFS gateway.
00:07:41.630 - 00:08:24.910, Speaker B: So quickly copy the URL, go back to our files, enter the URL over. Okay, so now our NfT json file which is our metadata file have the updated nft metadata file. So I'll just open this in a finder window. Go back to our quicknode IPfs. And now we will have to upload the NFT metadata file. So that's what I'm doing over here. That should be uploaded.
00:08:24.910 - 00:09:01.674, Speaker B: Copy the IPFs URL again just to check if the file was uploaded or not. Okay, looks like it was uploaded. This is our metadata. The name will be qnccip nft. The name will be qnccip nft. Description will be cross chain NFt and the image URL will be the URL of the image which we just uploaded earlier. Asset png attributes trade type will be year, value will be 2023.
00:09:01.674 - 00:09:49.698, Speaker B: Another trade type will be sticker and the value will be moon man because it's a moon man sticker. So we just need the link of this metadata uploaded on IPFs and then we go to our contracts. And now is the part where we get into the contracts and I'll explain you each and every contract what it does. But first we just have to replace the link of the NFT metadata over here which will be token URL. This can be dynamic as or where user can input the URL. You can create the contract in such a way as well. But for the sake of the demo I will be hardcoding the value of the NFT metadata.
00:09:49.698 - 00:11:01.706, Speaker B: So we can just mint that NFT on the polygon chain and then the NFT will also be minted on the avalanche fug chain. So this contract over here which is mynft Sol, it is a very basic contract which inherits the ERC 721 URI storage contract from the open zeppelin. It gets the balance of NFT for a particular address. And also it stores the token URI which is the metadata of an NFT. And to actually mint the NFT we have two other smart contracts which is destinationmintor Sol and sourceminter Sol. So sourcementer Sol will mint the NFT on the source blockchain which will be the polygon Mumbai blockchain and it will also connect to the Polygon Mumbai router of CCIP. And it will do that using this library of CCIP and then it will send a message using the router to the destination minter.
00:11:01.706 - 00:12:20.938, Speaker B: And the destination minter will mint the NFT on the destination chain which will be the avalanche fugee chain. Even this requires to interact with the CCIP libraries over here it will interact with the CCIP receiver library. And once the NFT mint is successful on the destination side, it will emit a mint successful event which is over here and the Utils library is utils file or folder or directory has another smart contract withdraw Sol, which we won't use in this demo. But I have just added this because a lot of time you might want to create an example where your contract holds some tokens and it releases those token or you can withdraw those token whenever you want to. So this contract withdraw soul will let you hold the tokens in the contract. And then there is a task called withdraw ts which will let you withdraw the tokens Erc 20 tokens from this contract. But for today we won't use this.
00:12:20.938 - 00:13:02.818, Speaker B: We will just use destination minter, mynft solve and sourceminter solve. So Mynft solved will be used to attach the token Uri and get the balances of the owner of the NFTs. Destination minter will mint the NFT on the destination chain. Source minter will mint the NFT on the source chain. So now let's set the environment variables. So we will be using Chainlink's encoded environment variable library. So NPX and encoded set PW.
00:13:02.818 - 00:13:59.670, Speaker B: So first we will have to set a password for our environment file. All right, so now that's done, let's set the actual variables of the environment file or variable. So the first variable will be private key. And now I will have to enter the value of the private key. Make sure that you're entering a private key which is for your testing purpose or which does not have a lot of your funds or all of your funds. Make sure to not add your main wallet's private key because it can be a security hazard. And now we will need to add the polygon mumbai RPC URL.
00:13:59.670 - 00:15:03.482, Speaker B: So the value of the environment variable will be polygon mumbai RpC URL. Let's go back to quicknode, get the RpC URL. So the first one will be polygon mumbai and the second one will be avalanche fusion. So we will have to copy the HTTPs URL, paste it, and now the next one will be avalanche fugrpc URL. Let's go back, click on avalanche fug, get the HTTP URL, paste it, click enter and that's it. We don't need any other variable, so we'll click enter again. And now when we go to the code base again we will see this new file n is created.
00:15:03.482 - 00:15:53.230, Speaker B: It will have our environment variables and the values in the encrypted format. So even if you by mistakenly upload this environment variable in a public code sharing platform like GitHub, it's still secure because you have encoded it with your password. It's always better to use this kind of environment variables. And now what we can do is we can compile our smart contracts. So NPm hardheads, hard heart type. So this will compile our smart contracts and they will be ready to deploy to be deployed. So once this is done we can import our tasks.
00:15:53.230 - 00:16:49.466, Speaker B: And now let's understand what are the tasks files which we will be using or which are being used in this repository. So there are a bunch of tasks files. Tasks are basically hard hat healthier files which lets you deploy your smart contracts and interact with your smart contracts. So not all these tasks files will be used to deploy or interact with contracts directly, but some will be used to help in the process. For example the first one which is constants ps it holds all the constants. For example the fees pay in this will hold which tokens we have to pay. The fees in the first option can be a native token, native token of that particular chain or the link token.
00:16:49.466 - 00:18:00.114, Speaker B: So in CCIp you can pay fees in native token of that particular chain or even with link. So make sure that the private key which you are importing in the environment variable, it has some funds. So in this case, because we are using the polygon Mumbai chain and the avalanche fugitive chain, make sure that you have some testnet tokens or tokens on both the chains or it can even be link. But for now we will be using native and it also holds addresses of link tokens and the router contracts of CCIP on each chain. So we need the router on avalanche fug chain and Mumbai Testnet. The polygon Mumbai testnet and also the chain selector Ids. And then there is the utils ts which, which takes values from constant Ts and assigns them with their particular variables.
00:18:00.114 - 00:18:44.690, Speaker B: For example for network it will assign the values to RPC URLs from the environment variable. And for our case we are just using polygon Mumbai and avalanche Fuji RPC URL. And it will also have some. It will also have some conditions where if the environment variable is empty it will show you a particular message, it will get the private key. If the private key is not present it will give you error or a particular error. It will get the router config which we set in the constant file over here. We set the router config with the router addresses and chain selectors for that particular chain.
00:18:44.690 - 00:20:00.090, Speaker B: And then it will also get the fees pay in which we set it over here that the fees will be paid in either the native token or the link token. So that's what the util file is all about. And I think now we can talk about the helper chain, the helper task. So what helper task does is it will call the router smart contract on the sender side and it will simulate the transaction again to get the message ID. And this is required in the risk management process or the risk management network of the Chainlinks CCIP protocol. So the helper ts file will get the message ID from the simulated transaction and then it will send it to the risk management network. Then risk management network will verify it and send it on the sender side, sorry, receiver side and then the balance of Ts.
00:20:00.090 - 00:21:45.294, Speaker B: This task can be used to get the balance of a particular NFT for a particular address which we will be using. Once we have deployed all the smart contracts and once we have minted the NFT from one chain to another, this file will be used to fetch the balance of the NFT for a particular address and then the deploy destination minter file. This task will be used to mint the file will be used to deploy the destination minter smart contract which will be the smart contract which will be the smart contract which will be deployed on the destination chain avalanche fugee chain in this case and it will mint the NFT on the destination chain side and then the deploy sourceminter Ts file, this file or this task will be used to deploy the source minter smart contract on the source chain, the source chain being Polygon Mumbai in this case and then the crosschain mint Ts file. This file will finally be used to mint the NFT from the polygon Mumbai testnet to the avalanche Fuji testnet. And then we have an index TS file which basically imports all the task files which we have created. And apart from tasks, we also have a small utils file, which is spinner TS, which is just a small spinner. Just like this, you see a slash and a straight line.
00:21:45.294 - 00:22:45.790, Speaker B: So it's just a small spinner, which we will see in the command line interface where it's just a small spinner and it spins when our task is being done. So let me look for some comments if we have any questions. Until now, we will have some time during the end as well for questions. But looks like until now, we do not have any questions. So let's deploy our smart contract. Let's make sure that the task file is uncommented and we can use the task in hard hat config. All right, so now let's quickly deploy the destination minter, which is this smart contract, and Mynft Sol on the destination chain using the deploy destination minter task.
00:22:45.790 - 00:23:28.000, Speaker B: So that's what we are doing over here. NPX hard hat deploy destination Minter, which is this task deploy destination minter. And we are saying that do all of that on network Polygon Mumbai, which we set in our hat config file. Polygon Mumbai will use the polygon Mumbai RPC URL. So let's click on enter. And this is the spinner TS utils file, which we just saw over here. You don't need to add that, but it just gives a good touch.
00:23:28.000 - 00:24:06.950, Speaker B: So it looks like my NFT smart contract is already deployed. It's deployed over here. So until now, we have completed this. So let's add tick mark over here. Until now, we have completed this, where we have stored the NFT asset on IPFs as well as the metadata. We set up the hard hat and environment variables. We have already set up and compiled the smart contracts.
00:24:06.950 - 00:26:06.704, Speaker B: We have went through the hard hat tasks, and now we will just mint the NFT by first minting the smart contracts on the source chain and the destination chain. We have already minted our smart contracts on the destination chain, which is the my NFT smart contract and destination minter smart contract. So let's look at the address of my NFT smart contract and save it over here because we will need the address of these contracts to mint the NFT across chain and the address of destination Minter, which is this. Let me save it over here. And the address of my NFT smart contract, also saving it over here. All right, and now let's deploy the source Minter smart contract. So NPM hard hat deploy source minter network and the network's name will be Avalanche Fusion.
00:26:06.704 - 00:27:06.722, Speaker B: Our destination chain will be polygon Mumbai testnet. My bad. So we have the source minter address and now what we need to do is we need to send some native token of the avalanche UG testnet to the source minter smart contract. So go to your metamask and send some tokens to your source minter smart contract to cover for the gas fee and the CCIP transaction fee as well. So what I'll do is I'll just send 0.1 Avax which is the native token and that should be enough to cover for the gas fee as well as the CCIP fee. So let's wait for this transaction to get completed and once it's completed we will mint NFDs.
00:27:06.722 - 00:28:11.942, Speaker B: So to mint NFDs we need this command. Let's also save the source minter address. There it is. This is our source minter address. So our command will be NPX hard hat cross chain mint, which will use this hard hat task, cross chain mint and then the source minter address which will be the source minter address of our smart contract source minter address. Then the source blockchain will be avalanche fugee and the destination minter address which will be this and the destination blockchain will be polygon Mumbai. And then we are mentioning that pay fees in we say native.
00:28:11.942 - 00:29:02.894, Speaker B: It can also be link because in the constants file we have mentioned that the fees pay in or pay fees in can be native or link but we are saying that it will be native. So let's see if the transaction is completed or not. Doesn't looks like a transaction was picked up. Let's see if it's completed. Okay, looks like it's completed but it's not index because this is testnet. So let's see if our source minter has any token balance or not. Okay, looks like it has 0.1
00:29:02.894 - 00:29:46.294, Speaker B: avax. Let's go back. Let's copy this entire command which is hard hat crosschain Nft mint source minter will be the source minter address. Source blockchain will be avalanche Fuji destination minter will be the destination minter address. And the destination blockchain will be polygon Mumbai and payface in native token. So let's copy this command, paste it in our command line. So it's saying that attempting to call the mint function of the source minter solve smart contract on avalanche Fuji.
00:29:46.294 - 00:30:39.866, Speaker B: So it's basically now minting the NFT on the avalanche Fuji chain using our same account look like the mint. Okay, so the NFT was minted. Okay, so it looks like the NFT was minted and the crosschain message was sent. And this should be our transaction hash for the CCIP transaction. And now what we need to do is we need to go to the CCIP explorer and paste the transaction hash over here so it will fetch our transaction. Let me zoom in a bit. Okay, so this is how our transaction will look like.
00:30:39.866 - 00:31:22.730, Speaker B: On the CCIP explorer, it will have a message ID which is used to send the message from one chain to another. And to identify the message, it will have a source transaction hash which will be this. It will have a destination transaction hash which is not available yet. Because the message is still being sent and the source is just yet finalized. Once the message is sent, this value will be changed to delivered. It will show us the source chain name, destination chain name, transaction timestamp, of course. And it will show us the transactions on both the chains.
00:31:22.730 - 00:32:08.860, Speaker B: So this is the contract interaction on the avalanche Fuji testnet. And this should be the contract interaction on the Polygon Mumbai testnet. So, yeah, so until we are waiting for the transaction to get, or the message to get delivered on the destination chain, let's just look at the chat if we have any questions. And Sophia, if you want to pop in and see if we have any questions.
00:32:22.930 - 00:32:36.740, Speaker A: So, at the moment, there's no questions in the chat. So everyone has any questions, just drop them in and Sahil will be able to help you and answer them.
00:32:37.670 - 00:33:21.790, Speaker B: Yeah, because a lot of times a message can take around five to ten minutes, depending on the complexity, to get delivered from the source chain to the destination chain. Because CCIP has some checks, some security checks in the background to make sure that the message is correct and is delivered to the right contract or to the right address. They say it in the docs as well, that it does not focus on speed, but it focus on correctness and accuracy.
00:33:25.750 - 00:33:38.454, Speaker A: I think that was right on spot for the question that we just received. What is the average time for the message to be sent to the destination chain? Believe you were answering that one, right?
00:33:38.652 - 00:34:26.610, Speaker B: Yes, I just said that. So according to the documentation, it can be somewhere between five to ten minutes. And it also depends on the complexity. If it's just arbitrary message, it should be very fast. But since this was arbitrary message, along with a transaction, which is we are sending a message to mint NfT on the destination chain as well. So this one might take some time because as you can see, the status right now is blessed. Which means that the transaction was validated by the risk management network of Chainlink CCIP, which is an intermediary off chain network which keeps track of transactions and it either blesses or unblesses the transactions.
00:34:26.610 - 00:34:50.780, Speaker B: Blesses means that that transaction is validated by the network. And if the transaction is unblessed, it obviously means that it's not validated and it's not correct and it's discarded from the network. So our transaction right now, it's blessed, which means that it went through the risk management due diligence and it should be delivered pretty soon.
00:34:54.510 - 00:35:08.820, Speaker A: Thank you, Sal. Yeah. Any other questions, drop them in the chat. Last opportunity to get an answer from Sahil. We do have time though.
00:35:09.350 - 00:35:38.070, Speaker B: Yeah. And looks like our transaction was successful. The status is successful right now. So we can see the transaction on the Polygon Mumbai testnet as well. So as you can see, the NFT was transferred. Let me zoom in a bit. All right, so this was the transaction on the avalanche QG testnet.
00:35:38.070 - 00:36:38.480, Speaker B: And this was the transaction on the Polygon Mumbai testnet. So as you can see, the token Id zero NFT was minted from zero address, which is obviously the zero address. Whenever you are minting something to this address, which is the address which is the address which I used to deploy the contracts and the NFT as well. So we can also test if the NFT was correctly deployed or not. We can check for the balance for my address. So this will be my wallet addressing that hard hat balance of my NFT. And this will also need my NFT smart contract address.
00:36:38.480 - 00:37:44.956, Speaker B: Because we want to check if token of that smart contract is held by this wallet address or not. Okay, so as you can see, this account does have one NFT from this smart contract. Even though we minted the NFT on the avalanche fuse testnet, we can see that we do have the NFT on the polygon Mumbai testnet as well. So that's how you can mint an NFT from one chain to another chain. In this case, we minted NFT from the avalanche Fuji testnet to polygon Mumbai testnet. But you can basically do this same procedure with any chains supported on CCIP. And.
00:37:44.956 - 00:37:52.240, Speaker B: Yeah, that's about it. So if anyone has any questions, feel free to drop them in the chat.
00:37:54.020 - 00:38:34.830, Speaker A: Yep. We'll give you guys a couple minutes. If you have any final thoughts, any remarks that you want to close off.
00:38:37.600 - 00:39:07.764, Speaker B: I just want to say that I know that there are a lot of different. Different chains out there. And I get it. Each chain facilitates or provides to a particular use case. Some chain has very low gas fees. Some chain has very low finality time. So depending on your use cases, basically you can use CCIP to create very powerful applications.
00:39:07.764 - 00:39:53.472, Speaker B: Let's say that you want to utilize low gas fees of one chain and utilize the low finality time of another chain. You would be able to do that with CCIP, which was not possible until now. Because blockchains are designed in such a way that they are just isolated within their own ecosystem. Right? But with CCIP, that's not the case anymore. You can harness good parts of each blockchain and create really powerful cross chain multifunctional applications. So yeah, if you have any questions around this particular demo, or around even CCIP or quicknode, feel free to reach out to me. I am s e n s a h I l sin sahil on twitter.
00:39:53.472 - 00:40:11.660, Speaker B: And I think chainlink's team is very responsive as well. So if you can reach out to them as well. And yeah, thank you so much for staying until now, listening until now and hope to see really cool projects coming out of this hackathon.
00:40:12.480 - 00:40:44.512, Speaker A: Yeah, definitely. Thank you so much sahil, for being here with us today. Yeah, if you have any questions on TCIP, feel free to drop them on our discord or our amazing Deborah team will help you out. And don't forget, your deadline to submit your project is December eastern time. So it's coming up about 18 days left. So keep up the hard work. Keep hacking.
00:40:44.512 - 00:41:00.270, Speaker A: We are definitely super excited to see what you guys showcase us. And I hope you all have a great day. Evening, morning, whatever you are, located it and we'll see you on the next workshop. Thank you everyone.
00:41:00.960 - 00:41:01.690, Speaker B: Yeah, thanks.
