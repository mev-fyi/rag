00:00:08.040 - 00:00:39.240, Speaker A: Hello. Hello. What's going on, everybody? We're going to get started in about four minutes. Going to give some people some time to roll in. Just saying hello. How we doing? We don't have to start streaming directly to YouTube so that the quality can be better because I have a sweet camera. We're going to be talking everything chain link.
00:00:39.240 - 00:02:11.640, Speaker A: But we have about four minutes till we actually get started. But wanted to pop in and say hello. Going to go pop this into the discord that we are live. Welcome. You'll pop this on Twitter, too. Got three minutes left here. I.
00:02:11.640 - 00:02:38.444, Speaker A: Chainlink. Chainlink. Hackathon workshop. That's what this is. It's a workshop about Chainlink at the chain link. Hackathon. Hello.
00:02:38.444 - 00:03:26.738, Speaker A: Hello, BG, how are you doing? We got two minutes left. We're going to give people a couple of minutes to trickle in. I know we said this actually starts at 430, so we'll give it a couple more minutes. How are we doing today, everybody? Did you manage to get your testnet ETH? I did. I'm assuming you're watching my Twitter for rinkby. Is that what that question is in relation to delay between Zoom and YouTube is too much. Doing great.
00:03:26.738 - 00:03:40.022, Speaker A: Thank you. Awesome. Glad to hear you're doing great. Cool. We're just going to give it another minute, guys, and then we're going to jump into it. Do everything. Chain link.
00:03:40.022 - 00:04:00.922, Speaker A: We're going over everything. Okay. Not everything, but all the basics of chain link. All the basics of chain link. Really excited for this one. This is going to teach a lot of the skills needed to do the rest of the workshops and rest of the hackathon. Yes.
00:04:00.922 - 00:04:16.290, Speaker A: Saw your tweet. Yes, I got my ring pe. Thank you. Thank you for following up. Thank you for being so caring. Wait another, maybe another two minutes for people to kind of roll in. Feel free to ask questions during this session.
00:04:16.290 - 00:04:43.162, Speaker A: Happy to respond and chat like these workshops to be a little. Can't. The word isn't coming out. Hey, what's going on? Urban? I like these demos to be a little bit more interactive. I'm ready. Excellent. Irvin, I feel like you already know all this stuff.
00:04:43.162 - 00:04:59.270, Speaker A: You've been in the community, but I love it. Welcome. Glad to have you here. Just going to give it one more minute. There you go. There you go. Here live here for answering questions.
00:04:59.270 - 00:05:36.152, Speaker A: BG eleven. Cool. I'm going to go ahead and share screen now. You guys can see that's we're doing interviews at this time or. No, not interviews, but I'll do a Q and a for developer questions. How many people are doing this hackathon? Well over 3000 people signed up, over three k. So a lot of people.
00:05:36.152 - 00:06:12.824, Speaker A: All right, let's jump in. So we're talking about chain link and just everything about chain link. So this is for people who are a little bit newer to chain link, who don't want to get just a good idea of what is this technology can do, what is it for. Obviously, this is going to fuel the rest of your Dapp development for the rest of the hackathon. Using Chainlink is a requirement, obviously, for submitting and getting a prize here. But we're going to go into why any of this matters, why all this matters, why it's so important, and how we can really take our smart contracts to the next step. So hopefully, you guys got to see Sergey yesterday at the opening ceremony.
00:06:12.824 - 00:07:01.572, Speaker A: He actually went really deep into a lot of the conceptual and a lot of where we can go and what we can build next. And I'm going to go a little bit more technical so that you guys can have a better understanding from a technical perspective on what we can actually build. So we're going to be talking about connecting your smart contracts to off chain data, creating financial definitive truth APIs, probably random number, and just all these features that Chainlink enables for smart contracts and why oracles and specifically chainlink is so important to the entire ecosystem. So here's a little bit of the layout of what we're going to do. So this is scheduled for an hour and a half. Again, would love to make this interactive. I will be periodically checking the comments here so we can kind of go wherever we want to go with this presentation.
00:07:01.572 - 00:08:20.596, Speaker A: But yeah, we're going to be going over what is this thing? What is this chain link and how does it work and what can we do with it? So first thing we really need to understand in order to really understand chainlink is we need to understand the oracle problem. We need to understand blockchains, we need to understand that smart contracts can't connect to external systems, right. They can't access data feeds, API, existing payment systems, or really anything that makes the web work. Today, this is obviously a huge issue because as hopefully some of you guys went to the earlier talk with intro to blockchain, intro to smart contracts, where we talked about how smart contracts are these superior digital agreements. Having an agreement between two people without any data means you can really only do very specific agreements, which is fine, but not the generation shifting paradigm that we really want blockchain to be. And that we want smart contracts to be. So this is kind of an issue, right? And the reason why they can't do this is the reason they're these walled gardens and they can't connect to the real world is because they're deterministic systems, right? So a blockchain, every single node that's running needs to be able to check on every single other node and say, are you returning the same value that I am? Right.
00:08:20.596 - 00:09:07.308, Speaker A: And if they're checking on random numbers or APIs, that could change. One node is going to say, hey, my random number is seven, another node is going to say, hey, my random number is 24, they're never going to reach a consensus. And this breaks the deterministicness of the chain. So blockchains can't make API calls, they can't access the real world. And this is the first part of the oracle problem, right? And so obviously due to this they can't connect, know, like you see, you know, events data, market data. They can't connect to any of this. And this is a huge problem because again, the smart contract, the agreements can't really do anything more than like token transfers, which is still great, but isn't this superior digital agreement that we need blockchain to be? So this is where chainly comes in.
00:09:07.308 - 00:09:37.676, Speaker A: This is where oracles come in. So a blockchain. Oracle is any device that interacts with the off chain world to provide data to smart contracts. They report the data on chain so the blockchains can stay deterministic. So they report in a transaction, they report the data on chain so that your smart contracts now have access to data that is useful, which is really helpful. So that's the first part of the oracle problem, is that blockchains can't really access real world data. The second part though is almost more important.
00:09:37.676 - 00:10:33.304, Speaker A: The second part is that centralized oracles are a massive point of failure. So if we have a blockchain and we have oracles, right, and we're getting data from the real world, but where we're getting the real world data from is from a single centralized point. Well, that kind of defeats the purpose of building smart contracts in the first phase, right? So we have this decentralized computation or this decentralized logic layer in our smart contracts, in our solidity contracts that we code, it's all decentralized because it happens on all these nodes across the network. But if we get our data from a single point, a single oracle, now we have this single centralized point of failure and it almost defeats the purpose of like I just said building a smart contract in the first place. So we want our logic layer decentralized and our data layer decentralized. Otherwise, again, if somebody can just turn off the node, turn off the data, our smart contracts are moot and useless. And smart contracts, they auto execute.
00:10:33.304 - 00:10:53.328, Speaker A: They don't know that they're running with a central point of failure. So this obviously doesn't work for oracles here. So we can't have centralized points of failure. And this is a crucial piece of where chainlink comes in. So there are these two problems. The oracles smart contracts can't access external data. Centralized oracles are huge points of failure.
00:10:53.328 - 00:11:31.120, Speaker A: So the answer to this is chainlink. And this is why Chainlink is so phenomenally powerful. Chainlink is this decentralized oracle network. Chainlink's designed to be a modular, decentralized oracle network for getting secure, reliable data. So it actually brings data on chain through an entire network. So many different chainlink nodes actually get the data, report it on chain so that it's A, decentralized and B, getting data from the real world. This is incredibly powerful because now your smart contracts can interact with the real world, interact with real world data and do really anything.
00:11:31.120 - 00:12:07.452, Speaker A: Right. APIs are what the current web and Internet and technology and software runs off of right when they want to connect to each other. So we're going to use those same tools that the current world runs off of and just add them into the blockchain world. So this allows your smart contracts to really do any input and any output. So these oracles are bi directional. So you can send requests or you can get requests, you can do whatever you want to do, which really unlocks this functionality. Your smart contracts to have unlimited potential because you can work with any data or send any request or do literally whatever you want to do.
00:12:07.452 - 00:12:47.690, Speaker A: Obviously incredibly powerful. I'm going to pause for a quick second and look at some questions in the comments here. Hi, can you give me an example of how zero knowledge proofs could be used with Chainlink currently? This is probably a longer conversation. Does it make sense to commit data on blockchain, then generate the proof off chain? This is probably a longer conversation, but I think that would be really cool. Really cool. All right, great. Thank you for the comment there.
00:12:47.690 - 00:13:10.272, Speaker A: This is chain link, right? And this is why chain link is so important. So let's dive into that a little bit more. Right. Let's talk about DFI. DfI obviously being massive right now, right? There's $40 billion locked in DFI. DFI stands for decentralized finance. Now, in financial institutions, you need data, specifically pricing data, most often pricing data.
00:13:10.272 - 00:14:17.204, Speaker A: If you want to know the price of an asset when you buy and sell it, you probably should have the price of that asset so you can buy and sell it. So Chainlink has actually gone ahead and found many of the best node operators on the planet and collected their prowess to build what's called price feeds, or data feeds. So these are decentralized networks that are incredibly high quality, and each node operator is independent, each independently getting data, reporting it on chain, and having it aggregated. Now, it's actually aggregated off chain with the release of OCR and the cryptographically signed. But in any case, the data is aggregated and on chain so that you have this kind of out of the box decentralized data that any developer can kind of reference, use and run with. Right? So right now, many of the most popular feeds are available, and you can even head over to data chain link, check it out, and it just got a makeover, which is really cool. I got to update my presentation.
00:14:17.204 - 00:14:39.630, Speaker A: I forgot that we just released this, but now look at this. It's so cool. So these are the different oracles that are responding with data here. And here is the trusted answer. So this is the aggregation, we can see a heartbeat deviation threshold, obviously. This is so cool. Oh, it's so nice.
00:14:39.630 - 00:15:09.604, Speaker A: For those of you who remember the old user interface, this is just so much cleaner. But each one of these nodes is responding, and you can see what each node is responding with. You can click on a node, you can see kind of their history as well. But this data is already decentralized, so people can just grab it and run with it, which is incredibly powerful. And we'll talk a little bit about why it's incredibly powerful. So here's a little bit more to the approach here. It's highly decentralized, civil resistant, provably secure nodes.
00:15:09.604 - 00:16:04.916, Speaker A: All these nodes have been audited, really high quality data, large open source community. And these are blockchain agnostic as well. And then chainlink in general is blockchain agnostic, which is why you see so many fantastic sponsors at this hackathon, like Solana, like Polkadot, like IPFs, Filecoin. There are a ton of layer ones and layer twos, or, excuse me, Polygon, because Chainlink can adhere to whatever blockchain needs, which is incredibly powerful. Other than the fact that it's super easy to access and work with this data. It's also important to have on the other side because you don't want to get hacked or attacked back in November, actually, of last year. So, like, what, three or four months ago, we saw about $30 million in attacks, or it was like 40 million or something like that, all from centralized oracle attacks.
00:16:04.916 - 00:16:37.516, Speaker A: So some protocol was using some type of oracle that wasn't secure. The oracle got attacked and they lost millions of dollars. So not only are the data feeds really easy to work with, really easy to work with, incredibly powerful, incredibly accurate and secure. But if you work with faulty oracles or faulty data, that is the recipe for getting hacked or rug pulled or whatever you want to call it. So this is a quick snapshot of DeFi. It's actually probably a month or two old. And this industry moves so fast that it's probably already out of date.
00:16:37.516 - 00:16:53.796, Speaker A: And by probably, I mean definitely already out of date. And you can see some of the protocols that Chainlink is actually feeding data to right now. Right, so, synthetics. Well, this says 1.5, but I think it's more like 4 billion. Right. They're another protocol that's actually sponsoring this ax fund loop ring.
00:16:53.796 - 00:17:16.400, Speaker A: It's much more than that. Set protocol. More than that. Avia, I think they're like four or 5 billion right now. But these data feeds are battle tested with these insanely powerful DFI protocols. And these data feeds are helping secure something like $10 billion in DFI right now. A lot of these top projects are using these data feeds, so they're just incredibly easy to use.
00:17:16.400 - 00:17:49.210, Speaker A: Jump in, start building, start coding, getting your data feeds, and just going. So, really powerful feature here. So I will stop again real quick and I will turn off my slack. We'll stop again real quick and look at questions again. Most of the use cases I see have been seen getting data but not sending data. We will show you sending data soon. How can we add a custom data feed? So, for sure.
00:17:49.210 - 00:18:19.370, Speaker A: So on here, you can request a feed, get some node operators together or yourself, you can get some node operators together and start building a feed. So if you request a feed, you can talk to kind of a group of node operators and see if they can get a feed together or. Yeah, just request some of the core engineers and they'll see what they can do. All right, cool. Good question so far. Let's keep it going. Excuse me.
00:18:19.370 - 00:18:55.516, Speaker A: So that's data feeds. Data feeds are insanely powerful, and you can build unlimited stuff with data feeds, and they are crazy easy to work with. They're pretty much my go to whenever I'm trying to build something. Right because I can do pretty much anything with data feeds. If you want to accept any payment, you can swap currencies with data feeds. It really makes building easy, and I absolutely love it. So the next piece that we're going to talk about is Chainlink VRF or Chainlink verifiably randomness function and why this is such an insane accomplishment and such an insane feat.
00:18:55.516 - 00:20:14.264, Speaker A: So Chainlink VRF is a way to create random numbers in a provably random way, which is kind of crazy to think about that. You can prove that a number is random. I can prove I rolled the dice in a random way, but it's actually possible on smart contracts. However, the current issue with smart contracts is that smart contracts are deterministic systems, right? So since they're deterministic, if you want a random number that's deterministic, that's not really possible, right? So getting a random number inside smart contract world is basically not possible. And if you know a lot about computer science, you know that even random numbers, when you do like math rand or in JavaScript or in Python or whatever, it's still pseudo random, right? But it's random enough that we kind of are like, okay, in the blockchain world, it's not random enough that we're okay. Because if somebody can determine the outcome of your smart contract, that's really bad, right? Because then obviously if everyone knows the winning lottery number, no one's going to play that lottery, or everyone's going to play that lottery and just pick the winning lottery number every single time. So the current methods for getting random numbers are using like a cache, however you say it, are doing a hash of the block hash.
00:20:14.264 - 00:20:58.736, Speaker A: And this actually gives the miners kind of this unfair advantage on what the number is going to be. So again, if you have a smart contract where there's a lot of money on the line, they're highly incentivized to influence that random number, which ruins the fairness of your smart contract. So Chainlink VRF is a way to get a provably random number into your smart contract. So you make a request to a chainlink node off chain, it generates a random result and returns it on chain in a provably deterministic random way. So this is obviously really powerful, and it's a way to get your smart contracts to using provable randomness. So pull together Avengochi. These are some different protocols that are using BRF.
00:20:58.736 - 00:21:20.450, Speaker A: It's actually available on mainnet today. Check out docs chain link slash chainlinkBrf. And it's a great way to get RNG into your smart contracts. How would the data feed look like for. This is a good question, actually. How would the data feed look like for weather data? It's a great question. So actually it would look pretty much the same.
00:21:20.450 - 00:22:02.696, Speaker A: Let me scroll down and see if there's any other data feeds that are non price. I think that we have like gas, I guess it's gas price, stablecoins, proof of reserve commodities, ethereum gas sponsors. So we would probably look pretty much the same, right? So let's just pick a top one again. This UI is so nice. It probably would just look exactly like this, but instead of like a number, it would be like temperature. Well, it would still be a number, but it'd be like temperature, right? Or precipitation percentage or humidity percentage or wind level. I don't know how they calculate that, but that's basically what the price feeds would look like.
00:22:02.696 - 00:22:35.880, Speaker A: Or the data feeds. It would be the same thing. Just this wouldn't be a me, this wouldn't be a dollar value, it'd be like degrees or something. Good question. And again, the last bit in the minimum piece of Chainlink that makes this all happen is that Chainlink is able to call any API request any data or post any data and really do anything. So the documentation has a ton of super. I reference the documentation all the time.
00:22:35.880 - 00:23:06.464, Speaker A: Docs, chain link, the last piece, this is kind of like the smallest unit of chainlink is just making requests. Right? And this is the documentation here of doing that. You can see we even have like an API call here. So whoever was just asking, oh, I've seen all about getting data, but what about sending data? Well, great, you just make an HTTP post request instead of a get request. So here's the documentation on making any API call. Actually, I think I hit the rate limit on this, so I think I can't. Oh, I didn't.
00:23:06.464 - 00:23:29.016, Speaker A: Yeah. Okay, so this is like the response of an API. We're going to go into this example in a little bit. So I know a lot of you guys are looking for ideas and looking for different things. Here are some of my favorite ideas. There's also the 77 smart contract use cases enabled by chainlink. Decentralized finance is obviously huge and going to continue to be huge.
00:23:29.016 - 00:24:06.544, Speaker A: Fantasy sports, Texas hold them different. Any different types of games and gaming, especially with polygon being a sponsor here and the fees being so cheap, that looks like it's going to be a chain where there's a lot of gaming going on. Tokenized assets insurance is one that I think is one of the easiest ones to understand the true power of smart contracts and chainlink. Having a bad faith insurance with an insurance provider is basically fixed with Chainlink smart contracts. So really looking forward to more insurance protocols being built and just kind of everything. But go check out this article. 77 use cases.
00:24:06.544 - 00:24:48.788, Speaker A: It's really fantastic. And then I actually didn't even put some of my other favorites like working with NFTs. We've done a couple of different randomized NFTs, which is really fun where you can make different game characters with random stats. If you were on with Austin Griffith and myself earlier, we actually generated a zebra with a random strength, which was really fun. He proceeded to then make a hippo that was stronger than my zebra, but so be it. But as always, hopefully everyone here signed up for the chain link hackathon because it's going to be absolutely insane and there's some really smart people working on really cool stuff now. So I'm going to move into the demo section, but I do want to pause again real quick.
00:24:48.788 - 00:25:34.660, Speaker A: Look at the comments, look at the questions here. Like I said, this is meant to be an interactive session, so I know a lot of people are returning returners to Chainlink and already understand most of this, but happy to jump into any questions as well and hear about what people are looking to do, what people are looking to build. Earlier I saw that generating a random number takes a minute. What is the faster way to generate a random number? So it's really just the speed of the network. That is the slow part. Yeah, I mean, ethereum's block time right now is like 15 seconds, 20 seconds or something like that. So you need to make a transaction to request a random number and then get a random number.
00:25:34.660 - 00:26:25.312, Speaker A: And that's really the fastest way because it's going to be the way to get a truly provably random number in a nondeterministic way that can't be gained or wrecked. Basically, verifiably random number is really important there. That's really the answer there. Will we be restricted to the data feeds provided or can we create a new data feed? And if so, how? Yes, and if so, how is a longer explanation. But the basic explanation is you just get a bunch of nodes, have them make a bunch of requests to a bunch of different APIs and have them aggregate the data together on mean. And all the price feed data is price feed stuff or data feeds contracts and everything is all open source. You can all see it on the Chainlink repo.
00:26:25.312 - 00:26:59.716, Speaker A: So if you want to draw some inspiration from there? Absolutely. Have a blast. So instead of using data feeds of chainlink, I could potentially just use an API of, let's say, flight status provider. Yeah, for sure. You can do whatever you want to do. The thing you need to think about though, when you're deploying these is decentrality, right? If you're working with a single API provider, that's going to be that same issue where you don't actually have a decentralized. Your logic isn't actually decentralized.
00:26:59.716 - 00:27:34.250, Speaker A: So that's really good point actually. But I think for hackathon purposes, doing stuff like that is absolutely phenomenal because most of the time, unless it's very specific data, especially like flight stuff, you can find and do work later on to get multiple data providers, right. So yes, the answer is absolutely, you can do that. And that sounds awesome. Dynamic NFTs agree. There is a sick article on that and I think we have an NFT workshop at some point. I hope we do because that is going to be a lot of fun.
00:27:34.250 - 00:28:11.700, Speaker A: How do we link chainlink to a front end framework? Like react? If we are using Chainlink for something like a web app, will we need another backend server as well? No, you don't. In fact, I've got front end questions a couple times. If I got a bunch of people to ping me, we'll probably add a front end workshop. I think that might be useful. If you guys think that might be useful, feel free to drop somewhere in the chat. Be like, hey Patrick, we would love to see a front end workshop. If I use a side chain like polygon, will it be faster? Polygon would be faster, yeah.
00:28:11.700 - 00:28:44.636, Speaker A: Just by the nature of the speed of the network for random number generation. Yeah. So the quicker the network, the quicker you're going to get your number back on the main chain. Obviously you could spend a ton of gas, but you're still going to be capped by the block time or the speed of the network. If I wanted to grab real estate prices from a site like Zillow, could I build an external adapter easily enough? We will have an external adapter demo. We will go over exactly that. And yes, please do a front end workshop.
00:28:44.636 - 00:29:06.884, Speaker A: Okay, well, we will see. I think it probably makes sense. All right, cool. Well, we're going to go on to demos now. These are the docs. Like I said, I'm in here every day because I use this all the time. Okay, now I'm getting a bunch of people say, yeah, we'd want a front end workshop.
00:29:06.884 - 00:29:31.232, Speaker A: All right, maybe I'll add one to the agenda for next week. Yeah, I'll add one to the agenda for next week. All right. So here's the docs. And again, if you're brand new here, if you're like I'm still super confused, go to this beginners the basics tutorial. Go through this. It'll teach you how to do exactly what we're going to do right here.
00:29:31.232 - 00:30:19.070, Speaker A: And if you're still confused, pop into the discord, say something online, do whatever you want to do, but just make it known that you're a little confused friend and workshop will be amazing and dynamic NFT workshop too. Dynamic NFTs is definitely on the calendar I believe, but. All right, so let's look into getting the price of an asset and you're going to see why I love working with the data feeds because of how easy they are to work with. And like I said, these are the data feeds that are fueling like 25 30% of DFI. Right. So these are incredibly powerful and they're also one of the simplest to use. And my Internet is kicking out just a hair, which is fun.
00:30:19.070 - 00:30:52.856, Speaker A: Let's try that again. Maybe remix doesn't want to work for me right now. Maybe remix is down. No. There we go. Just a little slow for some reason here. So once you hit this button you're going to come to remix and on the side you're going to have this gist thing here and you're going to have less than four.
00:30:52.856 - 00:31:30.144, Speaker A: You're just going to have one and it's going to be price consumer v three does. So I have a whole bunch because I've been doing this a lot today and let's even zoom in just a hair. So if you came to some of our original solidity and smart contract courses earlier or workshops earlier today, we kind of walked through what this is doing. Right. But we can see here again we're importing the chain link code right here, aggregator V three interface. We're importing it, we're creating our contract called price consumer V three. We have an object of type, aggregator V three interface.
00:31:30.144 - 00:32:23.110, Speaker A: We're calling it pricey. And then what we're going to do in our constructor, again the constructor is what gets called when you deploy the smart contract. This is like the first function that gets called and that's what this constructor thing does is we're going to set our global variable or contract variable if you will, price feed to this aggregator v three interface. Object at address this big address right. So what is this big address in the docs? You can find, and you can even do kind of this little Ens lookup. You can find where the addresses of these different pairs are. And so we're going to be working with the coven testnet, and we're looking for, I think, FUSD, which is.
00:32:23.110 - 00:32:37.972, Speaker A: That's the main net. That's rink B. Can I get COVID, please? Coven. Okay, great. RSI, 48 4 hours. I'm not sure what that means. Oh, that's USDT.
00:32:37.972 - 00:33:03.280, Speaker A: Okay, cool. So it's going to be this address right here, and then it's already populated here. But that's how we reference the address that we want, the pair that we want. So we want FUSD. So we use the address for FUSD, and you can find all the addresses right in here. Okay. And then once we do that, once we have this global variable defined, we have this function down here called get latest price.
00:33:03.280 - 00:33:20.104, Speaker A: Okay. And it calls pricey latest round data. It just calls this function, and it returns this big object here. And we are just going to return the price. Right. So that's going to be the price. So we're going to actually compile control s works, but we're going to also hit the big button there.
00:33:20.104 - 00:33:44.620, Speaker A: We're going to deploy. And now, since these contracts are on specific networks, right, for example, COVID. I'm on the rinkby network. I actually have to switch to the COVID network, right, because we want to be on the COVID network. And now we're injecting web three is now the COVID network. We need to be on the COVID network because this contract is on the COVID network. So we have to deploy this to the right network.
00:33:44.620 - 00:34:04.710, Speaker A: So we're going to deploy it. Metamask is going to pop up. Can you guys see that when Metamask pops up? I think you guys can't actually. You guys can't see that? It's annoying. Can you guys see that? It's like a delay on the zoom. Oh, you guys can't see that? Oh, awesome. Okay, cool.
00:34:04.710 - 00:34:17.624, Speaker A: Metamask pops up. Oh, you can't see it when metamask pops up, though. Oh, that's annoying. All right, well, metamass popped up. I hit confirm. We get our COVID link. Our COVID link here.
00:34:17.624 - 00:34:49.156, Speaker A: We're just going to refresh. And this is the transaction that's deploying the contract. Right? Again, if you haven't really worked with remix that much, we're deploying the contract here. And now that it's deployed. We have our get latest price function that we can call and we get the latest price. So this is the latest price of Ethereum in USD and 1803 is the latest price. The reason that we get that big number without the decimal is that solidity doesn't work with decimals very well.
00:34:49.156 - 00:35:10.392, Speaker A: So we multiply it basically. So this is 1803 and now we have the price of ETH in our smart contract and we do whatever we want with it. We can have an absolute ball. Any questions with this? No, we can't. Can't see metamask shows for a split second, then disappears. Sorry, it showed up. Hit confirm.
00:35:10.392 - 00:35:49.130, Speaker A: That's all I did, I promise. Any questions on this? I ran out of tea, guys. Black tea too. Yummy. As I'm waiting on questions, I'm going to flip over to the next bit. Is it free to use those data feeds and if so, who pays for them? Fantastic question. So data feeds, we go back to data chain link.
00:35:49.130 - 00:36:24.544, Speaker A: They're being sponsored by sponsors. So no, they're not free. People are paying for them to keep them up. However, as you saw here, it is just a view function, so it doesn't cost you anything to pull the price or use them. But without these sponsors, these wouldn't be able to work. Right, because these sponsors, and then we could scroll the way down to the bottom here. These sponsors are the ones paying to keep these data feeds up and because obviously if they went down, their protocol wouldn't be able to work.
00:36:24.544 - 00:37:07.244, Speaker A: So they are being sponsored, so they're not free. However, they are meant to be kind of this community resource where it's cheaper than if you rent even your own centralized oracle, right, because everyone's chipping in a little bit. So they are just a view function though, so you can just grab it. But the ask at the moment is if this starts to be a crucial piece of your infrastructure, probably makes sense for you to want to support and help sponsor it as well. And that is the current situation. So they're not free, but it is just a view function, so you can just kind of pull the data. Does the contract have to hold a balance? No, doesn't have to hold a balance.
00:37:07.244 - 00:37:26.612, Speaker A: So you saw like let's even delete this, compile it again, deploy, hit confirm. NMS popped up. I promise it did hit confirm. It's going to pop up here. We're going to hit get latest price. See, I didn't fund it with any money or anything. Like I said, it's just a view function.
00:37:26.612 - 00:37:55.730, Speaker A: It's the same on Mainnet. Absolute same on Mainnet. So, yeah, these are main net ready where you don't have to fund them with anything. How do you know where the decimal will be? Great question. So for fiat pairs, it's eight decimals, and for cryptocurrency pairs, it's 18. That's really it. So if you keep that in mind, these are really easy to kind of do the math with.
00:37:55.730 - 00:38:36.844, Speaker A: For example, FUSD is going to be eight decimals because it's a USD pair. And so it's fiat on this side. But if it's like, if it were to be USDF, this would be 18 decimals because it's got f as the base pair or the base currency. Good question. I ran out of NFT. Very nice. What does solidity multiply the number by to get rid of the decimal? And is it consistent? Good question.
00:38:36.844 - 00:39:03.556, Speaker A: Yes, I just answered that. So it's going to be for eight. Obviously you're going to do ten times, or ten raised to the eigth and then ten raised to the 18th. Good question. And yes, it is consistent for those. All right, cool. What are the data feeds? Update times.
00:39:03.556 - 00:39:22.892, Speaker A: Great question. So you can see here we have the trigger parameters. These are the deviation threshold and heartbeat. So they update whenever one of these two is met. So trigger parameters whenever the deviation. Whenever the price of an asset deviates beyond 0.5%. So if there's ever a 0.5%
00:39:22.892 - 00:39:45.220, Speaker A: deviation, it updates. Or just every 3 hours. So the last update was four minutes ago. That is probably because it's a little bit volatile right now. So it's just updating more often. Right, because obviously we don't want a price to spike and then 3 hours to go by and then we get a new price. Yeah, there's a deviation trigger, which is really nice.
00:39:45.220 - 00:40:06.234, Speaker A: Good question. Great question. Keep the question coming, guys. I'm loving these questions, but we're going to move on to the next demo here. So that is how we work with price seats. And again, you can see binance, smart chain, polygon, XDI. I don't know how to pronounce this, but this one as well.
00:40:06.234 - 00:40:33.906, Speaker A: All these different chains that these price seats are currently on, you can see get some historical price data if you want latest price. You can read more about these and you can read more about this decentralized data model that these are following. If you want to learn more about OCR, which is really cool, you can go there, but we won't talk about that. For now, let's go into getting a random number. Right. This is that VRF that we were talking about. And this follows a little bit different of a paradigm here.
00:40:33.906 - 00:40:55.654, Speaker A: We're going to make a request and receive. So the price feeds or the data feeds are already aggregated. It's already aggregated, the request has already been made. Someone has received as well. Somebody else has already requested and triggered these transactions for the data feeds for us. So these, we're actually going to be making the transactions, we're going to make the request here. And this is really powerful.
00:40:55.654 - 00:41:15.774, Speaker A: And this is where we start to get into some really cool stuff. So this is our contract. Let's talk about it. Same thing. We import this VRF consumer base. Sol this is the contract that's going to help us verify that the numbers are truly random. Now we do what's called inheritance here.
00:41:15.774 - 00:41:37.270, Speaker A: And if you were on with Austin Griffith, he did a little bit of this too. Random number, consumer is VRF consumer base. So we're saying our contract is going to be a type of VRF consumer base, which is really fun and exciting. Now we have these three global variables, or these three contract variables. Key hash v. Random result. Random result is where we're going to store the response from the chainlink VRF.
00:41:37.270 - 00:42:02.378, Speaker A: And these two are needed for the chainlink VRF. And we'll go into that in just a second. Now, here is where we have an interesting comment. This is just defining the parameters of the Chainlink VRF. So again, since these oracles are listening to very specific networks, we need to define the addresses that these have been deployed to. Right. It's going to be a little bit different for rinkby, a little bit different for Robson Mainnet.
00:42:02.378 - 00:42:39.062, Speaker A: Again, you can find all the addresses in the documentation, both here and here for the price sheets. So everything is there. Everything is there. If you ever get lost, go to the docs, and then if you're still lost, go to the discord. Somebody will help you because we are all trying to make the world a better place anyways. So when we define our constructor again, this is the first method that gets called when we deploy our contract. We are actually going to add this VRF consumer base bit, where we say we're going to give it the address of the VRF coordinator and the address of the link token.
00:42:39.062 - 00:43:16.806, Speaker A: So these are two addresses that we need to give to the VRF consumer base. The VRF coordinator is the contract on chain that is actually going to verify that our number is truly and provably random. Key hash is another piece that the VRF coordinator needs to prove that the number is truly random, and it helps identify the VRF node off chain. Now, the fee is the link that we need to pay to actually get this random number back. So when doing transactions on chain, obviously we need to pay a little bit of ETH, a little bit of ETH gas. When working with Oracles, we have to pay a little bit of link, a little bit of oracle gas. It's the same thing.
00:43:16.806 - 00:44:08.822, Speaker A: So you saw that we didn't have to do that for the data feeds because those had already been aggregated by somebody and just left public for you to use for the random numbers, we actually have to make the request, and that's why we have to pay the little bit of link here. So then we have our function get random number, which takes a user provided seed. This is just a number that we give it just to kick it off and prove that it's really, again, prove it's really giving us a random number. And then we call this request randomness, you can ignore this require for now. Then we call this request randomness, which takes that key hash, that fee, and that user provided seed. What happens is the node rolls the dice and it calls back to the contract to basically this fulfill randomness function. Technically the VRF coordinator calls it back, but just pretend that the chainlink node actually calls this function back and it returns the request id.
00:44:08.822 - 00:44:34.550, Speaker A: So the request that was created by this request randomness function and the random number, and then we're going to save the random number to this global variable random result. So let's go ahead and compile it, deploy it, inject a web three again. We need to be on an actual network. Metamask is popping up. I promise I hit confirm. I remember. You guys do need metamask, you need testnet, ETH, testnet, coven.
00:44:34.550 - 00:45:07.130, Speaker A: I should have went into this first, actually. Where to get that? If you ever get lost on getting any testnet. Sorry, yeah, I should have went over this before. If you ever get lost on how to get any testnet tokens, you can go to link token contracts. There's coven faucets here, rink B faucets here for the testnets. So binance smart chain obviously is a main net. There's no testnet here, but here's a BSc faucet for community link, which is really powerful.
00:45:07.130 - 00:45:42.646, Speaker A: Sorry about that, but great. So we have our testnet eats. We could deploy the smart contract now. We have this smart contract here. So what do we want to do? We want to get a random number, right? Random result is going to be initialized to zero. Call to random result be initialized to zero here. If I call, get random number right now, what's going to happen? It's going to kick out.
00:45:42.646 - 00:46:05.614, Speaker A: It's going to say, what are you doing? You're crazy. Stop doing that. The reason it's kicking out is why? Because it needs the link fee in order to actually make that request. So we actually get this gas estimation failed. And this is saying it failed with the follow error, error below, right. Gas, it doesn't know why. It's because we don't have enough oracle gas or chain link to actually make this work.
00:46:05.614 - 00:46:40.348, Speaker A: So we're going to copy it. We're actually going to send it some link. So metamask has popped up. I know you guys can't see it, sorry, but I'm sending it to link or one link or whatever I want to send. Metamask really doesn't pop up even when it's in browser. So I'm sending it to link just to be safe, just so in case I want to do it a couple of times. And again, this is going to give us a little transaction we can see here.
00:46:40.348 - 00:46:57.612, Speaker A: This is us sending. Oh, you can't see metamask. You just can't see it when it pops up. I got it. Okay, good to know. So we've given the smart contract link. Now if we hit this, we don't get this error, metamask will pop up.
00:46:57.612 - 00:47:16.952, Speaker A: And again, this one you can't see, but metamass did pop up. I'm going to go ahead and hit confirm. And this is actually going to kick off this transaction. So we're actually sending 0.1 link for this transaction. Again, it's a testnet, so it's just a default value here. I think on Maddox it's like one or something like that.
00:47:16.952 - 00:47:40.496, Speaker A: But we're kicking off this transaction and we have a success here. So now if we had random result, we're still not getting anything. And because we actually need to wait for that second transaction back. Right. So we've made the request and the node has picked up the request and went, oh, okay, you want a random number? Okay, I'm going to get you a random number. I'll be right back. And it has to make a second transaction back.
00:47:40.496 - 00:48:00.424, Speaker A: So we need to wait two transactions. And once we do, now we have a random number. Now we can do whatever we want in our smart contracts. We can make a know randomized nft like what we saw with Austin Griffith. We can make pool together or provably fair lotteries. We can do whatever we want. Loot boxes, you name it.
00:48:00.424 - 00:48:31.920, Speaker A: So incredibly powerful feature here. Let's go into some questions. Front end. Front end workshop. Yes, we'll do a front end workshop. Can you make the contract be triggered when some condition is being met in some time in future? Yes, that's a great question. Smart contracts don't react to polls.
00:48:31.920 - 00:48:54.024, Speaker A: I'm saying that wrong. Yes. You have to call the functions though in order for them to do it. They can't watch anything, right. You can't have, smart contracts aren't like servers that'll watch something. However, what you can do, and this is actually where Keeper comes in. And if you are here and you want to check out keeper, this is actually exactly the type of thing keeper is good for.
00:48:54.024 - 00:49:19.916, Speaker A: Right. It's good to monitor some event off chain, right. And when that thing happens, do something and definitely check out keepers. It's going to be a really awesome feature for the sackathon. And it can do that. But smart contracts themselves can't actually monitor or read anything. But you can have a keeper, a chain link keeper off chain, or you can have some type of chain link external initiator.
00:49:19.916 - 00:49:53.308, Speaker A: But yeah, basically something off chain is going to have to trigger it in the future. But absolutely, yes, you can have it be triggered in the future. How exactly does sponsoring a feed work? Would those feeds not be there without sponsors? Pretty much, yeah. Because again, like we just said here, in order to make a request, you have to request and receive data. Right now those are kind of just the protocols that really rely on those price feeds. Like without those data feeds they would have a hard time running. So they're sponsoring them to help them keep up.
00:49:53.308 - 00:50:47.052, Speaker A: I would imagine in the future kind of this system to change to make it, because again, it's not really fair that these sponsors are kind of providing it for everybody. Again, they are paying to keep about. If your protocol just starts really heavily relying on them, some access controls will probably be put in to help kind of share the burden across different protocols. Are we able to call VRF multiple times in one transaction for multiple random numbers? No, you got to call one simple time. Can you set the link feed to zero? I can, but if I did that here, the node still would be like, okay, well my fee is 0.1, right? So the node operators actually get to set their link fee. So if I change it in here, the node operator still says, hey, it's 0.1.
00:50:47.052 - 00:51:19.656, Speaker A: Well, it's 0.1. So if I send them nothing. Then they're not going to send me a run over back. How do we anticipate the gas fees to make sure that the contract has enough? Good question. So I think you're talking about oracle gas fees, and the node operator is going to say what their link costs are, right? So the link cost is going to be 0.1. If you're talking about ethereum gas fees, then it's okay. Well, whoever calls the function is going to pay whatever ethereum gas fee pops up.
00:51:19.656 - 00:52:20.040, Speaker A: But for the link gas fee, it's just going to be this right here, and that's going to be given to you in advance. Can you talk about how verification of the number is done? This is a longer conversation. Sorry, can you hold on off 1 second, guys? Mute this. Sorry about that, guys. Where was I? Can you talk about how the verification of the random number is done? Yeah, yes, I can, but that might be a longer conversation. So if you go to the GitHub, GitHub.com, this is where it gets a little bit over my head, to be honest.
00:52:20.040 - 00:52:48.640, Speaker A: But I will point you in the direction of what you're looking for. So we'll go to V six. We'll find VRF. We have VRF Sol, I think we want VRF. Consumer base is it vendor. Everything is in here. So if you want to go through this, you can read this comment.
00:52:48.640 - 00:53:25.228, Speaker A: There's kind of a lot here, to be honest, but this will actually give you everything that you want to know. So it's checking that hash that we give it, that seed phrase that we give it, and verifying that it's truly random. So that's really all I can kind of go into it without getting super in the weeds. Good questions. Great questions. Is the randomness thing available on Salana? Not at the moment. Where can you see how much an oracle node is requiring in the 0.1
00:53:25.228 - 00:53:47.510, Speaker A: example? Good question. And actually we'll get to that in the next video. For VRF, it's just 0.1. For chain link VRF, it's just 0.1. But we'll get to fees in the next video. So any other questions? And then we'll move on to the next one. And I'm going to get that set up while you guys think of any additional questions.
00:53:47.510 - 00:54:10.808, Speaker A: Very cool. Thanks. All right, any other questions? Bueller. Bueller, any questions? All the questions. Love it. This means you guys are wizards at Chainlink and you guys are going to do amazing things for the second. That's what we like to see.
00:54:10.808 - 00:54:55.690, Speaker A: Oh, no, a couple of questions. How do you get a smart contract to track the random numbers generated by multiple users? How do you get a smart contract to track the random numbers generated by multiple users? Yes, good question. Actually I should have had the example. Let me pull that back up. So what you'd want to do is make a mapping here. I'm not going to go right into it, but basically you do instead of this here you do like Quest ID. Excuse me? Bytes 32.
00:54:55.690 - 00:55:52.670, Speaker A: Quest id equals request randomness. So this request randomness assigns a bytes 32 and then what you do and then you just return request Id request ID. And then what you do is you'd actually set this up to like a mapping. So it'd be like at the top we'd have like mapping of request Id. Excuse me, to address call like request to address that. Even the right syntax. No, that's not 32 to address.
00:55:52.670 - 00:56:25.380, Speaker A: And then we'd save it in this request to address here. Do like request. I guess I am doing a little coding here. Request Id to address of request Id. We're going to set that to equals like message sender and then I'm not going to finish the rest of it. But then the fulfilled randomness function, we would just pull it out of that request to message sender. So great question.
00:56:25.380 - 00:56:49.856, Speaker A: Actually is possible to use chainlink to pull data on chain that can trigger a contract from a different language, eg python. Come to the external adapters workshop. That is exactly what we're going to do there. I had a question about weather feeds right above. If you have a chance to answer oh, did I miss your weather feeds question, I don't see it. Feel free to ask it again. So chain link VRF is not available on main net.
00:56:49.856 - 00:57:37.310, Speaker A: It is available on main net, 100% available on main net. If you want to use chain link VRF on Mainnet, just email VRF at chain link right now as we kind of grow the network and get everything settled up. Cool. All right, last example here. Now that I've botched up that smart contract, this is the kind of the minimum piece of chain link that makes this whole thing possible. This is making arbitrary gets posts and any type of requests, right? So this one obviously requires a little bit more work because you do need to build these decentralized systems yourself. However, they are also the most powerful because you can use them to do anything.
00:57:37.310 - 00:58:23.848, Speaker A: Just because I made this recently bi and because I feel like shilling it on camera because it's really silly unless my Internet doesn't want to work. This was an app I made a couple of days ago for kicks, and you can order me a verifiably random pizza. And it works with the Domino's API to actually return a random pizza, to order a random pizza from a smart contract. So that's kind of the creativity level. You can go here. Obviously mine was a little centralized because I was using a single node. And to make it better, I'd always use multiple chain link nodes.
00:58:23.848 - 00:59:04.312, Speaker A: But you can make any API call, you can do literally anything you want. So that's kind of a silly version. More interesting versions that we've done recently, or that I've done recently have been like with IPFs, setting that as a backend or making a call to some specific API, like to get maybe the reserves of an asset. Last year's winner, they used an API to rent out their Tesla using the Tesla API. So this is really this unlimited customizability here. If you're a little concerned about the decentrality of it, I would say for the hackathon, don't worry about it, just run with it and go have fun. But obviously for going Mainnet, you're really going to want to sort that part out.
00:59:04.312 - 00:59:51.192, Speaker A: So let's talk about what's happening here. We are importing chainlyclient Sol, which has all the code that we need to make this API call. We're going to inherit it in our API consumer contract. Same thing, a couple global variables, and this is the same bit as the last oracle. But this is where we can actually choose our oracle, right? So if we're like, how do I build my oracle network? This is where you choose the independent node operators. Now the question is, okay, where do I do that? How do I choose these different node operators? Well, I'm going to get rid of that. Now that I remember that my face is on there and looks very silly, we actually want to choose a node operator and a job, right? So if we go to.
00:59:51.192 - 01:00:20.700, Speaker A: Let me grow this a little bit, maybe not. If we go to COVID, Ethereum, coven, we can see all the different nodes that are alive and have listed on a node listing service. So market link is probably the most popular node listing service right now. Reputation link is another really good one. They also do some oracle reputation, which is really cool. They do a lot of really cool stuff. My computer is being slow, so I'm just going to exit.
01:00:20.700 - 01:00:58.172, Speaker A: But we can go to nodes. We can go to nodes and we can see all the different nodes on COVID and what they're doing and what types of jobs that they have. So for example, let's say I want a job that makes an H two to be get request and returns a UN 256. Let's see what I get. So we get some different nodes, someone's node is named get UN 256. That's pretty clever, but we can go to like a node, we go to their jobs and we see the different jobs that a node has. A job defines on an oracle what it can do.
01:00:58.172 - 01:01:48.244, Speaker A: So a job that has a get UN 256, it makes an HTTP get call, which is an API call, it parses out the data from the response, parses the JSON at a specific path and multiplies it. These are the different tasks or adapters that a job can do. So we could take this job ID and then we could take the oracle address right here of the oracle and then also the fee, somebody asked about the fee. So let's go back to that job and let's see the, and again this is on the COVID network, we can see the fee here as well. We can go here and we can just pop it in. So we have the Oracle that we just got from the marketplace, the job that we just got from the marketplace and then the fee, so we saw the fee was 0.1. Again, this is a node on the COVID testnet.
01:01:48.244 - 01:02:24.084, Speaker A: So we can grab stuff from the marketplace and use it and play with it. So you can see there's tons of different jobs, tons of different types of data. Just note on main net some have jobs waitlisted. So you might have to reach out to those non operators and just ask or you can test it yourself. So we call our constructor and it sets us up, so it sets our node up for success. It says here's the node that we're going to use, here's the node that we're going to call now in our request volume data, this is where we make that API call. So we do chainlink requestmemory build chainlink request.
01:02:24.084 - 01:03:13.210, Speaker A: This is where we specify the job ID, the callback contract, which is going to be this contract. We say we want you to return the data to this contract and the fulfillment function. So we say return to this contract. And when you do call this function down here, this fulfill function, this is what we want you to call when you return the data. So that's how we build, we start building the request, right? So once we do that and we have this job id again which has all these adapters in here or these tasks, we can add some parameters to those adapters. So let's say for the HTTP get adapter we want to add the parameter of this API. So we're saying for this get adapter we're going to call this, and if we just call it like in our browser here, we can see this is what it looks like.
01:03:13.210 - 01:03:38.336, Speaker A: That's so nice. We can see this is what it looks like. And we want the volume 24 hours. Like this is the response that we want to get. We're looking for whatever reason we want the volume of the last 24 hours of this. So we're going to add the path, right, which is going to be raw FUSD volume 24 hours. So if we go back here, the path is if we walk down the json response, how we get the data.
01:03:38.336 - 01:04:09.944, Speaker A: So we walk to raw Fusd volume 24 hours. So this is how we get the path here. And then last but not least, again we notice that this is not a whole number. So we want to multiply it. So we have this multiply adapter again in the job, job spec. So we did this json parse, which is that copy that, we walked down. We have this multiply adapter we're going to use to multiply by ten to the 18th again so that we can get it to be a whole number.
01:04:09.944 - 01:04:36.428, Speaker A: And then we add that integer in and then we send the request. So send you in the request. And then we use the oracle request and the fee. So this is how we send the request. So once we send the request, once it gets the data, it will actually call back with this fulfill function with the request ID and the type that it responded with. Again we can see what type it responds with. We see here it has an F U n 256 adapter.
01:04:36.428 - 01:05:08.300, Speaker A: So it's going to return an FU 256 and then ethx. This is the adapter that says okay, then I'm going to respond with that data. If it doesn't have the ethx adapter, it won't actually make a transaction back to ethereum or matic or avalanche or whatever chain. And then we have a withdrawal link function which you can pull your link out of. But this is how we actually get the data back. So we're going to go ahead and compile control s or hit that big compile button. We're now going to deploy it again.
01:05:08.300 - 01:05:47.530, Speaker A: This is on coven again. If you want the testnet link you can go to the link contracts in the docs link token contracts for the Testnet link and the testnet theorem. We're going to go ahead and deploy metamask pops up, you guys can't see it. I'm going to go ahead and hit ok once I increase the gas fee because I don't know why it's defaulting to one for some reason. And we have our contract here. And again we're going to call this request volume function, but if we call it, it's going to say what are you doing? I don't have any link, can't do that. So we're going to send it some link, just going to send it one link for now.
01:05:47.530 - 01:06:20.592, Speaker A: And then once this is confirmed we can make that API call and get that volume 24 hours into our smart contract. So this is getting data into our smart contract, which is obviously incredibly powerful here. So now we can call this request metamask pops up, you guys can't see it. I hit confirm and we're going to get this transaction. So this again, same thing with the chainlink BRF. We're making a request and waiting for a response. So this is the power here of the request and the response.
01:06:20.592 - 01:06:54.560, Speaker A: So this is what we're doing to get the data into our smart contract. So you can see it's currently zero, same thing as the chainlink BRF. The random number start at zero, and then once that second transaction is actually made, that will go into the smart contract and that will give us our volume here, which is obviously this big number because we multiplied it by ten, raised to the 18th. So I know I just threw a lot at you guys, so feel free to bring on any and all the questions. Really excited to hear this. And again, this one takes a little bit of extra work. Right, because you do need to get the API calls right.
01:06:54.560 - 01:07:24.520, Speaker A: If you want to go to Mainnet, you need to get the decentralized nodes and the decentralized APIs. However, it's also the most customizable and really limitless functionality way. So really exciting stuff here. So let's scroll up, look at these questions. Will it always cost zero? No, it'll cost whatever the node of the marketplace has specified. And anybody can put a note up there. Anybody can spend a note up there and market their jobs and their nodes.
01:07:24.520 - 01:07:44.270, Speaker A: No, it's just a default testnet cost. Yeah, exactly. So the 0.1 link is just different node to node, network to network. It's just kind of a default cost. Metamask just flashes really quick on the screen. Yeah, it shows up when you click it like this.
01:07:44.270 - 01:08:32.492, Speaker A: But when I make a transaction it just kind of flashes and. Sorry, how do you parse data in the smart contract? That you receive as Json from an API. Great question. So we have this path adapter, right? So if we see in this job spec we have json parse. So Json parse is deliminated by this path thing. Here you can read more about different adapters and what they do in the adapters section of the documentation. So this talks a little bit more about oracle jobs, how a job is this initiator and this adapter.
01:08:32.492 - 01:09:24.572, Speaker A: We didn't go over initiators here because we're using basically like the default run log initiator. Don't worry about that for now. But jobs are initiators plus adapters combined. So we're using a run log which just says do the way that we're doing it here. And then the adapters are the tasks that the job has. So different adapters or core adapters, if you will, do different things. So like a copy adapter is going to walk down the json path like you were saying, an ETH boolean adapter is going to take the response and turn it into a boolean yes or no ETH transaction, makes a transaction Fu into 56, takes whatever number that's created in JSON and turns it into an FU 256 so it can be understood by the blockchain.
01:09:24.572 - 01:10:14.028, Speaker A: HTTP get is obviously an adapter that makes an API get call HTTP get call HTTP post obviously makes HTTP post call JSon parse. This is another type of JSON parsing, but this is for HTP get HTP post adapters like we were doing before. Multiply adapter. There's a bunch of other adapters, but those are kind of really the important ones here. Great question. What's the cost of the request if it's a transaction? What's the cost of a request if it's a transaction? I don't understand the question. So whenever you interact or call a function on a blockchain that will change the state of the blockchain, you have to make a transaction.
01:10:14.028 - 01:11:06.236, Speaker A: So I can call this volume transaction or function as much as I want because it doesn't actually change the state of anything. I can't call this request volume as much as I want whenever I call it. I have to kick off another transaction because it will change the state of the blockchain. So you do have to kick off a transaction whenever you interact or change the state of a blockchain. Smart contract why is it you have to pay when calling the function, but we also defund the contract with link? I'm not sure I understand the question here. So when we call the function, we actually are paying with link to the oracle, right? So it's like, here's how I think about it. When we're doing our logical computation, we pay ETH to do our logical computation.
01:11:06.236 - 01:11:43.276, Speaker A: When we get data, we pay link. So when we interact with the outside world to get data, we pay link to work with oracles. When we work with our logic and our computation, we pay a little bit of ETH or matic or avalanche or salana or whatever chain you're currently on. Good question. But in reality, every request is going to be a transaction and cost something. Is there no way to make it zero? Or should we think of it like negligible because 2.0 requires Internet electricity, et cetera? Honestly, that's how I would think of it, yeah.
01:11:43.276 - 01:12:38.670, Speaker A: So you do have to pay like link, but as kind of the networks scale, they get cheaper and cheaper, obviously, but you really don't want to interact with one that's free anyways, because if it's free, there's no incentive for them to behave honestly, right? If you say, hey, get me data, I'm not going to pay you anything for it, any economic incentive for them to behave correctly is gone. It's the same thing with computation, right. If Ethereum, the blockchain, was free, there would be a good chance that no transaction would actually do what they said they would do. So it's actually good that there's a cost. Same thing. Why? It's good that there's a cost associated with Ethereum. I think as we scale, all these costs will get cheaper and cheaper as we're talking about Ethereum scaling being probably one of the hottest topics on the planet right now.
01:12:38.670 - 01:13:13.706, Speaker A: But yeah, so it's the same thing. You want that incentive layer there, because if you lose that, then all of a sudden you have a bunch of people who don't care, who are responding to queries and whatnot. So. Great question. Any other questions? Here's cool. Well, if there are no more questions, we can actually do a couple of different things here. What do you guys want to see? I'm looking for recommendations here so we can do more Q A.
01:13:13.706 - 01:13:37.860, Speaker A: We can go into some more examples. I'm going to hold off on like Brownie, truffle and hard hat until tomorrow. Tomorrow we're doing two sessions, one on Brownie, which I'm very excited for, and then one on both truffle and hard hemp because they're very similar. We're going to be building some DeFi protocols with them, which is going to be a blast. But if there's any other questions, comments, whatever you guys want to go through. Okay, here the questions are coming in. Great.
01:13:37.860 - 01:14:11.574, Speaker A: Hi Patrick. How do you specify a given value on a big json response in order to be converted to a solidity data type? Do you need an external adapter for that? No. So even like this, right, this is a huge response. So what we did is we walked down the path. So in our job here, we had this request, add path. And this is an adapter. This is the json parse adapter that says go to path, SUSD volume 24 hours.
01:14:11.574 - 01:14:29.214, Speaker A: So if this was like this, we said, okay, let's go to raw. Okay, cool, let's go to raw. First one is raw. Okay, let's pretend that that wasn't open. Okay, what's the next one? F. Okay, let's go to F. What's the next one? USD.
01:14:29.214 - 01:14:44.930, Speaker A: Okay, USD. Let's go to USD. And volume 24 hours. So that's how we can walk the path. And when it's this massive json thing that we obviously don't want to put on chain because it's going to be very expensive, we can just get the data that we specifically want. Great question. So the answer to that is we use an adapter.
01:14:44.930 - 01:15:02.394, Speaker A: We don't need to use an external adapter for that. We can use a core adapter. So those are the differences. A core adapter are adapters or tasks that are built in natively to the chainlink system. External adapters are adapters or tasks that we build or we customize. Right. And they're basically APIs.
01:15:02.394 - 01:15:49.298, Speaker A: And I will go over that in the external adapters demo on whenever it is. It's sometime this week. Do you have layer two solutions for Chainlink? So Chainlink is a layer two because Chainlink is built on top of these layer ones, these different smart contract platforms. But I think the question is more like what are the scaling solutions? Which is a great question. So Chainlink OCR actually recently came out, which is incredibly powerful. I think we have it in the docs. Actually, I should just go right to the docs.
01:15:49.298 - 01:16:28.100, Speaker A: Docs have everything. Docs are great. OCR or off chain reporting, which does this aggregation off chain and makes a single response to the smart contract network, which is incredibly powerful and it reduces costs by like 80% of the previous costs or something like that. So really powerful, really incredible stuff. There's also a next iteration of this that's going to make things even cheaper and even more efficient. But that is in the future and to come. So there are scaling solutions for chainlink in play and in the works, but they're not layer two scaling solutions because Chainlink itself is already a layer two.
01:16:28.100 - 01:16:42.230, Speaker A: Good questions. Love to see more examples. Okay, all right, Riz will have to do some more examples. And again, Riz and everybody else here, if you're looking for like, okay, I want to just see a depth. I want to see a full end depth. I get it. I got you.
01:16:42.230 - 01:17:05.760, Speaker A: Let's build some stuff. 100%. Check out Brownie, the brownie thing tomorrow and the truffle and hardhead. We're going to go literally end to end building an application using brownie and brownie in the morning, truffle hardhat in the evening. So don't miss that. It's going to be a lot of fun. If we have time, we'll do some friend and stuff, but we'll see if we have time.
01:17:05.760 - 01:17:51.520, Speaker A: My question skipped. Gavin K. I don't see a question. If I understand correctly, this code is calling only one oracle. How would you add another one to be more safe in the response they're giving? Great, amazing, fantastic question. So what you would do is maybe request volume data. You could have multiple requests, Chainlink request memory, like request two, it's a terrible name, but Quest two, can you scroll over please? Quest two equals this whole thing.
01:17:51.520 - 01:18:33.450, Speaker A: Build channel request and instead of this hard coded job Id, maybe we look in the marketplace and we say, I want this job ID. So we could do like 32 job Id. Job Id two equals this, grab this job id two. We can even do address oracle two equals marketplace grab you. Hello, hello, address boom equals this. Excellent. And below.
01:18:33.450 - 01:19:19.426, Speaker A: And then we'll just assume the fee is the same. We do like request two, boom. We could also do even like just do, I don't know, returns. What is this? Return turns by 32 request Id. So we could do, probably get rid of this, actually just get rid of the returns. But you guys can see Oracle two, request two. This would be fee two and then repeat, rinse and repeat, and maybe even change the fulfills.
01:19:19.426 - 01:20:00.038, Speaker A: And this is where you put like a mapping in here. So you could do like, actually you'd probably do, we're going to go super deep into it. Like bytes 32, request ID one equals this. Bytes 32, request id two equals this. And then we can do like, we would probably have like a mapping again, like I was saying before. So mapping of bytes 32 to un 256, request to volume. I guess I'm coding live in front of you.
01:20:00.038 - 01:20:41.442, Speaker A: Guys, request to volume. Then we do like request to volume of first one. Actually, no, we wouldn't set anything here. But in this fulfill function we could just do request, request to volume, underscore request ID equals underscore volume, and then same thing for all the other ones. And then we could see, okay, which requests responded with which with volume, or. What probably makes more sense is you do like oracle. Like you'd have this be address to you into v six.
01:20:41.442 - 01:21:11.594, Speaker A: This would be like Oracle to volume. And we could see a history of which Oracle has responded with what. And this is actually what the data feeds basically do. And then on the last step, maybe you could have like a function aggregate. Function aggregate aggregate. I'm doing some pseudocode here, function aggregate. And then it's like you do a for loop, like for each, I know this isn't possible in solidity.
01:21:11.594 - 01:21:38.934, Speaker A: For each oracle response, this is a very bad pseudocode. This is like python pseudocode. So just ignore it. For each oracle response, add together and then return the mean of the add together. Right. So you just return the mean of all the oracle response add together. That's obviously pseudocode, but it really wouldn't be too difficult to put together.
01:21:38.934 - 01:22:03.626, Speaker A: So that's your answer there. That's a great question. Absolutely great question. And that's how you build these completely customized networks, these completely customizable, these data feeds, and really do whatever you want to do, which is really powerful here. From my understanding. It is encouraged to get data from multiple nodes as the routes are decentralized. But it's not the case for VRF.
01:22:03.626 - 01:22:40.410, Speaker A: Right. And we can just verify that randomness. This is a great question, actually. So VRF, as the technology kind of matures and improves. So first off, since the on chain contract is actually verifying that whether or not it's random or not, you don't really need that as much. There is the case to be made about basically the worst thing that can happen is that the VRF doesn't respond, because if it does respond and the number isn't random, it blocks it. And this is why there are only a few chain link VRF nodes to prevent against that one vector.
01:22:40.410 - 01:23:30.794, Speaker A: But that's a really good question. And more development is being done to kind of make those decentralized as well. But yes, since there is this on chain verifier of the remnas, it makes it much safer to use because you don't even need to worry if they're going to give you a rigged number because they can't. So great question, what is the purpose of all this? To find the correct number to whatever question you're asking. Yeah, it's to get data into your smart contracts. Hey, is ten raised to the 18th hard coded? If so, why? Ten? Good questions, guys. Keep them coming.
01:23:30.794 - 01:23:57.270, Speaker A: Yeah, so this is just a way for us to write 0.1 link for the fee. I mean, the other way we could do it is like 1234-5678 910. 123-45-6789 so this is the other way we could write it, the fee, but we just don't want to write that because that's hard for humans to read. So we write this and we go, okay, 0.1 raised to ten to the 18th, aka 0.1 length.
01:23:57.270 - 01:24:21.406, Speaker A: Great questions. Great questions, everybody. Keep going. He said earlier because solidity can't handle. Yes, he said exactly. Solidity can't handle decimal points. So the minimum, if you guys are familiar with way the minimum value of f or link or anything is one way.
01:24:21.406 - 01:24:57.974, Speaker A: So one way is equal to zero point. How many zeros are there ETH? Right? So one ETH is this many way. So when somebody says, oh, I have gas prices are 100 gwe right now, this is what they're really saying. And then guay is just the middle point between way and ether. Great questions. At what point is the oracle interacting and changing the state of the blockchain, requiring the oracle to pay ETH to respond, to submit response, for example. Really good question.
01:24:57.974 - 01:25:25.070, Speaker A: And this shows that you really understand what's going on. So when I make the request, I am the one interacting with the smart contract. I am the one that pays the ETH gas to make the request and to call that function. When the chainlink node reads this off, it sees, okay, they paid link. Right? And I also pay link away. Right away. When the chain link node sees this, it goes, okay, great, I'm going to go ahead and return data.
01:25:25.070 - 01:25:57.418, Speaker A: The chainlink node is the one that actually calls the contract, and it's the one that pays the link. So when the second contract that the chainlink node does respond, it's actually paying the ETH. And most nodes actually have like a max gas cap so that they can't just get millions of ETH attack there. But yeah, they will be the ones to make the response and pay the gas in response. Great question. Chainlink was recently released on arbitrum testnet. Can you explain a little bit of what arbitrum does and what it does for chainlink? This is such a good question.
01:25:57.418 - 01:26:31.366, Speaker A: Arbitram is a roll up roll ups are really awesome. So roll ups are kind of like more like true scalability for networks. So like something like, something like Polygon or XDI. These are side chains, right? They're these own side chains, but they have bridges that connect. A roll up is basically hooked in to the Ethereum main net, but you can do your transactions there. So Arbitram is an example of one of these roll ups. If you've heard of optimism, optimism is another roll up.
01:26:31.366 - 01:27:27.590, Speaker A: And particularly it's an optimistic roll up where it kind of assumes that things are going to be good. If you guys want to learn more about rollups, Vitalik has a blog out called like an incomplete guide to roll ups, and it gives a good idea of kind of these different scalabilities. So Chainlink is live on Arbitrum testnet, which means that Chainlink is live on these roll ups, which is really great question. Arbitrum helps scale the Ethereum network and what it does for Chainlink is Chainlink can run on arbitrum and bring data to the arbitram smart contracts that will roll up into Ethereum. So these roll ups, they basically do computation off chain. Almost think of it as like mini sharding almost. They roll up into the Ethereum chain and they help process transactions, just not on the main network.
01:27:27.590 - 01:28:10.512, Speaker A: Instead of creating multiple requests and smart contracts manually, can you make your own data feed? But for requests where multiple nodes check it off chain the report back if they reach consistent, yes, you absolutely can do that. That is a little bit harder, but absolutely 100% you can make your own. That is where I would kind of have to point you to the GitHub and kind of copy the contracts there. But you absolutely could do that. So the jobs that we were using were actually called run log jobs. That would be a different one. That's called flux monitor, where they actually let me actually find the initiator.
01:28:10.512 - 01:28:39.708, Speaker A: It's actually a different initiator, a flux monitor one. The flux monitor will actually do that. Monitoring off chain and trigger an update whenever there's a deviation. You can also write your own external initiator, which is again, the initiators are just what kicks off a job for the run log. A run log job is just kicked off whenever we do that. Send chain link request to that defines a run log job. Flux monitor is a little bit more interesting.
01:28:39.708 - 01:29:10.498, Speaker A: I would definitely say check out the chainlink repo if you're interested in that. How does. I'm catching up on the questions. Don't worry. How does polka dot work with chainlink, are they both layer two? Polka dot works on top of chainlink or side by side? This is a really good question, actually. So it's a little bit confusing here. So polka dot is actually, I think, what they consider and what I consider as well, a layer zero.
01:29:10.498 - 01:29:38.586, Speaker A: Right? So Polkadot is aiming to be a blockchain of blockchains. Right? So interoperability between chains is a big issue. Right. We want these smart contract platforms to be able to talk to each other. More and more of them are coming out every day, so we want them to be able to talk to each other. Polkadot is a layer zero in the sense that it actually connects all these layer one blockchains together. So that is the purpose of Polkadot.
01:29:38.586 - 01:30:17.066, Speaker A: Chainlink is actually a me. Polkadot also has this feature called substrate, which allows people to kind of build like a ruby on rails, but for their own blockchains, which is really cool. Chainlink has a palette with substrate for these ruby unreal blockchains where you can make a blockchain that natively already comes integrated with Chainlink and has like Chainlink as kind of this default oracle service for these substrate chains. So they're not both layer twos. Chainlink is actually the layer two. Polkadot is the layer zero and all these other blockchains are the layer ones. So Polkadot would be here.
01:30:17.066 - 01:30:54.190, Speaker A: Blockchains like Ethereum, avalanche, Polygon, all these layer ones, although Polygon is almost like a layer two because it's kind of, that one gets a little bit tricky and then you have your layer twos like chain. Right. So really good question. That's how it works. Hopefully that answered your question. What happens if you have an API that requires accounts or payments to access? Are we limited to free APIs? No, you can use APIs with keys. I mean, the bad way to do it is just put your keys on chain.
01:30:54.190 - 01:31:29.774, Speaker A: The better way to do it is build an external adapter, which you should come to that workshop where we will explain how to do that. Basically you give your key to like a node operator, and that node operator makes that API call with the API key so that that key isn't public information. So great question. We will show you how to do that in the workshop. Seems like ETH and link will be okay. Do roll ups sacrifice decentralization as I understand other l two s do? No, they actually make everything way better. Right.
01:31:29.774 - 01:32:43.494, Speaker A: Because you're still running this decentralized network, centralized layer two, and it does this. I think that it's actually probably better for decentralization because you can still challenge these layer two transactions, right? So basically the answer is no. Doesn't sacrifice decentralization. Really. What's the benefit of being non Turing or human discernible code in regards to smart contract implementation as opposed to other methods like what ETH uses? I feel like this question is almost like, why does Bitcoin have its scripting language? There are a lot of reasons for that, and one of them is that you don't have these crazy. You'll never have like a crazy smart contract where maybe there's some recursive stuff that happens, where it just drains forever, or you can accidentally program your smart contract, do some crazy. If you're like a blockchain, like bitcoin, for example, that intentionally does non turing complete smart contracts, it's because of what you want your blockchain to do, right.
01:32:43.494 - 01:33:19.182, Speaker A: Bitcoin wants to be a store of value, and it's good at that. And it doesn't have touring complete smart contracts because it doesn't want to sacrifice any of its attributes. That can get into a little bit more philosophy there. It's really just a choice of what you want the blockchain to do. If you wanted to have turing complete smart contracts so they can do the smart contract platform, then great. If you want it to be more less functional. Gold doesn't have smart contracts, and people still value gold.
01:33:19.182 - 01:33:55.760, Speaker A: And it's probably better that gold isn't like programmable or maybe it's not better, I don't know. But yeah, those are kind of the more philosophical reasons behind. That's got a whole bunch more questions. You're a friend of some people. Okay, awesome. Well, welcome. Is arbitram utilizing chainlink OCR for those off chain computations, or is OCR only utilized by nodes in a network? Can provide a few examples of OCR in.
01:33:55.760 - 01:34:25.560, Speaker A: Yes, yes, I can. So, data chain link, let's go here. A lot of these feeds are currently on OCRs. I'm not sure which ones, to be honest, but I know a lot of them are, which is really powerful. I think arbitrum doesn't have the OCR data feeds up yet, but it will. So, yeah, most of these feeds that you see here have converted to OCR. More and more of them are converting as we speak.
01:34:25.560 - 01:35:06.860, Speaker A: Some weird questions here. You have your tea. Okay. I have my tea. Okay. Can you explain how chainlink is blockchain agnostic? Like Chainlink operate without ETH and some other gas fees? Yeah, so great question. The answer is kind of like, I mean, look at the sponsors for this hackathon, right? We have polygon, moonbeam, arbitrum, polkadot.
01:35:06.860 - 01:35:32.492, Speaker A: I might have already said Polkadot, polkadot and polygon. I forget I said one of the bees. Solana, we have all these blockchains that are layer ones that chainlink can run on and deliver data to. So that's really it. Chainlink can be blockchain gnostic as it can run on all these chains. And the reason it can do this is because of how modular the system is. Pardon me? Because of how modular the system is.
01:35:32.492 - 01:36:03.644, Speaker A: Right. It is able to change because we can do these external initiators and these external adapters which can be customized for whatever blockchain that we want to work on. So Chainlink is unlimitedly customizable. And this is why it's blockchain agnostic, because it can run on any chain. Great question. Trying to answer questions as fast as they come in. In the example you've shown, 0.1
01:36:03.644 - 01:36:32.520, Speaker A: link was hard coded. Is 0.1 link supposed to be static and forever or developers supposed to implement a way to change that in case node operators change? Yeah, that's actually a really good question. And the answer is basically yes. So node operative might change and monitoring the network and making sure that it is the most up to date is important. And this is why you're going to want to do proxy stuff. Or maybe you pretty much want to have it always variable so that your smart contract can adapt correctly.
01:36:32.520 - 01:37:24.070, Speaker A: Great question. It is an ERC 20, correct? No, chain link is an ERC 677. It has a bunch of increased functionality specifically for working with off chain data. How does a lending protocol execute liquidation when a certain condition is met, such as you have not enough collateral to hold your loan? This is a great question, actually. So it really depends on the lending protocol. So maybe after every transaction it checks to see if you have enough collateral. Maybe once a day, using something like keepers or something or some type of timed oracle mechanism, it checks to see everyone's balances and if they're out of sync, it liquidates things.
01:37:24.070 - 01:38:01.130, Speaker A: Maybe anytime there's a specific price update or something. It really depends on how the protocol wants to implement it. Link is not an ERC 20. It is an ERC 677. This is a backwards compatible ERC 20. So it has increased functionality, like I was saying, but you can also use it as if it's an ERC 20. All right, I am all caught up with the questions.
01:38:01.130 - 01:38:28.688, Speaker A: All right, cool. Well, everyone, thank you so much. This has been a blast I hope you guys all learned something. I know this is a lot of fun to chat with you guys and talk about chainlink here. We got a ton more stuff for the chainlink hackathon tomorrow. Brownie and truffle are really going to be these key pieces. For those of you wanting to build something really cool, those are the smart contract development frameworks that most professional software engineers actually use.
01:38:28.688 - 01:38:51.032, Speaker A: You can see a lot of the top projects on Defi pulse. For example, they are using, like, hard hat or brownie or truffle to run their applications. And we're going to go over all three of them. So 100%, if you're like, hey, I want to get into this deeper jump into this workshops tomorrow. We're going to teach you how to become awesome software engineers and work with Chainlink in the best way. And I'll talk to you guys then. Thanks.
01:38:51.032 - 01:38:51.690, Speaker A: All.
