00:00:04.490 - 00:00:18.686, Speaker A: Hello. Hello. Welcome, everybody. We are here for the security and auditing portion of the chain link hackathon. I hope everybody is having a phenomenal hackathon. Hope you're all doing well. I know you're all doing well.
00:00:18.686 - 00:00:30.962, Speaker A: You're at a chain link hackathon. Hope you're all meeting each other. Hope you're all making friends. It's not the solidity, it's the friends we made along the way. That's the real treasure, right? GM. GM. Let me see some GMs in the chat.
00:00:30.962 - 00:01:06.454, Speaker A: What up? GM. GM. How are we doing? We'll give everybody a couple minutes to come on in. And while you're coming in, if you want to post in the chat here what your level of coding prowess is, how strong of a coder you think you are, how you feel. How are you feeling? Are you like, I'm a wizard. If you're a wizard, smart contract engineer, put a wizard in there. If you're intermediate, put an intermediate.
00:01:06.454 - 00:01:25.874, Speaker A: And then if you're kind of a beginning, be like, just kind of get started. If you're like, how the hell did I end up on this? Know, post that in the chat as me. This will give me a good idea as to how to tailor this stuff. Oh, you like the foundry video, Tippy. Appreciate it. Hashtag beginner. Okay, cool.
00:01:25.874 - 00:01:46.700, Speaker A: So, yeah, give me your solidity level in the chat here, and then also your smart contract auditing or security engineering level. This will also give me a good idea of where to start. Mario, hello. I'm starting the NFT on chain in your two day course. Excellent, excellent. All caps. Love to see that.
00:01:46.700 - 00:02:12.078, Speaker A: Intermediate beginning to mid. Okay. Expert to Doc Skimmer. Okay, who here would say that they are kind of beginnerish on security auditing? What's your level of security and auditing? What is your level of security and auditing? The heads up there. Security on the zero. Okay. Expert, doc skimmer.
00:02:12.078 - 00:02:29.204, Speaker A: Excellent. Help people following the free code camp course. Excellent. You'd love to see that. You'd love to see that. Anyone else? These docs are a little bit or these comments are a little bit delayed here. Beginner.
00:02:29.204 - 00:02:38.556, Speaker A: Added the security and boot camp last year. Excellent. Beginner level. One beginner. Okay, cool. So this will be perfect. So this is more for beginner and intermediate security people.
00:02:38.556 - 00:03:05.220, Speaker A: So you are all in the right spot, or even beginner and intermediate solidity peeps. So let me change my camera here. Obs, a little bit of magic. Wonderful. So a quick introduction. So, my name is Patrick Collins. I should be on this side here somewhere if I scroll the way to the bottom.
00:03:05.220 - 00:03:49.976, Speaker A: I'm one of the co founders of the Cypher protocol. We do smart contract audits security and really our entire aim is to just help web3 in any way, shape or form that we can. Right. Help web3 scale by enabling developers such as yourself to do more. And in this presentation today, we're going to be going over auditing smart contract security, how to find bugs, just kind of the real beginner, the basics of security in web3 and security and smart contracts. So that's what we're going to learn today and how to find every bug, literally the exact steps that the top auditors in our space use to find bugs and secure their code. So let's jump into it and we're going to be doing some exercises.
00:03:49.976 - 00:04:22.284, Speaker A: Did I spell that right? Exercises? I don't think I did, but it's fine. Some exercises in foundry. If you want to look up my GitHub, I've got this link. Patrick Alpha C slash Denver security. This is a presentation I did especially for some Denver people. So if you want to follow along, this is the repo that we're going to be working out of and it has all of the code that we're going to be working with. And this is a QR code.
00:04:22.284 - 00:04:36.384, Speaker A: If you want to scan the QR code to get the link, let's get froggy. Yes, you love to see it. You love to see it. But yeah. So this is what we're going to be doing. We're going to be working out of this code base here. Oh, yeah.
00:04:36.384 - 00:05:02.472, Speaker A: A little bit more about me. My name is Patrick Collins, smart contract engineer, auditor educator, et cetera. You can find my Twitter, YouTube, our cypher website there as well. A lot of people have been saying they're doing some of my free codecamp stuff. Yeah, I love making educational content, love helping developers at scale. So here's our agenda here. Quick primer on why security is even important.
00:05:02.472 - 00:05:42.064, Speaker A: And then how long do we have? Is this an hour long? Yes, this hour long. Okay, cool. Quick primer on why security is so important, how to have a security mindset, some prerequisites to getting into security, and then we're going to go into the audit process. And a lot of the tools, the tools bit is going to be probably the most important piece of this entire presentation and definitely the takeaway that I want you to have for this. When it comes to tools, these are kind of the steps that I like to think about people should really take. So they should absolutely. Start with your test suite, then move to static analysis, then fuz testing, differential testing, form of verification, AI tools, et cetera.
00:05:42.064 - 00:06:05.868, Speaker A: There's some other tools along the way. Well, actually, I guess I should say we would stick manual review in here. But if you're like, what the heck are all these words? That's fine. We'll get to this in a minute. So, I've already did a little bit of a quick roll call of everyone's experience level with security. But, yeah, I'm monitoring the chat. I can see everyone's comments here.
00:06:05.868 - 00:06:51.736, Speaker A: Yeah, if you want to put in the chat again, like your confidence level when it comes to smart contracts and your confidence level when it comes to security, that would be awesome. Just so that'll give me more context as to how to tailor the rest of this presentation. So let's jump into why security, right? Why do we care? Why does this even matter? Well, matters for a lot of reasons. Number one, these numbers are quite big. These are very big numbers. So this is a snapshot of this site wrecked news, and they keep track of top hacks that have happened in the web3 space. All of these are more than half a billion dollars, which, if you look over here, you see this little unaudited keyword.
00:06:51.736 - 00:07:42.056, Speaker A: It means that these were smart contracts that were unaudited and they just shipped it, and they were like, yeah, these are probably fine, and they were not fine, and they lost over half a billion dollars because of that. In 2022 alone, DFI was hacked for $3 billion. $3 billion. That's a lot of money. And if you think about this, okay, if the risk versus reward is okay, I can either get a 200 million dollar hack or I can spend $2 million in security. If you're a protocol, obviously spending $2 million in security gives you a 99% reduction in cost. Isn't that amazing? So making sure your code is secure is going to help you in the long run for a billion, billion reasons.
00:07:42.056 - 00:08:13.716, Speaker A: And it's going to help web3, and you're going to look smarter and you're going to have a better reputation. There's a million reasons why we absolutely need to focus on security in web3. Security is for both protocol devs and for auditors. Okay? It's for both the protocol. Whoever's building the protocol, it's for them and for the auditors creating it. So if you want to be an auditor, you should learn security. If you want to become a smart contract developer, you should learn security.
00:08:13.716 - 00:08:42.464, Speaker A: Right? Security is for everybody. The reason, especially it's for protocol. Devs is you have to have a security mindset from day one. You can't just build your protocol and then at the end, go, hey, all right, cool, auditor. Now make this secure, because if your architecture is garbage from day one, well, I got news for you. I don't care how good the auditor is, if your architecture is garbage, you're not going to get off the ground. And this is kind of a funny example that I'd like to give.
00:08:42.464 - 00:09:27.260, Speaker A: Let's say that this is your contract, this car in the left is your contract, and you go, hey, we're done with our code. Auditor, can you please make sure this is ready to drive? Can you please make sure this is drive safe? The auditor is going to turn around and go, oh, no, I don't even think this is possible. The auditor would literally have to build the car for you. So we need to have security in our minds from day one. Okay, cool. And also, there are some jobs and stuff for those of you who do want to become smart contract auditors. You become an auditor at a firm, an independent auditor, tooling developer.
00:09:27.260 - 00:10:14.030, Speaker A: This right here is kind of some salaries for a very senior security engineer. Kind of a more mid level is going to be around the 150K, more junior is going to be 100K. So if you get really good at smart contract security, there's a lot of careers available in this role as well. So not only do you keep your protocol more safe, there's some careers that you can go into, too. So let's talk about some prerequisites before you can really even go deep into solidity, or, excuse me, deep into security and auditing. You definitely need some EVM knowledge, like solidity, Viper, whatever you want to be working with. But even more than that, you need a willingness to be constantly learning.
00:10:14.030 - 00:11:19.810, Speaker A: Hackers are going to continuously change the way that they approach hacking protocols. So you always need to be learning and always need to be growing when you're a security engineer and when you're doing security. So if you don't want to learn anything, you're probably not going to go very far. But if you like learning, if you love constantly diving into projects, you love constantly scaling yourself up, this is really all you need to start working in security, start thinking about security, but the more the better, right? So having an adversarial mindset, some industry specific knowledge, doing some ethical hacking, use of security tools, these all can help you become a better smart contract auditor. And especially those security tools, is something we're going to be talking about today. So this was kind of just a primer on security, what it takes to become an auditor or security engineer. Are there any questions so far? And I'm down to pause for a second, answer any questions.
00:11:19.810 - 00:12:03.970, Speaker A: Oh, that's the wrong camera. I should turn my other camera, my good camera back on. Oh, are there any questions so far? Yeah, it looks like I messed up my camera here. There we go. Any other questions so far? I will wait for a question after this beginner friendly course. Do we have the knowledge to start auditing? You have the knowledge to start thinking about auditing. That's what I would say.
00:12:03.970 - 00:12:30.730, Speaker A: I will give you some paths as to where to go if you just watch this. I would definitely not recommend you leave this presentation and start your own auditing firm. I think that you won't quite be ready for there, but you will definitely have the knowledge to start thinking about moving in that direction. Absolutely. You will have a high level overview of everything you need to be thinking about. How are you? I'm doing great. Thanks for asking.
00:12:30.730 - 00:13:01.950, Speaker A: All right, cool. Let's flip back. Cool. All right, so let's talk about the audit process. What's the audit process look like? If you finish your code, once you finish your smart contract code. Am I doing this right? Once you finish your smart contract code? Actually, two more questions. Are there resources we can use knowledge from this workshop to go and check out previous audits to learn from? Yes, absolutely.
00:13:01.950 - 00:13:36.840, Speaker A: I will give you a ton of resources at the end of this. A couple of them, actually, I can give you right now. You want to see kind of some of the top audit reports and compare them against each other. You want to search through all audit reports? Check out Solidit XYZ. This is a great place. Wow, they totally redid the UI. This looks awesome.
00:13:36.840 - 00:14:00.638, Speaker A: Check out Solidit XYZ. This is a great place to check out all reports in one place. Like it literally says right here. Also, if you want to start testing yourself, you can go to Ethernot. It's a really good question. Ethernot by open Zeppelin. It's a list of games that you can try out to test your security.
00:14:00.638 - 00:14:29.706, Speaker A: Another one is damn vulnerable defi. Damn vulnerable defi by Tincho. This is another really good one that you can actually start testing out your skills. Great question. And then let me punch in my test password. Sorry, one sec. I'm not going to use that, but whatever.
00:14:29.706 - 00:14:54.180, Speaker A: All right, cool. Great questions. How do you motivate yourself to audit projects all the time? Well, I would like web3 to be safer and that motivates me a lot. Oh, also you can do competitive audits, and we can talk more about that later. How can I know my smart contract is ready to be audited? Great question. That question will be answered at the end of this. Good question.
00:14:54.180 - 00:15:21.034, Speaker A: All right, cool. So let's talk about the audit process. So first off, there is actually no silver bullet to smart contract auditing. Right. However, these are kind of the main steps that people usually take is some type of manual review and then also using tools to augment their review. Manual review is exactly what it sounds like. You're going through the code and even more importantly, the documentation and understanding what the protocol should do.
00:15:21.034 - 00:16:02.774, Speaker A: A lot of people think you need to be like an EVM savant to do audits, but really, you almost more importantly need to be a business logic savant. Most bugs that we actually find come from some business logic implementation being done wrong. And the only way you could catch that as a bug is if you understand what the code should be doing. You understand the business logic. So a lot of tools actually have a really hard time finding most bugs. And actually they've done studies and they found that 80% of all bugs are actually what's called machine unauditable. So automated tools won't catch 80% of the bugs out there.
00:16:02.774 - 00:16:36.002, Speaker A: So, meaning automated tools can really only catch 20% of all bugs. Crazy statistic. Which means manual review is going to be the tool that's going to catch at least 80%. Now, AI is getting better, but if you try using AI as kind of your main automated tool, it's not really going to help that much. We've been experimenting with AI. Most auditing firms are experimenting with AI right now. They can be a little bit helpful with giving you context, but they kind of suck by themselves right now.
00:16:36.002 - 00:17:09.850, Speaker A: So, yeah, 80% of all bugs are what's called machine unauditable, which is kind of a crazy stat, which brings kind of to this. Yeah, you got to read the docs. You got to actually understand what the protocol does. And I know as developers, we're like, we don't really want to read the docs. We're going to browse, stack, overflow, or chat DBT or whatever for hours and do that instead when it probably would have been better if we just read the docs. Yeah, and just trying random stuff. You got to understand the docs.
00:17:09.850 - 00:17:42.832, Speaker A: You got to read the docs. So I just want to reiterate, you need to understand what the protocol should do. Right. Because 80% of the bugs are going to be from machine unauditable issues. Understanding what the protocol does is one of the most important parts of manual review. So what does that involve? It involves you sitting your butt down and you reading a ton of code and words. It's a long process.
00:17:42.832 - 00:18:13.708, Speaker A: It's a hard process, but that is the main piece of manual review. And with manual review, repetition is the mother of skill. The more you do it, the better you will get. That's really it. It might seem daunting at first, it might seem incredibly hard, and it probably will be incredibly hard at first. But the more you do it, the better you get. Right? Like I can come to a code base now seeing 4000 lines of code and know that, okay, after a couple of weeks I'm going to understand how every inch of this thing works.
00:18:13.708 - 00:19:07.452, Speaker A: Whereas in the beginning, when I was first starting, I would see 4000 lines of code and I would go, oh my God, I'm never going to understand any of this. So repetition is a mother skill. The more you do it, the better you will get. Now this brings us to our first actual code piece here. So this is a smart contract called caught with test. We have this function, set number, and what this is supposed to do, it's supposed to set this number variable to whatever new number is. If you saw this code, if you saw this contract and you're a smart contract auditor and you're doing security, you might go, oh yeah, there's nothing wrong with this function, right? I don't see any solidity issues.
00:19:07.452 - 00:19:40.250, Speaker A: I don't see anything wrong. But if you knew that set number should set number to whatever new number is, you would immediately go, oh my goodness, you're setting number to new number plus one. That's wrong. That's potentially a security issue, right? Because this set number function is not doing what this protocol is intended to do. And this would come from manual review. But this is why testing is so important. So if we go to the GitHub repo here, in here we have a test folder caught with test.
00:19:40.250 - 00:20:53.466, Speaker A: If we write a foundry test where we just simply have, hey, okay, my number equals 55. Let's call set number. Once we call set number, my number should equal that number in the contract. This would fail. And we can actually run this test. If we run forage test m run that specific test, and it should fail it. And we do indeed see it fails here, right? Because we should be doing, if we do that, this should be not number equals new number plus one.
00:20:53.466 - 00:21:20.866, Speaker A: This should be number equals new number this. And now if we rerun the test. We actually get this passing. Fantastic. Put it back to failing. All right, cool. So manual review, incredibly important tests are a great way to augment your manual review to tell you, hey, here's what this code, this is what this function should do.
00:21:20.866 - 00:22:00.094, Speaker A: And it's that combined with the docs, that can actually help you do that. So any questions about this so far? This is kind of the most basic piece here. Will number plus equal number work? You mean number plus equal new number? Um, so this is a really good question, actually, because again, we need to understand what set number does, right. If we're adding this new number to number, then great. Yeah, that would work. But we would know from reading the docs, oh, set number should set new number to number. So we know that this is not right.
00:22:00.094 - 00:22:27.562, Speaker A: And we would know that number plus equals number would also not work. Right. Because that isn't setting number, that's adding to number. Does the audit often result in improvements in the protocol docs too, as a side effect? Great question. This is something that I think isn't done enough. It should is the answer. It doesn't always do that.
00:22:27.562 - 00:23:19.248, Speaker A: I think more audit firms do need to focus on almost like documentation audits as well, because a lot of times protocols don't document what their code should do and that A, makes the audit a lot harder and B, can find issues right there. So, Matt, to answer your question, it doesn't, but it should. And more security firms should definitely pay attention to that. That's like the logic in your favorite number tutorial, right? Yes, it's very similar to that. Any other questions? Oh, what's up? Greetings from Turkey. Oh, hey. I didn't even see there.
00:23:19.248 - 00:23:41.332, Speaker A: Cool. All right, great. We're going to keep going. So let's talk about some tooling. I already talked about manual reviews, so we're going to skip over that. And we have an example that, this just brings us to Denver security SRC, caught with manual review. Here's another good example of what a manual review would catch.
00:23:41.332 - 00:24:13.120, Speaker A: So this code by itself is fine. There's nothing wrong with this, right? But we have this documentation here. It says adds two to a number to add and returns it. And we can clearly see that number to add adds only one. Right? So an automated tool wouldn't catch this, right? This is manual review and AI actually probably would be able to catch this, which is great. But we need to do number to add plus two instead of number to add plus one. So this is something manual review and testing would catch.
00:24:13.120 - 00:24:47.500, Speaker A: The chat is way too lagging. Yeah, the chat's kind of lagging. As an audit firm, do you run their test cases before creating your ones? That's a big step in the audit firm. In the auditing step often is, yeah. Hey, do your tests even make sense? And if I'm specifically looking for bugs and I see and I run their tests and I find, oh my goodness, they don't have any tests on this lump of code. Well, guess where I'm looking for bugs? I mean, that lump of code, that's exactly where I'm looking for bugs. Or that's one of the first places I'm looking for bugs.
00:24:47.500 - 00:25:06.736, Speaker A: So, cool. So we talked about test suites a little bit. We talked about manual auditing already. A little bit. But yeah, test suites are really one of the first lines of defense for any and every protocol. You absolutely need to be having a test suite. If you come to cypher and if you come to us and you say, hey, can you please audit this code? We don't have a test suite.
00:25:06.736 - 00:25:34.152, Speaker A: I'm going to tell you, you're not ready for audit. So somebody said, hey, how do you know you're ready for audit? This is absolutely step one. If you do not have a test suite, you are not working with a mature code base and you should not deploy, just full stop. You should absolutely, under no circumstances deploy code without having a test suite. So just full stop. I will literally turn you away. I don't care how much money you pay me, I will turn you away because I know for a fact you're not ready for audit.
00:25:34.152 - 00:26:00.692, Speaker A: And my job as a smart contract auditor is not just to do an audit report. My job is to make sure that you're more secure. My job is to make sure that when you launch your protocol, we can do it with a lot of assurance that we're not going to get hacked. And if you don't have a test suite, I have zero confidence. Zero confidence. So always need to write a test suite and try to get as much coverage, try to cover as many lines of code in that test suite as possible. So I have an example here.
00:26:00.692 - 00:26:52.822, Speaker A: This just brings us back to our caught with test that we already kind of went over. Like this function, we get caught really easily in a test suite, even the manual review, we get caught really easily in a test suite. So this is absolutely 100% the first line of defense. Writing good tests is one of the most important steps in making sure that your code is ready for audit. Is there a way to download foundry for WSL? Yes, you should be able to do, just be able to do this right here. If you can't, you can build from source, but this should work for WSL. This line here, what test suite do I recommend? I think any of these are great.
00:26:52.822 - 00:27:15.822, Speaker A: Foundry, hardhat and Brownie I would say are the most popular right now. Truffle and apworks are great too. For those of you who have been around a little bit longer, DAP tools works really if you pick anything from this list, great remix. You can actually write your tests in solidity or JavaScript as well. So any of these are fantastic choices. It's really just what you like the best. So foundry is the fastest framework by far.
00:27:15.822 - 00:27:37.480, Speaker A: All tests are written in solidity. Hard hat is the most widely used. Everything's in JavaScript. Brownie is pythonic, everything's in Python. You can also use boa too if you're working with Viper. If you're using huff, you'd probably want to use foundry. Yeah, aporks is pythonic, remix is solidity or JavaScript, and then Truffle is JavaScript based.
00:27:37.480 - 00:27:55.018, Speaker A: Great questions. All right, cool, moving on. Static analysis. Static analysis is the process of automatically checking the code for issues without actually executing anything. Hence the debugging is static. Right. So this is where you basically run some tool.
00:27:55.018 - 00:28:42.550, Speaker A: Artificial intelligence would also be considered static analysis, where you basically take some tool and you say, hey, look at this code. Does this look okay? Right, you're going to have to build from source. That definitely sucks. Sorry to hear that. Leave in my readme we have in here. Um, yeah, sorry. Most of these tools just kind of like dumbly look for keywords in specific orders, but they're great tools to use because they can just kind of be fantastic sanity checks.
00:28:42.550 - 00:29:14.674, Speaker A: And so here's the example we're going to be working with. It's going to be this slither sol. So we have this contract here, and this is the age old issue here. This is vulnerable to something called a reentrancy issue. This will compile fine. You could absolutely find this in manual review. And again, actually everything could be found in manual review, but we want to use tools that give us some assurance that we're going to make sure to find those.
00:29:14.674 - 00:29:53.674, Speaker A: Right? Manual review. We kind of have to trust human beings, don't mess up. Tools will not mess up. But this has something called the reentric issue down here. This line right here happen is when we call this message call and pull the money out of this, they could send this message call to a contract that will reenter this, recheck the balance. See that they have a balance. Withdraw again, withdraw again, withdraw again, withdraw again.
00:29:53.674 - 00:30:19.930, Speaker A: Just keep basically withdrawing and then only update their balances to zero at the end. This would be mitigated if this line was up here. The balance set it to zero and then make the call. And if they try to reenter, their balance would be zero. Real classic attack here. If you're unfamiliar with reentrancy attacks, if you google it, you'll get 1000 results. But feel free to ask any questions you assume.
00:30:19.930 - 00:31:02.164, Speaker A: But we can find this by just running a static analysis toolther exclude dependencies. We'll see that it actually will catch this for us so we don't have to trust that a human being is going to. And then you can ignore that for now. That's symbolic execution stuff for later. I might have to. Okay, there we go. So info detectors, reentrancy in, caught with slither, withdraw.
00:31:02.164 - 00:32:09.140, Speaker A: Right. So it found for us these reentrancy issues, even gives it to us in red. And so that we can know, hey, all you have to do is run Slither on this code base and we would have found this reentrancy issue. Reentrancy issue, unfortunately to this day, is still one of the most common bugs we see in the wild. And yeah, all they would need to do a lot of the time is run slither and it would have got it and it's really disappointing. Static analysis, great tool to use. Any questions on static analysis? Any questions on static analysis which made a protocol fell for reentrancy? A lot of them.
00:32:09.140 - 00:32:45.650, Speaker A: If you go to rec news, go to leaderboard. A lot of these. So I forget which ones off the top of my head, but a lot of these or read the cryptopians. Yeah, the Dow hack. This is commonly included in CI. Yes, great question, Evan. Yes, a lot of big protocols include slither in CI.
00:32:45.650 - 00:33:21.670, Speaker A: What more can we achieve with it? Well, if we go to slither GitHub right here, you can scroll down to all the different detectors that they have. It's in the wiki, I believe in the wiki detector documentation. You can see all the different types of detectors that they have here. There's a huge list of stuff they detect for. So you can find a lot of stuff in here. Is slither your preferred static analysis tool? Yeah, I definitely pretty much always use it. Big scary.
00:33:21.670 - 00:33:44.900, Speaker A: Yes. Does Chainlink have labs have any rest calls available? I've only seen API calls. I'm not sure I follow chainlink. You can make HTTPs calls if that's what you're looking for? Yeah, I guess. I don't know what you mean. I've only seen API calls. Like a rest call is an API call.
00:33:44.900 - 00:34:10.940, Speaker A: Do I need to be a smart contract engineer first to be a smart contract auditor? No, a lot of these smart contract auditors that I know are mediocre smart contract developers. It definitely helps though. It definitely, definitely helps to be a smart contract engineer. Yeah. The cryptopian, the Dow hack. Yeah, the most infamous attack of all time. Any other questions? These are great questions, by the way.
00:34:10.940 - 00:35:04.064, Speaker A: Cool. A little bit delay on the comments here, but that's fine. Fuz testing. Fuz testing, also known as fuzzing, involves providing random data as inputs during tests. And in my opinion, this is the brand new floor for security. I've got a great video, can we go to YouTube? There it is right there. Got a fantastic video on fuzzing.
00:35:04.064 - 00:35:19.420, Speaker A: This one right here. I highly recommend everybody watch it. I do some silly stuff in it as well. It shows me the silly stuff. Oh cool. We do some silly stuff in it as well. But it gives a really fantastic overview of fuzzing and how it can be super effective to making sure your code is safe.
00:35:19.420 - 00:36:18.888, Speaker A: But yeah, at the end of the day, it's really just sending random data as inputs to our smart contracts. And this is even better than testing because oftentimes we can't think of all the different scenarios that an attacker might do. So we can string together a whole bunch of random scenarios and use that as a basis to basically kind of COVID our bases. Hey, let's just do this whole bunch of random scenarios and see if it breaks anything. So if we come to our, and then actually let me comment this out so that it doesn't keep doing that. If we come to our code here, we've got this function. We know that this function should never return zero, right? Because the doc say should never return zero, right.
00:36:18.888 - 00:37:26.006, Speaker A: Writing a unit test for this would be really hard. Hey, how do I make sure this function never returns zero? Okay, well, I could pass zero into my number and write a test case for that. Then I could write a test case for one, I could write a test case for two, write a test case for 3456 different, et cetera. How do we make sure this never returns zero? Well, what we can do is we can just keep passing a ton of random numbers to this and let a process go that just kind of keeps picking different numbers and see if we actually break this property or invariant. So this is our invariant of the system that this should never return zero. And that's what we test for in our fuzz test. So if we have here caught with fuz t sol, we've got a fuzz test written in foundry, and we have this test fuzz function, which it'll keep populating this random number with random numbers, and then we'll keep calling, do more math with random numbers, and then we'll just make sure, hey, make sure it doesn't return zero, right? Because it not returning zero is our invariant.
00:37:26.006 - 00:38:26.640, Speaker A: So what we can do, pull this up. We can do forge test, m, paste this in, run this fuzz test, and once it compiles, or decides to not compile, whatever it wants to do, I guess. Come on. Here we go. Come on. So, no, we wouldn't need VRF for this, because we don't need a verifiably random number for this. We just need a bunch of randomish numbers.
00:38:26.640 - 00:39:12.840, Speaker A: This isn't part of a contract. Why is this not looking to compile for me? Here? Out. Here we go. Come on. Gods have spoken. My computer struggles running obs and other stuff at the same time, and that's something I'm doing right now. So it's probably not thrilled about this.
00:39:12.840 - 00:39:48.032, Speaker A: It's getting stuck somewhere waiting for my ape and foundry vids. Excellent. Excellent. Oh, maybe it wants us back in. Maybe it's mad at me for removing that. That'd be an interesting bug that I'd have to report. Oh, that is interesting.
00:39:48.032 - 00:40:09.960, Speaker A: I'm going to have to report that as a bug. Looks like if I put the model checker in, but I don't add contracts, it gets mad at me. Well, okay, whatever. Cool. Forge test, m test, fuzz. Now we'll run the fuz test. And boom, we found that right away.
00:40:09.960 - 00:40:53.796, Speaker A: It was able to find if we pass 1265, we actually break our assertion. So if we go back to cot with fuzz, if I do 1265, we can see we have this conditional here. If my number equals 1265, return my number module 1265, which is what? Zero plus one minus one times one, which would be zero. So this is actually going to return zero if we pass 1265. So it was able to find a case where we returned zero and say, oh, we found a breaking use case by just passing random numbers to this. So obviously, this is incredibly powerful here. Cool.
00:40:53.796 - 00:41:19.900, Speaker A: So that's fuzz testing. Any questions about fuz testing? Have you seen AI being used to pick out invariants from protocol docs, contracts, code, and then to generate tests about. It's something that I've been experimenting with a lot. I've seen other people too. It's mediocre at best. At the moment, definitely been having a hard time, especially when you get more complicated contracts. Most AIs have a context limit.
00:41:19.900 - 00:41:48.776, Speaker A: So if I dump 4000 lines of code and say, hey, this is this massive contract, can you give me the invariance? It's just not going to be able to process. It's just too much for it to handle. So we've been experimenting with different approaches to kind of piecemeal it together. Results have been kind of inconclusive. It's something that a lot of people are working on though, for sure. Great question, Matt. I think it's something we're going to keep experimenting and exploring with.
00:41:48.776 - 00:42:45.272, Speaker A: But there may be certain complex cases where the conditions would break when we pass test cases in a serial manner, will fuzz detect that? But there may be certain complex cases where the condition would break when we passed test cases in a serial manner. Will fuzz detect that? I'm not sure I follow the question, but I think I know how to answer what you're getting at. So, picking random numbers, obviously a unit 256 has a massive amount of numbers here, right? So if we wait long enough in our fuzz test, we could essentially just iterate through every single random number possible and hopefully just cover all use cases, right. We could just put in every single possible UN 256. That's kind of unfeasible for a time perspective. We'd have to wait, I don't even know how long, probably decades, centuries for a fuzz test to complete. And we need to ship.
00:42:45.272 - 00:43:19.172, Speaker A: So what most fuzzers do is they're actually what's called smart fuzzers, and how they pick the random numbers actually will determine how good your fuzzer is. So what most fuzzers will do, and in fact, what the foundry fuzzer does, is it sees that there's this conditional in here and it goes, there's this conditional pointing out, 112, 65. Let's try that as one of our original random numbers. Let's try two. Let's try one. Let's try 12345. Let's try all of these as random numbers and let's see if that works.
00:43:19.172 - 00:44:00.470, Speaker A: So how your fuzzer picks random numbers, and actually it picks semi random numbers will determine how good it is. So it'll usually do this thing called smart fuzzing, where to look at your code and try to figure out what it should pass just to get a good starting point. And then if none of those work, it'll go back to just picking randomish numbers. However, there are cases where fuzzing actually won't find certain issues. And this is if you have a crazy specific use case, the smart fuzzer can't do it, and you don't have twelve centuries to wait for your fuz testing run. And we'll get to that in a minute. But great questions so far.
00:44:00.470 - 00:44:27.128, Speaker A: All right, cool. Moving on. Feel free to keep asking questions. Next is another type of fuzzing. But a lot of people refer to them as invariants because that's what foundry calls them. This is something called stateful fuzzing. So, in our previous example here, this fuzz here, we pick a random number, we call do math, we check the assert, and then we start over.
00:44:27.128 - 00:44:47.388, Speaker A: We redeploy. Caught with fuzz, we pick a random number, we do it, we check it, we start over. We deploy a new contract, pick a random number, start over. This is called state less fuzzing, because every single time we run this test, we start from brand new. We start from a brand new state. We don't have any state. So this is called state less fuzzing.
00:44:47.388 - 00:45:24.092, Speaker A: State full fuzzing, or founder calls them invariant tests, is where the system remembers the state of the last fuz run and continues with a new fuzz test. So, this is state full fuzzing. And this is incredibly powerful because of this example we're about to see here. So, let's say we have this once again. We know our invariant is going to be should never return zero from this function. Do more math again. And in here, we can start to figure out, okay, well, how can this return zero? So, first, we do this.
00:45:24.092 - 00:45:58.808, Speaker A: U into 56. My number divided by one plus my value. Stored value equals response. Response. How can I make this return zero? How can I break this invariant? Well, this stored value up here starts off as 100. Um, excuse me, this, this, my value up here starts off as one. And if we do one divided by one, that's going to be one plus one is two.
00:45:58.808 - 00:46:36.150, Speaker A: So response is two return response. What we could do is we call new value. What's zero over one is if we change my value to zero, zero over one is zero, plus zero is zero, return zero. In order for us to break this invariant, we would first need to call change value by passing zero, and then call do more math again. Right? So this actually involves two steps. So, just us calling do more math again with random numbers here. This will never break our invariant, that we should never return zero, because we need to call change value.
00:46:36.150 - 00:47:30.572, Speaker A: So in order to break this invariant, we actually need to pass not only random data in here, but also random function calls with random data. Sorry. So if we go to our test case for this, it's a little bit more advanced. They're called invariant tests in foundry, which are just stateful fuzzing. What we do is we set up our caught with stateful fuzz contract, which has that bug in it, and we tell foundry, okay, that contract is going to be our target contract. I want you to string together a ton of random function calls with random inputs to their input parameters in all the coming fuzz tests. And you'll see that if we just do a regular state less fuzz test, it'll actually pass.
00:47:30.572 - 00:48:05.864, Speaker A: It won't find the issue. But if we do an invariant test or a state full fuzz test, it'll do a whole bunch of random function calls. It'll say, okay, I'm going to change the value to zero, and then I'm going to call do more math again. So now do forge test, m invariant test. Math doesn't return zero. It's actually going to give us a string, a sequence of function calls to break our invariant and make it so that that returns zero. So it says, okay, first we're going to call change value, and we're going to pass zero, and then we're going to call do more math again, and we're going to pass, really whatever we want.
00:48:05.864 - 00:48:45.540, Speaker A: And so our stateful fuz testing was able to find this stateful fuzzing, I would argue, is probably one of the most important testing methodologies, especially in DeFi. It's very easily able to find a lot of issues, and I think especially every DeFi protocol needs to be using fuzz tests and stateful fuz tests, because you're just going to have so much more confidence that your code is programmatically checked for. And when I'm doing an audit, I've actually found a bunch of bugs by just going, this is kind of confusing. I'm just going to write a fuzz test suite. And we literally find bugs in the first couple of days because we understand the invariance of the system. We write some fuzz tests. Boom, catch bugs.
00:48:45.540 - 00:49:38.480, Speaker A: Cool. Any questions about this? Is there manual fuzzing? What do you mean? Yeah, I mean, maybe I pick some random data. Sure. Yeah, you can do that. Is there some rule to follow which functions should be tested with fuz tests? Yeah, and this goes back to properties or invariance of the systems, something like in defi maybe you have a stablecoin and you just want to think of what are the properties or the invariants of the system, any property or the invariant of the system you want to fuzz test. So let's say you have a stablecoin. An easy invariant might be the total supply of the stablecoin should always be greater than the total collateral debt positions of the stablecoin.
00:49:38.480 - 00:50:21.110, Speaker A: Or maybe an easier one, like a lottery, for example. Hey, there should always be one winner. There should never be two winners, right? That's an easy invariant to fuzz test for a lottery. So then you would just say, okay, the lottery contract is my target contract. There should always just be one winner. Or maybe another invariant might be the winner should always collect less money than the total sum of entry tickets, right? Because maybe if you find a way to steal more money from the protocol than was given an entry ticket, you could actually steal too much money from the protocol. Right? So you want to fuzz test any property or invariant of the system.
00:50:21.110 - 00:51:00.896, Speaker A: Great question. Fantastic question. Why can't we all just get along, make memes and play? Wow. I mean, we can do that too, but I'm trying to build the future of finance. Should your fuz assumptions match your contract error statements and more, if applicable? Should your fuz assumptions match your contract error statements and more, if applicable? I don't totally follow your question. Um, should your fuzz assumptions. I think I hear what you like.
00:51:00.896 - 00:51:41.804, Speaker A: Should you have errors? Maybe is the question, right? I think I understand the question. Maybe because maybe your property or invariant isn't like if token too much revert. It's really kind of like more of an architectural system. Oh, Vmsume or VM pound. Should funds that match your contract error statement? What do you mean, match your contract error statements? I think maybe is the answer. So that's kind of a little bit more advanced for what we're going to go over here. Yeah.
00:51:41.804 - 00:52:16.744, Speaker A: So when you want to make sure your fuz test input parameters are within a certain range, you'll use VM assume VM bound. Not sure if I follow the question, if you want to rephrase for me. So stateful fuzz is more better than stateless, or they have their own efficiency in different scenarios, so they have their own trade offs. Right. State full fuzzing takes a lot longer to write tests for. Yes. At the end of the day, state full fuzzing is going to be more inclusive and go over more stuff.
00:52:16.744 - 00:52:50.900, Speaker A: But state less fuzzing is going to allow you to kind of more hyper specifically test a single specific contract. Right? And this again goes to, okay, the random number selection. If you just want to make sure that the input parameters to a function are good, you just do a stateless fuzzing, right. If you do state full fuzzing, then you might not cover the entire suite of inputs that you want to cover. So they have trade offs is basically. They have trade offs. Where can I learn more about testing? Spr? Interesting workshop.
00:52:50.900 - 00:53:10.552, Speaker A: My YouTube channel. Go to Patrick Alpha C on YouTube. We've got a more in depth video on fuzzing, symbolic execution and some other stuff like that. Great questions, everybody. Really good questions. All right, cool. And we have five minutes left.
00:53:10.552 - 00:53:37.270, Speaker A: So differential tests, we're going to skip this. If you want to learn more, you can check out the foundry docs. We're going to skip it. And then finally, formal verification. Formal verification, or FV, is kind of a generic term for applying formal methods to verify correctness of hardware. Applying FM means anything based on mathematical proofs in software, often used as a proof of correctness or proof of bug. And that's kind of a lot of big words.
00:53:37.270 - 00:54:14.320, Speaker A: And I kind of like just to break it down and say, okay, well, formal verification is just converting code to math. That's it. Once you convert your code to math, you can solve your math like you'd solve any expression. There are a lot of tools that do this, like Matt Manticores Z three is a solver Sartora. But yeah, it's really just taking your slitty functions and converting it down to math. Now, symbolic execution. Now a formal verification and symbolic execution is a way to do formal verification.
00:54:14.320 - 00:55:06.796, Speaker A: Now, the downside of symbolic execution is they take a long time to set up correctly, and you need to have a lot of domain expertise to get this right, and most of the time isn't worth it. We have a video on this on my YouTube as well, on form of verification right here. Go check that out. It's a lot of fun, but also there's some great threads, kind of, there's some great tips in the description for the blog we wrote with it as well, kind of explaining some of the best tools to do with it. I would argue most of you probably aren't going to need to do symbolic execution because a sufficiently powerful fuzzer is really going to be all you need. We have a demo. If you guys want to play with the demo in the GitHub repo, go for it.
00:55:06.796 - 00:55:36.680, Speaker A: We're running a little short on time, so I'm going to skip it now. But finally, AI tools. I talked about this a little bit before. Here's a wonderful example of where AI can really not be good. Yeah, this is what's heavier, ten k of iron or ten k of cotton. They're the same. But Chatterbati is like, iron is heavier, right? Like, some stuff like this is kind of funny that it can get wrong.
00:55:36.680 - 00:56:41.462, Speaker A: And that's it. Q and a for the, like, two minutes that we have left. Let me switch my camera. Questions. What specific strategies or algorithms are employed by foundry to ensure that the generated test cases during invariant fuzzing provide extensive coverage of the software's code base? So again, the foundry fuzzer is what's called a smart fuzzer, right? So they pick inputs based off of kind of what they read from the contract. What you're kind of asking is, hey, how do you ensure that the randomness use cases have good coverage? Did they cover enough use cases? So I actually don't think foundry has a really solid way of doing that right now. The consensus diligence fuzzer does, if you guys are looking for a paid alternative.
00:56:41.462 - 00:57:20.150, Speaker A: So the consensus diligence fuzzer will tell you, hey, we've covered 60% of all possible cases, which is really powerful. If you're looking for more assurance that your fuzzing is working, that might be a solution that you're looking for. Great question. ChatjpC is at high man. Cool. Any final questions before we jump off here? What's the difference in testing in foundry versus hardhat? Are there any tests that work better on any of those? So foundry is definitely faster. So if you're looking for speed, foundry is definitely quicker.
00:57:20.150 - 00:57:44.080, Speaker A: Hardhat is written in JavaScript, so if you like kind of JavaScript testing, you can do that. It's really up to you. It's what you like better. But I mean, that's kind of the main differences. Can you please provide more resources like Dan vulnerable defi of auditing a sample contract. Dan Vulnerable Defi is good, Ethernot is good. There's some other capture the flags that are really good.
00:57:44.080 - 00:58:08.370, Speaker A: I'm trying to think of more. I can't think of any more off the top of my head, but those are really good ones. How to be better at auditing. Sit your butt down and audit a. Oh. This answers both of your questions. Competitive audits are great places to go to as well, like code Farina, Sherlock, the saloon code hawks.
00:58:08.370 - 00:58:33.806, Speaker A: Those are all fantastic places. Those will allow you to do real audits, and if you do well, you actually will get paid. So the best way to become a better auditor is to do a lot of audits. Yeah, reading reports is really good. Like solidit. Fantastic site. So maybe you even crack open a code base and you do an audit yourself and then you compare it to an existing audit report.
00:58:33.806 - 00:58:58.806, Speaker A: Right. There's so much free resources out there for you to get better at auditing. Absolutely. On the cypher GitHub, we have a list of public audit reports that we've done. If you want to compare, if you want to grab one of the hashes and see if you can find more bugs. Great questions. All right, guys, well, we are at time here.
00:58:58.806 - 00:59:24.174, Speaker A: Thank you all so much for coming. I hope you enjoyed this presentation. I hope you learned a lot about how to be a little bit more secure. And I guess I'll say this, passing this final thought here, retail is never going to come to web3 until we make web3 more secure. 6% is a ridiculous statistic. It's like if you went to a bank in your country and said, hey, I'd like to put my money in this bank. And the bank went, okay, cool.
00:59:24.174 - 00:59:56.090, Speaker A: But there's a 6% chance that in a year it is all gone. You would never put your money in that bank. And it's the same thing with DFI. Retail will never put their money in DFI if we keep getting hacked as we are. So we need to make it more secure and we need to improve the narrative from, hey, just do an audit. Just get an audit to make web3 more secure. And having that mentality on let's scale web3 for security is going to make us a lot better in the long run.
00:59:56.090 - 01:00:02.710, Speaker A: So great questions. Thank you all so much for coming and good luck on the rest of the heck of a bye.
