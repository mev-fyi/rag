00:00:00.410 - 00:00:16.814, Speaker A: You. Hello. Hello. We got a special one for you all today. Hope everyone is as excited as I am for this one. This is a long one. This is a good one.
00:00:16.814 - 00:00:45.610, Speaker A: We're literally teaching you end to end, how to build a decentralized raffle. We're going to build the front end, we're going to build the back end, whole nine yards. This is going to be absolutely fantastic. So I hope you're all really excited because this is going to be an amazing workshop here. So just going to give people a couple of minutes to show up. Give me a couple of minutes to set up myself. Got my giant water bottle here, but I hope everyone is doing phenomenal.
00:00:45.610 - 00:00:58.894, Speaker A: Let me switch my camera here. Hello. Hello. How is everybody doing today? Welcome. Chat. Welcome. This is going to be a big one.
00:00:58.894 - 00:01:32.614, Speaker A: This is going to be probably the biggest one we've done so far. By probably, I mean actually, definitely. I hope everyone's doing today. How's everyone doing? Looking at the chat. How's everybody doing? Oh, there's an echo. Is there an echo? You getting some league before your coding session? You guys are brutal. No, I deleted it after that one round.
00:01:32.614 - 00:01:46.942, Speaker A: I instantly deleted it. That's how I deal with league. I instantly delete it after I play. Can't do this right now. Will this be recorded? Yes, will be recorded. Hello. How's everybody doing? How are we doing? You will be able to watch the video again.
00:01:46.942 - 00:02:10.466, Speaker A: It will be up on the chain link. YouTube. Yes. Growing the beard. I just haven't shaved. It'll be gone Monday. Sorry, everybody who's here, this QR code, this QR code, please fill it out after the workshop or whenever, really.
00:02:10.466 - 00:02:26.630, Speaker A: It is a feedback form to let us know what you thought about this workshop, if you liked it, if you didn't like it. And so we have a better idea of what workshops we want to do and what we don't want to do. So, hello, welcome. Hello. From Fiji. Hello, how are you? Better. I took a nap.
00:02:26.630 - 00:02:48.862, Speaker A: Excellent. Excellent. Hi. From hello, hello, welcome to the workshop. We're going to do this. We're going to have a lot of fun here. My giant water bottle so I can be nice and hydrated while teaching how to take fiat payment and change to crypto asset.
00:02:48.862 - 00:02:58.200, Speaker A: That's a longer conversation. Long conversation. Oh, hello from Dubai. What's up? Welcome to the stream. Hello, from Dubai. First one you're doing. Oh, boy.
00:02:58.200 - 00:03:07.190, Speaker A: This is a good one. This is a really good one. Argentina. Hello. More Madrid. Excellent. Got Madrid in the house.
00:03:07.190 - 00:04:03.642, Speaker A: What's going on? Madrid. I love this. Hello. Hello. And this is going to be a bit of a teaser for a lot of you know that I've been working on a hard hat freecodecamp master class, and so this is basically a subsection of one of the lessons in there, which is really exciting and it has not been released yet, so you guys are getting a cursory look. The thing that's kind of crazy, though, is we're going to do this in 3 hours. So the pacing on this is going to be kind of quick because, yeah, 3 hours is not really a lot of time to build the smart contracts, build the front end, deploy the front end, and then explain what I'm doing the whole time.
00:04:03.642 - 00:04:22.506, Speaker A: So we're going to be really quick. Yeah, we're having fun though here. It's Friday. We're building basically an entire hackathon project in 3 hours. Excited. Glad you're all in the chat. And like I said, this is going to be a very collaborative session.
00:04:22.506 - 00:04:32.226, Speaker A: Right. Want you guys to ask questions. Anything doesn't make sense. Ask away. And we're going to have fun. Right. If you want to follow along, feel free to follow along.
00:04:32.226 - 00:04:50.362, Speaker A: We're going to be going kind of quick, but if you want to kind of just see where the idea, ideology or where to start or kind of all the different things to think about when building your whole hackathon project. This is the video, this is the workshop that's going to do that. So hello from Spain. Zurich. Excellent. Dubai gang. Hello.
00:04:50.362 - 00:05:07.898, Speaker A: From canada, excellent. Oh, I love the. Oh, from turkey, excellent. Are you going to explain random generator? I am. Fillet jar with black coffee. Yo, Patrick, excited to follow along? Yes. If you can keep up, I will be beyond impressed.
00:05:07.898 - 00:05:24.210, Speaker A: If you can keep up, because we're going to be going kind of quick. Uh, all right, we're five minutes in. Know what that means? It's time for us to switch over to code. And let me just hit this. Hopefully I did it right. Oh, I did it right. Yay.
00:05:24.210 - 00:05:42.620, Speaker A: And we're going to be building our full stack. Raffle. Our raffle application. And let me remove the QR code again, please. I'll flash the QR code and the link for the survey as we come along this. We will be taking breaks in this. Hold on, let me switch back to that.
00:05:42.620 - 00:06:36.838, Speaker A: We will be taking breaks in this because this is a long session. So we will be taking a quick break halfway through so that people can go to the bathroom, get some coffee or whatever. Let's jump into this. Let's jump into this. So what are we going to do? Right before we code, it's always good to just write down what do we want to do? So we want to make a decentralized raffle or lottery or sweepstakes or whatever, some type of decentralized, I'm just going to say decentralized raffle. Right? We're going to make this decentralized application where it's 100% fair, 100% transparent. If you came to my the purpose of smart contracts talk at the beginning of the sackathon, one of the first issues that we ran into was, hey, McDonald's McMillion scandals.
00:06:36.838 - 00:06:55.298, Speaker A: That was wild. And we are going to build an application that could fix it. So if one of you wants to take this application, go to McDonald's and be like, hey, your monopoly scandal. I have the fix. It's decentralized smart contracts. Boom, here's the code. Thank you, Chainlink hackathon, for giving me the code for this.
00:06:55.298 - 00:07:23.670, Speaker A: I encourage you to do so. If somebody lands a like deal where you deploy like this as their monopoly be, I would be blown away. I would be absolutely blown away. So we're going to build a decentralized raffle. Now, let's write down some of the things that we want this contract to do, right. We're probably going to want people to enter the lottery, right? For a fee. We want people to enter the lottery for a fee.
00:07:23.670 - 00:07:46.638, Speaker A: We want people to be able to win, pick a random winner, and we want this picking of a random winner to be totally autonomous. At Nomas. Is that how you spell autonomous? I don't know how you spell autonomous. Autonomous. Autonomous. Wow. I'm great at spelling.
00:07:46.638 - 00:08:16.454, Speaker A: We want it to be autonomous. By autonomous, we're meaning we never have to interact we never have to interact with this lottery. We deploy to the blockchain and it just goes forever. That is the dream. And then additionally, it is provably random. What we don't want, we don't want a system where people can hack our randomness. People can pick the random winner.
00:08:16.454 - 00:08:37.314, Speaker A: People can manipulate our application. That is not what we want. That is going to defeat the purpose of making this decentralized raffle application. So first section of this is going to be writing the contracts. We're going to be writing the contracts. So we're going to write the contracts to do all this stuff. Awesome.
00:08:37.314 - 00:09:12.080, Speaker A: Then we're going to build the front end. Build the front end. And we got some things to think about. We want some buttons we're going to use next Js. We'll get to the front end when we get to it, but then we're going to deploy it in a decentralized context. We're going to build the front end and we're going to deploy it, and we're going to do all this in less than 3 hours. If we can do it in two, that'll be great.
00:09:12.080 - 00:09:37.700, Speaker A: And then I can go back to filming that master class on building. Makes sense. Everyone understand what we're doing? Any questions about what we're doing here? First time code along here. Better to just follow, watch, and re implement. If you can try to follow coding along with me, that is how you'll get the most out of this. So if you want to try follow coding along with me, that is how you'll get the best. We will be going kind of quick.
00:09:37.700 - 00:09:58.280, Speaker A: Chain link, VRFX, McDonald's. Yes. Guys are beginner. Looking for a team. If you're looking for a team, go talk to. I'm sorry, I don't know how to pronounce your name, but go talk to this person. Columbia, what's up? Shouldn't we build the front end first? Good question.
00:09:58.280 - 00:10:21.762, Speaker A: No, if we build the front end first, we're not going to be able to test the front end. Really? Because we have no contracts to test it against. We're not going to be able to have the Abis. We're not going to know exactly what our back end looks like. We're going to build our back end first. I mean, you could do the front end first, but I feel like it'll be a lot easier to do the back end first. Just got my first web3 junior job today.
00:10:21.762 - 00:10:36.338, Speaker A: Whoo. Congrats. Yes. Why not react for the front end? So next JS is react. Next JS is basically like, it's built on top of react. It's just more opinionated. So it is react.
00:10:36.338 - 00:11:05.854, Speaker A: It'll still be react up for the code along challenge. Okay, well, sounds like we're here. We're ready to go. Let's do this. Okay, so we're going to be making our contracts first. So what we're going to do, we're going to be writing our contracts first. So y'all already know we'll do yarn, add dev, hard hat, and we're going to add a whole lot of other packages in here, but we're going to start with hard hat.
00:11:05.854 - 00:11:31.066, Speaker A: Why? Because that's what we're doing here. Huge congrats, Lucas. Yes. Why not? Angular on the front end? Steven, fluid in the house. What's up, Steven? Steven, fluid used to be an angular developer advocate and is an absolute beast for the front end. We could 100% do this in angular, but I am much worse at angular. Sorry, Steven, and I don't know angular nearly as well.
00:11:31.066 - 00:12:03.442, Speaker A: We could do typescript here, and in fact, for people who are watching, I actually prefer typescript. I prefer coding in typescript, but I know there can be a little bit of a learning curve for people who don't know typescript. So we are going to use JavaScript in the master class that I'm building. All the code examples are coming with a JavaScript and a typescript example here. So Stephen, thank you for the question. I'm so sorry, it will not be angular. Is there any recommendation to not use angular and web3 projects? I almost never see it being used.
00:12:03.442 - 00:12:18.610, Speaker A: No, angular is great. Angular is awesome. You could totally use angular. Why not jquery? Because that's going to be my answer there. Why not foundry? So foundry. I actually really like foundry. Foundry.
00:12:18.610 - 00:12:48.482, Speaker A: They're working on their deploy functionality, and I think once they have that, life will be a lot easier for people using foundry. But I'll probably be doing more foundry stuff in the future. The reason we're using hard hat for this is just because it's just the JavaScript everything mentality, but we could really use hard hat, brownie, et cetera. How do you get the terminal to delete everything? Previously I hit Command K. It might be control K for where you are, but yeah, command K. Or you can type clear. They both do the same thing.
00:12:48.482 - 00:13:07.818, Speaker A: Anyways, so we have our minimal hardhat project here. Now we can run yarn hardhat. We're going to say create an empty hardhat config. Js boom, now we have empty hardhat config. I'm going to change this to 8.7 because that's the version of solidity I want to use. And let's get into it.
00:13:07.818 - 00:13:33.170, Speaker A: Let's create a new folder, contracts, new file. We'll call it raffle Sol. New file raffle Sol. And boom, this is going to be our new raffle. We're doing a little indexing. I'm using vs code like I said before, and this little indexing thing, it's going to be the hard hat solidity, hard hat extension, if you want to use that. It's really nice.
00:13:33.170 - 00:14:04.054, Speaker A: It's really nice. So let's get into our raffle Sol, and we're going to be here a little bit. So we'll do SPDX license identifier, MIT AGMA solidity 0.8.7 contract raffle. Boom. Pretty easy so far. About to get much more advanced.
00:14:04.054 - 00:14:22.654, Speaker A: Pretty easy so far. And if we run yarn hardhat compile, things should be compiling. For those of you who are following along with me, how are we doing so far? I know I'm going kind of quick. I'm coding kind of quick. How are we doing so far, people? We just got started. We just did some compilation. We got some boilerplate for our raffle contract down.
00:14:22.654 - 00:14:57.562, Speaker A: How are we doing so far? Why not? Php, y'all trolling me, y'all? Straight up just trolling me at this point. Svelte is actually really cool. Svelte is really cool. One of the other developer advocates at Chainlink Labs is really solid with svelte and has some examples. I'm just not less familiar with svelte. Sorry, not completely related, but is c sharp at any use at all for web3 and smart contract development? I haven't worked with this so much, but it might be hard hat still installing. Okay, so people are following along.
00:14:57.562 - 00:15:32.920, Speaker A: Hardhat is still installing. Oh, and I should tell you this, all the code is in, and I'm teasing this a little bit. All the code for this is going to be on this lesson. On this contract lottery. This lesson nine, smart contract lottery. So all the back end hardhead code is going to be here if you're looking to follow along. And then all the front end code is going to be in this smart contract lottery bit here.
00:15:32.920 - 00:15:47.450, Speaker A: Boom. Oh, and I should have showed you this too. Check this out, because here's what we're going to be doing. Got a little live demo for you. Boom. Centralized lottery right here. You can enter the raffle.
00:15:47.450 - 00:16:19.562, Speaker A: Metamask comes up saying, hey, you want to enter the raffle? I'm not actually going to do it, though, because actually, did I deploy this to Rinkbee? Let's see. I actually forget if I deploy it to Rinkbe. Let's go to rink B, switch accounts back to here. Who's connected? Disconnect, connect wallet. Metamask. Metamask pops up. I should have just opened with, huh? Okay, I did deploy it to Rinkbee.
00:16:19.562 - 00:16:53.694, Speaker A: And what we can do is it's on Rinkbee. We can enter our raffle. We'll go ahead and confirm and our transactions now going through for entering our raffle here and right now, there are eight players in it. It costs 0.1 E. And then when the Keepers have been set up, I actually set this up in a way where the keepers aren't set up, it'll programmatically pick a random winner every X amount of time, which will be however long. And that's it.
00:16:53.694 - 00:17:13.298, Speaker A: Right. And whenever a winner is picked, this will update and say, hey, the most previous winner is XYZ. And bada bing, bada boom. So, transaction still going through, but this is essentially what we're going to do, and it's going to be awesome. And we're going to deploy it on IPFs like you see here. So that's kind of the quick live demo of it. I will go directly get cloned.
00:17:13.298 - 00:17:32.240, Speaker A: You can do that, too. Gave up on coding along, enjoying it like a nice netflix show. Excellent. Okay, cool. But, yeah, you can get clone these if you want. Go from there. Yeah, they will probably change as time goes on because I'm still editing this massive course.
00:17:32.240 - 00:17:57.190, Speaker A: But, yeah, regular intervals means keepers, right? You got it. You got it. Autonomous means keepers. So cool. So we have our raffle here. Now, what do we want this raffle to do? Well, like we mentioned before, we're probably going to want people to be able to enter the raffle. So let's create a new function, function called enter raffle, and we'll make this a public function.
00:17:57.190 - 00:18:33.454, Speaker A: Well, external will probably be better. External function. It'll be a payable function, and we'll have people pay money to enter this raffle. The way that we do this is, we could say, require message value is greater than some entrance fee that we set. Right. So we're probably going to want to set this entrance fee right in the constructor. So we'll say constructor, entrance fee, and then we'll save this as a global storage variable.
00:18:33.454 - 00:18:58.214, Speaker A: So I'll say Un 256. And then normally I have it as private, but for this demo, we'll just make it public. I underscore entrance fee like this. And we'll say entrance fee equals I entrance fee. And then we'll stick this down here. Boom. Like that.
00:18:58.214 - 00:19:18.446, Speaker A: Now, question for you all. We'll make this immutable. Question for you all. What is this immutable? Keyword? Why is it mad at me? Control flow. Ends with initialize all mutable arrows. Oops, this is backwards law. Question for you all.
00:19:18.446 - 00:20:02.540, Speaker A: Why is this immutable? Why is our interest to be immutable? Why are we making this immutable? And what does immutable do? Any questions? Yes, it'll be for the 20 hours master class, which isn't out yet. Is teaching all those programs a separate skill from programming? Kind of. But actually, I think teaching programming makes me a better programmer. How much it took the junior developers, you know, to get their first job in blockchain. How much was the salary, Patrick? I think the fastest I saw somebody do it was they took my course and then six months later they got a job with trail of bits. I don't know what their salary was, but it was probably pretty good. So six months for junior developer straight out of college.
00:20:02.540 - 00:20:24.354, Speaker A: We don't want to change entrance fee for other users. Immutable cannot be changed because entrance fee will be I entrance fee not change. Similar constant. Yes. You all basically answered it. This is fantastic. So immutable variables can only be initialized one time inside the constructor, and they are way gas cheaper than those that do not.
00:20:24.354 - 00:21:01.520, Speaker A: So when we add this immutable keyword, we're saying, hey, we can initialize this one time in the constructor, but we can never change it. Entrance fee will never change. Right. So the entrance fee is always going to be exactly whatever it is this one time. And it's much cheaper for us to do this than not have the immutable keyword. And then we prepend our variables with I underscore to tell us as developers, hey, this is a cheap variable for us to work with. So we'll require message value is greater than or equal to the entrance fee, and we'll say otherwise we'll revert with not enough money sent.
00:21:01.520 - 00:21:44.382, Speaker A: Now, if you've been following along with some of our demos here, you know that require is kind of costly because we got to save this not enough money sent on chain. So instead, we're going to do some custom errors. We're going to say, if message value is less than, I underscore entrance fee, then we're going to revert with some custom error. For the top, we're going to say error raffle. Two underscores, send more to enter raffle. We're going to revert with this custom error that we just created. Why are we doing this? Because this is much more gas efficient than this is.
00:21:44.382 - 00:22:25.766, Speaker A: Custom errors cost less gas to store on chain than these big strings do. These two lines, does this block of three lines and this single line do nearly the exact same thing otherwise, yes. We're just making sure that people send enough value to enter our raffle here. Now, what else do we want to do? Well, we're probably going to want to keep track of raffle state. We want to see if we're open or calculating a winner. We don't want anybody to be able to enter our raffle while we're calculating a winner. So we're going to create some state for our raffle.
00:22:25.766 - 00:23:04.710, Speaker A: Let me zoom out a little bit. Hopefully this isn't too small for everybody. We're going to create a new type or a new enum, if you will. And this enum is just going to be a type of what the state of the lottery is in. So we're going to call it raffle state, and we'll have an open and a closed. Our raffle can be in an open state or actually, excuse me, a calq or a calculating state. It's either open for entrance, open for people to enter, or it's calculating a winner, and you can't enter while it's calculating.
00:23:04.710 - 00:23:47.234, Speaker A: So down here in our enter raffle, we'll say if the raffle is open, raffle is open. And we can keep track of the raffle being open by creating a new storage variable called Raffle State. So we'll call it we'll do type raffle state. So we'll say raffle state public s underscore raffle state. The reason we're doing s underscore is to tell us as developers, hey, this is a storage variable. It's very expensive to work with, and we're making this a storage variable because we are going to change it. Right.
00:23:47.234 - 00:24:17.150, Speaker A: The raffle is going to be open. It's going to be calculating. Then it's going to be open. Then it's going to be calculating. So we're going to say if the raffle state of our raffle is not equal to raffle state open, then what are we going to do? Then we're going to revert as well. We'll revert with a new error raffle called raffle not open. This, we'll add this custom error to the top.
00:24:17.150 - 00:24:53.418, Speaker A: Error raffle not open. Cool. So if they send us enough money and if the raffle is open, we'll say, great, you can enter our lovely raffle, and we'll place the player who called this enter raffle onto a list of players. So we need to create an array up at the top, and we're going to call it s players. So a storage array of address, payable. So payable addresses just in case they win. And then we'll make this public, too.
00:24:53.418 - 00:26:02.430, Speaker A: Again, we probably would make these private for gas saving reasons, but whatever public s underscore players, we have this array of players, and once they send us enough money, we'll add them to our list. We'll say s players push, and we'll add a payable message, sender and then one more thing we're going to want to do. Since we're changing state in kind of a dramatic way, we'll emit an event as well, and we'll just say we'll just create a new event. Raffle entered. Raffle enter. And then we'll just add the address index to player, grab this new event, and then we'll just do emit emit raffle enter of message sender. And this is our entire enter raffle function in all of its glory.
00:26:02.430 - 00:26:28.310, Speaker A: So any questions on that or anything that we've done so far, we are doing just okay on time. Doing just okay on time. Yes, immutable is similar to constant. Immutable is read only. Yes, immutable reads variable can but not be changed. Yes, immutable is cheap. No, constant is actually a little bit cheaper, but they're really close.
00:26:28.310 - 00:26:51.034, Speaker A: They're both really cheaper. They're both much cheaper than storage. So less gas because not get and set functions. Yes, because immutable cannot be changed. Because immutable variables cannot be changed, they are much cheaper. Is prepending a variable with I underscore new convention? That is a chainlink labs convention. So if you go through the chainlink labs code, you'll see that as a convention.
00:26:51.034 - 00:27:15.254, Speaker A: And I really like it because I am bad with gas. So it's really nice to just have, like a little, hey, by the way, this is pretty cheap to work with. This is not. Hey, Patrick, indicating is an expensive proposition on chain. How do you best handle it? That's, for example, the contract going through, looping all potential lottery winners. I'm not going to answer that now because of time, but that's a really good question. I'm sorry.
00:27:15.254 - 00:27:32.622, Speaker A: I wonder how skilled has to be to join this. All ranges of people are welcome to apply to chainly clubs. Chain the clouds is hiring. Yes, I'm using, I underscore because it's immutable. A bool isn't better than an enum for two states. So this is really interesting. Really interesting question.
00:27:32.622 - 00:28:06.674, Speaker A: So for code readability, this is much better. And actually, un 256 are even better gas wise than booleans. We could totally use a Boolean here, but maybe we want to add more states later. And I wanted to show off using an enum. That's really it. Why raffle state with capital R, another with lowercase R, another with lowercase R, other what? Other what? I think enum of two states is just redundant. Yeah, maybe, but I wanted to show off enum.
00:28:06.674 - 00:28:26.794, Speaker A: You're probably right. What do you think about this roadmap for someone to learn JavaScript? Step one, learn HTML. Step two, learn. I mean, that's good. Why is raffle and raffle. What is raffle underscore in the reverts? So these are going to be our custom errors. So if a transaction errors because they didn't send enough value, they'll get an error code that says raffle.
00:28:26.794 - 00:28:58.780, Speaker A: Send more to enter raffle, and if the raffle is not open, they'll get an error code that says this. So that's how we tell people that, hey, there's an issue with the raffle contract. That's why we prepend it with raffle, and then we say exactly what the error is. Why is address payable? Because if they win the lottery, we want to be able to send them money. Now, it's probably kind of a waste of gas for us to wrap them as payable here, but actually, I don't remember if payable is cheaper or not. Payable may actually be cheaper. So this might be better, but I forget, I'd have to double check.
00:28:58.780 - 00:29:39.160, Speaker A: Should we do revert at the end to prevent reentrancy? Should we do revert at the end? No, we're not calling any external contracts here, so we don't really need to worry about a reentrancy here. Why is address payable? I explained that enum function means it's just a type. Any particular reason you don't want to add a human readable message to the error? So our revert here is pretty human readable. Right? Send more to enter raffle. The reason we don't want to do this is because it's very gas expensive. Can we use constant instead of immutable? Yes, but you couldn't set it in the constructor. Then you'd have to set it up here.
00:29:39.160 - 00:30:05.536, Speaker A: Yeah, I knew how to use noom thanks to being here. Excellent. You wrote s underscore raffle state. Oh, because raffle state is a type. I actually forget if this should be a capital r or lowcase r, I'd have to double check unraffle state. Okay, I see what you're saying. So this is raffle state, and this is s underscore raffle state.
00:30:05.536 - 00:30:22.820, Speaker A: So if I do this, these are technically two different variables, right? Solidity is case sensitive. Can we add custom message for custom? Error like that are required? Not yet. I'm assuming at some point we'll be able to. Okay, cool. Let's keep going. Answer all the questions. Okay, so we can enter the raffle yay.
00:30:22.820 - 00:31:02.684, Speaker A: So now what do we need to do? Well, we need to be able to have a random winner picked. A random winner selected. So in order for us to select a random winner, we're going to need to think about two things. One, we want this done automatically. Then number two, we want a real random winner. Let's focus on this automatically part. Right? We want some decentralized process to automatically say, yes, it's time to trigger for a winner.
00:31:02.684 - 00:31:28.632, Speaker A: But before I go on, hopefully everybody's doing well. Hopefully everybody's enjoying so far. We got a lot of code to go through, but hopefully this all makes sense. Keep asking questions, keep saying the comment. Give yourself a big pat on the back for making this far. You're all doing excellent and I'm really excited to see what you all learn from this workshop. And if anybody leaves, or if anybody says, hey, I got to go, QR code in the top right, left.
00:31:28.632 - 00:31:46.770, Speaker A: I'm not sure where it is, but QR code up here, please take that. Before you leave, let us know what you thought of the session. Let us know if you liked it, if you didn't like it. It helps us figure out which one of these to do. So that being said, let's jump back into the code here. So we want this done automatically. We want people to pick.
00:31:46.770 - 00:32:14.968, Speaker A: Let me get rid of the. I'm going to leave the QR code up for a hot minute. We want a decentralized process to pick the winners for us. So some of you already guessed it, but if we go to docs chain link, we already have that can do that. We'll go to EVM chains. We have automate contracts aka the chainlink keepers here. So if you haven't worked with keepers before, I definitely recommend you checking it out.
00:32:14.968 - 00:33:10.860, Speaker A: It is a way for us to make any event trigger some transaction on the blockchain. Any event triggers some transaction on the blockchain. And this is what we're going to be working with here. So to work with Chainlink keepers, we need to define two functions. We need to define a check upkeep and a perform upkeep function. It's these two functions that say, hey, here's when we want you to do something and then here's the something we want you to do. So we'll create a function, check up, keep, checkup keep and what do we want this function to do? Well, we're going to want it to be true after some time interval, right? We only want our lottery to run after some time interval.
00:33:10.860 - 00:34:13.970, Speaker A: We want the lottery to be open, we're checking, when should we pick a winner? Well, the time interval should be gone, the lottery should be open, the contract has ETH, and then of course implicitly keepers has link, but that's kind of implicit, so we don't really have to worry about that. So let's create our checkup function to look for these three things. If these things are true, right? If the time interval is passed, the lottery is open, the contract has ETH, then we say, hey, it's time to pick a random winner. Now, checkupkeep comes with now the checkup keep function needs to come with a bytes memory check data. However, we're not going to use the check data bit, so we can actually just comment it out like this. So our function needs this check data thing because the chain link nodes are expecting the signature to have this bytes memory bit, but we're not going to do it. So we can just comment it out like that.
00:34:13.970 - 00:34:55.950, Speaker A: And then we'll make this public view, we'll make it a view function because we don't need anything to, we don't need anything to actually call this transaction. So check upkeep, we're going to make it a view function. All right, cool. Now also going to return, it's going to return two things. We're going to turn a boolean called upkeep needed, whether or not you need the upkeep, and then it's going to turn, which is, this is what we're going to focus on. If this is true, we're saying, hey, time to pick a random winner. And then we're also going to do a bytes memory, perform data which we're not going to use.
00:34:55.950 - 00:35:23.472, Speaker A: This is kind of like an optional flag for more functionality. We're not going to use it, so we're just going to kind of comment it out like that. Cool. So in our function here, first thing let's see, is the lottery open? We'll say bull is open equals rafflestate open equals equals s underscore raffle state. Cool. We're checking if it open. Let's see if enough time has passed.
00:35:23.472 - 00:36:07.280, Speaker A: After some time interval has passed. We'll say bull time passed equals this is where we need to keep track of time. So we need to tell our lottery how often it should update, how often it should update. So up in our constructor, guess what? We'll create another parameter in here. We'll do a uint 256, uint 256 interval, and then we'll save this to another immutable variable. We'll say un to 256 public immutable I underscore interval. And then we'll say I interval equals interval.
00:36:07.280 - 00:36:43.984, Speaker A: And this interval is going to be the time in seconds between lottery runs. Maybe we want this to run every day, every year, every month, every second, whatever this is. Right? And we're also, because of that, we're going to need to keep track of the timestamp. When was the last time the lottery ran? So we're going to do that. We're going to create another variable called S last timestamp. And this is going to be a 256. I'm just going to make it public for now.
00:36:43.984 - 00:37:25.468, Speaker A: S underscore last timestamp. Right. In our constructor we're going to say s timestamp equals block timestamp. We have this timestamp bit that we're keeping track of. So we're going to say the time passed is going to equal the time passed is going to be true if the current block timestamp minus the s underscore last timestamp is greater than the I underscore interval. So this is basically saying if enough time has passed, our time passed variable is going to be true. Great.
00:37:25.468 - 00:38:08.676, Speaker A: What is next? Okay, we need to check the contract has some ETH and there are some players. So we can say bool has balance equals address. This balance is greater than zero. Boom. Now we can say upkeep needed equals time passed and is open and has balance. And then to return both of these, we'll say return upkeep needed and then perform data we're not using. So we're just going to return it as blank.
00:38:08.676 - 00:38:21.284, Speaker A: So we'll say zero x zero. So some blank return data and boom. Now our checkup keep function is done. So we have a way to check our contract. I'm going to remove the QR code. For now. We have a way to check our lottery.
00:38:21.284 - 00:38:54.250, Speaker A: Hey, is it time to trigger a new winner? And this is exactly how we're going to do that. Cool. Any questions on this? Can you suggest a place that lists fee hierarchy for different features like specific opcodes or like specific. I'm not sure what you mean. I really don't understand. What's the type bytes? Can you explain please? Yeah, bytes is just going to be like some binary bytes data. This is a really good question for this demo.
00:38:54.250 - 00:39:21.010, Speaker A: Just ignore it for now because we're not going to be using it for this demo. So that's to do some more custom advanced stuff that we're not going to be doing here. Y zero x zero, because since our checkupkeep needs to return an upkeep needed and a bytes memory perform data. So we're saying, okay, great, return the upkeep needed because we actually care about that. We're not using the perform data, but our function still returns some bytes. So we're saying, okay, fine, just return some empty bytes. We don't care.
00:39:21.010 - 00:39:54.072, Speaker A: Could you zoom out so we can see the whole code? Yes, zoom way out. We've already got a lot of code here, so it's going to be really tiny. Hard to keep up with your super speed. If you can't keep up with my super speed, that is okay, because where did I put the code? Sn nine. All of the code is right here. Again, I'll post it in the chat. Can't keep up with my super speed.
00:39:54.072 - 00:40:10.224, Speaker A: Just copy paste from there. There you go. What unit is timestamp? Timestamp is a unit, 256. Let me zoom way back in. That's too far. Okay. All right, great.
00:40:10.224 - 00:40:29.316, Speaker A: So check upkeep. Cool. So now we have a way to say, okay, is it time for the lottery to trigger a new winner? Upkeep needed is going to return. True. If the lottery is open enough, time has passed and it has a balance, and it'll pick a new winner. Okay. And we probably actually, we probably should also say Bull has players.
00:40:29.316 - 00:40:58.450, Speaker A: We'll just say s underscore players length greater than zero. So we just also want to make sure that there is at least one player in this lottery, and then we'll also just do and has players. So now it's done. So we want to make sure players are in. This has some ETH, et cetera. Cool. Now we want to say, okay, now that it's time, now that we know when we should trigger a new winner, we'll do function.
00:40:58.450 - 00:41:24.712, Speaker A: Perform upkeep. Perform upkeep. And this is us saying, okay, once this returns true, once it's time to trigger a new winner. How do we do that? Well, we define how to do that in perform upkeep. Now, perform upkeep is going to take a bytes call data called perform data. Again, this is some advanced stuff, so we're not going to use it. So you can kind of just comment it out like this.
00:41:24.712 - 00:41:45.388, Speaker A: Okay. And this is going to be an external function and it's going to not return anything. Now, if you're following along, can I copy this? No. Okay. I can't copy this. That's annoying. And if you're following along with my git repo, I'm using override in here, too.
00:41:45.388 - 00:42:22.424, Speaker A: The reason I'm using override in the GitHub repo is because we import some stuff to override, but in this I'm not importing it so we don't have to. So that's why I'm not doing override. But yeah, anyways, so we're doing this perform upkeep thing. So we're saying, okay, cool, it's time to trigger the winner. How do we actually trigger the winner? Well, let's figure that out. So first we want to just make sure that it really is time to trigger the winner, right? So we'll say bool upkeep needed comma and this is how we get both return types here. But we don't care about the second one.
00:42:22.424 - 00:42:58.884, Speaker A: So we just put a comma and then leave it blank, saying we only care about this one. So bool upkeep needed equals check upkeep. We'll pass it kind of this blank thing here because again, we're not using the input parameter bytes memory. So we're saying check upkeep, and then we want to make sure that it is indeed time to pick a new winner. So we'll say if not upkeep needed, then we're going to revert. Raffle, upkeep not needed. I'm just going to leave this blank for now.
00:42:58.884 - 00:43:28.064, Speaker A: I'm not going to put any parameters in here, but in the GitHub repo, I am using parameters. So we're just going to say error apple, upkeep not needed. Okay, cool. So if upkeep not needed, revert. We only want this to run if upkeep needed is true. Now what we're going to do is we're going to change the raffle state to raffle state. Calculating now it's saying, okay, cool.
00:43:28.064 - 00:44:00.660, Speaker A: I'm going to go pick the random winner. Nobody else can enter the raffle while I'm figuring out who the random winner is. And the way we're going to figure out who the random winner is is using chainlink vrf. So the documentation here, I'll put a link in the description. Chainlink vrf. We're going to get a random number for our random winner here. And in order for us to get a random winner, we do need to do this in two transactions, right? We need to call, request, random words to get a random winner.
00:44:00.660 - 00:44:21.410, Speaker A: And then in a second transaction, we'll get that random winner. Excuse me, in a second transaction, we'll get the random number. So we're going to do this request random words thing to get this random winner. So that's what we're going to follow along with here. The chain link keepers is going to be the one to do that. Now, there's a whole bunch of variables we need to add in here to get that set up. So let's go ahead and get to it.
00:44:21.410 - 00:45:25.668, Speaker A: So the first thing we're going to need is we're going to need to call get request random words on this coordinator contract address. So we're going to need to add a VRF coordinator contract address because that's the contract that has this request random words function that we're going to use. Now, we're about to go with a lot of variables here, so stick with me. Absolutely, stick with me. So back up at the top in our constructor, we're going to need to keep track of this VRF coordinator and we're going to need to give it the functions so we can call request random words. But in order for us to do that way at the top, we're going to have to import at chainlinkcontractsrcv zero point eightintervacesvrfcordinatorv twointerface sol. And this is going to be what we're going to use to call that request random words.
00:45:25.668 - 00:46:12.000, Speaker A: An interface plus an address equals a contract. So we have the interface. Where do we get the address? Well, we'll get that from the constructor. We'll say address DRF coordinator v two. Then we'll create a global variable called VRF coordinator v two interface. VRF coordinator v two, interface public immutable, I underscore VRF coordinator and all my stuff modified. We're going to say IVRF coordinator equals VRF coordinator v two interface of VRF coordinator v two.
00:46:12.000 - 00:46:39.622, Speaker A: Great. Now that we have the coordinator interface, what else do we need? Well, we're going to need a key hash, a subscription ID, request confirmations, callback, cast limit, and a number of words. So we're going to create most of those in our constructor. So the first thing that we're going to need is our key hash. So we're going to do a little comma. It bytes 32, the key hash. I'm going to call it Gas lane, though.
00:46:39.622 - 00:47:11.460, Speaker A: Why am I calling it Gas lane? Because that's what this bytes key hash represents. It represents the gas lane. How much gas can we spend to call this random number? So we need a gas lane. So we'll do bytes 32 public, I underscore gaslane. Then we'll say I Gaslane equals gaslane. What's next? Subscription id. Okay, we'll do public.
00:47:11.460 - 00:47:56.814, Speaker A: Excuse me, un what is description id? Un 64 public I underscore subscription id. We'll add it in here. We'll do uint 64 subscription id without the I. We'll say I underscore subscription id eQuals subscription id like that. What else do we need? Request confirmations. I'm just going to make this a constant, constant variable. I'm going to say Un 16 public constant request confirmations equals three.
00:47:56.814 - 00:48:22.630, Speaker A: We're just going to hard code it to three. Oops. We're just going to hard code it to three. And what else do we need? Callback gas limit. This is going to be a constructor parameter. We will say Un 32 callback gas limit and we'll create another immutable variable. Callback gas limit equals callback gas limit.
00:48:22.630 - 00:48:58.494, Speaker A: This is a UN 32 Un 32 public I callback gas limit and then what else? We need number of words. I'm going to hard code that as well. Un 32 public constant num words and I'm just going to say equals one. Okay, we got all the variables here. Did I miss any? No, we got them all for the requesting here. That is all the variables that we need. So now that we have that contract, now that we have all the variables that we need to call it, what we can do is way down in our perform upkeep.
00:48:58.494 - 00:49:43.394, Speaker A: Now that we're calculating, we can make that request to say, hey, we would like a random number plea please. So we're going to say UN 256 request Id. And it returns a request ID equals IVRF coordinator request random words. And we're going to pass it. All those parameters we just made. So we're going to pass the gas lane subscription Id request confirmations, callback gas limit and the num words. Okay, and let me do run a hardhat compile just to make sure I didn't mess anything up.
00:49:43.394 - 00:50:03.030, Speaker A: Yarn hardhat compile. Believe I did mess something up. Library at chainlink contracts is not here. So we need to add this, of course. So we'll do yarn add dev at chainlink contracts like so. Cool. Now let's try to, oops.
00:50:03.030 - 00:50:29.600, Speaker A: Now we'll try to compile and comma in parameter list. This is, oh, I don't need a comma here. Let's try again. And we're good. It's compiling well. Any questions so far? I think I missed something. Where does contract check if upkeep is needed? Yes.
00:50:29.600 - 00:50:59.594, Speaker A: So we have our checkupkeep function and then in our perform upkeep. Before anybody can call perform upkeep, we call checkup keep and perform upkeep. And that's why checkup keep is public instead of external. We call checkupkeep and we just say, hey, make sure upkeep is there. In which blockchain can we use? Vrf coordinator, great question. If you go to randomness contract addresses, everything is on here. Right now it's rink B and B and B.
00:50:59.594 - 00:51:41.846, Speaker A: But coming to a blockchain near you, what does request confirmations do? Yes, good question. Let's say we want three blocks to be appended to the block where we get a random number. So it just guarantees how many blocks need to be on top of the block. We got the random number for it to count. Can you share the sole file you're working on? I'm just going to keep this up. Actually, that's yes. So we're working on this.
00:51:41.846 - 00:52:10.820, Speaker A: It's in contracts. Raffle Sol, if you want to follow along here. Okay, cool. And now we're just going to emit an event called requested Raffle Winner. So we're going to create a new event. Event requested raffle winner. And this event is just going to be a, you went to 256, it indexed ID.
00:52:10.820 - 00:52:44.940, Speaker A: And down here we're just going to do emitful winner request ID. This is a little bit redundant because the VRF coordinator also emits an event. But we're just going to do it to make it easier to learn those VRF functions. Why are they un 64 32 and not 256 gas savings. Because they don't need to be massive. So it's just saving a little bit of gas if we make them a little bit smaller. Great question.
00:52:44.940 - 00:53:31.098, Speaker A: Okay, almost done here. Now that we have a way to actually request a random number, how do we actually get tell our contract who to pick for a random winner. So how do we do that? Well, you got to create a new function. We're going to create a function called faux fill random words. And this is going to take a UN 256 request ID and a UN 256 array memory. Random words. We're not going to use request ID, so we're going to comment request ID out, similar to what we've been doing, but we are going to do random words.
00:53:31.098 - 00:53:52.020, Speaker A: So random words is an array of random numbers. Our num words is just saying one. Right. We're defining it as one. So we're saying we're only going to get one random number to pick one random lottery winner or raffle winner. So let's go ahead and do this. Now, this is going to be an internal override function.
00:53:52.020 - 00:54:45.460, Speaker A: The reason this is internal override is because the chainlink VRF coordinator contract needs to validate that these random words are actually random first. So the chainlink node is actually going to respond to this VRF coordinator contract. And that contract is going to call our fulfill random words function. Now in order for us to implement that, we actually have to make our contract VRF consumer baseable. We basically have to make it compatible with this VRF coordinator. To do that, we do import at chainlinkcontractsrcv 0.8 vrf consumerbasev two Sol and we just inherit all the functions of this vRF consumer base v two by saying raffle is vrf consumer base v two.
00:54:45.460 - 00:55:31.250, Speaker A: Ah cool. So let's finish our fulfill random words, fulfill random words here. So internal override. Now we're going to pick our random winner by saying un 256 index of winner is going to equal random words of zero modded by players players length. We're going to do this module function. Basically if our random word is 10 billion, we're going to mod it by if we have eight players, eight. And we'll get a number between zero and seven, that's how the mod function works.
00:55:31.250 - 00:56:07.338, Speaker A: We'll say address payable recent winner equals s underscore players index of winner. Boom. And that's how we get our winner. Payable recent winner. And that's how we get our recent winner. Now we're going to reset that players array because now that we have a winner, so we're going to say s underscore players equals new address payable payable array of size zero. So we're going to reset our players array.
00:56:07.338 - 00:57:01.280, Speaker A: We're going to reset the raffle state equals Rafflestate open. We're going to reset the timestamp to block timestamp. And then finally we're going to pay our recent winner. So we're going to say to pay them, we're going to say bool success AmA blank equals recent winner call. We're going to pass value of address this balance and we're going to do a little blank string like there. And then we're just going to say if not success vert raffle underscore transfer failed. And we'll make this a custom error at the top.
00:57:01.280 - 00:57:47.742, Speaker A: Error raffle transfer failed. And then we're going to emit an event here. Don't worry, I'm going to explain this in a second. MIT Winner picked and we'll just pass it recent winner. And up top we'll do event winner picked address indexed winner like that. And then also let's just create a storage variable for the most recent winner. So we'll do say address public, s underscore recent winner just so that we can see who most recently won.
00:57:47.742 - 00:58:40.960, Speaker A: And then down here we'll say s recent winner equals recent winner. Boom, and we're done here. Just about raffle should be marked as abstract. What did I mess up? Function fulfill random words, kernel override, performal keep oh, okay. And now that we're inheriting VRF consumer base, we need to, in our constructor here, we need to add the VRF coordinator, the VRF consumer base constructor, which need the VRF coordinator, v two address, boom, like that. Now it's not abstract anymore. Okay, so let me explain this, and then we're going to take a quick bathroom break because I really have to go.
00:58:40.960 - 00:59:17.820, Speaker A: So what we're doing here, this is actually the best way to send money in your contract. You've probably seen transfer, you've probably seen send before, but doing call is actually the best way to do it. So you can actually call any function in any contract by just calling or on any address by just doing this call thing right. And then in these little brackets we pass kind of the transaction data with that transaction. So we can specify the value in our transaction like this. Because any transaction you can send ETH or polygon or whatever layer one blockchain you can send value with. But the function that we're calling is nothing.
00:59:17.820 - 00:59:57.414, Speaker A: So we're calling no function, but we're sending as value the address of the balance of this address, which is going to be the fees from all the lottery entrance. And then if that transfer fails, we're just going to revert the whole transaction and then we're going to omit a winner picked. And let me actually just compile yarn, hard hats compile zah. Things are looking good. Not even any warnings spicy. Is it necessary to add dev while compiling? I tried it without Dev and it works. Just want to know if there's any implication from that.
00:59:57.414 - 01:00:30.450, Speaker A: No, not really. So in your package adjacent, if you add Dev, it'll just say dev dependencies instead of dependencies. This is an indicator to tell people, hey, these are the dependencies that the developers need, but not your full stack application. We're not really doing a full stack application. So everything's going to be dev dependencies basically. Don't worry about that for now. Why the square brackets? Why the square brackets? Where here or here? To access an element of an array, we need to use square brackets.
01:00:30.450 - 01:01:00.694, Speaker A: Why do you place your custom errors outside of the contract? I actually forget why I do that. I learned once that that's where they go. I forget. I'll actually have to double check. That's a good question. So the entry fees are essentially stored in an escrow? Yes, this contract is a decentralized escrow for the entry fee, and it's a decentralized winner picker. So yes, they are being stored in this raffle contract.
01:01:00.694 - 01:01:38.150, Speaker A: When we deploy it, what does call data do? That's a longer conversation. Don't worry about it for now. There are some good I think sliddy by example, slidy by example probably has some good solidity by example has some good examples here. Posting of the chat Matt's mind has been blown crazy, right? Yes. This is why blockchain is so freaking insane. We have a decentralized escrow here for a provably verifiably decentralized lottery. Right? And this is why this is so powerful and can fix that McDonald's problem.
01:01:38.150 - 01:02:11.902, Speaker A: And let me switch back to me here, because now we have a place where all the code is saying who's going to win, when they're going to win, and we don't have to rely on some centralized party saying oh, we promise, we pinky swear that we're going to pick a random winner. We can see transparently all the code in a decentralized escrow where all the lottery fees are being held. Excellent point. This contract is winner take all, right? Yes. This contract is winner take all. The way that we're coding, this winner take all eliminates the need for bots. Yes.
01:02:11.902 - 01:02:58.894, Speaker A: So the chain link keepers and the chainlink VRF are the only services that are picking the winners, but they're also doing this in a decentralized context. So everything is decentralized end end to, which is phenomenal. We have a provably random number, a decentralized automation going on. It's fantastic. Now, the only thing I will say here is somebody said, hey, this is winner tick all. There currently are no fees. Somebody would need to pay the chain link requests to run this lottery if we really wanted to make it truly permanent forever, right? So if we want to make this autonomous forever, we would add some fee mechanism where maybe we take maybe 1% of entries or 0.5%
01:02:58.894 - 01:03:25.240, Speaker A: of entries and then auto swap them for link on some exchange to pay the node operators. But we're not going to do that because that's a lot more coding. But essentially this can still do everything. Imagine state lotteries replace theirs with this, even though they never. Right, well, because they wouldn't be able to charge their insane fees for lotteries. Right. This would be a fair lottery and they don't want that.
01:03:25.240 - 01:03:54.690, Speaker A: I mean, the good thing about lotteries is that's how a lot of governments make money. So make some extra cash. But yeah, this would be a much more transparent way because there's been tons of lottery fraud even in the government where some government people who have access to the lottery say, oh well, the winner is me again. Whoops, I don't know how that happened. And essentially are stealing money from anybody who actually fairly enters the lottery, which is completely unfair. So this would be an amazing replacement. Yes.
01:03:54.690 - 01:04:08.998, Speaker A: It is also extremely simple. Yes. For instance, you can now emit most opens up defender uses as well. Yes, exactly. Yes. So this is a decentralized end to end implementation of a lottery. So we are halfway through this.
01:04:08.998 - 01:04:35.274, Speaker A: This is the contract. We are done with the contracts. We will have to write a deploy function. And ideally we would do this on a local blockchain first, but we're just going to wing it because we only have an hour and a half left. So we're just going to build the front end, deploy it to rinkby and pray it works. So with that being said, let's take ten minutes. Let's come back here in ten minutes because I have to go to the bathroom, go get a coffee, go take a break, ask some questions in the chat.
01:04:35.274 - 01:04:54.054, Speaker A: When I come back, I'll answer the questions. Then we're going to hop into the front end. We got an hour and a half left to do this. I promised you all we would build and deploy a full blockchain application. So we will be right back. So let's take ten minutes. So I will say 40 05:00 p.m..
01:04:54.054 - 01:15:08.824, Speaker A: EDT. We will be back. What's that in the chat? And we will be right back. Everyone take a quick break. We're about to come back. I hope you all enjoyed your ten minute break. Hope everyone had a good time.
01:15:08.824 - 01:15:30.592, Speaker A: Hope everyone got some coffee, maybe got some water, maybe went to the bathroom. Whatever you did, I hope you had a good time doing it. Hope you had fun. So we're going to get started in just 1 minute. I will answer some questions here. In the video, Patrick used public immutable, but in the GitHub it's all private immutable. Why is that? Gas savings and API, basically.
01:15:30.592 - 01:16:01.464, Speaker A: So when we're actually coding and we're using these variables. It's much cheaper to use private variables than public variables. However, we still want some function to expose to the world to kind of read some variables. So normally you do want to default to private variables and then create some type of getter and that way people don't have to see kind of the ugly s underscore API that's used. Great question. Save the time writing the accessors for the variables. I'm multitasking.
01:16:01.464 - 01:16:16.640, Speaker A: Okay, you know what? Great, good for you. I clicked show before I read it. Good for you. But okay, let's get back into it. Let's do this. We have our contracts done. Huzzah.
01:16:16.640 - 01:16:43.912, Speaker A: Now we don't have a lot of time left. We have an hour and a half left to do all this stuff. But before we can even do that, we need to deploy this. We need to deploy this contract. Now here is something I want to talk about real quick. So huge disclaimer. I'm looking at the clock right now and I would love to deploy this locally and test it locally and do all that stuff, but we're not going to have time.
01:16:43.912 - 01:17:10.770, Speaker A: So I'm just going to deploy this directly to a testnet. However, I must say for you all, never directly deploy to a testnet. Always test locally first. Always test locally first. Always write tests. Always do everything locally first. The reason that we're going to do it directly to a test net is because quite frankly we don't have enough time.
01:17:10.770 - 01:17:34.804, Speaker A: So I would say probably like another hour. We could do all the local stuff and we could write a test. So maybe really the marketing for this should have been like, hey, build a full hackathon project in 4 hours, but we're cutting off some of the local development here. Don't do this. Don't just yolo into a testnet. Don't just yolo into mainnet, write tests, do local development. I promise you it'll save you a ton of headache.
01:17:34.804 - 01:17:55.276, Speaker A: Right. The only reason that it's cool for us to do it here is because I've already written all this code and I've tested it locally and I've done all this stuff. So this is a good pathway. Local testnet, mainnet fork, mainet. That's a great pathway. That's great. Or I actually would do Mainnet fork before testnet.
01:17:55.276 - 01:18:27.770, Speaker A: But isn't testnet the same as locally test? No, it's not. When you throw your code on a testnet, everything's going to take much, much longer for you to run tests for much, much longer. You have to wait for those transactions to go through, et cetera. And I missed a question here. Patrick, have you done a video on using Chainlink sports data providers? I have not. So how do we know which un we have to use to save gas feeds? You can check the documentation, you can run gas estimators. There's a lot of stuff that you can do.
01:18:27.770 - 01:18:51.644, Speaker A: Actually, now that I'm thinking about it, maybe, I think actually un 256 is cheaper gas. So why is it you at 16 and Un 64? Maybe to make sure that the numbers aren't too big. Yeah, now that I think about, I think un 256 is cheaper. Sorry about that. Anyway, it doesn't matter. Let's move on. So we want to deploy this contract.
01:18:51.644 - 01:19:50.400, Speaker A: So to do that we're going to create a new folder, a new deploy folder, and we're going to import a package called hardhat deploy. So we're going to import it by running yarn add Dev Hardhat deploy like that. And we're also going to do some weird stuff if we go to hardhat deploy deploy hardhead deploy. Also we also want to do this weird thing where we're going to wrap hardhead ethers with hardhead deploy ethers. So we're going to copy this, I'm going to paste it, but instead NPM install. I'm going to do yarn add dev this, run that. For those of you who are following along, I'll post that in the chat.
01:19:50.400 - 01:20:13.820, Speaker A: Or you can just go to the package JSon in the code base. So that has been added. That is great. Do we need to add anything else? I think we're good. I think we're good. Okay, cool. Actually I'm going to add two more things because it's going to drive me crazy otherwise.
01:20:13.820 - 01:20:46.696, Speaker A: I'm going to add prettier plugin and prettier. These are just formatting packages. I will just lose my mind if I have to deal with like regular JavaScript formatting. Okay, so cool. So we're just going to add those and great, we're happy. Now that we've added those in our hard hat config, we have to add all that stuff in here. So we're going to have to do fire hard hat deploy fire EMV config and we're going to add that too.
01:20:46.696 - 01:21:25.904, Speaker A: We'll do yarn add envier and we'll do hardhat waffle even though we're not going to use waffle. So waffle. So let me add this package too. And we're adding all these so we can write our deploy scripts. Adding all these so we can write our deploy scripts. Now we're going to be deploying to rink B. So in order for us to deploy to rink B, we're going to go ahead and we're going to make a networks section or module exports.
01:21:25.904 - 01:21:59.464, Speaker A: So we'll do networks and we'll add in here, rinkabee. And to work with Rink B, we're going to need a URL which we're going to grab from our environment variables. Process env rinky b Rpc URL. We're going to private key. So accounts is going to be process env, private key. Then we're going to need chain ID, which is going to be four. And we're going to say save deployments.
01:21:59.464 - 01:22:32.504, Speaker A: It's going to be true. Now, I already have my burner environment variables set up, so I don't need to set them. If you're following along and you're unfamiliar with environment variables, there are some good demos to show you that. But for now, if you're just trying to follow along, go fast. Just put like your alchemy IO rinkby in here and your private key in here. Make sure that your private key, whenever you're doing any of this stuff and you're testing, make sure your private key is a burner private key. Do not use a private key associated with account that has any real money in it.
01:22:32.504 - 01:22:54.304, Speaker A: You will accidentally screw something up and you will get rugged and you will lose all your money. So always use a metamask that doesn't have any money in it. And if you need some testnet money, you can come over to faucets, chain link, grab some testnet money. So that's where you can go there. Cool. Anyways, so we have all that set up stuff looks good there. We also need one more bit.
01:22:54.304 - 01:23:19.032, Speaker A: We need this thing called named accounts. We're going to say deployer fault zero. This just means that whenever we use an account at index zero, it's going to be called deployer. And that's really it. Do I need anything else for this? I could do ether scan, but we're not going to do that. Okay, cool. That's all we need.
01:23:19.032 - 01:24:21.260, Speaker A: Great. So now we'll write our deploy script. We'll do a new file, one deploy raffle sol Js, and we'll deploy this raffle. Now, again, I'm going to do a little bit of hard coding in here. So if you're following along, the GitHub repo has much less hard coding but we're going to do a lot of hard coding now to create a deploy script, we'll do module exports equals an async function which is going to take get named accounts and deployments as input parameters. Little arrow function, we'll say const deploy log equals deployments. We'll say const deployer equals await getnamed accounts and get named accounts deployer.
01:24:21.260 - 01:24:52.020, Speaker A: And again, we went through this in some of our intros, so I'm not going to explain what these are doing here. And then that's pretty much it. Okay, cool. To deploy our contract, we're going to run all the arguments first. So we'll say const args equals and we'll make an array. If we go back to our raffle Sol, what does it need for arguments? Okay, it needs an entrance fee. Needs an entrance fee for the first bit.
01:24:52.020 - 01:25:34.640, Speaker A: So we'll create a new entrance fee. We'll say const entrance fee equals what we'll do ethers utils entrance fee entrance fee where do I have my entrance fee set? Ethers I utils I get parse ether, we'll say 0.1 but we're making it 0.1. Ethers for entrance fee. Cool. Entrance fee. What's next? Interval.
01:25:34.640 - 01:26:00.876, Speaker A: We'll say every five minutes, right? So we'll say 300, 300 seconds. And we'll do this as a string because JavaScript is weird. So every 300 seconds, what else? Oh, actually, entrance fee interval, the VRF coordinator V two. We're just going to grab that address from docs. Chain the link, contract addresses. Rink B. Testnet VF coordinator boom, grab this address.
01:26:00.876 - 01:26:14.064, Speaker A: We're just going to hard code this. So boom, VF coordinator address. What's next? Gaslane. Okay, Gaslane. Boom. That's the gas lane. Stick that in here.
01:26:14.064 - 01:26:37.296, Speaker A: Okay, great. What's next? Subscription id. Okay, we got to go to VRF chain link and we got to create a new subscription id. So I've already created a subscription Id, so I'm just going to leave it. I'm going to leave it like this. It's already funded with some link and stuff. But if you want to create your own subscription, you just connect to Rinkby and you hit create subscription and you'll get my active subscriptions.
01:26:37.296 - 01:27:05.890, Speaker A: You'll get a little subscription id like this. Actually, let's use this one because it has a ton of link in it. Yeah, we'll use this one. So we'll say subscription id is going to be 1002 and the subscription id is for working with the chain link VRF. You need a subscription for it. And then we also need a callback gas limit, which for us will do, like 500,000 gas. Okay.
01:27:05.890 - 01:27:44.300, Speaker A: Entrance fee interval VRF coordinator gas lane subscription Id callback gas limit. So we have all these arguments here, and now we can just deploy it by doing const. Raffle equals await. Employ raffle, comma, say, from player, comma, args. Args log. True. And then we'll also do weight confirmations.
01:27:44.300 - 01:27:59.004, Speaker A: You know what? We should just verify this as well. Now. Let's not verify. All right, cool. We can verify later. So, great. We have this deploy piece here, and I'm praying that I actually just did everything right and that we're going to do this correctly on the first shot.
01:27:59.004 - 01:28:24.680, Speaker A: So I'm going to run yarn hard hat deploy network rinkabee. And fingers crossed. Okay. Already have an issue in our config. Rink EB RPC URL. 90% of my issues are just spelling. Stuff's compiled and we're deploying raffle to the blockchain.
01:28:24.680 - 01:28:52.956, Speaker A: So we're going to deploy this, and then we're just going to move on to front end because we have an hour left. Okay, so we're deploying it. It's been deployed. Let's go check this. Bad, Larry. Deploy it at blah, blah, blah. With that much gas, we'll go to rankbe, etherscan, IO, stick that contract address in here, and boom.
01:28:52.956 - 01:29:15.784, Speaker A: Now, we could verify it if we have time. I'll verify it, but I don't know if we have time. So we have an hour left. How are we doing? Any thoughts, comments, questions? How are we doing? What are we thinking? Thoughts? Comments, questions? How's everybody doing here? Hopefully we're all doing well. You're doing fantastic. If you're following along, please keep asking questions. And again, if you leave, please, before you go, fill out this QR code.
01:29:15.784 - 01:29:32.060, Speaker A: I'm going to leave it on the screen for a few minutes. Give us feedback. Let us know if you like this workshop. If you never wanted to see these again. The feedback helps us decide what is good and what people like and what people don't like. So thank you for being here. Be sure to hit the like button, too, and subscribe as well to the channel of YouTube.
01:29:32.060 - 01:29:46.004, Speaker A: I spell confirmations. Huh, sounds like me. We confirmations. Well. Well, we still deployed it, so. Whatever. So it's all good.
01:29:46.004 - 01:30:08.352, Speaker A: That's why it didn't wait six confirmations for it to go. Cool. Let's switch back to the code. Enjoying the movie? All right, cool. So I got rid of the wait confirmations because I spelled the wrong cool. All right, so we've deployed it. Now let's get frosty.
01:30:08.352 - 01:30:53.460, Speaker A: We're going to create a new folder for our next JS project. So I'm going to create MkDir NextJs full stack. Sorry about that. CD next full stack code dot. And we're going to create a new application for working with our full stack. We're going to build this really quickly and we're going to deploy it and it's going to be phenomenal and. Whoops, sorry.
01:30:53.460 - 01:31:17.980, Speaker A: So let's go ahead. Let's do this. So here we go. Let's create a new NextJs project. And if you followed along earlier this morning, you already know what it is, you already know how to do this. So we're going to do yarn create next app, period. And we're going to create a brand new next JS application that's going to work with, you guessed it, going to work with our application here.
01:31:17.980 - 01:31:42.738, Speaker A: We're getting all this fun stuff installed. Things are looking good. Okay, great. Now, because we want to make our lives easier, we're also going to install some other stuff. We're going to add yarn, add Morales, react Morales and web3 Ui kit. React Morales, web3 Ui kit. Like that.
01:31:42.738 - 01:32:01.394, Speaker A: Because we want to make our lives good. And we're also going to do something we haven't done yet. We're going to install Tailwind. Tailwind is a CSS formatter for us. We haven't shown this, but it's just going to make styling a little bit easier. And we're going to do that. So we add it by doing yarn add or NPM.
01:32:01.394 - 01:32:25.582, Speaker A: Install that command right there, add this tailwind thing. And like I said, it's just going to make doing a little bit of styling much easier. We're only going to do a tiny, tiny bit of styling because this is definitely not a full stack course. Okay. This is just web3, how to do some web3 stuff. How to do a full stack and stuff. Okay.
01:32:25.582 - 01:32:37.490, Speaker A: This is awesome. Thank you so much. It's a bit hard for me, so I'll have to rewatch, but I'm truly enjoying it and learning a ton. Excellent. And thank you so much for asking questions. Your questions have been really good. Can you share the deployment address so we can use that same one instead of deploying our.
01:32:37.490 - 01:32:51.430, Speaker A: Yes. Yes, I can. Boom. Here we go. Do you mind posting the yarn commands here, Patrick, please. Yes. No, I don't mind yarn create next app, period.
01:32:51.430 - 01:33:22.900, Speaker A: Then what do we do after that? Yarn add Morales react Morales web3 Ui kit. Then what are we going to do? Then we're going to do yarn add this. Yarn add this. But instead of D, we're going to do dev post this as well. Add tailwind. We're going to initialize tailwind with yarn instead of MPX. So we're going to do yarn this.
01:33:22.900 - 01:34:01.210, Speaker A: And I'll just post you this link, actually, and you can just follow along with this to add tailwind to your application. And we're going to override our tailwind config so we can open up tailwind config, paste it with that, and then we're going to go to globals CSs, oops. Css paste that in and we're good to go. So now we have tailwind in here. You'll see. No, don't share. Lol.
01:34:01.210 - 01:34:24.490, Speaker A: You'll see how we use it in a little bit. But okay, cool. So we've done some basic stuff here. Now if we run yarn dev or yarn run dev, we go to this. Sorry, go to our UI. We now have welcome NXJs. And I'm like super, super zoomed in.
01:34:24.490 - 01:34:47.270, Speaker A: So let's unsuper zoom in and. Cool, great. I'm going to create a new terminal in here just to run any commands. Okay. So we have a new thing. What's one of the first things we're going to want to make? Well, we're probably going to want to make a header. So let's create a new folder called components in here, a new file header.
01:34:47.270 - 01:35:02.686, Speaker A: Header JS. And we're going to make a header. And it's going to have a little connect button and everything. And actually let's go back to our pages, let's go to index and let's just delete everything. Goodbye. Goodbye. Excuse me.
01:35:02.686 - 01:35:20.354, Speaker A: Everything. Yeah, we'll delete the head for now and we'll delete everything except for that main div. Goodbye. And we'll just say hi. Now we're just saying hi in here we go back to the front end. This is hi. Cool, great.
01:35:20.354 - 01:35:56.394, Speaker A: I'm going to close that QR code, but please be sure to fill that out sooner. All right, cool. So now we probably want a header. We want to be able to connect to our application with our metamask. Zoom in just a hair. What we're going to do is a header Js, we're going to import connect button from web3 Ui kit and I'm going to lose my mind if prettier isn't in here too. So I'm going to add prettier.
01:35:56.394 - 01:36:14.534, Speaker A: You don't have to do this, but I need it. Otherwise I will lose my head. Yarn. Add prettier, add Dev. And prettier just makes it so that I don't have these gross semicolons and stuff. Save. Okay, cool.
01:36:14.534 - 01:36:37.386, Speaker A: There we go. Cool. Connect button like so. And then we're just going to do export default function header. And in here we're going to say return. And here's where some of that next Js is going to come. Or that tailwind is going to come in because I'm going to format these a little bit.
01:36:37.386 - 01:36:58.834, Speaker A: So we're going to create some nav div tags because this is going to be our nav bar. And we're going to say class name equals. And in tailwind you can define CSS right in class name. So we're going to say, we're going to give a padding of five. We're going to give a border bottom of two. It'll be a flex, flex row. Not going to explain what the CSS is doing inside here.
01:36:58.834 - 01:37:39.200, Speaker A: Do h one class name equals py four px four font is going to be bold. The text is going to be three XL. We're just going to say lottery. And then we're going to just inside here we're just going to add a div class name equals margin left auto py is going to be two. PX is going to be four. And these are just like paddings and stuff just for some formatting. And then we'll add the connect button.
01:37:39.200 - 01:38:16.410, Speaker A: Morales auth equals false again because we are not going to use a Morales server for this. Boom. Like that. And since we're using Morales, since we're using the Morales hooks and since we're using a connect button, we're going to need in our app to wrap our components in a Morales provider. So we're going to wrap this in parentheses like this. And then we're going to import Morales provider from Web three UI kit. Oh shit.
01:38:16.410 - 01:38:49.990, Speaker A: From react Morales not web3 Ui kit react. And then we're going to do Morales provider initia lies on mount equals false. Because again, we're not connecting to a morale server. We're just using the hooks and then just doing this. Now we have our app, we have this header component. What we want to do then is in our index Js. We want to grab that header component.
01:38:49.990 - 01:39:26.370, Speaker A: So we're going to say import header from components header. Then inside of this div we're just going to say there, that cool. If we go back to our front end now, we now get this lovely looking thing. It says lottery. It's got this little connect button. We can connect Metamask. And we're going to be on rink B.
01:39:26.370 - 01:39:39.888, Speaker A: So let's switch to a connected account. Let's disconnect here. Yeah, let's connect with this one. We'll connect wallet. Metamask. Metamask pops up. Bada bing.
01:39:39.888 - 01:40:02.110, Speaker A: Connect. Okay, questions? What did I miss? I personally prefer making my own state, but hey, to each their own. I see why it's just way faster. Yeah, we use the back end feature of nextjs. No, it makes a lot of sense. Yes. Okay.
01:40:02.110 - 01:40:12.752, Speaker A: You have to add prettier. All right. Same page. Yes. But also using vs code. I can forgive that. I have now lost my mind.
01:40:12.752 - 01:40:46.128, Speaker A: Thank you. Wait, why have you lost your mind? Why have you lost your mind? Because I'm not using style. Because I'm like coding a million miles per hour. How are we doing? We following along? We're not following along. We're actually already almost done, which is really exciting. So we now have our header in here, which is awesome. But what we need to do is we're going to need to make a new component called lottery entrance Js.
01:40:46.128 - 01:41:24.788, Speaker A: And this is going to have all our code to enter the lottery and to see all this stuff about the lottery. So let's go ahead and make this export default function lottery entrance. Now, what do we need to do? Well, we need to create a button to enter lottery button. Like that is the main thing that we need to see. So to make this enter lottery button, what we're going to do is we're going to import, use web3 contract from react morales. Use this. Web three contract from react Morales.
01:41:24.788 - 01:41:58.164, Speaker A: Now, in the GitHub repo associated with this. Where is this the GitHub repo I've got? Oh, no. We're going to go to lesson ten in the GitHub repo with this. I've got a lot more stuff than what we're going to go over with here. Got a lot more stuff in here. We added a ton of validation for, like, picking the right chain, picking the right address, depending on the chain, where you're going to forego all that because of speed. Notice, making a joke about vs code.
01:41:58.164 - 01:42:42.536, Speaker A: A friend of mine uses Vi mode, and I haven't become nearly as savant enough to do that. Maybe one day, but yeah. So we're going to build this now. So the main thing we need to do is we need to create this enter lottery button. So the way we're going to do this is we're going to say const run contract function equals use web3 contract. And we're going to pass it the Abi of the contract, which we can get. We're going to make a new folder called constants in here.
01:42:42.536 - 01:43:09.100, Speaker A: We're going to create a new file called Abi Json. And we can grab this by going back to our artifacts contracts raffle JSon. And we can just grab this Abi of our lottery contract. So we're going to grab this massive Abi. It is quite massive. Copy this whole thing. Boom.
01:43:09.100 - 01:44:03.276, Speaker A: Come back to our front end piece and just paste it in here. And now we have the Abi in its own file. And what we can do is we can import. We can import Abi from constants Abi Json. And we'll just say the Abi is the Abi. Great. And we need, after the Abi, we need the contract address for us.
01:44:03.276 - 01:44:35.210, Speaker A: We're just going to hard code it. Address right here. Address need the function name is going to be enter Ethel. And then we need the message value, which normally we would get by reading that entrance fee off chain. But we're just going to directly hard code it in here. It's going to be 112-34-5678 910, 123-4567, which is going to be 0.1 E.
01:44:35.210 - 01:44:56.024, Speaker A: And then we're going to say params is going to be blank. Going to sleep. Night, lucas, thanks for coming. Yeah. Morales has saved me a ton of time. I'm following along so hard that I don't have time to comment here. Excellent.
01:44:56.024 - 01:45:45.150, Speaker A: I'm coding really fast. All right, great. Now, blah, blah, blah, what are we doing? So we have this run contract function to enter the lottery. Now, in the interest of time, I'm going to see if we can just add this button to enter the lottery without some of the other stuff. So let's just do that first. So what we're going to do is in our return, we're just going to return a button to enter the lottery. So we're going to say div here, and we're just going to say button and button on click is going to equal an async function.
01:45:45.150 - 01:46:29.384, Speaker A: And we're going to run await enter raffle. And with this enter raffle, we can actually handle something. We can actually do handle success and make a little notification pop up. We're not going to do that in the interest of time, just because I want to get through this very quickly, and that's it. So this is way less code that's in that GitHub repo. But again, that's because we're doing this not enter raffle, going to be run contract function. Actually, we rename it to enter raffle.
01:46:29.384 - 01:46:54.210, Speaker A: Yeah, let's do that. Run contract function is going to be this enter raffle function. Okay. And in the interest of time, that's all we're going to do. So our whole application is going to break if we're not on rinkby. But that's okay because we're going to just make sure that we're on rinkby. We're going to make sure things are looking good for us now.
01:46:54.210 - 01:47:45.888, Speaker A: Yeah, like I said, the GitHub repo associated with this has a ton of data validation for making sure you're on the right chain. We're not going to add that in here, but what we are going to do is go back to our index Js and we're going to add that lottery entrance in here. So if we go back to our index Js, index JS, Bob will say import lottery entrance from components, lottery entrance. Right underneath the header. We're going to add this lottery entrance bit. Lottery entrance like this. Now, typically we want to do something like saying, hey, is web3 enabled? So I am going to add that at least, because otherwise life is going to be really miserable for people who aren't in metamask.
01:47:45.888 - 01:48:29.250, Speaker A: So we're just going to say const is web3 enabled? Equals use Morales. So Morales as a context provider is really powerful because it allows us to check, hey, do they even have web3 up? What's up with that? And we can import use Morales from react Morales. And we're going to say, is web3 enabled? Is use Morales. And we're going to do a little tertiary stuff here. We're just going to say, is web3 enabled with a question mark. And if web3 is enabled, then we're going to run all this stuff. So I'm going to do a little react fragment here.
01:48:29.250 - 01:48:56.010, Speaker A: If web3 is enabled, we're going to do all this stuff. Otherwise we're just going to have a div that says div. No metamask detected. Detected. Enabled. And we'll wrap this in parentheses here. Wrap this in parentheses here.
01:48:56.010 - 01:49:12.160, Speaker A: End that little JavaScript. So we're saying if web3 is enabled, go ahead, show the lottery stuff. If not, no manamass detected. Cool. So let's see if I did this right. Do a little refresh here. No manamass detected.
01:49:12.160 - 01:49:29.364, Speaker A: We probably shouldn't wrap the header. So let's not wrap the header. Let's have the header. Outside of that is web3 enabled thing. So we'll do this header. Let's go back. We're not connected now we're connected and we see we forgot to add our button here.
01:49:29.364 - 01:50:09.408, Speaker A: So let's go back to the lottery entrance button. We should probably name our button, right? Enter lottery. Now we have a little button. It looks absolutely horrible. So I want to just add a little bit of styling to it. We'll do a button, we'll say class name equals, let's do rounded ML auto font bold, and then we'll do, I don't know, BG blue 500. Make it a blue button, rounded blue button.
01:50:09.408 - 01:50:41.356, Speaker A: And now it looks a little bit better. It doesn't look great, but it looks a little bit better. So we're not adding those view functions. So actually it looks like we have plenty of time. We can add at least some of those view functions here. So to keep track of state, like how many players are in this or the recent lottery, what we're going to do is we're going to do use state in here. So we're going to say const recent winner and set.
01:50:41.356 - 01:51:06.944, Speaker A: Recent winner equals use state. We're going to start with zero. The recent winner is going to be nobody. And then we'll also do num players and set num players say zero. So the recent winner is going to be nobody. Number of players is also going to be nobody. And we can actually grab some view functions.
01:51:06.944 - 01:51:44.540, Speaker A: We can say view functions using the same syntax that we're using here. So we'll say const run contract function, get players equals use web3 contract. We'll pass this Abi is going to be the abi contract address is going to be this address. Actually, let's just save this global up here. We'll say const contract address. T equals that. Oops.
01:51:44.540 - 01:52:02.824, Speaker A: We'll do this instead. Contract address. Okay, cool. Contract address is going to be contract address. The function name is going to be. What is the function name? To get the number of players. We didn't add that as a function, so.
01:52:02.824 - 01:52:19.748, Speaker A: Just kidding. We're not going to do that. Sorry I lied. Instead of getting the number of players, we're just going to get the recent winner. Get recent winner. Because we did do a recent winner. If our raffle, if we go to our raffle.
01:52:19.748 - 01:53:33.110, Speaker A: S underscore recent s underscore recent winner is public. So we can call s recent winner to get the recent winner. So function name will be s underscore recent winner. Rams is going to be blank. Now what we can do, and this is where it gets a little bit confusing and we do have to import a use state from react act is we can say okay, anytime is web3 is enabled, let's update how many players there are and here's where it's going to get a little confusing. So we're going to do a use effect this and we're going to say if is web3 enabled, do some stuff, grab is web3 enabled? Of course. So we're going to say const is web3 enabled equals use morales, you need to import use morales from react morales as well.
01:53:33.110 - 01:54:14.848, Speaker A: We're going to say if is web3 is enabled in our use effect then we're going to run this get recent winners and we're going to run this anytime somebody connects to isweb3 enabled. So use effect is kind of this weird thing where it basically says okay, run this function anytime any variable in this changes. So that's what this means. So we're going to say, hey, anytime any variable in here changes, run this function. And the function that we're going to be running is just getting the recent winner. So that's how use effect works. So we're going to say anytime is web3 enabled kicks on.
01:54:14.848 - 01:55:04.640, Speaker A: If it is on then we're going to say const recent winner from call equals await recent winner. And then we're just going to set the recent winner and we're not going to do numpliers anyway anymore, we're just going to set the recent winner. We're going to say set recent winner of this response. And I know I'm going really fast, it's because I also want to deploy this. And once we have this recent winner, what we can do back down in our return, we can make another new little div. We'll just say the recent winner was do a little JavaScript. Recent winner.
01:55:04.640 - 01:55:42.908, Speaker A: Right now it should be nobody, right? So if we go back to our front end, weight isn't allowed in an on sync function. Oops, we can't do it like this. We got to do some weird stuff. All right, so I'm going to do async function, update Ui like this, paste that in here. Is web3 enabled? I'm just going to run update Ui. Some reason that works. See what I messed up on? Whoa, I need to import use effect from react, not wherever that is.
01:55:42.908 - 01:56:09.824, Speaker A: We'll do a little refresh here and bottom recent winner. Wat recent winner Watt recent winner is nobody. There is no recent winner. And we now have a way to enter the lottery and we're pretty much good to go here. So let's get this all together. Any questions so far? We're about to finalize this. I'm going to deploy this and we're going to let you all enter the lottery.
01:56:09.824 - 01:56:24.072, Speaker A: Hopefully it actually works. Praying it actually works. Any other questions? I'm going to come back to the Tori link of code but have to work right now. So I'm just casually following along. Excellent. I stopped coding along trying to understand and follow along. We'll continue coding tomorrow when I catch up in slow mo.
01:56:24.072 - 01:56:31.324, Speaker A: Excellent. Whatever works best for you. They'll be uploading the channel. Yes. Ross's goals. Yes. All right, cool.
01:56:31.324 - 01:56:59.332, Speaker A: So with that being said, our UI is done. Now. We don't have number of players showing up because I forgot to add that as a parameter. But technically our UI is pretty much done. So let's finish this bad boy out. Now what we haven't done yet. What have we not done at VRF? Chain link? We have not added a consumer to our ID of 1002.
01:56:59.332 - 01:57:37.120, Speaker A: Right. We need to tell the registry that it's cool to use the subscription for Chainlink. And we also is it keepers chain link or is it keeper chain link. We also haven't attached the keepers to that contract, so we're going to have to do both of those. But first, let's go ahead and let's go ahead and create this. So to export this code now that we're done, now that we think that we're done, I'm going to run yarn or actually in our package JSON and this is where you all can experiment here. We're going to do yarn.
01:57:37.120 - 01:58:03.064, Speaker A: Excuse me, 1 second yarn. Next, export what this is going to do. Oh, just kidding. Using, oh, excuse me. Yarn. Next build. We're going to build this, we're going to compile all this code into kind of a single minimal bundle, right? A single minimal bundle for us to use.
01:58:03.064 - 01:58:53.000, Speaker A: And once we've got this whole thing compiled in an optimized production build, we're going to export it into its own file. Once it's exported, I'm going to host it onto IPFs and any of y'all can interact with it. Now, we don't have time to do it with fleek, but fleek would be a way to add it to interact with it even easier. Fleek would give it a URL. We could also deploy this on morales, we could deploy this on Versaille on firebase, but we're just going to deploy it directly onto IPFs so anybody can go ahead and just interact with it. So great. So we just made a production build, now we're going to do yarn next export.
01:58:53.000 - 01:59:46.074, Speaker A: And I ran into an issue, no expert map and blah blah, image optimization. So am I doing something with images? I'm going to delete that next image thing because we can't use that image thing when we export. So image optimization. So nextjs has some optionality to do stuff on the back end. Since we just want this as a pure front end application, we don't want any of that back end stuff. So if there's any code in our project that does stuff on the back end, we just need to get rid of it. And images have image optimization so we had to get rid of it.
01:59:46.074 - 02:00:15.490, Speaker A: Now we'll run build, we'll run export and awesome. We now have it exported in this out file. And this is the minimalist example of our code. Now that we have this, you ready for something crazy here where you see some realness. Here's what we can do. I'm going to open IPFs, I'm going to open my IPFs and if I was on fleek I could deploy this to fleek and fleek would give me kind of a canonical URL. But we're not going to have time to do fleek.
02:00:15.490 - 02:00:39.600, Speaker A: So what we're going to do, sorry about that, is in my files here on IPFs. I'm going to import this code. I'm going to import this code. I'm going to import this folder. Let me just find it real quick. Full stack. No, where is it? It's here.
02:00:39.600 - 02:01:11.990, Speaker A: Okay, here it is. So in nextjs full stack, it's in this out folder. Okay, so I might have to rename it though. Yeah, I'm going to have to rename it, sorry, 1 second. I'm going to rename it to seal hack out, try it again. I got to rename it because I already have a file name out from some previous testings. Okay great, here we go.
02:01:11.990 - 02:02:23.870, Speaker A: So I'm going to grab that seal hack out and upload it, uploading this to my Ipfs file now. What I can do is I can find that cl hack out, I'm going to go ahead and pin it set pinning, I'm going to pin it to my node, cl hack out, I'm going to copy the CID and I can use a browser with something like IPFs companion or brave browser and I can just do slash paste it in and it should give me that website. I literally just deployed to IPFs 2 seconds ago, which will be pretty crazy, right? If it was that quick, and it looks like it's not being that quick, which is also fine because we literally just posted it half a second ago. So that would be pretty crazy if it went up that fast. Slash paste that in. Oh my goodness gracious. So I just need the hot second.
02:02:23.870 - 02:02:53.350, Speaker A: And now we've got it hosted on IPFs. Now what fleek will do for you because you can deploy this on fleek. What fleek can do for you is it'll also give you kind of a regular HTML URL as well. So I'm going to go ahead and post this in the chat if you want to go ahead and interact with this, but we can go ahead and connect our wallet, connect the metamask, count one, connect and boom. Now we can see the lottery. It's on IPfs. Anybody can interact with it and I can even enter the lottery.
02:02:53.350 - 02:03:28.814, Speaker A: We probably should have tested this. I'm praying it actually works before I deployed it. We're going to go ahead and confirm and we're entering this lottery and we can go ahead to our metamask. We'll view this transaction on a block explorer, and it looks like it is working. It's on rinkby, and this is my enter. So if anybody wants to enter the lottery, we'll be able to see your transactions pop up. We'll be able to see you enter our lottery here, and we'll be able to see the most recent winner.
02:03:28.814 - 02:03:46.426, Speaker A: So in the amount of time it takes me to hook up, the amount of time it takes me to hook up the keepers in VRF. If you want to enter the lottery, try to be the winner. Go for it. Okay, someone's entering the lottery. Excellent. Yes. Let's see who the winner is going to be here.
02:03:46.426 - 02:04:14.882, Speaker A: In vs code, right click on folder file and open containing folder reveal and explorer. Wait, why? Open containing folder reveal and explorer. In vs code, right click on folder why? What does that do? Anyways, entering the lottery. Let's see if we do a little. It looks like mine went through. Oh, two people went through. Yes.
02:04:14.882 - 02:04:55.420, Speaker A: Okay, so we have two people who've entered the lottery. Anybody else want to end of the lottery. Did that link work for anybody else? And you should actually be able to do. If that link doesn't work, you should be able to do the IPFs gateway. So if we go back to IPFs if that link doesn't work, that IPFs link doesn't work for you. What should work is if you copy, if I copy the CAD and I go to IPFs IO this, does that workfs gateway. Okay, well, this also works, but it's ugly.
02:04:55.420 - 02:05:11.760, Speaker A: You can also do the gateway if the IPFs peer link didn't work. It doesn't have the formatting. Oh my God, this is so ugly. Oh, just kidding. It doesn't even work. The gateway. That's disappointing.
02:05:11.760 - 02:05:33.636, Speaker A: The gateway doesn't even work, but that's fine because we're not using the gateway, we're using the actual IPFs link. Let's go, get back. Don't use the gateway. All right, we have two people who've entered. Let's see. Let's do a little refresh. Oh, my God, we got a bunch of people who entered.
02:05:33.636 - 02:05:48.792, Speaker A: Oh, this is great. Welcome to the lottery. Okay, cool. All right, now let's hook this up with Chainlink VrF chain link keepers, and we'll see who wins. Okay, so it was subid 102. So we have plenty of funds in here. If you don't have funds, you can add funds.
02:05:48.792 - 02:06:15.860, Speaker A: If you don't have funds, you can go to faucet chain link. Let's go ahead and add a consumer in here. The consumer is going to be our contract address here. And you still got time to enter the lottery. Remember, it's only a five minute window. And then we're going to do, where do we go? We're going to paste this address in and add a consumer, and I got to approve and send this transaction. So this is going to tell us, hey, VRF registry contract.
02:06:15.860 - 02:06:37.384, Speaker A: It's cool to use the lottery here. It's cool to use the lottery here. Cool. And like I said, sorry we didn't put more stuff on here like how many you have entered. But again, we can see it all on chain. Oh, it looks like some of you entered twice. Nice, look at all you entered.
02:06:37.384 - 02:07:15.912, Speaker A: Excellent. So do you all have IPFs or brave? I guess so. The reason I can see this on my browser is I have IPFs companion installed IPFs companion. So if you want to install IPFs companion, you should be able to. Yeah, if that link, oh my God. If the IPFs link I sent you, you can't see it in the browser, it's because you don't have like a local IPFs node. So if you install IPFs companion or if you're using brave, actually brave just has an IPFs node built in.
02:07:15.912 - 02:07:50.564, Speaker A: Okay, so everyone using brave Yep. If you're not using brave browser, you can get this companion thing, this IPfs companion, which will stick an IPFs node into your browser so you can see like IPFs URLs. Again, we could use something like fleek HQ. Fleek h one fleek HQ. And this can give us a canonical regular URL that normal people can use who don't have these amazing web3 browsers. But we're not going to have time to show you how to go through this. So sorry.
02:07:50.564 - 02:08:14.860, Speaker A: So if you have brave or an IPFs companion, you can enter. If you can't website works for me, but the wallet will not connect. I do have companion installed using brave 404 here. So a couple of people got in. A couple of people are having a hard time. Yeah. And this is why it's good to use something like fleek, to just give like a regular URL.
02:08:14.860 - 02:08:39.104, Speaker A: But the other thing is you have to be on rink B. You have to be on rink B. By the way, the wallet balance does not update automatically. It should. So this is some good feedback. So if you run into issues here, make an issue on the GitHub repo or make an issue on the Morales repo or on the forum, it should update automatically. So it should definitely update automatically.
02:08:39.104 - 02:08:50.356, Speaker A: So in any case, I'm going to do another refresh. How many. Oh, a ton of people have entered. Wow, you guys are beast mode. So we've added chain link VRF here. So consumer has been added. Right.
02:08:50.356 - 02:09:13.180, Speaker A: So now we have this chain link VRF address here. Now we just got to add keepers. And it pretty much should just automatically go because we've already waited five minutes. So all we need to do is add keepers here. So let's go ahead, let's register a new upkeep. We don't really need an address. I'll do this one, I guess we'll call this hackathon lottery.
02:09:13.180 - 02:09:30.150, Speaker A: Whole bunch of exclamation marks. Paste the upkeep address. We'll do a gas limit of 500,000, which is way too much. But whatever. Check data. Like we said, we're doing blank starting balance link. We already have.
02:09:30.150 - 02:09:51.900, Speaker A: How much link do I have in here? Assets got eleven link. So I'm just going to dump ten link in here. Hopefully that's enough. Submit registration for request. We're going to go ahead and confirm this review transaction here. Transactions going through. Hopefully ten link is plenty.
02:09:51.900 - 02:10:29.688, Speaker A: And it went through. So now we can view upkeep and this should probably kick off any second now. Reloading the page does though for what that's worth. Interesting. It looks like this is where front end development can be a nightmare because everyone's environment is different. So now if we do a little refresh here pretty soon, we should see. Oh, it's underfunded.
02:10:29.688 - 02:10:50.020, Speaker A: Okay. We need to add more funds here. Okay. Excuse me, do I have another wallet with link assets? Okay. No, I don't. So we're just going to go back to faucet Dutch into link, not running because it's underfunded. We're going to go ahead and connect to metamask here.
02:10:50.020 - 02:11:14.954, Speaker A: And this is why I went really fast, just in case we ran into anything like this. Oh, no, we're on COVID. We want to be on rinkby, not a robot. I also don't want ETH. I'm not a robot, though. Fire hydrants watch me fail the captcha or the captcha on screen. Just like, clearly I am a robot and not able to do it.
02:11:14.954 - 02:11:36.800, Speaker A: So we're going to get some more link to fund our keepers because right now it's underfunded. It looks like the minimum balance is 10.3, so we were off by 0.3. So we just got to add a little bit more funds for it to actually run. Once this confirmation goes through, we'll have some more link. Okay, great. We got the link.
02:11:36.800 - 02:11:46.610, Speaker A: Now what we can do. Look at that. 1.6 ether in the lottery already. Wow. Now what we can do, we'll add some funds. We really only need one, but we'll just do.
02:11:46.610 - 02:12:01.340, Speaker A: Oh, wait, why does it say 1.5 in my wallet? I have 11.5. Okay, well, whatever. I'm just going to add four. Confirm. We got to allow our ERC 20. Going to go ahead and confirm this.
02:12:01.340 - 02:12:31.918, Speaker A: Once the allowance goes through, we got to confirm the link transfer, and then the lottery should just kick off because the keepers has been hooked up. VRF has been hooked up. We have a truly transparent, autonomous, decentralized lottery. So for those of you who could not enter the lottery, I'm sorry. Front end is fun, isn't it? Full stack is fun. And that's where full stack can be. Like I said, kind of a pain in the butt.
02:12:31.918 - 02:12:47.074, Speaker A: All right, cool. We allowed. Let's go ahead and confirm now and we'll send some ETH to our keepers bit. And then right now we see all these enter. Oh, my God. We see all these enter raffle functions. Oh, my goodness.
02:12:47.074 - 02:13:12.650, Speaker A: Y'all trying to win out, huh? We're seeing all these enter raffles. We'll see one called perform upkeep and then we'll see that our random winner. Right. And if we're on our front end right now, we do a refresh. There's still no recent winner, but once this goes through funds added successfully, we'll do a little refresh. We can see if we scroll down. Aha.
02:13:12.650 - 02:13:27.394, Speaker A: We have a perform upkeep. So the chainlink nodes performed upkeep, and they triggered a VRF call. Right now. They triggered a VRF call. So if we do refresh on the front end, it's not going to be up yet. Right. Because we have to wait for a second transaction.
02:13:27.394 - 02:13:58.502, Speaker A: Right. We've only triggered the VRF request. So if you look at our VRF subscription, we do a little refresh here. What day is today? The 29th. Okay, we have April 29. So this is going to kick off very soon to get us that random number, because the perform upkeep just kicked off, we call perform upkeep. So very soon this is going to be fulfilled because we just called the chain link request.
02:13:58.502 - 02:14:27.094, Speaker A: And once the chain link node gets us a random number and returns it, this will be updated. Now, this can take a couple of minutes because rinkby is a little bit slow, and sometimes things take time, or because I totally messed up some variable and we didn't do any local testing. So that could be the other reason why it doesn't come back. But I'm hoping I did it right. Charlie needs more fake ETH. Charlie needs more fake ETH. Wait, it's two now.
02:14:27.094 - 02:14:53.270, Speaker A: What's two now? And so now we're just kind of waiting. Oh, my goodness gracious. I just did a refresh. We have a last fulfillment. This means we recently got a chain link VRF response. If we go back to this and we do a little refresh, we now have a recent winner who is 46 Da so and so. Who is this? Whose address is this? Who won? If that's me, I'm going to laugh.
02:14:53.270 - 02:15:11.474, Speaker A: We have our winner. Winner, winner. Who won the hacking lottery? Oh, Powershell kid. The Powershell kid. Congratulations to Powershell kid. You are the winner of, I think it was, what, 1.6 fake ETH.
02:15:11.474 - 02:15:27.942, Speaker A: Right. And if we go to our contract. Oh, it was maybe 1.9, almost two fake rink B test on ethereum. Congratulations. Congratulations here. And if we go to our contract here, you'll see that we don't have a fulfilled randomness.
02:15:27.942 - 02:16:09.306, Speaker A: We only have these enter raffle functions here, and you might be saying, hey, Patrick, what's up with that? Well, remember, it's actually an internal transaction. So we get a fulfill randomness being called by the chainlink vrf coordinator contract. So it actually counts as an internal transaction, not a direct transaction on the contract. So huge congrats to the Powershell kid. Powershell kid. How many times did you actually enter? How many times did you enter the lottery? What's your address again? You were 46 Da. You entered three times.
02:16:09.306 - 02:16:25.920, Speaker A: Excellent. I guess. Did anyone enter more than you? I think 96 entered more than you. Oh no, they also entered three times. Did anyone enter more? F one. Oh I see. F one entered a couple of times.
02:16:25.920 - 02:16:33.726, Speaker A: Four times. F one. You entered four times, you didn't win. Oh, that feels bad. Three times. Excellent job. All right, cool.
02:16:33.726 - 02:17:31.940, Speaker A: So that is us having created our decentralized lottery end to the end. For those of you who couldn't join the lottery, once again, I'm sorry, this is where IPFs can be a little tricky. And having kind of a canonical HTTPs is still important to have even when you do host on IPFs, for example, if we go to HTTPs app ive.com for example, we'll see this little IPFs thing, right? Saying hey, this is hosted on IPFs. If you're on brave, only if on brave you'll see this and you can view it on IPFs. But it also has this HTTPs because they need like a lot of people don't have that IPFs compatibility and that's okay. So even when we're deploying our contracts on IPFs in this more decentralized way, it's still best practice to also as of right now, deploy it to some centralized piece for exactly the rationale that a lot of people saw because they ran into these issues here.
02:17:31.940 - 02:18:09.934, Speaker A: And with that being said, even though we didn't write any tests, and if any of you submit projects and you don't write tests, I'm going to be very disappointed in you. And I won't take off points per se, but I will ask how the heck did you build this without cheating or something? Write tests, write tests, do as I say, don't do as I do here. But yeah, that was a lot of fun. We did literally a whole decentralized lottery in less than 3 hours, end to end. We even deployed it. That's like crazy. We built a website.
02:18:09.934 - 02:18:38.502, Speaker A: We built a decentralized lottery with a decentralized escrow and an autonomous lottery approvally random lottery. Wow, what a 3 hours? Or was it 3 hours? It's like seven. So that was really 2 hours. Hold on, what time did we start this? Oh, we have another half an hour? Oh no. Two and a half hours. Oh yeah. We coded this in less than 3 hours.
02:18:38.502 - 02:19:01.662, Speaker A: Oh wow. So that's really impressive. So how are we feeling? How are we feeling? I sped up, but actually I didn't need to speed up because we have another 30 minutes. I thought we were ending at seven and I was the one who scheduled this. Sorry. How do we feel? Congratulations, Powershell kid. Are there any additional questions here? Okay, how do you listen for lottery contract events? Really good question.
02:19:01.662 - 02:19:24.518, Speaker A: There's a number of ways to do that. Ethers has a listener thing. So you can go to ethers, you can do like provider on and then type the event you want to listen for and then say what you want to do when that event happens. So ethers has one, Morales has one. There's a ton of packages where you basically set up some process to listen to the blockchain for events. So ethers, Morales, they both have one. Good question.
02:19:24.518 - 02:20:03.806, Speaker A: Any other questions here? Any ideas on reducing fees for users that want to buy more than one ticket? Pushing to an array a bunch would be expensive. Great question. Yes, pushing to array would be expensive. One thing you could do is you could add a parameter to that enter lottery function. So you could say enter lottery and then add one of the parameters, be a unit, 256 number of tickets, and then you just print them that number of tickets. And instead of mapping, instead of an array with that address a whole bunch of time, you could do like a mapping and say like mapping number of tickets. And then just have an array of the unique addresses.
02:20:03.806 - 02:20:42.720, Speaker A: So that could be something that you do. But maybe that'd be more expensive because you'd have to check the array every time for them. But yeah, those are some ideas. Can you go over the variables in the contract which you would normally put as private? Yes, that's a really good question. And yeah, I know, it kind of just went really fast here, let me switch over to code. So in here, all these variables are public, but the name s underscore timestamp would be like gross to see if you're interacting with the contract. Right.
02:20:42.720 - 02:21:12.826, Speaker A: And public variables are actually more expensive to interact with. So normally I would make them private. And then at the bottom I would make some getter. So I would do something like function get last, or what is it called? Get last timestamp. And this would be a public view or external view or whatever, and then just return s last timestamp. Right, because get last timestamp is a lot more readable. Oh, public view.
02:21:12.826 - 02:21:32.814, Speaker A: Excuse me. Returns 256 because get last timestamp is a lot more readable than s. Underscore last timestamp as an API. So that's how I would do it. 2 hours, 15 minutes. I can't do math. Yeah, we did that in 2 hours and 15 minutes.
02:21:32.814 - 02:22:09.980, Speaker A: Isn't that crazy? How hard would it be to pick multiple winners? Good question. So in this, in our num words, we're picking just one random number. We could easily just bump it up to two. And then in fulfill random words, we could just pick two winners here instead. And so when we send the money, we would just split it into two. We'd split the address this balance into two. That's it.
02:22:09.980 - 02:22:27.300, Speaker A: Oh, great. Need to review at zero point 25 x. Yes. And be sure to stay tuned for my end to end hard hat thing. And as people drop off, hold on. As people drop off, please take this QR code. Please grab this QR code or let me post the link.
02:22:27.300 - 02:22:53.130, Speaker A: Let me post the link here. Hold on, grabbing the link. Please give us feedback. Let us know if you hated this, if you love this, if you thought it was mediocre, if you thought it was amazing. Let me give you the link here. If I can find the link here. Where the heck is my link? Okay, here it is.
02:22:53.130 - 02:23:14.204, Speaker A: Please give us feedback. If you like this, if you hated this, if it was too fast, if it was fun, if it was not fun. QR code link right here. Link in the chat. Either way, let us know before you go. So I'm going to leave the QR code up. I'm going to leave the QR code up.
02:23:14.204 - 02:23:51.160, Speaker A: Okay, sorry, what was the question? How do we prevent people from entering multiple times? So this one, we didn't. We just let people enter as many times as they wanted because if they were going to pay, like great, we don't care. But what you could do is when they enter, you could check that array, you could make a function called not already entered or check if already entered and you would loop through that array to see if they're already there. Or you could also store them. Anybody who enters as a mapping saying. True. If they entered and you could just check the mapping, that actually would be much more gas efficient.
02:23:51.160 - 02:24:04.444, Speaker A: Yes. Okay, great. Glad that you enjoyed it. And this was kind of fun, right? I knew this was going to be fast and hard to follow. We have a second winner. Oh my goodness, do we wait? Oh, you all been playing. I guess it is five minutes.
02:24:04.444 - 02:24:17.010, Speaker A: Hold on. Let's go to the code. We have a second winner. Who won? Oh, wait. Oh, crap. Where is it? IPfs. Is this it? No.
02:24:17.010 - 02:24:57.170, Speaker A: Where is that? Seal hack out. Copy Cid. Hey, we got a second winner. You all been playing the lottery without me? What's up with that? And yeah, because it's going to just continuously go right for forever. So who was the second winner here? Who is our second winner? 69. Oh wait, is that me? 62947, who's our second winner here? Congratulations to the second winner. Whoever won, you probably won a lot less money.
02:24:57.170 - 02:25:29.290, Speaker A: What is this transaction? I don't know what this transaction is. I don't know. Whatever. Congratulations to whoever won here. But yeah, it's an autonomous lottery, so it's just running now until it runs out of link. It'll just run forever until it runs out of link. Why is the method called random words, but it returns numbers? So this is kind of a callback to some computer science stuff where like a number is called a word.
02:25:29.290 - 02:26:05.670, Speaker A: That's basically it. It's some computer science reason. Would it be possible to fix the issue with it not working for non brave users without using fleek? Only heard about it today. We'll be checking it out. Yeah, so you would need to deploy this to kind of like a regular hosting service, like a regular HTTPs, like what I was showing with app iv.com. So you would do that next export and then you would just deploy it to any static file. Versailles a good one.
02:26:05.670 - 02:26:48.950, Speaker A: Nettlefi is a good one. I think GitHub even has one right now. But yeah, you just need to host it on some traditional centralized application so that non IPFs, non brave users could use it. And yes, no eoxes, I know you ran into the issue where you didn't have the IPFs working and that's why something like that is really important. Once IPFs becomes more adopted, I'd be willing to bet that more browsers will have it built in, which is really exciting. What will keep this lottery dap from running? The only thing that can stop this lottery at this point is it running out of link. That's it.
02:26:48.950 - 02:27:09.240, Speaker A: Other than that, nothing. This will run forever. If those two subscriptions have linked, they'll run forever. That's it. Hey Jorge, congrats. Congrats. And now every five minutes forever until it runs out of link, there will be a random.
02:27:09.240 - 02:27:29.980, Speaker A: So. All right, cool. Any other questions here and again, please fill this out. Very helpful. Very helpful to us or very helpful to me? Let me move my chair out of the way. Very helpful. Letting us know what you liked, what you didn't like, giving us feedback congrats, Jorge.
02:27:29.980 - 02:28:05.630, Speaker A: Any other questions here? Looking forward to the 20 hours hardhead course too. Yeah, that's going to be insane. For the feedback form, build a raffle app with solidity NextJs is not recognized as a valid option. That is annoying. If that doesn't work, you could just do the intro to full stack again. Now I want to test it. Let's go.
02:28:05.630 - 02:29:03.502, Speaker A: What was this called? Build a raffle, build a full stack web3. So full stack, web3, next JS solidity, raffle code along. That's what this is. Full stack web3 next JS solidity, raffle code along how can you keep the site pinned on IPFs filecoin? Yes, excellent question. So when we talked about IPFs before, data persistence is not guaranteed on IPFs. It's a decentralized distributed network, but data isn't necessarily guaranteed to be in this decentralized state. Filecoin puts blockchain economics on top of IPFs, and you can use Filecoin as a blockchain to guarantee your data stay.
02:29:03.502 - 02:29:39.366, Speaker A: So yes, so you can use Filecoin as a decentralized option, and then as a centralized option you can use IPFs. And that's actually a good point, because right now I'm the only node pinning this data. Once I turn my computer off, you won't be able to reach that place anymore. So that's kind of crazy. I'm the only node that's pinned this site. So if you're watching this in the future, you might not be able to go to that ipfs hash. Because if I'm the only node that hosts that data and I go down, nobody can do it anymore.
02:29:39.366 - 02:29:51.070, Speaker A: But anybody else can pin that data if they like. Really enjoy this workshop. Well, thank you. Glad you were here. Hopefully you learned a lot. Full stack. Yes, that is the name of the workshop.
02:29:51.070 - 02:30:09.560, Speaker A: Can this be deployed with remix? Yes, the back end can be. Obviously not the front end. Yes, set it for the next one. Running a local chainlink node code along have been wanting to set my own node. Yeah, that's going to be exciting. Cool. Any other questions here? And yes, QR code feedback form, please take.
02:30:09.560 - 02:30:32.460, Speaker A: Thank you. And I know we said this was 3 hours, we're going to end a little bit early. I'm sure nobody's mad about that. Well, I hope nobody's mad about that. Well, what if you turn your no back on? Does it come back? It sure does. It sure does. Stay based, my friend.
02:30:32.460 - 02:30:56.260, Speaker A: Give it a couple more minutes for any other questions, just because like I said, we said we'd go for another half an hour at least, and we're ending a little bit early. I'm very excited. We're ending a little bit early. Any other questions here? You all have been great. Thank you so much for participating and commenting and being in the chat. Be sure to QR code. Thank you.
02:30:56.260 - 02:31:30.430, Speaker A: Any other questions while I glug my giant water bottle? Thank you. Can I learn solidity without Dev experience? But I can read JS Python? Yes, you sure can. Welcome to Web three. You can do whatever you want, web3. That's not true, but yes, you can. It's 02:00 over here. Heading to bed.
02:31:30.430 - 02:31:56.354, Speaker A: Good night. All right, it looks like the questions have died down for the most part, so I'm going to jump off again. QR code feedback form thank you all so much for being here. Hopefully you all learned a lot. Hopefully this was helpful for you. Good luck at the hackathon next week we are doing a ton more advanced tutorials, so I hope to see you all there. They're going to be a ton of fun.
02:31:56.354 - 02:32:07.350, Speaker A: Like somebody mentioned running your own chainlink node, which is going to be an absolute blast. And stay based. All good luck at the hackathon, good luck coding, and I'll see you out there. All right, bye.
