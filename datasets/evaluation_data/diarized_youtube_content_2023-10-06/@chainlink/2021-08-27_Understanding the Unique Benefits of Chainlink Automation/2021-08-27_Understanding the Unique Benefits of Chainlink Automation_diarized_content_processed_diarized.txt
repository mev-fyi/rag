00:00:06.410 - 00:01:15.122, Speaker A: Now, Chainlink Keepers is fundamentally the ability to give an off chain, to give a computation to something called the keeper network, to give a computation that isn't something you can do in a contract or you want to do in a contract. For either capability reasons, the contract act can't do it cost reasons. The contract would be too costly, it would be too costly to do in a blockchain or sometimes privacy reasons. The other reason that we found is realistically, just like you had a centralization problem with data where people would run their own oracles and those oracles could fail, and that failure could lead to a DeFi protocol being underwater or dislocated from markets or dislocated from reality. It's very much the same situation with keepers. You have developer teams and developer communities that are building a great DeFi application, a great gaming application, but they don't want to build infrastructure and they don't need to build infrastructure. And that's the problem we need to solve for them at Chainlink, and the Chainlink network needs to be built to solve by the larger community, by them together with us, and so on.
00:01:15.122 - 00:01:56.306, Speaker A: It's a matter of providing a decentralized system that you can offload the responsibility of off chain computation to, while still having those off chain computations have a measure of decentralization and trust minimized guarantees. Right? So the way it really looks is, hey, I'm a smart contract development team. I know I'm going to do a thousand contract calls about a certain topic, whether that's telling the contract what time it is. For example, smart contracts can't know what time it is. They need server. They need a central server to tell it it's midday UTC time, time to settle, time to execute. Even that level of information isn't available to the contract, just time.
00:01:56.306 - 00:02:50.254, Speaker A: And so these developer teams know, hey, I am going to have 1000 plus interactions with a smart contract. Man, I hope I can keep my server running. Man, I hope I don't miss one of those, because if I miss one of those it'll be a real problem. So instead of having to do 1000 of those and not being able to tell their user base that they're giving them reliable guarantees, now, they can quite simply say, here is one upkeep request into the chain link keeper system, into a single chain link keeper network, and then that chain link keeper network will do thousands of ongoing DevOps, off chain compute and other transactions. Now why does this matter once again, right? Just to explain this kind of slightly esoteric problem, why does trust minimized off chain compute matter. Well, once again, when you're building decentralized, secure systems, you need to be secure and decentralized and hyper reliable end to end. So you need to be hyper reliable.
00:02:50.254 - 00:03:51.062, Speaker A: When the gas price is at 2500, you need to be hyper reliable. If a server somewhere goes down, you need to make sure that your systems run in all market conditions, in all network conditions, because that's the nature of blockchain based applications. You need to provide that cryptographic truth guarantee that under all circumstances you will be able to generate the outcome the application says it will generate. So how does this look when everything's okay? Well, when everything's okay, the smart contract development team is triggering things based on time, maybe doing limit order execution through their interface, maybe doing automated liquidations, maybe doing smart contract DevOps requests. Someone on their team is maintaining a central server. That central server essentially decides how the application will and won't function because it controls certain key outcomes of what the smart contract application is able to do. And that is a very striking parallel to oracles, right? Data oracles, same exact story.
00:03:51.062 - 00:05:10.586, Speaker A: Guess what? That's a bad idea. Same reason you don't want a centralized system controlling your contracts, whether it's for data, or telling it what time it is, or triggering it for various key events that you would ideally offload. And the place where that starts to get shown is when gas does go to 2500 and transactions aren't being broadcast, or your centralized server fails, or an adversary finds out how to ddos your one centralized server, and all of a sudden you're not broadcasting DevOps transactions to your smart contract. Those are all very exploitable, very risky things that Chainlink networks expressly eliminate, right? They expressly eliminate the congestion issues, the network issues, the market based issues, the exploit issues, all of those. And that's been proven, which is why once again, the Chainlink networks that provide data, hundreds of those now exist, going to thousands soon. And those networks provide that data under the same set of guarantees that Chainlink keepers will provide to the applications that now need a reliable method to compute key computations that the contract cannot do, but that have to be done in a decentralized, trust minimized, hyper reliable manner. And so that's the fundamental role of keepers.
00:05:10.586 - 00:06:17.138, Speaker A: And this once again serves the purpose of firstly, unburdening the smart contract development teams from having to do this so that they can focus on making a great deFi gaming or insurance application, and secondly, providing an end to end decentralized guarantee for how the application functions. And this guarantee is what all of this is about, all of this is about a decentralized smart contract with end to end security, end to end decentralization. This is what end to end decentralization looks like, not this. Now here are some examples to provide clarity. So in the case of Ave, we're working with them on reliably managing the liquidations in their protocol to make sure their protocol remains solvent. That means that the various liquidations that need to happen for their protocol to remain above water, insolvent and usable, will now, in many parts of their kind of smart contracts, be done by chain link keepers that will provide guarantees about liquidating those things, about getting transactions in, about that, about properly monitoring that. And that's a critical aspect of keeping the AaVE protocol working properly.
00:06:17.138 - 00:07:48.158, Speaker A: In the synthetics case, it's about staking and fee distribution. And so there needs to be a mechanism to properly give out staking, rewards, fee distribution and so on. And this is a very clear need in many different applications where a keeper network is now going to take on the role of making sure that that part of the application works properly as an off chain, trust minimized computing resource that's configurable by the synthetics community and the synthetics team, and through whatever set of processes that community has. And then another final example is pool together for something as basic as starting its games and ending its games on the basis of time. Right? So instead of the pull together team having to initiate these critical aspects of their game, they can now offload this responsibility to a hyper reliable, decentralized computing system in the form of a chainlink network that's committed to doing this just like it's committed to providing data and under the same set of hyper reliable systems, guarantees and reliable systems. So this is a big, big improvement for what smart contract developers can build today. They can offload a massive amount of DevOps, a massive amount of automation, a massive amount of computation that their team has to do internally, and they get their developer resources back, their protocol becomes more decentralized, and their protocol can prove more cryptographic truth to their users.
00:07:48.158 - 00:09:01.926, Speaker A: So it's just a benefit all around, accelerating what can be built. The more expansive vision of keepers that I'm truly excited about, and I'm already starting to see certain protocols taking advantage of, is the ability to actually offload certain amounts of computation into a keeper network. So the way that this looks, and in practice it can actually be done today at this very moment, is the broadcasting of a smart contract on chain into a network like Ethereum. That contract that was broadcast and deployed on chain then can be split into two equal parts. It can have a portion that is supposed to be executed on the blockchain network and then it can have a subsequent portion, maybe even a very large portion that would be extremely costly to run on the blockchain network in the keeper network. So the keeper network basically at no cost or just like web systems cost, just base minimal hardware and web traffic cost, which is like the lowest cost you're going to get for any computation, can now execute a portion of the code that was broadcast and deployed on chain. Now the benefits of this are twofold.
00:09:01.926 - 00:09:42.680, Speaker A: Firstly, you've deployed the code on chain so everybody can verify what the keeper network is going to compute for you. That keeper network is only for that contract and it is not going to compute anything else for anybody else. It's not going to do anything else. It's a distinct service that only computes that piece of code for that one contract on a committed Sla type of basis. And so everybody knows this keeper network has committed to run that code which has been deployed on chain. So now you know that this trust minimized oracle network is committing to run that code. So you have certain assurances and certain cryptographic truth and certain transparency there.
00:09:42.680 - 00:10:37.640, Speaker A: And then the keeper network runs that code. So if you had a contract that you wanted to make more robust, you didn't want to pay a lot of ethereum fees, or you wanted certain privacy about that code, guess what? You can broadcast it and then you can have it run in the chain link keeper system. And the chain link keeper system can look at a multitude of on chain and off chain activity. And this is a very extensible capability that we already see some of the protocols we're working with that are using chain link keepers doing. We're seeing them basically say, hey, I want a more robust, more advanced hybrid smart contract. Here's what I want happening on chain for cost or speed or whatever other reasons. Here is the code that I want to run off chain in a trust minimized way.
00:10:37.640 - 00:11:06.590, Speaker A: And here's what I needed to do. I needed to tell me the time. I needed to go get some data. I needed to compute some things. I needed to compute something else. Once you see the results, I needed to monitor a contract somewhere and then do something based on that monitoring because smart contracts can't even really monitor each other unless they're kicked by keeper system. And so this is extending to a very large degree what smart contract developers can build with a trust minimized system that generates cryptographic truth on that topic.
00:11:06.590 - 00:12:14.930, Speaker A: And so that's quite an amazing innovation in my opinion, and I think it's going to generate a lot of very advanced use cases. Now if this is something that you would find useful if you're a developer, if you're building various blockchain based applications, I think you should really check this out. This is a decentralized, easy to use form of off chain computation that in a matter of minutes can allow you to offload some of your centralized responsibilities to a decentralized system that you can configure. You can add more nodes, you can add less nodes, you can expand what the nodes are computing for you, and you can prove all of that to your users. So they know that this portion of your smart contract is not run by you, is not in a black box, but it is in this cryptographic truth, decentralized, completely end to end provable model, which is the model that I think everyone here is going towards you. That's.
