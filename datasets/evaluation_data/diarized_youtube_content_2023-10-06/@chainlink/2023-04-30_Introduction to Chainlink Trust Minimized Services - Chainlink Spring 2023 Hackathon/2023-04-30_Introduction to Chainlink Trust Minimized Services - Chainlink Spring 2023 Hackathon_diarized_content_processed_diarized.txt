00:00:40.440 - 00:01:24.950, Speaker A: Mohammed Good morning. Good developers from all over the world welcome to this workshop. It you this is 09:00 p.m. For me. I hope that the morning for you. Yeah. Good morning.
00:01:24.950 - 00:03:05.840, Speaker A: Good morning. We will wait about seven minutes for more people to come. I have a question. Is there any API that provides me the access to create automation in Chainlink? Actually I think you cannot use any API to just create a subscription or do something like that. You can just create automation in advance and use any API to do something with automation. Good afternoon Akin Sanwa and if you want to learn more about Chainlink, there is a new service called Chainlink Functions we just released in last month and you can use the chainlink functions to just make an API call to the outside world and move the data move unnormalized data to the smart contract. It will like the new version of NApi.
00:03:05.840 - 00:05:36.810, Speaker A: Hi everyone, it for Saturday it check the time so four more minutes for more people to come. Well you have questions before I even start and you'll learn a lot about the chain links. So how many link tokens would I need? Once beta is over and the devs can start building? If you want to start building on the testnet like Sepolio or Mumbai, you can just get some test tokens from the faucet and think about 15 or 20 links is enough for you. What packages needed to be installed for this workshop? You actually don't need to install any package because for this workshop I just introduced the auto service provided by Chainlink and I'm going to use a remix to do the demo. So if you can open the remix and input the solid code in the remix, the IDe will help you to install all the packages. And of course we have some other workshops following this workshop. It's going to happen in April and May.
00:05:36.810 - 00:06:28.974, Speaker A: If you want to learn more deep knowledge about chaining functions, about the development tools and about the public chains, they may have some approval request. They need to install some packages in advance. Just keep an eye on that and comment alert. Thank you for your questions. Hello, I'm a new in the web3 space. Do I stand a chance to partake this hackson? Yeah, of course. In Chainlink Hackson we encourage new developers to come and learn and to just watch what other people doing and try your code and to implement what you want to do in the Haxton.
00:06:28.974 - 00:07:23.050, Speaker A: And it's going to last for one month and you can learn and build. It's a good opportunity to learn and also make some friendship. If you want to find a team to just coding with some other developers as a team. You can go to the discord, the chaining discord. There is a channel called teams or maybe members. You can post your requirement or just post your skills stack to see if you can find a team. Okay, cool.
00:07:23.050 - 00:07:58.258, Speaker A: It's 09:00 p.m. For me and the workshop is going to start. Thanks for all the developers coming here and welcome to take part in the chain link hackathon. And thank you everyone and good morning, good afternoon and good evening. So let's start. Before I start, there are some other questions. How many Chainlink services are there? In total? There are about five chainlink services you are going to use in Hafton.
00:07:58.258 - 00:08:43.638, Speaker A: It's called Chainlink data feed, chain link functions and Chainlink VRF, chain link automation, chain link and API. I'm going to cover four of that in the workshop and you can learn all the basic knowledge of this trust minimization service in this workshop and start building. And if you want to learn more about the details about different services you can just go to the docs chain link. That is the documentation website of the chain link. You can learn more details about every services and I will show in the workshop. Don't worry. Okay, let's start.
00:08:43.638 - 00:09:05.270, Speaker A: Let me just slide show my slides. Okay. Hey everyone, good morning, good afternoon and good evening. Hi to the developers from all over the world for this workshop. And welcome to take part in the Chainlink hackathon. And my name is Frank. I am a developer advocate from the Chainlink Labs.
00:09:05.270 - 00:10:03.034, Speaker A: I'm going to make a brief introduction about how the trust minimize the services provided by Chainlink in this workshop. And if you want to learn more about the other services and get some deep understanding of the Chainlink about a public chain or want to learn something about development tools, we also have other workshops in a series after this one and just keep an eye on that and come and learn and welcome everyone. Okay, so in my presentation or in my workshop, there are going to be three parts. For the first one I'm going to introduce what is the oracle and why we need that. And for the second part I'm going to introduce the Chainlink address minimizer services including the chainlink data services and Chainlink computing services. In the Chainlink data services there are two services. The first one is a data feed.
00:10:03.034 - 00:10:30.806, Speaker A: You can just get the price of a particular asset from the outside source. And the second one is called functions. You can use functions to get some on the data or get some custom data. All the data you can get in the web. Two API. You can use functions to connect your smart contract to these APIs and build logic based on that. And after that there are also the chain and computing service.
00:10:30.806 - 00:11:35.942, Speaker A: The first one is VRF. You can rely on VRF to get a randomness on chain and you can use automation to just automate functions in your smart contract. And all of these services can open up a huge number of the use cases and I'm going to introduce all of them and do the demo for each service so you can learn how to start and where you can find the documents. And at last I will spend a little bit of time to share some useful information about the chain link community as a developer or as a builder. When you have some problem, technical problem, you can find someone to help you that is very important. Okay, so let's start. The first question we need to answer here is what is an oracle? Oracle is actually a new kind of the infrastructure that helps developers to relay the data and computing services from the off chain to on chain smart contract.
00:11:35.942 - 00:13:22.398, Speaker A: So maybe your next question is that why we typically need infrastructure help us to relay the data and computing services? The short answer is that the smart contract on the blockchain just cannot actively get data from the outside world. So as we all know that the data saved on the blockchain, the biggest characteristics of the data saved on the blockchain is that every single piece saved on the blockchain has its own ownership, which means there is not a central authority that can remove or modify the data arbitrarily, because the data is actually sift across multiple nodes in the whole network. And in this scenario, in order to make sure that every different node keeps the same data, there is a process called consensus. The consensus if there is a new update there, is the data supposed to be updated or added to the blockchain. The state need to be updated. There must be a node under the whole network. Make a proposal to say like I want to execute this logic in the transaction and I get this result, can you guys just execute in the transaction I proposed and to see if you can get the same result, if you get a SIM result, can you guys just update your own database correspondingly? And this node will just broadcast this news to the whole network, and every single node in this network will receive this proposal and execute what is told in the transaction to see if they can get the same result.
00:13:22.398 - 00:14:46.406, Speaker A: If the same result is calculated, they will just update their databases and the consensus is successful. And after that we can see that the transaction is written into the block and the state is updated finally. So that is called the consensus. Everything sounds good, right? But think about this scenario. If I want to get data from the outside API, maybe the temperature temperature of the city where I'm living, maybe Hong Kong, maybe Beijing, or maybe New York City, there is a node make a proposal to say like I just get a temperature data from the outside API in Hong Kong and that is 20 celsius degree in Celsius. Can you guys just check the same API and get the result to see if you can have the same temperature data? If the result is the same, can you guys just like before to update your databases or just update this state? So what do you think going to happen next? Like before, after the node make the broadcast this news to the whole network. The different node in the network will just make an API call to the outside API.
00:14:46.406 - 00:15:18.718, Speaker A: And let's first assume that every different node have the same access to the API. And do you think they will get the same answer? Maybe, but maybe not. Because in the different time slot and the different people, even they call the same API, they may get the different answers. Because like in the 02:00 p.m. In the 02:00 p.m., 30, maybe the data provided by the API is different or the API is found and the service is suspended. So the node cannot get a result from the API.
00:15:18.718 - 00:16:15.762, Speaker A: So if the node cannot get the data, cannot get the same answers, the consensus cannot be passed. So the transaction cannot go through the consensus and the data cannot be updated into the blockchain. And that is called an oracle problem. That is why the blockchain cannot get or fetch the data from the outside world by itself. And to summarize it, the blockchain is actually a deterministic system, and the blockchain can only handle the deterministic transaction. So what is an deterministic transaction? That is, no matter when, no matter who, to execute this transaction, the same result will be calculated. For example, like one plus one, and no matter who and no matter when, to calculate one plus one, the result will always be two, and that is called a deterministic transaction.
00:16:15.762 - 00:17:09.126, Speaker A: But if you want to make an API call to get data from the outside world, and if you want to get a random number, the different node will get different answers and the different answers in the different node. So the transaction cannot go through the consensus in this way. The blockchain cannot just handle the indeterminate transaction. And oracle by its name is actually used to solve this problem. Oracle can help us to relay the services relay the data and relay anything we want from the off chain to onchain. Okay, so I will answer the questions after I go to the next section. Okay, so we've been talking about what is an oracle and what we needed.
00:17:09.126 - 00:18:13.398, Speaker A: So let's go over some different types of the oracles. When the oracle, this concept is forcely introduced into the web3, in the very early stage, there were a lot of the centralized oracles in the market. The process for the centralized oracle is pretty straightforward. Usually the user will write a smart contract, and through this user smart contract the developer can send a request and save that onto an event log. And the data on the event log can be caught by off chain centralized oracle node. And this oracle node with necessary data from the request will just use the predefined script in the server and get a data from their data sources and then get all the data and just write this data back to the smart contract. That is pretty straightforward, right? But actually there is a problem called a single point of failure.
00:18:13.398 - 00:19:36.626, Speaker A: When you use a single node oracle, that you create a single point of failure because the data you rely on is actually fetched by a single node. And when there is something bad happens on this centralized node, the data will be controlled or exploited and it will be harmful to your protocol. The users under your decentralized application may lose a lot of money on that. So think about this scenario, and the whole reason you want to build your applications on the decentralized network is because you want to rely on this decentralized network with hundreds of or even thousands of nodes to promise your application is very secure, very reliable, and very transparent. But if you are relying on a centralized node to feed the data to your smart contract, actually you create a single point of failure. That was what we're saying, that you use a single node oracle, you create a single point of failure. The solution, or the answer to this problem is that you can use a decentralized oracle network instead of the single node oracle node.
00:19:36.626 - 00:21:19.510, Speaker A: So for the decentralized oracle network, you may have the 16, or you may have 30 nodes under the network, and every different node will get the data or get calculated something by its own. And after all of this node gets a result, they will talk to each other just like a consensus algorithm, and then aggregate all the answers into a final report. And the don, the decentralized oracle network here, this guy will send this aggregated result back to the decentralized oracle network, and the decentralized oracle network can verify if this result is valid by checking the signatures or do some other necessary verifications. And if everything is fine, the decentralized oracle network will save the aggregated result into its smart contract that can be consumed by the other smart contract. So comparing to the single node oracle, the decentralized oracle network actually can of mimic the trust minimization that blockchain has. So they apply the trust, minimize the service into the oracle layer or we can call it a data delivery layer to make your oracle is just secure, just reliable and just data tamper proof like the blockchain and four replicas being run by the independent and CPU resistant node operators. That is the advantage of the decentralized Oracle network.
00:21:19.510 - 00:22:12.914, Speaker A: We can also call it Don. So the chainlink is kind of the decentralized Oracle network. And based on the Don we also provide some services including the data services and computing services. Under the data services we have a Chainlink data feed and Chainlink functions. With the Chainlink data feed you can just get the price of the particular asset from the external source and use this asset in your smart contract. And if you want to use some customer data like transportation data, like bank payment data, like temperature, you can use the chainic functions to get this kind of normalized data and enable your smart contract to consume this data. And for the compute you can use the chain viewer app to just get some randomness on chain.
00:22:12.914 - 00:23:45.896, Speaker A: And you can also automate your functions in your smart contract with the chaining automation. And all of these services are relying on the decentralized Oracle network. So decentralized Oracle network plus data and a computing service is chaining web3 services and chaining web3 services. Just connect the developer of the web3 apps to the different blockchains to the web, two, Lexus to anything you want. And you can just combine your smart contract with chain link Oracle network to just extend your smart contract to a hybrid smart contract and build the logic based on the data from the midworld. Okay, so before I'm going to cover the knowledge of the data feed from the chain link, I'm going to see the questions. So if an oracle node is centralized, what are security vulnerabilities? Yeah, if the Oracle node is centralized, it means that the centralized node could be attacked or exploited much easier than the decentralized network.
00:23:45.896 - 00:25:10.548, Speaker A: And if the data provided by a centralized oracle node is attacked or controlled, the decentralized application that relying on this centralized oracle node will be influenced very easily and the user of this decentralized application may lose a lot of money on that. It is meaningless for us to build a decentralized application, because the reason we want to use blockchain, we want to use a decentralized network, is that we want to use thousands of nodes in the network to promise our app is safe and transparent. But if the data feed part, the Oracle part, is centralized, it is meaningless for us to build a dedication in the decentralized network. Very good question. Thank you. What happens to data quality nature when it is decentralized? Do they all provide the same different data? Yeah. For the decentralized Oracle network, every node will have a node operator, and every node operator is a different company or different organization, and they will operate a node to get data or calculate something by its own.
00:25:10.548 - 00:27:08.380, Speaker A: So the answers may be different, and after they get the result, they will just use an aggregation algorithm. They just aggregate all the answers they get and to generate a final report. And maybe that is the median number from all the answers, maybe that is the average number from all the answers, and then they can put this final result to the onchain. Smart contract do you experience any hacker attacks on your oracles? And how do you prevent that for chaining oracles? We have not experienced any attacks and because we use a decentralized oracle network, so it is much harder for attacker to just control the data. Does aggregation have time complexity? It will have some, the different oracle node, we actually use the algorithm, very similar to the consensus, but it's much easier than the consensus algorithm used by the ethereum or other public chains. So it will cost less time and that is efficient for the different node to just gather other result and then to calculate the median of these other results and generate the final report. Okay, so let's continue.
00:27:08.380 - 00:28:19.362, Speaker A: And so we first start with chaining data feed for the chain link data feed. As I said before, if you are building something called define the decentralized finance, and there is a very decent chance for you to use chain link data feed because you need to know the value of the asset in your protocol. And in the data feed workflow, there is a part called chain link nodes. This is a decentralized oracle node. We have like 16 or 32 nodes under a decentralized oracle network. The DoM and every node under this network will get the data from the different providers, and providers will get the data from the other data sources. So after every node get the data and saved on the node, all the node in this decentralized oracle network will talk to each other and aggregate the answers into a final report and send a report to a smart contract, the chaining data feeder contract and the chaining data field contract is deployed by the chaining lab.
00:28:19.362 - 00:29:22.200, Speaker A: The smart contract will just verify the signatures and do some other necessary verifications to just certify the validity of the data. If the data is fine, the data of the price will be saved in this smart contract that can be used by can be consumed by the other consumer contract. So the data feed just enable you to consume the data of the price of the different assets and use this data into your consumer contract. So if you are building something related to the tokens related to the price, you need to focus on the price of the tokens. You will need a data feed. And if you want to take a look at our data feed, you can directly go to the data chain link and we have the different data node alive in the different networks. And this is an example.
00:29:22.200 - 00:29:53.342, Speaker A: This is a data feed for the ETH. You can see the ETH USD. And this oracles is a decentralized oracle network. We have the 32 oracle node under a network and every node will get the data as I mentioned earlier. And after every node get the data they will just generate a final answer. The final answer will show on the top left which is $1,282.6 for the ETH.
00:29:53.342 - 00:30:28.106, Speaker A: Of course that is older price and there are some other parameters I also want to mention. The first parameters is called deviation threshold which is 0.5% in the ETH USD. That means if the price of the Ethereum will automate more than 0.5%, there are going to be a new update for the ETH data feed. And the second parameter is called a heartbeat. The heartbit is usually the half hour or 1 hour.
00:30:28.106 - 00:31:24.602, Speaker A: And if the time this period of time expires there is a new update. No matter if the price of the asset is alternated more than 0.5% or not. If the time expires, there is a new update for the data feed. So from these two parameters you can see the data feed does not constantly update the price data on the smart contract because every time you want to write some data on the blockchain you want to update some data, you need to spend some gas fees. If we just constantly update the data on the smart contract, it will be very inefficient. And actually we can just go to this website to take a look at state chain link and in this website you can see there are different networks, Ethereum, Mainnet, Polygon, Mainnet and BNB chain, the arbitram.
00:31:24.602 - 00:32:42.914, Speaker A: And in the different network we have the different feeds like ETH, USD, the BTC USD. And when you click that you can see the exact same thing as I just shown in the slide the different oracle node under the decentralized oracle network and they will get a final report as this price and shown on the top left. And these are the two parameters I mentioned earlier and yeah that is chainic data feed. And let's continue. So where you can use the data feed as we talked earlier, the define is the most obvious and widespread use cases of the data feed. So for example, you can use data feed in the landing and a boring protocol because if you have a landing and a boring protocol in the blockchain, the users or investors of your project will collateralize some asset on your propco, on your smart contract and get some USDT or USDC or some other stable coins back. So in this scenario you need to care what is the value of the asset collateralized by the users.
00:32:42.914 - 00:33:40.682, Speaker A: If the user collateralized $500, they can only just get back no more than $500. So if there is something wrong with the data, with the price of the asset, the users will lose the protocol will lose some money on that. So that is very important for the protocol like landing and borrowing to know the true value of the asset, the AVI compound or Venus or using the chain data feed. And except for that, we also can use the data feed on the mirror asset. The original idea for the mirror asset is that the protocol can allow the users to treat some asset not only from the blockchain native asset, but from the web two world. Like the stock in the web two world. They can just mirror the asset in the web two world and to allow users to treat that.
00:33:40.682 - 00:34:30.970, Speaker A: So that is also important for them to know the real value of the web two asset. And also for the stable coin, you can use the data feed to decide what is the value of the asset collateralized on the protocol and to decide how many stable coins can be issued based on this asset. So you also need a data feeder to know the value of the collateral asset and also for the asset management and options and the future. You can imagine how important the data of the price of the asset is imported for this kind of use case. Yeah. And next I will do a demo to show you how to use the data feed in the remix. And that is pretty simple.
00:34:30.970 - 00:35:50.420, Speaker A: If you have the laptop with you, you can just try with me. Okay. Before I do that, I can see if there is any questions I need to answer. Can we pull data points every minute? Do you mean that you want to just get the data in a very short time. Actually from the smart contract you just cannot get the data in a very high frequency because the data can only be updated for one block generated and for every block there are going to be a time, maybe the 1 minute or maybe the 30 seconds for a new block generated. So it is very difficult for you to get a price every second, but for every minute maybe possible. What if the data source for all chain link nodes become C? We have someone to carry about that.
00:35:50.420 - 00:36:48.754, Speaker A: I think it's quite expensive. If Chainlink provides data on Ethereum main net, how chain link handles that? Yeah, as I said before, there are two parameters. We just don't constantly update the price. Only if the price is alternate more than the threshold or the time of heartbeat expires, we just do the update. But for the other cases we just don't constantly update the data. Okay, yeah, there are a lot of questions. So I only have one and half hour today, but for the slides I only complete the data feed.
00:36:48.754 - 00:37:32.100, Speaker A: We still have the chain link functions, chain link VRF and chain link automation. So I will first do the demo and at the end if we have more questions we can stay here and I will answer all the questions. So let me first do the git feeder demo and if you want to do the demo just try the chain link product. You can go to the docs chain link, that is a chain link home for the developers. We provide the details of all the services. Here you can see the first one is a data feed and click that. You can see from the left panel your content.
00:37:32.100 - 00:38:29.334, Speaker A: Go to the using data feeds here and we have a sample contract and copy that sample contract and open the remix. For those who don't know about remix, the remix is an online IDE for solidity code. And in the remix just click the create. Not this one, for this one, create a new file here and we can call it data feed, sample solidity and paste all the codes into the remix. Let me close that. Yeah. In this smart contract there are something you need to care about.
00:38:29.334 - 00:39:59.170, Speaker A: The first one is in the constructor. We need to give the smart contract the address of the price feed you want to get for this one. That is price feed for the USD which will give you the price of the BTC. But if you want to get the price of the other assets, you can find the different addresses in the documents in here. The price feed addresses. If you click this you can see there are a lot of the public chains, ethereum, BnB chain, the polygon and all the other public chains and under the different public chains you have the different pairs and related address and you can first decide which chain you want to use and then to see which price of the asset you want to get and get the correct address and then input this address in the constructor to create a new aggregator interface. And after you get this interface you can use that in your functions and maybe you are building a defined protocol, you have some other functions in your smart contract you can still use the same thing to first instantiate an aggregator v three interface and give it a cracked address for the data feed and then use this interface to get the latest data.
00:39:59.170 - 00:40:42.750, Speaker A: The function is called the latest run data because the price data is updated by round. So in every round there are several data. First one is a round ID, you don't need to care about that. And the second one is a price and the third one is started at, which means the timestamp for the round ID and all the other details. But in this example we only care about a price. So we can only write a price here and it will be fulfilled by the price feed we just created here. So yeah, we are using the supportia which is a testnet of the ethereum.
00:40:42.750 - 00:42:16.590, Speaker A: So if you do not have the tokens, if you do not have the Ethereum or link in the testnet, you can go to the faucet here and in the faucet chain link to select the Etherma supportion and write your valid address. To make this two checkmark and log in by the Twitter 1 second and authorize the app. And then to check this I'm human to pass the verify request computer keyboard, not this one. Yes. Okay and send a request and after you send a request your wallet will receive the 20 test link and 0.1 support ethereum because I have already got enough tokens so I will not wait this complete and in the remix let's switch back to the remix and after the smart contract is complete and you can go to here compile the data feeder sample and everything is fine. There is a green check mark here and after it's compiled you can deploy this smart contract to the testnet.
00:42:16.590 - 00:43:13.554, Speaker A: Before doing that, select injected provider. When you select this option it means remix will use your metamask rather than a local virtual machine. So click deploy and your metamask going to pop up and click confirm. Yeah, I think we need to wait for about 30 seconds. The contract deployment is processing. Yes, after the smart contract deployed successfully, the price consumer V three and we only have one functions here. It's called get latest price, which is this one.
00:43:13.554 - 00:45:05.980, Speaker A: If I click this button, the functions will be called and the price will be returned. Let me click that. See, this is the result. Let me just remove my face from the screenplay. Can you guys hear me now? How about nowhere? Okay, thank you. Thank you very much. Yeah, I don't know how to just remove the image.
00:45:05.980 - 00:45:47.092, Speaker A: Okay, so you need to see my face. I'm sorry about that. Okay, let's move to the second one. The chaining functions, the training functions is in data. And the chaining functions are quite a new service. We just released this service since last month right after the if Denver and chaining functions is a service to enable your smart contract to reach out and make an API call to the outside world. And for the chain link data feed, you can get a price of the particular asset.
00:45:47.092 - 00:46:29.284, Speaker A: You can get normalized data from the chain data feed. But if you want to get some unnormalized data, if you want to get some customer data, maybe you want to get a weather and flight data to build a web. Three parametric insurance. For example, if the people just buy the insurance from your protocol and if the flight is delayed, they can get some payout. They can be offered some payouts. And how do you do that? You need to get the flight data from the outside API and then trigger the functions in your smart contract. But from the data feed you cannot get this custom data, you cannot get anomalized data.
00:46:29.284 - 00:47:27.108, Speaker A: This niche data cannot be fetched. But with the chainx functions you can use the same don to fetch the data from the API in the webtoon world and to fulfill into your smart contract. This actually enables a huge number of the use cases. For example for the weather and flight delay data you can build insurance and you can also get a greenhouse gas emission data to just generate some carbon asset for the market. Because most likely you need to use IoT to track what you do and your activity. And if this iot device have an API, you can use the chaining functions to get the data from the API to get a greenhouse gas emission. And you can also get election and sports data for the prediction markets and for the dynamic NFT.
00:47:27.108 - 00:48:17.276, Speaker A: That is my favorite. And also for the asset and micronomic data, you can just do some RWA which is very popular today, the real world asset, you can get RWA and increase the liquidity of the assets. So with the chain functions you can just extend the ability of your smart contract not only on blockchain but also for all the data you can get from the web two world and this is the chain function workflow. The chaining function workflow in this graph you can see here. This one is Don, the decentralized Oracle network. That is the same thing supporting the data feed. There are a lot of the oracle node under this don.
00:48:17.276 - 00:49:30.160, Speaker A: And when you create a request from your smart contract and you can write your request with some programming language like a JavaScript, you can use the JavaScript to write your request and use the smart contract to wrap your JavaScript code and any other necessary data into the request and send this request to the chaining function smart contract. The chaining function smart contract will check if you have enough balance and do some other check and if everything is fine. The chaining function smart contract will save your send request into the event. And the data in the event can be taught by the DLN. The DLN will just make an API call using the data you wrapped in your request and to get the data from the API providers. And then after every node get a result, they will do an aggregation like before like the data feed and fulfill this result back to the smart contract using a fulfill request. And after that you can get the data from the API providers.
00:49:30.160 - 00:50:06.830, Speaker A: And the beauty of this is that as a developer or as a builder, you can only focus on this smart contract. You can only focus on your consumer smart contract. You don't need to care about all of this. The server setup, the configurations, the chaining functions will take care of all of that. You just need to write your request in the JavaScript and send a request. And then wait a second, you can get a result back to your smart contract. This will just help developers to have a higher efficiency and save a lot of time.
00:50:06.830 - 00:51:29.716, Speaker A: And in order to show how powerful the chain link functions and show some use cases in the chain link functions, we create a website called usechainlinkfunctions.com. If you're interested in how to bridge the web two data and services into the web3 smart contract, you can just go to this website and check the use cases on there and you can see that we can use chaining functions to connect your smart contract to the AWS data exchange. The AWS data exchange is, as far as I can see, is the biggest API data marketing in the world. It includes some marketing data, includes transportation data, gaming data and sales data. You can just connect your smart contract directly to this API with the chaining functions and it actually allows you to have the connectivity and the flexibility as any web two app has today. So just check that and you can also send the request to the Twilio to just use your API to send notifications not only for the web two users but also for web3 users and also for the Google Cloud bigquery and meta NFT giveaway. And yeah there is a lot of the use cases and just go and check it.
00:51:29.716 - 00:52:40.488, Speaker A: And for the training functions we also have a master class for the training functions it's in the May 2 I think should be let me see three days later and my colleague will give the master class on the chain function. He will show how to use functions with the hard hat on how to use the chain functions to send the notifications through Twilio to the artist who is on the Spotify. That is a very cool use case. Just react is turnout and to see the master class of the chaining function. And for now I just want to do a very simple chaining function demo and to show how everything works. But for more complex use case and for more use cases use a website and learn the master class. So in order to use the chaining functions, first you need to go to the GitHub smart contract kit and this is the official repl of the chaining labs.
00:52:40.488 - 00:53:49.888, Speaker A: And in the repositories you just search function and there is a repo called functions hardhead starter kit. The reason we want to use a starter kit is because the chain function is relatively new. So we do not have a UI for the chain functions on the website. So we have to use JavaScript code the hard hat to standard request standard transactions on our behalf and to try the chaining functions and click that in the code here. Just copy this link, the HTTPs link and go to the terminal. Let's zoom in the terminal. Okay use a deep clone this link to just clone all the codes into your local and you will have a new folder called chaining hard head starter kit and go to this folder.
00:53:49.888 - 00:54:41.280, Speaker A: Use NPm install to first install all the dependencies defined in the package. Json let me see the question. We cannot follow this demo unless our wallet address has been whitelisted correct? You have to be in the whitelist and if your address is not in the whitelist there will be your notification when you try to use that on the testnet. But it is very easy for you to get you in the whitelist. You just send a request and you will be in the whitelist. Maybe after one business day. Please answer my question.
00:54:41.280 - 00:55:38.432, Speaker A: So what is your question? Sorry if I call the API due is for actual transaction on chain. So if every transaction costs more than $4. There is $16 for API response. If that was on the Ethereum main net it is financially feasible for this question. If you want to let me understand your question. Actually you will not have four transactions on chain because you send a request to the smart contract of the chain function and this function will be get or be fetched by the don. And there are a lot of the node under the don and every node will make a request to the API and get a result back.
00:55:38.432 - 00:56:51.716, Speaker A: And all of this is off chain and there is no transaction for this process and only after the node aggregate the result and write it back there will be a transaction and you need to just fund your subscription and the balance can be consumed by the deal. And that is not expensive. I don't know if I answer your questions and if you mean that the gas fee is expensive on the Ethereum main net, that is a problem. But we cannot solve that because in the Ethereum there are a lot of the nodes, thousands of nodes. So every computation or the transaction on the ethereum is very expensive. And maybe the new technology in the future will solve this problem, but that cannot be solved by Chainlink. And of course, the reason we use Ethereum is because we want our protocol or we want our app to be safe and reliable.
00:56:51.716 - 00:57:57.520, Speaker A: And the safety and the reliability depends on the cost. If the transaction costs more, the reliability and the safety is kind of relatively more safer and more reliable. You it and what kind of aggregation happens when a get request simply return a JSON? You need to just get what you need. In the JSON there are going to be a path because in the JSoN there are a bunch of information. You need to know exactly which piece of data you are needing for your smart contract and exactly get that piece of the data. Okay, first let me just complete this demo and I will answer the question. NPM version seven.
00:57:57.520 - 00:58:41.366, Speaker A: Let me see my NPm version. Yeah, it should be more than seven. Okay, so for now you get everything you need and go to the repo. You can see there are instructions how you can use this repo and you can also go to the documents here. Remember, if you need any information, if you need any details of the different services provided by Chainlink, just go to the document website. It will solve most of your problem. And the second one you see here is the chaining functions.
00:58:41.366 - 00:59:31.722, Speaker A: Go to the chaining functions here. The getting start. Yeah, the node operation should be the 18 and git clone and change directory to the folder. You just git clone and use NPM install to install the audit dependencies. And next it help you to just set the credentials in the hard hat because the hard hat will send transactions on your behalf. So it has to know your secret key and it has to have RPC to the node, maybe the polygon Mumbai, maybe the supportia, maybe other testnet. You need to get these two things, the RPC URL and the private key.
00:59:31.722 - 01:01:21.550, Speaker A: And I have already prepared these two credentials and we'll input through the command line. So first I'm going to input this command mpx env and set password that will give it one, two, three, but don't use this password in the production. And next I need to set these two variables. The first one is a private key and if you don't know the private key go to the metamask here and go to this one and account details. There is a button called export private key. Input your password here and the metamask will show the private key to you for the use case for the test or for something you want to try, just use a new wallet and do not receive any real asset into your test wallet and a private key. I've already got that and we'll put it here's my private key and the second one because we are using the sapolia, we need to set this environment variable called Sapolia RpC URL and also I have already got my sapolia URL in advance and everything is fine.
01:01:21.550 - 01:02:16.830, Speaker A: And if you don't know how to get the RpC you can go to a website called alchemy.com and sign in. It will give you the different options to get the RPC URL into the different testnet just like this. Okay, let me switch back to my terminal so everything is fine. Let's go to the documents here. So we have already set our environment variable and the next is to compile all the smart contract NPX hardhead compile. There are a bunch of information, but don't worry, they are just libraries and dependencies and the files is compiled or compiled successfully.
01:02:16.830 - 01:03:15.300, Speaker A: And let's see the tutorials. You can see under the tutorials there are a lot of things. The first is the request computation. In this first one we will just request the decentralized Oracle network to just execute our job because we write our job in the JavaScript and we send our request to the chaining functions and the chaining functions just put it in the event log which can be calculated by the DoN and then the DLN read back to the result to the smart contract and the second one is call an API just the way talked earlier. We can use the chaining functions to call the outside API and the third one telling you how to just encode the different types of the data. And there are a lot of things here if you are interested in that. You can just read these tutorials when you have the problem.
01:03:15.300 - 01:04:03.810, Speaker A: And I will just demo the first one because I want to save some time. It's already nearly 1 hour. So in this hardhead repo we have the different branch. For the different tutorials we use a different branch so we need to first check to the tutorial one and let me open that code. Sorry, use the Vs code to see this architecture and this one is environment variables. We shipped just by using the env Unc command and there are two things you need to care about. The first is under the folder contract.
01:04:03.810 - 01:05:08.342, Speaker A: Here is a smart contract called function consumer and you can see under this smart contract there are two functions. The first one is called execute request. That is this thing here. The send request is the execute request. When you call this execute request and input the source, the source is your JavaScript code and the secrets is the credential information and other arguments and the subscription id and the guest limit. It will send a request to the chaining function smart contract and after the smart contract put this request into the event log and calculated by the DLN. The DLN will fulfill the result back to the fulfill request this function and if you have some customer logic you can just write your customer logic under this function.
01:05:08.342 - 01:05:49.098, Speaker A: And after the function consumer smart contract get the result. The result can directly be consumed by your logic. And the other thing you want to see is that in the function request source, this is the job you want dun to execute. It's called a function request source. And actually for this one it actually calculates the geometric mean of the arguments. And the arguments is let me check. Switch back to the document.
01:05:49.098 - 01:06:52.290, Speaker A: The argument is 123456 to ten and the job is to calculate the geometric mean of these numbers and everything is good. Let me just simulate that. Sorry. In this one, the simulation and without send this request to the blockchain. You can simulate on the local and you use this command, the MPX hardhat function simulate and paste here to just run that you can see the hard hat. Just simulate everything will be happened on chain and write the result back. The result is 453 and you can also use some other command to just create a request and just create a subscription and put some balance in the subscription.
01:06:52.290 - 01:08:14.850, Speaker A: And then to send the request in the real testnet, but I will not do that today. It's time consuming. Let's move to the next one and let me see that. Questions there are quite a lot of questions. First one is has chain link data feeds experienced any trouble when providing data feed to certain defiance before? The answer is no. That you can search the news and search anything you want and you will not find any attack on the chain data feed. I'm using the Polygon Zkebm for why not seeing the first transaction sent by the vitality as one of guests of the launch ceremony? Hope to see it.
01:08:14.850 - 01:09:19.960, Speaker A: Yeah, in the future we will integrate all the service into the different public chains and Zkevm is a future, I know that. So let me first complete all the content here and then I can answer the questions. So next is computing service. So we've been talking about the chain data services for the data feed and the chaining functions. But we also provide some computing service like chaining VRF and a chaining automation. The chaining VRF, you can get a randomness on chain for your NFT or maybe some other decentralized application. And for the automation, I'm sorry, you can use it with your smart contract to automate your functions in the smart contract and I will cover what kind of the use case this service could be integrated.
01:09:19.960 - 01:10:20.364, Speaker A: Okay, the first one, the chaining VRF. VRF stands for the verifiable random function in the VRF. Why we need VRF? Because from very recently getting the randomness on chain is still an issue. In the previously conventional way of getting a randomness on chain is rely on some on chain thing like a block hash or some other information on chain. So that is very expensive for the smart contract to get this random number. And actually this on chain stuff could possibly contribute by the miners if the miners have more than the 51% of the computing resources and a mining resource. And if you don't want to use on chain thing, you can use a centralized application centralized server to provide you a random number.
01:10:20.364 - 01:11:20.392, Speaker A: But you know that this way is not that safe, not that decentralized, not that transparent. If you rely on the centralized server to give you a random number, if the random number is controlled, actually your smart contract is influenced easily. So for the chaining VRF, we just combine the onchain thing with the off chain oracle. The off chain oracle will get a seed from the onchain and use a private key and algorithm called VRF to generate a random number and a proof. So these two things will be sent to onchain smart contract called the VRF smart contract. The VRF will then verify this randomness is the true randomness by the proof. So from this way you can just get a randomness, the true randomness from the oracle.
01:11:20.392 - 01:11:58.772, Speaker A: Because in the buf there is one seed, one result that is a one two one algorithm. So the oracle off chain cannot generate as many of the random number as by its half. It can only generate one random number with one seed. But this seed is on chain and is public. This VRF will help you to open up a huge number of use cases. As I said earlier, the chinic VRF is widely used in the NFT ecosystem. You can use the Nft to just mint nft with the random trees.
01:11:58.772 - 01:13:05.452, Speaker A: For example, there is a project called the axe infinity and you need to first mint axe and then use axe to play to earn from the very early stage of the axe. Use chain viewer app to generate some random treats for the NFTs and also for the NFT like board, AP, yard club and the project. Use randomness to just airdrop some NFT to the holders. And except for the NFT creation and distribution, the VRF can also be used in the raffling and the fair selecting. If you have ideal platform, you want to assign the opportunities to the different people in a whitelist or something like that. You can use VRF to generate a randomness to decide which user is lucky ones or which users are not that lucky. And we have a block here to just introduce 32 use cases.
01:13:05.452 - 01:14:00.400, Speaker A: If you are interested in the use cases of the chain VRF, just go to the block of the chaining to check more details and then let me do a demo for the VRF services. So first, just as before we go to the documents here and the chaining VRF is. Let me refresh the page. This is a chaining VRF V two. That means the chaining VRF is a version two and in the chain VRF go to the get a random number and you will have a contract here. Let me copy that contract and switch back to the remix in the file. Create a new one called VF.
01:14:00.400 - 01:15:15.860, Speaker A: Sample solidity and paste all the code here and in this smart contract just as we do in the chain functions, there are two functions you need to take a look at. The first one is request random words. Remember how we interact with the Don before. We need to first send a request through the contract and when the don gathers a result it will use fulfill use fulfill functions to feed the result back to the consumer's smart contract. So in the VRF you send a request by this function and you will receive the result by this function. And if you have some customer logic you can write your logic under this transaction. Maybe you can write the NFT minting process in these functions and the users can mint NFT randomly and get some random yeah, and we also have some configurations.
01:15:15.860 - 01:16:04.710, Speaker A: The key hash which is a gas lane. This is a maximum gas fee. You allow the chaining do into use for your VRF. If you needed the VRF in the very short time you can select high gas fee, the high gas land and if you don't care about that you can select some of the select a gas land with a low gas fee. And what is that? Let me give you an example. The supported network, it's called gas sorry. Oh it should be this one.
01:16:04.710 - 01:17:06.012, Speaker A: Yeah. Here for example in the ethereum main net there are three options. The 2200 degree, the 500 degree and 1000 degree. So if you select this key hash, the maximum gas fee you allow the do n to use is 200 degree and if you set this one that is 1000 degree and for different testnet we are using this one because that is only a test net. So we only have one options here for the 30 grade for the supported testnet. That is the first one you need to care about and the second one is a callback gas limit that is a maximum gas limit you allow the do and to use to fulfill the randomness into your smart contract. And this is the number of words means how many random words you want in this request and to input all the configurations in the constructor and you can use that.
01:17:06.012 - 01:18:17.620, Speaker A: And because we are using a supporting and testnet so we can use the same configuration and then let me compile that in the deployment tab you can see that we need to have a parameter for the constructor which is called a subscription id. What is that? As I said before, every time you want dun to help you to get a data or help you to calculate some results, you need to pay for the Dun. The way you pay for that is you need to create a subscription and put some balance into your subscription and then add the consumer add this contract into the subscription. So I will show how to do that. So first go to the let me close that first go to the VRF chain link and this is the UI for the chaining VRF randomness function and go to the create a subscription and this is your address. It will read the address from the metamask and then create a subscription. The metamask going to be going to pop up and confirm.
01:18:17.620 - 01:20:15.330, Speaker A: We need to wait for a little time for the transaction and the UI need to detect that. Okay, after the subscription is created and I need to add some fonts and I need to add ten links into the subscription. While I'm waiting I will answer some questions. So if we choose 1000 GUI we will have a priority to generate to get our VRF from the training oracles compared to others who pick the 500 GWE. Actually for the VOF service the Don will send fulfill the result back to the smart contract when the average gas fee on the public chain is below the gas line you selected. If the average gas fee for the Ethereum mainet is about 200 gray and no matter 1000 or 500 gray you choose, the chain viewer app will fulfill at the same time. So how fast do you receive? The fulfillment does not depending on the priority of the chain view app, but based on the gas fee of that public chain you are using.
01:20:15.330 - 01:21:22.116, Speaker A: Okay add a comment consumers because we have not deployed our smart contract yet. So we do not have a consumer address yet but we have an ID for our subscription. That is 1598. That is our subscription ID and we just need this Id to deploy our viewer app smart contract to paste the ID here and click the deploy it and then just click confirm. Yes you it. I made a pull request for use training functions. Can you provide a review of that? Yeah, I can do that.
01:21:22.116 - 01:22:45.680, Speaker A: Just send me your PR and I will ask the owner of the repo to review that and just complete that PR. You can find me in the discord and you join the chain link discord and you can just put the information there and I will see that. Okay so our viewerf consumer is deployed successfully and we can see there is a bunch of the functions and also we have address of this contract and copy this address and input this address in our VRF subscription and here to copy that add consumer and confirm and we need to wait about 30 seconds. And in the future you can use the chaining functions. In this way you can just have a UI to create a subscription and fund this subscription and add consumers. But for now the UI is not completed. So the better way to use the chaining functions is use the hard hat starter kit.
01:22:45.680 - 01:23:58.448, Speaker A: Okay. The consumer is added successfully. So you can see that we have a consumer here which is a smart contract we just deployed and this is a history that we create our subscription and fund it and add a consumer and then we can just request a random number here. So the function is this one remember what we see request the random words when we call these functions, the smart contract will send a VRF request. Just click that and confirm. And after this request is made so the request should be saved on the event log and the event log can be called by the don here and we should see the request here. Let me refresh the page and see we have a penny request.
01:23:58.448 - 01:24:54.436, Speaker A: This is the VoF request we received and the don will just calculate the random number and write it back to the smart contract. But it is pending for the 22 seconds because the VRF need to wait for a new block and find a time slot to send this result back to the smart contract. And how we see this random number we will have a request ID here. Say this one every time when you make a request into viewerf the VRF will give you a request ID and copy this request ID into this one. This one is a get request status. Actually this request is fulfilled and the fulfilled is true. And this one is a random number returned by the chaining vf.
01:24:54.436 - 01:25:43.800, Speaker A: It is array of the uint 256. So there are two elements in the array. The first one is this number C and here is a comma and the second one is this one. So by this we get a two random number from the view f and if you want to have some cosmologic you can directly write the logic under this function. So cool. And let's move on to the last one I'm going to cover today. The chainlink automation the chainlink automation is another web3 service provided by chainlink to just allow the users to automate the functions for your smart contract.
01:25:43.800 - 01:26:50.044, Speaker A: And the chainlink automation is also relying on the don, the decentralized oracle network, the same mechanism as before. The don will just check the conditions defined in the smart contract. Yeah, you need to write some predefined conditions in the smart contract. If the conditions is met and the smart contract will check it and find that it's matte and to use a upkeep registry to send a transaction to the upkeep smart contract. That is the user smart contract to trigger this function. So the thing is like that, you first will just write some conditions in your smart contract and when these conditions are met maybe that is a time, maybe that is based on some outside data and the dom will get this conditions status. If that is yes it will trigger the functions you define in your smart contract.
01:26:50.044 - 01:27:56.724, Speaker A: But if the conditions is not met yet, it will change to a new node in the dun and check the conditions in the next block so that is how the chain automation works. So you can rely on the off chain smart contract and to just automate the functions in your smart contract in a secure and very reliable way. And where I can use the chaining automations in the use case the first one is actually there are a lot of the use cases and it opens a lot of the use cases in the web3. And the first one, maybe you can use the chain automations to do a yield harvesting and a compounding. Think about the scenario, you just stake some asset on the protocol and you will get some yield for every hour or every 2 hours or maybe every two days. You need to claim your yield and reinvest in your staking. And by this way you can increase your money in a compounding interest.
01:27:56.724 - 01:29:00.530, Speaker A: And if you use the chaining automation to just automate the functions, you can just do it periodically and with a full commitment. And also you can use the chaining automation in the dex limit orders as we all know, in the dex there is not a trading engine to watch if your order should be taken or not. In the decentralized exchange, the automatic market maker is used and AmM is actually approved. Contains two types of tokens and the ratio of the tokens will decide the price of token. So if you want to say like buy a token when the price of it is dropped from fifteen dollars to ten dollars, and you can write this logic in your smart contract and set it as a predefined condition. And when this condition is met, the chaining automation will just trigger the functions of the smart contract and to make your order be taken by someone else and also for the liquidation. When.
