00:07:15.900 - 00:07:34.624, Speaker A: You test, test, testing, testing. Is that better? Did I fix it now test. There we go. Sorry about that, guys. Now there's sound. Cool. Yeah.
00:07:34.624 - 00:07:51.450, Speaker A: So we're really excited for this workshop today. We are doing a full stack blockchain application end to end. We're doing front end and back end. This was definitely really highly requested. We're really excited to be doing this. We're really excited to be working on this project. We have a couple of different ways that we can go with this.
00:07:51.450 - 00:08:25.140, Speaker A: Similar to how on the back end, we can use hard hat, we can use truffle, we can use brownie, we can use all these different frameworks on the front end. It's the same thing. There's way more frameworks than what we're going to go over here and we'll kind of go over a couple of different examples to get you spun up with the front end really quickly and get you guys going there. So it is 804. We have a lot to cover in this, so let's go ahead and jump right into it. Boom. Cool.
00:08:25.140 - 00:09:15.190, Speaker A: So let me show you first what we're going to be working on today. So we're going to be working on something like this. It's an application that allows us to stake our different tokens so we can stake. These are kind of the different tokens that we can stake and then we can also get issued rewards based off of how much we've staked. So if you guys have ever seen anything like getting mad echo now though, let's see if we can fix that. Better, worse test. See if we can fix that.
00:09:15.190 - 00:10:16.612, Speaker A: Did I ruin it? Actually better works. Yeah, that's super strange, actually. Hold on. Is it better now? I don't want to keep going if I'm still echoing. Did I fix it or is it still whack? Some quick audio issues here. Looks like I fixed it. Okay, cool.
00:10:16.612 - 00:10:35.608, Speaker A: All right. Thanks for pointing that out, though. Appreciate it. All right, let's get back into it. So here's what we're working on. It's an application that allows us to stake our tokens and then get issued rewards for it. So here we can see like up in the top, right, we have a reward balance.
00:10:35.608 - 00:11:36.812, Speaker A: And this is similar to like if you've ever seen, you Guys have probably heard of liquidity farming or yield farming or liquidity mining or whatever. This isn't necessarily that, but it's more just giving some type of reward token based off of how much somebody has invested in your platform, right? For example, if you are having an Ave or a uniswap or something, right? And somebody has $100,000 invested in your application. You can give some type of governance token or something like that based on the value that they have in. And that's actually the important part of this tutorial, is that it's actually based on the value. So our fau token, which is like our fake kind of dummy faucet token, is going to pretending to be like dai, basically. And then chainly token is obviously going to be link. And then we're going to have our DAP token, which is also going to be like a sort of die.
00:11:36.812 - 00:12:09.608, Speaker A: So this tutorial is inspired by DAP University. If you guys haven't seen him, definitely go check it out. He are a sponsor of this hackathon and they have a lot of fantastic videos here. So they're the inspiration for this. But without further ado, let's jump in into building this and let's talk a little bit about the different front end approaches that we can take. Okay? So before we actually even dive in. So I'm a big fan of this package, create Eth app.
00:12:09.608 - 00:12:46.740, Speaker A: So after you guys do all your back end stuff, you do your brownie, you do your hard hat, you do your truffle, whatever. After that you use create ETH app to actually create a front end. And a lot of projects, you guys have probably seen this too, they do this in a separate repo, right? So they have one repo for the back end, one repo for the front end. In our demo here, we're going to do everything in the exact same repo. We can even look at front end and the back end are going to be in the same repo. If that makes your life easier. Absolutely, go for it and just put everything in the same repo.
00:12:46.740 - 00:13:19.296, Speaker A: You don't have to do two repos, but it can be a little bit nicer to separate the two, have them in two different repos. But for developing, it's usually a little bit easier to have them in the same repo here. So that's just kind of a little note there. Another note is that if you're really struggling, there are a couple of crutches you can use to build up a front end. One click. Dap is. Is a really nice know.
00:13:19.296 - 00:13:53.892, Speaker A: I think you log in with Metamask, you connect Metamask. Yep. Sign in. And what you do, actually once you sign in is you just add like the name of your Dap, a description, Abi, contract, address and network, and it'll kind of spin up a really easy front end for you. So that's what I'm going to say. First off, if you know nothing about front end, know nothing about Javascript, nothing about any of this stuff, one click dap is a really easy way for you to get started. Create ETH app is going to be a little bit more advanced.
00:13:53.892 - 00:14:36.200, Speaker A: It creates a react js front end boilerplate for us to kind of go in and modify. This will give you all the bells and whistles. This will kind of be a little bit of a crutch. And of course you can always use scaffold eth. This is almost like the midway solution where you can just add your contract to his contracts folder and then on your front end in the react app. I believe he has a contract section or no, sorry, not the contract section. Maybe it's an app JSX.
00:14:36.200 - 00:15:20.836, Speaker A: You can add your contracts in here and that will actually have them render on his scaffold eth bit. But we're not going to go into that. One other example that I wanted to show you guys just because I'm pretty proud of it and it's really silly, but it's really fun. I have this one. This is an example of a front end I created with crate eth app. It is the VRF pizza front end. If you're looking for an example of doing a front end in a separate repo outside of the one that's in the back end.
00:15:20.836 - 00:15:41.980, Speaker A: So this is the back end. This is the front end. The back end is written with brownie, as you can kind of see here. And the front end is with this create eth app. And you can see like it has all the boilerplate of create Eth app. But if you guys want to check those out as an example, you absolutely can. For kind of a different example.
00:15:41.980 - 00:16:44.864, Speaker A: And this one create eth app actually uses this vrF pizza front end, use crate eth app like I said, and create eth app actually does like state hooks and does a lot of the newer react stuff where the example we're going to be going over isn't going to be doing state hooks or any of that newer stuff. So you're going to get a couple, there's a ton of different examples here for you to check out. And the other thing you can do is all this stuff is open source, guys. So this is like actually one of my favorite parts of the blockchain world is like everything is, everything is open source. So you can look up like front, maybe not. Yeah, this is like the uniswap front end right here. Right? So you can just fork this copy, paste it, whatever you want to do.
00:16:44.864 - 00:17:09.188, Speaker A: And you can see the front end of all these other applications. So all this stuff is open source, which is amazing. So if you ever want to just check out somebody else's front end, you absolutely can. And without further ado, let's learn how to do this. Let's get this started. So I'm going to kill it on my end over here. Going to refresh.
00:17:09.188 - 00:17:35.232, Speaker A: And we're going to be starting from blank. Let's do this. Are you guys with me so far? We're going to be going over a lot of stuff here. Okay, cool. So let's get started, right? And a lot of our examples have been using truffle. Let's just continue to start there. Right.
00:17:35.232 - 00:18:09.628, Speaker A: Let's do truffle and box smart contract. Kitbox, get started. Just getting a sample box in here. And again, if you want to use brownie, if you want to use hardhead, there are examples for both of those as well. So let's get it going. Let's do our contract sections first. And once we have our contracts up, once we have our contracts kind of being built, we can start doing the front end, right? Because we can't start doing the front end until we have the back end kind of up and going.
00:18:09.628 - 00:18:49.380, Speaker A: So let's even just really quickly again, look at what we're trying to accomplish here. What are these contracts trying to do? So we have a contract that's going to be taking tokens, right? We're going to be sending tokens to this token farm, to this staking contract. We have a reward token, like a DaP token here that we're going to be giving back to people. And do we need anything else or are those the only two that we really need? That's really all we need. We just need those two pieces because we can use existing tokens. We can use like the existing chain link token. We can use the existing faucet token, which we're going to pretend it's dai.
00:18:49.380 - 00:19:34.920, Speaker A: A lot of people are often asked, hey, I'm looking for a die faucet. I usually just use what's called faucet token. I just pretend it's die. So they just give you like ERC 20, you can just pop in your address here. Amount ten connect metamask mint free tokens. And you get this thing called faucet token. So if we look in your metamask, once we mint it, we'll get ten more fau so it looks like it just confirmed.
00:19:34.920 - 00:19:56.892, Speaker A: So now it's 1858. So this is what I use. Instead of like a die faucet, I just use this faucet token. So this is all we need. We just need two contracts. We need a contract that allows us to do all this staking and then we just need a simple ERC 20 to give rewards back. Now, we also are going to want this platform to issue rewards.
00:19:56.892 - 00:20:22.004, Speaker A: So that's going to be another functionality. So we need to stake, we need to unstake, we need to issue some rewards. And that's really it for the most part. We don't really need too many other bits. We do need to kind of allow the specific tokens that we want. So we do need to allow the addresses, but that's really it. So I'm going to kill this.
00:20:22.004 - 00:20:42.764, Speaker A: And now we're going to start from scratch, now that we kind of know what we're doing. So let's jump in here. So we have our contract section, we have a whole bunch of boilerplate in here and we have a whole bunch of boilerplate scripts, whole bunch of boilerplate migrations. I'm just going to go ahead and kill all this stuff. Goodbye. We're going to start from absolute scratch scripts. Yes.
00:20:42.764 - 00:21:22.264, Speaker A: We're just going to start from scratch. Here are smart contracts in this box audited? No, they are not. These are created as is. So we're just going to get rid of all the scripts. We're going to get rid of the tests, too, with the trash and cool, and we'll even get rid of all the migrations. So we're starting from pretty much scratch here. Okay, we'll leave the test for now.
00:21:22.264 - 00:21:58.150, Speaker A: So let's go ahead and create our first, the easier part of this demo, which is going to be the DAP token. Right? This is just going to be an ERC 20. Right. And if you guys have followed along with some of the tutorials so far, you know, pretty much the easiest way to create an ERC 20 is just using open zeppelin. So we're going to do pragma solidity 0.6.0, we're going to import open Zeppelin. I'm actually going to copy paste here so I get it right.
00:21:58.150 - 00:22:28.332, Speaker A: And again, open Zeppelin UC 20. If you guys check it out, Zeppelin, it just imports some really standard open zeppelin code for us so that we have a really easy way to create an ERC 20. Sorry, actually, we're starting from scratch, so this will be empty. Yes. Okay, cool. Once we've imported from open zeppelin. Our ERC 20.
00:22:28.332 - 00:23:07.416, Speaker A: We can do contract token, we inherit it is ERC 20. We'll do constructor public ERC 20. All we need to do is give it a name and a symbol. We'll call it DAP token and we'll give it a symbol of Dap. Dap it up. And then we just call this mint function. So all this syntax that I'm doing, you can check out the opens up in the documentation to learn what this looks like.
00:23:07.416 - 00:23:43.576, Speaker A: But this is really the easiest to set up an ERC 20. So we're going to mint two message sender, they're going to be the owner and we're going to do a big, I'm actually going to copy paste this too. A large amount of for the initial supply. So if we go 123-4567 810, the initial supply is actually, what is this, a million? Initial supply is a million. Right. Because remember this is like in way. So those are there and that's pretty much all we need for our contracts here.
00:23:43.576 - 00:24:23.720, Speaker A: So let's do a quick truffle compile, see if this worked. Looks like we ran into an error. Let's figure out what the error is. Can I find module? Okay, I should probably install stuff. Install with urine. So this is going to install all this stuff that you see in package JSon and get us going here. Now I am going to be skimping a little bit on the tests in the interest of time.
00:24:23.720 - 00:25:12.134, Speaker A: But oftentimes writing tests as you're coding, as you're developing, is actually going to make your experience a lot better. If you've ever seen those videos where you press a button and another button pops up or you fix one code or you fix one bug and like five other bugs get introduced, this is going to be test is going to help you prevent from doing that. Right. So tests are going to be really useful. And yeah, pretty much anytime you write some type of function, you put tests on it if you want it to stay like that. So for this Dap, we could put in some tests saying like, hey, is the initial supply what we expect it to be? Are we doing what we want here? But again, we're just going to skip over the tests in the interest of time. So let's do truffle compile again.
00:25:12.134 - 00:25:39.502, Speaker A: Let's see if this compiles and great, so it compiles. So we know we don't have any compilation errors here. Okay, great. So we have DAP token pretty much done. So when we deploy this, it's going to mint a million dap tokens to the user. Okay, great. Now let's work on the harder one, right? And this is going to be, we're going to call this token farm Sol.
00:25:39.502 - 00:26:14.090, Speaker A: Okay, this is going to be the contract that has a lot of stuff in here. So let's just define what it needs to do before we even start coding. But let's give it a pragma solidity, solidity 0.6.0 and let's contract token farm. We need this to do. Let's think about this before we do anything. So we probably need a constructor.
00:26:14.090 - 00:27:19.342, Speaker A: Constructor, look, what else do we need? We need a stake tokens amount, right? We need a user be able to stake tokens. What else do we need? We probably want an unstaked token. We don't want to have our people forever permanently locked in here. So we'll call it unstake tokens public. And what else do we need? We probably want an issues reward, right? So let's give it an issue or like an issue tokens. So we'll do function issue tokens. And what else do we need? We probably want to get the token price right again.
00:27:19.342 - 00:28:11.478, Speaker A: We're going to be issuing rewards based off the value of those tokens. So we'll say get token eth price. Look, anything else that we need, looking at my boilerplate here, there are going to be a couple other, couple of other functions that we need, but these are kind of the main ones, right? We want someone to stake tokens, unstake tokens and issue tokens. I mean these are our three core functions. So let's start building this. So um, great. So let's give this, let's give this a name real quick.
00:28:11.478 - 00:28:49.890, Speaker A: We'll call it string public name equals depth token farm. And let's go into our constructor. So the reward token that we're going to use is going to be that DAP token that we deployed. So we need a way to say, hey, the reward token is going to be this DAP token. So what we can actually do is we're going to import the interface of an ERC 20 into our smart contract. Again. We can go to open zeppelin.
00:28:49.890 - 00:29:41.906, Speaker A: We're actually going to import this I ERC 20. This is the interface and it allows us to interact with ERC 20s really easy. Great, glad to hear the volume issues are fixed. Sorry about that. So we're going to import some opens up in code contracts token ERC 20 IRC 20 sol and we're going to set a global IEC 20 public DAp token. Boom in here. We're going to set the DAP token equals IRC 20 DAP token address.
00:29:41.906 - 00:30:29.186, Speaker A: And this is going to be a parameter that we pass address. And again, guys, feel free to ask a ton of questions here. These are meant to be engaging and we're supposed to work together on this, but great. So we have our constructor, and once we deploy this contract, we're going to say, hey, the token that we're going to use to issue rewards is going to be this ERC 20. Again, this is an interface and it allows us to say, hey, this is an ERC 20 and we're going to set it to this DAP token bit. So once we deploy this, we're going to set it to this dap token. Great, simple enough so far.
00:30:29.186 - 00:31:05.280, Speaker A: Now let's go to our stake tokens function. This one's going to be a little bit more interesting, right? So how do we actually have users stake stuff? So this is going to be something that a user is going to call. A user is going to call this function. So what do we want them to do? We want them to stake a certain amount of a token. So we probably need a couple of things. Probably need an amount and the address of the token that they want to use. Okay, so let's require the amount greater than zero.
00:31:05.280 - 00:31:54.026, Speaker A: And if they don't give it an amount greater than zero, we're going to give an error saying amount cannot be zero. And let's have them start adding this token. Now, something that we probably should think about though is do we want people to stake any and all types of tokens? Probably not. We probably only want them to stake tokens that we've defined that are good, right? If you want it to be any token, you absolutely can. But maybe we also don't have a price feed for those tokens, right? If we don't have a price feed for those tokens, then we can't assess the value of the token. So let's create a new function called token is allowed. And this will give us an idea of whether or not the token is allowed.
00:31:54.026 - 00:33:22.060, Speaker A: So we'll do function token is allowed and it takes the address of the token. It's going to return Boolean, right? True if the token is allowed and then false if it's not. So how do we actually figure out what tokens are allowed? Well, we probably need some type of mapping, right? Or some type of array that tells us which tokens are allowed. So let's actually create that array at the top so we'll say there's an address array called allowed tokens. And this is where we're going to store our token. So you guys probably are going to see, we're going to need like a store tokens or like allow tokens, right? So when our tokens is allowed function or token, excuse me, token is allowed, we're going to loop around that array and we're going to find the ones that are allowed. So we'll do a for loop un 256, call it allowed tokens index equals zero.
00:33:22.060 - 00:34:06.994, Speaker A: Allowed tokens index is going to be smaller than the allowed tokens length. Allowed tokens index plus. And as you can see, we're already starting to kind of get a little bit big here, right? A little bit complicated. So let's even talk about word wrap real quick. And this is where writing those tests as you go along is going to make your life a lot easier, right? Because if we do trophy compile right now, we're probably going to get run into a bunch of errors. It's going to be like, what are you trying to do? You're crazy. And yeah, it's like you spell things wrong, you can't.
00:34:06.994 - 00:34:55.254, Speaker A: Come on, three s's on address. Come on, get it together, Patrick. So running these tests kind of as you progress, you can make sure, okay, this function is actually going to do what I want it to do. But again, we're going to kind of skip over in the interest of time. So we're going to loop through this array of allowed tokens and we're going to say if allowed tokens, allowed tokens index equals equals token, then we're going to return true. So if this token is in our array of allowed tokens, then we're going to return true, otherwise we'll return false. So this is what this function is doing.
00:34:55.254 - 00:35:35.598, Speaker A: And this is exactly like, you could write a unit test for this just to make sure. Okay, am I setting this correctly? So you probably need a function to add allowed tokens. So let's add that function. Add allowed tokens, address of the token. Now for this we are going to have a manager. We are going to have like a token manager, right? Because we don't want anyone to be able to just add tokens. Maybe they add some terrible token, but we do want people to be able to add tokens.
00:35:35.598 - 00:36:01.370, Speaker A: So maybe this would be done by a governance a dow. This wouldn't necessarily be the owner, right, because this would make it centralized. This would be like the admin key. We're just going to do only owner for the sake of this demo. So only owner is a modifier. Hopefully some of you guys are familiar with. It means that this function can only be called by the owner.
00:36:01.370 - 00:36:23.858, Speaker A: We can actually import. This opens up on as well. I'm just going to copy paste so this ownable contract, you guys can check it out. It has what's only owner. This is what the modifier looks like. It's actually really simple, but it requires that the owner is going to be message sender, which is really nice. So we do have to inherit it as well.
00:36:23.858 - 00:36:59.840, Speaker A: Is ownable. All right, we got some questions. Can we use this code in production? It's not audited, so I would highly recommend you do not. This is provided as it's hey Patrick, why not use a mapping for tracking allowed tokens? A for loop would consume a lot of gas. No, actually, yeah, that's probably much better. Yeah, that's probably way better. Now that you mention it.
00:36:59.840 - 00:37:45.310, Speaker A: Yeah, I kind of want to. Let's change it on the fly. Let's do mapping of address to boolean public allowed tokens. Yeah, actually a mapping would be better. I'm just going to keep going just so I can follow along with my demo here. But yes, a mapping would be actually much better and much cheaper and much more gas efficient. I probably did something weird on the front end that wanted me to use a mapping or something, but yeah, you probably would want to use a mapping.
00:37:45.310 - 00:38:23.580, Speaker A: So let's go back to our add allowed tokens. So we'll do allowed tokens. Allowed tokens push or if you're doing the mapping, this would be like allowed tokens. Token equals true, right? If you were doing the mapping, you would just do that. It'd be really similar if you were going to use something like new cipher to encrypt the messages. Is this where you would do that? I haven't worked with new cipher enough to know the answer to that. Maybe, I'm not sure.
00:38:23.580 - 00:38:40.958, Speaker A: So cool. So we have this function. Now it adds allowed tokens. We have our is token allowed? We have our add allowed tokens. Awesome. Now we can go back to our staking. Now we can go back to our staking function.
00:38:40.958 - 00:39:37.940, Speaker A: So if token is allowed, a mapping would be like a million times better. If the token is allowed, we're going to do some stuff, right? We need to update unique token staked, which we'll get to in a second. We need to update the number of tokens that this address has, that this user has. Let's just do some boilerplate code. We're going to need to transfer the token. So we're going to take this token transfer from message sender, comma address. We're going to transfer it from the sender to this contract by the amount.
00:39:37.940 - 00:40:09.100, Speaker A: And then we're going to need a way to keep track of how much they've actually staked. So let's actually go ahead and create that as well. We're going to need to have these guys have some type of staking balance, right? So this is where we definitely 100% need to do a mapping because an array would be insane. So we'll do a mapping of addresses. Two. And what do we want to do this a mapping of? We probably want to do this to a mapping of a mapping. Actually.
00:40:09.100 - 00:40:59.206, Speaker A: Don't let this spin your head too far. We're going to do a user. So it's going to be the user address is going to be mapped to a mapping of token addresses which is mapped to amounts, right? So we're going to do a mapping of address to un 56 equals this. And we're going to call this public balance. So that's what this is going to do. Let's go back down to our stake token function, right? Because this is one of our most important ones. We'll come back to this in a minute.
00:40:59.206 - 00:41:29.060, Speaker A: I'll show you why we need this. But let's pretend we don't care about that for now. So our staking balance and our stake token function staking balance of, actually, sorry, it's vice versa. It's going to be token address, excuse me, to mapping of user addresses amounts, sorry. So we're going to do staking balance of the token. But it doesn't really matter. You can do it either way.
00:41:29.060 - 00:42:16.382, Speaker A: Sender be equal to staking balance of, of the token of the user plus the amount. So we want to keep track of the staking balance of their token that they're going to send. So we're going to say the staking balance of the token message sender is going to be equal to the same thing plus the new amount that they're going to send. So great. This is us keeping track of the staking balance here. And then we want to keep track of who all of our stakers are. So we're going to add this additional piece in a minute.
00:42:16.382 - 00:42:38.794, Speaker A: I'm going to skip over it now. Unique tokens. Because if you just want to add staking here without any rewards, this is really all you need, right? If the token is allowed, go ahead and have them transfer it. There's two other functions that we'll need. And again, we'll get to those in a minute. So great. So we have pretty much the boilerplate of the stake token function done again.
00:42:38.794 - 00:43:23.000, Speaker A: We're going to come back to it in a little bit later. But now we want our users to be able to unstake tokens as well. So how do we actually have them unstake the token? So they'll do address token. So they're going to unstake a specific token. First we need to balance equals balance token sender, we get their original balance. Now we want their balance to be greater than zero. Otherwise we could say taking balance not be zero.
00:43:23.000 - 00:44:51.160, Speaker A: And once we get it, we're going to do again to interact with these ERc 20s, we'll do ierc 20 of the token transfer sender balance. Just a quick note, why are we using transfer here and then transfer from up here? Does anybody know? I got to wait like my 2 seconds for the delay to kick up to piece out? Why are we using transfer in one place and transfer from in another? Does anybody know it? Let's see. How clever are we? Does anybody know? Sorry about that. If nobody knows, we can move on. So the reason we're using transfer down here. And then actually, if you're watching this later, pause for a second and be like, okay, why are we using transfer here? Transfer from up here. Okay, so the reason we're using transfer here is whoever is initiating the function is going to be a couple of questions here.
00:44:51.160 - 00:45:32.286, Speaker A: We're unsure, okay, the reason that we're going to use transfer here is that we're going to call this unstaked token and transfer assumes that the sender is going to be Message sender, right? It assumes one is from the owner and the other is from the mint address. Transfer from is from someone after approve. Yes. So transfer from. We do have to do the approve, right? So up here in transfer from, we're calling the stake token function, but it's the contract that's actually doing the transferring. Right? So we first have to approve that this contract can do this. Right? Because we own the tokens.
00:45:32.286 - 00:46:01.994, Speaker A: We own the tokens. So we're going to say, okay, we want to send the tokens from the sender of this to this smart contract because we are the owners of the token, not the contract. In this case, who's the owner of the token. The contract is. So it can just send. It doesn't have to do that whole two step process, right? Because it's the owner of the tokens. So that's the difference.
00:46:01.994 - 00:46:30.454, Speaker A: This is when the contract owns the token. The contract owns the token and it's moving the token. This one, the contract doesn't own the tokens, but it's moving the tokens. So that's kind of the difference there. That's why we need to use transfer versus transfer from. So anyways, let's do staking balance the token sender. We're going to turn the balance to zero.
00:46:30.454 - 00:46:55.726, Speaker A: We're just going to withdraw everything and then we will need to do one other step, but we'll get to that later. So great. So unstaked tokens and stake tokens. If we wanted to just send this, we probably could, we wouldn't be able to issue any tokens, but we could have people stake on our platform and maybe we could do something crazy with their stake. But we want to issue tokens. We want to do that liquidity farming stuff. So let's actually do this issue tokens bit here.
00:46:55.726 - 00:47:37.654, Speaker A: Okay, so how do we issue tokens? Well, we want an idea of who all the stakers are, right? So do we have any data structure where all the stakers are? Not really. Right. We have the staking balance mapping, but this is a mapping. We can't loop through a mapping. We have an allowed tokens array, but that's just the token. So how do we actually keep track of this? Well, we're probably going to need another address array called stakers. This is where we're going to store all of the stakers.
00:47:37.654 - 00:48:42.018, Speaker A: Now we have to go back in our stake tokens and we actually have to update our stakers bit. Okay, so we'd have to do like stakers push message sender. But what's the issue here? If I stake the same type of token over and over again, I'm going to get added to this list a whole bunch of times. So we only want to update if there's a new unique token staked. Okay, so we're going to add this function called unique token staked. And if user does have unique token staked, true equals equals true. Actually we'll count if unique token staked is one.
00:48:42.018 - 00:49:18.918, Speaker A: If they're adding a unique token. If this is their first token, we'll do stakers push message sender number of unique tokens that they have is one, we'll send it to one. So we're only going to be updating here if this is their first token staked. But obviously we have to update the amount of tokens staked. So let's create this function update. Function update unique token staked. Right.
00:49:18.918 - 00:50:46.714, Speaker A: And what is this going to do? It's going to just add the number of unique tokens that they have, right? So we'll do address user address token and we'll have this be an internal function so that other people cannot call this, right. Only our contract can call this. We'll say if balance token user is less than or equal to zero, what are we going to do? We're going to do unique tokens staked by the user equal to unique staked user plus one. We need this unique token staked data structure. Let's go ahead and make that. We'll do mapping address to un 256 public unique token staked. That's right, yeah.
00:50:46.714 - 00:51:35.174, Speaker A: So if the staking balance of a user of that token is greater than zero, we're going to add it to the number of unique tokens staked. So this is kind of a dangerous function, right, because we're doing kind of a dumb operation here to update the number of unique tokens. But again, the code here is provided as is and isn't really meant for production anyways. Great, so we have this unique token Staked. Now let's go back to our stake token function, stake token function and we need to give it the message sender and the token. And we should probably do something colon at the end. I'm going to pause real quick if anybody is super lost.
00:51:35.174 - 00:52:33.710, Speaker A: I know I've kind of been coding for a little bit and it's like, what are you doing? You are doing some crazy stuff here. Are there any questions from anybody following along so far? It's a little bit delayed, so the questions might come in in a minute, but I will look down in a minute. So we're still onto the issue tokens here. Okay, so now we have an idea of who the stickers are. Is it on GitHub? Yes, this is on GitHub right here. Everything that we're going over is in here and you can feel free to follow along in here if you want. So issue tokens.
00:52:33.710 - 00:53:21.722, Speaker A: What we want to do is we want to loop through the stakers. Let's loop through all the stakers and we'll do stakers index is less than stakers length. Stakers index. Plus we should do this righteous. How do you use Solidity 0.6? Because my example was written in 0.6. That's really it and haven't updated yet.
00:53:21.722 - 00:53:48.562, Speaker A: That's pretty much it. Use whatever solidity version that you want. A lot of the Chainlink core contracts work really well in 0.6 and I know they work well in 0.6, so that's why I just kind of been sticking with it. Yeah, at some point we'll probably move, I'll do more examples in 0.80.8. That safe math upgrade is actually massive.
00:53:48.562 - 00:54:32.820, Speaker A: I'm really excited about that. But anyways, so what do we want to do? So we'll do address recipient equals. It's going to be the stakers, stakers index and we're going to send some of our DAP token, right. This is going to be that reward for them. So we're going to do Daptoken transfer recipient. But how much are we going to send them? How much are we going to send them? Oh, also we definitely want only the manager to be able to call us. So only how much are we going to send them? Well, again, we want it to be based off the value that they've staked on our platform.
00:54:32.820 - 00:55:25.602, Speaker A: So we probably should have a function that checks the total value of a user or how much they've staked in the platform. So let's go ahead and create that function. Now, new function is get user total value address of the user. And this is going to be a public view turns un 256 because we're going to be using this function to be getting the total value that a user is staked on our platform. So how do we do this? Well, conceptually we just loop through all the tokens that they have staked on our platform and we get their ethereum equivalent in value. Okay, so let's go ahead and figure out how to do this. So let's do un 256, total value equals zero.
00:55:25.602 - 00:56:38.986, Speaker A: And then if we wanted to be clever, we do like earns total value, but we're not going to be clever here. If want to check, do they have unique tokens staked? Does this user have unique tokens staked? If yes. Well what do we want to do? We're going to loop through all their tokens, right? And this is where a mapping would be a little bit hard actually, because if we had, yeah, this is where our mapping would be a little bit hard. So we're going to loop through the allowed tokens and this way we can always kind of go back and loop through. Okay, how many tokens does this person have on our platform? So this is where an array actually does come in really handy. So un 256 allowed tokens index zero allowed tokens index is less than allowed tokens length allowed tokens index. Plus there's definitely some more clever data structures than this for doing this.
00:56:38.986 - 00:57:28.170, Speaker A: But this is what we're going with for now, just because it's conceptually a little bit easier. So we're going to loop through all the allowed tokens. I'm going to check, hey, does this user have these allowed tokens? If yes, great, let's get the value. So let's even do that right now. We'll do total value be equal to total value plus get user staking balance eth value. This kind of disgusting function where they're going to take the user and allowed tokens of the allowed tokens index. We're going to create another function here called getuser staking balance eth value.
00:57:28.170 - 00:57:58.814, Speaker A: So what's this going to do? It's going to say based off the user, user and the token. This gives us the user and the token. How much is that worth? If I have ten link, how much is that worth? If I have ten die, how much is that worth? Right. We want to get that value so we know how much to reward them. So let's create another function. It's going to be this function here. It's going to be function get user staking balance e value.
00:57:58.814 - 00:58:36.162, Speaker A: And again, we're going to take address of the user, address of the token. There's probably a better function we can do than this. We do public view returns un 256 and let's do this. So this is where getting the price of this token is going to be really important. Okay, so we don't have the functionality yet, but we will. So let's do this. So let's just do a quick check.
00:58:36.162 - 00:59:55.386, Speaker A: If the unique token staked user less than or equal to zero, return zero. So, right, if they don't have any tokens, we're just going to be like, okay, you don't have any tokens, bub. Beat it. If they do have tokens, we're going to return taking balance of that token of the user and we're going to multiply it by our function, get token f price token. And then we're actually going to divide it by ten raised to the 18th because and then actually we want to even do it like this. We're going to get the balance, we're going to times it by its price and then we're just going to divide by the precision here so that we can get the actual reward amount that we're going to send them. So let's create another function.
00:59:55.386 - 01:01:00.634, Speaker A: Got a lot of functions here called get token eth price and this function get token eth price so we're going to say based off the address of the token public view returns based off the address of the token we need to get the price. So this is where the chain link price feed bit comes in. So we'll do address price feed address. And how do we get the price feed address? Well we're probably going to need to do some type of token mapping. So we'll call it token price feed mapping token. We'll actually have to create this as well. We'll do mapping address public token price feed mapping and we're probably going to need a function that will set this up correctly.
01:01:00.634 - 01:01:37.914, Speaker A: So we'll do function set price feed contract. We'll do address of the token. I'm actually going to go a little bit quicker just because I'm running a little bit low on time. Address the price feed public only owner. We'll do token price feed mapping. Token equals price feed. So this is something that once we initialize our contracts we're just going to set this up right depending on the network that we're on.
01:01:37.914 - 01:02:20.460, Speaker A: So let's scroll back down to get token needs price which I clearly have defined twice. Here's where we did the chain link bit. Aggregator b three interface price feed and if you haven't seen this stuff, work with the price feed stuff. Definitely go check out the documentation. So we want to be working with this chain link aggregator v three interface. So we're going to have to go back to the top. We're going to have to import this.
01:02:20.460 - 01:03:10.554, Speaker A: Great we've imported it. Now let's just get that price. So if we go back to the docs too link the price feeds using latest price. This is kind of the functions that we have and this is exactly what we're doing in our contract. Let's even just copy this because this is exactly what we want except for price feed latest round data and we're going to return although we want a un 256 not an int price. Great. So now we have the latest token eth price.
01:03:10.554 - 01:03:48.522, Speaker A: We have the user staking balance user get total value. We can issue tokens. Oh no we can't issue tokens. Let's finish that. So what are we going to transfer this person? We're going to transfer the total value they have staked on our platform. So get user total value resip boom. Now we have import what? Yeah, import the chainlink library.
01:03:48.522 - 01:04:15.226, Speaker A: Sorry. So this is how we're going to import chainlink into this smart contract here. We're going to do this import statement right here. So that we can work with the chainlink price feeds. Good question. So now do we have everything, a lot of stuff in here. Let's do a quick scroll down.
01:04:15.226 - 01:04:48.546, Speaker A: Right, so we have dap token, right? We have two arrays for stakers and the tokens that we allowed. Yes, we could do some mapping stuff here. We have three mappings that we want for our users. We have a constructor, we have a stake tokens function. We have a setting price feed function updating unique tokens. Do we have unstake? We haven't fixed unstake, but we will in a minute. Yeah, I think that's the only bit we need.
01:04:48.546 - 01:05:44.980, Speaker A: So this again is where tests are going to help you out a lot. You write some tests and you can actually do stuff from the tests. So let's fix our unstaked tokens bit. Here's what do we need to fix from here? Well, we need to add this bit about the unique, unique token staked message sender. Equal, since they're unstaking all their tokens, excuse me, they're unstaking that specific token. So we're going to remove that token from the platform. Awesome.
01:05:44.980 - 01:06:32.740, Speaker A: Now in the interest of time, I kind of want to just write my migration script like copy paste. So we're going to write the migration scripts real fast. Okay, so let's do this in here. We're going to do two deploy token trans, actually let's compile first, compile some compilation errors. Let's go see. Did you mean I year C 20? Yes, I sure did. You mean stakers? I sure did.
01:06:32.740 - 01:07:06.880, Speaker A: Did you mean stakers here too? I sure did. Did it, did you mean a real type? I'll start to compile. Awesome. So stuff compiles. Great. So again, you definitely would want to write tests here. We're going to skip over them because we only have an hour left and we got to get to the front end.
01:07:06.880 - 01:07:29.922, Speaker A: Write tests. It's going to help you a lot more. A lot of times somebody, oftentimes when I'm doing this stuff, I'm like, oh, I'll just skip the test. It'll be quicker for me to get to an MVP. And it actually usually ends up taking me longer. Right. Because I run into bugs, I try to fix something and then everything gets way out of whack.
01:07:29.922 - 01:07:53.674, Speaker A: So we're going to skip the test just because I've already tested this myself. So let's go ahead and do the migration. So it's compiling. Awesome. Let's migrate some stuff. So we'll do const depth token. And if you're like wait, migrations, what are you talking about here? Go watch some of those other truffle videos that we have.
01:07:53.674 - 01:08:58.974, Speaker A: Artifacts require let token module exports equals async function deployer network accounts. We'll do await deployer deploy app token constoken equals await token deployed. It'll do like console log token address. Let's go ahead and test this. And again, since I just downloaded the truffle box, if we go to the config here we have ganache, we have Covid. It looks like we don't have live in here, probably should have live in here. But we have these two environment variables, mnemonic RPC URL.
01:08:58.974 - 01:09:40.610, Speaker A: Here's an example. If you want to just do it in a env, you can do like Env and then put those in there. Again, we have ours set so we don't need to do that. If you're like wait, environment variable, what are you talking about? Just kind of follow this and put it in your own env file. So we'll do truffle migrate, work Covid and we'll see if this works. So this should run this and we should constant log the DAP token address ran into an error here. Unknown error when sending transaction.
01:09:40.610 - 01:10:28.500, Speaker A: There's a good chance this is actually related to this recently released a bug in their hardware wallet and I'm just going to reinstall everything. Sorry guys. Yeah, there's a weird glitch right now. So this is good. Actually we're going to test deploying this and this is like a really simple ERC 20. So if we can't deploy this, that's a bad sign. It it.
01:10:28.500 - 01:11:17.158, Speaker A: So we're going to redownload this stuff now. Let's go ahead and try to truffle migrate and we'll see if we get the same error. I haven't seen this error before, so this will be do a little bit of live debugging here if this is an error. Again, the other thing about writing tests is you don't have to finagle with doing the testnet eth and the testnet link. You can just run everything locally, which is great, which is why we still have these mocks in here. Yeah, so it looks like it was related to that. So yeah, Truffle released a bug recently.
01:11:17.158 - 01:11:52.300, Speaker A: So if, if that's causing issues, just use that different version and I might even go into the box and update that right after this video so that everyone just kind of starts with that older version. Cool. So we actually were able to deploy it. And this is where the address was. We can go check that out on Covid scan. Yeah, so the answer to that error is just downgrading your hd wall provider to 1.0.40. It's a really annoying truffle thing right now.
01:11:52.300 - 01:12:22.306, Speaker A: The other workaround is to just not use truffle, use hard hat or brownie. Anyways, great. So we have this deploy script. Let's create our deploy script for the other one. This will be deploy token farm. This one's going to be a couple more things. So I'm just going to do a little copy and pasting.
01:12:22.306 - 01:12:51.646, Speaker A: In the interest of time, do this module exports again. We're going to get the DAP token that's already deployed. Going to deploy the token farm. We're going to send our token farm the initial starting balance here and. Great. And then I'm just going to copy paste again. Sorry guys, I'm super speeding through this just because I want to get to the front stuff.
01:12:51.646 - 01:13:16.870, Speaker A: You can go check this out in the GitHub. Let's talk about what's happening here. We're saying, okay, if the network starts Covid or it's live, if it's one of these two networks, we're going to set these addresses. So we're going to add allowed tokens to this token, which is the link token address. And this is the link f price feed address. So again, you can see all these in the contract addresses here. Go to Ethereum.
01:13:16.870 - 01:13:44.062, Speaker A: You could also use ens. That actually would be pretty cool. But if we scroll down to coven, it's f. Actually we can even just link f so on the COVID network. So we're getting the price and f of everything so that we have something to compare to. We're going to do fau token as well. This is the FAU token address.
01:13:44.062 - 01:14:04.680, Speaker A: We're pretending it's going to be Dai. So this is the Dai eth, and then this is going to be our DAP token, which we're also going to be pretending it's Dai. So we have this add allowed tokens. So we're adding the allowed tokens for it. And then we're setting the price feed contracts up correctly. Okay, so we have this mapping and we know where the price feed addresses are. So let's go ahead and run this as well.
01:14:04.680 - 01:14:29.230, Speaker A: Network coven. And this should just deploy the token farm because truffle should be smart enough to be like, oh yeah, you already deployed the DAP token. Yeah. So it's going right for the token farm, which is good. And we are deploying. Awesome. We're getting somewhere.
01:14:29.230 - 01:15:14.234, Speaker A: So now we have the back end pretty much done and we have stuff deployed. We have stuff deployed to some good places, but when we're working with our front end, we actually want to be able to interact and work with these abis on the front end. So I'm actually going to create a new folder, src. And this is where all my front end stuff is going to be. And I'm going to create a new folder in here called Abis. And what I want to do actually is in my truffle config. And this is where we're slowly migrating to the front end bit.
01:15:14.234 - 01:16:11.770, Speaker A: We can add what's called a builds directory or a contract build directory in here. So we can say contracts build directory. Going to be Abis. In this way, our front end will actually be able to be able to interact with this a little bit better. So we have source Abis. If we rerun this set network covenant, we're actually going to get all these abis in this source Abis folder, right? And this will be great because we can put all our front end stuff in here. What is an Abi? Abi stands for application binary interface.
01:16:11.770 - 01:16:42.630, Speaker A: So if we look at these, it has this Abi section and this is really where the AbI is. And it just shows the way to interact with your contract. Right. So it's going to have all your events, all your function calls. It tells us, okay, here are the functions and here's what we can do with this contract. And we need an Abi and an address in order to interact with any smart contract on chain. Good question.
01:16:42.630 - 01:17:02.380, Speaker A: So that is the abis though. So awesome. So we've deployed to source APIs, we have our back end set up. Now we can move into the front end stuff. Let's do it. Let's do some front end stuff. So I'm going to go ahead and drop in some boilerplate stuff.
01:17:02.380 - 01:17:51.758, Speaker A: If you guys feel free to just copy paste from the repo on this. This is just going to get us set up and doing things for the front end. So in here we're going to do, actually, once this is done being sent. So we're going to add components and we're going to add everything we need for our front end in this sRc. So we're added components, index js, we're going to add a service worker and it's going to be a pretty lightweight front end. Just going to be a simple is a terrible word, but we're just going to have a server that's going to be. Yeah, like I said, running our front end.
01:17:51.758 - 01:18:46.042, Speaker A: Once this decides it wants to finish, we're not going to go over, like, all of the stuff here. We're just going to copy paste some boilerplate just so that our lives are a little bit easier. Okay, cool. Let's go into source and we're going to touch serviceworker js and open that up js and I'm just going to paste some stuff from my GitHub. Again, just feel free to copy paste for this section. This is kind of the less important stuff. And we are also going to create an index.
01:18:46.042 - 01:19:18.890, Speaker A: So this is going to be one of the more important parts. So it's going to be react. So we're going to do import react from react. Import react Dom. From react Dom. Actually import bootstrap css. Bootstrap csS.
01:19:18.890 - 01:19:54.242, Speaker A: And then actually, I'm just going to go ahead and copy paste all this stuff in here because this really isn't the interesting part. This is literally just some boilerplate to get started. You can literally copy paste this into your smart contract and go, the more important thing and the more interesting thing is going to be components. Now we have this components file. This is where stuff gets interesting. Okay, so we're going to have two kind of main functions or main files. We're going to have app js, main js.
01:19:54.242 - 01:20:17.450, Speaker A: So let's go ahead and navbar js. So let's go ahead and create all those we're going to do app js. File is going to be main js, navbar js. These are the different components of a react app. Yes. The nav bar is going to be for the nav bar, and the main and app are going to work together. Let's also create an app css.
01:20:17.450 - 01:20:54.378, Speaker A: And I'm kind of glossing over a little bit here, but stick with me, guys. So let's start doing our. Which one do we want to start with first, actually? How do I get through all this in 45 minutes? That's going to be the real challenge here. It's going to be to rip through this in 45 minutes. Let's just start with main, right? Yeah, let's start with main. So again, we're going to be doing kind of the class based react here. So let's just go ahead and start ripping it.
01:20:54.378 - 01:21:27.154, Speaker A: So we're going to do import react comma from react import. Let's get some images in here. Actually, we could skip the images for now. Now we have our class main. It's going to extend component and let's render some stuff. So this is going to be our main function. That's going to be rendering our front end.
01:21:27.154 - 01:22:02.780, Speaker A: So we have our render function, render return. And this is where we start writing the HTML and this is where we write kind of the less interesting stuff. And I kind of want to just copy paste. How did I go through this in like 2 hours? Let's do div id actually. Yeah. How do I get through the rest of this in 40 minutes? That's going to be the real question. Which sections can I copy paste and which sections do we want to see? Let's think about this.
01:22:02.780 - 01:22:44.886, Speaker A: Do it. What's the best way to go about this? What do you guys think it? How do I, how do I copy paste most of this without copy pasting stuff? Maybe we'll start with app first. Actually, I'm running a little low on time. Probably should stop being slow here. Let's start with app. Let's start with app js. Let's just start here and let's just go import react ownant from react.
01:22:44.886 - 01:23:17.686, Speaker A: Yeah, let's start here because this is going to have a lot of the contract stuff. So we're going to be using web three from web three. Now we want to import the contracts that we made. Yeah, I do want to copy the directory, but I don't want to copy paste this jam you're killing. I feel like I'm going to be skipping over a lot of stuff if I just copy paste everything. But yeah, let me know what you guys think. We're going to import it.
01:23:17.686 - 01:23:55.300, Speaker A: So import our dev token. And this is why we put it into its own kind of thing. We're going to import it from Abis token JSoN, you're going to see how we're going to interact. We're going to go through app and then index or main will probably just copy paste because there's going to be a lot there. Token farm from Abi Tokenfarmjason. And this is one of the niceties about having your front end and back end in the same repo. We can compile, build, send it, and then our front end automatically has it available.
01:23:55.300 - 01:24:26.038, Speaker A: We do import ERC 20 ABIsC 20 jSon. We're going to import Navbar. Actually we're going to skip the nav bar for now. Main import app css. That's how we're going to style it. And then we're going to import and actually we will have to import the nav bar. Crap.
01:24:26.038 - 01:24:51.122, Speaker A: Do the nav bar first, actually. Then nav bar from. Could you please explain Abis and why we need it? So this is the second time someone's asked about Abi. So, yeah, I'll go into Abi. So Abi stands for application binary interface. So if we go to, like, if we go back to remix, for example. Right? Oh, crap.
01:24:51.122 - 01:26:03.100, Speaker A: I meant to update this, actually. So it stands for application binary interface. So this means that we have a way to interact with these smart contracts, right? When we call contracts, when we interact with contracts, we're kind of just calling these functions that are really just like bytes and stuff on chain. So it's a little bit easier to see when we're actually doing it. If I want to interact with a contract on chain and I don't know what the functions are, how am I going to interact with it? Right? Like, if we go to Etherscan Covid and we look at this, that we just deployed, token farm address, right? Go to the contract. What do you see here? Do you see any functions? No. You see a whole bunch of stuff, right? This doesn't mean anything.
01:26:03.100 - 01:26:35.160, Speaker A: When we're writing software and we want to call a function in here. There's nothing here to call, right? This is just a bunch of Jarvis. Like, how do we actually compute this? So we need an ABI to say, here's how we can interact with this smart contract. So an ABI is a way to make sense of stuff. Now, the Abis are kind of dumb. And when we say, hey, this ABI belongs to this address, our code is going to say, oh, okay, well, you're the boss. Great.
01:26:35.160 - 01:27:12.370, Speaker A: And if we call a function based off our ABI to this contract, it's going to try to call that function on this contract. And if that function exists, it'll call it and we'll be successful. Great. If it doesn't exist, it'll freak out and be like, stop doing whatever you're doing. You're being nonsense. So there are two things you always need to interact with a contract that's on chain. You need the address of that contract and you need the ABI or interface.
01:27:12.370 - 01:27:32.182, Speaker A: Those are the two things you always need when interacting with the contract. So keep that in mind. You need the address and you need the ABI or interface. You also need the Eth one connection or, excuse me, the eth connection. Right. You also need to know what blockchain it's on. Like if it's on coven or rinkby or whatever, but those are the two main things.
01:27:32.182 - 01:27:58.658, Speaker A: Once you know what blockchain you're on, those are the two things you need. You need the address and you need the ABI. You need the ABI because your code needs to know how to interact with that contract. Does that make sense? Because this is just jarble, right? Computer doesn't understand what this is. If I go back to my code and I say, hey code. This is how you interact with it. Hey code.
01:27:58.658 - 01:28:22.326, Speaker A: This is what you can do. Hey code. There's a. Let's look at the token farm. Hey, code. This contract has an owner, new owner, previous owner. Hey, code.
01:28:22.326 - 01:28:35.260, Speaker A: You can change ownership, you can renounce the ownership. Hey, code. This has a staking balance. You can view the types of that staking balance. Hey, code. It has a mapping in here. Hey, code.
01:28:35.260 - 01:29:00.658, Speaker A: You can add allowed tokens, here's the inputs. So it lets us know how to actually interact with it. So good question. Really good question. I'm actually just going to copy paste nav bar because the nav bar is not doing anything interesting. I do need to add this as well. Cool.
01:29:00.658 - 01:29:20.780, Speaker A: Hello. Yeah, we're not going to look at the app bar. App bar is not doing anything interesting. We're going to skip over that app js. Okay, class app extends component and this is just some react stuff. Again, this is class based. The VRF pizza one that does state hooks, which is different.
01:29:20.780 - 01:29:47.070, Speaker A: I recommend checking out the state hooks if you want to work with the newest stuff. So async component will mount. And this is when we load. We're going to await this load web three. Await this load blockchain data. Okay, so once we log into the page we want to load our web three stuff. We want to connect to the blockchain.
01:29:47.070 - 01:30:23.022, Speaker A: Okay, so how do we do that? Well, we probably need a function called load web three. We probably need a function called load web three. We also need a function called load blockchain data. Okay, so this is going to connect us to web three and this one is going to load all the blockchain data into our smart contract into the front end. So this is, hey, once we get to the page, how do we get stuff up? Let's do this. So let's create an async function called load web three. And this is where knowing a lot about how to work with web three kind of comes into play.
01:30:23.022 - 01:30:54.678, Speaker A: And how to work with web three on the front end. So we're going to say if window ethereum, if there is like a metamask or something that's what this means if window ethereum. You can learn more about this in the web three package. But if window ethereum, then we're going to say window web three equals new web three. Window ethereum. This is how we're going to connect to the blockchain. We're going to say await window ethereum.
01:30:54.678 - 01:31:47.740, Speaker A: Enable. We're kind of hard coding this, so to say. Okay, the instant we get into this front end, we're going to load web three data, we're going to load blockchain stuff, and we're going to wait until the user hits that confirm button. What happens if I hit yarn or yarn start right now? I think I was supposed to create react app here. Is that where the boilerplate is? I want to test this real quick. I started this with great racked up. I probably did.
01:31:47.740 - 01:32:32.260, Speaker A: What happens? MpX create react app. Create react app. Okay to proceed? Yeah, sure. Unless it deletes all my stuff. Do make dir tests. I'll run it. Yeah, it's okay to proceed.
01:32:32.260 - 01:33:14.150, Speaker A: Actually, if this is what we did, then everything will make a lot more sense. Actually, don't remember if I created this with create racked up. Let's find out, guys. Let's find out. There's a good chance that we did, and if we did, then that's great. So we have a new file, src tst. Oh, well, look at that public.
01:33:14.150 - 01:33:57.250, Speaker A: Looks pretty much like what we were doing. Well, we're going to just delete that, though. Remove the rf test. If you're looking to create a front end, I highly recommend doing like create react app as your starting point. We're just copying and pasting stuff from here, but we're just going to copy paste and we're going to continue on our package. JSon scripts, add a new one. We do start.
01:33:57.250 - 01:35:00.052, Speaker A: We're going to do react scripts, start command not found. Okay, all it. Let's get the command. A lot of this stuff in here. Sorry, guys, I kind of bounced all over the place. HD wallet. So I'm actually going to recommend you guys do like create react app or create ethapp to get started.
01:35:00.052 - 01:36:23.888, Speaker A: If you do create ethap, you're going to get the state hooks. If you create react app, you're going to get this class based stuff. So we're just going to copy paste over. We're going to copy paste some stuff over just so that we get everything good here. Apologies, guys. It the lab coding. Oh, no, I'm just going to grab from this real quick.
01:36:23.888 - 01:36:55.292, Speaker A: Apologies, guys. So, yeah, so you're going to want to do create react app or create eth app. And that's really going to get you guys set up. But in the interest of time from me, like actually doing this, right this. So we are still going to go through app js, but we're going to have everything else already set up for us. So create ETH app or create react app. That's kind of going to be your starting point.
01:36:55.292 - 01:37:41.290, Speaker A: And then you guys saw that once we did that kind of create that create react app, it populated with the different components, with the index and everything, and then you can just run yarn start from that and that'll actually get you up to speed. Yeah, this kind of has everything already imported in it, but we're going to pretend like we don't have anything in here. Sorry, guys, apologies there. Create react app or create EtH app really does explain a ton. I mean, I still have nothing, but I have much better framework in my head of where to start putting a dis. Awesome. That's great to hear.
01:37:41.290 - 01:38:21.960, Speaker A: So create react app or create eth app. Those are two really good ways to start your front end. But yeah, sorry, I kind of jumped around a lot there. Let's put back the back this stuff, because this is where most of the important stuff is anyways. Actually, main is going to have a whole bunch of like, HTML. Yeah, I'm not going to have enough time to go through over this anyways. Main is going to have a bunch of HTML, a bunch of Javascript to get to update the HTML based off the variables.
01:38:21.960 - 01:38:45.424, Speaker A: And that's really it. That's really what this main page has. So let's do the app js. Yeah, because there's no way we're going to hit it all in 30 minutes. A little bit aggressive here with the timing app is where the majority of this stuff happens. So in here, what are we going to do? The instant we start, we're going to load web three. Okay.
01:38:45.424 - 01:39:54.420, Speaker A: And so we're going to say if window Ethereum, we're going to do else. If window web three, window web three current provider. And what this is saying is saying, okay, if there's ethereum here, let's enable it. Otherwise, let's just get the current provider. So you pretty much have to have a metamask. The way we're setting this up, you have to have a metamask to work with this. So we're saying if they don't, we're going to do window alert on e brow detected on web three, browser detected.
01:39:54.420 - 01:40:28.530, Speaker A: Maybe install metamask install again. So all the contracts are going to be the same. The deploy scripts are going to be the same, and we have 25 minutes to get through the rest. So there was no way I was going to get through the rest if we're going to go through everything. So create Eth app and create react app are going to be your friends. Create EtH app is going to use state hooks as opposed to this class based stuff. But state hooks are really nice.
01:40:28.530 - 01:41:29.590, Speaker A: So let's go ahead and do Yarnstar now and let's see what this little bit gets us. Not much, right? Pretty much nothing. Or it'll just load forever because it's like, what are you doing? What are you talking about? Yeah, well, we have an error, but metamask pops up right away. Right. So we're actually going to go ahead and go back. Let's add this other function that we have, which is load blockchain data. It load blockchain data.
01:41:29.590 - 01:42:02.530, Speaker A: And this is where we have to load. We want to load all of our contract information. Const web three equals window web three. There are accounts constaccounts equals await web three e get accounts. Sorry. So if you do yarn start, it'll keep like updating. I don't want to do that quite yet.
01:42:02.530 - 01:42:42.830, Speaker A: And we're going to set the state of our app here. So the state hooks are a little bit different. We're going to use set state. So we're going to set state of our account to account zero this set state of token address. We're going to initialize the front end so that they're on the link token address. We're going to do this set state. So we're going to skip this part.
01:42:42.830 - 01:43:29.050, Speaker A: We have to have this part, the image chain link set state token name. So what is this going to do? Actually, I'm curious what this is going to do. Yarn start should kind of break and freak out, actually, because we don't have any other information. Yeah, it's going to break and freak out. I have 20 minutes to get through a lot of stuff. Let's go really fast. I guess.
01:43:29.050 - 01:44:03.750, Speaker A: So what are we setting the state for? So we're setting the state so that on main js we can actually call this stuff. So again, Main is where we do all of our HTML, right. So if we want to get the staking balance of each token on the front end, we can do this properties and get the token name right. Because when we set the state, we're sending the state for our front end. Same thing with image. If we want to use a certain image, we can grab it by getting it from the properties that we set, token name, address and everything. So let's just try to rip through the rest of this because this is kind of the important one.
01:44:03.750 - 01:45:05.240, Speaker A: So we'll do const ERC 20 equals new web three contract. And this is where we need that Abi EC 20 Abi state token address this set state to ERC 20 for setting the ERC 20 state to ERC 20. So again, on the front end, actually, we don't do anything here. We'll do it on the back end stuff and then we'll get the balance. ERC 20 balance. Wait, ERC 20 methods balanceof state account call. So we're going to get the balance of this ERC 20 based off of the account that's connected.
01:45:05.240 - 01:46:24.740, Speaker A: This way we can render it on the front end and then we'll do this set state 20 balance two string. We're getting our ERC 20 balance of the account that's connected to us and we're going to render this on the front end. So let's keep going though. We have the balance of our ERC 20. Let's, let's do const. DAP token data DAP token networks work id this DAP token networks let's get the DAP token data from our networks based off of the id. Like for example, if we're on coven, if we're on rinkby, if we're on whatever, and if there is data, there's, let's get that data token equals new three e contract.
01:46:24.740 - 01:47:38.952, Speaker A: And again, you see we're using this web three e contract and we're going to use the DAp token Abi again, because again, in order to interact with anything, the AbI, right, we need to work with the ABI and the address. Anytime we initialize a contract to interact with AbI address, always we'll do this set state address depth token data. We're setting the DAP token. We're telling it, we're saying, hey, great, we have a DAP token here. We're also going to do this set state token. Now let's start getting some balances here. Let DAP token balance equals await token methods.
01:47:38.952 - 01:48:24.148, Speaker A: I'm sorry I'm going so fast here, guys. Balance of this state account call. So same thing as above, how we got the bounce of the ERC 20. We're going to get the bounce of the reward token. This set state balance two string. So now we have the balance here. And then again we're going to do else alert, say app token not deployed.
01:48:24.148 - 01:49:00.040, Speaker A: So if we don't find any information we're just going to say, hey, we have an error. Okay, all it, so this is all for the DAP token. It's all the DAP token data here. This is all ERC 20 stuff. Now let's grab stuff for the token farm, farm data. And this is all in this async load blockchain data, right. So this is just us loading all the blockchain data from our contracts.
01:49:00.040 - 01:49:54.250, Speaker A: Token farm data is going to be tokenfarm networks. Again, network id because we want the network id typo balance of. Thank you, thank you. What I get for trying to build a whole front end in 15 minutes. Token farm data. If token farm data, token farm equals new web three e contract token farm Abi token farm data address. Thank you, appreciate that.
01:49:54.250 - 01:50:34.848, Speaker A: So again, same thing. We're getting the token farm information from the ABI and the address. Again, you're going to see this a lot. Anytime you want to interact with a contract you're going to need to get the ABI and the address. So this set state farm, this update staking balance and this is a function that we're going to need to do. We're going to say, okay, great, let's get all the token farm data, let's update the staking balance. It's going to be functional.
01:50:34.848 - 01:51:33.224, Speaker A: We're going to make in a little bit and then let's do another else here, right? Else, hey, you didn't deploy the token farm. So loading blockchain data, we're getting all the information for whatever token that they're working with right now. Again, we're going to default them to link. Then we're going to get the DAP token. This is going to be their rewards, right, the rewards that they need. And then we're going to get all the token farm database and then we'll do, once this is all done, we'll set loading to false and we'll have a loading state that we will change to true oftentimes. Okay, great.
01:51:33.224 - 01:52:17.600, Speaker A: So this is going to load us all of our, we have ten minutes left. I'm not going to get through the rest of this stuff, guys, I'm sorry. I'm going to copy paste and we're going to just go over. We ran out of time, team, we ran out of time. I was too slow building the contract. So let's just go ahead and run this copy pasted stuff back in. So let's just go over what kind of happened here because again, we're not going to have time to kind of just code everything else.
01:52:17.600 - 01:52:50.246, Speaker A: So we have a couple of functions at the top here we have component will mount. So this gets loaded whenever we refresh, right? So we load this web three data which we saw was just like basically interacting with metamask. And then we have this load blockchain data which gets all of our account information. It gets all of our ERC 20 information. It loads the DAP token, it loads the token farm. And then we have a couple of different functions. This is this stake tokens.
01:52:50.246 - 01:53:39.770, Speaker A: This is how we interact with that big stake tokens button. You can see that once we hit stake tokens we're going to change loading. And on the front end there's a loading component. It's probably in the nav bar or it's in the CSS. No, it's in the nav bar. Where is loading when we'rendering? If this set state is loading, we're going to add this little HTML that says loading. We have a way to change token whenever we click a button that changes the different tokens.
01:53:39.770 - 01:54:21.640, Speaker A: We have this function here which gets called again from the front end JS. We kind of botched the front end here, guys. But whenever we click one of these buttons, right, if we click dap token, we call this change token function which changes us to that specific token. What else is in app JS? We have update balance which gets called whenever a transaction finishes. We can call this update balance to update these balances on the front end, right, because we have these different balances here. Update staking balance. This is a button that we press.
01:54:21.640 - 01:54:38.800, Speaker A: This isn't a button that we press. This again is going to update the amount of staking balance that we have. We have a whole bunch of other functions down here. Like I said, stake tokens, unstake tokens. This is this big button right here. Stake and unstake. These are what gets called.
01:54:38.800 - 01:55:12.520, Speaker A: These functions gets called. And this constructor props thing. This is what's used so that this main can render all the variables from this app js. And then we also have this render. If stuff is loading, we're going to add this little loading bit and then the main content is going to be. Again we're going to say, hey, we're going to send it over to main js and here's what we're going to set all the starting variables to so that main can understand stuff. And this is just for the nav bar.
01:55:12.520 - 01:56:05.660, Speaker A: So sorry guys, we didn't quite have enough time to go through everything here, but let's just look at how this works. Right now I'm staking ten link. Let's stake one more link, see if we get this loading thing pop up. Metamask is going to ask us to approve first. Once that goes through, it's going to ask us to actually confirm. And now what's happening is the transaction is going on on Covid and unless I just broke everything. Sorry, that was actually a different local host I was running.
01:56:05.660 - 01:56:36.494, Speaker A: Oh no, it's there. Let's see. Did that transaction finish Covid? Looks like it did finish. Our staking balance finally went up to eleven. Now if we unstake, say we want to pull all of our link back, we're going to confirm. Once this finishes, the staking balance is going to go back down to zero because we're going to unstake everything. So it looks like it finished.
01:56:36.494 - 01:56:54.886, Speaker A: If we do a refresh here, it looks like it's back down to zero, which is good. And we can see our link balance went up. We can see the balance of all of our tokens here. Our link balance went up. Now we don't have any reward, so let's figure out how to do that. Remember, we only give rewards if people have something staked. So let's hit stake.
01:56:54.886 - 01:57:30.420, Speaker A: We'll stake some of our tokens here and then we'll take questions. Yeah, sorry, we ran through this really quick. I recommend you guys checking out create react app or create ETH app to kind of get a front end going pretty quick. Create eth app is really good. It is using state hooks. So this demo uses class based components, which is a little bit different. But learning the state hooks will be really good.
01:57:30.420 - 01:58:02.030, Speaker A: And once this transaction finishes, looks like it's still going. We'll get a staking balance and we can call one of our scripts here. We can call issue tokens this issue token script and then we'll be able to see a reward here. Does this finish? Okay, great. We have ten links staked now right here. Let's go back to our scripts. We can run truffle exact scripts.
01:58:02.030 - 01:58:25.720, Speaker A: Network coven. It's going to call our issue tokens function. That's it. Unknown. Network coven. Is it network live? Oops, sorry. I converted it to live here.
01:58:25.720 - 01:59:20.614, Speaker A: Network live. And this should issue tokens. This should issue rewards tokens here based off of how much ten link costs in ETH. So sorry, I kind of bounce all over the place, but yeah, open for some questions here, guys. Hopefully at least the first part was really helpful, kind of seeing the running process of adapt that actually works. And again, you can absolutely fork this, do whatever you want with this, play with this, or just go right for create EtH app and go from there. Any questions, comments here as we wait for this transaction to go through their link.
01:59:20.614 - 02:00:01.060, Speaker A: Staking isn't a thing, but for this, for token farm zero. Right now this isn't hooked up to like any other application. So this is kind of the gateway, right? Once you have people staking on your platform, then you can deposit into Aave. You can kind of do what yearndod finances and deposit it around. You can kind of do whatever you want once people stake in your platform. So right now the APY for this application is zero. It good question.
02:00:01.060 - 02:00:50.670, Speaker A: And is it freaking out because I have to redeploy. Whenever that finishes, this will go up. Any recommendations for resources that go in depth? What you taught today? Yeah, so for the front end stuff, I would say go check out cray eth app. This one's really good for the truffle stuff. Most of the back end stuff is actually more, I mean, you can just watch chain link YouTube if you go to videos, right? We've done a number of workshops on the back end stuff. Right. Testing.
02:00:50.670 - 02:01:20.160, Speaker A: You can go check out this video here. For the truffle stuff, we can check out here. DAP University, like I said, DAP University has a lot of really good videos. If you like videos, if you like courses like Udemy. Udemy solidity is really good. Crypto zombies is going to be one that's really good. And this is just kind of basic solidity stuff here.
02:01:20.160 - 02:01:45.670, Speaker A: That's more like basic solidity stuff here. But for the front end stuff. Yeah. Create ETH app or you can take really any react or front end course for that. VRF pizza. That silly VRF pizza. One, I learned a lot of my react stuff from just googling state hooks, react front end, and then watching a bunch of videos that teach us how to do that.
02:01:45.670 - 02:02:02.620, Speaker A: So the docs are really good. There's a lot of videos on some of the stuff. Yeah. I apologize. We didn't go as deep in the front end stuff as we would have liked because we kind of got short on time. But yeah, there's a lot of really good resources there. Good question.
02:02:02.620 - 02:03:09.966, Speaker A: Any other questions? It. My biggest problem is wrapping around, wrapping my head around linking smart contracts to a front end. Yeah. So really the piece that you really need is going to be like if you create react app or create ETH app or whatever, the biggest thing that you're really going to want to look for is having this section, right? Having being able to get your abis. Because if you look at all of our app, our front end stuff in app js is we import these abis, right? Import token farm from Abis token Farm. And then once you import an ABI, you can interact with the contract with kind of pure javascript stuff, right? So const token farm equals new web three e contract pass in the ABI, pass in the address. Those are the two things that you're going to need.
02:03:09.966 - 02:04:12.434, Speaker A: And once you have those, you can do whatever you want, right? So right away we got the token farm with the ABI, with the address. And then we called tokenfarm methods staking balance, right? So we called one of these functions and if we remember, solidity is interesting. Sorry, you guys can't see my screen. So yeah, in app js, like I said, you need the ABI and you need the address, right? That's it. Web three e contract ethers is a pretty similar syntax, but once you have the ABI and the address, then you can just start calling functions. So staking balance is a function. In solidity, these global variables count as functions, but we could just as easily call like stake tokens, right? And once you have this, you're good to go.
02:04:12.434 - 02:04:59.102, Speaker A: So the other thing that you're going to need is a web three connection. We do it with web three equals window web three, and we do this load web three function, right. So if we say if window Ethereum, then we have window web three equal to this window ethereum. Window Ethereum is basically saying if metamask is there, have that metamask be the connection, which is really helpful. So once you have the blockchain connection, the ABI, the address, you're good to go. And since we're dumping our abis to this Abis folder, we can just, just, when we compile, we can just pull the APIs right out of here. Hope that helps.
02:04:59.102 - 02:05:11.920, Speaker A: That's a good question. Awesome performance. Thank you. I do apologize though for not getting as far through the front end stuff as I would like. I am late for a meeting, but yeah, feel free to ask questions in the discord. Thanks everybody for joining and we'll talk to you soon.
