00:00:16.730 - 00:00:46.246, Speaker A: We've completed all the basics of this section that I wanted to go through, and you should be incredibly proud of yourself for getting this far. You've just deployed a really advanced smart contract. We're using a library and Chainlink contracts to build some of the most powerful applications on the planet. We've learned to use a library for any type we want in our smart contracts. We've learned more about multiplication and then units of measure in solidity. In smart contracts. We've learned about mappings, more about arrays, what the constructor does.
00:00:46.246 - 00:01:14.606, Speaker A: We've learned how to send money, we've learned about for loops, we've learned about the different ways we can actually send money, at least from a low level. And we've learned about modifiers. This section is one of the tougher sections in this course, so if you completed this, you should be incredibly excited. We're going to go through our code now and we're going to make a number of tweaks. Now this section we are going to do a little bit more advanced solidity here. So if you get a little bit lost, don't sweat it too much and feel free to try some of this.
00:01:14.628 - 00:01:20.806, Speaker B: Stuff in the future on your own. We're going to modify this contract to.
00:01:20.828 - 00:01:26.198, Speaker A: Make it a little bit more professional. It's not going to be end to end amazing, but it's going to be a little bit better, and you'll see.
00:01:26.204 - 00:01:26.882, Speaker B: Why in a minute.
00:01:26.946 - 00:01:29.606, Speaker A: So the first thing that we're going to do is we're going to look.
00:01:29.628 - 00:01:31.574, Speaker B: At some of these variables here in.
00:01:31.612 - 00:02:15.606, Speaker A: Particular, owner and minimum USD owner gets set one time in our contract here and then it never changes again. Minimum USD gets set one time, even outside of the constructor. If we have variables that only get set one time, we can actually use some tools in solidity to make them more gas efficient. For now, let's compile our fundme contract and then deploy it to a Javascript virtual machine. Remember, we can go ahead and deploy it right now. However, funding and withdrawing and doing any of the money stuff isn't going to work because again, we don't have a chainlike network on our Javascript VM, so those aren't going to work so well. But for what we're going to do right now, we don't really care so much.
00:02:15.708 - 00:02:19.234, Speaker B: Here's what we do care about. We do care about how much gas.
00:02:19.282 - 00:02:54.334, Speaker A: This costs to actually send. We do care about how much gas this costs to create. Right now, creating this contract costs about 859,000 gas, and we're going to add a couple of tricks right now to bring this number down. We're going to add some stuff back in in a bit which will bring it back up. But for now we're going to learn some tricks to bring this number down. The two tricks that we're going to learn are the constant keyword and the immutable keyword. In their solidity, there are two keywords that make it so that your variables can't be changed, and those keywords are constant and immutable.
00:02:54.334 - 00:03:17.466, Speaker A: You can learn more about them in the solidity documentation. If you assign a variable once outside of a function and then never change it. So if it's assigned at compile time, you can go ahead and add this constant keyword. We'll learn later about storage. But when you add a constant keyword, this minimum USD no longer takes up a storage spot and is much easier to re to.
00:03:17.568 - 00:03:19.466, Speaker B: So now if we recompile this and.
00:03:19.488 - 00:03:22.810, Speaker A: We deploy this new contract, let's see if we saved any gas.
00:03:23.790 - 00:03:26.282, Speaker B: We look in the transaction logs now.
00:03:26.416 - 00:03:28.986, Speaker A: We can grab the transaction cost of.
00:03:29.008 - 00:03:31.006, Speaker B: How much this costs to deploy, and.
00:03:31.028 - 00:03:54.870, Speaker A: Let'S compare it to how much it was before. Wow, we saved almost 19,000 gas. That's almost as much gas as it cost to send Ethereum. Typically, constant variables have a different naming convention. Typically you'll want to do them all caps like min emum, underscore USD. So all caps with underscores. So now let's just find minimum USD and replace that with all caps as well.
00:03:54.870 - 00:03:59.298, Speaker A: With this interaction, we know that this variable is a constant variable and it's.
00:03:59.314 - 00:04:00.678, Speaker B: Much cheaper to read from.
00:04:00.764 - 00:04:02.822, Speaker A: Now, if we go ahead, compile this.
00:04:02.876 - 00:04:06.634, Speaker B: And redeploy in our fundra contract, even.
00:04:06.672 - 00:04:23.200, Speaker A: Though this is a view function, remember, view functions do have gas costs. When called by a contract as a constant variable, we can see the execution cost of this variable, 21,415 gas. So let's put a little note right underneath it.
00:04:23.810 - 00:04:26.814, Speaker B: If we remove the constant variable, we.
00:04:26.852 - 00:04:31.130, Speaker A: Delete this contract, we redeploy, collect fundme.
00:04:31.290 - 00:04:35.618, Speaker B: And we hit minimum USD again. We can now see how much gas this was cost.
00:04:35.704 - 00:04:53.202, Speaker A: If it wasn't a constant variable, we can see the gas cost did indeed go up. Now, on chains that are much cheaper, this gas difference probably won't make that much of a difference. But on more expensive chains like Ethereum, this is going to make a big difference. For example, on Ethereum, we can actually see current gas prices.
00:04:53.346 - 00:04:55.222, Speaker B: On Ethereum. Here we can see that the current.
00:04:55.276 - 00:04:59.190, Speaker A: Gas price of Ethereum is about 141 guay.
00:04:59.270 - 00:05:01.286, Speaker B: So we'll go to our converter guay.
00:05:01.318 - 00:05:08.846, Speaker A: To way, we'll copy the way price times this, we'll get the gas price of calling our minimum USD, which is.
00:05:08.868 - 00:05:14.686, Speaker B: This number here, which if we put back in our Ethereum unit converter, we.
00:05:14.708 - 00:05:16.746, Speaker A: Can see costs this much gas.
00:05:16.938 - 00:05:18.994, Speaker B: And if we times that by the.
00:05:19.032 - 00:05:27.874, Speaker A: Approximate current price of Ethereum, which is around $3,000, calling minimum USD as a constant is going to cost $9.
00:05:27.992 - 00:05:30.514, Speaker B: Calling us at a non constant is.
00:05:30.552 - 00:05:44.858, Speaker A: Going to cost almost an entire dollar more. You can see how all these little gas optimization tricks are going to make your life a lot better. So let's keep this constant keyword in here. We'll learn more about constant and storage in later sections of this course.
00:05:44.944 - 00:05:57.626, Speaker C: Now, as you're just getting started with this course and with solidity, do not struggle and do not worry about making your contracts as gas efficient as possible. In the beginning and especially right now.
00:05:57.728 - 00:06:00.366, Speaker A: Just write your contracts as best as you can.
00:06:00.468 - 00:06:24.310, Speaker C: Once you get really good at gas and once you get much later on in the course and much more advanced with solidity, then you can start going back and working on gas optimizations. But do not let gas optimizations hold you back. Or if you start stressing over it, just let it go, don't worry about it, and just write your code as best you can. So long story short, do not stress about gas optimizations right now.
00:06:24.380 - 00:07:01.218, Speaker A: Now, another variable we only set one time is going to be our owner. Variable owner equals message sender. We set this one time in the constructor. Variables that we set one time, but outside of the same line that they're declared, and we set them, for example, in the constructor, we can mark as immutable. Typically, a good convention for marking immutable variables is going to be doing, I underscore, so that we know that these are immutable variables. They have very similar gas savings to the constant keyword. Owner, of course, is a variable that we can't set on the line here, because inside the global scope, there's no function going on.
00:07:01.384 - 00:07:04.526, Speaker B: However, inside functions, because inside the global.
00:07:04.558 - 00:07:21.490, Speaker A: Scope, there's going to be no message sender. There's only going to be a message sender when we're inside of a function. So inside here, we might say Iowner equals message sender. And then of course, we'll scroll down and we'll change this require only owner now equals Iowner.
00:07:21.570 - 00:07:29.162, Speaker B: Now, if we compile that and deploy it, we can see how much gas we can see how much gas calling.
00:07:29.216 - 00:07:36.750, Speaker A: Iowner is going to be by. With the immutableness, we get 21,508, which we'll go ahead and copy for now.
00:07:36.820 - 00:07:52.754, Speaker B: And we'll put right here, we'll say immutable. Now, if we remove the immutable keyword, let's close this redeploy. Now, if we scroll down to Iowner, scroll up the logs, we go down to the call, we scroll down, we.
00:07:52.792 - 00:07:58.900, Speaker A: See the execution cost was much more. So we'll do double backslash paste that in here.
00:07:59.590 - 00:08:04.278, Speaker B: Gas for non immutable. So you want to keep some of.
00:08:04.284 - 00:08:30.606, Speaker A: These tricks in mind when it comes to storing variables. The reason that these two save gas is because instead of storing these variables inside of a storage slot, we actually store them directly into the bytecode of the contract. And like I said, don't worry too much about that for now. Later on in the course, we'll teach you more about storage and a lot of this low level stuff that it comes with these contracts. But for now, just know that these exist, and they're nice gaff savers if.
00:08:30.628 - 00:08:35.454, Speaker B: You'Re only setting your variables once. All right, great.
00:08:35.492 - 00:09:02.150, Speaker A: So we've just made our contract a little bit more gas efficient. Little gas efficiency improvements are going to be concepts I sprinkle throughout this course. And when we get to the more advanced section, I'm going to break down exactly what's going on and why all these gas efficiencies exist and what's going on behind the scenes. For these gas efficiencies to occur, it's a little bit in the weeds, which is why I'm going to gloss over it right now. So if it's confusing, don't worry, I wouldn't let these gas efficiencies be the thing that slow you down.
00:09:02.220 - 00:09:02.646, Speaker B: Awesome.
00:09:02.748 - 00:09:29.034, Speaker A: So we have these two gas optimizations. How else can we make this contract a little bit more gas efficient? Well, one of the ways we can make this more gas efficient is by updating our requires. Right now with our require statement, we actually have to store this sender is not an owner. As a string array, every single one of these characters in this error log needs to get stored individually. This string may not seem very big, but it's a lot bigger than the alternative.
00:09:29.082 - 00:09:30.306, Speaker B: With what we can do as of.
00:09:30.328 - 00:09:33.234, Speaker A: 0.8.4 of solidity, you can now actually.
00:09:33.272 - 00:09:36.798, Speaker B: Do custom errors for our reverts.
00:09:36.974 - 00:09:49.670, Speaker A: We declare them at the top and then use ifs instead of require, and then just add our revert statements. This ends up saving a lot of gas since we just call the error code as opposed to calling the entire.
00:09:49.740 - 00:09:51.922, Speaker B: String associated with the error.
00:09:52.066 - 00:09:56.474, Speaker A: So for example, with our require down here, and actually with all of our.
00:09:56.512 - 00:09:58.922, Speaker B: Requires, what we could do is instead.
00:09:58.976 - 00:10:02.570, Speaker A: Of having this require, we could create a custom error.
00:10:03.070 - 00:10:12.862, Speaker B: So at the top what we could do is we could say error not owner. And you'll notice that this is actually.
00:10:12.916 - 00:10:14.846, Speaker A: Outside of the contract here.
00:10:14.948 - 00:10:16.286, Speaker B: Now what we can do is we.
00:10:16.308 - 00:10:22.382, Speaker A: Can take this error not owner scroll down into our only owner. Instead of doing a require, we'll do an if statement.
00:10:22.446 - 00:10:36.562, Speaker B: We'll say if message sender is not iowner, then we're going to go ahead and revert with a not owner error.
00:10:36.706 - 00:10:57.974, Speaker A: This ends up saving us a lot of gas since we don't have to store and emit this long string here. Now in a lot of code today, you'll still see require a lot of places because these custom errors are pretty new in solidity. So you'll want to get used to writing it both ways. I wouldn't be surprised if in the future the syntax for some of these errors looks like this so that it's more readable.
00:10:58.102 - 00:10:59.018, Speaker B: But for now, if you want to.
00:10:59.024 - 00:11:18.482, Speaker A: Do a more gas efficient way than requires, you can use something like this. We could update all of our requires here for these custom errors, but for now I'm going to leave both in just to show you the differences. This revert keyword does the exact same thing that require does without the conditional beforehand. So you can actually go ahead and revert any transaction or any function call.
00:11:18.536 - 00:11:20.100, Speaker B: In the middle of the function call.
00:11:23.150 - 00:11:42.978, Speaker A: Now let's look at one more way to improve this contract. Sometimes people will try to interact with a contract that takes Ethereum or the native blockchain token without actually going through the required function calls that are needed. For example, on a Javascript evm here, I could actually try to send this contract money without calling the fund function.
00:11:43.144 - 00:11:45.762, Speaker B: However, if I were to do that, what would happen?
00:11:45.816 - 00:12:22.910, Speaker A: Would our fund function get triggered? No, it wouldn't get triggered. We wouldn't keep track of that funder. We wouldn't have that person's information updated in this contract. So if later on we went to give rewards or something, we wouldn't know about those funders. And this wouldn't be great because people would send our contract money without us ever knowing and we wouldn't be able to give them any credit or anything. Additionally, maybe they called the wrong function by accident and they weren't using metamask and they weren't using a tool to tell them hey, this transaction is likely going to fail. So what can we do in this case? What happens if someone sends this contract.
00:12:23.570 - 00:12:27.934, Speaker B: Eth without calling the fund function? Right.
00:12:27.972 - 00:12:46.210, Speaker A: Now, if we were to send this fund me contract eth, it would just go to the contract, right? And this contract just wouldn't keep track of those people. But there's actually a way for when people send money to this contract, or people call a function that doesn't exist for us to still trigger some code. And now there are two special functions in solidity.
00:12:46.370 - 00:12:51.530, Speaker B: One is called receive, and one is called the fallback.
00:12:52.110 - 00:12:58.250, Speaker A: Now in solidity there are actually a number of special functions, and two of these special functions are the receive special.
00:12:58.320 - 00:13:01.274, Speaker B: Function and the fallback special function.
00:13:01.392 - 00:13:21.154, Speaker A: A contract can have at most one receive function declared using the receive external payable without the function keyword. This function cannot have arguments, cannot return anything, and must have external visibility and a payable state mutability. What does that actually mean and or look like? Well, let's create a separate contract to go ahead and play with this.
00:13:21.272 - 00:13:22.226, Speaker B: So in here we're going to create.
00:13:22.248 - 00:13:26.498, Speaker A: A new file called fallback example sol.
00:13:26.584 - 00:13:28.022, Speaker B: And in here we're going to add.
00:13:28.076 - 00:13:31.430, Speaker A: Our basic pieces, spx license identifier, mit.
00:13:31.930 - 00:13:42.502, Speaker B: Pragma solidity 0.8.7, and we'll do contract fallback example like so.
00:13:42.636 - 00:13:57.246, Speaker A: Feel free to pause the video to catch up to this point. Once we create our fallback contract, let's create a variable to go ahead and try to test this function. We'll create a un 256 public result variable and let's create this receive function.
00:13:57.348 - 00:14:03.520, Speaker B: So we'll say receive is going to be an external payable function.
00:14:04.150 - 00:14:32.498, Speaker A: We don't add the function keyword for receive, since solidity knows that receive is a special function whenever we send ethereum or make a transaction to this contract. Now, as long as there's no data associated with the transaction, this receive function will get triggered. What we can do in here now is we can say result equals one. So let's go ahead and test this out on the JavaScript virtual machine. We compile this.
00:14:32.604 - 00:14:35.866, Speaker B: So we're going to go ahead and compile this, we'll go deploy it on.
00:14:35.888 - 00:14:37.238, Speaker A: The JavaScript virtual machine.
00:14:37.334 - 00:14:39.660, Speaker B: We're going to deploy our fallback example.
00:14:40.270 - 00:15:21.622, Speaker A: And we're going to see what result is initialized to. Since we haven't set anything for result, result of course is initialized to zero. But what if we were to send this contract some Ethereum well, receive would go ahead and be triggered here. We can actually send this contract some Ethereum directly by working with this low level interactions bit here. Don't worry about what call data means for now. Just know that this area down here is a way we can send and work with different functions, and we can add parameters to this transaction by going up here and adjusting the variables up here. If we keep call data blank, it'll be the same as if we were in metamask and just hitting send and then choosing this contract address.
00:15:21.756 - 00:15:22.054, Speaker B: Again.
00:15:22.092 - 00:15:32.394, Speaker A: We can't actually use metamask since this is a virtual machine and not one of the networks that we're working with. So if I do, for example, I change this value to one way and.
00:15:32.432 - 00:15:34.906, Speaker B: I keep everything blank, and I go.
00:15:34.928 - 00:15:43.294, Speaker A: Ahead and hit this transaction button, which again is going to be the same as hitting this send button, but only sending one way. What do you think will happen?
00:15:43.412 - 00:15:44.894, Speaker B: Well, let's try it.
00:15:45.092 - 00:15:49.230, Speaker A: We can see in the log area that we did indeed send a transaction.
00:15:49.390 - 00:15:51.966, Speaker B: And if you look at the description.
00:15:51.998 - 00:16:21.862, Speaker A: Here, you can even see it says from so and so to fallback example, receive. It looks like it called our receive function, which should have updated our result to one. So if we hit result now, we can indeed see that result has been updated to the value of one. Well, let's go ahead and delete this. Let's deploy this contract again, and this time let's have value be zero. Does receive get triggered this time? So let's pull this down. Let's hit transact.
00:16:21.862 - 00:16:33.230, Speaker A: Let's leave the call data blank. We'll leave value at zero. So this will be the same as if we had sent zero ethereum to this contract. Let's hit transact.
00:16:33.730 - 00:16:36.898, Speaker B: Looks like that went through. Do you think result is going to.
00:16:36.904 - 00:17:05.734, Speaker A: Be one or zero? You thought one, you were correct. A receive function gets triggered anytime we send a transaction to this contract now, and we don't specify a function, and we keep the call data blank. When working with any other contract, like fundme, for example. When we call one of these functions, we're actually just populating this call data bit with certain data that points to one of these functions up here. If we send a transaction and we add data to it, we could actually call one of these functions.
00:17:05.782 - 00:17:06.762, Speaker B: Now let's try this again.
00:17:06.816 - 00:17:38.498, Speaker A: Let's delete the contract again. We'll redeploy, open this up. Result is currently zero. Receive, like I said, only is triggered if our call data to it is blank. Now this time, if I add some call data to this transaction. Do you think receive will be triggered this time? If we hit transact and remix, we actually get a pop up saying fallback function is not defined. This is because whenever data is sent with a transaction, solidity says, oh well, since you're sending data, you're not looking for receive, you're looking for some function.
00:17:38.498 - 00:18:04.734, Speaker A: So let me look for that function for you. I don't see any function that matches the zero x, so I'm going to look for your fallback function. Remix is smart enough to know that we don't have a fallback function. The second special function in solidity is called the fallback function. This is very similar to the receive function, except for the fact that can work even when data is sent along with transaction. So our fallback will look something like this.
00:18:04.932 - 00:18:14.174, Speaker B: Fallback external payable result equals two.
00:18:14.372 - 00:18:40.970, Speaker A: Fallback is another one of these functions where we're not going to put the function selector because solidity is expecting this. Actually, you're already familiar with one other special function. If we go back to our fundme, our constructor, for example, is another type of special function. There's no function keyword. Solidity knows that this constructor is immediately called when we deploy this contract. So now we have our fallback function. Let's go ahead and compile this.
00:18:41.120 - 00:18:42.970, Speaker B: Let's delete our old contract.
00:18:43.550 - 00:18:46.038, Speaker A: Let's go ahead and deploy this new contract.
00:18:46.214 - 00:18:49.050, Speaker B: Let's click here. We hit result.
00:18:49.200 - 00:19:11.058, Speaker A: We do indeed see it's set to zero. Now, if I add this zero x and I send this and I hit transact, this is equivalent to calling our contract here without a valid function. So our contract goes I don't recognize what you're trying to tell me here. I'm going to refer you to our fallback. And now if we hit result, we see that it's been updated to two.
00:19:11.144 - 00:19:14.130, Speaker B: If we take this away, solidity will go.
00:19:14.280 - 00:19:30.086, Speaker A: It looks like you're trying to send some ethereum or call this contract without specifying what you want to do. Well, I have a receive function, so I'm just going to go ahead and forward you to that. So if we call transact, we hit result, we see it updates back to one, add some data, hit transact, we.
00:19:30.108 - 00:19:33.702, Speaker B: See it updates to two, no data updates to one.
00:19:33.756 - 00:20:13.410, Speaker A: Soliditybyxample.org has a wonderful little chart that we can use to figure out whether or not receive is going to get triggered or fallback is going to get triggered. If it is empty and there's a receive function, it'll call the receive function if it is data and there's no receive function, it'll just go to the fallback function. And if there's no fallback function, it might error out. So this is a lot of really fantastic information here. How can we apply this to our fundme contract here? Well, what we can do now in our fundme is we can add these fallback and receive functions just in case somebody actually sends us contract money instead of calling the fund function correctly.
00:20:13.490 - 00:20:15.026, Speaker B: So what we can do is let's.
00:20:15.058 - 00:20:21.914, Speaker A: Add a receive function. So if somebody accidentally sends it money, we can still process the transaction. We'll say receive is going to be.
00:20:21.952 - 00:20:30.026, Speaker B: External payable, and we'll just have the receive function call fund, and we'll do.
00:20:30.048 - 00:20:32.300, Speaker A: The same thing with our fallback function.
00:20:33.330 - 00:20:41.566, Speaker B: We'll have fallback external payable. We'll just have it automatically call fund.
00:20:41.748 - 00:21:08.934, Speaker A: Now, if somebody accidentally sends us money without calling our fund function, it'll still automatically route them over to the fund function. This means too that if somebody doesn't send us enough funding, that transaction will still get reverted. So let's go ahead now and let's switch to rinkbe to test this on a real testnet. I'm on rinkby in my metamask. Let's switch over to injected web3, and we'll scroll down, we'll choose our.
00:21:08.972 - 00:21:14.682, Speaker B: Fundme contract, and we'll go ahead and deploy this metamask pops up.
00:21:14.736 - 00:21:29.726, Speaker A: I'm going to go ahead and confirm the transaction and we see our fund me contract here. Right now we can see I'm the owner, we can see minimum USD, and we can see, of course, that it's a blank contract and there's nothing funded in here. If we copy the address and then.
00:21:29.748 - 00:21:34.000, Speaker B: Go to Rinkbeeth ether scan, paste the address in.
00:21:34.530 - 00:21:43.122, Speaker A: We can see that there's no ether in here, and the only transaction associated with this has been the contract creation. We saw what happened before when we hit the fund function.
00:21:43.256 - 00:21:46.354, Speaker B: Our contract was updated with a new.
00:21:46.392 - 00:22:05.978, Speaker A: Balance, and that funder was added to our array. Let's see what happens now if we just directly send this contract money without calling the fund function here. If we did this right, our receive function should pick it up and kick the transaction over to fund. So let's copy this address.
00:22:06.144 - 00:22:11.514, Speaker B: We'll go to our metamask, we'll hit send, paste the address in here.
00:22:11.632 - 00:22:19.520, Speaker A: We'll do 0.2 eth again, because this should be more than the minimum amount in USD we'll hit next.
00:22:19.890 - 00:22:22.574, Speaker B: I'll go ahead and confirm this and.
00:22:22.612 - 00:22:52.890, Speaker A: After a slight delay. If we did this right, we should see this transaction having called the fund function here. Now that our transaction has gone through and after a brief delay and waiting for Etherscan to update, we do indeed see that our balance has updated to 0.2, which of course this makes sense. And we see in the transactions list here, we see that this actually went through as a transfer. Instead of us calling the fund function, let's go ahead and remix and see if our funders was updated.
00:22:53.790 - 00:22:55.946, Speaker B: It looks like it was at the.
00:22:55.968 - 00:23:23.540, Speaker A: Zero th position of funders. We have our address, and if we take our address and pop it into address to amount funded, we can see exactly how much we had funded. This means that since we added this receive function in here, we automatically had to call our fund function up here. So awesome work. We were able to add a receive function to help people who accidentally call the wrong function or accidentally send this contract money instead of correctly calling the fund function.
00:23:23.910 - 00:23:25.586, Speaker B: Now, if they had directly called the.
00:23:25.608 - 00:24:15.398, Speaker A: Fund function, it would have cost them a little bit less gas. But at least this time they're going to get credit and add it to our funders array for having sent our funding contract money. We've even learned some advanced sections of solidity, and this is going to be the last time that we start our projects in remix. We're going to be moving over to a code editor now, where we can get even more advanced with our solidity and our setups. For the most part, you've gone over the vast majority of solidity basics. There are a number of things that we still haven't learned yet, and the reason we haven't gone into them is because they get more advanced, and understanding the real use doesn't really make too much sense until a little bit later. Some of the things that we're going to go over are enums events, try catch function selectors, abi encoding, hashing, and then assembly.
00:24:15.398 - 00:24:34.222, Speaker A: However, if you've gotten this far, you probably can read most solidity code and understand what's going on, which is absolutely fantastic. So you should give yourself a huge round of applause for getting this far and doing this. Let's do a quick summary of this more advanced section and make sure we understand what we learned in solidity. There are a couple special functions.
00:24:34.286 - 00:24:38.430, Speaker B: Some of them are receive, fallback, and constructor.
00:24:38.590 - 00:24:49.842, Speaker A: These functions don't need to have the function keyword and instead can just be called like so. Receive and fallback are two very special functions. If data is sent with a transaction.
00:24:49.986 - 00:24:52.946, Speaker B: And no function was specified the transaction.
00:24:52.978 - 00:25:22.638, Speaker A: Will default to the fallback function if that fallback function exists. If data is empty and there's a receive function, it'll call the receive function. There are a couple of keywords that can help us save gas in the long run. Some of those keywords are going to be constant and immutable. Constant and immutable are for variables that can only be declared and updated once. Once we say minimum USD is 50 times one e 18. This minimum USD can never be changed again, and this helps us save gas.
00:25:22.638 - 00:25:38.546, Speaker A: Immutable can also save gas similar to constant. However, immutable variables can be declared one time in the constructor. Once an immutable variable is declared, it can't be changed later on. In fact, if we even tried to update an immutable variable or a constant.
00:25:38.578 - 00:25:41.766, Speaker B: Variable and we compiled, our compiler would.
00:25:41.788 - 00:25:46.806, Speaker A: Give us an error saying can't write to immutable here. Or if we tried to change a.
00:25:46.828 - 00:25:50.602, Speaker B: Constant variable, our compiler would say, hey.
00:25:50.656 - 00:25:58.554, Speaker A: You can't assign to a constant variable. Sorry. In remix, if we want to send ether to a contract that's on the JavaScript virtual machine, we can deploy that.
00:25:58.592 - 00:26:00.666, Speaker B: Contract, and then in the contract we.
00:26:00.688 - 00:26:02.622, Speaker A: Can just hit the transact button without.
00:26:02.676 - 00:26:04.942, Speaker B: Any call data and update the value.
00:26:04.996 - 00:26:06.394, Speaker A: That we send with the transaction.
00:26:06.442 - 00:26:11.614, Speaker B: If call data is blank, it'll trigger a receive function if it exists, but.
00:26:11.652 - 00:26:16.960, Speaker A: If there's data that doesn't specify any of the other functions, it'll trigger the fallback function.
