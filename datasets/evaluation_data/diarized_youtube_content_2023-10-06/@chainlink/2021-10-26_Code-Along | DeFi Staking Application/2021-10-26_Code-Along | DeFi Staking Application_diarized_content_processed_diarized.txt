00:02:06.210 - 00:02:23.842, Speaker A: You. Hello. Hello and welcome back to another workshop. We're a couple minutes in already. Hopefully everybody can see and hear me. Okay. Oh, I got myself playing the background.
00:02:23.842 - 00:02:40.478, Speaker A: Let's. Let's mute myself there. We have an insane tutorial today. We have an insane workshop today. And this is a code along workshop. So you are highly encouraged to code along with us, which is going to be a whole lot of fun. And we're going to build something really cool.
00:02:40.478 - 00:03:06.600, Speaker A: So how is everybody doing today? Hello. I should probably post in the discord. This is happening. A whole bunch of friends in here. We're going to be doing some really cool stuff. This is one of my favorite tutorials here. And we're just going to be working on the back end.
00:03:06.600 - 00:03:35.940, Speaker A: The back end of this tutorial. Let me just pop this into the discord. D five workshop starts now. Cool. All right, well, we're a couple of minutes in already. I believe we can go ahead and get started. So let me show you what we're going to be building today.
00:03:35.940 - 00:04:01.322, Speaker A: I'm going to cheat a little bit. I'm going to cheat a little bit, everybody. So here's what we're going to be building. Switch to this. I'm going to cheat a little bit. I'm showing the YouTube because we're not actually working on the front end today, so I didn't prep to make sure the front end was done. But here's what it will look like when we do the front end.
00:04:01.322 - 00:04:30.398, Speaker A: We have a front end workshop for this. That's going to happen, I believe, Thursday or Friday. It's on the calendar. It's like Defi front end or something. But basically it's an application where we can stake our tokens into this contract. Right? So think about a lot of the top defi protocols like Aave synthetics, et cetera. They all have this staking functionality, or more accurately is actually deposit functionality.
00:04:30.398 - 00:05:14.260, Speaker A: A lot of people call it staking. When it's not actually staking, it's actually more depositing. But we can deposit these tokens. And once you do this, you can use this for collateral, for loans, you can use this as some type of economic incentive for someone to behave correctly, or you can really kind of do whatever you want to do with it. And it's kind of the precursor to a lot of these incredibly powerful DeFi applications, this staking or deposit, which is more accurate mechanism. And that's what we're going to learn how to do today. We're going to learn how to stake and deposit stuff into this contract so that we can then later on use it however we want.
00:05:14.260 - 00:05:57.054, Speaker A: So that's going to be an absolute blast. If you want to see, let's go to. If you want to see what this looks like, it is on my GitHub. I will drop a link in the chat here if I stake there's a free codecamp edition of this as well. We're going to use the more up to day one. So the front end currently has a bug in it. But yeah, like I said, that's totally fine because we're not even doing front end today and I will fix it for our front end demo.
00:05:57.054 - 00:06:22.680, Speaker A: But cool. So here is what all of our code looks like, and if you want to just get clone this and be on your merry way, excellent. But we're going to walk through setting this up from scratch. So like I said, if you want to jump on here and just do this, great. Let me actually remove names. There we go. Okay, cool.
00:06:22.680 - 00:06:52.286, Speaker A: And like always, this is a code along. Please feel free to jump in. Please feel free to ask questions and we'll get started. So let's jump into our code editor and let's begin building this thing. Let's begin building one of these incredibly powerful defi applications so that we can build the future of finance. Let's jump into a brand new project. Here we go.
00:06:52.286 - 00:07:29.050, Speaker A: So, yes, so this is in Python. However, the vast majority of this is going to be with solidity, right? So this is the Python edition, only JS and TS squad. It's solidity. So the framework that I'm using is brownie, which is pythonic. So if you're unfamiliar with brownie or unfamiliar with Python, no worries. You can take this exact same code, these exact same contracts, and put them into your hard hat or your typescript or whatever you want to do. So it does not matter.
00:07:29.050 - 00:08:12.854, Speaker A: But let's go ahead and get started. We're going to create a new brownie project with brownie init. And again, for those of you who are like, wait, what's brownie? What's going on here? In the description of this, there's some brownie setup instructions. So if you've never worked with Brownie before, I'm dropping these into the chat. However, like I said, you can do this with hard hat. So I'm going to add the hard hat setup instructions in the chat as well. And actually, this might be kind of fun.
00:08:12.854 - 00:08:48.866, Speaker A: This might be kind of interesting. We had a couple of people say, oh, like hard hat. TS squad, if you can squint you can almost see the currently braces. I'm going to zoom in. Don't worry. This might be an interesting question here. How many people here would want to see how quickly I can be adaptive on my feet and do hard hat instead of brownie for this demo? How many people would like to see hard hat rather than brownie? And how many people would like to see brownie? I know we have brownie on the schedule, but a couple people jumped in here, said, I'm building using hard hat.
00:08:48.866 - 00:09:05.370, Speaker A: Okay, what do we have for hard hat versus brownie? Put in the chat. Brownie or. Okay. All right, they're coming in. Okay. This is kind of fun. Okay.
00:09:05.370 - 00:09:12.182, Speaker A: Hard hat. Hard hat. Brownie. Hard hat. Brownie. Hardhat, gang. Brownie.
00:09:12.182 - 00:09:17.306, Speaker A: Hard. Uh oh, it's tight. It's one in one. Let's do it. Hard hat. Hard hat. Brownie.
00:09:17.306 - 00:09:23.146, Speaker A: Hard hat. Hard hat. Brownie. Brownie. Brownie. Uh oh. Poll says hard hat.
00:09:23.146 - 00:10:05.722, Speaker A: It's actually super close. Can you do polls on YouTube? I don't think. I think hard hat might have eked out. I think hard hat might have eked out. Can I be that slick with it that I can just flip everything and just do it in hard hat? What do you all think? Do you think I'm a good enough programmer to just do everything in hard hat and be a little bumpier? All right, well, in any case, most of this is with solidity, so. All right, ready? I'm going to go ahead and do this in hard hat. A lot of people are saying hard hat.
00:10:05.722 - 00:10:22.594, Speaker A: I'm going to do this in hard hat. Like I said, the code is up in python. It's up in Brownie. You can go check that out. Like I said, I think I just posted it. A link to it in the chat. Yeah, I posted a link to it in the chat, but we're going to do hard hat here.
00:10:22.594 - 00:10:47.242, Speaker A: Oh, goodness. This is good luck, me, right? All right, we're totally switching gears. We're doing it in hard hat. I mean, the good thing is, if you're here for Brownie, the people here for brownie, you actually have the demo code that you can refer back to. If you're here for Hardhat, we get to follow along. We get to do this together. However, the code, the solidity, the important part is going to be the exact same.
00:10:47.242 - 00:11:30.194, Speaker A: Right? So we're just working on the back end of this application here. We're just working on the back end. Oh, goodness gracious. Okay, let's do it. So for hard hat, I think I just put the hard hat setup instructions in the chat and those people who are excited to see this in Brownie, I actually do this in the freecode camp solidity video and let me put a link to that. I do this whole thing. Yeah, let me grab a link to that just so that we don't leave the people who came here for brownie high and dry.
00:11:30.194 - 00:11:59.380, Speaker A: So for people who are here for Brownie, that link on YouTube actually shows me going through this exact same thing in brownie in that freecodecamp video at that timestamp. So feel free to use that and have fun. But yeah, here we go. We're, we're gonna see if I can do this in hard hat. So to get started, we're going to do MPX hardhat, right? So if you have hard hat installed globally and then actually, let me just, I'll flip to head docs. We have 45 minutes left. I got to be fast here.
00:11:59.380 - 00:12:42.874, Speaker A: So if we flip to the hardhat docs, go to the docs, you first want to save it globally and then you can just do MPX hardhat to go ahead and get started. The docs for hardhat are awesome. So we'll do MPX hardhat and this will go ahead and it'll start spinning. Give us this output and let us spin up a project. All right, here's another poll. What do we want? Typescript or javascript? What do we want here? YouTube chat what are we feeling? We feeling typescript or JavaScript? JavaScript is the bane of my existence, but I can do stupid things and get away with it in JavaScript. What are we thinking? YouTube what are we thinking? Peeps? Types.
00:12:42.874 - 00:13:08.854, Speaker A: Oh goodness, they're coming in. Javascript. JavaScript JavaScript JavaScript Typescript Typescript Typescript Type JavaScript JavaScript Type JavaScript JavaScript JavaScript TypeScript TypeScript blah blah blah, JavaScript JavaScript hardhead is awesome. Anyways, some of you are posting many times so that I don't notice what's going on. You all cheating. All right, well, I think JavaScript is the. All right, so more people are saying JavaScript.
00:13:08.854 - 00:13:56.646, Speaker A: So we're going to start with JavaScript here. But typescript is really good too. And if you're really solid with typescript, you'll know how to redo it. For typescript, we're going to take, yes, a whole bunch. We're going to have hardaid go ahead and install a whole bunch of stuff for us and we're creating our new demo project here and I'll try to clean everything up and put this on GitHub for those of you who are here to refer back to the code so that it's not just this video that you have. But yeah, like I said, the contracts themselves, you can check that brownie link because the contracts aren't going to be any different. Right.
00:13:56.646 - 00:14:21.120, Speaker A: The contracts are going to be exactly the same. It's really just the tooling around the contracts that are going to be different. So again, if you're here for brownie, the contracts are going to be the same. So it doesn't matter, but. Okay, cool, there we go. So we have our dummy project here with a greeter sol sample script. I usually like to add this tool called hard hat deploy actually, and it's probably right in here.
00:14:21.120 - 00:14:38.534, Speaker A: Hard hat. Hard hat. Oh my goodness. Hard hat deploy. Come on. Where is the plugins? So in the plugins there's a plugin. Oh, it's because it's in the wrong place.
00:14:38.534 - 00:15:11.182, Speaker A: Documentation, plugins. I should go to the plugins, look for the plugins. Hardhat deploy. And this makes deploying stuff a lot easier. So this is something that I pretty much always use. And we'll just do yarn add, hardhead deploy. And what this will do is so right now to deploy our contracts, we have this scripts thing and this is what deploys everything.
00:15:11.182 - 00:15:35.526, Speaker A: And I'm going to zoom out just a hair. This is what deploys everything. But we actually can put it in our deployments in a new folder called the deploy folder. And whenever we run like hardhead node or we spin up a node, hardhat will know. Okay, first I'm going to deploy everything in this deploy folder and then go ahead. But I've already stalled long enough. Let's jump in.
00:15:35.526 - 00:15:49.674, Speaker A: Let's start making some stuff. So we're going to have two main contracts here. We're going to have our depth token Sol. Let's get rid of the greeter. Goodbye delete. See you. See you never.
00:15:49.674 - 00:16:22.886, Speaker A: And we're going to have this thing called Tokenfarm Sol. Dap Token is going to be really simply, it's going to be like our governance token, if you will. Right. It's going to be the reward token. Whenever somebody stakes on our platform, we're going to reward them with this DAP token here. And is there another workshop right after this? I don't think there is. We might go over a little bit just because now I'm being, trying to be light on my feet here and adhere to the people.
00:16:22.886 - 00:17:14.198, Speaker A: What day is today? This day. Okay, so we can go over a little bit, as long as I don't have another thing. But yeah, so DAP token, this is going to be our reward token, right? This is what we're going to give out to people. And this is going to be like a super simple ERC 20. So we can just code it as such, right? So 0.8.0. And then we'll do the SPDX license identifier it, and then we'll create our contract depth token and boom. Okay, this is what we're going to be making now.
00:17:14.198 - 00:18:25.390, Speaker A: I am a big fan of using open Zeppelin packages. Zeppelin open Zeppelin contracts. You can definitely check out their documentation to get started, get started contracts. And they have all these different packages that have basically everything that you need to like build one of these things, right? So they have an ERC 20 token, which again, this ERC 20 is kind of a lot of the tokens that you see can onbot Ethereum and you can build an ERC 20 super easy with open zeppelin. So we're just going to do import at open zeppelincontractstoken sol what we can do now is since we've imported this from open zeppelin, all the code in this ERC 20 sol, we can just inherit it to our DAP token. We can just say DAP token is ERC 20. Now all we have to do is make a constructor where we say ERC 20 and we add just the name of the token.
00:18:25.390 - 00:19:05.900, Speaker A: And let me do this. We add just the name of the token, and we add the name of the token and the symbol. So we're going to call this DAP token and the symbol is going to be DAP. And now we just have to do in here, we'll do a little mint message sender. We'll mint some initial supply. So we'll say one. 2345-678-1234 so this is like 1000 here.
00:19:05.900 - 00:19:29.794, Speaker A: Expected this, but got this. Yeah, makes sense. And that's it. Our DAP token is done, right. This is all we need. When we inherit the functions of this is ERC 20 into our DAP token, we get all the things like approve transfer from et cetera. So this is really all we need.
00:19:29.794 - 00:20:10.366, Speaker A: And we can even test it out with MPX hard. Heck, well, we can see if it compiles at least. Oops, I forgot to install this yarn. Add that. While that's installing, I'm going to look at some questions here. Chad, I'm curious, why do you prefer JS or typescript over Python? I prefer Python because life is harder with Javascript and typeScript. Yeah, there is the notion of as sweetheart Fortnite says the Javascript everywhere notion where it's like oh well, I'm just going to use JavaScript on the front end and the back end.
00:20:10.366 - 00:20:39.420, Speaker A: That way I don't have to kind of know different languages. I disagree with this. I think Javascript is not good for a back end. I think it's the front end, so you have to use it on a front end, but I think it kind of sucks on the back end. But that's me. What was the name of the plugin? Yep, hardhead deploy JS is more universal. Are you not a fan of the enter keyword? Patrick, what's the license for? Good question.
00:20:39.420 - 00:21:27.480, Speaker A: It used to be a newer thing, it was added to the compiler like hey, you're missing a license identifier to make licensing easier for smart contracts. Right, since everything is open source, but not every open source has the same permissions and stuff like in the meat splace law world. This just kind of saves you from kind of having to deal with any weird legalities. So you can change your license identifier to say hey, you're free to fork this code and do whatever you want with it. Obviously it's open source, so people could do that if they wanted to anyways. But this is kind of like the legality of it. Good question.
00:21:27.480 - 00:21:59.154, Speaker A: So that's it. So that's our whole thing here. I'm not going to write any tests for this, but normally you would want to go ahead and write some tests for this. We're going to jump into our token farm now and the token farm is this is really where all the meat of this application is, right? So this is where we're going to stake some stuff. We're going to unstake and we're going to print out a reward, right? So we're going to give people a reward for staking with our contract. So let's go ahead and do this. I'm just going to grab this line again.
00:21:59.154 - 00:22:34.654, Speaker A: Let's go ahead and make this. So we're going to do contract farm and we're going to start like that. So in here, first thing that let's kind of think about this for a second. What are the things that we want to do, right? And let's just put some comments. So we want to stake tokens, that's the first thing that we're going to want to do. Then we're also going to want to let people unstake tokens. We're probably also going to want to reward users or issue tokens to the people who are staked on our platform.
00:22:34.654 - 00:22:58.162, Speaker A: And is that pretty much it? Yeah, that's pretty much it. Those are going to be the main functionalities that we have. Obviously we'll have other functionalities around this, but this is mainly what we want to do. Right. We want people to stake tokens, unstake tokens, et cetera. So let's go ahead and work on each one of these as such. So the first thing we want to do is have people stake tokens.
00:22:58.162 - 00:23:37.214, Speaker A: So let's go create a function called stake tokens. And what do we think they should take as parameters? Well, a six amount, an address of the token they'd like to stake. Right. So if I want to stake a token, it's going to be annoying. You all passionate about what frameworks you like. Oh my goodness, the caps locks in the chat. I love it.
00:23:37.214 - 00:24:07.050, Speaker A: So we're going to make a stake tokens thing and we're going to make this public, obviously, because we want anyone to be able to stake on our wonderful platform. And I'm going to close this off because we're not going to need to look at that for a while. We're going to make this public. And in here, what do we need to do? Actually, let me turn this off. Let me turn this off for now. In here, what do we need to do? Why is prettier not working? Prettier doesn't want to work for me. That's fine.
00:24:07.050 - 00:24:40.040, Speaker A: In here, what do we need to do? Well, first let's make sure they actually send amount. Yeah, I did yarn add the open zeppelin package. Yes, you're going to need to yarn add open zeppelin and yeah, I also need pragma solidity. Pragma solidity 0.8.0. We're going to need to require the amount is greater than zero. So we'll start with there. We'll just say amount cannot be zero.
00:24:40.040 - 00:25:28.214, Speaker A: And let's see. So the first thing that I think of when I see this, I think there's a lot of really shady tokens out there. Maybe I only want this platform to allow staking of tokens that actually are good and actually have some value. So maybe I want to have some allowed tokens array or something. Right? So these are the things that are important to think about when you're making these, and it's really good. Best practice when working with tokens to not just allow people to use any token, right, because they could send you some stupid token that has no value and try to just get all your yield or your rewards or something. So it's really best practice to have some type of checker here.
00:25:28.214 - 00:26:03.630, Speaker A: So I'm going to create a function called token is allowed. So I'm going to say require token is allowed. We're going to pass in the token and if it's not allowed, we're going to say token isn't allowed. All right, cool. So I've already created another function that I need to make. So let's do function token is allowed. We'll take an address token and we'll make this public and it's going to return a boolean.
00:26:03.630 - 00:26:39.642, Speaker A: So if they try staking a token that we're cool with, we're going to say, okay, cool. Yeah, you can stake that. If not, we're going to say, hey, beat it. Right? What are you doing? Stop being crazy. So what we're going to do is in here, we're going to have to go to an allowed tokens mapping or an allowed tokens array. Typically for something like this I would just use a mapping and then do like a mapping of yes or no. But we're also going to loop through this array later.
00:26:39.642 - 00:27:35.694, Speaker A: So for now we're just going to have it be an array. But yes, it would probably make more sense at first glance to do this mapping, but I'm going to do it, like I said, as an array. So in here we're going to loop through a new array that we create. So at the top I'm going to do, I'm barely going to use hardhead anyways, so that's cool. So we're going to do address array public s allowed tokens. Now you might be asking, okay, why am I doing this s underscore? And the reason we're doing this is because storage in solidity is really expensive to read and write to, right. And so anytime you have a variable that's outside of these functions, it's in storage and it's going to be really expensive to read and write to.
00:27:35.694 - 00:28:07.400, Speaker A: You might have seen before, I do a lot of demos where I do the parameters with like an underscore at the beginning. It's really just to say, hey, this is what a storage variable looks like. And this is what a memory variable looks like. Memory variables are a lot gas cheaper. So kind of by convention I'm putting this s underscore to say, hey, this is storage. Right? Another thing you could do is for all your memory variables, you could put like an underscore on as well. But this is kind of the newer convention that I've been using and I've been liking it a lot.
00:28:07.400 - 00:29:27.010, Speaker A: But any case, we have this array and what we're going to do is we're going to loop through it, right? So we're going to say 456 allowed token index equals zero allowed tokens allowed tokens is less than allowed tokens, slow tokens length allowed tokens index plus. And this is a typical for loop. So we're going to just loop through this array that we have and see, okay, is that token in. There's this token in there. If yes, great. If no, great. So we'll just say if allowed.
00:29:27.010 - 00:30:17.330, Speaker A: If s allowed tokens. This is pretty guess inefficient, but it's fine. We're going to be accessing this so much if allowed tokens of that index equals token and we're going to say, hey, great return true, that is allowed. Otherwise, outside the loop, we're going to do return false. So now we have a function seeing, checking to see if a token is allowed. However, this is empty, doesn't have anything in it, right? So we need a way to add tokens to it. So we're going to do function add allowed token.
00:30:17.330 - 00:30:47.446, Speaker A: And this is what we're going to do. Add allowed tokens. And this is how we're going to add tokens to our contract here, right? So we're going to do address token, make this public. Then we'll just do slowed tokens. Push, push the token on there. Awesome. Here's what we have so far, right, let me zoom out just a hair.
00:30:47.446 - 00:31:22.440, Speaker A: We don't have a lot, right? We have the start of a function to stake tokens. We have a way we can check to see if a token is allowed. And then we have a way to add allowed tokens. Does anybody see an issue with the way we currently have this set up? Right? Does anyone see an issue with where we have currently set up? And I'm looking at some questions now. Why everyone using Un 256 instead of just un? Great question. So a UN 256 is actually the default for Un. So Un 256 and Un are the same.
00:31:22.440 - 00:31:45.802, Speaker A: But I just like being explicit. I think it's better to be explicit saying hey, this is a 256 versus just the default. Great question. Can you repeat why you're using an array instead of a un to bool mapping? Yeah, it makes something later easier. That's it. Looping, in contrast, is sketchy. No, it is really sketchy.
00:31:45.802 - 00:32:24.860, Speaker A: And that's why I'm asking, hey, what's wrong with this? It's sketchy because especially with a dynamic array, you could loop forever. Is token allowed any advantage in it not having a modifier? Yeah, well, it doesn't matter, right? Anybody can check. Anybody could call this function, right? We're not saving state here, right? We're just checking to see if a token is allowed so there's no advantage there. Hard hat gave me this compile error. Well, let's see if it gives me a compile error. Compile was good since you started using hi fat. 35 years.
00:32:24.860 - 00:32:43.578, Speaker A: Brownie is amazing. You guys are all crazy. Can you please identify some patterns? Consider gas efficient? If I have time, yeah, we'll go into more gas efficiency stuff. It's public. Yes. So everyone can add tokens. Exactly.
00:32:43.578 - 00:32:53.602, Speaker A: Need ownership constraints. Yes. You can allow duplicate tokens? Yes. Product should be ownable? Yes. Add only owner. Yes, you all have it. Spot on.
00:32:53.602 - 00:33:32.590, Speaker A: Right. Now any schmuck and bozo could call add allowed tokens and can add some stupid worthless token. So we need to add some ownership restraints. So for those of you who are familiar with modifiers, we could create our own modifier called like only owner. But again, I love working with open zeppelin. So we're going to add, we're going to import some open zeppelin stuff. So we're going to do import at openzeppelincontracts accessownable Sol, and we're going to make our token farm contract is ownable.
00:33:32.590 - 00:34:05.740, Speaker A: And again, you can check out the Openzeppelin documentation, scroll down to access. And this kind of has all this stuff. We're now ownable. And we get access to this modifier called only owner. So now what we can do is in our add allowed tokens, we just do a little space here and we can say it's only owner now. Only we can add new tokens. Great, you all have it.
00:34:05.740 - 00:34:22.094, Speaker A: Yeah. So now no randos can add tokens. Cool. So now we have the way to add tokens and we have a way to check to see if those tokens are good. Perfect. Let's go back to our stake tokens now. Awesome.
00:34:22.094 - 00:34:49.110, Speaker A: Great. So we're checking to seeing the tokens. Cool. If it's all good. Awesome. What do we do now? Well, we probably want to let them stake the token, right? We're going to want to transfer the token from them to us. And by us, I mean like this contract, right? This contract that we're creating, this contract that we're deploying.
00:34:49.110 - 00:35:41.876, Speaker A: Let me zoom back in again. So how do we do that? Well, we're going to use what's called an interface. So anytime we want to call a function or work with a function of another contract, one of the easiest ways to do is to use the interface. So interfaces define all the functions that a contract has. And I'm going to borrow from open Zeppelin again, IRc 20. Actually, let's just go to open Zeppelin confects. I'm still laughing over how aggressive you hard hat peoples are.
00:35:41.876 - 00:36:02.740, Speaker A: See, this is what Javascript does to you. It makes you aggressive and angry, like we want Javascript. I'm just playing, guys. I'm playing. But am I? So here's an interface for ERC twenty s, right? So here's an interface for a token. So you can see this interface. It has a whole bunch of functions.
00:36:02.740 - 00:36:38.708, Speaker A: None of them are actually defined, right. The interface just defines what functions you can call on a contract. And we'll give it an address. So it'll call that function on the contract at that address and do whatever it does. So we're going to go to the top. We're going to do import open zeppelincontractstoken ERC 20 IERC 20 sol. Actually, I barely had to use hardhead, so that's kind of cool.
00:36:38.708 - 00:37:35.160, Speaker A: And now we have this interface that we can strap an address to and call functions are so back in our stake tokens. Now what we can do is we'll say IRC 20 of that token address. So we're doing the interface at this address, we're going to call transfer from, and we're going to send from message sender to this address, to this smart contract, and then the amount that they're sending. So since we're doing this transfer from function, this means that the User will themselves have to call the approve function at some point. We can't call the approve function from this function, they have to call it themselves. Most user interfaces will have like a separate, we'll have the button actually work. Okay, now I've kicked off a JS war.
00:37:35.160 - 00:38:07.264, Speaker A: I'm so sorry. You're right. JS. Will this be available after live? Yes, it will be available. Can you explain what an interface is? I will. So the interface, like I said, when somebody does this stake tokens function, we want them to send their tokens to our contract, right to our address. Now we need a way to know what the functions are of the contract address.
00:38:07.264 - 00:38:32.440, Speaker A: So what we do is basically this interface. It has all the functions that we can do. Like if we look in here, transfer from should be in here, there's this transfer from function. Right. We need a list of all these functions that we can call in our interface. So we just say, hey, and remember this token is an address. We just say, hey, there's an address out there that we've called token.
00:38:32.440 - 00:39:00.448, Speaker A: There's an address out there with all these functions. Let's go ahead and call some of those functions. And here's the address that has those functions. So hopefully that was clear. If it wasn't, yeah, let me know. But once we pass the token parameter to our interface, we can then call all those functions address. This equals the contract address.
00:39:00.448 - 00:39:46.480, Speaker A: Yes. Is it cheaper to use openz import than create the modifier? It actually would be gas cheaper for us to create our own, but I like working with open zeppelin and this is a demo, so great question though. So the token must be an I ERC 20 token. Yeah, so this I thing is actually like some common syntax. It means, it stands for like interface. So if you go in here, actually, you'll see there's two almost confusing contracts, right? There's ERC 20 sol and IERC 20 sol. So the IRC 20 sol doesn't have any of these things defined, right? The ERC 20 sol, it does have all this stuff defined, right? It's got a whole bunch of stuff in its functions.
00:39:46.480 - 00:40:27.180, Speaker A: That Interface is a lot gas cheaper and it's how we, it's how we start using these functions. So that, that wasn't very clear at all. I'll make it a little easier with just this. The rule of thumb, if you want to deploy a contract, if you want to deploy a contract, you need to have all the functions defined. You need to have all the functions defined. You can't have a function that doesn't do anything. If you want to use a contract that has already been deployed, you use an interface.
00:40:27.180 - 00:41:14.364, Speaker A: So that's going to be your rule of thumb there. Great questions. Do we need to approve specific amount? Yes, you do. But I can't approve here, right? If any contract could call approve on your token, then you would be insecure, right? If any other contract could call approve, then you'd be ruined. So the approve function can only be called by a user, not through a contract, and that's how that works. So on the front end of your website or your application, there will be like a hey, call this approve function directly on the ERC 20 contract, and then we can call the stake tokens function. Great question.
00:41:14.364 - 00:41:33.184, Speaker A: What if the token is not an ERC 20, but we used ERC 20. Great question. So if it's not an ERC 20. Maybe it's an ERC seven seven. Or an ERC 677 or something. Again, remember, this interface just defines what functions it has. And you don't even need to use all these functions.
00:41:33.184 - 00:42:02.110, Speaker A: Let's say the only function you use is transfer. You could still use this interface. In fact, you could delete all the functions in here except for transfer if that was the only function you wanted to use. So if it's not an ERC 20, that's totally fine, so long as the functions you want it to use are in the interface. Right. If there's some weird function in there, not that part of an ERC 20, you'd need to make your own interface. Amazing question.
00:42:02.110 - 00:42:25.750, Speaker A: But IRC does not have implementation on transfer foam, so it's not doing anything. Great question. So it doesn't. Right. But it doesn't matter because we're passing an address. All we're saying is. We're saying, hey, call transfer from function on whatever contract is at this address.
00:42:25.750 - 00:42:45.000, Speaker A: I think it's an ERC 20. That's literally what we're saying. And solidity will try this. And if it's not an ERC 20 at that address, it'll error out here. Right? So we're saying call transfer from at this address. And here are all the functions and stuff. Here's what the contract kind of looks like.
00:42:45.000 - 00:43:11.460, Speaker A: I think it's an ERC 20. Great questions. I'm having problems issues here. Definitely check the getting help, um, on the chain link docs. Maybe make a stack overflow question. How can the setup be reused for NFT staking? You would just do I ERC 721. Boom.
00:43:11.460 - 00:44:06.536, Speaker A: Anyways, let's move on. So now that we've sent tokens here, our contract needs to keep track of how much we've actually sent here. That way we know how much we can give back as a tokens and everything. So what we're going to do is we're going to create a mapping and we're going to create a mapping called staking balance. This is going to be a mapping of token address, address to owner to balance. It's like a mapping within a mapping. So we're going to do a mapping of an address that's mapped to a mapping address to a UN 256.
00:44:06.536 - 00:45:14.424, Speaker A: And we'll make this public. We need our contract to keep track of the staking balance. And again, we're going to do s staking balance because this is in storage and we're going to have to update this as people deposit tokens and I clearly thought I could do this much quicker while explaining everything. So in here we're going to do f staking. Balance of the token address of message sender equals whatever they currently have in here plus the amount we want to keep track so that when we can send rewards later on and boom, that's basically all we need for this staking bit. Now because we're kind of coming up on time. I'm not going to add the rest of the functionality in here, but you can definitely, like I said, you can check out that link that I put in the chat to kind of see what the rest of these contracts looks like.
00:45:14.424 - 00:46:00.890, Speaker A: Again, it doesn't matter if you're in brownie or not or hard hat because the solidity will be exactly the same. But for the purpose of this demo, I want to walk through the tests because the tests are really important and I want to walk through deploying these to kind of show you how this works a little bit. So we're going to delete this. Goodbye. We're going to make a deploy script here because a lot of people want to deploy. So we're going to make a deploy script here. And this is where I'm like, okay, all right, Patrick, this is where hold, just let me open up something real quick.
00:46:00.890 - 00:46:34.148, Speaker A: I want to make sure I don't totally make a fool of myself. Your beloved Javascript. I try to touch Javascript only when necessary. Oops, hold on, just opening up my reference. Something about coding everybody is oftentimes it's not about knowing the right answer, it's about knowing where the right answer is. And I'm a big believer in that. We're back.
00:46:34.148 - 00:47:30.020, Speaker A: All right, cool. We're not going to have time to go into adding a price feed to this so that we can price the collateral and everything. But again, that's all in, that is all in the GitHub associated with this. Anyways. All right, so let's go ahead and do deploy script here. So in our deploy create a new file one, deploy contracts, contracts js. And in here we're going to do some stuff.
00:47:30.020 - 00:48:13.166, Speaker A: So in here we're going to use when we run MPX hardhead deploy, this is what's going to run. So we're going to do module exports equals async function and we're going to do a couple of things. We're going to do get named accounts. You'll see what all this does in a second. We're going to do deployments, we're going to do get chain id again if you wanted Brownie, you actually have a GitHub right now, so congrats. So if you're confused like, hey, what's going on? Don't worry about this right now. This is what's going to run once we call MPX Hardhat deploy.
00:48:13.166 - 00:48:47.914, Speaker A: So we're going to need to grab a few things. So first we're going to need const deploy log from deployments. Do const deployer equals await at named accounts. I'm going to tell you what this all does in a second. Const chain id equals await. Get chain id. All right, so when we run MPX hardhead deploy, we get a whole bunch of stuff stuck into this contract, which is great.
00:48:47.914 - 00:49:17.410, Speaker A: Oh, and I actually do have to go in ten minutes because I have another event. So I'm going to make this deploy script super fast. And then in order for us to actually deploy this stuff, we need this deploy function to deploy. This log is just for logging. And we get this from this deployments object. We want a deployer which is going to be like the account that we deploy from. And then the chain id is obviously the chain id of the network.
00:49:17.410 - 00:49:55.666, Speaker A: So this getnamed accounts is the only thing we need to update though in our hard hat config. We're going to need to add something down here. We're going to need to actually add a bunch of stuff down here. First thing we're going to need to add is outside of here's. I'm going to be a little explicit. We're going to do default network hard hat. Going to go super fast.
00:49:55.666 - 00:50:13.814, Speaker A: Maybe I'll just rip through this. What's wrong? What are you mad about? So that I can answer some questions. Yeah, you know what? I'm going to see how fast I can code this thing. Yeah. Okay. Named accounts. And this just says, hey, here are the accounts that we're going to use.
00:50:13.814 - 00:50:53.010, Speaker A: So we're going to have a deployer account default zero. So we're going to have a deployer account, a deployer mnemonic where we're going to default to the zero width account in the mnemonic and great, that's all we need there. But I know I'm going to be speeding through a little bit here. And now what we're going to do is we're just going to go ahead and deploy this contract. So we're going to say const token farm. We're not even going to deploy the DAP token yet. We can deploy that later.
00:50:53.010 - 00:51:24.206, Speaker A: Equals await deploy token farm. Yeah, I'm not going to have time to write tests either. Oh man, I super over budgeted. But this will still give you a good sense of what's going on from deployer. So this is that named account that we just added to our hard hat. And we're saying this is the account that we're using to deploy. There's no args, but we'll say log true, and that's it.
00:51:24.206 - 00:52:07.706, Speaker A: That's our whole deployed script. So now if I do Mpx hard hat ploy, it'll spin up unrecognized task deploy or Mpx hardhat node. Oh, whoops, sorry, I forgot to add in the hard hat config. I need to add the hard hat deploy in here. Sorry. So the top I'll do require hard hat deploy now. If I do Mpx hardhat deployed now, it should work.
00:52:07.706 - 00:52:49.610, Speaker A: All right, cool. So it compiles and then it deploys. What else we could do? We could do MPX hard hat node, and we'll spin up a node now that has this token far deployed. It's deployed here. We didn't have time to kind of go over contracts, go over testing and everything, but we did do this in hardhead, which was kind of fun, just really simply here, really kind of stripped down version of this token farm here. But again, if you want to see kind of the whole code and everything, I'll kind of just briefly go through what the rest of it looks like. Here's this token farm contract.
00:52:49.610 - 00:54:03.054, Speaker A: We have our stake tokens function, which it actually does a couple of other things, but it stakes some tokens, and the issue tokens function looks like this, which is pretty clever, which is pretty cute. It goes through all the stakers, it finds their address, right, and then it transfers them some amount. So we take this dap token, which is our reward token, and we transfer it based off of this get user total value. And this get user total value is calculated by the collateral that they've staked, the amount of tokens that they've staked using this function, which grabs, which figures out how much each one of these tokens are worth with this get token f price, of course, coming from a chain link price feed. So I know we kind of ripped through this really quickly and we didn't quite get to go through everything, but that is the gist of how you would set something like this up. And it looks like there were a ton of questions, which is awesome. Hopefully this was still helpful, but we do have five minutes, so I'm happy to jump into any questions here.
00:54:03.054 - 00:54:50.574, Speaker A: If you want to see more hardhat and more brownie, again, definitely check out the hard hat starter kit. If you go to tests, there are some unit tests in here. This is a great place to go ahead and check out some stuff. We also have, for those of you who are like oh man, typescript or die, we also have, this is going to come later. Stephen Fluan is actually going to be demoing this, but this is a typescript project of like a decentralized raffle. You can see all the deploy scripts in here. Things look a little bit different in here in the typescript edition, but it's basically the same.
00:54:50.574 - 00:55:38.220, Speaker A: And there's also typescript tests in here as well that you can kind of play with and move around. So with the last four minutes, let's jump into some questions here. Do we need to use safe transfer from instead? If you want to, it's up to you. Could you put a required to be sure it's an ERC 20? Could I put a required to do? Probably, but that probably wouldn't be worth it, right? Because you're going to spend gas to check to see to make sure it's an ERC 20, where if it's not an ERC 20, it would error out on that transfer from statement anyways, right. If it didn't have that transfer from function, it would break. And that's basically your require. Yep.
00:55:38.220 - 00:56:12.090, Speaker A: Does IRC 20 create token instance, thus able to transfer from function? It doesn't create a token instance, it creates an ERC 20 instance. So it creates an instance of a contract that has those functions defined in the ERC 20. Right. It has no idea what they do, it just knows that it can call them on that address. Great question. We're going to see the timetable for next session. Hack chain link.
00:56:12.090 - 00:56:51.620, Speaker A: Hack chain link. That has everything. It's going to be early to do with JS. No? Yes, it's always too early. Why don't you like JS? So, I know I joke a lot. I partially don't like JS because it's really fun to hate, but I don't like JS because it does all this weird threading async stuff and I feel like it's hard to debug. And there's like 50 different standards for the same thing, like yarn and NPM.
00:56:51.620 - 00:57:50.470, Speaker A: People overuse packages and node modules is like two years worth of just garbage. Node modules is insanely big. And that's basically why I don't like it for smart contract development, back end stuff I think it's necessary for front end. I think Async makes a lot of sense for front end, but I think for doing a lot of the smart contract stuff where a lot of what you need to do is synchronous, it makes more sense to use a synchronous base language like Python. Python does have async support, but those are my feelings. I care about developer experience and I feel like it's much easier to debug and work and find support for Python, whereas JavaScript, it's like, well, you're using Es six versus Es five module. Well, this only works in this framework and that only works in that framework and that's why I don't like it.
00:57:50.470 - 00:58:17.020, Speaker A: Does hard hat have anything similar to brownie mixes? No, but on the Chainlink GitHub we have a bunch of starter kits. So look at the hard hat starter kit. This code has been really helpful. Can we review this later in the hackathon to finish it? Great question. Yeah, I can post this. I'll post it on GitHub. I'll say like unfinished workshop and then on my GitHub and I'll post it in announcements.
00:58:17.020 - 00:58:58.584, Speaker A: Hopefully this was helpful. I know we didn't get quite as far in as we would like, but yeah, this literally, it gave the real basics of kind of the start of the contract and how to deploy it. We didn't go into tests, but again, you can check out the tests again if you want brownie on the Brownie project or go to the hard at starter kit to look at tests there, how they're formatted or the decentralized raffle that showed. Will the hackathon be going over making bots on the blockchain at any point? Go to the decentralized raffle workshop. That's going to be really good. So bots don't activate themselves. Somebody has to activate a bot.
00:58:58.584 - 00:59:19.476, Speaker A: So that's actually where Chainlink keepers comes in and is really powerful. Is there a workshop for gas efficiency? Go to the opcodes workshop again. Go to hack chain link. Scroll to the schedule opcodes. Andre is giving a workshop. It's not necessarily on gas, it's on opcodes. But he goes over a lot of really cool gas stuff.
00:59:19.476 - 00:59:39.130, Speaker A: Alex Rohn hitchhikers has a hitchhikers guide. Let me find this Alex Rohn at Smartcon. He did a really great workshop on gas efficiency and stuff. I just posted it in the comments. It's phenomenal. Definitely. Go check that out.
00:59:39.130 - 01:00:21.096, Speaker A: Type air getchain. Id is not a function you'll have to make a stack overflow for that. Does it cost less gas to copy and paste code from open zeppelin? From open zeppelin, GitHub or import? So when you import, that's actually exactly what it's doing. It's copy pasting it into your code. So if you want all the code from open Zeppelin, just use the import functionality. Any tips for mocking things like uniswap? Yes. Use an interface exactly as we showed here.
01:00:21.096 - 01:00:42.412, Speaker A: Use an interface and just put in that interface the different functions that you want. Yes. This is all I do, coding tutorials. Can you tell me the difference between a hardhead and brownie? Brownie is pythonic. Hardhead is Javascript. That's it. Which is better? Neither one is better.
01:00:42.412 - 01:00:55.172, Speaker A: It just depends on what you like. That's it. Neither one is better. I like brownie, but that's just because I like Python. All right, cool. Well, hopefully everyone got some value out of this. I got to jump off.
01:00:55.172 - 01:00:58.980, Speaker A: Thank you all so much for being here, and good luck at the hackathon.
