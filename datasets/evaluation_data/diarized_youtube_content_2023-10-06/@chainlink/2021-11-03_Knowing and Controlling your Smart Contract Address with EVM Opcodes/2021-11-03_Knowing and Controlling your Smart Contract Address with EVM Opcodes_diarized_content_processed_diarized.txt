00:00:23.780 - 00:00:37.728, Speaker A: Everyone, welcome to another channeling workshop. We are going to just wait for a couple of more moments for everyone to jump in and then we can start.
00:00:37.894 - 00:00:41.680, Speaker B: So I will be monitoring this live.
00:00:41.750 - 00:01:17.310, Speaker A: Chat on YouTube, so feel free to post comments, questions, whatever during the workshop. But obviously at the end we will have a little q a session so I will try my best to answer all the potential questions you guys may have. Okay, let's officially start. I think we're good. So welcome again. I hope everyone is having fun enjoying this hackathon. I hope you guys build some amazing stuff.
00:01:17.310 - 00:01:34.000, Speaker A: Really looking forward to this. And today's workshop is about knowing and controlling your smart contract address with EVM opcodes. It's basically I will explain to you how EVM handles smart contract deployment.
00:01:35.940 - 00:01:36.352, Speaker B: Which.
00:01:36.406 - 00:02:20.690, Speaker A: Opcodes is EVM using for that? And also we will try and see the way how to know your smart contract address even before deployment to whatever chain. So it's like really awesome and powerful feature. My name is Andre Rakich. I'm a blockchain developer and new developer advocate at Chainclabs. On this slide you can see my twitter and LinkedIn handles, so feel free to reach me out after this workshop if you have any questions, comments, whatever. So let's start with the agenda. First we are going to cover what TVM is and how it works exactly.
00:02:20.690 - 00:02:34.192, Speaker A: Then I will explain to you what create two opcode is and how you can use this upcode to pre compute your smart contract addresses even before deployment.
00:02:34.256 - 00:02:36.000, Speaker B: To the actual blockchain.
00:02:36.160 - 00:02:50.612, Speaker A: And finally, we will have a little q a session at the end where you can just ask me whatever you want. So I will just paste you the link to this GitHub repo.
00:02:50.756 - 00:02:52.090, Speaker B: Where are.
00:02:54.940 - 00:03:59.164, Speaker A: All the code from this workshop? And then you can follow along basically. Okay, so this is the repo GitHub andrearchist create two. So feel free to clone this repo locally and you can just follow everything that I'm going to do during this workshop. Okay, let's start. So what is Evm? The EVM stands for ethereum virtual machine, and it's a computation engine that handles smart contract deployments and execution. It's a part of all EVM based general purpose blockchains. Because of this thing, EVM, we have so many general purpose blockchains.
00:03:59.164 - 00:04:56.556, Speaker A: For example, you have a bitcoin blockchain, and with bitcoin you can only transfer money. You can only transfer bitcoins. It's just a blockchain for money transfer. You can execute some simple scripts, but that's it with EVM and EVM based blockchains you can have, as I said, like general purpose programs, you can code defi apps, you can code daos, you can code whatever you want because of this thing called EVM or ethereum virtual machine. So what is this EVM exactly? We have solidity or wiper. That's the languages for writing smart contracts for general purpose blockchains. So let's say for example, we are coding a solidity smart contract.
00:04:56.556 - 00:05:13.160, Speaker A: Contract Sol. And we have that one solidity file. When we want to compile that one solidity file, it needs to grow through Sol's compiler. Solidity compiler. And there's like a different versions. 0.8 is like the latest whatever.
00:05:13.160 - 00:05:59.456, Speaker A: When solidity file goes through solidity compiler at the output we have at least two files. One is contract ABI and the second one is contract bin. So about the ABI, I think like all of you already know what ABI is. ABI stands for application binary interface. And it is a simple Json. It is a standard way to interact with contract both from outside world, like from our front end for example, both for contract to contract interaction, when basically you can call function on another contract from your contract. That's all because of the ABI.
00:05:59.456 - 00:06:57.396, Speaker A: Our focus today during this workshop is this another file contract bin. This binary file has all the instructions and language for programming EVM. In this binary file you have all the necessary inputs for EVM. And EVM knows how to handle all of these instructions coming from the solidity file. So what is EVM? EVM is stack based machine which use lasting first out stack to hold temporary values. So what's this lasting first out stacks mean? It means that if you push three values to the stack, let's say one, two, three, it will be push one, push two, push three, and then when you want to execute the pop function, pop. Now the three is out of the stack.
00:06:57.396 - 00:07:31.892, Speaker A: The three is being kicked out of the stack because it's the last in element that is being pushed to the stack. And last in first out you have like the three is kicked out of the stack. EVM has no registers. There is only that thing called stack and that's it. Stack memory you will see later. But there's no in memory register. For example at clang, at that assembly view you have ax ah, for example here, this is not the case.
00:07:31.892 - 00:08:06.270, Speaker A: There is no register. And EVM also has its own language called EVM bytecode. And this evm bytecode is stored in that bin file. Okay, so let's start with a simple example about what is bytecode. So this is a bytecode view of some small set of instructions. So it's not really readable at first glance. You see like 600-5600 401.
00:08:06.270 - 00:08:49.784, Speaker A: What's that all about? But if you go to this link it's ethervm IO. This is the Ethereum virtual machine opcode summary you have here like the table with all of Ethereum opcodes. So you program your EVM stack machine by opcodes. Opcodes are those instructions for the stack. And you saw here like there's a 60. It's the first number. And if we go here in this table and click 60 we see here that the 60 stands for push one opcode.
00:08:49.784 - 00:09:27.880, Speaker A: So push one means that this opcode will going to push one unsigned integer eight value to the stack. So push 32 for example is for unsigned integer two, five, six. But for like the lowest one unsigned integer eight we will use push one or 60. So if we go back to our bytecode view like push one five, we are going to push number five to the stack. Then we have again push one four. Now we are going to push four to the stack. And lastly we have this one.
00:09:27.880 - 00:09:58.080, Speaker A: So what is one? If we go back to our ethereum virtual machine opcodes table one stands for add opcode. And as you can see this add opcode works like this. You have two elements on your stack. It's going to pop two elements, add them and that summary will push back to the stack. In our case, five plus four equals nine. So it is going to push nine.
00:09:58.150 - 00:09:59.464, Speaker B: Back to the stack.
00:09:59.612 - 00:10:31.470, Speaker A: If we go back to the presentation. Here's like the assembly view of this bytecode view. As I said, push one five, push one four and then add. This is just three simple, simple opcodes for something to EVM handle for us. Here's the slides. This is our imaginary stack. It's empty now and first opcode comes here in first instruction for the EVM to handle, push five.
00:10:31.470 - 00:11:00.704, Speaker A: Now five is on the stack. Stack now has only one element, five. The next opcode instruction, push four. Now there's two elements on the stack, five and four. Like five is bottom and four is at the top. If we do a little, for example pop four will be kicked out of the stack. But for now we have five and four like you can see on this slide.
00:11:00.704 - 00:11:45.860, Speaker A: The third instruction is add. And as I said, add opcode works like this. It pops two elements from the stack, whatever those elements is and add them like in some temporary memory. And that summary pushed back on the stack. So it add will pop four out of stack, pop five out of stack, add them together, and their summary nine, push back to stack, and this is the end of our execution. We now have number nine on our EVM stack. Okay, so EVM can access and store information in six places.
00:11:45.860 - 00:12:32.720, Speaker A: So these six places are stack memory, account storage, call data code, and logs. I bolded this memory and account storage because this is really important for you when you write your solidity code. But I will cover all of these six places. So stack, we already saw what stack is. So it's basically place where EVM opcodes pop information and push back onto the stack. Memory is a temporary place for storing some data. So in memory, you store information accessible for the duration of a transaction.
00:12:32.720 - 00:13:11.708, Speaker A: So you have one transaction, it has some steps, some opcode instructions, and the memory is accessible only during the duration of that particular transaction. So it's temporary account storage. So it's a storage of a smart contract. So we have like two types of account on Ethereum, externally owned accounts, AEOA. This is basically wallets, your personal wallets for signing transactions, for holding tokens, et cetera. And the second type of accounts are smart contract. And accounts can have storage.
00:13:11.708 - 00:13:45.032, Speaker A: And for smart contract, it is really important to have its own storage, because in that storage, you can store your global variables. For example, call data. Call data is the data field of the transactions. And yeah, EVM can also access them. So if I go back to this simple transaction, it's on Rinkibuy, and it's from our previous workshop about full stack NFT dungeons and dragons app. So this is the smart contracts for dungeons and dragons. It's a minting functionality.
00:13:45.032 - 00:14:31.290, Speaker A: Here on Etherscan, you can see this input data, and it's like function request, random character. We can decode that input data. It's alf. You see, EVM is seeing like this, like a set of hex number, but EVM can access this data, and that's like this call data code is basically a source code of smart contract. And logs are everything that you emit via events. So when you write solidity code, you have some events and you emit them, and it's kind of like logger. And EVM can access those messages, addresses, unions, whatever you emit as an event.
00:14:31.290 - 00:15:22.776, Speaker A: So this is the full schema of EVM, how it looks. And it's important for you to know that EVM is quasi during complete, it's not during complete, it's quasi. Why quasi? Because all execution processes are limited to finite number of computational steps. By the amount of gas available for any given smart contract execution. So in theory EVM is turing complete. You can do whatever computation you want, but in reality is limited due to gas. So each transaction has this slot called gas available.
00:15:22.776 - 00:16:33.212, Speaker A: So you probably know that you need to pay for these gas executions. And that's the reason why loops are anti pattern in solidity, why we try to optimize our codes to spend less gas, to have less opcode instructions because of this gas available parameter. Because in theory if we run out of gas, the execution holds it's opcode and our transaction is being reverted. So we have like program counter which is just incrementing increments from one instruction to another. We have EVM code, it's from that if you remember contract bin file and it's being transferred to set of operations. So operations can be push pop, add store s store m store s load, m load whatever. And these operations act as like some of the parts of EVM.
00:16:33.212 - 00:16:35.996, Speaker A: So this is the stack we explained.
00:16:36.028 - 00:16:38.528, Speaker B: What stack is how stack works.
00:16:38.694 - 00:17:10.140, Speaker A: This is memory. If you remember, memory is here for storing temporary values only during the execution of transaction. This is the storage and it's related to smart contract. So it's not part of EVM, it's part of each account. EVM just can access them. So writing and reading from storage is really expensive, are really expensive operations in terms of gas. So be careful with this.
00:17:10.140 - 00:17:57.944, Speaker A: And also if we have message call, message call basically mean that our smart contracts are going to call the function on another smart contract. This also consumes more gas. And with message call it's really important for you to understand that it's still a part of the parent transaction. So if we have some transaction which needs some opcodes to be executed on our smart contract and we execute, execute, execute program counters increments guess available decrease. And at some point, at some line we need to call another contract's function as a message call. It's not a new transaction, it's a part of the parent transaction. And now on the second smart contract you have some set of instructions to be executed.
00:17:57.944 - 00:18:46.380, Speaker A: And all of these executions are consumed by this guest available of parent transactions. So be careful with this. Do not have transaction reverted situation because of too many operations. As I said, there's like memory versus storage debate. And memory is temporary. While storage is resistant and reading from memory, you use m load upcode for that for writing. You use m store upcode for that for reading and writing from storage and do storage, you use s load and sstore and s load and sstore are really, really expensive operations, so you need to be really careful with that.
00:18:46.380 - 00:19:50.450, Speaker A: And for you, I have amazing video about just that topic. So during Smart Contract Summit, Alex Rohn, one of the engineers from Chainlink Labs, hosted a workshop about Hitchkitch guide to the EVM, where he explained basically this how to handle S load s store, how to write to storage, read from storage, how he, when he writes smart contracts, when he has storage variable in smart contract always has a prefix s underscore to know that this is expensive to modify, et cetera, et cetera. So I highly recommend to watch this video. It's on chain link, official YouTube channel. It lasts only 20 minutes, so it's really easy for you guys to watch it to be fully concentrated while watching this video. It has a lot of useful information about this topic, so I highly recommend to watch this video. It's on Chainlink, official YouTube channel.
00:19:50.450 - 00:20:00.560, Speaker A: Okay, so let's start with now explaining create and create to opcodes. So this is the opcodes for deployment.
00:20:00.640 - 00:20:02.260, Speaker B: Of the smart contracts.
00:20:02.760 - 00:20:31.624, Speaker A: Typically smart contract deployment is handled by create opcode. So either like from remix or from Harhat or from Brownie, or earlier from Truffle, you have some ways to deploy your contract via different python or JavaScript scripts. Or you know, with remix idea, you just need to click on some buttons and that's it. But in the background everything is handled by this opcode.
00:20:31.672 - 00:20:33.416, Speaker B: So create opcode.
00:20:33.608 - 00:21:12.170, Speaker A: You can see on the picture on the right, this is the schema of the transaction for creation new smart contracts for deployment. So you have nons, it's a number only once parameter. It's like whatever number can be, it's related to your wallet, externally owned account. So on each transaction it numbers gets increment and that's it. That's not important. We have gas price and gas limit also that can be set manually via our wallet. You know how to handle this? Like pretty basic stuff.
00:21:12.170 - 00:22:24.028, Speaker A: VRF are just the parameters for signing transactions, also standard stuff that's important. But these three fields are just really important and different than like when you call a smart contract, when you send some tokens to another external account, when you send ether or any other native coin for like polygon, it will be matic, whatever, it's different. So here, this two field is like the destination address and it's empty because we are not sending money, we are not sending coins, we are not sending tokens, we deploy new smart contracts. So this is empty value is usually zero, except you have a payable constructor and you need to specifically use message value inside your constructor. In that case this value won't be zero, it will be whatever number is and data in data fill. You saw it like on the ether scanner previously during this workshop. It's the init code for smart contract deployment.
00:22:24.028 - 00:23:33.700, Speaker A: And how is contract address is computed? It's a ketchup hash of sender address and nons and that's it like ketchup is a standard hash function on Ethereum. It takes sender address and nons, whatever nons this is, combine them, hash them and you have your smart contract address. Pro tip for you guys if you want to make your front end team's life easier and you deploy your smart contract to several testnets and mainet you're doing multichain whatever. Usually you need to handle different smart contract addresses. But if you create a fresh new account and as the first transaction deployed to all of these chains, you will have the exact same address on each of these testnets, mainets, whatever. So this is like a really cool feature for you guys to make life of your smart contract team easier. Front end team easier.
00:23:33.700 - 00:24:30.820, Speaker A: So what about create two? Create two was included during Constantinople's fork and it's a way to pre compute address of a smart contract before deployment. So with this opcode you will already know the smart contract address even before you actually deployed to the actual blockchain. And also there is one parameter that can be changed so you actually can look through all of possibilities to find the special address for your smart contract if you want. That's really up to you. So how contract address is being computed using create two opcode. So if we remember create opcode, it's a catch two five six of sender address and nons. But with create two it's a catch two five six of four parameters.
00:24:30.820 - 00:25:17.690, Speaker A: First is ff and that's a constant just to prevent collisions with the create opcode. Then we have the sender address as the same like as with create opcode. Then we have the salt and this salt is an arbitrary value provided by sender and you can change that salt to basically find your special smart contract address. And finally to be deployed by contracts bytecode. This is the fourth parameter to be hashed, to be catch two five six hashed. And this is how we are going to have our unique smart contract address. So this is like the theory, let's now start building this.
00:25:17.690 - 00:25:35.836, Speaker A: I'm going to use open Zeppelin's create to smart contract. This is just not smart contract. This is library and we are going to create a simple hardcat project. So if I go to my integrated terminal, I'm on desktop, I will create.
00:25:35.938 - 00:25:38.896, Speaker B: A new folder called create two and.
00:25:38.918 - 00:25:42.220, Speaker A: I will CD to that create two folder.
00:25:42.300 - 00:25:51.220, Speaker B: It's empty. That's all good. I will just add NPX hard hatch in it command.
00:25:52.280 - 00:25:58.580, Speaker A: And now we are going to wait to create a new hardcat project.
00:25:58.650 - 00:26:00.432, Speaker B: We're going to do create a basic.
00:26:00.496 - 00:26:03.252, Speaker A: Samples project in this folder.
00:26:03.316 - 00:26:07.130, Speaker B: Git ignore. We are going to install everything and that's it.
00:26:08.220 - 00:26:11.690, Speaker A: Okay, so just for the questions.
00:26:12.860 - 00:26:15.308, Speaker B: Found it.
00:26:15.394 - 00:26:17.870, Speaker A: Yeah, you have the link to the video.
00:26:19.520 - 00:26:23.950, Speaker B: Um, okay.
00:26:41.630 - 00:27:04.374, Speaker A: With grade two, there's nothing stopping from attempting to deploy to the same address twice. That's actually a good comment. And if you wait till the end of this workshop I will have a little trivia question for you guys, similar to this one. So maybe you can then just join the discussion and see just what community thinks about that.
00:27:04.412 - 00:27:06.200, Speaker B: So this is a really good question.
00:27:10.870 - 00:27:12.834, Speaker A: What is the benefit of knowing your.
00:27:12.872 - 00:27:14.834, Speaker B: Contract address ahead of time?
00:27:15.032 - 00:27:22.200, Speaker A: Well, basically unisop users use that because they pre compute the addresses of their.
00:27:22.970 - 00:27:38.794, Speaker B: Pairs poles even before actual deployment to the blockchain because they have some mapping inside their factory to handle and hold all this data and they just need.
00:27:38.832 - 00:27:41.046, Speaker A: To have the liquidity from both sides.
00:27:41.078 - 00:28:04.322, Speaker B: To deploy the smart contracts, et cetera. You can also have some maybe platform where you create a new wallet for new users, but you activate their accounts only when they deposit funds to that wallet, for example. And you just handle this as a smart contract, not wallet for example.
00:28:04.456 - 00:28:09.734, Speaker A: Just be creative. Is that 10:00 p.m.
00:28:09.772 - 00:28:15.874, Speaker B: In it? Basically, yeah, hardhead is a framework like brown.
00:28:15.922 - 00:28:17.974, Speaker A: Yeah, hardhead is a framework where you.
00:28:18.012 - 00:28:21.666, Speaker B: Write scripts and tests in JavaScript or typescript.
00:28:21.778 - 00:28:23.386, Speaker A: With brown it's the same thing, but.
00:28:23.408 - 00:28:58.374, Speaker B: You write scripts and tests in Python. Okay, so as I said, we are going to use open sapling contracts. So I need to install this package also. So MCM install opens up in contracts. Just wait a little bit more. I think we are good right now. I'll open visual studio code because this is my code editor.
00:28:58.374 - 00:29:14.962, Speaker B: With code I open the visual studio code in the folder where I am now. So if I click enter, we are now inside our create project hardhead project. Okay, so it's simple.
00:29:15.096 - 00:29:17.122, Speaker A: I hope you guys, you can see this.
00:29:17.176 - 00:29:20.900, Speaker B: I zoom it like as much as I can as possible.
00:29:21.510 - 00:29:24.238, Speaker A: So this is this standard greeter solve.
00:29:24.254 - 00:29:37.094, Speaker B: Smart contract, some sample script, some sample test, firehead config. It's zero point 84. So this is good. And yeah, that's it.
00:29:37.132 - 00:29:39.366, Speaker A: So we are going to create a.
00:29:39.388 - 00:30:48.250, Speaker B: New smart contract, new file coil called deployer Sol for example. And yeah, so we need that license stuff, license locked and it's going to be mit for example. We don't care. Pragmat solidity version will be zero eight and yeah, so contract, deployer, this is our smart contract for like factory contract for deployment and new smart contracts using create to upcode. We are going to deploy this Greeter solve smart contract. So as I said, we need this library from open sapling. I will import it here and I will do something like this to save us memory.
00:30:48.250 - 00:31:36.522, Speaker B: Also we need from our folder not folder file greeter sol. We need greater contract. Okay, we are good. Okay, so let's start with deployment, with coding. So we need first a function to compute address. So we'll call function compute address. And if we remember the create two, the only non constant variable is that salt.
00:31:36.522 - 00:32:15.254, Speaker B: That's the arbitrary value provided by sender. So we can just provide that salt with bytes 32 and this will be public view function which returns address some new pre computed address. And here how to do this. So if we go back to the documentation, you can see here that this library has these compute address functions which takes salt and bytecode hash as parameters. So salt, we already know what is this. So what is bytecode hash?
00:32:15.302 - 00:32:17.574, Speaker A: Bytecode from a contract can be obtained.
00:32:17.622 - 00:33:04.730, Speaker B: From solidity with this line. So this is the creation code of our smart contract. So we need something like this return create two compute address salt we already have. We need bytecode hash. So bytecode hash will be bytes memory bytecode hash. And as we saw in the documentation, this is type of leader creation code. And the last thing is that we need to hash this value.
00:33:04.730 - 00:33:38.182, Speaker B: So this is catch up two five six of bytecode hash. And boom. This is our function from computing address. If we run now, our integrated terminal NTX hard compile should be compiled successfully. Okay, nice. Okay, I need capital l here. Sorry.
00:33:38.182 - 00:33:39.718, Speaker B: I will just close this.
00:33:39.884 - 00:33:40.454, Speaker A: Okay.
00:33:40.572 - 00:33:43.414, Speaker B: The second function that we need, because.
00:33:43.532 - 00:33:45.622, Speaker A: When we compute our address, we just.
00:33:45.676 - 00:34:18.500, Speaker B: Need to deploy a smart contract. So this will be a function for deployment of smart contract. We can call it like function deploy greeter for example. And that function also needs to have this salt parameter. So bytes salt also public. This is payable and returns reader address. Return it like this.
00:34:18.500 - 00:34:46.570, Speaker B: Actually this is type address. Sorry. I hope you can see this. Okay, address greeter address. So Greeter address is like our return parameter with react to deploy and. Okay, let's see what this deploy takes as the parameters. So announce salt bytecode.
00:34:46.570 - 00:34:48.220, Speaker B: Basically.
00:34:50.590 - 00:34:54.110, Speaker A: I explained to you how create.
00:34:54.180 - 00:35:01.898, Speaker B: Two needs four parameters for deployment. And with create there's only address of sender and non.
00:35:02.074 - 00:35:04.418, Speaker A: Here we have constant, we have address.
00:35:04.504 - 00:35:40.602, Speaker B: We have salt and we have to be deployed contracts. So four things. Okay yeah, here it is. So create to deploy zero salt. And the third thing is let's go back to the documentation. So amount zero. As I said during the, the slides, these values in most cases zero because a greater constructor is not payable, it's not using message value.
00:35:40.736 - 00:35:44.570, Speaker A: Salt is like provided parameter and bytecode.
00:35:44.730 - 00:36:18.120, Speaker B: We are going to grab bytecode like this bytecode. It's pretty much the same as here. It's a creation code of greeter. So byte memory, bytecode, hash. Okay it's not hash, but this is hash. Okay, we can call it bytecode. And with this deploy function returns new precomputed address.
00:36:18.120 - 00:36:23.434, Speaker B: And this is like our return parameter. And boom, that's it.
00:36:23.472 - 00:36:28.794, Speaker A: Like we deployed our create to smart contract with just this one line.
00:36:28.912 - 00:37:03.990, Speaker B: The last thing is that we can emit some event. So this event can be deployed for example. So this is just for the logs and let's see. Okay, address is okay to emit. So this is contract address, let's say. And what can we emit more? Let's do the salt. So salt is necessary like that to know why this address is just this.
00:37:03.990 - 00:37:14.330, Speaker B: It's because of the salt. So Ms deployed contract address is this greeter address and salt is salt.
00:37:14.910 - 00:37:25.786, Speaker A: Okay, that's pretty much it. This is our whole smart contract. I will just zoom out a little bit to see it. Just this, I don't know, 28 lines.
00:37:25.818 - 00:37:29.566, Speaker B: Of code is enough for deploying a.
00:37:29.588 - 00:37:32.640, Speaker A: New smart contract using create two.
00:37:34.390 - 00:37:43.300, Speaker B: Once again in my integrated terminal NPX hard hat, compile to see that everything is okay.
00:37:44.310 - 00:37:45.730, Speaker A: Boom, everything's okay.
00:37:45.800 - 00:38:01.142, Speaker B: So this is really nice license. I need to do it one more time because I don't like this warning.
00:38:01.286 - 00:38:02.380, Speaker A: Okay cool.
00:38:03.950 - 00:38:08.266, Speaker B: Then the next thing iterjs has a.
00:38:08.288 - 00:38:53.498, Speaker A: Really nice function called get create to address. And this Javascript function can also compute smart contract address for you using create code even before deployment. So my intention is now to try this function or method from eaters js to see how this function computes our address, to see how our smart contract deployer computes pre computes our address and to hopefully make it like equal. So sampletest js I don't think we.
00:38:53.584 - 00:38:58.394, Speaker B: Need all of this so I can just delete everything. I think that's okay.
00:38:58.592 - 00:39:08.254, Speaker A: Okay so we will start with a little before each hook, but before that.
00:39:08.292 - 00:39:19.460, Speaker B: We need a deployer instance. So this is our smart contract before each. Now this just before each.
00:39:21.190 - 00:39:21.874, Speaker A: Okay, this.
00:39:21.912 - 00:40:16.862, Speaker B: Is going to be async function because we need to deploy smart contract locally on local hardhead network. So constant deployer factory will be await get contract factory of deployer. Then next thing this deployer is equal await deployerfactory deploy. And then we need to await deployer to be deployed. So all of this sample code you can also find on hardhat official documentation.
00:40:17.006 - 00:40:28.914, Speaker A: Like first thing when you write test is this. So this is test in Javascript. I usually prefer typescript in production code, but for this simple demo it's really.
00:40:29.052 - 00:41:08.226, Speaker B: Okay to do this Javascript stuff. Okay, so we are going to write only one test and greeter should we do not capital. This should have the same pre computed addresses. Addresses, okay, this is also an async function. Okay, so we need salt. Salt can be whatever value we want. We can have it like, okay, 18 number for example.
00:41:08.226 - 00:41:12.600, Speaker B: So catch up to five, six of.
00:41:14.570 - 00:41:18.818, Speaker A: 18. So this is 18 in hexadecimal value.
00:41:18.924 - 00:41:24.294, Speaker B: So this in hexa equals 18 in decimal.
00:41:24.422 - 00:41:26.202, Speaker A: We need to provide a hexa value.
00:41:26.256 - 00:41:31.870, Speaker B: To catch two five, six, okay, so this is our salt.
00:41:32.210 - 00:41:36.350, Speaker A: It can be like whatever value we want. It's just random.
00:41:36.770 - 00:41:53.140, Speaker B: We can just play with this value later. So right now I want to pre compute smart contract address using deployer smart contract. So how to do that?
00:41:53.830 - 00:41:58.134, Speaker A: Well we have this compute address function. So we are just going to call.
00:41:58.172 - 00:42:31.440, Speaker B: That function, okay, so const solidity reconfuted equals await deployer compute address function and salt. Right now I will just console log this. So let it pre compute it and see what is going to happen. So NPX hard hat test.
00:42:34.630 - 00:42:48.242, Speaker A: Okay, so this is our pre computed smart contract address of greeter to be deployed smart contract. And you can see like it's a regular smart contract address, 20 characters.
00:42:48.386 - 00:42:52.422, Speaker B: Perfect. I will just put this here.
00:42:52.556 - 00:43:02.186, Speaker A: Okay, second thing, as I said, I want to now pre compute this address using meters get create to function. Get create to address.
00:43:02.288 - 00:43:36.122, Speaker B: So how to do that, we need to pre compute address using meters js. Okay, we need emit code hash. But first let's do something like this. So code const recomputed can be get to address to see what are the parameters.
00:43:36.206 - 00:43:47.026, Speaker A: So we need like from address we need salt and we need this init code hash. So from is from our deployer smart contract.
00:43:47.058 - 00:44:30.578, Speaker B: So deployer address salt is salt like the same and we need this init code hash. So init code hash is catch up bytecode. So bytecode we can import it like this. Let's find out our require. My mistake. Let's see. Okay, it's in artifacts folder, it's in contracts, it's in greeter salt.
00:44:30.578 - 00:44:47.622, Speaker B: So we need bytecode to be deployed. Smart contract and greeter Json. So this is bytecode. Boom, there it is. So catch a call bytecode. And then we are going to provide this knit code hash.
00:44:47.686 - 00:44:50.490, Speaker A: And last thing, I'll just console log.
00:44:50.640 - 00:45:03.360, Speaker B: This ethers precomputed address and let's run our test once again. MpX hardhead test.
00:45:05.510 - 00:45:28.006, Speaker A: Boom, we have two addresses console logged and they're exactly the same. So our smart contract is doing really well. Iterjs library computed in the same way. And just we need to make this a successful test. So unit test is not console logging. With unit test you need to just.
00:45:28.108 - 00:45:44.590, Speaker B: Have some expect syntax. So last thing we are going to write something like that. So expect solidity precomputed address to equal Peter's precomputed address. And that's it.
00:45:44.660 - 00:45:46.718, Speaker A: And just now, one more time.
00:45:46.804 - 00:45:50.000, Speaker B: NPX hardhead test.
00:45:50.770 - 00:46:05.886, Speaker A: See boom, our smart contract is okay. Our unit tests are all passing. Just one unit test is passing and we are good. Okay, so back to the questions because.
00:46:06.008 - 00:46:08.920, Speaker B: Oh, my mic is going away because.
00:46:09.290 - 00:46:25.670, Speaker A: We have a little Q a session. But before that I have like as I mentioned a little trivia for you. So follow Andre underscore dev on Twitter and join the discussion. So what's the discussion?
00:46:25.750 - 00:46:27.340, Speaker B: I will go here.
00:46:27.790 - 00:47:01.560, Speaker A: So you need to follow this twitter account here. I will post something for you. So this is a tweet. Dear web3 builders, here's an evm trivia for you. How to change smart contract source code without changing its address. So I will just read this and you follow me, go to this tweet and join the discussion. I will join this discussion later and see who gets this first.
00:47:01.560 - 00:47:06.642, Speaker A: Okay, but before that, let's go back to our Q a session.
00:47:06.706 - 00:47:08.360, Speaker B: So let's see.
00:47:10.090 - 00:48:06.140, Speaker A: This is great tip for someone who's thinking of multi chain deployment. Exactly. I already said like if you have not create two, but regular create and you want to do deployment to multichains, just create a new wallet, fund it with some coins and then do the deployment to each of these chains like as your first transaction. And because create upcode stacks takes address of a sender and nons. And these nons will be the same because it's a freshly new generated account, you will have exactly same smart contract address on all of these different chains. So it's really nice for your front end team to handle these smart contract addresses. What else? I already covered this.
00:48:06.140 - 00:48:40.422, Speaker A: No. Is there a chance of collision with an existing contract that you compute a new contract address? No, because with create two, first parameter of that four is ff and that's a constant to prevent collisions with create about create two with the same addresses. That's the question for you on Twitter, so join the discussion if you want answer on that question, I will also post it somewhere on discord or Twitter or whatever. So just wait a couple of more.
00:48:40.476 - 00:48:42.280, Speaker B: Hours and you will see.
00:48:43.690 - 00:49:25.266, Speaker A: Okay, error trying to use okay, so error hh twelve. You need to install hardhat on your machine to actually hardhat init this project. But also you can git clone it from here. So this is the whole working example under rackage creates two repo. So just clone it and you have here a package Json install it and you're good to go. It has all the scripts. It also has some bonus contracts and some scripts to find the special address.
00:49:25.368 - 00:49:26.680, Speaker B: One for you.
00:49:29.530 - 00:49:52.458, Speaker A: Okay. Warning comes from extra n. Thanks. I didn't notice this SBDX warning is really like. I don't know, I'm just not going to say my opinion about that. Okay, awesome stuff. Let's go.
00:49:52.458 - 00:50:07.234, Speaker A: This is Twitter. That's it. So okay guys, this is all of your questions. Thank you again for having me. Thank you for attending this workshop. I hope you find it interesting. I hope you learned something new.
00:50:07.234 - 00:50:16.206, Speaker A: I wish you best of luck by the end of hackathon. I really hope that you are going to build some awesome stuff and see you around. Bye.
