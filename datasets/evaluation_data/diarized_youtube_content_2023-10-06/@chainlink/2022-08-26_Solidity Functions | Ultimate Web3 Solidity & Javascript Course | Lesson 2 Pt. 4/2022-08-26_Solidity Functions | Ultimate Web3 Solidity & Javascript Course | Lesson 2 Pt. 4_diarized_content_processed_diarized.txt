00:00:11.050 - 00:01:15.634, Speaker A: Now let's go ahead and create a function. Functions or methods are self contained modules that will execute some specific set of instructions for us when we call it. If you're familiar with Java or Python or JavaScript or anything like that, functions work the exact same way functions get identified by the keyword function. Let's create a function called store that will change the value of favorite number to some new value, and the number that we're going to change it to is going to be variables that are passed to our store function here. So we're going to allow our store function to take a variable of type un 256 and we'll call it underscore favorite number. We'll make this a public function which we'll get to in a minute, and all we're going to do is we're going to set favorite number equal to whatever variable that we just passed. So now we have this function called store that it takes some parameter that we're going to give it and it sets this favorite number variable equal to whatever number that we give this function.
00:01:15.634 - 00:01:53.962, Speaker A: Now to see this actually in action, let's deploy this to an even faker blockchain than a testnet. We're going to actually deploy this to a local network or a JavaScript VM. And first, before we can even do that, let's just make sure that it's compiling correctly. Looks like we have a green checkmark, which is good, and we'll come down to this button here, which is our deploy and run transactions tab. Our deploy and run transactions tab has a ton of different configuration pieces for actually deploying this contract. First, we want to make sure we are on the JavaScript VM London piece here. JavaScript VM means we're going to be deploying to a fake local JavaScript VM.
00:01:53.962 - 00:02:42.634, Speaker A: The JavaScript VM is a fake local blockchain where we can simulate transactions really quickly without having to wait for them to go through on a testnet. Don't worry about the London versus Berlin piece here for now injected web three and web three provider we'll talk about in a little bit. We also have this account section here. When we run on our fake JavaScript VM, we're given a whole bunch of fake accounts from where to deploy from, and we're given 100 ETH for each one of these fake accounts. You can kind of think of it similar to our metamask account in Metamask, except for the difference here is that this is this fake Javascript VM Ethereum that we're given for our transactions, including deploying contracts, we're actually given a gas limit. There's also values we can send and we can choose our contracts. Right now we only have one contract, simple storage.
00:02:42.634 - 00:03:31.694, Speaker A: So that's going to be the one that we're going to deploy. So on the left hand side to deploy this to our fake Javascript VM, we're going to go ahead and hit the deploy button. And if we scroll all the way down to the bottom now, we can see a contract was deployed. It says simple storage at x blah blah blah blah blah. And we see this orange button store with kind of this grade text un 256 underscore favorite number on our fake local blockchain, we're actually given an address. Every single smart contract has an address, just like how our wallets have an address. So if we hit this copy button here and we put it into a comment, make this a little bit bigger, we can see that the address of this contract that we just deployed is located at this address.
00:03:31.694 - 00:04:11.222, Speaker A: Additionally, if you pull up the slider over here, you'll be able to see this little green checkmark with all its information about this deployment. And you can hit the little drop down and see a whole lot more information about this. Something you might notice is you'll see some familiar keywords like status, transaction hash, from to gas, et cetera. When we deploy a contract, it's actually the same as sending a transaction. Remember, anytime we do anything on the blockchain, we modify any value we are sending a transaction. So deploying a contract is modifying the blockchain to have this contract. It's modifying the state of the blockchain.
00:04:11.222 - 00:05:04.890, Speaker A: And if we had sent this on a rinkbee or a coven or a mainnet network, we would have had to spend the gas to actually deploy this contract. And this is the simulation of how much gas and the transaction hash and from and to and all this other stuff about our transaction had we actually deployed it to a real network, but since it's Javascript VM, it's all fake information. Now we have this big orange button store. This big orange button resembles the store function that we just created. So if we add some number into this store, like one, two, three, and we hit the store button, we actually call this store button, and we actually execute a transaction on our fake Javascript blockchain to store the number one two three for favorite number. And if we scroll all the way up to our account now, you'll see that we have a little bit less ether in our fake account. This is because we spent the gas to actually call this contract.
00:05:04.890 - 00:05:44.006, Speaker A: And if we pull up this bottom bit here and I call this with five, I call store, you'll see it flash. For a quick second, we sent another transaction to store the value five in our favorite number. Now the question you might be having is, that's really cool, Patrick, but I can't see what favorite number actually is. How do I know that those transactions are actually going through? Well, right now the visibility of our favorite number is set to private, so we actually can't see it. And we'll talk about visibility in just a second to make it so that we can see it. We'll change our favorite number's visibility to public. So let's go ahead, we'll recompile, we'll go back to the deploy tab.
00:05:44.006 - 00:06:11.378, Speaker A: We'll click the little x here, which is to say let's get rid of this contract. And it just gets rid of it from our window here. It doesn't actually get rid of it from the blockchain because again, they're immutable, well, kind of immutable since again, this is kind of a fake simulated chain. But we go ahead and compile. And now we hit deploy again. And if we scroll down, our new contract will now have two buttons. One is the orange button for store, but now we have a new favorite button.
00:06:11.378 - 00:07:02.994, Speaker A: This button represents this public variable favorite number, and it resembles a function saying, hey, show me what favorite number is. So if I were to click this favorite number button, what do you think will show up? Well, do you remember what this gets initialized to? Well, let's click it now. We do indeed see that zero shows up. We see that this is a unit 256, and the value stored in it is zero. Now, if I were to change that number to five by calling the store function and now hitting favorite number, we do indeed see favorite number gets updated to five functions and variables can have one of four visibility specifiers. We have public, private, external, and internal. Public is visible externally and internally, meaning anybody who interacts with this contract or sees this contract can see what's stored in this favorite number function.
00:07:02.994 - 00:07:39.310, Speaker A: You'll see here in the solidity documentation. It says it creates a getter function for the storage state variables. When we add this keyword public to favorite number, what we're actually doing is we're creating what's called a getter function for favorite number. We're basically creating a function that says to return the value of favorite number. And that's why this blue button pops up, because this blue button is a function that says, hey, return the value of favorite number. Private means only this specific contract can call this function now for storage. It doesn't mean only this contract can read what's stored here.
00:07:39.310 - 00:08:06.402, Speaker A: And we'll get into that a little bit later. But private means this is the only contract that can call the favorite number function. Private functions are only visible to the current contract. External functions are only visible externally, meaning somebody outside this contract can call this function. And then internal means that only this contract and its children contract can actually read it. But we'll get into that a little bit later too. So, oddly enough, variables are just function calls.
00:08:06.402 - 00:08:53.874, Speaker A: Now, the reason that we didn't see favorite numbers show up on the left hand side when we first deployed this without the public keyword, when we don't give a visibility specifier to functions or variables, they automatically get deployed as internal. And as we know, internal functions and variables can only be called by this specific contract or derived contracts, which again we'll get into later. So let's just keep it public for now. The reason that we're prefixing our parameter here with an underscore is a way to tell us, hey, this variable here is different from the favorite number global. There are some different naming conventions that are used for parameters. And as we get later into the course, we'll understand more and more of what good names for parameters are. Every time we call this store function and we change the value here, we're actually sending a transaction.
00:08:53.874 - 00:09:36.690, Speaker A: Because remember, every single time we change the state of the blockchain, we do it in a transaction. And we can see all the details here. If you go over to the transaction details in the logging area of your remix, you can actually scroll down and you can see the transaction cost in units of gas. You'll see a number, something around this, and you'll notice it's more than that 21,000 number from sending ethereum. That's because we're doing something more computationally expensive. We're actually storing a number over here. Now, what do you think will happen if we do more inside of this store function as well? So instead of just storing this number, maybe what else we do is we will store the number here, and then we'll update our favorite number.
00:09:36.690 - 00:10:10.586, Speaker A: We'll say favorite number equals favorite number plus one. Since we're doing more stuff now, we should see this store function actually become more expensive. So let's go ahead and recompile. We'll delete this, we'll redeploy. We now have a new contract, we'll store five again. Now, if we look in the details of this transaction and we scroll down to execution costs, we do indeed see the amount of gas has greatly increased, and that's because we're doing more things. This store function is now more computationally expensive.
00:10:10.586 - 00:11:03.102, Speaker A: And like I said, each blockchain has a little different way of how they actually calculate gas. But the easiest way to think about it is the more stuff you do, the more expensive that transaction is going to cost. So let's go ahead and delete this line to continue our example. Now, let's talk about scope for a second. Our favorite number is basically in something called the global scope, meaning anything inside of these brackets can access this favorite number variable. But what if I did something like this? What if I made a UN 256 called test VAR, and I set it equal to five, and then I created a new function called something? We'll have it take no parameters and be public. Could I access the test VAR and then change it to something like six? Can we do that? Well, let's go ahead and see what happens when we try to compile this.
00:11:03.102 - 00:11:22.742, Speaker A: We actually run into an error. We get expected primary expression right here. Well, that's because I have the double question mark. Let's try it. Now we get undeclared identifier. Our something function doesn't know about this test VAR. When you create variables, they only can be viewed in the scope of where they are.
00:11:22.742 - 00:11:55.070, Speaker A: Now, if that's a little confusing, just look for the curly brackets. These two curly brackets encompass this whole section here. Right? The opening one is up here. The closing one is down here. So if I create a variable directly inside of these curly brackets, that means everything in here can access it. However, test VAR was created inside of these curly brackets, which means that only stuff inside of these curly brackets can access test VAR. Since our function something isn't inside of store, our something function won't know about test VAR.
00:11:55.070 - 00:12:35.294, Speaker A: So that's how scope works. You want to look to see if your variable that you created is inside of these curly brackets, and that's how you can know if other functions can work with them. So this is why this fails. Now, like what we saw in the documentation, when we add this public variable to favorite number, we're secretly adding a function that just returns this favorite number. We can also add our own function that also returns the favorite number to resemble the function that's getting created in the back end. So we could say function, we call it retrieve, and we make it a public view, and we'll say it returns a UN 256. I'll explain what that means in just a second.
00:12:35.294 - 00:13:11.542, Speaker A: And we'll say return favorite number. Now I'm going to hit command s, which again I'm going to do that a lot throughout this section. But just remember that that's equivalent to me going to the compile tab and hitting compile. Now if we go to the deploy tab, delete our last one, deploy a new one. We now have a retrieve function which is going to return the exact same thing that our favorite number is going to return again. If we update this to five, call favorite number and then retrieve they both now return five. Now as you can see here, these two functions are blue, but this function is orange.
00:13:11.542 - 00:13:42.178, Speaker A: What's the difference? Why do these have these different colors? Well, the key lies in this view keyword here. There are actually two keywords in solidity that notate a function that doesn't actually have to spend gas to run. And those keywords are view and pure. Oh, and let's also get rid of this variable up here. A function that is a view function means we're just going to read state from this contract. We're just going to read something off of this contract. For example, our retrieve function right now is just reading what favorite number is.
00:13:42.178 - 00:14:24.126, Speaker A: A view function disallows any modification of state, so you can't update the blockchain at all with a view function. Pure functions also disallow any modification of state, so we couldn't update our favorite number. Not only that, but they also disallow reading from the blockchain, so we couldn't read favorite number either. Instead, what you might do with the pure function is maybe something like function add public pure one plus one, or return one plus one. This would be returns un 256. Maybe something like this. Maybe there's some math you want to use over and over again.
00:14:24.126 - 00:15:00.982, Speaker A: Maybe there's some specific algorithm that you want to implement that doesn't actually need to read any storage, et cetera. Now, if we call a view function or a pure function by itself, we actually don't need to spend any gas since we're just reading from the blockchain. Remember, we only spend gas. We only make a transaction if we modify the blockchain state. So you'll notice in our little console down here that if I call retrieve, this call thing comes up. However, it looks different than when we call the store function. When we call the store function, we get this little checkmark, we get a hash, we don't get the little checkmark and we don't get a hash with the calls.
00:15:00.982 - 00:15:30.690, Speaker A: That's because clicking these blue buttons doesn't make a transaction. This is saying, hey, we're just going to read off chain, we're just going to read this value. However, if you look in the details of this call, there's this execution cost bit here. So what's going on? Well, we can read this part right here. Cost only applies when called by contract. If we do have a function that calls retrieve. If there's a function that is updating state that calls a view or a peer function, that's the only time it'll cost gas.
00:15:30.690 - 00:16:24.150, Speaker A: So for example, if our store function, which is not a view function, were to call retrieve at some point, then we'd have to pay the cost of the retrieve. Because reading from the blockchain costs this computation and costs gas. Calling view functions is free, unless you're calling it inside of a function that costs gas, in which case it will cost gas. So if we leave it here, we delete this, we recompile, we redeploy, we hit favorite number, retrieve, they both still cost nothing. But if we add, if we store eight in here, we can see, we can see our execution cost has gone up from what it was without retrieve, which we can go ahead, we can compile, I hit command s to compile here we can deploy. Let's go ahead and store again, we'll click on that transaction. We can see that it's much cheaper without that retrieve function in there.
00:16:24.150 - 00:16:56.540, Speaker A: And again, our favorite number variable, as long as it has this public visibility, it also is counted as a view function that returns a UN 256. The returns keyword means what is this function going to give us after we call it? So we say this function is going to give us this function is going to return a UN 256. When we call retrieve, it's going to return or give us a UN 256. This is the result of calling the function. This six is the result of calling our retrieve function.
