00:00:00.250 - 00:00:24.982, Speaker A: Welcome back, engineers. In one of our earlier videos we showed how to make an API call through a chainlink node. In this video we're going to go into, number one, how this actually works. Number two, exactly what the code looks like and what you need to do with the code. Number three, an introduction to adapters and number four, a brief introduction into external adapters. And to get help with any of this, ask any other questions and join the community. Be sure to grab the discord link in the description below.
00:00:24.982 - 00:01:09.870, Speaker A: Let's build remember that Chainlink oracles are blockchain middleware, so we need something to programmatically tell them to make an API call or get this data. Put another way, we need something to initiate them to post data through an external transaction onto the blockchain. These instructions for telling a chainlink node to start getting data is called an initiator. Each chainlink node has specified initiators that they're going to be listening for. In addition, they also have a specific set of instructions on what to do with that data once they start getting it. This set of instructions defining what to do is called the adapters or tasks list. The combination of initiators and adapters makes up a single job in a chainlink node.
00:01:09.870 - 00:02:05.838, Speaker A: Chainlink nodes can define as many jobs as they like, so in this way, how they get data and what they do with that data is essentially limitless. Once a job is defined, it's given a specified job Id. One of the most common jobs that most nodes have functionality for is a run log initiator combined with a HTTP get json, parse, multiply Fu 256 and ftx adapters. We'll get what into this list of adapters does soon. A job with a runlock initiator means that the chainlink node will actually watch the blockchain for any events that have that job specific Id. Once a chainlink node finds an event, it will execute what's specified in the adapters or list of instructions, including posting the data onto the chain via an external transaction. Your smart contract will have to wait a little bit for the chainlink node to post its data in an external transaction, but once it does, you'll be able to pull the data right from that transaction.
00:02:05.838 - 00:02:44.190, Speaker A: Let's see what this looks like in code form. Here's a subset of the code from the previous video where all we want to do is get the numerical price of Ethereum to start making a request to the chainlink node. We will call the build chainlink request function that is imported from the chainlink client sol. This function returns a chainlink request struct that we need to populate to send and make the chainlink request. In this function, we need to pass the specific job Id, the callback address, and the callback function signature. In order to build this chainlink request struct. We can find a job ID by heading over to a node listing service like market link and searching for the job that we want.
00:02:44.190 - 00:03:19.366, Speaker A: When we come to the node listing service, there are two things that we want to get a job ID and an oracle address. Node listing services are where independent nodes post their information about how to connect to their chainlink node. You can refer to them often for building your decentralized network of oracles. You can search right here or browse jobs, nodes feeds, and a number of other things. We want a job that can do an HTTP get request and return a UN 256. So let's look up get un 256. Oh, we need to make sure we're on the correct network first we want on Robston.
00:03:19.366 - 00:04:00.862, Speaker A: So now we get a list of nodes that have a job for HTTP get Un 256 to make sure this job has the right adapters or set of instructions for the job. Let's find the actual job in its list of jobs here. Here's the get Un 256 job that we want, and here are the tasks or adapters that it has. It has the HTTP get JSoN parse multiply f unt 256 and ETH transaction adapter. So this job will work perfectly for us. We can then copy the job id to use in our code. You can see other nodes that have similar jobs and you can come back to this list when you make your contract decentralized.
00:04:00.862 - 00:04:48.098, Speaker A: But again, for testing and developing, we can just pull from a single node for now. Make sure you also grab the oracle address as you'll need this later too. For this demonstration we're going to be hardcoding all the variables, but you may want to go back and refactor this code later to add these parameters to be passable to your function so that you don't have to add a new function for every oracle that you add. The second parameter is the address of the contract to return the data to, or the callback address. With this we're saying we want the data to be returned to this contract, and the last parameter is the function that will process the data once collected or the callback function signature. Once the chainlink node makes the external transaction posted on chain, its transaction will actually perform the execution of the callback function. In this case fulfill.
00:04:48.098 - 00:05:23.698, Speaker A: This is where you can customize what to do with the data. Once received. We want to make sure we add this record chainlink fulfillment to ensure only the requesting oracle can fulfill it. It takes the request ID and the data from the chainlink node. As you can see, we're just going to set the return value to our current price variable. We can then add parameters to our adapters tasks. Remember how in this job we had this HTTP get adapter? Here we can add the parameters of what to actually call with this adapter we can add it by saying rec add, get the name of the adapter and the API that we actually want to call.
00:05:23.698 - 00:06:14.606, Speaker A: Since every piece of data we store on the chain costs ethereum and we only need the Un 256 price. We then add the path parameter to our json parse adapter to walk the path and get the specified value in this API call. We can see that the mapping is from USD so we add this to our request with the rec add path, rec add path USD. This way we will only be returning this value and finally the multiply or times adapter. We do this because decimals don't work well on the blockchain and we need a whole number. So we're going to multiply this number by 100 which essentially will move the decimal place over two places so that our smart contract can understand the value. The last two adapters convert the result into an ABI encoded Un 256 and creates the ethereum transaction on chain.
00:06:14.606 - 00:06:47.278, Speaker A: Those we don't have to add any parameters to. And now we're done with the adapters. You can see a list of all the adapters and how to use them in the chainlink documentation links in the description. Now we use the sendchainlink request to method with the address of the oracle we got from market link, the request itself and the oracle payment. This will be how much link we want to send to this node. We can see the cost of the job on market link as well. For this job the cost is zero one link.
00:06:47.278 - 00:07:24.778, Speaker A: This will be the representation of zero one link. Now let's run this contract, compile, inject to web three, approve, connect, deploy, confirm, copy the address, send it some link and then request the price of ETH. Here we actually have the chainlink node and we can see the request come in and the chainlink node go through the adapters. Once the request transaction actually goes through we'll be able to see the job show up on the chainlink node. Here I have access to the GUI of the chainlink node and we can see created just now, we have a new job run. If we flip back to our code, we still don't have the current price. This is because the chainlink node hasn't finished making the transaction back onto the chain with the data.
00:07:24.778 - 00:08:09.090, Speaker A: Once it's fully complete, we can flip back to our code, and once it's complete, that means this fulfill function has been called and we can see. Once we click current price, we can see it's actually been updated. Here, oracles can define the parameters right in their job definition as well. These are known as their job specs, and you can just call a job without having to put any parameters in at all. For example, you can see here that the parameters are already defined, and what you could just do for this is copy the job id, copy the address of the node, and just have your code look like this. You can see exactly what a job spec looks like by hitting the job spec tab on the node listing service. This has been a pretty deep dive in exactly how Chainlink works from an engineering perspective.
00:08:09.090 - 00:08:44.010, Speaker A: But with this, you now have a lot of the basic tools for building some amazing projects in blockchain yourself. But let's say you want to do something a little bit more involved, like the API that you're using requires authorization. Maybe you want to save some gas by doing some computation off chain, or maybe there's just some functionality not covered in the adapters tasks list. This is where jobs with external adapters come in. External adapters are ways of building additional customized functionality into your jobs, and we can find out exactly how those work in the next video. I'll see you. There's.
