00:00:52.350 - 00:01:06.258, Speaker A: Hello. Hello. Welcome. Welcome back, guys. Today we're going to be working on testing our chain link smart contracts testing, especially locally, right. Because we're going to make them very powerful. So we're just going to wait a couple of minutes as people roll in.
00:01:06.258 - 00:01:41.938, Speaker A: Let people roll in so we can have this be a little bit interactive again. Feel free to jump into the comments. Feel free to ask some comments. These sessions are for us to chat, to talk, and to learn about solidity and smart contracts and building really powerful applications. Obviously, testing is a really important piece of the development world because we want to use our tests. We want to iterate very quickly over trialing and erroring stuff, right. And being able to write effective tests is going to really enable us and really empower us to write our smart contracts much faster, much better and more fun.
00:01:41.938 - 00:02:16.718, Speaker A: So we're going to give it a couple of minutes, let some people roll in. Unless you all are testing wizards, in which case we will not do much testing. Just kidding. No, the other thing is, if you want to go mainnet, if you want to take your project from fun Hackathon project to live to mainnet, you definitely, definitely 1000% need tests. There's no way any respectable project is going or whatever your user is going to work with your protocol if it doesn't have tests. I mean, these are really make or break facts for sure. Absolutely.
00:02:16.718 - 00:02:42.034, Speaker A: Facts. Welcome to the stream. Welcome to the stream. And we are also going to go over multi chain use. So we're going to quickly go over that because understanding that network uses is going to be helpful and we haven't quite covered yet. And we have a fun little thing to demo that's new for you engineers for Matic in particular, matic binance and XDI in particular. So we're going to go over that really briefly.
00:02:42.034 - 00:03:04.800, Speaker A: We'll probably will release another video sometime in the future showing people how to do that because it's working with the chain link VRF. So it's 433. We are going to just go ahead and jump right into it. Let's get into everything here. So let me switch to the stream. I don't know if I have this up. Oh yeah, everything's black.
00:03:04.800 - 00:03:29.570, Speaker A: Sorry, 1 second. Let me swap to this. Much better. Boom. All right, cool. So first thing I want to show you guys is working with multiple chains. So I know a lot of you guys have metamask, right? So we're going to expand this view.
00:03:29.570 - 00:03:58.830, Speaker A: So this is metamask right here. And what we're going to do is we're going to jump in and we're going to look at the different networks. So obviously different test networks are pretty simple, right? We have Ethereum, Robson, really, you just kind of switch, right? And your metamask kind of updates. Obviously these are all testnets and it's fine. When we're working in our vs code, it's going to actually be pretty similar. Let me expand this so that it's actually covering the whole screen here. It's going to be kind of similar.
00:03:58.830 - 00:04:52.074, Speaker A: Right. So when we looked at, we can look at our truffle config, for example, we have this module exports and we have all these networks defined in here, right? So again, they're defined with this RPC URL that we're setting as an environment variable here. So really usually on any type of framework, whether it's truffle, whether it's hard hap, you can do command network and then whatever you set in here, right? So if we set coven up, it'll be coven. We could add a new network. And you even saw me do this a little bit earlier, switch to rinkby, whatever. And it's the same for everything. It's the same for XDAi, it's the same for binance, smart chain, it's the same for Polygon, where the URL is just going to be the URL from that RPC.
00:04:52.074 - 00:05:43.946, Speaker A: So for example, we can even go to metamask setup, metamask setup polygon, metamask polygon. And they'll even show us the RPCRL and the chain ID, which are the important pieces. So we have the RPC URL, boom, this guy chain ID matic. So we can just copy paste this. So instead of like URL, we would do something like this for polygon, for chain ID, we'd grab this right here and that's pretty much it. And then boom, all of a sudden we can start deploying to these other chains. So the only other thing you'd have to do, obviously, is especially when working with link tokens, is get the link token on that network.
00:05:43.946 - 00:06:30.522, Speaker A: Now here's where I'm going to show you guys something really cool. So to convert to something like polygon, right, it's actually really easy to convert from Mainnet Ethereum to Mainnet polygon because they have a proof of stake bridge, which is really sick. And you can actually convert your assets over to polygon really quickly. So this is in our documentation. Like I said, I think I do need to switch to Ethereum, mainnet or something. Connect, sign. So I'm signing in to the bridge here and this is their bridge.
00:06:30.522 - 00:06:57.446, Speaker A: So it's really easy. We just kind of pick the token that we want. For example, maybe we want link so we can interact with stuff want link. And then we transfer, we just hit this transfer button, a big thing will pop up. It'll say, are you sure you want to do this? You say yes, it does it in like seven minutes. It's really nice, right? I mean, we're doing interoperability, we're doing cross chain stuff here, obviously. Okay, so if you switch, it kicks you out.
00:06:57.446 - 00:07:30.626, Speaker A: It doesn't let you do that. Once you transfer your token over, what you can do then? Oh, it looks like I do have $0.04 on matic mainnet. Nice. Cool. Once you do swap your tokens over, what you're going to need to do when you swap your link tokens over is you're actually going to have to swap them from the bridge link to true link. So we actually don't even have, actually don't even have polygon on here.
00:07:30.626 - 00:07:55.498, Speaker A: So let's even do it. Polygon, add it right here. Polygonmatic rpcrl fan ID matic block explorer. Boom. Save polygon matic. Done. Awesome.
00:07:55.498 - 00:08:14.080, Speaker A: Then we can come to this peg swap thing, right? So once we get some link token over here. Oh, it looks like I do have 0.1 matic. Nice. Once we get some link token over here, let's see if I have any link in this wallet. I didn't know I had money in this. Okay, cool.
00:08:14.080 - 00:08:46.742, Speaker A: I got zero link, guys. I just found like half of a half of a penny. You guys excited for me? Boom, boom. So I don't have any in this wallet, but what we can do is the bridge link that we actually bridge over actually isn't erc six seven compatible. So what we need to do is we need to swap the bridge link over from matic bridge link to true, like wrapped link. This is the link that actually works with Oracle. So that's just the next step for working with Matic.
00:08:46.742 - 00:09:23.966, Speaker A: And it's the same thing for binance smart chain. XDI actually does give you the correct token, but if you bridge from binance smart chain to XDI, it'll give you the wrong token. So we just got to do this extra step of bridging over. But it's super quick, super easy. So with that being said, I'm going to go switch over to testing now and we'll take some questions. Let me look at the comments here. Hey Patrick, I understand that Chainlink main use is to bring off chain data to chain as that is a major problem for blockchains.
00:09:23.966 - 00:09:49.754, Speaker A: Yep. Bring off chain data on chain. Yep. However, if you're messing with Brownie, I think I can process data that is off chain either from a file or an API, then use that in a smart contract, thus bringing it on chain without using Chainlink. What am I missing? Okay, great question. So for your reference, you should go over to the everything chainlink intro workshop that we did that goes over and answers this exact question. So you can also write your smart contract in Python.
00:09:49.754 - 00:10:30.102, Speaker A: You don't even need to deploy it to theorem, so why are you even bothering? Just spin up a server, you don't have to spend any gas, just write your smart contract on your centralized server. What's the issue there? Oh, it's a centralized server, that's the issue. The whole purpose of this blockchain world and writing these smart contracts on the first place is to be decentralized and have these autonomous, automatically executing smart contracts that don't need a centralized intermediary. So the same reason why you don't say, oh, my Python program that's running on my computer. Yeah, that's a smart contract. That's the same logic behind, oh, the data that I'm going to give to my smart contract. Yeah, it's decentralized.
00:10:30.102 - 00:10:48.450, Speaker A: It doesn't work like that. You need your logic layer and your data layer decentralized. So sure, you can put data onto your smart contracts. You can say the weather outside is twelve degrees or it's raining fire or it's raining basketballs. You can absolutely do that, 100%. But your data is coming from a centralized source. It's coming from you.
00:10:48.450 - 00:11:23.994, Speaker A: So this is not something that we want. We want our data to come from a decentralized network. So if you think you can put data on chain yourself and it's just as good, then I would say then your Python program that's running on your raspberry PI in your basement is also a smart contract, which is clearly not true. So that is the answer there. Great question. Any other questions on multichains? Any other questions? Cool. All right, well, I just took a second to answer that question.
00:11:23.994 - 00:12:09.124, Speaker A: Let's move on to testing stuff, right, because that's why we're here. So a couple of things we want to do. Are these the right tests? Let me just check real quick. It I got to pull the branch. Sorry guys, I had the wrong branch up. 2 seconds here, 2 seconds here. So we're going to be testing with both hard hat and we're going to be testing.
00:12:09.124 - 00:12:42.752, Speaker A: Oh, this is on Patrick, alpha C master. Okay. Okay, here we go. Now we're on the right one. Sorry about that, guys. Let's jump into some code. So testing our smart contracts, this is super important.
00:12:42.752 - 00:13:10.840, Speaker A: Obviously this is super important. Why? Because we want to do things correct. We want to actually deploy smart contracts in a smart way. So when we deploy our smart contracts, what we're going to do, and I'm going to show you guys how to do this with truffle and brownie. We're not going to show you guys hard hat. I don't have those ones, those examples done yet, but the concepts are going to be the same. And actually, I highly recommend you guys check out hard hat for running these tests because hard hat tests are even faster.
00:13:10.840 - 00:13:39.364, Speaker A: They are super fast. They run on the hard hat runtime environment and they're awesome. So definitely recommend you check that out. So if we look at our package here, right, this is a sample truffle package. It's going to be very similar to a hard hat package. When we use this, what we want to do is we want to run our tests locally, right? Right. Now, so far we've been talking about running tests and working with tests on a testnet, which is great and a great way to actually test stuff.
00:13:39.364 - 00:14:13.184, Speaker A: However, the issue is that you'll see, you'll run into a lot of, oh, you always need to have these testnet tokens and you got to wait a lot longer for stuff to come back and you can't unit test as well. So how do we fix this? How do we address this? Well, what we do is we deploy. And then one other thing is that we can't actually work with local, on our local ganaches because we need to work with these oracles. Right. These oracles are watching these chains. So how do we get them to watch our local chain so we can test faster? Well, we can't really do that, right. That's going to be really hard.
00:14:13.184 - 00:14:44.392, Speaker A: So what we want to do is we want to deploy mocks. We want to deploy basically fake contracts that dummy what is happening on chain. Right. So if we run a local testnet, we're clearly not going to have, maybe I should even draw. If people are getting confused by this, let me know. If we're running a local testnet, we're not going to have access to stuff that's being aggregated on chain, right. All the oracles that are returning data, we don't have that.
00:14:44.392 - 00:15:10.032, Speaker A: So we want to deploy a dummy contract that pretends to have it. So let me know in the chat if that doesn't make sense, or if that does make sense, let me know. Either way, I'm looking at the chat right now. If you guys are like this makes perfect sense, move on, let's do it. Mocks are pretty fundamental to most testing infrastructures. They're really good. And it's no different here.
00:15:10.032 - 00:15:33.816, Speaker A: Mocks are very important for our testing. I'm not getting any feedback here, so I'm assuming you guys are all wizards and you guys all got it. Well, then I will move on. I will continue with the testing here. So here is a sample of testing. A price feed. Okay, now they're coming in.
00:15:33.816 - 00:15:43.304, Speaker A: Streamyard was just slow. Makes sense. A dummy oracle simply we should make chain link. Exactly. Okay. Yes. So we're going to deploy a dummy contract oracle.
00:15:43.304 - 00:16:00.976, Speaker A: That's pretty much it. Yet we're going to deploy a dummy contract that is going to pretend to work to get data. Right. So let's deploy those dummies. So here's an example of the contract. Now in truffle, we can run truffle test and we're even going to run a specific well to do all of our tests. We can just run truffle test.
00:16:00.976 - 00:16:21.032, Speaker A: You'll see that this is a little bit slow. Again, highly recommend you guys checking out hard hat because hard hat tests stuff fast. Hard hat tests are really fast. This isn't in the main truffle box repo yet. We are working on pulling it in there. But you can check out my repo, which has all these tests in there. Cool.
00:16:21.032 - 00:16:49.410, Speaker A: 13 passing. But if we want to do a certain specific test, we can do test truffle, test price consumer v three, test JSON so that we can just test this one. And I'm going to walk through this real quick. Actually, you know what, let's just live code it because that's more fun. Right? Let's go live code. Goodbye. See you.
00:16:49.410 - 00:17:14.632, Speaker A: Now it's gone. And now I'm like, wait, hold on, I got to get my tests in order here. I got to figure out what I'm doing. What is this? Price consumer V three. Price consumer V three. 1 second. Just getting all my bearings in order.
00:17:14.632 - 00:17:48.336, Speaker A: Here's test it. All right, cool. Sorry about that. So we're going to write some tests here. So the first thing is we're going to grab, assert so we can actually do our tests. So we're going to do const, assert equals choir. So chi is a package pretty much most solidity.
00:17:48.336 - 00:18:00.996, Speaker A: Both hardhat and truffle use this. So it's going to be pretty familiar. Hardhat does have some nice additions for markers. Definitely. Again, recommend you guys check that out. So now we're going to test our contract. So this is all we really need for testing.
00:18:00.996 - 00:18:34.100, Speaker A: So let's start testing our contract. So we're going to test the price, consumer v three. So we're going to do contract price, consumer V three counts. And now we're going to do a function here, accounts. It's going to get us set up to actually test this contract. The price, consumer V three. We're going to do const, price, consumer V three equals artifacts.
00:18:34.100 - 00:18:57.112, Speaker A: Artifacts require, remember this is truffle syntax. Price, consumer V three. Again, artifacts grabs from the build directory. Right. So it's going to contracts price, consumer V three, which is in there. Again, this is that really simple, that really simple demo contract right here. Right.
00:18:57.112 - 00:19:16.530, Speaker A: And all it's doing is grabbing the latest price. That's it. Right. But we don't have an address we can give it. You'll notice here too that actually that I should have mentioned this before. The constructor is now taking a variable instead of just having everything hard coded. And you'll see why in just a second here.
00:19:16.530 - 00:20:00.396, Speaker A: And again, feel free to ask questions. So we are going to be testing this, which has been slightly changed for that one piece. And again, we'll show you why. We also need const, what else do we need? We need a mock price feed equals artifacts require mock v three aggregator. Okay, so cool. So this is what we need. So you're saying, okay, price consumer v three, that makes sense.
00:20:00.396 - 00:20:29.610, Speaker A: That's this guy that we've been working on this whole time. What is this mock v three aggregator? So if you'll notice here on the contract side we have a new folder called mocks. Oftentimes this is also called test or whatever you want to call it. It holds stuff in here for testing our contract. So you can see in here we have this mock v three aggregator, Sol, which actually imports directly from the chainlink repo. So we can even click on it. We can go into it, we can see what's in here.
00:20:29.610 - 00:21:22.994, Speaker A: This is just a smaller repo, it's literally exactly the same interface as a regular aggregator, but it's just easier for us to actually test stuff. So we're saying, hey, we're going to get a mock price feed consumer, or, excuse me, a mock price feed. And this is what we're going to reference instead. So remember how when we deployed our price feed smart contracts, we just kind of copied this and had this be blank and we had it like this and we just hard coded it like that. Now we're going to have it be a variable and we're going to pass our mock price feed address in here so that we set our smart contract to look for this fake, this dummy price feed that we're actually deploying. Okay. In oracle there is only actual prices.
00:21:22.994 - 00:21:44.160, Speaker A: Or can we call prices from yesterday? Yes, you can call historical prices. Go check out the docs. Look up get historical prices. So anyways, we're going to swap this out for price feed, right? We're going to swap this out for a variable here. Great. So that's what we do here. Now let's come back now.
00:21:44.160 - 00:22:13.720, Speaker A: You'll see in a second. We're going to take this mock price feed and we're going to deploy a new one to this price feed consumer. So also let's get our default account again. We need to be able to, we need an account to deploy from. And let's do this. Let Price consumer three mock price feed. Okay.
00:22:13.720 - 00:23:07.074, Speaker A: So we're going to define these so that we can use them later. So we have our contract section basically set up. Let's start testing our actual contract. So let's do describe get latest price, right? Because all we want to do now is test getting the latest price. So we're going to do it as a function here and we're going to do this fun little arrow syntax and we're going to do let price equals, I don't know, $200 or 200 way. 1234-5678 910, 1234-5678 that is 200 way. This is what we're going to set to be our price feed.
00:23:07.074 - 00:23:47.320, Speaker A: So we're going to say when we call our price feed, when we call get latest price, this is going to be the response. Why? Well, it's because we're going to set this to be the price of the mock that we're going to do. So now we're going to do a before each again, before each, when we run this test, before each happens, before each one of these tests that we do. And you'll see us do that in a second. So we're going to make this an async function because we need to do some awaits in here. And now we're going to deploy the mock price feed. So we're going to do mock price feed equals, wait, mock price feed new.
00:23:47.320 - 00:24:23.550, Speaker A: And what are the parameters of mock price feed. Well, again, we can find out by going into the contract right here. Again, we're looking for the constructor. What's the constructor? Okay, it takes decimals and initial answer. So the decimals are how many decimals on it? And this is the question we get a lot. How many decimals in the answer and then initial answer. So this is going to be the answer that we're going to return here.
00:24:23.550 - 00:24:44.758, Speaker A: So back in here we're going to say we're going to go for eight decimals. And again, most of these are eight or eight or 18. And we're going to say price is the initial answer. Now we're going to say price. So this is going to be deploying basically a new mock price feed. It's going to be dummy, deploying a new mock price feed. Great.
00:24:44.758 - 00:25:20.050, Speaker A: So now we're going to do mock consumer V three. Excuse me, price consumer v three equals await v three. This is us deploying and we're going to add mockprice fee address as the initial parameter. So if we look on price consumer, we look at its parameters, we see it takes an address as a parameter. Right. And this is how we set this up so we can test it efficiently. So we add it so that it actually takes the price feed as a parameter.
00:25:20.050 - 00:25:40.300, Speaker A: And we can then test this a lot easier. Right. So now we do price consumer v three equals await this new. And boom. Now we have this in here. So before each one of our tests we're going to deploy a fake mock price feed. And we're going to deploy a fake price consumer V three.
00:25:40.300 - 00:26:24.280, Speaker A: Great. Now we can write the test that we actually wanted to do. So we're going to say it returns the price async function and we're going to do some weights. We're saying before each one of these, it's that are coming forward, we need to do this. And did I do that wrong? And this describe, we're saying this kind of whole section is getting the latest price. And we're saying this whole section is this price considered V three contract. So that's kind of how it's split up here.
00:26:24.280 - 00:26:57.434, Speaker A: So you make a fake oracle and a fake contract. So we make a fake price feed. Right. So we're basically making a fake oracle to do our tests here. So we're dummying, getting a response from the mock price feed and you'll see why. So it's the same thing as if we had added a real one in here, but instead of a real one, we pointed our contract to a fake price feed. A fake price feed so that we can test the rest of our smart contract a lot easier.
00:26:57.434 - 00:27:38.490, Speaker A: Right. And you'll see why in just a second. So now we're going to say it returns a price. We're going to make an async function because we're going to do some awaits and we're going to do assert, but equal or actually, just to make it easier, we're going to say let latest price equals await as consumer v three get latest price. Again, this is this function right here at latest price. So we're saying latest price is going to be this and then we're going to cert. Equal.
00:27:38.490 - 00:28:07.862, Speaker A: Latest price is going to equal what? Going to equal price. Right. Because that was the initial price that we've set it as. So we've set up a fake price feed that had an initial answer of 200. Actually, I guess it should be 18, right, because this is definitely 18 decibels. So an initial answer of 200. And then we're going to call it later from our smart contract and assert the latest price is equal to price.
00:28:07.862 - 00:28:52.070, Speaker A: Now, obviously, this is a really simple example here, but what if we did a bunch of crazy stuff here. What if we were like, all right, with get latest price when we were like, okay, price equals price times the square root of infinity and beyond. Something crazy like that, right? We'd want to be able to check to see that our math is good and we're not doing something crazy. And the more intricate these gets, the harder they become to test. So with this simple example, it's obviously really simple. Or with this example, it's not necessarily simple, but this example. Now let's test just this.
00:28:52.070 - 00:29:11.722, Speaker A: Right? So we're going to test just this. So we can do truffle test, test priceconsumerv three test. And we are going to see what happens here. So we're going to just test this. Testing just this bit that we just did. Let's see if we did it right. So what's happening is ganache is running a local chain in the background.
00:29:11.722 - 00:29:31.380, Speaker A: We're going to deploy this fake. Get latest price. Get latest pre is not a function. Let's get latest pre. Let's get latest price. What do you guys say? Let's actually get the latest price. So we're going to test this now.
00:29:31.380 - 00:29:50.090, Speaker A: And great. Passing it returns a price. And you can see it kind of gives this nice little output here. You can ignore that. That's a console log I put in there. So the contract is price consumer V three. We're testing the function get latest price.
00:29:50.090 - 00:30:11.150, Speaker A: Yes, it does return a price. Great. Any questions here? So you make a fake oracle on a fake contract? Basically, yes. Is there a way to test the deployment of the smart contracts as well on testnet aka integration tests? Great question, actually. Yeah, there are. Integration tests are really important, right. So this is how you do it locally.
00:30:11.150 - 00:30:58.382, Speaker A: And this is important for doing really quicker iteration on testing. For doing integration tests, you can actually do network oven or whatever you want it to be. And sometimes what people do is they'll have like if network ID does not equal 42 or whatever test like this. Otherwise test a different way. So there are a little bit of additional setup sometimes when doing these integration tests. And some people actually have a harder time understanding the mocks. So they just go right for the integration tests and they skip over the mocks and they just do everything.
00:30:58.382 - 00:31:36.780, Speaker A: Integration tests. Obviously the disadvantage there is integration tests are going to be, let me even switch. Obviously the disadvantage there is integration tests are a lot slower, right. You got to wait for every transaction to come through, you got to wait for the link to happen and everything. So you absolutely 100% can write tests without doing mocks and just on a network. And again, you can just do that network bit there. But if you're trying to iterate really quickly, the larger your project scales, the harder it's going to be to maintain doing integration tests every time you make a small change.
00:31:36.780 - 00:32:05.554, Speaker A: So it's really important to kind of understand the difference between the integration tests that you're going to do on a testnet and the unit tests that you're going to do kind of locally and with Mox. So that's a really good question, actually. That's a really good question. Typo and get latest price? Yep, sorry about that. Is there a tool to establish test coverage? I think there is, but I forget the name of it right now. Come back to me. Why is an integration test valuable? Good question.
00:32:05.554 - 00:32:38.526, Speaker A: Integration tests are basically, hey, does everything work together the way we expect it to? Right. And this is really important. Unit tests are great because they test a singular piece of your code and this kind of gets into just smart contract. Excuse me. This just gets into software engineering, general concepts here. Unit test is like testing a function and important to see. Okay, does this thing do what I want it to does? Does a little thing do what I want it to do? Integration tests are like, does this thing do what I want it to do when everything else is happening.
00:32:38.526 - 00:33:04.840, Speaker A: Right. And oftentimes there's a lot of everything else happening that can screw something up that you wouldn't expect. So integration tests are super valuable. What is the process for running nightly regression tests? That kind of depends a little bit more on your setup. I don't know if there's a specific, like this is how you got to do it. I don't know if every project even runs nightly regression tests. Maybe they do.
00:33:04.840 - 00:33:25.306, Speaker A: I'm not sure. I don't know that much about nightly regression tests, actually. So. Good question. I'm not sure. Is all of chainlink contract also available with mock and repo? Pretty much, yeah. So there's mock aggregator, mock vrf coordinator.
00:33:25.306 - 00:34:04.700, Speaker A: Actually, I'm in the process of adding or requesting a mock oracle to test API calls locally as well. Right now. What I kind of do is until we get that in, until we get that in properly, is I just do like a mock Oracle contract like you see here, where it's basically the exact same thing as an oracle contract. Excuse me, but I have like a couple variables modified and I'll show that in a second. So this is kind of the simple one here. Let's also do a VRF test because we want to take a look at that. And then if we have time, we'll look at some of the brownie stuff because I love Brownie and Brownie is the best.
00:34:04.700 - 00:34:22.640, Speaker A: You guys can see I'm very biased to Python. I think Python's awesome. Let me just look. How are we doing on time here? We're doing good. We're doing quite well. Okay, so let's do a random number consumer test here because this is going to be a little bit different. Right.
00:34:22.640 - 00:34:56.380, Speaker A: We actually are working with a link token here, and the contracts are going to be a little bit more, they're going to be a little bit more intricate. So let me just delete everything in here, and we're going to do the random number consumer boom. Delete everything in here. Looking at a couple more questions. Is all chain link repo also available? Yeah. So like I said, there's a lot of mocks in there. If you head over to the tests folder, there's a lot of these mocks in there that you can just grab and drag and drop like you see here.
00:34:56.380 - 00:35:28.902, Speaker A: Great question. To what extent do Chainlink devs, at least in development contracts, adhere to TDD, as in writing the test first before one writes the actual phone? I don't know. That's a great question. I mean, chainlink's open source, so you're asking like, what do people do know? I don't know, maybe they all do, maybe they all don't. I mean, TDD test driven development is more like, and just for your guys awareness, here's the question. TDD test driven development is more like a methodology. So I don't know.
00:35:28.902 - 00:35:54.794, Speaker A: That's a good question. I'm sure some do, some don't. Beats me. Will you do more polygon stuff? Yeah. What do you want to see? Let's finish this first and then we can talk about more polygon stuff. But yeah, I definitely highly recommend if you guys are looking to get real link, check out this bridge, this double bridge. So all you got to do is bridge your link token using this bridge and then just swap it using this peg swap.
00:35:54.794 - 00:36:25.030, Speaker A: So really excited to see people using that. Really excited. What I really want to see is I want to see a bunch of projects deploy NFTs on matic using Chainlink VRF. We're hoping to give out some more details on the main net for that very soon, but we will see. Cool. All right, let's do some tests here because these are going to be interesting as let's get, we're going to start the exact same way. We're going to start with assert equals required chi.
00:36:25.030 - 00:36:45.134, Speaker A: Then we're going to do our contract. And this is going to be the random number consumer, comma accounts. Boom, boom, boom. So we're going to test this random number consumer now. So what is this random number consumer that we're testing? Well, let's take a look. Let's take a look. So it's this one.
00:36:45.134 - 00:37:22.262, Speaker A: It's this simple example of, I should stop saying simple because sometimes these are difficult for people to understand. So it's this boilerplate example of getting a random number, right. So we have request random number and fulfill randomness. So we get a random number and then we fulfill it, right. So if you're unfamiliar with Chandlink VRF, we just deployed a whole bunch of video content on it, definitely like clickback or whatever. And then just chainlink VRF. And there's a ton of videos on it that go over this really in depth, especially with remix.
00:37:22.262 - 00:37:56.190, Speaker A: So you'll see here we've changed the contracts a little bit so that they're better to test. And this is actually good software development practice. We want everything that we code to be able to be testable. Specifically, we also want every function to be testable. We're not testing every function here, but just for the demo. But you typically want to test all your functions and test everything here. We have all of the inputs to our constructor here, they're variables.
00:37:56.190 - 00:38:22.990, Speaker A: This is, again, so we can kind of do some of that mock stuff, right? If we're testing locally, there's no link token, so we need to deploy a mock link token. There's no VRF coordinator, so we need to deploy a mock vrf coordinator. Is there a fee? Sure there's a fee, right? We could just set the fee to whatever we want it to be. We could set the key hash to be whatever we want it to be. So we're going to have to deploy mocks of these two. So this is why we need them to be. We need at least those two to be parameters.
00:38:22.990 - 00:39:05.770, Speaker A: I also have last request ID as a thing in here. This isn't the best practice here. The best practice actually is to emit an event. And you'll see how I do that in a minute. But just for the purpose of this demo and for simplicities, we're just having it be last request ID. Okay, let's get into it. Const random number consumer equals artifacts require, require random number consumer.
00:39:05.770 - 00:39:21.262, Speaker A: Boom again. Hey, give me the random number consumer. It's in the build. We did truffle compile or hard hat compile or brownie compile or whatever. It's in the build. It's in the build. In the build.
00:39:21.262 - 00:39:55.274, Speaker A: Give me the build now. Const DRF coordinator or didnator. Mock equals effects require VRF. You guessed it, coordinator again. We can see that in here. Right when we compiled, we have this test VRF coordinator mock. Why is this one mock aggregator and this one VRF coordinator mock? Good question.
00:39:55.274 - 00:40:33.750, Speaker A: I don't know. Great question. This is vs. Code that I'm using. Yeah, this is vs. Code. So we have this VRF coordinator mock and this is going to be the exact same as the mock like price feed, right? Very similar to that, except for instead of having this on chain contract that's going to verify randomness, we're going to have a fake dummy, one that's going to verify randomness.
00:40:33.750 - 00:41:21.366, Speaker A: We're going to be calling a fake chain link oracle here. Okay. Now we also need a fake link token, right? And this one we don't have, we don't have in our tests, but we could, we could put like a mock link token, but we're actually just going to pull it right from our package, right? So when we installed this, we did NPM install this in the backseat when we did NPM install. So we're actually just going to pull the link token. And let me just do this from our package here. And do we need to mock anything else? No, not really. This we need to mock this.
00:41:21.366 - 00:41:39.498, Speaker A: We need to mock. This is fine as it is. Right. This is the contract that we're testing. So again, per usual counts, we need a default account equals accounts zero. And. Great.
00:41:39.498 - 00:42:06.530, Speaker A: Now we're just going to do a couple of lets because all of our contracts are going to have, all of our tests are going to have some stuff in common. They're all going to have random number consumer with the lowercase R because this is us pulling us in the class. This is going to be the actual instance of it. BRF core de nator mock. We're also going to need a seed phrase. We're going to need the mock link token. We're going to need a mock key hash.
00:42:06.530 - 00:42:32.560, Speaker A: Keyhost hash. And we're going to need a fee. Okay, great. So that's all the stuff that we need right there. So let us proceed. Time for us to build the test. So let's describe, what are we testing? Describe do request random number.
00:42:32.560 - 00:43:11.334, Speaker A: This is just going to be a regular function, hence this arrow stuff function. And our first test is, sorry, we're not going to do tests so we need to do a before each, again, right before each of our tests we need to do some stuff. What do we need to do? Well, we probably want to deploy this stuff so that we can test it. Right before each one of these tests we want to deploy the random consumer so we can test it. Let's do this. So let's set up the key hash equals and I'm just going to copy paste the key hash value in here. Boom.
00:43:11.334 - 00:44:03.894, Speaker A: Super long. Doesn't really matter the key hash fee equals doesn't really matter the fee. We're going to do 112-34-5678 910 1234-5678 link equals waitlinktoken New from default account because we need to dummy a link token. So we're going to deploy a dummy link token. Then we need to deploy our VRF coordinator mock equals await. VRF coordinator mock new and what are the parameters for the VRF coordinator mock so we know there's nothing for the link token. We can check, we can go vrf coordinator mock control, click into it constructor.
00:44:03.894 - 00:44:24.382, Speaker A: All it takes is the link address. So that's all we need to do for our test here. So we can do link address comma from default account. Default account. So we're deploying a mock link token. Mock VRF coordinator, guess what we deploy now. You got it.
00:44:24.382 - 00:44:39.318, Speaker A: A mock or excuse me, not a mock, a random number consumer, an actual random consumer because this is the contract. We don't want to mock, we want to test this. We also want our seed. Seed. This is going to be the seed. It's going to be whatever. Let's just do one, two, three.
00:44:39.318 - 00:45:12.834, Speaker A: It's going to be the seed for the random number. We'll need it a little bit lower. So now we're going to do random number consumer equals await random number consumer new. And we needed to deploy these two first, obviously because we need those addresses so we can come back to the random number consumer. Number consumer, look at its constructor and we see it needs a link token for the first one. So for the first parameter so we can do link address. Great.
00:45:12.834 - 00:45:31.880, Speaker A: Second one is going to be the key hash. Key hash which we have defined up here. And we're going to do the VRF coordinator mock address. And last but not least, the fee. Fee. Just kidding. Last but not least, the default account.
00:45:31.880 - 00:46:08.734, Speaker A: Remember you need this toggle word wrap. Remember you need this from anytime you make any type of transaction with web3 or ethereum, you need it like a from. It's like who is this transaction happening from? And we're saying default account which is our account zero which gets pulled in from Truffle's fancy keywords. Cool. Going to quickly look at some comments. Is it better to build on remix or truffle? I like to say like remix is really good. It's kind of like a little bit like training wheels.
00:46:08.734 - 00:46:38.730, Speaker A: It's great for really visualizing and understanding smart contracts. If you want a really sophisticated application, you need to use truffle brownie or hard hat. There's really no other better way to say it. You got to use one of those. If you make it on remix, you should import so many contract from GitHub. If you make this on GitHub or on remix, you do have to import right from GitHub. Will this video be saved? Yes, absolutely.
00:46:38.730 - 00:46:57.220, Speaker A: 100%, definitely. Come back to it later. Cool. So we have the describe up now we have the before. Did I not do the before each? Oops, I didn't say that this was before each. Oh, sorry guys, my bad. This is actually before each.
00:46:57.220 - 00:47:29.226, Speaker A: And this is an async function because you're doing awaits. Sorry about this, guys. So this is actually going to go into there. Why are we doing this before each? So this is saying for everything that's happening in this describe before each of these tests that we're going to do, we need to set it up. So we're going to set it up like this. So let's keep going. We're going to say it now, we're going to do our first test, and I got to be a little bit quicker because I'm running out of time.
00:47:29.226 - 00:47:43.740, Speaker A: Although I don't think anyone's after me. Right? So we can go a few minutes over. Yeah, no one's after me, so we can go a couple of minutes over. Worst case, we have almost 70 people watching. Great. Awesome. Hello.
00:47:43.740 - 00:47:59.620, Speaker A: Welcome everybody. We're learning really important stuff here. Remember, everyone who's watching, feel free to leave a comment, say hello, ask a question. These are meant to be interactive, so questions have been great so far. Definitely good questions. No question is too dumb. No question.
00:47:59.620 - 00:48:24.576, Speaker A: There are no dumb questions here. No dumb questions here. Okay, so what do we want to test? So oftentimes I'll do this. It reverts without link. I mean, you don't really have to do this, but let's just do it kind of real quickly. So if our contract doesn't have link, it's going to revert, right? Because the VRF coordinator needs link to function. It needs the link token.
00:48:24.576 - 00:48:49.620, Speaker A: Link token. Is that ERC 677? Is this big enough, by the way? Oh, that's like obnoxiously big. If you guys want this bigger, let me know. Hello, welcome. And so we're going to have it revert without link. So if we tried to call a function, right, we would expect it to revert. So we're going to call, wait, expect revert.
00:48:49.620 - 00:49:19.148, Speaker A: And then actually we got to add some open zeppelin test helpers. So this is something else we want to grab if we want to use expect revert, which you'll see how I use it right here. Openzeppelin again, open zeppelin has amazing tools. So await expect revert unspecified. We should actually put what the revert message in here. This is basically saying, hey, we expect a revert to happen. We don't know what kind.
00:49:19.148 - 00:49:47.680, Speaker A: We should probably put the real one in here. But just for simplicity, we're going to keep it like this. Now we're going to call the function number, get random number feed. And again, always from fault account, we should expect this to revert, right? Because again, in our random number sol if we call get random number. This needs link. We know it needs link. This should fail.
00:49:47.680 - 00:50:16.320, Speaker A: So if we run this, it will pass odly enough because we're telling it, hey, this is going to fail. So let's run the test just on this truffle test, random consumer test Js. So this will pass because we're saying we want it to fail. Great. So it does revert. So we're saying this did fail. If this didn't fail, we would be confused.
00:50:16.320 - 00:50:21.730, Speaker A: So we did this. Right. Hello. Hello. Oh, everyone's saying hello now. Yay. Welcome.
00:50:21.730 - 00:50:55.352, Speaker A: What do you think about using FSM final state machine for building smart contracts? I don't know. I don't know that much about that. Sorry. Love your questions. By the way. Great questions right here. How does each test differ from the previous one? Since you are setting it up the same each time, won't each test result be the same? How does each test differ from the previous one? Since you're setting up, won't each test be the same? Okay, good question.
00:50:55.352 - 00:51:37.992, Speaker A: So I'm setting it up the same, right? Because I want to do this in every thing in every test. But for us this is actually a perfect question. But for example, in this test here, I'm calling get random number, but I didn't supply it with link, right. So this test is going to be very different than the next test that I write, which will supply it with link. So these are, you kind of capture these different scenarios, right? So now I'm going to say it turns a random number with link. So this is one that's going to be different. So it's going to be set up the same, but we're going to do different stuff in the test.
00:51:37.992 - 00:51:52.060, Speaker A: That way we can see the different stuff and we can see the different. Is there a way to capture events? Great question. We're actually going to come right to that. Great question. Really good question. This is Alejandro. We're actually going to demo that very soon.
00:51:52.060 - 00:52:47.544, Speaker A: Hey, what's up? How are we doing? Hello. All right, cool. So now the first thing we want to do is we want to send our random number consumer link. So we're going to do link transfer and this is going to dummy sending our random number consumer contract link. We're going to send link transfer address and then we're going to do some web3 stuff. Actually web3 utils, two way, one ether from account. So no, we're not sending one ether, we're sending one link, which is we're saying, hey, grab this one, this number one, turn it to way in ether.
00:52:47.544 - 00:53:43.010, Speaker A: So this could also be kind of replaced with like 112-34-5678 910, 1234-5678 but actually JavaScript might kick out because JavaScript doesn't like big numbers. So we're saying, okay, transfer and you can look up the parameters transfer takes. It takes an address, it takes an amount and then obviously everything takes it from default call out. So we're just sending our random number, consumer contract, some link so that we can test. Let's keep moving on then what we want to do now, we can actually call that contract. So we're going to say let transaction again. Because what we get back when we call function is a transaction equals await random number, consumer, consumer, get random number.
00:53:43.010 - 00:54:01.832, Speaker A: And what are the parameters of get random number? I believe it's just a seed. Yes, it's just a user provided seed. So we can call it. So again we have the seed defined up top. So we're going to do seed or from seed. And again everything is going to be from default account. Okay.
00:54:01.832 - 00:54:36.756, Speaker A: So we have a transaction and we're going to equal it to that. So here's the answer to your question, actually. And then we can even console log, transaction receipt, raw logs. So I'm just going to run this to show our friend here how to actually see event data. So if we emitted events, you can see everything in this transaction receipt, in these logs basically. And that's actually a really good question. And you can see kind of everything in here.
00:54:36.756 - 00:55:02.920, Speaker A: Here are the different topics. There's all this stuff in here. There's the log index, log one, log zero. These are the different events that are being emitted. So that's actually a really good question. And events are actually the way we want to test things. So I'm doing kind of this cheaty way where I'm setting last request ID to a public variable.
00:55:02.920 - 00:55:38.580, Speaker A: What we really want to do is define an event, event, whatever. And I'm not going to go into this here. And then we do like a MIT event. And then what we'll do in our test is actually check. We'll do like an assert equal transaction receipt raw logs, whatever log you want to do at whatever point equals what the event that you're expecting. That's a really good question. I know I kind of skimmed over that material.
00:55:38.580 - 00:55:58.510, Speaker A: But events are really good for writing tests and they're really just good to have in general. So there you go. So this is kind of that whole bit. So you can write your tests and actually check the events. And that's actually really good practice. So I'm giving you kind of a cheatier practice here. I'm sorry.
00:55:58.510 - 00:56:38.010, Speaker A: In your tests it's much better to actually check the events. So great question. Really good question. And then even then we can do smarter things than like assert exists TX receipt receipt logs this is like the super lazy way to check, hey, did we do this right? Are there even logs? Yes. Okay, cool, we'll move on. So the better way, like I said, is actually to emit some events to see that this worked. So we're going to get a random number here.
00:56:38.010 - 00:57:42.110, Speaker A: We're doing kind of this really lazy test here. Now what happens? Okay, so we need to figure out, okay, are we going to get a random number back? How do we get that random number back? Well, this is a great question. So first off we need to get the request ID because what we need to do is we actually need the VRF coordinator mock to call back the function. So in this contract our oracle actually calls the VRF coordinator which calls fulfill randomness. So that's something that we need to understand and it calls it with this callback with randomness function. See this is the function that it uses to actually call back that fulfill randomness function. And you can even see it here, it's doing some, a little bit fancy solidity stuff.
00:57:42.110 - 00:58:14.036, Speaker A: It's calling the fulfill randomness selector, which I forget where it is, it's somewhere in this code base here. But this raw fulfill randomness function calls the fulfill randomness function. But this is the method that actually does it. So this is another reason we needed to deploy the mocks. We have control over the VF coordinator so that we can actually call back. So we've made this transaction to make a request to an oracle. We need to pretend that it is going to respond.
00:58:14.036 - 00:58:53.440, Speaker A: So I'm going to do let request ID equals await random number consumer last request ID. And now I'm feeling kind of silly. And now I'm like I should have done it with the event actually default account. So again, I kind of cheated here. And actually I'm probably going to update this later to do it the right way. I have this last request ID so that I can get the request ID. And what I do is I just set that last request ID variable to the return of request randomness so that we can have the request ID for the VRF coordinator mock.
00:58:53.440 - 00:59:15.964, Speaker A: But again, the right way to do that is actually with events. So I will probably update that so that we can test appropriately. But for now we're going to test it this kind of cheaty way. And the reason I'm saying because is you actually can't get the return value of a smart contract. Just kind of like by calling it like this. So we're calling get random number and if we look hey, get random number. It returns a bytes 32.
00:59:15.964 - 00:59:35.970, Speaker A: Right. Tough. In web3, the return value is going to be that transaction actually. So like I said, the correct way is to use events, as Alejandro pointed out. So thank you, Alejandro. We're going to do it this cheaty way. For now, request ID equals a weight random number consumer last request ID.
00:59:35.970 - 01:00:18.672, Speaker A: And then we're gonna do, now we're gonna call the VRF coordinator lock VRF coordinator mock callback. Callback with randomness. And we're going to give it the request ID because it needs the request ID. We're going to give it the random number, which we're going to set to seven seven seven. And we need it to give it to random consumer address. So we're saying, okay, this request ID returned this random number and this was the address that called it. And we're going to say this is from, again, default account because we don't really care which account we're calling from.
01:00:18.672 - 01:01:01.564, Speaker A: Now we're just going to do a quick assert equals assert equal actually should be non assert equal. Now we actually need to get that random number equals await random number consumer random result from default account. The VRF coordinator mock called it back. Called back. The function called back. The function gave us a random number, and now we're going to get that random number from the random result. Right.
01:01:01.564 - 01:01:23.524, Speaker A: So all these public variables are secretly functions. Secretly view functions. Right. So we're going to call this view function for getting random result. And we're going to say, okay, get out of the way. All these things keep popping up. Random number got to be equal to what we set it to.
01:01:23.524 - 01:01:42.576, Speaker A: Seven seven seven. Right. So seven seven seven or seven seven seven. So let's test it and see if we did smart things. Let's see if this works. We did. Then we've successfully tested our random number consumer locally.
01:01:42.576 - 01:01:52.860, Speaker A: Right. This is all locally. This is testing our chain link. Smart contracts locally. Okay, we did something bad here. TX is not defined. Okay, well, it's because it's transaction.
01:01:52.860 - 01:02:14.740, Speaker A: Now let's see if we did this right. We did something else. Random dumber. Lubur. Yeah, that's not a thing. So that makes sense as well. Random dumber.
01:02:14.740 - 01:02:31.204, Speaker A: Little tongue twist. A little tongue tie for you there. Did I spell it wrong anywhere else? Spelling programmers greatest strengths. Spelling things right. Now let's see if we spelled it right. Great. And now everything's passing.
01:02:31.204 - 01:03:05.300, Speaker A: And now we can say, great. We've successfully tested our smart contracts. We are now wizards of testing. And this is obviously incredibly powerful because we don't need to do all of our tests on a test net, right? We can still do this network COVID or whatever. And we can also just hard code everything in here to be for specific addresses. And oftentimes I'll do that too. But more often than not I'll do that for the scripts in the script section is okay.
01:03:05.300 - 01:03:35.208, Speaker A: This is where I'm going to kind of do an integration test as a script or something like that. It's good to have maybe like a separate folder for integration tests. It's really kind of however you want to do it. But now we can do this without even having to get any testnet link, any testnet ETH. And it's really powerful in that regard. So I didn't get to show you guys how we do it in brownie. And pretty much everything that we just went through the same methodology is going to work for hard hat.
01:03:35.208 - 01:04:00.784, Speaker A: Some of the syntax might be a little bit different, but you can check out the hard hat docs. They are fantastic at explaining their testing. Their testing is really good. One other note to mention with truffle, if your migrations aren't perfect, it'll freak out and not let you do anything. Kind of annoying. But it is by design that it does that for some reason. So just make sure your migrations are good as well.
01:04:00.784 - 01:04:24.796, Speaker A: That way you can actually do stuff. So I'm trying to pull up brownie. So my brownie tests are in here as well. I have test contracts, I have mocks. You can check out the tests here. They're pretty similar. And by pretty similar I mean they're literally the exact same steps just in python, right? So here's a python test for testing a price feed.
01:04:24.796 - 01:04:40.640, Speaker A: It's doing the exact same thing. So it's taking an address. This is actually creating a mock address. Get latest price. It's in the comp test. I'll just kind of look through it really quickly. Late.
01:04:40.640 - 01:05:12.028, Speaker A: What is it called? Fusd price. Here we go. And you can see it's doing the same thing if network showactive. It's saying if we're testing on the development network, we're going to deploy a fake aggregator here. And actually to your other question. Well okay, what about my other test? Well, okay great. If network showactive is in the defined networks, then we're going to use a real network, right? So this is a way to test with networks that we actually have.
01:05:12.028 - 01:05:45.576, Speaker A: And then if it's not, then we skip it. So it's literally the exact same methodology. Then we deploy our price feed contract, our price feed consumer, and then we test it. We say, okay, get the latest price, assert that it's a value, that it's an integer, and that it is greater than zero. So it's going to be the same thing here. There's a mock oracle contract, whole bunch of fun stuff, and we are a little bit overtime, but we don't have a hard stop here so we have time for some questions. Hope you guys learned something here.
01:05:45.576 - 01:06:12.140, Speaker A: I know we kind of went through a lot of stuff. Like I said, testing these smart contracts is incredibly valuable and it'll help you iterate much quicker on building these. Dapps, if you do some of this testing, right, locally, yes, you can absolutely 100% test and deploy everything on a testnet. And in fact, when I was first starting out, that's mostly what I did. But doing a lot of this stuff locally will make you a lot quicker. I promise. It'll make you much faster and it'll make you much safer.
01:06:12.140 - 01:06:26.800, Speaker A: Right, because you're going to have tests on everything and if you accidentally break something, you'll know about it because your tests will fail. So tests are absolutely massive, especially in the smart contract world. So. Hope you guys learned something. Patrick, you're kind of hilarious. Well, thank you. I'm going to take that as a compliment.
01:06:26.800 - 01:06:47.884, Speaker A: Appreciate that. Looks more succinct. Python is king. Okay, cool. Well, we have some other Python enthusiasts here. Love it. Looking at questions now, this might be off topic, but just wanted to confirm, for smart contracts, can we make a call to one of our hosted APIs on Google Cloud using chain link? Absolutely, 100%.
01:06:47.884 - 01:07:10.752, Speaker A: Go check out the make a get request. Pop your get request in here, right. Swap this out for an API call. That makes sense. Make sure you kind of watch our video on making API calls, right? Because you're going to need to know how to choose an oracle in Java. D just follow this tutorial. If you're like, wait, I'm still a little confused.
01:07:10.752 - 01:07:36.212, Speaker A: Go through this advanced API calls, it will teach you everything. If you're like, I'm super confused. This will teach you everything. If your API call is really advanced and you're using some stuff in headers and bodies or you have API keys, you're going to want to look into external adapters, which we're going to go over tomorrow. Is today Thursday? How's today already Thursday? Today's already Thursday. Oh my goodness. I hope you guys are building crazy stuff.
01:07:36.212 - 01:07:56.556, Speaker A: So we're going to go over that tomorrow. We're going to go over a local chain link node, external adapters on your chain link node so you can kind of do more customizable crazy stuff. So looking forward to seeing all the crazy stuff people build. Good questions. Looks more succinct. Yeah. Like I said, I start all my projects now with brownie.
01:07:56.556 - 01:08:09.910, Speaker A: Big hardhead is also great. Hardhead's really good. Great workshop. Thank you. Thank you so much. So I know we're over, but we don't have a hard stop here, so I'm happy to take some other questions. If you guys have questions or comments or.
01:08:09.910 - 01:08:35.040, Speaker A: Thank you for the kind words here. Really appreciate it. Really hope that you guys are getting value out of these because I think we're going over some really important stuff and some stuff that's really going to help you take your smart contracts to the next level. So looking at questions, we'll take a couple more questions. Oh, is that the one and the only? Oh, one and the only. Hey, welcome. How's it going? The one and only.
01:08:35.040 - 01:08:51.252, Speaker A: Ladies and gents. Ladies and gents. Cool. Well, we'll wait maybe 30 more seconds because it sounds like you guys are all testing wizards. You guys were like, yep. No, Patrick got it. Makes sense.
01:08:51.252 - 01:09:20.088, Speaker A: Your question. Oh, well, what was your question? It looks like my thing is updating a little bit slow. Feel free to drop your question again, general question about the project. Should we aim to implement our project on the ether main net or keep it on the coven testnet? It's whatever you want to do, actually. And it doesn't even have to be the ether main net. It can be Polygon. Who's a sponsor? Avalanche.
01:09:20.088 - 01:09:38.680, Speaker A: Who's a sponsor? Solana. Who's a sponsor? Moonbeam. Who's a sponsor? Plasma. Who's a sponsor? Polkadot. Like the list goes on. If you want to deploy now, you absolutely can. I will say, though, if your project is handling money or something, you probably want to go get it audited.
01:09:38.680 - 01:10:05.576, Speaker A: Right? You want to get it audited. If it's like an NFT or something, maybe that's a little bit easier. But if you're trying to deploy some real powerful applications that people are going to want to use, you absolutely need to get it audited. And for me, I like looking at Openzeppen and what Openzeppen does. That's a personal thing here. But yeah, if you're going to go to Mainnet, you definitely want to get it audited. You absolutely can deploy on Mainnet.
01:10:05.576 - 01:10:41.770, Speaker A: And I would actually love to see some people deploy, for example, like on matic with some VRS stuff or on matic with some price feed stuff because the gas fees are so cheap there. Would love to see some people deploy some applications there. But no, you do not have to deploy to a main net. You can deploy everything to a testnet, and that's good enough for like a submission here, so you do not have to deploy to a main net. Good question. What exactly is open zeppelin? Okay, good question. So open Zeppelin, let me even flip back to the stream here.
01:10:41.770 - 01:11:18.384, Speaker A: So open Zeppelin is like a collection of smart contracts. And they also do a bunch of other stuff. They do audits, they do defender platform to automate Ethereum operations, reusable libraries, security audits. They have a lot of really cool stuff. Probably their coolest thing is this contracts, application build, secure smart contracts in solidity. So you can see here we even use some of their stuff. Or do we? Maybe we don't.
01:11:18.384 - 01:11:59.116, Speaker A: Not in these, but in the demo. NFT, our NFT demo we did earlier, we did use some of their stuff. So if we go into dungeons and did, we imported some of their contracts. So they have a whole bunch of contracts that are basically already pre configured for standards, have a lot of safety measures already built in, and they're already audited. So it's really kind of easy to just grab what they've done, plug it into our projects and be ready to go. So Openzeppelin, absolutely love them. I pretty much use them in all my projects, so definitely open zeppelin.
01:11:59.116 - 01:12:26.692, Speaker A: Really cool. A couple of these questions I don't really understand. Sorry. What about this platform? Truffle is good too. Yeah, all these platforms are good. If you want to build all these platforms, we'll get the job done. All right, cool.
01:12:26.692 - 01:12:40.920, Speaker A: Well, if there are no more questions, thank you, everybody, so much for watching. I hope you all learned something. I'll see you guys in the discord. Feel free to again ask questions. Really looking forward to the projects that you guys build, and we'll talk to you guys soon. Thanks all. Bye.
