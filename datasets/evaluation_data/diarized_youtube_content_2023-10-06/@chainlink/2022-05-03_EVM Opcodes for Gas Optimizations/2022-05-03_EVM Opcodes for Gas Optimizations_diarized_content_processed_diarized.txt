00:01:13.570 - 00:02:03.414, Speaker A: Hello, hello, welcome, everybody, to another chainlink hackathon workshop here. We're going to get started in just a minute. How's everybody doing today? How are we all doing? How was life? Hello, hello. How are we? What's going on? My Internet seems to be having an issue, so hopefully the quality is going to come in okay. I just kind of just have to deal with it. Can I restart my. No, that didn't fix anything.
00:02:03.414 - 00:02:27.642, Speaker A: That's sad. Well, hopefully you'll be able to see my screen. Sorry, my wifi is having some issues here. Apologies there. Yeah, I'm aware quality is not going to be great right now, but we are here to talk about EVM opcodes and gas optimizations. So this is a big one. This is an exciting one.
00:02:27.642 - 00:03:17.442, Speaker A: We're going to learn how to make our contracts more efficient. Usually my quality just kind of comes back, but it's just going to stay down like that. It's really just going to do that to me. Said I was going to get an Ethernet cable and I still plan on doing that if I refresh my page. Give me 1 second it. That's a little better. All right, cool.
00:03:17.442 - 00:03:31.320, Speaker A: All right, so we're a few minutes past already. Let's jump into it. And remember, this is going to be collaborative, right? Please ask questions. Please drop into the comments. I can see you all here. What up, what up? How are we all doing? And yeah, ask a ton of questions. Let's jump right into it.
00:03:31.320 - 00:04:10.098, Speaker A: So we're going to be talking about EVM opcodes for gas optimizations here. And there's a couple, a bunch of different useful resources here. And I actually can share these slides in the chat here. Anybody who wants to follow along wants to check out some of those resources, feel free to check them out. And of course, actually, before we finish this, grab that QR code. I'll leave it up for the first couple of slides so that later on, once this is over, you can grab the QR code and you can give us some feedback on this session. Let us know if you liked it, hated it, loved it.
00:04:10.098 - 00:05:00.690, Speaker A: Want to see more? Want to see less? Lets us know what people liked and what they did not like. So what's on the menu today? Here's what we're going to be talking about. We're going to talk about EVM overview, storage overview, transactions overview, and a little bit about contract deployment so we can make more efficient, more gas efficient choices with our solidity code. Now, the first thing to keep in mind is that whenever we compile our contracts we get two files. Essentially, we get a contract ABI and a contract bin. The EVM, or Ethereum virtual machine, is a computation engine that handles smart contract deployments and execution. That bin file, that bin file is going to be your binary file.
00:05:00.690 - 00:05:39.522, Speaker A: And then the ABI is going to be our application binary interface. It's going to be how we can interact with our code. And if you're on remix, for example, if you look at the bottom, there are the two things that end up being down there. One's ABi, one's bytecode. If you copy those and you paste them into a file, you'll get exactly that. You'll get the ABis, and you'll get all the low level bytecode stuff. Now, when we compile this down, we get these bytecodes, right? We get these very small, these minimalistic jumble of letters and numbers and stuff.
00:05:39.522 - 00:05:55.480, Speaker A: And you might have seen these before. And here's a bytecode snippet of this and to humans. Oh, snap. I did forget to put this on the discord. Sorry. Thank you. Good call.
00:05:55.480 - 00:06:33.794, Speaker A: Let me do that right now. Appreciate the shout out, Freddie. Let's do that. Let's go to discord. Thank you for up. All right, cool. Sent.
00:06:33.794 - 00:07:15.422, Speaker A: All right, let's go back. So here's like a little bytecode snippet. Now, this is basically a contract compiled down to the machine instructions or the machine level instruction, which to a human means absolutely nothing, right? This is a jarble of numbers and doesn't make any sense here. And this actually gets compiled down to what's called these opcodes or the machine readable instructions. This jarble of numbers here gets compiled down to the really low level machine instructions. So we're literally telling our computers exactly what to do, what transistors to flip, where to stick some memory stuff. We're being very specific.
00:07:15.422 - 00:07:59.050, Speaker A: And this gets translated into this exact bytecode, gets translated exactly into these, what's called opcodes. And it's these opcodes that are the low level binary, the low level code that our solidity compilers and our evms run to actually do stuff, to do stuff with our solidity code. So we're seeing in here, we can read this as that 60 stands for the push op code. So we're saying we want to push five. So that's what these first four are doing. We're saying, okay, push five. This next group of four.
00:07:59.050 - 00:08:28.886, Speaker A: So the first two is the opcode saying 60 is push four. So we're pushing four. And then we're adding the two of these together, that's exactly what this opcode stands for. And you can see kind of a list of all these EVM opcodes. If you go to EVM codes and you can see a list of all these opcodes here. You can see what their names are, what the bytecode, what the opcode is, what the two digits that represent. That is what the inputs are, what the outputs are.
00:08:28.886 - 00:08:56.800, Speaker A: And you see this really interesting one here called minimum gas. And that's going to be one of the important pieces of what we're focusing on for this video. So each one of these opcodes costs a different amount of gas to do. So if you want to add two numbers, you're spending a minimum of three gas. If you want to multiply, you're spending five gas. Subtract three gas. And we have all these different opcodes in here that do all these different things.
00:08:56.800 - 00:09:28.342, Speaker A: And we'll come back to that. In this specific example that we have here, this push, push, add. We end up pushing data onto what's something called the stack. So Ethereum is a single stack based machine. If you're familiar with like registers. It doesn't have any registers, it's purely stack based. So whenever we do anything, whenever we do some computation, it puts all this stuff on what's called like the stack.
00:09:28.342 - 00:10:17.126, Speaker A: So it's this different data structure that it works with called the stack for doing all of our computations. So this is kind of an example of we're just adding two numbers, right? And the way that it's literally going to add the two numbers is first we're going to push zero x five onto the stack right here. So we push that number onto the stack. Then we push zero x four onto the stack. So with the stack is literally, what is it? A last in, first out. Hold on, a last in, first out data structure. Meaning the first thing that went on this data structure is going to be now at the bottom, right? So if we pushed a ton more stuff on the stack, this five would always be on the bottom.
00:10:17.126 - 00:10:42.946, Speaker A: So now we pushed zero x four into the stack. Now we have a four and a five on our stack here. And then we call this add opcode. And then we can even look in evm code to see exactly what it does. And this stack input is going to be a and b. So it's going to be the first two positions of the stack. And it's going to just literally add the two of them together.
00:10:42.946 - 00:11:22.218, Speaker A: So we're going to call this ad op code. We're going to say okay, we're going to pop this four off the stack. We're saying, okay, goodbye, four. We're also going to pop five off the stack, and we're going to add the two of them together, and then we're going to stick that back onto the top of the stack. So we had four or five, then we ran this opcode, add solidity, said, okay, cool, I'm going to take those last two, pull them off the stack, combine them together, and then stick back whatever is left. And then we get nine here. And so we could even kind of calculate, very roughly kind of the gas of those three upcodes.
00:11:22.218 - 00:11:43.830, Speaker A: So we had add, which was three. We had push one, which was three. We had push one, which was three. So, in total, just those three operations cost nine gas. Right. So now you're starting to see, oh, okay. If we understand exactly what's going on in the bytecode, we can really start to understand what's going on with how much gas we're spending.
00:11:43.830 - 00:12:33.346, Speaker A: Now. The EVM can access and store information in six different places. The first place is this stack that we just talked about, and that's where it does some of this computational stuff. Another one is memory, which is where everything in memory is this temporary location that just gets wiped and deleted after a transaction finishes. Storage, which is one we're going to be focusing on today, which is a place in a data structure in our smart contracts that is persistent, and you'll hear storage used a lot. We have call data, which is a special data type for input parameters to functions. We have code, which is literally like the bytecode of our contracts.
00:12:33.346 - 00:13:34.762, Speaker A: And then we have logs, which is whenever we emit an event, data gets pushed to this location. So these are the six spots that information is accessed and stored at all times. Right? So anytime you're reading data, anytime you're writing data, it's going to be one of these six places. And understanding which of these six places we're reading or writing the data from is going to be paramount to making gas optimizations, because each one of these has very different gas consumption rules, and in combination with our opcodes, and that'll make sense in a second. So, now that we've kind of talked about this, we talked about pushing stacks, opcodes, all that weird stuff. Let's talk about storage. So, in solidity, one of these data structures that we use is this data structure called storage, right? It's one of these six places, right? And here's kind of the layout of how storage actually works.
00:13:34.762 - 00:14:56.606, Speaker A: So whenever we have kind of a global variable or one of these variables that's kind of outside of a function, it gets stuck in storage. That's because it's going to be persistent. If a favorite number was a public variable, we would have that read favorite number, excuse me, we would have a view function, right, called favorite number that we could call and we could view this storage spot at location zero. We can read exactly what's going on here, right? So when we do this Un 256 favorite number at the top of this exact contract, it gets stuck in the zero width slot of storage here, right? Each slot is going to be 32 bytes long, represents the bytes version of an object, right? The Un 256 version of 25 right here. So we're sticking favorite number equals 25 into storage is going to be zero x 19. If we have a boolean, we do the same thing, right? And since this variable is underneath this favorite number, solidity just sticks it in the first storage slot here. So now we have two persistent variables, two variables that are going to go in storage, two variables that even after functions go through, they're going to stay, it gets stuck in this first storage slot.
00:14:56.606 - 00:15:59.398, Speaker A: And for booleans, a true boolean would be zero x one, since the hex version of true is zero x one, which is kind of interesting. True, the boolean of true has the exact same bytes as the number one and the Boolean false has the exact same bytes as the number zero. Kind of interesting how that kind of hex conversion works. Now if we have an array, arrays and mappings are a little bit different in specific dynamic arrays and dynamic mappings, they're kind of interesting. So for dynamic values like mappings and arrays, the elements are stored using a hashing function. So we do hold up a slot here, right? When we add un 256, my array, we do add it to kind of this sequential storage thing. But when we push a number like 222, we do some weird hashing function and pick some crazy spot in storage to store the data.
00:15:59.398 - 00:16:53.320, Speaker A: So 222, the hash of that is like whole bunch of, we stick the two two two version at this kind of crazy location that's based off of some weird hashing function for arrays. Now at that sequential storage slot, right? So zero is favorite number, one is sambul, two is my array. At this spot here we just have the length of the array so that we know how long the array is. And then all the elements inside the array are at these weird locations in storage. And there's a ton of spots in storage. So hopefully we don't clash with anything but that's kind of another conversation for mappings. Mappings also take up a storage slot, but they don't have a length of the map or anything like that.
00:16:53.320 - 00:17:49.194, Speaker A: So for mappings, this is just kept blank just to say, hey, we have a mapping in here, but we're just going to leave it blank for now. Now interestingly enough, constants and immutable variables are not stored in storage. Constants and immutables are not stored in storage. They don't take up a slot in this data structure. Now you might be thinking, well, how is that possible? Well, we know constants and immutables can't change, right? So we don't need to stick them in a storage slot, right? Because the reason we have this storage data structure is so we can say, hey, I need to update what's at the zero slot, hey, I need to update what's at the first slot, I need to update what's at the second slot, et cetera. Constant variables never change so we never need to update them. So instead of storing them in storage, where do you think they're stored? Where do you think we're stored? Let me see in the comments here.
00:17:49.194 - 00:18:25.686, Speaker A: Where do you think constant variables are stored? If they are not in storage? If they're not stored in storage, where could they be? And here are the six places they could be stored. It's going to be stack memory. I just said it's non storage, so not storage. Call data code or logs. Where do we think? Where would we guess? And if you saw that slide, there was a hint in there, the answer was in there, but don't rewind. Guess. Where do you think that's stored? Where do you think constant variables are stored? Where do we think, okay, we got some guesses here.
00:18:25.686 - 00:19:01.946, Speaker A: We have code memory, code stack memory logs, probably memory. Where do we think code stack. These are all great guesses, so I'm going to tell you the answer now. So it's actually stored directly in the code or the bytecode of the actual code. So it's not stored in memory because memory is, and I know I didn't really tell you a lot about these different types of storage. It's unstored in memory because memory is deleted after a transaction finishes. It's not in the stack, it's on storage.
00:19:01.946 - 00:19:36.830, Speaker A: Like I said, it's not call data, it's not a parameter. And smart contracts actually can't read from logs. Once you emit a log, a smart contract can never read that again. So it's stored directly in the bytecode. So the way that this works, the way that this works in solidity is solidity goes, oh, okay, well, anytime I see this not in storage variable in your code, I'm just going to swap out with the number one, two, three. So it literally, like inside that code data structure, it doesn't recognize not in storage as a variable. It recognizes not in storage as the number one, two, three.
00:19:36.830 - 00:20:30.622, Speaker A: It literally just goes, it just goes through the code says, okay, anytime I see not in storage, that's going to be one, two, three, devastated. And additionally, these functions down here, if we have this function, do stuff like un 256 nouvar, un 257 othervar, these two variables, new VAR and other VAR, they also don't go in storage. Right? When we call these functions, these are going to be memory variables. These two functions only exist for the duration of do stuff. When we call this do stuff function, we get a new VAR in memory, another VAR in memory. And then when this function completes, once it hits that n bracket, it goes, okay, everything we just created in here, axe it, delete, it, is gone. So in these functions, this is memory stuff.
00:20:30.622 - 00:20:56.614, Speaker A: Now, memory variables are much cheaper to read and write from. They are much cheaper to read and write from. And we'll talk about exactly why here. So, instead of me kind of rehashing what Alex has already said, I wanted to show you this video. Alex Rohn's hitchhiker's guide. Hitchhiker's guide to the EVM. So we're going to watch this real quick.
00:20:56.614 - 00:23:27.784, Speaker A: Let me remove the brand, and then we'll keep going. He just does such an amazing job giving tips and everything that. Figured it would just be better to watch him. Let me share screen here. Kind of confusing here. Let me do. Oh, well, Alex will be in the box here, so thank you.
00:23:27.784 - 00:24:05.264, Speaker A: Alex test. Yeah, Alex will be in the box here, but he won't be talking, so I will be talking. So now the question then becomes, is, okay, so, Patrick, it sounds like storage is crazy expensive. Why is it so expensive in the blockchain? Well, if we look at the centralized world, in the centralized world, storage is pretty easy, right? If I storing some data on my centralized server, I have a single disk, low overall cost. It's going to be easily scaled. I'm storing it to my centralized storage. So it's really cheap for me to store stuff just on one machine.
00:24:05.264 - 00:24:46.992, Speaker A: Now, in the decentralized world, guess what? You have a ton of nodes that you need to store the data on. You're tens of thousands of disks. You have so many more machines that you need to save your data on. So it's way more expensive to store data because you're literally doing it on thousands of machines. Now, the two EVM opcodes that are in charge of reading and writing to this storage location is going to be s store and s load. S store being the storage opcode where it stores that data. Anytime you store data in one of those storage variables, it does s store and then s load is going to be reading from one of those data locations.
00:24:46.992 - 00:25:21.468, Speaker A: So that's going to be the s load operation. And it's the two of these combined that makes, for lack of a better term, incredibly expensive. Incredibly expensive opcodes here. Now, what can we do about it? I'm just going to pause and talk on my own speed. So there's six things that we can kind of keep in mind when it comes to these comes to storage. To make our code more gas friendly, we want to not store in storage if we don't have to use constants when we can. We want to make it painfully obvious.
00:25:21.468 - 00:25:50.920, Speaker A: We don't want to read and write too often. And then also we want to pack our structs. So the first one, don't store if you have to. If you never use a storage variable again, don't store it. Right. Use events instead. There's a reason that these events are an incredibly powerful tool that we can use to index things off chain, right? So if we never use a variable, if we never store a variable.
00:25:50.920 - 00:26:25.544, Speaker A: Don't. Just don't, right? Yeah. If you don't need to store something, don't store it. Right. Use events, emitted events instead. If you want to keep track of all the transfers. For example, in ERC 20, that might be cool, that might be good for having somebody query your stuff.
00:26:25.544 - 00:27:05.836, Speaker A: But having this mapping of all the transfers an ERC 20 token has ever done is going to be incredibly gas and efficient, right? Because every single time somebody does a transfer, they got to pay this extra gas, this insane amount of gas to store that transfer data in this transfer mapping. So we don't want to do that if we don't have to. So what we can do instead is we can use a transfer. We can emit one of these events that I talked about instead. Now, events are going to be. Where did I put. The events are going to be in this logs data location.
00:27:05.836 - 00:27:58.264, Speaker A: So anytime you emit an event, it gets stored in this logs data structure. And storing data to logs is much cheaper because it doesn't allow for contracts to read and write, excuse me, read from that logs place. You stick in the logs data structure and boom, that's it. So if we do want to get this historical data, sorry, too fast. So if we do want to get historical data, and we do want to keep track of all the transfers and stuff that's happened, and I know it's kind of fuzzy right now, sorry, we want to emit these transfer events and then just say, hey, if you want to get all this historical information, you can index all these transfer events yourself. So that's one incredibly powerful gas optimization. Now, the impact on gas here on just switching from saving in storage to emitting as a log is going to be nearly 50%.
00:27:58.264 - 00:28:54.964, Speaker A: So that transfer function goes from 61,000 gas to 36,000 gas, literally cutting almost in half how expensive it is for your ERC 20 token to do a transfer, which is incredibly powerful. Next one, use constants when you can, keywords constants and immutable. Like I was saying before, those get stored in the code as opposed to being stored in storage. So you need to constantly be asking yourself, hey, can this be an immutable constant? For example, if you're using with the link token, that link token address is never going to change. So great. Make that an immutable or a constant. So, an immutable variable is a variable that can be set in the constructor, and then a constant is one that has to be set outside the constructor in that kind of global scope.
00:28:54.964 - 00:29:52.996, Speaker A: So if you can make your code immutable, or if you can make your variables immutable or constant, you're going to save yourself a ton of gas as well. Constant will save yourself even more gas. It would look something like this address public constant link, but you just can't save it in the constructor. The impact on gas here is going to be an absolute insane amount, right? So saving that address of the link token from being a regular variable to a constant, you're saving nearly 82% gas by changing the data location. So you're absolutely saving an absolute ton of gas here. One of the other important things, and this is something that we do at Chainlink Labs, is we use a special naming convention. We use an s underscore prefix, and you've probably seen this before for storage variables.
00:29:52.996 - 00:30:28.324, Speaker A: This way, as developers, we can easily say, oh, this is a storage variable. This is probably going to be really expensive for me to use. So instead of going important thing, my reference and index, we do a little s underscore so that when we're coding, we go oh, right. This is a storage variable. We should probably not read and write to it all the time. Speaking of read and writing too often, you don't want to read and write too often, right? Reading and writing more than twice loops many conditional statements. So right here, we're reading from storage by saying require s and index does not equal.
00:30:28.324 - 00:30:43.776, Speaker A: We're reading from storage again, require s and index. We're saying if s and index is less than index. We're reading from storage again by saying if s and index. Right here, s and index plus equals index. Else if s underscore and index is great. We're reading from storage again here. We're reading from storage again here.
00:30:43.776 - 00:31:13.848, Speaker A: We're reading from storage again here. Anytime you see this s underscore. And this is why having this convention is really good. And every single one of these lines, you should go, oh my goodness, we just read from storage 123-4567 times seven times. So what can we do instead? What do we want to do instead of doing that? Yeah, seven times. Crazy. That's many times that.
00:31:13.848 - 00:31:48.208, Speaker A: We're reading from storage. So what we can do instead is we read from storage one time right at the top like that. We read from storage once, we read it into memory, and then we read from memory, our memory variable instead. Memory variable reads are much cheaper. So we say, okay, great, we'll read into memory, and now we'll read into memory for the rest of this. And then we set it once down here. So we go from seven to two, and we end up saving a ton of gas.
00:31:48.208 - 00:32:26.800, Speaker A: Doing something like that is going to save not a whole lot of gas, but it will save gas. Right? So about 2% gas here. But you can imagine if you have a massive for loop where you're looping around 100 variables. If you've read it into memory, you're going to be a lot more gas efficient. And the answer is 42. It's a joke because of the hitchhiker's guide, which is kind of funny, but it's actually going to be 32. For EVM, the answer to everything is going to be 32, and that's Alex's joke, which I thought was very funny.
00:32:26.800 - 00:33:19.090, Speaker A: He talks a little bit about structs here and packing them. So I'm not going to go into packing the structs here because I got to talk about structs and stuff, and we're already half an hour in. But if you want to learn more about packing your structs, definitely go watch the rest of this video. Listen to Alex's wizardry because he gives some more tips about working with structs here. But in any case, recap, don't store when you don't have to use constants. If you can make it obvious with that s underscore, don't read and write too often and then pack your structs. And then come back to this video so that you can learn about packing your structs.
00:33:19.090 - 00:33:40.662, Speaker A: With that being said, what are the questions so far? Let me scroll up. I think there are a couple of questions here. Okay, quick question. And let me switch back over. Hello. Quick question. In this code, event address, index, underscore name, what does the index keyword do? I get confused.
00:33:40.662 - 00:34:09.842, Speaker A: Okay. Yeah. So in an event, when you index a keyword, you add it as a topic. So it is a little bit more gas expensive, but it is easier for indexers to read out of the events log. That's basically it. That's what the index keyword does. So if we look at a transaction, you probably find a transaction pretty quick, right? Hopefully they emit an event here.
00:34:09.842 - 00:34:41.422, Speaker A: No, this one didn't. Let's just pick random transactions. Hopefully they emitted events. No, a lot of these did not emit events state because all these are just sends instead. What if we do uniswap? Uniswap. Here we go. Here we go.
00:34:41.422 - 00:34:56.798, Speaker A: Transaction logs. Okay, so this is an example of an event that's emitted. So they emitted this approval. Oh, I'm not sharing my screen. Let me switch over. Sorry. This is an example of approval event that was emitted.
00:34:56.798 - 00:35:28.374, Speaker A: Now you see index topic one, index topic two, and then address and spender. So index topic one and two. So when you index an event, you add it to this topic part of your events or your logs data structure. So they're a lot easier to read because we're saying at index zero, we have address owner. At index one we have address spender index two. At index zero, we have the hash of the entire event. At index one we have owner.
00:35:28.374 - 00:35:59.938, Speaker A: At index two we have spender index topic two. And then at the end we have this Un 256 value. So anything outside of the index topics gets just kind of added to this data structure. And they all get kind of almost jarbled together, if you will. Let me see if there's an example where, so here's kind of an example of an event. Maybe this is a couple of data structures combined together. But yeah, basically it just makes it easier to read your events.
00:35:59.938 - 00:36:38.318, Speaker A: Hopefully that made sense. So functions default to memory. I thought you needed to specify memory in the function declaration, or do we need to just specify storage when needed? Really good question. So that's kind of for special types like bytes and bytes and strings. So when we use bytes and strings, we do need to say, hey, this byte is in memory, or this bytes arrays in memory, or the string arrays in memory. But if we declare like a variable outside of a function, it defaults to storage. So the variables inside of a function default to memory.
00:36:38.318 - 00:37:26.260, Speaker A: Yes, except for strings and bytes, which we always need to declare. We always need it to be explicit there because like I was showing you before, arrays and mappings have kind of this really weird way that they store data. So we just need to tell solidity, hey, this is going to be in memory, or this is going to be in storage, because it needs to know what to do with this weird mapping thing. Okay, am I going to do this in storage or am I going to do this in memory? And it just wants you to be explicit, which I really like. It just forces you to be explicit with expensive stuff like strings and bytes. Good question. What else? Other questions are in here.
00:37:26.260 - 00:37:59.098, Speaker A: Is it okay to think of this type of memory as Ram versus ROM? What is ROM? What is ROM? Computer read only memory. Oh, okay, cool. I'm not sure what you're referring to when you said rOm. Immutables. Well, they're not memory, they're read only storage. If you're talking about like immutables and constants. Yes, immutables and constants are read only.
00:37:59.098 - 00:38:32.822, Speaker A: So if that's the analogy you want to do, great. But I think Ram and ROM isn't great because those are memory and we're talking about storage. Hitchhiker's guide to the EVM is a reference to a famous encyclopedia about travel, randomness and towels in the galaxy. Yes, thank you. What about s store two? What about s store two? I don't think that's an opcode. I think that there's. Yeah, I remember reading something about sstore too.
00:38:32.822 - 00:39:39.874, Speaker A: I think it's like it's a library somebody uses. I forget. But if there are such ways to optimize gas, why wouldn't this be done at a compiler level? Kind of a funny story here. Well, so it depends, right? We want to be able to be very precise with how we code stuff, right? If we start optimizing, if the compiler is too abstracting, then it can be harder to do exactly what we want it to do. Like, let's say it just always picked memory or storage for us, then maybe that would kind of stink. The other kind of humorous thing is that a lot of people who are gas golfers complain about the solidity compiler all the time. I don't, because like a lot of the stuff that it does that may be more gas ineffective, save and give safeguards otherwise.
00:39:39.874 - 00:40:33.630, Speaker A: So like a big one for a while was solidity consistently was what's called unchecked with its overflows. So you could have like a un eight that was number 255, and that's the maximum size you can have for un eight. And if you added one to it, it would reset to zero, which is very bad for math, but it's very good for gas. They changed that recently to have this thing called safe math built in where it will prevent those overflows and underflows. And that's good for kind of a developer experience. It's not so good for gas. So there kind of comes this like, okay, what are you optimizing the compiler for? So there's a lot of kind of design choices that need to be done, but there's always going to be ways to optimize gas.
00:40:33.630 - 00:41:08.246, Speaker A: And understanding what's happening on the back end is important, so you can do that. Are logs still secure? Were they ever not from danger? I think they're good. S underscores the important cost of storages. Yes. Is there a cheat sheet for gas optimization? That kind of overview that Alex gave was very good. Don't read and write to storage if you don't have to. That's going to be a big one.
00:41:08.246 - 00:41:55.160, Speaker A: But there's always going to be different gas optimizations that you can do. I don't know of like a specific cheat sheet, but I would love to see one. Actually, that would be really cool to see gas optimization cheat sheet. So when we declare a global variable and then call it in a function, it gets saved to storage. Does it get overwritten, or saves another value in different place? Does it get overwritten, or saves another value in different place? They call it in a function, get saved to storage. Does it get overwritten, or saves another value in a different place? I'm not totally sure I follow the question. So when we declare a global variable and then call it in a function, it gets saved to storage, does it get overridden or saves another value in a different place? Sorry, I'm not following your question.
00:41:55.160 - 00:42:12.010, Speaker A: It. All right, cool. No more questions here. Awesome. Back to. But yeah, feel free to ask more questions as we continue. Cool.
00:42:12.010 - 00:42:38.232, Speaker A: One more question. These evm optimizations valid for all EVM compatible or just ethers? It's all of them all EVM compatible? I think he's asking the variables saved in the same location. Yes. In your function. Yeah. Okay, I see what you're saying. So if you're accessing a storage variable in a function and you save it or you update it, you're saving it to storage.
00:42:38.232 - 00:42:59.444, Speaker A: Great question. Okay, I think that, yeah, that makes sense. So those are some of the things to think about when it comes to gas codes. And actually, if we look at EVM, cos we see all these gas costs like three. Three, three, cool. Let's look down here. So logs are going to cost a lot more gas, right.
00:42:59.444 - 00:43:31.904, Speaker A: We can see how expensive logs can get, but it doesn't even compare to the create opcode, which is for creating a contract. We see the call opcode, the call code for calling different calling functions or sending messages. Delegate call is expensive. Create two for creating contracts as well. Revert, self destruct, and then s store. If we look for s store, s store and s load have a minimum of 100 gas as well. Right.
00:43:31.904 - 00:44:10.376, Speaker A: So these are going to be very expensive here, way more expensive than all these stuff, and way cheaper than like an m load, a load word for memory, or an m store save word to memory. Right. So three gas versus 100 gas for saving the memory, and then three gas versus 100 gas for loading to memory. Way cheaper working with memory than working with storage. Now let's talk about transactions. So here's kind of a transaction. Here are the different fields of a transaction.
00:44:10.376 - 00:44:41.044, Speaker A: We have the nuns with the TX count for the account. We have gas price, gas limit, two value data, and then VR and S. And these are the components of your transaction signature. This is kind of the cryptography magic that happens behind the scene to make sure your transaction is your transaction function. Save number, external save number equals number. Yes. So if saved number is a global variable, you're calling, doing this right here.
00:44:41.044 - 00:45:17.056, Speaker A: If saved number is a global variable and you're saying save number equals number, you're calling s store. So you're saving save number to storage. Good question. Gas is way, I'm a little bit late. Gas is whatever unit you want it to be in. And when we transfer ETH, it often comes with a 21,000 gas limit because that's how much it costs to send ETH. And then we update two with the address the transaction is sent to.
00:45:17.056 - 00:45:49.964, Speaker A: The data is going to be empty. When we do a function call, the address to the transaction is sent is going to be updated. The gas limit is going to be whatever you want the data is going to be all that data for that function call. And then for contract deployments, the two is going to be empty. And then in the data piece is going to be the contract initialization code and the contract bytecode. So even when we're deploying contracts, it's this data field that we want to keep in mind, making this as small as possible to make our code more gas efficient. Does it get overridden, though? Yes.
00:45:49.964 - 00:46:12.252, Speaker A: You're writing that one memory? Yes. Well, not to the one memory slot, to the writing. To the storage slot? Yes. So if you write to storage in a function, it will get overwritten. Yes. Let's talk about contract deployments. And here's a quick snapshot from somebody else's presentation.
00:46:12.252 - 00:46:53.248, Speaker A: Just because I didn't want to have to go through and figure out which one was the initialization code fragment and code to be deployed to blockchain. Whenever you deploy a contract, it comes with almost like two sets in the binary code, right. The first huge chunk is going to be what's called the initialization code fragment. This tells the blockchain how to set up your contract, how to set up your code, and then you have the bytecode that actually represents your contract. So this stuff up here is all the opcodes that are saying, hey, we're building a contract, let's get set up to do that. And then this is the code that gets saved onto the blockchain. So let's look at a contract like this.
00:46:53.248 - 00:47:22.280, Speaker A: Real minimalistic contract. Contract. My contract. It's got a public favorite number. It's got a set favorite number. And yes, for Matt, who's been asking, favorite number gets overwritten when we do this, right? Because when we refer to favorite number, we're saying, hey, give me that storage variable and let's overwrite it with this new number thing. And when we compile this contract, this is exactly what it looks like in bytecode, which is obviously completely unreadable.
00:47:22.280 - 00:47:48.192, Speaker A: Here's what it looks like with opcodes, which is also nearly completely unreadable, but it's slightly more readable. Right? Because now we're saying, okay, push ox 80, right? And in here we know that 60 is push and we're pushing 80. Okay, what happens after that? Push ox 40. Cool. So we pushed 80. Okay, we're going to push 60 is push. We're going to push 40.
00:47:48.192 - 00:48:18.268, Speaker A: Okay, what's next? 52. What's 52? Okay, m store. We're going to m store. We're going to m store some stuff and then blah, blah, blah, now we can see we have this s store opcode in here. If we remove that global variable, right? And we just do un 56 constant, public favorite number equals 77, we can, once again, we can now see that there is no s store opcode in our compiled bytecode, which is cool. That's what we want. We will want to see less.
00:48:18.268 - 00:48:39.540, Speaker A: We don't want to see that as store anymore because we're no longer storing something. And then I'll leave you with this. There's a fantastic blog called deconstructing a solidity contract. Part one, introduction. I think it's six parts by open zeppelin. Deconstructing solidity. Open zeppelin.
00:48:39.540 - 00:49:02.564, Speaker A: Put it in the chat. Here it is. Very good. If you're looking to go even deeper than what we went in here, so be sure to check that out. And with that being said, that's going to be the conclusion of our talk here. Before anybody leaves, please fill out this QR code here. Give us some feedback.
00:49:02.564 - 00:49:25.168, Speaker A: Let us know what you liked, what you didn't like about this course. I'll drop the link in the chat as well. Let me just grab it. Hold on 1 second. But yeah, they help us figure out if the workshops are a good use of time, if people hated them, et cetera. So please grab the QR code, grab the link here. It's going to be in the comments.
00:49:25.168 - 00:50:29.172, Speaker A: Let us know what you thought and then. Yeah, questions in the last ten minutes that we have, could you show us how to measure some opcode? What do you mean measure some opcode? Could you elaborate? Hi Patrick. What about the order or grouping on variable declaration according with their size to optimize storage block slot usage? What about the order or grouping on variable declaration according with their size to optimize storage? What about the order or grouping? I think I see what you're saying. That's a good question. I don't know enough to answer that intelligently. I do know that ordering does matter, but I don't think it matters so much that it would be worth focusing on. I think I know, especially when you order your functions a different way, the ones that you're going to call the most you want at the top of your contract.
00:50:29.172 - 00:51:13.560, Speaker A: I forget, but it's like small amounts of gas. That's a good question. I forget the actual gas optimizations there. That's the meaning of 32 for stacking structs, yes. Are there any hardhead plugins that show you the opcodes being executed? I don't know, actually, but foundry and brownie have opcode step throughs so you can literally step through opcode to opcode your entire solidities. Or viper smart contracts, which is really cool. So if you want to see a step through Debugger for opcodes, foundry, and brownie, and I think apeworks too have step through debuggers.
00:51:13.560 - 00:51:33.628, Speaker A: Hard hat, might as well. I'm not sure, though. Is EVM always last and first out oriented and never first and first out? Yes. EVM is stack based. Yes. I was wondering what specifically Chainlink has been liking for in a project these days. Good question.
00:51:33.628 - 00:52:06.120, Speaker A: Cool stuff. Cool stuff that helps the world and does gaming, dows, you know, you name it. I'm assuming you're talking about Chainlink Labs. The Chainlink oracle network likes just smart contracts in general. Good questions here. Any other questions? Any other questions? Yeah, the takeaway from this should be the minimum takeaway is that reading and writing to storage is expensive. So if you don't have to do it, don't.
00:52:06.120 - 00:52:52.516, Speaker A: That's the takeaway it. Any other questions? Here's. All right, cool. Well, if there are no more questions, am I looking at it? Please take the feedback form. Let us know if you like this, if you didn't like this, if you want to see more gas optimization stuff, if you want to see less gas optimization stuff, and good luck with the rest of the hackathon. Tomorrow we have some great workshops for you, so hopefully you show up to tomorrow's workshops as well. We got a bunch of cool ones the rest of the week.
00:52:52.516 - 00:53:15.436, Speaker A: And then after this week, hackchain link, we're nearing the halfway mark of the hackathon. Already has already been going that fast. Oh my goodness. So what is today? Today is the third. Tomorrow we got build a dow with Zubin. It's going to be fantastic. Filecoin, full stack DFI application.
00:53:15.436 - 00:53:35.500, Speaker A: Then we're going into some smart contract security. I know all of you here are going to be excited about this. Then we're going to build a web3 game. We're going to work a little bit with alchemy next week. We're doing a little bit more about security audits. Why? Binance, smart chain, some new founding products. And then we're at the midway check in, and it's off to the races.
00:53:35.500 - 00:53:50.310, Speaker A: It is off to the races. So we're already getting close to the midway check in point, getting close to the middle of the hackathon. I hope you're all doing well. Hope you're all excited, hope you're all building, hope you're all learning, having fun, and with that being said, thank you all for coming here, and we'll see you in the next one.
