00:00:02.010 - 00:00:34.600, Speaker A: And we are now streaming live, preparing to setting up the meeting here, redirecting to YouTube. And we are live. Hey, how's it going? Hey, how's it going, everybody? I know we're doing back to back workshops for this chain link hackathon. There's just so much knowledge for everyone to at and so much learning for everyone to get. So I'm here with B. Or do you go by b actually? Or do you prefer Bartos? Am I even saying that right?
00:00:35.290 - 00:00:37.400, Speaker B: I think B is good. B is good.
00:00:38.490 - 00:00:39.706, Speaker A: What was that?
00:00:39.888 - 00:00:41.420, Speaker B: Everyone can say it.
00:00:41.950 - 00:01:08.642, Speaker A: Okay, I'm here with B from Solana. For those of you who are unaware, Solana is. They're one of the sponsors for the hackathon. They're an incredibly fast layer, one solution. So their blockchain is actually written rust. You can write smart contracts in Rust, which is really powerful. And B is here to walk us through Solana, what we can do with it, how we can work with it, and with that, I will turn it over to you.
00:01:08.642 - 00:01:10.098, Speaker A: Thank you so much for being here.
00:01:10.264 - 00:01:54.960, Speaker B: Yeah, totally. Thanks for having me. And I'm super excited for chainlink and Solana integration that we have been working for quite some time. But before we cover that, I thought I will give basically an overview from the developer perspective, how you start building on Solana, like what Solana is, and how you approach things that are slightly different from, for example, Ethereum. So the first thing that I wanted to cover is programming model is a bit different. So yes, you are using rust instead of solidity, but also you need to think slightly differently about how you structure your smart contracts. So everything on Solana is something that we are calling an account.
00:01:54.960 - 00:02:26.054, Speaker B: And I like to compare it to files in operating system like Linux. So everything is a file and it happens. Some of the files are executables and some of the files store memory and you can search for them in our explorer. So let's say I want to look up amm. I can type swap. This is what we are calling our amm program that we deployed. And you can see here that it actually has a bunch of transactions that were executed against this file.
00:02:26.054 - 00:03:17.420, Speaker B: And just happens that this specific account is executable. When you go to specific transaction, you can see list of accounts that participated in that transaction, how their balance changed, and below that you can see specific instructions. I guess the programming model would be first think about what's in my transaction. Then the transaction has set of instructions inside of it, and each instruction has set of accounts that they operate on that store. Their memory. And that's the main difference from when you are programming in solidity, where in solidity in smart contract you can have this global state that your smart contract is operating in Salana, you need to explicitly pass your state to the instructions that are being executed. Like for example an account that holds your tokens, we are calling them SPL tokens equivalent of ERC 20.
00:03:17.420 - 00:04:07.370, Speaker B: You need to pass all of them explicitly. But that allows us from the programming model, parallelize operations in those smart contracts. The other difference is we are favoring quite a bit reusability of contracts. So for example, you will have only one smart contract that's handling the tokens versus deploying your ERC 20 on Ethereum. And that allows us to increase, I guess, transparency and audit, because you don't need to run audits on your own ERC 20 implementations. It's all handled by central one that we kind of know we can trust. If you wanted to, you could deploy your own, but wallets and everything kind of know how to interact with the one that we deployed.
00:04:07.370 - 00:04:44.546, Speaker B: And they also render slightly differently in here. So you can see like this account, maybe this one is not a great one, but when you go to the specific account, you can see the balance, maybe let's say USDC. So we have a native USDC that's handled by circle. And when you go to one of the transactions that USDC participated, you can actually see like the transfers for example here. And if you click, you can see this USDC. And this is the balance in this account. And that programming model requires you to start thinking a bit harder, at least at the beginning.
00:04:44.546 - 00:05:25.202, Speaker B: When you build your smart contracts, how your memory will be structured, what global variables, effectively, you will need to pass to different operations in your smart contract. So if we go with the example of Amm, you probably would have couple of accounts that you need to pass around. Like one would be both of the accounts for the purse you want AmM to operate against, like the custody or treasury accounts. And then one account that stores the configuration of the pool. And then those are all passed to the smart contract. When you are executing it. There is a bunch of programs that we also have that you can start modifying or building on top of.
00:05:25.202 - 00:06:23.640, Speaker B: They are all described in spl Solana.com. So there is the token program that I described that allows you to basically spin up really quickly your own tokens. And because you don't need to deploy your own smart contracts, it's also much cheaper because you just need to specify that you want an account that represents a mint and then the individual accounts that users store. The other thing that's, I guess worth about mentioning about accounts is the fact that each account has the concept of rent and you need to store specific amount of Sol native token to Solana to make sure that those accounts are not being garbage collected by the blockchain. And you can see that in explorer where you go to the account. It basically shows how much salt that account has. It's maybe visible better, like here, that account costs that much to store on the.
00:06:23.640 - 00:07:45.262, Speaker B: So I covered kind of the token swap program amm, but if you want to, you can kind of read how you interact with this in here. And this is fairly interesting because the way we build it, we allowed to customize the curves from the start so you could reuse the same smart contract code, but deploy your own curves if you don't like constant product or the ones that we deployed like stable curve or the offset that allows you to effectively launch an equivalent of ieos on AMM. The lending program is also interesting, and the reason I'm covering these programs during this session is I think those are great starting points if you are thinking of working on Solana Price that we have for this hackathon. And there is also the Chainlink integration itself. That would be interesting from the price perspective. But one idea for the program could be, hey, take the Amm and somehow integrated it with the chaining oracles that we have running on Solana, maybe to provide a different curve implementation that executes something differently. The other one maybe would be related to the lending platform where you could provide a stable interest rate loans.
00:07:45.262 - 00:08:28.094, Speaker B: Right now it only supports variable interest rate loans and it's not integrated with chandling Oracle. I don't think I need to cover those accounts. So from the other place where you want to start is probably the Solana program library. So this is where all the code for those programs start. Everything in Solana is open source and you can customize it however you want to. It's Apache license. So from the high level, when you go to Solana program library and I can post later links to the discord for this hackathon or the token swap, that's the lending program.
00:08:28.094 - 00:09:16.190, Speaker B: When you are looking at it, Solana programs, because they are in rust, they kind of follow a convention that we have. So there is usually a state file that describes the accounts that you will be storing on the blockchain. So you can think of it, those are like fields in your smart contract, normally on Ethereum. In here they are basically distributed instructs that you store on blockchain. Then there are instructions. Those are effectively the methods that you will be executing against smart contract. So when you're looking at the existing code, I like to start with instructions, then look at the actual accounts, how the state looks like, and then the last place that I usually look at is the processor that actually executes the specific instructions.
00:09:16.190 - 00:10:25.166, Speaker B: So if I search here for process deposit, this is how the deposits are handled in AMM market. When you are depositing both sides of the tokens, the interactions with the token program, for example, are fairly straightforward. So this is how you would execute an equivalent of like safe transfer or a mint. The other thing that's also probably straightforward from those smart contracts is dynamically deploying your own tokens where you just pass an account that represents a token and you can immediately start minting. So that's something that's I guess an equivalent of 1155 ERC where you want to dynamically manage list of tokens that are listed through this exchange. And again, if you go through a bunch of those programs, they are fairly similarly structured. So for the amm, let's say you wanted to implement a curve that integrates with the Chainlink oracle.
00:10:25.166 - 00:11:51.066, Speaker B: I would imagine you would grab one of those files, let's say constant product curve, and implement the specific swap methods that checks how you want to move the price based on the Chainlink oracle. So I guess this is also a good point to show how the oracle itself is structured, at least right now on Solana. So when you are looking at the aggregator, you will have predefined answer that specifies the median of whatever you are publishing. And this is another set of interesting projects that I guess you could start thinking how they could be published. So it would be super interesting from my perspective to figure out in this rust code if you are thinking of submitting pr for the price, how we would publish set of historical prices, maybe something more than prices like historical volume, and also adding more price speeds. I think right now we are supporting Coinbase FTX, and I think one more, the other one that would be interesting from my perspective of extending the specific program for publishing prices is being a bit more dynamic of what's published right now. It's a JSON config that specifies how the node operators of this publisher are publishing them and who can write to the Oracle.
00:11:51.066 - 00:12:45.834, Speaker B: It would be interesting if almost anyone can spin up the new price feed and then somehow incentivize people to pay for them. And you can see the Chainlink Oracle itself follows exactly the same model where you have a state that describes all the different accounts that are here and then the processor. So if you're thinking of modifying that code, it's probably straightforward. So that's on the smart contract side. If you wanted to do something outside of rust, let's say for this you don't want to run rust. It would be interesting to see, for example, a comparison of prices that the chain link oracle is publishing on Solana with maybe centralized sources. So maybe like a dashboard of prices in JavaScript.
00:12:45.834 - 00:13:50.400, Speaker B: And for that you could use our scaffold application that interacts with the chaining and kind of integrated, and maybe I can cover quickly the scaffold. So there is a repository under Solana labs that's called DAP scaffold. So this is a react repository. So if you know react, it should be fairly straightforward to get inside of this. It's using context for integrating with the accounts. So maybe an interesting way of doing this would be adding specific context that allows you to listen to all the Chainlink oracles and then pulling additional information, let's say from like Coingecko or Coinmarketcap or other centralized exchanges directly, and thinking of how they are diverging from each other. So that would be something probably interesting.
00:13:50.400 - 00:14:02.870, Speaker B: So, Patrick, I don't know if we have the ability to kind of answer questions, but maybe this is a good time to start answering a bunch of questions or maybe talking about your experience with Solana.
00:14:03.450 - 00:14:25.580, Speaker A: Yeah, let's pull up some of the questions. What do you think about integrating? I don't know about that. Oh, whoops. I should have, should have responded here. So the screen is a little bit small. If you could hit there.
00:14:26.430 - 00:14:30.346, Speaker B: Sure. Now a bit is too late, but, yeah.
00:14:30.368 - 00:14:31.020, Speaker A: All right.
00:14:33.310 - 00:14:44.180, Speaker B: So Solana program library, I guess this is where I. One, let's see.
00:14:46.950 - 00:14:49.522, Speaker A: Or if you control.
00:14:49.656 - 00:14:50.580, Speaker B: That's better.
00:14:51.290 - 00:14:52.840, Speaker A: Yeah, that's better, actually.
00:14:54.970 - 00:15:11.014, Speaker B: And this one, let's see. Maybe like that. Too big. So I guess let's cover that from the top. So, state file normally covers the state. And you have a bunch of instructions.
00:15:11.062 - 00:15:12.570, Speaker A: Here that's way nicer.
00:15:15.070 - 00:15:51.954, Speaker B: Right. So when you're looking at these tracks, this is how the content actually stored on Solana. And you can define pretty much anything in here that you want to store. There is a size restriction on those accounts, which is around like ten megabytes. And once you start hitting that, you need to start thinking how you break down the accounts into multiple of them that you are pulling. But so far we haven't seen anyone necessarily hitting the limit on the individual account. And the way I like to think about it is so each account effectively is a public key on the blockchain.
00:15:51.954 - 00:16:52.650, Speaker B: So then you can treat effectively blockchain as like massive hash map where you can just store multiple things that are related to each other. And Solana is allowing you to retrieve the accounts also by convention by using this find program address. And what it's allowing you to do is to define set of seats that effectively allow you to create predictable public key for that account. And the other thing that it's allowing you to do is this is how the smart contracts are signing, logically, the accounts that they own. So smart contract itself doesn't have a private key on Solana. It logically, through the runtime, sets the flag, hey, this transaction is signed because it was created in this specific way with the find program address. And the way it works is we try to find the address that's off the ed to 5519 curve.
00:16:52.650 - 00:17:15.780, Speaker B: You should be able to, this is how you do it. Where you have public key find program address. You specify set of seats that you pass in here and the program id, and then this specific account will be only able, like, if it requires signature, only that program will be able to sign it. What are the other questions, Patrick, that we have?
00:17:19.510 - 00:17:24.840, Speaker A: Yeah, that was the main one. Let's see if there's any other questions now that we kind of went through it again.
00:17:25.530 - 00:17:35.126, Speaker B: And also from your experience. So I know, Patrick, you interacted with Solana quite a bit. You tried to build rust yourself. So what was your perspective on?
00:17:35.308 - 00:18:30.154, Speaker A: Yeah, so Rust was a language that I was like, all right, I'm going to learn this in like 6 hours. So it's not my strong suit, but what I really liked about just kind of rust in general is it's like a pythonic, low level language, which I think is awesome. So from that perspective, I thought that was really cool, being able to just rip up smart contracts in Rust. The other thing that I thought was really cool was how, yeah, it's a super fast blockchain, and especially with the chainlink integration, being able to do those price feed updates super quickly, but also really cheaply is definitely a powerful thing. So I'm really looking forward to that as well. And I know the integration is still kind of being fleshed out a little bit. And for everybody who's watching, if you guys want to do some with Solana, this is kind of what I was recommending before.
00:18:30.154 - 00:19:29.946, Speaker A: If you want to do a mock chain link call, I think that that's great to get data into your smart contracts using a mock price feeds or something, have it just like dummy to be like a value or something. But yeah, no, I wish I was better at Rust to be like, yeah, here's what I thought, but I'm still kind of getting my bearings. But from what I played with, I thought it was really nice. I think the Javascript part was really helpful too, being able to do. I know you guys have the Javascript framework as well. I think that's going to be really helpful for a lot of the engineers who are more familiar on the Javascript. Uh, although I will say people who do want to build with Solana getting into some rust is definitely going to be helpful because that's how you can really dive in and build these really powerful smart contracts.
00:19:29.946 - 00:19:32.880, Speaker A: But yeah, I think the Javascript plugin is really nice too.
00:19:33.250 - 00:20:17.678, Speaker B: Yeah, so there's actually a lot of things that you can do just from JavaScript, which I kind of like about the programming model that we have. Like for example, creating your own ERC 20 doesn't require any rasp development. The same way if you want to create an NFT, it's actually the same smart contract program that we have on Solana. You can just do it from Javascript and it's like fully decentralized. So obviously user owns their own keys, it doesn't go to any server, you just say create a new account and execute this specific instruction. So in this case I'm showing how you approve transfer of funds for a user and then you can revoke them as well. But you could literally do it with anything.
00:20:17.678 - 00:21:05.830, Speaker B: You could start a new central limit order books market. And that's another thing that Solana has that I think it's big differentiator where serum guys deployed central limit order book that's super fast that you can start integrating. So let's say you're thinking of maybe building something on top of NFTs that integrates with serum and with Chainlink for whatever reason. Maybe, I don't know, some crazy idea of physical art and making bids on serum, and you are pricing art using Chainlink. You could easily connect all those pieces actually, or most of them just from JavaScript. And the amount of rust code that you need to deploy on Chainlink and actually have audited is minimal. And that's because there's a lot of composability with those smart contracts.
00:21:05.830 - 00:22:29.106, Speaker B: You don't need to deploy your own central limit order book or your own imm, you can just integrate with them by calling into them. And they all have models where both central limit order book and amm where they favor people that forward flow to them. So for example, if you hold serum and forward flow to central limit order book, you can get like kickbacks from the decks. And that also favors people that are building uis where you can literally take the UI that serum built either for AMM or central limit order book and receive portions of the fees for effectively user acquisition or building UI and forwarding that fees to the smart contract. So I think the serum guys fought really hard about how do we incentivize different participants in this ecosystem. Like how do we incentivize liquidity providers, people that build the underlying protocol and people that also deploy the UI and think how they acquire users and build beautiful user experience. Patrick mentioned that Solana is super fast, but to quantify it right now it's going up to 50,000 transactions per second with 400 millisecond block time and fraction of a cent per transaction.
00:22:29.106 - 00:23:14.310, Speaker B: So if you are running, for example, this crank that effectively sends updates to chaining oracle that will be very cheap, much cheaper than other blockchains. And you can actually start thinking, hey, can we have subsecond updates on an oracle which solves a bunch of problems in terms of how you smooth the prices, how you aggregate them, because now you're working about much smaller window and your smart contracts can interact with that. So I'm definitely excited about that integration, especially once we start going into something more than prices, like historical data and volume data, which makes building, for example like perpetuals much easier.
00:23:15.930 - 00:23:37.530, Speaker A: Yeah, 100% agreed. I think even more like nuanced data too, like weather data. You can get the price of specific cities really quickly, or even doing silly things becomes really easy and really fun because it costs barely anything to make those updates. So yeah, 100% excited for when this is going to be finished.
00:23:38.690 - 00:23:41.630, Speaker B: Yeah, weather would be fun if you were doing like commodity.
00:23:42.690 - 00:23:47.840, Speaker A: Yeah, yeah. For in and see if there's any other questions in here.
00:23:50.390 - 00:23:59.410, Speaker B: What are the other projects that excite you, Patrick, that you would see being more viable on Solana than other blockchains? Just because of speed?
00:24:00.250 - 00:24:36.334, Speaker A: Just because of speed? That's actually hard to say. Yeah, that's hard to say because some of them, they're so intertwined with the ecosystem that they live on. And a lot of the products that have currently been built, they've been built kind of with the current model in mind. Right? You don't need crazy speed to borrow and lend, right? You don't need crazy speed to do some things. It's obviously nice. It's obviously nice to do that. But, yeah, I'm not sure.
00:24:36.334 - 00:25:06.390, Speaker A: I'm just excited to see what people kind of do and see their creativity unfold and see what new stuff and yeah, maybe some of the old stuff comes over mean. The answer is, I'm excited to see everything on everything. I'm super excited to see what people are like, okay, rust is super low level. Solana is super fast. Here's what I can do. Now that we have a really fast changes. Anything real time, I think, is going to be sick.
00:25:06.390 - 00:25:38.514, Speaker A: Like, you want a real time price feed. You want a real time, real time whatever. I think to me, though, anything with real time stuff, I'm really excited for. If you need something done fast, I'm like, maybe some type of game, actually. Gaming, actually, now that I even say that, because Solana is one of the few chains that can go fast enough to keep up with gaming. And so maybe modern gaming decides that Solana is where they want to go. I think that would be mean.
00:25:38.514 - 00:25:52.840, Speaker A: Obviously, financial instruments on Solana are going to be really cool and really powerful. Yeah, I mean, the sky's the limit when you say, what are you excited? Like, everything, man. Like, how do I answer that question?
00:25:53.930 - 00:26:22.926, Speaker B: Yeah, no, that's fair. Yeah, gaming is super exciting. There's a couple of teams that are building games on top of Solana, there's this team, Star Atlas. I think the team looks super strong and the people behind it. I'm super excited about that game. But even in the hackathon that Solana itself was running recently, there was a bunch of games that got me super effectively. One that was super interesting from my perspective, was this no loss integration between multiple chains.
00:26:22.926 - 00:26:43.334, Speaker B: When they were moving assets between Solana and Ethereum, we have the wormhole bridge that you can take advantage of. So when you start thinking, combine high speed oracles from Chainlink and then somehow bridging assets to different chains, I think for arbitrush opportunities. I think it's becoming very interesting.
00:26:43.532 - 00:26:56.090, Speaker A: Yeah, for sure. Yeah, absolutely. So there are a couple of questions here. I'm not sure I understand this first question. What do you think of the clarity smart contracting language? Is that a Solana thing? I've actually never heard of clarity.
00:26:56.750 - 00:26:58.010, Speaker B: Yeah, me neither.
00:26:58.510 - 00:27:15.506, Speaker A: Okay, sorry. We're not sure what clarity is. Okay, cool. What would it look like to actually call the Chainlink Oracle from Solana? Can you step through an example of how to do. Probably. We probably can't do this. Because it's still a little bit, I.
00:27:15.528 - 00:27:30.582, Speaker B: Mean I can show the example code I guess, right. So there is a demo in JavaScript and I can show it in Javascript where you can effectively get the.
00:27:30.716 - 00:27:38.220, Speaker A: Oh yeah, perfect. Right, because price feeds is going to be super simple. That's right, yes.
00:27:38.990 - 00:27:56.222, Speaker B: I just want to find the right example here. Just bear with me for a second. Maybe start with the smart contract. Right. So basically you get this aggregator account and just say get median and that's it. I don't think it can be much simpler than that.
00:27:56.276 - 00:28:05.026, Speaker A: Yeah, I was going to say literally just like solidity and just like every other language, it's like boom, get us the address. Yeah, awesome. That looks perfect.
00:28:05.128 - 00:28:49.522, Speaker B: Yeah. And the other part that I think was extremely smart choice when Solana started using rust. So yes, maybe if you don't know rust it can be daunting, but once you start getting into it, Solana made this choice that we will not build any custom tools for you to build on top of it. Everything is like out of the box tooling that you have with Rust and Javascript. So you just use cargo and just run tests with cargo, build with cargo, there is nothing custom about it. Once you are in rust you use the tools that you know. And I think that's the advantage of using something that's like mainstream language or language that can become more mainstream like rust when you just leverage the tools that are there.
00:28:49.522 - 00:29:00.930, Speaker B: And same with Javascript, you just use like NPM and all the packages just out of the box. There's nothing special about how you code on Solana.
00:29:01.690 - 00:29:07.880, Speaker A: Yeah, awesome. Yeah, I think that this is super cool. And then the Javascript I'm assuming is pretty much the same.
00:29:08.730 - 00:29:13.240, Speaker B: Yeah, I'm trying to find an example here.
00:29:13.610 - 00:29:17.194, Speaker A: I saw an await. All right, await. Initialize it. Looks like that's deploying it.
00:29:17.232 - 00:29:33.070, Speaker B: Yeah. So this is I think starting to initialize the oracle if you want to publish the prices. I don't think the Javascript right now has the example how to read the price, but it would be exactly the same where you just get the account, deserialize it and just call get median.
00:29:33.570 - 00:29:53.640, Speaker A: It's super straightforward and everyone who's watching you can absolutely get cloned. This is open source too, right? Everything we're showing here? Yes, you can absolutely get clone this to use as your idea for the hackathon and build something really cool. So definitely good question here. So another question. Can you explain what proof of history means?
00:29:55.130 - 00:30:41.186, Speaker B: Sure. So basically it's a different way of doing consensus where we are using this verified delay function that when people start voting on specific fork of the chain, each next vote effect, like switching the chain, will cost them more because there's this delay function that's predictable before they enter proof of stake. So it's a combination of proof of work and proof of stake, where on Solana you can actually stake Sol and all the validators are charging like normal commission, but it's a way to synchronize effectively the clock between the validators. So this is super high level description. Awesome.
00:30:41.288 - 00:31:01.740, Speaker A: Very cool. Yeah. Any other questions in the YouTube chat here? We're monitoring, we're ready. But yeah, as we wait for any of the questions to kind of come in. Yeah, b, what are you kind of excited to build on Solana and build with the chainlink integration here? I know a little bit before, and you're like, yeah, everything.
00:31:03.550 - 00:32:22.230, Speaker B: No, I think because of speed, I'm primarily excited about all and everything DeFi just because I think with the speed and scale that Solana can deliver, it has the potential to actually deploy apps that will go to potentially billions of users and they can actually interact with the base chain. I'm super excited about some slip ux, I guess on top of those applications, just because if it's fast, it's much easier to build like a good user experience. And basically trying to combine engineers that are coming also outside of blockchain and trying to like myself and trying to encourage them to build on top of it because now they can actually scale to the user base that they would like to reach. I know it's not very specific in terms of specific things on Defi. I'm super excited about teams that are building, for example, like perpetuals, like margin trading, expanding the lending platform, and all of those could 100% use high speed oracle that's diversified from different sources. So I'm super excited to see what people build as part of chain link hackathon.
00:32:24.650 - 00:32:37.240, Speaker A: Awesome. 100% agreed. Now, here's a little bit of a more challenging question. Would love to see you step through a more complex rust program for salana and explain the different parts of it.
00:32:37.930 - 00:32:48.686, Speaker B: Sure. I don't know if this is complex enough, but let's go through this. Amm, is this complex enough?
00:32:48.788 - 00:32:53.600, Speaker A: I think amms are at least a great starting point. So let's do it.
00:32:54.610 - 00:34:02.222, Speaker B: Okay, so like I was saying, I always like to start with instructions. So start with here and think, okay, what are the accounts on top of instruction? We basically create this enum that identifies those are the different types of functions that you can call, and each of those functions will take a set of accounts. So for example, initializes a new AmM pool and it specifies okay, what is the new pull account, what is the authority that can work on top of that? And that's the create program address that I described before. You will have two custody accounts for each of the token purse and then the mints as well for the LP tokens that when user deposit they will get the LP token back. So now when you go from here to the processor, you can basically search for process initialize. And there is a bunch of things that you are seeing here. So all the parameters that the pop ups are a bit annoying.
00:34:02.222 - 00:34:47.620, Speaker B: So all the parameters that are simple types, they will be passed like this. And then all the accounts where you store additional information will go here. So first what you will see normally with the smart contracts on Solana is you're extracting all the accounts from the accounts vector and then you are validating. Are those the accounts that I'm expecting? So this is slightly bigger section of your requires in Ethereum smart contract. And then you are unpacking them and making sure hey, is this all that I want? And this is fairly straightforward code, just like if statements that are comparing. Is it everything that I got, what I'm expecting, this is all the same. And then you can go into the setup here of the actual market.
00:34:47.620 - 00:35:46.134, Speaker B: So once you do that during the initialized instruction, we'll mint LP tokens here that the user will get back. Once they are minted, they basically go directly to the user account. Then you store all the information in the account itself and then you say pack. And once that instruction is successful that will be saved on the blockchain for people to interact with. And you can subscribe from the JavaScript site to the notifications of that. And like hey, this new program for that new account for that program was created and let me find the Javascript site of this as well. How you are doing that in the accounts should be subscribed somewhere here.
00:35:46.134 - 00:36:42.418, Speaker B: So for example, like this one, you will get notifications on the specific account that's changed by the smart contract and you can update the state on your UI and you can provide filters like for example, you are only interested in the accounts that are owned by the smart contract as well, or specific smart contract. So this is like super high level. It doesn't go into the details of rust specifically, but it shows you the flow that you have and that repeats through all the functions. So let's say you go to the deposit, then deposit acts almost the same way as initialized. So first you do again pull all the accounts, do all the checks on those accounts. If you got everything that you expected, you unpack the data from those accounts so you can start interacting with them. In this case we run some simple math, and once that math passes all the constraints, we'll initialize.
00:36:42.418 - 00:37:35.900, Speaker B: Then the token transfer itself and then the mint. So because this is a deposit instruction for amm, you have two token transfers from the user to deposit a and B, and for that a and b, the user gets lp tokens on the other side. So conceptually it's fairly straightforward. There is a lot of code like, it looks like it's a lot of code, but most of that code that's really like a bowler plate that it's fairly straightforward to just copy paste. Not the ideal pattern. Eventually you will have like code generation, but again, this is just like pull all the accounts that you need, unpack them, check if everything that you got is what you expect, run some basic math calculations, and then potentially execute instructions on the tokens itself. Hopefully that kind of stepped through the specific example.
00:37:35.900 - 00:37:41.340, Speaker B: This was detailed enough, or not. I'm trying to.
00:37:42.590 - 00:38:00.580, Speaker A: What do you guys think? Very useful explanation. Someone else was like, this is a little too advanced for me. I like the basic one. Here's a question though. How do you choose which program in the enum is called? Is that done via the web? Three call?
00:38:02.070 - 00:38:48.720, Speaker B: Yeah, sure. So there is actually in the processor. So there's this process initialized. So you can see first there is this, when you process with constraints, that's called by this generic process from the entry point. So think of it, there's like a main function that's called when the contract enters, and then we deserialize the instruction and basically do a switch on the enum. You don't need to do it exactly like that. But that's the pattern that we have in Solana program library, and basically within that switch instruction or match instruction in rough terms, we call each one of the methods that you have.
00:38:48.720 - 00:39:19.974, Speaker B: Awesome. And on the JavaScript side it's fairly similar. So let me show you the Javascript site of this. Let's see if this is good enough. I think it's in here. So on the Javascript side you specify the binary layout that you want to send. So you send hey, this is the instruction.
00:39:19.974 - 00:39:54.620, Speaker B: And usually sometimes you can create data. In this case I was just lazy and I said I want to invoke instruction number two, which in this case is deposit and pass, bunch of additional parameters and then the accounts. So this is probably the most annoying part from the Javascript where you need to look up all the accounts that you need and pass them explicitly and sign them. Any other questions? Patrick?
00:39:55.120 - 00:40:09.780, Speaker A: Just one more actually. What code language would you recommend for someone to learn first before getting into smart contract programming language? So I almost feel like the answer to this, well, for Solana is just rust, right? Just like get into rust.
00:40:10.520 - 00:40:55.660, Speaker B: Yeah. It's a bit personal, right. But I think I would grab one of the existing programs from the reference implementation, like tokenswap. If you understand how amm works, try to modify it, try to build your own custom curve. Like again, the simplest one that I can think of is the curve that just reads the chain link oracle and uses that to swap the tokens or exchange the tokens for specific price. It's fairly straightforward starting point. So the way you would do it is, again, you would go to the token swap program, grab specific curve, and just implement literally like single method swap.
00:40:55.660 - 00:40:57.110, Speaker B: And that's it.
00:41:00.120 - 00:41:22.970, Speaker A: Awesome. All right, well, cool. Well, I think that's all the questions here. B. I want to thank you so much for coming out and explaining Solana and showing people Solana and showing people the integration and just for teaching the people how to build really cool stuff for Solana. We're really excited to see what types of projects that we're going to get submitted here. Any other thoughts? Comments? Questions?
00:41:23.660 - 00:41:44.350, Speaker B: No, it was great. I wanted to know if you have any questions about how to work with smart contracts or if the idea is kind of super exciting to us, reach out on our discord. And I'm always happy to join one of calls and brainstorm or try to help you with smart contracts on Solana. And thanks for having me here.
00:41:45.200 - 00:41:49.680, Speaker A: Awesome. Well, thanks so much. Thanks everybody for watching, and good luck with the rest of the hackathon.
