00:00:14.470 - 00:00:50.020, Speaker A: Good morning. Good morning. How is everybody doing? Just going to give it a couple of minutes here for people to show up, for people to say hi. So good morning in the chat, GM. How's everybody doing today? How are we all doing? As we wait for people to come in, in we get set up. GM. I see the gms in the chat.
00:00:50.020 - 00:01:16.018, Speaker A: Excellent, excellent. Excellent. I'm also just finishing getting set up here myself. Good morning. Good morning. Good morning. Good morning.
00:01:16.018 - 00:01:38.054, Speaker A: GM. GM. GM. Let's switch over to me. Hello. Hello. Good morning.
00:01:38.054 - 00:01:48.058, Speaker A: Good morning. One. Good morning, all. What is up? It is 734. We're a couple of minutes in. We have a long session today. We are going to be going through it today.
00:01:48.058 - 00:02:16.520, Speaker A: We're going to be doing some amazing d five. We've done a ton of learning about how to build some of these protocols, how to build with solidity, how to use these different frameworks. And now we're taking that and applying this to a DeFi protocol. We're going to build live today a very minimalistic defi staking application. So I hope everyone's excited. I hope everyone's ready. Hope everyone has had their coffee and or wheaties, because we're going to be going through today.
00:02:16.520 - 00:02:40.714, Speaker A: And let me show you what we're going to be building. As long as I can pull it up. Here it is. Let me switch screens here. There's nothing on my screen. Let me fix that. There we go.
00:02:40.714 - 00:03:14.546, Speaker A: Now there's something on my screen. So this is Defi minimal. I'm going to post a link to this in the chat here. This is Defi minimal. It's a git repo that shows examples of minimalistic defi applications. So if we go into contracts, we have a lending protocol, we have an options protocol, a reward token, a staking, how to interact with a swap, how to do a really minimalistic automated market maker like uniswap. It's a great repo to come check out and learn how to kind of build some of these minimalistic DeFi protocols.
00:03:14.546 - 00:04:01.270, Speaker A: Everything in here is based off of something from Mainnet, one of these more mainstream applications. And today we're going to be building one of the ogs, one of the original Defi protocols, which is going to be a staking application, which is going to be based off of this, off of synthetics. So if you haven't heard of synthetics, synthetics, it's a protocol that allows you to mint synthetic assets. Don't worry too much about that now. Really cool. But they also pioneered this staking design which is what we're going to go through. So what is staking? A lot of people might say, okay, what is staking? Well, staking is when you lock your tokens into a protocol and you gain yield in return.
00:04:01.270 - 00:04:39.102, Speaker A: So you lock a token in your protocol, you gain yield in return. And the tokens locked do certain stuff, right? So the tokens that are locked do stuff. So let's create a quick readme. Staking can be locking tokens to net rewards, tokens to net rewards. And let me zoom in, and the tokens locked will do something. So we're not going to do that do something thing. But maybe your protocol needs collateral.
00:04:39.102 - 00:05:23.534, Speaker A: Maybe your protocol needs a ton of underlying money to do some stuff, right? So locking your tokens can have a bunch of different, you can have a bunch of different reasons to lock tokens. The reason synthetix locks these tokens is so that it can have underlying collateral to mint their synthetic assets. And if that's confusing, don't worry too much about that now. Definitely go check out the synthetics documentation if you want to learn more. But that's essentially what we're going to be building today, and I hope you're ready. So we are going to be using the hard hat repo, excuse me, the hard hat framework for this. However, if you're using brownie, if you're using foundry, if you're using anything else, all the contracts are going to be the same, right.
00:05:23.534 - 00:05:47.074, Speaker A: It'll just be your tooling that's going to be a little bit different. So we're going to go through the contracts first. So if you're like, hey, I just want the contracts, great, just stay for the contracts bit. You don't have to stay for the tooling bit, but we are going to be working with Hardett. But again, the solidity code is going to be exactly the same. So with that being said, let's jump into it. If there's any questions before we get going.
00:05:47.074 - 00:06:20.078, Speaker A: And then I guess I should mention, for those of you who don't know, Defi is absolutely insane. One of the main use cases for blockchain. Okay, cool. So we got somebody saying, hey, what is Defi? DeFi stands for decentralized finance. I just sent a link called defi llama. It's a tracker which tracks different decentralized finance applications. And it's one of the big major benefits of smart contracts.
00:06:20.078 - 00:06:57.182, Speaker A: Smart contracts enable us to engage in censorship resistant, non centralized finance. So we can borrow, we can lend, we could swap protocols without ever having to work with a centralized intermediary so we can interact with finance. We can use these financial products without a centralized intermediary. And it's absolutely massive. And like I said, since this is live, I want this to be interactive. I want people to ask questions, et cetera. So before we get going, is Defi staking similar or the same as the earn function in binance? I guess we'll start with a definition of what DeFi staking is.
00:06:57.182 - 00:07:32.674, Speaker A: So I'm not familiar with binance's earn function, but it's probably something similar, right? You're going to lock some tokens, you're going to deposit some tokens, and in return you're going to get a reward. And they're going to use your tokens for something. They're going to use your tokens to lend, to give out loans, they're going to use your tokens for underlying collateral or a whole bunch of different reasons. Yep, right there. Non centralized finance. Right. So there's no single bank who can screw you over.
00:07:32.674 - 00:07:59.146, Speaker A: There's no lender who can screw you over. It's all autonomous code. DeFi equals decentralized finance, aka future of France. Yes, hopefully that's clear. There's some good learning resources, like what is Defi? And you get some good stuff in there. But let's go ahead, let's get started and let's build a staking application. So once again, I'm in my visual studio code.
00:07:59.146 - 00:08:49.594, Speaker A: I've got a new folder called staking, and we're going to go ahead and get started. So I'm going to do a little boilerplate setup with hard hat here and I'm going to cheat a little bit. No, I'm not going to cheat a little bit. Yes, I am going to cheat a little bit for one of my up and coming free codecamp videos. I've been doing a lot of work on a hardhead edition. I've just kind of been grabbing this yarn dev thing, this yarn ad right here. It's a massive, massive piece of boilerplate, but it's a piece of boilerplate that I've really, really enjoyed using.
00:08:49.594 - 00:09:45.798, Speaker A: So we're adding a ton of dependencies here. We're adding nomic labs, hardhat, ethers, hardhat deploy ethers, nomic labs, hardhat, nomic labs, hardhat waffle, chai waffle. All this stuff to set up like a hardhat project in our repo here. So if you're like, whoa, that seems like a lot of stuff I posted in the chat, but it's basically just some boilerplate hardhat stuff and then some plugins that I really like that come with it. And we're going to do a little formatting. It's going to be good. While we wait for this to come in, any other questions? We wait for this million packages to be downloaded here.
00:09:45.798 - 00:10:22.370, Speaker A: Also, I'm going to add in these two prettiers, and prettier is just a file to help format our code. If you want to learn more about it later, we can talk about that as well. Why Defi? That's more important. Yeah, Defi because if you came to the purpose of smart contracts, we know that the reason that we're doing all this is for trust minimized agreements. Right. Having sophisticated financial products is one of those reasons for having Defi. Right? We want to have Defi.
00:10:22.370 - 00:10:44.222, Speaker A: We want to be able to engage with finance without getting screwed over. We want to be able to say, hey, I want to buy this thing or I want to invest my money and not get screwed over. That's why. Because you're not trusting a centralized entity. Great. Foundry or hard hat. What would be better? It doesn't matter.
00:10:44.222 - 00:11:09.640, Speaker A: Pick one and go. Does not matter. Can we do NPM add with all that stuff? Yes, you could do NPM install. I think it would be Save Dev. Or you just do NPM install all that stuff. So just instead of yarn add dev, you just do yarn add and then paste that in here. No problem with deprecated packages? No.
00:11:09.640 - 00:11:32.814, Speaker A: I guess a productive learning exercise for the Python can be to rewrite this in Brownie. Python. Yes, that would be super cool. So if you're here, you're Python, rewriting the boilerplate in Python will be cool. But like I said, all the contracts are still going to be solidity, so we don't have to worry about too much there. I just installed a whole bunch of boilerplate. Whatever hard hat setup that you like, you can use for this.
00:11:32.814 - 00:12:05.674, Speaker A: And let's go ahead and create our new file folder. Actually, let's do yarn hardhat. And we'll set up, we'll just say, create an empty hardhat config js and great, we now have a new hardhat config. We're going to update this solidity version to 8.7, and we're also going to update a whole bunch of stuff in here. But for now we'll just leave it blank. Now let's actually start building some stuff.
00:12:05.674 - 00:12:35.608, Speaker A: So let's create a new file or folder called contracts. And in here we're going to create our first solidity file called staking Sol. And this is going to be our staking application. Before we actually get to coding stuff in here, let's talk about what we're going to do. I'll be doing this with Brownie. Excellent. Can I start working on the hack joining today? Yes, you absolutely can.
00:12:35.608 - 00:12:45.284, Speaker A: It also allows you to design your financial. Yes, it does. Oh, same. Oh, my gosh. I love all the people doing this in Brownie. Just pick one and master it and begin. Yes, exactly.
00:12:45.284 - 00:13:17.540, Speaker A: Doesn't matter which framework, pick one and go. So let's talk about this staking application. What do we want this to do? What do we want this to do? Well, we probably want it to go. The reason we're thinking about this first is we don't want to just start coding. We wanted to actually think about what we're going to do and then actually code it. So first thing we're probably going to want is people to be able to stake. This is going to be users lock tokens into our smart contract.
00:13:17.540 - 00:14:22.556, Speaker A: That's the first thing we're going to want people to be able to do. And since they're going to want to stake, they're probably going to want to be able to do what. If they're going to lock tokens into the protocol, then we probably want them to be able to withdraw, which is unlock tokens and pull out of the contract. We're also going to want to have some type of claim reward, right? Where users, users claim users get their reward tokens. At the end of the day, those are kind of the three core functions that we want this to do, right? We want to be able people to stake tokens, withdraw the tokens they've staked, and then also claim whatever reward that they are due, can we use natural language processing for building DeFi or any other applications in near future? I don't know. That sounds really cool, though. Yes.
00:14:22.556 - 00:14:42.090, Speaker A: Unstake. Unlock unstake. Yes, exactly. We're going to call it withdraw but unstake. Same thing. Right, cool. And the reward, we're going to have to figure out what's a good reward mechanism, what's good math? Or let's do it like this.
00:14:42.090 - 00:15:20.084, Speaker A: What's some good reward math? Those are going to be the main things that we want this to do. Let's jump into it. We can start with stake because that should be relatively straightforward. And I do want to point out too, actually, while we're looking at staking stuff, if any of you all are familiar with solidity by example, solidity by example has a different version of this. It's slightly different, but it's still absolutely fantastic. I highly recommend checking it out. Let me paste it in there.
00:15:20.084 - 00:15:59.600, Speaker A: Again, highly recommend checking it out if that's something that you want to work with. So let's do this. So we're going to get started by actually coding. So we'll do some SPDX license identifier, MIT pragma solidity carrot 0.8.7 contract staking we did it. Let's even just make sure it works. I'm going to run yarn hardhead compile or MPX hardhead compile.
00:15:59.600 - 00:16:56.900, Speaker A: Okay, cool. Compiling successfully. Okay, contract staking what's the first thing that we said we were going to do? We said we're going to make a stake function. So let's make that function function stake. What should this take as input parameters? Well, let's do a UN 256 amount of tokens and then we already are running into our first question. Do we allow any tokens or just a specific token to be staked? If we allow any tokens, we're probably going to have to do a UN 256 amount comma address of the token that they're staking and et cetera. For our example here, we are not going to allow any token.
00:16:56.900 - 00:17:53.860, Speaker A: We're just going to have one token. So one ERC 20. So yes, do check mark here. We're going to do just one specific token, right? If we wanted to allow any token, and this is where I challenge you to do some improvements, we'd need to do some chain link stuff to convert prices between tokens so we can always know how much value we have. Okay, so for now we're just going to do a singular token and we'll define it someplace else. And you know what, why don't we just define it now? So we're going to do a singular token and we're probably going to need to keep track of that singular token somewhere. So why don't we just go ahead and do that right in the constructor so that right away we're always going to know exactly what token that we're going to deal with.
00:17:53.860 - 00:18:34.930, Speaker A: So we're going to say constructor, we'll say addresses of the stake in token this, and then we'll create a global variable that keeps track of this staking token that we're going to pass as an input parameter. Now we could store this as like an address public s staking token s stands for storage because this is going to be a storage variable. Am I lagging? Am I lagging here. If I'm lagging, let me know. I saw somebody saying that I'm lagging. Hopefully I'm not lagging. Yeah, let me know.
00:18:34.930 - 00:19:03.020, Speaker A: But instead of doing this as an address, we know that this is the address of an ERC 20 and we're going to want to do. No, not to me. Okay, cool. This is going to be an address of an ERC 20. So instead of making this an address, we're going to make this an IERC 20. Okay, so how do we actually turn this address into an IERC 20? Well, open zeppelin to the rescue. Open Zeppelin GitHub.
00:19:03.020 - 00:19:45.416, Speaker A: Oh, and for everybody who's here, please be sure to take the feedback form after we are finished with this session. I will be sending not, we will be sending a feedback form after. Please, please be sure to take that. Let us know if you liked this session, if you didn't like the session, et cetera. So opens up on contracts, they have a token interface that we can use. So we'll use their IERC 20 and we'll just wrap it around this address that we pass it so we can save a global IERC 20 instead of an address. So we can just immediately call the functions on here, grab this.
00:19:45.416 - 00:20:33.448, Speaker A: Of course we're going to need to import it, so we'll need to do import at openzeppelincontractstoken Sol we're going to import this. Now that we've imported this IERC 20 interface, we have it as a new type, so we can do I ERC 20 public s staking token. Again, we're doing the s underscore to tell us as developers, hey, this is a storage variable. It is expensive to read and write. And then we'll just say in our constructor, say s staking token equals IERc 20 of staking token. Cool. So now we're keeping track.
00:20:33.448 - 00:21:28.520, Speaker A: And let me zoom out a little bit. Hopefully this is still big enough. Now we're keeping track. We only have one type of token that we're going to allow people to stake and we're going to input that token in the constructor. Okay, great. So what we can do now in our stake function is we're going to want to, what? We're going to want to keep track of how much this user has staked, what else are we going to want to do? Going to want to keep track of how much token we have total. And what else are we going to want to do? Well, we're going to want to transfer the tokens to this contract.
00:21:28.520 - 00:22:40.400, Speaker A: That's it. So we want to keep track of how much each user has staked, right? Because when they go to withdraw, we need to know how much they've withdrawn. So we're going to have to create another global variable that's going to keep track of these balances. We're going to make a mapping that maps addresses to a UN 256. And in my code example I have it as private, but just for the demo here, I'll just make them all public. Okay, why I ERC 20 so we're using an IERC 20 because we're telling solidity that our s staking token is of type IERc 20. Now we're not doing of type ERc 20 because we don't need all the extra baggage, right? So when we call functions on s staking token, like for example approve, if we call approve on an IRC 20, the IRC 20 doesn't have the function actually defined how to do approve.
00:22:40.400 - 00:23:30.770, Speaker A: So what happens is it says, hey, like IRC 20 doesn't have an approve. Well, I'm just going to call approve on whatever address you gave me. If we gave it of type ERC 20 instead of IERC 20, the approve function in ERC 20 has stuff in here. It has stuff in here. And so that's going to be confusing to us because the stuff that we have in our approve function here might be different than the stuff in the address. So we make this staking token type IERC 20 so we can call, just so that we can call the functions in an ERC 20 and then whatever code is at that address will handle it. Hopefully that makes sense.
00:23:30.770 - 00:24:01.736, Speaker A: If the interface stuff is a little confusing, just don't worry about it for now. And just anytime you want to kind of like create a new type like this, just use the interface and don't use the actual contract. So hopefully that's helpful. Just tell us about these different tokens like ERC seven seven. No, that's not what this session is about, about different tokens. We're just staking like ERC 20. So thank you for the comments.
00:24:01.736 - 00:24:49.290, Speaker A: Keep them rolling in. So we need to keep track of how much users have staked mapping address to un 256 public s underscore balances. This is going to be a mapping of someone's address mapped to how much they staked. So someone's address to how much they staked. So down in here we're going to say s underscore balances, right? Because it's a storage variable of message sender equals and then we can do plus equals. But I'm just going to be a little verbose here. Equals s underscore balances of message sender plus amount.
00:24:49.290 - 00:25:27.396, Speaker A: So we're increasing how much. We're keeping track of how much they staked by how much they're actually staking here. Like I said, we're also going to want to keep track of the total supply. So let's make a total supply up here and we'll just make this public. S underscore total supply. And this is going to keep track of how many tokens have been sent to this contract. Now, this is a little bit redundant, but it's going to make it a little bit, going to make calculating rewards later a little bit easier.
00:25:27.396 - 00:26:08.996, Speaker A: And I'll show you why. So we're going to say total supply equals total supply plus amount as well. And then we'd probably like to emit an event, but for now we're just going to skip that. And then of course we need to transfer the tokens of the contract. So our staking token here has a function. And again, if we go to ERC 20, transfer from it also safe transfer from. But it has transfer from and that's how we're going to transfer our tokens.
00:26:08.996 - 00:27:02.810, Speaker A: So we're going to say s underscore stakingtoken transfer from and it takes from to an amount as input parameters. So it's going to be from whoever calls stake. So message sender two is going to be address this. So we're sending it to our staking contract that we're going to deploy. And for amount and transfer from is external returns a boolean perfect. So we can say bool success equals that. And then we can do require success comma and then just say failed if it doesn't actually work.
00:27:02.810 - 00:27:25.040, Speaker A: Now, this is kind of what you'll see in a lot of code. In a lot of code out there. However, we're going to do the slightly more gas efficient way. Just because I feel like doing it doesn't really matter. But instead of doing requires like that, we can make custom errors at the top. So typically the way you want to do custom errors is you put the contract name two underscores and then what the error is. Transfer failed.
00:27:25.040 - 00:28:12.450, Speaker A: Now, instead of doing require, you're going to say if it's not successful, that's what that exclamation mark or bang as it's known. If bang success revert staking transfer failed. And boom, that's going to do the same thing. This staking function isn't done, but for where we currently are, this is doing everything that we want to do, right. It's updating balances, it's updating total supply, it's sending us the tokens and then it's reverting if sending the tokens fails. Great. Any questions about that so far? We are going to come back and update this a little bit, but for now, that's essentially what we need to do.
00:28:12.450 - 00:28:31.350, Speaker A: All right, cool. Next, we have a stake. Now we need a withdraw. Okay, cool. So they've been able to stake the token. Now if later on they want to withdraw, how do they do that? Okay, great. So we'll say function.
00:28:31.350 - 00:29:10.860, Speaker A: Okay. What's the staking underscore transfer failed code? Yes, great question. So in here you might have seen like require success, right? Our code looks like this. Basically we saying hey, require that success is true. Otherwise revert the transaction and emit this failed thing here. Now doing that is really gas expensive because failed is a string. So we're saving this string on our contract, which costs a lot of gas.
00:29:10.860 - 00:29:49.176, Speaker A: So instead we're kind of doing like the almost reverse of that. We're saying if it's not successful, if bank success, if it's not successful, revert with this custom error code that we created and we made it at the top here. Error staking transfer failed. Revert with this custom error. And this is way more gas efficient than doing require failed. I'm willing to bet sometime in the near future solidity will support custom errors. Like I'm willing to bet in the future things will look like this because that's way more gas efficient.
00:29:49.176 - 00:30:08.912, Speaker A: But right now that doesn't work. So this is what we have right now. Where would the approval happen? Without approval wouldn't transfer from revert since transfer from is called by the staking contract, not the user. Amazing question. Yes, spot on. If you don't call approve, this will fail. Now our staking contract can't call approve.
00:30:08.912 - 00:30:48.784, Speaker A: Why not? Why can't our staking contract call approve? Well, because our staking contract doesn't own the tokens, so our staking contract can't be the one to. Oh yes, and thank you for doing that. For doing NPm install package installation. I typed this NPm install try without save dev. Try without save dev. In any case though, so actually on the front end or the user needs to approve this themselves. So our contract can't do this.
00:30:48.784 - 00:31:36.610, Speaker A: So the user will call approve on the ERC 20 token contract themselves instead of our staking contract calling approve because if we allowed any contract to be able to call approved, then any contract could hypothetically approve any token. So that's the case then. Should we check if it's approved or not? Yes, we could check if it's approved. However, stakingtoken transfer from will fail. Right. This will return false and then this will revert the transaction. Okay, so it's still going to get reverted? Yeah, we probably could check a little bit earlier up, but we're still catching it down here.
00:31:36.610 - 00:32:08.938, Speaker A: But yeah, you could check to see if it's approved or not if you wanted to. Cool. Really good questions. Really good questions. Hopefully that all makes sense. Any other questions? Those are both fantastic questions. I'm going to keep going.
00:32:08.938 - 00:32:31.300, Speaker A: If you keep having questions, keep dropping them in the chat. That's what these live sessions are for. So now function withdraw. We need to pull those tokens back out. Oh, let's do unit 56 amount. How many do we want to pull out? Make this external and let's pull these out. So we're going to do pretty much the reverse of what we did up here.
00:32:31.300 - 00:33:19.002, Speaker A: So we're going to say s balances of message of sender equals s balances of message sender minus amount. We're going to do this exact same thing with total supply except for it's going to be minus amount. And then we're going to transfer tokens. Once again, we're going to transfer instead of transfer from. If we look in here, we're going to call transfer instead of transfer from. We're going to call transfer because our Staking contract now has access to the tokens. When we do transfer from, we're saying, hey, we want to grab those tokens from the user.
00:33:19.002 - 00:34:09.234, Speaker A: When we use transfer, we say we have the tokens and we're going to send them. So we're going to use transfer instead of transfer from. So we're going to say bool. Success equals s underscore stakingtoken transfer message sender amount. So we're going to send back, we're going to send those tokens back, right? And this is going to be the equivalent of equivalents of if we had said IGN token transfer from. Address this to message sender, right? These are due essentially the same, but since who it's coming from is us, we can just use transfer, right? So those are going to be the same. All right, some questions here.
00:34:09.234 - 00:34:46.480, Speaker A: Do we check for overflow? Underflow? We are not going to do that here. Why? Because in solidity version 0.8 and above, solidity automatically checks that we could actually change this to not check for that by using the unchecked keyword. But solidity automatically checks for overflow underflow. In newer versions of solidity, the custom error saves gas. But how is it interpreted in on the evm? I forget, I would have to double check actually. But it definitely saves gas because I've definitely tested it.
00:34:46.480 - 00:35:15.686, Speaker A: That's why we use IRC 20 instead of ERC 20 because we didn't want contract to approve. Not quite. We can't call approve. Right? We can't call approve here because we don't own those tokens. So we can't call approve. If we own the tokens we'd call approve, but we don't, so we can't. Hi Patrick, in staking function you are adding in advanced balance to the sender, but the transaction can fail after.
00:35:15.686 - 00:35:40.430, Speaker A: Yes, yes it. Oh, amazing, amazing point. So revert, that's what this revert keyword. So revert and require. If success is false in either one of these cases, it ends up sending what's called a revert command. And what revert does is revert says, hey, all that stuff that we did previously. Yeah, don't do that.
00:35:40.430 - 00:36:09.046, Speaker A: And it reverts all these changes. So you make a really good point. Hey Patrick, we just updated the balances and total supply, but this transfer from could fail. So what's up? Revert will revert these changes. So revert says anything you've done in this transaction? No, reset it. That was a really good question. Hopefully that makes sense.
00:36:09.046 - 00:36:43.246, Speaker A: Hold on, I lost my water. Let me grab it. 1 second and we're back. Hopefully that makes sense. That's a really good question. Okay, I'm confused about imports. Add import copy structure from IR 220 in GitHub.
00:36:43.246 - 00:37:05.580, Speaker A: It compiles and deploys that with our contract. That consumes more gas. Right. Can you explain more about import mechanics? You're spot on. That's exactly what it does. We could, if we wanted to make this super minimalistic, instead of importing this whole IERC 20, we could just import the functions that we want. But you're right.
00:37:05.580 - 00:37:20.846, Speaker A: Good point. Did you mention that custom errors are only available in 0.8.4 and above? I did not. Good point. That's true. 0.8.4 and above are where custom errors come in.
00:37:20.846 - 00:37:59.450, Speaker A: So revert basically cancels the transactions. Yes, exactly. Amazing question. In the front end, can we call the approve function within a function, not necessarily asking the using to approve? Yes. So in the front end, you will have the user call the approve function. So the user will call the approve function on the front end, but they will call the approved function on the token contract, not on your staking contract. Does our constructor need to be formatted the same as the IERC 21? No, I don't even think this has a constructor.
00:37:59.450 - 00:38:32.514, Speaker A: IRC 20 doesn't even have a constructor. Smart contract. Why don't we add the balance updates after the revert check to save gas? That way we'd save. I love this question. Why don't we add the balance updates afterwards? So you're basically saying why don't we do this right? I love this question. Okay, who wants to answer this? Oh, it looks like somebody actually already answered. You don't want to do that because of reentrancy attacks.
00:38:32.514 - 00:39:17.540, Speaker A: That's exactly why. You absolutely do not want to do that because of reentrancy attacks. Pull this up so we're not going to have time to go over that here. Where's solidity by example? I believe he has a reentrancy attack. Yes. We're not going to have time to go into here this right now, but if you want to learn more about reentrancy attacks, I just dropped a link to it in the chat. But yes, you absolutely 100% want to change state before you transfer your tokens here.
00:39:17.540 - 00:39:33.322, Speaker A: So great questions. Reentrancy dance? Yes. Okay, cool. So now we're back to the withdrawal. We've updated the balance, we've updated the supply, now we're transferring the token. We have bull success. The same thing here.
00:39:33.322 - 00:40:13.638, Speaker A: We're going to say if not successful, revert with some error that we create. Actually we'll just do transfer failed again. Revert staking transfer failed. We're going to send the tokens back. If that doesn't work, just revert the whole transaction and we'll admit event in there somewhere. But whatever. All right, so stake check, it's not done, but we have it.
00:40:13.638 - 00:40:53.006, Speaker A: Withdraw check, it's not done, but we have it to claim rewards now. Text effects it's not really a question. Why are we using external and not public function access modifier? Great question. So external is actually a little cheaper than public, external is a little bit cheaper to use than public. Because when we say external we're saying, hey, no function inside our staking contract is going to use this stake thing. So we're saying only contracts or addresses or accounts outside of this contract can call this function. And by doing that we save gas.
00:40:53.006 - 00:41:18.650, Speaker A: And that's really it. I mean, we could make it public if we wanted to. But oftentimes you'll see these as external because. Yeah, because only external addresses and contracts call them. Okay, great, we have those two. Now let's do function, time, reward. And here's where things are going to get a little interesting, okay.
00:41:18.650 - 00:42:29.780, Speaker A: Because we need to figure out, oh, they've staked some stuff. How much reward do they get for staking? So we need to figure out same reward thing. We'll make this external as well. So we need to figure out how much reward do they get? And this is where each implementation of staking is going to be a little bit different, right? Because everyone's going to have their own reward mechanism. We're going to do one of the most common ones, the most fundamental ones, to deFi, where contract is going to emit x tokens per minute or x tokens per second and disperse them to all token stakers. So let's say it's 100 tokens per second. Let's say this contract sends 100 reward tokens per second.
00:42:29.780 - 00:43:47.082, Speaker A: And there are two tokens. There's somebody who has 50 staked tokens and somebody with 20 staked tokens and someone with 30 staked tokens. Well, that would mean that the rewards would be, say, staked rewards would be 50 reward token 30, or, excuse me, 2020 reward tokens and 30 reward tokens. So if we're giving 100 tokens per second, if this is what's currently in staked, this is what would happen for rewards. Now let's say someone comes along and stakes 100 more tokens. Now for stake, we have 150, 20 and 30, right? What are the rewards going to be now? Well, since we're doing 100 reward tokens per second, rewards are still only going to match up to 100. So the total here, total equals 200.
00:43:47.082 - 00:44:24.466, Speaker A: Now we just do some math. So we say, okay, well, 100 divided by 200 is going to be 50. So this person is going to get 50, this next person is going to get 25, this next person is going to get ten. And then math 15, because we're going to give out a total of 100 tokens per second. So the more people stake, the less rewards every person gets. Wow, I never knew the visibility function. Save gas.
00:44:24.466 - 00:45:06.002, Speaker A: Yes. There you go. Want to be better for gas efficiency if we make the ward one a day? Why would that make it more gas efficient? One to one staking to reward ratio. Not quite right. So some people might be asking, why not one to one? Why not? If we stake 100, we get 100. And the reason is you can often just quickly bankrupt your protocol. But you're going to need enough reward token to give to your people.
00:45:06.002 - 00:46:06.644, Speaker A: So kind of figuring out your rate, right, your reward rate and just having that be constant and oh God, when we save, it doesn't freak out on us. There we go. Figure out your rate and that way your protocol can continue to live forever. Now, this is where it gets a little bit harder because we're doing a lot more math here. So we're doing this function, claim reward. And what we're going to need to do is first off, it's first off, we need to figure out how much reward that we have. So when we stake, withdraw and claim reward it, we need to keep track of how much reward people have.
00:46:06.644 - 00:47:02.288, Speaker A: So in all of these functions, we need to create some type of modifier or some type of math where we can update internally how much reward everybody has whenever they stake, whenever they stake, whenever they modify, et cetera. And then we can use that reward amount to math down here. Okay, here's how much they deserve. So let's create a modifier. We'll make this up here, create a modifier called update reward for some address account for some address user. We're going to add this modifier to all of our functions. Now to get this is where the math gets a little bit tricky.
00:47:02.288 - 00:48:04.764, Speaker A: To update the reward of each one of these users, we're going to need to do a couple of things. So first off, we're going to need to figure out, okay, how much is the reward per token, what is the current reward per token. And then we're going to need to get the last timestamp. And we're basically going to say, okay, between time periods of noon and one or whenever this was last called user earned tokens. Because anytime somebody stakes, anytime somebody stakes, the amount given out is different. The amount given out is different every time somebody stakes within a time frame. So let's look at another example here.
00:48:04.764 - 00:49:04.050, Speaker A: Let's say for five days, one person had 100 tokens staked, hasn't claimed it or anything, or actually 5 seconds. 5 seconds. One person had 100 token stakes. That means their total reward is going to be 500 tokens. Now, let's say at the six second, right at 6 seconds, two persons have 100 tokens staked each. So this would mean person one is going to get what for rewards, they're going to get 550 and person two is going to get 50 because person one got his 500 tokens for being the only one staked his or her. And then person two is just going to get 50.
00:49:04.050 - 00:49:46.510, Speaker A: And now going forward, person two is only going to get 50 tokens per second because person one is going to only going to get 50 more tokens per second because there's two people in here. So we need to keep track. We need to basically have some data structure that says, okay, between seconds one and five, person one got 500 tokens. Okay. At second six on person one gets 50 tokens now. And we need to continually update and continually keep track of the time so that we can have this reward. Correct.
00:49:46.510 - 00:50:31.790, Speaker A: And the math here, once again, it might look a little bit tricky, it might look a little bit weird, but this is kind of the standard staking pattern for a lot of these protocols. Hopefully that makes sense. If it doesn't make sense, let me know. Each user calling claim reward, it updates the reward balances or some chain link keeper. Yes. So we're going to put the onus of updating on the users, right. Because when they call claim rewards, we're going to have that data structure that's going to keep track of how much they previously earned is going to get reset to zero.
00:50:31.790 - 00:51:08.010, Speaker A: So we want to put the onus on the users. Can you please show us to calculate the APR of this pool? Maybe when you finish the withdraw, not because the APR. So this isn't a pool. Right. And the APR is going to be incredibly variable, especially variable on the token price, which we haven't added into this. Right. And the APR is going to change kind of, as you see here, the more people are in this pool, the less your APR is going to be.
00:51:08.010 - 00:51:28.060, Speaker A: More people are in this pool, the less the APR is going to. So if we have time, we can talk more about that. But I'm already an hour in. Oh, my goodness. Yes. You aren't sending withdrawing tokens every second. It's just an internal calculation of the gas.
00:51:28.060 - 00:52:00.170, Speaker A: Yes, exactly. Okay, pyro, you got it? Yes. Okay. What if we use flexible aby according to real time market? I mean, again, this is going to have a flexible apy. This isn't like a borrow and lending pool. So saying like, hey, can we calculate what the APY is? It doesn't really make that much sense. Should we add time period after withdrawal that locks the function so they don't spam the withdrawal? If they want to spam the withdrawal and they were the one paying the gas to do that.
00:52:00.170 - 00:52:29.570, Speaker A: It seems like a waste of gas to me and it doesn't really seem like it'll cause them much harm. Sorry if you've already discussed this, but what are some of the ways that contracts make money from having tokens staked to them? They can be used in liquidity pools. Yes. So that is how some contracts do use it. You'll deposit tokens for liquidity pool for this one. We're not doing that. We're not actually defining in this example what these stake tokens are used for.
00:52:29.570 - 00:53:24.050, Speaker A: But yeah, we're giving out a reward, right? And where the reward is coming from, it's not really clear, but it's just kind of the set up for, if you wanted to give out a reward, here's what it would look like. And then this is how the users make money is because they get these rewards. Can you please explain the staking math a little more? Yes. Let me just give another example. So let's say time equals zero. Person A has 100 and person B has 50 staked. Staked at time equals one.
00:53:24.050 - 00:54:25.764, Speaker A: Just a PA still has 100 staked and that means they've earned. They've earned how much? If we're doing 100 tokens per second and then we'll just say 100 tokens second staked, 50 staked. Actually, these are kind of crappy numbers. We'll do 80 and 80 and 2080 staked. That means they're going to have earned how many. They're going to earn 80 and they'll have withdrawn zero, right? Person B is going to have 20 staked. They'll have earned 20 and withdrawn zero right at time one.
00:54:25.764 - 00:54:48.572, Speaker A: So they've had this stuff staked for 1 second. Now let's say time equals two. Time equals two. They still have 80 staked. Now they're going to have 160 earned, right? And this person is going to have 40 earned. Let's say time equals three now. Now they're going to have 240.
00:54:48.572 - 00:55:20.570, Speaker A: If my math is right, 240 earned and withdrawn zero. Now let's say new person enters. This is time three. Let's say new person enters now. Time equals three. We now have a person C coming in. The new person enters and they stake, say they stake 100.
00:55:20.570 - 00:56:17.050, Speaker A: Person C comes in, they stake 100. Now how much do we have earned and withdrawn for everybody? Well, person a is going to have their 240 earn 240 plus what plus 80 divided by the total, which now is going to be 200. So the new total token staked now equals 200 because we have 80 plus 20 plus 100 is 200. So 80 divided by 20 or 200. So it's going to be 40% of the 200 times 200. Wait, no, hold on. 80 divided by 200.
00:56:17.050 - 00:57:10.830, Speaker A: So if we're doing 100 tokens per second. So it's the 0.4 times 100. So they're going to get 40 tokens they've withdrawn. Person two, same thing earned is going to be 60 their previous 60 plus the new, but it's going to be 20 divided by 200 times the 100 tokens per second. So that equals what? Ten ron, zero and then 100. This person here, they're going to have earned 50.
00:57:10.830 - 00:57:45.510, Speaker A: Right. Because they have half of the staking pool withdrawn is going to be zero. Makes sense. What is ApR? The return per period they get. What is Apr? API. What is APR interval? Percentage rate. First, the yearly interest generated by the sum that's charged to borrowers or paid to investors.
00:57:45.510 - 00:58:43.844, Speaker A: Good questions. So every time there's a withdrawal, we should calculate the time diff times token per second and divide by total number of stakers and add that number to everyone's staked address. That's how I'm thinking about it. Pretty much, yes, pretty much. And we only need to calculate and do that math when somebody withdraws or when somebody stakes or withdraws or claims their reward. Yes, it hopefully this is helpful here. And the only time we actually need to update a function and spend gas is when somebody stakes or somebody withdraws.
00:58:43.844 - 00:59:23.300, Speaker A: Because when somebody withdraws, we need to say, hey, so let's do one more. We'll say time equals four. Time equals four. And we'll say pa withdrew everything. Well, now they're going to have, let's say they withdrew everything and they claimed their reward. Now they're going to have zero staked. They're going to have zero earned and they're going to have 280 withdrawn.
00:59:23.300 - 00:59:41.450, Speaker A: They withdrew all their stake. They withdrew all their earned. And that's how we tell the contract, hey, this person doesn't have anything anymore. And then these two would be like updated accordingly. But I'm not going to do the math. Great questions. Really good questions here.
00:59:41.450 - 01:00:52.942, Speaker A: Okay, hopefully that makes more sense. Let's keep going. So actually, I think this was a helpful exercise because I think it'll make doing the math here a little bit better. One of the first things that we're going to need to do in our, in, it's in our update or, excuse me, our update reward bit is we're going to need to figure out, okay, what is the reward per token stored. So in our example down here at the beginning when there's, we're giving out 100 tokens per second. That means, that means that what? That down here, it was one token per stored token or staked. One token per staked token down here, when the total was 200, it was what, 0.5
01:00:52.942 - 01:01:26.682, Speaker A: tokens per staked token. And that's how we did some of this math down here. Okay, so we need to get this reward per token stored, and we're actually going to make this a storage variable so that other functions can use it. We're going to make it at the top, we'll say un six public. And the other thing is, if you're like, hey man, I'll be honest, the math is really confusing for me. Don't worry about it, just trust the math works. Although I'm saying just trust.
01:01:26.682 - 01:03:09.050, Speaker A: And the whole antithesis of this space is to trust stuff. But you can look at a lot of these big protocols, like synthetics, like other protocols that are doing staking and kind of see the different math strategies that they use, right? So this is the one that synthetics is using. So we need to get this reward per token. So, and we're going to turn this into a function called reward per token we're going to create, so let's create this function, reward per token. And this is going to be a public view view, returns un 256, and at any time somebody can see, okay, what is the reward per token in here? Per each one of these tokens I get, per each one of these tokens I get. What's the reward? Basically, what is the reward per token? How much reward a token gets based on how long it's been during its most recent snapshot, if you will. Now what we're going to say, first off, we're going to say if s underscore total supply is zero, then we're just going to return s underscore reward per token stored.
01:03:09.050 - 01:03:58.590, Speaker A: If there's nothing staked, we're just going to say, okay, great. Reward per token stored is just whatever we had, whatever we said it was last. Otherwise we're going to return reward per token stored plus. And this is where it gets a little bit tricky again to say the block timestamp minus the last timestamp. S underscore last timestamp, which we haven't defined yet, which we will last update time. So anytime we call stake or withdraw, we're going to need to update the time. Actually, we're going to do that in our update reward function.
01:03:58.590 - 01:05:10.050, Speaker A: Update time equals block timestamp. We're going to make this global as well. And again, this is where the math gets hard. So if you're like, what is he doing? Bear with me, just bear with me here. Block timestamp some reward rate. Reward rate, which again for our contract is going to be 100 tokens per second. So we're going to say public will make it a constant reward rate equals 100 times a reward rate times one e to the 18th because we want it to be in way divided by s, underscore total supply.
01:05:10.050 - 01:06:09.790, Speaker A: You might be reading this and you might be going, what in great heavens is going on here? So again, we have a reward rate of 100 tokens per second. So right here we're grabbing. Okay, well how many seconds has it been? Right? Okay, it's been 1 second. Okay, times that by 100 times by 18 decimal places. Divide that by the total supply. If there's 100 tokens, if it's been 1 second, if this is one, if it's been 1 second, reward rate is 100 and the total supply is 100, then this person is going to get reward per token of one plus whatever the reward per token stored is. So, plus whatever they've earned before.
01:06:09.790 - 01:06:39.670, Speaker A: Okay, excuse me. Plus whatever the return reward per stake is. You do not have to remember all this math. You can absolutely rewatch this later. Thank you. You do not have to remember all this math. You can absolutely watch this later.
01:06:39.670 - 01:07:43.764, Speaker A: So if you're going, what is this math? I would basically just say, don't worry too much about it. But yeah, feel free to come back to this and we can ask more questions about the math. I know that if we spend too long on the math here, everyone's going to be like, what are you talking about? What is this math? But for now, let's just keep going, right? So we're updating the reward that each person gets. We're getting the reward per token like so we're getting the last timestamp so we can have those timed snapshots. And now we can finally update how much reward each person has, right? Because we want to keep track of how much everybody has earned between these timestamps of people staking and unstaking stuff. So we're going to say s underscore rewards of account equals earned and we're going to create an earned function of account. Now that we have the reward per token, we have the last update.
01:07:43.764 - 01:08:45.930, Speaker A: We can now see how much in total this person has earned. So we'll say function earned, which will take an address account as input parameter. This will be a public view and it'll return a UN 256. Now we're going to get the total this person has earned, right? And they're going to use this to call withdraw and get ready for some more math here. So actually let's make this a little easier. We'll say we'll need uni two v six current balance equals s underscore balances, right? And maybe this will be the part two that should be easier to understand. We'll get their current balance, which is the current balance that they have staked, right, which we're just getting from our storage variable.
01:08:45.930 - 01:09:50.446, Speaker A: We're also going to need the reward per token, but we're also going to need how much they have been paid already. So we're going to create a new data structure called s user reward per token paid. And this is going to be a mapping up here, mapping of address to Un 256 public. This right here. And this is just going to be a mapping of how much each address has been paid. Why do we need that? Well, because we don't want to give them what they've already been paid. So we're going to say Un 256 amount paid equals s user reward amount paid per token of account.
01:09:50.446 - 01:11:21.530, Speaker A: And then we'll update this later on in our claim reward function. And then we need the UN 256 current reward per token equals reward per token app. So get the current balance amount paid amount they've already been paid, the current reward per token and then s underscore rewards UN 256 tasks rewards. Right, and this is all the stuff that we need to calculate how much they've earned, how much they've earned here. And we'll say their current balance needs times the current reward per token minus how much they've been paid. We're doing the reward per token minus how much they've already been paid times the current balance. Stick with me, stick with me.
01:11:21.530 - 01:12:41.610, Speaker A: I can see some of you all zoning out how to buy one e to the 18th and this whole thing added to fast rewards. 256 earned equals this return earned. Feel like I did it like this to make it easier to understand, but I feel like I did not accomplish that. I did not make this easier to understand. Yeah, 100 tokens per second is pretty hardcore. Well, if you think about 100 tokens per second, as in like if one token is 112-34-5678 910, 1234-5678 if this is one token then 100 nothing, right? We have this earned function which I see a lot of you all being like, what is going on? And I'm like, oh yeah, this is definitely a little bit tricky to understand here. Let's just keep going.
01:12:41.610 - 01:13:18.978, Speaker A: Again, this is a whole bunch of math stuff. If you're super struggling with this math, say hey, math is hard and call it a day. Don't call it a day. Try to understand what's going on here. I know that this is kind of hard because there's a lot of math. So hopefully this is making sense. Let's just finish the function here and we'll finish the function here and then we can ask more questions about like what just happened with all the math.
01:13:18.978 - 01:14:19.434, Speaker A: So we'll say s underscore user reward per token paid of account and equal to s underscore reward per token stored. And that is the end of this modifier. The reason we made this modifier is because whenever we stake, we want to update the reward. We want to update the reward of message sender whenever we withdraw. We want to update the reward of message sender ever we claim reward. We want to update the reward of message sender. Anytime we do anything, we want to update the reward update the rewards of this person.
01:14:19.434 - 01:14:52.450, Speaker A: Right? Because if they withdraw, okay, great. If they withdraw, great. We need to say, hey, we withdrew a whole bunch and now they have nothing left to be earned or they have nothing left staked. When you claim rewards, you got to update earned, withdrew and claimed rewards on everything. When they withdrew and claim rewards, they have nothing staked. Now everything was withdrawn so they have nothing left turn. Anytime we pretty much do anything, we need to update the rewards for that user.
01:14:52.450 - 01:15:13.130, Speaker A: Cool. Hopefully that makes sense. Now that we have that update rewards function and we created a whole bunch of random variables and stuff. Did I create this one? Yes. Did we create this one? S rewards. We didn't create s rewards. Create s rewards.
01:15:13.130 - 01:16:19.280, Speaker A: So this is going to be a mapping of an address to a unit 256 republic as rewards mapping of how much each address has been paid. It's going to be a mapping of how much rewards each address has. So claim reward, they first need to update the reward amount. Okay, now that we have that, what we can do is we can say, okay, great, well, un 256 reward equals s rewards. Now that we're calculating this rewards thing, message sender, all we got to do is we just transfer them the awards that they're due, right? That's it. So we update the rewards and we just transfer them the rewards. So s rewards is going to be kind of the how much each reward address has to claim that.
01:16:19.280 - 01:16:58.794, Speaker A: So s rewards is how much they have to claim, which is great. Then we can just transfer them how much they have left to claim. So we'll update that reward amount and then transfer them the amount they have to claim. So once again, we'll just do bool success equals s underscore rewards token transfer message sender. And we only have a staking token so far, but we probably want to have a different reward token. So let's do the same thing in our constructor here. So we'll do an address staking token.
01:16:58.794 - 01:17:24.322, Speaker A: We'll also do an address rewards token or reward token. And we'll just copy paste this. And so we'll say s underscore reward token equals I Erc 20 reward token. And then we'll just copy paste this into I reward token. So we have two different tokens in this contract. We have one for staking and one for reward. They could 100% be the exact same token.
01:17:24.322 - 01:18:38.210, Speaker A: But we're just going to make it clear that we potentially could have two different ones. And then down in claim reward full success. We're going to say if not success, revert taking transfer failed. So are we done? Pretty much. We could do a little bit of cleanup here. We can create a little modifier, modifier called more than zero more than zero which takes a UN 256 amount just to make sure that people are staking and withdrawing more than zero. And we'll just say if amount equals equals zero, then we could say revert needs more than zero.
01:18:38.210 - 01:19:15.310, Speaker A: And we'll prepend it with staking. Staking underscore underscore needs more than zero. A little underscore down here up at the top. Error. Staking needs more than zero. Then we'll use this more than zero modifier on our stake function stake more than zero amount. Also probably do more than zero on withdrew amount.
01:19:15.310 - 01:19:42.852, Speaker A: So now that both of those are needed more than zero, we probably could double check for re entrancy by using like open zeppelin re entrancy guard. But for the most part, we're pretty much good here. So I'm going to compile real quick and then I'm going to answer your questions. Don't worry, I'm coming. Yarn hard hat compile. I'm going to come answer the questions. Got to add this.
01:19:42.852 - 01:20:06.190, Speaker A: So let's go ahead and add these. We'll do yarn add dev add opens up on contracts. We have 40 minutes left. Okay, so we're doing plenty fine on time. We'll do compile again. I meant s reward token. Do anything else wrong.
01:20:06.190 - 01:20:34.208, Speaker A: Looks like I have shadow declaration. Okay, so I have an earned variable and an earned method. Earned. Okay, earned. So we'll say call this like underscore earned that. Okay, cool. Okay, so now this is compiling successfully.
01:20:34.208 - 01:21:03.792, Speaker A: So pretty much we're good here. Now what we want to do is create a deploy function, make some tests, et cetera. And if we have time, I think the tests will really show us. Oh, that's how it makes sense. That's why it makes sense. And that'll show kind of the math that goes on behind the scenes. But before we do any of that in the last 40 minutes, let's answer some questions here.
01:21:03.792 - 01:21:46.352, Speaker A: And I think the test will really make the math make a lot of sense. What happens if I claim rewards and then deposit them again? Well, you'll update the rewards, right? And then you can just go ahead and restake them, which will update rewards again. So we're updating balances no matter what. So that's what will happen, right? Because when you claim rewards, you'll now have zero left to claim, and then you can just redeposit them, which is great. You've made it pretty clear. Appreciate your patience. If math is mathematical and critics are critical, then testar, okay, you will get a bigger portion of the pool.
01:21:46.352 - 01:22:38.800, Speaker A: What does line 48 say? Oh, it's an underscore. So this is like after you write your modifier code, you're saying, hey, now go ahead and do the rest of whatever function that I'm modifying. More than zero here. You can kind of read this as, okay, do the update reward code. Okay, then do the more than zero code, which is do this and then do the rest of the code. Where do we define s underscore rewards? I didn't define it when I was coding, but now I defined it like this mapping of how much rewards each address has to claim. Will there be a GitHub for this? Yes, indeed.
01:22:38.800 - 01:23:18.390, Speaker A: So this is at a minimal. So I just posted it in the chat. How often do you run these code alongs for the hackathon? We're doing them kind of all the time, so definitely check out hack chain link. Chain link. And you can see the agenda down here. So today it's this, later on today we're doing an NFT using ipfs. Tomorrow there's a whole bunch of stuff, day after that there's a whole bunch of stuff.
01:23:18.390 - 01:24:03.830, Speaker A: Next week there's a whole bunch of stuff. There's a whole bunch of stuff all over the place. How do you call functions when it has modifiers with different parameters as the function being called? When it has different parameters as the function being called? So you can just call a modifier with whatever functions the modifier takes, right. So for example, we have update reward, which is a modifier which takes an address account as an input parameter. We're just passing address as the input parameter, even though the stake function has a different input parameter. So update ward is looking for an address. We just pass it an address like in the function declaration.
01:24:03.830 - 01:24:38.936, Speaker A: What's the scope of revert? Every operation before the revert instruction within the called function. It's the entire transaction, actually. The entire transaction. So every operation before the revert instruction within the whole transaction. Yes. Crazy righteous. Which is what we want.
01:24:38.936 - 01:25:13.788, Speaker A: The math done here related to staking. Are there any reference books or blogs which cover them in details? Yes, um, by example. Does a pretty good job, I guess. He doesn't really go over it, he just kind of shows his code. Synthetics, you look at this. Oh, actually, yes. Smart contract programmer.
01:25:13.788 - 01:25:29.444, Speaker A: Actually, this is really good. Yeah. Okay, this one is really good. I'll post a link to this in the chat. He's got a video which goes over it. Can't see s underscore rewards token. Oh, yeah, we fixed that.
01:25:29.444 - 01:25:55.550, Speaker A: What was updated meant the last line of earned. Okay, earned. We're returning earned. Is that what you mean? The more investors in the contract, the less the APR. Yes, the way that we're defining it. So that's because we have a constant reward rate. Now, what synthetix does, and what a lot of protocols do is they don't have a constant reward rate.
01:25:55.550 - 01:26:37.050, Speaker A: Their reward rate changes based off of how many people are using their protocols, for example. So if they're making a killing on fees, this reward reward rate is going to spike. But in this one, yes, the more investors, the less the reward can. But you can customize this as much as you want out of interest. Are there any well known public staking projects that update per second? This at least shows what DeFi and programmatic contracts can do. Wouldn't it be feasible for tradfi to do it? Shows what DeFi. Well, what do you mean, this one? Updates per second.
01:26:37.050 - 01:27:00.866, Speaker A: So like, synthetics updates per second. Not sure I follow. When does the modifier on a method get executed? Yes. So when you call this function, when you call any function, you run the modifiers first. So we're going to run update reward first. We're going to run, run zero. Well, that's not necessarily true.
01:27:00.866 - 01:27:41.360, Speaker A: They get run whenever the modifier tells it to. So this weird little underscore thing, this stands for the rest of the code. So if we run more than zero like this, we first would run the function, and then we'd run the code in here, but more than zero gets hit first, if you will. Like it goes to more than zero first. I just got a calendar notification saying I have a workshop right now. Well, it's a good thing I'm already doing the workshop. So that's how that works.
01:27:41.360 - 01:28:20.780, Speaker A: This is to make LP stake. This is to make a staking contract. I'm not sure what you mean by LP stake. I meant function stake, amount with modifier more than zero and other variable. Oh, I see what you mean. So you just pass another variable in here. So you do like my un 256, my other VAR, then just do this.
01:28:20.780 - 01:28:58.576, Speaker A: Hopefully that's clear. Meant function stake with modifier more than zero, another variable. When you call function hash, you need to send two parameters, amount and another variable, right? Yes, exactly. Can I ask some ethereum related but non staking question? Yeah, sure. Okay, hopefully this is clear now. What do we want to do now, actually? So we have a couple of options. So I can write a quick test to hopefully show you kind of the math in action and kind of this in action.
01:28:58.576 - 01:29:46.084, Speaker A: Or we can talk more about the math if we want. What do we want to do here? How are people feeling? How are we feeling? And I'll flip back to me because I know we've just been talking for an hour and a half here, so I hope everyone's still doing all right. I need a haircut test. Would love to see some tests. Okay, I have something notice and can't understand. What's that? I create a function which generate the private key randomly. The private key I got after many empty accounts have asset, but the account I not totally following your question, sorry.
01:29:46.084 - 01:30:08.760, Speaker A: Can you do a test and deploy? Test and deploy. All right, here we go. All right, we're jumping in. Test and deploy. Absolutely. We can absolutely do that. So for those of you who follow with the hardhat starter kit, you absolutely should let me, hardhat starter kit.
01:30:08.760 - 01:30:41.696, Speaker A: You know that we love working with Hardhat deploy. And I just posted a link to the hardhead starter kit. Oh, and remember for people who are jumping off, before you jump off, before you jump off. Hold on, let me grab something before you jump off, please. Please remember to fill in the feedback form. I'm going to post it here. Post in the chat.
01:30:41.696 - 01:31:26.820, Speaker A: I'm also going to put it on screen, please. And I think I have a QR code copy link that just goes to the, yeah, please fill out that form. Let us know how we do it did in these, but yeah, wait till the end, let us know how we did it. Helps us figure out what workshops are good and which ones are bad. And maybe if we get feedback here saying, hey, math too hard, we won't do any more math ones. A couple more questions, then we'll absolutely jump into the test and play the first day in contract you do follow a code and keep learning to do similar contracts. The first thing in contract you do, you follow a code and keep learning to do similar contracts.
01:31:26.820 - 01:32:01.980, Speaker A: Yes. No need for hackathon, no need for haircut attackathon mode. Can a modifier run after the code? Yes, a modifier can run after the code. So like in staking, if we put this underscore up here, this means the code of the function is going to run first and then this is going to run. So this underscore stands for the rest of the code question. Really good question. Okay, let's do this.
01:32:01.980 - 01:32:59.504, Speaker A: So first thing we got to do is let's write our deploy script so that we can deploy it for our tests. So I use hardhead deploy. If you're not familiar with hardhead deploy, it's awesome. I'm not going to go over it too much right now, but to write our tests, since this is a staking contract, we're going to need to deploy. We're actually going to need to deploy tokens, right? Deploy a reward token. JS deploy our reward tokens before we can deploy our staking contract, right? Because if we look at our staking, what does a constructor take? It takes two addresses, two ERC 20 token addresses. So before we even do that, then what we're going to need to do is create a new file called rewardtoken Sol.
01:32:59.504 - 01:33:41.024, Speaker A: And I'm going to go a little bit quick here because short on time and I'm just going to copy paste this code in here. But basically we have a real simple, real minimalistic reward token we're importing from Elpin Zeppelin. The reason we're using ERC 20 and not IERC 20 is because we want those functions. Yes, you could test with Brownie if you wanted, but we're going to test with hardhead here and we're just minting this many of the tokens. And this is going to be both our staking token and our reward token. So first let's go ahead, let's deploy the reward token. And in our deploy functions, if you go to the hardhead starter kit, you can kind of see an example of what these look like.
01:33:41.024 - 01:34:31.672, Speaker A: You can also check out the hardhead deploy package that we're using to help make our deployments easier. So to get started, we're going to do module exports equals async, named accounts and deployments. It's going to be little arrow function here. And in our hardhead config we're actually going to need to add a whole bunch of stuff in here and I'm just going to copy paste. I'm sorry, I realized that we're short on time. So in order for any plugin to work with Hardhat, you need to add it to the hardhead config. So we're adding hardhat waffle for our tests.
01:34:31.672 - 01:34:53.940, Speaker A: We're adding hardhat deploy so that our deploy script works. We don't need this one. We don't need this one. We don't need this one and we don't need this one either. Well, we probably should use that one, but we're not going to use it. So whatever. And the other thing that we're going to do in our config is we're using this getnamed accounts function which comes with hardhead deploy.
01:34:53.940 - 01:35:49.960, Speaker A: And basically we just name accounts in our module exports here. So we'll just do named accounts. You were hoping I'd do what? We'll say deployer is going to be default zero. So we're basically saying, hey, we're naming a deployer account to be like the ethers, built in accounts at index zero, ethers, which comes with Hardhat, gives us like a bunch of fake accounts. And we're just saying the deployer, we're going to name one deployer and that's always going to be at index zero and that's it. And it's just kind of nice for writing some tests here. Now we're going to say const deploy which is how we're going to deploy stuff equals deployments.
01:35:49.960 - 01:36:28.804, Speaker A: Const deployer equals await get named accounts. I got to go crazy fast if I want to write a test here. We're going to do Const reward token equals await deploy reward token. This reward token is the name of the contract. So the name of the contract is reward token. So boom, we're saying we're going to deploy reward token. We're going to say from deployer and this is the arguments that we're going to give it.
01:36:28.804 - 01:36:54.108, Speaker A: Args is going to be blank. No constructor arguments. Log will say true. That's it. And then we'll do module exports. Tags equals all and ward token just to make sure this is working. And I know I'm going kind of fast.
01:36:54.108 - 01:38:20.550, Speaker A: Yarn hardhat, deploy tags, reward token, unrecognized tasks, deploy hard head config. No, we have it depoly. That's why. Because depoly isn't a task. We ran to an issue from to lowercase is not a function. What the heck? All right, well, it worked this time. Cool.
01:38:20.550 - 01:38:43.150, Speaker A: I'm not sure what it did wrong, but it's working now. Great. So we're deploying this. Awesome. So now that we have a reward token that we're going to create our, we're going to deploy our staking token. You know, sometimes stuff just works right? Isn't life great? And we're going to do real similar setup to this. I'm going to copy this bit.
01:38:43.150 - 01:38:56.012, Speaker A: Boom. Because we're going to deploy staking in here and we're going to have the same setup. And then if you saw this again, I'm just going to run this one more time. We're saying deploying reward token. We deployed here. We deployed it. Yay.
01:38:56.012 - 01:39:19.748, Speaker A: Awesome. Now let's deploy our staking contract. We're going to do real similar setup here. The only difference is we're going to say const reward token equals await. Ethers get contract. We got to import ethers from Hardhat. Ethers get contract, reward token.
01:39:19.748 - 01:39:55.364, Speaker A: And this is one of the cool thing about hardhead deploy. To get the most recently deployed reward token, we can just do ethers get and it'll get it for us, which is phenomenal. And then we can say const taking deployment equals await. Deploy. Staking deploy. Our staking contract. We're going to say from deployer args are going to be what? What are the args for? Staking the constructor address one and address two.
01:39:55.364 - 01:40:29.860, Speaker A: So we'll say reward token address and then reward token address. And then we're going to need log is going to be true. And then that's it. And this will be staking. Now if I just run yarn hard hat deploy, it should deploy our staking, our reward tokens and then our staking contract. And I ran to an issue. No contract deployed with name.
01:40:29.860 - 01:40:54.090, Speaker A: Reward token. Deploy reward token. Oh my God, did I just overwrite this with, oh my God, I did overwrote. Deploy reward token with staking. Let's undo, undo and do and do and do. Undo and do and do. There we go.
01:40:54.090 - 01:41:16.448, Speaker A: You all see me do. That's kind of funny. Now I put in the right spot. I didn't save this. I'm wrong here. Two lowercases, not a function. Okay, so now we're back at that weird four.
01:41:16.448 - 01:41:31.296, Speaker A: I'm pretty sure I just spelled something wrong. Right? If I do? Yes. Okay. Because I need to have deployers in brackets like that. Okay, cool. Deploying reward token. Deploying staking.
01:41:31.296 - 01:41:51.150, Speaker A: Okay, we did it. Okay, so now we have like 2 seconds. We have ten minutes to do some testing, which we're going to do now that we have some deploy scripts. Any questions? Deepali? Well, it's working now. Yes. Was hoping you do another version of testing with brownie. Yeah, sorry, I'm not.
01:41:51.150 - 01:42:25.856, Speaker A: Do you even need to import hardhead? Yes, you do, but. Okay, great. Now let's do some tests because we're going to go a million miles per hour here. Tests. We're going to do a staking test. Staking test. Js and the reason that tests are so fantastic is we're really going to be able to see by running these tests exactly how much reward people will get on different stuff.
01:42:25.856 - 01:42:50.668, Speaker A: Okay, so I'm just going to write one giant test. There are more tests than that repo that I sent you. But let's do it. So we'll say describe and this is going to be using like mocha test scribe. Staking test. This will be an async function and we'll say do a little let. We'll say staking reward token, lawyer.
01:42:50.668 - 01:43:21.880, Speaker A: We'll say die and then stake them out. Say before each async function why I'm using an error function. Yes. Screw it. Arrow functions are silly. Async function. We're saying before each test that we run, we'll say const deployer equals we'll do await ethers.
01:43:21.880 - 01:43:47.904, Speaker A: Ethers get signers. Actually ethers is imported from hardet. Great. And we'll call this accounts, accounts. And then we'll say const deployer await zero. Don't need to wait now to deploy to run through our entire deploy folder. And this is why I love it so much.
01:43:47.904 - 01:44:39.744, Speaker A: We just run await deployments fixture and we just say all so that will deploy everything for us. And then we're importing deployments from Hardhat. Then we'll say staking now equals await ethers. Get contract staking and do this a couple more times. We're going to say reward token equals get reward token and then don't need die. So we'll say reward token, staking and reward token. We have those.
01:44:39.744 - 01:45:27.120, Speaker A: And then we'll say stake amount equals ethers. Utils parse ether. Boom. Okay, so we have a little before each. Now we can just now we'll do like our one massive test and I'll do it in like five minutes. It what the heck? What is that? It allows users to stake and claim rewards. This will be an async function.
01:45:27.120 - 01:46:06.860, Speaker A: Now what we want to do to work with the staking contract is we're going to do everything that. It's all coming down to this. First thing, what we're going to want to do in staking is we're going to want to stake. Where is stake? We're going to want to stake some tokens. And as a lot of people said, hey, Patrick, transfer from. When does that actually get called? Well, it's going to get called on the UI or it's going to get called on our test. So we're going to do await reward token, approve staking address stake amount.
01:46:06.860 - 01:47:00.510, Speaker A: If we're on like a website or a UI, we're the one actually calling this, right? And in our tests, we still have to be the ones to call this. So we're saying, okay, great, we're going to approve the staking address to take x stake amount of our tokens. Now we're going to do awaitstaking stake amount. So we're going to stake 100,000 tokens. So we're staking 100,000 tokens and we could just run our tests here, right? So let's even just do, we'll say const earned or starting earned equals awaitstaking earned. And this deployer address, because it's the deployer. Yeah, deployer.
01:47:00.510 - 01:47:17.090, Speaker A: Deployer. Deployer. Const. Deployer. There we go. Then we'll just console log this out. Console log earned.
01:47:17.090 - 01:47:40.394, Speaker A: I'm doing a little string interpolation like that. Then we can do hh test or yarn hardhead test. I have a shorthand installed where I can just do hh and it's the same as doing like yarn hard hap. So we have, okay, great. We have earned zero, which makes sense because no time has passed, right? We staked 100,000 tokens. No time has passed. So we start off with zero.
01:47:40.394 - 01:48:24.774, Speaker A: So I'm going to say starting, which is exactly what we expect. Okay, now I have some utils that I use and I'm just going to copy paste them. Because guess what? Since we're running on our own local blockchain, we can actually move blocks and move time ourselves. So I have already created these functions and I'm not going to go through making them because we're short on time. But I have a function here called move blocks where we move blocks however many blocks. Like we mine however many blocks we want. And we can move time however long we want to move it right, which is really important for running tests, and I'm going to import them.
01:48:24.774 - 01:49:20.500, Speaker A: So I'm going to say const blocks equals repo for this is here. Move blocks equals require, but dot fills blocks. We're also move time. Move time. We staked a whole bunch of stuff and cool, nothing really happened. Well, let's go ahead and we'll move time and we'll see how much we've gotten after we move time. So to move time, we'll say const seconds in a day equals 86400.
01:49:20.500 - 01:49:52.552, Speaker A: And the reason I know this is because I googled it before kihi. And what we're going to do is now we're going to do await move time seconds in a day. And then we'll do await move blocks one. So we're moving this many seconds, and then we're moving one block just to make it so that we have a block which has the time. And now we can run earned again. But this will be ending earned. Ending earned equals awaits staking earned.
01:49:52.552 - 01:50:31.320, Speaker A: And then we can do the same console log here again. But instead of starting earned, we'll do ending earned. Ending earned. Run it like going crazy fast. So moving one blocks ending, we ended up earning this many tokens after one day, right? And you might be thinking, holy cow, that's a lot of tokens. Remember, one token is 112-34-5678 910, 1234-5678 really? This isn't a whole lot of tokens at all. We didn't even get one token from one day.
01:50:31.320 - 01:50:45.550, Speaker A: So let's try a year. So we'll say const seconds in a year. And I already know how many seconds are in a year. It's that many seconds. So let's try doing that. So we'll do seconds in a year. We'll run this again.
01:50:45.550 - 01:51:19.380, Speaker A: And after a year we got this many tokens, which is a lot more, still less than one. But again, our contract is only outputting at a very tiny rate. So that's how the math works. It keeps giving us more and more tokens as time progresses. Now, what do you think? If we waited a year and then somebody else staked. We actually don't have time for that. We have seven minutes left.
01:51:19.380 - 01:51:41.772, Speaker A: So you can check the tests in the repo here, and you can play with it, you can expand on it, you can do whatever you want. But yeah, hopefully this was helpful. I know I kind of really sped through this because we have no time left. I'm going to switch back to me. Thoughts? Comments questions. And, yeah, I'm sitting down now. Thoughts, comments, questions on anything that we went over.
01:51:41.772 - 01:52:31.370, Speaker A: I know this was a lot. I know this was kind of definitely the most advanced workshop we've done so far. Yeah, how did we do? What did we think? Any thoughts, comments, questions? Everybody who asked questions, though, these are really good questions. I'm constantly impressed by the level of questions here, especially with a concept like this where we had 2 hours to learn defi almost, which is not a small feat at all. So if you understood anything, if you took anything away from this workshop, I'm incredibly proud. I'm incredibly proud, because again, this was a hard workshop. And again, in the chat right here, posted a link to that feedback form.
01:52:31.370 - 01:52:54.452, Speaker A: Please give us feedback so we know, hey, maybe the hard hat Defi workshops aren't for you all. Maybe you guys all say, hey, you know what? We don't like those. Let us know. Patrick, you coded way too fast. I couldn't follow along. Repo wasn't clear. Make the repo better.
01:52:54.452 - 01:53:07.096, Speaker A: Code example, not good, et cetera. Or maybe, hey, Patrick, you're amazing. You killed know, whatever feedback. It helps us figure. Know. Positive or negative. Positive feedback says, great, keep doing it.
01:53:07.096 - 01:53:37.280, Speaker A: Negative feedback says, all right, stop doing it. So, good session. Good session. And we have five minutes left here. So are there any questions on anything defi, anything, this project, or really anything at all? Right, because we have five minutes left, so we can kind of talk about whatever we want to talk about now. Questions, comments, concerns? Yeah. Freddie, based off your questions, I could tell you were coding along, which is awesome.
01:53:37.280 - 01:54:21.890, Speaker A: You are 100% doing this the way I had intended. Yeah, the math part. And then I got really fast at the end because we started running out of time. The math part took me a few tries to figure out myself, and that's why I'm saying, hey. Even with people who really understood the staking, like explaining it to me, I was like, what? So it's a little bit tricky to grasp. Once you grasp it, it makes more sense, but it definitely takes a couple of tries. That video from solidity by example is really good.
01:54:21.890 - 01:55:02.430, Speaker A: Solidity by example or our smart contract programmer, really good. Where is the repo of all the files? So I posted in the chat a couple of times. Defi minimal, smart contract kit, DFI minimal. It's in the chat somewhere. If you scroll up as well. Is it worth to add typescript support? Probably. Is there a brownie mix you would recommend to use as starting point to remake this project with brownie? So I haven't done this with brownie, but you could pretty easily just copy all the contracts and then create your own scripts on it.
01:55:02.430 - 01:55:34.292, Speaker A: If you look at the chainlink mix, I mean, if you look at the chain link mix, it should be, I don't want to say straightforward, because that's not always true. Basically, I don't think I know of a staking contract. Brownie repo. But there are plenty of repos with Defi. I've done some flash loan stuff. I've done some aave stuff that'll be pretty similar. All right, cool.
01:55:34.292 - 01:55:46.696, Speaker A: Awesome. Thank you. Is the code for staking NFT similar? Yes, it'll be very similar. Defi staking is complicated. Makes sense. See, the thing is, it doesn't have to be. Just the math is right.
01:55:46.696 - 01:56:12.092, Speaker A: At the end of the day, Defi staking is pretty simple. And I don't want us as a community to get into the habit of saying like, oh, Defi is hard. So be it. Because it really should be something that anybody can pick up. We want to enable this technology to allow anybody to just use and go, right. We don't want to have a system where only elite people can use Defi. That would suck.
01:56:12.092 - 01:56:45.020, Speaker A: And that's kind of already what traditional finance is right now, where only the elite people can use it. And that's not what we're trying to build here. Or at least that's not what I'm trying to build. That will tear me apart if that's what happens. Was following along up to the test, then went, like, the flash we'll go through. Yeah, sorry, I started copy pasting a ton because, well, we had no time left, which makes it impossible to code along because, like, hey, like, I'm copy and pasting this now. Good luck.
01:56:45.020 - 01:57:19.176, Speaker A: Thanks for following along, Paul. Can anyone stake, or do you need experience in computer programming? Yeah, anybody can stake, and anyone should be able to stake. I think that's where we want to aim. We want to aim to be a point where anyone should be able to stake. Apart from solidity by example, what other resources would you recommend to learn more about staking and see other examples of contracts? Good question. Good question. Open zeppelin, for sure.
01:57:19.176 - 01:57:49.504, Speaker A: Absolutely open zeppelin. Damn. Vulnerable defi. If you want to learn about defi security, Openzeppen's ethernet is very good. Those are more like security stuff, but they also will help you learn a lot of, and the cool thing about all these protocols is that they're all open source. So if you want to go see synthetics code, if you want to go see Ave's code. You can just go to their repo and play around.
01:57:49.504 - 01:58:19.976, Speaker A: The thing that's a little bit hard is they're pretty large code bases. So going to those repos might be really overwhelming, but you can do that or you can go to those repos, you can go to any production project is deploying contracts to l two s, like arbitram or optimism. Very different from main net nodes. Like nearly exactly the same. Cool. All right, well, remember to fill out that feedback form. It's in the chat, so scroll up.
01:58:19.976 - 01:58:34.464, Speaker A: Just click the link. Thank you all for being here. It is 931. So we are now over. Hopefully you all learned something here. Let me know in the feedback form what you learned, what you didn't learn, and we will talk to you all soon. Good luck at the hackathon later on.
01:58:34.464 - 01:58:54.064, Speaker A: Today we have an NFT end to end. There's no math in the NFT bit, so that's good. And we're going to be hosting it on IP fest. So it's going to be a ton of fun. So if you want to learn how to make nfts programmatically, make them customized, make them dynamic, definitely go to the session later today. We'll see you there. And good luck at the hackathon.
01:58:54.064 - 01:58:54.610, Speaker A: Bye. All.
