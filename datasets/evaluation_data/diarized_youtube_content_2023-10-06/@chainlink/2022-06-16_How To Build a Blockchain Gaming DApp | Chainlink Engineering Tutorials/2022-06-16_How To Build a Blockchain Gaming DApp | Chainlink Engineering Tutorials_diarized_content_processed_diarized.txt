00:00:00.250 - 00:00:45.626, Speaker A: Hi, I'm Richard, one of the developer advocates at Chainlink Labs. And in this tutorial, we'll be building a game on the goerly test network. This game will be a quiz where you can put answers and questions onto the blockchain, as well as funding them with a reward for a correct answer. Now, the answers will be hashed so that you can't just look into the contract and see what they are. So what exactly will this look like? We'll be building a very basic front end that will interact with our contracts. You can see here, I've already got one question in here that's funded with a little bit of ETH. You can submit an answer, or you can add more funds to this question if you'd like to.
00:00:45.626 - 00:01:17.400, Speaker A: You can also submit new questions and answers. So, as everyone should know, the ultimate question of life, the universe, and everything. The answer to that is clearly 42. We submit our answer, and you can see here that we will be able to submit it in just a moment. Once it's confirmed, you should see the value of this question will drop to zero. We won't be able to answer it anymore because it just kind of wouldn't make sense to answer questions with no reward. But our balance of ETH will have increased by just a little bit.
00:01:17.400 - 00:01:42.442, Speaker A: So let's take a look at what we will be using to build this game. The first thing you're going to need is some sort of wallet. I'll be using Metamask for this tutorial. You can find it at Metamask IO. Once you install it in your browser, you should have something that looks like this. Now, one thing to note, I'm on the go early test network. You can see here, I've got a bunch of different networks here.
00:01:42.442 - 00:02:12.440, Speaker A: You may or may not see these test networks. If you don't, we can take care of that. If you take a look up here and you go to settings and then under advanced and you scroll down, you should see an option to show test networks. This is where you can turn that on. If you turn this on, you will then be able to select the go early test network, which is what we'll be using for this. If you'd like to use one of the other test networks, you're free to do that. You'll just have to change a few things as you go along.
00:02:12.440 - 00:02:51.540, Speaker A: Besides Metamask, I'll be using visual studio code to do all of my code editing. Make sure if you want to follow along exactly that you get visual studio code, not visual studio. It's something completely different. Also, I have GitHub Copilot installed, so if you see some magic happening where code just kind of appears on my screen and I hit tab, that's what's going on. Sometimes that code is completely wrong too, so it may be fun to see what GitHub comes up with, but Copilot's pretty interesting. I've liked it so far, but that's what's going on. If you see kind of grayed out text appearing in my code editor, that's where it's coming from.
00:02:51.540 - 00:03:29.370, Speaker A: To develop these smart contracts, we'll be using solidity. That's the language for smart contract development that we'll be using within the ethereum ecosystem for EVM based chains. So you can find out more there at docs soliditylang.org. That's where you can find all the different documentation about solidity. To use solidity, we will also be using a framework on top of it called foundry. Foundry is kind of new on the scene, and I really enjoy it because it lets you write tests in solidity as well. Other tool sets like hard hat are fantastic.
00:03:29.370 - 00:04:10.886, Speaker A: I just like foundry a little bit more right now because I can write my tests in solidity, and so my brain stays kind of in the solidity ecosystem, if you will. So we'll be using foundry. It can be found@GitHub.com foundry rs foundry you can also take a look at the documentation at book gitfoundry sh this will give you all the information you need for installation, getting started, everything like that. But we'll also be walking through this as well. Finally, the last piece for the smart contract side of things that we will need is some way to access the blockchain to deploy our contracts, and I'll be using alchemy for that. This is a RPC endpoint is what I'll be using from alchemy.
00:04:10.886 - 00:04:44.166, Speaker A: They have a bunch of different products, but I'll be using their RPC endpoint as a way to access the blockchain and deploy our contract there. So we'll get to that after we've written the contracts, tested them, done all that fun stuff. Besides alchemy and foundry, we'll be using Svelkit for the front end. So if you head to Kit Svelte dev, you can find the instructions for installing it there. They're pretty minimal. We'll walk through this as well in setting up an application and getting it all connected. I will say right now this is focused more on functionality than front end design.
00:04:44.166 - 00:05:09.774, Speaker A: Look and feel. So I will leave that up to you to make this look good. I'm going to focus mostly on getting things connected, a little bit of CSS here and there, just so that things look okayish. But this is definitely not a front end development tutorial. This is more about getting things connected. I mentioned that we'll be using the Gorely testnet. Gorely net is where you can find information there.
00:05:09.774 - 00:05:38.694, Speaker A: Once you have it in your wallet, one thing that you may need is some testnet ETH, and you can get that from faucets chain link. When you connect your wallet here and you're connected to the go early network, you will see your wallet address populate. You can prove that you're not a robot. I'm sorry to all my robot friends out there. Evidently no test ETH for you, and you'll pick some things to prove that you know what a mountain or hill is. Probably be different for you. Once you hit submit, you'll get 0.1
00:05:38.694 - 00:06:15.090, Speaker A: testnet ETH, which will be plenty for the purposes of this tutorial. And finally, we have our own machine that we'll be doing this development on. So if you head to localhost 3000, nothing will be here yet. Hopefully, if something's here, you need to stop whatever that is because we'll be using that port for this tutorial. But you should see nothing currently. Once we get spellkit up and running in the second half of this tutorial, you will be able to see your website here running off your local machine. All right, so let's head back to book Gitfoundry sh and let's go ahead and install foundry.
00:06:15.090 - 00:07:01.054, Speaker A: If you head to the installation instructions, you can see here you'll need to run a curl command that will pull down a shell script and run it. Once you've done that, you'll need to run Foundry up. When you run foundry up, it should look something like this, and it'll download and install, and then you'll see that it's done. Once you have that, you should be able to continue on with initializing your first steps here. You should be able to continue on with initializing the project. So we'll use forge. Forge is one of the commands included with foundry, and we'll be using that to run a lot of things with Foundry.
00:07:01.054 - 00:07:33.610, Speaker A: So the first thing we do is Forge init, and we won't be doing hello, Foundry. We'll just call this something like Quiz game, so forge init and then the name of your project. So let's head back to the command line and do that. So forge init and we'll call this quiz game and this, actually, let's back up a minute. We'll call this quiz game, but let's make a directory called Quiz game. And we'll store both the front end and the smart contracts in here. So we'll keep them separate.
00:07:33.610 - 00:08:01.314, Speaker A: So we'll go into quiz game and from here now we'll run forge init and we'll just call this foundry. This will hold the files for our smart contract, so you'll see it initialized. DS test and forge project. Cool. What does that mean? If we take a look here, we now have a foundry directory. If we look within that directory, you can see we start to have a bunch of stuff. So let's go ahead and open up vs.
00:08:01.314 - 00:08:18.068, Speaker A: Code. I have a shortcut installed in my terminal here. If I type code and then a directory means this directory, it'll open up vs. Code. Cool. So we've got our quiz game folder and we have our foundry folder. Within foundry we have a few different things.
00:08:18.068 - 00:08:47.164, Speaker A: The first thing we have here is the source directory. This is where we'll be spending most of our time. They give you a basic contract and a basic test directory with a test for that contract. This is seriously the most basic of tests. It just checks to see if true is true. But what it does do is it allows you to see kind of the layout of how to set up a test in foundry. And this will be where we'll start.
00:08:47.164 - 00:09:17.716, Speaker A: We're going to be using test driven development, which means we'll be following this cycle of write a test, run the test, it's going to fail, fix the test so it passes, run the test again. It's going to pass. Sweet. Then you start over, you write a new test, you run the test, it fails, you fix the test so it passes and you run it again. And now it's passing. Awesome. So that kind of cycle of write a test, fix the test, write a new test is how we'll be doing our smart contract development.
00:09:17.716 - 00:09:54.260, Speaker A: This gives you the basics here where you have a setup function that will run before each test and then you have the different tests that you will be running within the contract. You can see here, this is also the most basic of contracts. It does nothing. But we will fix that in just a moment. Now, before we get going too far into this, there are a few things to know about foundry. We have a git ignore file. And when you split up into two different directories like this, if you're going to be storing this quiz game folder in GitHub.
00:09:54.260 - 00:10:34.736, Speaker A: You'll need to put a git ignore at the top level of that directory for git to know what it needs to ignore. In this case, you'd want to include these. You're also going to want to include any sort of environment, variables, anything like that. But for the purposes of this tutorial, let's go ahead and make that first change and we'll add git ignore to the top level. And we are just going to take what's in here and we're going to put it in here for now. So we're just kind of copying from the foundry version and putting it in the root of our project altogether. We'll do the same thing.
00:10:34.736 - 00:11:13.112, Speaker A: We'll add to this file when we initialize the Sveltekit repo, because they come with some pretty good defaults, and I'm not think this is a good way to start. Also, we may want to initialize this. So if we open up a terminal and we say git init, that'll just create an empty repository so we could track our changes if we wanted to. We can submit it to GitHub at this point. I'm going to leave that up to you to kind of do that, as that's slightly outside the scope of this tutorial. All right, so we have our basic set up here. We have in our source directory we have the tests.
00:11:13.112 - 00:11:36.528, Speaker A: So create a new file here called Quizgame t Soul. And we're just going to copy the examplecontract t soul. We'll copy it and put its contents in here for now. It's a good place to start. Like I mentioned, it kind of gives you the skeleton of a test in foundry. I'm going to change a couple of things. I'm going to change the version of solidity just to be a little bit more current version.
00:11:36.528 - 00:12:11.936, Speaker A: We can note that it imports dstest test sol. This contract is where all of our testing functionality is coming from, things like assert true, and it's giving us a little bit of an error right now, saying that it can't find it. But this is more of an issue with vs code and not foundry. It's not knowing how it's going to import it, but foundry and the forge command that we will use to run the tests know where this is. So it's okay. We have our contract, the contract name. Let's call this quiz game test.
00:12:11.936 - 00:12:30.950, Speaker A: It's of type ds test. We have our setup function, which we'll be filling out here in just a moment. And then we have our test example, and this will let us test it. So we've got this set up. I guess we could have just renamed this one. But let's go ahead and remove the sample. They gave us that contract t sol.
00:12:30.950 - 00:13:01.600, Speaker A: Okay, perfect. So at this point, if you go into your foundry directory, you should be able to run forge test. What this will do is it'll look in the test directory and run all the tests in there. And you can see that we have our test, it compiled our contract and it ran our contract. The test and test example passes. Fantastic. This lets us know that our test is set up and working correctly.
00:13:01.600 - 00:13:49.070, Speaker A: The next thing that we can do, before we get going too far into our test driven development cycle is let's go ahead and rename this contract from contract Sol to Quiz Game Sol. And we will call this contract quiz game. And we'll go ahead and change our version up here as well. Perfect. Now, within our test, we can go ahead and start testing actual things. Let's go ahead and do a couple of things. The first thing that we'll need to do is we will need to import our quiz game contract.
00:13:49.070 - 00:14:18.342, Speaker A: So import, because that's where it lives. It lives up one directory, Quizgame soul. Perfect. And at this point, everything should be passing as well. Awesome. So this means that our test can see our contract. Fantastic.
00:14:18.342 - 00:15:15.210, Speaker A: Now, traditionally, you'd think you want to start editing this test, but we're going to approach things slightly differently. We are going to have our first test actually be the setup. And the reason for that is we're creating a quiz game. And the way that this will work is we'll be supplying both a question and an answer. And the answer is going to be a hashed answer. So in order for all of our tests to run, we need to have a quiz created so we can do that in the setup because it kind of makes sense to create the quiz before we do things like testing to make sure that you can answer it and that when you answer it, you get paid out and stuff like that. So how do we do this? We want to create a question, and we also want to create an answer.
00:15:15.210 - 00:16:28.110, Speaker A: So we're going to create a question and the question is going to be, see, this is what I'm talking about with GitHub. It's very crazy. Some of the stuff that it comes up with, like, I have no idea where it's getting this capital of France business, but our question is going to be a string and we're going to store it in memory, we'll call it question and what is the answer to life, the universe, and everything? It's a great question. So we'll create that question, and then we need to create the answer. Now, you and I both know that the answer is 42, right? But we don't want to actually store that in our quiz game, because within a smart contract, everything is publicly available to be seen. So when we create this contract, we want to actually have already hashed the answer. How can we do that? Well, we can use an algorithm called Kekak 256, and that is a one way hashing algorithm.
00:16:28.110 - 00:16:49.462, Speaker A: So what that means is it will take our string and it will turn it into a hash. Any change to our string to our answer going in will change the hash. So it's a one way hashing algorithm. So it means you can only go in. Right. You can't ever say, take this hash and give me the answer. Okay, that seems secure.
00:16:49.462 - 00:17:41.974, Speaker A: How then would we approach it from a checking if we got the right answer? Because I can't unhash. Well, the way that we'll approach that is, when you answer a question, we will hash the answer and see if the two hashes match. There's a very secure way of keeping data hidden with one little caveat, too. We will do what's called salting our hash. What that means is we're going to add a little bit of text to the hash so that things like pre generated dictionaries, if you were to prehash tons of combinations, it would be very easy then to go backwards, right? Because you could know, I put in this value, and I get this hash. So now I can go backwards and say, well, this hash has to be this value. So in order to prevent that from happening, we will salt the hash.
00:17:41.974 - 00:18:15.480, Speaker A: Which means you could still create a dictionary, but you'd have to go through all those combinations. And it's kind of impossible to prevent that sort of brute force attack. But at least you can't have already done the work once and then just benefit from it. So that's the purpose of assault. So we'll need to create a salt, and then we'll combine that salt with our answer and hash those together, and that will create our hashed answer. So what does a salt look like? It can be anything you want. I'm just going to use something very simple.
00:18:15.480 - 00:19:08.006, Speaker A: We'll say equals, and it's a bytes 32, and then we're just going to say, 1231-2312 so just like that, it's a little salt. It's just some random characters, basically to add to our answer. So we'll take the salt and we'll take the answer, and then we're going to hash them together. So our hashed answer is going to be of the type bytes 32. We'll call it hashed answer. And then this is where we will use that keckec 256, and we will use Abi encode packed. What this does is this takes in the two values and packs them together so that we can then hash them.
00:19:08.006 - 00:20:03.348, Speaker A: So we'll take both of our salt and our answer, and this will give us our hashed answer. Now, you might be wondering at this point what all this stuff looks like, right? Something that's really cool about foundry and forge is that we can log out the different things that we're doing here via emits. So if we wanted to say, what does this hashed answer look like? We could say emits log bytes 32, I believe, hashed answer. And when we run forge test, it's not bytes 32. I think there's an underscore in there. Let's take a look at foundry documentation in here under DS test reference. You'll see it's a Mit log.
00:20:03.348 - 00:20:27.790, Speaker A: Yes, there's an underscore in there, underscore bytes 32. So it should be log underscore bytes 32, and we run forge test. You'll see that. You don't see it, right? So why is. Because we need to add some v's to this to increase the verbosity. So make it more verbose. And you can see here we have logs, and this is our hashed answer.
00:20:27.790 - 00:21:22.440, Speaker A: So in this case, this value here is the encoded value of 123-12-3123 plus 42. Pretty cool. So this is the value that we'll pass into our contract. Then, to create a secure answer that we can check later on, we've got our hashed answer. Now we need to create a new quiz game, right? So we'll need to instantiate an instance of this quiz game contract above. So we'll say game equals new quiz game. And this will need to pass in both the question and the hashed answer.
00:21:22.440 - 00:22:04.270, Speaker A: Copilot is trying to help there by telling us we need salt. And then we can do something like we could emits log game question just to see that we have our question so we can kind of keep track of it ourselves. While this isn't truly a test, it's just the setup. If this runs correctly, we know at least that we have a quiz game created. So at this point, if we give this a save and we try to run our tests again. We should enter the test driven development cycle of hey, something's wrong. And I've realized I forgot one other step as well.
00:22:04.270 - 00:22:48.658, Speaker A: This game, we need to define that outside of the setup. When you say quiz game, public game, just kind of telling us what game is. That's why we got two errors there. We should have only had an error about this new argument failing, and this one failing, because when we create our contract, the constructor doesn't take this many arguments. So let's go and fix the constructor for our quiz game. If we head back over to Quiz game Desol, back in the source directory, we'll need to do some very similar things. We will need to keep track of our.
00:22:48.658 - 00:23:11.050, Speaker A: Wow, what we got here? We got a lot of stuff. Question and hashed answer. I mean, it's trying to get there. Copilot's coming along. We will not be following that copilot, though. So the first thing we need to do is we need to have the same salt. So we need bytes 32, no spaces, and we'll say public salt equals.
00:23:11.050 - 00:23:40.862, Speaker A: And it was bytes 3212-312-3123 Again, this can be anything you want. When you change it, you're just making your answers. Once they're hashed slightly different. It's good. So we need this because we are going to need to hash the answer provided when somebody tries to answer this question. We'll need to hash it with the exact same data that's being used when we created the quiz. So we'll need to keep track of that salt.
00:23:40.862 - 00:24:18.184, Speaker A: We also can go ahead and say bytes 32, public hashed answer. So this is going to be that answer. We can say string, public question. So yes, GitHub, gopilot coming in clutch right there, doing what it needs to do. And then in our constructor, spelling is important. We'll take in a string memory question. I mean, this is it right here.
00:24:18.184 - 00:24:45.684, Speaker A: I'm going to hit tab and copilot is going to fill it in, but we're going to take in a string for the question, we'll take in a bytes 32 for the hashed answer, and we'll go ahead and store those two values in our public values that are stored within the contract. Fantastic. What's saying here is we can take this public off because we don't need that, even though copilot seemed to think we did. If we run our tests now. Awesome. So we see two things here in our logs. We see the hashed answer.
00:24:45.684 - 00:25:40.676, Speaker A: That's provided we also see the question. And if you remember, this question came from our actual game that we created. So we created a new contract, initialized it with our question and answer, and then we got the question back out. So just like that, we have our question and our answer being stored in a contract, and it's stored in a secure way, but it doesn't really do anything other than storing questions. Right. Let's take a look at what we need to do next in order to provide a guess to our questions in our quiz. So I think first I'm going to try guessing a number that I know should fail just to make sure that we aren't accidentally giving people correct answers for wrong answers.
00:25:40.676 - 00:26:14.320, Speaker A: So let's create a new function, and I'm getting rid of that test example function called test quiz fail. So this is a public function, and we will say that we want to game guess. So we're going to create a guess function and our guess, let's just. 42 is the right answer. Copilot, let's say one. One is our guess answer. Now, this is an interesting test because we know it's going to fail.
00:26:14.320 - 00:26:55.260, Speaker A: But in order for this test to pass, we need it to fail. How do we do that? Because traditionally we want to ensure things are positive are true. In this case, what that means is that we will need to use two terms called try and catch. So try means I want you to try to do something. If it succeeds, then we have a success path that we can go down. Catch is the oh no, something went wrong and it failed. But in this case, we know it should fail.
00:26:55.260 - 00:27:40.140, Speaker A: So we want to try game guess one inside here, and you can see copilot's trying to kind of give us an example of how it would normally approach these things. So, normally in here, this means that we succeeded. In our case, though, if I guess one and I know the answer is supposed to be 42 and this succeeds, that means something's wrong. So in our case here, I'm going to kind of say assert true false. So this should always fail. This basically means if it gets to this assert true, something went wrong. Outside of that, we'll say catch.
00:27:40.140 - 00:28:25.790, Speaker A: And this means there was an error, which means it's correct. We tried to guess a wrong number and it didn't pass, we're going to assert true true. So if we guess one and for some reason that's successful, and we know our answer is supposed to be 42, we're failing this test. Otherwise, we're going to pass this test, it seems kind of backwards, but it's because we're testing for failure. So when we run this, we should see an error again because we don't have a function called guess. So let's head back to our game contract, our quiz contract here, and let's make a new function and we'll call this function guess. So this will take a string call data.
00:28:25.790 - 00:29:10.996, Speaker A: We'll call it answer and it's public. That means anybody can call it inside of here. The first thing that we need to do is we need to check if our hashed answer is the same as a hashed version of the guess. So the answer they're passing in. So I'm going to do this with a require, and I think this may be a little bit nicer way to do this because they won't be able to call this function at all and waste gas on it if this doesn't pass. So what this is saying, and you can see copilot's got it going on. So it says keck act two, five, six Abi encode packed.
00:29:10.996 - 00:29:28.162, Speaker A: Does this look familiar? Abi encode pack. Salt answer. Let's check here. When we created this Cacac 256 Abi encodec. Salt answer. Oh, no, it went away. So Abi encode pack.
00:29:28.162 - 00:29:55.834, Speaker A: Salt answer equals equals. That's a double equals hashed answer. Remember, that's the value that was passed in and stored when we ran the constructor. And it'll give me an error or a complaint that it could be a view because we're not doing anything here. We can just ignore that for right now. We'll be doing more in just a moment. But at this point, if we rerun, our test should pass.
00:29:55.834 - 00:30:24.514, Speaker A: Sweet. So quiz fail passes. Awesome. That means if we guess the wrong answer, it doesn't let us go any further. Now, the next thing that we're going to do is we're going to use some cheat codes. I know you're thinking, I thought we were doing solidity, not playing a game. And what cheat codes do.
00:30:24.514 - 00:31:22.258, Speaker A: If we take a look back at the foundry book, you can see here there's a cheat codes reference. Cheat codes essentially let you manipulate the blockchain that you're testing on when you're running these tests in local blockchains like this. And what we specifically are going to do is we'll be using a function called deal that lets us actually manipulate the amount of ETH a given address has. So we can determine that ourselves. The reason why we're going to do this is if you remember, we're building out a quiz where the question holds some ETH and then based on a correct answer, that question contract. That quiz contract will then transfer that ETH to the person who answered it. In order to do that, you'll need to have that quiz contract hold a little bit of ETH.
00:31:22.258 - 00:32:02.310, Speaker A: And the way to do that within your tests is with the cheat codes. And the specific one again is deal. So we head back to our test. We'll need to create an interface outside of our contract and we'll call it cheat codes and then function. And the one that we want to use is called deal. And what this does is it needs to take in an address. So it's going to be the address that's going to receive the balance a UN 256 and we'll say it's external.
00:32:02.310 - 00:32:44.310, Speaker A: So then we'll be able to, within our contract, we'll be able to cheat the blockchain and tell the blockchain exactly how much a given address should have when it comes to its balance. All right, so how do we actually do this? How do we apply this within a test? So let's take a look here. Oh, we need one other thing. Just like we had here, we'll need to say cheat codes constant. Cheat constant cheats equals cheat codes. And then we'll say he VM address. This will just let us use cheats within our contract.
00:32:44.310 - 00:33:08.062, Speaker A: Head on back down to the bottom. We're going to make a new function and we're going to call it test quiz pass or test quiz success. I like pass. So function test, quiz pass. It's public, you kind of see GitHub copilot. It's coming in. And we need to do a few things.
00:33:08.062 - 00:33:47.078, Speaker A: We need to first track the balance of the address that we're running all of these tests from. So un 256, begin balance, address this, close that balance. So that'll get our balance at the beginning. We need to essentially fund the question, so cheats, deal. And then we need the address of the game contract. Right. We have our game contract that gets instantiated at the beginning of each test with our setup.
00:33:47.078 - 00:34:21.260, Speaker A: So it'll be game here instead of this address. No, we don't need address here. We're getting address of game. And let's go ahead and give it, I don't know, 10,000. Then we can go ahead and guess 42, which should be correct. And then we should see that our current balance is the same as our beginning balance plus that 10,000. So assert equal.
00:34:21.260 - 00:34:41.892, Speaker A: Yes, this balance, beginning balance, 10,000. So if we do that now, we should see that it fails. It's not equal. Sorry, it's Eq assert Eq. We run it. We should see we have a failed test. Just fails.
00:34:41.892 - 00:35:19.812, Speaker A: Why is that? It's because guess doesn't pay anything out. Now, when it comes to moving balances around and having payable contracts, it's always important to have two functions. We need a fallback function just in case there's no way to get funds in. And we also need a sieve function. These kind of determine what happens when funds come in. In this case, nothing happens. It just gives us a place for that to come in.
00:35:19.812 - 00:35:45.710, Speaker A: So we have these two. We'll add them really quickly to our actual contract as well. So just have those there. You can have different things happen within these functions. We might do that in a few minutes when it comes to events, but it's important to have them if you're going to have a contract that is receiving or sending. So we have our guess, and currently it doesn't do anything. It just requires that you guess the correct answer.
00:35:45.710 - 00:36:25.000, Speaker A: But we want to take the ETH that is stored within this contract and we want to send it to the guesser if they guessed correctly. So the first thing we need to say is, we need to say if this address has a balance, that means there's some sort of ETH in it, greater than zero. Then we want to send it to the message sender, the guesser. So payable? Payable. Sorry. Whoops. Message sender.
00:36:25.000 - 00:37:05.182, Speaker A: This will get us an address that we can send stuff to transfer. And we'll go ahead and transfer the entire balance of this contract to the message sender. Transfer. So just like that, our test should now be passing. Sweet. So what this does, if we go back to our test, we've taken a balance check of the test contract. We then magically created some value within the quiz contract.
00:37:05.182 - 00:37:46.330, Speaker A: We ran our guess, we gave it the correct guess, and then the balance of our test contract has now increased. Our quiz game is essentially done. We can create a quiz that we give a question to it. Anybody can see the question. We provide the ability to guess when you guess correctly. If the quiz contract has a balance, you then get that balance on the front end side of things. Events are fantastic and we want to create some events to let our front end watch for these events so it kind of update itself.
00:37:46.330 - 00:38:51.000, Speaker A: You can think of events as sort of like the logs within the blockchain space. So up here underneath question, we're going to create two new events. We're going to say an event quiz funded and we can go ahead and pass in the about that it was funded with and then event and I'll call it answer guest. We'll use this one, the quiz funded event, to inform our front end of whether or not it needs to update the ability to guess because you remember, we don't want people guessing if they can't win anything. And then this answer guest will use that to kind of turn off the question. If somebody gets the right answer, then we can check the balance again and turn it off if there's no balance. So both of these are fairly simple, especially this answer guest one, it doesn't require anything, but let's go ahead and within guests if we are going to transfer this eat out, let's go ahead and emit answer guest makes sense.
00:38:51.000 - 00:39:29.330, Speaker A: And then within both the fallback and receive, let's go ahead and just add emits quizfunded and not message value GitHub but address this balance. Yep. So we'll take this exact same line and we'll put it in here. So this way these events will be emitted when there is a transaction that funds this contract. This one will be emitted when the answer to the quiz is guessed. Sweet. So we have our quiz game contract is complete.
00:39:29.330 - 00:40:22.834, Speaker A: If we only ever wanted to make one quiz question, we could be done right now. But we'd like to be able to make multiple questions. And that means that we need to create a factory, a place that will crank out quiz games for us. Essentially what a factory does is it takes a contract and it basically just spits out contract after contract after contract. So as usual, let's go ahead and make a new test called Quizfactory T Sol within here, we will be taking basically the same stuff that we had within quiz game tests. So we can just copy this for now. I'll paste it in same stuff, except we don't need a lot of it.
00:40:22.834 - 00:40:39.880, Speaker A: So we don't need these cheat codes. We can clean that up. This is not a quiz game test. It is a quiz factory test. And go ahead and get rid of these. We'll empty out our setup. It probably would have been easier to start from scratch, to be honest.
00:40:39.880 - 00:41:10.180, Speaker A: And we'll go ahead and get rid of all of this. We'll just have our setup for now. All right, so we have the ability to import a quiz game, but we don't want a quiz game, do we? We want the Quiz factory. We have our contract quiz factory test. We need to declare the factory. So we'll say quiz factory, public factory. This way we can interact with the contract itself.
00:41:10.180 - 00:41:32.182, Speaker A: And within our setup we'll say factory equals new Quiz factory. That's it. That's the super basic test that let us know if we can import everything. You guys see, it's going to fail. Like, that's what the red squigglies are for there. But let's run it. And yeah, we don't have the quizfactory file, so let's create that under your source directory.
00:41:32.182 - 00:41:56.354, Speaker A: New file, quizfactory. So within here we have that SPDX license identifier. Sure. Unlicensed. We'll say this, but we won't comment it out. And then we need imports. So we'll need to.
00:41:56.354 - 00:42:40.330, Speaker A: In order to create quiz games, we need to import the quiz games contract. It's in this directory and it's called Quiz Game Sol. Our contract is called Quiz Factory and it has a constructor. This should let us pass our test so far. Sweet. This means that we have a basic test and everything is set up. Everything is working and running just fine.
00:42:40.330 - 00:43:26.390, Speaker A: Now from here, we will need to change our test file so that we can pass in the values to create a new quiz. And it's going to look a lot like what we did in our setup in the other test file. So what is this going to look like? Well, we're going to have a function and let's go and call it test. Create quiz doesn't take anything in public. And within here, we'll need to store the question, the answer, the salt man, GitHub, copilot, one tab. It's taking my job. The hashed answer.
00:43:26.390 - 00:44:00.920, Speaker A: We can go ahead and emit that hashed answer if we want, and then we'll say quiz. And let's just say quiz game, quiz or no, we don't want this yet. Okay, so we got our hashed answer. Now, once we have our hashed answer, we need to use that factory contract. Say create quiz seems like a logical name for the function to make a new quiz. We'll pass in the question and the hashed answer. Now, this is important.
00:44:00.920 - 00:44:49.720, Speaker A: When we're creating our quiz, we passed in the hashed answer. When we're running our quiz factory, we're passing in the hashed answer. While we are technically storing the hashed answer in this contract here for test purposes, when it comes to actually using this and our front end, we will hash it on the front end and we will transmit that hashed answer across. So we're not storing the unhashed answer anywhere in our contracts on the blockchain. One thing to remember, they are publicly readable, so we don't want to do that. All right, so we create a quiz. And then the way the factories normally work is they keep track of all the different things that they create.
00:44:49.720 - 00:45:22.370, Speaker A: Traditionally, in my mind, with this sort of scenario, we would create an array of quiz games. And within that array of quiz games, we'd have all of our different quiz games that we've created with this factory. So that means that there would be a quiz game. We'll call it quiz. And that's going to be from our factory, from the value of a variable named quizzes. And again, that's going to be an array. So we'll take the first quiz from quizzes.
00:45:22.370 - 00:45:54.058, Speaker A: We've got our quizzes. We take quiz zero. And then we need to check something about this quiz. I think probably the easiest thing to do is to check the questions are equal. That's kind of what it's providing here. But that's not going to work the way that GitHub copilot thinks it does. The way to compare strings in a test like this would be to hash them.
00:45:54.058 - 00:46:32.902, Speaker A: And then you compare those two hashed values. So we'll say Kekak 256, we'll say quiz question. And we'll compare that to the hashed version of the question that we're supplying when we create the quiz. So if these two hashes are the same, we're good to go. We've run our tests and we can see create quiz doesn't exist because we haven't added that function to our quiz factory. So within quiz factory, we need to do a few things. The first thing we need to do is we need to make a quiz game array public.
00:46:32.902 - 00:47:05.610, Speaker A: And we'll call it quizzes, probably also, it's a great idea. We already know about events. Let's just go ahead and make an event called Quiz created. And we can say what the index is. And we could also pass the address of the creator if we wanted. I don't even know if we need to do that. We can just say what index the quiz is.
00:47:05.610 - 00:47:38.358, Speaker A: I think that'll be enough for now. Got those two events. We will now create a function called create quiz. And yes, it's going to take in a question. And yes, it's going to take an answer. It's going to create a new quiz game called Question with the question and the answer. And it's going to push that quiz that it just created via that contract into this array.
00:47:38.358 - 00:48:03.826, Speaker A: And then it'll go ahead and emit that event. GitHub copilot got that one pretty correct. What is going on here? We need the word new in front of this. We need a new quiz game. This is going to then call the quiz game contract. If you remember, our constructor takes in a question and an answer. That's what we're doing, passing the question and the answer.
00:48:03.826 - 00:48:36.078, Speaker A: So just like that, we have created a basic factory. We run our tests again. Something is wrong here. What's it say? Invalid type. For argument and function call implicit conversion from a string memory to a bytes memory requested. Well, that's not going to work, is it? The reason for that is this question needs to be, both of them actually need to be Abi encoded, packed. So let's go ahead and do that.
00:48:36.078 - 00:49:03.760, Speaker A: Take that there. Take that there. And we'll say abi encode packed. And then we'll go to the end, put our little closing parentheses, give it a run. Again, still running into errors. Ebi encode packed. Man, spelling is huh in cod.
00:49:03.760 - 00:49:48.140, Speaker A: Sweet. Okay, we take our values and we assert that our question from the quiz that we just created is the same as the question from the expected value that we passed into the quiz that we just created. Awesome. At this point, we can create a quiz. Maybe it also would be useful to ensure that that array is working. So let's go ahead and say, function, test count quizzes. Q I z z es.
00:49:48.140 - 00:50:30.870, Speaker A: And from here we will essentially do the same thing that we did above, because we're going to create a quiz. So we'll go ahead and copy all this create quiz business and the values there. And then let's just go ahead and create two quizzes. Same question, same answer. It's okay. We'll say quiz game memory quizzes equals factory gitwizzes. This will create a new function to return the quizzes.
00:50:30.870 - 00:51:05.940, Speaker A: And we want to assert equal the quizzes length is two. So what this will do is actually give us the ability to return those quizzes, not just count them, but actually get all the quizzes. This will let us display them within the front end. And that way we can interact with the quizzes individually within the front end. So maybe this is more accurately labeled something else. But we're testing the count of quizzes returned. We save this, we should see again an error saying, hey, you don't have a get quizzes function.
00:51:05.940 - 00:51:27.900, Speaker A: Let's head back to our quiz factory contract and we'll say, function, get quizzes. And that returns basically the array of quizzes. Yeah. Think that's pretty good. Maybe this will work. Let's find out. It works.
00:51:27.900 - 00:52:16.506, Speaker A: All right, so with this function here of get quizzes, returning the quizzes for us, we now have the ability to get all of the quizzes and we can create quizzes. So we're good to go. Our contract's pretty much done. We now need to deploy our contract. And deploying with forge is fairly straightforward, but there's a few things to know. I'm going to create within the foundry folder a new file called Deploy Sh. This is what's going to be the contents of that.
00:52:16.506 - 00:52:56.440, Speaker A: All this is doing is a fancy way of allowing me to demonstrate to you forge create without sharing any of my private keys and that information. Also, if you would like to use this, it will be included in the GitHub repository that is linked. But essentially what it's doing is it's reading in your RPC endpoint. This is from alchemy that we talked about at the beginning of this video. It's also reading in the contract name. This read s makes it so that you don't see what you type. That's also good, because then you don't have things like your API key stored in your history.
00:52:56.440 - 00:53:32.290, Speaker A: It will then prompt you for your private key, for your metamask wallet. Never ever share your private key. It'll then deploy via that RPC URL and your private key, your contract to the network of your choice. So let's go ahead and give this a save, and then you can run this one of two ways. You could either type bash deploy and that'll run it. Or if you want to type, just deploy. It'll complain and tell you that you don't have permission.
00:53:32.290 - 00:54:19.940, Speaker A: You can change the mode shamad the permissions on that file just by doing Chmod U Plus X, that's adding execute permission to the user profile deploy. Now, if you run dish deploy, it'll run for you. All right, so we need a few things and I'm going to do them off screen, but I'll show you the results here. So if we head back to alchemy and we log in, you'll be able to create different RPC keys. This is the one I'll be using for Gurley. Once you click view key, that's going to be that private information that you shouldn't share. I'm going to pull that off onto a separate screen and I'll go ahead and grab that information now.
00:54:19.940 - 00:54:48.778, Speaker A: So I've copied that information. I'll head back to the output of that script so we run deployed sh. I will paste in that value. You won't see it because that's what that s does, but it stored it. Then it's asking, which contract do you want to deploy? We want to deploy our quiz factory. Once we deploy quiz factory, it will also deploy quiz game because it imports it. So we'll say quiz factory, give it a return.
00:54:48.778 - 00:55:22.268, Speaker A: You'll notice it compiles, and then it asks you for your private key. Now let me show you how to get this. Your private key will be under Metamask, and when you log in, you can click here, click account details and export your private key. It'll give you the value and you can copy and paste it in. So that's what I'll be doing again off screen. So go to my account details. I export private key.
00:55:22.268 - 00:55:59.040, Speaker A: It'll prompt you for your password again. Once you click confirm, it'll give you your private key. You paste that in, press return, and then I always like to copy something else into my copy buffer just to make sure that it's not my private key. All right, we paste in the private key, we hit return. You can see here we have the deployer. That's going to be my wallet address where it was deployed to. So this will be the address of the contract that we just deployed to the go early testnet and then the transaction hash.
00:55:59.040 - 00:56:38.488, Speaker A: If we were to take a look at the go early Testnet Explorer and take this contract address, let's go ahead and copy it, put it into the explorer. We should see our transaction here. Yep, and we have our contract creation. So this is that quiz factory contract on the go early test network. At this point, we're ready to build out the front end. So how do we do that? This is a great point to take a break if you need a break, before we dive in to the front end. All right, we're going to be building out the front end using Sveltekit.
00:56:38.488 - 00:57:17.076, Speaker A: I like it personally, just because it's very simple to explain and see what's going on. There's not a lot of background knowledge that's needed. There is a little bit of what I like to call svelte magic that happens, and we have available to us, we can talk through that as we get there. Personally, I just like it because it breaks down the application into some JavaScript code, plain HTML, with a little bit of that svelte magic sprinkled in, and then CSS. So let's go ahead and get started building out this application. You'll notice it's pretty straightforward. NPm init svelte, my app, you will need NPm installed.
00:57:17.076 - 00:57:49.106, Speaker A: If you don't have that, you can go ahead and install Npm. But once you have NPm installed, it's pretty straightforward. So we'll take this and we'll head back to. We can just do it straight here from our vs code from the shell here. If we go back up one directory to our quiz game folder, we do NPm init svelte and we'll just call this svelte. This will create a new directory for us. It's going to ask us a few things.
00:57:49.106 - 00:58:20.494, Speaker A: Do we want to install this package? Yes, sure. We're going to be using the skeleton project if you'd like to see more about how Sveltekit works. The demo app is fantastic, and it walks you through a lot of the different things that are available from a code standpoint within svelte, we'll be using the skeleton project. Let's not do any type checking just to keep things easy. But yes, let's do Eslint and prettier. And no, we're not going to be using browser testing. So at this point, you'll notice we have our foundry directory and we have our svelte directory.
00:58:20.494 - 00:58:41.420, Speaker A: Now, one thing to point out before we go too much further, this address here deployed to you will need that. So make sure you write that down. Copy paste it somewhere. Probably don't write it down. That's a lot to write. Keep this somewhere. Keeping it in the ether scan for the test network is fine, but we'll need that later.
00:58:41.420 - 00:59:18.818, Speaker A: All right, so once we've initialized our svelte folder, let's first take a look at the svelte git ignore. We'll go ahead and grab all of this, and we'll just add it straight on in to our git ignore. Give that a save, and we can go ahead and close both that and we can pretty much close everything else. So let's just go ahead and say close all. We'll go ahead and minimize the foundry folder for now. We'll need it in a minute. So we've got svelte inside source, we have routes and our index svelte.
00:59:18.818 - 00:59:52.316, Speaker A: This is the home page that you'll see once you follow these steps. So we need to literally just follow the steps that lays out CD svelte. Go ahead and run NPm install. We'll need to install one other thing, ethersjs that allows us to interact with the ethereum blockchain and the test networks. So we'll go ahead and install that too. So NPm install ethers. And then the next thing that it said after NPm install, we can do git in it if we want.
00:59:52.316 - 01:00:21.916, Speaker A: We need to skip this one because we've already initialized this git repository. The last thing is NPm run dev this open will actually pop it open in a browser. I'm just going to run dev without it and you'll see it's exposed localhost 3000. If we head to that URL, we should see welcome or welcome to spellkit. So I already have that open back here. Give this a refresh. Welcome to spellkit.
01:00:21.916 - 01:00:55.280, Speaker A: One thing that is great about Svelkit is it does this hot refresh business. So if I come to here and I say welcome to my quiz, I go ahead and delete the rest of this stuff, give it a save, look at the browser. Boom, it's already refreshed, ready to go. So you can see your changes in real time. If you've got two screens or you want to use like half of a screen, it's fantastic way to just kind of see all of your changes reflected in real time as you go. All right, so we've got svelte installed. It's up and running.
01:00:55.280 - 01:01:20.856, Speaker A: We can tell that because we have our changes showing here. Let's go ahead and just clean this up. We'll get rid of all these other tabs while we're at it. We have just our tab. Head back to here. So welcome to my quiz. What do we need to do now? Well, when we're talking about blockchains and looking at things on the blockchain, we need to connect to the blockchain.
01:01:20.856 - 01:02:00.600, Speaker A: We could use an RPC URL like what we used to deploy our contracts via alchemy. We can also use a wallet, which is probably better in this case because we're not going to be just looking at the blockchain, we need to be interacting with the blockchain. So we're going to want to go ahead and create a way to connect our wallet to the blockchain. So let's go ahead and do that. So the first thing we'll do, one thing to know about svelte is within the source directory. It's pretty common to create a lib directory and to have components live there. So create a new folder and we'll call it lib.
01:02:00.600 - 01:02:46.772, Speaker A: Within that lib directory, we'll create a new file and let's call it wallet connect svelte. So this component then will start off with just having a button and we'll say attach wallet. I like to kind of follow this method, similar to test driven development, but not with tests directly. When it comes to dealing with front end development, where I create like a very basic component, get it attached, and then I flesh out that component. So we create this basic component that just has a button that does nothing. For now, within index svelte, let's go ahead. And the first thing we'll do is we'll create a script tag inside of here.
01:02:46.772 - 01:03:30.870, Speaker A: We're going to import WalletConnect from. And now you could either say walletconnect or within svelte, there's this concept of dollar lib, and that always points back to this lib directory under source. No matter where you are in the hierarchy of files and folders, this will always point back up to this lib directory. So it's kind of a good practice and good to just kind of start doing that. So wallet connect svelte. So this imports that component, and then we can go ahead and use it. So we'll just say wallet connect here.
01:03:30.870 - 01:03:55.870, Speaker A: And if we head back to our browser, we should see this button that says attach wallet, and it does a whole bunch of nothing. Awesome. We've got our wallet. Let's make our wallet button do something. This one's going to be kind of a doozy all at once. So we head back to wallet connect within here. We're going to need a script tag as well.
01:03:55.870 - 01:04:47.190, Speaker A: Inside the script tag, we installed a package called ethers. Ethers is a way to connect to the blockchain. We're going to import it here. So import ethers from ethers. And then we're going to create an object that's going to be basically a set of properties for all of our web three stuff. Things like holding the provider, the signer, the account, what chain, we're on, the contract, everything like that. So we'll create a web three props variable, and we will then give it the provider, the signer, the network, and not network account.
01:04:47.190 - 01:05:21.380, Speaker A: That's what I said, right? Account. And we can go ahead and say chain ID for now. You'll notice when we save it, Svelte's doing a lot of stuff here with a new plugin and all this stuff, we can kind of minimize this for now. We can use this if we need to later. Remember, this is where the server is running from. So we have our web three props kind of initialized. Let's go ahead and make a function to connect our wallet to this oh, wow, that's a lot of stuff.
01:05:21.380 - 01:06:16.062, Speaker A: We are not going to be using that one. Sometimes GitHub cobilot is fantastic. Other times, man, I don't even know. So we're going to create an async function and we'll call it connect wallet. I don't know what that was. We'll call it connect wallet. And within this function, we need to say let provider equal new ethers providers web three provider window, Ethereum, any, and then we will await wait, provider send eat the request accounts.
01:06:16.062 - 01:07:02.382, Speaker A: So this is going to go ahead and say, hey, can I see the accounts? Can I go ahead and ask for your connection? Once we have that, we'll say Const signer equals provider get signer. So once we've gotten the provider, we'll go ahead and get that we need the account, which is going to be the address of the signer. And go ahead and get the chain ID. Const chain ID equals await signer Gitchainid. And then we can go ahead and take all these different values and we'll put them back into those web three props. Cool. So this is what it takes to actually connect your wallet.
01:07:02.382 - 01:07:35.766, Speaker A: So now with our button on click, we want to run connect wallet, right? So this point, this should get us all this information for our wallet connection. So we saved it. Let's head back to here, see what happens if we click attach wallet. It looks like nothing happens. Pretty sure, yeah, I've already given this address permission to connect to my wallet. So let's go ahead and disconnect. So it's not currently connected.
01:07:35.766 - 01:08:35.502, Speaker A: And now when we click attach wallet, it prompts us, hey, do you want to connect Metamask to this host? Sweet. So we say next and connects and we're connected. But how would we know? Well, if we head back to our index svelte, we can use a little bit of svelte magic here. So svelte lets us do things like this where we can say if we don't have a web three props account. So if we don't have an account, right, then we want to show the wallet connect button. Otherwise, else, let's go ahead and I don't know, what could we do? Just something fun like an emoji. If we have our account connected, we can show the wallet connect.
01:08:35.502 - 01:09:07.386, Speaker A: Otherwise, an emoji. But in order for this to work, we need this web three props to be passed around. So let's say export lets web three props equals see your provider signer account chain. Yes, sounds good. So we're kind of initializing it here with export in both of these places, it lets you pass it back and forth. But what we will do is to this component, we'll bind web three props. This says, any changes on this side, pass them through.
01:09:07.386 - 01:09:34.798, Speaker A: Same on this side. If web three props changes, pass them back. So now when we connect our wallet, we should see a nice little smiley face. So we attach our wallet, and boom, we've got our little smiley face. Dude, let's go ahead and look here. If we detach it, disconnected, disconnect this account, give this a refresh. So now we can attach our wallet, right? We say, no, don't attach.
01:09:34.798 - 01:10:05.900, Speaker A: Still have our button. We attach our wallets, connect it, get our happy little smiley face with shades. Sweet. At this point, we've connected to the wallet. In order to get access to things on blockchain, we can do one of two things at this point. We could go ahead and get the quizzes that we've already created, but we haven't created any because when we deployed our contract, we didn't create like a basic quiz. So probably we need to create a way to add a question.
01:10:05.900 - 01:10:55.600, Speaker A: So let's go into the lib directory, we'll make a new file, and we'll call it add question Seltz in here. We'll need to do much of the same stuff that we did with the web three props just to kind of pass that information around so that we can interact with the blockchain. So we need a script tag. Within the script tag, we'll go ahead and import ethers again. And we'll go ahead and export those web three props. One difference here, though, is we're going to need a contract as well. So once we're authenticated with the blockchain, and once we have all of this different stuff, like the signer, the account, we also need to grab the contract itself.
01:10:55.600 - 01:11:18.280, Speaker A: Then we'll use a little bit of svelte magic. Again, that dollar sign, colon. What that means is that this variable win, it changes. Go ahead and update it. Everywhere else it's used. It's a reactive variable. Again, it's asking me, what's the capital of France? Man, GitHub copilot wants to know that answer.
01:11:18.280 - 01:12:03.622, Speaker A: So we've got our question, our answer, and then we also need to kind of keep track of the hashed answer. So remember, when we create a quiz, we need to pass in the hashed answer. So we'll create an async function called hash answer, and we will say that we need to hash hashed answer. Whoops. Hashed answer equals ethers utils. Kekac. Yep, this is the same hashing algorithm that we used in solidity.
01:12:03.622 - 01:12:34.690, Speaker A: It's just ethers has it as well. And then the way that you pack stuff together here is a little bit different. So we used abi encode packed. What was it? Abi vim foundry. We used Abi encode packed. When it comes to ethers, it has a slightly different format. So it's ethers utils solidity hack.
01:12:34.690 - 01:13:15.300, Speaker A: This is going to do the same thing essentially, but we need to tell it what we're packing together. So it's a bytes 32 and a string. It's not a string string. So those are the two types that we're packing together. And then we'll go ahead and grab the ethers utils form format bytes 32 string. This is where that salt is coming from. 1231-2323 and then we also, yes, we need the answer.
01:13:15.300 - 01:14:08.364, Speaker A: So this is essentially the hashing and packing of the salt and the answer together. So once we do that, then we can use, and probably I guess either call this hash answer. We could just call this add question. Let's just call this add question because now we can say web threeprops contract, create quiz question and then hashed answer. Got those two things. Now we'll need this contract and we'll update that. We need the contract and we'll update that here in just a moment.
01:14:08.364 - 01:15:14.940, Speaker A: Let's go ahead and build out this component real quick. So we have a div, I'm thinking that we're going to have like kind of a box around it like we saw and a few things there. So we have a div, we'll call it wrapper and within that we can go ahead and have a span of input label and this will say question and then inputs. And the type is going to be text, but I don't know that we really need that. We need an input and we'll say bind this value to question. Then we'll have the answer. And yes, we'll bind the inputs to answer and a button on click.
01:15:14.940 - 01:15:51.510, Speaker A: Evidently I misspelled the word question I'm seeing now. Q E S T I N. So when we click add question, it will run our add question function. Cool, seems good. We can go ahead and add just a little bit of style to this if we want and add our wrapper function or, sorry, wrapper class down here and overflow. It's hidden. There's a few things.
01:15:51.510 - 01:16:31.216, Speaker A: Make it look okay. Not fantastic. Rim give it a little bit of padding, 20 pixels, give it a little bit of a border radius, 15 pixels, give it a width. Again, this is all just make it look okay. Feel free to do what you like with this. Grab a box shadow, add it to it. Cool.
01:16:31.216 - 01:17:15.912, Speaker A: And then we'll go ahead and say input label display, inline block and we'll say width equals shared, 200 pixels. Why not? Let's give this a save and see how this looks. So we've created this. We need to now add add question to our thing. Instead of a smiley face, we could just have add question and bind web three props. Sweet. Also need to import it.
01:17:15.912 - 01:17:49.988, Speaker A: So here add question. And if we head back here, if this happens, go ahead and give the server a restart and refresh your page. Sometimes that'll fix it. What's it complaining about? I have boo boos in here. We have mistakes. Mistakes have been made. So Div, div button, input span, input this.
01:17:49.988 - 01:18:31.654, Speaker A: What's happening right here? Oh, these need to be self closing. Okay, we attach our wallet and now we see question and answer. Cool. We have our add question button. We click this. Nothing happens because we have not added our contract yet. So if we head back to our index spelt within this, we need to do a few things.
01:18:31.654 - 01:19:05.160, Speaker A: We need to add the contract to a few places. We need the address of the contract. We're going to need the AVI from the contract that will let svelte and ethers know how to interact with the contract. So the way to do this is within source directory. Let's go ahead and add a new folder called contracts and whoops. Not this source directory, this source directory. But it's always dangerous to have this foundry folder open when you're not messing with foundry.
01:19:05.160 - 01:19:39.190, Speaker A: So we have contracts here, but we do need to go back to foundry. So within foundry we have an output directory. When we deployed our contract, it compiled everything. And in here, inside Quizfactory is a json file. We need to copy this and add it to our contracts directory. We also need to copy quiz game because we'll need it later. So this json file, copy it and we'll add it to our contracts directory as well.
01:19:39.190 - 01:20:18.050, Speaker A: We'll get to that one in just a minute. But right now we're going to be using quiz factory. So let's go ahead and minimize down the foundry folder again, just so we don't get confused with source directories. We edit our two files to our source contracts under Svelte and you can take a look at what's in here. The one thing to know is it's at the top of this json object is an ABI and we'll be using that. It basically describes what you can do with the contract. So within our index svelte, we need to import a few things.
01:20:18.050 - 01:20:51.230, Speaker A: So probably the best place is just up here under add question. We need to import contract Abi. That's going to be the Abi for the contract from. And this is located in contracts and this one is quizfactory. So at the top level, we're concerned about the quiz factory when it comes to the individual quizzes. That's where we'll be using the quiz Abi itself. And the other thing that we need is we need a constant called contract address.
01:20:51.230 - 01:21:28.520, Speaker A: Maybe not address Adar. And that will be the value of the contract that you deployed. Remember we mentioned saving it down here also we had it on the explorer. It's this address here. Yours should be different. So we need this contract Abi and the contract address. Once we have those two things, we can then pass them to wallet connect.
01:21:28.520 - 01:22:14.370, Speaker A: So we'll pass them in as two separate values to wallet connect. So that when we connect our wallet, we can interact with those things as well. You'll see why in just a moment. So contract address and contract Abi. Those get passed into the wallet connect components within here. We then need to export, export. Let contract address equal nothing and say export contract Abi.
01:22:14.370 - 01:22:45.440, Speaker A: This is not going to be a string, though. This is going to be a object with an ABI in it that's null. Just kind of do that for now. Once we have these two values and we do these things like getting the signer, the account, all that stuff, the provider, we can now say const. Contract equals. It's new ethers. Contract, contract address.
01:22:45.440 - 01:23:24.220, Speaker A: Get the contract Abi, use the signer. This lets us say, here's the contract we're going to be interacting with. And here is the person that we'll be using the account that we'll be using to interact with it. We also need to add a contract here to our web three props as well as up here to our web three props. So we've added contract here, we've added contract here and we've got the contract defined. At this point, we connect our wallet. We'll go ahead and set up the contract for the quiz factory as well.
01:23:24.220 - 01:24:11.690, Speaker A: Then when it comes to adding question, you can see we pass in, we expect to have the contract pass in and then we can create the quiz. Everything is saved. Head back here, attach our wallet and now, if we say, what is the answer is 42, we say add question. Now we're actually interacting with the contract we deployed and when we confirm, we'll actually create a new quiz on the blockchain. That's pretty cool. So we've got our question, we've got our answer, we've got our new quiz created, but we can't see it. We need to create a component to display all of our quizzes.
01:24:11.690 - 01:24:37.166, Speaker A: All right, let's go and do that. We're getting close. So we're making a new component. We're going to put it in the lib folder, we're going to call it question svelte. We're going to be using the same component over and over and over to display all of our questions. But first we need to display one question. The first thing we need is we need a script tag.
01:24:37.166 - 01:25:20.062, Speaker A: And within this script we're going to import ethers. And we also need to do a few things because we are going to be using the other contract now. Right. Our first contract was to use the quiz factory to create quizzes, whereas this time we're going to be using the quiz contract, the quiz game contract, to display quizzes. So we need to import contract Abi from our. Nope, not our quiz factory, but our quiz game JSON. So under contracts we have quizfactory and quiz game.
01:25:20.062 - 01:25:45.570, Speaker A: We'll be using this one. And this is going to look a lot the same as what we had before. So let answer equal null. Let question equal null. Export. Let web three props equal. Yeah, it's going to be all that same stuff, export.
01:25:45.570 - 01:26:38.600, Speaker A: Let question address equal null. We'll be passing in the question address so the factory can return a list of quizzes, remember? So we'll be passing in the question address. We can say that question is null and we can say that the value is null. It's going to be the value for it. We can also keep track of if it's funded or not. And you may think, well, if the value is greater than zero, then it's funded, right? Pretty much, yeah. But we can actually, instead of just having it be true or false, we can use this to set a class for CSS because it will update, it's a reactive variable.
01:26:38.600 - 01:27:16.068, Speaker A: We can actually say funded equals and then value. The one above that we just calculated, is it greater than zero? If it is, then question funded. Otherwise question not funded. So we can kind of use that value to inform our CSS in a minute. Let the question contract equal null. So this is going to be the contract for the question itself. So we'll pass in the question.
01:27:16.068 - 01:27:31.450, Speaker A: We'll pass in the value. Looking at this, too, I see that we have question twice. So we don't need to do this. We can get rid of this question up here. And we now need to actually get this question. And we'll pass in the contract address. And we're also going to be passing in.
01:27:31.450 - 01:28:06.548, Speaker A: We have here imported the contract Abi. So given the address of the actual quiz game contract that the quiz factory created, we should be able to get all the things like the question, the funding value, all that stuff. So let's go ahead and do that now. So async function get question. And what we'll do here is we're going to say, yes, it's going to be this new ethers contract. It's going to be the question address, the contract Abi and then the web three prop signer. So this could be confusing because we have a contract here.
01:28:06.548 - 01:28:29.790, Speaker A: We don't really want to use that. I'm just storing it because it's passed in with web three props. But we're using a separate instance of the ABI in the contract itself. So that looks good. We're going to say let question equal awaits and then we'll get question. That doesn't look quite right, though, does it? Because it's not get question. When we built this, it was just question.
01:28:29.790 - 01:29:17.196, Speaker A: We built out our contract because we don't have a function to return it directly, but because it's a public variable, we can actually get it back. And then that doesn't actually need a let either, because we want to use this question that we defined out here. So we have our question set up next. We need to get the value of answering it correctly. So value equals awaits or no, what value would be a number? And when we're looking at the value of this contract, it's going to be not formatted in ether. So we need to do that. It'll come back as a big number, I believe is the type that it comes back as.
01:29:17.196 - 01:30:05.442, Speaker A: So we'll need to actually go ahead and convert that into a number that we can display and understand easily. So, ethers utils format ether awaits. And it's web three props provider get balance of question address. Let me make this smaller just so we can kind of see everything that's going on here. So we have our value after value. We'll need to go ahead and get the event listeners set up right. So if the question is answered or funded, remember we had those two events.
01:30:05.442 - 01:30:43.854, Speaker A: So if the question is answered or the question is funded, we should go ahead and set up some listeners for that. So that's where qcontract the questioncontract on. And then we're listening to quiz funded. That gave us a balance back. It returned a balance in there, I believe. So if that happens, then we will say that our value equals yes. We don't need to reset this here because that's a reactive variable.
01:30:43.854 - 01:31:27.980, Speaker A: So anytime value changes, funded changes too. What's going on here? Too many closing curlies and parins. And then we also need to set up another listener to the question, contract on. And we'll say quiz or answer guest. Answer guest. If the answer is guest, then we can go ahead and say run get question again. Because if it's guessed, we need to check and see is it funded? All that fun stuff.
01:31:27.980 - 01:32:07.530, Speaker A: Cool. This will get our question. We're also going to need a function to submit a guess, right? That one's pretty simple. It's a async function. Submits, guess, submit, guess. And basically we will just say await q contract, question, contract, guess, and we'll submit our answer. Seems pretty straightforward.
01:32:07.530 - 01:32:53.370, Speaker A: Seems pretty straightforward. And lastly, the last thing that we need to do with our contract is we need to fund our contract if we don't already have some funds stored in there. Async function fund. And this will say that we need to say web threeprops signer. This is the person who is authenticated through attaching their wallet send transaction. So this transaction will say our two is our question address. The value is going to be parse ether, but not one, not one whole ether.
01:32:53.370 - 01:33:39.670, Speaker A: Let's just say funding, which is a value that we need to add up here. So we can just add it underneath this funding equals zero. So pass in funding. And once we run that, we add that to it, we can go ahead and say funding equals zero afterwards, right? So we can just kind of clear it out or do you want to say zero null? I like null better. I'll just empty it out. So fund our contract. And then finally the last thing that we need to do outside here is we need to run getquestioned.
01:33:39.670 - 01:34:14.130, Speaker A: This will just force this first function to run when this component is loaded. Cool. That was a lot. There's a lot of stuff up here, but let's put it to use. So we need a div. And this div is going to have a class equal to funded. Remember, this is the value either question funded or question not funded.
01:34:14.130 - 01:34:33.554, Speaker A: Based on that, we can change things like the background color. So we'll have that div. And then let's go ahead and give it another class two called qwap for question wrap. Don't try to read that as a word. And then we have. Let's see here. Let's see what GitHub's got for us.
01:34:33.554 - 01:34:53.902, Speaker A: So div class question. I like that. So around the question we'll have its own div. We have the question value h one maybe a bit much, but it's okay. And then we've got a lot of stuff here. I'm not going to go with this, but let's go ahead and say div question. So div of class question.
01:34:53.902 - 01:35:21.000, Speaker A: And within that we'll add the question. Seems good. Next we'll have a div value and within that we'll have the value. And it's an ETH. Cool, I like that. Then we'll have an input type of text and we'll say this is bind to the value answer. So bind that to the answer value.
01:35:21.000 - 01:35:47.470, Speaker A: We'll add a button on click. Submit guess. Seems good. Submit answer. And also we need one other thing here, disabled. So we'll disable this button because we don't want to be able to guess unless the value of the question is greater than or equal to zero. So if the value is more than zero, this is not disabled.
01:35:47.470 - 01:36:06.982, Speaker A: Sorry, less than equal to, I said greater than value is less than or equal to zero. Then we can submit our answer. Cool. Don't fear the line breaks. Input type text bind to value funding. Yep. And then a button fund question fund.
01:36:06.982 - 01:36:39.280, Speaker A: But we'll get rid of this disabled. These are type of things that like GitHub copilot is so close sometimes so far, awesome. So we've got all this stuff set up. Looks pretty good to me. Let's add some style here. And we need first question funded. We'll say the background is going to be, I don't know, colors are fun but we'll just say four ee or four e.
01:36:39.280 - 01:37:08.860, Speaker A: So kind of a green color question, not funded. So this is where this comes in, right? So we have this class of funded and based on the funding we can change what the question looks like and it'll be reactive. So it'll change on its own based on those events. I don't know. I think it's pretty cool. I think spelt is great because it makes it kind of easy to understand what's going on in my opinion, and see that it also gives you the reactivity, which is cool. So background here.
01:37:08.860 - 01:37:33.150, Speaker A: What's a good kind of pinky color? We have FFB six c. One just sort of a pink and a green. That seems good. The Q for question wrap stuff that goes around the question overflow. Hidden. Sure. Position relative.
01:37:33.150 - 01:37:43.126, Speaker A: Sure. So far I like those two. Margin, bottom one rim. Sure. Padding. 20 pixels. Yeah, all this looks good.
01:37:43.126 - 01:37:59.660, Speaker A: Maybe make it a little bit wider. 1114. Sure. Give it a little drop shadow. Seems good. Yeah, do that. And then we need one last thing for the question.
01:37:59.660 - 01:38:28.030, Speaker A: And let's just go ahead and say our font size is two rem just because. Make it easy to see. Got our question. Let's go ahead and add it. To index svelte, we need to import question, question from dollar. Lib question svelte. So we'll import it.
01:38:28.030 - 01:38:58.354, Speaker A: And then at this point we should just be able to say add question. And underneath add question, we can say question and we'll bind the web. Three props. I think that's probably good. Let's check it out. Attach our wallet, and we've got this. So that is showing null and null because we aren't actually passing in any of the question addresses.
01:38:58.354 - 01:39:26.298, Speaker A: Right. So we're not actually getting these things. So next we need to create a component to cycle over all of the questions. So this is what one question will look like. Just kind of the one thing here. Let's go ahead and create one more component. The last component that will cycle over all of the questions, making a new component.
01:39:26.298 - 01:39:46.194, Speaker A: That's right. The lib folder. All questions dusfelt inside all questions dust felt. You've got a script tag. Inside that script tag. We need to import question from. See, this is where it's nice.
01:39:46.194 - 01:39:59.514, Speaker A: It could be dot slash, but we don't care. It's in lib question felt. Going to do this here. And let's go ahead and just do all questions. Right. Basic setup here. Back here.
01:39:59.514 - 01:40:33.300, Speaker A: Let's change this to all questions. Let's change both of these to all questions. Save that and take a look here. Touch wallet. All questions so we know it's going to show up there. Okay. Within all questions, we need to do the usual suspects of stuff of like saying export let web three props.
01:40:33.300 - 01:41:00.740, Speaker A: Yes. And we need all those things. Then we need to say questions. We'll go ahead and say this is null for now. And then this needs a colon. Not there, there. So we say our questions, and then we'll go ahead and write a function sync with an N function called get questions.
01:41:00.740 - 01:41:52.210, Speaker A: And that will say questions equals await web three props. Contract gitwizzes. Right. So this is referencing back to thin foundry in our source from our quiz factory. Git quizzes say all questions. So the questions are git quizzes. We'll also say web threeprops, contract on quiz created address.
01:41:52.210 - 01:42:32.270, Speaker A: It logs the address of the quiz. Then we can just say get questions again. And outside of this, we'll run get questions. So this will say all of our questions. From here, we'll need to do another little bit of svelte magic. So we say if we have questions, questions, quizzes, quizzes, questions. And close our if just to keep it nice, tidy.
01:42:32.270 - 01:43:03.660, Speaker A: So if we have questions, let's create a div and we'll call it qwap. Same thing, question wrapper. Then we'll do a little bit more svelte magic. And yes, this is it here. Each questions as question. We'll say question we need to pass in the web three props. And so we're going to say question address.
01:43:03.660 - 01:43:32.582, Speaker A: Right? So we need to pass in the question address. And maybe a better thing to call this is question address, because that's really what it is. It's the address of the question. So we'll pass in question question address, and we'll also pass in web three props. So for each of the addresses that are returned here, we're going to loop through them. We're going to pass them in to this. Let's add a little bit of style just to make things look so.
01:43:32.582 - 01:44:01.854, Speaker A: So and, okay, so question wrapper display. We'll say it's flex. Say flex direction is a column. Go ahead and say justify content center and align items center. Give that a save. Come back over here. We'll attach our wallet and.
01:44:01.854 - 01:44:43.990, Speaker A: What's going on? Why are we got null still? Maybe there's an error. So it says no matching event. Argument value quiz funded inside of our contracts. Let's go back real quick and look at our events here. So in quiz game, we have quiz funded. So it's saying that in question svelte, there was no quiz funded. Fund is not defined.
01:44:43.990 - 01:45:29.540, Speaker A: Submit guess is not defined. What is going on is going on. Submit guess is not defined. So within question, have our button. Submit guess. Did I just typo something? Oh, got a problem with closing brackets here. So this one should go here.
01:45:29.540 - 01:45:42.870, Speaker A: So get question is its own function. Submit guesses its function. Fund is a function. Let's reload this and see what happens now. There we go. Man. Closing brackets.
01:45:42.870 - 01:46:02.170, Speaker A: So what that was is this closing bracket was wrapping up all of these functions as well. So they weren't kind of top level functions. So what is the answer? We know the answer is 42 because we made this. But we haven't funded this question. So we say we want to fund this question with zero one. Fund the question. You'll see here, it's going to transfer.
01:46:02.170 - 01:46:26.934, Speaker A: Zero one confirm. We'll wait just a moment. You can see here that's pending practice twiddling our thumbs, depending on how things are going. Maybe go make some coffee. But it shouldn't take too long. Okay, so the contract interaction happened. Just a moment here.
01:46:26.934 - 01:46:46.730, Speaker A: You should see that. This should update. No matching event, quiz funded. Sure about that? Let's go ahead and refresh. Attach our wallet. Okay, so that's there. No matching event, quiz funded.
01:46:46.730 - 01:47:22.170, Speaker A: Still not liking this. What is going on? So we've got create quiz. If we look at quiz game, quiz funded is an event. It should be spit out for that. The quiz contract is quiz game contract. Abi Q contract Q contract on answer guessed and quiz funded should be working. Let's try guessing an answer and seeing what happens with errors here.
01:47:22.170 - 01:48:14.680, Speaker A: Confirm our answer. Give it a moment. Looks like our listening to the events may not be working as expected. Got a slight problem somewhere. I'll probably leave this in though, because troubleshooting is also a key, key part. So let's give it a moment and see. Feeling like it's probably not listening correctly.
01:48:14.680 - 01:48:46.020, Speaker A: Yes. If I refresh, it's back to zero. Okay, so no matching events arguments, quiz funded. So queue contract, the question address. Right, that's what we got going here. So let's go ahead and do some things here. Let's say console log and question address just to check to see that we're getting that.
01:48:46.020 - 01:49:49.490, Speaker A: Okay, we can see that up here, right, that's probably a little tiny, but we have our question address up here. That's where we're getting our question from. So like this, what is the answers coming from there? So we've got that now, this is going to be a quiz game. And a quiz game has an event, quiz funded, quiz funded. So if we go back to question, we say on Quiz funded, it's complaining about this not being there. So if we comment this out and we clear this refresh, connect our wallet answer guest. So it's having a problem with both of these.
01:49:49.490 - 01:50:27.258, Speaker A: So it's a queue contract. If we take a look at our contracts, we have quiz game inputs, bytecode. If we look for funded. Nope, it's not there. What if we come back here to quiz factory and we look for created. Okay, so you see here we have this name type event. So come back to Quiz game.
01:50:27.258 - 01:51:17.380, Speaker A: And we look for event. Are no events inside quiz game. Interesting. Wondering if we added those and didn't compile it when we built it, it should have compiled it. So output quiz game. Json, there's nothing there. Let's take a look back in and perhaps let's go back up to foundry.
01:51:17.380 - 01:51:41.210, Speaker A: We'll say, forge, build. No files changed, compilation skipped. Come to quiz game, just say answer correct. We'll add a new event to this. Build it. Okay, so it compiled it there we have three events. Now if we take a look here.
01:51:41.210 - 01:52:17.884, Speaker A: Now we have events, it's interesting it wasn't picking up the events before. Curious if it's actually going to emit these events now. So let's take a look. If we remove this, because we just had these two, we run forge build again. Oh, interesting. Even though we removed it, it's saying that there was no files changed. There should be a way to force this compilation.
01:52:17.884 - 01:52:47.850, Speaker A: This is an interesting little issue. Haven't seen this before. So foundry book, go to. Where would this be? Tests. Gas tracking debugger. Wouldn't be tests. The advanced testing.
01:52:47.850 - 01:53:01.540, Speaker A: We'll just search for. Build forge commands. Build commands. Forge, build. Forge. Build. Build modes.
01:53:01.540 - 01:53:24.860, Speaker A: Optimizer artifacts. Watch mode. There's a force force. Clear the cache and recompile. So forge, build force. Okay, that should have forced it to build it. And now there are two events.
01:53:24.860 - 01:54:06.872, Speaker A: Interesting. Very interesting. I'm going to delete quiz game from our svelte contracts. Paste in this new one, save it. Come back to question svelte uncomment this because now this error was coming because within the json file, that's describing what the contract can do. There was no quiz funded or answer guest event. So now if we reload this, I stopped it running.
01:54:06.872 - 01:54:43.240, Speaker A: So back to felt and say NPM. Run dev refresh. Okay. Attach wallet. Okay, so we can see here, I'm curious if I fund this with zero one again, if 00:51 should go to zero four. Curious if this will update or not. It may have not compiled it with those events when it deployed it as well.
01:54:43.240 - 01:54:59.738, Speaker A: So it's zero four. Okay, so the events are there. That's very interesting. I've never seen forge do that before where it doesn't actually change the json file as you can see. It updated it there. And if we say that the answer is 42. Well, first let's try an incorrect answer.
01:54:59.738 - 01:55:25.990, Speaker A: See, it doesn't even let me submit and it gives you this error. And this error is because it checks that require before it actually tries to run the function for us. It's kind of a nice thing for metamask to do, but I think it works pretty well. So it's not one, it's 42. Maybe you could game it by just guessing all the random numbers and brute forcing it here. I don't know. You could check that require and make it an if instead.
01:55:25.990 - 01:56:13.256, Speaker A: So it actually costs gas to guess. So once we guess correctly and we click confirm, give it just a moment here. We should see this update as well. Awesome. So our value is now zero, and our value here has increased. So just like that, we have taken a full stack application gone from smart contract all the way through to front end web application. Again, it's not the the best looking application, but it's fully functional.
01:56:13.256 - 01:56:27.150, Speaker A: You can build it out from here, make it prettier if you like. Add questions, add answers. It's all hashed on the blockchain and exists 100% on the blockchain. So thanks for watching and I'll catch you in the next one.
