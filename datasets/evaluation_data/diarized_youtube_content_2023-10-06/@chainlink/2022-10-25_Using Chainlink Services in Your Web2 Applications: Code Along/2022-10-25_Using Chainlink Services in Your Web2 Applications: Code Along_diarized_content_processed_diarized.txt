00:00:04.010 - 00:00:34.530, Speaker A: What is going on? We are going to go live here in just a little bit as we wait for people to join the live stream. But while we wait, I'm Richard, one of the developer advocates here at Chainlink Labs, and we also have Zubin as well. He's another developer advocate. You have complete golobal cover bridge, as we have Australia and the so, you know, total chain link labs. Global domination is occurring in this live stream. Indeed.
00:00:34.690 - 00:00:48.534, Speaker B: That is pretty cool because you're in the western hemisphere and the northern hemisphere. I'm in the eastern hemisphere and the southern hemisphere. Like, we literally have it covered. It's pretty cool. It's pretty cool. And you guys are heading into. I know it's called the spring hackathon.
00:00:48.534 - 00:00:54.510, Speaker B: Sorry, the fall hackathon. But for me, it's spring. See, GM. GM.
00:00:55.890 - 00:00:58.958, Speaker A: It was just time zones that are hard. But no, it's seasons, too.
00:00:59.044 - 00:01:03.490, Speaker B: Everything's hard. Yep. And the night sky is upside down. All of that GM guys.
00:01:03.560 - 00:01:03.842, Speaker A: Hello.
00:01:03.896 - 00:01:06.260, Speaker B: Where's everyone from? Lucas and John, where are you guys?
00:01:16.310 - 00:01:27.560, Speaker A: So, yeah, we've got pretty cool, I think, code along. Walk through some code together along. Coming up. I think that'll be good.
00:01:27.930 - 00:01:29.158, Speaker B: It'll be fun.
00:01:29.324 - 00:01:31.720, Speaker A: New York is Canada. That's right.
00:01:34.090 - 00:01:35.954, Speaker B: So far, it's four in the morning.
00:01:36.012 - 00:01:36.186, Speaker A: Yeah.
00:01:36.208 - 00:01:40.970, Speaker B: I don't think I'm going to win this at all. There's no way I'm going to win this in the eastern hemisphere.
00:01:43.550 - 00:01:44.662, Speaker A: Germany, Sweden.
00:01:44.726 - 00:01:58.750, Speaker B: Okay, nice. Very cool. Germany, Sweden, east coast. Hey, again, Darb. Nice to see you, man. Very nice.
00:02:00.960 - 00:02:09.424, Speaker A: Just for everybody here. I don't know if I should do this or not, but here's the code that we'll be going through if you want to kind of play along.
00:02:09.622 - 00:02:11.170, Speaker B: I'm going to put that up.
00:02:13.220 - 00:02:39.130, Speaker A: That's the repo that has all the code in it. We'll walk through it, explain it. It's a svelte kit front end to kind of talk through how to use web3 stuff in a more web two centric way. So, yeah, I think we'll give maybe another minute or two, and then we'll get going. Like a few more people are joining in. It's always the worst when you come for the live stream and you're, like, five minutes behind, you're like, oh, what did I miss?
00:02:39.900 - 00:02:46.030, Speaker B: Just miss the introductions. Don't worry. We'll go through them again, let you know who's talking to you today.
00:02:46.640 - 00:02:53.436, Speaker A: I'll wait till I can see one more viewer pop in and be like, and that's how you do everything. So that was an awesome talk, Zubin. We're just about to.
00:02:53.458 - 00:02:54.180, Speaker B: Thanks for joining.
00:02:54.280 - 00:03:27.690, Speaker A: Just joking. Just joking. So, yeah, real quick, what we'll be walking through today is how to incorporate price feeds, automation and randomness, vrf into a web two front end. The first two you can actually do without having to have your users do any sort of wallet connection or anything like that. VRF. Unfortunately, you do have to kind of blur the line between web two and web3 together to get that.
00:03:30.540 - 00:03:39.676, Speaker B: So, Richard, question for you on that. Just connecting a wallet, you think that makes something a web3 thing just because it's using cryptography or what's your analysis on that?
00:03:39.858 - 00:04:10.932, Speaker A: I would say if you have to have a wallet, then you've entered into the realm of web3 personally. Got you at that point. Yeah, that makes sense. Yeah. Let's go ahead and I'll share my screen if you all let me know in the chat if sizes of text and everything are good. I'm always slightly dubious with multiple things happening on our stream here, if we're good there, but I'll go ahead and share my screen. So this is what we'll be talking through, this very basic little.
00:04:10.932 - 00:04:49.236, Speaker A: I don't even know if I would call it a web app here we have three different little cards. The first one is going to be a USD to ETH conversion based on Chainlink price feeds. The second one is a very, very simple, smart contract on the back end that keeps track of how many times something has been counted. We'll automate that with Chainlink automation, and we'll look at how do we reflect that on a front end. And then finally, this last one here is for getting a random number. And how do we do all that? And we'll talk through the wallet connection piece and how to actually interact with the contract. So let's go ahead and dive in before we go too far.
00:04:49.236 - 00:05:21.950, Speaker A: This whole front end is built with Sveltekit, if you're interested in that. It's probably out of context for this, but if you go to Kit svelte dev, it'll walk you through everything you need to get started. They're getting started right here down at the bottom. Whoops, I'm zooming in on my wrong window here. Right here. It's pretty simple to start up a sveltekit application, but once you've got that, then you can kind of follow along if you want to download the repo from the GitHub as well. It has everything in.
00:05:21.950 - 00:06:11.310, Speaker A: And as we're going through if you have any questions at all, feel free to drop them in the chat. I'll do my best along with Zubin to answer any questions as we go along. So this first little component here, convert USD to ETH, right? It's pretty basic. If we convert, it'll let you know the current price of ETH and then what the value of that is in terms of ETH. So what does that look like? How do we actually go about creating this? On the right hand side here, this is the entire page that we're looking at. On the left, it's just three separate components. So the first one, this convert component, let's take a look at that component and see what it does.
00:06:11.310 - 00:06:44.490, Speaker A: So if you're not familiar with sveltekits, it's broken down into three main sections. The first is the script area up here at top. Then we have HTML. And if you have any CSS, then that would be down here in the bottom in a style tag. But we don't because I went ahead and used tailwinds for this. I don't know how you all feel about tailwinds, but I love it because CSS is like wizardry that I do not fully comprehend sometimes. And tailwinds makes my life super duper easy.
00:06:44.490 - 00:07:11.456, Speaker A: So let's dive into the HTML part first. All this stuff in class, you can just basically ignore that. That's just making it look somewhat presentable over here. But we have a few things. So when we refresh this, just to look at what it looks like, to start with, we have our dollar sign and we have an input field. That's a text input field. So we have our basic dollar sign here and our input field.
00:07:11.456 - 00:07:55.680, Speaker A: And the input field is going to be using this value of value that we'll be converting in Svelte's. A little bit of svelte magic here is that bind basically takes a variable and binds it to the component. So if you change the value here, everywhere else, that that variable is will change as well. This is really good because that means that if I change it here, it'll automatically be changing it with the actual value up above in the script portion that we'll look at in just a second. So next we have our button, and the button is disabled. If you put in something that is not a valid currency, we'll look at that. But if I type in like letters, I can't convert them because it's expecting USD.
00:07:55.680 - 00:08:22.340, Speaker A: And when we click it, we run this convert price function. So we have is valid currency. The value and convert price. Those are the three things that we use in our HTML when we're converting that price. So let's look up at the actual JavaScript piece to see how this is actually implemented. So we import get ETH price. This is going to be a JavaScript file.
00:08:22.340 - 00:09:01.876, Speaker A: We'll take a look at that when we get to it. Down here we set up some basic things like our variables for value price, and then the calculated value, that's going to be the end result as well as the current price of ETH. And we have a check here of validate USD for our value. If you haven't ever used Reg x tests to return a boolean like true or false for validation, it can look like crazy madness in here. But essentially what this is saying is we have a regular expression that begins with a digit and there's zero or more of them. It has a dot in it. Maybe that's what the question mark is.
00:09:01.876 - 00:09:45.824, Speaker A: This is optional dot, and then it has zero to two digits following that dot. So essentially what that's saying is you need something that's some numbers, maybe a decimal place, and then two more numbers. If we start to go to a third, we're not in correct currency format anymore and so it becomes invalid. Regex is super cool, and I'm a big fan of it as far as like a way to easily do checks like this. So if our valid currency is true, then we can convert. And when we convert we use that get ETH price function that comes from this util that we import. This git ETH price JavaScript file is.
00:09:45.824 - 00:10:28.550, Speaker A: I'm going to zoom out, just, I'll just make it a little wider on my screen here. That'll solve our problem. So this function pretty much comes straight from the chainlink documentation. If you haven't been to the docs, it's at docs chain link. And what this is doing is a couple of things here. So the first thing that we're doing is importing ethers. JS Ethersjs is one of the main ways of interacting with web3 blockchains back ends is what I would think of them in my web two mentality here, but it's a way of interacting with them and so that gives us access to some functions like this provider function.
00:10:28.550 - 00:11:09.600, Speaker A: We will actually use a JSON RPC URL. The RpC URL is going to be what allows us to connect to that blockchain. In this example I'm using the Fuji test network from avalanche, and so I have that URL here. This is one that they provide as an RPC URL. If you're using something like the Ethereum network, for example, if you go to alchemy, you can get an RPC that's your own personal RPC. You may or may not be able to find like Metamask's RPC URLs available out there online, the same ones that metamask uses in their wallet. But you need some way of saying, hey, this is the endpoint to actually connect to the blockchain.
00:11:09.600 - 00:11:58.896, Speaker A: We set up that provider and then we use this aggregator interface. Abi, what is this madness? So aggregator V three interface, that is going to be the function and contract really, that we will be using for getting the price feed data. So within the price feeds, the aggregate all the prices together, that's what this interface is. That's going to return back that price for the last round of consensus on what the price of the asset actually is. An ABI is application binary interface. It's similar to an API just giving your front end basically all the information like, hey, here's what's available. Here's the different functions that you can call.
00:11:58.896 - 00:12:28.120, Speaker A: You can see here there's a function called decimals, for example, and we'll be using that to get the number of decimals in the response that we get back, there's a function called get round data and it returns several different things. Right. This is the description of all the different functions that are available for you to call from that actual smart contract. You'll see later. We keep this API in a separate file for some stuff as well. But in this example, we're just putting it right here because it's fairly short, fairly straightforward.
00:12:29.920 - 00:12:51.244, Speaker B: So Richard, question for you on that from me, actually, just those in the crowd who are fairly new to this. In a web two world, we cannot interact with a smart contract without the ABI. We need the ABI anytime we're trying to interact with a smart contract from the front end. Sorry, anytime.
00:12:51.292 - 00:13:07.968, Speaker A: We absolutely like that. But I know that ethers for sure, you need to give it to, to basically give it all of the, I think probably the best equivalent would be like endpoints that you can touch within that smart contract.
00:13:08.064 - 00:13:13.560, Speaker B: That's how I describe it as well, that to know the functions and what parameters they take so you can call them from the front end.
00:13:13.630 - 00:13:48.820, Speaker A: Right. It also helps because it lets you like ethers, know what the response types will be as well. So we set up our ABI, we have our provider set up above, which is basically just saying, hey, what's the URL, what's the endpoint that we'll be hitting to get into blockchain world, if you will. From there we have an address of where this contract is actually deployed. This comes straight from the Chainlink documentation. We set up the contract. So we let ethers, we use the contract function here to provide the address, the ABI and the provider.
00:13:48.820 - 00:15:00.892, Speaker A: This will actually give you like a contract instance, so then you can actually interact with that specific contract. We'll use that to call latest round data and decimals. To return those two values, we'll store them in two different variables and from there we'll return a number that is the value of ETH multiplied by ten to the number of decimals. Essentially what this is doing is it's taking a non float and turning it into a float, right? So if we take a look here at what this ETH price was, and it would be slightly different than this, but essentially what the answer from the contract would be, it would be something like this, and decimals would be equal to eight. This is because within solidity there is no concept of decimals or like non whole numbers. And so in order to represent that, we store both the decimals and the actual value. So this ends up being something like this.
00:15:00.892 - 00:15:48.440, Speaker A: These zeros are probably actual numbers, but for this example, I just kind of like chopped them off and rounded just to make things easier for myself. So walking through this contract explanation kind of, or I guess walking through this JavaScript file of how to interact with the contract. Do you all have any questions? There's only 14 of you right now in the live stream, so feel free to ask away any questions, it'd be awesome. And in true streamer fashion, questions is just code for I needed a coffee break.
00:15:54.250 - 00:15:59.382, Speaker B: Well, if there are no questions, or if there are later on, I can always pop them on the screen and we could take them on.
00:15:59.436 - 00:16:10.378, Speaker A: Yeah, feel free to, as we go, just add questions if you got any, or comments, thoughts, cries of anxiety, those type of things. So we get our price of ETH, we get that back.
00:16:10.464 - 00:16:12.190, Speaker B: We have a question here, Richard. Sorry.
00:16:12.260 - 00:16:51.580, Speaker A: We do have data function, round data function. So this latest round data is that we're talking about here. So this latest round data is going to be based on the contract itself. We'll go to documentation docs, chain link data feeds. From here we can just say we want to go to contract addresses, we'll go to avalanche testnet, this is ETH USD. So we'll take a look at this actual contract real quick. So within this contract, let's get latest round data.
00:16:51.580 - 00:17:47.552, Speaker A: So within this contract we have this latest round data function. It's going to turn a bunch of different things, so it's going to return the round ID what the answer is. So what the price is of that asset pair and then when the round started, when it was updated and what round it was answered in. So that will be where that is, that's coming from the aggregation. So the way that Chainlink solves what's called the oracle problem, or the problem with getting non deterministic data onto chains, onto blockchains, which need to be deterministic, is that we need to have some sort of way to reach consensus and just to divert real quick to what that means. If I ask everybody right now what's one plus one? We'd all agree hopefully that it's two. If I ask everybody right now what something's non deterministic, what time is it? Right.
00:17:47.552 - 00:18:23.252, Speaker A: Like I'm going to have one answer. Zubin's going to have a very different answer than me. We're both right, but we're not wrong. So given that, that is how we solve this problem is by getting a bunch of different sources within the chainlink distributed oracle network. All these different oracles, they give us a different answer to what the price value is of an asset. All of those different prices then are submitted, signed and stored in a smart contract. Then given a set of prices, you can come to a deterministic value because now you have just a list of prices.
00:18:23.252 - 00:18:50.310, Speaker A: Use all of those prices together to come to a deterministic value. So you can take a non deterministic question and turn it into one that can be asked in a deterministic fashion. So hopefully that answers that question. For ABI files, is there a standard file encoding to keep in consideration? Abis, what I've done in the past is I just store them as a JSON file and I'll show you all that when we get to the automation piece.
00:18:51.560 - 00:18:56.212, Speaker B: You can also just save it as you did in this one. Right? In the JavaScript file itself.
00:18:56.266 - 00:19:05.610, Speaker A: Right, as an object, yeah, you can save it right here as a variable as well. It is kind of as a json file here as well, or json object.
00:19:06.460 - 00:19:09.690, Speaker B: Yeah, just an array actually. In JavaScript, yeah, correct.
00:19:11.260 - 00:19:57.850, Speaker A: Okay, so we get our price back and then we essentially just do the super simple math of like how many dollars divided by the price of ETH means how many ETH, right. And we update that value. So not to get too deep into the svelte, side of things. But essentially once we've clicked that, it shows this block down here because we have a value for ETH now and we display the price of ETH, the value of the value we're going to calculate, and what the actual price is. So these variables get updated dynamically as this changes. So if I come in here and I just say like one, two, three, we click convert, it goes out to the blockchain, queries the blockchain, gets the values back. Boom, there we go.
00:19:57.850 - 00:20:17.740, Speaker A: Cool. Clear as mud. I think probably Zubin has this amazing drawing here to kind of help this as well, just to kind of clarify how this whole process works. So here we are at the front end, we submit our USD.
00:20:18.640 - 00:20:26.660, Speaker B: So Richard, just to jump in, do you want to just drag the right side of your window a little bit so it zooms in a little bit? It's a little bit small. Yeah, thanks.
00:20:26.810 - 00:20:36.590, Speaker A: Maybe. There we go. Is it better?
00:20:37.760 - 00:20:39.164, Speaker B: I think so, yeah. Thank you.
00:20:39.202 - 00:21:15.576, Speaker A: Cool. So we are up here on our front end, right? We submit, we type in our USD, we click get or convert. Then what that does is the JavaScript file. That utility that we were looking at there goes out to the blockchain, it gets the data from the price feed, contract returns the price of ETH in terms of USD back and we display it on the front end on the other side of that smart contract. What's happening in order to create that ETH USD price? Right. That latest round data is the chainlink. Oracle network is constantly updating the price.
00:21:15.576 - 00:21:58.872, Speaker A: It's either going to be based on a time passing, so at a regular cadence it forces an update no matter what or when a certain threshold is passed it's going to be dependent on what price feed you're looking at. But based on like if the deviation in price is above or below a certain percentage, it'll force an update as well. So that's keeping the contract updated and then we are querying that contract. Cool. All right, so let's take a look then at this next one, this total counted box here. That looks amazing, right? It just says five. Super amazing.
00:21:58.872 - 00:22:56.536, Speaker A: So what is happening behind the scenes here? So the first thing to take a look at here, let me just kind of clean up everything is we're going to use this automation component. And what does that automation component look like? We have basically our total counted and we have our count with a bunch of tailwind stuff around it and a link to the actually deployed contract here. For this one I did it a little bit differently. Where instead of having a separate JavaScript file that we're importing, everything we need is right here. All in this one function. Listen for event. So what are we listening for? What event are we listening for? If we take a look at the contract itself, it has one function called count that we can write.
00:22:56.536 - 00:23:04.024, Speaker A: And the contract itself is pretty stinking basic. This is, do you want to paste.
00:23:04.072 - 00:23:05.244, Speaker B: The link in maybe?
00:23:05.282 - 00:23:46.216, Speaker A: Richard, the entire contract? Sure. You all can go and look at this. So if you go there and you head to contract and you go to code, it's 15 lines long. Even with comments, the contract itself is nothing more than a public un 256 that gets incremented with the count function. When it does get incremented though, it emits an event and that's key. So events are kind of like logs on the blockchain. If we head to events, you can see every single time that I have counted this, right? So is it 012345.
00:23:46.216 - 00:24:31.560, Speaker A: And if you remember, our count is currently at five. So what happens is every time that the count function is called, a new event is emitted and the value is incremented as well. So we could see that working. Let's pull this over here real quick here. If we go to write contract, and you all can do this too, you can really mess with the number. While I'm doing this, if I connect my wallet and then I click on count and confirm that transaction, so this will increment that value and it will emit a new event. And when that new event is emitted, we should see, yes, the value changed.
00:24:31.560 - 00:25:10.048, Speaker A: So how do we do that? How do we listen for events in the front end? Well, let's take a look at the code. So here, this should look kind of similar to what we saw in the other one. We have our contract address, we have our URL for our PC endpoint, same URL, different contract address, because we're looking at a different contract. We set up a provider with ethers, we imported ethers as well. And then we set up our contract using ethers, the contract object. Now here we have our contract address, we have our provider, those are the same. But then there's this automation.
00:25:10.048 - 00:25:49.330, Speaker A: Abi, what is that? Where is that coming from? Well, we're importing automation from this automation JSON. What is this business here? Essentially it's the same thing that we used in the other one, but formatted in a json file and just kind of stored separately because this one is not super long. But sometimes your contract AbIs can be fairly robust, right? And pretty long. So you can store it as a separate file and then just import it as an object and use that object as well. And it kind of keeps things a little cleaner. Right. Instead of having the ABI just in line here, we can just import it, keep it nice and clean.
00:25:49.330 - 00:26:43.216, Speaker A: So from here we go ahead and say that we want to have our transaction be this. Our current count is the transaction, sorry, our count transaction. We're going to await it because we need to go out and query it. When we query the blockchain, essentially what we're doing is doing an asynchronous function, right? We go out and make a call, wait for that response, because blockchain takes a second to come back to us and then we get that value. So we have our transaction for that to go ahead and grab the current count and then we store it as count, which will be the value that we display on the page. And then we have this automation connect contract. So the automation contract that we set up here when there is a counted event.
00:26:43.216 - 00:27:31.812, Speaker A: So this dot on is listening for events. It's an event listener, same purpose as they would be normally, and that we're listening for an event to be emitted from our contract. In this case, we're specifically listening for the counted event. And if we look at the contract itself, we can see that the event is counted and it emits counted with the number as well. So we listen for the counted event and then the value that it's emitting, we'll use that as count and we'll store that in our new value into our count variable. So that is how we listen for events to happen. We're talking about automation.
00:27:31.812 - 00:28:31.930, Speaker A: We're talking about how could we make this happen automatically? If I don't want to come to this thing and click count over and over and over, how can I automate this? Right? So this is one of the really cool things that Chainlink allows you to do is use Chainlink automation. Again, if you head to Docs chain link, we have a whole section on automation, but if you head to automation chain link, you'll need to connect your wallet and then you can register a new upkeep. Now when you're trying to do something like this with registering an upkeep, it'll ask you two things here. If you want it time based or to use custom logic. Time based is going to be based on Cron tab. Just basically at a certain time, at a certain interval, do this thing and then custom logic will be based on a function within your smart contract that will be returning a boolean. And based on that boolean it will then perform the upkeep, the automation or not.
00:28:32.700 - 00:28:43.070, Speaker B: So Richard, question for you on that. Why would anyone want to automate their smart contract? Is it because they don't want to have to manually do it as a developer, they want to decentralize? What are the.
00:28:45.120 - 00:29:21.020, Speaker A: If you one you don't want to do it, right? Like if you need something done every Friday afternoon, submit your TPS reports, then you could automate that if you want to ensure that something will happen. Maybe Zubin is responsible for submitting the TPS reports every Friday afternoon. But sometimes Zubin likes to go on vacation. Or maybe Zubin just wants to go to the pub a little bit early on Friday afternoon. You can make sure that it happens. You mentioned decentralization in there, which yes, so the automation jobs get submitted to the oracle node network. So you do have that benefit as well, right? That's going to be decentralized.
00:29:21.020 - 00:29:55.190, Speaker A: So we take a look at this time based trigger, it'll ask you for your contract address so we can go ahead and just grab that real quick. And this contract was actually validated, right? So I've actually submitted it and validated the code. That's how we can see the code here. If you just deploy the contract, it won't be validated. And in the automation interface here it'll actually ask you for the ABI for this contract. So it knows what functions are available too. Since I've already validated it, it was able to grab that for me.
00:29:55.190 - 00:30:45.076, Speaker A: And let's say that we want to do this every 1 minute. So again, this is a cron tab, and if you're not familiar with this, this kind of breaks down what the different values are. You have your minutes, your hours, your day of the month, month of the year, and day of the week. There's a fantastic website, I think it's Crontab guru, which will let you kind of mess around with it and it'll tell you what it is doing in more human readable format. I like this, just to make sure that I know what I'm doing. But here you can kind of see too. When you set this up, it'll give you the next five, so you will have a good idea of what you're looking at.
00:30:45.076 - 00:31:20.224, Speaker A: So we set this up, we'll call this just account and we'll give it five link to start with. Now Link, what if you don't have link? Right, we've got this little thing. Do you need link? You can head to the faucet. So faucets chain link will allow you to actually get some testnet link and depending on the network, maybe some testnet currency of whatever network it is for avalanche. Unfortunately, it doesn't have that on like go early, for example. You can definitely do that. So I don't need any link.
00:31:20.224 - 00:31:53.080, Speaker A: I'm going to skip that part. It's not because I'm afraid I'm not really a human. And we'll register this new upkeep. It will make us confirm that, hey, we're actually deploying a smart contract here and we'll confirm this as well to exploit. So we have a confirmation to submit our link and then a confirmation to actually deploy the upkeep. We can view our upkeep and so we can take a look at the upkeep itself. We'll pop it over here, we'll watch the total counted over here.
00:31:53.080 - 00:32:11.494, Speaker A: So now what we'll see is every time a minute has passed, our upkeep should trigger. And this sometimes takes a minute. But here you go. Yeah, so we've got our first one right where we have our actual upkeep happening. It shows you how much it cost. It shows you when the next one will happen. And you can see, hey, our total counted.
00:32:11.494 - 00:33:07.468, Speaker A: It already changed all on its own. So if we stay here for like another minute, we should see this total counted go up to eight in just a second while we wait for a minute to pass. Any questions? It. All right, we can see it just happened again because we went up to eight. If we refresh over here, we should see, yes, we have another instance of it going. And essentially this will just continue on until we run out of link, which based on the current spend, that's going to be a while. So as we're going here, it'll just keep going.
00:33:07.468 - 00:33:30.580, Speaker A: So can it be likened to cron jobs? It absolutely can be likened to cron jobs. It's essentially distributed cron jobs for smart contracts. That's absolutely how to think about it, 100%. The difference is that since that distributed Oracle network that's powering it on the back end, it's not relying on one machine. And if that machine goes down, hey, your cron job is not going to work anymore.
00:33:32.680 - 00:33:45.370, Speaker B: Would you say that that's for the time based one, but what about the custom logic based one? Would you say that that's close to Cron job or would there be a different mental model for that one?
00:33:50.240 - 00:34:10.400, Speaker A: It just depends, I guess, on how you're thinking about it. That one would be running essentially, it checks every block to see if the value is true. So maybe not as much as like a cron job, but more like event based execution.
00:34:11.300 - 00:34:17.364, Speaker B: Yeah, it's pretty cool. And what happens, Richard, if you refresh the page now, it won't show nine.
00:34:17.402 - 00:34:19.828, Speaker A: Anymore, will this page?
00:34:19.994 - 00:34:20.660, Speaker B: Yeah.
00:34:20.810 - 00:34:27.044, Speaker A: Yeah. So it goes out and shows nine because that's what, this is one variable that just is being incremented constantly.
00:34:27.092 - 00:34:31.224, Speaker B: Correct. So it's on a per session basis. Right. That's how the listener will end up working?
00:34:31.342 - 00:34:45.644, Speaker A: No. So the listener, it's going and getting the actual number from the contract. So the number is a variable that is stored in the contract itself.
00:34:45.762 - 00:34:46.188, Speaker B: Right.
00:34:46.274 - 00:35:22.040, Speaker A: Every storage count is called this number will increment. And so the contract itself is going out and getting the value of this number. And then anytime that its count is called, it emits a new event. And so when that new event is emitted, it basically refreshes the number with, and fetches it value that's emitted with the event. So it doesn't need to requery the value because that value is passed out with the amend or with the emit.
00:35:23.900 - 00:35:26.584, Speaker B: Perfect. Thank you. That's clear now.
00:35:26.782 - 00:36:14.024, Speaker A: Cool. All right, so let's dive into the most complicated one, if you will. So the first thing you notice is, like I mentioned at the very beginning, if you weren't here, the attached wallet means that we're kind of blurring the line between web two and three because you can't do this one without. I guess you could, if you wrote your contract in the right way, you could do this without having a wallet. But it's a lot easier to kind of talk through and explain what's going on with the wallet. So we will probably look at the code first here. So we have our random here for this, and we have this wallet connect.
00:36:14.024 - 00:36:59.252, Speaker A: So what does wallet connect do? Essentially this is going to take the place of the RPC URL. So in the previous two examples, we used an RPC endpoint to basically be like our entry point into the blockchain. In this instance, we're still using an RPC endpoint, but it's the one that's in your wallet. And we're also getting some more information like your address and the chain ID that you're on, so that we can actually interact with the contract. These two are just reading values from a contract. Anybody can read a value. Anybody can read it because it's all on the public blockchain.
00:36:59.252 - 00:37:44.132, Speaker A: It's available, it's public information. But when it comes to writing you have to basically know who is performing the action. And there's going to be like the gas fees accounted for and stuff like that. So how do we do that? Well, this is kind of outside the scope of this tutorial, but we can walk through it a little bit real quick. When Zuba and I were talking through this earlier, you could probably dry this out, if you will, like to make it more generic. Instead of passing in the contract address here and getting the contract and everything like that, you kind of keep that separate and treat this just as the wallet information. So that's something kind of like just tuck away in the back of your head.
00:37:44.132 - 00:38:06.300, Speaker A: But again, we import ethers. I have this value of web3 props. That's going to be the things like the provider, the signer, the account, and the chain ID. I just store those as an object together just to kind of make things easy. We have a contract address that will pass into this component. We have the contract ABI that will pass into this component. And then we have a connect wallet function.
00:38:06.300 - 00:38:43.130, Speaker A: Essentially what that's doing is it's looking at the browser window, seeing if there's an Ethereum object, which means you have a wallet available to you. Something like metamask using brave. The brave wallet works the same way. We request the ether, like the ETH accounts, which is going to essentially say, hey, do you want to connect your wallet? So that's what, when you look at this and we attach our wallet, that's what this is. You're requesting the accounts. So you give it access to an account. At that point you can get the signer, and from there you can get the address and chain ID.
00:38:43.130 - 00:39:54.488, Speaker A: All this to say that's how you basically get the address and chain ID and RPC endpoint, essentially the provider for this from the wallet instead of providing it yourself. So once we've done that, then we can kind of continue on in the same way that we were before. And when we actually call the function to get the random number, we'll use those values. I've also set this up. So this is kind of like a weird double case here, where we only use the provider for the wallet to actually get the random number to request a random number when we're listening for it. When we're watching for the random number, we just use, again, the RPC endpoint, because that's a read function. I just wanted to kind of separate those two out mentally, that when you are listening for events, reading information from a blockchain, that's where you can do everything just like a normal web two dev, like hey, I've just got this endpoint that I got a query.
00:39:54.488 - 00:40:30.540, Speaker A: Whereas when you're interacting with the blockchain, that's when you kind of start to go more into like the hey, you have to have a wallet set up and all that stuff. So hopefully that is kind of clear. But we've got our wallet connect. Once we have our wallet connected, then we have our get a random number button. And what that will do is it will take the values from that wallet connect. And if you remember within wallet connect we had our actual contract set up as well. So it takes all that contract information and it then calls request random words from that contract.
00:40:30.540 - 00:41:39.552, Speaker A: The contract that we're using is straight out of the chainlink documentation, just like copied and pasted and deployed. But the get random words in here, or the request random words, sorry, is a value or a function that essentially sends a request out to the VRF coordinator. So the node that is in charge of requesting random words for you, and then it will get it back and the fulfill random words function will be called. One thing to note, this contract uses only owner for request or random words. So if you wanted to kind of play along with me and in the contract you wanted to do a request random words, unfortunately you can't because you're not the owner, but you could deploy it yourself. If you head to docs chain link and go to the randomness, the VRF section and look at get a random number here, it will walk you through everything you need to set up this contract. You'll need to create a subscription in order to do that.
00:41:39.552 - 00:42:20.092, Speaker A: It'll walk you through that and how to actually deploy this contract for yourself so that you could do that. If you wanted to do that. When you did do that, I should say you would need to change the contract address to the address of the contract that you are using here as well as in no, just here because I pass it into the wallet connect. So just something to kind of keep in mind there. If you're going to play along with this yourself, you would need to actually deploy this contract yourself. The other two contracts you could just use as is, and they work just fine for you. All right, so we've got our get random number button.
00:42:20.092 - 00:42:53.050, Speaker A: When we click that, that's where it'll go off and request random number. And then this part down here, this random number part down here that is actually just listening for that event to be emitted. So once that randomness is fulfilled, it emits an event with the random numbers in there as well. It's the request fulfilled event, and it returns the actual random words, the random numbers themselves. It is an array I had set up to just request one. So I'm just returning the first of that array. You can see here we've got our random number back.
00:42:53.050 - 00:43:42.812, Speaker A: So I would say the listening, the watching for the random number to come back 100%. Web two, the requesting. We're kind of blurring the line there a little bit, but yeah, that is kind of in a nutshell, how to start, like, dipping your toe into the web. Three, space as a web two. Dev, do we have any questions, any thoughts? I'm realizing now, Zubin, that I did not show off the drawings for the second two.
00:43:42.966 - 00:44:00.250, Speaker B: That's okay. We can maybe do that as part of the questions. If people have. Richard, if you were sitting across the table, you may kick me under the table for asking you this question. But why random words? Why is it called words?
00:44:01.580 - 00:44:19.148, Speaker A: So I was super confused about this as well. So there's a computer science term, words, and trying to see, like, where I.
00:44:19.154 - 00:44:31.170, Speaker B: Think if you google words, computer architecture, software architecture, it comes up. The Wikipedia article should. Has to do with the processor as well.
00:44:32.120 - 00:45:05.390, Speaker A: Yeah, it's the technically correct. Yeah, there you go. So to get super duper nerdy, it's a natural unit of data. So essentially, this is the proper term for what's being returned in my mind. It just translate automatically from words to numbers. That sounds really weird to say, but, yeah, it's technically correct is why.
00:45:06.800 - 00:45:15.552, Speaker B: Got it. So it's not actually words, it's just something. It's a computer science term. And so we put that up for you on the screen. Take a look at it. It's not actually words. It's actually a number.
00:45:15.552 - 00:45:20.370, Speaker B: Correct. Cool. So rye guy has a question here.
00:45:20.740 - 00:45:58.780, Speaker A: Any references of web two languages, frameworks that easily integrate wallets. So I'll start off by saying I'm super biased in the fact that I like Sveltekit and there's not any really nice stuff for Sveltekit yet. React has a few things, I think. Let me stop sharing my screen while I Google real quick. I'm always devious about Googling and then, like, something terrible happening. I think it's Rainbow Wallet connect. So, like, Rainbow Wallet has Rainbow kit.
00:45:58.780 - 00:46:07.324, Speaker A: That's what it is. I think it was Rainbow kit. It's by Rainbow.
00:46:07.372 - 00:46:19.348, Speaker B: Yeah, it is. I've got a bunch. I'm putting some up just because I have a running list of all the stuff I'd like to get good at, and I never managed to get good enough at it because I don't have enough time, but I put some up here.
00:46:19.434 - 00:47:04.790, Speaker A: Yeah, but Rainbow Kit is from the little bit of experimentation that I've done, very friendly with a bunch of different wallets and actually works pretty well on mobile. That's like another side story of mobile web development for web3 stuff is wallets are rough on mobile. Yeah, Rainbow Kit seems to do pretty well with integrating with different wallets. Pretty well. Does randomness have parameters? Can I configure pseudo randomness? Like, I have no idea what Perlin noise is. It does have parameters. We'll start there.
00:47:04.790 - 00:47:45.104, Speaker A: When you are setting this up, the contract that I deployed is here on the screen. Let's make it a little bigger. There are parameters, I don't know if this is what you mean, but we have things like the number of values that you'd like to return. There's also things like how many block confirmations you'd like to go by before you return those words. The higher this number is, the more secure your randomness is. The lower it is, the faster it is. Callback gas limit is used because when you actually fulfill random words within this function itself, you can do other things.
00:47:45.104 - 00:48:25.980, Speaker A: And this is a limit to how much gas can be spent when you do those other things. By do other things, I mean like if you had an NFT, for example, and you were using this randomness to generate traits on that NFT, you could actually create the NFT once you get the random values back. But I'm not sure if that's what you mean. If you wanted to do pseudo randomness, I guess you could probably do something within fulfill random words to kind of mess around with the value that you get back to make it fall within a range or something like that, if that's what you're talking about. I'm not sure. I'm not sure you'd go ahead.
00:48:26.050 - 00:48:27.550, Speaker B: Sorry, go ahead. No, you.
00:48:27.920 - 00:48:32.590, Speaker A: No, no, I was saying like if Michael wanted to add more details to their question.
00:48:33.040 - 00:49:06.968, Speaker B: Yeah, I think I just add Michael. It's a great question because there are other ways to have pseudo randomness in a blockchain. But the reason why VRF exists really is we don't want pseudo randomness for certain use cases. We want it to be completely non deterministic in that sense, truly random. And so VRF isn't really designed to support pseudo random. There are other ways you can do that on a blockchain, but VRF is meant to be completely random, cryptographically, verifiably random. There's no validator miner out there that can sort of predict where it's going.
00:49:06.968 - 00:49:19.020, Speaker B: There's a cryptographic proof that's submitted along with the actual random number. It's use cases very specifically where you want a cryptographically guaranteed random number generated for the blockchain.
00:49:22.560 - 00:49:28.940, Speaker A: Yeah, you'd be essentially like undoing the benefits of VRF.
00:49:33.030 - 00:49:38.358, Speaker B: But I'll tell you what, randomness in the blockchain, it's a crazy topic. It's like Alice in Wonderland sometimes when.
00:49:38.364 - 00:49:46.950, Speaker A: I read about it for game development, sometimes it's helpful when you can guarantee certain outcomes.
00:49:48.170 - 00:50:01.580, Speaker B: Interesting. We've usually heard the opposite, haven't we, Michael? Like it's mainly in game development where you don't want to guarantee certain outcomes that you'd use VRF. Like you want randomness, you want to guarantee a random outcome rather.
00:50:05.430 - 00:50:10.470, Speaker A: Okay, so you want randomness, but within a certain bounds maybe is what I'm.
00:50:10.970 - 00:50:11.862, Speaker B: Sounds like it.
00:50:11.916 - 00:51:17.882, Speaker A: Understand this. As with that, yes. So your seed in, you want to be truly random, but now I have to Google like what is Perlin, sorry, googling away here. Super interesting to watch somebody Google. Okay, so this is for procedural generation stuff, essentially like how Minecraft worlds are generated, but you would use. Am I understanding it right that the seed being truly random would be beneficial there? Correct. And then using that seed to generate the whatever from the algorithm is what you're looking for, is that correct? Yeah.
00:51:17.882 - 00:51:31.262, Speaker A: Okay, so you could use VRF to generate the random seed and then use that in whatever you're doing with that seed. Yes, I think that would be an applicable thing to do, for sure.
00:51:31.316 - 00:52:21.840, Speaker B: Yeah. And also I think behind the scenes, and I'm just going to post this for you, Michael, on the chat, there is a stack overload post that came out maybe a day ago, and one of our colleagues, Patrick, was helping answer this with a bunch of other people. So it talks about pseudo randomness post the merge on ethereum, and also talks about how VRF does use a bunch of fairly deterministic, well, not deterministic, bunch of information from the blockchain that other people can read as well, but also a secret key that is computationally infeasible to calculate in order to generate that seed. So you could use VRF to give you a seed, or use the fact that VRF already has a computationally infeasible seed behind it and just work directly off the random number that comes off it depends on your use case.
00:52:30.720 - 00:52:41.344, Speaker A: Cool. Yeah, I think Michael, for your use case, that would need to be within the fulfill randomness function. You'd have to put the perlin function into that fulfill randomness function in there.
00:52:41.382 - 00:52:43.248, Speaker B: Yeah. In the callback, right?
00:52:43.414 - 00:53:01.032, Speaker A: Yeah, sure. Real quick. One more thing before we go in. The top right hand corner of the screen is a little QR code. It's kind of like a survey to see what you all thought about this, how we did, what we could do better, that kind of stuff. If you could take a second and fill that out, we would really appreciate it. It would be super awesome.
00:53:01.032 - 00:54:00.190, Speaker A: Probably should have asked for that earlier in the broadcast, but, yeah, I don't know what. Other questions? Any other questions? Comments? If not, I guess we'll have to wrap it up. Any questions from you, Zubin? Richard, do no shave November. It's been like, no shave six months. Rye guy. Man, if you go back in Chainlink videos, you can see me without the beard. It existed, although there was a mustache.
00:54:04.130 - 00:54:05.200, Speaker B: That's great.
00:54:05.890 - 00:54:25.720, Speaker A: All right, well, thank you all for coming. I appreciate it. I don't know. This has been fun. I always like the interaction piece. Makes things a little more fun than just talking to my camera by myself, like a crazy person yelling at clouds in my room alone. So, yeah, thanks, and I guess we'll catch you next time.
00:54:26.090 - 00:54:29.730, Speaker B: Have a great day wherever you are, guys. Thank you. Bye.
