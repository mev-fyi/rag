00:00:10.730 - 00:00:44.890, Speaker A: So here we are back in remix, and we have our simplest storage Sol. If you skipped over the last section, be sure to go to the full blockchain solidity course js and scroll down to lesson two. Welcome to remix and grab this code. Go to simplestorage Sol and copy paste this code into remix because this is where we're going to be starting from. We have this simple storage contract, which is great. It allows us to store a favorite number and it allows us to store favorite numbers across different people in both mappings and arrays. But let's say we want to get even more advanced with this.
00:00:44.890 - 00:01:25.494, Speaker A: We actually can have a contract, actually deploy other contracts for us, and then go ahead and interact with those contracts from other contracts. Contracts interacting with each other is an essential part of working with solidity and working with smart contracts. The ability for contracts to seamlessly interact with each other is what's known as composability. Smart contracts are composable because they can easily interact with each other. This is especially awesome when it comes to things like DeFi, where you can have really complex financial products interact with each other incredibly easily since all their code is available on chain. So we're going to learn how to do that. So let's keep our simple storage contract exactly the way it is.
00:01:25.494 - 00:02:01.938, Speaker A: We're going to create a new contract called storage Factory. So we're going to hit the new file button and type in storagefactory Sol and let's close this off for now. So let's go ahead and get this contract set up from what we learned before. First thing we're going to want to do is the SPDX license identifier, which we're going to do MIT. And then the next thing we're always going to need is our solidity version. So we'll do pragma solidity and we could do 0.8.7. But for this one, let's do 0.8.0
00:02:01.938 - 00:02:23.478, Speaker A: and then just add the carrot, meaning any version of 0.8 point something will work. And then let's add our contract name, which is going to be storage factory. Now hit command s or control s, or go to the compile tab and hit compile. And boom. We have our regular setup here. Now we want to create a function that can actually deploy our simple storage contract.
00:02:23.478 - 00:03:09.958, Speaker A: So we'll create a function called function create simple storage contract. We'll have it be public so anybody can call it. We'll have it deploy a simple storage contract and save it to a global variable. But before we can do it. How can our storage factory contract know what our simple storage contract looks like in order to deploy it? If our storage factory contract is going to deploy simple storage, it's going to need to know code of simple storage. One way we can do this is we can actually go to our simplest Sol and copy everything underneath pragma solidity and down and paste it into our storagefactory Sol underneath our pragma solidity. If we go ahead and compile and save this, it actually works.
00:03:09.958 - 00:03:51.554, Speaker A: Our storagefactory Sol contract actually now has two contracts in it. It has the simple storage contract and it has the storage factory contract in it. If you actually go to the deploy tab and scroll down to deploy while you're on the storagefactory Sol, not the simplest Sol on storage factory, you can see that you can actually choose which one of these contracts to deploy. A single file of solidity can hold multiple different contracts. Now that we have our simplest Sol in our storage factory, we can actually go ahead and create this function. To deploy a simplest Sol, we're going to create a global variable the same way that we would create any other global variable. We'll do the type which is going to be type simple storage contract.
00:03:51.554 - 00:04:25.490, Speaker A: We'll give it a visibility of public and we'll give it a variable name. Type simple storage contract is going to be public. The name of the variable is going to be simple storage. Now, in our function create simple storage contract, we're going to say simple storage equals new simple storage. This new keyword is how solidity knows. Ah, okay, we're going to deploy a new simple storage contract. So we go ahead and compile this, we'll go to the deploy tab, make sure we're on the Javascript VM.
00:04:25.490 - 00:04:54.982, Speaker A: We'll scroll down to the contract and we'll choose storage factory. And remember, you need to have storagefactory soul selected in order for that to show up. Storage factory. We'll go ahead and hit deploy. And now we see our storage factory contract has two buttons. One is create simple storage, and the other one is going to be a view of our simple storage contract. If we click it right now, it's going to show us that it's currently at address zero because it gets initialized to being blank.
00:04:54.982 - 00:05:33.718, Speaker A: It's saying there is no simple storage contract currently deployed. Now, if we pull up our console and clicked create simple storage, we see we created a new function call storagefactory. Create simple storage contract. And in doing so, we called this function which created and deployed a new simple storage contract. We can now see what address the simple storage contract is at by clicking the simple storage button and we see the address associated with it. So now we know how a contract can actually deploy another contract. But the thing is, having this massive chunk of code above our storage factory is a little bit redundant, especially since we have our other file called simplestorage Sol.
00:05:33.718 - 00:06:19.522, Speaker A: And let's say we have a contract that has got a ton of other contracts in it. Always copy pasting all these contracts is going to be a lot of work. So instead what we can do is use what's called an import. So let's go ahead and delete our contract. Simple storage and now we're just going to type import simplestorage sol this import simplestorage Sol is the exact same as our copy pasted version of simplest Sol. It takes the path of another file, it takes the path package or GitHub, which we'll get to in a minute of another file and says okay, we are going to paste that contract into the top of this contract here. And we actually see if we go back to compile, we go to deploy.
00:06:19.522 - 00:06:53.790, Speaker A: Let's delete our old contract, we can actually see storagefactory sol again. We can deploy it, click the drop down, and once again we can run those functions exactly the same. Importing our contracts like this is much nicer than always copy pasting the code. This way, if we want to change something in simple storage, we have one canonical place to go ahead and change it, instead of having to change it in multiple different places. Now additionally, you'll notice the pragma solidity. If we have our contracts in two separate files, we actually can have different versions of solidity. Right now our storage factory has carrot 0.8.0,
00:06:53.790 - 00:07:25.834, Speaker A: which means that anything within the 0.8 range of this contract is okay. But for simplestores Sol, it says anything in the 0.8.8 and above range is okay. So if we were to try to change the compiler version to 8.5 and then go ahead and compile remix is going to automatically bump it up to a better version that is compatible with both of them, in this case 8.13. But if we, for example, changed our solidity version of storage factory to 0.7.0
00:07:25.834 - 00:07:56.670, Speaker A: and then tried to compile them, we actually end up getting an issue. Parser error source file requires different compiler version. This is because our storage factory is saying hey, anything in the zero seven s is okay. However, our simple storage is saying anything in the 0.8.8 and above is okay, so those two versions are not compatible. So what we need to do is we need to make sure our versions of solidity are indeed compatible. So let's change the version back recompile.
00:07:56.670 - 00:08:41.438, Speaker A: And now we're looking good again. Now, since we have this create simple storage contract, every single time we call it right now, it'll just replace whatever is currently in our public simple storage variable. Let's go ahead and update this so that we can actually keep a running list of all of our deployed simple storage contracts. So instead of having this be a single variable, we'll make this a simple storage array or list public simple storage array. Now, whenever we create a new simple storage contract, instead of saving it like this, what we're going to do is we're going to save it as a memory variable by saying simple storage. Simple storage equals new simple storage. And we're going to add this variable to our simple storage array.
00:08:41.438 - 00:09:05.042, Speaker A: So the same way we did it before, we're going to do simplestorage array, push simple storage. So I should spell storage, right? Let's go ahead and compile. This looks good. We'll deploy the storage factory. Deploy, click here. We now have a simple storage array view button. We'll do create simple storage.
00:09:05.042 - 00:09:14.940, Speaker A: Now we can view the simple storage contract at zero. Right now there's nothing at one, but if we create another simple storage contract, we can see the new simple storage contract address at index one.
