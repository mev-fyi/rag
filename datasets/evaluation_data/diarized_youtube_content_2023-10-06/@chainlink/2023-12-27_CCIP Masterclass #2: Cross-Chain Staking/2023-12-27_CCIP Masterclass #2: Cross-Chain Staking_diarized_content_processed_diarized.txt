00:00:03.850 - 00:00:58.480, Speaker A: The topic for today's one is cross chain staking, or cross chain staking edition, where we'll be covering some majority defi primitives and how you can use CCIP chaining. CCIP for cross chain defi. Basically, we are going to create something called cross chain staking dap. It's going to be a simplified version of some popular staking apps. We're simplified in a manner that we are going to have only one staking token and one LP token, and that staking DAP code will be as minimal as possible. So, yeah, I see a question. Actually, the question is, if it's possible, I would like to see a guide on vanity addresses from a talk you did.
00:00:58.480 - 00:01:17.842, Speaker A: If you can send, you can just ping me on Twitter. Let's see. This is my Twitter. So after this masterclass, and I will try to find that presentation. I think there is a video, actually, I did a talk on vanity addresses at Belgrade, so maybe that can be useful. Cool. Yeah.
00:01:17.842 - 00:01:40.326, Speaker A: So, yeah, we can start now. My name is Andreakich. I'm one of the developer advocates for chaining protocol at Chaining Labs. And you can see, as mentioned, my twitter handles over here, I'm much more responsive on Twitter. So if you have any follow ups like this one, feel free to ping me there. Not in dms. I think for privacy reasons that feature has been disabled.
00:01:40.326 - 00:02:17.702, Speaker A: But you can just tweet and tag me and I will answer as soon as possible. I'm also present in our discord, but in discord, there's too much noise. So make sure to tag me and I will try to answer and follow up, especially if you're participating in constellation hackathon. We're trying to be there for you. Cool. Alongside with me together in the background will be Richard Godliber and Frank Kong, two developer advocates for Chainlink protocol at Chainlink Labs as well. These two gentlemen will be helping you with the breakout rooms with any questions you have.
00:02:17.702 - 00:02:53.134, Speaker A: So feel free to. This is a zoom webinar, basically, so feel free to ask questions in the chat. Or more precisely, there is A-Q-A section, so Q a section will be the best place for that. And either Frank or Richard or myself during the exercise time will answer those. So just wanted to give a quick shout out and a huge thank you to Richard and Frank. Cool. So, as being said, this Masterclass is kind of a follow up on the first Masterclass.
00:02:53.134 - 00:03:36.846, Speaker A: Masterclass number one. And if you remember, or you were present at Masterclass number one, you kind of remember that we used Gitbook for that. So because of the amount of content we have, and also to support hardhead, foundry and remix as a different development environments, basically you can use Chainlink CCP with whatever development environment and with all the majority blockchains, we are going to add them more and more. Definitely. So the same thing will be this evening, morning, afternoon, whenever you are. So we are going to use Gitbook as well. So I'm going to stop sharing this screen and I'm going to share the gitbook.
00:03:36.846 - 00:04:25.602, Speaker A: And also the Gitbook URL will shortly pop up in the chat as well. I can close some of these tabs. Actually, the only two tabs that we're going to need is remix id and the official docs alongside Getbook. So getbook URL is in the chat at the moment and this is its content. So you should be able to see CCOP Masterclass number two crosschain staking edition. And this is going to be our content for today. So if you for the first time with us, as I said multiple times, there was CCP Masterclass number one and it's available.
00:04:25.602 - 00:05:25.090, Speaker A: Gitbook for that masterclass is available at the following URL. I'll make sure to tweet both of these URLs afterwards, but as I said, it's good to keep them bookmarked or somewhere because we are going to host more master classes in the future. So the Masterclass number one was pretty much CCP overall. We wanted to share with you as much as possible about how CCP works under the hood and how you can use it. Today we're going to focus on one piece of what CCP can do, that's transferring token transfers for this second Masterclass, and we are going to use those token transfers in some defi use cases alongside that. So we're going to have two exercises. The first one, as you see on the left, is going to be pretty short one, it's a warm up exercise just to get some test tokens and transfer them to set up our environment, basically.
00:05:25.090 - 00:06:28.540, Speaker A: And then this is going to be the major one, crosschain staking alongside those two, we are going to have the bonus lecture, which is debugging tips and tricks. And I think this one can be particularly useful for you because I saw a lot of questions in our discord and a live questions at recent East Global hackathon in Istanbul, where people had struggling with some errors or issues when working with CCIP. And I'm just going to share my approach when debugging CCP issues with you. So you can bookmark that page as well whenever you need it. I'm going to share a couple of useful tools and techniques when it comes to debugging CCIP stuff. Finally, during the extras number two, we are going to cover some of the best practices security wise and design wise when working with CCIP and then going to implement those best practices in our code base as well. So make sure to carefully follow up that.
00:06:28.540 - 00:07:38.282, Speaker A: And yeah, at the very final URL, it's going to be some extra material that you can check afterwards, but we're going to have one simple bonus. Exercise or homework exercise depends after exercise number two. So there are going to be plenty of stuff for you to play with even after master class number two, if you want that, of course. So before we start with the first exercise, let's do a quick recap on what Chainlink CCP is. And we're going to deep dive into processing the CCP message as well because refresh on that will be helpful for us to understand the debugging tips and tricks. Subchapter so as you already know, CCP stands for Chainlink cross chain interoperability protocol, which is a way for you to send various different types of cross chain messages across different blockchains in a complete decentralized way. Basically, you can do that by using something called lanes.
00:07:38.282 - 00:08:30.362, Speaker A: And lane is pretty much similar. Like mental model is pretty much similar to the bridge, although it's a bit different because there are three different decentralized oracle networks as three different off chain components. That ensures that traffic on these lanes is done in a decentralized manner. And also lanes are bi directional. So if we have blockchain a and c on this image, basically lane consists of two different pathways. If you're sending something from blockchain a to c, that's one lane, and if you're saying vice versa, from c to a, that's a different pathway. Both pathways combined makes one lane.
00:08:30.362 - 00:09:23.290, Speaker A: So that means basically when we want to add another blockchain, like for example, I don't know, polkadot, bitcoin, filecoin or whatever, blockchain is currently not supported. By chaining CCIP. We will need to deploy two directional spatways to form one lane. From the user points of view, it's not particularly important because when you want to interact with chaining CCAP, you basically interact only with the router contract, right? So you're going to interact with CCAP router contract. You're going to specify the chain selector of a blockchain. You want to send a message to so destination chain selector. Chain selector is basically un 64 value and it's unique in a chain link CCIP environment.
00:09:23.290 - 00:10:16.450, Speaker A: So if for example chain id of Ethereum mainet is one, progarla is five or whatever, those numbers are not the same in chain link CCIP. The reason for that is that we want to make them all unique lengths and there is actually a fancy form of how these are getting calculated. But more important to you is that you can find all of those at our official docs. So coming back to lanes from the user point perspective, you're just going to interact with the router, provide the chain selector you want to send the message to and the message itself. It's pretty much the same flow as you're going to the post office and you want to send a package, you're going to provide them a package. And also write down or type down the destination address and the destination sender, your friend or some family member or whatever. If you're doing drop shape on that customer.
00:10:16.450 - 00:11:04.930, Speaker A: But that's pretty much it. The post office will handle everything and it's going to be maybe post officer going to the next quarter, next free to deliver package, or it's going to involve some airplane boat traffic. Depends like if you're sending a message or a package to other parts of the world, for example. So this is a nice analogy when it comes to using chainlink CCP as well. So how you can use it, I think we already know that, but let's just quickly recap. So any address can be a sender. So it can be your externally own account, your smart contract, wallet account, any smart contract of your DAP, anything.
00:11:04.930 - 00:12:12.294, Speaker A: So sender can be any address receiver can also be any address with a slight but, so let's first see what we can send. So we can transfer tokens at the moment, and not just at the moment, but that will be the case in the future as well. We can transfer only CCIP supported tokens. The reason for that is that first to create a token you will need I think like 2 minutes of work, even less nowadays with simple quick up tutorials, creating an ERC 20 token is extremely simple. So for tokens to be legit, there needs to be enough liquidity, enough users trading volume, et cetera. So that's why we cannot just easily support any ERC 20 token. And also if you want to do transfer tokens in a decentralized manner that involves various different token pools, other security mechanism that we are going to, mechanisms that we are going to cover today as well so that's why we cannot support every single token in the same way that you cannot get the price of every single token using data feeds, for example.
00:12:12.294 - 00:13:28.586, Speaker A: Also you can send any kind of data, and by any kind of data I literally mean that. So it can be anything that is bytes. So CCP understand the language of bytes. So anything that is bytes, like going from simple hello world of text messages to some encode that solid instructs to for example function signatures or data payload, whatever can be sent using chainlink CCP as long as you know how to decode it on other side, more on that later. And finally, what you can do is you can combine both token transfers and sending arbitrary data, which we are going to do actually today. Now, when it comes to receiver, if you're receiving tokens again, any address can be a receiver because tokens will arrive. The only difference is if you're sending arbitrary data, if you have that data payload that you need to decode, then you need to just implement one function which is CCIP receive function because Don will through an EVM off ram contract, then through the router contract eventually will call that function on your smart contract to pass the data payload.
00:13:28.586 - 00:14:43.458, Speaker A: So if a receiver of a message is externally owned account or a smart contract that has not implemented that function properly, only tokens will arrive. Now the question here is what if you want to receive both and your contract logic depends on receiving both data and tokens. Like what if you are not aware that you haven't implemented CCAP receive function correctly? Or more problematic way is what if you implemented it correctly but there is an edge case or a bug in CCIP receive for example gas limits or something like that. You have a modifier whatever and you don't want just tokens to arrive. You want also both tokens and data to arrive because it affects your contract logic. For that there is a really good smart contract example inside applications folder of CcAp NPM package called defensivexample Sol and we are going to use some primitives from that defensive example Sol contract. Today I'm going to teach you how you can use ccapdefenseample SL contract.
00:14:43.458 - 00:15:45.446, Speaker A: Also, if you go to official docs, you can find transferring tokens with CCP defensive example. So I highly encourage you to check it out afterwards. Basically, if there is a bug or something wrong with CCP receive function, or of course like data haven't arrived, defensivexample will help us to lock the tokens and not release them until that bug is resolved. So yeah, this is a basic CCAP architecture. So from the user point of view, as I said, with the post office example, you're just going to interact with a router contract. Inside is like this black box black magic thing called CCAP which will deliver your crosschain message and you can just monitor it. Actually, there is a CCAP explorer at CCAP chain link, which is a website for Explorer.
00:15:45.446 - 00:16:50.574, Speaker A: It's the same way as you can monitor your package when you're sending it using post office. Fantastic. So now this is a higher image or a higher picture when it comes to processing a CCP master. So this is this black box we're talking about. Again, you absolutely don't need to know all of the tiny details about it, but it is useful sometimes to have this page bookmarked or to go to official docs to refresh, especially when it comes to debugging, because you will get much more sense about what went wrong when you compare your smart contract and CCAP contracts as well. But basically the number one step is that you're going to prepare the message so there can be tokens and data and you're going to interact with the router contract. Now, router contract will interact with this on ramp smart contract right on ramp smart contract on wrap smart contract I saw the question, I'll answer it later on.
00:16:50.574 - 00:17:44.206, Speaker A: Wrap smart contract will emit an event specific event that risk management network. This is off chain decentralized Oracle network off chain component and committing Don. Again, off chain component will listen for also executing Don will listen for that event, but not going to do anything particularly important, but these two will do. Also, if you're sending some tokens, router contract will interact with this token pool smart contract for the particular token you're sending. So token will be either locked or burned on the source chain. We're going to refresh on token mechanism as well. Then committing done will wait for a finalized tag on a source blockchain once the transaction or batch of transactions that are monitoring has been finalized on a source blockchain.
00:17:44.206 - 00:18:32.170, Speaker A: And that time depends really on the blockchain itself. For Ethereum Mainet, that's straight to epochs. For some other blockchains it's faster or longer. Depends, but that's for security reasons. To avoid chain reorg, when the finalized tag was emitted or finality has happened, the committee zone will put the transaction or recreate like a mini part of Merkel Tree with all of the finalized transactions and will put that Merkel Tree to the commit store smart contract, which we cannot see on this diagram. Now risk management network will monitor both source blockchain and destination blockchain. And when this event on onram blockchain happens, it will also wait for finalized tag and it will also recreate the Merkel tree.
00:18:32.170 - 00:19:44.486, Speaker A: The thing is that at this point, risk management network will compare its own Merkel tree and the Merkel tree reported at the commit store blockchain. So risk management network is a network of independent node operators, which means that every single node operator will actually listen to the underrated contract and will actually recreate its own version of Merkel Tree. Then each single node will compare its own representation of Merkel tree with the one reported by committing Don and will vote with blast or curse. The thing is that when enough threshold of blast votes happened, then the transfer or sending of a crosschain message will continue. If for whatever reason there is a curse, enough curse votes for a cursed threshold, the status of a message will be cursed. And at that point the sending of cross train message will be stopped immediately. The thing is that also these nodes can vote multiple times.
00:19:44.486 - 00:20:28.342, Speaker A: But the thing is that once they vote curse, they cannot go back to blast as well. So that's one important thing to matter. So this is all due to security reasons, right? When we see a blast tag at CCP Explorer, that's usually a good thing. That means that there is no chain reorg on a source blockchain or our transaction was left on a wrong fork, or there is something like sequencer is down, for example, if it's l two or whatever, that's usually good. So everything's okay with the source blockchain and we can proceed with the execution itself. So that comes the execution done into a play. Execution done.
00:20:28.342 - 00:21:18.262, Speaker A: Another off chain component will monitor from events from a commit store contract where the actual blast or cursed attack will be reported and depends on that. It will call the offram contract which will pass the call to the router contract which finally going to deliver the message again. If we have token transfers, then there will be an interaction with a token pool to mint or unlock or unfreeze the appropriate amount of tokens on the destination blockchain. And those are going to be delivered to your receiver. Cool, let me quickly go to the chat now. Yeah, Richard said that quick reminder, if you have a chat question, you can ask into the Q A section. I'm going to answer this one.
00:21:18.262 - 00:22:22.266, Speaker A: How fast is delivery of the data from the sender to receiver? How we measure the speed, that really depends on the source blockchain. Both combination of source and destination, but more on the source blockchain. So as I said, finality time on Ethereum is straight to epochs, so you cannot expect crosschain message to arrive before that. So this is all due to security reasons, right? So whenever finality has been reached on source blockchain, then we have this round of votes for blast and cursed by the off chain components and then just another transaction on a destination blockchain. Which really depends how long is to include the transaction in the next block on the destination blockchain as well. You are going to see your data and tokens immediately. But also, maybe you want to wait for finality on the other side as well.
00:22:22.266 - 00:22:49.054, Speaker A: That's totally up to you. Team CCP will wait. So basically it depends on finality time on both source and destination blockchain, but mostly on source blockchain. Regarding Q-A-I think there was a question like what does dawn mean? And that should be answered. But dawn stands for decentralized Oracle network. It's a network of independent nodes. It's not a blockchain.
00:22:49.054 - 00:23:21.330, Speaker A: Decentralized oracle network is not a blockchain. It just serves to reach a consensus on some off chain or on chain data and computation and that's it. It's like a middleware layer for all blockchains. And dawn is one of the main components of the Chainlink protocol as well. Chainlink is much more than just an oracle, by the way, guys. It's a platform with a lot of different services. So make sure to check a lot of different, as I said, services or products besides Chainlink.
00:23:21.330 - 00:23:43.380, Speaker A: CCP. Chain CCP. Just one piece of products available. Cool. Okay, we don't want this prepare. We all covered that live. This is the picture of how Merkel Tree really simplified Merkel tree looks like.
00:23:43.380 - 00:24:36.614, Speaker A: And basically what the risk management network compare is root hashes. So if you don't know what root hash is or what Mercotray is, there is a nice video and also like a YouTube short by Richard on our official YouTube channel. So just search for it. It has like tons of views. It's really informative piece of video. Cool. Now, as I said, do we need to know all of that? Well, definitely not, right? If you think of sending a crotching message or CCAP as a post express office or like international flight or whatever analogy you're going to use, the thing is that you're going to always interact with the router contract, provide the receiver address and destination chain selector, and that's pretty much it.
00:24:36.614 - 00:25:47.654, Speaker A: Like sit and relax, maybe monitor the CCP explorer for the message to arrive and that's it. Like if you're flying from JFK to Barcelona, al Prat airport, for example, this is a nice analogy from the last Narcon, which was in Barcelona. Basically, when you come to, let's say, JFK airport, and you're going to go straight to the check in desk, you're gonna check in your luggage and then that's it, right? So you can now walk by, get some, I don't know, like coffee or something to eat, drink, whatever. There are going to be several screenings or security checks, right? Just for the security of everyone in the plane and outside, basically. So your canned luggage, if any, will be scanned and all that stuff. But yeah, that's pretty much it. Then you're going to sit back, relax in the airplane, have a lovely flight, you're going to land to Spain, go to passport control once again in Spain, and then finally you're going to collect your luggage under the hood or behind the scenes.
00:25:47.654 - 00:26:40.134, Speaker A: A lot of stuff will happen with your checked in luggage, including that maybe they will going to open it and you'll see that tag or note that your luggage has been opened for a security screening or security check. Same things go with the cross chain message, right? So if you take CCF as an international flight, you can see how you can have a mental model of what committing done, risk management, network and executing done are doing. But the thing is that you're going to have a lovely flight. And airplane industry is a huge one. A lot of people and a lot of technique is included, a lot of smart people, engineers and all that stuff. Working really hard for you to have, for all of us, actually, to have a lovely fight, same things go with CCAP. So again, no need to know all of these details precisely.
00:26:40.134 - 00:27:26.426, Speaker A: This is just a simple analogy if you want to have a metal model. But sometimes it is important or informative to go to our official documentation and check some of these sections, specifically when you're debugging something and you want to debug stuff faster. Cool. Now, let's start with the first exercise. So the first exercise is this tiny token transfer. Basically, it's going to be a simple, warm exercise for all of us to transfer a simple token and to get it first from the faucet to set up our environment for the main exercise. Right? So for this one I'm going to use remix, but you can also use hardhead and foundry if you want.
00:27:26.426 - 00:28:15.210, Speaker A: These are like all the steps for hardhead and foundry. If you notice any bug or something, because it's possible like this is for hardhead with latest node version latest version of Hardhead with ethers v six in typescript. If we want to use javascript or veeam, maybe something's going to be different. So yeah, make sure to tweet that to me or some other channel of communication to maybe update or expand this getbook. It's not always that the easiest thing to do, but I assume that if you're using Harkit or foundry, you're already pretty fluent in working with those environments. I'm going to use Remix, as I said. So I'm going to just go to remix ethereum.org,
00:28:15.210 - 00:29:00.410, Speaker A: which is a URL for remix ide online code editor online id for working on smart contract development I'm going to create a new workspace by clicking here Create new workspace. I'm going to choose the blank template and I'm going to just name it CCap Masterclass module two. You can name it however you want. Let's just zoom it a bit so it's a bit easier for you to follow up. Cool. Alternatively, of course, we have starter kits for hangerhead and Palmdrit, so you can just git clone those. They are available at the following URLs.
00:29:00.410 - 00:29:50.970, Speaker A: Now one thing that to remember that for us to use chaining CCap, we'll need this at MPM package, which is official NPM package with all of these smart contracts and a couple of helper library interfaces, which libraries interfaces that we can use and we will use today when working with CCIP. So this is the URL to the official NPM package. These are the instructions for you to install the package using hardhead and foundry. Also, we're going to install official chainlink contracts package. We are going to need both of those. If you're in remix, you're just going to copy this empty smart contract. Remix will import it manually.
00:29:50.970 - 00:30:18.126, Speaker A: So yeah, again, if you're using with other frameworks, you'll see the actual steps. So I created a new empty SL file. I copied the content of the file. I'm going to switch to 0.8.19 version. I'm going to hit compile, hit compile command s, whatever my smart contract has been compiled. All greens.
00:30:18.126 - 00:30:45.702, Speaker A: That's good. And also I see that the new depths folder was generated from NPM chain name contract Ccp blah blah. I finally imported client library, which is this one. We're going to use it highly cool. So I just validated that my setup works. So I'm going to continue for the transferring of tokens you can transfer two type of tokens at the moment, CCAP Bnm and Ccp lnm. Ccp Bnm stands for burn and mint.
00:30:45.702 - 00:31:25.000, Speaker A: Ccp lnm stands for lock and mint and both of them are like simple ERC 20 tokens that has a different transfer of tokens mechanisms. When it comes to CCAP, there are total three token transfer mechanisms. We are going to explain and deep dive into it during the exercise. Number two, but just for you to know that we are going to use both of these tokens today. Ccp bnm you can mint on any single blockchain. Ccp lnm you can mint only on ethereum sepolia. So for now what I'm going to do is, and you can see all of the details here.
00:31:25.000 - 00:32:19.718, Speaker A: For now what I'm going to do is that I'm going to mint Ccp bnm using the official documentation. You can also use Etherscan or whatever method you want because you can mint one one unit of these tokens using this drip function. So you can call drip how many times you want. Again, probably the easiest way is to just click on this URL and you can mint it straight from the docs. So I'm currently at avalanche Fuji testnet, so this is the one. If you don't have it, there is also a URL in a gitbook, but I can show it to you that you can go to chainlist.org. There will be a URL pretty soon in the next chapter, but you can do that now as well.
00:32:19.718 - 00:33:05.606, Speaker A: And you can just click add metamask to add it to your metamask, right? So you can see that I can only mint one Ccp Bnm token, but I can add both them to address to wallet. Sorry, this is just because lnm can be, as I said, minted on sepolia and you will have lnm like a wrapped or synthetic version on other blockchains. Right? So you can add that address here. So I'm going to hit this mint one Ccp bnm button and that's a metamask pop up. Great. I'm going to confirm it and wait for a transaction to be included in the next block. So you can see that here and also in the wallet as well.
00:33:05.606 - 00:33:28.282, Speaker A: So you can see that it's pending calling the drip function. So again, this is the easiest way to get it. You can also like I did it. You can also do that from the lock explorer, from your script, whatever you can also here it is, add it to the wallet. I already have it. But if you don't, just click the button and you will see something like this. Fantastic.
00:33:28.282 - 00:34:05.386, Speaker A: Cool. Let's now transfer this CCP BnM token, right? So to do that I'm going to develop this CCP token sender. Unsafe. Smart contract. Unsafe is intentionally here because this is the minimal code required for us. Not the minimal code required actually I added some extra to be more efficient, but pretty much really short smart contract just for us to warm up as I said. So what I'm going to do now is I'm going to copy the content of all of this smart contract and I'm going to go back to remix id.
00:34:05.386 - 00:34:30.926, Speaker A: I'm going to collapse all this stuff and I'm going to create a new file and name it CCP token sender. Underscore unsafe. So just paste it here. This is a warning. All good. I know what I'm doing and compile it, right. So besides all of these imports, you can see that I'm using for example safe here, c 20 from open sapling.
00:34:30.926 - 00:35:02.810, Speaker A: So this is some extra owner is created to put on the owner modifier. So those all can be excluded as well. But yeah, our main function is this one actually transfer. So we're transferring to this blockchain, to this address. On this blockchain I'll put my wallet address, this token and this amount of this token. This token will be CcpBNN and I'll put some arbitrary amount. So here I'm just putting these two parameters in array.
00:35:02.810 - 00:35:41.382, Speaker A: This is array of tokens that I'm transferring. And now this is our message. So I'm packing my package that I want to go to the post office to post officer to send it, right? So I'm going to put the receiver address here, I need to encode it because again, if we want to add bitcoin in the future or Polkadot, they don't reference accounts with the same address length. So we're just going to encode it at bytes and decode it on the destination side if needed. I don't need for this use case, I'm not sending any data. So I'm leaving this as empty. I'm sending tokens.
00:35:41.382 - 00:36:03.262, Speaker A: So I'm providing my token amounts array from the above as the tokens. I'm sending extra arguments. I can leave it also as empty. This is the default value. But I'm going to actually specify it manually because gas limit I'm going to put to zero. Why? Because I don't have CCP receiver function, CCP receive function. So I don't need that extra gas to be called.
00:36:03.262 - 00:36:34.934, Speaker A: So I'm saving actually some money here on fees because I'm putting this gas limit to zero. Meaning that I'm going to just pass the tokens to my wallet, right? And for fees I'm going to use link token. You can also use a native coin like native coin or wrapped representation of native coin. So avax or wrapped avax. If you want to use that then you're going to put address zero here. But I'm going to use link token as my token for fees. Then I'm going to calculate the fees.
00:36:34.934 - 00:37:23.386, Speaker A: So for this specific message to this blockchain, okay, this is the fees amount and if I don't have it enough in this smart contract, it will rework. So I'm going to approve CCP router just to spend that amount of fees, not like the maximum possible, right? And then I'm going to transfer inside this smart contract from my wallet, CCp Bnm. And then I'm going to approve router to also spend my amount of CCP Bnm from this smart contract in order to interact with the token pool. And finally I'm just going to call CcP send function and that's it. Right. Cool. At the end I'm going to emit some event and.
00:37:23.386 - 00:37:39.998, Speaker A: Yeah, let's do that now. So pretty simple. Smart contract as a warm up, as I said. So let's prepare for deployment. This is the URL if you want to go to chainlist. I already added avalanche fuji as you already saw. So I can just continue.
00:37:39.998 - 00:38:16.422, Speaker A: So what I need to do is I need to deploy this smart contract and if you saw my constructor, I need to provide the CCP router contract address and the link token address, right? So you can see here router address and link token address. So I already compiled it. I'm going to deploy it to avalanche Fuji. So to do that, I'm going to switch from remix VM to injected provider metamask over here. And it will connect with my metamask wallet. So you can see here 43113. This is the chain id or for avalanche Fuji blockchain.
00:38:16.422 - 00:39:05.514, Speaker A: If I change the blockchain network from my wallet here, it will change automatically. So that's kind of what we're going to do today a lot. So I want to deploy this smart contract. So I need to provide CCFP router contract address and link token address, right? So where I can find those, I can find those obviously in a gitbox so I can just copy paste it from here, right? This is router. But the thing is that basically if you go here, there is a supported networks section at the very top. So if I click to supported networks, I want to go to testnets and then several testnets available here. I'm looking for Fuji testnet and this is the router here, 554-4544 this is the same one, right? So this is the one I posted here.
00:39:05.514 - 00:39:22.538, Speaker A: So same things. Go for link if I want to. So these are supported fee tokens. I'm paying with the first one with link. So I'm going to copy that address as well and paste it here. Finally, I'm going to hit transact to deploy this smart contract. And this is a metamask pop up.
00:39:22.538 - 00:40:13.326, Speaker A: I'm going to hit confirm and wait for a transaction to be included in the next block which just happened. So this is my contract now finally because I have this line. So I'm transferring TCP BNM tokens from my wallet to this smart contract. I need to approve this smart contract to spend the appropriate amount of CCP BNM on my behalf. Secondly, you can just send CCP bnms to your smart contract. So to do that first actually because I'm paying for CCP fees and link, this is the URL to the CCP faucet and if you click here, I don't need to log in with twitter because I don't need avax, I just need 20 link. I can grab some free link tokens for fees.
00:40:13.326 - 00:41:10.462, Speaker A: So I just need to solve a captcha and this one is particularly hard one. Okay, this is the bear here and the bear here and send request and I'm just going to wait for my links to arrive, right? So this is the first thing that I need to do if you don't already have links on avalanche Fuji in your wallet, right? So I'm just going to wait for confirmation of it. This is now waiting for a transaction to be included in the next block which just happened. We're just waiting to be finalized and I can also click on the transaction hash to go to the explorer if I want to, which I don't. Cool. If I open my wallet I will see 20 new links. What I started to talk about is that you will need to approve.
00:41:10.462 - 00:41:50.830, Speaker A: This is the thing you will need to approve on CCP BNm smart contract token page to approve our smart contract to spend some amount of it before that because I already have those links and copied this address. Let's copy it again. I'm going to send one link as specified in a gitbook to it for fees. So here are like new links. Paste the address here. So this is the address of this smart contract. And I'm sending one link, right, hit next and yeah, hit confirm.
00:41:50.830 - 00:42:24.442, Speaker A: We're going to wait for this transaction to be included in the next block. What just happened? Cool. Now, because we already have one link, let's do the final step, which is approving approval. So I'm going to go to this URL also. You can go just to explore and manually copy the address. Or you can go here actually, and if I click to CCP Bnm, this thing, it will again go to the same page. So you will need to connect your wallet, which I already did.
00:42:24.442 - 00:42:55.698, Speaker A: So you'll see a connect wallet button here. Connect it from metamask, pop up, boom. You want to call this approve function. So spender is my smart contract and I'm going to send 100 units of CCAP BnM. So I'm going to hit write to initiate this transaction. You can see that I'm allowing this amount of CCp Bnm. So really tiny amount of CCBNM to be spent by my, our contract.
00:42:55.698 - 00:43:32.906, Speaker A: So I'm just going to hit approve button and wait for this Transaction to be included in Xbox, right? It's still pending. It's confirmed. So the final step will be just to now we prepared everything to just, if you go here to just send the first message and how. Well, let's examine the code. So we have this transfer function. So destination chain selector, I'm transferring to Ethereum, sepolia. So what I want to do is now to collapse all of this, go to Sepolia and boom.
00:43:32.906 - 00:43:51.142, Speaker A: This is the chain selector for Sepolia. So I'm going to copy this one. Receiver will be my wallet address. So I'm sending to myself these tokens. So I'm going to paste it here, tokens, which I'm sending is CCP BnM. So I can grab it from here, of course. D, two, one, three.
00:43:51.142 - 00:44:22.634, Speaker A: Let's see. D, two, one, three. And I'm going to send those 100 units because this is what I approved previously. Obviously if you go here, you can just copy paste the values from here. But keep in mind that docs are always up to date, so you should always referral to the official documentation. So hit transact metamask, pop up. And finally sending the package, sending the cross chain message using the router contract.
00:44:22.634 - 00:45:12.414, Speaker A: So I'm interacting with the router contract here you can see transaction hash, right? So I'm going to copy the transaction hash and go to CCAP chain link. This is the block explorer. So CCAP chain link and I'm gonna search for my transaction, right, so you can see here the live status of transaction. And we can see already that the source was finalized because Alan Fuji is actually pretty fast. So I'm using it a lot for CCAP stuff because of that, right, so you can now monitor the live status of your cross chain message in the same way that you can monitor the sending of your package. You can see the source transaction hash r ones. This destination one is not yet available because we are still waiting now for these blockchain components to do their own thing.
00:45:12.414 - 00:45:49.082, Speaker A: And you can see a bunch of other details as well if you go back to Gitbook. This is the URL for CCP Explorer. So CCP chain link and this is this message. While we're waiting, we can examine a code a bit. So we send the message using the CCP send function which comes from this irouter client interface. And you can just provide destination chain selector and the message object. So if I go to our code, it's here destination, CCp send destination chase selector and message message is the struct from here.
00:45:49.082 - 00:46:39.990, Speaker A: So if I go back, message is actually coming from the library, from the client library and more precisely it's EVM to any message struct on the destination side. If you want to decode it is any to EVM message. So keep in mind that, but you can see you have receiver data array of tokens, address for fees and bytes for extra arguments. This is struct for array of tokens, consists basically of token address and amount you're sending. This is struct for extra arguments, gas limit and strict sequencing. This is just some extra reading material for you. If you want to know what all of these means in detail on the other side, we're not using that, but if you want to implement that famous CCP receive function, this is the signature and it's come from this interface.
00:46:39.990 - 00:47:23.050, Speaker A: So it's any two EVM message, different struct but pretty much similar. So you have message id, unique id of a crosschain message source chain selector so you're aware from which blockchain the message came. Sender, the ones who initiate the sending of crosschain transaction data, data payload if any and tokens if any. Token amount. EVM token amount is the exactly same struct as before. And this is a good manpower model so you can see what's necessary on the source side and on the destination side, one of my favorite images. If I go to CCP explorer, you can see now the status changed to committed.
00:47:23.050 - 00:48:08.586, Speaker A: That means that committing done now committed that Merkel tree or Merkel tree with transactions to the commit store contract. So we are now waiting from risk management network to do its own thing to bless it essentially. Okay, this is pretty much it for this exercise. We can examine a bit more of code if you want, but if you don't want and you're kind of getting bored or whatever, now is the time for you for maybe to start playing a bit. We're going to have 25 minutes. Actually, not 20. Let's do 25 minutes.
00:48:08.586 - 00:48:32.298, Speaker A: So at 06:00 p.m.. 15. 06:15 p.m. Et we are going to continue with the exercise number two. So until then you will have time to recreate this example by yourself. Just follow the steps from the getbook as I did. It's pretty straightforward.
00:48:32.298 - 00:49:12.998, Speaker A: As you already saw, I copy pasted everything from the getbook. But the goal is not to just copy paste, but to actually understand what we are doing. So there are plenty of reading material for you if you finish earlier to also check out. And yeah, I'll be sharing this screen for a bit. Just we are going to wait for a success tag to see a success message and then we are going to play some lo fi music as well. So yeah, the main takeaway from this picture is that EVM to any message is not the same as any to EVM message. So two different structs.
00:49:12.998 - 00:49:33.182, Speaker A: Be aware of that. The reason why they exist and are different is if we want to support non EVM blockchain, which we want in the future. Like, I don't know, like bitcoin or whatever. Cool. While we're waiting, maybe I can answer some questions. Right? Cool. Awesome breakdown.
00:49:33.182 - 00:50:00.826, Speaker A: Thank you. What if the user has no link token? If users don't have link token, you can actually pay for CCIP fees using the native asset. Native coin on Ethereum will be ether or its own wrapped interpretation wrapped ether. Cool. We can now see that the status is success. That's pretty much it for this exercise. So you can now start working on your own.
00:50:00.826 - 00:50:25.570, Speaker A: This is what we want to see, this green status message. And also we can always check the destination transaction cash as well. I tried to get a test link from the faucet and didn't show it up on the wallet. I did receive Avax. You don't need to receive James. You'll just need to add link token to the wallet. Maybe that's the issue.
00:50:25.570 - 00:51:00.334, Speaker A: So if you go here and find other resources, you can find link token addresses, link or link token contracts. What you can do is you can go to let's see where avalanche is. Fuji testnet just collapsed this zone thing so I can see better. Sorry about that. And this is the address of link token on avalanche Fuji. So you can just click on add to wallet and you can add this asset to a wallet and it will appear like this. You can see like 94 so just try to do that.
00:51:00.334 - 00:51:39.590, Speaker A: Maybe that was the issue. Does this mean that we cannot send message from BSV? I'm not sure what BSV is but you can use all the supported blockchains. You can find them here. Supported networks for both mainet and testnet. Cool. Yeah that's pretty much it. I will answer all of this q a stuff asyncly so we can just play some lo fi and you can peacefully watch work on your examples.
00:51:39.590 - 00:52:02.866, Speaker A: But yeah, we'll be back here at 06:15 p.m. Eastern time. Cool. Stop sharing screen and yeah, I'm going to continue with answering questions in a QA. And yeah we're going to have some lo fi and let's just quickly edit the slide. So it's not 06:00 p.m. It's 06:15 p.m.
00:52:02.866 - 00:52:29.210, Speaker A: So we can just have that as well. I think like 25 minutes is more than enough time for coding exercise. Right? So share screen and hopefully we'll have lo fi pretty soon. Cool guys, see you in a bit. Okay, cool. You should be able to hear me again. We are going to start just in a minute.
00:52:29.210 - 00:53:04.918, Speaker A: I hope this first exercise wasn't too hard. If you still need some time to finish it up, that's completely fine. And okay. And yeah, let's just share this screen and it'll be nice if you can, as I read it, just post a proof of transaction or transaction hash in a chat so we can know that you did it and we can also congratulate you if you have any issues. That's also very welcome to be posted in a chat. Cool. Now let's start with exercise number two.
00:53:04.918 - 00:53:41.646, Speaker A: Our main exercise, our cross chain staking dap. So first, before we start, let's just now cover these token handling mechanisms. There was a question about it in the Q a session so I just said that I'm going to explain it now. And yeah, we can build on top of it. So when it comes to token handling mechanisms, there are three currently supported burn and mint lock and mint and burn and unlock in reverse and lock and unlock with a current version of CCAP. Burn and mint and lock and mint. Burn and unlock are supported.
00:53:41.646 - 00:54:26.494, Speaker A: Lock and unlock are coming soon. Burn and mint is basically the token mechanism that CCAP BNM test token is using. It's usable when you can mint the same token in multiple different blockchains. For example, USDC is a good example of production ready token that has that capability. And basically what burning mint mechanism will do is that if you're transferring that type of token, it will burn it on the source chain and mint it on the other blockchain. Freshly minted new tokens so you can have it in your wallet. So that's basically happened when we transferred CCP BNm.
00:54:26.494 - 00:55:29.906, Speaker A: We burn it on avalanche Fuji and it was minted on ethereum supportion. Second one is lock and mint and in reverse burning lock. It's useful when you have a token only on one blockchain, for example, that can be link wrapdth or whatever. Wrap DTH is actually not a good example, but link is a good example. And in our testnet scenario, that's CCP lnm. So basically you were going to have that CCP lnm, the original version only on the one blockchain, and on all the others you will have actually this wrapped or synthetic version that's ClCCPl in CCP lnm's case. So basically what's going to happen is that you're going to lock it on one chain, mint it on another on that chain that you can mint CCPLM, and in reverse you're going to burn it and unlock.
00:55:29.906 - 00:56:07.486, Speaker A: The wrapped representation on other third one is lock and unlock. Basically it's useful when you have that synthetics or wrapped implementation to now send it to some third blockchain. Right? We are lock and unlock feature. Cool. Another thing that I want to mention is something called rate limits. Rate limits is basically a security feature for token pools itself. As I said, this burning, minting, locking, unlocking is happening all on the token pools for each particular Token.
00:56:07.486 - 00:56:58.882, Speaker A: And now let's see which available rate limits exist. The first one is network rate limit, and the second one is token rate limit. So network rate limit is basically a total USD value that can be transferred from one network across all available lanes. And that value comes from chaining data feeds. And token rate limits is about a total number of tokens itself that can be in a token pool. Let's see that on example, shall we? So four different entities are important. So bucket is basically the total value of tokens that can be transferred at a given moment, capacity is the full capacity of the bucket, right? Refill rate is basically rate at which the bucket is refilled, more on that later.
00:56:58.882 - 00:57:49.982, Speaker A: And finally, availability, the current amount of value in USDC that is present in the bucket. So this is the value of token and this is the amount of value in USDC. So let's say that we have this, and basically if you expand this, you can see the actual code. So that's everything on a blockchain on smart contract, right? So let's say that we have an example of this refill rate. And obviously for each of these examples, you can go to docs and see the actual values for each tokens, et cetera. So if I go to CCAP supported network to testnets and I want to see for example, let's do the CCp bnm. So CCp BNM, I transferred it from Fuji testnet to sepolia testnet.
00:57:49.982 - 00:58:10.362, Speaker A: Cool. Rate limit capacity. It's 100,000 CCAP bnm. This is the whole bucket that can be there. And this is the refill rate. Basically 167 CCp bnm per second. Okay, so we just simplified these numbers for this example.
00:58:10.362 - 00:59:15.786, Speaker A: Let's say that the capacity is $100,000 and the refill rate is $100 per second in the value of token units. So at the first moment, like deployment t zero, the bucket is empty after 100 seconds. The bucket consists of basically $10,000, right? 100 per number per second. So 100 times 100 is 10,000. After 300 seconds, we have $30,000 of tokens in a bucket. And now if we have a user that wants to send, for example, $40,000, this sending of this transaction will revert actually. And you can find all of the error messages here helpful for debugging, for example, or for monitoring on your front end, it will revert because hey user, you need to wait for 100 more seconds for this bucket to be refilled, for example at 400 seconds.
00:59:15.786 - 00:59:57.834, Speaker A: So 100 seconds later, user can now retry with its transaction and transfer will succeed. So there is $40,000 of token in a bucket so that exactly the same amount will be transferred. And now the bucket is also again empty after 100 seconds. Again or 500 seconds. From the beginning of this example, we'll have again $10,000 in a bucket. And after 1400 seconds, bucket will be maxed at 100,000 capacity. And in this moment, refuel will stop, basically until a new transit happens.
00:59:57.834 - 01:00:24.450, Speaker A: This is just a security thing. If token pool gets drained. So this is a reasonable amount that can be recovered in a case of black swan event. Okay, cool. For this example, we are going to use also open zeppelin contracts. So we need to install that one as well. So if you're using Harhet or foundry, these are the steps.
01:00:24.450 - 01:01:10.638, Speaker A: Basically the only reason why we're using open zeppelin is reentrancy guard. And you want to use this four time eight four times zero version just because the rest of the contracts are at that version. Open Zeppelin had a recent breaking change, so let's just downgrade a bit. This is just for reentrancy guard contract for non reentant modifiers. So in terms of remix ide, what I need to do is I need to just import this reenter ciguard from openzeppelin. I'm going to reuse my empty SL smart contract for this thing. So I'm just going to override it with here all green dependencies.
01:01:10.638 - 01:01:39.382, Speaker A: Here's the open zeppelin. Lovely. That's what I wanted. Cool. For this example, we will also need, besides CCp VnM Ccp lnm token, which we're going to use basically as an LP token for staking. So what I need to do is that I need to, well, mint it again to call that drip function, as I said, multiple times. So CCp Lnm for minting is available only on ethereum sepulia, not in other blockchains.
01:01:39.382 - 01:02:09.942, Speaker A: And if you go to click on this URL, let's click actually on this URL. I lost it. You can see here that when you're on fuji that you can only add the ClCCP lnm to wallet. But if you want to mint it, you will need to switch to ethereum sepolia, sorry. Which I'm going to do now. So I switched to sepolia, saw that this button appeared. So I want to click that button right.
01:02:09.942 - 01:03:04.658, Speaker A: So this will mint one ccp lm token to my wallet address. What you want to do if you don't have it in your wallet already, is that you can maybe click on this button. So you will see this token in your wallet like I can see it now, or for example. So let's see the activity. This is still pending, so I'm going to just wait for this transaction to be included in a net block and continue. Obviously, as I already said, you can drip call this drip function from explorer, from your scripts, from your smart contracts, for example. So I'm going to pre fill my staking contract with this ccp lnm but maybe you will want to manually call the drip function to drip or to mint new amount of tokens, Ccvl and m tokens.
01:03:04.658 - 01:03:56.146, Speaker A: So maybe something for you to think about it if you want to build on top of this example. Cool. Let's see what we are actually building. So we are going to deploy this simplified staking smart contract. That's a staking contract. This is one of the defi dapps that exists or you want to create and it has this stake function. So basically you can stake on behalf of any address, right? So in our example Alice can stake for example hers Ccp Bnm tokens on avalanche Fuji on behalf of bob address or her own address or her own some different address doesn't matter, right? So whatever address is specified as on behalf address to that address, CCp lnm tokens will be minted.
01:03:56.146 - 01:05:49.878, Speaker A: So we're going to send crosschain message from this crosschain sender data source smart contract to the crosschain receiver, right? So that crosschain message will contain both tokens and data payload and data payload will be that on behalf address, right? So crosschain receiver upon receiving tokens, PNM tokens and the details about on behalf address will inside CCAP receive function call the stake function of simplified staking smart contract and provide the amount of CcAP Bnm Alice wants to stake and the on behalf address which can be bobbed for example. So now simplified staking will transfer from CCp BnM tokens and transfer back Ccp lnm tokens to Bob. Bob then can transfer these Ccp lnm tokens to Charlie on polygon Mumbai for example using our tiny token transfer we created during the first exercise. So at the end we're just going to combine two smart contracts, two exercises. Actually there's more than two contracts, two exercises for that final step. Also our bonus exercise if you finish it earlier or homework exercise will be to send a reply message. So that means that when crosschain receiver received crosschain message like tokens and data from crosschain sender from Alice and calls this stake and get a confirmation from stake that everything worked well, send a replay message to crosschain sender again saying this address has now staked this amount or got this amount of CCP LNM.
01:05:49.878 - 01:06:37.686, Speaker A: And there is a mapping already here in crosschain sender just that functionality has not been implemented. That's something for you maybe to do as a follow up or today during the bonus exercise if you are fast enough. But before we start with the development. Let's now see a couple of security best practices that are highly advisable to be used and that we are going to have in our smart contract. First one is that you want to verify destination chain. So when you're transferring crosschain message, you want to specify to which blockchains users can send those crosschain messages. When you're receiving crosschain messages you want to verify from which blockchains you want to receive these messages.
01:06:37.686 - 01:07:06.190, Speaker A: So verify source chain. Also. Maybe it depends on your use case, but maybe it will be clever or smart enough to verify the sender. So from which address or which accounts from specific blockchains you can receive crosschain messages. From. The rest you will definitely just not going to receive any, it will be result in a failed transaction by default. 100%.
01:07:06.190 - 01:08:14.342, Speaker A: You always, always want to verify router address because due to architecture of CCP, if there is a breaking change or some new release or support of new token for transfers or new blockchain which is non EVM or whatever, maybe CCP will under the hood needs to add that feature, remove that feature, whatever. As I said, you're just interacting with the router contract and that's it. You don't care what post office or airplane industry is doing behind the scenes. So you always want to verify that the router address contract is correct and you want to make it mutable if possible. So you can just easily update the router contract instead of upgrading or redeploying your whole dap. Setting a gas limit as I said, when you're transferring tokens it's zero. But when you're transferring tokens and data, this is the maximum amount of gas that calling the CCP receive function costs and this amount is non refundable, so you want to measure it upfront.
01:08:14.342 - 01:08:51.382, Speaker A: So we are going to set the gas limits manually as a function parameter. But what you want to do is to measure it using either eth underscore estimate gas, which is basically available in JSON RPC API. So you can call it on any client node. You can use hardhat or foundry built in tools for gas measurement. There is a plugin at Harhat, there is a CAS command or a flag actually. Sorry. When you're running forge test in foundry you can use alchemy for example.
01:08:51.382 - 01:09:47.282, Speaker A: They have an nice dashboard, et cetera, et cetera, et cetera. We will have a section on this particular thing or measuring the gas limits in the following master classes, so make sure to don't miss those. But following these URLs, you will be able to do it by yourself. Pretty straightforward. And finally our defensive example. So our contract logic heavily depends on both tokens and data, more precisely on behalf of address, right? So if tokens arrive but something's wrong with CCP receive crushing receiver does not know on behalf of which address to stake the received tokens. And it now has like tons of these TCP VNM tokens received, but doesn't know what to do with them.
01:09:47.282 - 01:10:37.170, Speaker A: So to do that we implemented something called defensive example. And I'm going to quickly show you the code and then we are going to comment on it. So we're going to go to crosschain receiver and you can see now that first there is this only self modifier. That's the new thing. This is the CCP receive contract, right? So CCP receive contract has this receive contract has this only router modifier and only allow listed modifier for both source chain selector and the sender. So both of these are like combined in a single modifier. That means that I want to only receive tokens and data from my cross chain sender.
01:10:37.170 - 01:11:12.658, Speaker A: Smart contract from avalanche Fuji. That's it. And I want this function because it's external to be called only by the CCP router on Ethereum support. That's it. Now I'm going to use this try catch mechanism that solidity has and I'll call process message. This one we're going to talk a bit on process message later and it's intentionally empty. So if everything's okay, no action needed, right, I'm just going to pass the call.
01:11:12.658 - 01:12:17.282, Speaker A: But if there is any error catched, we have an array, actually not array mapping here that sets this message id with some error code. For this example, there are only two error codes like basic ones and basic and give me a second. And resolved. So basic is error, resolved is all good. So obviously you can expand this and to add multiple different error codes so you know what happened and you can have multiple if statements like a switch case scenario and solidity. And you can leave this basic error code as a default one if none of these previous worked out. But for now we're going to have just basic end result, right? And I'm going to put in this mapping the keys message id, the content, the message content itself and emit an event it not reverts.
01:12:17.282 - 01:12:53.380, Speaker A: That's why it's in catch block. So to prevent the reverting the whole CCIP flow. So CCP message will arrive. You will see a success tag in a CCAP explorer. Nothing bad will happen but you will see an event. And also you can check these mappings to see that something went wrong. And if you figure out what went wrong and how you can solve the issue, maybe increase gas or allow this sender or allow this source chain, whatever the issue can be.
01:12:53.380 - 01:13:48.894, Speaker A: Or for example if you want to call the stake function but you didn't approve, simplify staking contract to spend your tokens. You can just call the approve function there and retry the message. So process message does pretty much nothing except it calls the underscore CCP receive function. And also for testing purposes there is this sim revert flag. So you can practice testing and how your Dap will react if there is an error in black swan event. So you can do like test drills basically. But also you can see that only your contract can call this process message function, right that we are calling it basically here CCP receive.
01:13:48.894 - 01:14:26.420, Speaker A: Let's scroll down. CCP receive underscore CCP receive actually doing the actual logic. So approving simplified staking to spend this amount of tokens and calling the stake function, right. This is the function for only owner to set sim revert flag for testing purposes. And let's see how retry failed message function looks like. So you're going to provide message id and token receiver. So at this moment tokens are locked and it will not be available to underscore CCP receive function.
01:14:26.420 - 01:15:04.510, Speaker A: So you are going to check the error codes. Basic is basically an error code but you can have more granular logic here of course. And you want to set the status now to resolve. So to prevent for this checkup basically to not revert, to revert in future. Sorry. And you're going to get from that mapping the actual message and just do the safe transfer of tokens to the receiver, whoever the receiver is. In our case that's our smart contract.
01:15:04.510 - 01:15:47.658, Speaker A: And also the amount that's needed and emit message recovered event. And if I scroll up to defensive example, this is basically what is stated here. So receiving and processing messaging is doing through the CCP receive function. Then it called process message which calls underscore CCP receive. If there is an error it will be stored in a mapping and you can reprocess the field messages like this. You saw all of that finally emit a message recover event. This is this retry fail message function.
01:15:47.658 - 01:16:20.070, Speaker A: Cool. Let's now start with the coding of this exercise. So the first thing that we are going to do is that we'll have this tiny interface for simplified staking. So stake and unstake so our CCp receive can call it. So I'm going to copy this, go back to remax and create I simplified staking sol smart contract. Let's move it actually from dependency. Sorry, that was my bad.
01:16:20.070 - 01:16:48.590, Speaker A: Can I move this? Let's delete it. Yeah, I want to delete this because does not belong here. It belongs here. I simplified staking so cool. Let's put the capital s. So I'm going to copy the content of the file here and compile it. Pretty simple, pretty straightforward, nothing major there.
01:16:48.590 - 01:17:20.582, Speaker A: Then I want to develop the actual simplified staking contract. Let's first copy the content of it and then we can comment the code of it. So that will be simplified staking as well. And let's see our staking smart contract. Basically it again used this safe here c 20 library for token transfers. It has these two tokens. So one is staking token, the other is LP token.
01:17:20.582 - 01:17:37.278, Speaker A: Sorry staking token is CCp bnm. LP token is CCp lnm. Simple as that. So we support only two tokens. Basically a couple of events, nothing major here. Stake function. So stake function, extremely simple.
01:17:37.278 - 01:18:27.322, Speaker A: Transferring staking token or CCP BNM to the smart contract, updating the internal mapping. So stakes basically for this on behalf of address and transferring LP tokens back to the on behalf of address. Unstaking works in reward. So you can first cannot unstake more than you staked. And then transferring LP or CCP lnm to the smart contract and returning CCp Bnm from the smart contract to the message sender. Finally you have this withdrawal function that only Omer can call because we're going to pre fill LP tokens Ccp lnms by just sending them from our wallet. So you can just withdraw them as an admin or user.
01:18:27.322 - 01:19:03.046, Speaker A: Obviously in reality this is simplified. For example you might be want to mint it, have token pools, LP providers and whatnot. After simplified staking we need to develop crosschain receiver and crosschain sender. Let's start with crosschain receiver. So let's create crosschain receiver Sol and copy the content here, save it. Besides these regular imports, let's see what we have. So we have this enumerable map.
01:19:03.046 - 01:20:06.526, Speaker A: This is a fancy mapping for by 32 to un. We're going to use it for some extra functionalities that opens up and gives beyond regular mappings and solidity enum for our codes, we already saw this code base. You can see this special enum is for failed messages. Then simplified staking this is the address of simplified think smart contract. A couple of storage variables and these two mappings are for allow listed source chains and senders and finally mapping for message content of the failed message. Right, a couple of events, a bit more errors and then a constructor where we are just going to setting the simplified staking address so we know our address of our staking contract and it's immutable by the way. So that's something for you to maybe notice and think about it.
01:20:06.526 - 01:21:35.290, Speaker A: Do you need that kind of feature or functionality for your devs? A couple of modifiers so only allow listed and only self we already saw that functions to allow list source chain and allow listender and the rest of the code base we already saw so ccap receive with this feature to find process message and catch errors but not revert just emit the event so the whole flow can continue. The actual process message function for retrying, trying the pale message to unlock tokens, function to set sim revert flag for testing purposes and the actual underscore CpCCP receiver which will call the stake function. Finally there is a view function to see all the failed message ids so all keys of these mappings so you can see the actual message ids that failed. Cool. Finally let's develop our crosschain senders, right which will be on avalanche fuji. Yeah, so again you can just copy it and we're going to examine the code together. So what I need to do is to name it crosschain sender sol and paste it here compile all green.
01:21:35.290 - 01:22:19.450, Speaker A: That's what we want. So crosschain sender has this mapping of liquid tokens amount on top. This is for extra bonus exercise for homework. So yeah this is for reply message. There is this enum which allows user to pick whether it's going to pay for fees in native coin or in link token I'm going to use link but you can use native as well. A couple of storage variables mapping for allow listed destination chains, a couple of errors and one event. This receive function exists so you can transfer native coins to this smart contract for fees purposes.
01:22:19.450 - 01:23:09.010, Speaker A: Modifier for that mapping from top and function which only owner can call which allows destination chain. Finally this is our send function, the most important one. So it has this extra modifier that we didn't have in the first exercise and after that pretty much the same thing. So we are setting token amounts like we did earlier. We are sending a receiver address. We're sending now data payload which will be this on behalf of address and now the important thing is that because this is bytes that on the receiver side, this underscore CCP receive knows how to decode it. So you can see it decodes data payload data field to address to the actual data tape type in solidity.
01:23:09.010 - 01:23:46.470, Speaker A: Because we don't want bytes, we want address. Sometimes you want bytes so you're not going to decode it, but if not you'll decode it like this. That's why we're encoding it from here, because you must send bytes here. Token amounts, the array of token amounts that we are sending. That's all good extra arguments. Now instead of hard coding gas limit, we are providing gas limit as a function argument as well. Also this EVM extra arguments v one, v one specifically said, and you can find that in our docs that this can be changed.
01:23:46.470 - 01:25:03.114, Speaker A: For example if you want to add a new feature or something to expand, or maybe to expand this struct or maybe to remove this strict flag or whatever that good practice is that this extra arguments field is mutable in this smart contract is not. But this is a good practice that we are missing. So you definitely want to do that for production ready contracts that you want to be on mainet because maybe you're going to miss some important CCPI update or really cool features that basically your smart contract can't use. Finally, fee token depends on the value of enum we are also providing. We're going to select either link token address or address zero, which says that we are going to pay with native coin aka message value again calculating fees for this specific message on this destination chain selector from the router. And now if you're paying with link, we're going to check for balance, approve link, and then transfer tokens again. So this is the same logic we had in the first exercise, transfer tokens in the smart contract approving router to spend it and call the CCP send function.
01:25:03.114 - 01:25:54.094, Speaker A: If you're fame within native, there is no need for any approval of any kind for a p token because it's message value. But the syntax is a bit different because you'll need to provide a value like this because it's message value. Finally, we're just emitting an event and this is two functions that only owner again can call to withdraw tokens and to withdraw, sorry, native coins and tokens. This is basically to withdraw native coins or tokens or link tokens you're using for CCIP fees. Cool. Let's finally now do our exercise. So the first thing is that we want to deploy the simplified staking as well.
01:25:54.094 - 01:26:19.160, Speaker A: On ethereum sepolia, this is the contract that defi contract or defi app that already exists. We need to deploy it because it's not existing, our example. But maybe that can be, I don't know, like Aave for example. You want to do something with Aave so you don't have this step, of course. But we're going to deploy it. We need to deploy it on ethereum sepolium, so on ethereum sepole. So how to do that? First, collapse all of this.
01:26:19.160 - 01:26:56.430, Speaker A: Go to simplify staking, compile it once again. Compile it here for example. Then make sure that you're on Sepolia. I am at the moment because I took those Ccpl and m. But make sure you are also, you can see I am also 115511 is a chain id for sepolia. So if you see that you're good simplified staking, let's collapse this one. So we need to provide staking token address which is CCp Bnm and lp token address which is CCp lnm.
01:26:56.430 - 01:27:27.082, Speaker A: Again, you can get it from beginningbook, but all of them are available at official docs. So you can go to because you're on sepolia, sepolia to Fuji. You can see addresses for both Ccp Bnm and Ccp lnm. So just going to copy those and paste it in remix. And if you go here, you can also see that Ccp Bnm is fd whatever and 46 is lnm. So these are the same. So staking token again.
01:27:27.082 - 01:28:20.358, Speaker A: Staking token is Ccp Bnm lp token is CCp lnm. Totally up to you how you're going to have your logic or name those in your contract. But this simplifies taking this approach. So I'm going to deploy this to sepolio and wait for a transaction to be included in a nice block. The next step is that I will need to transfer some CCp lnm tokens to this simplified staking. The reason for that is that initial liquidity that I'm going to provide as an admin and also I can withdraw those tokens later if needed. So to do that, I first need to wait for smart contract to be deployed, which just happened.
01:28:20.358 - 01:28:53.630, Speaker A: So to do that I need to copy this address p five and go to metamask, check CCp lnm. Right, here it is ccp lnm paste the address and I'm going to send 0.5 but you can send 1210 whatever. This is initial liquidity. I'm going to send 0.5 ccp lms and hit next. This means that I'm pre filling again simply by staking with some initial liquidity.
01:28:53.630 - 01:29:25.902, Speaker A: So cool. We now don't just wait for this transaction to be included in the next blog, but we basically set up our defi simplified staking dap that we want to interact again. If you're using other whatever that's already there. Cool. Now let's deploy crosschain receiver and crosschain sender on appropriate blockchain. So we're going to start with crosschain receiver mostly because we are already on a greeterium sepolia. Right? So we are already on a blockchain where simplified staking is.
01:29:25.902 - 01:30:05.498, Speaker A: So to do that, I'm going to click on crosschain receiver and compile that smart contract. I'm going to go back and select crosschain receiver from this. So now if I go to constructor, you can see that I need to provide the router address and the simplify staking address. So when it comes to CCP router address, this is the router address on a blockchain where this smart contract is. So in this example, this is Sepolia router, right. So I can provide it like this from get a book D whatever. But if you go to supported network sephola, you can see that d zero d.
01:30:05.498 - 01:30:29.710, Speaker A: This is the exact same array. This is the address. Basically we want router address on that blockchain. Simplified staking is the address of our smart contract we just deployed. So let's just hit this copy and let's see DD five. Okay, that sounds about right. And hit transact.
01:30:29.710 - 01:31:08.170, Speaker A: This means that we are deploying now CCP receiver smart contract to sepholia test network. We're going to wait for this transaction to be included in the next block and we are going to continue with the rest of the masterclass. Cool. It's confirmed. We can go on. Now we want to deploy crosschain sender but that smart contract is an avalanche Fuji. So to do that I'm going to follow the same steps, but I will need to switch to switch network before deployment.
01:31:08.170 - 01:31:48.170, Speaker A: So the same steps means that I'm going to go now to crosschain sender. I'm going to compile the smart contract and now I'm still an injected provider but I'm going to open my remix my metamask. So this is important moment. Open metamask and switching from sepolia to avalanche fujis chain. So I'm changing the network but I'm not refreshing anything. I'm still in the same view, same environment. And you can notice here that this chain id changed from 115511 to 431143 which is a chain id for avalanche Fuji.
01:31:48.170 - 01:32:21.734, Speaker A: Now I need to provide CCP router address but which one the router address on a blockchain that this smart contract will live will be deployed on. So this is the CCP router contract address on avalanche Fuji. Again, you can grab that from the gitbook but if you go here and collapse all this stuff now we were looking for Fuji. This is Fuji. This is the router address for analanz Fuji. 55447 A 5544. Yeah, that's cool.
01:32:21.734 - 01:33:06.094, Speaker A: Now I'm going to paste it here. Same you will want to paste link token address this one and the staking token address which is CCp Bnm which is this. See b these are the same but always refer to the official docs and just hit transact. This will deploy our new smart contract. You can see new contract on avalanche Fuji chain basis contract deployment. So this is all good. Hit confirm and wait for a transaction to be included in the next block.
01:33:06.094 - 01:33:36.720, Speaker A: Here it is. So crosschain sender, crosschain receiver simplified staking. If I try to view some get router it'll be all zeros because I called the function on this address on a completely different blockchain so it doesn't have a context or anything. So that's zero. This is also a good task for you to know that you're on a wrong blockchain, blah blah. So if I just switch to sephole on my metamask and call the function again, I will see the actual router contract. And this is great.
01:33:36.720 - 01:34:23.306, Speaker A: Cool. Now because we're going to send cross chain messages from the cross chain sender. We're gonna fund it with some link for CCP fees. For bonus exercise you will want to fund CCAP receiver function also with link because it will send the reply message basically. But for now I'm just funding crosschain sender with link for CCP fees and I can do like that. So I'm going to copy the address, I'm going to go to metamask, I'm going to find my tokens and I can just spend for example five links. So because I want to spend to send multiple messages, I don't want to refund it all the time.
01:34:23.306 - 01:34:52.510, Speaker A: So I'm just going to send five and leave it as is. So file link. Great. So I'm going to just wait again for a transaction to be included in another block and then we can proceed. Cool. Finally. It's not actually finally, but we have a couple of more steps.
01:34:52.510 - 01:35:23.482, Speaker A: You probably have a sense that the next step will be the same next step from the last exercise. So we are going to approve again our new contract to spend some amount of Ccp Bnm we have. So I'm going to copy again. But we already have it copied. So again this is CCp Bnm. Our wallet is already connected. So you can just go to this for example screen and this is probably what you can see.
01:35:23.482 - 01:35:55.842, Speaker A: So just switch spender to this new CcP sender contract. Cross chain sender smart contract instead of the previous 100 is fine. We can stake hundred of CCp BNN and hit right. This is just for testing purposes. In reality that's a really small unit. You can see zero point 160. But yeah, I can approve our new contract to spend this amount of my precious on lovely CGP Bnm tokens.
01:35:55.842 - 01:36:47.000, Speaker A: So these are all the same thing that things that I did for the first exercise. In the first exercise, previous exercise, we just sent the message afterwards. Now we are going to allow list those destination and source blockchain and senders for extra security and then we're going to send the message. So that's what I'm going to do now as an extra step. So you can see here that first on crosschain sender smart contract I want to call allow destination chain function. I'm going to provide the chain selector of Ethereum sepolia because that's my destination chain and the true field. So how to do that I need to locate allow destination chain function.
01:36:47.000 - 01:37:08.650, Speaker A: Here it is. Allow destination chain. So I'm sending from avalanche Fuji to Ethereum sepolia. So let's find the chain selector of sepolia testnet. Here it is. Chain selector of sepolia. I'm going to provide that one here and allowed a strip.
01:37:08.650 - 01:37:59.878, Speaker A: I'm going to hit transact and I'm going to just confirm it. Wait for this transaction to be included in an act block and we can convenient. You can also when this is not pending anymore, validate. Yeah, here it is here using this public function which is a view one which is public mapping basically was this chain selector allow listed? Yes. Fantastic. Next one we need to now go switch back to ethereum suppolia to go back to crosschain receiver to call allow list sender and allow list source chain. So these two functions I need to call.
01:37:59.878 - 01:38:45.110, Speaker A: So to do that, first I'm going to scroll this to monitor this environment tab. I'm going to open my metamask and switch back to Sepolia. So I'm changing networks again from avalanche Fuji to ethereum sepolia to allow list our newly deployed smart contract as a sender. So I'm on Sepolia, notice the change 115511 chain id of sepolia and I want to interact with crosschain receiver. So I want to call allow list sender. So sender is crosschain sender the address that I want to receive messages from. So I'm going to put it here and put true here as allowed.
01:38:45.110 - 01:39:13.054, Speaker A: So let's hit transact and let's confirm it and wait for this transaction to be included in the Nag block still pending. Sepolia is a bit busy at the moment. Cool. It's confirmed. And let's do the same thing with a source chain. So allow list source chain. I'm on ethereum sepolia.
01:39:13.054 - 01:39:38.700, Speaker A: I want to allow list the source chain. So I want to receive messages from avalanche Fuji. So I'm going to go to supported network networks and find the chain selector of avalanche Fuji. And you can see 114. This is the same thing but always, always refer to the official recommendation. So sour chain selector. True.
01:39:38.700 - 01:40:03.902, Speaker A: And hit transact as well. So I'm going to hit confirm and wait for this transaction to be included in an x block which just happened. Cool. I can always now validate that. So let's first get router. So you can see this is the router address. Let's see if this source chain was allow listed.
01:40:03.902 - 01:40:21.338, Speaker A: Yes. Let's try a different one. Let's try for Example polygon mumbai. Do we want to receive messages from polygon Mumbai? No, we just want to send Lm tokens later. So this one is false for example. And also I can do the same thing for sender. Right? Okay.
01:40:21.338 - 01:40:45.962, Speaker A: Sender. Is it allow listed? Cool. It's really helpful for debugging by the way. Cool. And finally after I did these extra steps, I can now send the crosschain message. So for do that I'm going to use cross chain sender. I'm gonna go back to avalanche Fuji, send the message and then monitor the status on the CCP explorer page.
01:40:45.962 - 01:41:05.750, Speaker A: So I'm going to go back to remix. I'm going to again changing networks. I'm changing networks from ethereum sepolia to avalanche Fuji. Because my sender is an avalanche Fuji. So avalanche Fuji C chain. Let's validate that in remix. Cool.
01:41:05.750 - 01:41:28.590, Speaker A: 43113. That's cool. And we want to call the send function. So send function is this one. Actually if I go to crosschain sender is this one. So you can see doing a lot of stuff here. And these are all the parameters that I need to provide.
01:41:28.590 - 01:42:07.610, Speaker A: So the first one is destination chain selector. We can just copy paste them from here but let's do it like a real raw example. Destination chain selector. So I'm sending to sepolia. So again sepolia copy paste receiver is cross chain receiver. So receiver of the cross chain message is cross chain receiver contract which will then call the stake function on the simplified staking contract. So receiver is crosschain receiver copy.
01:42:07.610 - 01:42:50.978, Speaker A: Let's see here it is on behalf of. That's Alice address, Bob's address, charlie's address, whatever I'm going to put myself as on behalf address. So I want my wallet address to receive these CCpl and Ms on the destination chain which I can then use to send it to polygon mumbai. To chart amount I'm spending is 100 because this is the amount I approved previously for fees. I'm going to use link. So pay fees is an enum. So enum basically corresponds to uint eight.
01:42:50.978 - 01:43:28.020, Speaker A: So enum in any programming language is like these human readable values but under the hood is all numbers. So under the hood native is zero, link is one, some other element will be two, et cetera. So that's why I'm providing here one instead of link as handily written. And finally gas limits. So as I said, you want to measure this. I'm going to put for now 500,000 because that's more than enough. But in the following master classes I will teach you how you can measure this actually.
01:43:28.020 - 01:43:45.930, Speaker A: So let's now transact this. All good. No issues for now and hit confirm. I want to wait now for. Yeah here it is for transaction hash. So let's grab it for a bit. Transaction hash is here.
01:43:45.930 - 01:44:49.040, Speaker A: Copy. So I can search for it in CCP Explorer. I'm going to paste it here and yeah we can now monitor the status of this message. After this message is success you will want to go to receiver to validate that there is no failed messages and also to go to simplified staking to see that your tokens has been transferred lnm tokens. So there is a mapping there to see basically how much of tokens have you staked. After we do that, while I'm answering questions I'm going to transfer those tokens to Polygon Mumbai as well. But you can start working on this example is 30 minutes fine with you guys or you want more or less 45? Totally up to you.
01:44:49.040 - 01:46:05.080, Speaker A: Write down in the chat when we decide. I suggest 30 minutes, but we can do more when we decide on that, we're going to play some lo fi and after that exercise time we are going to cover these debugging tips and tricks, chapter, sub chapter or chapter, and we are going to wrap the master class for today. So yeah, while we're waiting, let's see if there are any questions and consensus. Unanswered questions and consensus on wow, another transaction. Nice one, Narby and consensus of time for exercising. I suggest 30 minutes, but we can do more. How do I send you a line number? You can just send a transaction hash or if you have any errors, repo for Gitbook is not live, but maybe you can send the line number and the contract itself so I can easily search it to Gitbook if that's okay.
01:46:05.080 - 01:46:36.122, Speaker A: Develop prosthetic sender section. First line in remix tab has Error. Okay, cool. That means that you need to change the compiler version. Okay, cool. So basically where is the remix? So if the error is the first one, that usually means that compiler version is not okay. So just switch to 0.8.19
01:46:36.122 - 01:47:18.080, Speaker A: or whatever and you should be fine. So that usually means that also if you have an error, let's do like this. So let's compile it and okay cool. There is an error. You can always see what the error is and you can paste the error to me so I can help you answer it. Or there is this nice feed that feature that you can ask chat JBT what went wrong and it will actually provide you an answer saying that hey, your compiler version is not correct and you will need to fix it. Cool.
01:47:18.080 - 01:47:50.850, Speaker A: If the file name is wrong, then just change the file name. That's fine, I can edit it if that's the issue. Cool. Let's collapse all this. I started delayed because of time. How do I catch there will be a replay of this masterclass Kelly so I'm not sure when but you should receive it on your email. You can always go through Gitbook.
01:47:50.850 - 01:48:27.266, Speaker A: So we just covered step by step instructions from gitbook. So if you're more into reading materials then you don't need the video. Video will be applied uploaded at some point and also there is a link to the masterclass number one, the previous one from summer where you can see the content we did there if you want to check it out. Okay, let's go back to CCP explorer fantastic. It's successful. That's good. Git book link is here.
01:48:27.266 - 01:48:42.940, Speaker A: Just scroll a bit. Through chat? No. Okay, cool. Sorry. Let's see. Yeah, here it is. This is just all of it in the chat team will find it.
01:48:42.940 - 01:49:03.294, Speaker A: You're welcome. Cool. This means that our message was successfully delivered. But we still want to check if everything went okay with our defensive example. Right. So what I want to do now is I am on avalanche Fuji. So I will now switch back.
01:49:03.294 - 01:49:50.814, Speaker A: So I'm changing networks again to Ethereum Sepolia for the very last time to see what went wrong. And while I'm on Sepolia, I can also transfer my lnm tokens to other addresses on Polygon mobile. This three means that I received tokens because I had two. But let's validate that in general case. So if I go back to crosschain receiver, there is this function called get failed messages message ids. View one and you can see that this array is empty. This is good.
01:49:50.814 - 01:50:35.014, Speaker A: That means that there were no errors. We can now simulate this if you want, for whatever reason to be true or false, but everything went fine. That means that if I go now to simplify staking and there is this stakes array. If I put my address here, I should be able to see that I staked 100 units of this token. And here it is, 100. That means that everything went fine with the receiving of our smart contract, with our cross train message. However, with a defensive example, you can always see what went wrong and you can always resimilate or reply the sending of retrieve.
01:50:35.014 - 01:50:51.314, Speaker A: Sorry, not reply. Retrieve. The sending of cross chain message on the destination side. So just that final part. Cool. Now let's see. So let's start at 07:45 p.m.
01:50:51.314 - 01:51:09.030, Speaker A: Eastern time. So if that's fine with you. No, actually let's do 740. So 740 or 745, we'll see. Depends how it's going to go with you. We're going to continue with the master class. So we're going to play some lo fi now.
01:51:09.030 - 01:51:48.654, Speaker A: And then we're going to continue in 30 minutes after you finish this exercise so you can start working on it. Now for the very last thing, I'm just going to combine exercise number one with this one. So I'm going to deploy this token transfer again on Sepolia. And I'm going to send my LP Tokens to Polygon Mumbai. And also you have this bonus exercise if you did really fast and really well, or you can do it for homework, that you can expand this example to add a reply message back. So 30 minutes for exercise. While we're waiting.
01:51:48.654 - 01:52:22.560, Speaker A: I'm going to do this really quickly without much of explaining because we already did that. So just to show you that that's possible as well while you're working some lo fi and then debugging tips and tricks and next steps afterwards. So cool. That'll be it. Let's now quickly repeat the process for sending. So that will be what? Crosschain CCP token sender. I can just deploy it to Sepolia again.
01:52:22.560 - 01:52:40.600, Speaker A: Router will be router on Sepolia. Boom. Here it is. Link token address will be link on Sepholia. Boom. Transact. Let's deploy this smart contract really quickly.
01:52:40.600 - 01:53:03.290, Speaker A: Fantastic. Let's now approve Ccp lnm to spend it on my behalf. So I want to go here. I'm going to looking for a pro message. So I'm going to connect with my wallet. Perfect. This is a pro function.
01:53:03.290 - 01:53:23.094, Speaker A: You can see this is extremely easy, extremely straightforward. This is CCP token sender unsafe. So I'm going to copy it. So I'm improving. I can do again 100 the amount I received. Yeah, I want to approve. I'll be there.
01:53:23.094 - 01:53:59.062, Speaker A: I'm going to wait for this to be included in the next block. And finally I'm just going to send my llm tokens from Sepholia now to Polygon Mumbai to myself again. So how can I do that? Well, you remember there is this transfer function. So destination chain selector now is polygon Mumbai. So I'm going to do polygon Mumbai chain selector. This one, receiver is my address. I'm sending my address.
01:53:59.062 - 01:54:29.120, Speaker A: I'm sending 100 units of CCP alnam. This one, boom, boom, transact. And this is going to fail. Why? Because I haven't funded token sender with links. So to do that, I'm just going to send one link to cover for CCP fees. One. Let's wait for this.
01:54:29.120 - 01:54:58.178, Speaker A: But yeah, having these failed transactions is often very good because you can practice debugging basically and see what went wrong. But this was like extremely straightforward error. Like, yeah, I cannot send the message if I don't have enough for fees. Let's see now, it's all better. I have enough for fees. And yeah, let's hit confirm. And also it's a nice thing that you can see it reverted with not enough balance.
01:54:58.178 - 01:55:32.610, Speaker A: So I actually can see from here what's going on. Like current balance is zero and this is the approximate amount of fees. So that's why I had an error. So as a final step, I can again put this transaction hash here and now monitor the transfer from Ethereum Sepolia to Polygon Mumbai. Cool. Yeah, that's just combining exercise number one with exercise number two. I'm going to stop sharing my screen and I'll see you all again at 07:40 p.m.
01:55:32.610 - 01:55:55.900, Speaker A: Eastern time. So that's in 28 minutes. If you have any questions again about exercise, just drop it in a chat or q and a section and I'll answer it. Type it. See you later, guys. Okay, cool. You should be able to hear me again and see our cutting time has officially over.
01:55:55.900 - 01:56:43.430, Speaker A: I saw that one person had issues, so yeah, if you had issues, try debug yourself. I'm going to show you a couple of tricks now, or you can always, after this master class, go through steps again. Just follow carefully, step by step, read through it with your own pace afterwards, but not lo fi music to disturb you or whatever and should be fine. If not, you can always post a stack overflow or stack exchange question tag chain link, and we're going to follow up, either us or someone from the community. Cool. Our last topic for today is really something. As a bonus exercise, I would say let's go to transaction details.
01:56:43.430 - 01:57:38.998, Speaker A: This is just a CCP Explorer page from our transfer from Ethereum to Mumbai. Just a successful one, and as I said, this one final one is more like a bonus chapter. Something I wanted to share with you about debugging tips and tricks, something I use oftentimes. This is like the majority of the most common tools and techniques I use when it comes to debugging CCP stuff, and I thought you may find it useful. Okay, so here I'm going to start with a couple of screenshots. Unfortunately, some of them are my call red was resolved, so I cannot go through them again. But the thing is that if you want to understand more how to debug CCP problems, it's really good to always refer to processing the CCP message lifecycle.
01:57:38.998 - 01:58:41.386, Speaker A: It's linked here in the intro of this masterclass, and also there is always up to date information on official documentation, so that sometimes can be useful to know the actual flow and which contract will call, which contract, et cetera, to be aware of all of those external calls and where the execution may fail. The second, probably even more important skill is to understand the solidity compilation process. So this is a quick diagram of what is going on on a very high level. When you compile solidity, which is a high level language through some of these compilers, so I use the version 0.8.19 as a version of compiler. You can use whatever you want. But the thing is that when you compile a solidity file, it will go through compiler and two main outputs will be generated.
01:58:41.386 - 01:58:59.490, Speaker A: The first one is contract bin and the second one is contract AbI. Abi is just a giant JSon. And let's actually show that in practice. So let's compile. Let's see. So, ABI and bytecode. So, compilation details.
01:58:59.490 - 01:59:15.034, Speaker A: Here it is. So you can see there are like a bunch of other stuff. But let's collapse this. Let's collapse this. This is the ABi. So, Abi is basically gianting JSON file. It's really pretty here.
01:59:15.034 - 01:59:38.014, Speaker A: So if I open it here and JSON viewer. This one is. Let's see, this one is not. Let's go to this one. Okay, yeah, sure. So you can see here that this is a gianting JSON file. Basically this is just simplified version.
01:59:38.014 - 02:00:20.094, Speaker A: Nice one that we can see on remix. And it consists of all of, you can see customer events, function, signatures, all the stuff that this contract has. The reason for that is that you can easily interact with the contract using your front end or whatever contract bin or. EVM bytecode is just a giant hex number, hexadecimal number. It's essentially a set of instructions for the EVM to execute. So, for example, if you see 60, like a number 60, that's push zero of code. Then some value.
02:00:20.094 - 02:01:01.502, Speaker A: That means that sequence means that EVM will push that value on stack, and so forth and so forth. So this is something that EVM will execute. And if I go back here, and now if I see the bytecode, you can see here in a much prettier way. But if I copy the bytecode and maybe go here, scroll down a bit, paste it here, you can see it's a gigantic hex value. Really gigantic. And if I scroll back all the way to beginning, these are the set of instructions that EVM will do under the hood. Push, push zero.
02:01:01.502 - 02:01:37.594, Speaker A: So I'm going to push value 80, push 00:40 and all that stuff. Almost all smart contracts. EVM bytecode starts with this sequence. This is some memory allocation at the beginning. But this is a set of instructions that EVM will execute. So all the time when you have smart contract, you will get Evi and EVM bytecode. Now, this huge hex number, it's not really clear and readable to us.
02:01:37.594 - 02:02:31.210, Speaker A: And we cannot decode its content without an ABI. With an ABI, it's extremely straightforward to do that, to do so, because in this giant hex number, there will be a function signature of some specific function, which if we go to ABi, we can see where that came from, et cetera, et cetera. So there are like bunch of different tools for ABi encoding and decoding. And this is particularly important to know that this thing exists because it will help you debug cc pairs much, much easier. Right, cool. Now let's go back to our gitbook. So the first error that you will mostly encounter is the error on the receiver side.
02:02:31.210 - 02:03:50.370, Speaker A: So sending a crosschain message went through, you funded it, everything went cool, all great. And then something happened on the receiver side, and you don't know what. So you can see something like this. So if your smart contract is unverified on etherscan, and all of our smart contracts that we deployed actually were unverified because we didn't verify them due to time limits, I would say for this masterclass, we need to keep it at some reasonable time frame. So that means that CCP explorer without an ABI will not be able to decode the message, but it will display the error code. So this is the error code. So from top of your mind, it's unclear what went wrong, although you kind of can see that either some function or some, because this is an error, probably this is like the custom error happened because there is this first sequence of characters, which kind of looks like a function selector or something, unique identifier for custom errors or something like that, and then a couple of leading zeros and then some content.
02:03:50.370 - 02:04:24.782, Speaker A: So leading zeros, that usually means that this is an address. Address is 20 bytes, you need to put it in a 32 bytes field. So kind of you get a sense that this is an address, but of course you're not sure what went wrong. Right. And this is actually a screenshot from one cross chain message that I got from my colleague. So when he started working on CCP on the first, it was, it was unclear to him what happened. So it's a high probability that this already happened to you or will be.
02:04:24.782 - 02:04:56.774, Speaker A: But in reality, this error is really easy to solve if you have Abi. Right. With the ABI, it's extremely easy to decode this value. So to do that, you can use a couple of online tools. This one is probably my favorite. And also foundry has this cast ABI and code decode functions, cheat codes functions, whatever, from Cli. So it's really easy when you have a contest or where you have Abi to do that to do so.
02:04:56.774 - 02:05:32.306, Speaker A: So when I got this error or this message, I told to my colleague, hey, can you just send me an ABI of a smart contract and I can help you. And what I did is that I went to this tool. So basically you will provide an, you will provide input data, and when you hit decode, you will see whatever decode value is. This is a function basically, yeah, bid on striggle. This is a function, right. But yeah, what you can do is you can put the ABI here. So you can see this is the actual ABI big one.
02:05:32.306 - 02:06:07.438, Speaker A: This is the input and we can see the output. So the output is sender not whitelisted and some parameters that means that sender not whitelisted error, custom error was generated, was thrown actually. And with this value. So if I go back here now, you can see that this sequence starts with CD 93, whatever ends with zero, d 65. And this is the value we got. So you can see CD 93. So our initial clue that this is do something with the address make completely sense.
02:06:07.438 - 02:07:21.350, Speaker A: So this is actually the sender. So that means that whoever sended this function called the allow source chain function on the receiver side, but didn't call the allow sender function on the receiver side, and we got this error, which was pretty easy to decode and to figure it out what went wrong. So most of the times, not most of the time, all the times you will see the actual error code if your smart contract is not verified on the CCP Explorer. So CCP, it's clever enough to tell you not only that something went wrong, but what went wrong. And to give you the ability to manually re execute the function when you figured out what went wrong in this particular scenario, what we need to do is just to call the allow sender function on the receiver side and go to CCP Explorer and click that manual execution button. That's it. Obviously if you're a power user you can do much, much cooler stuff.
02:07:21.350 - 02:08:15.126, Speaker A: So in the official repo CCP repo, you can go here and click on the link. There is this script, basically called CCP revert reason script, and I use it all the time, so it's really easy to use. It's extremely simple. So you either need to provide error code string like the one we just had, and it will try to go through a list of known APIs to decode it. If that's not possible, you will then use this inputs. So you'll need to provide either error code string or these chain id, TX hash and TX requester and you will need to have inside tnv JSON RPCrl with an archive node. That means that you want to check something on Sepolia, you go to Alchemy, put that JSON RPCrl in Env and run it.
02:08:15.126 - 02:09:20.090, Speaker A: Because alchemy by default is an archive node or something like that. You get a point and it will execute it and you will see the actual decoded error, or in a human readable way what ran wrong. So if you run this basic example, what you will see, and I pasted you the contents of the file as well. If you want to have just the script itself, you will see that it will display something like this. So if you access an array, bytes and array slides, blah blah, and you were like hey, what's that? But the thing is that if you search a bit for this, or you're like a solidity power user, you will see that this essentially mean that EVM panic code 32 was drawn out. So this one was particularly tricky error, because this is essentially a panic error on an EVM side. So something really bad went wrong on a receiver side on the contract itself, not related to CCIP, so not related to CCIP.
02:09:20.090 - 02:09:58.118, Speaker A: And if you scroll down a bit, you can see that this is exactly panic 32, right? So basically in the receiver side there was an array and CCP receive function. Tried to access an element of array which were not there, not exist. So something with like I don't know if there is a loop or something. Just be sure that you specify the ranges of the loop precisely. And that's it. So in this scenario, if a contract is not upgradable, they will probably need to re update or redeploy. Sorry, redeploy the contract.
02:09:58.118 - 02:10:39.382, Speaker A: But yeah, like using this script, you'll solve like 90% of your troubles. So this one is pretty easy with a tool and pretty straightforward if you have Avi and all that stuff. But if not, this is probably your swiss knife when it comes to errors. So highly recommend to check it out. It's all public, it's all open source, so you can just run it and see what actually went wrong. You just as again need to provide either error code string or these parameters. Now probably not, probably.
02:10:39.382 - 02:11:30.626, Speaker A: I think this is the most common one, is to see something like this. So error code is ux. So this means that you have some really nasty bug, which it's not easily discoverable solidity, which kind of sucks. But if you know what your code base is doing, then you can figure it out. For example, a really nasty one was that there was a hackathon participant wanted to use that cross chain Nft minting adjusted a bit. But the thing is that he wanted to call a function with multiple parameters, and when he called API encode selector or encode the signature, he had like a white space between comma and the actual dcheep of, of a variable he want to pass. So this results in a completely different hash.
02:11:30.626 - 02:12:07.390, Speaker A: So crosschain destination wasn't able to call the function. So it will just trigger some unknown function or some unknown chunk of bytes on an NFT contract. This one was really nasty. So this type of type is like error code zero x, but most of the time it just means that it's out of gas error. So that's why we are now specifying this gas limit manually and provided as a function parameters. So something like a design taught for you. But in reality if you use that syntax like default one, that means that basically you're out of gas.
02:12:07.390 - 02:13:14.150, Speaker A: Gas limit is gas needed for execution of this function is higher than a gas limit. So what you can do is you can again trigger manual execution here and you can provide gas limit override and boom, you will be ready to execute, right? So yeah, what I said is that this essentially means that your CCP receive function costs or consumes more gas than this default to 200,000. And this syntax is doing exactly the same. So what you want is as we did to manually set a gas limit also I said that, but I'm going to repeat it. This eVm extra arguments v one is a struct that needs to be immutable. It's the best practice to keep it mutable because it will change in future with new upgrades to CCP rather well itself. So maybe if you want to access some pretty cool feature of CCF in future on a production code base, you may want to leave this field or destruct mutable.
02:13:14.150 - 02:14:03.094, Speaker A: Essentially under hood it's all bytes, so you can literally just combine and hash it as a bytes instead of have this solidity syntax however is easier for you. Also I post these random CCP tips regularly, so maybe you want to follow for them or just search for my user handle and this sequence of characters like random CCP tips. It's not a string, I don't know, and it will display all of these random CCP tips. So yeah, how you can solve this? Well yeah, you can just set gas limits manually and on the sender side and that's it. In the future you will not need to re execute the trigger. Manual execution override et cetera. What you need to keep in mind is.
02:14:03.094 - 02:14:34.962, Speaker A: I already said it. We have a question. Okay, cool. Client EVM registers two different arguments as opposed to one argument. How do I fix this? I'm not sure what you mean by two different arguments instead of one, but this is the correct syntax. So if you just provide a bit more context, I'll maybe able to help. But this, what you want is the correct syntax basically does not mean that.
02:14:34.962 - 02:14:50.642, Speaker A: That literally means that if you have EVM extra arguments, we do without tricks, for example, that will change. But for now this compiles. Cool. Let's collapse this. Yeah. Finally, tenderloin is your friend. Basically, tenderloin is one of the most powerful EVM debuggers.
02:14:50.642 - 02:15:33.438, Speaker A: So oftentimes you will see failed transaction on CCP four, not saying what went wrong. And if you go to destination transaction, you will see something like this fail. So this is not particularly helpful. This is not helpful at all. You can just see that method was correctly decoded because of the existence of Abi, but basically it failed and you don't know why, what happened? It's hard. So you can go here and if you click more, you can find something like debug trace two or parity trace. That's usually helpful because you can see exactly which smart contract threw an error.
02:15:33.438 - 02:16:17.086, Speaker A: But tenderly is much much more powerful because you can see something like this, right? You can see the whole full trace. You can also switch to see storage accesses, event logs if smart contract is verified, or you can provide Abi through Cli, it's even much more helpful. And now you can see that, okay, something went wrong. So we have sender to receiver calling this function. Then receiver did some stuff. So this is some execution inside that send function, right? Calling the router to get fee, that's something that we can see now because router contract has been verified and this is something that we usually do. So we are calculating the fees.
02:16:17.086 - 02:16:38.122, Speaker A: Okay, this is the message. So we can see the content of the message and we can see extra arguments is the default one. Cool. Calculate from USD value, blah blah. You can see that something with tokens, fee token is not zero. So fee token and links. So something with tokens is going on.
02:16:38.122 - 02:17:36.374, Speaker A: And then boom, error, you can see and you can know even though your smart contract is not verified, again with the API and source code, you're much more in control. But this is something that I debug for other user. You can see approximately where there is. So after get fee and all of this stuff, when you collapse this, the next function line went wrong. So usually after get fee and approval and all this stuff, you're going to send the ccap message so you can have a grasp of what went wrong. And here we don't need to be geniuses to figure it out that this smart contract was not funded with link and that's why this function failed, right? But you can also see one more thing, that when you don't have verified contracts and you don't have the API or source code, it's a bit harder. But you can see all of this purple stuff, purple hackers.
02:17:36.374 - 02:18:41.002, Speaker A: So these are all function names. But the thing is that if you don't know function, if smart contract is not verified, you cannot see get fee. You can see this four bytes which is essentially a function selector, right? So function selector is a unique for a function so you cannot decode it without an ABI. But if it's unpopular, function selector here, this is also function selector bc this is a function selector which was decoded to send because polygons can were aware of that function selector. But the thing is that if you don't know what is, maybe it will helpful for you to go to this URL. This is Openj xyz signatures and you can search for a function selector, right? So if you search for this one you can see something like this and you can see hey, ccap send function failed. So I know that when I called ccap send function on a router contract, something failed.
02:18:41.002 - 02:19:24.560, Speaker A: And because of that you can see. So send was a top level function and inside there was like several function calls. For example get fee, calculate fee, blah blah. And when I called CCAP send with these signatures, the transaction reverted and we already saw that it's because I haven't funded wetlink for CCap fees. So these are a couple of tools that I use regularly when debugging code. I think it can be really helpful for you. So to repeat, knowing how to decode these error codes is probably skill number one and it will solve you like 90% of issues.
02:19:24.560 - 02:20:02.860, Speaker A: If not, then I'll highly suggest you to use this CCP reverse reason script again available at official repo, all open source or public. You can just copy it from here and with a little of setup. So either code string error code string or these three variables plus archive node, you should be able to decode message and to figure it out what went wrong. Cool. And that's pretty much it. We are right on time. Final URL is just some example crushed in dapps and tools something as a follow up for you.
02:20:02.860 - 02:20:41.558, Speaker A: You already saw this page at Masterclass number one as well, so a couple of examples, real world use case examples that maybe can inspire you to build something during constellation hackathon or for some other hackathon or your project in general. That'll be it. We're right in time. Thank you very much for staying all up till the end. I hope you had an amazing time. I hope you learned something new. For those one who didn't finish or needs to drop out or came later, the recording will arrive into your inbox pretty soon.
02:20:41.558 - 02:21:01.050, Speaker A: There's being edited basically, so you will be able to watch the replay. So yeah, that'll be it. Thank you so much. Once again, I'm going to stop sharing my screen and I'll see you in the next discord office hours, next tcp masterclass or on Twitter. Cheers.
