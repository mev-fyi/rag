00:00:27.050 - 00:00:52.414, Speaker A: Hello everyone. Welcome to another Chainlink CCF Masterclass. My name is Andre. I'm a developer advocate at Chainlink protocol Chainlink Labs, and with me I have blessing Devrel from Circle before he introduced himself. Please drop some gms in the chat or where are you tuning in from so we just can know that you can hear us. Blessing, over to you.
00:00:52.612 - 00:01:13.842, Speaker B: Yeah, thank you, Andre. My name is blessing. I'm a developer advocate at Circu and I'll be here with you walking through all the workshop explaining the concept of CCTP and CCIP and how everything fits together to make you ensure that you have secure USDC transfer. So over to Andre. Thank you.
00:01:13.976 - 00:01:34.586, Speaker A: Perfect, perfect. Thanks Lassien. So we can see that we're having people tuning from Paris, from states, more precisely from Chicago, New York. Great. Great to have you all. So this is how we're going to roll. We're going to drop if you attended any of previous master classes, you already know this.
00:01:34.586 - 00:02:19.846, Speaker A: So we're doing this using gitbooks because the amount of content is so large to be fit in a slides or a docs. So we're going to represent the whole book for each master class. So what I'm going to do is I'm going to just share my screen so you can see it and we're going to drop the link to the getbook as well. So yeah, this is it. This is CCP Masterclass number four. You have a link in a chat and also I'm going to display it really quickly on screen so you know where to find it all. So we're going to quickly type it here and here.
00:02:19.846 - 00:02:53.746, Speaker A: This is the full URL. So cll getbook IO Ccipmasterclass four. That's the only thing that you need. The rest will be padded automatically or just click the URL from the chat. Cool. So regarding CCAP masterclass number four, this one is going to be all about the latest stuff added to CCIP during or kind of like prior to holidays. So CCP came with a new release, version 1.2,
00:02:53.746 - 00:03:40.046, Speaker A: and its major thing is now support for native USDC token transfers. If you want to check up on any of the previous masterclasses, here are the URLs. When working with CCP, you should always refer to the official docs for latest info. Some of the info in the previous Masterclass gearbooks are outdated due to this new release. We're going to update those SAP, but to let you know, follow either this one, this gitbook, or as I said, always refer to the official docs so let's say what's new in CCAP version 1.2 to quickly recap what CCAP is for newcomers. Basically, CCIP is the universal messaging protocol to transfer both data and tokens across different blockchains.
00:03:40.046 - 00:04:23.614, Speaker A: So that can be EVM blockchains. We have multiple EVM testnets, but also in the future and non EVM blockchains like Polkadot, Solana, Bitcoin, Bunch of private bank chains, et cetera. So for you to be able to work with CCP, the only thing that you need to do is basically to interact with a router contract. There is a CCP router contract per CCP supported blockchain and in the middle is this CCFP thing which we can interpret as a black box, literally. So who can be a sender? It can be any address, literally can be your extremely on account, can be your smart contract, anything as long as you interact with the router contract. More precisely, calling CCAP send function. Who can be a receiver? Again, any address.
00:04:23.614 - 00:05:19.550, Speaker A: If you're sending tokens, like we're going to do, if you're sending USDC, any address can be a receiver. Just specify it as a receiver in the message you're sending, and tokens will arrive if you want to pass data as well, like we are going to do in second exercise where we are going to deposit USDC to compound with three then your receiver must be a smart contract implementing CCP receiver function, which we will see it's extremely easy to do. So basically TLBR is that you just interact with the routers, taking care of routers and that's it. But of course, what's new with this release? So first, as I said, there is no change to CCP router interface as long as you know how to interact with router contracts. That is. However, due to this new release, new router contracts must be deployed. So we have now new router contract addresses.
00:05:19.550 - 00:06:00.106, Speaker A: So just make sure when you go to the official docs to switch to 1.2 version, you will see that the older router contracts are marked as deprecated in the docs. So if you want to make your previous masterclasses backforce compatible, you will need to update your router addresses. And that's also like a best practice for the future. You should always make your router addresses mutable so you can make backrost compatible contracts. Obviously the biggest thing in this release is the support for USDC token transfers, which we are extremely excited for. Lastly, the strict field from extra arguments property basically has been removed.
00:06:00.106 - 00:06:39.062, Speaker A: So that means that this syntax will not work. So this is the thing that we need to update besides routers for previous master classes. Whenever you see strict, just delete it and it will work. Basically the syntax is basically the same. Also another best practice or good practice for production deployments. Make sure extra arguments are always mutable and you can rely on a syntax, but more precisely you can just rely on bytes variable because it's all bytes under the hood. We've created this helper contract which help you decode or actually, sorry to encode extra arguments as bytes.
00:06:39.062 - 00:07:11.798, Speaker A: And it's much simpler to just store a bytes value in a storage, make it mutable. That's it, you're good to go. You will always have forward compatible and backward compatible contracts. Finally, some gas limits and some other service limits has been increased adjust on testnet so you can always see this. And finally we have a new release of chain and contract CCP MPM package. So we did all the previous master classes using version 0.7.6. Now we are bumping to 1.2.1.
00:07:11.798 - 00:08:15.366, Speaker A: That means that if you install the latest version and something doesn't work with older master classes, that's going to fix. Obviously it's just a matter of correct import. So either downgrade or adjust those imports. But the most important thing, as I said, are actually USDC transfers. So USDC stablecoin digital dollar stable token, sorry, digital dollar backed 100% for us dollars. How it works under the hood? Well basically there's just as the regular CCAP plus some extra stuff, right? So again you're a sender, you're interacting with the router, then router passing the message to the on RAM contract which interacts with a new USDC token pool. Then again three off chain components, risk management network committing, done executing, done doing their own thing, plus something extra committing, done again, providing finalized Merkel trees to commit smart contract which is monitored by risk management network.
00:08:15.366 - 00:09:20.750, Speaker A: And then we have interaction with the off RAM contract and USDC token pool on the other side. Finally router delivers the message how that interactions works under the hood. So we have these actually USDC token pools on multiple blockchains which used USDC CCTP protocol under the hood. We're going to hear about CTP in a minute, but basically executing dawn is listening for burn events. It's requesting attestations from CTP attestation API and getting those attestations and providing them to the offram contract, which finally triggers the transactions with CTP attestations to the USDC token pool on the other side and we are getting USDCs on the other side. Basically, if you're not familiar what attestation is, an attestation is basically assigned authorization to mint the specified amount of USDC on the destination blockchain. Now, how all of this thing works in practice under her.
00:09:20.750 - 00:09:32.260, Speaker A: I'm going to pass it over to our lovely guest from circle to explain you in a bit. I'm going to stop sharing my screen and yeah, blessing, you may take over.
00:09:32.710 - 00:10:27.102, Speaker B: Yeah, thank you, Andre. So I'm going to start sharing my screen to walk everyone through how they all connect together. So we've been using this git book so far to go through the master classes. So for me to explain how this USDC transfer works and our CCTP powers that under the ood, I've highlighted a couple of points that you should take note of and we're going to be building off that point where I'm going to walk you through how everything works under the Ood. So again, this is the operational process which Andre has already explained, and I will extend that and I will explain how everything all works together. So if you take a look at this step, we actually have three steps. And these three steps is everything that has to take place for you to be able to transfer USDC from the source chain to the destination chain.
00:10:27.102 - 00:11:11.374, Speaker B: So you burn USDC on the source chain and then you mint the equivalent amount of USDC on the destination chain. So how does this actually happen? Let's take a look at the first points that I highlighted here. So when the user initiates a transfer of USDC, the USDC token pool interacts with CTP contract to burn USDC tokens. So this is where the bond actually take place. How does this work? This is the circus developer documentation that actually describes everything that you need to know about CTP. And after this I'll drop the link in the comment. So if you would like to visit this documentation to learn more about how everything all work together, but really I'll walk you through the steps.
00:11:11.374 - 00:11:52.314, Speaker B: So if you look at this source domain user, I want you to think of the source domain user as the USDC token pool that Andre walked us through. And what that does is that it makes a call to this smart contract right here, which is the token messenger smart contract, and it makes a call to the deposit for bond function. And then it deposits the specified amount of USDC that you like to transfer to the destination chain. It deposits it and make it ready for bond. And it delegates the bond activity to the token minter smart contract right here. And then that makes a call to the bone function. And while all this is happening, a message is sent via the message transmitter.
00:11:52.314 - 00:12:32.746, Speaker B: With the send message function you can see all the parameters as shown, the destination domain, the recipient address and the bond message. And this makes it ready for the event to be emitted. Right? So let's go back to this second step. You see this second step is on the off chain. Everything that happens off chain because this is on the source chain rather. And all this actually takes place with the CCIP executing done, listening to the relevant CTP event on the source chain. And then it captures the event and then it makes a call to the circle attestation service API to request an attestation.
00:12:32.746 - 00:13:37.538, Speaker B: I'm sure the question on your mind is what is this attestation service API? What does attestation even mean as described here, that an attestation is assigned authorization to meet the specified amount of USDC on the destination chain. So let's go back to our diagram. You see that on the left side we have the source domain which is where the bonding activity actually takes place. In the middle we have the attestation and on the right we have the destination domain where the maintenance takes place. But really in the middle the attestation is actually, I want you to think of it as a service that act as a trusted facilitator to make sure that this process is secure and to facilitate and ensure that it actually took place. So because if you think about it, USDC is a digital dollar that is 100% backed and it is one to one to the US dollar, meaning that whenever the amount of USDC that we have in circulation there must be the equivalent amount of us dollar backed. So this attestation actually makes sure that this holds true.
00:13:37.538 - 00:14:20.874, Speaker B: And it confirms that the USDC that would like to transfer to the destination domain has been bound on the source chain and it authorizes on the destination domain that. Okay, go ahead. You can meet this specified amount of USDC on the destination domain because it's been bound on the source domain. And this is actually just an API. It's called the IrIs attestation API or the Iris attestation service. And really it makes a query and then it passes the attestation status and submits it on chain to the destination domain. So if I go back to the git book, you see that I've highlighted a couple of points right here that the USDC token pool calls the CTP contract.
00:14:20.874 - 00:15:34.610, Speaker B: So the USDC token pool actually calls the message transmitter contract with the receive message with all the necessary parameters. That's the message and then the signature, because the attestation service attests to this with the signature. And then it makes sure everything is ready through the token messenger and it passes that to the token minter saying that you can meet this specified amount of USDC on the destination domain because it's been bound on the source domain. And going back to what Andre shared, that the USDC token pool then transfers the specified amount of USDC to the CCIP receiver. And if you take a look at the diagram, that's actually how you have your USDC on this other side from the source chain. So if I go back to sorry, 1 second. So if I go back to this, right, so that's the third point that says that the USDC token pool transfers the specified amount to the CCIP receiver and that's how you get your USDC from the source chain through the attestation service to the destination chain all powered securely with CCTP.
00:15:34.610 - 00:16:26.434, Speaker B: And that's how everything works under the Ood. So now at circle, if you really want to understand deeply how to interact with the smart contract, interact with the API or the attestation service, we have this quick start guide that will drop the link also in the comment section and you can take a look at this. You can practice going through from step one upon to the last step where you meet your USDC on the destination domain and you see how everything works. And if you're interested in going through the smart contract, this is the GitHub repository. I also make the link available in the comment section and you can practice, you can check up more, you can read up more and learn about CCTP. But truly that's how CCTP powers all the activities for you to get your USDC from the source domain to the destination domain. And thank you Andre.
00:16:26.434 - 00:16:27.560, Speaker B: Over to you.
00:16:30.110 - 00:17:05.454, Speaker A: Cool. Thank you blessing. That was awesome. We just learned how CCIP actually use CTP under the hood to seamlessly transfer USDC tokens across different chains. As Blessing said, he'll drop some links that he shared during his presentation and he'll be with us for a while. So if you have any questions about CCTP or anything USDC related, he'll be your guy. He'll follow up in comment sections in the lecture live chat YouTube comment section whilst we are going to continue with the first exercise.
00:17:05.454 - 00:18:06.306, Speaker A: So for this masterclass we'll have two exercises, right? So I'm going to share my screen once again and you can follow along with me while I'm going to do it live. We'll have like exercise time as you used to, and then we are going to continue with exercise number two. And again, exercise time like you used to. So for the first exercise, it's going to be extremely simple. We are going to deploy one smart contract that we're going to transfer USDC from her smart contract to our externally owned account or any other externally owned account. Then in exercise number two, we're going to reuse that already deployed smart contract from exercise number one and instead to sending to transferring tokens to a receiver, which is an externally own account or wallet. We're going to transfer actually to the receiver smart contract which will deposit those USDC tokens into the compound web v three on Polygon Mumbai.
00:18:06.306 - 00:18:42.142, Speaker A: So we're going to do avalanche Fuji to Polygon Mumbai. For both exercises, we're going to get some tokens from circle and chain link faucets and you'll see, we're going to do this in remix. It's going to be as you already used to. So let's go ahead. So, first and foremost, since I said that we're going to do this exercise in remix, you may want to go to remix ethereum.org. Right. If you want to do these exercises in hardhead or foundry, there are CCP starter kits available which you can clone at the following URLs.
00:18:42.142 - 00:19:30.958, Speaker A: So I'm going to click on this one, and if I go back to my gitbook, it says that I should select a blank template and name the workspace as CCP Masterclass four, which I'm going to do now. So if you go here, you have a create workspace, you select blank and you name it CCP Masterclass four. I'm going to hit. Ok, I'm going to zoom remix a bit so it's easier to follow along. Cool. Next we are going to use this. You may actually know about this NPN package called Chainlink contracts CCAP NPN package which basically contains CCP contracts needed for you to interact with Chainlink CCAp.
00:19:30.958 - 00:19:59.910, Speaker A: So we are actually going to use Openzeppelin as well because we're going to need the reentrancy guard contract. So that's the only reason why we're going to install Openzeppelin contracts package as well. So in foundry and rhett, there are different steps how to install it. In remix. It's going to be extremely simple. So remix is going to do it for us as long we provide the actual path. So what I'm going to do is just going to copy this code.
00:19:59.910 - 00:20:43.414, Speaker A: I'm going to go back, hit this create new file button over here on the top left and name empty sl my new solidity file which is going to be empty. I'm just going to paste the content here. I'm going to hit command s or control s. Depends on whether you're like on Mac, Linux or Windows. Or you can always go to solidity compiler at hit compile empty. So before all of that you might need to know that we are expecting solidity version 8.0.8.20. And also there are a couple of stuff which are new at remix.
00:20:43.414 - 00:21:53.634, Speaker A: So at remix id maybe one of the important new things is that with the latest remix id release, the EVM version is now set to Cancun, because Cancun was the name of the latest Ethereum hard fork on Ethereum support Testnet and will be soon on Ethereum mainet. So that means that some of stuff that Shanghai and Cancun upgrades had maybe some other blockchains like avalanche Fuji Testnet or Polygon mumbai testnet that we're going to use today do not have. One of the probably most notable ones is actually the push zero op college opcode. That means that if we use the latest settings, we maybe have issues deploying our smart contracts to these two testnets. So what we actually want to do is to downgrade the Ethereum virtual machine version to Paris, which is the merge version. So if you want to understand more, there is this stack overflow question which will guide you about all the details regarding the pursue opcode. Actually this answer so highly recommend to check it out.
00:21:53.634 - 00:22:36.206, Speaker A: It basically has all the details about how to set it up in various different development environments. I'm going to close this, so let's do this in remix. So we should as shown on an image, we should set it the solid commail version to 0.8.20. We should toggle this advanced configuration, drop down and set the EVM version to Paris instead of the default, which is Cancun. And finally we're going to click this compilemt sl button to recompile our smart contracts once again to make sure that everything's fine. So quickly follow up with me. Solid the compiler tab hit 0.8.20
00:22:36.206 - 00:23:20.378, Speaker A: advanced configurations over here, EVM version is now Paris and click compile Mt as well. So we compile now our smart contract. And if you go back to file Explorer and find this dependency tree, we can see chain link contracts all the way down. Up here we can see that we successfully installed all of these installed, got all of these controls from these packages and that'll be it. Cool. Do we have any questions? I'm going to quickly go back to our cool. So we have actually a couple of questions.
00:23:20.378 - 00:23:52.694, Speaker A: So yeah, let's quickly answer them before we continue. So the first one is with CCIP to send USDC from one domain to another bot domains needs to support USDC natively and also. Yeah, so basically what you're looking for is official documentation, as I already said. So I'm going to just go straight to it. So docs, chain link is the official documentation of chain link. If you go to CCAp you can come to supported networks. Testnets version 1.0.2
00:23:52.694 - 00:24:23.022, Speaker A: is here. And then for all these blockchains, all these combinations, you can find where USDC is supported. So if I go to Fuji Testnet and Fuji to Mumbai, I can see that there is USDC over there. If I go to Sepolia, boom. Fuji testnet to sepolia, it's over there, et cetera. So basically wherever we have USDC available on a testnet, it's supported. We're going to go back in just 30 seconds just to answer the second question.
00:24:23.022 - 00:24:56.678, Speaker A: So second question was, is CCP only working with USDC or other tokens too? It works with our tokens. Again, go to this page, explore or just read through the documentation. There are other tokens we are using CCP, BNM and CCAP LnM. Those are like custom tokens which you can mint for free on testnets for various different testing purposes. But yes, there are other tokens. You can also check the main net as well. But probably the biggest one is not probably, definitely is USDC.
00:24:56.678 - 00:25:17.086, Speaker A: Okay, cool. Greetings from North Macedonia. Hello. And yeah, let's continue. So cool. Now that we kind of covered the questions, let's now go to faucet to get tokens for this exercise. So during this masterclass we'll transfer, as I said, USDC from avalanche Fuji to polygon Mumbai testnets.
00:25:17.086 - 00:25:48.342, Speaker A: This is the URL to the circles testnet faucet where you can get, as stated here on image, USDC and also EuRSC tokens on various different testnets. We are going to want to use avalanche Fuji. So what I'm going to do is I'm going to follow this URL. You can type it manually, you can see USDC. I'm going to switch to avalanche fuji and I'm going to provide my wallet address down here. So I'm currently on Sephora. I want to switch to avalanche Fuji chain.
00:25:48.342 - 00:26:21.702, Speaker A: Here it is. I'm going to click to copy my wallet address over there, paste it here, send ten USDC and yeah, tokens has been sent to my wallet. So here you can see that I have now 15 USDC. If you are not sure how to add it to your metamask wallet, that's extremely simple. So you're going to go to block Explorer over here. And here you can find all of the token addresses you have. This is the USDC token address.
00:26:21.702 - 00:26:53.294, Speaker A: Just grab it and then you can go back to your metamask. If you're using metamask, you can import tokens, can just paste it and metamask will do its magic for itself obviously. Oh, I pasted the wrong address. Sorry about that. So once again, here it is. And yeah, metamask will just take care of the rest and you will see token symbol populated automatically, token symbols, et cetera. You're going to add it of course.
00:26:53.294 - 00:27:35.470, Speaker A: I already added mine so that's why I was unable to add it again, of course. So this is just for you to see. But yeah, I got USDC on avalanche Fuji cool. I'm going to go from the faucet back to the gitbook. So the second token that I'm going to kind of need is link token because I'm going to use link to pay for CCIP fees. You can also use native wrapped implementation of a native coin of a blockchain. You are so for avalanche Fuji there will be like wrapped avax Fuji.
00:27:35.470 - 00:28:03.586, Speaker A: Basically you can use message value inside your smart contract to pay for fees. But I'm going to use link because first I can get those tokens much easier. And second, fees in link on these testnets are cheaper basically. So I'll have more tokens to play with it. So I'm going to just click this URL. It's already connected. My wallet is already connected to this UI.
00:28:03.586 - 00:28:27.440, Speaker A: You may want to connect your wallet over here. Once you're connected, switch to avalanche Fuji blockchain as displayed here. It already populates my wallet address and 25 test link. If you need Avax, you can click here as well. Just you need to authorize via GitHub profile. I don't need Avax. I'm just going to grab 25 link, going to send request and that'll be it pretty much.
00:28:27.440 - 00:29:16.414, Speaker A: I'm just going to need to wait for confirmation to get 25 testnet link. Same thing like you can get the address of a link following this transaction hash or going again through a block explorer from here, or finally if you go here to resources in a docs, there is a page called link token contracts where you actually can get the address of the link token on various different testnets for easier adding to the wallet. You even have this add to wallet button over here which was just going to add the link token automatically. Cool. I'm going to just close this thing. Both requests completed. Let me check my wallet once again.
00:29:16.414 - 00:29:42.360, Speaker A: I have links, I have USDC. I'm ready for this exercise. Cool. Before we continue, I'm going to quickly go back to our chat to see if we have any new questions. There is one actually. Does gas prices apply? Yes, and we are going to see really soon how you can control that. Cool.
00:29:42.360 - 00:30:01.086, Speaker A: Let's go back to the exercise. So we need to develop this transfer USDC smart contract. And basically what I'm going to do is I'm going to create a new solution file in remix. I'm going to copy the whole thing. This is the whole source code. Then I'm going to walk you slowly through it before we continue. Okay, cool.
00:30:01.086 - 00:31:09.826, Speaker A: So I'm going to copy this, as I said, go back again, click create new file, name it, transfer USDC Sol and paste the content over here. This is obviously a valid warning, so do not just blindly copy paste code from the Internet, but I'm going to walk you through it really quickly. So I'm going to zoom this code a bit just for better clarity. So we have a couple of imports contracts that we are going to need basically. So like ERC 20 interfaces for interacting with USDC tokens, token and link. Then the interface for the GCP router owner is creator just for some extra security measurements like for some actions that are advisable to be performed when go to production and the actual client library that we imported in that empty solidity file which is the most important actually library for interacting with chainlink CCap. So first we have these three storage variables over here.
00:31:09.826 - 00:32:09.910, Speaker A: Each one of them represents CCAP router smart contract, link token smart contract, and the actual USDC token smart contract. Then we have this mapping of allow listed chains which will be used to populate with blockchains we want to interact with. So we're not going to allow for any blockchain to receive or send CCP messages. We are going to specifically allow only interaction between talent pog and polygon Mumbai to avoid any issues if USDC is not available on some other testnet or similar stuff. So for that purposes we also have this modifier which will throw an error if the destination chain is not allowed listed. So don't be careful when copy pasting stuff from the gitbook. Follow the steps carefully to not get one of those silly errors thrown in the constructor.
00:32:09.910 - 00:33:04.962, Speaker A: We're just going to assign those three storage variables and allow list destination chain is that function that will allow list polygon Mumbai as destination chain to be our receiver. Destination chain selector, if you're here for the first time, is basically a unique number which is like unique id for CCAP supported blockchain. So for example, chain id for polygon Mumbai is I think 8001-8301 destination chain selector for Polygon Mumbai will be something different, will be this huge number, 12532, whatever. So these chain selectors are ccap specific. This is how we take care of all support blockchains. And there is actually a simple formula how you're calculating those. So those chain selectors are not the same as chain ids.
00:33:04.962 - 00:33:52.680, Speaker A: So just an fii for you guys. Finally, we have transfer USDC function, which is our main function, right? So we are accepting some function parameters. We're going to go through that later. We want this function to be called only by owner and receiver to be only allow listed chain. So because we are sending tokens, we are creating this token amount array in memory. So it's array of EVM token amount struct from client library, which consists of actually two fields. So token, which is the address of token you want to send, which is USBC, and the amount we are sending, which is basically the amount we are providing as a function argument over here.
00:33:52.680 - 00:34:25.594, Speaker A: And then we're going to create a CCP message object, right? So from EVM to any message struct from a client library, we're going to populate next things. So receiver, we're going to provide the address of a receiver as a function argument. That must be like externally on the counter wallet for this exercise. I'll explain shortly why. And we're just going to AbI encode it to be bytes because CCP understands only the language of bytes. Technically under the hood, we're not sending any data. So we're just going to leave this as empty.
00:34:25.594 - 00:35:11.550, Speaker A: We're sending token amounts, we're going to assign token amounts to this array we created earlier for extra arguments. We can see that we are only setting a gas limit because strict field is removed and gas limit is customizable. So because for this first example, what we are going to do is that we are going to set gas limit to zero. And in the other example, we are going to set it to 500k. Why zero? So this gas limit, to answer the previous question, is the amount of gas that the receiver contract. The receiver, yeah, smart contract will consume to receive a cross chain message. So if you're sending only tokens and your externally owned account is a receiver where there is no call to CCP receive function, you're receiving just the tokens.
00:35:11.550 - 00:35:39.170, Speaker A: Externally owned accounts cannot have smart contracts. Actually, externally owned accounts are not smart contracts. So externally on the accounts cannot have any code in it. So you're just wasting this gas limit for nothing. The thing that is important is this gas limit is non refundable. So that's why you want to control it. In second exercise, we're going to spend roughly around 470 plus k in gas.
00:35:39.170 - 00:36:22.294, Speaker A: That's why we're going to just round it out to 500k. But also there are in our doc steps how you can measure this gas limit and estimate it properly using various tools from Harkit and foundry, gas test to alchemy dashboard, even thunderly dashboard, and much more. Finally, as a fee token, I'm going to use link. So I'm setting link token as an address here. If you specify address zero, that means that you're paying with native coin on that blockchain, which be avax forgetnet aka message value. Yeah. Finally, we are going to calculate the CCF fee for this message.
00:36:22.294 - 00:37:21.226, Speaker A: If we are sending it to Oliver Mumbai by destination channel selector, and if we don't have enough in our smart contract, enough of links, we're going to throw an error. If we do, we're going to approve just that portion of needed for fees to be spent by CCP router. And then what we're going to do is going to transfer USDC tokens from our externally owned accounts to the smart contract using safe transfer from function. Then we're going to again approve router to spend the amount we are transferred into a smart contract so we can transfer it using CCP further. And yeah, finally, just calling the CCP send function from the router interface. CCP send accepts two arguments, destination chain selector and the actual message object emitting some events and that's it. This withdrawal token is a helper function which will allow you to withdraw any link or USDC token tokens accidentally locked in.
00:37:21.226 - 00:38:10.510, Speaker A: That'll be it. Now, let's see this contract in action, shall we? If I go here, I need to prepare for deployment. That means that I need to switch to injected provider metamask environment in my remix id. So to do that, what I need to do here is that I need to once again compile this smart contract which I just did and then go to deploy and run transactions. And here from the environment select injected provider metamask I'm going to click at it and it will now connect with my metamask wallet. So the only thing that matters now is on whichever network I'm connected in my wallet, that's the network connected to remix. So speaking about networks, Sepholia is the default testnet you will get from adamask.
00:38:10.510 - 00:38:54.390, Speaker A: So avalanche Fuji and Polygon Mumbai are not there. But doesn't matter if you click this URL or just search for avalanche Fuji on chainlist it will navigate you just a second to avalanche Fuji testnet which has this add to metamask button. Just click it, connect your metamask and you will have the avalanche Fuji testnet in it. Notice the chain id 43113 and if I go to remix it's 43113 over here. And yeah, just do the same thing for Polygon Mumbai. If you don't have it, once again click to the URL or just follow the instructions from the getbook. You'll have the Mumbai 8301 add on atomask and we are ready to roll.
00:38:54.390 - 00:39:24.302, Speaker A: Now let's deploy this transfer USDC SL contract to avalanche Fuji. So to avalanche Fuji. Right. And how I'm going to do that? Well I'm going to go to remix. I already compiled the smart contract and what I need to do is now to find this deploy orange button. I need to make sure that I select transfer USDC over here. And you can see in the constructor there are three variables over there that we need to provide.
00:39:24.302 - 00:40:01.534, Speaker A: So address of CCF router link token and USDC token so you can get them from here. But again always follow the official documentation for latest info especially on these token addresses so you can find all of the info here. So router link token address and USDC and let's do that. So again I can copy from here but if I go back to let's say this is fujitestnet. Router address for Fujitestnet is this one. So f six nine whatever. And if I go to get a book it's f six nine whatever so I'm going to provide that one here.
00:40:01.534 - 00:40:35.670, Speaker A: Then the link token address so supported fee tokens because I'm using it for fee link copy. So here b 9d whatever, the same thing, b 9d forever et cetera. And finally USDC because I'm sending from Fuji testnet to mumbai testnet, I'm going to open this drop down and here I'm going to grab the address of a USDC token. Notice the number of decimals. USDC has six decimals. We're going to talk about that in a moment. So I'm going to paste the address here.
00:40:35.670 - 00:41:09.806, Speaker A: All good. Five, four, we can see five, four, we're ready to roll. So I'm going to hit this orange transact button. I got the metamask notification popped up. I'm going to hit confirm and I'm going to wait for a transaction to be included in the next block, which just happened. So we deployed transfer USDC smart contract to avalanche fuji. Our next step will be now to call the allow list destination chain function because we want only to send tokens to polygon Mumbai.
00:41:09.806 - 00:41:41.710, Speaker A: So how to do that? You can see the address of the chain selector here. But if I go here, this is the allow destination chain function over here. We need to provide destination chain selector which is the chain selector of polygon Mumbai. So Mumbai testnet chain selector, this thing over here, 12532 et cetera. 12532, et cetera. So paste it here and as allowed, I'm going to type true, just that. I'm going to hit transact.
00:41:41.710 - 00:42:04.462, Speaker A: I'm going to sign a transaction in my metamask. Once again. Click confirm. And I'm going to wait for this transaction to be included in an x block which just happened. Lovely. Let's go to step number three now on step number three on avalanche Fuji. Again, I'm going to fund my smart contract with thrilling links for fees.
00:42:04.462 - 00:42:28.070, Speaker A: So how to do that? Well, that's extremely simple. So I'm going to grab the address of my smart contract and I'm just going to send thrilling to it. That's it. So how to grab it? Well, here, there is this copy button. So this is the address of your smart contract. I'm going to click a copy, I'm going to open my metamask. I'm going to find my link tokens over here that I got from the faucet.
00:42:28.070 - 00:43:00.520, Speaker A: I'm going to hit this send button because I'm sending now links to a smart contract as a receiver. I'm pasting this address and we can see this is the address of our smart contract and you will do file link. It doesn't matter. Like three or more should be more than enough. I'm going to hit next and I'm going to once again sign this transaction. I'm going to wait for this transaction to be included in the next block and we're continuing that just happened. So we may continue.
00:43:00.520 - 00:43:43.860, Speaker A: Step number four is that now pay attention. So now on avalanche Fuji, we need to call the approve function on USDC sol smart contract. This is important because we have some amount of USDC, more precisely ten USDC we got from deposit in our wallet. But we want some amount of those tokens to be withdrawn from our wallets by our sender smart contract. So we can easily just send again tokens to a smart contract. But due to nature of our transfer USDC function, we're going to specifically call the approve function of the USDC so smart contract. So I'm gonna go click on this URL basically.
00:43:43.860 - 00:44:09.926, Speaker A: And this is the contract for USDC on Avalanche Fuji blockchain. You'll need to go to click to write as proxy. That should be already triggered and you should connect your wallet if you're not already here will be like a connect wallet button. Click it, connect it, connect it. And that's it. We want to call the approve function. So I'm going to expand this approve thing.
00:44:09.926 - 00:44:45.718, Speaker A: So the spender is the address of our transfer USDC smart contract. So I'm going to go back here and grab that address once again. I'm going to paste it here, make sure that it's the right address and it is. And then what I want to do is to provide the value I'm sending. So I want to send one USDC to Polygon Mumbai. So if I go back to docs, we can see and I mentioned that USDC has six decimals. Six.
00:44:45.718 - 00:45:15.746, Speaker A: That means that I want to approve this amount, this value, one as in one USDC plus six zeros. So 123456. That's it. One and six zeros. I'm going to hit write and you will soon see the metamask pop up with exact same information. So your spending cap request for your USDC to be one. You see one because we have six zeros at the end.
00:45:15.746 - 00:45:46.314, Speaker A: So I'm going to hit next, I'm going to approve and I'm going to wait for this transaction to be included in the next block which just happened. Here it is. It was successful. So I'm going to close all this thing and that's it. I successfully approved one USDC to be spent by our transferusdc. So smart contract on our behalf. So again, if you have troubles, you can follow the, the.
00:45:46.314 - 00:46:07.394, Speaker A: All the important stuff has been marked out. Six decimals. All of that stuff. Finally, let's transfer our tokens. So the fifth and final step is to on island Schwarjee. Call the transfer USDC function and provide some parameters. So let's see what those parameters are.
00:46:07.394 - 00:46:40.630, Speaker A: So transfer USDC function over here, destination chain selector. We're transferring to polygon Mumbai. So we need to provide the chain selector of polygon Mumbai testnet where to find it again, official documentation. So Mumbai testnet, grab the chain selector like this, hit copy button and paste it here. As a receiver I'll provide my wallet address. So I'm just going to provide my externally owned account address from here and the same address I have on polygon Mumbai. I'll just receive tokens on polygon mumbai.
00:46:40.630 - 00:47:17.998, Speaker A: Amount I want to spend the send is one USDC because I just approved one USDC to be spent by this smart contract. So once again one and six zeros. 123456 finally as a gas limit I'm going to provide zero because I'm sending to externally owned accounts. So there is no CCP receive function call going to save on those gas costs. And I'm finally going to hit transact button and here is a metamask pop up. I'm going to hit confirm one more time and wait for a transaction to appear. Here it is in the next block.
00:47:17.998 - 00:47:48.402, Speaker A: So I'm going to click here to grab the transaction hash. So this is the transaction. You can also grab it down here from remix. Here it is transaction hash, the same thing. And I'm going to scroll down a bit and you will see that there is this thing called CCP explorer. So this is the URL to CCP explorer page. And if I paste the transaction hash I just got, I can live follow the status of my crosschain message.
00:47:48.402 - 00:48:19.334, Speaker A: So we can see that source has been finalized on a source blockchain. So there is a source transaction hash. There is not yet the destination chain transaction hash and we have the message id which is the unique id of chainlink cross chain message. We have a couple of more details here like source and destination chain included. So we are sending Fujit to polygon Mumbai. Some other stuff like transaction timestamp from which to which we are sending. So this is the address of our smart contract.
00:48:19.334 - 00:48:52.402, Speaker A: This is my wallet address. The amount of link we spend for fees so it's 0.9. And finally the amount of tokens we are sending which is one USDC. You can see here, gas limit was set to zero. That's all good. And now we are waiting for this crosschain message to get delivered. So source finalized means that the finality has been reached on avalanche Fuji.
00:48:52.402 - 00:50:09.134, Speaker A: Now we see that the status changed to blast blast means that after there was a source finalized commit, dawn reported that Merkel tree with those transactions to the commit store smart contract risk management network did the same thing, then compared those two Merkel trees. Each of the nodes in a risk management network voted for either blessed or cursed and we can see that the majority voted for blessed. That's why we see a blast tag now. We saw blast tag now our executing done is interacting with CCTP protocol under the hood. We minted some new USDC on polygon Mumbai and finally we have a success status, meaning that tokens USDC arrived to Polygon Mumbai. So if I switch now to polygon Mumbai testnet which is over here and go back to tokens, I'll see that I have twelve USDC now and I just got ten from the faucet, one as eleven as a test for this workshop. And this is a twelve on.
00:50:09.134 - 00:50:34.920, Speaker A: So this is 100% legit. So that'll be it for the first exercise. That's the end of the first exercise. It's really important to finish the first exercise because we are going to use this transfer USBC smart contract for our second exercise. So don't hesitate to ask questions, take your time. And we are going to continue in 20 to 30 minutes. Depends on your speed while we are here.
00:50:34.920 - 00:50:57.790, Speaker A: Okay. We can't see the presentation mathematics just in case. I'm going to fix that. This is a good point. Should we keep our autocompiler on you can. I don't use it. A lot of people use it so that's fine as long as your compiler is set to use IRA CVM version and 0.8.20.
00:50:57.790 - 00:51:25.030, Speaker A: So make sure you got that. But yeah, so that'll be it. We are going to now maybe play some lo fi and I'll be here to answer your questions. And we are going to continue in 2030 minutes. So just report your progress in a live chat. So I know when to continue. But at least 20 minutes to 30 as I said, for this exercise.
00:51:25.030 - 01:04:46.230, Speaker A: So yeah, just let's see if we can play some lo fi. If you don't hear this, just let us know. Actually, cool. I'll be around. Definitely not professional. So yeah, it's it diamond. It's sa sa it.
01:04:46.230 - 01:11:09.508, Speaker A: It's it. We are right on time. Hello again, let's say. So congrats and kudos to all of you who successfully finished the first exercise and shared that with us. I'm going to quickly take this time to answer a couple of questions we have and then we are going to proceed straight to exercise number two. As a reminder, you will need exercise number one to just build on top of it for exercise number two, just another smart contract on the other side. So yeah, make sure to finish this up, this first one, at least the second one will be easy to integrate.
01:11:09.508 - 01:11:33.384, Speaker A: Right. So let's see. So first of all, there was a question from Sylvia Margarita how the USDC approval from the sender UA will be done in an app. A pop up would be triggered from the UI. So essentially yes. This approval is just calling an approve function or increase approval. Depends on the ERC 20 token for UDC that will be approved function regularly.
01:11:33.384 - 01:12:01.884, Speaker A: That's what we did basically at a block explorer where we saw that wallet or metamask pop up. The same thing will be in the actual dap. It's essentially just a call to a smart contract. Yeah, so there was a question. I'm not able to change my environment even after a compile. I hit deploy and I got that. Currently you have no contract instances to interact with.
01:12:01.884 - 01:12:32.064, Speaker A: So make sure. I'm going to actually share my screen for this one. So give me 30 seconds leaves. So there'll be our lovely gitbook once again. So make sure your smart contract over here is selected in this remix tab. And then you should be able. I'm going to zoom out of this, this a bit and then you should be able to see the actual instance.
01:12:32.064 - 01:12:59.612, Speaker A: So don't be on home tab or whatever like amptab, just select the actual smart contract. Cool. Let's see what else. Metaverse says that I don't have enough matic to pay for transaction fees on Mumbai. What do I do? So you will need matic to deploy this smart contract in exercise number two. And that's it. That's pretty much it.
01:12:59.612 - 01:13:27.792, Speaker A: So we're doing all of these exercises from avalanche Fuji to polygon Mumbai. So essentially you always want to be on avalanche Fuji, especially for this exercise. On this exercise number one, we are never going to polygon Mumbai. Just we're going at the very last step to verify that there are USDC in our wallet. But we're doing everything on avalanche Fuji. So make sure you have avax Fuji tokens for matic. There are various different faucets.
01:13:27.792 - 01:14:01.744, Speaker A: You just grab some matic from a faucet and you should be able to deploy that one contract and that's it. If you still have troubles, maybe someone from the chat will help you. If you provide your testnet wallet address, just please use testnet like your wallet address. That you're using for Testnet for testing and if someone have any spare matic to share on Polygon Mumbai please help. But yeah, you will need really tiny amount of matic for both exercises. The majority is again on avalanche Fuji. Especially this first one.
01:14:01.744 - 01:14:35.852, Speaker A: Everything's on avalanche Fuji. Yeah, and thanks Mr. Zozert for help in a comment section. Really appreciate that. And yeah, once again congrats on your successful deployment and finishing of the masterclass of the x ray number one as well as to John M. Perfect guys, let's now continue with the Masterclass. We're going to explain how to implement exercise number two.
01:14:35.852 - 01:15:15.640, Speaker A: I'm going to do it really slowly with you so you can even code with me. But after that we'll have 30 minutes for doing the exercise number two on your own and then we are going to wrap it up. Let's see another question. Not sure why but I'm not able to approve USDC after deployment. Allow the destination but now I'm not able to do a transaction. Just make sure you're connected to the block explorer. So once again if I go back to this thing and I'm going to unpopposely disconnect.
01:15:15.640 - 01:15:46.230, Speaker A: So disconnect this account. Okay, cool. I'm going to switch to GC chain if I refresh. Shit. Okay cool. Let's do this thing once again. Should be disconnected, right? I'm not sure why it's not something wrong but anyway there should be like a connect button.
01:15:46.230 - 01:16:23.090, Speaker A: If you're connected, make sure you're on USDC. This address you're clicking the contract tab. You're clicking write as proxy tab and then there is approve. Put the address of our transferred Csmart contract and one with six zeros hit write and it should work. If not validate. Do you have enough evacs testnet tokens for Fuji in your wallet. If you don't go get to our faucet to grab some extra.
01:16:23.090 - 01:17:00.810, Speaker A: Cool. Any final questions before we proceed? Let's see. I'll reset later. Yeah, this was actually a good one. Do all CCIP code live on chain or is it off chain? So there are smart contracts on every supported CCP blockchain and there are also three main off chain components. Three dawns don't stand for decentralized oracle network. Basically it's like have three layers of extra off chain security.
01:17:00.810 - 01:17:29.830, Speaker A: So yeah, there's like committing done executing on and risk management network. You can find all about that in the second chapter called what's new in CCP one version 1.2. Cool. Let's now proceed to actual exercise, shall we? I'm going to click to exercise number two in gitbook. I'm going to move this thing aside. You should be able to see the title deposit transfer USDC to compound with free. Sorry about this.
01:17:29.830 - 01:18:06.684, Speaker A: So in first exercise we use that smart contract to transfer USDC from it to our wallet addresses, to our wallet accounts or externally owned accounts. Now we're going to do much more interesting stuff with it. We're actually going to deploy it to a compound with three and get tokens in return. So we're just going to use this smart contract basically and build on top of it. So no new environment settings needs to be set up. So now we want to be on Polygon Mumbai, basically. So we're going to switch to Polygon Mumbai.
01:18:06.684 - 01:18:53.388, Speaker A: We're going to develop and deploy two smart contracts. The first one is this swap testnet USDC smart contract. So this one is actually necessary and it's extremely simple. We'll see. Because compound V three and majority of even, I think like all the d five protocol on testnets have their own version of test tokens because they can mint them for unlimited amounts and makes it easier for users to test part of different actions like supply for compound. So that's why compound v three has its own version of USDC. And the good thing about compound is that's exactly the same smart contract as the USDC.
01:18:53.388 - 01:19:45.548, Speaker A: Just they redeploy it on testnet and testnet only so they can mint it instead of going to a faucet. So this smart contract is just going to swap the actual USDC to the compound USDC token and we're going to grab that from their faucet or smart contract for a lot and it's extremely dummy but basically does the swap and that's it. That's it. That's important because we cannot deploy the actual USDC into component v three on testnets and this is for testnets and testnets only. On Mainet is just the pure thing, the regular USDC and everything. So you will never need this extra step. Then we're going to deploy, develop and deploy the actual crosschain receiver smart contract which will interact with the main interface for Comet.
01:19:45.548 - 01:20:24.712, Speaker A: Comet is just the name of a main smart contracting compound with three and it will use this swap, testnet USDC smart contract, tiny one to swap for these testnet tokens. The rest we're going to explain later. So yeah, let's go to step number one. We said we need to develop and deploy this on polygon Mumbai and let's do this. How I'm going to again copy the content of this gitbook code snippet. I'm going to go back to remix, I'm going to go to file Explorer and I'm going to hit create new file here. I want to be sure that I'm in the root.
01:20:24.712 - 01:21:03.956, Speaker A: So here I'm going to name it swap testnet USDC as well. So swap testnet USDC SL. I'm going to paste the content of it, I'm going to just compile everything and we're good to go. So, as I already explained, extremely small smart contract just for testnet purposes only. What I'm going to do now is I'm going to again compile it and deploy it to polygon Mumbai. So how to do that? I'm already using ejected provider metamask. I'm currently an avalanche Fuji C chain testnet.
01:21:03.956 - 01:21:45.728, Speaker A: We can see 431143. What I'm going to do is I'm going to trigger my wallet, my metamask and I'm going to switch to Polygon Mumbai. So this is how you're switching between testnets in remix when you're using remix. So I'm going to just switch to Polygon Mumbai. And you notice this thing now, it's 8001, I'm on Polygon Mumbai. That means that I'm going to deploy my contract to Polygon Mumbai. And if you're unsure, like if I click on this instance now, owner, owner is all zero, because this address, there is no such a smart contract on Polygon Mumbai.
01:21:45.728 - 01:22:26.260, Speaker A: I'm not on the right blockchain, so it will return all zeros. If I go back to Fuji, it will return the actual owner address. So what I need to do now is I need to select this swap testnet USDC thing. So swap testnet USDC, not the ifoster, whatever. So swap testnet USDC. And we can see that I need to provide the address of a USDC token, the address of a compound USDC token and the address of a faucet. So how to get those? Well, they're all in the getbook and also these later two are available at the compound v three, official documentation.
01:22:26.260 - 01:22:54.856, Speaker A: So I'm going to copy the first address, I'm going to copy the second address and I'm going to copy the third address. Positor. I'm just going to be really careful about the names and everything. That's good. So I'm going to hit transact. Hitting transact, meaning that metamask will pop up. I'm on Polygon Mumbai.
01:22:54.856 - 01:23:08.816, Speaker A: Once again, triple check. I'm deploying a new contract from my account. I'm going to hit confirm. I'm going to wait for this transaction to be included in the next block. And here. Yeah, here it is. All green.
01:23:08.816 - 01:23:35.828, Speaker A: And here it is. I now have this tiny swapper contract. Cool. Now we have all the prerequisites to work with USDC on testnets and compound so we can proceed with our actual smart contract. So in Polygon Mumbai we're going to develop the cross chain receiver smart contract. So once again I'm going to copy the content of it. I'm gonna create the new solidity file and name it cross chain receiver.
01:23:35.828 - 01:24:00.336, Speaker A: And I'm gonna paste the content of this code snippet into that file. So once again, file explorer, create new file. And again I need to be sure that I'm in the root. So create new file. And we said crosschain receiver. So cool. And I'm going to paste everything here.
01:24:00.336 - 01:24:32.280, Speaker A: Cool. I'm going to compile it. And let's see what do we have here? Inside this code we have a bunch of imports. Again, probably the most important one is this CCP receiver. This is a new one, so this one is necessary if we want to have that CCP receive function. Under the hood, CCP receiver is coming actually from an application folder. So technically what you need to do to implement is initiative message receiver.
01:24:32.280 - 01:25:09.492, Speaker A: But CCP receiver is just a recommended or a good implementation of that one. So it's like an abstract contract, you can just build on top of it. As I said, we're going to use comet main interface and our swapper contract. And here we are, we are inheriting CCP receiver smart contract so we can have that CCP receive function and we have a couple of errors and enums over there. We're going to talk about that in a minute. Two storage variables, one for a comet smart contract, the main component v three smart contract and the other for our tiny swapper smart contract. There is two mappings.
01:25:09.492 - 01:26:10.430, Speaker A: Now we have allow list source chains, so we kind of want to allow list now on polygon Mumbai that we want to receive messages just from avalanche Fuji and we also want to allow list sender. We only want to receive messages from our smart contract transferusdc SL smart contract on avalanche Fuji. Finally we have this ineumerable mapping which is basically a mapping of failed messages. And this is because we implemented something called defensive example, which is the best practice I'm going to talk about that in a minute. So in constructor we're just assigning those storage variables, couple of modifiers and then two functions that we are kind of used to now already allow list source chain and allow list sender. We're going to call it using owner account. Then there is this CCAP receive function, right? So CCAP receive function is implemented like this to support defensive example.
01:26:10.430 - 01:27:30.464, Speaker A: Defensive example basically means that when you're transferring tokens and you have some extra functionality to perform, if that extra functionality fails, well, tokens will still arrive and that will kind of mess with our logic. So with defensive example, instead of having the actual logic inside the CCP receive function, we are going to have a mechanism to prevent tokens from arriving if there is an error or an issue on the receiver side until that error gets resolved. So here basically we have try and catch block. So try is to process the message. Process message is basically function down here which may have these modifiers and it has this if statement which basically seem revert is a storage variable if we want to manually trigger and test this functionality during development, right? So if everything will go well, then nothing happens and that's what we want. But if we caught some error, we're going to put the message id and the error code, which is we have two error codes, basic and resolved. We can add multiple error codes.
01:27:30.464 - 01:28:21.556, Speaker A: Obviously we're going to put it in that third mapping and we're going to emit an event. This function however will not return. So it's like transaction is successful, but tokens are kind of locked until you figured out what went wrong and then we can proceed. This is an extra layer of security which is kind of like, kind of recommended. So then process message already said you can trigger this for testing purposes. And then we have this CCP underscore CCP receive, which is basically the actual logic we are going to use. So for you, basically you're going to just copy the code from here, from the feds of example, from our docs, and you're just going to go straight to underscore CCP receive and implement your thing.
01:28:21.556 - 01:29:08.640, Speaker A: Nothing happens. Like you can just reuse the other parts if you want to play all around with it. There is this retry fail message and set Sim revert. So you can manually set it to true, to manually trigger that it reverts and then you'll figure it out how to get it back to false, obviously to resolve the issue. But before that you can call this retry failed message and it will try to basically retry the failed message. And if everything's to go well, then it will unlock and send the tokens to the destination. So basically you can just copy paste all this stuff and just build on top of it inside CCP receive.
01:29:08.640 - 01:29:49.900, Speaker A: This is the actual logic we need. So we're going to get the address of a USDC token from any three VM message like this. And then we're going to get the address of a compound USDC token from our tiny swapper contract. We're going to get also the amount we received, the actual amount of USDC tokens and then we're just going to do the actual swap. So swap actual testnet USDC for compound with three's version of USDC token. And this is for testnet purposes only. After that, we're just going to approve comet smart contract to spend our USDC, our compound USDC.
01:29:49.900 - 01:30:33.040, Speaker A: And finally, this is what we want. We want to call the supply function of compound v three to actually supply USDC on polygon Mumbai. And this contract will return tokens on polygon Mumbai in return. So this one not your wallet address. So you may want as a homework to add some extra logic to maybe add a line here to now transfer tokens to your wallet or something like that. This view function is just a helper function to get failed message ids. So basically what you need to do is you can just reuse this smart contract, this defensive example, and adjust the underscore CCAP receive function and that's it.
01:30:33.040 - 01:31:09.444, Speaker A: You have all of those extra layers of security. Cool. Let's now deploy the smart contract, shall we? So step number three is that on polygon Mumbai, we want to deploy this cross chain receiver smart contract. So how to do that? We already kind of are familiar with it, but let's do one more time. So I'm going to go to deploying run transactions. I'm going to make sure that I'm on a polygon Mumbai and that injected rider metamask is toggled on. And here I'm going to switch to cross chain receiver.
01:31:09.444 - 01:31:50.404, Speaker A: I'm deploying cross chain receiver smart contract. What I need to provide is the address of a CCP router on Polygon Mumbai, the address of a comet smart contract, main compound with three smart contract, and the address of our dummy swapper smart contract. So for CCP router, I'm going to grab it from here. You can also grab it from the official docs and you should. I'm going to put it here for comet. I'm going to grab it from here as a second one, paste it here. And from swap testnet USDC, as you can see, the address of frivolously deployed swap testnet USDC is my contract.
01:31:50.404 - 01:32:23.360, Speaker A: So where to find it? Well, just scroll down a bit and here it is. I'm going to copy that address, paste it here, make sure that everything's legit. Should be. So final step is just to click that orange transact button and to deploy this smart contract on polygon Mumbai testnet. I'm going to hit confirm and wait for a transaction to be included in the next block. While we're waiting, we can focus on step number four. Here it is.
01:32:23.360 - 01:32:53.964, Speaker A: Confirm transaction on polygon Mumbai. We kind of want now to call allow list source chain function. So we are providing the source chain chain selector. So that will be avalanche, Fuji chain selector and if I go to official docs, what I want to provide is this value 14767, et cetera. And if I go back here, that's 14767, et cetera. So we are looking for allow list source chain function. So here it is.
01:32:53.964 - 01:33:21.552, Speaker A: Our crosschain receiver. We're still deployed. We are looking for. Here it is. Allow list source chain function. So source chain selector is this one that we copied is the chain selector of avalanche Fuji. And I'm going to type true hit transact and hit confirm while we're waiting.
01:33:21.552 - 01:33:52.480, Speaker A: Well, you kind of already have a sense. What's our next step? Our next step is now to call allow list sender. So our sender address will be the address of a transfer USDC. Right. TransferusDC SL Smart contract we deployed in exercise number one. So that's why it's really important to finish with the first exercise. So allow list sender.
01:33:52.480 - 01:34:26.810, Speaker A: I'm going to scroll up a bit and here is my address of a transfer USDC smart contract on avalanche Fuji. So I'm going to just put it here. I'm going to write down true hit transact and just confirm it. That's it. We're going to wait for this one to be included in the next block. We can see that everything is green so far. That's good.
01:34:26.810 - 01:34:55.584, Speaker A: We're going to wait for this one because if I'm not mistaken, this is our last action item on polygon Mumbai for tonight. Here it is. Okay, cool. All green. Perfect. That's it for polygon Mumbai. When you come to step number five and successfully execute step number five, we are going to change our wallet addresses back to avalanche Fuji.
01:34:55.584 - 01:35:28.908, Speaker A: So we're now going back to avalanche Fuji and we, on purpose have this step number six which is exactly the same as approving step in a previous exercise. We could easily just approve two USDC in exercise number one. But for the sake of repetition, we are going to do this again because practice makes perfect. Right? So what I want to do is I want to switch now. So I'm switching from polygon Mumbai to avalanche Fuji C chain. I'm on avalanche Fuji C chain. I can see Avax over here.
01:35:28.908 - 01:35:54.544, Speaker A: I can see in my remix that 43113 chain id is back and I'm going to continue with the getbook. So step number six on avalanche Fuji call approve function on USDC. I'm going to click on the URL. I'm going to toggle this approve function. I'm going to again provide the address of a transfer USDC as well. Smart contract. And again one USDC.
01:35:54.544 - 01:36:29.280, Speaker A: So one following with six zeros. Once again. So transfer USDC is this address spender, this one and then value one following by six zeros. 123456 hit right. And I'm not connected now to this block explorer because I disconnected earlier. That's not ideal, but we're going to figure it out. No worries.
01:36:29.280 - 01:36:47.240, Speaker A: Let's see. That's because I disconnected last time. Okay, cool. So let's see if we can approve it manually. Right. What I want to do is that maybe I can try here. Okay, connector is still not found.
01:36:47.240 - 01:37:16.610, Speaker A: Maybe I can just delete cache or something. But let's not focus on errors just too much. I'm going to do something different here. So let's see if I can grab the whole thing. Yeah, I can't. So I'm going to do little hockey thing. You should just follow the steps over here.
01:37:16.610 - 01:37:36.772, Speaker A: Let's see what's the. Okay, so 612. Sorry about that. But stuff like this happen so no worries. Okay, cool. Let's see what's wrong now. Email version.
01:37:36.772 - 01:37:54.540, Speaker A: Okay, that's cool. No worries. So we need to see what was the version value back. If I can grab that from here, that'll be extremely interesting. But let's see. So maybe London. Okay, it's Berlin.
01:37:54.540 - 01:38:38.654, Speaker A: Okay, it's Berlin. Perfect. And what I'm going to do now is I'm going to try to do this manually, unfortunately, because I have some issues with this block explorer. Unfortunately. Okay, this is not great, but let's do copy this address. Okay, that doesn't work. Never mind.
01:38:38.654 - 01:38:59.608, Speaker A: We're not going to focus on that too much. I'll try to fix the issue later maybe like this. Let's see. Okay, cool. Can I connect? Okay, cool. Looks like I finally made it. We'll see.
01:38:59.608 - 01:39:19.922, Speaker A: So I'm going to connect once again. I'm going to sign a message. Okay, final try. If this doesn't work. Well, never mind. We are kind of already there. So this is transfer USDC.
01:39:19.922 - 01:39:45.822, Speaker A: Right? So approve spender 123456. Okay, here it is. That's what we want to see. And again, approving one USDC. So I hopefully solved your issue with the question for last time that you not was able to. I don't know who asked to call the approve function. So apparently there is a button over here to connect it.
01:39:45.822 - 01:40:11.270, Speaker A: Okay, sorry for this taking too long, but we are now there. Perfect. And our final step is to now call the transfer USDC function like we used to previously. So once again we're going to call transfer USDC. So we need to provide 1253 as a chain selector. This is the chain selector for Polygon Mumbai. I'll already have it.
01:40:11.270 - 01:40:30.282, Speaker A: As a receiver, I need to provide a different address. I need to provide the address as stated here of the. Actually this is a mistake. Not your wallet address. The address of crosschain receiver smart contract. We're going to fix that pretty soon. So crosschain receiver is this one.
01:40:30.282 - 01:41:13.720, Speaker A: Right? So crosschain receiver here, amount is the same one following by six zeros. So let's do one more thing. So 112-3456 and when it comes to gas limit, we're going to bump it to 500k. So 500k instead of zero because now we're sending our tokens to the smart contract and I'm going to hit transact. I'm going to sign this transaction and I'm going to wait for transaction to be included in the next block. Right. Let's switch back to all of this stuff again.
01:41:13.720 - 01:41:29.678, Speaker A: Cool. If it went through, it's not yet. So we're just going to wait. Here it is. And I'm going to, as earlier, grab the transaction hash. Right. Okay, this is too tiny.
01:41:29.678 - 01:41:54.380, Speaker A: Okay, cool. Transaction hash. Here it is. Go back to CCP explorer and search now for this one. Right. So once this one gets finalized or success, we should be able to see the balance of token tokens of our receiver smart contract increase. While we're waiting for that, I'm going to go back to check for questions.
01:41:54.380 - 01:42:38.086, Speaker A: Let's see. Do we have a couple of insights? Yeah, Sylvia, I didn't get why we needed to swap USDC to USDC. So we have one legit USDC on testnets, but compound has its own version of USDC and all of other defi protocols kind of have those MOOC tokens which look the same for the reason because they can mint them permissionlessly and it's kind of helped their users to try test the platform without extra dependencies. So that's why we just did that swap part. This is just for testnet because we cannot provide the actual USDC to compound with reading. Must be that mock token. That's it.
01:42:38.086 - 01:43:03.882, Speaker A: But on mainet just not a thing. Okay, so we have a couple of follow ups for faucet. Perfect. Debugging sessions are great. Thanks. Hopefully we solved those issues we had earlier. We can see that the tag is blast.
01:43:03.882 - 01:43:47.002, Speaker A: That's always great. I'm going to now stop sharing my screen and I'm going to just play some lo fi so you have more time to participate in exercises. We will have survey to fill in if you want. That'll be highly appreciated because we created these surveys, both chain link labs and circle for you to provide a feedback because we kind of make these master classes for you guys. So whatever you like, disliked or think we can do better, just write it down and we'll make it happen for the next masterclass. Of course. Thanks for nice words.
01:43:47.002 - 01:44:14.710, Speaker A: In a chat I'm going to share screen place in low file and I'll drop the survey for you to fill in once you're done with CCP exercise number two. We can see this one was success. That's always great. Feel free to again share details in a chat and I'll fix that tiny typo in a minute. So don't put the wallet address. Put the actual contract address as a receiver. Okay, cool.
01:44:14.710 - 01:45:24.540, Speaker A: Let's play some lo fi really quickly. Stop sharing screen. Where is music? Here it is. Okay. And let's fix all of that stuff that needs to be fixed. Satellite like 30 minutes for this one. I'll be around for the next 30 minutes, maybe even more if you need to help with any questions.
01:45:24.540 - 01:45:41.890, Speaker A: And yeah, I hope we're going to make it together. It's always nice to see so many positive comments. So yeah, thank you very much guys. I hope you enjoy this. I hope this was like a great use of your time. We're going to drop the feedback. Feedback URL anyways.
01:45:41.890 - 01:45:58.520, Speaker A: Yeah, feel free to write something that didn't like that usually helps. Whatever it is, drop something you didn't like. So even it's like a tiny detail so we can make it better. Of course. Cool. Thank you guys. Okay.
01:45:58.520 - 01:46:42.242, Speaker A: Yeah, my contract received compound USDC. So yeah, great person. If I'm pronouncing that correctly. Hi, Zuvin, what's up? This is one of our bas at hosting a set of awesome functions master classes. Previously compound USDC received. Amazing, David. Amazing.
01:46:42.242 - 01:47:04.666, Speaker A: Great job. Really looking forward to you joining us in our next master classes and maybe expand our previous ones. Yeah, this is what we want. So this is the URL for the form. Just fill it in. If you like it, great. Write that down.
01:47:04.666 - 01:47:30.100, Speaker A: But if you have something that you didn't like or you think we can do better, that'll be filed, you know, just any suggestion of any kind will be great for any further CCP or other masterclass or something. Even like, if you didn't like my touch word or whatever. I'm joking. But to get a point. Yeah. To win is the chain functions master. That is correct.
01:47:30.870 - 01:47:31.390, Speaker B: Yeah.
01:47:31.480 - 01:47:43.962, Speaker A: Cool. And we have another og of tank. I'll say. Harry Potter. Hi, Harry. Yeah, we're playing some. Yeah, cool.
01:47:43.962 - 02:06:09.120, Speaker A: So yeah, again, let us know how we did fill the form and whenever you're done, whenever you're done, just let us know in chat so we can congratulate you publicly. I'll be around. Just. It's. I know. I. It's sa.
02:06:09.120 - 02:14:54.308, Speaker A: It's race. It. It's okay, guys, we are right on time. It's 07:15 p.m.. ET. Yeah, I hope. As I said, you enjoyed this match class.
02:14:54.308 - 02:15:25.404, Speaker A: There is a feedback form down here, so please feel free to fill up. I hope I helped some of you in the chat during the extra time. And as always, once we're done with this masterclass, we can always follow up on Twitter or x however you prefer. So Andre, Andre or Andre underscore dev on Twitter. So feel free to tweet me on wall. I think dms are logged, but on regular profile like tweets. That's fine.
02:15:25.404 - 02:15:55.940, Speaker A: I'll always follow up. And if you have any questions, issues, either there or at our discord or just write a stack or a full question or stack exchange question and tag chain link and we will try to help you as soon as possible. As I said, the previous master classes will be updated SAP and yeah, much love for you guys. Thank you for spending your precious time with us today and I appreciate you all and see you soon. Bye.
