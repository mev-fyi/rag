00:00:00.410 - 00:00:55.082, Speaker A: So, out of curiosity, how many of you have heard about Chainlink off chain reporting, raise your hands. Oh, okay, cool. For those of you who have never heard of it, I'm very pleased today to introduce you to the protocol that beats in the heart of Chainlink's decentralized oracle networks. And you who have already heard of it stick with me because they have something new to talk about. So in short, chainlink off chain reporting is a protocol that allows smart contracts to interact with data and computation off chain. And if we take it one step further, it allows smart contracts from different chains to also interact with each other. Today I am excited to talk to you about offchain reporting three which comes with new exciting features.
00:00:55.082 - 00:01:32.518, Speaker A: We designed off chain reporting 30 to offer fast finalization, high throughput and flexibility. And I will start restock by giving an overview of offchain reporting protocol. Then I will discuss how you can use it to configure it and build on top decentralized applications. Then we will focus on exciting features of offchain reporting 3.0 specifically. And finally, we will see a use case with chainlink data streams. So offchain reporting runs on a decentralized network of oracle nodes.
00:01:32.518 - 00:02:33.230, Speaker A: And by decentralized we mean of course that these oracle nodes do not need to trust each other. And in fact, if an adversary compromises some of them, this will not compromise computation or data integrity. And the protocol is of course designed to run even if the network is partitioned or if the nodes are faulty. And what it does is that it collects data from external sources, it aggregates them, creates reports, and it collects signatures from the oracle nodes on these reports which attest their validity. Therefore, we call them attested reports, and in the end it submits those reports in a reliable, fast, and cost efficient way to some external consumers, such as, for example, a smart contract. Now, off gen reporting is not yet another decentralized protocol. The cool thing about it is that it is highly configurable and it allows developers to add custom logic on each step of its execution.
00:02:33.230 - 00:03:42.462, Speaker A: Say for example, you want to implement with off chain reporting, a threshold signature service on a high level. The first step of the protocol will gather some input from the data sources, and then what the oracles can do is sign this input. So we will implement the first method of the configurable logic to do a signature. Then the protocol moves on to gather those signatures that each oracle created, and then the developer can implement in the second method of the implementation, signature aggregation, and therefore create a threshold signature, the set of the methods that the developers can implement on their own. We call them reporting plugin, and we expose from offchain reporting an interface that defines these methods that the developers can implement. Another example can be, for example, decentralized voting. So in this case, after an input, the oracles will vote possibly based on this input, and then the protocol will gather these votes.
00:03:42.462 - 00:04:26.910, Speaker A: And the second method of the plugin implementation here can be counting votes, for example. Now, under the hood, offchain reporting is a composition of four protocols. This allows us to develop them independently in a modular way. The protocol is a composition of a pacemaker, an outcome generation protocol, a report attestation protocol, and a transmission protocol. So let's see what they do. Outcome generation, similar to most practical, decentralized protocols, implements a leader follow paradigm. This means that at each time one oracle acts as leader to drive the protocol.
00:04:26.910 - 00:05:07.278, Speaker A: But for fairness and resilience, we don't want this oracle to remain the same all the time. Instead, we want the leader role to rotate across all oracles. And to do this consistently, we utilize the pacemaker protocol. So off chain reporting is structured in epochs, and each epoch has an oracle as leader. And the pacemaker is the protocol that allows oracles to move from epoch to epoch consistently. The next protocol, outcome generation is essentially the core of off chain reporting. It is the protocol that gathers the data from sources and creates outcomes based on those data.
00:05:07.278 - 00:06:21.270, Speaker A: And we use the term outcome here to highlight that these are not just aggregated data from the sources, but instead we can combine this with arbitrary metadata, arbitrary state if you like. The third protocol, the report attestation protocol takes these outcomes and translates them into a tested reports. In fact, it is also the protocol that ensures that the reports are available on all oracles and gathers signatures from all oracles on those reports, and therefore these reports are attested. Finally, we have the transmission protocol that will take the attested reports and reliably transmit them to the external consumer. Now, the four protocols interact with each other via events. Initially, the pacemaker protocol will send a new epoch start event to the outcome generation protocol to signal the start of the epoch. And the outcome generation protocol will run in rounds and once it creates an outcome, it will notify the report at the station protocol.
00:06:21.270 - 00:07:38.924, Speaker A: It will also notify the pacemaker protocol with a progress event, which ensures that the pacemaker protocol knows that everything is going well with the current configuration and the leader is operating as expected. The report at the station protocol in turn will notify the transmission protocol, and finally the transmission protocol will send the report to the external consumer. And this repeats for multiple rounds until a configurable number of rounds when the outcome generation protocol will notify the pacemaker that this leader has been there for a while and it's time to move to a new epoch. Now, offchain reporting three has a new feature, which is it builds a contiguous history of outcomes. This means that the outcome of a round points to the outcome of the previous round consistently across all oracles. And importantly, this also holds across epochs, and more importantly, this also holds across epochs when there is something going wrong. So for example, say in some round the leader was faulty or there was a network partition and we could not generate an outcome.
00:07:38.924 - 00:08:33.260, Speaker A: In the new epoch, the first outcome will still point to the previous one. And this is important because it allows us to pass state from outcome to outcome, and we will see actually what we can do with that. Say we want to create now reports for prices, and we want to create these reports for contiguous periods of time, such that for each period of time all oracles have a unique report. So in this example here, for the round of report R one, we have a report of $10 from the period from T one to T two. And then in the next round we want to ensure that the report is from T two to t three. So here the state we can pass from round to round is the timestamp t two. In fact, this is the logic that runs inside chainlink data streams.
00:08:33.260 - 00:09:37.684, Speaker A: Chain link data streams is a combination of two implementations of the reporting plugin. The first one is the implementation of aggregating prices from external sources to create reports on them. And the second one takes the prices from the aggregate, takes the aggregated prices, and if some condition is satisfied, it notifies a decentralized application to perform some action. Now we will use the first part as an example to see how we can build our reporting plugin. So, recall, the reporting plugin is an interface of methods which the developer chooses how to implement to add custom logic on offchain reporting. And specifically for data streams, the external data sources send data, which in this case is a collection of prices. So for example, a bid price, an ask price, and a benchmark price from their order books, and also a timestamp.
00:09:37.684 - 00:10:40.344, Speaker A: And when the oracles observe this data, they run what the implementation of the first method dictates, which can be just checking the format of this data. And if this goes well, they will create an observation message. And this observation message, because of the contiguous history property, it can point to the previous outcome. Now the leader collects these observation messages and sends them as a bundle back to all oracles. And now it's time to use the second method of the reporting plugin. And the implementation we choose for data streams is to create a median from the prices reported in the observations and also set the bounds for the period of time we want the report to hold. So for the lower bound we will look into the previous outcome that we know of because of the contiguous history and the observations that point to it.
00:10:40.344 - 00:11:42.044, Speaker A: And for the upper bound we will use the values that we see in the observations, and then we might want to add some conditions. For example, if we want to ensure that we don't create outcomes for overlapping periods of time, we want to ensure that the from point is larger than the two point. And if everything goes well and the oracles can create an outcome based on this information, they will send it back to the leader, and then the oracles run an agreement among them and they receive the attested report from the report attestation protocol. And now we can again implement a method for the reporting plugin to dictate what we do with this attested report. And this method is usually a filter method, and it tells the Oracles whether they should submit this attested report to the external consumer or not. And such an implementation could be, for example, that we do not want to send stale reports to the external consumer. So say the report is a day old, then we don't want to send it.
00:11:42.044 - 00:13:01.640, Speaker A: Otherwise we send it to the next step of the process. Now, beyond data streams, there is no doubt that off chain reporting protocol is a key technology for decentralized oracle networks. The configurable logic allows us to build, on top of a battle tested implementation, all chainlinks, products that may be data streams, verifiable random functions you call it. Importantly, off chain reporting allows us also to implement what we can call hybrid smart contracts because they allow developers to have some computation off chain, for example, like functions do, they can hit an API, do some computation with it, agree on the result, and then also do some computation on chain with the result of the off chain implementation computation. And of course it is implemented in a way that it allows us to have it chain agnostic to be able to integrate with multiple chains. We are particularly excited about offchain reporting 30 because it is highly flexible. The reporting plugin is extended to be even more expressive and allow developers to build even more expressive reporting plugins.
00:13:01.640 - 00:13:52.410, Speaker A: It also uses the contiguous history property to enable state to be passed from round to round or from outcome to outcome. And even though this is a protocol with stronger properties than previous versions. It still has low latency, subsecond latency. And finally, of course, for a practical, decentralized protocol, we want high throughput, and we can have this by batching multiple reports in a single outcome. So this is joint work with a talented team from Chainlink Research, Lawrence Breitenbach, Christian Cachan, Alex Coventry and Alexandro Topletiano. And I'm excited to tell you that this is live on minutes, and it is ready to enable web three to reach its true potential. Thank you.
00:13:52.410 - 00:13:56.630, Speaker A: Close.
