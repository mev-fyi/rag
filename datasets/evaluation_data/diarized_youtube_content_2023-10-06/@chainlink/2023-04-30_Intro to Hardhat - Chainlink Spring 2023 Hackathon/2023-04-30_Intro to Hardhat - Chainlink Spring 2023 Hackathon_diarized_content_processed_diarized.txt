00:03:04.180 - 00:03:46.764, Speaker A: Hello everybody. We're going to start in a couple of minutes. Just say some hit some gms in the chat or something so you know that you can hear me or amp or the music you it. And then we are going to start with this workshop in couple of minutes. Hope you're going to enjoy it. I see a couple of questions. Cool devices here.
00:03:46.764 - 00:04:03.876, Speaker A: I'm going to shut down the music, by the way, right now. Give me a. Okay. Hello. Hello. Let's go. Yeah, this video is not pre recorded, by the way.
00:04:03.876 - 00:04:36.830, Speaker A: So we are live, but it's going to stay on YouTube afterwards if you can follow along right now. But yeah, so hello everyone. My name is Andre and this is another Chainlink hackathon workshop. Our topic for today is intro to Harhat. Okay, let's quickly change the slide. So this is our main topic for today. This workshop is going to be a pure code along.
00:04:36.830 - 00:05:18.120, Speaker A: So if you have your laptops with you and you are willing to try to maybe call along with me, you're more than welcome to do so. We're going to hide this stuff right away. Okay? Yeah, you will watch it later on YouTube. Thank you very much. So this is the question for anyone who are not able to attend at the moment. This is live, but it's going to stay on YouTube later. Okay, so to answer the next set of questions, this is the agenda.
00:05:18.120 - 00:05:52.480, Speaker A: So we are going to create a simple hardhead project. Then we are going to write some tests using typescript. Then we are going to try to use the hardhead chain plugin. And then finally I'm going to quickly explain to you how to use chainly harvest Arkit, which is basically a boilerplate repo for any hackathon related projects. Yeah, as I said, my name is Andre Dakic. I'm one of the developer advocates for Chainlink protocol chain clubs. You can see here listed my Twitter and Lance handles.
00:05:52.480 - 00:06:35.552, Speaker A: So if you want to follow me there, feel free to do so. Basically, I tweet a lot about solidity. Sometimes I announce workshops and workshop details like this one. So if you want to follow along after this workshop, ask anything chain link related, you're more than welcome to do so on my Twitter or lens. So this is the agenda and this is pretty much it for this template for these slides. Let's start diving in right into the code itself. Okay, so I'm going to now present my terminal window.
00:06:35.552 - 00:07:44.632, Speaker A: I'm on Mac. If you're using Linux or Mac, it's going to be pretty much the same flow for you. If you're on Windows, the recommended approach will be for you to actually use Windows subsystem for Linux too. Okay, so let's first share my integrated terminal. I'm going to CD to desktop and create a new folder and I'm going to name it Harhat workshop. Okay, so this Mkdir is basically for creating a new folder on Linux and macOS operating systems. If you're on Windows, it's going to be pretty much the same, but the point is that you need to create a folder and then CD into that folder and open your code.
00:07:44.632 - 00:08:26.712, Speaker A: Editor of choice. I'm using visual studio code, but you're more than welcome to use anything you allow. So this code is just dot is just a simple command that's going to open visual studio code inside this folder. You can do that manually if you want as well, but this is basically like a shortcut for that. So I'm going to now stop sharing this screen and I'm going to present my hardhead thing. Okay, so we have a question before that. So why is chaining teaching hardhead and foundry? Aren't they mutual exclusive? And if so, which one should we choose for which type of project? Excellent question.
00:08:26.712 - 00:09:31.448, Speaker A: So basically to start with a blockchain development, two of the best choices at the moment are Harkat and foundry. And if you want to use Chainlink in your blockchain development, then you will need to use either chain link or either, sorry, Harkhead or foundry or truffle or, I don't know, April, whatever is your preference? So which one to choose? It really depends on the type of problem you're going to solve. It really depends on how you're going to set up your tests, your testing environment. It really depends on your language preferences because in foundry you're going to write your tests and scripts in Solidity, while in hardhead you're going to write them in tacript or javascript. With April you're going to use Python, et cetera, et cetera. From what I saw from some latest production ready projects, they tend to combine foundry and hardhat as well, because all of these frameworks and tools are basically have their pros and cons. So by combining them you're going to use the best of both worlds.
00:09:31.448 - 00:10:09.050, Speaker A: So it's really up to you what you're going to use. Okay, we see that someone is using sublime text rather well. What is foundry? Foundry is similar to Harkit, so it's basically development framework for writing, testing and deploying smart contracts. Okay, let's see we are looking for visual studio code. Perfect. I'm going to share this, click this. Okay, so you should be able to see my visual studio code.
00:10:09.050 - 00:10:39.244, Speaker A: I'm going to do something like this. Zoom it a bit so you can follow along and open the integrated terminal. So you should be able to see this integrated terminal. Basically just give me a second. Okay, so what I want to do now is that I want to create a new hardhead project. So to do something like that I'm going to hit something. So I'm going to first need to check my node version.
00:10:39.244 - 00:11:20.930, Speaker A: So node version I should be able to have node installed. After that I'm going to type something like this NPX hardhat in it, NPX hardhat in it and hit enter. Then this integrated terminal environment is going to pop up. So basically ask me what do you want to do? Create a Javascript project, create a typescript project, empty config file or quit. I'm going to select create a typescript project and hit enter project root. It's okay to be the same as this one git ignore yes. Install dependencies yes.
00:11:20.930 - 00:12:17.170, Speaker A: And we are going to now wait for everything to be installed and set up. So coffee break. While we are waiting for this to happen, maybe you'll have some kind of questions. So I'm more than welcome to try to answer them. Also, while we are waiting, because there are no any further questions, I can maybe explain to you the explain. Okay, there are a couple of questions. We're going to wait for that.
00:12:17.170 - 00:12:44.198, Speaker A: Give me a second. Okay, while this is installing. Okay, perfect. This is installed. Let's first answer some questions. It's upon us whether we choose javascript or typescript. Yes.
00:12:44.198 - 00:13:26.078, Speaker A: So if you're more familiar with either of those two languages, choose it. I'm going to use typescript because I prefer typescript. But again, it's totally up to you guys what you're going to use. Where we can find info on node version compatibility. So either like node JS official website or specifically for hardhead, go to their documentation or GitHub so you can see which versions they are support. Okay, give me a second. General advice for people with little to no knowledge about web three development.
00:13:26.078 - 00:14:16.402, Speaker A: Excellent question. So to get started with web three development, you will first need to learn some of the EVM compatible languages so you can actually write smart contracts on blockchains. So my suggestion is to start with solidity because it's the most popular one. There is a really handy solidity handbook on web three, codecamp, blog or website. I'm going to post the link at my twitter after this workshop because I don't have it prepared ready. And yeah, as being said in the comment section also like hardhead documentation is pretty well after that. Ether js for web three front end stuff and then build on top of that.
00:14:16.402 - 00:14:59.862, Speaker A: Probably I'll suggest for you then to go maybe to read mastering Ethereum book or something like that. But it's totally up to you. Why do mostly people use hardhead and standard truffle personal preferences, just personal preferences between these two frameworks when it comes to truffle. Again, you can write your tests and script in javascript or typescript there as well. Yep, first understand blockchain working. Yep, that's, that's good advice. And yeah, this is the absolutely fantastic resource.
00:14:59.862 - 00:15:33.318, Speaker A: Patrick Collins blockchain development course okay, let's continue with the workshop. So we have four folders now. We created a new Harkit project. So inside the Contracts folder is the folder where your smart contract is going to live. So all your solidity files are going to be present there. Inside your scripts folder is where you're going to store your scripts. So they're going to be written in typescript and most of them are going to serve basically for deployment to a blockchain.
00:15:33.318 - 00:16:13.946, Speaker A: Inside your tests folder you're going to find all of your tests. So you're going to store your typescript Javascript files with tests over there. And finally hardhead config real important file. This is where your hardhead configuration is going to live. So inside this config you're going to specify solidity version. I don't know, the network specification for each network for your end to end tests or deployment scripts, et cetera, et cetera. So this is the config part.
00:16:13.946 - 00:17:03.686, Speaker A: And package Json is just the standard stuff as we imagined, inside any node JS project. Okay, so we have this lock smart contract here. This is like a boilerplate smart contract developed by Nomic foundation by guys who created hardhats. There is like deployment script for this contract and there is a sample test for this contract. So this is like an example for you. If we want to compile these smart contracts, what we need to do is to type NPX hardhat compile by typing NPX hardhat compile. It's going to compile the smart contract, generate two more folders, actually three more folders, and say that compilation was successful.
00:17:03.686 - 00:17:53.082, Speaker A: So the artifacts folder is basically built info for this smart contract. So you can find, let's see, this is the better, yeah, so you can find the source code, the ABI, the init bytecode, the deployed bytecode, et cetera, all the build artifacts for the smart contract itself. Then there is a folder called cache. So this is just hardhead exclusive. This means that if I do hardhead compile once again, it's not actually going to compile them once again because there is nothing to compile, there is no changes in my smart contract, et cetera, et cetera. So this is for performance reasons. And finally we have this folder called typechain types, which is basically because I'm creating a typescript project.
00:17:53.082 - 00:18:43.370, Speaker A: This typechain is a tiny library, really handy, which automatically generated typescript types for out of solidity types here. So it's going to be easier for me to write tests. Actually, all of these files, cache artifacts and typechain types should be present in your git ignore. So it's not really a wise idea for you to push them or publish them onto the GitHub. Okay, now that we started with the hardhead, let's create a new contract. So inside contracts folder create simplestorage Sol, which is a simple solid file. Okay, so I'm going to hit this close this so we can see better.
00:18:43.370 - 00:19:13.006, Speaker A: So first of all, you'll need to specify the license. So SPDX license, edentifier, and I can put MIT, but you can choose whatever license you want. This is basically a license for your smart contract. If you're not sure what to put, you can put unlicensed as well. But I'm going to use MIT. Okay, so next one I'm going to select the solidity version. Solidity compiler version.
00:19:13.006 - 00:19:39.670, Speaker A: Sorry. So I'm going to say something like this. So any solidity compiler version that is 0.8.0 or higher can compile my smart contract. Because if I go back to Harkin config, and I can see that Harkat is going to use 0.8.18 solid version for compiling my smart contract. So it's not going to result in error.
00:19:39.670 - 00:20:10.500, Speaker A: Contract, keyword, and simple storage. This is like a name of smart contract. I'm going to save all of this and once again type NPX hardhat compile. So I compiled my simple storage contract. I have new typings for typechain, et cetera, et cetera. Okay, now that we have an empty contract, let's do something fun with it. So first of all, we can do something like this string message.
00:20:10.500 - 00:21:15.626, Speaker A: This is storage variable, which is type of string, and it's present in smart contract. So if I do something like this function set, actually function get message, public view returns string memory and return message. I should be able to see the content of this message because this message is empty. For now, what I will see is basically an empty string. So by default it's empty string. Okay, so to set the message, what I can do is type constructor. So constructor is going to be going to be executed during the deployment process only.
00:21:15.626 - 00:22:03.422, Speaker A: So this is going to be called only once. So here I can type something like this. Hello world. Okay, so now when I call this get message, I should be able to see hello world. Solidity has a really handy technique which will automatically generate getters for us if we put public here. So because we put public over here, it's going to create a new getter function called message. So the name of a storage variable which is going to be exactly the same as this one.
00:22:03.422 - 00:22:56.640, Speaker A: So I can easily remove this function as well because I put public keyword over here. Okay, finally I can type something like this. So function set message, which is going to set new message. So it's going to be string memory, new message, again public. And it's going to set message to new message. Okay, so it's really nice, I don't know, thing in solidities to always emit events. So I'm going to event, create a new event called new message, which is going to have string message.
00:22:56.640 - 00:23:59.234, Speaker A: And I'm going to emit new message with message. Okay. If I type NPX, hardhat compile, everything is going to work. Okay, so do we have any questions so far? Okay, couple of questions. What is the contract AbI exam? So ABI stands for application binary interface. It's a gianting, not gigantic, but the JSON file which has set of your smart contract functions, storage variables, public storage variables, et cetera, et cetera. So you can easily communicate with your smart contract on a blockchain using your front end for example.
00:23:59.234 - 00:24:32.474, Speaker A: So it's like handy interface for communication from the outside world to the blockchain to the smart contract on blockchain. Exactly. Which contains struggle whenever you're using. Yep, this is pretty much the thing. Yeah. When you're using interact, blah, blah. Hey Andre, good question.
00:24:32.474 - 00:25:51.750, Speaker A: How much memory is allocated for strings? So if string is under 32 bytes long, it's going to be stored inside the single slot in storage. But if not, slit is going to treat it as an array of characters. So it's going to have one slot for array length and couple of nested slots for the string itself. Why do we need to emit event you don't, but it's a good practice. And by emitting events you are basically, events are searchable through logs. So it's a good practice to emit events, things that you want to read from blockchain, but it's like expensive to store. For example, with this smart contract I can only read the latest message, but if I want to search for all of the messages I can only do if I maintain events previously because I can search logs using completely off chain computation.
00:25:51.750 - 00:26:34.046, Speaker A: Yeah, pretty much the same. Like we need to emit events if we want to display. So event is literally like a console log from blockchain. What is the purpose of Harkit in the building process? So it's for compiling smart contracts. So for smart contract development, for writing tests and for deploying to the blockchain. So testing. Okay, so as part of our agenda I said I can talk faster.
00:26:34.046 - 00:27:12.778, Speaker A: Yeah, but this is just to have a reasonable pace for everyone to follow up. Sorry about that, but I'll just speed myself up. Okay, so as part of the agenda I said that we were going to write some tests. So this is the next chapter, writing tests with solidity with hardhead. So the tests are going to be in typescript, but before that set message. So at the moment set message can be called by anyone. So in solidity there is something called, there is a nice pattern that you're going to limit that you're going to track the inputs and then you're going to update, sorry drews.
00:27:12.778 - 00:27:54.538, Speaker A: And then emit events at the end. So what I want to do is that I want only owner to, to be call my set message function. So to do that I'm going to first address, I'm going to make this private owner. Then I'm going to say that owner is whoever deploys this smart contract. So master sender and I'm going to create a modifier. So modifier only owner, it's going to say something like this. So require that message sender is equal to owner.
00:27:54.538 - 00:28:27.830, Speaker A: And if not only display this error message, only owner can call. So there's going to be error, only owner can call and to be a valid modifier. I'm going to put this and also only owner here, NPX hardhead compile. Boom. Okay, so, okay, no questions about modifiers. We all know that. Fantastic.
00:28:27.830 - 00:29:02.740, Speaker A: Let's continue. So by typing I'm going to clear this up. NpX herhat test. You're going to execute test suit because I already said that there are a couple of pre written tests inside her hat we are now seeing that nine tests are passing. So tests are located under test folder inside log ts. There are set of tests for log. So as smart contract, so go there, create simple storage spec ts which is a test.
00:29:02.740 - 00:29:42.190, Speaker A: And then let's create our first test. We can basically put this on the right so we can follow along to see what they have written. But it's going to be pretty easy for us. So we need to start with a describe block and here inside describe block. I'm going to say something like this. Simple storage unit tests and then async function function create a new function. Okay then let's make this actually a function.
00:29:42.190 - 00:30:14.662, Speaker A: Okay, so here I can create a new test by creating an it statement. So it should something. Okay. And here async function create new function. Okay, sorry about that. So inside this it statement I can write my tests. So what I can do, I can deploy this smart contract.
00:30:14.662 - 00:31:03.558, Speaker A: I can deploy to a local hardhat network. I can call functions of this smart contract. I can assert some things, et cetera, et cetera. Because of the performance reasons, there is something called fixtures. So fixtures are used for you to deploy smart contract only once and then we're going to use the copy of it inside every single unit test. So unit tests or these it statements needs to be independent of each other. If you have a unit test that for example checks, I don't know that only owner can call a function, then the other one should not be even aware of the existence of that unit test or the owner, et cetera, et cetera.
00:31:03.558 - 00:31:49.042, Speaker A: So in order to do that, you must either deploy your smart contract to a local hardhead network inside every it statement or use fixtures. Fixtures are more faster and there have caching techniques, et cetera. So to use fixtures I should do something like this, create a function called async function, I don't know, deploy simple storage fixture and deploy smart contract. So to deploy smart contract you should use something like this. So you should write something like this. Const simple storage factory is await eaters. So I hit tab.
00:31:49.042 - 00:32:32.934, Speaker A: So ethers was automatically imported from harhead for me. I'm going to do something like this so you can see better. So ethers get contract factory and I'm going to use simple storage. Okay, save it then. Const simple storage is again await simplestoragefactory deploy. And because if we go back to simple storage, we can see that there are no deployment parameters over there. So I can just now hit deploy and that's it.
00:32:32.934 - 00:33:15.106, Speaker A: Okay, finally inside. Yeah, and I should return simple storage. Okay, finally here I should do something like this. So const simple storage await. And let's see the syntax. Yeah, load fixture deploy simple storage fixture. Okay, and this load fixture is coming from this thing.
00:33:15.106 - 00:34:09.798, Speaker A: Okay, I'm going to close this now so we can see better that you should import load fixture from nomic foundation, hardhead network helpers, et cetera. So what I can do now is that I can console log simplestorage address so I can see that this fixture is actually deployed. Simple storage contract to a local hardhat network. So once again, NPX hardhead test, moment of truth. Okay, here it is. We can see that we have simple storage unit test and some address. Okay, so to speed us up, I can only run set of my tests so I can do something like this describe only if I repeat the process now, only this test is going to be run and all of the next ones obviously.
00:34:09.798 - 00:34:56.850, Speaker A: Okay, do we have any questions right now? Okay, modifier. Fantastic. Thank you. Thank you for answering some of the questions. Okay, let's continue to speed us up. As I said, if I change my constructor to accept messages like this, string memory message and use syntax like this, I'm going to mtxrhead, compile it one more time. Now the deploy function is going to be red because we are expecting one argument, but we got zero.
00:34:56.850 - 00:36:04.060, Speaker A: So an argument for message was not provided. It's really handy user error. So what I can do is const message equal to let's say hello world or not hello world, something else, and then deploy message. We should now be able to see this message as our message. How so? Const message is equal to simplestorage message, as I said, because we have a public visibility modifier over here. So message is going to be automatically generated as a getter function. What I can do is I can console log my message message and then hit NPX hard hat test.
00:36:04.060 - 00:36:45.640, Speaker A: So we have a promise because this is an async call. So with Javascript typescript you need to wait for something to be executed. So I'll need to wait for my local harkit nod to read the actual message. So once again, now we have something else as a message. So this is this message. Okay, so this is not a valid unit test because we're just console logged something. So this unit test is actually should test deployment stuff.
00:36:45.640 - 00:37:38.520, Speaker A: So first deployment stuff is that we set up this message to provided message inside constructor. So I'm going to go back to fixture, export it from fixture, and now what I want to do is basically to have an assert statement. So first I'm going to import it. So import assert from chai. So I'm going to do something like this, assert that message is equal to message here. Okay. If not messages are not the same.
00:37:38.520 - 00:38:21.726, Speaker A: And run and pixar head test. Okay, everything's fine. And also I'm going to test that the owner is actually message sender. So how to do that? So if ts there is eaters get signers. Okay. So I'm going to close this, close this, et cetera. So with get signers I'm going to get some externally owned accounts in hardhead network that I can use for testing by default when I call functions.
00:38:21.726 - 00:39:18.838, Speaker A: By deploy default is going to be called by the first wallet external whatever, which is this owner. But I can actually manually specify which wallet is calling, which account is calling this function by doing connect owner. And now I literally said call this function using owner. So I'm going to export owner and other account as well. And here I need owner. So what I want to do now is that I want to check who is the owner but I cannot because this variable is private. But let's see how to do this.
00:39:18.838 - 00:39:45.970, Speaker A: Okay. Let's make it public. This is the easiest solution. So once again NPXR hit compile. I can literally get this value from the storage, but this is faster. So here if I do something like this. So const owner is weight sample storage owner.
00:39:45.970 - 00:40:15.702, Speaker A: If I console log these two values, current owner and owner, I should be able to see two exact addresses. If I hit NPXR, hit test. Sorry about that. Current owner is a string but owner address, sorry about that. Let's do one more time Npxrhead test. Okay. Two addresses exactly the same.
00:40:15.702 - 00:40:54.840, Speaker A: So let's see about the type string. Okay, cool. So what I should actually do here is that I should remove this to assert this should be equal or owner was not set properly. Hit NPX architect. And yeah, this is it. Okay. Do we have any questions right now? Okay, in get contract factory you define contract name, right.
00:40:54.840 - 00:41:56.600, Speaker A: What's the package we need to import? Yeah, I'm going to go over here. So it's nomicfoundation hardhead network helpers. This one I'm going to actually put it inside the chat it how to just remove contact connect owner part. That's pretty much it. Not that I'm aware of, but maybe on Twitter, I don't know. Okay, let's continue with the workshop. Let's now test the set message function, shall we? Here I'm going to do something like this.
00:41:56.600 - 00:42:30.098, Speaker A: I'm going to put this into the right so we can see better what we need to test. So we need to test four things. We need four things actually three things. Sorry, we need to test that only owner can call this function. We need to test that the new message is now set and we need to test that the correct event was emitted. So to do that, I'm going to create a describe block first. So describe going to type something like this set message, which is the name of the function.
00:42:30.098 - 00:44:01.860, Speaker A: You can type whatever you want basically and then do async function and open new brackets and now three it statements. So let's say first we said it should be called only by an owner async function. Then let's put this aside, shall we? It should set new message and finally it should emit an event, a proper new message event to be more precise. So three stuff that we need to do, okay, so first of all, how to be called by owner. So once again we are going to load some stuff from pictures. So we need simple storage, we need other account and that's pretty much it. So here there is another thing from chai called we can move this up expect.
00:44:01.860 - 00:44:59.074, Speaker A: So we are expecting something to happen and here we are expecting that await simplestorage actually connect by other account. So now other account is calling this function set message to hello world, for example, to be reverted. Okay, let's now type NPX hardhat test and we have an error. Okay, so it says something like okay, it reverted with string blah blah. So we have a syntax error. So it's going to be right like this. Sorry about that.
00:44:59.074 - 00:45:40.286, Speaker A: One more time. So there needs to be a weight statement here. So wait, expect blah blah to be reverted again this call we know that this call is going to revert why? Because we have other account, et cetera. But if I change this to be called by an owner, this test should now fail owner because it's not going to be reverted. Okay, so assertion error. We expected transaction to be reverted, but in reality it has it was not because it was called by an owner. Okay, so this is a new stuff.
00:45:40.286 - 00:46:37.970, Speaker A: Clear once again, if I called NPX hardhead task, everything should be green. But we now know that this function call reverted but we are not completely confident why. So here we have something called reverted width. So reverted width expect and reason and a reason is this error message from our smart contract. So it reverted because of this error. So if I copy paste here, this here, and once again NPXR had test, our test was written even better because we expected that this call we're going to revert. Okay, let's split it up for better readability to be reverted with blah blah.
00:46:37.970 - 00:47:29.074, Speaker A: Okay, cool. Second step, second thing, we should set a new message. Okay, so once again I'm going to copy this thing here, remove other account because we're not going to use it inside this test and do something like this. So const new message is for example chaining spring hackathon. Okay, so here I'm going to call the function. So await simplestorage, connect owner by owner, set message to new message and do something like this. So we called the function.
00:47:29.074 - 00:48:10.926, Speaker A: Now what we're going to do is type const actual message. We're going to read it from the blockchain. So simple storage message. And then finally we want to assert these values. So again I can again console log it, console log actual message so you can see it. But this is not a valid test here, chain link spring character, blah blah. But I actually, as you already know, need to assert that actual message is equal to new message, if not message not set.
00:48:10.926 - 00:49:04.434, Speaker A: Okay, this is the error message. Okay, once again NPXR test everything is working properly. Finally how to emit events. So once again I need fixtures, I need new message. Const new message which can be again, this is fun, hopefully. And then I'll going to use expect one more time. So expect await expect that a call to simple storage from owner set message to new message is going to emit a new event.
00:49:04.434 - 00:49:34.410, Speaker A: So emit have two parameters. First one is contract. So contract is simple storage. And second one is event name, which is new message. Right, so this is the event name new message. But what we can see here, that message has this event has some arguments. So what I can do now is to type width arguments and the argument is new message.
00:49:34.410 - 00:50:16.120, Speaker A: Okay, once again nPXR test so we can see that everything's working fine. And it is so once again for better visibility to emit. Okay, here it is. Once again NPXRC test. Do we have any questions so far? Missed out a bit. Can someone copy paste the test file written so far please? Yeah, I can copy paste it. Hopefully it's going to be here.
00:50:16.120 - 00:51:08.060, Speaker A: Let's see if not. Sorry about that, I kind of broke you too. But yeah, for what do I need test? I could deploy a smart contract on a testnet. Well, yeah, but tests are important because besides unit test there's a lot of other testing techniques like fuzzing, et cetera. It's going to basically minimize the possibility of bugs in your smart contract, let's say like this, exact troubleshooting, et cetera. And yeah, this is the most common test of trust. What is the difference between tasks and script? I'm going to show it right now.
00:51:08.060 - 00:52:50.038, Speaker A: Yeah, this is correct. You're using load picture as a first. Yeah, this correct. So what I can do is basically I can have here because this describes type I can have before each and then async function like this and then, sorry about that, I can say const simple storage contract and then sorry it's going to be let, and then here I'm going to do something like this and then I'm going to say simple storage contract is simple storage. And now what I can do here is that I don't need to use picture, I can use contract but it needs to have type called simple storage. Let's see from type chain, give me a second here and sorry about that, should be here and now. Yeah, I should other user and then user is, let's see what's user.
00:52:50.038 - 00:54:09.470, Speaker A: User is other account. Other account is type signer with address. This should come from ethers, right? Let's see import signer with address from ethers. I guess maybe here's I missed somehow the import, give me a second lock. Let's do something like this maybe. No, never mind, let's make it any, that's fine, but here, give me a second. But here how to convert this to sign a red address? Never mind, do something like this.
00:54:09.470 - 00:54:59.644, Speaker A: This is going to fail right now because we are not expecting this. We expect to be reverted. But this is basically the thing that inside before each hook I call load picture once and then I can use this simple storage contract in all of my tests here like simple storage contract. Remove this simple storage contract one more time message. And this, if I put it only it's going to work right now without using load pictures, et cetera. So this is the point and yeah, good point. Cool, thank you.
00:54:59.644 - 00:55:33.396, Speaker A: Okay, so difference between scripts and tests. So here I'm going to present you something that we created. We don't have a lot of time, by the way, sorry about that, but I'm going to stop sharing this and I'm going to start presenting share screen window. So you should be able to see my streamyard right now, something called hardhead chainlink plugin. So if I go to official documentation, this is a general overview for setting up the hardhead. So we covered all this stuff down here. I have a section called working with Oracle.
00:55:33.396 - 00:56:11.296, Speaker A: So this is the example of working with blockchain oracles. What is an oracle? Why do we need it? What is Chainlink, et cetera, the oracle problem, part of the security architecture, et cetera. So this is like a piece for getting price data. So how to write chaining data fit, smart contract. And then here we have a section on randomness. So like how randomness on chain is extremely vulnerable to nv attack, how it's not secure, how you should use VRF, et cetera. And here we have something called, the mention of something called Chainlink hardhead, chainlink plugin.
00:56:11.296 - 00:57:12.552, Speaker A: So this is literally a plugin for hardhead, which have some predefined tasks for you. So all of these tasks are going to come from this plugin. While for example the deployment script, I will need to write it manually by myself. And here you have an example of how to deal with VRF subscriptions when you're deploying a VRF for example, consumer contract. So here I'm creating ongoirly a new subscription, then I'm funding it, then I deploy my contract and then I'm adding it as a consumer. All of this from this deployment script instead of go to VRF web page connecting my wallet, add details manually, et cetera, et cetera. Okay, so how to see this plugin in action? As said, this is how I'm going to install it.
00:57:12.552 - 00:58:03.590, Speaker A: I will need to import it, import it inside hardhead config. And I should be able to find a documentation over here. So this is the page for plugin. And if I go here to repository or click beta type over here, there is a thing called documentation. So if I go to documentation MD, I can see all of the available documentation for this plugin, from installation to importing to setting up. And then for all of different types that this plugin has. So it does have denominations, library, it has chain link functions, tasks, then we have chain link data feeds, stuff all the way to the end to the give me a second.
00:58:03.590 - 00:58:44.768, Speaker A: I should rewrite this in gitbook, et cetera, but all the way to running a local chain link node on a hard hat network. And this is what we are going to do. We are going to run chainlink node inside your hardhat network. So if documentation is too much for you, too boring, inside this readme file, or here as well the readme, we have some example usage. So example number one, get the latest price of ETH, create and manage VR app subscriptions from what we saw at the official Harkit documentation. And finally this is what we're going to do. We're going to run the local training node on your hardhat network.
00:58:44.768 - 00:59:22.736, Speaker A: And now that we have a local training node on Harkat network we can write more and more and better tests. And for example let's say that you want to test the creation of external adapter. For example, it's extremely handy to do this with our head. I should stop sharing this, sorry about that. And present once again my visual studio code. Okay, so let's expand this terminal as much as possible. I'm going to clear it.
00:59:22.736 - 01:00:43.384, Speaker A: Yeah, as we saw. So I should NPM install save dev chain link, hardhat Chain link this is a plugin for Hardhat. I install it now I should go back to the hardhead config here it is and add this line import chain link hardhead chain link okay, go back terminal, clear this stuff and if I do something like this so NpX hardhat help I can see all of the available tasks. So these tasks came predefined with hardhead and all of these tasks are now new and they are part of Chainlink plugin. So I'm looking for this run and node task. Okay so I'm going to split this thing up again clear here, I'm going to run a hardhead node so NPX hardhat node and I run local hardhead node. Secondly I should have Docker installed.
01:00:43.384 - 01:01:28.532, Speaker A: So once again you'll need to have Docker installed. So I'm going to present again share screen window. Where is Docker once again? Yeah here it is. So Docker desktop so we can see here that no containers are running at the moment, but Docker is up and running and if you don't have Docker go to Docker desktop, just download it and you're good to go. So Docker is necessary for this thing to work. So I'm going to stop sharing right now and go back to Hardhat. So here I'm going to type the name of the command which is if I recall correctly NPX hardhead chain link run node.
01:01:28.532 - 01:02:27.528, Speaker A: So NpX hardhead chain link run node this is now spinning up my docker container et cetera. And now node is up and running which I can see now inside my docker desktop. So share screen once again tar screen, you can see here that now my disk image is up and running. So we have progress and chain link node and postgres database for the node and that's it. You have spin up your chain link node on your local hardhead network. Is Docker an external software? Do we need to download it? Yes. So you need to go to Docker.
01:02:27.528 - 01:03:00.810, Speaker A: I'm going to paste the link. So Docker desktop docker. So you're going to download it from here and then you're going to just need to run it and that's it. So download it from docker.com. Docker desktop is the official website. Okay, so if I go, give me a second here. Yeah.
01:03:00.810 - 01:03:42.596, Speaker A: So then let's present screen window. I'm going to present streamyard once again. So if I go here, it says okay, a couple of important nodes, blah blah. But if you visit localhost on port 6688 in your browser and I can visit like this, you should be able to see operator UI. So this is like a proof that your node is up and running on hardhead network. One more time. So if I go back here, there's like credentials for me to log in.
01:03:42.596 - 01:04:18.120, Speaker A: So user at harhapchain IO. This is like a dummy user, but it's like hard coded and password is strong password seven seven seven. Don't worry, everything's on your local machine so there is no security issues of any kind. If I hit access account now, I'm not going to save it. You can see the actual dashboard of local chaining node. Pretty handy, right? Finally, because we don't have a lot of time, documentation for plugin once again available here. Finally there is this thing called Harvester kit.
01:04:18.120 - 01:04:56.072, Speaker A: So Harvester kit is a boilerplate repo for testing, deploying and shipping chainlink solidity code. It's extremely useful for you. If you want to build really fast Hackman projects, just spin it up. You have a set of contracts over there with all of the usage of all chainlink services. Then scripts, deployment scripts and regular scripts like reading price. Then tasks, couple of predefined tasks, and finally set of tests so you can see how you need to properly write Chainlink tests. There is another branch called typescript.
01:04:56.072 - 01:05:38.184, Speaker A: So this is a javascript version. If you want to use typescript, just switch to typescript version of the start. It has this blue thing over here I'm going to show you how to check out. Once again, it has something called git pops. So if this is 2022, let's say so if you have contributed to Harheter kit, you should be able to get a git pop for 2023, et cetera. So how contribute? Start with open issues or see if there is open issues. There are a couple of ones that are like good first issues like this one.
01:05:38.184 - 01:06:06.560, Speaker A: So you can go jump into it or straight open a pull request and you can see here, let's say if there is, this is like a typo in readme, for example, this is a merge pull request, rahul, open it, blah, blah, blah. Okay. And he became eligible for git pop, et cetera, et cetera. So you can even build on top of it. But let's say how to use it. So we first need to, yeah, let's see. We first need to git clone it.
01:06:06.560 - 01:07:07.070, Speaker A: We have actually quickstart guide over here. So I'll need to git clone it and then CD into that repo. Okay, let's stop sharing this one and continue with the sharing of my integrated terminal. So share screen terminal over here. I'm going to CD out of it. So git clone harkitar kit cloning into Starkit and I'm going to CD Harkit starter kit, starter kit and open again my visual studio code. Let's see.
01:07:07.070 - 01:07:28.476, Speaker A: Stop sharing this thing. Switch between a lot of things. Sorry about that, guys. So this is a welcome screen. Okay, welcome screen. So we are now inside our kit, contract, scripts, test, et cetera, a lot of stuff over there. How to use it.
01:07:28.476 - 01:08:03.340, Speaker A: Open new terminal once again, hit NPm install first. After hitting NPm install, you can again write NPX, hardhead, test, compile, et cetera. And if you want to switch to typescript version, just type something like this. Git checkout typescript. Okay. And now we can see that our tests are written in typescript. If I git checkout main, go back to the main.
01:08:03.340 - 01:08:41.480, Speaker A: You can see that your tests are now in javascript. So there is both javascript and typescript version of this target. Okay, do we have any? Yeah. And Rahul got in GitHub. You're welcome. Do we have any final questions? So again, Harhettar kit, if you want to see how to use it, just go to the official repo. And here inside the official repo I'm going to present that screen once again.
01:08:41.480 - 01:09:13.744, Speaker A: So inside the, inside this repo, so there is a quick start guide. We did that then NPm install. We did that for our previous hardhead project. Don't need to call it then I can call tests then. If I want to go to typescript, git checkout typescript NPm install once again. How to use it if I want to deploy smart contracts, just hit NPm, run deploy. If I want to run a local network, hit this command.
01:09:13.744 - 01:10:33.388, Speaker A: If I want to deploy to Mainet or polygon, which is like a production ready network, follow these steps, et cetera, et cetera. If I want to run forking tests over here, auto funding, couple predefined tasks, tests, performance optimizations, et cetera, et cetera, how to interact with already deploy contracts, couple of commands over here. Just follow the long and copy paste stuff, read carefully and everything's going to be pretty much the same as written here. And it's going to be extremely easy. If something doesn't work right or there is like a type or something, open an issue or open a pull request, you'll have a git pope and the chain and clubs guys are going to actually help you for your pull request to be actually merged so you can merge, so you can even level up your coding skills by contributing to the open source projects like this. Coming back to the story, this is a link for plugin if you want to use it, and this is a guide for the usage of a plugin. So I think we are on time.
01:10:33.388 - 01:11:11.556, Speaker A: We were a bit late, so any final questions? If you have it, feel free to write them now. If not, thank you for attending another channeling hackathon workshop. I hope this was useful for you. I tried to keep it on a reasonable pace. Everyone can follow along code along. Once again, what we covered were four types, four things. So creation of harfat project writing unit tests with typescript usage of harfat chainlink plugin, especially for running a local chainlink node.
01:11:11.556 - 01:11:37.836, Speaker A: And finally, I showed you that Chainlink hardware kit exists, which is a hackathon boilerplate ready project for you to get started with the usage of Chainlink services. I yeah, thank you for joining me. Thank you for your time. And we are going to see you next. Yeah, I hope that you're going to build some amazing stuff during this fact. Bye.
