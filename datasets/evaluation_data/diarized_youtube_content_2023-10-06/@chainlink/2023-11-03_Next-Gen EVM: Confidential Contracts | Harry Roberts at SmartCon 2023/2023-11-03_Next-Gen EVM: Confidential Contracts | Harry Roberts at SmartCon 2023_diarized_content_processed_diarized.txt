00:00:02.010 - 00:01:03.070, Speaker A: So, hi everybody, I'm Harry to the sideswip. Yeah, I'm a technical product manager at the Oasis protocol, Oasis network, and forgive me if I'm looking at my phone, that's just where my notes are. And why am I here today? So essentially, most of us, we're looking at scalability and autonomy because they're fairly big problems. And I think smart contracts should be a little bit smarter. But inevitably there's always going to be more chains and more tokens and more tokens and more chains and l two s and l three s and l four s as well. Maybe, but I think we've reached some sort of fundamental limit of what we can do with transparent contracts. So really I want to start with some more general context to get an overview of where we are and how it all works together and why scalability and autonomy are really important because they're very inherently linked to each other.
00:01:03.070 - 00:01:55.700, Speaker A: So I think of it as like a battle between humans and machines to impose some kind of order. That is, it's the linear sequence of events that's going forward in time, and if we look at the ideal functionality, so everything must happen only once, and you must get instant visibility of everything by everybody. It's final forever, it can never fail and nothing's ever forgotten. But that's sort of far from reality. So, for example, we have the laws of physics, which is not ideal, and if any distributed system is big enough, then it's probably failing all the time. And there's packet loss and errors and cosmic rays, and generally humans and reality get in the way. So failure is the norm and we have to work around that.
00:01:55.700 - 00:03:17.862, Speaker A: And a lot of failures are sort of because of communication, and communication is necessary to synchronize the state of our sort of linear timeline. And I'm not sure if you're aware of Metcalf's law, but it's like assumed that the total value of the network grows proportionally to the square of the number of nodes of the network, and that's because they can all communicate with each other. And so of course, when they're all communicating with each other, we also need like Erlang's theorem as well, because, well, there's going to be queuing and delays, and you can only talk to so many people at the same time. And it's a problem where in the best case it's n squared complexity, because everyone can talk to everybody and you've got global communication, and in the worst case, you've got the n squared problem, where everyone's connected to everybody and can communicate with each other. So the whole point of this sort of communication with each other is trying to synchronize state, and we only know what the other nodes are telling us. And over time we settle on the same answers. So while we've got integrity, that's being maintained by the cryptography, and like byzantine fault tolerant protocols, there's still lag and there's errors and there's semantic differences between protocols, and there's bugs, and there's always bugs.
00:03:17.862 - 00:03:58.540, Speaker A: And when the nodes are communicating state with each other, the key is that the synchronization is happening over time and it's happening across the planet. And eventually we all agree that anything else would be improbable. But there's finalities, not sort of exact, if that makes sense. So if we start with some examples, right? So we've got gas by the ghost, and Frank is my finality pac man. And Frank has to decide sort of which transaction does he eat first. But there's a limit on how many he can eat. And what happens if we want more transactions per second.
00:03:58.540 - 00:04:33.860, Speaker A: So we can add another chain. And hopefully the new chain is going to be a little bit better, a little bit faster. But now we have two francs and two little finality ghosts. And in theory, we can do this forever. We can just keep adding chains. And at one point you can end up with a chain running on every device on the planet, but they all have to communicate with each other. So you can get infinite scalability as long as you cut out the communication, which is a problem.
00:04:33.860 - 00:05:17.090, Speaker A: You can sort of see where this is going. But if we want finality, we can just add one more sort of over chain on top of that that observes all of the other ones, is trusted by all of them, and it defines what's final. So it decides that there's a single point of state synchronization. And then we can do like cross chain swaps. So if we want to communicate between the chains, we have this grand overchain. But yeah, you can't sort of expect everyone to stay neatly on their own chains. And you can't expect everyone to wait for this grand overchain to tell you what's final and what isn't.
00:05:17.090 - 00:06:41.290, Speaker A: There's sort of no neat, sequential sort of finality timeline that everyone marches along. So in a world of multichain, sort of interdependent transactions, we end up running wherever the assets are. So if you're your chain here and your chain here, you do some communication, but ultimately the assets are staying sort of where they belong and the communication is a problem. But then we get sort of into the real world, which is everything's on fire and it's different and incompatible with each other, and the rug is getting pulled all the time, but it's very highly concurrent, it's very parallel, it's very scalable, and it's more valuable than sort of any chain on its own. And this is sort of what I see the industry as being like. You've got the hungry hippos of all the DFI users are trying to sort of get the transactions minted, and then there's me in the back end going, right, okay, how do I do this? And that's because everything's talking to everything, and this is like the necessary mechanics that we have to deal with, because you're not in isolation, you're talking to everything at the same time. But we sort of need to figure out some shortcuts that can make our lives easier.
00:06:41.290 - 00:08:23.114, Speaker A: So I don't know if you've implemented protocols and implementing different protocols, it's really annoying, especially when you get to the cross chain sort of semantics. And we want to make something that makes it easier to have contracts that are more autonomous, that are sort of more decentralized, and that are more fault tolerant. So for example, with bridges, you now have a single point of failure, which is wonderful, but some of the things we can use, like intents, so looking at solvers to figure out the correct way of doing things so you can adapt to the different chains and the different mechanics as they evolve. We can also reduce the number of state updates. We can use trust and sort of summarization, maybe through ZK snarks, to reduce the amount of data that's communicated. And we can implement sort of stateless or eventually consistent operations that over time it resolves and it doesn't need this sort of hard sort of finality stop, which is what I'm sort of getting to at the moment, is the next generation, as I see it, is introducing confidential contracts, which they can be really useful in this case if you sort of think a little bit differently, and it can make these shortcuts really, really simple. So for the purposes of me today, I'm saying that let's think more generally and think about sort of what confidentiality for contracts versus fully transparent contracts, and how can we rethink, how can we solve these in sort of more novel ways? So in my case, I work for Oasis.
00:08:23.114 - 00:09:12.750, Speaker A: We do the Oasis Sapphire, which is our confidential, EVM compatible chain. Rather than using ZK or MPC, we're using the Intel SGX, which is the trusted execution environment. And right now that's where the sweet spot is. And it's letting us do one thing that sort of, I see it as being really game changing, and that's the contracts can have their own secrets. So when all of the contract storage is encrypted by default, that means that unless your contract has a function that lets you retrieve the encrypted data, then nobody can see it. Like not even the person who deployed the contract can see the data. And from a developer's perspective, the closer we can get to just normal solidity makes it easier to deploy.
00:09:12.750 - 00:10:35.910, Speaker A: And when the contracts get executed, if they're executing this trusted enclave, then that means the node operators can't see what's going on. And you have sort of end to end encryption between the DAP running in the user's browser and the smart contract, which it's like HTTPs, but for blockchain, which I think it's going to be interesting, you can get privacy already, you can use fully homomorphic encryption, you can use zero knowledge proofs. And the problem is that they can't have their own secrets. So you can have a secret, you can prove in zero knowledge that you know some piece of information, but it's a bit slow, it's complicated, it's really annoying, right? For full disclosure, I like fully homophobic encryption, I like ZK, but there's a lot that I can't do with them because the contracts themselves can't have secrets. And there's a lot that sort of also is possible, but it's really difficult because of the semantics of fully homomorphic encryption and ZK as well. And you can also look at distributed key generation. So if you want to have autonomy of your keys, you can have a purpose specific NPC quorum that will sign something on demand based on some set of conditions.
00:10:35.910 - 00:11:51.790, Speaker A: But it's because of the nature of communication to synchronize the state, make sure you're not stealing the secrets. You have to be very sort of case specific, and they're mostly used by like bridges. So maybe a bit of account recovery where it's one specific use case rather than a general programming system. And one example we're using is that if you want to control a wallet on say bitcoin or even Monero whatever, right? So even though the contract can hold a secret or the NPC can hold a secret, there's a lot of message passing between the nodes of the NPC system. So if you think back to the scalability side of things, the more messages that you have in the NPC system to synchronize the state in private, the more complicated it gets, the less scalable it gets. And so for very practical reasons, MPC is quite limited in that regard. But let's move on a little bit to the most straightforward use, if you have confidential contracts, which is what I call smart privacy.
00:11:51.790 - 00:13:06.760, Speaker A: So if you look at what's public and what's private, it depends on a lot of factors and how you decide what is public and what is private, it's really up to you to decide. So I don't know if you're like a privacy maximalist or a transparency maximalist, but the real world sort of operates in the middle where you've got your envelope, you put your letter inside the address on the front, and it's this sort of compromise between the two where it depends on what you care about being private. And what do you care about being public? That yeah, it sort of reflects the real world. So think of like if you want to do a ZK protocol where you keep things that are private within a group and the group can change over time, it gets really complicated. So like the signal protocol for example, has a way of doing this, but you might also have different use cases. So you want to make things private for only a limited amount of time. And with the sort of smart privacy approach you are able to make these decisions on a sort of per application basis and decide exactly the semantics for your case about what is private, what is public, and how it becomes either one.
00:13:06.760 - 00:14:30.286, Speaker A: So let's look at an example of what would happen if you gave a contract the ability to have its own secrets and generate an ethereum key pair. So the contract, when only it knows the secret key, the wallet address, can be public and it can act, so it can sign its own transactions, or it can arbitrate, so it can act as a trusted oracle for contracts on other chains or just between users. This can really radically sort of simplify sort of protocols. So if you don't change the state and you're just doing view calls, it's free basically. So most of the time you can implement a protocol through view calls that it only costs as much as deploying the contract. So if you're sort of trying to truncate a multiparty algorithm into sort of a single step, then you can cut out all the state updates, you can reduce the gas and you can even do things like recursion. So if you have a contract that knows its own secret, it can sign that it saw some data and then truncate all of that information in the same way that you would use like a ZK roll up and says, I've seen all this information, here's my signature.
00:14:30.286 - 00:15:06.942, Speaker A: And then anybody who trusts the contract can or trust the contract's public key can verify that you've passed the data through the contract. So like an example of this would be a bitcoin light client. So I know if you're trying to do like trustless bridges, you'd have to synchronize the entire state of bitcoin step by step, block by block onto the contract. And of course this is state updates. It costs a lot of gas. You can now do that with ZK roll ups. But again, it's really complicated to implement this.
00:15:06.942 - 00:16:17.618, Speaker A: You've got a lot of complex mathematics to do the recursion, but with confidential contracts that you can execute them with access to the confidential state without having to make state updates and that's all free, then you get the same kind of functionality as ZK roll ups, but without the overhead. But if we move more on towards sort of multichain contracts, which is where if we're looking at this polychain sort of world where you got lots of different contracts and lots of different chains, you want the contracts to be more autonomous. So if they can have their own key pair and they can sign their own transactions, they can sign transactions on other chains without needing to have a bridge. So if you want less synchronization, you don't want to have this sort of global overchain or CCIP or whatever, then you can have the contracts that can act independently, autonomously and on their own. But the problem is they're doing everything in isolation. So without the bridges, the contract's blind. It can't see the state on the other chain and it doesn't have access to the Internet.
00:16:17.618 - 00:17:22.700, Speaker A: So sometimes it's not even sure as time has passed, but it's got its own keys, it can update its own state and it can move forward. And with that kind of logic you can sort of look at automata, so you can figure out all the different possible states, the states that can and can't be in, and you can use your users as worker bees. So you can implement the sort of game, theoretic sort of arguments there and say it's in their interest for them to pull the data to you and to prove it to you without having to implement all these bridges and all these oracles, you can even use the contracts as like a super smart state channel. So when they have their own keys you can pass messages back between a couple of different users with data that only the contract can see. So it can enforce a protocol for you. And most of the time you don't actually have to do any state updates. So through the eth call, through view calls it's pretty much free.
00:17:22.700 - 00:18:59.820, Speaker A: And I'm not exactly sure how contracts with keys are going to evolve and or like the use cases that people come up with, but there's a long history in computer science of studying automata and this is like the single discrete units that they're independent, they're robust, and lots of the devices that are getting made at the moment, there's lots of network programs, they're all talking to each other via servers, via users, via Bluetooth, and like large parts of the RF spectrum they're all these devices chattering to each other but none of them have the full picture. So they're all in isolation and they're all together working through these little protocols because they all have their own local state and they're really really useful because they're just tiny cogs in the machine rather than trying to do big things. So I think we're still sort of going through this sort of cambrian explosion of what's going to happen. So like TCP IP is 50 years old, like arm processors are 40 years old, HTML is 30 years old, elliptic curves were 20 years ago are being standardized and blockchains like ten years ago are getting traction and zks like five years ago. I really do think that confidential EVM, so the contracts with secrets, we're still just seeing the early days of what's possible and it's really interesting to see where this is going. Like in the next ten or 20 years. I'm pretty sure it's going to surprise me.
00:18:59.820 - 00:19:55.846, Speaker A: But yeah, this is sort of the beginning of autonomous contracts that scale and some of the building blocks that let them be fully autonomous aren't quite there yet. So there's lots of oracles that let you prove to the contracts about state. And I think we're still in the problem discovery phase of if you have fully autonomous contracts that can have privacy, what's the rest of the infrastructure that we need? But at the same time what infrastructure can we get rid of because they can have privacy. And of course with all the web3 stuff there's loads of other infrastructure that comes with it. And like the bridges, the data APIs, it's a sort of delicate balance, but we're sort of trying to figure out some of these problems. And so we're running a grants program to push that along a bit. And that's all I have for today.
00:19:55.846 - 00:20:11.660, Speaker A: But if you want to check us out, please come to the booth. Let's figure out some use cases. Thank you. Our Co.
