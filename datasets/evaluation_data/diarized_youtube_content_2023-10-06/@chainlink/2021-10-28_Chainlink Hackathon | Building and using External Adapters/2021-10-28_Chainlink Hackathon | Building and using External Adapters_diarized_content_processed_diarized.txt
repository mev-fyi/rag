00:00:18.320 - 00:01:30.450, Speaker A: Hey, everyone, what's up? Welcome to another chain link hackathon workshop. Today we're going to be talking about building and using external adapters. So we are live right now. I'll just give everyone maybe another 30 seconds to join and we'll get started. Patrick, can you just add my share screen to the stream? Thanks. Awesome. Cool.
00:01:30.450 - 00:01:58.060, Speaker A: All right, let's get going. If you guys have any questions throughout the workshop, feel free to ask them in the chat. And as I get to certain points, I'll have a stop and have a look. Cool. Well, yeah, thanks again everyone for joining. My name is Harry Papacrissio and I'm a developer advocate for Chainlink Labs. And as I said earlier today, we're going to be talking all about building external adapters.
00:01:58.060 - 00:02:56.540, Speaker A: So the agenda for today is we're going to do just a quick recap on any API functionality in Chainlink, then we're going to introduce the concept of external adapters and then we're going to do some coding. We're going to do a live demo of building and using an external adapter and then we're going to just wrap things up by talking about what you can do with an external adapter other than using it in your project. And then we'll finalize by talking about where can you go to get some more help in regards to external adapters. Awesome. So before we can talk about external adapters, I just want to do a quick recap of Chainlink's any API functionality because it's actually an important part of using external adapters. Right. So Chainlink Anyapi functionality provides the ability for a chainlink oracle to reach out to an API to get external data or do some kind of external computation.
00:02:56.540 - 00:03:59.756, Speaker A: And the way in which it does this is via what's called a request and response model. So you have a smart contract there on the right in the diagram which reaches out to a chainlink oracle and says, hey, I want to reach out to this API. Here's some input data, please do the work for me. Chainlink Oracle takes that request, it reaches out to the API, it does what it needs to do, and then it sends a response back on chain via what's called an oracle or an operator contract that sits in between the node and then other smart contracts, and then that response eventually gets sent back to the node that made the request in the first place. Right? So it's what's called the request response model. So let's talk about adapters now. So chainic adapters allow chaining oracles to integrate with any external API and they're kind of split into a core HTTP task and external adapters.
00:03:59.756 - 00:05:56.280, Speaker A: So a core HTTP task is basically an inbuilt adapter that comes with the chain link oracle out of the box and it allows you to do any HTTP web service request, right? So you can do a get a post, a put, et cetera, as long as you just need to specify URL whether it's a get put post and you can specify body, you can use this task, right? So for a lot of scenarios where you want to reach out to an API, this is actually a suitable thing that you can use and you don't always need to use an external adapter, right? And we'll go through more of that in details in the coming slides. But for when you do need to use an external adapter, chainic provides the functionality which we're describing today. Right? So this is what we're going to go through next. So external adapters are basically, they're an API in themselves and they allow Chainlink oracles to connect to any API that exists that isn't reachable via a standard HTTP task, right? So in the way in which it does, this is an external adapter is an API in itself that has a specific input and output JSON structure. And as long as you adhere to that structure in terms of the requirements, the chaining node can then do a request to that adapter and then that adapter sends a response back to the chaining node and the chaining node can interpret that response and then continue processing the job that uses the adapter. And because it's basically just an API that takes a HTTP post request and then returns a body, you can actually write them in any language you want. You can write it in Go JavaScript, whatever, any language where you can create that kind of API.
00:05:56.280 - 00:07:23.804, Speaker A: And in terms of where they sit on the stack, they can run either on the same physical machine as the chaining node using it, or you can run on separate machines, or you can run them as serverless functions on the cloud, et cetera, the choices are kind of up to you. So if you go to our docs at docs chain link and go to the node operators section here, we've got a really good introduction to external adapters as well as some guides on basically building one and then adding it to a node, which is kind of what we're going to go through today. So yeah, in terms of the architecture, the adapter sits in between the Chainlink Oracle that's using it and then the external API that it's connecting to, right? So the smart contract makes a request, makes it to the node. The node then has a job that processes that request, and as part of that job it reaches out to an external adapter and says, hey, I need you to do this thing for me. The adapter does the API request and then sends the response back to the node, which then sends it back to the smart contract. So here are the basic specs that I was talking about in terms of you need to have a specific structure in the adapter's input and output. So when you're making a request to an adapter, you need to have a data tag.
00:07:23.804 - 00:08:18.420, Speaker A: It doesn't need to have anything in it, but it needs to be present. And that's really the main part. So a lot of scenarios people put in the ID as well, the job ID that's using the adapter because it could be useful for debugging and logging and things like that. And there are a couple of other optional things such as metadata tags and a response URL which is self explanatory, but those are optional, you don't need to put those, and there's more information on them in our docs as well in terms of what the external adapter will send back and what the chaining node that uses it needs to have in order to interpret the results. Once again, we need to have a data tag with some kind of results in there. And usually people put a job ID, job run ID as well for debugging and logging purposes. However, it's actually not mandatory.
00:08:18.420 - 00:09:34.716, Speaker A: So that's it really in terms of the structure of how the node should receive requests and then send responses back. So in terms of why would you want to use an external adapter? There's usually a few reasons. So one example is when you're doing some kind of intensive or computation that you can't generally do on chain, right? So maybe you're iterating through a big chunk of data, for example historical price data, or maybe you're reading some really big file or something. You can't do that stuff on chain. Or if you can do it, it's generally very expensive and hard to do in a decentralized manner across hundreds of thousands of nodes. And another reason is if the core HTTP task isn't suitable, right? So for example, if you're reading data from a database as part of your job and you need some kind of JDBC library, obviously you can't do that with a HTTP get or post. So that's another candidate for using external adapter or when you need to have custom functionality as part of your API call when you need to do special things every time you basically want to do this API call.
00:09:34.716 - 00:10:12.936, Speaker A: That's another reason to use an external adapter because you can put that custom logic inside code off chain. Or for example, you might want to use an external adapter for privacy reasons. So for example, you might have an API key that unlocks a vehicle or something, and you don't want to have that in a request on chain going off to a chaining node. So you might want to store sensitive things like that on the chaining oracle side in environment files or environment variables, et cetera. That's another reason why you may want to use an external adapter. Cool. So let's go through a demo now.
00:10:12.936 - 00:10:54.932, Speaker A: So in terms of what we're going to be achieving in this demo, we're basically going to do four things. We're going to define what is the data that we want to get as part of our smart contract API call. What is the data, what do we need to pass to the API to get the data, what do we need to parse from the data that we get back from the API. Right. So we need to just define those things. Then we're going to actually create an external adapter and we're going to create it based off of a template. And then we're going to create a job on a chainlink node that uses the external adapter and then we're going to create a consuming smart contract that then uses the job and the adapter.
00:10:54.932 - 00:11:48.650, Speaker A: Right. So we're going to do an end to end external adapter demo here. Awesome. So I'm just going to switch now. Whoops. So let's start off by defining what is the data that we want to get as part of our demo here. So for those who are also big football soccer fans, there's a really cool sports data website called Sportsdata IO where you can get some really cool sports statistics, right? And these guys actually run a chainlink node themselves.
00:11:48.650 - 00:12:32.164, Speaker A: However, I think in terms of the data they return as part of that they only return betting information. But in our demo here we want to do some player statistics. So we're going to create our own external adapter here. So I've signed up to this site with a free account and I get given an API key. So what we're going to be doing is let's have a look at player season stats here. So here's my API key here. Round ID is just the round of the league so we're going to just set it to one.
00:12:32.164 - 00:13:21.344, Speaker A: So without looking at a specific player yet, we get an endpoint here that just returns player season statistics and as you can see it returns a whole bunch of stuff. But let's say in our smart contract we have some kind of fantasy game smart contract or something and we're storing just player IDs on chain or something. So here, I've just taken an example here. So here's another API point. Player season stats by player individually, right? So using this API call that didn't work. There we go. If we look at this one, as you can see, we get individual stats for a specific player.
00:13:21.344 - 00:13:58.112, Speaker A: So we have Raynerini here, Manchester United games, 27 goals, own goals, fouls, et cetera. So let's say we want to take one piece of this data and return it on chain as part of our smart contract. So let's just maybe stick with games. Easy number gets iterated each time the player plays a game. So we've agreed that this is the data that we want to get on chain using our external adapter. So we know what the API is. We have the URL here, it uses our key.
00:13:58.112 - 00:14:55.156, Speaker A: Maybe we don't want to put this key in our smart contract. So we're going to create an external adapter that obtains data from this API based on a player id, right. And whatever the player Id is, we want to send it to the external adapter. Cool. So now that we've kind of defined what we want to do in terms of our adapter, let's start building the adapter. I'll just see what questions are in the chat. For now it how does chain link can do updates by external sources? For example a t one, I get the stats, someone rewrites them and the next pool shows completely different win loss at t two, what happens? So the smart contract will only know the data that it requests to get basically.
00:14:55.156 - 00:15:43.670, Speaker A: So zoom in a little bit. Thanks for that. So if you're requesting data every day and there's updates multiple times per day, then yeah, you're not going to get those updates unless you do more frequent updates in your smart contract. So I guess it's kind of a bit of a thing you need to take into account and make sure that your frequency of updating your contracts is aligned with how often the data is updated. So for example, for sports data, soccer games are generally played a few times a week towards the weekend. So you might want to update your smart contract for something like this, maybe on a Monday morning for example, every week. Okay.
00:15:43.670 - 00:16:30.828, Speaker A: And yeah, the dual arc. Once I'm done with this, I'll publish the code for everything I do. I'll publish the code on GitHub and I'll update the YouTube description with a link to everything. So I'm just going to switch to my vs code now. So in terms of creating the external adapter, we're going to use a template that exists that I like to use. So this is GH Thomas's GitHub here from Chainlink Labs and he's created a chainlink external adapter node js template, right. So this is a template that you can use for creating an external adapter.
00:16:30.828 - 00:17:12.560, Speaker A: It makes it really easy. It's got some inbuilt validation and stuff in it. You need to have node js installed, right? So if you don't have node Js you can head to nodejs.org and install that and then you'll have everything needed to kind of get this adapter going. So what we're going to do is I will open my vs code, hopefully that's big enough for you guys. So we're going to say git clone sports adapter. So we're going to just grab a copy of that repo.
00:17:12.560 - 00:18:08.044, Speaker A: Cool. So what we've basically done here is we've pulled the repository using git and we're going to start playing around with it now. So there's actually not too much to it. The first thing I'm going to do, hopefully that's big enough for you guys. The first thing I'm going to do is install all the dependencies using yarn or you can run an NPM install and once that's done we can start going through everything. So in terms of what's in here, it's really just a couple of files. So package json readme and then the app Js here is what takes requests.
00:18:08.044 - 00:19:05.408, Speaker A: So it uses the exprs here library and we listen on a certain port for requests. And then any post to wherever this adapter is deployed at that port it's just going to call the create request function, right? And it just listens on that port and just every time it gets a request it calls create request and create request is in index JS here. So here it is. It's just a body of doing stuff for processing a request and then sending a response back, right? And if you deploy your adapter to Google Cloud or AWS, there's some wrapper functions here. We don't need to worry about those for now. So in terms of what's happening here, let's take a quick look before we start changing things. First thing you'll see is that we're using, there's a chain link library, chain link external adapter.
00:19:05.408 - 00:20:01.684, Speaker A: You can actually take a look at this once you've installed the dependencies and you can see some of the other things that it uses here. So for example, validator and requester, they're all there for you to kind of see. So this first part here, it just defines any custom error scenarios that you may want to use and you can kind of define them here for when you want to use them. We don't need to worry about that for now. Over here is where we define any parameters that we're sending that we expect to be sent to the adapter. So in the base template example you can send a base from or coin and then there's another input parameter that you can call quote to your market, right? And then here's where kind of the main body of the adapter is here where the create request thing is called by app Js. So it receives input, right.
00:20:01.684 - 00:20:41.440, Speaker A: And then in that input it basically passes out a job run ID and an endpoint. And it actually uses this validator functionality here to do a bit of validation on some of the inputs. So for example, to make sure that the ID is a number and sorry, to make sure that certain things that are meant to be a number are a number, et cetera. Right. Yeah. So these field names are not specifically what the endpoint wants in the request, but they're what the adapter expects to receive from a chain Inc node. Right, these ones here and yeah, it does end up putting them in the endpoint.
00:20:41.440 - 00:21:37.696, Speaker A: However, that won't necessarily always be the case. Right. And then what it's doing after that is once it's done a bit of validation, it's building up a URL with basically an endpoint. In this case it's just getting some crypto price data. And once it does that, it basically builds up a parameters object with basically everything that's going to get sent to the adapter. And it basically then builds up a config object that contains the parameters and the nURL and then it just sends that config object to this requester class that's in the chain link library and that basically just does a HTTP request to the URL. And then whatever response it gets, it basically does a callback to the chain link oracle or to whatever called the adapter.
00:21:37.696 - 00:22:07.500, Speaker A: With the status as well as the response. Right. And obviously if there's any issues, it returns a 500 error. There is some validation that occurs on the data. In this example, because it is crypto price data, we expect it to be a number so it does some validations there. So one thing to note is you don't need to do all of this stuff here that uses the validator and et cetera. You don't need to do any of that at all if you don't want to.
00:22:07.500 - 00:22:49.020, Speaker A: You can have your own custom logic that uses nothing except for what's in your main file. You don't need to use any extra libraries if you don't want to. As long as you can accept a request from a chaining node in the correct format and then send a response in the correct format, you can do whatever you want in your external adapter. Right. So in terms of our adapter here, the first thing we're going to need to do is we need to store our API key somewhere. So I'm a big fan of using the M library. So I'm going to go Npm install emv.
00:22:49.020 - 00:23:54.160, Speaker A: This is a library that allows you to create a env file and store sensitive parameters in it. If you want more info on that, just go to GitHub and search for env one word. So the next thing we need to do is we need to use that library. We're going to say required m config because we want to use that. And once that's done we can actually create our emv file. So we're going to store our API key in our Emv file. So I'm going to say emb API key equals now where is our API key? It should be here in our URL.
00:23:54.160 - 00:24:49.890, Speaker A: Cool. So we're going to use that API key in a minute. We don't want any custom errors for our API call to the sports data API. But in terms of custom parameters as we defined here, we need to specify a player id, right? Whoops, not that one. That one, yeah. So we need to specify a player ID when doing a request because we need to put it into the URL. So if we go back to our custom params here, we're going to get rid of that second one and we're going to create one that's called player id and we expect a parameter that's literally called player id.
00:24:49.890 - 00:25:43.396, Speaker A: Cool. So now in the create request function we don't need to worry about an endpoint. So we need to grab our API key now. So we're going to say const API key equals and this is how you use the emv library is you say process env API key and it will look in a env file and it will try grab this value here. So we're going to store it here. Also going to store the player id. So the cool thing about using this template is that this validator library here that you can see the source for if you want.
00:25:43.396 - 00:26:19.250, Speaker A: Like I said, it does a bunch of cool things and it allows us to then strip out the player id from basically this object here. So you go validator validated because it validates everything data and then player id. So we've got the API key stored, we've got the player id stored. Now we just need to set our URL. So as I said before, our URL is, whoops. Our URL is defined here that we looked at earlier. So I'm going to actually paste that in.
00:26:19.250 - 00:27:10.496, Speaker A: I'm going to remove the API key because we don't want to hard code it. And I'm going to inject the API key here based on the API key variable. And the only other thing we need to do is inject the player Id. So we don't want to hard code that either. So we're going to say player ID. So all we're doing here is we're building up a URL that we want to basically hit that says I want to access this API and I want you to inject the specific player ID that comes from the request to the external adapter using the API key that we store in the EMV file. Right.
00:27:10.496 - 00:28:05.264, Speaker A: Once that's done, we don't need to worry about this stuff. In terms of the parameters that we're sending to the request, we're only sending the player ID. The API key comes from the env file and that's it. Yeah, we'll send the request off using the URL and the parameters. And yeah, once we receive a result, we don't need to worry about validating that thing because it doesn't exist anymore. If you want to add your own validation, you can, you can put in whatever you want, you can use other libraries, et cetera, just for the purposes of this demo and time. I won't bother though, and I think that is it.
00:28:05.264 - 00:28:44.220, Speaker A: Let's take a look now so we can start the adapter by going yarn start. So the adapter is running. Hopefully you guys can see that. Hey tippy, what's up? I'll get to answering a couple of questions in a little bit. I just want to get to a certain point before we run a bit late. So I've started up a new terminal here. So we're going to do a test to our external adapter now.
00:28:44.220 - 00:29:57.110, Speaker A: So we're going to build up a curl command. So we'll do curl X, we're going to do a post. So the adapter takes a HTTP post request and the header we want to specify as content type patientJason and the URL that we want to do the post to is 80 80. So I'm running it locally here and in terms of the request body that we want to send, we want to build up a JSON object here. So first we want to specify the ID of the job run that we're doing. So I'm just going to say one and then we want to build up a data object because remember that's mandatory. And in the data object we're going to say player ID.
00:29:57.110 - 00:31:08.670, Speaker A: And as a test we'll just take the player ID that we used beforehand and we'll throw it in there and I think that should be it. So as you see, we got a response here, the same response that we saw here in my browser. And if I go back to the adapter that was running, you could see it generated some output here. So here's what the request to the API provider provided and here's the result. So we're actually sending back everything, right? However, in our consuming smart contract we're just going to use one value like I said. So that's it. We've actually defined our data and we've basically created an API, an external adapter that uses that external data and now we're actually ready to use the external adapter as part of a chain job.
00:31:08.670 - 00:31:46.852, Speaker A: So how do we do this? I'm just going to switch now to my node here. So the requirement for this workshop basically is you need to have a chain ink node running. I'm running version 1.0. Highly recommend if you haven't got one running. Check out a great video that Zach, our fellow developer advocate ran earlier today. He's got a really good workshop on running a chainic node. Once you follow that and get to this point, you can then create a job that uses the external adapter.
00:31:46.852 - 00:32:16.752, Speaker A: Right? So I've got a node running, it's version 1.0. I've funded it with some ETH. I've deployed an Oracle contract as per Zack's workshop and I'm ready to now create a job. So with version 1.0 of the node. The jobs are created using the toml format, so we no longer use the json format. And I know it's a little bit, for those who were used to JSON, like me, they might find that a little bit intimidating at first.
00:32:16.752 - 00:33:11.270, Speaker A: But I promise you, once you kind of get stuck into it a little bit, it's not as bad as you think. So the first thing we need to do is we need to add our external adapter as a bridge. I'm logged out. So the bridges section is where you define your external adapters, right? So you go new bridge, you can call it whatever you want, however you need to. Just make sure you remember what you called it, the URL the external adapter is running on, and then you can specify a minimum contract payment in link and how many confirmations you want before you consider the transaction to be valid. I've already created a couple here, so I'm not going to create another one. As you can see, soccer data localhost 80 80, pretty simple stuff.
00:33:11.270 - 00:34:26.184, Speaker A: Now the next thing we need to do is create a job. So in Zach's chainlink node workshop he did a really good example of a simple direct request job. So if you go to our node operators section in the docs at docs chain link and go to fulfilling requests, it's got a good guide on creating a simple direct request job that it takes a request from an oracle contract and it basically processes a request doing a normal HTTP get here and then sends a response. So creating a job that uses an external adapter is very similar to this kind of basic example of doing a normal HTTP get. So we're actually going to take this toml job spec example and we're going to modify it for our use. So I'm going to literally copy everything and I'm going to go to jobs, new job in there. But first I'm going to just go through everything because I think it's a bit easier to read here.
00:34:26.184 - 00:35:01.524, Speaker A: Can you guys see that? Okay, hopefully you can. So let's take a look at what this tumble stuff does. So the job type is a direct request job, like I said, see some more details about a direct request job here executes a job upon receipt of an explicit request made by a user. Pretty simple schema version. Leave it as one name. You can call the job whatever you want. It doesn't matter if you don't explicitly specify an external job ID, it'll just generate one on its own for you.
00:35:01.524 - 00:35:42.420, Speaker A: That's generally the approach that I take, but then you can call it whatever you want. So the contract address is your oracle contract address that you deployed as part of setting up your chainik node. Like I said, check out Zack's workshop on running a chain node. If you want more details on this, however, you do need to note down your oracle contract address that you deployed as part of these steps because you need it in two spots in this direct request scenario here. So we specify the address that we want to listen to for requests. Maximum task duration can leave it as zero, which is unlimited observation source. You don't touch that.
00:35:42.420 - 00:36:38.628, Speaker A: So here's where we define our job pipeline, right? So a job pipeline is basically a series of tasks that the job will perform in order until it reaches the end, right? So we specify all of the tasks in a row here and we call them names. And then at the end we just specify the overall pipelines. We say decode log goes into decode, cbor goes into fetch goes into pass, and so, so until you get to the end. So in terms of these names on the left, you can actually call them whatever you want. You can call it XYZ if you want. It's the type that actually matters here, right? So in this direct request scenario here, first we're doing an ETH ABI decode log. So that will basically look at your oracle contract address or whatever address you specify and literally listen for a log emitted by an ETH account.
00:36:38.628 - 00:37:50.430, Speaker A: Right? So that's what we're doing here. We're looking at an oracle contract and say hey, we're looking for this oracle request log that gets emitted and specifically we're going to be looking at what's in the data section of it here, right? So we specify data and topics as job run log data and jobrun log topics. These are specific to direct request jobs. They're like kind of special variables here. Jobrun log topic, job run log data, right? You generally don't need to change those for these types of requests anyway, so we're not going to worry about those. So that's the decode log part of the job. So the next thing we need to do is actually decode the data that we get from that log, right? So we've got a CBOR pass job here and all we're doing is we're saying we want to decode the data that comes from the data section which is defined by this, the data thing from this decode log output, right? And that's essentially what CBOR pass does.
00:37:50.430 - 00:38:54.924, Speaker A: More info is here in the cbor task section here passes a cbor payload typically as part of a direct request workflow. So we want to get that data that comes from that data parameter in the event the next thing we're going to do is a HTTP request. Here, this is just in this direct request example the HTTP task I showed you guys before you just say, do you want to do a get post put? And then you do a URL? So in this case they're getting the URL from the output of this task from an element called get. So they're specifically looking for that in the data that the oracle request event emitted. The next thing that they're doing here is they're doing a json pass. This basically just passes the data from whatever specified in data. So we're saying whatever the output of fetch was, we want to parse whatever was specified in the path from the decode CBIR.
00:38:54.924 - 00:39:35.464, Speaker A: So once again, from this oracle event that was emitted, they're expecting someone to have specifically specified path equals something or other in there. And we're stripping that out and using that. And then what are we doing? There's a multiply task. It literally, just as you'd probably guess, it multiplies the result of whatever the input is by something. So in our case we're taking whatever was output by the pars task, we're multiplying it by 100. And then basically the next step is we're doing an ETH ABI encode. So what this does is it encodes bytes payload according to the ETH AVI encoding.
00:39:35.464 - 00:40:15.964, Speaker A: So we're preparing the data to do an ETH transaction basically. So the data that we're encoding is going to be just a UN 256 and the data that we want to encode is value and then whatever the output of multiply was. So we're encoding that in prep to do an ETH transaction. Then on the next line we're doing another ETH API encode. But this time we're preparing the contract call that we're going to call. So in this case it's the fulfill oracle request call on the oracle contract that we receive the request from. And we're just building up a function call.
00:40:15.964 - 00:41:01.000, Speaker A: So it takes a whole bunch of stuff here, as you can see. However, luckily we can actually just grab most of it from the code log task here further up because it was all kind of specified there. So we can just get it all from there. The only thing that's different is the data. And for the data we're actually grabbing it from the encode data task, which we previously done just up here. Right. So that's just encoding a transaction, getting it ready to submit to the blockchain again, and then finally we have an ETS task to basically send that transaction.
00:41:01.000 - 00:41:34.048, Speaker A: So all we're specifying here is the address. So we're sending it back to the oracle contract address that gave us the request and the data is the ETH encode TX output here and then that's it. So we've specified the pipeline here and it's all ready to go. So let's take that now here, let's see if it's logged me out. Cool. It hasn't. So I've pasted it in here.
00:41:34.048 - 00:42:20.524, Speaker A: So now we're going to change it for external adapter. So hopefully you guys can see that the first thing we're going to do is we're going to change the name sucker data ea. We'll remove these comments, we don't care about those. So the next thing you need to do is put in your oracle contract address. So I know that my node was deployed and I set up my oracle contract address with that address. So I'm going to actually put it in both parts of the job that specify the oracle contract address. Once again in the docs, if you follow along with this fulfilling requests page, it gives you all the instructions on how to get that oracle contract address going.
00:42:20.524 - 00:43:04.450, Speaker A: Or even better, check out Zach's workshop that ran earlier today. Cool. So what else do we need to do? The next thing we need to do is we don't need to multiply. We're getting soccer stats data, we don't need to multiply anything. So I'm going to remove that from there and from the pipeline at the end. Now the only other things we need to do is we need to change the fetch. So we're no longer using the HTTP task, we're using the bridge task that is here.
00:43:04.450 - 00:44:07.940, Speaker A: So this is the task that uses external adapters, right? So you specify the type as bridge. The name needs to be the same name as the bridge that you created on your node and then you just can build up a json request data object like that. So I'm going to say type equals bridge name equals hackathon and URL request data is the other element that the bridge type needs. And we need to build up a json stream here. So we're going to say now you kind of need to double backslash any double quotes in here. So we need to go double backslash quote. So we're going to say id is job spec external.
00:44:07.940 - 00:44:50.352, Speaker A: External job id. What this does is it gets the external job Id from, if I go to direct request filling requests. Sorry, no, not that section. Direct request. Yeah, job specternal job ID. It's a special parameter that you can use to get the globally unique job ID for this job. Right.
00:44:50.352 - 00:45:54.872, Speaker A: So we're taking it from that special parameter there. Can you have a json path task without the path parameter so that I can work with the entire JSON? I think can. However, you can probably just not even have a json path parse task at all if you don't need to do any parsing. And I think it would just pipe the results through to whatever the next task is. So I'd probably try that one first before doing one with just no data. All right, so where were we? So we specified the external job ID as the ID, and the next thing we need to do is specify the data. So we're going to say data, and in our data tag we're going to have Jason object and we're going to say player ID because we need to pass through the player ID.
00:45:54.872 - 00:46:44.864, Speaker A: Remember, we want to get the player ID from our request that came in from this oracle request here. So we're going to say CBO, no code, CBO player ID. Right. So that's going to take the, it's going to look for a thing called player ID that came in this data thing here, in the bytes here, because we decoded it here. Right. And we're expecting there to be something called player ID in there. So we've got a type called bridge name.
00:46:44.864 - 00:47:18.636, Speaker A: Hackathon is the bridge name, and then request data equals that. And I think that should be good to go. So once we get that result back from the external adapter, we want to parse a specific field. So in our case it was games. Games. As you can see, the data returned is actually an array here. So we need to be aware of that and make sure we set things up properly.
00:47:18.636 - 00:48:07.244, Speaker A: So in our results, we're going to return from the data tag, data object, sorry, data zero, because it's an array gains, so it's not dots with this version of the node, it's commas. So if you have an array in a data object here, we're going to say data and then zero first element in the array and games. Right. So we're hard coding it here. However, you can also specify it in your request if you want. Kind of like how they did in the demo here. But for now we're just going to hard code it I think the only other thing we need to do now is because we remove the multiply task.
00:48:07.244 - 00:49:07.348, Speaker A: We need to change the value in the encode data task here to basically get data from the pars task here instead of multiply. All right, I think that should be it. So once we're kind of happy with things, I think I'm just missing a bracket there. Once we're happy with basically the job, you can basically just hit create like that and boom, successfully created job. So you can see the definition here, errors, runs, et cetera. So in the definition here's our external job ID that we're going to use. So now the next step is to create a consuming contract for this.
00:49:07.348 - 00:50:09.400, Speaker A: So I'm going to go back to the chain link docs here. Docs chain link and we're going to go to the using any API section and make a get request. And here's the standard API consumer contract for doing an API call. We're going to just open that up and change a few things. I'll just zoom that in a bit so you guys can see. Hopefully that's okay. So the first thing I'm going to do straight off the bat is I'm going to take my external job ID and I'm going to put it here in the job id section.
00:50:09.400 - 00:51:19.890, Speaker A: So we also need to strip out any dashes. The next thing I'm going to do is take the Oracle contract address which is this one here and I'm going to put it here. So when you use the standard API consumer contract you need to specify an oracle contract and a job id when you want to do a job request. So how do we use this job now that uses the adapter? We don't need to specify a get parameter. So the standard API consumer contract consists of two functions, one to do the request and one to receive the response. Here, let's just change volume to games request, games data fill and games want to receive the games parameter back. There we go.
00:51:19.890 - 00:52:01.870, Speaker A: So we would have built up a request. We don't need to specify path, but we do need to specify the player iD. So like I said, let's say this is a fantasy sports smart contract or something which stores the player iD on chain. So in our case we're just going to hard code it though just to make things easier. Then we don't need to specify what we're multiplying things by or anything because we don't have a multiplication task in there. And that's it really. So we have a standard API consumer contract that looks at our Oracle contract, our job ID, the fee point one link.
00:52:01.870 - 00:52:47.240, Speaker A: We're adding a player ID parameter to the request and then we generate a request using this function. And then if we hopefully receive a response from the chain link Oracle, it stores a response here in the games variable. So I'm just going to compile that one and I'm going to deploy it on the coven network. So I'm going to deploy the API consumer contract. We'll give that a few seconds. Cool. So that's done now.
00:52:47.240 - 00:53:40.030, Speaker A: So because we specify a payment in Link, we need to fund our contract. So I'm going to send, I think it was just 0.1 actually, but I always just send one. We need to fund our contract with some link and once that's done we should be able to call the request games function here to do that API call. So there we go. So hopefully our external adapter should get that request. And I'm just kind of peeking at the output of the adapter here.
00:53:40.030 - 00:54:32.252, Speaker A: Boom, there we go. The external adapter got the request and generated the result. So if you go back to your chain link node here, as you can see, there's a bit of a bug with the current version of the node where sometimes the front end will just kind of balk like that and not show anything. Just note though that the node is still running, it's still processing the job, and we actually do have an open issue for this one. So I'll just show you guys the issue node gui blank screen while tomorrow job is executing. So the job is actually still executing. However, for the duration while it's being executed, sometimes you can't get access to the front end.
00:54:32.252 - 00:55:23.996, Speaker A: So we're currently looking at that. Don't be too worried about it, just check what's happening in the back end on your node and you can kind of see that everything still ticks along. So just a heads up to kind of not get scared if that happens to you. Generally if you wait 30 seconds until the job is completed executing, you can then generally refresh your screen and it shows up again. So here we can see there was a successful job run here and we can kind of see all the output of each task here. Here's the bridge task, all the data that was returned JSON pars task we passed 27 from the results and then we encode a transaction sender on chain. So if we go back to our consuming smart contract here and check the games parameter.
00:55:23.996 - 00:56:09.352, Speaker A: Boom. 27 it's a bit small. So there you have it. What we did was we defined an API that we wanted to create an external adapter for. We defined what type of data the API needed to receive and then what data we wanted to extract from the API. We created an external adapter for that API using a simple node JS template and we deployed it locally. And then using a chainy node we spun up a new job that uses the external adapter and once we had that done, we created a simple consuming smart contract based off of the standard API consumer contract.
00:56:09.352 - 00:57:27.012, Speaker A: We just modified a couple of things like which job Id, which Oracle contract, the input parameters and then we basically just sent a request to our job and very similar to the direct request job example, it received that request, it reached out to the external adapter and said hey, using this player ID, access this, get me this data. The external adapter accessed the sports data API and then it sent the response back and then the chain passed the games element for us and then sent it back to our consuming smart contract. So there's just a really cool simple example of using an external adapter with the Chainlink 1.0 nodes. I'm just going to finish up here and then I'll see if there's any outstanding questions. So once you've created your external adapter and used it as part of your submission, you can actually list it for other people to use as well on the chain link marketplace. So if you go to market link you can kind of see here there is an adapters section and there's all kinds of adapters that people have already listed from weather adapters to property data, external adapters, sports data adapters, a whole bunch of stuff.
00:57:27.012 - 00:58:07.092, Speaker A: So if you think your adapter would be useful for others, you can actually list it here. Or if you want you can even just look in here to see if there are any adapters that already exist that you can then use as part of your project. Right? So just wanted to point that out here. So just to close things off. If you need some help with creating your external adapters or running your training nodes especially, definitely reach out to us. The best place is in our discord. We actually have some node operator channels, so we've got a node operator channel for just help with general node stuff.
00:58:07.092 - 00:59:12.410, Speaker A: In general we have an operator request channel. If you create an external adapter but you can't or don't want to run a node and host a node adapter, you can actually ask existing node operators to host it for you and generally you'll get someone responding that's happy to help you out if you say hey, I've created this adapter, I've tested it, can someone please host it on coven for me or polygon or wherever and create this job Id for me. Create this job for me based on this job spec so that I can use it as part of my project. Generally someone is usually willing to help you out there. And we also have an external adapters channel in the discord as well for getting help and asking questions and collaborating with anything external adapters. So let's just see if there's any questions now that is it in terms of the presentation. Patrick, if you want to post the link to the feedback form, if you have any feedback, feel free to scan the thing here or fill out the form.
00:59:12.410 - 01:00:28.752, Speaker A: Let's see if there's any questions that I missed here. If you have any questions, feel free to ask. Now what is the difference of using the NEAPI directly to request the sports API with using the job from the node? Let me see if I understand that. What is the difference of using the NEAPI directly to request the sports API with using the job? Okay, with the way that the sports data API is set up, you can just use any API request directly with a job that uses a normal HTP task. For example, you can go to chaining market here and go to jobs and you can search on Ethereum Coven and get UN 256. You can use this job ID and operator contract to do that. However, you need to specify the API as part of your request to use the sports data API here.
01:00:28.752 - 01:01:25.228, Speaker A: As I showed here, it's in the header. I said, you know, maybe in some cases it's know, some premium API membership that you don't want to just have the API key on chain. So that's a good candidate for storing it off chain somewhere. And using external adapter is a good way to kind of do that. Let's see if there's any other questions. I answered the one about external sources. Um, all auth methods supported in a request response model, including basic JWT two.
01:01:25.228 - 01:02:37.584, Speaker A: So if you're using a standard HTTP task which is here, it doesn't really support some of that authentication that you specified, right? I don't even know if you can inject headers into this. Yeah, I'm not sure if you can. So if you want to use stuff like OAuth and things like that, that's kind of like a good candidate for using an external adapter. Cool. I'm not seeing one more question. Is there a way to simulate job runs locally? I'm trying to write a job, so I'm wondering if there's a more streamlined way to test the job out without going through the test blockchain all the can. In my example, I was running the chain ink node locally, I was running the external adapter locally.
01:02:37.584 - 01:03:58.670, Speaker A: However, like you said, I was using the Coven network. People in the past have used a local chain such as Ganache as part of their development, and they have had some success in getting a job to successfully run and execute with everything done locally. However, I don't think it's 100% bulletproof yet, so you may get some intermittent results. So just be aware of that. But definitely recommend trying if that is something you want to do because working on a local chain is a lot faster, you can develop a lot quicker. However, just be aware that it's not something that we've officially supported yet. However, it's something that we are looking into any migration documentation for adapters to keep up with new API version any migration documentation for adapters? Do you mean external adapters or just the core chain link adapters? I guess if it's just APIs that you're using as part of an external adapter, I guess it's up to you.
01:03:58.670 - 01:05:03.710, Speaker A: External adapters. It's up to you as the person who created the external adapter to make sure that your external adapter stays up to date. So if they deprecate or get rid of an API endpoint that your adapter uses, then obviously your external adapter is not going to work as expected once that occurs. So I guess if you publish it on market link, et cetera, and people use it, it's something that you should just be aware of, or whoever uses it should be aware of it too. Really? Because everyone kind of submits code as open source software. So yeah, you need to be aware of changes and things like that for sure. How much it's going to cost? How much is what going to cost? Okay, cool.
01:05:03.710 - 01:05:26.484, Speaker A: No other questions. I think we'll leave it here. So once again, guys, thanks for listening. Reach out to us in the discord if you have any questions or if you need help with anything. And yeah, feel free to give some feedback on the form that Patrick posted as well. So best of luck with your building external adapters can't wait to see what everyone builds. I'm a huge fan of external adapters.
01:05:26.484 - 01:06:06.176, Speaker A: I've used them in pretty much every hackathon submission that I've done in the past. I feel that they allow you to create some really cool and creative projects because they literally provide the ability to reach out to anything, right? Whether it's a car, a fridge, you name it. If it has an API, you can connect a smart contract to it using a chaining node and external adapters. So just quickly, this last question that came in the external adapter call how much it's going to cost. In my case, I think I specified 0.1 link. However, you can specify the minimum payment when you create the bridge.
01:06:06.176 - 01:06:17.968, Speaker A: There's a field there that called minimum payment, so you can specify it there. Cool. Well, thanks everyone. Best of luck with your hackathon projects. And yeah, can't wait to see what everyone builds. Thank you and bye.
