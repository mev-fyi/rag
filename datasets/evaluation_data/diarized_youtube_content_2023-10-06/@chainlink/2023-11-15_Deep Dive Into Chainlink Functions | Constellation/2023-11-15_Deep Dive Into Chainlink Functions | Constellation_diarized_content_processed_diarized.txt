00:00:50.430 - 00:00:50.980, Speaker A: You.
00:00:59.510 - 00:01:11.138, Speaker B: Hello, everybody, and welcome to Constellation, the chain link hackathon for 2023 the fall. 2023 in the US.
00:01:11.224 - 00:01:14.418, Speaker A: Now, everybody out there, because I'm in.
00:01:14.424 - 00:01:30.110, Speaker B: Australia and it's morning here, I know it's different times at different parts of the world, so please just drop in the chat where in the world you're from, what time it is there, and whether you're eating or drinking something fun right now. And then we get started and we got a couple of good. Hey, guys. Gm. Gm, indeed.
00:01:31.410 - 00:01:32.414, Speaker A: Where's everyone from?
00:01:32.452 - 00:01:39.300, Speaker B: Come on, drop it in the chat. Hey, Christopher from NYC.
00:01:41.500 - 00:01:41.960, Speaker A: Oh.
00:01:42.030 - 00:01:44.650, Speaker B: 06:00 p.m. At a cafe. Nice. I like it.
00:01:46.060 - 00:01:48.090, Speaker A: Hey, Leo, how's it going, man?
00:01:52.690 - 00:02:02.338, Speaker B: Let me get rid of that banner that says we starting soon because we've already started. So instead I'll show that one and.
00:02:02.424 - 00:02:05.762, Speaker A: We can give people a couple more minutes.
00:02:05.816 - 00:02:19.720, Speaker B: Oh, here we go. We have Madrid. Yeah, it's midnight in Spain. Seb, I hear you, man. We got David, or David maybe from Hungary. We got Joel from Madrid. You too, Leo, was great to catch you there, man.
00:02:19.720 - 00:02:28.426, Speaker B: What's us? Oh, virgin islands, of course. USVI, 07:00 p.m.
00:02:28.448 - 00:02:28.794, Speaker A: Right now.
00:02:28.832 - 00:02:33.442, Speaker B: That's great, Dominique. That's nice. Eating some salmon and pasta.
00:02:33.606 - 00:02:34.560, Speaker A: Very nice.
00:02:34.930 - 00:03:05.608, Speaker B: Hey, I'm here from Turkey. Welcome aboard, man. Harry, don't bust my alter ego here, man. You're the lead guitarist from link 182, right? I heard. All right, guys, we're going to give everybody about a minute, and then we can get started because you got a lot to cover today. I'm super excited to talk to you about this stuff. I'll be sharing some links.
00:03:05.608 - 00:03:34.344, Speaker B: I'll do my best to keep up with the comments in the chats. But listen, when I'm sort of coding and in it, I may not be able to. I'll do my best, though, and I'll keep trying to scan just in case my audio drops out or my video drops out. Please do leave the feedback in the comments and I'll try and see it. But if you want to, just open up that repo that I've put there, and we'll get started with that in a moment. So where's the repo? It looks like this. Can you guys see my screen? No, not yet.
00:03:34.344 - 00:04:04.992, Speaker B: There we go. So that's kind of what the repo look like now. And I'll keep pushing stuff up to it as we code along, but I'll walk you through all of that in a moment. Hey, Rio from Seattle. Yeah, there's a lot going on at Chainlink at the moment, my friend, there's always going to be stuff. Take a look at the hackathon schedule, and I'm sure you'll find pretty much everything you need to learn. And what I encourage everybody to think about is don't just watch stuff once or do stuff once.
00:04:04.992 - 00:04:36.256, Speaker B: If you really want to grock it, you want to do it a couple of times, go through it a few times, and I promise you, every time you do it, a new mental model will click. And that's the kind of learning you really want to do. All right, guys, so we three minutes past the average. So what I may do is I may kick off and then we can take it one step at a time. So let's start by perhaps introducing myself. Well, maybe just welcome you guys on again. So welcome to Constellation the fall hackathon from Chainlink for 2023.
00:04:36.256 - 00:04:56.150, Speaker B: And you're in the functions deep dive workshop. I'm super excited about functions. I'm one of the engineers that was quite closely involved in developing some of the tools they'll be using today. And I love getting you guys involved with it, seeing what you think about it, giving me feedback, all of that. It's really important to us. Right? So thank you, Dap. Thank you very much.
00:04:56.150 - 00:05:08.390, Speaker B: That's exactly right for putting that link in there. And what I may also do, guys, is I'm going to put this other link down here for you. That's going to help you with.
00:05:09.080 - 00:05:10.712, Speaker A: Let me see, where is it?
00:05:10.766 - 00:05:28.684, Speaker B: Here you go. I'll put the read only version. It may be a bit much. See if that's okay. Otherwise I'll give you the right version as well. I'm just a bit worried this has all the links. I'm a bit worried that if I give you the right version, somebody will accidentally have a keystroke in there and break a link or something.
00:05:28.684 - 00:05:30.030, Speaker B: But I've just put.
00:05:31.700 - 00:05:33.570, Speaker A: Sorry, that's not right.
00:05:34.180 - 00:05:37.810, Speaker B: That link I just put in there was not quite right. Let me just fix that for you.
00:05:39.380 - 00:05:40.576, Speaker A: Here it is.
00:05:40.758 - 00:06:00.832, Speaker B: This little riser pad should have everything you need for the stuff today. And I'll keep putting other links up for you as well. You can see it's on the screen. But we start off with this, cloning the repo, and we'll get started with that. But first, let me tell you a little bit about myself and then function. So, my name is Zubin Pratap. Welcome, everybody.
00:06:00.832 - 00:06:24.320, Speaker B: Thank you for joining. I'm a developer advocate and Devrel engineer here at Chainlink Labs. One of the coolest jobs in the world. And I can say that because for a long, long time, I was a corporate lawyer for about 15 years, so I know what other work can feel like. And then I was a suite at Google for a couple of years and then I joined chain link to get involved in the blockchain space and start teaching a lot more. Those are my contact details. Feel free to reach out and I'll do my best to respond.
00:06:24.320 - 00:06:44.196, Speaker B: Today we're going to talk about chain link functions. Yeah, Dominique, paste pin is not a bad idea as well. It's kind of all the similar, same sort of thing. I should have thought of that. But see if you can access that link, and I'll keep pasting links as we go along anywhere. But thank you for the suggestion. So we're talking about chain link functions now.
00:06:44.196 - 00:07:36.504, Speaker B: What is chain link functions? We'll go into it a little bit more deep and there will be coding to be done as well. But really it's a way to call any API from your smart contract. And you can also pass any custom for now it's JavaScript, but any custom script you want to the chain link decentralized Oracle network. And you can fetch or post to web two APIs that way so you can interact with the rest of the Internet. And you can also run some compute workloads in your custom script and then return all of that through the chain link Don's consensus algorithm and the consensus protocol OCR two, as we call it, return it back to your smart contract. So it's also verifiable and trust minimized, right? So it's like, for those of you familiar with Google cloud functions, or AWS lambda, it's kind of like that. With the additional benefit of consensus trust minimization and all the blockchain technology we've come to love.
00:07:36.622 - 00:07:37.048, Speaker A: Right?
00:07:37.134 - 00:08:04.124, Speaker B: So that's kind of what it is. Now here's a screenshot that illustrates this. This is from a site called usechainlinkfunctions.com. Let me put that in here. Actually, I've got it somewhere here, so let me just copy and paste that for you. But if you go to usechainlinkfunctions.com, you'll see a bunch of scripts that people have used with chain link functions that would help a lot with understanding how it works.
00:08:04.124 - 00:08:44.444, Speaker B: But the basic idea is your script. It's basically, sorry, wrong one, your script, it's basically custom JavaScript. You can inject secrets, as you can see in lines five to seven, right? And that's encrypted secrets and you can inject it into your runtime. You can also access arguments, so you can make it very dynamic. It's like literally running a script that you supply API secrets for or you supply arguments for. You run the compute, you wait for the response and then you return the response back via the consensus protocol into your smart contract, right? So that's kind of what chain link functions does. So it connects your web three smart contract running on the blockchain to the decentralized oracle node network, which then runs in a decentralized way.
00:08:44.444 - 00:10:00.496, Speaker B: The custom JavaScript that you supply aggregates the responses, gets consensus on it, and sends it back to you in your smart contract, right? And it's all verifiable, it's all inspectable on the blockchain, and that's what makes it so trust minimized. So it's really very cool stuff. So why do we need it? Well, we believe at chain link that hybrid web three dapps are probably going to be the way we need to operate going forward. We need to have the blockchain, the traditional Internet is also going to be there and we need a way for the two to communicate with each other via traditional APIs on the Internet. Now traditionally a blockchain is a hermetically sealed system, right? So what that actually means is that everything, because of the way consensus works on a blockchain, take the ethereum network, all the nodes out of synchronize and achieve consensus before block can be mined, right? And so what ends up happening is that you can't actually connect to the traditional Internet that easily because then you lose the deterministic quality of the blockchain and so you cannot really connect with real world events and data. And that's where Chainlink, for example, brings the oracle concept comes in, right? It connects the web three blockchain world to the traditional Internet world. And a decentralized oracle network is what we are channeling too, which is there's no point having just a single oracle node because that becomes a single point of failure.
00:10:00.496 - 00:10:43.970, Speaker B: It becomes fairly concentrated. It may not be, it's easy to compromise or in theory, if that compromises or that goes down, you have a problem. So by having a decentralized network of oracle nodes, you now have all the benefits of the blockchain without it actually being on chain. And you can connect to the traditional world, right, to the traditional Internet computing world. So I encourage you to go to the Chainlink documentation and again, I'll pop this link down here for you. Here you go, it's docs chain link, Chainlink functions, and I will show you that on the screen as well.
00:10:44.900 - 00:10:48.564, Speaker A: There you go. That's what it looks like, right?
00:10:48.682 - 00:11:12.990, Speaker B: So I'm going to put that in the chat you guys can see. So now, why am I bringing this particular slide up? Well, it's really important because for many years Chainlink was doing some of this functionality through something called any API, which is kind of the old way of connecting your smart contract to any API on the Internet and getting data back. However, that required quite a lot of technical expertise and a lot of.
00:11:14.880 - 00:11:15.196, Speaker A: What.
00:11:15.218 - 00:12:04.170, Speaker B: Would we call it, technical expertise, time, labor, and a lot of sort of fiddling around. In configuration, you had to potentially do your own node or write a whole bunch of scripts that you didn't really understand at first and stuff. So we said, all right, let's just get rid of that. We'll upgrade that version of chain link functions, which is literally as simple as sending some JavaScript to your smart contract and having the system just send it off to the decentralized Oracle network, supply consensus on the response and bring it back. So for those of you who are looking during this hackathon to connect your smart contract with external data that's data that's not on the blockchain, APIs running, some compute. If you see any API, don't use it. Perhaps try chain link functions, because you'll find that you're able to do what used to take about two days to set up, you can now do in about an hour, and I'll show you how to do that today.
00:12:04.170 - 00:13:00.780, Speaker B: Right, so let's talk about some of the use cases, like some of the classic use cases we've already seen in the brief time the functions has been, which it's been on main net beta for about three months now. Dynamic data that's being put into generative AI NFDs or even just dynamic NFDs, right? You pull in real world data and make your NFDs dynamic or representative of real world data changes from any HTTP endpoint, right. You can also have powerful integration with web two apps. For example, we have examples of people using connecting with Instagram APIs for giveaways, social influencer giveaways, verifying Twitter handles through on chain raffles so that price collectors can be verified using their Twitter handle. I wrote with my colleagues a demo smart contract where an artist, a music artist, will get paid by their record label. And the payment contract is a smart contract based on the number of Spotify streams they have. It just automatically executes the payment with a stablecoin, right.
00:13:00.780 - 00:13:45.724, Speaker B: So really powerful. And that's using the Spotify API. So powerful integrations with web two, you can have a bunch of social dapps, like there are a bunch of use cases out there using the lens protocol or graph protocol to query on chain data and interact with other on chain protocols so you can compose dapps together. There are ways to connect with external data warehouses like a universal connector to pull in AWS data. Or during the Smartcon in Barcelona, we had people from Google as well showing you how to pull in bigquery data from bigquery databases into your smart contract for weather data or parametric insurance and stuff like that. And of course there are the iot use cases as well, right? Push and pull event based triggers for iot devices. So those are various things.
00:13:45.724 - 00:13:56.992, Speaker B: Now again, I put some links at the bottom, use chain link functions. There are a bunch of example scripts, and then you can see the blog there at the bottom to, you may not be able to see it because it's concealed by the banner. Let me hide the banner for a moment.
00:13:57.126 - 00:13:57.856, Speaker A: There we go.
00:13:57.878 - 00:13:58.976, Speaker B: And then I'm in the way as well.
00:13:58.998 - 00:14:01.824, Speaker A: So I'm going to just, let's do that.
00:14:01.862 - 00:14:37.724, Speaker B: So those are the two links, right, that you can look at at the bottom if you want to see the other use cases. Now let me put my face back in here so you guys can see my pretty face. All right, so how do we use chain link functions? Well, let's get into some of the key mental models that we need to have, right? And I'll break these down a little bit more. But really think of it this way. You write some custom JavaScript using node JS type JavaScript, okay. And then you put that JavaScript into your smart contract. It's often easier to do it via a request configuration kind of thing.
00:14:37.724 - 00:15:18.916, Speaker B: And I'll show you how to do all of this in a moment. But you basically put in a bunch of data into a request configuration and you send that packet of data if you like to your client or consumer smart contract. So you deploy a functions enabled smart contract. And again, we'll go through all this in detail. Now, that functions enabled smart contract is something that you own and you run. And into that contract you will send a request configuration and then you create a subscription that holds your link balance so that your consumer contract can use that link balance to have the functions executed by the decentralized oracle network. Your smart contract will simply interact with the subscription manager and all of that, send the code off to the DoM, to the decentralized Oracle network.
00:15:18.916 - 00:15:36.284, Speaker B: The Oracle network will run the compute on it and return the round trip. It'll get consensus on the return values of that compute and send it back into your smart contract. So the key steps, and this is where it's really important to understand the key steps in making these systems work.
00:15:36.322 - 00:15:36.668, Speaker A: Right.
00:15:36.754 - 00:16:09.560, Speaker B: First and foremost, you need to create a chain link function subscription. I'll show you how to do that. Then you need to add some link to it. So I would strongly recommend there's a link at the bottom of the slide over there where if you don't have link right now, I'd encourage you to connect to. For today's demo, I'll be using the Mumbai network Polygon Mumbai because it's a little bit faster so you can see the results faster and so you can use connect your wallet to that and go get some polygon Mumbai link from faucets chain link.
00:16:09.630 - 00:16:10.200, Speaker A: Right.
00:16:10.350 - 00:16:15.230, Speaker B: So I'm going to put that, it's on the screen, but I'm going to put it here in the chat as well.
00:16:16.480 - 00:16:17.212, Speaker A: There we go.
00:16:17.266 - 00:17:16.504, Speaker B: Please go to that and get some link or some Testnet link and make sure you have some of that to add to your subscription because we're going to do that in a few minutes. Right. So then the next step as well, we deploy a functions compatible consumer smart contract. That's the one that you own, that's your app if you like, and we add that smart contract address as an authorized consumer to the function subscription that you created in step one, this is a way to make sure that your link balance are not being consumed by random contracts, right. It has to be associated with you, your smart contract and your wallet so that it's your funds that get used in an authorized way. Now, if your custom JavaScript that you're sending for decentralized execution needs to rely on things like API keys, authentication, passwords, whatever it is, these are typically, we refer to them as secrets. Well, you can encrypt those secrets, send them to the decentralized Oracle network, and they will get injected in real time into your custom JavaScript code at runtime.
00:17:16.504 - 00:17:39.328, Speaker B: Right when it's being run, when the code is being run. So we need to do that step as well. And I'll show you how to do that because we will be using, for today's example, we'll be using chat GPT API keys because I will show you how to interact with chat GPT's OpenAI's API to get sort of an LLM based response, a large language model based response from chat GPT to a prompt that we give it.
00:17:39.354 - 00:17:39.880, Speaker A: Okay?
00:17:40.030 - 00:17:59.916, Speaker B: And then finally we execute the custom JavaScript code that has access to all these secrets and all that. But we do it all on the chainlink decentralized Oracle network. We send it the request, there's decentralized compute on it, decentralized hitting of the API, and you get a response back that has consensus applied to it and you'll see the response in your smart contract. We'll do all this today.
00:18:00.098 - 00:18:00.444, Speaker A: Cool.
00:18:00.482 - 00:18:04.270, Speaker B: I'm going to pause very quickly. I see there are a couple of questions.
00:18:05.520 - 00:18:05.884, Speaker A: Cool.
00:18:05.922 - 00:18:40.536, Speaker B: I see that Harry and Dab have got most of them, so thank you so much. Thanks Dab for also adding the URL parameter. Appreciate it. That's exactly right. Make sure your wallets are connected to Mumbai if you plan to follow along. Okay, so now let's check out some tooling. So I'm going to actually put this link down here because this is where if you want to get open API keys for this, if you're planning to code along, you probably need to create an open API platform, open API account for yourself and then get the API keys from this link.
00:18:40.536 - 00:19:25.336, Speaker B: So if you just go to this link, it'll ask you to log in anyway or create an account and then it'll redirect you. Now, I will say that obviously, because we only have a couple of hours, I will need to maintain a certain pace. I'm going to do my best to break it all down. In fact, I've broken the whole repo down in steps for you, and I'll keep pushing as we go. I would recommend that those of you who've had less than six months of overall coding experience, whether web two or web three, and those of you who've had less than, let's say three to six months of web three experience, it's probably better for you to just pay attention and watch. You can absolutely watch this video at a later time and follow along then. But there are key mental models that you may miss if you're also typing and doing wallet stuff and API keys and all that at the same time.
00:19:25.336 - 00:20:02.780, Speaker B: So unless you're a fairly experienced programmer and comfortable with JavaScript, comfortable with solidity, have worked with some chain link stuff before, maybe it's better for you to just watch and then redo it later on in your own. Because I'll do it very step by step. It'll be very clear for you, but for those of you who are most seasoned, have got a lot of the setup already done, then feel free to follow along. But I will need to maintain a certain space. So please be mindful of the fact that we have time, that I'm on the clock a little bit, and I want to make sure that I get through the whole thing so that everybody who watches this later on can benefit from it. So let's check out some of the tooling. And while we're doing that, you may want to go and try and get your API keys.
00:20:02.780 - 00:20:05.472, Speaker B: But if you don't, don't worry about it. You can do it later and follow along.
00:20:05.526 - 00:20:05.816, Speaker A: Right.
00:20:05.878 - 00:20:14.584, Speaker B: That's the DLDR. Okay, so first and foremost, let's go back to that repo again, right, this.
00:20:14.622 - 00:20:19.716, Speaker A: One, and just git clone it, please, to your machine.
00:20:19.748 - 00:20:24.652, Speaker B: I've already done it here, and I'm looking at my screen, and it seems.
00:20:24.706 - 00:20:25.310, Speaker A: Like.
00:20:27.200 - 00:21:00.792, Speaker B: That text is big enough for you guys, right? If it's not, please let me know. But for right now, just git clone this repo, which I've put in the chat, and do an NPM install CD into that downloaded repo, and then do an NPM install. Let that go on in the background, please. And we'll keep talking and I'll keep presenting to you. And just let the NPM install go on in the background so that we save a bit of time that way. Right. Next thing, what we want to do is, and I'll do this with you, is we want to go to functions chain link.
00:21:00.792 - 00:21:13.964, Speaker B: Okay? So let's do that. And I will show you. This is where we create our function subscription. So you remember that. Let me go back a bit. Step one, create a chain link function subscription, right? So that's what we're trying to do now. So we go to functions chain link.
00:21:13.964 - 00:21:32.530, Speaker B: I'm sorry if my screen moves a bit too fast. Do let me know if that's the case, I'll slow it down because I know that sometimes there can be a little bit of a lag. So you'll see now that it's detecting my wallet. But if for those of you have. Okay, well, I'm going to connect my wallet because it wasn't doing that new window and I restarted. So I'm going to do this.
00:21:33.400 - 00:21:37.670, Speaker A: So you connect your wallet to the front end.
00:21:40.360 - 00:22:08.956, Speaker B: Well, I don't really want to go to Sepolia, so let me just fix that. Yeah, Polygon Mumbai is fine. Yeah, I'm in Polygon Mumbai. Okay, so make sure that you get some. If you haven't already, go to faucets chain link, make sure you're connected to Polygon and then do your verification and get your testnet link. And you probably need to get some matic as well if you don't already have some of that. So you can do that at faucet chain link.
00:22:08.956 - 00:22:38.504, Speaker B: All the links will be there for you. Now, going back to Chainlink functions, what we want to do is we want to create a subscription. Now, when we do this, they're going to be two transactions. Let me just go back to this again. So when we create a subscription, there are two transactions, two times that you'll have to sign some stuff on your metamask wallet, and then you want to fund your subscription. So let me just create a subscription for you and show you how it's done. We'll also do this programmatically, by the way, but first you need to accept the terms of services.
00:22:38.622 - 00:22:40.584, Speaker A: So that's fine.
00:22:40.622 - 00:22:45.210, Speaker B: So I'm just going to do zoom, not contract.
00:22:49.980 - 00:22:50.744, Speaker A: That's fine.
00:22:50.782 - 00:22:52.056, Speaker B: And I'm going to create a subscription.
00:22:52.088 - 00:22:52.284, Speaker A: Right.
00:22:52.322 - 00:23:10.896, Speaker B: So it's going to do a couple of transactions. Now, please confirm the transaction. Here's transaction one, right. And then it's going to do the second one in a moment, the signing of the message one, which is basically verifying your wallet so that you can then be allow listed to use the Chainlink function system.
00:23:11.078 - 00:23:16.012, Speaker A: What's going on here? Yes, confirmed.
00:23:16.076 - 00:23:38.676, Speaker B: Now the sign message one is going to come up. Here you go. Sign the message. And we are cooking on gas. Hopefully as soon as it confirms, we're good to go. That's right. Muradif Chainlink faucet provides link, but there's a link in that to go and get polygon.
00:23:38.676 - 00:23:41.848, Speaker B: Mumbai faucet polygonmatic, basically.
00:23:41.934 - 00:23:42.184, Speaker A: Right.
00:23:42.222 - 00:23:48.476, Speaker B: So if you go to faucets, chain link slash Mumbai, as Dab said, you can get your testnet link from there.
00:23:48.578 - 00:23:49.436, Speaker A: And then you have to go to.
00:23:49.458 - 00:23:58.492, Speaker B: The Mumbai testnet itself to get its matic. Okay, so now you've got this, you've created the subscription.
00:23:58.556 - 00:24:01.056, Speaker A: You can add funds here if you.
00:24:01.078 - 00:24:02.368, Speaker B: Want, or you can do it later.
00:24:02.454 - 00:24:02.848, Speaker A: Right?
00:24:02.934 - 00:24:23.912, Speaker B: I would probably add funds here. If I was you. I would just add three link and do it. But I'm going to do this for you programmatically. So I'm not going to do this necessarily now. Okay. But once you get to the stage, you know, your allow list, you know, you can absolutely use functions as long as the wallet address that you're going to use in your code is the same one that you've signed all this on.
00:24:23.912 - 00:24:50.812, Speaker B: Okay, so make sure it's the same one that you're using in the code. You're using the private key for that wallet address. If you mix wallets up, then you'll have to allow list the wallet that you're using by coming back here and doing this again. All right, I'm just going to do, I'll do this later, but you guys should add some fun to it if you want. Or we can do it programmatically in a moment. And now you'll see that there are no consumer contracts. Now, you remember that we had talked about add a contract address as an authorized consumer to your function subscription.
00:24:50.812 - 00:25:21.048, Speaker B: That's what this is saying. We don't have a consumer yet and that's because we haven't deployed anything. So we'll come back and do that later. All right, so let's get back to the steps in the presentation. So we fund with three link, or like I said, as long as you've created a subscription and you have that subscription ID, you can do it programmatically. Now, if you're wondering what your subscription ID is, back at the functions chain link Mumbaiurl, you will see your subscription IDs right at the end. It's also here on the screen.
00:25:21.048 - 00:25:31.436, Speaker B: That's your wallet address that's showing you're an admin. It shows that you have zero link balance in your subscription at the moment and you have no consumers. And this will give you a history of the events associated with your subscription.
00:25:31.468 - 00:25:31.616, Speaker A: Right.
00:25:31.638 - 00:25:36.560, Speaker B: So the subscription dashboard is where you manage your link subscription, your function subscription.
00:25:37.140 - 00:25:37.890, Speaker A: Right.
00:25:38.260 - 00:26:06.836, Speaker B: What have I said here? Use the wallet address that you use in code and dev. Again, if you have errors, it could be because you've used different wallet addresses. All right, now let's test drive the custom JavaScript. So where will we find this? Well, I've actually pushed it up today to your source. So if you go to the repo that I've told you to clone and you go to source JS, right? It should be there in your IDe. If you've already cloned it, just copy.
00:26:06.868 - 00:26:09.228, Speaker A: That raw file for a moment and.
00:26:09.234 - 00:26:17.036, Speaker B: We'Re going to paste it in in a moment in this site. Okay, so functions chain link is a very cool tool.
00:26:17.138 - 00:26:17.500, Speaker A: Sorry.
00:26:17.570 - 00:26:20.360, Speaker B: Functions chain link playground.
00:26:20.440 - 00:26:21.070, Speaker A: Okay.
00:26:25.750 - 00:26:42.886, Speaker B: Discipline. Yeah, white glow, I bet. At night. Absolutely, man. Go for it. All right, so go to functions chain link playground to really test drive the custom JavaScript that you want to do right now. I've done this before, so that's why it's showing up there.
00:26:42.886 - 00:27:13.438, Speaker B: But if you copy this source, this is the custom JavaScript that's going to hit the API and return the data. So let's go through very quickly. We're going to send in the prompt as the first argument, args at index zero. Then we're going to compose a post data object, which is basically how we hit the open API. API, sorry, OpenAI API. I was wondering what's wrong with that open AI API. And then that's the data we need to send it.
00:27:13.438 - 00:27:37.318, Speaker B: That's the object we need to send it. We use functions to make an HTTP request. Let me zoom in on that. Sorry guys. We use functions to make an HTTP request, right? We hit that URL, it's a post request. We send it headers, including our OpenAI API key, which is available in this globally injected secrets object. And I'll show you how to configure all this on the smart contract side and the script side.
00:27:37.318 - 00:28:11.186, Speaker B: And we send it this post data, we're sending it here in line 16. So that's the full post request to the OpenAI API sends us an API response, we pull off the relevant. If it's an error, we throw the error in the functions execution. But if it's successful, we pull off the right data that we want from it as defined by the API, and we encode it as a string, which is bytes. It'll be a bytes array, that's what encode string does. It encodes a string into bytes and then we send that to our smart contract. However, for now, let's just see if this code works.
00:28:11.186 - 00:28:32.146, Speaker B: Right. So that's why we go to functions chain link playground. Thank you again, dab. Appreciate it, man. And I'm just going to paste the code in here. Okay, zoom that in for you guys a bit. Okay, so that's the code I just showed you on the screen, which is in the repo.
00:28:32.146 - 00:28:37.914, Speaker B: And now what we want to do is we want to give it an argument. So the argument I'm going to give it is the prompt, right?
00:28:37.952 - 00:28:40.666, Speaker A: Because we see the prompt is being.
00:28:40.688 - 00:28:54.334, Speaker B: Passed in as an argument. So there's only one argument. You can add multiple arguments if you want to have pass multiple arguments. In our case we only need one, which is the prompt saying please can you describe what a blockchain oracle is in 15 words or less?
00:28:54.372 - 00:28:54.670, Speaker A: Right.
00:28:54.740 - 00:29:18.946, Speaker B: And for the API key, well, I'm going to need that. That's what you would have had to get from your OpenAI API key, which I linked to previously. I'm just going to paste that. The good thing is it's masked so you guys can't see it. So I don't get charged for all of you hitting this API and I'm going to just run this code. But when I do, what am I expecting to see? Well, I'm hopefully not going to see an error response that's thrown.
00:29:19.058 - 00:29:19.622, Speaker A: Right.
00:29:19.756 - 00:29:42.126, Speaker B: If there's any console logs, I'll see them here in this box. And if there's an output type, well the output is going to be bytes because that's how it's done. And then the output will tell us what outputs we generated in bytes and it'll also decode it into a string. Well, hopefully. Famous last words. Let's see though. Right, so I'm running the code now, it's hitting the API and here we go.
00:29:42.126 - 00:29:49.490, Speaker B: So that's the bytes, that's what gets sent back to your smart contract encode string into bytes. Looks like that.
00:29:49.560 - 00:29:52.622, Speaker A: You decode that, that's actually the response.
00:29:52.686 - 00:29:56.146, Speaker B: As a string that the OpenAI API gave us.
00:29:56.168 - 00:29:56.306, Speaker A: Right.
00:29:56.328 - 00:30:15.882, Speaker B: A blockchain. Oracle is a trusted external source that provides data to a blockchain network, 15 words or less. Now this is the simulation that happens in browser, okay? So we know now that the code works. So this is a good starting point tool to help us know that the JavaScript that we work, but none of this is happening on chain yet. So that's the next stage. Let's get back to the presentation so we know what's happening.
00:30:15.936 - 00:30:16.154, Speaker A: Right.
00:30:16.192 - 00:30:30.094, Speaker B: So we've run through these steps and we put it in the prompt of the VR. We got the results, now let's code. So let's break this down step by step, guys, because there's a bit we need to do here. Okay? So I'm going to switch over to my browser in a moment.
00:30:30.132 - 00:30:33.422, Speaker A: Now we've got the source JS, right?
00:30:33.476 - 00:31:01.834, Speaker B: We've got that in our, let me close this out. We've got that already in our repo because you would have cloned it from, if you've cloned the repo from here, you've already got source JS. Let's also take a look at some of the other parts of this code. Okay, so we got source JS just in terms of the plumbing. I'll show you what we need to do for environment variables now. But if you look at endotample, these are the two environment variables we need and we'll get to this in a moment. But just keep this in mind.
00:31:01.834 - 00:31:18.526, Speaker B: We need the RPC URL and my bad, we also need your private key here. We also need your private key, which will be, if you look for all the environment variables that we use, you.
00:31:18.548 - 00:31:22.286, Speaker A: Will see that use process n private.
00:31:22.318 - 00:31:33.454, Speaker B: Key, ignore the coin market one that's not we use RPC URL. We use private key. And specifically we use it for the Polygon network.
00:31:33.502 - 00:31:33.810, Speaker A: Right?
00:31:33.880 - 00:32:07.642, Speaker B: And then we'll use the chat GPT API key in the actual source JS file. But I'll show you that it's not going to show up now because we haven't actually written the script for it. Okay, so we do need these three API keys, your RPC URL for the Polygon Mumbai network, your GPT key and your wallet private key, the one that you've got already approved to use. Functions using the functions front end subscription UI. All right, so those are the environment variables you're going to need in a moment. Now let's look at connection Js. This is just a helper file.
00:32:07.642 - 00:32:35.634, Speaker B: All it does is it requires the ethers library. It pulls out a provider's wallet, uses your RPC URL to create a provider, right? So you can actually connect to the blockchain. It takes your private key and then creates a wallet with that and creates a signer object using that wallet. For those of you familiar with web three development and ethers GS, this is all fairly familiar, but it exports all three. So we do this the one time and we can access it through all the scripts that we're going to write. That's all connection JS does. It connects us to the blockchain.
00:32:35.634 - 00:32:59.018, Speaker B: Network networks JS is a bit of configuration. I've also added this Ethereum sepolia one here for those of you who want to try and do this later on on Sepolia, we support a bunch of chains. If you go to functions, chain. Sorry, docs, if you go to docs, chain link functions. The documents for this, you can see that the supported networks are listed here under supported networks.
00:32:59.034 - 00:32:59.166, Speaker A: Right?
00:32:59.188 - 00:33:12.386, Speaker B: So these are all the networks. Avalanche Polygon and Ethereum, both Mainnet and Testnet. Okay, so that's what we've got supported at the moment. For this configuration, I've included the Ethereum supporter, just as an FYI. But we're going to use the Polygon Mumbai one today.
00:33:12.488 - 00:33:12.850, Speaker A: Right?
00:33:12.920 - 00:33:49.520, Speaker B: And so this has access to the private key, some default stuff, but most importantly, it's got some functions, chain link functions, related configuration values here, which we'll use in the course of the code. So that's what networks is. And we've seen what connection is now let's look at the consumer contract. Remember how I said you need to have an authorized consumer contract which is functions enabled, which is your smart contract that you're going to deploy? Well, that's going to be in functions consumer. I've already done the code for you here so that it saves us a bit of time. You know what, I may have actually forgotten to do mpm install myself. So there we go.
00:33:49.520 - 00:33:51.790, Speaker B: That's doing that in the background.
00:33:53.750 - 00:33:57.666, Speaker A: Now I think. Also I meant to show you the.
00:33:57.688 - 00:34:29.878, Speaker B: Screencast mode so you can see my commands at the bottom over there as I do them. My keyboard shortcuts may not necessarily work for you, but I've added that in case you want to see. And also it gives you this helpful red dot thing when I click on things. So let's look at functions consumer. It's basically a smart contract. It inherits the functions client and confirmed owner libraries that Chainlink makes available publicly. And the key part is you pass in some configuration details.
00:34:29.878 - 00:34:43.022, Speaker B: You pass in the Dawn ID and the router, which we'll cover in a moment. And then that's how we instantiate the smart contract. That's how we construct it. The constructor and the most important two functions are send request here in line.
00:34:43.076 - 00:34:45.806, Speaker A: 42 and fulfill request.
00:34:45.838 - 00:35:23.914, Speaker B: Right now, fulfill request is the only one you'll see. It's an override. It's because it's inherited from the functions client contract. It's the one that you have to do. This is an interface that you have to implement because this is how the decentralized Oracle network and chain link smart contracts know how to send you back the data, right? It has to send you back the data by using an interface that it knows you're going to have, and that's the fulfilled request. So the one thing your functions enabled smart contract must have, and it won't compile if you don't have that, because you're inheriting from functions client is, you need to implement something and fulfill request and follow the signature send request you can construct in any way you want. I've done it this way.
00:35:23.914 - 00:35:59.206, Speaker B: For the purposes of the demo, we need to pass in a couple of details. First of all, we need to pass in the source code. Second, we need to pass the location of the secrets. There are two options. You can either put the secrets in an encrypted form on a GitHub gist, or an S three bucket or a cloud storage URL, some publicly accessible URL, but encrypted, you can give it a URL or you can upload your secrets in encrypted form to the chain link dawn, and they keep it in a decentralized storage over there. So that's the location of the secrets, those are the two that are supported. And then when you do that you have to give a reference to where your secrets are located.
00:35:59.206 - 00:36:26.898, Speaker B: And you'll see all that in a moment so that the Dom says, okay, I know this is a URL, or I know this is actually on the decentralized oracle network itself and I know where to pull it from. Args is an array of strings, so it can only be strings at the moment. And bytes. Args is kind of optional. We won't use this radio today, but it's basically arguments in the form of bytes in case you want to make it more efficient and so on, so forth. But we'll use the string array subscription ID is what we created here in your chain link function subscription. So that's this thing over here for me.
00:36:26.898 - 00:37:14.138, Speaker B: I may use a different one, but that's really what it's meant to be. And callback gas limit is, well, once the compute has been done and you're sending your results back to your fulfill request, how much gas do you want to send as part of that call? Right, and so we set it at, I'll show you that, which is probably the right number for most cases. And then inside that actual send request function, inside that we build a request object and the reference for that, I've added that link here if you want to see what the functions request request object struct looks like. We initialize the request with some data that we've passed in. In the actual functions here, in the actual method here we add the secrets location, we add the encrypted secrets reference. We check if there are arguments. If there are arguments, we set them again with bytes args.
00:37:14.138 - 00:37:37.798, Speaker B: If there are any of that, we set them and then we send the request. It gets encoded into CbOr, which is like JSON, but except that it's immutable. It's a way to structure the data in bytes. And then we pass in the subscription ID, the callback gas limit and the don ID and we get a request ID. Now that's a lot to cover. So this contract I've kind of done for you, you guys should inspect it later on. You do not have to do it this way.
00:37:37.798 - 00:38:00.734, Speaker B: This is how I've done it for the demo. But you do have to have this function there. Line 71 has to be there. You can implement whatever you want in it, but that signature has to be the same. That's the key takeaway from this, and we're going to deploy this in a bit. Now that we've covered the key concepts, let's do the environment variable stuff. Okay, talker, let me show this question.
00:38:00.734 - 00:38:54.450, Speaker B: Where are the private variables stored? In theory you could say that they could, but we've implemented something, and I don't want to get too deep into this because it's fairly technical, but there's something called threshold encryption that we do in chain linked ons, which basically means we shard the private key as well. And so in a given round, all the nodes have to come together, consensus on the private key before they can decrypt or decode the secrets that are sent in. So we encode it with the public key from the node, which is a public key, which is fine, but the decryption has to have consensus because every node only has a shard of the private key. It's kind of complicated. There's a bit of research out there, but it's a good question, right? In theory you're right, they could potentially see the ODs of that are absolutely tiny, especially during sharding. And so that helps minimize risk to only one given round of consensus.
00:38:55.270 - 00:38:56.066, Speaker A: Cool.
00:38:56.248 - 00:38:59.058, Speaker B: Now let's do this.
00:38:59.144 - 00:39:02.334, Speaker A: So you can use a n file.
00:39:02.382 - 00:39:31.206, Speaker B: And require the node n package, right, to store your secrets locally on your repo, but we prefer to store them locally encrypted. And the reason we do that is often people will accidentally not get ignored their env file and push their secrets to GitHub. And things can happen, especially with private keys. So what we do, we recommend a chain link. We have this little package called Env enc. If you look at the package JSon.
00:39:31.238 - 00:39:35.774, Speaker A: You'Ll see that this is a chain link, right?
00:39:35.812 - 00:39:51.650, Speaker B: And what that does is it takes in your secrets and your private keys, and all of that stores it on file locally on your machine, but it does it in an encrypted at rest format, which means even if you accidentally push it up or someone sees it without your password, they're not going to be able to decrypt that encrypted data.
00:39:51.720 - 00:39:51.954, Speaker A: Right.
00:39:51.992 - 00:40:23.690, Speaker B: And so it's kind of useless to them. So let's start by getting our environment variable sorted out, right. So how we do that is we first need to set a password. And remember, without this password for your encrypted data, for your encrypted secrets API secrets, you will not be able to decrypt it. You can reset them all over again. You can do that, but you can't really decrypt it unless you remember the password. So first I'm going to do NPX env set password.
00:40:23.770 - 00:40:24.400, Speaker A: Right.
00:40:27.730 - 00:40:31.038, Speaker B: Interesting. So if I do that, I'm going.
00:40:31.044 - 00:40:35.570, Speaker A: To just toggle off for a moment.
00:40:35.640 - 00:40:54.482, Speaker B: While I set the password and then I'm going to do the screencast mode again. Okay, so now I set my password, right. It is masked, but had it not, if I screencast you would have seen all my characters. But it's masked and then what should have happened is if I do NPX.
00:40:54.546 - 00:40:58.566, Speaker A: Nc view it'll tell me that you.
00:40:58.588 - 00:40:59.740, Speaker B: Actually haven't got.
00:41:02.030 - 00:41:03.066, Speaker A: Is not found. Right.
00:41:03.088 - 00:41:25.602, Speaker B: So it's going to create this envenc file when you start saving your passwords there right now it's saying, well we haven't actually found it. That's why the view call didn't work. So the only way to create it really, I mean the best way to create it is to actually start setting your environment variables. So I'm going to do NPX env, just set, not set PW, right.
00:41:25.736 - 00:41:28.338, Speaker A: And then the name that I'm going.
00:41:28.344 - 00:41:48.650, Speaker B: To do, let's start with RpC URL and the value for that, let me try and pull it out because we're doing. Here we go. I think I've got this. Hopefully that's going to be copied correctly. It'll be masked here anyway. Do I want to set another variable?
00:41:49.870 - 00:41:50.620, Speaker A: Yes.
00:41:53.870 - 00:42:01.840, Speaker B: Okay. If you want to set another variable, don't press enter, just put the variable name. So I'm going to do the chat GPT API key here, press enter, give it the value.
00:42:04.610 - 00:42:09.214, Speaker A: Screen, and I'm going to do, yes, I do want to put another one.
00:42:09.252 - 00:42:10.542, Speaker B: I want to put my private key.
00:42:10.596 - 00:42:14.750, Speaker A: In and value is going to be.
00:42:14.900 - 00:42:40.060, Speaker B: That private key value there. Okay. And now I do not want to set another variable name. So I'm just going to press enter to finish. So what just happened? We set three environment variables, but if you look at the, there's a new enc file and that's what is there now. So all of this is encrypted. So the only way you can do it, can access this now is if you do NPX env.
00:42:40.060 - 00:43:18.046, Speaker B: Now I won't do that because if I do that it's going to show you the decrypted version of my secrets which means it's going to be completely visible to you. I'm not going to do that, but that's how you do it. And as long as you set your password. Oh, it's important to remember every time you restart the terminal or create a new terminal session, you'll need to set the password afresh, otherwise you will not be able to. Couldn't find the environment variable error. And that's why, because it doesn't know your password. You have to set the password fresh every time.
00:43:18.046 - 00:43:47.934, Speaker B: All right, so now that we've set the environment variables and we know that they're in this env and ENC file, we've got these three done. Let's see what's next. Okay, we've done that just as a point. The stuff in the ENC file, your environment variable, is stored locally on your machine. It's git ignored in this repo, but if you forget to ignore this, even if it gets pushed up, nobody can use this. This is total gibberish for them without your password. Right.
00:43:47.934 - 00:44:09.714, Speaker B: That's the whole purpose of this. We don't send it in this form to the blockchain or we don't send it in this form to your consumer contract. None of that. This is just for local development safety. There's a different kind of encryption that we need to do when we send the secrets to the chain link functions and we'll cover that separately. Okay, so this is just for the local development and for your repo.
00:44:09.762 - 00:44:09.974, Speaker A: Right.
00:44:10.012 - 00:44:21.894, Speaker B: Now let's write the scripts for each step. So now we're going to get into some codings. Follow along if you can. Otherwise, just pay attention closely and we'll break it up into the pieces.
00:44:21.942 - 00:44:22.250, Speaker A: Right.
00:44:22.320 - 00:44:32.026, Speaker B: So the first thing that I want to do is I want to create a folder with the name scripts.
00:44:32.058 - 00:44:32.640, Speaker A: Okay.
00:44:33.170 - 00:44:34.720, Speaker B: And inside that.
00:44:37.010 - 00:44:37.854, Speaker A: You know what, that.
00:44:37.892 - 00:44:52.226, Speaker B: Was the wrong command, sorry, let me get rid of that. I should have done make directory, make their scripts and we'll see a scripts folder here. And in that I'm going to create a file and the first file I'm going to do is I'm going to.
00:44:52.248 - 00:44:59.034, Speaker A: Call it deploy Js.
00:44:59.182 - 00:45:27.978, Speaker B: You know what I'm going to do as well? Not a lot that we've done yet. So I may push after this. That's what I'll do. I'll push after this because I'll push the code up to GitHub so you guys can pull the latest version of the script if you need. Now in the interest of time, I'm going to copy and paste some of the imports so that you don't see me just typing imports all the time. And then we'll actually do the code stuff together. What am I doing here? I'm pulling in the ABI and bytecode, which I've also provided for you under the contracts ABI folder.
00:45:27.978 - 00:46:04.166, Speaker B: I've generated the ABI and bytecode in this big JSon, right, and I did that actually using remix. But you can use hard add or whatever. So this project doesn't use hardad at all, because I want to show you how to use the NPM, the functions toolkit NPM package, which is the package that we publish for the use of functions in a node environment. It's super easy to use. It's here if you go to GitHub functions smart contract functions toolkit, and I'll put that for you here in the chat. You can see all the things it helps you do. It helps you create subscriptions using a subscription manager.
00:46:04.166 - 00:46:31.106, Speaker B: It helps you handle your secrets, it helps you listen in real time, mount a listener to listen for on chain events and a bunch of utilities like the simulator and stuff like that, which I'll talk about in a moment, or I'll talk about perhaps later on. But all the functionality that we're going to be using today is in that package. Now, you don't need hard hat to use this, obviously. Hard hat is a tooling thing. It'll make your development environment a bit faster. But today we're not going to use any hard hat, just scripts. So it's broken down all the steps for you.
00:46:31.128 - 00:46:31.554, Speaker A: Right.
00:46:31.672 - 00:46:58.086, Speaker B: Okay, so back to the code. So this first, deploy consumers. The goal here is to deploy the consumer. We're pulling in a bunch of things that we've already got in our repo, we've already talked about the networks folder. Let me close this terminal for a moment. And we're pulling out the contract factory type and the method and stuff and utils from the ethers library. Now for each of these steps, you're going to have to specify which network we're on and make sure it's Polygon Mumbai.
00:46:58.086 - 00:47:04.858, Speaker B: If you're following along or if you're using Sepolia, make sure that whatever string.
00:47:04.874 - 00:47:07.742, Speaker A: You put in there matches the property name.
00:47:07.796 - 00:47:16.574, Speaker B: So I'm using Polygon Mumbai here, and Ethereum and Sepolia, so make sure it's that. So I'm just going to be super careful and make sure it is exactly the same. It is exactly the same.
00:47:16.612 - 00:47:16.766, Speaker A: Right.
00:47:16.788 - 00:47:41.994, Speaker B: And you'll see why in a moment. Now from that, what we want to do is we need to pull off a couple of the input arguments. So if you look at the functions consumer sol, you will see that the constructor requires an address. Type the router address and a bytes 32 of the Dawn ID. In the configuration, you'll see that. Here's the functions router address, and you'll see the dawn ID as a string. So we'll convert that to bytes 32 in a moment.
00:47:41.994 - 00:48:08.658, Speaker B: But these are the two pieces of input data we need in our script. So that's what I'm going to do here, right? I'm going to go const router address equals we pulled in the network's object. So I'm just going to go and you can see my AI is helping me complete it. That's fine. Functions router. Okay, why functions router? Because that's what's here. That's what the name of the property is here.
00:48:08.658 - 00:48:28.360, Speaker B: Okay, so we're just pulling that piece of data in and then we want to do const Don ID bytes 32. And we want to convert functions router, what's it called here? It's called Don ID. So we want to convert that to bytes 32.
00:48:28.810 - 00:48:29.186, Speaker A: Right.
00:48:29.228 - 00:48:47.502, Speaker B: Well, how do we do that? Well, it so happens that ethers gives us a utility to do that. So it's format 32 byte string. That's the one. We're pulling off ethers utils and formatting a string to bytes 32.
00:48:47.636 - 00:48:48.222, Speaker A: Right.
00:48:48.356 - 00:48:52.042, Speaker B: So does that look right? Bytes 32? Yeah, that looks right.
00:48:52.116 - 00:48:55.970, Speaker A: Okay. Yeah, so that should be fine.
00:48:56.040 - 00:49:01.700, Speaker B: What I'm just going to do is I'm going to put the skeletal structure of the deploy function.
00:49:05.190 - 00:49:09.490, Speaker A: Functions consumer contract.
00:49:10.150 - 00:49:49.474, Speaker B: Going to be an async function, return the promise, going to do something. I need to spell async correctly, going to do something. And then I want to call this deploy functions consumercontract. And then I don't think that we need to worry about bin. We can just do a catch error and console log error. Deploying consumer contract can fix the typo and I want to print out the error here. Okay, so we're just going to do that.
00:49:49.474 - 00:49:53.714, Speaker B: And all I'm going to do here is I'm going to do for now, just to make sure it's working, is.
00:49:53.752 - 00:49:57.442, Speaker A: Router address and Don ID by 32.
00:49:57.496 - 00:50:18.358, Speaker B: Okay, let's try. And so for that I would do node because this is just a node script and the reason I like to name it by step is because it actually makes it easy to autocomplete. So I can just do zero one, it'll autocomplete for me and it should print out those two values. Here we go. That should match with networks.
00:50:18.534 - 00:50:20.086, Speaker A: Yes, that's one matching.
00:50:20.118 - 00:50:23.046, Speaker B: And the other one's the bytes 32 version of the Don Id string.
00:50:23.078 - 00:50:23.322, Speaker A: Perfect.
00:50:23.376 - 00:50:52.840, Speaker B: So we know that the script, the basics of it is running. So I'm going to delete that console log and let's continue doing so. We need to get the reference to the functions consumer smart contract. So what we will do is we will just do a new contract factory which we've imported up here. Pass it the ABI, pass it the, I love how the AI helps with the auto completion so much faster. But as long as you know what, that's correct. Sometimes the suggestions are kind of wildly wrong, as many of you.
00:50:52.840 - 00:51:07.340, Speaker B: So we want to assign that we've got a reference to the contract factory given that the, the API and bytecode in the wallet. Okay, good. Now what we want to do is you want to.
00:51:09.550 - 00:51:10.554, Speaker A: Deploy it, right?
00:51:10.592 - 00:51:39.910, Speaker B: So what I'm going to do is I'm going to connect it to me as a signer just to make sure. I'm going to do contract factory. We could just do a deploy, but I'm just going to make super sure, connect it to the signer that I've imported deploy. And we need to pass it the initial constructor args, which is router address and the Don ID byte 32. That's correct. That's exactly what we want to do. And this is going to return to us a contract.
00:51:39.910 - 00:51:44.550, Speaker B: Functions consumer contract.
00:51:46.730 - 00:51:47.594, Speaker A: Return to us.
00:51:47.632 - 00:52:05.600, Speaker B: Let me format that and perhaps it'll be helpful for when we run this for me to do deploying. Deploying. Okay, that should work.
00:52:07.650 - 00:52:09.422, Speaker A: Okay, that should work. All right.
00:52:09.556 - 00:52:10.814, Speaker B: In fact, let me just make this.
00:52:10.852 - 00:52:13.922, Speaker A: A little bit better for us by.
00:52:13.976 - 00:52:19.650, Speaker B: Saying I'm going to pass in the network to make sure it's read that correctly on network.
00:52:23.030 - 00:52:30.806, Speaker A: Here. So once we, what have we done here?
00:52:30.828 - 00:52:31.526, Speaker B: We deploying it.
00:52:31.548 - 00:52:39.958, Speaker A: So now we need to wait options.
00:52:40.044 - 00:52:43.146, Speaker B: Consumer contract, the return deployed. Yes, that's right.
00:52:43.168 - 00:52:45.866, Speaker A: We want to wait that and then.
00:52:45.888 - 00:52:58.860, Speaker B: We want to print out done, deployed at address. Address.
00:52:59.630 - 00:53:00.042, Speaker A: Okay.
00:53:00.096 - 00:53:26.582, Speaker B: Now what I'm also going to do is I'm going to, because we will need to take a note of this deploy of a bunch of stuff, the contract deployments. So I'm just going to do a secret. This is what I do is I do a touch notes env. This is just my way of doing it. And that way I have a notes file that doesn't get pushed up and I'm going to start storing information here like the contract that we've deployed and things like that. Okay, so we've got the deploy script now let's see if that's actually going to work. I believe that should work.
00:53:26.582 - 00:53:38.326, Speaker B: I believe we got everything we need. So I'm just going to do node scripts one, deploy consumers again and let's see what happens. So good. So far so good. It's reading the data correctly. It's reading the network correctly.
00:53:38.518 - 00:53:39.260, Speaker A: Um.
00:53:49.160 - 00:54:04.984, Speaker B: Okay, so it's deployed there. So I'm just going to take a note of this contract address because we have the contract now that's already on Polygon Mumbai. We can just go to functions if you want. We can go to the function subscription and add your consumer here if you want.
00:54:05.022 - 00:54:05.176, Speaker A: Right.
00:54:05.198 - 00:54:16.728, Speaker B: I could do it this way and sign the transaction there. Can absolutely do that. That's probably the faster way. But I'm going to show you how to do this programmatically as well because that's what the NPM package does. It breaks all this down for you so you can do everything programmatically.
00:54:16.824 - 00:54:17.084, Speaker A: Great.
00:54:17.122 - 00:54:38.660, Speaker B: So we've got a contract deployed. Now let me just, okay, let me just push all this up. Git add, git commit one and push this to sign the commit. Git push origin. Am I in branch main? I am on branch main. All right, so hopefully.
00:54:40.840 - 00:54:41.376, Speaker A: Excellent.
00:54:41.408 - 00:54:49.912, Speaker B: Let's just quickly check the repo so I make sure that you guys are okay. If I refresh this, there should be a scripts folder. Beautiful. So you guys can also start copying it down from here now.
00:54:50.046 - 00:54:50.612, Speaker A: Excellent.
00:54:50.676 - 00:55:01.736, Speaker B: All right, so that's where we are. We've just finished doing this. All right, let me close all this stuff out. So that's deploy consumer. Does anybody have any questions before we run ahead because we still got quite.
00:55:01.758 - 00:55:02.750, Speaker A: A bit to do.
00:55:03.360 - 00:55:36.596, Speaker B: Three, two, one. Seems to be quiet, which is good. Either everyone's asleep or everyone's having a white claw and it's rapidly getting asleep. I'll just jump to script two and we can address questions later. Okay, so let me close that out and in the scripts folder I'm going to create a new file. The next step, let's see, what was the next step, guys? Does anyone remember what the next step is? And the reason I'm asking you is because I want to make sure that you realize that we have all the steps here. So we've got that right.
00:55:36.698 - 00:55:37.350, Speaker A: Okay.
00:55:42.060 - 00:56:18.790, Speaker B: So the next step is to actually create, we've created the consumer contract. We've sent it out. The next step is to create and fund a subscription, which I said you could do it through the UI, but I'm just going to show you how to do it. Programmatically as long as your wallet address has been allow listed, which means you've signed the transaction in the front end UI, and that's the same wallet you're using in your code. This script will work for you. Fate and fund subscription Js okay, and I'm going to pull in a bunch of imports for you so that you don't have to see me type, but you'll start to see there's a lot of similarity around there. Okay, so I'm going to pull in this.
00:56:19.400 - 00:56:20.084, Speaker A: There we go.
00:56:20.122 - 00:56:23.764, Speaker B: Let me close out some of these windows for you. So you'll start to see this is.
00:56:23.882 - 00:56:27.304, Speaker A: Kind of the first time we're actually.
00:56:27.342 - 00:56:46.700, Speaker B: Importing the function toolkit NPM package. So that's this one here that I talked about. Right, so pulling in the subscription manager to create a subscription manager, this is what you need to do. Okay, so that's why we're pulling in here and we'll start to use all these things in a moment.
00:56:46.850 - 00:56:50.110, Speaker A: Now what I need to do is.
00:56:51.680 - 00:56:53.328, Speaker B: Let me create the function, right?
00:56:53.414 - 00:57:02.496, Speaker A: Create and fund subscription async function, do something.
00:57:02.598 - 00:57:10.960, Speaker B: And then we want to do create and fund subscription. Yep, good. The AI is starting to learn my pattern. That's good. And then I do console log error.
00:57:11.040 - 00:57:16.100, Speaker A: Creating funding subscription.
00:57:18.280 - 00:57:46.344, Speaker B: Okay, now what are the steps we need to do? Well, the first thing we need to do is we need to create a subscription manager, which you'll see here in the actual repo. Right, so the repo or the, if you look at the NPMJs documentation, it's all there as well. So that's what we need to do. We need to create a new subscription manager. We need to give it a signer, which is what I've imported here. We need to give it the link token address and the function router address. Now you'll remember that we actually access some of the stuff from the networks file.
00:57:46.344 - 00:58:12.176, Speaker B: The link token address is here and the functions router address is here. So we need to repeat some of the code from step one. From step one. Right, so I'm going to do that. Constant functions router address is equal to networks network, whatever one we run right now. Functions router, correct. And the other one we need is a link token address there.
00:58:12.176 - 00:58:27.400, Speaker B: I love the way it's completing it for me. Okay, link token address. Yes, that's the right one. And is it called link token? It is indeed. Great. That looks right. We passed all that in here to our subscription manager.
00:58:27.400 - 00:58:35.120, Speaker B: The next step is the subscription manager object has been created. We need to call initialize on it. So that's kind of the next step here.
00:58:35.270 - 00:58:38.290, Speaker A: We need to do this.
00:58:40.500 - 00:59:14.386, Speaker B: And that just sort of initializes it and wrong one. Have I zoomed out a bit? I'm sorry, guys, let me zoom in a bit for you. Okay, so then we awaited, and now what we want to do is we want to create a subscription, right, which is this step. So let's just copy that and see whether we can use that and repurpose it for our purposes. So create subscription. Now, you may have already done this via the UI, so if you have, you'll need to modify the script. But I'm going to create a subscription.
00:59:14.386 - 00:59:28.058, Speaker B: I'm going to fund it. I'm going to add a consumer, all of that programmatically so that you guys can see all the steps. So that's typescript. So we can take that out. So we take the subscription manager we call create subscription. Now we can pass in a consumer address. And if we do that, it automatically.
00:59:28.154 - 00:59:31.246, Speaker A: Adds that contract that we deployed to.
00:59:31.268 - 00:59:52.214, Speaker B: It as a consumer. But what I'm going to do is I'm going to do that as a separate step for you. So I'm going to just take out consumer address now so you can see it being done. All this is going to do is create a subscription. That's literally all it's going to do. And so we don't even need to pass it an empty object. We can just pass it.
00:59:52.214 - 00:59:57.480, Speaker B: Nothing at all. And then let me just print something out here.
00:59:59.210 - 01:00:09.130, Speaker A: Subscription, subscription id. Whoa. Created perfect subscription.
01:00:12.350 - 01:00:25.422, Speaker B: Juicy part of. That's always the juicy part, right? All this hard work of doing wherever this is. I'm just kidding. I know what you mean, man. We'll get you in a moment. Sorry, but this is about chain link functions and less about the actual OpenAI stuff. But I get it.
01:00:25.422 - 01:00:35.026, Speaker B: I totally get the fun part. Yeah. Scrubscription. Exactly. Nice one. Love a good typo. All right, so hopefully that should work.
01:00:35.026 - 01:00:53.640, Speaker B: So we create the subscription. Now, the next step would be to actually add a consumer to it. So you can actually do that. If you look at the documents, there's an add consumer here. You can add consumer with something like that. So let's just type that out. We can do a, wait.
01:00:53.640 - 01:01:15.850, Speaker B: What will actually end up being is this subscription manager, which we've created the instance of. And then we want to do a add consumer, and then we want to pass it some details for the adding that. So we want to pass it a subscription ID. And that's the name of the property. It's expecting and we want a consumer address now see how it's suggesting. Signer address. That's not right.
01:01:15.850 - 01:01:23.202, Speaker B: The consumer address needs to be this one. Right. So we can just, let me put that here.
01:01:23.256 - 01:01:23.570, Speaker A: Const.
01:01:23.640 - 01:01:46.380, Speaker B: Consumer address is the one that we've just deployed. And so we get this value from our notes. This is why I keep a notes pad open as well, because you'll need to store all of this data. And now we've got the same property name so we don't need to actually do a colon and paste it in again. What is this going to return us? This is actually going to return us a receipt. Right. So we're going to do.
01:01:49.870 - 01:01:50.630, Speaker A: Receipt.
01:01:50.710 - 01:01:59.360, Speaker B: Let's just call it a receipt. It's a transaction receipt that we get from the back of that. And if you want, you can do.
01:02:00.290 - 01:02:02.080, Speaker A: A little bit of a note here.
01:02:04.050 - 01:02:13.700, Speaker B: Subscription now has contract address. Sorry, consumer address.
01:02:17.350 - 01:02:22.786, Speaker A: Oh my gosh. As a consumer subscription, let's give it an ID. Subscription.
01:02:22.898 - 01:02:25.730, Speaker B: Id now has as a consumer.
01:02:25.890 - 01:02:31.462, Speaker A: Let's go down here. Okay.
01:02:31.516 - 01:02:50.350, Speaker B: So we're printing out useful information as we go along. And then the last thing we want to do is we want to fund our subscription. So let me actually annotate this add given a subscription that's useful. And the last thing we want to do is fund. Exactly.
01:02:50.500 - 01:02:50.862, Speaker A: Okay.
01:02:50.916 - 01:03:08.740, Speaker B: And to that again, we use a subscription manager for that as well. We use subscriptionmanager fund subscription. It's all documented in the NPM package readme as well as in NPMJs. That's fine.
01:03:09.910 - 01:03:10.942, Speaker A: Subscription.
01:03:11.086 - 01:03:43.418, Speaker B: And then we want to pass it the config, which is going to be a bunch of things because we need to pass it a bit of data in terms of subscription ID and the amount of link we want to add. So make sure your wallet that you're using to dev has the link in it. The first thing it's going to ask for is, well, which subscription ID do you want to add funds to? And the next thing it's going to ask for is the dual demand. Now, just like ether has way as its smallest unit, the smallest unit of link is called Joules after one of the co founders and researchers rejuven.
01:03:43.434 - 01:03:43.566, Speaker A: Right.
01:03:43.588 - 01:03:48.402, Speaker B: So Joules amount is the smallest unit and so we need to give this a value.
01:03:48.456 - 01:03:51.794, Speaker A: So let's do const.
01:03:51.912 - 01:04:25.806, Speaker B: Joules amount is equal to and we want to do utils, parse units. And I'm going to do a constant in a moment so that you guys can configure this and change it any way you like. It's 18 decimals and we want to make that as a string. So what is going to happen here? We got to give this link amount a value. So let's do that right at the top here. Const link amount. And the good thing is we can do decimals as well.
01:04:25.828 - 01:04:25.966, Speaker A: Right.
01:04:25.988 - 01:04:49.094, Speaker B: But these are going to be like the entire number if you like rather than up to 18 decimals. So this basically means I'm going to send 3.3 link which is going to be three, three followed by lots of zeros, 17 zeros to get to that. And so joules amount is now going to evaluate to an amount that's a very long number and we're going to fund the subscription with that.
01:04:49.132 - 01:04:49.670, Speaker A: Okay.
01:04:49.820 - 01:04:56.040, Speaker B: So hopefully if we do all this and let's print out a here that it's done.
01:04:59.530 - 01:04:59.990, Speaker A: Perfect.
01:05:00.060 - 01:05:03.610, Speaker B: That sounds like a really great comment to put in. So thanks AI.
01:05:05.790 - 01:05:07.034, Speaker A: And I think that's more or less.
01:05:07.072 - 01:05:13.866, Speaker B: All we need to do. So what should happen is if we run this script, it should create, what are the steps we're doing here?
01:05:13.888 - 01:05:16.534, Speaker A: It should create a subscription, it should.
01:05:16.592 - 01:05:48.566, Speaker B: Add a consumer to it and it should fund it and we should be able to see it all in there. It should be in the UI. There's no need for consensus on this Toka because this is not going through the decentralized Oracle network. This is literally just interacting with smart contracts, Chainlink and our consumer contract that is already on chain. So there's no need. So in that sense, yes, there's Polygon, Mumbai's consensus if you like, but not Chainlink because it's not hitting the dawn. Oh sorry, were you asking about another question? Sorry, I'm not answering about that.
01:05:48.566 - 01:06:09.006, Speaker B: I thought you're asking about the script I'm writing now. So I haven't actually looked at your question yet. So I'll try and do that later. So if we succeed in doing all of these steps we should come back here and we should find a new subscription created here with the ID that will get printed out here. This one subscription ID created. Let's see if that works. Let's see.
01:06:09.006 - 01:06:35.920, Speaker B: It's always fun when we actually try and do the live coding stuff. So zero two, is that what it's called? Create and fun sub. Yes, that's right. Thank you, AI. Okay, let me increase the size of this view and see what's going on. Must be initializing. That must be what it's doing at the moment because it hasn't even hit the first comment yet.
01:06:35.920 - 01:06:53.426, Speaker B: 0718 created. Now I'm going to take a note of that. Guys, remember the notepad? Take a note of that. Now it has this one as the consumer. Is that it ends with five. Five F 54.
01:06:53.528 - 01:06:53.842, Speaker A: Yeah.
01:06:53.896 - 01:07:02.022, Speaker B: Excellent. It has my contract, seven one funded with 3.3 link. Awesome. So all three steps appear to have worked, which is really good.
01:07:02.156 - 01:07:08.650, Speaker A: All right, great.
01:07:08.800 - 01:07:25.554, Speaker B: Now let me just go here to functions chain link Mumbai and refresh the subscriptions page. There we go. We have a new subscription, seven on eight. It's showing up. And if I click on it. Yes, it tells me that's me, that's my wallet address. It has 3.3
01:07:25.554 - 01:07:34.882, Speaker B: link and it has a consumer that's been added, which is the same address that we deployed. Perfect. This is good, guys. Good. Yeah. Thank you, Dev Austin. Thank you.
01:07:34.882 - 01:07:57.050, Speaker B: Doing great so far. Hey, don't jinx it, man. Don't speak too soon. You know how these things are at live coding. All right, let me push this up for you guys. Origin Main.
01:07:57.120 - 01:07:59.020, Speaker A: Perfect. Let's see.
01:07:59.890 - 01:08:03.840, Speaker B: There's no reason why it shouldn't have been pushed up, not yet.
01:08:05.330 - 01:08:05.838, Speaker A: Okay.
01:08:05.924 - 01:08:11.600, Speaker B: Should have been pushed up. Yeah. There we go. So you've got number two here as.
01:08:12.770 - 01:08:13.434, Speaker A: Right.
01:08:13.572 - 01:08:25.540, Speaker B: All right, let's keep going. We've done the second one. Now, the third step is to actually handle the API secrets, which are we're going to need.
01:08:27.110 - 01:08:30.466, Speaker A: So keep in mind the RPC URL.
01:08:30.498 - 01:08:45.206, Speaker B: Is needed for our wallet and for our provider to run to connect to the blockchain from our local machine. The private key is for us to sign transactions so we can interact with the blockchain from our local machine. The only thing our source needs, if you remember source, there's only one secret.
01:08:45.318 - 01:08:46.762, Speaker A: Which is the API key.
01:08:46.896 - 01:08:55.022, Speaker B: So the only secret we need to send as part of this step is that one, the GPT API key.
01:08:55.076 - 01:08:55.342, Speaker A: Okay?
01:08:55.396 - 01:09:44.974, Speaker B: So just keep that in mind for this step because this is what secrets are needed by our custom source code that's being executed in a decentralized way. That's the secret we're talking about here, not all the dev environment variable stuff that we need to actually write code with. Okay, so next step, new file, three underscore secrets Js. And what I'm going to do, guys, I'm just going to copy and paste a bunch of the import so that we don't have to worry about that. And I have some of them snippeted here for my convenience. Okay, so this time we're going to use secrets manager, which is this guy that helps us manage secrets. Okay, we're going to use secrets manager, I may not use these right now.
01:09:44.974 - 01:10:10.918, Speaker B: Let me see, because I'm mindful of time. We have the signer, the networks, that's fine. We're importing that from the toolkit. Now this, guys, is the envenc package, which helps us read the contents of the envenc encrypted file here. Right? So that's our alternative to the end config. You can of course use it, that's why I've commented it out here. But for the purpose of this demo, I'm going to show you how to use encrypted secrets at rest.
01:10:10.918 - 01:10:17.026, Speaker B: And so you require it up here, much like you would with n. And off you go. And so now it's injected into your script.
01:10:17.058 - 01:10:17.302, Speaker A: Okay.
01:10:17.356 - 01:10:48.338, Speaker B: And network Polygon Mumbai, you've seen that before. All right, so now the first thing we want to do is const. We want to write encrypt and upload secrets. That's the step that we're going to do want to, in this demo, like I said, we can actually send it up to a GitHub gist or something. But then you need GitHub API credentials and things. I haven't bothered with all of that. I'm just going to send it up to the dawn this time because then we don't need separate API credentials from GitHub or s three or any of those.
01:10:48.338 - 01:11:11.082, Speaker B: And you can also see how you can actually store it securely on the dawn. Okay, so this is an async function. We're going to do something here and then. So we're going to just call this and. Yeah, we want to do that. And then we want to do console log error and uploading secrets. And what is the actual error? Well, that's what hopefully will not happen.
01:11:11.082 - 01:11:13.740, Speaker B: And hopefully we'll never see that message. And.
01:11:15.470 - 01:11:16.938, Speaker A: No, that was not what I.
01:11:16.944 - 01:11:33.202, Speaker B: Meant to do there. That was what I meant to do. Now let's start implementing this actual function. So the first thing we need to do is initialize and create a secrets manager, which you will see what happened here. That's why we need to create a secrets manager here.
01:11:33.256 - 01:11:33.860, Speaker A: Right.
01:11:34.550 - 01:11:52.258, Speaker B: So let me just copy this code. Makes it faster. So we got the secrets manager. It's going to send the signer the don ID. This time it's a string because we're not actually sending it to. We're not actually initializing a smart contract which needed the bytes 32. This is a string.
01:11:52.258 - 01:12:02.806, Speaker B: So we know the drill here. We just got to pull these values off. So let's start with functions, router address. There we go. Thank you. Helpful AI. You disappeared.
01:12:02.806 - 01:12:20.574, Speaker B: There you go. And yes, it's called functions router. So that's fine. So this is correct. And then we want to do const. Don ID is equal to networks. That sounds right because I think it is called Don ID, isn't it? Yeah, it is.
01:12:20.574 - 01:12:32.980, Speaker B: Perfect. So we've got those two values there. Now this secrets manager is now happy. It's got what it needs, except it needs to be initialized just like subscription manager did. So we initialize it there.
01:12:34.390 - 01:12:34.866, Speaker A: All right.
01:12:34.888 - 01:12:47.320, Speaker B: And the next thing we want to do is I want to actually start using the GPT API key, right? But to use secrets you need to create an object of secrets, right? So you need to create an object that looks like this.
01:12:47.930 - 01:12:49.142, Speaker A: You need to give it a key.
01:12:49.196 - 01:13:04.286, Speaker B: And the actual secret value. Now the key has to be what we used in our source, right? So the secret object is going to look for a key called API key. So we need to make sure our object has a key called API key and then we give it the value. So let's construct an object and see.
01:13:04.308 - 01:13:04.926, Speaker A: What that looks like.
01:13:04.948 - 01:13:31.830, Speaker B: So we're just going to say, well, secrets is going to be an object. It's going to have the API key requirement because hey, that's what secrets is going to be, an object that has an API key and that's the value it's going to look for. So we give it the API key and we're going to say, yeah, this is going to be whatever we put in our process env and I think, what did I call mine?
01:13:33.770 - 01:13:35.174, Speaker A: GPT API key.
01:13:35.212 - 01:13:41.258, Speaker B: So let's just call it that API key.
01:13:41.344 - 01:13:41.834, Speaker A: Right?
01:13:41.952 - 01:14:14.050, Speaker B: And so that's what our secrets object will end up looking like. You know what I'm going to do just to help debug it, I'm going to say if there's no process env GPT API key, please throw an error. That way we'll know if that's what's happened. Okay, so let's do that. That way we'll know if there's a problem with the secrets. Okay, now we've created a secret object. What do we need to do? We need to actually encrypt it.
01:14:14.050 - 01:14:50.830, Speaker B: The next step is to encrypt this using the dawn public key. So this is not for local storage, but this is to send up to the Dom. We need to encrypt it. So secretsmanager encrypt secrets is what we want to do and we want to pass it the secrets object. Now this is an async function, so we want to await the results and we're going to get something called the secrets. Let me be super descriptive, encrypted secrets object. Okay, so this is going to return an object.
01:14:50.830 - 01:15:11.174, Speaker B: In fact, you'll see this, we've used the same logic. Here you go. So we encrypt the secrets and we get back some sort of object. Okay, so let's just call it encrypted secrets object. Right. What happens next? Now that we've encrypted, we need to actually get ready to upload it.
01:15:11.212 - 01:15:15.494, Speaker A: Right. So you know what, let's just do.
01:15:15.532 - 01:15:29.130, Speaker B: This and see what happens. Encrypted secrets object. I mean, I'm going to change my API keys anyway, but I'm pretty sure this is going to be encrypted. But I just want to make sure this bit works. So let's just call it node scripts.
01:15:30.990 - 01:15:32.330, Speaker A: Node scripts.
01:15:35.650 - 01:15:46.890, Speaker B: Is that what it's called? Yeah. So it's going to try and do some cool things and encrypt it with the Don public key and all of that because there you go. So that's what it looks like. That's what the encrypted secrets look like.
01:15:46.900 - 01:15:47.186, Speaker A: Oh yeah.
01:15:47.208 - 01:16:00.742, Speaker B: Here you go. It is an object. Hang on, let me make this easier for you. It is an object. You can see the starting curly braces there and the ending curly braces there. And the object has one property called encrypted secrets, and that's the GPT API key, just encrypted form.
01:16:00.796 - 01:16:00.966, Speaker A: Right.
01:16:00.988 - 01:16:19.260, Speaker B: And we're going to send that to the decentralized oracle network. Okay, so far so good. So I'm going to delete that console log because it's going to fill up the terminal. Let me close that out. So we've got a secrets object. It had the property on it called encrypted secrets on it.
01:16:20.610 - 01:16:21.118, Speaker A: Right.
01:16:21.204 - 01:16:43.650, Speaker B: What do we want to try and do? We want to try and do an upload function now. So we have secrets manager and I think the documentation is here. We encrypt the secrets. We got the secrets object here. This is what we want to do. Let me just copy and paste that. We want to upload the secrets to the dawn.
01:16:43.650 - 01:17:09.606, Speaker B: So pasted that in here. I have a to do highlighter. That's why it looks like that. And so we have the encrypted secret hex string, which is we take the encrypted secrets object, take the encrypted secrets property from it, which is the whole hex string that filled our console a moment ago. Now we need to send it some gateway URLs. Okay, so that means we need to define gateway URLs. So let's do gateway URLs.
01:17:09.606 - 01:17:31.726, Speaker B: We want to use the same property name as that just to be sure. And we want to do. Hang on, it's in network. So there we go. Gateway URLs is there. So we know what we need to do here, don't we guys? So what do we do here? We just basically pull it off there. We say networks, network and gateway URLs.
01:17:31.726 - 01:17:46.478, Speaker B: Perfect. And then we can just delete this line, just put a comma at the end so it just passes in the value that way. And we need a slot ID. So because we're storing on the decentralized oracle network, we need to give it a slot ID. Right. A memory slot. So I'm just going to.
01:17:46.478 - 01:17:55.420, Speaker B: Do, you know what? I'm just going to do zero. Let me actually define it as a variable so it can be easily read and understood by you guys.
01:17:56.750 - 01:18:01.280, Speaker A: Const. And I'm just going to do zero.
01:18:03.330 - 01:18:11.082, Speaker B: Okay, get rid of that line there we have the slot ID being used now. Minutes until expiration.
01:18:11.146 - 01:18:11.374, Speaker A: Right.
01:18:11.412 - 01:18:29.398, Speaker B: So we want the secrets to be expiring after a certain amount of time so we can keep cycling through them and rotating them. So for the purpose of the demo, I'm going to do about another 70 minutes. Okay, let's just do 75 minutes. So I'm just going to do const. Minutes until expiration. Thank you, AI. I'll just do 75 minutes.
01:18:29.484 - 01:18:29.974, Speaker A: Okay.
01:18:30.092 - 01:18:32.294, Speaker B: And then I'm going to do that.
01:18:32.332 - 01:18:32.486, Speaker A: Out.
01:18:32.508 - 01:19:03.566, Speaker B: So now we have all the configuration that we need to upload secrets, the encrypted secrets to the dawn. Okay. And then we get two values, we get a success boolean and we get a version number. We'll need to take a note of the version number in a moment. So here's what we're going to do. If there's a successful outcome, which I really hope there is, do console log uploaded secrets to dawn. Okay, so that's what we're hoping to see to start with.
01:19:03.566 - 01:19:15.640, Speaker B: And then we want to do is remember that we need to pass a secrets reference, a reference to the smart contract saying, hey, this is where the encrypted secrets sit. Now for that, if you see here.
01:19:16.250 - 01:19:19.698, Speaker A: In the documentation, it says the secrets.
01:19:19.714 - 01:19:25.734, Speaker B: Manager build Don hosted's encrypted secrets reference, super descriptive name, but not much doubt as to what it does.
01:19:25.772 - 01:19:26.070, Speaker A: Right?
01:19:26.140 - 01:19:32.920, Speaker B: So let's do that. So we do secretsmanager build Don.
01:19:34.750 - 01:19:36.426, Speaker A: Oh, there you go. Right.
01:19:36.528 - 01:19:44.074, Speaker B: And we pass it an object that has the slot id for the encrypted secrets that we've already uploaded and the version.
01:19:44.122 - 01:19:47.902, Speaker A: Right. So that's basically this piece of data.
01:19:47.956 - 01:19:56.290, Speaker B: And this piece of data. And that's enough for the secret manager package or the helper to basically give us a reference. And so we give this a name.
01:19:56.360 - 01:20:01.810, Speaker A: Encrypted secrets reference.
01:20:03.510 - 01:20:24.410, Speaker B: Is equal to. It's not an async function that I think. Yeah, I'm pretty sure it's not an async function. And so you have the encrypted secrets reference now. Right, and now we need to make a note of that, guys. That's another thing we add to our little notepad. We'll say, encrypted, make a note of the encrypted secrets reference.
01:20:24.410 - 01:20:49.454, Speaker B: Sorry, wrong paste. There we go. Which is encrypted secrets reference. All right, now, I think this may actually be the moment of reckoning. Always a slightly nervous moment as you get into more and more complicated stuff. But let's quickly recap. What have we done here? Right, the goal here is to encrypt the secrets.
01:20:49.582 - 01:20:50.626, Speaker A: And the only one that we need.
01:20:50.648 - 01:21:00.054, Speaker B: In our source JS is API Key, is the chat GPD API key. So we create a secrets object with that value. We then encrypt it.
01:21:00.252 - 01:21:00.854, Speaker A: Right.
01:21:00.972 - 01:21:03.766, Speaker B: It's only the encrypted values that go on chain. So that way no one can actually.
01:21:03.788 - 01:21:06.006, Speaker A: Use it without the private keys, and.
01:21:06.028 - 01:21:33.600, Speaker B: We send it up using upload encrypted secrets to dawn, give it the necessary parameters it needs without including our secrets object, which has a property of encrypted secrets on it. We send that up. Assuming it's successful, we then generate a reference to that uploaded secrets that's sitting on the dawn. And then we need to take a note of that. Yeah, we need to take a note of that reference. Okay, let's just see what happens. Let's just see what happens, guys.
01:21:33.600 - 01:21:52.886, Speaker B: So, node scripts, what script number is this? Zero, three. Oh, yeah, we just ran it to check out the secrets update. Let me for a moment and see how we go. Moment of reckoning. Oh, yeah. Spiel crypto. I don't blame you, man.
01:21:52.886 - 01:22:09.100, Speaker B: 100 and 20:00 a.m. Is pretty late. Oh, yeah. All right, so it worked. So we managed to upload the secrets to dawn, and we got an encrypted secrets reference. I'm going to copy that and I'm going to store it here. And I'm going to be very clear that this is a secrets ref because I don't want to confuse it with the contract address or something.
01:22:10.210 - 01:22:10.862, Speaker A: Good.
01:22:10.996 - 01:22:18.270, Speaker B: So far so good. Okay, let me upload this git status. Git add, git, commit.
01:22:19.970 - 01:22:20.622, Speaker A: Really?
01:22:20.756 - 01:22:25.300, Speaker B: No, sorry, that's not it. I'm actually having trouble seeing this because of that banner at the bottom.
01:22:27.110 - 01:22:30.130, Speaker A: Three. Done. And the commit.
01:22:30.630 - 01:22:32.740, Speaker B: Hit push. Origin main.
01:22:33.990 - 01:22:34.498, Speaker A: Yeah.
01:22:34.584 - 01:22:49.190, Speaker B: Who is right? Pass me that white claw. No, don't get me started. We still got some ways to go. I'm having difficulty looking at the screen already with all the stuff in it. Do not give me a white claw right now. All right, let's see if it's actually been uploaded.
01:22:50.090 - 01:22:50.562, Speaker A: Yeah.
01:22:50.636 - 01:23:03.830, Speaker B: Three is there for you guys as well. Guys, if you want to pull down, let's go. All right. So far so good. So far so good. Let me just clean up the screen a bit. Now, the next step is the moment of truth.
01:23:03.830 - 01:23:09.574, Speaker B: Because I know Muradif has been hanging for this all year, is to actually make the functions request.
01:23:09.622 - 01:23:09.834, Speaker A: Okay?
01:23:09.872 - 01:23:11.650, Speaker B: So let's do that in script four.
01:23:11.840 - 01:23:12.530, Speaker A: It.
01:23:12.680 - 01:23:54.926, Speaker B: All right, let's just call it request JS because that's what it is. All right, so for request JS, again, I'm going to show you how to construct the request. But just to quickly recap for you guys functions consumer, that's all request needs to basically send in because of the way I've designed the contract. And you need to send in the request needed to build a request object, right, to build this thing successfully. So if you look at the reference document here on line 51, you'll know what I mean if you need to understand that fully. But our contract as it currently stands, needs what is 123-4567 pieces of data. Well, really six, because we're going to pass in an empty array for that.
01:23:54.926 - 01:24:21.720, Speaker B: So really six pieces of data. And that's the goal of this step. We need to put together these six pieces of data to send to our send request function. Okay, so again, I'm just going to pull in a bunch of imports so that you guys aren't seeing me type imports, which is probably not the fun part to watch. And of course, if you want, I'll paste this in here as well. But if you want, you can also use that n if that's what you're using. But we're going to use Enc as you talked about.
01:24:21.720 - 01:24:37.850, Speaker B: Okay, now this is where we need stuff like our consumer contract address, the subscription Id, the encrypted secrets reference that we got in the previous step. You see how I'm building it all up. I got you guys. I got you. All right, let's do this. Send request. Send request is an async function.
01:24:37.850 - 01:25:14.246, Speaker B: And again, I'm showing you this. There are ways to do this a little bit faster and cleaner, perhaps, if you like, with hard ad tasks or scripts. But the reason I'm breaking it down for you this way is so that each step is its own script and you can build the mental models. You just need to look at a script to understand what's actually going on there. And that way, I believe it's going to be much easier for you guys to reason about the code to know how this functions toolkit package, which is by the way, super powerful because it's abstracted all the stuff away for you, right. You can see like literally six lines of code in each script and you're getting everything done. Okay, so that's the point is to show you how to use the functions toolkit package and how functions works with it.
01:25:14.246 - 01:25:36.430, Speaker B: Now let's do the send request and then it's AI. Why aren't you helping me out? Catch. Okay, yep, that's fine. We want to do, is this error taking the functions request.
01:25:38.210 - 01:25:39.120, Speaker A: All right.
01:25:42.450 - 01:26:06.578, Speaker B: Dev Austin, that's still the case. So that's kind of part of the reason why. Okay, long story short, that's part of the reason why I've said 15 words or less. You're right that there's a 256 byte not bit, I think. But if you go to the, let me show this to you guys while I'm here. What did I close out the functions documents? Okay, let me go. If you go to function DevOps.
01:26:06.578 - 01:26:39.620, Speaker B: And this is to answer your question, right. If you go to service limits currently, you will see that it's a 256 byte maximum return size, right? So not bit. Now you can request an increase to this for your use case, but I argue that a lot of the use cases, usually you may not need. Why would you want to send that much data on chain, right? It's kind of expensive to store all that stuff on chain. So there are ways to design your way around that. But in theory, these service limits can be increased by making a request. Hope that answers your question, my man.
01:26:39.620 - 01:26:51.110, Speaker B: All right, let me, fine, let's get back, let's get back to sending the request. So where were we? We've got the basic scaffolding put out. Okay.
01:26:51.180 - 01:26:55.606, Speaker A: Now we want to make sure we.
01:26:55.628 - 01:27:24.500, Speaker B: Need to request something from the consumer contract address, right? So let's just get a reference to that. So we want to do new contract because we're using ethers Js. Send it the consumer address which we need to define now we want to give it an ABI and we want to give it a signer which is going to be us. Yeah. So what is this actually?
01:27:25.430 - 01:27:26.414, Speaker A: Okay, so contract.
01:27:26.462 - 01:27:28.194, Speaker B: We've got the import. I was wondering how that's actually.
01:27:28.232 - 01:27:28.386, Speaker A: Okay.
01:27:28.408 - 01:27:29.890, Speaker B: I forgot I put the imports there.
01:27:29.960 - 01:27:30.194, Speaker A: Right.
01:27:30.232 - 01:27:44.758, Speaker B: So here's the function. Consumer contract. Okay. We need to define consumer address. So let's do that. Post is not going to get very far.
01:27:44.924 - 01:27:45.446, Speaker A: There we go.
01:27:45.468 - 01:27:51.660, Speaker B: Here's the consumer contract address. No, give it a string. There we go. So we have the consumer address ready.
01:27:52.350 - 01:27:57.034, Speaker A: And we actually need to actually, yeah.
01:27:57.072 - 01:28:02.110, Speaker B: Okay. So what are we actually trying to do? We need to send the request. We need to send it all this data.
01:28:02.180 - 01:28:02.414, Speaker A: Right.
01:28:02.452 - 01:28:25.090, Speaker B: So let's try and just see how that would look. So we need to do await functions. Consumer send request is the name of the actual function and it needs to have all this data in it. So I'm just going to break line over there. So what does it need? It needs the source. It needs the secrets location. So we're going to do source.
01:28:25.090 - 01:28:46.886, Speaker B: Oh well we need to read the source file, don't we? That's what we need to do. Okay, so that's fine. I'll do that in a moment. I'll show you guys how to do that. We need to send it a variable called source which has the entire source code. We need to tell it that the secrets location is actually in the dawn. So I've imported this thing called location here from the functions toolkit.
01:28:46.886 - 01:29:08.130, Speaker B: So you can go location dawn hosted. There we go. So that's the second value done. And then the third one is an arguments array subscription ID and callback estimate. Okay, so we need to do args. We need to do empty bytes args which we're not using. We're going to do, and I'm going to just say bytes args.
01:29:14.070 - 01:29:14.818, Speaker A: This one.
01:29:14.904 - 01:29:26.406, Speaker B: If you ever want to send in arguments as bytes instead of the actual strings, you can do that way. And the next thing that we need to do is pass the subscription ID. That's what it wants, right?
01:29:26.508 - 01:29:26.774, Speaker A: Yeah.
01:29:26.812 - 01:29:42.414, Speaker B: And then the callback gas limit. And then callback gas limit. So we need to actually define all these things. Let's start with source. That's why I needed the file system. Of course. All right, so we read source like this.
01:29:42.414 - 01:29:49.182, Speaker B: We go Const, source is equal to Fs, read file sync and we're going to have to pass it.
01:29:49.236 - 01:29:49.870, Speaker A: Whoa.
01:29:51.090 - 01:30:17.530, Speaker B: All these autocomplete AI. Stop for a moment. Thank you. We want to resolve the path that is from our current, the current directory we're in, which is in the scripts directory, and we want to say, well, source is actually in the root of the project. So we want to go back one level and then we want to go source Js.
01:30:20.590 - 01:30:23.162, Speaker A: Yeah, we can take that out. That's optional. That's fine.
01:30:23.296 - 01:30:48.500, Speaker B: What's going on here? What's all these things? No, there we go. All right, so we're reading file, we're saying, okay, this is the path to source Js. This is what we actually want to read the source code. We want to actually pull it out and make it a string. Oh, that's right. If you want to make it a string, I got to go to string. There we go, that looks better.
01:30:48.500 - 01:31:01.430, Speaker B: That's source. That's the first argument we're going to pass in. What's the second one? Location Don Hostel. We've already passed that in because that's an enum. The third one is Args. Okay, so let's build the Args thing now. Args, you remember guys, is the prompt.
01:31:02.730 - 01:31:14.874, Speaker A: So you know what, let's just do this. That's the prompt we had already.
01:31:14.912 - 01:31:51.394, Speaker B: I showed you this in the playground, actually. Let me make it even easier for you guys, especially those of you who are sort of relatively new. And then we just say, here you go, here's an array with one argument in it and the argument is prompt. Okay, and now the last, well, subscription ID, right, so we have that here, my subscription ID, seven one eight, which I've just created. So I'm just going to do const, subscription ID is equal to. And this can be a string, that's fine, pass that in. And now callback gas limit is the last thing we want.
01:31:51.394 - 01:32:21.082, Speaker B: Callback gas limit. And we can just do 300,000 for this in languages like JavaScript and Golang and I think in Python and stuff you can, instead of the comma, if you want to make the number easier to read, you can just put an underscore. So this is how I write it, 300,000. And now we have the send request as done. This is going to return to us a transaction. So let's just call it request transaction. We await that and then the next thing that we need to do is, well, we actually need to wait it properly.
01:32:21.082 - 01:32:47.542, Speaker B: So request transaction, wait, I'm going to wait for one block and this is going to be the ex receipt that we get here. And we're going to need that because we're going to have to actually look for the request hash and request ID. Now, the request ID is what gets returned here. We're also going to store it on chain.
01:32:47.606 - 01:32:47.834, Speaker A: Okay.
01:32:47.872 - 01:33:17.474, Speaker B: We're going to store it on chain. That's what we do here in this line 61 in the smart contract. But this send request will eventually emit a request ID and we want to try and read that. Now I happen to know how to do this because I've obviously looked at the contracts before, so just take my word for it. But I'm just going to type out the relevant code here for you. So request ID is equal to the transaction receipt correctly. And then it's got the events property on it.
01:33:17.474 - 01:33:27.766, Speaker B: And then it's going to be the second event that was emitted, or rather the third because that's indexed two, which is the third and it's the args. And then the ID property, which is the request ID.
01:33:27.868 - 01:33:28.374, Speaker A: Okay?
01:33:28.492 - 01:33:35.350, Speaker B: And now I want to just make sure that we have it correctly. So I'm going to do request.
01:33:37.930 - 01:33:38.738, Speaker A: Made.
01:33:38.924 - 01:34:08.766, Speaker B: Request ID is request ID and transaction hash is request hash. Okay. No hash. All right, so we're going to do some fun stuff here as well. Don't break the street. Oh, thank you, my friend. Thank you, Muradif.
01:34:08.766 - 01:34:17.478, Speaker B: Don't break the streak. I always forget to do this, it's so funny. And then it'll give me undefined errors. Thank you, Muradif. And I'm glad I checked, man. Thank you. You're right.
01:34:17.478 - 01:34:37.430, Speaker B: Thanks for don't break the streak. I love it. You're my guardian angel, man. I appreciate it. Okay, so what are we trying to do here? We're going to build a subscription request. Sorry, this functions request and we're going to send that request. It's going to send it the source that we've read straight out of the source JS file.
01:34:37.430 - 01:35:05.906, Speaker B: We're sending that adjusted string. We're going to send it a bunch of parameters. We're going to get a receipt, we're going to get a request ID, and then hopefully we're going to console that log that things are successful. And I'm going to show you something on chain. In fact, let's do that now before we run this because it may make debugging bit easier. So I'm going to take my contract and I'm going to go to Mumbai Polygon scan, which is the block explorer where my contract sits. Now the good thing is I've already verified this contract for you guys, so you'll see, there's a tick mark over there.
01:35:05.906 - 01:35:20.438, Speaker B: So this is the contract that I've just deployed and I'm going to go to the read contract. You can write contract if you want, but we don't need to. For this example, I'll just do the read contract. And now you will see that these are some of the values that we can already read from the smart contract.
01:35:20.534 - 01:35:23.322, Speaker A: This request ID is going to get.
01:35:23.376 - 01:35:31.494, Speaker B: Set here in line 61 when the request ID is fulfilled and we store it as an on chain storage variable. Okay, right now it'll be empty.
01:35:31.622 - 01:35:32.870, Speaker A: There you go, empty.
01:35:32.950 - 01:35:54.254, Speaker B: Okay. There's no response that's been had and there's no error because we haven't actually made the request yet. But if there is a request, you'll see when it fulfills, we store both the error. It's going to be either or, okay. If response exists, error will be an empty bytes. If error exists, response is going to be an empty bytes. Okay, right now on chain, there's been none.
01:35:54.254 - 01:36:06.600, Speaker B: So we're going to see that both last request, sorry, last response is empty bytes and last error is empty bytes. Let me reset that. What we will expect when I run this script. Now, sorry, when I run script four.
01:36:06.970 - 01:36:08.246, Speaker A: In a couple of seconds, I would.
01:36:08.268 - 01:36:13.466, Speaker B: Expect request ID to show up and then either last error or last response to show up.
01:36:13.488 - 01:36:14.010, Speaker A: Okay?
01:36:14.160 - 01:36:25.054, Speaker B: So this is the moment of reckoning. And then there's a way for me to read the response also, and I'll show you the script for that because you can do that using the NPM package that I've talked about.
01:36:25.092 - 01:36:25.246, Speaker A: Right.
01:36:25.268 - 01:36:49.190, Speaker B: The function toolkit package. Okay, so let's try and do you know what? I may just want to make this a little bit easier for me to debug just in case I don't have any of the information I need in my script. So let me just do, if there's no consumer address, which I know that's not true, or there's no encrypted secrets reference. Aha, see, there is something missing.
01:36:51.930 - 01:36:52.710, Speaker A: Um.
01:36:55.850 - 01:36:58.022, Speaker B: And there's no subscription ID.
01:36:58.076 - 01:36:58.366, Speaker A: Yep.
01:36:58.418 - 01:37:11.500, Speaker B: Then I want you to throw me an error. Throw error missing. Yeah, please check.
01:37:14.050 - 01:37:15.406, Speaker A: That's what's missing right now.
01:37:15.428 - 01:37:46.710, Speaker B: The thing is, the encrypted secrets reference is being passed here, isn't. Oh no, I missed it all together. See, we missed it. There we go. Right after secrets location, I need to put encrypted secrets reference. Let's just call it that. I'm going to define it here, put it up here, and I'm going to take it from the notes that I had from the previous step, and I'm going to put it in here.
01:37:46.780 - 01:37:49.298, Speaker A: So where is it?
01:37:49.324 - 01:37:50.140, Speaker B: There is.
01:37:50.830 - 01:37:51.194, Speaker A: Great.
01:37:51.232 - 01:37:57.798, Speaker B: I'm glad I added that step because now if any of these three bits of information that I need are missing, it'll throw an error.
01:37:57.974 - 01:37:58.662, Speaker A: Excellent.
01:37:58.726 - 01:38:16.020, Speaker B: Yeah, that was close. Exactly, Meredith. Exactly. This is why I like doing throwing errors during debugging and stuff, because helpful errors will tell you where to look for the answer. So hey, let's not speak too soon. I could still have made some errors, which is the joy of live coding. That's part of dev life, right? Always making little mistakes and then fixing them up.
01:38:16.020 - 01:38:33.960, Speaker B: All right, let me expand this up a bit for you guys. What are we expecting to see here? We were expecting to see, have I actually put any.
01:38:34.570 - 01:38:35.270, Speaker A: No.
01:38:35.420 - 01:38:50.538, Speaker B: Let me put some helpful comments so we can actually see what's going on. Send me the request and then request made. Okay, so now we should know which stage it's at.
01:38:50.624 - 01:38:51.046, Speaker A: Woohoo.
01:38:51.078 - 01:38:52.510, Speaker B: Here we go. Sending the request.
01:38:54.050 - 01:38:59.134, Speaker A: Tick dock, tick dock. Tick tuck. Tick, tick. Come on, let's go, let's go, let's go.
01:38:59.172 - 01:38:59.870, Speaker B: Chain link function.
01:38:59.940 - 01:39:00.800, Speaker A: Let's go.
01:39:05.590 - 01:39:16.582, Speaker B: Could take some time. That's fine. Also think my network may be a bit slow. So what are the steps that it's going to go through? It's going to construct the request send.
01:39:16.636 - 01:39:21.382, Speaker A: It actually should have added a check.
01:39:21.436 - 01:39:43.222, Speaker B: On whether or not the source is actually there. It's not usually this close. So I'm thinking there's something wrong with my network because I noticed that last time also was giving me a bit of trouble. There we go. Could also just be network spikes. Right. Okay, so I've got a request ID from the transaction stand.
01:39:43.222 - 01:39:50.250, Speaker B: Okay, so that's my request ID. What is it? Zero X 59179. Okay, so let's go back here.
01:39:50.400 - 01:39:52.458, Speaker A: I'm going to reset and I'm going.
01:39:52.464 - 01:40:04.320, Speaker B: To see if there's a request ID. Oh yeah, here we go. Let me zoom that into you guys. 59179 for one. So that's the same request ID here. That's good.
01:40:05.990 - 01:40:14.114, Speaker A: Now keep in mind moment of suspense that what gets sent back here, the.
01:40:14.152 - 01:40:26.226, Speaker B: Response and the error are all bytes, so we should be seeing hex codes. If I look at last response, if it succeeded, if the request failed, and it may do, and I'll show you how to debug that, then last error.
01:40:26.258 - 01:40:27.586, Speaker A: Will have a response.
01:40:27.778 - 01:40:36.060, Speaker B: Last error is empty, so that's positive. Last response is also empty, which means I have no idea what's going on. So let's just take a look at that in a moment.
01:40:39.550 - 01:40:42.780, Speaker A: Oh actually this can sometimes happen.
01:40:45.790 - 01:41:16.866, Speaker B: Aha. I had to refresh the page. See, never ever assume that things are going wrong. Things are always going, no, I'm just kidding, assume things are going wrong. So last request ID is still the same last error, there's none, but we have a successful response. All we know at this point in time is that the functions was executed, the source Js file was executed by the decentralized oracle network and some response was sent back. The actual execution did not fail, but the request to the API may have failed.
01:41:16.898 - 01:41:17.094, Speaker A: Right?
01:41:17.132 - 01:41:46.350, Speaker B: That's possible. So that's what we'll know in the last response thing, and I mean the open AI response. Now this is bytes. So guys, good trick. For those of you aren't familiar if you go to hexadecimal to string converter you'll see I use rapid tables but if you just google it you can, oh sorry, this is to decimal, I wanted hex string converter, I use code beautify for that. Now if I paste, what have I done here? I've just pasted this bytes value here, right, there you go, woohoo. That's the result.
01:41:46.350 - 01:42:15.014, Speaker B: This is the converted string. This has actually come through chainlink functions, gone through the decentralized oracle network and then come back into our smart contract. And it's been saved in our smart contract in the s underscore last response storage variable. We've just decoded that from hex to string and it's the same answer that open API gave us here. The blockchain oracle is a trusted external source that provides data to a blockchain network. Oh, it's actually not even the same, it's a slightly different answer. There you go.
01:42:15.014 - 01:42:28.622, Speaker B: So now you know it's real, which is perfect. So all of this decentralized trust minimize and it's come back. Now I know we've got about minutes left, so I want to do one more script and then I want to run you through a couple of things, okay.
01:42:28.756 - 01:42:29.678, Speaker A: In fact I'm going to try and.
01:42:29.684 - 01:43:12.730, Speaker B: Do two scripts if I can. So let's try and make this a little bit faster. The first thing I want to do is a read response script for you, okay, so I'm going to do new file five read response. So this is how you can read the response directly on programmatically. Okay, and so for that, again I'm going to do the usual thing. Let me try and pull out the usual suspect imports and then I'm going to do const read response is an async function that returns a promise of some sort. And then I'm going to do read response, catch error reading response.
01:43:12.730 - 01:43:45.750, Speaker B: Then we go error, close that and we close that. Okay, now let's actually implement our read response. So what we're going to do is, again, we're going to try and get hold of the contract. So I'm going to try and just copy the code from here, from the request file because that's what we need to do. We need the consumer address. So const consumer address is equal to I take it from my notes file.
01:43:50.810 - 01:43:51.880, Speaker A: There we go.
01:43:53.690 - 01:43:56.490, Speaker B: So I have Abi, I have signer, I have consumer address.
01:43:56.560 - 01:43:56.842, Speaker A: Great.
01:43:56.896 - 01:44:06.330, Speaker B: So we have the consumer contract, now we have a reference to it and I want to get the await functions consumer.
01:44:10.050 - 01:44:11.230, Speaker A: Response.
01:44:12.050 - 01:44:27.140, Speaker B: You can also do last error or whatever you want. And this is going to be the bytes. Response bytes. Okay, actually let's just call it response bytes. Now once we get that.
01:44:29.930 - 01:44:30.438, Speaker A: That'S going.
01:44:30.444 - 01:44:59.630, Speaker B: To be the bytes. So I'm just going to do a print of that response bytes. So just so we can track what's going on on our console. Now what I want to do is I want to try and decode that result. So the functions toolkit exposes this helper to decode the result and you need to pass it the return type. Okay, so here's how it works. So we do decode result, which is that imported function, and we do response bytes.
01:44:59.630 - 01:45:21.160, Speaker B: Return type. Yeah, it's a string return type. String. Now make sure it's lowercase because that's what the enum is. It's defined as a lowercase. Okay, and I'm going to say decoded response is this. And now I'm going to say.
01:45:22.970 - 01:45:23.634, Speaker A: Console.
01:45:23.682 - 01:45:31.910, Speaker B: Log decoded response from OpenAI chatgpt.
01:45:34.730 - 01:45:35.094, Speaker A: Put.
01:45:35.132 - 01:46:00.226, Speaker B: This stuff on new line just so that breaks it up in the terminal. And we want to do decoded response. Okay, so that's how you read values. You literally, just because it's in bytes, you can decode it. So you can read obviously using the ethers Js library, but you can decode using the helper function here. So let's try and test run that node five. Is that what this is?
01:46:00.248 - 01:46:00.578, Speaker A: Yes.
01:46:00.664 - 01:46:14.358, Speaker B: Let's see what happens. It should first print out the bytes. Oh, and there we go. I forgot to put a column there. But really, here's the response. A decentralized digital ledger that records transactions. Okay, good.
01:46:14.358 - 01:46:21.370, Speaker B: Is that the same as what we've got here on chain yep, exactly what it is. So that's how you read responses. Okay, awesome.
01:46:21.440 - 01:46:22.166, Speaker A: Hey, thanks, Sean.
01:46:22.198 - 01:46:42.910, Speaker B: That's super kind of you, man. I appreciate. Okay, so now there's one last cool tool I want to show you. We'll actually script it out. Then there's some more tools that I can point you to in the NPM package. But here's what we're going to do. I'm going to mount a listener on chain.
01:46:43.410 - 01:46:44.494, Speaker A: Then I'm going to send a new.
01:46:44.532 - 01:46:50.654, Speaker B: Request and when that request fulfills, the listener will tell us. This is the response we got.
01:46:50.692 - 01:46:50.990, Speaker A: Okay?
01:46:51.060 - 01:47:03.734, Speaker B: A little bit more ambitious. The kind of thing you want to do with 15 minutes to go, right? Makes perfect sense. I'm a sucker for punishment, but let's do this. Let's do this, guys. Yeah. Murdiff. Hey, it's chat GPT, okay? There's only so much you can expect.
01:47:03.734 - 01:47:11.222, Speaker B: It's not always going to get it right. At least it's replying to us. I'm happy for the smaller things. Right, but yeah, fair point.
01:47:11.356 - 01:47:14.838, Speaker A: Okay, so the next thing that I.
01:47:14.844 - 01:47:50.040, Speaker B: Want to do is, and I'm going to not put this in the scripts folder, what I'm going to do is I'm just going to do it right near source in the root of the project. I'm going to do listen Js, okay? And I'll tell you why I'm going to do that in a moment. It's because I want to run it using notamon. I just want to do an NPM script for it in a moment and I'll show you what we do. Okay, so I'm going to just do the imports again so that you don't have to worry about doing that and not wasting time on that by typing all that out. And I'm going to do the network polygon Mumbai as well because that's previous thing. We've already done that.
01:47:50.040 - 01:48:00.514, Speaker B: Now what we're going to do is we're going to have to get the listener to start going. So there is a response listener.
01:48:00.562 - 01:48:02.650, Speaker A: Where is it? Is this it? No.
01:48:02.720 - 01:48:08.380, Speaker B: Yeah, this is it. So there's a response listener. You can see the documentation for the response listener here.
01:48:10.670 - 01:48:11.994, Speaker A: Where is it? Where is it?
01:48:12.032 - 01:48:42.806, Speaker B: Here you go. Functions. Response listener. Okay, that's where you can see the documentation for what I'm doing now. But here's what we're going to do. We've imported a response listener, so we're going to do Const. Response listener is equal to new response listener, which is that imported thing from the NPM package and we're going to have to give it a configuration object which is going to have a provider and functions router address because that's what it's going to be listening to.
01:48:42.806 - 01:48:53.722, Speaker B: The good thing is we now know where to get the functions router address. And yes, my AI is correct. We want to get it from functions router, right?
01:48:53.776 - 01:48:55.290, Speaker A: So that's correct.
01:48:55.360 - 01:49:00.122, Speaker B: Okay, so we provided this information. The next thing we want to do.
01:49:00.176 - 01:49:03.966, Speaker A: Is we want to just maybe say.
01:49:04.148 - 01:49:23.086, Speaker B: Listening, listening for request. Now you can actually do it by transaction hash or by request ID. You can look at the documentation. In this case we're going to do it by request ID. Okay, so now we do response listener.
01:49:23.278 - 01:49:24.930, Speaker A: And we actually mount it.
01:49:25.000 - 01:49:47.660, Speaker B: Listen for response, right, sorry, responses, I think is the right one. Listen for responses and we need to give it two bits of data. We need to give it the subscription ID and then we need a callback. Okay, so here's what I'm going to do. Subscription Id we have here, let me just get that right now.
01:49:48.110 - 01:49:49.500, Speaker A: Save it up here.
01:49:51.630 - 01:49:53.774, Speaker B: Oh no, not that one.
01:49:53.892 - 01:49:54.560, Speaker A: Here.
01:49:57.090 - 01:50:40.218, Speaker B: Const subscription ID is equal to could store it as a string, that's fine. And the callback will get, let me try and make this more brackety for people who are less familiar with all the fancy JavaScript syntax. We get a response in the callback and so what we're going to do is we're going to check if the response is an error first, if there is an error, if there's no response, error string is the property that gets returned by this. Then we're going to do a few things. That's why it's complaining. So if there's no error, we're going to do a few things, and otherwise, if there is an error, we're going.
01:50:40.224 - 01:50:42.858, Speaker A: To do handle that error, right?
01:50:42.944 - 01:50:44.118, Speaker B: And if there's an error, you're just.
01:50:44.144 - 01:50:55.678, Speaker A: Going to go, well, console log, there is error during functions execution, and then.
01:50:55.764 - 01:51:24.458, Speaker B: What is that error response error string is what gets returned from the listener. Now if there's no error string, we're going to do the console log and we're going to say functions response decodes to a string value off and we're going to do what we did from five the read response, we're going to.
01:51:24.464 - 01:51:28.860, Speaker A: Go decode result, we're going to use that.
01:51:33.150 - 01:51:36.350, Speaker B: We'Re going to use the response object and we're going to say response.
01:51:38.130 - 01:51:40.570, Speaker A: Bytes string.
01:51:40.730 - 01:51:43.214, Speaker B: That's what comes back. So what have we done here?
01:51:43.252 - 01:51:45.806, Speaker A: We mounted the listener, we're going to.
01:51:45.828 - 01:52:05.346, Speaker B: Start listening for response pass in the subscription id. So we start filtering for that. We get a response. If there's no error, we take the responses bytes hex string. Right. And let me make sure I've spelt that correctly from the documentation. And we know the return type is going to be a string.
01:52:05.346 - 01:52:37.890, Speaker B: So we decode that result and we console log it. Once we get that in the listener and if there's an error, we print out the error string that comes back with it. Okay, now I want this to unmount gracefully and it's also there in the document. But once we finish listening, we want to do listener. So we want to unmount the listener. So we do process Env on signal interrupt callback that we want to run on that. And we're going to do callback, removing.
01:52:38.470 - 01:52:39.410, Speaker A: Listeners.
01:52:41.430 - 01:52:45.314, Speaker B: And response listeners. What we've got there, isn't that what we've called it?
01:52:45.352 - 01:52:45.602, Speaker A: Yeah.
01:52:45.656 - 01:53:02.738, Speaker B: Response listener and we want to do stop listening for responses. Call that, close that out. Bob's your uncle. Okay, so what are we doing here? We're going to mount this listener. We're going to listen to the subscription Id that we've given it. Now we're going to make a request.
01:53:02.834 - 01:53:05.458, Speaker A: So did I do.
01:53:05.564 - 01:53:14.202, Speaker B: Thank you, Radif. You're the man. I love the way you're just paying such close attention to my code. And I really appreciate it.
01:53:14.256 - 01:53:17.014, Speaker A: Okay, let me try and increase.
01:53:17.062 - 01:53:36.782, Speaker B: So we're going to have to make the request from this terminal. So what I'm going to do is I'm going to just create a new, I'm just going to create a new terminal here and I'm going to rename it to listener. Now before we do that, what I want to do is, oh, no, I could just do this node listen Js.
01:53:36.846 - 01:53:40.254, Speaker A: Because it's in the root and it's not working.
01:53:40.312 - 01:53:40.920, Speaker B: Why?
01:53:41.530 - 01:53:42.258, Speaker A: Aha.
01:53:42.354 - 01:54:13.214, Speaker B: Good. I'm glad this error showed up. It's not going to be able to actually read my stuff until I do the set password. Remember I said the password needs to be set for every terminal session. So let me just clear that I need to set the password, stop screencasting for a moment, do my password, resume screencasting. All right. No, listen, John, let's hope it works now.
01:54:13.214 - 01:54:19.940, Speaker B: Okay, listening. So what are we expecting to happen? Well, it's listening. It's not going to do anything until I do the request again.
01:54:21.990 - 01:54:22.498, Speaker A: Four.
01:54:22.584 - 01:54:23.220, Speaker B: Yeah.
01:54:24.630 - 01:54:25.682, Speaker A: Oh boy.
01:54:25.816 - 01:54:49.354, Speaker B: Oh, and the tension is on. I'm breaking the cold sweat. Let's see. We should get a new request ID, assuming there's not much network sort of spikage going on, we'll have a new request ID and then we should see something come. Oh good, so we have a new request ID here. Let's see what's happening on the listener front. This could take a while, right? But while that's listening, let me just go over here, refresh this and read.
01:54:49.392 - 01:54:52.106, Speaker A: The new request ID and see if.
01:54:52.128 - 01:54:54.860, Speaker B: It'S the same FE 47.
01:54:56.290 - 01:54:57.246, Speaker A: Oh yeah, here we go.
01:54:57.268 - 01:55:18.274, Speaker B: So the listener came back. Functions, response decals to string value of blah blah blah. So good, it was successful guys. Yes, that's the same request Id. Perfect listener, mounted listener is very happy and it's listening. Okay, so that's how you add the listener as well. Now I know we've covered a lot.
01:55:18.392 - 01:55:20.340, Speaker A: But really what do we try to do here?
01:55:22.870 - 01:56:15.698, Speaker B: Let me go back to that. We created some custom JavaScript, we sent it to our smart contract along with all the other parameters and configuration we need that got sent to the decentralized Oracle network. The decentralized Oracle network took your custom JavaScript or our custom JavaScript, including the secrets API, spoke to the chat GPT API, got consensus on the result, sent it back on chain in the form of these response bytes that you can see here. Let's just copy that one again for fun. Do it in code, beautify, and there you go, it decodes to a string. So all of this with consensus in a trust minimize format, you can now basically connect to any API you like from your smart contract. All we did is put this little contract up here, right, and we send it some data, send it some parameters, and all of that happened with the trust minimization of the chainlink decentralized Oracle network.
01:56:15.698 - 01:56:30.966, Speaker B: All the benefits of the blockchain, but through the Oracle network, which technically runs both on chain and off chain. And all of this was made possible because of the way we abstracted out the functions toolkit. Sorry, all of this was made possible in these JavaScript scripts.
01:56:30.998 - 01:56:32.918, Speaker A: So if you look at this, you've.
01:56:32.934 - 01:56:48.174, Speaker B: Got what, 12345 scripts here and six to listen, and there's more you can do. So all of this broken down thanks to this functions toolkit package is a way for you to programmatically interact with chainlink functions. All of the documentation is there. So let me get back to my.
01:56:48.212 - 01:56:51.454, Speaker A: Presentation then on that bit.
01:56:51.492 - 01:56:54.370, Speaker B: We've written scripts for each thread. Oh, I haven't pushed the code, guys.
01:56:54.440 - 01:56:55.330, Speaker A: Haven'T pushed the code.
01:56:55.400 - 01:57:22.486, Speaker B: So let me do that very quickly so that you have all of that. Okay, so we have two things that we need to do. Git, add, git, push. Sorry. Git, add, git, commit. Do read response and listen. Push.
01:57:22.486 - 01:57:28.300, Speaker B: Origin main. That should now be pushed up here any second now.
01:57:28.910 - 01:57:29.334, Speaker A: Yes.
01:57:29.392 - 01:57:34.400, Speaker B: Four and five are there and so is listen. Perfect. So now you guys have all the code you.
01:57:37.570 - 01:57:38.846, Speaker A: Bit. That was quite a bit.
01:57:38.868 - 01:58:13.194, Speaker B: I do love coding but I got to tell you, if it wasn't for Muradiv's help, man, that's pretty incredible. That's pretty incredible. So thank you for your help, all of you guys, out. Really, really appreciate your help with this, but that was a lot of fun to do because this chain link function, I'm deeply passionate about this topic, so don't get me started. But the fact that you can now interact with the traditional web in any way you want and have the benefits of consensus, super exciting for me. Just think of all the use cases that you guys can unlock with this, right? It's just something else, right? It's really fun. So if you guys have your phones around, take a look at this QR code.
01:58:13.194 - 01:58:27.040, Speaker B: I promise you it's safe. I know you're not supposed to hear me say that and I know you're not. It's safe, okay. And it's on YouTube. So what am I going to do? I'm not being anonymous here. Please give me, give us, give the team, give function some feedback. We would really appreciate it.
01:58:27.040 - 01:58:49.814, Speaker B: I'm going to actually put the feedback link in the chat as well so that you guys can just click at it there if you want. But I would really love to hear from you guys what we really want to do. It's still main net beta, but we're constantly developing. We've got so much stuff that we want to try and do with this. Has my video frozen, by the way.
01:58:49.852 - 01:58:50.440, Speaker A: Guys.
01:58:54.540 - 01:59:14.450, Speaker B: Can you still see it's frozen on my end. So I don't know whether my computer is just having a moment anywhere. It's only me. You can do without seeing me. But look, if you give us feedback, guys, we do take this very seriously and it's our mission to try and include all of that feedback in the product roadmap, the ones that really help the community. Oh, my video has been frozen for a while. Great.
01:59:14.450 - 01:59:16.770, Speaker B: Might as well just turn it off then.
01:59:41.610 - 01:59:45.110, Speaker A: See, still frozen. Not the most flattering expression.
02:01:02.530 - 02:01:09.620, Speaker B: Okay, can you guys hear me now? Hopefully you guys can.
02:01:13.430 - 02:01:14.980, Speaker A: Can you hear me now?
02:01:16.950 - 02:01:25.794, Speaker B: Sorry about this, guys. Oh, getting mixed response. No consensus on the response. And whether you guys can hear me. Ooh, slowly.
02:01:25.842 - 02:01:29.400, Speaker A: Consensus all right, okay, let me go back a step.
02:01:30.330 - 02:01:59.650, Speaker B: What I was saying was please give us feedback because this is the way we improve and we really want to hear from you guys what you enjoy, what you don't enjoy, what you'd like to see, what you're blocked on, what your use cases are, any questions you have? Sure, you can use discord, no problems. But we also recommend you put it on stack overflow. We monitor that as well. And the reason for that is it's more friendly to those that come after they can. Also, Discord is not the most easy to search, whereas stack overflow is always there. But of course we're here to support you in Discord as well. You can use all of these links.
02:01:59.650 - 02:02:35.110, Speaker B: You can go through the functions documentation that I've already shown you. Docs link chain link functions this is the NPMs, the functions toolkit package we use today. That's today's repo run functions app. I'll show you in a moment the playground I showed you right at the start where you paste in your JavaScript and give it the arguments and secrets and off you go discord. We can support you on that, but also encourage you guys to use stack overflow so that it's searchable. You can check out more sample repos by going here and just searching all repos starting with functions. And you can see all the sort of public repos that we have out there that show you various use cases.
02:02:35.110 - 02:02:54.706, Speaker B: Now let me show you run functions app. Don't worry about it being frozen, guys. I don't know what's going on with the camera. There it is. What it is. I'm smiling at the camera but there's no point because it's frozen. Okay, so this is run functions app.
02:02:54.706 - 02:03:05.526, Speaker B: We just released it. It's very cool. It's an interactive way for you to understand what's happening in channeling functions. So I encourage you guys to go here, let me paste it in the.
02:03:05.548 - 02:03:09.254, Speaker A: Chat and I would encourage you guys.
02:03:09.292 - 02:03:40.690, Speaker B: To go there and play around with it. It breaks down a typical consumer contract all the various pieces to it specifically for this application example. It then shows you what the JavaScript source looks like, which bit is the subscription ID. So it breaks down pretty much what I did today in the workshop. It breaks it down for you and highlights all the relevant bits and shows you how it works. So this is a good way for you to build your mental models. And I'm a huge fan of building mental models before you start devming because I know it's tempting to want to write code, but if you don't build your mental models, you can't reason and debug as effectively.
02:03:40.690 - 02:03:43.460, Speaker B: So I encourage you guys to do that.
02:03:44.070 - 02:03:44.482, Speaker A: Right.
02:03:44.536 - 02:03:59.206, Speaker B: What else can I tell you? Oh, I guess it's the end. So am I on the hour? Oh, I'm three minutes late. But you know what? I blame the camera. I'm just kidding. I know it's a bit rushed for some of you guys and I hope you will watch the video again because I've broken it down to steps. Take a look at the repo. All the steps are there.
02:03:59.206 - 02:04:13.946, Speaker B: Thank you so much for attending and super thankful to all you guys in the chat who helped me out, calling out the bugs and my mistypes and my typos. I really appreciate it. Thank you so much for helping me out with that.
02:04:14.048 - 02:04:16.198, Speaker A: And again, feedback.
02:04:16.294 - 02:04:26.510, Speaker B: Absolutely welcome. Loved it. We really value it. We pay very close attention to it. And I'll see you on the flip side. So for the rest of the hackathon guys, good luck. Reach out again.
02:04:26.510 - 02:04:30.046, Speaker B: No sound. Leo, are you sure there's no sound?
02:04:30.148 - 02:04:33.220, Speaker A: Dav, can you hear me? What's going on?
02:04:33.910 - 02:04:47.874, Speaker B: So I'm looking at my settings here and it definitely is picking up my audio. I can see that it's picking up my audio. All right, maybe it's just Leo. I don't know. Anyway, guys, thank you so much for attending. Enjoy the rest of the hackathon. We're all here for you.
02:04:47.874 - 02:04:57.322, Speaker B: Reach out when you need, have a blast code, hack, build, make the future you want and you know where to reach us anytime you need.
02:04:57.456 - 02:04:57.946, Speaker A: Absolutely.
02:04:58.048 - 02:05:06.470, Speaker B: Reach out anytime you need and ask any questions that you may have. All right, see you next time, guys. Take care. Bye.
