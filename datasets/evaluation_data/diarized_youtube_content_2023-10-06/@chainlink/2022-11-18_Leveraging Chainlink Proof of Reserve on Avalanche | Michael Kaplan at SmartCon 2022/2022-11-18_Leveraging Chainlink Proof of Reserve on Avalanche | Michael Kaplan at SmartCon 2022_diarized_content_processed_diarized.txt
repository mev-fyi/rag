00:00:08.890 - 00:00:09.566, Speaker A: Hello everyone.
00:00:09.668 - 00:00:50.118, Speaker B: Thank you for being here. Like you said, my name is Michael Kaplan. I work at Ava Labs. I'm a staff engineer there and I mostly focus on working on the Avalanche bridge, which is the cross chain asset bridge from Ethereum to avalanche and also bitcoin to avalanche. Today we're not actually going to be talking about the bridge. We're going to be talking about the proof of reserves functionality that we have through Chainlink on Avalanche and how that can be used to actually make Defi applications on avalanche more secure. We have a very minimal demo of how to actually interact with that that we'll hopefully be able to deploy on the Fuji testnet, which is the avalanche testnet.
00:00:50.118 - 00:01:48.094, Speaker B: And then also we'll look at how that fits into the bigger picture of the avalanche ecosystem in terms of subnets and all. So I'm sure if you're in this room, you've probably heard about a number of bridge hacks that have happened already this year. And it's really an implicit assumption that you have to always keep in mind whenever you're using a bridge or holding any bridge token for that matter, is that the bridged asset carries risk. No matter how secure the bridge itself is, there's always the chance that there's a bug in the code, that someone gets phished to get keys that they shouldn't have. There's always some level of risk there that the bridge asset, which is supposed to be backed one to one with the asset on the native chain, will not actually be backed one to one. So there's some headlines from earlier this year. Just since the start of this year, I think there have been almost $1.5
00:01:48.094 - 00:03:21.826, Speaker B: billion stolen from bridges. So we definitely have to account for the fact that there's risk in holding these bridges. How to make a bridge secure, I think is an entirely different topic that I won't go into in this talk, but happy to talk about afterwards. I think that's where I spend most of my time, but that's not where this talk is focusing. So when we consider that risk of holding the bridge token, it actually extends to any of the DeFi applications that you can use that token in. So if you have a uniswap pool with a bridged asset, if all of a sudden that bridged asset is no longer backed on the native chain, the price of it drastically changes, possibly in the time span of however long it takes a transaction to finalize on that chain, which creates extreme arbitrage opportunities and really expands and multiplies the impact of potential bridge exploit, right? So if you could somehow exploit a bridge and take control of the assets, the native assets, on one chain, and now they're bridge tokens in DeFi applications on the second chain, you can use the information that that's no longer backed and take advantage of that arbitrage opportunity to buy up whatever other tokens you'd like on the chain that the bridge tokens are on, knowing that the bridge tokens aren't actually working. So the bridge risk actually stens to the DeFi applications.
00:03:21.826 - 00:04:12.940, Speaker B: And of course, these DeFi applications don't necessarily know if a bridge has been hacked. They don't want to necessarily account for this case. The hack might occur off chain. These applications are fully on chain, so it's a really unidential situation to put them in. And the proof of reserves feeds from Chainlink is actually one great way to limit this potential explosion of an attack surface and really protect the defi applications from the bridge being attacked itself. So what are the proof of reserve feeds that took this right from Chainlink? They provide smart contracts with the data needed to calculate the true collateralization of any on chain asset backed by off chain or cross chain reserves. So when we think about the case for a bridge, it's really a cross chain reserve system.
00:04:12.940 - 00:04:56.730, Speaker B: If you have link E, for instance. So using the avalanche bridge, you take link from ethereum, you can move it to avalanche, you get the link e token on avalanche. That link e token is supposed to be backed one to one by link held by the bridge on ethereum. And you can actually check that that is the case by looking at this proof of reserves Chainlink feed. So it provides a real time audit of the reserves, and it's powered by the same decentralized network of Chainlink oracles as all the other chainlink products available. Price fees, VRF, proof of reserves, et cetera. Yeah, so this is really the, it's perfect for minimizing risk of bridge assets to defi applications that I was talking about earlier.
00:04:56.730 - 00:06:02.400, Speaker B: And you can read more about that on the Chainlink website itself. Any questions so far? So now, how does this fit into the Avalanche bridge and the avalanche ecosystem as a whole? Well, you might have heard that we launched bitcoin support for the Avalanche bridge earlier this year. So not only can you move ERC 20s over to avalanche across the bridge, you can now also move your native bitcoin right from the bitcoin network over to avalanche and get BtC B is the wrapped token. And we certainly hope that this Btc B asset will be used heavily in many different Defi applications. Obviously there aren't smart contracts on bitcoin. If you're holding bitcoin, you don't get to take advantage of a lot of yield and defi opportunities that might be presented if you're holding a WBTC or BTC asset that you can use in these Defi applications. So there's great incentive for you to bridge to take advantage of BTC B in these defi apps, but there's also that risk we were talking about.
00:06:02.400 - 00:07:07.750, Speaker B: But launching alongside the bitcoin support on the Avalanche bridge was this proof of reserve speed from Chainlink. That actually is a decentralized attestation of how much BTC is held on the true bitcoin network by the bridge itself. Yeah, so the demo that I put together today is pretty minimalistic, but it is aimed at demonstrating how to integrate the proof of reserves feed into a smart contract such that it will not allow any transactions through this feed using an asset that's not fully collateralized. So yeah, I have a GitHub repo that you can either go to directly, the URL is not too long, or scan that QR code. It should also bring you to the GitHub Repo, I guess just some prerequisites we'll use git bash solidity, and if you're familiar with Etherscan, you'll be very familiar with the format of Snowtrace. That's the Avalanche Explorer. And yeah, you can feel free to follow along.
00:07:07.750 - 00:08:22.400, Speaker B: Those are some dependencies of actually running code. I think they're relatively standard. The one you might not be familiar with is foundry, a rust based smart contract development toolkit basically developed by Paradigm, I believe so it provides similar functionality to a truffle or a hard hat, but it is purely rust based and uses sub modules, so I find it a bit cleaner and easier to install with. And there's also dockers, so I'm going to go ahead and open the repo. Yeah, so first, I guess one disclaimer is that I'm not a smart contract developer myself, so I didn't build this as a functional DeFi application, more so just a demonstration of how you can actually use the proof of reserves fee in the Defi application that you're building. And I'll leave that to but we can look at this sampledeficontract Sol. Here's the path to it in the repo if you're following along.
00:08:28.930 - 00:08:29.774, Speaker A: Great.
00:08:29.972 - 00:09:58.822, Speaker B: So you'll see that we're using the open Zeppelin contracts just for the ERC 20 interface and the chain link smart contracts for the aggregator V three interface, that's their standard price feed interface. And within this sample DFI contract, what we really want to do is kind of mimicking a generic deFi application where you deposit tokens into the smart contract into some pool mechanism and then you can withdraw it later on. Like I said, I'm not a smart contract developer myself in terms of building the DeFi applications, but you can imagine some type of generic flow like this for many different applications. Yeah, and the proof of reserves feed on the Fuji testnet is at this address. You can find all of the feeds available on the Avalanche testnet and Mainnet at that link in the code and then the actual BTC B ERC 20 contract is available. So if we look at get collateral amounts, this returns the current BTC B supply and the current BTC collateral amount held by the bridge on the bitcoin network as reported by the proof of reserves oracles. So relatively straightforward code here we're just getting the total supply from the ERC 20 interface.
00:09:58.822 - 00:11:00.190, Speaker B: And similar to the previous presentation, we're calling the proof of reserve contract to get the latest round data. That is the chain link answer there. And in this case it's not a price, it's the actual collateral amount held by the bridge. We check that it's the correct round Id that the collateral amount was supplied and just return those amounts. And this function here is fully collateralized. I think it's a kind of self explanatory one, but it's a snippet that DeFi applications would need to include in their own code in order to make sure that the bridged asset is actually fully collateralized at the time of this transaction and interaction with their Defi app. So we're just getting the collateral amounts and making sure that the total supply of the wrapped token is less than or equal to the collateral amount held by the bridge on the bitcoin network.
00:11:00.190 - 00:12:01.662, Speaker B: It could be less than in any number of valid cases. The only thing we don't want is if the wrapped token supply is greater than the collateral. That should never be possible. For things like bridge fees that might be held by the bridge, the collateral amount might exceed the wrapped token supply. Or if you were to burn a wrapped token for instance, that discrepancy could be the case. Or actually in a common path, when you perform a bridge transfer your bitcoin to the bridge on the bitcoin network, and at that point the bridge is holding the funds, but the wrapped asset doesn't actually get minted until six blocks later on bitcoin, at which point the transaction is considered finalized. So we do expect the collateral amount to be greater than the and then just to round out this smart contract, there's not any real functionality here, but just kind of showing it as a demo purpose deposit into pool.
00:12:01.662 - 00:12:12.790, Speaker B: Before we allow any interaction of BTC B in this deFi application, we just require that the bridge asset is actually fully collateralized and if it's not we're.
00:12:14.410 - 00:13:36.660, Speaker A: Pausing all that behavior and similarly down below for so I'm going to go ahead and open a terminal to run this big enough actually, sorry, any questions before I actually run it on what smart contract? Soon I'll show you the script that we will use to run it. If we go back to the root of the repo, it is in directory and what we're doing here is just first creating a wallet. Obviously we need to deploy a contract from an EOA. We'll need to put some avoc in that account in order for it to cover the transaction fee. But then we will be using the foundry tool that I was talking about earlier to actually deploy, contract and interact with it. So first we use cast, which is a foundry tool for interacting, the command line interface for interacting with any EVM based chain. The API endpoint we're using here is the public avalanche endpoint that anyone is able to use.
00:13:36.660 - 00:14:27.620, Speaker A: We're going to wait until the wallet that we generate actually has at least 0.5 in order to deploy the contract. When we go to deploy the contract we use called forge, that's another foundry tool, and we are sending it from the account that we generated using that private key. And all we needed to do is provide the actual contract we want to deploy. Forge will take care of compiling and solidity and all that. And then once the contract is deployed we will interact with it by actually calling the get collateral amount function using CAS and the is fully collateralized method. Also Cas provides you this really nice interface for calling solidity functions just by providing the function.
00:14:27.620 - 00:15:13.582, Speaker A: Go ahead and run it. So you can see, obviously don't use this wallet on main net because all of us have the private key here and online. But we can take this wallet address. You can use the faucet if you're following along. The faucet is available at faucet a box network. I'm not going to use faucet myself because I don't want to rate limit anyone else who might be on the same wifi. So I will just send some testnet tokens from the core wallet here.
00:15:13.582 - 00:17:21.850, Speaker A: If you haven't had the chance to try out the new core wallet, this is a small little demo of it's great. So I'm going to send Viabox from my wallet to the address that script output. Great. You can get a sense if any of you haven't interacted with avalanche before, you can get a sense of how long it takes transactions to finalize. Should this be a second or two? In this case, it's already done. So our new wallet has the balance and it is waiting for us to deploy that contract to different. At this point it's compiling the solidity and it will actually send a transaction for that contract.
00:17:21.850 - 00:17:57.030, Speaker A: So I'm going to take the contract address, just show you. This is the testnet. Snowtrace IO is the Testnet store. And you can see the contract was deployed. It's already verified actually, because I ran this demo before and it had the same bytecode. You can see the full contract source in the explorer and all that. And then lastly, if we continue again, the script will continue on to actually interact with that contract.
00:17:57.030 - 00:19:18.350, Speaker A: Checking the current BTC B supply, which you can see here, and the BTC collateral amount as supported by the Chainlink group of reserve feed, which you can see is slightly more than five, which I explained is the expected case, and if recall is fully collateralized, we get back true. Which is why the log there, BTC B is fully collateralized. Yes. So like I said, it's not meant to be any sort of useful application, but it is meant to show how you can leverage just a few lines of code to actually protect your defi application against the bridge risk that comes with any type of bridge asset, whether it's the avalanche bridge or any other bridge for that matter. Any questions on the future? Yeah, definitely. So it's a really interesting question. I think less so from the x chain to the C chain, and more so from the C chain into any other subnet which might have smart contract.
00:19:18.350 - 00:20:22.500, Speaker A: So the X chain, for those not familiar with the avalanche architecture, is meant to be a super fast payments chain that you can create native assets on and transfer them, but it does not have smart contract support, so you're not able to build these robust DeFi applications on the X chain when you're actually moving a token from the X chain to the C chain that gets into an automatic transfer which is built into the avalanche client itself. And I think someone on the platform team would probably have the best explanation there. But there's an automatic import and export transactions, sorry, import and import transactions. So you export the upxo from the X chain and since all these chains are running on the same avalanche. Go client. The C chain is then made aware that this Utxo was made available for consumption and there's special handling. Exactly.
00:20:30.970 - 00:21:37.530, Speaker B: You just gave me a perfect segue onto my next slide. Thank you. Yeah, so this proof of reserves and VRs and price feeds are certainly super useful for applications on the C chain. And C chain we really built in a way that we hope will be very usable for the short term future in terms of the low transaction fee and short time to finality. But at the end of the day, no matter how much we scale the C chain or the EVM, there's still going to be some competition for the block space and the resources of that chain, which is why we are so excited about this subnet model. So for those not as familiar with subnets, they're really independent L1s that execute their own virtual machine, have their own state, and are completely independent from other subnets. But in order to be a subnet validator, you also have to validate the primary network on avalanche, which consists of the XC and P chains.
00:21:37.530 - 00:22:50.674, Speaker B: Yeah, so if you're running an application or you launch an application within a subnet, how do you then use the chain link feeds that are on the C chain, since it's an entirely different blockchain? It's a really interesting problem and one that we're currently working on solving. And it is possible to solve because all of the validators of a subnet are also validating C chain. So they know about the C chain state and they should be able to read from there. And so that way we can provide if you launch your application on a subnet, you should be able to read the current state of the proof of reserves of the price feeds on the C chain without making any additional trust assumptions or having to rely on an additional bridge between the C chain and the subnet itself. Yeah, so it's a really cool model that allows for horizontal scaling of chains without competing for the same resources. And you might then ask, what about subnet security? So they're all independent L1s. How many validators do they actually have? Are they actually decentralized? That's a great question.
00:22:50.674 - 00:23:56.550, Speaker B: You should be concerned about that. There are a couple of different models a subnet could employ here. They could be their own sovereign l one, in which case you do have to look into how decentralized they are, how many validators they have, what's the stake distribution like and all of that. But you could also build a subnet that kind of assumes the security of the underlying C chain if you wanted to. If you wanted to build it as a subnet as an l two kind of like arbitrum you could checkpoint state back onto the C chain and have fraud proofs and all of that such that you are able to leverage the C chain security or the security of another L1 for that matter as a subnet and the subnet in that case would really be the sequencer and just a pure l two for whatever L1 is underneath. So you really have this flexibility in the functionality there to design your subnet however you'd like. You can also have different virtual machines on different subnets so it doesn't have to be the EVM, it could be any virtual machine.
00:23:56.550 - 00:24:04.760, Speaker B: Yeah there's a lot left to build and a lot of exciting possibilities. Any questions?
00:24:08.410 - 00:24:08.918, Speaker A: Awesome.
00:24:09.004 - 00:24:10.140, Speaker B: Well thanks for following along us.
