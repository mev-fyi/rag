00:00:02.810 - 00:00:25.040, Speaker A: And we are live on YouTube. Hello. How's everybody doing? So we're just going to kind of just jump into it for this one. I know a lot of my other workshops so far have been a little bit more. There's the conceptual piece and then I'll dive into the code a little bit for this one. We're just going to kind of jump into it. Feel free to ask a ton of questions here.
00:00:25.040 - 00:01:03.614, Speaker A: That's really what is going to be best. There's that both in the YouTube chat and zoom. You have the Q a feature, so feel free to ask as many questions as you like. So let's get started. Is this the right one? Yeah, we're going to share screen. All right, cool. So hopefully you guys have been watching keeping along with the workshop so far and you're aware of what the three tools that we're going to be covering are today.
00:01:03.614 - 00:01:45.482, Speaker A: So we have the price feeds, we have the randomness, and we've already gone over getting an API, but we're also going over chainlink alarms as well, which is a really cool feature. So if you haven't checked out the price feeds already, just again, a real quick refresher. They're a decentralized way of getting pricing data on chain. And you can go up at feeds, chain link, you can find these on etherscan and see the contracts. Exactly. And we have different node operators providing data. Each answer gets aggregated in the middle for whatever currency pair.
00:01:45.482 - 00:02:20.840, Speaker A: And that is going to be our decentralized source of truth to get data. And a lot of projects are using this like Aave light synthetics, like I believe Uranduff finance as well to power their defi apps, right? Because now you have this reliable off chain data, this pricing data, this really important data that you can use on chain. So it's really good. And it's also probably one of the easiest ones to use. So again, yeah, there's a little blurb here. Synthetics using price feeds. Ave is using price feeds and it's literally just a view function.
00:02:20.840 - 00:03:15.222, Speaker A: So for those of you who are going to be building with your JavaScript, with truffle or buildler, you have your JavaScript, you can literally copy paste, you have your python, but let's see what it looks like in COVID. So I have a whole bunch of these actually. So when you launch it, this is really it, right? So I know I've talked a little bit about this before. We import the aggregator interface and that's how we can interact with contracts. So then we're in our constructor. Once we deploy this, we're going to set the address to the address that we want. And so for here, since we're on the COVID network, we're choosing this so we can even see what this for later what this address is.
00:03:15.222 - 00:03:50.630, Speaker A: We can go here, control F and we can see that this is the ETH USD there for COVID and we can get whatever we want here. Let's say we want to get what the current price of bat is. Maybe we don't actually want Ethereum. We can pop that in there. We're going to compile this contract, injector, web3 deploy. Sure. And you'll notice once it deploys, you'll notice that the function is actually blue.
00:03:50.630 - 00:04:19.674, Speaker A: And you'll notice I don't send any link to it. Right. So for those of you who are kind of newer to solidity, this is a view function here. So you see in the function get latest price, public view returns. It returns an int. So it's a view function means it's not actually making a transaction. We're just saying, hey, what's the data over there? Right? What's the data at this specific place on the chain? So we don't actually have to do any transactions.
00:04:19.674 - 00:04:49.894, Speaker A: And we're just going to call this price feed, get latest round. Again, price feed is going to be our aggregator, interface object. It has a function latest round where it returns all these values. And we're going to get to some interesting things that all these values do. We only want the price out of all these values. So if we hit get latest price, we're going to see the current price of bat is actually not this, it's going to be. Does that make sense? $0.26
00:04:49.894 - 00:05:31.506, Speaker A: bat USD price? Yeah. So about twenty six cents. And the reason again that we get this seemingly large number, but it's really a smaller number is because blockchain doesn't understand decimals. So it actually is multiplied by whatever ten to the 8th to get the decimal place to move from here, over here. So it's a whole number. So for price feeds, that's really it. Now you have the price of whatever asset that you want to use for your smart contracts.
00:05:31.506 - 00:05:58.670, Speaker A: And this is like the thing about price feeds is it's so powerful but it's so simple. It's literally a view function. You can get the price, you can use it to do whatever. Like we said, ave is using it for their lending and borrowing. Synthetics is using it for their platform as well. And it's literally that simple. And you can set, again, we can redeploy with any of these price feeds.
00:05:58.670 - 00:06:54.302, Speaker A: I feel like there's not even a reason to do one more, but it's just really powerful. So the other thing that's fantastic about it is since we're on blockchain, everything is recorded, right? Everything you do on blockchain is recorded, which is great for getting historical price because it's always going to be there. So to get historical price, we can also work with that same price feed and just call a different function though, right? So in the documentation, again, we have it super easy. For those of you who are probably going to be building with truffle or buildler, you have JavaScript here. If somebody's working with Brownie, could you please let me know because I've been meaning to play with it more. And if somebody makes a project with Brownie or some other Python web3, I would love to see it. We'll try soon.
00:06:54.302 - 00:07:20.166, Speaker A: Okay, awesome. Yeah, please let me know. I would love to see some Python. The blockchain community is mostly JavaScript, mostly like truffle, build, blur. Those are a lot of the tools people use, but I would love to see a couple of python projects in here as well. But anyways, historical price for a consumer, that's for later. Yeah.
00:07:20.166 - 00:07:51.394, Speaker A: So for this one again, we're importing the aggregate interface. It's literally the same thing. Just we're going to be adding this rounds back so we can actually put a timestamp in. But this is where if you guys came to the graph workshop earlier, the graph would be perfect because then you could build a subgraph that could do all this triaging to find the rounds back from the timestamp, if that makes sense. That's where this would be perfect. This would be fantastic. But saw the recap, missed it, looked cool.
00:07:51.394 - 00:08:22.670, Speaker A: Yeah, exactly. If you check out the recap of the graph, this is a perfect place to do. Perfect place to do that. Anyways, where was I? Okay, let's compile. Same thing, deploy. And Friday, I'm actually going to be doing a lot of my deployments with truffle. The reason I've been doing with remix is because it's familiar with a lot of people and it's really simple to kind of show you stuff really quickly.
00:08:22.670 - 00:08:51.750, Speaker A: But I'll probably be doing more truffle stuff starting Friday, so let's deploy. And again, this is a view function so we can do our rounds back. And actually I'm going to. Oh, okay, never mind. It went right away. Sometimes here, you'll see. Let me see if I can actually get it to error out because if you do it too quickly, sometimes the interface will say it's done when it's not.
00:08:51.750 - 00:09:22.014, Speaker A: Did I do it fast enough? Yeah, and you'll get this error like failed to decode output, blah, blah. Don't worry, it just means it hasn't actually finished deploying and the UI might have updated faster. So if you get this, just hit tight, don't worry about it. But it's something I've ran into a couple of times and then you just update it. So we could even do like ten rounds back. You see what the price was there, 50 rounds back. At some point we'll reach a cap, 1000 rounds back.
00:09:22.014 - 00:10:03.102, Speaker A: Okay. Yeah. Back when it was $400 or what is this, this ETH USD back when it was $400. So 5000 rounds back and again, rounds back is every round is whenever there's a price update. So if we go on the feeds chain link page we can see that a price update gets triggered every time the heartbeat hits, which for this pair it's 3 hours or whenever the deviation threshold hits. So for this price feed pair it's going to be 0.5%. So whenever this hits or the heartbeat hits, we're going to trigger a price update and that's going to count as a round and that's what's going to count as the rounds back here.
00:10:03.102 - 00:11:23.160, Speaker A: So I wonder if I do like this many, what will happen? Yeah, VM execution error because that's way too many rounds back. So a couple of questions here. Does it cost link to read price feed? If so, who pays the fee? So as you saw here, it's just a view function. So we're doing like this natively in it, it's just a view function. But if we go to the feeds chain link page, they are being sponsored by a number of different projects and this is super ideal, right, because since we have a bunch of sponsors paying a little bit to sponsor these price feeds, you now get this data for even cheaper than if you had your own centralized oracle, right? You get this data because it's this shared collective resource that everyone's accessing. Rather than you spinning up your own decentralized oracle, you spinning up your own network and everybody having their own network, it's just this great common resource. So it's fantastic in that sense.
00:11:23.160 - 00:12:16.438, Speaker A: But yeah, as you can see it's really easy to get historical price here. It's really easy to get, you can get the timestamp started at answered in whatever you want. And then this is where you can do interesting stuff with the price feed, right? You can set like a token reward, you can figure out an options contract. Literally the uses for this are kind of, again, just capped by how creative you want to be. On Friday for our defi demo, we will be using price feeds to show you how to make a simple defi yield farming application. So definitely you want to come out Friday. And then we're also going to be using truffle there instead of remix because truffle is going to make the development process a lot easier for us.
00:12:16.438 - 00:12:54.690, Speaker A: And we're also going to be building it with node JS so we can put a front end on top of it too. So that'll be really nice. But when it comes to price feeds, it's literally that simple. This is all the code you really need. I don't really know what else to say other than, hey, it's literally this simple, but it's so powerful because you have this decentralized pricing data. And again, it's proven its security because right now these price feeds are securing like $3 billion or something like that. So I do want to move on to the next piece, which is going to be the VRF.
00:12:54.690 - 00:13:35.186, Speaker A: Unless there are any other questions on the price feeds, I feel like you guys got a pretty good grasp of price feeds, but if there are any other questions, let me know before I move on. What if we want to list a new one? Good question. So again, you're always welcome to build your own price feeds. You're always welcome to build your own networks. And again, that's what makes the whole technology so fantastic, is you can do that. However, if you're looking to get to spin up kind of your own decentralized network, you can come to defi chain link, launch your price feed, put your information in there. I will say just a heads up.
00:13:35.186 - 00:14:24.754, Speaker A: The integration team, those of you who were here earlier, the integration team is pretty backed up, so if they don't get back to you right away, they are working on it. But yeah, you can come here and request a price feed, which is pretty fantastic. But yes, you are more than welcome to build your own. Cool. What's the starting point to create our own price feed on a testnet? Good question. So what you would do is you would have to get a network. Well, the starting point would be to get one oracle, one reliable oracle, to get high quality data.
00:14:24.754 - 00:15:11.680, Speaker A: And that's something that's really important too. All the oracles who are providing these price feeds are using really top quality APIs so that the data is also guaranteed to be really good. So you would need to get at least one provide in this top quality API. Then you would need to get a decentralized network of these oracles and all of them be independent, right? That's super, super important. Otherwise you're going to get exposed to civil attacks, which is where multiple people pretend to be the same person to do malicious things to the network. But yeah, you'd have to get a network of these oracles to start providing this data. And then you could have a simple smart contract that just periodically calls them again.
00:15:11.680 - 00:15:47.370, Speaker A: All that information is here in this make a get request. You just have several of these get requests happen. Just keep pinging around. So you can make price feeds of any data, like sports data, weather data, news data, whatever you wanted. So it's really modular in that sense. But again, there is kind of a lot of work that goes into spinning up these networks. So all of these price feeds are kind of already battle tested.
00:15:47.370 - 00:16:18.310, Speaker A: And again, like we said, they're being used by some of the top projects in DeFi right now. So these are super reliable price feeds here. Deep dive. I don't know if that's a question. Do you think it's possible to create a test price feed during this hackathon, or is that unrealistic? I don't think that's unrealistic at all. I think you'd absolutely do that if you're a node operator and you want to play with doing some of that stuff. I think that that is definitely doable.
00:16:18.310 - 00:17:05.106, Speaker A: All right, moving onto. But again, one of the other main benefits of the price feeds is that it's this community asset and it's this shared collective resource. So if you're looking for some specific data, it might be nice just to add to the collective, but I would be very curious to see what you do. Curiosity is your only innovator. Anyways, moving on. Chainlink VRf. So I'm going to kind of rip through these, but these are literally bleeding edge things here, and I probably should be spending a lot more time on them.
00:17:05.106 - 00:18:01.240, Speaker A: But I want to get through all three of them and then possibly have some time at the end to show you like an application of all three. This is Chainlink vRf. So Chainlink vrf stands for chainlink verifiably random function, and it's approvally fair and verifiable source of randomness. And the main question people will ask is, okay, well, how did we do it previously. How do we get random numbers before? And you'll see a lot of people did like, they would hash the block hash at the time. They would hash the block at the time to get a random number. Now, this generates this conflict of interest for the miners, right? So anytime somebody has influence over whether or not over a game or over some type of chance or some type of randomness, it's no longer fair.
00:18:01.240 - 00:19:04.810, Speaker A: And so the miners actually, when they mine these blocks, they have the opportunity to decide whether or not they want to publish these blocks, right? So if I'm a miner and I'm like, hey, there's a lottery smart contract going on right now, and I know they're using the block hash, and I got a million dollars on the line, I'm going to put in a little script that says, hey, if you mine the block hash, don't publish it if the winning number isn't yours. And that's a huge issue, right? Because now they have control over who wins your supposedly provably random lottery. And that defeats the whole purpose of having a random number or having any of this stuff. Chain link VRFs are really powerful in this sense because they provide provable randomness. They say, hey, my number is random and it's provably random. So they're on testnet right now. It's in the final stages of review, and a couple of products are already starting to adopt them, which is fantastic.
00:19:04.810 - 00:19:47.110, Speaker A: And again, they're really easy to deploy. So again, if we want to deploy it on remix, we have the link here. We don't have JavaScript or Python, but it's going to be similar to where was it? It was in price feeds, but it's going to be similar to this price feed stuff, the price feeds code. So we're going to hit and we get populated with this random number consumer here. So again, we're going to import from the VRF consumer base file. And again, if you're using node Js, your imports are going to look different on remix. Remix can import, right from GitHub.
00:19:47.110 - 00:20:26.562, Speaker A: NPM is a little bit different. You'll use just the node JS syntax. Now, here are the kind of important this when we launch the smart contract, here's the constructor right here. Right? So we need to have the VRF consumer base point to the VRF coordinator. So this is another smart contract on the network that is going to coordinate working with the random numbers. And we also have to tell it what the link token is for this network. And this is a link token for COVID.
00:20:26.562 - 00:21:13.490, Speaker A: Right. And then we also have to give it the key hash. So each node, each VRF has a specific key hash that we need to give it and we use that to prove that the number is actually going to be random. So then it's literally kind of the same as calling an API, like the same asynchronous type layout here as calling an API because we call this get random number function. And I'll talk about the user provided seed in a second and it'll return, actually it doesn't really matter what we return. It'll return this request randomness function. And this is actually what's going to request the randomness.
00:21:13.490 - 00:21:41.614, Speaker A: Yeah, that's actually what's going to request the randomness. And then it's going to go out, same thing as the API. It's going to go out, there's going to be event on chain. The chainlink node is going to be looking for this. It's going to pick it up, it's going to say, okay, cool, I'm going to go grab your random number. Here's your random number, here's the proof of why it's random. And it posts it on chain in a transaction via this fill randomness function.
00:21:41.614 - 00:22:03.970, Speaker A: And then we're going to set our random result value to our randomness so we can actually play with it right now. Deploy. That was really fast. Oh, it's because it's non injective web3. Let's do that now. Let's deploy. How much, Keith, do I have got enough.
00:22:03.970 - 00:22:45.906, Speaker A: Okay, great. And then we have our get random number function. Yes, we have our get random number function which calls our request random number function and then fulfill randomness is called by the node here. So take a couple of questions here. 3 hours is a long time. Why isn't it faster? Are you talking about the price feeds? The short answer is gas costs. The longer answer is there's also that price deviation, that price deviation threshold which is going to kick off if there's anything significant happening.
00:22:45.906 - 00:23:31.166, Speaker A: So it's not like it only updates every 3 hours. And if there's some crazy spikes, they'll never update. It'll update pretty much anytime there's an insignificant spike. But if it's fairly stable, there's no reason to waste gas updating. If it goes from two hundred dollars and fourteen cents to two hundred dollars and fourteen cents, why would you waste gas doing that? How random is it in comparison with quantum generated numbers? I don't know how random quantum generated numbers are. Yeah, I don't know how random quantum generated numbers are, but let's continue with the demo and you'll see for yourself. So we're going to do a get random number.
00:23:31.166 - 00:24:00.714, Speaker A: We can provide whatever we want for a seed. So this is what we're going to use. The node is going to use to prove its randomness, this seed. And this is the same issue that you'll run into a couple of times. Remember, we need to give it chain link gas because it is making a request to a chain link node and we're just going to send it to to be safe. Two is probably overkill. Oh, yeah.
00:24:00.714 - 00:24:36.846, Speaker A: The fee is 0.1 length, so two is definitely overkill. But while we're waiting, how random is it? Oh, yeah. I'm not sure how random quantum generated numbers are. How do you get the required key hash on line 33? So the node itself actually will have the key hash. So when you look up the documentation for these nodes and the random numbers, that's where the key hash will be. And I think there's the contract addresses.
00:24:36.846 - 00:24:59.082, Speaker A: Yeah, so if you look at the contract addresses for the different ones, right now they're just on Robson, coven and Rinkby. Although Robson is having issues, the key hashes will be listed with the node themselves. Anyways. That probably finished. Yep. Okay, so funded it. Let's get the random number now.
00:24:59.082 - 00:25:38.054, Speaker A: Now that we have the chainlink gas, we have the oracle gas, it's going to actually work because we're going to send it there. We're going to make this transaction. And again, we're posting this transaction. Our chainlink node, which again is off chain, is going to read it and say, okay, cool, I'm going to go get your random number, and then it's going to do its off chain work, and then it's going to repost it back on chain. So if you just immediately go, what's the random result? Why is it still zero? Never mind. It updated already. But if you go, what's the random? Why is it still zero? It's because you have to give it a second to post the transaction back on chain.
00:25:38.054 - 00:26:50.720, Speaker A: So we can see the random number here. It's massive and a lot of people go, okay, well, that's useless to me, but I'm actually going to cheat and go back to my other contract right here real quick. Is it in my lottery contract? So if you see this number and you go, okay, this is a crazy, insane number. We could do like randomness modulo ten. I think that that's right. Right? Is that the correct syntax. Wait, that was back here.
00:26:50.720 - 00:27:14.242, Speaker A: Yeah, that should work. Let's go back to random consumer. So if we do like random miss module ten now, we should be able to get. No, sorry, I have to redeploy. Let's reject that. To even trash this. Just make sure I compiled deploy.
00:27:14.242 - 00:27:37.534, Speaker A: And as you can see, there's a lot of clicking around in remix for those of you guys who are new. And this is going to be one of the main benefits that Brownie and truffle is going to give you. It's going to allow you to kind of deploy this stuff without all this manual clicking around. You can create a script that does all this for you. Um, so great, we're going to fund it with link. Yeah, even this funding with Link. And again, Friday, be sure to check it out.
00:27:37.534 - 00:28:01.414, Speaker A: And next week we have a truffle deep dive with the truffle team, which will be really exciting to show you how to go even faster. So we're going to fund it with Link. While we are waiting for it to go, how do you get the key hash? Oh, I answered that. Awesome. Good question. Can you request the random number as often as you want in a predetermined time frame? And does it cost you any gas? It's off chain. Right.
00:28:01.414 - 00:28:43.410, Speaker A: Can you request the random number as often as you want? Yeah, you can request the number as often you want in a predetermined time frame, yes. And does it cost you any gas? Anything you do on chain costs gas. Let me clarify. Any state change you make on chain is going to cost gas or any computation? Yeah, anytime you do like a state change on chain, it's going to cost gas. The price feeds doesn't cost gas because we're not actually changing the state of anything. We're saying, hey, what's this value here? And then we can just look at it and get the value. We're not doing any computation with the EVM, the ethereum virtual machine.
00:28:43.410 - 00:29:05.898, Speaker A: We're just getting, or maybe getting the, actually maybe getting the view is with the EVM. Don't quote me on that. But we're not making a state change. So anything that you do, though, costs gas. It's off chain. Right? The chain link node is off chain, yes. However, when you make a transaction, sorry about that.
00:29:05.898 - 00:30:18.420, Speaker A: When you make a transaction on chain, when you make a transaction on chain, it's going to cost gas. Question, does the link fee ever increase? The chainlink nodes get to decide the link fee, so it could, if they wanted it to, you probably would be incentivized to not use them because if they keep changing your price on you, that's going to be a big pain in the butt. So it can increase, but they're kind of incentivized to make a knock because if you have to keep updating your contracts, then you're going to be less likely to use the ones who keep changing the price on you. Wouldn't be a good idea to obfuscate the generated random number. Wouldn't it be a good idea to obfuscate the generated random number? I guess it depends on what your application is, actually. So that's a good question. Like, for example, if you wanted to play like a poker game or something, right? You wouldn't want anyone to be able to see your random number.
00:30:18.420 - 00:30:37.640, Speaker A: Zkp. Zkp. There's a lot of echo. Oh. Zero knowledge proof. That's where my knowledge is a little bit lacking. Horatio, you're asking some fantastic questions here.
00:30:37.640 - 00:30:54.686, Speaker A: I would be curious to have you ask them in the discord as well. And maybe somebody else could jump on, because those are really good questions. I'm just not sure the answer to them. So. Good questions, though. But anyways, so we deployed. I forgot if I funded this.
00:30:54.686 - 00:31:23.542, Speaker A: I think I did, right. Yes, I did. So now we're going to do another seed here. And again, you just want to kind of do a random seed here, which sounds kind of funny. We need, like a random seed to get a random seed. And then once it posts it back, we'll have something that's not as large and not as insane. And then we can use this for something a lot easier, like a dice roller, like a lottery winner, instead of having that massive number that we got.
00:31:23.542 - 00:31:37.514, Speaker A: So we got two. Perfect. So this is a much more digestible number and it's a random number. So that's really fantastic. We'll see the video. I know mine. Okay.
00:31:37.514 - 00:32:06.980, Speaker A: Welcome. Glad you're here from pretty much. And that's how the VRF works. So it's almost the same as making any API call. It's just with getting a verifiably, provably random number, which again, is really exciting and this massive, massive benefit over security. So I don't know how random it is in comparison to a quantum random number generation. And yeah, obfuscating it, I think is really interesting.
00:32:06.980 - 00:32:58.278, Speaker A: I'm not the right person to talk about doing that, but I think that that's a fantastic question and a really good use case, so thank you for asking. All right, cool. And we're going to go to the last piece before I hopefully have time to show the decentralized lottery if I don't get time. We wrote a blog about it, although the blog code is with Robsten, so you'd have to just change over all the addresses to COVID. But yeah, hopefully we have time to go over it so we can get through this chain link alarm park pretty quick. Oh, it actually looks like we don't have the easy one click deploy. We kind of have it set up like this.
00:32:58.278 - 00:33:26.800, Speaker A: So this works too. So maybe we can even just kind of build it together here. Let's call alarm soul program slowdy. We're going to use this one import. So this syntax is for node js and for python. So we're actually just going to get the. I don't want to use that one.
00:33:26.800 - 00:34:02.422, Speaker A: I don't want to use that one either. Okay, maybe I'll be able to use this one. So we're going to import the chain link client. We're going to have the oracle payment, which is the same, this works the exact same as making an API call or the Vrf. We're going to make a request to a chainlink node. We're going to emit an event. Chainlink node is going to read it, pick it up, and it's going to process and do whatever needs to be done and then it's going to respond accordingly.
00:34:02.422 - 00:34:34.080, Speaker A: So the constructor here is set public chainlink token. Oracle payment equals oracle payment. Kind of standard stuff here. Now we're going to add our interesting, we're going to add our interesting function here. Oh God, the syntax. Syntax looks kind of gross here. Let's clean that up a little bit.
00:34:34.080 - 00:35:53.760, Speaker A: Let, nice. So we're going to have our function delayed start which this one we're going to take the address of the oracle and the job ID, this job and that. Oracle is going to define being able to make these chainlink alarm clocks and I actually didn't even describe what it does. So the Chainlink alarm clock is this really cool feature that allows you to basically say, hey, I want this done in X minutes. And this is a really powerful tool for something, for tons of applications, something like, for example a lottery, right? If you want the lottery to be done in a week, you can say, hey, come back in a week. And now you have a decentralized way to run your smart contracts in a timed fashion. Or maybe you have an options contract that needs to expire in a certain amount of time or an insurance contract, or maybe there's something as simple as like a silly bet between you and your friend, you say hey, on this date if it's not done, do X, right? And so this will be an on chain way to get that.
00:35:53.760 - 00:36:54.590, Speaker A: It's as simple as this. So we have our delay start function which is going to take the address of an oracle and then the bytes 32 job Id of that oracle, that's going to define it and we're going to do the same thing we always do. Actually this is, oh wait, no, if this was a newer version we'd have to do address this, but we're going to use this one. Maybe, actually you know what, maybe we'll make this a working session. No, I want to quickly speed through this and the important bit is this rec add, you win. Until now plus five minutes. And if we go to the chain link docs, all these pieces that you guys see and that you guys have hopefully been starting to see that go along with the request, these are the adapters, right? So just keep that in mind and you can find all the docs on the adapters in the documentation.
00:36:54.590 - 00:37:49.490, Speaker A: So this is the sleep adapter and this is the syntax for it. Rec add, int until now plus 1 hour, now plus five minutes, whatever you want. And what it does, I keep jumping to that one. And what it does is it tells the chain link node to respond in five minutes, in 5 hours, in five, whatever. If you want you can just do something like 60, which is seconds. So you'll say hey, I want you to respond in 60 seconds. Let's even compile so we have an issue from, okay, because I'm using V six file requires different compile version.
00:37:49.490 - 00:38:33.082, Speaker A: You know what, let's just use v six because that's what everyone's going to be using anyways. These are some of the issues you guys are going to run into while you're building. Undeclared identifier function delay start public only owner, only owner. Let's just get rid of that for now. Only owner would mean that only I could call this function getting rid of it, but I didn't import only owner. I could have imported it and now we have something else fulfilled, not found or visible. I should add a fulfill request.
00:38:33.082 - 00:39:10.018, Speaker A: Yes, here we go. Forgot to add the fulfill request. This was kind of cool. We got to see what it's like to triage some of this stuff. Okay, so let's do a fulfill, let's add a Un 256 times called, right? And then when we construct it we'll do times called equals zero and then we'll do times called equals times called plus one. Perfect. Okay, now it's actually compiling.
00:39:10.018 - 00:39:31.380, Speaker A: Great. We're on our injected web3. We want to do alarm Sol. It looks like we're taking an oracle payment in here. So let's do 123-4567 810. 123-4567 that should be 0.1 link.
00:39:31.380 - 00:40:03.242, Speaker A: I could have just defined it in here. Okay, it covered that. 1234-5671-2345-6789 ten. Deploy. Great. Couple of questions. While we actually had already deployed, let's send it some link and then I probably can rush through the decentralized contract.
00:40:03.242 - 00:40:37.714, Speaker A: But I actually haven't tested it on coven yet, so it'll be a question if we get it to work, because Ropsync recently became busted, so we'll test it in prod here. You've been working. It's VRF live on main net. It's in the final phases of the security review. You could hypothetically run a VRF job on Mainnet. We would recommend not, though. Again, Chainlink is a modular framework.
00:40:37.714 - 00:41:00.826, Speaker A: Right. You can do whatever you want. Right. So on, none of the chain link Oracles, none of the main net chain link oracles is VRF live. So that's the answer there, especially for something like this. You really want the security audit to be done? You absolutely do not want to. I kind of just made a joke.
00:41:00.826 - 00:41:44.160, Speaker A: I was like, we'll test on a product, something like that. That's going to ride on a lot of people's well being, is not something you want to just throw on Mainnet and test it there. So it's finishing its security audit and then it'll be live on Mainnet. While it's doing that, products are adopting it for their testing because it's such a valuable tool for them to use for their entire infrastructures. So it is not live on Mainnet, it is finishing its security review. Good question. How far into the future can you schedule an alarm? Is there any risk that the alarm will not go off, for example, if the Oracle goes down during the time it would expire? Great question.
00:41:44.160 - 00:42:29.850, Speaker A: I feel like hopefully at this point you're starting to understand what the answer to that would be. I kind of want to let you guys answer that or let somebody from the audience answer, how do you protect yourself against the risk of one of these oracles going down, including the chain link alarm clock? Redundancy. Excellent. Okay, I'm looking for a different keyword, but that is absolutely correct. Redundancy. Perfect. Exactly.
00:42:29.850 - 00:42:59.240, Speaker A: Decentralization. So thank you Leo and Horatio's got it. Awesome. You guys are getting it aggregator. So again, if we go back to feeds, chain link, that question is actually a fantastic question because the same question applies here. What happens if one of these nodes goes down? Well, there's 20 other nodes. What happens if five of them go down? Well, there's 16 other one.
00:42:59.240 - 00:43:38.114, Speaker A: This is one of the key principles of blockchain and smart contracts in general is this decentrality of the system, something like Twitter. And the reason I bring up Twitter is because they got hacked like a month or so ago. The hacker got into their main system and that was it. Right. I like to use that as an example, because if, for example, the social network was on a decentralized network like this, that one resource that they got into would just be one node and they wouldn't have been able to scam a bunch of people. Right. So really good question.
00:43:38.114 - 00:44:16.720, Speaker A: And that question applies to basically everything in defi, everything in smart contracts, everything in chainlink. How do you protect yourself against oracles going down, being malicious, being hacked? And the answer is decentrality. Absolutely decentrality. So really good question. How far in the future can you go with these? That's a good question. I'd have to double check actually, but I'm pretty sure that they use a Unix timestamp. So you could go as far as that goes.
00:44:16.720 - 00:44:32.610, Speaker A: I would have to double check. That's what I think. Yeah. I'd have to double check though. But. Okay, delay start, and we're probably going to be running on short on time. We'll see if we can do the decentralized contract.
00:44:32.610 - 00:44:59.420, Speaker A: But do we have the. Yep. Okay, we have the oracle address, which is going to be this. And this is something that you can do live. But again, something like this, you definitely want to make sure you do it right. And you definitely want to make sure it's decentralized if you're going to do something like this live. Because just as I forgot who asked it, but just as they asked that question, hey, what happens when this goes down? Well, you're going to have something that never gets.
00:44:59.420 - 00:45:20.046, Speaker A: You're going to have like a timed event that never closes. Right. If the oracle goes down, then the event's never going to cease. So you definitely want to have that decentralized. If you're doing a main net, again, if you're just testing, you can just have one. Not a big deal. But for mainnet it's pretty much essential, right? And not even pretty much it is essential.
00:45:20.046 - 00:45:44.762, Speaker A: You definitely always want to have these be decentralized because that's the entire purpose of smart contract. So job ID, is that what it takes? Yeah, it takes that in the job ID. Job Id has to be in quotes. I think this also has to be in quotes. Okay, I got to redeploy. So this times called needs to be public. Sorry about that.
00:45:44.762 - 00:46:16.694, Speaker A: And does that go on the, oh, sorry, whoops. Let's delete this one. Oracle payment. I probably should have just made that value. Wouldn't have to plug it in every time. Oh, unless it takes this. Oracle could also take one link instead of 0.1
00:46:16.694 - 00:46:51.280, Speaker A: link. Let's try it out. So cool. So now we have the times call variable at zero coving oracle address job id again. If you're looking to find job ids and oracle information you can always check market link. I need to fund this error encoding arguments are blah, blah, blah. This is a different error actually.
00:46:51.280 - 00:47:42.270, Speaker A: Oh, is this not the, this might not be the bytes version, so I might have to do string to bytes. I have that in here's, maybe I don't. Let's find the string to bytes. I'm pretty sure this has a string to bytes function we can use. Let's check. Maybe it doesn't. So the issue I'm running to now is I'm passing it a string and it wants a bytes.
00:47:42.270 - 00:48:31.134, Speaker A: That's what it looks like, right? Error encoding arguments bytes 32 value is this. Yeah, so it's saying this is a string and not a bytes. Actually, you know what, maybe I'll just put it in the smart contract. Oh, I lost my page. This one's, did I just close it out? Whatever, let's do this. Let's do, let's get rid of this and let's just hard code it in here again. You don't want to hard code stuff.
00:48:31.134 - 00:49:16.510, Speaker A: Usually you want to do like wrapper functions. So did I just get rid of my alarm coven right here? That should recognize that as a bytes. Yes it does. Okay, cool. Now we can just pass to the oracle, you know what, let's even do oracle payment. Let's even just do 112-34-5678 910, 1234-5678, that way I don't have to do this anymore. Cool.
00:49:16.510 - 00:50:02.750, Speaker A: And I am taking a long time. Let's delete this deployment. Looks like it's just about done. Now we have our delayed start. I probably should just hard coded this for this as well. Here's the oracle address start. Need to give it some link and you're starting to see more and more why truffle is really nice because then you don't have to click around like this all the time.
00:50:02.750 - 00:50:30.692, Speaker A: You can just run like a fun script. And we'll go over these on Friday, and Truffle will go over these next week using migrations. They're really nice. And I forgot to do check times called. It's currently zero. When this is fulfilled, it'll come back and it'll fulfill it and it'll be plus one. So whenever that happens, we'll get the fulfillment there.
00:50:30.692 - 00:51:10.240, Speaker A: And while we wait for it to come back. Yeah. Are there any other questions on kind of the chainlink alarm and seeing kind of how powerful this tool is here? Okay, great. Fairly straightforward. So let's see if ether scan COVID, see if that fulfill was called. And it looks like we're running out of time. Contracreation was in.
00:51:10.240 - 00:52:23.124, Speaker A: Oh, I didn't hit delay start, forgot to hit delay start 10 seconds ago. And since we said this for 60, we got to wait 60 seconds for it to actually respond, so it shouldn't come back. And if we watch here, we should get that fulfill being called in about 60 seconds, kind of hang out, sit tight, talk about how fantastic our hackathon projects are going. Everyone here has been asking really good questions, so feel free to keep asking. And we're not going to have enough time to go over the lottery here, but I can kind of briefly go over it because it's a little bit more involved. 54 seconds. So still waiting 1 minute.
00:52:23.124 - 00:53:05.990, Speaker A: So this is around when it'll probably start working, because again, it starts counting from when it picked up the job. So we'll give it a little bit more time. Hopefully. I put in all the addresses correct. And this is why testing is so important. Maybe I should have done like 5 seconds so it was quicker. You, it looks like.
00:53:05.990 - 00:53:35.596, Speaker A: How come it didn't show up in the transactions here's. All right, well, it counted, but now I'm curious as to, did I miss something? Well, in any case, it did what we wanted to do. And so you can delay the start as much as you want. You could keep hitting this and it would keep waiting 60 seconds and just keep updating the counter. Right. Because we know it called the fulfill function here and it added one to the times called. So that's really cool.
00:53:35.596 - 00:54:03.960, Speaker A: So we have like five minutes left. I don't really have enough time to kind of show you everything here, but I can kind of briefly go over what is going on in this code. And if you check out our blog it has all the code in here. It's just all with rops and addresses. Feel free to flip them over to COVID. Some of them I flipped over to COVID here. I was going to try to work through it with us on the workshop, but it shows basically some of the power that both of these can have.
00:54:03.960 - 00:54:40.756, Speaker A: Right. So this is an example of having a decentralized lottery that anybody can be a part of, and the winner is provably random. So this would be a case where nobody owns this lottery. All the winnings would go to the winner. And so not only that, you could have your payouts be significantly higher than in a centralized way, because in a centralized way, whoever's running the lottery probably wants to get paid for securing it. I'm pretty sure a lot of lotteries, like the state lotteries, they usually keep something like 50%. I could be wrong, 50%.
00:54:40.756 - 00:55:45.444, Speaker A: So this would be a way, even if you're doing a state lottery, for the overhead to be much lower, because you have a lottery that's running itself, which is really cool because you have the timed alarm clock that says, hey, this lottery is going to end in five minutes, or this lottery is going to end in one week, get a random number with the VRF, and then once it's done, restart. So there's a couple of. Couple of contracts here. The main one is this lottery sol. It's got a whole bunch of stuff in here. The main piece is start new lottery, which changes the lottery state to open. It can't start when it's closed, changes it to open, and that's when it starts, this alarm clock, and for whatever the duration of the lottery is going to be, it starts the alarm clock, and it kicks it off, and it makes the alarm, and that's when you can start entering.
00:55:45.444 - 00:56:25.012, Speaker A: And then there's this enter function, which once the lottery is open, you can start entering. You can start entering. It's really simple. You enter, and you have to send in the contract some value, and you enter the lottery. And then once it's done, the chainlink alarm clock will call this fulfill alarm function, which will kick off this pick winner function, which will go over to this randomness, which gets the random number, which spits it back over to the lottery function, which gets the winner. Right. And then you could hypothetically have the random number, then start the new lottery again.
00:56:25.012 - 00:57:17.510, Speaker A: So you'd have a continuous, provably random, super low overhead, decentralized lottery with just a couple of smart contracts here. It's super easy for those of you who haven't worked with interfaces, interfaces are a really easy way to work with smart contracts across your project. And I'm sorry we didn't get to go into showing how this works here, but if you want to check it out for some inspiration, again, it's not going to work on Robston. All the Oracles are in Robston, but if you switch them over to COVID or rinkby, it'll work. And that could even be like a starting base if you want to build something with that. I would love to see some more like a UI on top of this, a really nice UI, or an even better decentralized lottery or whatever you want to do. So that's just an example of using the VRF and the alarm clock really well together.
00:57:17.510 - 00:57:56.000, Speaker A: And we have like a couple of minutes here and we'll take some questions while we're here. This is actually insane. The interesting thing is that the competition is now on advertising level, not really on the. That is a fant. I really like how you even just made that comment. Yeah, that's something to think about since there's all these smart contracts out there. You don't even have to build a back end, right? If somebody builds a smart contract, puts it out there, your whole job could just be building a front end and driving traffic to that smart contract.
00:57:56.000 - 00:58:23.900, Speaker A: And yeah, you literally hit the nail on the head. Once the smart contract is out there and if it has the permissions that make it community resource, anybody can access it. Anybody could do it. And now you have this community lottery, and exactly as you said. Then it would just all be up to advertising and marketing and saying, hey, come on, this lottery, do it through our platform. Well, it really is. I feel like I don't stress this enough and I really should.
00:58:23.900 - 00:58:59.568, Speaker A: It really is this age. There's these wild amounts of new economic opportunities, these brand new ecosystems built around this stuff. You hit the nail on the head by saying, not really on the tech level as this is open source and every lottery could be technically perfect. Yeah, exactly. So how do multiple oracles get the same random result, though? How is the random number aggregated? That's a really good question. And the answer is. Sorry.
00:58:59.568 - 00:59:39.510, Speaker A: That's the blog if you guys want to check it out. Apologies. That's the blog if you want to check it out. How do multiple. The answer is, where's the VRF docs? I am having a hard time following my own docs here. Okay. The answer is you're going to use basically some aggregate method that's going to choose a random number for one of these because you can't do the same thing as like a median, right? Because then you're always going to get like a central value.
00:59:39.510 - 01:00:08.716, Speaker A: So you have all these oracles submit their random numbers and you would do some type of aggregation. You could also do some pretty cool off chain stuff with threshold signatures to get the random number off chain. Well, to kind of aggregate it off chain, which would be really cool. But yeah, there's a bunch of different aggregation algorithms you can run to get that. Awesome. Thank you. Horatio, thank you so much for being here.
01:00:08.716 - 01:00:34.070, Speaker A: You asked really good questions. A lot of you asked really fantastic questions. I'm really excited to see what you built. Made some really good comments. So that's it for this. I hope you guys learned a lot. Like I said, a lot of what we've done has been in remix because it's really easy to see, because it's really easy to deploy and because I can just click that button and be in there.
01:00:34.070 - 01:00:59.100, Speaker A: But yeah, the next couple of sessions are going to be a little bit more around truffle and building with node JS builder. Again, Dev is really popular too. If you guys want to check that out, that'll help you develop a lot faster. Again, you saw right there that I was clicking around a lot. You can script all that out. But yeah, that was it for this session. I hope you guys learned a lot and I will talk to you soon.
01:00:59.100 - 01:00:59.720, Speaker A: All right, bye.
