00:01:30.270 - 00:01:43.826, Speaker A: You. Hello. Hello. What's going on? Mike check. Mike check. How we doing? It is 831. Give it a couple minutes for some other people to show up and then we will get right into this.
00:01:43.826 - 00:02:03.706, Speaker A: We have a lot to cover today. A lot to cover today. There's a good chance that we're going to go over, but we are going to be doing something insane. So we're basically going to be going through a project that if you follow along with this, you copied the repo. This is basically kind of like a full scale project. This is nearly hackathon submission worthy. It just doesn't have a website to go with it.
00:02:03.706 - 00:02:27.860, Speaker A: But really excited to go through this with everybody today. So if you're just tuning in, this is exactly like kind of the end to end code with me. Code along where, like I said, we're going to build a dynamic NFT, well, a randomized NfT completely from scratch. So we can do it together. You can definitely follow along with me. Exactly. So really excited for this one.
00:02:27.860 - 00:02:51.562, Speaker A: And we're in HD now. You see that? I'm looking at that. Resolution looks good. I think the HD is coming through nice and clear. Oh, I love. Excellent, excellent. Hey, how's it going, everybody? Fox, Raymond, Mr.
00:02:51.562 - 00:03:20.660, Speaker A: Nguyen, how are you doing? Just give it one or two more minutes for some other people to show up. You should get some makeup so it could be more because HD now, now that it's HD, I can't shy away from all my blemishes. I appreciate that. You're good. Hey, how's it going? Welcome to the stream. Welcome. Got all my comments down at the bottom here, which is why I'm looking down.
00:03:20.660 - 00:03:39.420, Speaker A: Welcome. We're going to give it one or two more minutes just for some extra people to trickle in. Really excited for this one. Great job. I haven't even started yet, but thank you. Oh, for sure. Welcome.
00:03:39.420 - 00:03:47.420, Speaker A: Absolutely. Thank you. Check this out. Look what we can do. We can show comments and stuff now. Thank you. Appreciate that.
00:03:47.420 - 00:03:58.560, Speaker A: We got all this production value going in. I love it. Hello. Welcome. Exactly a topic you need right now. Well, excellent. We are exactly going to get into it in just one or two more minutes.
00:03:58.560 - 00:04:21.222, Speaker A: Appreciate it. Welcome, everybody. We have a lot to go over today, lot to go over today. So I will give less time than I have in the past workshops and we will jump into it. There's a good chance we're going to go over. I'm going to try to code as quickly as possible, but in the most sensical way that I can. Oh, I have this up.
00:04:21.222 - 00:04:35.526, Speaker A: Okay. Welcome off of them. I can even give you guys a sneak preview. Actually, I guess we'll give it one more minute. One more minute and then we'll jump right in. So again, I am monitoring the comments. I love for these to be interactive.
00:04:35.526 - 00:05:04.260, Speaker A: Please ask as many and all questions as you would like to ask here. How long would you go? This will probably be actually an hour and a half instead of just an hour. I will try to keep it to the hour and a half, but we'll see. Like I said, we're doing a full scale dap here. Okay, 843. Let's jump into it. So welcome one, welcome all.
00:05:04.260 - 00:05:33.870, Speaker A: Welcome to our NFT workshop here, where we are going to be building end to end from totally 100% scratch our own NFTs, which we are going to deploy real time to the rinkby testnet and we can actually even render it on openc. So we have to do a lot here. There's a lot to cover in an hour and a half. Let's get to it. Will this be available later? Yes, this will be available later. Thank you for asking. So let's jump right into it though.
00:05:33.870 - 00:05:58.466, Speaker A: I'm going to switch to the stream here. Hopefully you guys can still hear me. Okay, we're going to put my face in here. So this is what we're going to be working on, be working on deploying an dynamic NFT to OpenSea. So here's an example of what we're working on. So this is Opensea. If you guys aren't familiar with it, it is an NFT marketplace where you can deploy, sell and work with all your NFTs.
00:05:58.466 - 00:06:41.454, Speaker A: It's a ton of fun. And so what we're going to be deploying, we're going to be working on, are building and deploying these NFTs, right? So nfts, again, stand for non fungible tokens. So these are tokens that are non fungible. It means that they are unique, right? There's only one of their kind. So if we look at these, these are ones that we have deployed, these are ones that I've deployed to Mainnet and that we actually gave away as part of an NFT, almost like escape the room treasure hunt, which is a lot of fun. But what they have is something that's really cool is they have stats, right? So they have different statistics that are generated by the chainlink VRFs. These are verifiably random NFTs that we've actually created.
00:06:41.454 - 00:07:22.478, Speaker A: And this is something similar that like Avagochi's for example, is something that they use. They use the chainlink VRF to create these NFTs with purely random statistics, purely random stats. So if we look at this character, we see it has charisma, constitution, dexterity, intelligence, strength. And these are random numbers that were given to them, right? So this creates provably scarce and provably random characters that creates basically cryptographically provable digital scarcity and rareness, which is really cool and kind of a great way to show up. Hey, look, I have this awesome nft here. It's stats. And then you can use these obviously, to build any type of games on top of them.
00:07:22.478 - 00:07:50.940, Speaker A: You can show them off in any type of art gallery. Do whatever you want to do. So this is what we're going to be working with on Opensea. You can even check like the contract address. And this is kind of more the code of what's going on behind the scene, right? So this contract is verified so we can actually see. So if you guys even want to just look at this, you can go check this out. I'm actually going to comment, I think that this posts to YouTube, I'm hoping this posts to.
00:07:50.940 - 00:08:08.014, Speaker A: So here is the code. You can go check out the entire code base. We can actually even interact with the code or interact with the contract. So we go to this read contract bit here. Let's go to characters. Let's see what character zero is. Let's query up.
00:08:08.014 - 00:08:38.170, Speaker A: And we see all the stats on chain of this character. So we have the name, which is chain link Knight, charisma, wisdom, all this stuff which is showing up here in our NFT marketplace. And again, this is where you can buy and sell, do whatever you want to do with these chain link nfts. But just a really fantastic way to take your NFTs, deploy them. And again, kind of here's the whole collection. So this is what we're working on and this is what we're going to be building. And like I said, this is basically, my setup is falling down.
00:08:38.170 - 00:09:09.758, Speaker A: This is basically hackathon submission worthy right here. It would be great if we added like a website on top of this as well. But these are great kind of as their own. So let's go ahead and jump into this. If you guys want a written format of this, we've written a blog deploy, sell your own dynamic NFT. We have another one, another blog that's kind of the precursor to this. If you want to go through as well or just follow along with this video, because we're doing everything here are there any questions before we get started? So we see we have a couple of notes.
00:09:09.758 - 00:09:32.314, Speaker A: That looks so awesome. Yes, it does. Yes, it definitely does. Can I put rinkby ETH into an nft real ETH for sale? You can do whatever you want, anything in code. So the cost to generate the NFT depends on the network that you're on for the VRf. So cool. Let's jump into it.
00:09:32.314 - 00:09:47.662, Speaker A: So I have my code editor here, and this is Defi Brownie. Let's go to NFT. Just going to double check. I think this is the right one. Yes. Okay. This is the right one.
00:09:47.662 - 00:10:03.026, Speaker A: We have a blank vs code here, so we have absolutely nothing. And I'm actually going to hide my face. I know somebody told me I needed makeup, so I'm going to hide my face. Just kidding. But I'm going to hide my face. So you can see the whole terminal here. And I think that's big enough, right? Yeah.
00:10:03.026 - 00:10:31.134, Speaker A: If that needs to be bigger, let me know in the comments here. But. So we're going to start a project off the same way we're going to start off any other project. It's either going to be Brownie bake or it's going to be starting a hard hat project. We are going to do a truffle project. So remember, in order to use truffle, and again, you can use truffle hard hat burner, you can use whatever you want to do. I always type in truffle, even like it should be truffle ethereum because truffle is obviously going to get me like candies and stuff.
00:10:31.134 - 00:10:53.890, Speaker A: But if you don't have trouble, you do need node Js. Node Js. You can download node Js right here and then you'll know that you have it. If you do node V, it'll tell you what version of Node you're on right now. And then node comes installed with NPM. NPM, which these are what we're going to be working with. And you can do NPM, install g truffle.
00:10:53.890 - 00:11:24.234, Speaker A: I've already done it, so I don't need to do it here again. We're going to be doing this from scratch. But GitHub and dragons, I should show up GitHub dungeons. Patrick Alpha C. But if you want to just see the end result, see the end product here. I'm going to put this in the comments as well. Does metadata have to be on on chain or IPF is good enough? Great question.
00:11:24.234 - 00:11:41.774, Speaker A: We're going to go over that. We're going to go over that. So this is the, the repo with everything that we're going to go over. So if you want to just get clone this and go to town, absolutely. Have a blast. But I'm going to show you how to do it from scratch because this will be really helpful. So we're here and we have truffle installed.
00:11:41.774 - 00:12:13.726, Speaker A: So we're going to do truffle unbox, smart contract kit box. Remember, this is going to place into our terminal just a sample chain link repo here. Right? So we have our contracts like we went over yesterday, our migrations, our scripts, tests, blah, blah. Just going to give us all kind of the nuts and bolts here. I'm going to go ahead and just strip this down because there's a lot of stuff in here I don't care about. I'm going to delete this. I'm going to keep this one in here.
00:12:13.726 - 00:12:30.670, Speaker A: You'll see why in a minute. Delete this. I'm not going to rename it. I'm going to delete it. This is random, this is random number consumer. We want to keep this in here because we are going to be working with the chainlink VRf. We are going to be calling a verifiably random NFt.
00:12:30.670 - 00:12:55.274, Speaker A: So we're going to keep that in here. We're going to delete two of these again. We're going to keep the random number of consumer. This is just to get us set up. Just because this has a whole bunch of boilerplate code in here, why reinvent the wheel? And we're going to do two random number consumer ventures. We're probably going to change the name, but we're going to leave it in here for now. So we're also going to remove these.
00:12:55.274 - 00:13:07.630, Speaker A: Goodbye. Move the trash. Price number consumer. Goodbye. Goodbye. And then we have this fund read randomness request. Let's even do CD scripts.
00:13:07.630 - 00:13:34.278, Speaker A: CD random number consumer scripts. Copy, copy, copy, copy, R star. So we're going to move everything down one. Yes. And then remove random number consumer strips. Now, in scripts, it should just be those great tests. We're going to remove this.
00:13:34.278 - 00:13:59.870, Speaker A: We're probably not going to have time to go over tests. But if you want a production value application, you should definitely write some tests. We have testing workshop later today. Definitely don't want to miss that. That's going to actually speed up your environment, your building here. So here's what we have. We have a new chain link truffle repo, which is going to go over everything that we want in here.
00:13:59.870 - 00:14:38.554, Speaker A: What we want in here. Hopefully this makes sense where we are so far, because we went over a lot of this yesterday. So what do we have in our contracts folder? So we have this random number consumer Js, right? And remember, what this is going to do is this is going to, what this is going to do is our contract is random number consumer. It is VRF consumer. It's going to create a random number. It's going to create a random number and return it. That's it.
00:14:38.554 - 00:15:29.950, Speaker A: So we can even run the scripts. I'm not going to run it just in the interest of time, but this is kind of the boilerplate code just to get an NFT started, which is great, just to get a random number. What we want to do is we want to get an ERC 721 or an NFT. So the first question is, okay, what the hell is that? What is this nonsense? What is an ERC 721? Look it up. So ERC 721 and we're going to go to open Zeppelin. But ERC 721, similar to an ERC 20, is really just a standard, right? So it's a standard that says, here are the functions that define an ERC 721. And if we go to open Zeppelin, open Zeppelin is a package that you're going to use a lot.
00:15:29.950 - 00:16:16.202, Speaker A: They have a lot of fantastic tools for deploying smart contracts and using smart contracts. And we want to use the version three. We definitely want to use the version three. So the easiest way for someone to deploy in ERC 721 is just like this, right? Import solidity. We import this open Zeppelin contract and we just add this. My NFT is we inherit it and then we set the name and the symbol here, right? So what is this ERC 721 package here? So we can even google this. What is this code that we're importing? We can see it here.
00:16:16.202 - 00:16:59.660, Speaker A: There's a whole lot of stuff going on in here, right? And you can see these are the functions that define what an ERC 721 looks like. It has balance of, it has supports interface, it has owner of name symbol, this token Uri, which is very important. And we'll get to in a minute, base Uri approve. There's a lot of stuff in here. But again, an NFT is just a set of standards that everyone kind of follows, right? That's really it. New year C 721 and NFT, they're the same thing. Okay, so if we wanted to make a really simple NFT, what we could do in our contracts, we could do new file nftsimple Sol, literally copy paste this in.
00:16:59.660 - 00:17:26.178, Speaker A: What we're going to do is we need to install this. Mi opens up on contracts. Double check that. I'm installing this. Correct. Opens up on docs, open Zeppelin docs. We'll find out a second.
00:17:26.178 - 00:18:03.226, Speaker A: It's installing for some reason I can't find their get started page. Well, we installed it with NPM install anyways. But we install this NPM install, I opens up like contracts. This way we can actually interact with this stuff. In this way we import this code at the top and it's basically taking those standards and slapping it right at the top of this contract right here. Right. So it's importing.
00:18:03.226 - 00:18:37.674, Speaker A: It's importing. Thank you for importing. I think we did install the stuff from the truffle box as well. But if we didn't, we'll redo an NPM installer just to be extra sure. Installing, installing. We can even do a really sample migration to test this out. Okay, great.
00:18:37.674 - 00:18:52.160, Speaker A: So just to make sure. Did I do it there? Whoops. Oh no. Did I do in scripts? Oh no. We're good. Yeah. Okay.
00:18:52.160 - 00:19:32.392, Speaker A: Then we can do shuffle compile if everything compiles. Awesome. Everything compiled. Cool. So now just to deploy this really simple NFT, we're going to do a quick new migration. So we're going to do migrations, new file three nftsimple JsN. We're going to do nfT simple effects require nft simple.
00:19:32.392 - 00:19:54.620, Speaker A: This is going to pull in this NfT simple in here. We're going to get rid of this because we don't need to. We're going to make this really simple. This is going to be some not super great code because we're just going to say, hey, we're just going to deploy to COVID or actually rink b. We're going to deploy to rink B. Deploy. Deploy.
00:19:54.620 - 00:20:23.268, Speaker A: Be simple. And we're not going to take any parameters. Deploy, deploy NFT simple. And then we're also going to add one extra thing that's going to help us out a lot. And I'll show you what that looks like in a second. We're going to add this truffle plugin. Truffle plugin verify.
00:20:23.268 - 00:20:51.440, Speaker A: So what this truffle plugin that we're going to add in, it allows us to verify our code. Right on. Etherscan. Okay, so we're going to do API keys. We're going to set our API keys up like this. Etherscan process envi Etherscan. And what this is going to do is if you create a Env file, or you set your environment variables correctly.
00:20:51.440 - 00:21:49.444, Speaker A: This env file, you do API, ether scan API key equals blah blah blah blah, whatever your ether scan API key is. And this way when we go back to ether scan, remember how before I was showing you actually, let's see if it even ether scan when I was going through this contract and stuff, in order for the code to actually show up on Etherscan on our block explorers, we need to actually verify the code and verify that the code actually works. So we're going to add this truffle plugin. And let me just undo this. We're using this truffle plugin, verify to actually work with it to actually verify our stuff. And we can even google it and we'll NPM install it, start the plugin with NPM or yarn and it even has the instructions here. All you got to do is do plugins, truffle plugin, verify, and then add your API key.
00:21:49.444 - 00:22:28.940, Speaker A: So if you ever get lost, you can always come back here. And then we have this usage here and this is how we actually verify it. So it's going to be truffle run verify, blah blah blah. Or, excuse me, the way that I did it in the readme, it's like this, but same thing. First we need to migrate it. So we're going to do truffle migrate and this is actually going to deploy it to Rinkbee. Actually, before I do that, I should mention once again, remember we do need our mnemonic and our RPC URL.
00:22:28.940 - 00:22:53.108, Speaker A: Your mnemonic is going to know. Remember, it's going to be exported from metamask. It's going to be your mnemonic from here. If you didn't watch the kind of welcome to truffle hard hat, definitely go back and watch that video because that explains a little bit more RPC URL. Again, that's going to be your infura. It's going to be your alchemy or what have you. It's going to be the HTTPs URL for one of these sites.
00:22:53.108 - 00:23:17.264, Speaker A: And again, you can get keys for free. No worries. These are what defines where to interact with stuff. We also are going to need in our metamasks. Let's just double check in our rinkbee because we're going to be testing on rinkby. We do need testnet, Rinkby and testnet link. And again, if we ever get lost, we can come back here.
00:23:17.264 - 00:23:37.236, Speaker A: Testnet link is here. Testnet, rinkby is here. Boom, boom. That's how we can get both of those because we need both of those in our wallets, but great. So let's go ahead and migrate this. So we're going to do truffle migrate. And again, this is going to be deploying it directly on chain to the rinkby chain.
00:23:37.236 - 00:24:00.108, Speaker A: Truffle migrate reset network rinkabee. And let's just make sure we have Rinkbee set up in here. We don't. Whoops. So let's just get Rinkbee set up. Rinkabee. Network id I believe is three, four.
00:24:00.108 - 00:24:24.950, Speaker A: It's four. Network id is four. Mnemonic URL. Great. So rank B network reset and we're going to do f three. So this should only deploy this one. This nftsimple Js, I believe.
00:24:24.950 - 00:24:44.792, Speaker A: So let's go ahead and see if that works. So we're going to compile. Actually might not work because I don't think I did the initial migration. The network id specified in the trophy config forward does not match the one returned by the network id. 42. Whoops. Because I'm using the COVID RPC URL.
00:24:44.792 - 00:25:08.404, Speaker A: So I also have a rinkabee RPC URL. So we're going to switch it to that. And again, if you're like, what are environment variables? You can always set them in know, like know URL. And there's one for Rinkby, there's one for coven, et cetera. So this error makes sense. I think it still might error out, actually, because didn't do the initial migration. But I'm curious to test that now.
00:25:08.404 - 00:25:28.152, Speaker A: Now that here. Oh, I guess I can just do. Yeah, hold on. It's going to say could not find artifacts for and then that probably actually means that I didn't do. Yep. Because this is actually called my NFT. So nft simple now.
00:25:28.152 - 00:25:49.130, Speaker A: Because if we go to build right, it's going to say my NFT. It's not going to say nft simple yet. It says my NFT. Now let's do truffle compile. Now we have NfT simple in here. Now we can actually migrate, I think, unless we have to do the migrations first. But we're going to find out.
00:25:49.130 - 00:26:10.320, Speaker A: All right, great. Nope, says we're going to go ahead and deploy it. Awesome. So we're actually deploying it to rinkby. We get a transaction hash again. You can go check that out on etherscan. Once we're done here, we're actually going to verify it and I'm going to show you why this is so fantastic.
00:26:10.320 - 00:27:00.696, Speaker A: Truffle run. It's going to be truffle run. Verify Nft simple. We are on the brinkbee network and we also need the license, which is going to be MIT. So it's the MIT license. And so what's going to happen here is since we have, where's the contract address? Since we've defined our ether scan API key, which again, if you're like water environment variables, you can just set ether scan here, come back to Etherscan and you can sign in, get an API key right from here. What's going to happen is it's going to say pass verified.
00:27:00.696 - 00:27:11.984, Speaker A: Here's where it is. And that contract that we just deployed with an NFT. Boom. Now we can see the code. We can read the code. We can read all the variables. We can write all the variables.
00:27:11.984 - 00:27:42.072, Speaker A: We can do whatever we want. And if you've gotten this far and you're like, I just want to deploy an NFT, I don't care. I just want to deploy an NFt. You did it. This is it. Like you just deployed an NFT and it's verified on chain, so we can do whatever we want here, right? The name is going to be my NFT, which we probably should change. But this is as simple as it gets when it comes to working with and deploying like an NFT.
00:27:42.072 - 00:28:16.632, Speaker A: So that's kind of like the, hey, bare bones, we have an NFT. How are we doing on time? We're doing okay on time. Great. I'm going to answer one question. Can we do truffle verify on testnet? Yes, we can. Should you change the constructor for label and token? If we wanted to, yeah, like if simple. If we wanted to do that, yeah, we could, but we already deployed it, right? So this is the simplest way.
00:28:16.632 - 00:28:36.204, Speaker A: So now that we know, okay, we've done a little practice doing the simple one. Now let's do a really cool, crazy one. Okay, let's get with it. Let's get into this. Let's do one where we actually can be like, boom, check out my Nft on ether scan. Look at this. It's crazy.
00:28:36.204 - 00:28:57.844, Speaker A: We're going to do a really cool one here. This is going to be one with verifiably random stats. This is going to be one with true randomness that we can view on etherscan. So this is going to be, let's pop off, right? Let's do the darn thing. So we're going to be creating that dungeons and dragons Nft, right from scratch. Feel free to code along with me. Let's do the solidity first.
00:28:57.844 - 00:29:19.212, Speaker A: So now that we know, okay, this is all it takes to build, deploy an NFT, get it on ether scan. We didn't show you how to put it on openc yet. We will get there. Okay, so we're going to be using literally kind of the same setup as we just did here. So we're going to start with solidity 0.6.6 and same thing. We're going to import the ERC 721.
00:29:19.212 - 00:29:42.532, Speaker A: We also need to import a couple of other things. So we're going to import the chain link code. So this VRF consumer base is how we're going to interact with the chain link VRF. So we also have to make this inherited VRF consumer base. So my contract NFt simple is this and this. Let's even change the name. Let's change this to something crazy.
00:29:42.532 - 00:30:14.472, Speaker A: Maybe we want to do like, verifiably random dogs or something like that. Actually, I think I do have a cute dog that we can use. Yeah, I do have a cute dog. We'll do verifiably random pugs. This was actually provided by a chain link community member who is awesome. So shout out to them. So we'll do rng pup contract.
00:30:14.472 - 00:30:39.124, Speaker A: Rng pup is ERC 721. BRF consumer base again. So we're going to do constructor and it's going to be rng pup. The name of this is going to be rng pup. And so the symbol will do rng pup unless somebody else is like, hey, we really want to see dungeons and dragons characters. Let me know in the comments. If you guys have any suggestions for any fun nft stuff.
00:30:39.124 - 00:30:57.076, Speaker A: Keep it civil, please. Thank you. Thank you, Tomas. But, yeah, so we'll do rng pop. Unless people are like, yeah, no, we want to see the dungeons and dragons stuff. Actually, no, I changed my mind. I changed my mind.
00:30:57.076 - 00:31:22.452, Speaker A: Sorry. I have a lot of stuff, a lot of artwork for the DND stuff. So we'll just do that. So the name is going to be dungeons and dragons character. Dragons character. And then the symbol will be DND. So we have those two main pieces here.
00:31:22.452 - 00:31:58.850, Speaker A: So what we need in all of our contracts is going to be in constructor. Like I said, it's right here. But we also need it to work with the VRF consumer base. So this part right here is ERC 721. This is kind of the constructor of the ERC 721. We also need the constructor of the Erf consumer base. And then actually we're going to do constructor public.
00:31:58.850 - 00:32:33.000, Speaker A: We also need the VRF consumer base, which, remember, it takes the VRF coordinator and the link token. Right. So we can find those in the random consumer contract here. I'm going to go ahead and grab some code from the final example that has everything in it actually does the truffle. No, it doesn't. Okay, I'm just going to grab some stuff from the main piece that already has all this information. Scripts or migrations.
00:32:33.000 - 00:33:22.440, Speaker A: Actually we do it all on the migration. So these features actually when we do our migration scripts, when we do our migration scripts, these are some of the important addresses that we're going to need. We're going to need the VRF coordinator, which is right here. We're going to need the link token right here. Again, these are specific to rinkby. If you ever are like what's going on? We can go back to the documentation link token contracts, rinkby or whatever other chain that you want to work on. Matic for example, binance, smart chain, matic or polygon is a sponsor here.
00:33:22.440 - 00:33:51.476, Speaker A: They have super cheap fees. A lot of projects are being deployed on. Yep. And if you want to convert it, you can use the new peg swap, which is awesome, but we're not looking at that now. So Mumbai, they are sponsored, they're doing awesome stuff. XDI, whatever you want to work on. These are what we're going to need for rank B.
00:33:51.476 - 00:34:32.412, Speaker A: So we need the VRF coordinator, which again is going to be this. We need the link token address, which is going to be this. And, and that's really it. So in our constructor here, what we're going to need to do is we're going to need to set these variables so that we can work with them later. So let me scroll this down. Usually I like to make some contract variables up here. Up here I'll do like bytes, 32 internal key hash because nobody really needs to know the key hash or work with the key hash.
00:34:32.412 - 00:35:04.840, Speaker A: We'll make it public just for this demo so that we can kind of work with it and see it. We'll do un 256 public VRF coordinator and then we'll do, we don't need a link token address. So cool. So those are the pieces that we need. What we also need for working with the VRF. Again, if we look back here, we need these three variables as well. So we're just actually going to go ahead and copy paste.
00:35:04.840 - 00:35:33.204, Speaker A: I'm still calling this NFT simple. If you rename this to rename dungeonsanddragonscharacter sol. So we need the key hash and the fee and then the random result. We actually don't need the random result, but we'll keep it here for now. So the key hash and the fee, again, these are important pieces for working with the chainlink VRF. Again, we went over that recently. If you're like, what is the chain link VRF? Go watch our chainlink Vrf video.
00:35:33.204 - 00:36:30.484, Speaker A: It will explain everything and what all these pieces do. Great. So what we want to do now, let's set these up for success. So the VRF coordinator is going to be equal to this address that we give it. Key hash is going to be equal to key hash, which we have to set these in the constructor. So just for clarity here, we're passing variables to the constructor and then we're going to pass the variables that we pass to the constructor to this constructor. Right? So if I do address VRF coordinator, when we deploy this, we're going to pass it as an input parameter to deploy it.
00:36:30.484 - 00:37:12.092, Speaker A: And then it's going to automatically pass that parameter into the VRF consumer base, which is very good because we need it. So we also need the address, same thing here, of the link token, which again we're going to pass that to the VRF consumer base. And then again we need the bytes 32 key hash. Again, these are variables that we need in order to, and I'm going to do this because I hate not having word wrap on key hash. Key hash. We're going to be passing this down here. So this one doesn't go to the VRF consumer base, but we do need it to make our VRF calls.
00:37:12.092 - 00:37:28.090, Speaker A: Okay. And then we're going to do fee equals. We're just going to set it to something hard coded here. We're setting it to 0.1 link. This is saying take 0.1 times by ten raised to the 18th or 0.1
00:37:28.090 - 00:37:47.452, Speaker A: on different networks. This fee is way lower. We're just kind of defaulting to 0.1 to make it easy to understand. And what is the error variable? Must be mixed cased. Okay, well, don't tell me what to do. So we have our constructor set up.
00:37:47.452 - 00:38:31.740, Speaker A: Great. I'm going to have to speed up if we want to get through everything. Next, what we're going to do is we want to create a struct for a character, right? So how are we going to store our characters? Each one of our characters is going to be unique, it's going to be different. How are we going to do that? Well, what we're going to do is we're going to create a struct which is like an object in solidity or whatever, right? So we're going to call struct character. And this is going to define, this is going to almost be like the class that's going to define all the characters that we're going to create. And we'll give them some stats. We'll give it un 256 strength.
00:38:31.740 - 00:39:02.032, Speaker A: We'll keep it a little bit small strength speed. Right? Un 256 stamina. And then we'll do string name and we'll just do that for now. So in the actual example we do a lot more, but for simplicity's sake, we'll just do strength, speed and stamina here. So these are the characters that we're going to have. They're going to have strength, speed and stamina. And to keep track of them, we're going to need a list of these characters.
00:39:02.032 - 00:39:31.804, Speaker A: So we're going to create a character array, public characters. And this is where we're going to store all the characters that we create. Okay. We're also going to need some mappings, but we're not going to go into that yet. Mappings will go here, but we will come back to that. And again, we're going to put this comment in right above the constructor. Again, this just has all kind of the stats for rink B.
00:39:31.804 - 00:39:49.668, Speaker A: It's literally the same as what's up here. Don't worry about it for now. So cool. So we have the constructor. Now what do we need? Okay, well, let's build a function that will request a random number so we can create a new character. So let's create the function. Function.
00:39:49.668 - 00:40:10.860, Speaker A: Request new random character. What are we on for? Time. I have 50 minutes. Time to go fast. Request new random character. What do we need? We need a unit 256 user provided seed. And again, what is the user provided seed needed for? It is needed for the chain link VRF.
00:40:10.860 - 00:40:48.072, Speaker A: We'll give it a name, string memory name. And this will be a public function because we want to name our guys and we're going to have it returns bytes 32. Again, this is going to work for truffle, brownie, whatever. The solidity is going to stay exactly the same. Great. And in the actual example that I gave you, we're going to have a couple more like bells and whistles and some other stuff. We're going to keep it pretty simple for the video here.
00:40:48.072 - 00:41:23.872, Speaker A: But what we need to do in this is we need to request randomness, right? How do we actually get that random number? So byte 32 request ID is going to equal request randomness. Key hash C user provided seed. Right. So what are these, this request random, request random lockness. Request randomness. This is imported from the chain link VRF. We need to give it the key, hash the fee and the user provided seed in order to make that.
00:41:23.872 - 00:42:12.390, Speaker A: Now what we want to do is actually I'm going to skip that for now and we'll come back to it and I'll show you why we're going to do return request ID. Actually we're not going to skip what I just kind of mumbled under my breath. We're going to skip. So this is great. So this is going to request a random number and then in some fulfill number in a fulfill method. Once we get the callback, once we get the random back, we're going to do function fulfill randomness which is going to take that request ID and the random number that gets returned internal override. Don't worry about that for now.
00:42:12.390 - 00:42:42.220, Speaker A: This is where need to define the creation of the NFT. So this function, all it's doing is it's requesting a random number from the Chainlink VRF. And then in our fulfill randomness function this is actually where we are going to call back and get it set up. Yes. And this is vs. Code Emma. Oh, I still have, let me hide that person's comment.
00:42:42.220 - 00:43:20.324, Speaker A: Great. So this is where we're actually going to find it, define it, and this is where we're going to request it now since it's asynchronous. Right. So since we're requesting a new random character in a different stack or a different thread than where we're going to fulfill it, we need a way for the random number that we requested to match the random number that gets called back. So we actually have to set a mapping to do that. So when we request our new random character, we want to do a couple of things. This is where we're going to scroll back to the top, create some mappings.
00:43:20.324 - 00:44:20.092, Speaker A: I know I'm kind of bouncing all over the place, but it makes sense, I promise. So we're going to create a mapping of bytes 32 string and we're going to call this request to character name a mapping bytes 32 to address. And this is going to be request to sender mapping of a bytes 32 to Un 256 request to token ID. And these are the three mappings that we're going to need. Let's scroll down and figure out why we need these. So again, when we create this, when we request this random number, it's going to get fulfilled, it's going to get called back. The node is going to call this fulfill randomness function back and it needs to know, okay, which character is this random number associated with.
00:44:20.092 - 00:45:11.790, Speaker A: So what we want to do is we'll do request to character name of request id equals name. So we're saying I should probably spell things, right. That probably will be helpful. We're saying this request id that we just created, this random number request is going to be associated with this character name that we just gave, right? And then we also need request to sender of request ID. This is going to be message sender. So whoever kicked off this function is gonna be the owner of this NFT, right? That's who we want to be the owner of this NFT. So those are the two important functions that we're going to need here.
00:45:11.790 - 00:45:54.452, Speaker A: So let's scroll down to fulfill randomness now. So what happens is we call the random number, we say, hey, chainlink VRF, give us a random number please. Gets returned here and fulfill randomness. And now we can actually start doing stuff. So the way it works is the chain link VRF responds with random number and the request ID. And what we're going to do is we're going to create a new character ID. So un 256 new id is going to be equal to characters length because we have this characters array and we're going to set the id of this character to being the new length of this array of NFTs.
00:45:54.452 - 00:46:33.270, Speaker A: So let's give it some strength. Now. Un 256 strength, strength equals, we're actually going to just grab, we're going to grab a modulo of the random number. We're going to get a number between zero and 99 for this. But strength is going to be between zero and 99 and it's going to be from the whole random number. Un 256 dexterity equals. And we're going to do some fun stuff.
00:46:33.270 - 00:47:13.632, Speaker A: Random number, I spell that right? Random number module, 1000 divided by 100. This way we'll get different random numbers for each one of these, right? Because we're going to use the same random number to generate a few different random numbers. And actually what are the sets? Speed, stamina, up. So strength, speed and stamina, excuse me, not dexterity. Strength, speed, stamina. And you went 256 Emina equals. We're going to do the same thing, random number modulo.
00:47:13.632 - 00:47:47.390, Speaker A: But this one will be this many divided by 1000. So this is just a way for us to get multiple random numbers from the same random number. So we're basically splitting the random number. I'm just going to switch real quick. Basically splitting the random number into like little sections, right? We're saying, okay, these digits are for this random number. These digits are for this random number. Although this first one is just kind of the whole thing, but we're basically splitting up in a way that makes sense so we can have multiple random numbers there.
00:47:47.390 - 00:48:15.908, Speaker A: Great. So let's continue then. What we want to do is we're going to push this new character onto the array of characters. So we're going to do characters push, we have this characters array. Remember it's called characters, characters array. Called characters right here. We're going to push this onto the character array.
00:48:15.908 - 00:49:02.388, Speaker A: We're going to create a new character care actor. Boom. And we're going to give it the strength, speed, stamina, and we'll give it request to character name. Request id. So this mapping that we did above here, when we set the name of the request id, now once that request id is fulfilled and returned back down here, now we can actually use that name to set the character and add it to the character right here. And then once we do that, we're going to call this safe mint function. This is imported from open Zeppelin the RC 721.
00:49:02.388 - 00:49:49.472, Speaker A: We're going to call this safe mint function. What's going on here? Okay, I'll fix that. Call this safe mint function, which this is where we do request to sender. Request id, new id. So we're minting and we can actually even, we can see what safe mint does. Safe Mint mints the NFT, right? And it sends it to the owner with the token ID. So we're saying request to sender.
00:49:49.472 - 00:50:21.680, Speaker A: This is how we make that message again, request to sender up here. This is how we make the message sender the owner of it, even though the chain link node is what calls this fulfill function. So awesome. Now what we want to do is we want to just set this last little bit. So in the example we have a couple of other functions. We're not going to go into that now because we're just going to use ether scan to kind of check it out. But we want to set a token Uri.
00:50:21.680 - 00:50:44.336, Speaker A: So what is a token Uri? What is a token Uri? Here is what happened when people were figuring out NFTs. They said, nfts are awesome. We can put art on chain. This is great. Life's a breeze. This is awesome. Really excited.
00:50:44.336 - 00:51:31.190, Speaker A: However, storing a lot of stuff on chain is really expensive. And if you've probably interacted and if you've interacted with any chain, you've realized, wow, okay, doing a transfer costs like maybe a dollar or something like that. Imagine how much it costs to put a whole gigabyte on chain. So to kind of get around this, the art world in the NFT world says, okay, here's what we're going to do. We're going to create what's called the token Uri or token Uri. Look up Uri versus URL, because aren't those the same thing? They're often used interchangeably, but they're not a UrI. Could be IPFs, it could be HTTP, it could be whatever, but it's a way to identify a specific something.
00:51:31.190 - 00:52:34.452, Speaker A: So they said, okay, well here's what we're going to do. We're going to give it a token Uri that will return some attributes about it just so we can render it on these different platforms. So we are programmatically making these so that they can battle. They have these on chain stats so they can do whatever they want, but in order to render them and make them viewable, like for example on I closed OpeNC Opensea chain link wizard, they said we don't want to deploy this big image to the chain that's going to bankrupt us. So what instead they said okay, instead of that we're going to use a token Uri which is going to define where the image is stored, right? So you can do some type of decentralized storage. And this kind of brings, if you guys want to talk about like full stack blockchain, I'm really excited about that topic. IPFS and protocol labs is really excited about that topic.
00:52:34.452 - 00:53:23.530, Speaker A: And again, they are a sponsor of this hackathon, which is really cool. So in this token Uri, it needs to return a json object that looks like this. So it's just any API call basically, which can be IPFs, a server API, whatever. We're going to use IPFs again because we want a more decentralized transparent one where it just has the name, description, the image and the attributes. Again, the image, hold on, let me just make sure this looks good. The image needs to be something like this, right? So the image is going to point to something like this. And this is what we did for the chainlink NFTs that you guys saw before.
00:53:23.530 - 00:54:00.804, Speaker A: We have them stored, we actually have this image stored on IPFs so it's more decentralized. Although we can talk about some of the intricacies of how that works, filecoin is actually going to be a major improvement. So if any of you guys figure out how to do a filecoin backend for something like this. That would be really cool. But anyways, so this is what we need. So we need a token URi that represents, that follows this. So because setting that up, let's define the function that makes the token URi and we'll explain it in a little bit.
00:54:00.804 - 00:54:35.330, Speaker A: So if you're like, I'm a little bit lost. Don't worry, we'll get there. So we're going to do function, set, token Uri, token ID, and remember, new ID. This is what defines the token ID when we minted it. String memory token Uri. This is going to be a string that we're going to give it public. I am going to just copy paste this require in don't worry about this for now.
00:54:35.330 - 00:55:08.830, Speaker A: But all we need to do is do this. Set token uri, token id, token uri. Yeah, you can go check out the description to go look up these functions to figure out why that those are important. So we're going to set the Token Uri and then you can also do this on the fulfill, but we're just going to do it in a separate function here. So we're going to set the token ID to have the token Uri. And again, this is how we're going to be able to render the image on something like Opensea. Right? So great.
00:55:08.830 - 00:55:47.288, Speaker A: So we have pretty much all the functions that we need here to get one deployed. Obviously it doesn't look like much right now, but let's see if we can deploy this to the chain and see what we can do next. Right, so let's go ahead and create a quick deploy script. So in our migrations, I'm actually just going to delete this. Goodbye. We're going to delete this and we're just going to start from scratch. In our contracts we have, what do we have? Dungeons and dragons? We're even going to delete this actually, because we don't even need this either.
00:55:47.288 - 00:56:21.780, Speaker A: Goodbye. Goodbye. So we're going to create a new migration again to deploy character Js and this actually isn't even going to deploy the character. We're going to do rename this deploy character contract because that's more accurate. So let's see, actually, let's see if our, see if our stuff compiles. I'm just assuming I'm an amazing coder and ever make mistakes, which definitely isn't true. We all make mistakes.
00:56:21.780 - 00:56:57.436, Speaker A: Okay, let's see what mistakes are made. Visibility already specified as public is public. Okay, well that makes a lot of sense. We don't need this one again. Second time is a charm. No, didn't do it right the second time. Let's see, they spell something wrong.
00:56:57.436 - 00:57:23.110, Speaker A: Add address is not implicitly convertible to expected type of UN 256. That's because this is an address and not a unit 256. So that makes sense. A couple of typos here and there. By the way, key hash is defined twice. They're like right next to each other. Thank you.
00:57:23.110 - 00:57:38.724, Speaker A: Let's see, is that what the. Yes, there it is. Previous declaration is not here. Wait, what does it say? Identifier. Already declared. Okay, let's try again. A couple of compilation errors and boom.
00:57:38.724 - 00:57:52.210, Speaker A: Okay, cool. So let's look and build. We should be able to see, what do we call this? Dungeons and dragons. Boom. Dungeons and dragons has been built successfully. Awesome, great. Now we can go ahead and create this deploy script here.
00:57:52.210 - 00:58:27.736, Speaker A: So I'm just going to copy and paste a couple of things in here. Again, I said I was going to copy paste this before. These are the variables. Again, you can find these in the chain link docs. It's the VRF coordinator address for Rinkbe, the Rinkbee link token address, and the Rinkbee key hash. Again, you can find those in the chainlink docs. So next, what we need to do const dungeons and dragons character equals artifacts.
00:58:27.736 - 00:59:18.364, Speaker A: This is how we get the stuff in the build folder require. I'm just going to copy and paste this because it's silly to do the typos again. So we're going to grab this, this is how we get those builds, and then we're going to create the script. So module exports equals async function. If you're like, what are you typing? I would say, don't worry about it, just copy paste this and then you can kind of google a little bit later what this syntax is. So this is just JavaScript's way of saying, hey, this is how truffle is going to know what we're doing here. Okay, then we're going to deploy it.
00:59:18.364 - 00:59:55.688, Speaker A: So this is just going to be truffle syntax. We're going to do let D and D equals await because it's asynchronous dungeons and dragons character. Deploy. Excuse me, whoops, sorry, it's going to be apologies, we need to deploy first. Deployer. Deploy thunders and dragons character. And again, this is where it takes in the parameters that we gave it.
00:59:55.688 - 01:00:32.960, Speaker A: So what are the parameters of the constructor, the coordinator, the link token, the key hash. Okay, so we need to give it again. I'm just going to copy paste the coordinator link token. How are we doing on time? Not great. Super speed. D and D equals await and dragging character deployed. So we're saying, okay, great, this is what's going to deploy that contract and then we are going to let dnD equals this deployed.
01:00:32.960 - 01:01:03.272, Speaker A: Okay, and that's it. So we're just going to deploy this to rinkby network. This won't work on other networks because we're hard coding it to rink B. But let's see if this works so we can do truffle migrate reset network. Rink B again. Because I have all my environments variables set up correct, we should be able to deploy this no problem. And this is going to be our super sick contract.
01:01:03.272 - 01:01:39.304, Speaker A: Here's export default to be full ESC six friendly. Yes, es six friendly. Es six es. Five common js. These are things that I got to learn more about recently and I decided that JavaScript is wild, so I messed something up. Deploy invalid or does not take parameters. So we got to take a quick look see.
01:01:39.304 - 01:02:05.968, Speaker A: We'll see where I messed up here. Wait, deploy to deploy dungeons and dragons character. Dungeons and dragons character constructor. Constructor. So we did something wrong. What do we do wrong here, guys? So we can even look at the build contracts. Dungeons and dragons character looks like it takes an address.
01:02:05.968 - 01:03:15.770, Speaker A: An address and a bytes 32. Let's see in the deploy address address and a bytes 32. Okay, so what did we mess up? Here's actually did mess up require. I think this is only for ownable. Oh no, that is for that invalid or does not take parameters. What did I mess up, guys? Anyone see where I messed up? Deploy to deploy rink BvRF link token key hash copy and paste. My working demo.
01:03:15.770 - 01:03:42.160, Speaker A: This is pretty much the same code. It just has a couple of ifs. If thens saying if you're working with rinkby, great. If not, you messed up. Let's see if it was the script or if it was the contract. So if this works, then I messed somewhere up in the script. If it doesn't work, then I messed up somewhere in the contract.
01:03:42.160 - 01:04:03.864, Speaker A: So let's find out together. We have a half hour left. I think we can do this to opensea and rip this out. I think this will be perfect timing, actually. So we're saving migration to chain. Keep track of all our migrations. That's what this first one does.
01:04:03.864 - 01:04:31.010, Speaker A: This initial migration, deploy to deploy migrations. And then we're just going to do this one. And it looks like I messed up my script here. That means because it's working so sorry, guys. It's working now. Yeah. Do you guys see where I messed up before? I don't see where I messed up before.
01:04:31.010 - 01:04:51.684, Speaker A: Deploy ringping. Well, in any case, this one's working. Bytes 32 check. Maybe there's a bytes 32 check or something. Oh, actually, there's a good chance you're right. No, it looks like that's right. Well, in any case, this one's working, and we just added a couple.
01:04:51.684 - 01:05:08.380, Speaker A: Like, if network starts. I thought this was exactly the same module exports. Did I do module exports wrong? Oh, my gosh, I did. I didn't do exports. Wow. Okay. Embarrassing.
01:05:08.380 - 01:05:27.964, Speaker A: Well, in any case, we'll keep this in here so it works. So we've deployed it, right? So we can go see this contract address. We're going to go to rink B ether scan. And remember, it's not going to be verified yet. Yeah. Module exports. That was my mistake.
01:05:27.964 - 01:05:38.950, Speaker A: Whoopsies. Thank you. Thank you for looking out here. But we see. Great, we've deployed it, but that's about it. So we can't really do anything much with this on Opensea. Right? So we can even copy this.
01:05:38.950 - 01:05:55.524, Speaker A: We want it to look like this. Let's go to the Rinkbee testnet. Right? Rink B. Testnet. Sorry. Rinkbe openc. Openc.
01:05:55.524 - 01:06:24.644, Speaker A: Rinkbe. So this is the testnet on rinkby. Are we on the Rinkbee network? Let's just double check. Great. We are this address in here, or actually, let's go to my profile. We're going to sign in. This is my metamass that's associated with the private key that I'm using, saying I'm unnamed and I don't have anything because there's nothing to have.
01:06:24.644 - 01:06:48.780, Speaker A: It's like, what are you talking about? There's nothing. We have nothing for you. So let's verify this contract again. We're going to do that truffle run. Truffle run. Verify because we have the truffle plugin installed. Truffle run, verify.
01:06:48.780 - 01:07:03.840, Speaker A: Just going to copy paste so I don't misspell. Dungeons and Dragons character network. Rinkabee license mit. 25 minutes. Here we go. Here we go. We're doing it.
01:07:03.840 - 01:07:27.480, Speaker A: We can do it. So now we're verifying this on etherscan because, again, I have my API up. Now we can see it on openc. We can see it here. Great. And we have this thing verified, which is awesome. And can we see it now on Opensea? I don't think so, actually.
01:07:27.480 - 01:07:49.836, Speaker A: I think we can't see all items. Aha. Here we go. So we can see. Oh, so I've deployed a ton of stuff from here. Oh, whoops, I cheated. So these are the ones that we just deployed, right? And obviously it's empty chain info.
01:07:49.836 - 01:08:27.976, Speaker A: Is this the token ID 2 hours, 30 minutes ago. Maybe this isn't the case one of these, is it? So clearly I've deployed this a ton of times because I've worked with this a ton of times. So we can't see anything though. It's just a blank. Nothing. So that's not helpful to us at all. So what do we want to do now? Well, first this code we deployed was just the code for getting all the framework set up.
01:08:27.976 - 01:08:41.652, Speaker A: We haven't actually requested anything yet. Right. We haven't called this requesting random character. So this is going to be an empty array. So remember, if we go to openc, if we go to dungeons and dragons character, we go to the contract. Read contract. Let's go see characters.
01:08:41.652 - 01:09:16.392, Speaker A: Zero. Let's see, is there a zero character? It's going to be nothing, right? Because there's no characters have been created yet. So we need to actually create a character. So in the example, I have a script that actually calls this request new random character. We're just going to call it from ether scan in the interest of time. But if you want to see the scripts that actually do it, definitely go check those out. There's a script for funding the contract, for sending it link.
01:09:16.392 - 01:10:05.256, Speaker A: There's a script for generating a contract. But yeah, just in the interest of time, we're just going to call it right from ether scan. So we're going to connect to web3 here. Connect. Awesome. What I'm going to do is I first need to send this contract some link because in order to request a random number which can send it to just case we want to create a whole bunch of these, if we want to create a random number, we need it to be able to send a link to interact with a chain link, vRF. And again, this is another one of the major benefits of doing everything in your coding environment like vs code, because you can just put everything that we're going to do right here into a script so that you can just kind of repeat it and not have to do all the kind of manual work that I'm about to do.
01:10:05.256 - 01:10:30.672, Speaker A: So it failed to testnet. Sometimes things fail on the testnet. Maybe let's make the gas crazy high 50 gwe we're going to send it link. And once we send this contract link, then we can actually request a new random character, right? And then we'll be able to actually see it. Great. So we actually did it. We're going to quest a new random character and we're going to give it a name.
01:10:30.672 - 01:11:22.370, Speaker A: So we'll do a random seed of like, I don't know, 123-4567 or four, five, six. And we'll give it a name of, we'll do Hackathon night. Right? Can I read property methods of undefined. Oh, did I mess something else up? Can I read property? Oh, I should probably, should connect to web3, right? That's probably helpful. Connected to web3 is important, guys. So now we're going to confirm this transaction and we can view it. And this is the transaction that's actually doing the random number getting.
01:11:22.370 - 01:11:56.124, Speaker A: So we just called this request random number, which kicks off a request randomness to the chain link VRF. And the chain link VRF is going to return by calling fulfill randomness. And it's going to create this random number or, excuse me, it's going to create this random character for us, push it onto the array and then mint it. And we're going to be the owner. Right? So that's what's happening behind the scenes right now. So let's refresh. And remember we have to wait two transactions for this, right? So we have to wait for this transaction to fulfill succeed, which it did, which is great.
01:11:56.124 - 01:12:21.568, Speaker A: And then we have to wait for the chin VRF to actually return and create this provably rare character here. So now if we go back to read contract, remember how there was nothing here before? There probably will still be nothing. No, just kidding. There's a character here now. So we see its strength, its speed and its stamina. So it's called the chainlink hackathon knight. It's got some pretty abysmal stats.
01:12:21.568 - 01:12:32.090, Speaker A: But you know what? It's the first one, so we'll go with so. Okay, awesome. So we have an NFT. We did it. Congratulations. We call it a day. We move on.
01:12:32.090 - 01:12:48.300, Speaker A: No, just kidding. We still want to deploy it onto Opensea. We want to see it on Opensea. We want to work with it on Opensea. So we still have a little extra work to do. So remember how before I said, okay, we have this token uri thing. So let's even go to this on the rinkbe openc.
01:12:48.300 - 01:13:21.400, Speaker A: No items found. That's so annoying. My profile unnamed sound of this account. Okay, here we go. Copy this. There's a good chance it's just taking Opensea some time to propagate CLms again. Yeah, Opensea is probably just being a little slow to update, which is fine activity.
01:13:21.400 - 01:13:38.764, Speaker A: Of course there's not going to be anything activity created a minute ago. Oh, to you a minute ago. Oh, so we did create it. Great. Okay, here we go. So this is the NFT that we just created and it's like what? There's something on chain. I don't really know what's going on.
01:13:38.764 - 01:13:56.272, Speaker A: I can't really render it because it's looking for that metadata that it doesn't have yet. So this is the one that we just created. Right. It's like dungeons and Dragons character aka. Right. And that doesn't mean anything to anybody. So what we need to do is we need to set a token Uri and to do that we're going to add this to IPFs.
01:13:56.272 - 01:14:20.732, Speaker A: And again in my example I have some scripts that actually a script called like create metadata that do a lot of this stuff for us. We're just going to do it manually because it's going to be a little bit quicker. So I have IPFs installed. If you don't have IPFs you should definitely get it. It's awesome. It's a lot of fun. And what we're going to do is we're going to create this.
01:14:20.732 - 01:14:59.284, Speaker A: So we're going to do files in here and we're going to create the metadata for this guy. So I obviously have a bunch of different files in here because I've done this a bunch of times. But we want to create some metadata that looks like this. And we're going to set the token Uri of this equal to that. Right. We're going to set the token Uri equal to the API call that we're going to create in here. So let's actually create a file and then we'll import into IPFs.
01:14:59.284 - 01:15:29.676, Speaker A: So here's what we're going to do. New folder metadata. In this metadata folder we're going to do chainlink, Hackathon, Knight, Json. And in here we're going to have the metadata. And again, in the interest of time, I'm just going to go a little quicker. So this is, we're going to define everything. So I have a script that automatically creates it based off what's on chain.
01:15:29.676 - 01:16:08.604, Speaker A: If we look on chain again, where is the read contract? Is this it? This has got to be it. Yeah. Character zero. We do have to manually set it in our metadata folder. So we're going to set strength to 48, speed 34. And again, I have a script that automatically does this and then this was stamina. Stamina for 48.
01:16:08.604 - 01:16:33.492, Speaker A: And then we're going to get rid of the rest of this. Goodbye. We're going to call it link Hackathon night. And then we're going to call the description. You just win. Just kidding. We're going to call it chain link hackathon is where I learned to do this.
01:16:33.492 - 01:16:59.660, Speaker A: That's a stupid description. Rules, we'll go with that. Chain link rules. So this is the token uri that we're going to set. And again we have this. It's blanking because I have ipfs up. Sorry.
01:16:59.660 - 01:17:13.124, Speaker A: We'll close it real quick. And this is going to take us to image of the chainlink knight. So this is the image that's going to be rendered. Right. And again, this is also stored on ipfs. So great. So we have this metadata here.
01:17:13.124 - 01:17:40.824, Speaker A: Now let's pop into our ipfs desktop and we're going to import a file. Actually I'm going to hide my screen real quick just in case I don't go somewhere stupid in my folder here. Here we go. So chainlink hackathon night. Json, we're going to open it. Imported it. Great.
01:17:40.824 - 01:18:04.470, Speaker A: We're even going to pin it. Chain link hackathon night. We're going to pin it so it stays up. If you guys want to check out IPFs pinning services, I definitely recommend that you do. They will help keep your pins up longer. But this is what's going to define how Opensea actually knows what our thing looks like. So now what are we going to do? Share link.
01:18:04.470 - 01:18:22.536, Speaker A: We're going to copy this. Link files. Whoops. Now that we have it in IPFs, share link, copy the link. We're going to go back here. And again, I have a script that does this, but we're going to do it here. Oh yeah, we do it live, guys.
01:18:22.536 - 01:18:41.196, Speaker A: Oh yeah. I'm showing you this stuff works. This stuff is fun. And we're going to go back to the right contract, we're going to connect back to web3. Okay. And we're going to do the set token Uri. So the token ID is going to be zero, right, because it's the zero token that has this token Uri and we're going to set it to this.
01:18:41.196 - 01:19:20.056, Speaker A: And again, remember we have access parameters so that only the owner, only myself can set this. We're going to do write, confirm, view our transaction. And this is pretty much the last step that we need to do in order to get this to render on IPFs. Just checking my notes here to see if I missed anything. And once this is up, we can go back to this and it will show up here that the metadata is actually here. So we'll do a quick refresh and we'll see if we did this properly. If we did it properly, Opensea will be like, oh, okay, that's what you meant.
01:19:20.056 - 01:19:46.612, Speaker A: I can understand the token uri. I can't understand the onchain attributes. I'm actually looking forward to when these marketplaces understand the on chain attributes instead of having to do this token uri thing. But again, IPFs makes it really easy and blockchain y, if you will. Right? Filecoin and IPFs together is going to be a way to have like a decentralized database and do this, which I think will be a lot of fun and really cool. So let's refresh. Let's see if it worked.
01:19:46.612 - 01:20:20.440, Speaker A: And boom, there it is. So we have our night here, right? We can check out the levels, we see speed, stamina, strength. We can see the chain info, we can see who owns it, right? It was created by me eight minutes ago and now we can do whatever we want with it. And now we have it list. Okay. I'm super excited that we did this real time. So in an hour and a half, in less than an hour and a half, we've created a digitally scarce piece of artwork, deployed it to a testnet and showed it on an NFT marketplace.
01:20:20.440 - 01:20:44.036, Speaker A: And you can reproduce this exact same thing for Mainnet. Just swap out, obviously the addresses and the API keys for their main net equivalents of the rinkby ones that we did. But this is like end to end. We've built an NFT. Obviously we did a little bit of the artwork before. You probably want to do some of the artwork yourself previously. But I know we went through a lot of stuff right here.
01:20:44.036 - 01:21:10.400, Speaker A: And again, the full repo for everything with more of the scripts, with more of kind of what we. More of the stuff in here is available here. Again, I will drop this into the chat. Drop that into the chat here. The article that goes over everything, it's in here. I just updated this to be able to do env files. So if you're confused with environment variables, you can use env files.
01:21:10.400 - 01:21:35.764, Speaker A: But with that, I'm sorry, I wasn't showing. Hold on. This is the repo that has everything. It's recently updated to have env stuff in it. Here is the article, like I said, that goes along with it. I will drop this into the chat as well. There are two NFT articles that you guys can read.
01:21:35.764 - 01:21:57.116, Speaker A: That will go over more of this as well. I know we sped through a lot of stuff here, so we definitely have time for questions. So I'm going to be looking down on the questions now. Are there any questions? Okay. Hey, Patrick, is it possible to change the stats of your NFT after minting? Okay. Triggered by some sort of event. Also would want to restrict it.
01:21:57.116 - 01:22:19.408, Speaker A: So only the owner originally minted has permission to do so. Yes. Great question. And the answer is absolutely. So if we go back to the stream, if we go back to here, the way that we set it up and the way we set up the contract is that it only gets minted once. Right. So this is digitally scarce, but it's not so much dynamic.
01:22:19.408 - 01:23:01.036, Speaker A: A dynamic way to add this in would be to say, okay, maybe add another, like a function. And this is what I wanted to do, but we didn't have enough time function battle. Right. And it pulls a random number and it sets them and it pulls a random number, like pull RnG and then use Rng to battle weighted on stats or something like that. And then winner updates. Right. And so that is something that you absolutely could do for other dynamic NFTs.
01:23:01.036 - 01:23:29.848, Speaker A: Right. Obviously, what else you could do is something a lot of people talked about is like, create an API or something that connects to weather data and it updates the NFT real time whenever it's, like, raining or something like that. Or whenever the president changes or something like that. That would be also a dynamic NFT and just a crazy cool something that we haven't seen yet. So great question. Absolutely great question. Let's see what other questions? Props for coding.
01:23:29.848 - 01:23:46.320, Speaker A: Thank you. I tried bidding for. I wasn't promoting it. You should be a dungeon master. I want to play that game. I actually love being dungeon master. I prefer being dungeon master.
01:23:46.320 - 01:24:08.568, Speaker A: Thank you. Okay, what else? Any other questions? Why did you use truffle over hard hat? Great question. And really, the reason is, when I was first making this, I knew truffle better, so I used truffle. If I were to redo it, I definitely would redo it with hardhat. I mean, truffle still gets the job done, obviously. And all these contracts will still work with hardhat. Right.
01:24:08.568 - 01:24:37.004, Speaker A: It's no different. It's just a different framework. So if you're like, hey, I want to do this hard hat again, just copy paste the contracts into hard hat. Is it possible to make an NFT burn itself if certain conditions are met? Or would that incur a network fee? Is it possible to make an NFT burn itself? Yes. It would also incur a network fee. Right? Because anytime you make any type of state change to the blockchain, you do have to pay a little bit of that gas parameter. So it would incur a network fee.
01:24:37.004 - 01:24:54.544, Speaker A: However, that would be really cool. Maybe you burn an NFT if somebody does something bad or something like that, or their Pokemon dies. But yes, you could do that. Absolutely. Great question. Any other questions here? These are good questions. I'm going to move this up so I'm looking at the camera.
01:24:54.544 - 01:25:12.092, Speaker A: Any other questions here? These are great questions. And if there are no questions, I'm assuming that means you guys all got it. You guys all killed it. Oh, sorry, I didn't see, I skipped a couple of questions. Sorry. Can set Uri be called anytime after the minting by the original owner? We would like to change metadata triggered by events. Wondering if that's possible.
01:25:12.092 - 01:25:49.112, Speaker A: Oh, I think I did just answer this. Yes, right. Because the way that I set it up here, just in this example, is we have set token Uri the way we have it set up is it just anytime it can be set right. But the token Uri again is only what is going to be shown to the world. Right? On chain, this won't change the attributes at all, right? This won't change the on chain attributes at all. In order to change the on chain attributes, you'll have to have some type of function that can actually do that. So really the answer is, anything is possible through code.
01:25:49.112 - 01:26:28.790, Speaker A: You can set these functions up to be in any way that you please. So absolutely great question. Can anyone other than the original owner set the token Uri? Let me go back to the code. So this function right here is approved owner. I kind of skipped over it when I was talking. This is a function from the ERC 721 import from open Zeppelin, and it basically says, it checks to see if the message sender is an approved member of the token ID. So the owner of the token iD can quote unquote, set approvers who can update stuff.
01:26:28.790 - 01:26:57.244, Speaker A: And this is just a really easy way to do it. So right now, the way I have it set up, only I can set the token Uri because I haven't set any other approvers and I am the owner. So this is a function that protects you against that. So access controls are really important. And if you want to learn more about access controls, again, opens up one is going to be your friend here. Go check out the opens up packages to do that. Great questions.
01:26:57.244 - 01:27:19.830, Speaker A: Really good questions here. What would have been different with ave protocol. I'm not sure I understand this question. So you could do like flash loans with your NFT. That would be kind of cool. Thinking about ah, you should check out the Abagochi code. Actually, if you want to learn more about how theirs work, they definitely do really cool stuff.
01:27:19.830 - 01:27:56.012, Speaker A: Can I use Photoshop to create? Yes, yes, you absolutely, you can use whatever you want. Wouldn't updating NFT state from weather data, for example, also incur gas link fees? Yes, it would. Great point. However, if you had it just be like a view function, right? For example on a data feed, right? If you're just pulling the data feeds, it would not incur a feat, which would be really cool actually. So if you set it up the right way. No. Who created the images shown in OpenSea? That would be our amazing designer, Julian.
01:27:56.012 - 01:28:29.992, Speaker A: He is a monster. He makes super cool art. Right? What about generative art? Would that be possible to have an organic NFT based on a script like processing? Yes, you can do that. Again, the answer is, anything's really possible through code. All this is really possible through code. So great questions, great questions. Any other questions here? I'm going to sit on here for another two minutes and answer some questions.
01:28:29.992 - 01:28:46.188, Speaker A: These are great questions. I know we went through a lot here. This was a ton of fun. We actually deployed like an NFT with art, with stats with on know, verifiably random stats live, which is insane. Which is so much fun. What a way to start the day. Feeling inspired.
01:28:46.188 - 01:29:02.804, Speaker A: Excellent. I'm glad to hear you're feeling inspired. I'm glad to hear that you're ready to build. You're ready to be excited because this is how I feel. I feel super excited. You guys are working on some really cool stuff and I'm really excited to see what everybody's working on, especially in this space. Right? So thank you.
01:29:02.804 - 01:29:46.672, Speaker A: Any other questions? Any other questions? I do have to hop off in two minutes because Ave is actually going next and they're going to be a blast as well. So if you want to see Ave kind of give their demo, Mr. David will be going on and he will be explaining more stuff about Ave, which will be a blast later today. We have a ton of cool stuff lined up for the hackathon workshops. We are doing testing and multi chain at the end of the day today, which is going to be a blast. I know a lot of people, we do a lot of demos where we deploy to testnets because it is kind of the best, most accurate way to test your stuff against real oracles however, testing and deploying locally is obviously a blast as well because it's going to be faster. You're going to be able to iterate a lot faster.
01:29:46.672 - 01:30:10.296, Speaker A: I'm going to show you guys how to use mocks and everything. Data feed example in the future would be nice. Thanks. I will put it on my to do list, but my to do list is pretty long. I would love to see somebody make a data fit example because I feel like it would be very doable here. I have a problem activating my metamask account. How can I log back into it? That's a longer question.
01:30:10.296 - 01:30:42.896, Speaker A: I would say. You might want to ask metamask support, but if you have your seed phrase, you should be good to go and you should 100% have that backed up. Is it possible for the original minter to burn an NFT after it has been transferred? If you set up the code that way, the one that I just set up? No, the original minter cannot burn it, so it depends on how the code is written. So this is why audits are important. They check for that stuff. All right, well, it is 10:00 I got to jump off. Thank you all so much for coming.
01:30:42.896 - 01:30:44.868, Speaker A: Looking forward to you on the next one. Bye.
