00:00:03.850 - 00:00:22.510, Speaker A: Welcome, all of you. This is amazing. Together with myself today, we have like a guest lecturer or co lecturer, Masa Musawe from Offchain Labs. She is going to talk all about arbitram today. So, Masa, if you want to say hi to fox, feel free to do so first.
00:00:22.660 - 00:00:47.100, Speaker B: Yeah, I already said GM, if that counts, of course. But yeah, no, it's really exciting to be here. I'm Masa, as Andre said, I'm an integration engineer at the offchain labs. And for what it works, I'm in Montreal, so it's really cold and chilly and snowing in here and. Yeah, happy to have.
00:00:48.510 - 00:01:09.694, Speaker A: Amazing, amazing. Let's quickly take a look at a chat. Okay, I think we have a decent number of participants. We have a quorum, obviously. Guys, if you're continuing to joining in, you're more than welcome to follow along. As I said, use chat for general stuff, q a for questions and, yeah, we can start. So I'm going to hand the mic over to Masa.
00:01:09.694 - 00:01:18.950, Speaker A: She's going to do the first part, as I said, all about arbitrum. Again, Masa Musawi from offchain Labs. Masa, the floor is yours.
00:01:19.290 - 00:01:28.220, Speaker B: Thank you. I'm going to share my screen and please let me know if you can see that. How does that look?
00:01:29.070 - 00:01:32.150, Speaker A: Looks perfect. I can see the exploring arbitrum title.
00:01:32.310 - 00:02:04.930, Speaker B: Amazing. All right, so I'll take the floor. So welcome, everyone. For those who have not heard our intro, my name is Nassau. I'm an integration engineer at the offchain labs. And today I'll be co hosting a chainlink CCIP masterclass with Andre. For all of you, I've just heard that Chainlink also had another, like, the whole set of master classes, so I invite you to look at them all on YouTube.
00:02:04.930 - 00:02:38.720, Speaker B: So a bit myself. Again, I'm in Montreal in Canada, and I'm both doing phd and an integration engineer at the offchain labs. And this is my twitter. If you feel like you have any question during the presentation that I'll be giving on arbitrum, please feel free to reach out to me on Twitter or on arbitrum's discord. I'll be very happy to answer any questions that you might have. And this is the website. If you need to reach out to me via email or other social media.
00:02:38.720 - 00:03:41.890, Speaker B: All right, so, as Andre said, I'll be walking you guys through what is arbitrum? We stay really at a high level because we don't want to get into nitty gritty details. We just know the high level of what arbitrum technology is and what are the benefits of building a CCIP on arbitrum chain. So arbitrum, for those that do not know, is a layer two scaling solution. And it's an optimistic roll up. And we provide ultra fast and ultra cheap transactions that derive security from the Ethereum blockchain. The transactions that you do are really cheap and not expensive, and there's no heavy crypto involved, there's no magic, it's just that it's a roll up. So it's an optimistic roll up that is deriving security from DL one, which is the underlying chain, and it is the Ethereum blockchain in this case.
00:03:41.890 - 00:04:40.438, Speaker B: And we leave a really minimal footprint on L one. So you don't even have to pay a lot of ether for the call data that is being posted on l one. And it is fully trustless, meaning that the security is rooted from Ethereum blockchain. And other than that, you don't have to trust anything else. And we do have interactive fraud proofs in place, which is basically, if you see that in the talk, I'll talk about how the technology works, but at a high level, the way it works is if there's anything that goes wrong in the state of the chain, we have some protocols implemented for anyone to come along and try to challenge those outputs of the chain. And it's dropping compatible, meaning that it is fully EVM compatible. So if you're building on the Ethereum blockchain on the EVM, it would be very easy, extremely easy for you to build on arbitrum as well.
00:04:40.438 - 00:05:22.014, Speaker B: Porting is really easy. It's basically one click and it basically works with any existing Ethereum dapps and tooling that you currently are using on the Ethereum blockchain. So let's quickly see how it works. Again, I'm not going to go through the details, but if you have any questions, feel free to drop in the chat and I'll try to answer. So the way it works is arbitrum is basically another chain that is working on top of the Ethereum blockchain. So here at the top you see the arbitrum chain and at the below you see the Ethereum blockchain. So these two chains are both basically progressing via the state transition.
00:05:22.014 - 00:06:22.946, Speaker B: And for the arbitrum chain to be able to operate, what we do is we put a set of smart contracts, we call them bridge contracts, on the Ethereum blockchain. So both chain, they progress as they get a transaction, as the input of the chain, and on a regular basis right now is every 30 to 45 minutes there is an operator that commits, that basically puts the output of the arbitrum chain and put them on the bridge contracts on the Ethereum blockchain. And that is what I meant, but by deriving the security from the underlying l one. So what happens is that output is being placed on the Ethereum blockchain and then it's public, it's available for anyone to go and check the output of the arbitrum chain. And this continues. And everybody can check the output, it's fine. But let's say that the operator puts an output of arbitram chain on l one, which we find incorrect.
00:06:22.946 - 00:07:17.970, Speaker B: So what happens is now the protocol goes, the fraud proof protocol goes live, and anyone can come, they can challenge the output. And this can happen in a very cheap manner, because the way the protocol works is it really gets down to that little step in the execution where 2% started to have different outputs for the chain, so it doesn't go and compute every step in the computation in the whole history. And after that they can both reach out to an agreement of which output is correct, and then the chain corrects itself. So we have life fraud proof in place. That is really how arbitron works. I don't want to get into the detail because we have the breach contracts that I described. It has outbox contract inbox for getting the input and output of the chain.
00:07:17.970 - 00:08:13.290, Speaker B: We have the roll up, who's basically responsible for managing these challenges between the validators. But I won't go through the details, but feel free again to reach out to me and ask questions or drop them in the chat. But what I want to do instead is I want to do the sneak peek into the arbitrum. I want to talk about the current chains that we have and also our exciting future development so that you can really get an understanding of what's going on in the arbitram space and also understand why you should build CCIP on Arbitrum. So we have different chains. Our main chain is Arbitram one, which is an optimistic roll up based on a roll up technology. It's a main net, and according to the l two beats is the most famous l two because of the largest TVL and also TPS.
00:08:13.290 - 00:08:51.074, Speaker B: We have very high TVL and TPS, and it's very cheap and fast. It's very cool and easy to use. As I said, it's fully EVM compatible, so you can easily build on that one. And a little history for arbitrage one. It came live in August 2022. I'm not sure if there's anyone here who's been following us, but before that, we had the Arbitram classic, which had the classic technology. So on August 2022, we upgraded arbitram one from classic to nitro stack, which significantly increased the throughput and speed of the chain.
00:08:51.074 - 00:09:38.266, Speaker B: And we also, in arbitrary one technology, we are using advanced call data compression, which, again, significantly reduces the amount of call data that is being posted to l one. So, remember a few slides before I mentioned the operator has to put the state back to l one. So the way they have to recompute the state is using that call data that is posted on Ethereum. So on nitro, we will leave a very little footprint on at once. So your transaction is even cheaper. Now we have fully ethereum gas compatibility, so it's really easier to account for gas that you have to pay. And we have safer l one to l two messaging and retrievables.
00:09:38.266 - 00:10:40.022, Speaker B: And what is interesting is for developers on Nitro, which is a new technology for arbitron one, we have guest tracing, which was not available in arbitrary classic. So now we even provide broader debugging support and a lot more improvements. Another main chain that we have is arbitrum Nova. So this is basically, it introduces another security assumption, which is now you have to post your call data to a data availability committee, and that makes your transactions to be cheaper and even faster. But there's a trade off, because, again, now you are trusting a set of committee for you to keep your call data for you. But again, this is up to you if you want to use arbitram Nova or one. But we recommend Nova for gaming application, let's say, because those have a lot more transactions and computations to be done on chain.
00:10:40.022 - 00:11:37.274, Speaker B: So Nova would be a better place for them to develop because it's cheaper and faster and they don't need, really that high security. And Nova is still secure, but not as secure as arbitrary one, because there is another security assumption here, and we have the portal, you can go and explore the arbitram ecosystem. We have both for arbitrary one and Nova, and on each, you can find different Dapps, different wallets, and different application that you can use. It's really a good place if you want to start exploring both of these chains and the future of the ecosystem. For arbitrum, how it looks like is we are busy building. So we're currently working on bold stylus and orbit. And bold is the permission validation stylus is a huge upgrade to the evm I'm sure you've heard of that.
00:11:37.274 - 00:12:21.062, Speaker B: And we have arbitram orbit, which is basically your own customized nitro chain on top of arbitram one or nova. So I'll be talking about this so that you can see at what stage are we right now. So we start with the bold. So the way currently the validation process works on arbitrum chains is it is permission. So remember that operator that I mentioned, that it puts the state of the chain on l one. So currently not everyone can do that. So it's permission, meaning that we chose a set of validators to do that, not we, it's arbitram Dow.
00:12:21.062 - 00:13:10.918, Speaker B: I mean, and then the way it works is transactions are sent to the sequencer, and the sequencer posts those transactions to l one. And now it comes for the validators to come along and they execute those transactions, they create some r blocks, and they post the state back on l one. And as I said at the beginning, if there's a disagreement between two of these validators, they can start a challenge. The fraud proof starts, and then only the honest validator can win. So this is the high level idea of how validation process works on arbitrum now. But the way it works right now, why we made it permission has a special reason. And the reason is it is vulnerable to the denial of service attack.
00:13:10.918 - 00:14:06.570, Speaker B: So anyone can come, if it was open, it's permission. So this attack is not feasible. But the reason we made it private is anyone can come along and they can spend as much money as they want so that they can kind of extend this validation process, so they can basically perform a denial of service attack. So that's why we made it permission. But what Wolf does, which is basically an acronym for bounded liquidity delay, is it basically gives an upper bound, which is seven additional day for someone to be able to delay the challenge period. And they can do that more than that. So what it does is it makes the validation process secure, and it also enables us to provide permissionless validation for arbitram chains.
00:14:06.570 - 00:14:55.830, Speaker B: So currently bold is being worked on. I'm not part of the bold team, but I know that the code is done. So it's going under the audits right now. And after that we integrated with the nitro stack, and then we'll launch a devnet. I have some good news that the devnet will be launched, I guess sometime soon. And then, of course, because arbitram is a DAO, we have to propose to the DAO so that they can create an arbitrum testnet chain. And then we propose to the main net, if the Dow approves, we have the vault integrated with the arbitram mainnet, and then at that point, anybody can come along and they can start permissionlessly validating arbitrum chains.
00:14:55.830 - 00:15:59.546, Speaker B: The other product that we are working is arbitram style, which is basically an upgrade to the developer's environment. So, right now, you can write smart contracts in solidity, but with Stylus, you can smart contract in any other languages as well. And that would include, for now, Ross C and C Plus plus. And we are working to add a lot more. And the way it works is stylus basically runs another virtual machine, a was in virtual machine on top of the EVM, and it does it on an interoperable manner, means that if you write a smart contract in ROS and smart contract in solidity, both these contracts, they're able to talk to each other without any issue. And the reason for stylus to be very easy to use and cheaper is vasm, by itself, is a lot more efficient than solidity. So it increases the speed, and it reduces the cost in a significant manner.
00:15:59.546 - 00:17:01.474, Speaker B: And also, memory usage is improved when you're writing a smart contract. So we figured that it opens a lot of new use cases for us, and that would include advanced crypto generative art and a lot more. Right now, if you want to do advanced cryptography on arbitrum, even on arbitrum, with a lot more gas that you have, still, it is not feasible. But with Stylus, you can even do that on arbitram, one on Arbitram stylus. And we feel like that with Arbitram stylus, we can open the door for a lot more developers to join the space. Because I grabbed this figure because it was interesting, because right now we have around 20 case study developers in the whole ecosystem. But if you compare the number with the ones we have for the ROS or C Plus plus developers, you can see that there's a lot more developers in the space who would like to join, but they don't have the ability because they code in Ross and C Plus plus.
00:17:01.474 - 00:17:27.594, Speaker B: So with that one, we get more developers to join the space, which is very cool. So, again, same as bold. The next step for Stylus is we have the testnet, but it's going under the audits, and then we propose it to the DAO. And if the DAO approves, we can launch it. Oh, sorry. I should have changed this. But, yeah, it's supposed to be stylus, and then we have the mainnet ready.
00:17:27.594 - 00:18:12.278, Speaker B: If the DAO approves. And then at the end we have the arbitrum orbit which basically allows you to deploy your own blockchain and customize one on top of the nitro technology. And it is very cool because you can now change your chain in what way that you want. You can have it either in roll up or any trust. You can have a customized challenge, period, because right now it's seven days on arbitrum, but you can make it like even in a matter of one day or even minutes. You can change the base fee, you can change the custom fee token and use any other ERC 20 token rather than ether. So it opens a lot of door for you to customize your chain.
00:18:12.278 - 00:19:16.334, Speaker B: That settles to either arbitrage one or Nova and possibilities are endless. You can add new pre compiles, make your blockchain private and sponsor transaction for your users, or even have some actions to be permission. Not like making the whole chain private and all of that at the same time. You are inheriting the security from the Ethereum blockchain because you are settling to arbitram one and then l one. So this is very cool I think. And to sum up or what I want to talk about the key benefits of integrating CCIP and arbitrum. I think I've said enough, but still, arbitram provide low transaction fees and fast transactions and it can be really important for decentralized applications that they have frequent transactions and interactions with smart contract and arbitrum is fully EVM compatible and with stylus we even go beyond that.
00:19:16.334 - 00:20:36.322, Speaker B: We are EVM plus and you can basically start developing without any modification to the current application that you have. It is really easy and easy to use and interoperability is not a problem here because as I said, it's fully EVM compatible and we have a lot of dapps and liquidity on all of the chains. So it is very easy for these Dapps to communicate together and it's really highly secure because we are inheriting the security from l one and we have live fraud proofs in place. So if anything happens when we open the validation, if there's any malicious validators posting malicious or incorrect state, we have live fraud proof in practice and you can always open a challenge and only the honest validator would win. And it is very developer friendly because we always focus on easy integration for developers. So you can use basically the existing tools and libraries that you normally use on Ethereum, on arbitrum as well. So it is really easy to use and community support is also another factor.
00:20:36.322 - 00:21:24.310, Speaker B: So we try to be friendly and we provide support for anyone who wants. We have Arbitram discord available and our team is always available to help you to build on Arbitrum. And if that's not enough, I only found about this a few days ago. One of our senior software engineers, he dropped a medium post on the state of l two s, and it is a nice post because he breaks down the various parts for l two technologies and he compare different of these components in arbitrum, which I found really cool. I post the link in the chat after my talk so that you can go through that, and with that I conclude my talk and I pass it along to Andre.
00:21:24.970 - 00:21:41.486, Speaker A: Thank you, Ansa. That was really amazing. Really informative. I must say that I'm really looking forward to trying stylus now. If you have any questions for Masa, that was amazing. Drop them into the q a section if you have any general comments. Chat is there.
00:21:41.486 - 00:21:49.600, Speaker A: In chat you can find Masa's twitter handle, website and all of the necessary URLs. Cool.
00:21:51.330 - 00:21:56.260, Speaker B: Yeah, I'm keeping my eyes on the chat for any incoming question.
00:21:56.870 - 00:22:53.700, Speaker A: Amazing. While I'm now sharing my screen, I do actually have a question for you guys, since Masa said that arbitrum kind of inherits Ethereum security when the transaction on arbitrum is actually finalized. So when is that finality? We will need that to understand CcAP security closely. But now let's see how we can use arbitrum, and more specifically arbitrum sepolia testnet to build some cross chain nfts. So today we are actually going to create a fully decentralized cross chain NFT smart contract and we are going to do crosschain transfers from arbitrarion Sepolia to ethereum sepolia testnets. This is our third CCP masterclass. In the first page in this getting started page, you can find the URLs to getbooks for CCP Masterclass one and two.
00:22:53.700 - 00:23:37.794, Speaker A: I think I saw a question about recording for CCP masterclass number two that should be answered. But yes, we expecting it to be pretty soon, like seven to nine days. The URL for this one is Clldevrel Gitbook IO CCPmasterclass three. That should be dropped in the chat as well. And yeah, let's start. So first we're going to do a quick intro to chaining CCAP, and more precisely, we're going to focus on a security side of chaining CCAP because we talked about CCAP a lot in previous two masterclasses. So I highly encourage you to check previous two, we're trying to keep new content from masterclass to masterclass from week to week.
00:23:37.794 - 00:24:39.842, Speaker A: So chain CCP is really defined with defense in depth first mechanism, which means that there is like these five levels of cross chain security. And chain CCP tends to be on a level five where level one is just some centralized backend on centralized node servers which can be decentralized, which can be then separated in a network, that can be again separated in multiple networks. And finally, on level five, we have multiple different decentralized networks with different clients, not overlapping clients, developed in different languages, et cetera, et cetera, knowing as committing, done, executing done, and risk management network. So basically with TCAP, there is no risk of centralization of any kind. You're not using like traditional centralized bridge. You have this whole decentralized architecture in place. What this brings to you is first of course, multiple layers of decentralization.
00:24:39.842 - 00:25:42.630, Speaker A: And as we already know, this works with Merkel Tree and Merkel proof's technology behind the hood. So whenever there is a transaction on a source blockchain, committing done, and both risk management network will monitor that source blockchain. In our example, that will be arbitrum sepolia testnet for that finalized tag. That's why I ask you when finality should happen on arbitrum blockchain. Once that happens, basically committing Don will form like a tiny mercury tree with a subset of transactions of those finalized transactions, including yours, and will pass that root hash of that tree to the commit store smart contract on the destination chain, which risk management network, actually nodes from risk management network will monitor. In the same time, nodes in risk management network will do the exact same thing. They will recreate that Merkel tree.
00:25:42.630 - 00:26:37.366, Speaker A: And finally, they will just get the Merkel tree actually root hash from that smart contract committed or reported by committing Don, and compare with the root hash of their own Merkel tree and see if those are equal. If those are equal, that's good. If not, then we will do something about it. So each of these nodes in our risk management network will vote now on this report with either blast or curse status. There needs to be a quorum of votes, like a threshold for both states, either blast or cursed. We usually monitor our CCP explorer, our web page for blast tag. That's good, because whenever we see blast, that means that our crosschain message will be delivered.
00:26:37.366 - 00:27:35.146, Speaker A: After that, it's simple execution. So basically, as I said, risk management network is developed with this mindset where we are using this n version programming. And the thing is that with risk management network client for this network is developed in rust language with a completely separate theme, while clients for committing Don and executing dons are developed in Golang. And the thing is that there is no single node that overlaps or single node that participates in both of these dawns. Dawn stands for decentralized Oracle network as we already learned. So this is a broader picture of chain and CCAP. Basically there is a source blockchain, there is destination blockchain, and there is this off chain part consists of three dawns, three decentralized oracle networks.
00:27:35.146 - 00:28:23.758, Speaker A: From your point of view as a developer, what you need to care about is only router contracts. So we already know there is one CCP router smart contract per CCP blockchain. And all the interaction is happening between yourself and that or your contracts, your DAp and that router. Like you can see TCP as a black box, literally. So imagine like you're sending a package, so you're going to go to post office, you're going to name where you want to send it, do some extra stuff, label it, and that's it. Post office will do the sending for you. And then on the other side, if you're receiving cross chain message, you literally don't need to do anything because router will deliver the message to you.
00:28:23.758 - 00:28:57.286, Speaker A: What you can do is you can monitor against ECP. Explorer does a similar thing as like you're monitoring your package to see where is it, especially when you're ordering something overseas, for example. And apart from that, I forgot to mention these configurable rate limits. So this is specific to token transfers. So again, with chaining CCP, as we already learned, you can transfer tokens. More precisely, CCP supported tokens. Arbitrary data literally means anything.
00:28:57.286 - 00:29:41.606, Speaker A: That's what we're going to do today. And both of that combine both tokens and data. When it comes to transferring tokens, there is these rate limits because to transfer tokens through in a cross chain decentralized manner, you need to have token pools. So you must not have a centralized bridge. There needs to be like a token pools. And token pools are basically smart contracts which locks or holds some tokens in it. Configurable rate limits means that if we have a token pool for token x at the very end, at the beginning, at the very beginning, the bucket is empty, then we're going to refill it on each second with a specific rate.
00:29:41.606 - 00:30:43.610, Speaker A: And if for example, you want to transfer like 50,000 of that token x and there is only 30,000 tokens in a bucket, you need to wait for a bit to bucket to be refilled. And also once bucket is full, we will not fill it later or not we, but smart contracts will not fill it until someone transfers those tokens. Rate limits basically exist. If there is a vulnerability or something, that pool is drained, whatever, we can cover losses. We will not lose all of tokens, basically. So yeah, with TCP you can get multiple independent nodes run by independent keyholders, three decentralized networks or dawns, separation of responsibilities, increased decentralization and never before seen level of risk management that can be rapidly adapted to any new risks or attacks or vulnerabilities or anything that will come in a future. So that's why you only care about router contracts, because behind the scenes we can add features, adapt all that.
00:30:43.610 - 00:31:18.130, Speaker A: You don't need to upgrade or change your smart contract. That's really important because of the immutable nature of smart contract itself. Now, coming back to concrete stuff or how to build crosschain nfds. So first, to understand what crosschain NFT is, let's first understand what NFT is. So NFT is a smart contract on any EVM compatible blockchain which inherits ERC 71 interface. And that's it. If your smart contract implements that interface, that means it's NFT.
00:31:18.130 - 00:31:49.550, Speaker A: If not, well, it's just a regular smart contract. So NFT is basically a smart contract on a single blockchain. That's it. That's why it's so hard to create cross chain nfts. So to make nfts cross chain, you basically need to deploy that smart contract to multiple blockchains. And then you need to find a way to connect them. Now finally, with CCP being launched, we have a way to connect those smart contracts with CCP lanes.
00:31:49.550 - 00:32:27.180, Speaker A: So how do they work? Basically, let's take a look at this image. You can have three different token transfer mechanisms. So for minting and to, or seeing an NFT displaying in your wallet, that's going to still happen on one blockchain. But to prevent double spending problem and problem and stuff like that, you can choose between one of these transfer mechanisms. So the first one is burn and mint. That means that you have an NFT on one chain. When you want to cross chain, transfer it to another.
00:32:27.180 - 00:33:13.990, Speaker A: For example, from Arbitrum sepolia to Ethereum Sepolia, what you're going to do is you're going to burn it on Arbitrum sepolia. You're going to send a cross chain message with all the details and then mint it on Ethereum sepolia. Once you want to cross chain transfer it back, you're going to burn it on Ethereum sepolia and mint it on arbitrage. That means that you have only one NFP in existence when it comes to lock and mint mechanism. That means that again, you're transferring from arbitrarium sepolia to Ethereum sepolia, you're going to lock your NFT. So lock means it's still in your wallet, or maybe you want to lock it in some other smart contract. Or if you're locked in your wallet, you kind of want to add logic to make it not transferable.
00:33:13.990 - 00:33:55.190, Speaker A: Also you want to not display token metadata or you want to display an image sales locked or something like that. Or literally move it to a smart contract and then you're going to mint it on destination blockchain, Ethereum sepolia. In this example, when you want to transfer it back, you're going to burn it on Ethereum sepolia and then unlock it on arbitrum sepolia. And the third mechanism is basically lock and unlock. There is no minting and burning, you just do lock and unlock part. So the easiest way to implement this is to basically have like a token pulse or NFT pools. For this masterclass, we're going to use the first one burn and mint mechanism.
00:33:55.190 - 00:34:35.860, Speaker A: Cool. Let's now collapse this image so you can find all of these details in this getbook. So how to use chain and CCP? I think we already saw this image multiple times, but CCP in the middle is a black box where you can send both data and tokens or one or another. Basically you're interacting with the router and that's it. If we transfer a regular ERC 20 tokens, you're just going to send it, send them and that's it. Any address can send them, any address can receive them. You don't even need to create your smart contract, you can just interact with their router contract if you're sending arbitrary data, which we're going to do today.
00:34:35.860 - 00:35:17.700, Speaker A: Again, sender can be any address turning on account, smart contract, anything. Receiver must be an address or smart contract which implements that CCAP receiver interface. So one function only CCAP receive. That function will be called biodon through the router contract. So you want to make sure that you're able to decode message because transferring data is just bytes chunk. If you're transferring arbitrary data to a wallet, only tokens will arrive. Because wallets does not have an ability regular externally owned accounts does not have ability to decode or to have any smart contract on that matter.
00:35:17.700 - 00:36:18.690, Speaker A: Yeah, so let's see how we're going to implement burn and mint model. Well, it's pretty simple. So on arbitrum sepolia side, if that is our source blockchain, you basically want to have a couple of modifiers at this function to make sure that there is no re entrance attacks or something like that. We're going to have this only enabled chain, a modifier that means that you can send this cross chain message only to ethereum sepolia and only to that address on ethereum sepolia to make sure that we are communicating only with our smart contract on other side and not any other address. And then what we are going to do is we're going to save token Uri and we are going to burn token on our transepolia. Then we're going to create a crosschain message object receiver. Is that NFP address from that enabled change? This data is really crucial because we're going to encode all of the details in a data payload.
00:36:18.690 - 00:37:06.222, Speaker A: So from address to address token id, token Uri, all of that details so we can, with all of these details, mint the exact same NFT on Ethereum sepholia to this address with this specific token id, with this metadata, et cetera. We're not sending any tokens for extra arguments, we'll touch on that later. And we're going to pay for fees depending on this parameter. So you can pay for CCP fees in both link token and also native asset of that blockchain. So for arbitram sepolia testnet there'll be arbitrum sepolia eat or wrapped arbitrum sepolia eat to make our lives easier. We're going to use link. So you'll need only arbitrum sepolia eat for yes, but again vice versa.
00:37:06.222 - 00:37:57.606, Speaker A: You can just pass pay fees in as a native and you'll pay in arbitrage monsopolia it instead of link. Completely up to you. Your choice on the other side. Now we are going to implement this CCP receive function again, a couple of modifiers so we make sure that only router can call this function again non reentrant that we are receiving now this message only from arbitration sepolia that the sender is only this smart contract on arbitration sepolia and a bunch of other details. And then finally what we're going to do is we're going to just decode the data payload like this and mint the new NFT and set the metadata URI and that's it. So pretty straightforward. Let's see now that in action for NFT metadata you can use whatever you want.
00:37:57.606 - 00:38:35.054, Speaker A: There are a couple of ipfs hashes or ips URLs for you if you want to steal them. Basically. So we have this tiny, if I click this, basically it's going to take a while, but you should be able to see like an IPF payload. Once we have it, I'll go back, but basically you'll have this tiny chain link, elf chain link, knight chain link work or chain link, whichever is your favorite, you can take it. I basically have a string array with four of them. So I'm just going to do module operator operation and yeah, I'm going to mint all of them eventually. A couple of development.
00:38:35.054 - 00:39:18.686, Speaker A: Best practice. I think I already mentioned that. But for this particular exercise you must always make sure to verify source chain destination, chain sender and receiver address. So only those smart contracts, the same smart contracts but maybe with different addresses must communicate between themselves and no one else to prevent losing of our nfts. Basically we also must verify triple check router addresses. So because router smart contract is basically our door to the CCAP, we want to set gas limits. So gas limit basically specified the maximum amount of CCP can consume to call that CCP receive function on our side.
00:39:18.686 - 00:39:54.314, Speaker A: And this unspent gas is non refundable. So in production ready contract you're going to measure the gas consumption approximately of that CCP receive function and you're going to set it to that value. This is also important because we want to also send our NFT back to arbitrance sephola, maybe from arbitrage polio to some third chain whatever. So maybe gas limits will be a bit different. So you don't want to lose money on gas fees. There extra arguments? I thought that we're going to talk about it later. Now is the time.
00:39:54.314 - 00:40:20.942, Speaker A: So extra arguments is basically its own purpose is to allow compatibility with future CCP upgrades. So we are now going to use CCP version 1.2 or for previous two master classes we used 1.0 in 1.0. Extra arguments consist of both gas limit and strict sequencing. Now only gas limit is there. We removed strict sequencing because it was like experimental feature.
00:40:20.942 - 00:41:00.942, Speaker A: So now only gas limit is there. That means that if you want to try to use new routers with altmark contracts, there is a slight possibility that will be incompatible. They are compatible now, but let's imagine like in three years you want to do something, it's going to be hard to keep with all the backwards compatibility. So one of the best practices, and it's present in our docs, is to make extra arguments, build mutable. So extra arguments under the hood is just a bytes data. So I crafted this really tiny smart contract, a helper smart contract. If you're using remix or foundry, this is going to go straight out of the box.
00:41:00.942 - 00:41:45.690, Speaker A: If not, there is a workaround for hardhead as well. But basically you're going to provide gas limit as a function parameter. It's a pure function and it will convert do all the magic for you and you're just going to have this piece of bytes data which we are going to pass instead of hard coding it in our smart contract like we usually did. That'll be it from the intro. Let's now see this thing in action. So I put the details about arbitram sepolia and ethereum sepolia config details that we are going to use. There are much more on that here, and I'll already open this page aside so I can just follow along while I'm doing the exercise.
00:41:45.690 - 00:42:34.138, Speaker A: So we have chain selectors, router addresses and link token addresses for both chains, and that's pretty much it, right? This is the only thing that we are going to need. So as you already know, you can use any development framework you want to build with CCP. There is hardhat foundry and remix instruction in this gitbook, hardhat with typescript and eater three six. So not all of flavors, but also you can easily port in any development framework of your choice. As you already know, I'm going to use Remix ID because it's the simplest for me. Alternatively, you can just clone CCP starter kits for both architect and foundry. So to use Remix, what I need to do is I need to create a new workspace.
00:42:34.138 - 00:43:14.810, Speaker A: I'm going to select a blank template and I can maybe name it CCP Master class three cross NFT on arbitrum. This is gold, but you can name it however you want. And I'm going to click ok, I'm going to just zoom this a bit so it's easier for you to follow along. And that's it for now. Cool to use CCP and interact with the router contract and all that stuff. As you already know, there is this NPM package. So this is the official NPM package for CCP smart contracts, and we now need to install it if you're using Carhat.
00:43:14.810 - 00:43:56.210, Speaker A: Also, besides this package, we're going to install chain in contracts and opens up on contracts the newest version like version five, whatever. So for Carhatt it's really simple NPM install. For foundry we have these forge install glands and for remix it's even easier. So I'm going to just copy this smart contract and remix is clever enough to manually, to automatically import all of these dependencies for me. So I'll have the empty contract with three random smart contracts from three packages just to make sure that everything's fine. And then I'm going to start. So I'm going to create empty SL smart contract.
00:43:56.210 - 00:44:21.786, Speaker A: I'm going to paste the content from the getbook, hit save and you already see this adapts folder expanded. So dapps NPM, this is what I'm looking for. I'm looking for chain link contracts, contracts HTP and opens up in contracts. That's it. This is what I want. That means that I successfully imported all this. And if you don't believe me, if I do this, this is command and typing.
00:44:21.786 - 00:44:47.010, Speaker A: This is the contract I imported now from the package. Right. Okay, cool. Now let's do something meaningful with these contracts. So before we start, final thing is to go to faucet. If you're planning to pay for Ccfp fees in link, you can go to this link faucet, the chain link, click here. This is the image, this is the chain link faucet for arbitram sephola.
00:44:47.010 - 00:45:14.482, Speaker A: So you can get 25 link or zero point 25 test eat. If you don't need test eat, just test link. There is no need for GitHub login. If you need it then you're just going to outright with GitHub. This is just to prevent from bot attacks essentially. But yeah, I have plenty arbitramit for fees. I'm just going to grab some link.
00:45:14.482 - 00:45:48.966, Speaker A: So basically my wallet was already connected. You will see one extra step if yours is not ready. Basically a connect wallet button. You're going to connect it and yeah, that's pretty much it. I'm going to close this now and yeah, this is actually on Sepolia. That's my bad. So if I switch sorry to arbitram sepolia in my wallet, I should have seen details for arbitrage support where I can grant 25 link on arbitrage.
00:45:48.966 - 00:46:12.606, Speaker A: So apologies for that. Now I cannot use it because I already used positive, but never mind. So just make sure to verify on which blockchain you are in your wallet to get the right link tokens. But yeah, I have plenty. So no worries about that. Perfect. Once we have that we can finally develop our smart contract.
00:46:12.606 - 00:47:11.714, Speaker A: So develop means that I'm just going to copy the content of this page and then we're going to go slowly through it function by function. So I'm going to copy, I'm going to create a new file in the root folder, so new file xnft Sol and I'm going to paste the content before that, before I save it. So to compile it I need to either command s on control s or go here to solidity compiler and hit this compile xnft smart contract. But before that I must scroll down a bit. So the next section is actually prepare for deployment. And what I want to say is that for this smart contract to be compiled, we need to use at least 0.8.20 solidity version.
00:47:11.714 - 00:48:14.666, Speaker A: This is because we are using the latest mark contracts from opens up in their latest release for nfds. The thing is that with this solidity version and the new ones, push Zero Opcode was added in a recent or I think the latest Ethereum hard fork. And this Shanghai hard fork, which is the name of that hard fork, is now, Shanghai is now set as a default EVM version. That means that there is a possibility, like a really big possibility that your smart contract will have push zero opcode. Ours have majority of other blockchains, including arbitrum, Sepolia, Testnet have not yet add this push zero opcode. That means that if we compile this smart contract with default remix settings, we will be able to deploy it on Ethereum sepolia, but we will not be able to deploy it on arbitrage sepolia because we either need to downgrade to zero point 19 or to manually set this EVM version. So I highly encourage you to check this stack overflow answer.
00:48:14.666 - 00:48:54.726, Speaker A: It's for myself. But still you have all the details about how to manually set the EVM version for all of these most popular environments, right? And we can see it's pretty good doing. So what I'm going to do is for remix also for Harhat and Foundry, these are the steps, just copy details. So for foundry, add this line. For Harhat, add this config and you're good to go for remix. As being said, I need to go to solidity compiler tab and find these advanced configurations drop down. So solidity compiler, advanced configuration up here.
00:48:54.726 - 00:49:17.658, Speaker A: And this was default. Now I'm going to switch back to Paris and hit compile. So just don't use Shanghai, use whatever you want. Paris is the merge. So that's cool. So now I'm absolutely sure that this will be deployable to any blockchain other than including Ethereum, sepolia. With changa, it was just ethereum.
00:49:17.658 - 00:49:56.700, Speaker A: No other blockchains will be able to accept that smart contract because that bytecode for poor zero code is basically unknown to them. Cool. So yeah, let's now quickly go through this smart contract and see what we have here. So if you have a bunch of inputs, we're going to skip that for now. Also, this is an example contract, so don't use this in production. It's not tested, heavily tested, stuff like that. But yeah, so there's this in basically to check whether you want to specify actually whether you want to pay for fees in native asset or in link.
00:49:56.700 - 00:50:24.610, Speaker A: Couple of errors. Then we have this constant. This is arbitrage supportio. Chain ID means that we want to first mint, like the initial mint of NFT to happen only on arbitrage. This is our main chain, this is our source chain. And then from arbitrary supply we are going to cross transfer it to ethereum, sepolia and other blockchains later. But the first, very first mint is happening on arbitrary sepolia and we are hard coding this in smart contract.
00:50:24.610 - 00:51:08.242, Speaker A: Couple of characters. This is just those uris I was talking about. So if I go again, this is this warrior whatever. So yeah, you can reuse it for future projects. If you want. A couple of details about cross NFT like address and those extra bytes and then a couple of storage variables, immutable storage variables for router, link token and chain selector. So if I go back here, router, link token, chain selector so I have immutable smart contract, immutable source variables for those I'm also making sure or tracking current chain selector value because I don't want to allow cross chain transfer on a chain where I am.
00:51:08.242 - 00:51:30.454, Speaker A: So chain selector is basically a unique identifier for a CCAP power blockchain. And basically you can see that it's unique to chain ccap. So this is always held like the same length. So un 64 value. This is a chain selector for arbitram sepolia. This is not the same as chain iD. So be clear about that mapping for all these details.
00:51:30.454 - 00:52:03.074, Speaker A: Couple of events and that's it. A couple of modifiers. So only router can call this function only on arbitrum support this section can happen. This is mint only enabled chain can be a receiver and only enabled sender can send a message. Also this operation is not allowed on current chain. If you want to set some config details on a chain where you already set it or something like that constructor just creating a new NFT. That's it.
00:52:03.074 - 00:52:29.030, Speaker A: This is the mint function. So mint is pretty much the standard. ERC 71 opens up in implementation of mint function. We only have this modifier to allow this to happen only on arbitration sepolia enable chain means that, okay, we deploy this smart contract to arbitrage from Sepolia. Let's deploy it now to Ethereum sepolia. Let's now go back to Arbitram Sepolia and say to this contract on arbitration sephola. Hey, there is a new cross chain version of the Sainsmart contract on Ethereum sepholia.
00:52:29.030 - 00:52:53.822, Speaker A: Let's now provide these details. And only owner can do that, only dao. And obviously this cannot do for yourself. Like you cannot enter details for arbitration poly on arbitration sepolia. So that means that we're going to provide now chain selector for Ethereum sephola address of this same contract on Ethereum sepholia and CCP extra arguments for that chain. And that's it. You can enable chain, you can also disable chain.
00:52:53.822 - 00:53:43.410, Speaker A: So this is all the best practices that we are suggesting you to have. And finally, this is crosschain transfer from, this is our function that we want to have it. So a couple of modifiers, we are burning token here, creating a cross chain message object. We're encoding all of these necessary details, which we're going to decode on the other side to mint the new NFT. And we're not sending any tokens for extra arguments. We are using those extra arguments bytes provided here when you're enabling chain and we are specifying whether we want to pay in native or link for fees, then we're going to call the router contract to calculate the fees, CCP fees for this crosschain transfer. So on this chain selector for this message, how much that will cost for these three off chain components to deliver it.
00:53:43.410 - 00:54:35.378, Speaker A: And again, if you're paying in links, then first you're going to check whether you have enough. Then you're going to just approve router to spend part of your link tokens and you're going to send it, send a message, ccP send function, same things for native, just with our approval and with these extra parenthes because we are now paying basically with message value. That's it. Emitting event. On the other side, we are receiving a cross chain message, basically decoding all of these details. As I said, minting an NFT, setting a token URI and emitting an event, a couple of helper functions, withdraw native asset, withdraw token for fees and also to get token URI router, couple of u function functions and finally supports interface. That's pretty much it.
00:54:35.378 - 00:55:07.966, Speaker A: Now let's see this thing in action, shall we? So let's first prepare for deployment. We already did that. So prepare for deployment means that just make sure on remix to set that EVM version to Paris. And also, if you don't already have original sepolio in your metamask wallet, you can go to chainlist.org. If you click on this URL, it's already pre configured. So basically you want to include testnets, search for arbitrage sepolia, and just add this to metamask. So if you're not clicking this URL, this is the main one.
00:55:07.966 - 00:55:39.846, Speaker A: So you want to include testnets and search for arbitrage polio or just click the URL from the gitbook. Right. For other environments, just setting environment variables for arbitrage RPC URL and optional ethereum sepolia. Because for this exercise we're just going to do a transfer from arbitrum to ethereum. But if you want to do vice versa, or backwards, you'll want to set that as well. To do that, you can maybe go to alchemy. Alchemy have a pretty decent RPC URL for Arbitrum sepolia and Ethereum sepolia.
00:55:39.846 - 00:56:09.300, Speaker A: So yeah, I suggest that, but you can do however you like. Cool. Now we are in remix. Let's deploy this NFT first to ethereum sepolia first to ethereum sepolia as a destination chain just to prevent the number of chain switching in our metamask wallet. Let's see. Okay, cool. Something is wrong with my camera settings, but that's, never mind, we can check that later.
00:56:09.300 - 00:56:47.914, Speaker A: Cool. What's more important is to deploy this smart contract to Ethereum. So Polya, how we're going to do that, we're going to compile it once again to make sure that we're using the right configuration. Perfect. So first, what we're going to do is we're going to select injected provider metamask and injected provider metamask. If you're doing this for the first time, there will be a pop up here to connect your wallet to remix because I already did it. What I want to do is I'm going to specify the network I am through my metamask wallet.
00:56:47.914 - 00:57:24.506, Speaker A: So if I want to go to Sepolia, I'm now on Ethereum sepolia. This is Ethereum sepolia links, blah, blah. And you can also see 115511. This is chain id for Ethereum support. That's changed, right, so that's how I'm specifying on which blockchain am I. If you don't see this change or something wrong, just hit refresh and that should be solved. What I want to do now is I want to deploy this smart contract, right? If I go to constructor, what I need to provide basically is router address, CCP router address, CCP or sorry, link token address.
00:57:24.506 - 00:58:05.270, Speaker A: And finally the chain selector on a blockchain where I am, that will be Ethereum sepolia chain selector. So how to do that? Well, if you go back here to these exercise details, at the very top you have config details. So we need router address. So CGP router address for Ethereum sepolia, paste it here, link token address. Right, so link token address, here it is. And finally, chain selector for this chain. So this is this value, triple check it just to make sure that these are correct values.
00:58:05.270 - 00:58:33.646, Speaker A: Bf seven, seven, nine. Okay, cool. And hit this transaction button which will deploy our smart contract to Ethereum sepolia. What I need to do now is I'm going to hit confirm and we're going to wait for this transaction to be included in the next. So, yeah, that just happened. Amazing. Right, so now let's quickly go back to Gitika book and see what our next step is.
00:58:33.646 - 00:58:57.814, Speaker A: Our next step is to do the same thing, to perform the same action now on arbitrary sepolia. So I'm now deploying the very same smart contract to arbitram sepolia blockchain. So how to do that? Basically, as I said, we're switching chain. You're in control of that through your wallet. So I'm going back to metamask. I am going here and I'm selecting arbitrum sepolia testnet. Right.
00:58:57.814 - 00:59:52.714, Speaker A: I'm monitoring this part, as you can see. Now it changed to 4216 114, which if there is a chain id for arbitrage Apollo. And if you're not sure what to look for, well, that value is hard coded here, but obviously you should go to arbitrum docs or to google it to make sure if you don't know from top of your head. So now what we're going to do is do the same thing but with different config option. So we're going to now basically provide config for arbitrary sepolia so that'll mean CCP router address for arbitrary sepolia, copy it, paste it here, then link token address, copy paste it here, link for fees. If you just want to do native, then you don't need a link, obviously. And finally, chain selector for arbitrary sephola, paste it here, and that'll be it.
00:59:52.714 - 01:00:08.094, Speaker A: What I need to do now is, again, click transact. There's another metamask pop up. Okay, I'm deploying this to arbitrage a new contract. Perfect. This is what I want, right. We're now going to wait for this transaction to be included. And that's it.
01:00:08.094 - 01:00:44.886, Speaker A: So now pay attention really quickly. So we have two instances, very same instances in our code wise in our remix environment, but they are on a completely, two completely different blockchains. So this one is the second one. This is an arbitrary sepolia. And if I code this get CCP router function, I should be able to see the router contract address if I want to interact with this one. The first instance that should you see, return me like address zero. Why? Because this address, specifically this smart contract with this address do not exist on arbitrum sepolia.
01:00:44.886 - 01:01:04.110, Speaker A: This is an instance on ethereum sepolia. So just make sure to not confuse these two. Calling gas Vcf router or do some interaction with a contract will help you. So I know that this one is Arduino Sepolia, this one is ethereum sepolia. That's it. Cool. Now let's go back to our gitbook to see the next step.
01:01:04.110 - 01:01:25.762, Speaker A: So the next step is now this is config. I don't need that. The next step is now to go back to ethereum sepholia to enable this chain. Right. So on ethereum sephola, I want to say, hey, there is a new contract deployed on a new chain. I want to be able to do cross chain transfers with this blockchain for this exercise. Precisely.
01:01:25.762 - 01:02:07.870, Speaker A: I want to receive a new NFT from this arbitrarium sepolia blockchain. Let's enable that. So again on ethereum sepolia means that I want to go to my metamask to switch back to ethereum sepolia. And if I go back, I can see Sepolia 111-5511 I'm back on ethereum sepolia. So now if I call this get ccp router function, I should be able to see the router address because now I'm interacting with a contract on the right blockchain. So if I go back to details. You can see we need to call enable chain function for foundry and hardhat.
01:02:07.870 - 01:02:33.674, Speaker A: You have dedicated scripts for remix. It's easy, we just need to find this enable chain button and here it is. So if I go back to enable chain, you can see I need to provide chain selector, cross chain NFT address and extra arguments. So this is the chain I want to enable. That means that only I can call this function only on other chains. That means I'm on ethereum sempolia, I'm adding details for other chains. I cannot provide chain selector of ethereum sepolia.
01:02:33.674 - 01:02:58.206, Speaker A: So I need to provide details for arbitrage polya. Right. So chain selector for arbitrage Apollia is this one. So I'm going to copy this 3478 number, paste it here. I need to provide the crosschain NFT address on this chain. So how to do that? Well, scroll down a bit and copy it here. So this is the address of smart contract we previously deployed in previous step and provide it here.
01:02:58.206 - 01:03:37.006, Speaker A: Finally CCP extra arguments. So I said to you, you can use this helper contract, I already have it, but I calculated for you that if you want to use default settings, what you can do is just copy this value because this is 2000 in gas and for the sake of time we're just going to use this. So hit transact. And this is on sepolia. Perfect. Just hit confirm. That means that we are now enabling arbitrum sepolia on ethereum sepolia.
01:03:37.006 - 01:04:04.426, Speaker A: Cool. Step number four is to go back to arbitrarium sepolia for the very last time. So we have another chain switch. Right. And call again enable chain function but on arbitrum sephola now. So how to do that? Well, for the very last time, go to our metamask. Second.
01:04:04.426 - 01:04:31.694, Speaker A: Yeah, go to our metamask. Go to arbitrageepolia. And this is the final switch of networks. That's it. For the final time, make sure this custom 421614 chain id is what you're seeing. And that's it. We are now on arbitrage polia and we will not going to go back to any other chain throughout the rest of this CCP masterclass.
01:04:31.694 - 01:04:46.674, Speaker A: Right. Okay, cool. Let's now go back to this instance. So to make sure. Okay, CCP router, it works. Cool. So we need to call enable chain on arbitram sepolia.
01:04:46.674 - 01:05:20.610, Speaker A: We need to provide details about ethereum sepolia. So how to do that chain selector for ethereum sepolia. Copy paste it here, crosschain NFT address on ethereum sepolia. So scroll up a bit. It's this one copy, 47, 47 and bytes. Well, it's going to be the same one, right? So I'm going to just copy this value and paste it here. Finally, what I'm going to do is I'm going to hit transact button and wait for a metamask pop up.
01:05:20.610 - 01:05:47.066, Speaker A: Here it is. Hit confirm. I'm now going to wait for this transaction to be included in the next block, which just happened. And we can continue. Now we set up a scene for these two smart contracts to communicate between themselves, between each other. Let's now do something meaningful, right? So step number five will be to fund crosschain NFT with three links. Or you can do one, three, whatever.
01:05:47.066 - 01:06:06.770, Speaker A: Three is more than enough. Just go in. This is for TCAP fees. And I said multiple times I'm going to use link for that. So how to do that? Well, just copy the address of that smart contract as a receiver. Go to your metamask. These are tokens you had from the faucet.
01:06:06.770 - 01:06:31.174, Speaker A: Hit send, paste the address here. There is a warning. You're about to send a token to a contract which can result in loss of funds. But I understand because we added that withdraw and those withdraw and withdraw token functions. So withdrawal token is for this one. So I can absolutely withdraw my tokens later. I'm going to hit next and I'm going to just hit confirm.
01:06:31.174 - 01:07:08.040, Speaker A: This is an arbitrary sephola. This is what I want confirm. And I'm going to just monitor my metamask pop up to see when the funding is done. So I'm just waiting for this transaction to be included in the next block. Obviously, if you want to do cross chain transfers back, you're going to switch against Ethereum support and fund that smart contract with some links. But again, for this tutorial, for this exercise, we're just going to do one crosschain transfer. So that step is kind of redundant, right, cool.
01:07:08.040 - 01:07:47.906, Speaker A: Now, when we have a link for CCP fees and we connected our two blockchains, let's now mint our first cross chain NFT. So to do that, well, on average sepolia, I just need to call the mint function. That's it. And if you want to do this on ethereum sepolia, well, you will not be because mint can be done only on arbitrum sepolia. And then for all of other blockchains, you need to cross chain transfer it, basically. So I'm calling the min function I'm hitting confirm here and I'm going to wait for this transaction to be included in the next block. And here it is.
01:07:47.906 - 01:08:20.814, Speaker A: You can see a green tick. This is great. So our first, very first token id index zero will be the so zero will be the token id of our very first NFT from this collection. And if I query this Token uri function with zero, I should be able to see this URL. And if I paste it here, well, this is our lovely chain link elf. So cool. Also, if I want to see who is the owner of this token id, well, this is my address.
01:08:20.814 - 01:08:49.042, Speaker A: Amazing. Cool. Finally, as a final step, let's now do a cross chain transfer of this NFD. So how to do that, we just need to call cross chain transfer from function. And if we've done our previous steps correctly, if everything is set up, we should be able to do that. So let's find the crosschain transfer function. Here it is crosschain transfer from and we need to fill a couple of details.
01:08:49.042 - 01:09:21.646, Speaker A: So I'm going to basically send it from my address, Nordrom sepolia, to my address on ethereum sepolia. So these two are going to be the same token id I'm sending is zero. We just validated that we have this token and the destination chain selector is ethereum sepolia. So I'm sending to Ethereum sepolia. So I'm going to provide this chain selector as destination here. Payphizin is an enum. Basically enum is under the hood, just set of numbers.
01:09:21.646 - 01:09:55.674, Speaker A: So enum by default means that native is zero, link is one, some other option will be two, et cetera. Because I want to pay for ccfs and link, I'm going to provide number one, which is an enum value for payphysin link. And I'm going to hit transact. There is a metamask pop up, which is good. Everything's set up. This will not revert on arbitration sepolio. So I'm just gonna hit confirm and I'm gonna wait for this transaction to be included in the direct block that just happened.
01:09:55.674 - 01:10:49.578, Speaker A: So what I can do now is I'm going to get the transaction hash of this transaction and then I'm going to go now back, but I'm going to navigate to CCAP chain link. This is a block explorer for chaining CCP for all of these crosschain messages. And I can already see that this probably is my transaction from Sepolia to Ethereum Sepolia. But still, I need to either pass message id transaction hash on an address. I'm going to paste transaction hash and hit enter to search for it. And here I can now monitor the cross chain transfer of my NFT, right? So this is still waiting for finality on arbitrage Apollo so I can monitor it here. So if I click here for source blockchain transaction, you can see that I burned this token id on this side.
01:10:49.578 - 01:11:26.150, Speaker A: So sending 20 address, I effectively burn it. So I don't have it now in my wallet it's transferring. But once this message arrives on arbitrance, I should be able to CCF explorer. I should be able to add it. I will have it definitely, but I should be able to add it to my metamask. So if you go to NFTs tab and import NFT, you can just need to provide the address of a smart contract token ID and hit import and it'll say hey, successfully added. You still need to refresh for token metadata.
01:11:26.150 - 01:12:38.942, Speaker A: But yeah, you should be able also to see it on Opensea and all of that. So if you go here and refresh metadata, image should appear at some point and yeah, that'll be it. So for now, we just need to monitor the status of this crotching message and we will have our NFT in our wallets eventually says it's still waiting for finality. So you need to wait for finality to happen on arbitrum sepolia testnet. That's why I asked at the beginning of lecture, do we know how can we calculate finality? Is it just finality on arbitrary polio or need to be finalized on layer one, et cetera, et cetera? So yeah, that'll be it for now. This concludes our exercise time, like our workshop. Once this is finalized again, if I go back to Gitbook, you should be able to add your NFT into your metamask wallet on other site.
01:12:38.942 - 01:13:02.840, Speaker A: For now, we can see that it has been burned on arbitrum sepoli. Yeah, now is the exercise time. So it's 03:15 p.m. Eastern time. We are right on time. So you have 45 minutes, 30 to 45 minutes. Depends how long it will take for you to try to do this exercise by yourself.
01:13:02.840 - 01:13:36.434, Speaker A: If you have any questions or need assistance, feel free to drop them into chat or q and a section. I'm going to try to answer now all of your questions together with Masa and then we are going to finally wrap it up. We're going to do either 345 or 04:00 p.m. Eastern time. Depends how long it will take for you. But this is basically the very last step of this lecture part, let's say. So now exercise time.
01:13:36.434 - 01:13:53.654, Speaker A: We're going to play some lo fi in the background. And yeah, if you need any assistance, feel free to drop them in the chat or q and a. I'll try to answer it. And yeah, as I said, we're going to have now some fancy chili lo.
01:13:53.692 - 01:14:00.550, Speaker B: Fi before that one. Can I take some time to talk about finality, the point that you raised?
01:14:01.130 - 01:14:02.200, Speaker A: Oh, absolutely.
01:14:04.730 - 01:14:45.030, Speaker B: Because this is important. Yeah. So we have different levels of finality on arbitrum chain and it really depends on the use case. So the way it works the transaction lifecycle is you send a transaction and the sequencer would receive that. And what the sequencer does, it orders transaction on a first come, first serve manner. So it basically sorts all the transaction and right away it kind of publishes a receipt, which is basically all those order transactions on its feed. So we call this soft finality, which is basically instant.
01:14:45.030 - 01:14:52.982, Speaker B: And after that, basically the result of the execution will never change because it's all deterministic.
01:14:53.046 - 01:14:53.706, Speaker A: Right.
01:14:53.888 - 01:15:49.020, Speaker B: So if you want to trust the sequencer, which a lot of Dapps are trusting the sequencer right now, you can basically trust those order transaction and you can basically use the instant or soft finality. But if you don't want to trust the sequencer, you can wait for the sequencer to post those batches on l one and then wait for the Ethereum to progress for some time. And then once those blocks are finalized on Ethereum, then you can say it's final. And that would be called hard finality. So a lot of exchanges, I know, as far as I know, most of the exchanges and most of the Dapps are basically now relying on soft finality, which is instant. But like RB scan, let's say it doesn't. So it takes some time.
01:15:50.290 - 01:16:15.042, Speaker A: Amazing. Thank you very much for clarifying. That depends again on a finality time. We will need to wait for our nfts to appear in your wallet. So that's again for extra security because we are doing cross chain transfers. And if something wrong, well, we already burned our NFT on arbitrage polio. We don't want to have none or two nfts on our site.
01:16:15.042 - 01:16:46.046, Speaker A: So that's the only reason why. So it'll take a while, but it will eventually see your nfts in your wallet. And yeah, that's just something that I wanted to clarify about crosschain transfers. I'm now going to. Sorry about the camera, something's wrong with Zoom. Like, my camera is working, but Zoom, I don't know why, just doesn't allow me to switch between any of the camera. So I'll try to fix that.
01:16:46.046 - 01:17:12.710, Speaker A: But in the meantime, you don't need to see me. You just need to have a lo fi music in the background. And I'm going to be there in the background as well to support you during this coding time. So. Yeah, thank you very much. And if you have any questions, just drop them in the Q A section. I wish you happy holidays and thank you for joining us.
01:17:12.710 - 01:17:17.570, Speaker A: And we're going to see you in next year. Enjoy, guys. Thanks. Bye.
