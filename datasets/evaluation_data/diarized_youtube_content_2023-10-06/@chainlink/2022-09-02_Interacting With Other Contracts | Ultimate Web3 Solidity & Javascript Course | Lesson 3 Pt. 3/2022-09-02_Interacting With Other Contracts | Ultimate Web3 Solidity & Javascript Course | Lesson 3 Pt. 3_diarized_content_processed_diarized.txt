00:00:10.570 - 00:00:17.182, Speaker A: All right, so this is great. We can now keep track of all of our simple storage deployments, but how do we actually interact with them?
00:00:17.236 - 00:00:18.318, Speaker B: Let's say we wanted to be able.
00:00:18.324 - 00:00:24.026, Speaker A: To call the store function on all of our simplest souls from our storage factory.
00:00:24.138 - 00:00:25.474, Speaker B: You can think of the storage factory.
00:00:25.522 - 00:00:40.922, Speaker A: As almost like a manager of all of our simplest sol. Let's create a new function that can do exactly that. So we'll create function and we'll call it SF store, which is going to stand for storage factory store. And it's going to take a UN.
00:00:40.976 - 00:00:56.958, Speaker B: 256 simple storage index and a UN 256 underscore simple storage number. It'll be a public function as well.
00:00:57.044 - 00:01:28.214, Speaker A: Now, in order for you to interact with any contract, you're always going to need two things, and we're going to refer to this a lot. You're always going to need the address of the contract and the ABI of the contract. The ABI stands for application binary interface. The ABI will tell our code exactly how it can interact with the contract. We'll go deeper into ABI as we move on. But if you go to your compile tab, you hit compile and things are actually compiling. You can scroll down and you can.
00:01:28.252 - 00:01:31.370, Speaker B: See compilation details, and you can see.
00:01:31.440 - 00:01:45.662, Speaker A: A whole bunch of information on your different contracts. You can see the name of your contract, which for our simple storage contract is simple storage. You can see a whole bunch of metadata, like the compiler, the language output settings, all this other stuff.
00:01:45.796 - 00:01:48.206, Speaker B: You can see the exact bytecode and.
00:01:48.228 - 00:02:19.994, Speaker A: The opcodes, which we'll talk about much later. But you can also see this ABi. This ABI tells you all the different inputs and outputs and everything you could do with this contract. For example, in our simple storage, if we look at the zero width index of our ABI, we have a function add person. If we look at one, we see our name to favorite number. If we look at two, we can see our people, three, retrieve, four, store. It tells us all these different ways we can actually interact with our contract and the different functions that we can call.
00:02:19.994 - 00:02:53.506, Speaker A: We know where our addresses are because we're storing them in this array here, our simple storage array. We can also get the ABI because we're importing simplestorage Sol. When you compile simplest Sol, as you saw in the compilation details, whenever you compile it, it comes pre packaged with the ABI. We automatically get the ABI just by importing it like this. In the future, we'll see other ways that we can actually get abis really easily. So to call the store function on one of our contracts, we're first going to need to get that contract object. So what we can do is we.
00:02:53.528 - 00:03:01.238, Speaker B: Can say simple storage variable named simple storage variable named simple storage of type.
00:03:01.324 - 00:03:03.602, Speaker A: Simple storage is going to be equal.
00:03:03.666 - 00:03:07.960, Speaker B: To a simple storage object.
00:03:08.490 - 00:03:24.302, Speaker A: And instead of doing new simple storage like we did last time, we're just going to put the address of this simple storage object in here, which again we can get from our array. And in this function we're passing the array index, so we can say simple.
00:03:24.356 - 00:03:34.986, Speaker B: Storage contract at address simple storage array at index simple storage index this bracket.
00:03:35.018 - 00:03:53.974, Speaker A: Notation here is how you access different elements of arrays. So if we want the zero th element of our list here, simple storage index would be zero, and we pass it into this bit here, and then that'll give us the address of our simple storage contract, which we pass into simple storage here. Since this is an array of simple.
00:03:54.012 - 00:03:56.934, Speaker B: Storage contracts, we can just access that.
00:03:56.972 - 00:03:59.334, Speaker A: Simple storage contract using the index.
00:03:59.462 - 00:04:10.598, Speaker B: So we would say simple store edge array at index underscore simple storage index.
00:04:10.774 - 00:04:36.786, Speaker A: Now we're saving the contract object at index, simple storage index to our simple storage variable. Our array here is keeping track of the addresses for us, and it automatically comes with the abis here. If this was just an array of addresses of the contract objects, instead we would have to wrap the address in a simple storage object like this. But we'll get to that much later.
00:04:36.888 - 00:04:38.398, Speaker B: So for now all we have to.
00:04:38.424 - 00:04:50.486, Speaker A: Do is this and we now have a simple storage contract object. Now that we have it, we can call our store function on the simple storage contract. So we'll call simplestorage store and we'll.
00:04:50.518 - 00:04:56.042, Speaker B: Store the simple storage number to it.
00:04:56.096 - 00:05:26.694, Speaker A: So this is perfect. And if we were to deploy this right now though, we wouldn't be able to read this store function. So let's create another function that can read from the simple storage contract from the storage factory. So we'll create a function called SF get, which stands for storage factory get. It'll take a UN 256 underscore simple storage index. This will be a public view function since we're just going to be reading from our simple storage contract and it's going to return a UN 256, and.
00:05:26.732 - 00:05:33.394, Speaker B: We'Ll say simple storage simple storage equals.
00:05:33.522 - 00:05:39.398, Speaker A: We'Re going to use this same syntax from up here to get the contract simple storage array at the simple storage index.
00:05:39.494 - 00:05:49.866, Speaker B: And then we're going to do return simplestorage retrieve to get that number that.
00:05:49.888 - 00:05:51.646, Speaker A: We just stored up here.
00:05:51.748 - 00:05:56.350, Speaker B: And I should spell retrieve correctly. So we get no issues. Perfect.
00:05:56.500 - 00:06:00.490, Speaker A: So now we'll compile, we'll deploy Javascript.
00:06:00.650 - 00:06:02.590, Speaker B: We'Re working on a fake account.
00:06:02.740 - 00:06:04.618, Speaker A: We're going to use our storage factory.
00:06:04.714 - 00:06:05.826, Speaker B: Let's go ahead and delete all the.
00:06:05.848 - 00:06:07.074, Speaker A: Contracts we have so far.
00:06:07.192 - 00:06:11.554, Speaker B: Let's go ahead and deploy, hit the drop down rate right now.
00:06:11.592 - 00:06:13.666, Speaker A: If we do SF get at zero.
00:06:13.848 - 00:06:15.218, Speaker B: We'Re going to get nothing.
00:06:15.384 - 00:06:20.310, Speaker A: Simple storage at address zero is going to be nothing. Let's create a simple storage contract.
00:06:20.650 - 00:06:21.014, Speaker B: Now.
00:06:21.052 - 00:06:37.306, Speaker A: At simple storage list, we get an address at zero. If we hit SF get right now at index zero, we get zero. So let's store a value on this contract here. So the index of that contract is zero. So we're going to pass zero as.
00:06:37.328 - 00:06:39.498, Speaker B: A simple storage index and we're going.
00:06:39.504 - 00:06:41.210, Speaker A: To save the number seven.
00:06:41.360 - 00:06:43.422, Speaker B: So we'll go ahead and do SF store.
00:06:43.556 - 00:06:56.738, Speaker A: And if we did this right, this is going to store the value seven into this contract. So if we do SF get of zero now, it does indeed return seven. If we do SF get of one.
00:06:56.904 - 00:06:59.186, Speaker B: We'Re going to get nothing's going to.
00:06:59.208 - 00:07:04.734, Speaker A: Happen and we're actually going to get this revert error here. So let's create another simple storage contract.
00:07:04.862 - 00:07:05.154, Speaker B: Now.
00:07:05.192 - 00:07:13.782, Speaker A: If we do s of get of one, we get zero because we're going to get that default value. Let's go ahead on the simple storage contract. At index one, we'll store the number.
00:07:13.836 - 00:07:16.470, Speaker B: 16, we'll hit SF store.
00:07:16.620 - 00:07:23.594, Speaker A: Now, we'll do SF get of one and we get 16. Feel free to pause right now and play around with this so that you really understand it.
00:07:23.632 - 00:07:25.414, Speaker B: The quick recap is our storage factory.
00:07:25.462 - 00:08:02.230, Speaker A: Contract allows us to create simple storage contracts. It then saves it to our simple storage array, which we can then call different functions on. We can store values from our storage factory contract and then we can read values from our storage factory contract for any of the simple storage contracts that we've created. This is incredibly powerful. We can additionally make these two functions even easier. We can call the retrieve function directly on this. When we call simple storage array and then we add these brackets and add the simple storage index, this returns a simple storage object.
00:08:02.230 - 00:08:03.478, Speaker A: So what we could do is we.
00:08:03.484 - 00:08:13.834, Speaker B: Could actually delete this whole part and just dot retrieve right here and then delete this line and say return and.
00:08:13.872 - 00:08:15.466, Speaker A: Just have it be just like this.
00:08:15.568 - 00:08:16.666, Speaker B: If you go ahead and save or.
00:08:16.688 - 00:08:25.022, Speaker A: Hit compile, you'll get the green checkmark there. We're calling the retrieve function on whatever this is. And whatever this is is a simple.
00:08:25.076 - 00:08:27.246, Speaker B: Storage object so perfect.
00:08:27.428 - 00:08:28.574, Speaker A: We can do the same thing up.
00:08:28.612 - 00:08:39.722, Speaker B: Here by deleting this part and just doing store underscore simple store edge number. Tada.
00:08:39.866 - 00:08:42.382, Speaker A: We save it and this will work exactly the same.
00:08:42.516 - 00:08:43.006, Speaker B: Awesome.
00:08:43.108 - 00:08:54.130, Speaker A: We now have a simple storage contract. Can store variables in a storage factory contract that can be almost like a manager of these simple storage contracts and deploy and interact with them themselves. This is fantastic.
