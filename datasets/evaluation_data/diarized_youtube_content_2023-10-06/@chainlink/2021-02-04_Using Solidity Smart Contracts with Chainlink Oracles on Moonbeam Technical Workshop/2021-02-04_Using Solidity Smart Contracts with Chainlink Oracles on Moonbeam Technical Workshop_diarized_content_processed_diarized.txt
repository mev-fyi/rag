00:00:00.090 - 00:00:42.778, Speaker A: Really excited to have Alberto, the developer relations manager of Moonbeam Network, joining us today. Really excited for this presentation. Also have Patrick Collins joining us today to be able to answer and help ask some good questions on the technical front, but really excited to dive into a really neat network that's building with Polkadot, a new blockchain that you can do a lot of really exciting things with if you haven't seen a Moonbeam network. I'll make sure to drop those links into the chat here in a second. Throughout this, if you have questions, definitely drop them into the YouTube chat. We'll be monitoring it and bringing those questions live and whenever there's a break or pause we'll be able to answer your questions. So without further ado, thanks a lot, Alberto again for joining us.
00:00:42.864 - 00:01:09.442, Speaker B: Yeah, thanks Keenan for the nice intro and feel free to interrupt me if there's any questions going on throughout the presentation. So yeah, thanks a lot for having me. I'm really excited to be here. Like Keenan said, my name is Alberto. I'm the developer relations manager at Peerstay gang. Well, let me share the screen and just get started with. All right, so, okay.
00:01:09.442 - 00:01:17.786, Speaker B: Like Keenan said, today's presentation would be about Moonbeam. Basically we title it using solidity smart contracts with Chainlink, Oracles and Moonbeam.
00:01:17.838 - 00:01:18.390, Speaker C: Right.
00:01:18.540 - 00:01:23.474, Speaker B: And I work for Purestake, which is the company that is currently developing Moombeam.
00:01:23.522 - 00:01:24.118, Speaker C: Right.
00:01:24.284 - 00:01:48.782, Speaker B: So yeah, before we go into the presentation, a little bit about myself. I'm Alberto. Like I mentioned before, I'm actually a mechanical engineer. I did a phd in internal combustion engines. So nothing related at all in blockchain. But I joined Purestake June last year because I've always wanted to do something that I really like and I really into. I'm really into.
00:01:48.782 - 00:02:33.538, Speaker B: And so yeah, I took a shot at it and I joined pure stake last year as a developer relations manager. And basically my role in the company has been to do this documentation side and provide the best possible feedback or communication channels with our developers so they can onboard to moonbeam the easiest way possible, basically. And you can find my GitHub, basically handle on the presentation with a Twitter and also my email and feel free to reach out to me anytime you like with questions and everything and I'll be happy to answer them. So yeah, let's do first a session structure. Right, so we're going to first start with a brief introduction in Moonbeam and a summary of what's the deal with Moombeam.
00:02:33.574 - 00:02:34.062, Speaker C: Right.
00:02:34.196 - 00:03:27.882, Speaker B: And then we'll briefly go into some technical bits we're going to talk about our Ethereum compatibility features and some other additional features as well. And last but not least, we're going to do a little demo, and the demo will include some features like deploying smart contracts and interacting with the Chainlink Oracle system that we have deployed to our testnet called Moonbase Alpha. So actually, before we dive into the presentation, I'm going to do something a little bit different in this presentation, and I'm actually going to jump and do a quick demo. Right, so if you're familiar with the Ethereum ecosystem, what I have here on the screen is remix. So remix is this web browser based tool to compile smart contracts and deploy them. And it's a very easy way to get started with simple contracts and deploy them quite efficiently to any Ethereum network.
00:03:27.946 - 00:03:28.318, Speaker C: Right.
00:03:28.404 - 00:04:18.394, Speaker B: So what I have here is a very basic hello world contract, and basically it's going to store the world hello world into this variable here. So let's go ahead, and after it is compiled, I can go to this tab right here, which is our deploy and runs transaction tab, and I'm going to select this injected web3. So basically metamask is going to inject the provider here, and you will see that I have an account with holding one token, one ether in this case. And what I'm going to do is just deploy the smart contract, right. And if you're familiar with this, it's going to sound pretty basic and pretty straightforward. If you come from the Ethereum world, you have metamask on the right hand side, and I'm going to confirm this transaction. And what we're going to do now is wait some seconds until this transaction is confirmed.
00:04:18.394 - 00:04:26.014, Speaker B: Right, and we're going to wait and we will see our contract down here on the deployed contracts.
00:04:26.062 - 00:04:26.562, Speaker C: Right?
00:04:26.696 - 00:05:15.530, Speaker B: So basically what I've done until now is something that is very basic and it's very straightforward. If, like I mentioned before, you come from the Ethereum world and you can see here that it's pending, and hopefully we'll get our confirmation message soon. There we go. And then basically I can just pop the contract up and click in text and we have our hello world contract. Right, but what if I told you that all I just did, it was not against an Ethereum network, right, it was not against a guest node or an ethereum network. Rinkabee Coven Rupstin, but it was against basically another kind of network that runs on substrate, which is basically based in rust.
00:05:15.610 - 00:05:15.998, Speaker C: Right.
00:05:16.084 - 00:05:19.358, Speaker B: And that is what I'm going to present to you today. And that it's moombeam.
00:05:19.374 - 00:05:19.602, Speaker C: Right?
00:05:19.656 - 00:05:32.274, Speaker B: So the first question we have to ask is what is moombeam? And basically Moombeam is a smart contract parachain on Polkadot. And we like to say that it's the easiest entry point for Ethereum projects.
00:05:32.402 - 00:05:32.854, Speaker C: All right?
00:05:32.892 - 00:07:32.566, Speaker B: So basically, if you're not familiar with the Polkadot ecosystem, you have a main blockchain that is called the relay chain. And Polkadot itself does not offer smart contracts capabilities. And it actually outsources this kind of information to the other blockchains that will connect to it in forms of shards, if you're familiar with this Ethereum term, right? So mumbim at its core is just that it's a smart contract parachain on Polkadot, but we're deeply focused into deep Ethereum compatibility, let's say, right? So we want to provide the best and let's say the most frictionless experience for Ethereum users or developers in the Polkadot ecosystem. And because we're talking about the Polkadot ecosystem, we have to talk about cross chain integration, right? So the Polkadot ecosystem offers this native cross chain integration where these parachains or shards can communicate with each other. So basically the moonbeam can be your gateway to enter the Polkadot ecosystem. And once you're in, you can communicate with other blockchains. Just as a fun fact, the name Moonbeam comes from the jazz standard polkadots and moonbeams, right? So we like to say that the moonbeam's Ethereum compatibility features help polkadots in different ways, right? So first, it provides an easy on ramp for existing projects and developers because we offer a fully compatible Ethereum API and an AVM, right? So existing projects and developers can start working with Polkadot on Polkadot with minimal effort, meaning that you can just grab existing contracts that you have and just deploy them to moonbeam and they'll work, right? Moreover, the cool thing is that we provide developers to use the tools that they know and love, right, if you come from the Ethereum world, because we have tools that have been developed and updated for many years, such as Metamask, truffle, more recently hardhead and remix, like I showed you before.
00:07:32.566 - 00:07:43.200, Speaker B: And developers can build apps on Polkadot using these Ethereum based tools that they have gained experience over the years already. But Moomim is not only like.
00:07:44.950 - 00:07:45.314, Speaker C: It.
00:07:45.352 - 00:08:04.102, Speaker B: Extends beyond smart contracts and tools, right? We also offer other things like full Ethereum support for the Ethereum standard account format, signature support, and event subscriptions. And we'll see some of these features later on in the presentation. So why does a multi chain strategy make sense?
00:08:04.156 - 00:08:04.374, Speaker C: Right?
00:08:04.412 - 00:08:54.306, Speaker B: And these are only like three points. This is probably a never ending discussion. So on the one hand, we have the lost market opportunity. And just to provide an example, let's say. So let's say that you're a project that, I don't know, wants to run like a casino or some sort of thing, right, where the user will roll a dice on the blockchain and will just get a number from one to six. And it doesn't make economic sense to do this right now on Ethereum because of the high gas fees, right? So basically these kind of projects are priced out because let's say if a rolled dice costs like $25, it just doesn't make sense economically wise, right? So basically these projects are basically a lost market opportunity because they are not able to provide that service. So they can just move to another chain, which it might be cheaper to deploy.
00:08:54.306 - 00:09:31.570, Speaker B: On the other hand, we can say that the Polkadot ecosystem with Kusama are providing a whole new class of assets, right? And basically they're not native in Ethereum. So basically by deploying through moonbeam, you will be able to access these new kind of assets that will be available on Polkadot and Kusama. And we also think that blockchains, basically, in terms of user experience, there will be blockchains that are specialized for every use cases, right? So we don't think that there will be one blockchain to rule them all. So how does Moonbeam fit in this multi chain world?
00:09:31.640 - 00:09:31.922, Speaker C: Right?
00:09:31.976 - 00:10:22.530, Speaker B: So basically this is one way we like to look at things. This on the right hand side is basically the Polkadot ecosystem, where all these gray islands here are basically these parachains or like shards or different independent blockchains, right? And you can see that they're connected to the main circle, which is like the Polkadot blockchain, which is called the relay chain. And Moomim is just one of these, right? So basically, if you have your solidity smart contracts, you're actually able to deploy this to Ethereum, but you can also deploy them to moonbeam. And if we go as an example, if we were using truffle, by just changing a few words on the truffle config file, for example, you can add right now the Moonbase Alpha testnet. And just instead of deploying your contracts to Ethereum, you can just deploy them to the testnet. And it's just that simple.
00:10:22.600 - 00:10:23.074, Speaker C: Right?
00:10:23.192 - 00:10:55.434, Speaker B: And some of the projects are planning to deploy on moonbeam. They include Sushiswap, human protocol, ocean protocol, we announced a couple of weeks ago. Only we have bitcoin.com exchange, linear IDX, and some other projects. And we have a website, a page on our website with a full list of all the projects that are planning to deploy on moonbeam. So we already saw a small demo at the beginning. And I told you that, yeah, we were doing all these things, remakes, deploying contracts and checking the storage in the contract.
00:10:55.434 - 00:11:07.934, Speaker B: But the question is, how do we bring Ethereum compatibility to a substrate based chain? Because these blockchains are built in a framework called substrate, which is basically like Lego blocks, to build these different blockchains.
00:11:07.982 - 00:11:08.626, Speaker C: Right?
00:11:08.808 - 00:11:22.902, Speaker B: And I like to provide this definition, which I call the black box definition, because the idea is that to the end user, which is like the Ethereum user or developer, the experience will be just exactly the same. And that's what we are aiming for.
00:11:22.956 - 00:11:23.414, Speaker C: Right?
00:11:23.532 - 00:12:00.974, Speaker B: And basically the technology or the stack that we use is called frontier. And this is something that is developed by parity, but we're actually working on this repository. So the idea is that the Ethereum user or developer, basically they do the normal things they do with their tools that they know and love. And these tools, what they do is they do these kind of like JSON rpCs, right? And frontier acts as a middleware, so you don't have to know what's inside frontier, but it just acts as a middleware that translates this native Ethereum calls to something that the parachain, in this case moonbeam, understands.
00:12:01.022 - 00:12:01.378, Speaker C: Right.
00:12:01.464 - 00:13:01.510, Speaker B: And that's the beauty of it, that from the end user point of view, it'll just feel like Ethereum. And in that regard, we also like to talk about unified accounts. And why does it matter? Right? And the idea is because any blockchain or any group can just basically grab substrate, add two things that are called EVM palette and Ethereum palette with frontier. So these Lego blocks that I was talking about, and have a blockchain that it's EVM compatible, right. You can deploy contracts to it, but this is the scheme of how that looks and why we believe that it provides a little bit of friction, right? So let's say you're a user and this image is supposed to look complicated because it kind of is, right? So we'll go through it. So let's say you're a new user, right? And you have a private key that it's associated to an H 160 address. And that H 160 address is the normal Ethereum address that you see on metamask or any other wallet, it's just a normal Ethereum address.
00:13:01.580 - 00:13:02.200, Speaker C: Right.
00:13:02.650 - 00:13:11.322, Speaker B: So with this private key, you're able to sign transactions on the EVM substrate runtime. Sorry, that I just put on the right hand side of things.
00:13:11.376 - 00:13:11.786, Speaker C: Right.
00:13:11.888 - 00:13:42.574, Speaker B: So you can basically sign transactions, deploy contracts, and use the Ethereum API to read stuff. And that H 160 address actually maps to an h two five six address, which is the address format used by substrate. And you can, for example, store the balance on the substrate runtime. But because you don't own or you don't know the private key associated to this h two five six address, you cannot actually sign transactions in the substrate runtime.
00:13:42.622 - 00:13:43.218, Speaker C: Right.
00:13:43.384 - 00:14:18.154, Speaker B: So in order to do so, in order to interact with both the Ethereum side of things and the substrate runtime, which provides important features like staking and governance, you need to have a separate account. And this separate account will have a private key that is different. That's why it's called private key b, which is associated to an h two five six address type. And now with this private key that it's a different signature scheme. You can actually sign these transactions that enable you to do staking, governance and just simple transactions through the substrate runtime.
00:14:18.282 - 00:14:18.622, Speaker C: Right.
00:14:18.676 - 00:15:15.054, Speaker B: So the thing is that you need to have two separate accounts with two separate private keys to actually interact with the two separate runtimes, let's call it like that in our blockchain. And this creates friction because let's say you're staking tokens on one side of the runtime, and then you want to deploy a contract on the EVM. So you'll have to send tokens to your other account and then track that token and then sign it. And then if you have token left, you'll have to bring it back and so on. So we believe that there's some friction in this kind of setup, right? So what we did is just basically modify the underlying account system. So basically supports the ECDSA signature support from Ethereum. And that means that you can use the private key and the H 160 address associated with it to interact with both sides of the runtime, let's say.
00:15:15.054 - 00:15:55.094, Speaker B: Right, so you can either use contracts, deploy contracts on DVm, but also sign the governance and staking transactions. And this is just really exciting because it removes this kind of friction that we saw before. So basically what we like to say is this is basically ethereum, but these kind of features that are native from substrate. Okay, so I'm going to basically stop right now and look at some questions because we talked a little bit about staking. So yeah, we do have staking coming. We're actually running a test set right now and we might have staking available as soon as next week, although we'll see because we're still testing some things.
00:15:55.152 - 00:15:55.374, Speaker C: Right.
00:15:55.412 - 00:16:01.086, Speaker B: And of course, once we launch these features, we'll provide all the tutorials and documentations for it.
00:16:01.108 - 00:16:01.246, Speaker C: Right.
00:16:01.268 - 00:16:28.386, Speaker B: So I think it's exciting to see this kind of features. We do have some docker. Well, no, it's mooming. Kind of like dockerish thing or kubernetes type thing. Well, actually our kind of infrastructure uses this kind of things. But right now, for example, if you want to run your local standalone node, you can spin up like a docker instance in the tutorials. It's all provided in the tutorials.
00:16:28.418 - 00:16:29.000, Speaker C: Right.
00:16:30.990 - 00:16:41.334, Speaker B: Let's see. I'm not familiar with Polkadot. Yeah, so Polkadot, let me go back to this image because I think it explains it somewhat easily.
00:16:41.382 - 00:16:41.642, Speaker C: Right.
00:16:41.696 - 00:17:16.742, Speaker B: So Polkadot basically, let's say that it's a blockchain that acts like a director, a musical director, right. And basically the idea is that all these different blockchains that connect to this main ring, that it's another blockchain. The idea is that these parachains, which are called like moonbeam, will produce blocks, but these are validated by the relay chain. And the idea behind this is that the relay chain acts as a main, central brain and it's able to pass messages between parachains and coordinate different things.
00:17:16.796 - 00:17:17.014, Speaker C: Right.
00:17:17.052 - 00:17:25.174, Speaker B: So that's the main architecture of Polkadot right now. So I'm going to keep going with the presentation, but I'll come back to the questions, so no worry.
00:17:25.222 - 00:17:25.900, Speaker C: All right.
00:17:27.150 - 00:17:51.554, Speaker B: It's great to see, actually a lot of questions. All right, so we're going to start with the demo, like the real demo, not the first one that I did before. In this demo, we're going to go through Metamask remix once again. I brought some examples with Javascript libraries of deploying contracts, sending transactions, basically subscription to events. And of course we brought some examples on chainlink. So. Yeah.
00:17:51.554 - 00:17:56.260, Speaker B: Patrick, do you want to ask questions now before we go to the demos or how you want to do it?
00:17:58.070 - 00:18:01.141, Speaker D: We can go to the demos now. We can save the questions for the all.
00:18:01.141 - 00:18:01.526, Speaker C: All right. Right.
00:18:01.628 - 00:18:31.678, Speaker B: That's good. All right, so let's start with the demo. Before I go into the demos, I want to show you really quick our website, right? So we have Moomim network, which is our website. And if you click on docs, you'll land into this page and we're in the works of revamping this a little bit. But here you'll find a lot of things, a lot of tools and tutorials that we've worked with. For example, you can find integrations that we work. We have a bridge between Coven and Moonbase Alpha or testnet that it's working right now.
00:18:31.678 - 00:18:36.862, Speaker B: We have some examples with Javascript libraries, oracles of course, talking about Chainlink and some other things.
00:18:36.916 - 00:18:37.422, Speaker C: Right?
00:18:37.556 - 00:19:02.326, Speaker B: So feel free to look it through and if you have any questions you can reach out to us in discord and we'll be super happy to help. So what we're going to do first is we're going to head into metamask, right? And you can see here that I cheated a little bit before in the remix example because I had metamask already connected to our testnet, Moonbase Alpha. So you might have asked yourself, how do I connect Metamask to Moonbase Alpha?
00:19:02.358 - 00:19:02.890, Speaker C: Right?
00:19:03.040 - 00:19:40.546, Speaker B: So if you go to metamask settings, so basically click on this icon and go to settings, you will see that you have a networks option. And in here you can actually add a new network. And when you do so you'll actually have to fill in this information right here. But don't worry, because we got you covered. If you go to getting started testnet and then integrate metamask, you'll find like a step by step tutorial on how you can connect Metamask to the testnet. And here's the information that you need. Okay, once you do this and you click save, Metamask will automatically connect to the testnet.
00:19:40.546 - 00:20:09.920, Speaker B: And you will see that I have two accounts, Alice and Bob, not super original. And I have Alice's address right here. And you can see that I'm using metamask. So this is just basically an ethereum style address, right? If you want to get some tokens to start playing around with the testnet, what you can do is that in the same page that getting started testnet, you can click on faucet and we have a discord bot that you can request tokens to. And it's super simple and I'll show it to you.
00:20:10.530 - 00:20:10.974, Speaker C: All right?
00:20:11.012 - 00:20:47.974, Speaker B: So in metamask what I'm going to do is I'm going to copy Alice's address and I have discord right here. And you will see that inside the moonbeam channel there is a channel called Alphanet bot. You see that people have requested tokens over and over. So what I'm going to do is that I'm going to type faucet send and I'm going to paste in my address. So basically the faucet will get fetch your address and send you a transaction for ten dev tokens. And this is limited right now to once per hour per discord user. We might change this in the future, but for now it's set up to 10 discord user.
00:20:47.974 - 00:21:12.514, Speaker B: Of course this takes a little while because the bot has to send the transaction. And once the transaction is confirmed, you will see that I have a confirmation from the mission control bot. That's a pretty cool name. And if we go back to Metamask, it usually takes a while to load, but if I do this trick of changing accounts, we should have. There we go. We have eleven tokens now, so it's pretty easy. That's it, that's it.
00:21:12.514 - 00:22:20.130, Speaker B: You can get tokens to just get started with the testnet. All right, so the next demo that I want to show you, let's go back to remix. And I'm going to deploy an ERC 20 token contract, which is like one of the bare bones of Ethereum, right? So what I have here, I have this super zoomed in, let me expand this a little bit. And I'm importing the open sepling solidity zero seven ERC 20 token contract. And what I have here is just the constructor, I'm setting the token name to chainling workshop and the ticker is clws, right, not a pretty name, but anyways. And I'm going to just mint a thousand tokens and as normal, this will basically set the whole token balance to the owner of the contract, which in this case it will be Alice, right? So you see here that I have injected web3 and I can see the chain id of Moonbase Alpha, our testnet. And if I go down, I can just deploy this and I'll get a message from metamask.
00:22:20.130 - 00:23:11.982, Speaker B: It looks kind of weird because I have this super zoomed in, right? So it's normally not this kind of like strange. So I'll confirm the transaction and while we're pending, I'll just answer some more questions. So Moomim is not a javascript type filter or anything. Moonbeam is its own blockchain, right? What we offer is basically, like I mentioned, frontier. I like to say it's like a translator between what normally goes on on Ethereum and what our blockchain is, which is built on a different technology stack, which is substrate, right? So it's a blockchain, it's actually producing blocks and everything. And you can connect to the testnet. I have an NFT contract on Ethereum is launching it on Moonbeam worthwhile? Yeah, you can actually go ahead and test it out on our testnet.
00:23:11.982 - 00:23:52.470, Speaker B: I invite you to do so and provide some feedback. I mean, right now it's only a testnet, but we actually plan to deploy on Kusama and Polkadot. So Kusama, I don't like to say it's a testnet, but it kind of is. So it's like what's called a cannery test to test code out, but it's actually under real economic conditions. So it's basically Kusama has its own token, the KSM, and it's worth something. And we're going to deploy moonbeam blockchain, let's call it like that, or a parachain to Kusama called Moon river. So I mean, this hopefully will happen at the end of Q one, but it doesn't only depend on us, but that's our roadmap for now.
00:23:52.470 - 00:24:21.694, Speaker B: And we're planning on polka dot mainet for the end of Q two. But yeah, you feel free to try it out on our testnet. All right, so we have our token deployed. We can see it down here on the screen. And it's just a normal ERC 20 token. It has all these methods. You can see that I can check the decimals, I can check the name, I can check the ticker or the symbol and I can go ahead and grab Alice's address and get the balance, for example.
00:24:21.694 - 00:24:57.466, Speaker B: And you can see that I have 1000 plus 18 zeros in balance. But I can also go ahead and copy the token address and go to metamask and I can just add this token, as you can see right here. Sorry, I did it too fast. So in metamask, I go to add token, custom token, and I paste the token address, right? And it fetches automatically the symbol at the decimal. And you can see that when I add it, I have 1000 tokens. I can transfer these tokens from Alice to Bob and all that, but I'm just going to go ahead and skip it just for the sake of time. Right? So that's it.
00:24:57.466 - 00:25:06.302, Speaker B: I mean, we've deployed an ERC 20 token contract on Moonbase alpha, which is our current testnet. And we can do stuff with this ERC 20 token if we want to.
00:25:06.356 - 00:25:07.054, Speaker C: Right?
00:25:07.252 - 00:25:40.762, Speaker B: So let's go for another question. Does every moonbeam node also run frontier or is frontier? So basically frontier is part of the runtime of moonbeam on the definition that I put on the slide, I put it on the middle as a black box. But because I like to show it like that, because it's like a middleware, right. But it's part of our runtime stack. Every node runs the frontier because it's basically the way. So basically when you do an ethereum action, what happens on the back end? It's called the JSON RPC, right. So it's a protocol to send stuff.
00:25:40.762 - 00:26:10.158, Speaker B: So basically the frontier grabs that message and translates it to something that moonbeam understands. But it's part of Moonbeam. So Moombeam is not mainly for developers. I mean, you can think of it as another Ethereum, right? So I mean, there's people right now, I don't know, with the NFT markets. So artists are publishing their art on NFT markets. And that's already our goal as well, to have these kind of markets under the Polkadot ecosystem. So it's not only for developers.
00:26:10.158 - 00:26:32.140, Speaker B: I mean, right now we're on a testnet and we're actually testing stuff out. So probably developers are the one that are engaging more with the platform. But in the future, we just want to be just like Ethereum, but on the Polkadot ecosystem. So I'll keep with the questions later on. I really like that. There's a lot of questions going on. This is super interesting.
00:26:32.140 - 00:26:43.814, Speaker B: All right, so what I have here now as a demo is some codes in the ether JS library. I'm not going to go through it specifically, but the idea of this code is that it sends a transaction.
00:26:43.862 - 00:26:44.314, Speaker C: Right.
00:26:44.432 - 00:27:08.062, Speaker B: And what I want to show you here is that the only change in this code between Ethereum, like doing this on Ethereum and doing this on Moonbeam is on line seven. This is the only thing that you have to change to be able to work like this code can exactly work the way it is by just changing line seven and pointing it to, for example, an Ethera API. This code will work exactly on Ethereum.
00:27:08.126 - 00:27:08.498, Speaker C: Right.
00:27:08.584 - 00:27:39.578, Speaker B: So what this code does is basically send a transaction from using the private key that is stored in secret stuff, JSON. And I'm going to send it from Alice to Bob. And basically it's just an ether JS code where I define the provider. I create the wallet passing in the private key and then just create the transaction object and just send a transaction. It's a super simple code just to show you how easy it is to play around with moonbeam. You can see that I added some logs down here. So we're sending a transaction.
00:27:39.578 - 00:28:21.206, Speaker B: This is Alice's account, and this is Bob's account. And once this transaction is confirmed, we'll actually see the transaction hash. I think I have time for a question. Are there gas fees? Yeah, of course there are gas fees because basically Ethereum and the token that we'll have right now, it's called Dev on the testnet, it's what it's called a utility token. So it's a way to pay for execution on the EVM. So we will have gas fees. Actually, the gas itself, the gas cost of gas execution is the same as Ethereum, but what will change is the price of the gas.
00:28:21.206 - 00:28:21.898, Speaker B: That's the difference.
00:28:21.984 - 00:28:22.282, Speaker C: Right?
00:28:22.336 - 00:29:00.438, Speaker B: So now that we have the transaction hash here, we can actually copy this. And we do have an explorer, but it's not like a Moomim specific explorer, it's just an explorer that you can point to any RPC URL and it works. And you can see that, for example, because we're a proof of stake network, the hash rate doesn't work. Or like the uncles, which is something that is specific to Ethereum, doesn't work. But anyways, you can actually go ahead and search for the transaction hash here and you can see that this is the nonsens 29. We sent a value of one ether. In this case it's dev, and we have the from and two addresses and the signature and everything.
00:29:00.438 - 00:29:07.414, Speaker B: And if you go to metamask, we can actually see that Alice now has ten dev tokens and Bob has two dev tokens.
00:29:07.462 - 00:29:08.060, Speaker C: Right?
00:29:08.990 - 00:29:39.294, Speaker B: So this other example here is pretty similar. But I just grabbed a contract and what I'm going to do here is just deploy it, right? So a contract is super simple, it's an incremental contract. And you can see here that the only line that I have to change to make this code work for Moonbeam is the provider once again. So we're just pointing it to our RPC from the testnet, the RPC endpoint in our testnet. And this code exactly works the way it is on Ethereum and in Moonbeam.
00:29:39.342 - 00:29:39.698, Speaker C: Right?
00:29:39.784 - 00:30:17.290, Speaker B: So basically we're just creating a local instance of the contract using the deploy method, passing in the initial number in this case and just waiting until it is deployed. So I'm going to go ahead and deploy this contract. And let's see another question, something behind scenes of the other dapps. I don't really understand this question. Sorry about that. Do you plan on having more activity on KSM or on dot? So this is a good question. Right, so we're going to have two deployments, one in Kusama and one in Polkadot.
00:30:17.290 - 00:30:45.006, Speaker B: And the idea behind this is to follow the same pattern that parity is doing. So basically what they're doing is that they're testing. I put double quotes because it's not like they're testing just because of the sake of it. They test code on Kusama, and only code that is externally audited embedded goes to Polkadot. So Kusama, they like to say it's like a faster custom because it's faster, because it can move faster in terms of upgrades and governance and those kind of features.
00:30:45.058 - 00:30:45.418, Speaker C: Right.
00:30:45.504 - 00:31:14.446, Speaker B: So we do plan to have both deployments. And one thing that I like to see Kusama, for example, our deployment in Kusama to say about it is that projects can actually test to get feedback from the users like features. Let me try this feature and see if users like it. But once again, in real economic conditions, I would expect it to be a cheaper chain to interact with. So some projects might just prefer to just deploy to Kusama instead of Polkadot.
00:31:14.478 - 00:31:14.626, Speaker C: Right.
00:31:14.648 - 00:32:02.818, Speaker B: Because they just want to have some part of the blockchain that it just works if you're only in Kusama. So as you can see here, the contract was deployed at this address that I have down here. So what I'm going to do now is I'm going to go to remix and I'm going to load this contract that I have in remix. But instead of deploying it at remix because I just did, what I can do is that I'm going to paste the address here and click on add address and this will bring the instance of the contract here. And I can check the number and you can see that the number that we stored initially was five. And this number is five. So just to show you that the contract was deployed correctly, the next tutorial that I have is basically it's a different side of things, right? So now we're going to use the web3 library, which I have installed in this folder as well.
00:32:02.818 - 00:32:37.758, Speaker B: And we're going to use subscription to stuff, to events and to this kind of things, right? So the first one that I'm going to show you is pending transactions. So basically using the web3 method called Eth subscribe. And when I run this code, what I'm going to get, if I'm lucky. So this is the subscription id it's called. And if I'm lucky enough and someone is using the testnet, I will get transaction hashes appearing, popping up here. So you can see that I was lucky. There are two transactions sent, right? Now let me control c here.
00:32:37.758 - 00:32:50.350, Speaker B: And the next thing, for example, is basically, oh, one thing. Once again, the only thing that I change here is the RPC endpoint, in this case the websocket endpoint to create the web3 instance.
00:32:50.510 - 00:32:51.122, Speaker C: Right?
00:32:51.256 - 00:33:13.618, Speaker B: So I can use the same code exactly to subscribe to block headers, right. So we can go ahead and fetch the block headers that are being produced. So once again, oh, I'm going to just pause this here. And once again I get the subscription id. And you can see that I have the author. This gas limit number is not right. This is already fixed.
00:33:13.618 - 00:33:58.934, Speaker B: And hopefully by next week when we do the one update, it'll work, it'll get fixed. We have the block number, we have the parent hash, receives root and a lot of information that it's useful. The timestamp, for example. And the last thing that I want to show you, it's the subscription to events from contracts, which is like super interesting, right? So what I'm going to do is that I'm going to grab this incrementer contract that you can see that when I use this function increment, basically it'll increment, of course, the numbers stored by a value, but it'll also emit an event. Okay, so I'm just going to copy this address right here. I'm going to go to this code which uses once again the web3 eth subscribe method. I'm going to paste the address here, right.
00:33:58.934 - 00:34:07.382, Speaker B: So what it does is just basically subscribe to all the events emitted by this contract, this specific contract.
00:34:07.446 - 00:34:07.962, Speaker C: Right.
00:34:08.096 - 00:34:41.398, Speaker B: And I'm not passing anything as topics for now. We're not going to go into this, but this is a possibility as well. So what I'm going to do is that I'm going to increment this value, for example, by two. And I'm going to prepare this. So I'm going to prepare this transaction, but before I send it, I'm going to subscribe to this. Right, so I already subscribed. I'm going to open this pop up metamask and then confirm this, right.
00:34:41.398 - 00:34:48.710, Speaker B: And once this is processed, we should see the event logs from that event that was emitted by the contract.
00:34:50.650 - 00:34:51.430, Speaker D: There we go.
00:34:51.500 - 00:35:23.540, Speaker B: I'm going to pause this now. And you can see that basically this is the address of the contract. And in the topics, because these values were actually indexed, are returned inside the topics field, we see that we incremented by a value of two, and the number stored right now is seven. So yeah, it's pretty cool. And this is super useful because a lot of front ends fetch this kind of events and actually Chainlink fetches some events to make their oracle system work. And we'll get into that in a minute. Let me see some questions.
00:35:23.540 - 00:35:39.266, Speaker B: Do you have to have a blockchain that runs with it or can you just utilize. Well, I mean non blockchain apps? I don't actually see a use case right now for non blockchain apps.
00:35:39.298 - 00:35:39.494, Speaker C: Right.
00:35:39.532 - 00:35:49.402, Speaker B: So I mean moving, being a blockchain, you would expect to have dapps that needs these blockchain capabilities for transparency or whatever you want to use the blockchain for.
00:35:49.456 - 00:35:50.010, Speaker C: Right.
00:35:50.160 - 00:36:48.570, Speaker B: So there are a lot of questions. I'm going to go continue with the tutorial before I run. I want to finish this and then we can go back to the questions because the next tutorial is actually Chainlink and this is the one that I want to have time for. So before we actually go into these tutorials, I want to explain two concepts that you guys might already know, but I wouldn't have it clear just because we're going to go into them a little bit. In a little bit. So the first one is that Chainlink offers two, let's say architecture models to get data off chain to the blockchain, right? So the first one is called the basic request model. And in this model, basically let's say a user wants to get the price of bitcoin, let's say, right? So the user can use a chain link client contract which makes a certain calls to an Oracle contract that emits an event, right? And this event is fetched similarly, like I showed you right now with the Oracle node that it's off chain.
00:36:48.570 - 00:37:39.646, Speaker B: So this oracle node has an API provider or whatever way of getting the price that you requested and then basically writes the information back through the Oracle contract. Through the Chainlink client contract, right? So this is like a two way communication. In our current setup you always need the link token, but in our current setup you can set the link payment to zero. So basically you're not paying or anything for this kind of information. And it's like a two way trip, right. You need to send this information to the oracle node and then the Oracle node sends it back with the price that you were actually trying to fetch the other way. It's called the price feeds and it works a little bit different because basically a user using a consumer contract, they just do read operations to an aggregator contract, right.
00:37:39.646 - 00:38:32.030, Speaker B: And the Oracle notes that it's off chain right now what it does is that it fetches the price, let's say from an API provider and just writes that price data into this aggregator contract. There's a lot of ways you can decentralize this and it's very well detailed on the Chainlink documentation. But for just this example, let's say that it's only like one oracle node just writing one data feed or one price to the aggregator contract. In our deployment that we have in Moonbase Alpha, basically the price is checked every minute. So this oracle checks the price from the API provider every minute and we update the price to this contract every hour unless there is a deviation greater than 1%. Okay, so we're going to go through both examples which are different but they both works, right? And we're not discussing topics about the economic model of each or anything. This is just to showcase the chainlink functionality on moonbeam.
00:38:32.030 - 00:39:08.842, Speaker B: So let me head back and for this I'm going to use this website. So basically I have to go to integrations, oracles and chainlink. And here once again we explain a little bit how it works. What's the idea behind everything? But what I'm going to show you is basically the client contract. Let me zoomed in a little bit. So the client contract has this function called request price which uses a send chain link request to what you need to pass in the oracle address, this rec field that it's built up here which is basically the job id. And I'll show you a little bit.
00:39:08.842 - 00:39:51.410, Speaker B: In a little bit, what's the job id and the payment which I told you already that you can set to zero in our deployment. But instead of doing this complicated bit of deploying your client contract, which you can, what we actually did is create a simple interface. Okay, so this is the interface that you need to interact with this contract and basically it provides you this request price function where you pass in the job id. And you might ask yourself what is the job id? Well basically the job id is related to the price that you want to fetch. So for example, if you want to try to fetch Btc to USD, you need to pass in this job id. In our case, let's go for link to USD.
00:39:51.490 - 00:39:51.878, Speaker C: Right.
00:39:51.964 - 00:40:42.614, Speaker B: So let's actually go for Btc to USD. So I'll just copy this job id. Well actually I have to go to remix and I'm going to open this contract that I have already here, basic request model interface. And with the interface loaded I'm going to basically load it on the left hand side by passing that address that is right here into this at address box and just click this button and you see that I have it down here. So when I was testing this, I actually was requesting, I think this is Ethereum's price. Could be right. So what I need to do is that in this request price button, I'm going to go ahead and copy the Btc to USD job id, go to remix, paste it in here and let's request this price so you can see here.
00:40:42.614 - 00:41:09.954, Speaker B: Okay, so right now we have a problem when there's like a contract calling another contract. This is already fixed and it will be updated on the next release next week. But for now when you see a very high gas limit, you can set it to 5 million. But like I mentioned before, I mean, this is way overkill for this. But like I mentioned before, next week this is already fixed and it will be updated. So while we wait, let me see if I answer some questions. I'm going to go from bottom to top because I have them here.
00:41:09.954 - 00:41:31.190, Speaker B: We do support ERC 1155. I've actually tested out myself. Basically, Erc one one five is just like an all in one contract for both nfts and fungible and non fungible tokens. All in one contract. And I've deployed them myself with remix actually. And they work. It's supported.
00:41:31.190 - 00:41:51.354, Speaker B: Yeah. So this is actually a great question. So I heard from Gavin woods saying that Polkadot is going to have upgrades and no forks. And we're very excited because we have been testing this in our testnet and usually the upgrades that we've done before, we just purge the testnet, erase everything and just deploy a brand new blockchain.
00:41:51.402 - 00:41:51.758, Speaker C: Right.
00:41:51.844 - 00:42:26.634, Speaker B: But actually we have already tested this and hopefully if all goes well, we're going to try this out with a big, big update coming next week. And the cool thing about this is that in Ethereum when there was a big update, you need to fork the blockchain, right. And force everyone to move to the new fork. In Polkadot there is a way of doing forkless upgrades when you can upgrade the runtime without needing a fork. And there's a lot of information in this on the Polkadot wiki, but it is possible. And we have done this before and it's super exciting actually. So yeah, I answered this.
00:42:26.634 - 00:42:31.142, Speaker B: What is the benefits? I think the benefits is basically that it's forkless.
00:42:31.206 - 00:42:31.386, Speaker C: Right.
00:42:31.408 - 00:42:40.442, Speaker B: I think that the name just says it all. You don't have to worry about having two blockchains and making sure everyone migrates to this new definition or version.
00:42:40.506 - 00:42:40.974, Speaker C: Right.
00:42:41.092 - 00:43:19.402, Speaker B: And honestly, at the top of my mind, I cannot think of any drawbacks. I mean, probably because there is a lot of complexity on the background, but if this is fixed and it works, it's great. Currently, I don't think we have any positions for new developers, but feel free to reach out to us and we'll keep you in mind. All right, let me see. Well actually this was already deployed, so I mean, you can see that the transaction was confirmed down here and hopefully we have the price updated. You see that bitcoin's price right now is $37,205.88. At least that's what the node is telling us.
00:43:19.456 - 00:43:19.818, Speaker C: Right?
00:43:19.904 - 00:44:19.450, Speaker B: Which is great. I mean this can be just adapted to any D app or whatever, right? So this interface, so let's go for the price feed interface, right? So let me go back to the documentation and once again, there's a little bit of like a short definition of how price feed works. And you can try it on Mumbai South, a very simple, in a very simple way. Basically we have this consumer v three interface which basically has this get latest price function. We also included its decimal function. So you know how many decimals this price has? And the description, just to provide a little text of like, okay, this is this price in this unit, right? And once again, what we did is to deploy all these consumer contracts so you can have all these price feeds available right now in our testnet. So let's go for for example, link in USD, right? So what I have to do is I'm going to copy this, go to remix and get my price feed interface.
00:44:19.450 - 00:44:54.040, Speaker B: And once I have it here, I can just repeat the same process I did before in the add address. I'll just paste in this consumer address and just click on the button and this contract pops up down here. So you can see here that this price feed that I'm getting has eight decimals. If I click on the description, it says that it returns link value in USD. And if I get the latest price, these are read only operations as you can see. And the current Lin token price is $24. And these are probably eight decimals as you can see right here.
00:44:54.040 - 00:45:23.874, Speaker B: And yeah, I mean, I think it's super exciting to see these kind of features already available in our testnet. Sorry about this. And you can start using them in your d apps because this is only like read only operations that you can implement into your d app or your web front end. And just like for example, display the prices and everything. So yeah, it's super exciting. So let me see if there's any more questions. I think so, yeah.
00:45:23.874 - 00:45:43.910, Speaker B: There's a question regarding the token and we do have already some token information available. Probably Katie or Kathy will paste the links on the chat. Yeah. Okay, so Katie shared the links. Thanks a lot. Yeah, Patrick, go ahead. I mean, I think I have only like the end slide.
00:45:43.910 - 00:46:19.054, Speaker B: Yeah, well, let me just finish if you want. So all sounds great. Right, so how do I get started? So basically we recommend you guys to go to our, oops, I moved this to our docs website. Basically it's what we call like to say a one stop shop where you have tutorials of how to integrate metamask remix. We also have tutorials on Truffle and hardhat, Ethereum, Javascript libraries, oracles bridges. Like I mentioned before, we do have a bridge working between Covid and our testnet and we have many things coming as well. So excited.
00:46:19.054 - 00:46:49.790, Speaker B: If you guys go to our docs website and ask questions about it and how you can get in touch with us, you can visit our website Amumi network, go to our discord channel, and we have a very open community always answering questions that you might have and helping guys to figure out some roadblocks, or helping them out on deploying their contracts into our testnet. And yeah, you have our couple of GitHub repos here on the screen, so I guess that's all on my side. So Patrick? Yeah, please go ahead.
00:46:49.940 - 00:47:03.460, Speaker D: Yeah, awesome. And thanks so much for that demo. I actually tested this out yesterday or two days ago, and I was surprised at how easy it was to actually get set up and get going, which was great.
00:47:04.870 - 00:47:09.140, Speaker B: Did you try the interfaces or you deployed the client contract yourself, for example?
00:47:12.090 - 00:47:41.454, Speaker D: I didn't even know that you had nodes already running. I just went through the whole process. I deployed a fake link token, I deployed a chain link node and I was like, oh yeah, this works great. Yeah, it just shows kind of how well done the EVM was, because I've worked with a lot of other chains at this point and sometimes something on the EVM will be a little off and then everything doesn't quite sync up right. I was really impressed with, we do.
00:47:41.492 - 00:48:04.166, Speaker B: Have a tutorial of how to run your tangling, your own tangling oracle node on moonbeam, so that's available as well for people if they want to jump in and try it out. But yeah, thanks a lot. And we're actually super happy to collaborate with other projects because we do want to offer the best or the most frictionless environment for ethereum projects because it's just the best way to onboard them, right at the moment. They feel any friction, they'll just say, hey, this is not for me.
00:48:04.188 - 00:48:23.260, Speaker D: Right, agreed. I think you guys are doing a great job. So just kudos for what you guys are doing. I did have a couple of questions that I want to ask, and then it sounds like everybody's asking really good questions. So can we go back to that wallet? Polka dot eth? I think a couple of people were a little bit confused on the frontier thing.
00:48:23.950 - 00:48:25.386, Speaker B: Okay, this one.
00:48:25.488 - 00:48:25.706, Speaker C: Yeah.
00:48:25.728 - 00:48:34.190, Speaker D: So both the frontier and the other one. So you're saying I deploy something on. Or is frontier the compiler, or is that.
00:48:34.340 - 00:48:35.902, Speaker B: Could you explain that a little bit more?
00:48:36.036 - 00:48:36.334, Speaker C: Yeah.
00:48:36.372 - 00:49:09.020, Speaker B: So frontier is basically like a module or something that runs inside the moombeam runtime. Okay. And I like to put it here. Even though it looks like it's outside moonbeam, it actually lives inside moonbeam. And the idea is that it's basically the Ethereum compatibility layer. So it's what translates this JSON RPC calls that are made by the web3 library or the ether JS library or whatever, to something that moonbeam understands. I like to look at it as a translator, basically.
00:49:09.710 - 00:49:19.850, Speaker D: I think I get that. Right, because Moonbeam obviously is written in rust. It's using substrate, and then you're converting an RPC call to whatever it is in rust.
00:49:20.530 - 00:49:30.334, Speaker B: And the great thing is that you can actually grab like a JSON RPC. I have a friend and a colleague of mine in moonbeam that I always joke that he speaks JSON RPC.
00:49:30.382 - 00:49:30.594, Speaker C: Right.
00:49:30.632 - 00:49:47.800, Speaker B: He doesn't like to use web3 or ether. He just prefers to do this JSON RPC stuff directly. And you can actually do it that. I mean, if you want to just do a JSON RPC call with passing our HTTPs endpoint, you will just get a result out of that.
00:49:48.170 - 00:50:07.486, Speaker D: Yeah, very cool. Can then we go to that other one a little bit lower, like kind of that eth substrate? Yeah, this one right here. Okay, so is this saying, hey, here's kind of what the equivalents are, or I apologize, I don't remember if you said there's a way to translate for the two of them to talk to.
00:50:07.508 - 00:50:17.530, Speaker B: Each other, or what was basically like, let's say you, Patrick. Right. You know, a little bit of substrate and you want to build your own blockchain that has ethereum compatibility.
00:50:17.610 - 00:50:17.998, Speaker C: Right.
00:50:18.084 - 00:50:32.614, Speaker B: So you can grab the substrate template and just add this EVM palette, which is like a Lego piece that you can plug into, and then Ethereum palette and frontier. And you'll have a blockchain that is compatible with Ethereum. You can deploy Ethereum smart contracts there.
00:50:32.652 - 00:50:33.094, Speaker C: Right.
00:50:33.212 - 00:51:22.174, Speaker B: But the problem that exists here is that if you want to interact with the Ethereum side of the runtime, so the Ethereum part of that blockchain that you built, you will need a private key that is associated to the H 160 address, which is basically the ECDSA signature scheme, right? Yes, but the problem is that there are mathematical ways to map that h 160 address to an h two five six address, which is what substrate understands. Let's say that substrate talks or understands or speaks in h two five six address language. And Ethereum speaks in h 160 address language. Okay, so basically the problem is that because you don't know the private key of that h two five six address, you can do read operations, because anyone can do read operations, but you cannot sign transactions and send transactions.
00:51:22.222 - 00:51:22.674, Speaker C: Right.
00:51:22.792 - 00:51:45.574, Speaker B: So where you're going to do a staking, you have to do a transaction to start staking in the network. So for that, you actually need a separate account. So that's why it's called account two, that has a private key associated to a nation two five six address from which you can actually sign these substrate transactions, let's call them like that, right? So we do believe that it provides some friction.
00:51:45.622 - 00:51:45.786, Speaker C: Right?
00:51:45.808 - 00:52:16.774, Speaker B: Because let's say you want to send a staking transaction, you need some funds on that account, but then you want to deploy a contract. Oh, crap. You have to go back to your account one and then send tokens there. So it just creates a little bit of confusion and friction. So what we have done is that we have modified the underlying account system in substrate so it understands EasydSa signature scheme. So basically the normal private key that you're used to from Ethereum and the h 160 address. And the idea of these two images is that this one looks complicated, right? It's because it is.
00:52:16.774 - 00:52:18.838, Speaker B: And this one looks like so simple.
00:52:18.924 - 00:52:19.174, Speaker C: Right?
00:52:19.212 - 00:52:20.214, Speaker B: So that's the point.
00:52:20.332 - 00:52:34.886, Speaker D: Yeah, I see what you're saying. That's cool. This is like rumor, real stuff. I heard eth two might actually change from 160 to the other one, but I'm not sure that's totally hearsay.
00:52:35.078 - 00:52:41.466, Speaker B: Yeah, I think the problem right now is that the roadmap for e two is still pretty unknown.
00:52:41.498 - 00:52:41.646, Speaker C: Right?
00:52:41.668 - 00:52:53.522, Speaker B: So we have had a lot of projects saying, yeah, e two sounds good, but it has been delayed so many times, I think there was already an EIP to delay the difficulty bump already like one more year.
00:52:53.576 - 00:52:53.794, Speaker C: Right.
00:52:53.832 - 00:53:01.970, Speaker B: So the problem is that a lot of projects are being like, they have constraints right now and they need a solution right now. And that's what we're trying to offer with Moonbu.
00:53:02.470 - 00:53:37.694, Speaker D: So that actually leads really well to my next question. Probably one of the harder questions. One of the questions you get a lot. And this is the type of thing, I think, as a developer, right, when I'm looking at different chains, different tools, that's exactly what I think of them. As I say, okay, this is a tool. And then I have to ask myself, why is this tool better than another tool? Why do I want to, is it going to make my life easier? Is it going to be cheaper? Is it going to be faster? Am I going to get more users? So this is kind of a twofold question. I'm not going to ask what makes your chain better than ETH, but what do you think the relationship between moonbeam and ETH is going to be moving forward?
00:53:37.892 - 00:53:56.582, Speaker B: Well, we don't like to think ourselves as an ETH killer or anything, because I do believe that if you think about it right now, the blockchain world is still not, how do you say, the general user? There is not a broad adaption to the blockchain world is still very small.
00:53:56.636 - 00:53:56.902, Speaker C: Right.
00:53:56.956 - 00:54:03.922, Speaker B: So I don't think there is like one blockchain to rule them all. So I think that moomim can coexist perfectly with Ethereum.
00:54:03.986 - 00:54:04.262, Speaker C: Right.
00:54:04.316 - 00:54:35.694, Speaker B: If you were like, going back to this slide, I think the zero, one and .2 kind of answer those questions, because if you're priced out in Ethereum, l one, you can just move to a cheaper chain, right? Or let's say you're not priced out because, I don't know, you don't mind about current Ethereum gas fees, but you want to tap into a new market, access new assets. Remember that Polkadot, if you enter the Polkadot ecosystem through Moonbeam, you'll have access to a whole other world of assets and blockchains.
00:54:35.742 - 00:54:35.954, Speaker C: Right.
00:54:35.992 - 00:54:51.510, Speaker B: So I think that's also interesting for projects to tap into this new world of assets. And they want to expand beyond Ethereum. They want to stay in Ethereum as well, but just want to expand beyond Ethereum because they want to tap into this new market that it's forming.
00:54:52.090 - 00:55:17.070, Speaker D: Yeah, I think that makes sense. That's the very polka dot pilled of the world, if you will. Multi chains. You know, chains are going to want to talk to each other. Each chain is going to know its pros and cons and they want to talk to each other and I know this is a little bit forward thinking, but Dot hasn't released their slots yet, right? Has KSM released their slots or.
00:55:17.220 - 00:56:10.350, Speaker B: Not really? I know that there's another blockchain called rokoko which is like the actual testnet of this KSM or Polkadot kind of ecosystems. And I know they're starting to open slots for parachains to connect to and everything. Boombeam actually did not participated in this kind of registration of parachains because we are actually running this kind of relay chain parachain setup since day one in our testnet. So we believe that we actually gain more knowledge, us running our own setup where we can control all the versions of the packages and stuff like that. So that's one of the problems that we want to deploy on Q one, on Kusama and the end of Q one. But there is still a lot of work to be done by parity in this sort of like auctions and slots of the parachains.
00:56:11.170 - 00:56:16.110, Speaker D: But it sounds like you do want to be on one of the slots, like be on one of the early parachains.
00:56:16.190 - 00:56:21.800, Speaker B: Yeah, definitely. So our idea is to be a parachain on both Kusama and Polkadot. So yeah, definitely we do.
00:56:23.050 - 00:56:23.462, Speaker C: Yeah.
00:56:23.516 - 00:56:45.594, Speaker D: Very cool. Like I was saying, I've enjoyed building on it so far. I think it's a really cool project. I think plasm is kind of the other one on Polkadot that's doing something similar. They're also trying to bridge this evm to Polkadot compatibility. I haven't checked them out yet, but they're on my to do list. But, yeah.
00:56:45.594 - 00:56:46.810, Speaker D: Awesome presentation.
00:56:47.710 - 00:57:21.026, Speaker B: Well, I mean, they're three minutes and there are a couple of questions I'm afraid that I'm not going to have time to answer them. But what I can tell you about the bridge is that we do have this bridge going on between Moonbase Alpha, which is our testnet, and coven. And it's really cool because it's a two way communication bridge. We have two somewhat simple examples to transfer ERC 20 tokens between both chains and ERC 721 tokens between both chains.
00:57:21.058 - 00:57:21.302, Speaker C: Right.
00:57:21.356 - 00:57:42.462, Speaker B: So we do have basically a tutorial on that. Hopefully Kathy or Katie will share that link with you and you can follow along the tutorial. And if you run into any problems, just let us know on discord and we'll help you through it. And regarding the question and NFT. So this is a very good question.
00:57:42.516 - 00:57:42.782, Speaker C: Right.
00:57:42.836 - 00:57:54.814, Speaker B: And this is something that we're thinking about right now in the bridge, for example, in the bridge that we have set up. One way of NFTs being unique inside the NFT contract is that they have a unique index.
00:57:54.862 - 00:57:55.074, Speaker C: Right?
00:57:55.112 - 00:58:26.798, Speaker B: So let's say I have a token that has an index of one. When you transfer that token from example, coven to our testnet, that token of id, one will be locked on the Ethereum side and a new token will be minted with the same id on the Moomin side. And if you want to transfer it back, then this token will be burned or locked and then it will be unlocked on the. So, yeah, well, yeah. Patrick, thank you so much for the questions. It was really interesting. I know that you got to run, I think.
00:58:26.798 - 00:58:30.094, Speaker B: Yeah, Keenan, I think we're there. Right with the time.
00:58:30.212 - 00:58:34.910, Speaker A: Yeah, I think we're there. Alberto, fantastic presentation. Really, really appreciate your time.
00:58:35.060 - 00:58:47.410, Speaker B: Thanks a lot. And make sure people to reach out to us in discord and hit us with any questions you might have. Check our documentation site. Thank you a lot for the invitation. And yeah, super happy to be here. Really. Yeah.
00:58:47.480 - 00:59:10.758, Speaker A: This is really exciting stuff that you're working on and really want to thank Katie and Catherine for helping organize this as well. And again, excellent job. And if you have questions, I'll make sure to drop all the links that we spoke about. I know there's a lot of them in the description afterward. The final video should be up in a few hours this afternoon, but definitely join the Moonbeam discord and their telegram and all their channels and ask your questions in there.
00:59:10.924 - 00:59:11.526, Speaker C: Yeah. All right.
00:59:11.548 - 00:59:12.758, Speaker B: Thanks a lot for having me.
00:59:12.844 - 00:59:20.940, Speaker A: Thanks everyone. Cool.
