00:00:16.830 - 00:01:10.680, Speaker A: So great, we've gone ahead and reset the array. But how do we actually now withdraw funds from this contract? How do we send the funds back to whomever is calling this now to actually send ether or send native blockchain currency? There are actually three different ways to do this. We're going to look at all three and say what the differences between the three of them are. The three different ways are going to be transfer, send and call. Let's go ahead and start with transfer, since transfer is the simplest and at surface level makes the most sense to use. So if we want to transfer the funds to whomever is calling this withdraw function, we would do, we would say message sender transfer. And then we'd get the balance of our contract here by saying address.
00:01:10.680 - 00:01:59.422, Speaker A: This keyword refers to this whole contract balance. And we can get the native blockchain currency or the Ethereum currency balance of this address like this. And we can just do that. Only thing that we need to do is we need to typecast message sender from an address type to a payable address type. So message sender is of type address, whereas payable message sender is of type payable address. And in solidity, in order to send the native blockchain token like Ethereum, you can only work with payable addresses to do that. So we just wrap it in this payable typecaster.
00:01:59.422 - 00:02:43.678, Speaker A: So this is the first way that we actually send Ethereum or send tokens from different contracts to each other. We wrap the address that we want to send it in. In this payable keyword, we dot transfer and then we say exactly how much we want to transfer. But there are some issues with transfer. Here we are on solidity by example for sending ether, which again is a fantastic resource to refer to if you get lost. The method that we just looked at was this transfer method. Now, we saw way earlier in the course that if I sent Ethereum from one address to another, it cost about 2100 gas or 2100 gas.
00:02:43.678 - 00:03:38.710, Speaker A: Our transfer function is capped at 2300 gas and if more gas is used, it throws an error. The next one that we're using is going to be send, which is also capped at 2300 gas. And if it fails, it'll return a boolean. So with transfer, if this line fails, it'll error and revert the transaction. With Send, it won't error, it'll return a boolean of whether or not it was successful. So using Send, we'll do payable message sender send address this balance, but we don't want to finish our call here, if this were to fail, the contract wouldn't revert the transaction and we just wouldn't get our money sent. So we want to do boolean send success equals this whole bit here.
00:03:38.710 - 00:04:11.626, Speaker A: And then we want to require send success. And if this send fails, we'll throw an error saying send failed. This way, if this fails, we will still revert by adding our require statement here. Transfer automatically reverts if the transfer fails. Send will only revert the transaction if we add this require statement here. So great. What's the third way that we can actually send Ethereum or native currency? Well, it's with this call command.
00:04:11.626 - 00:05:03.150, Speaker A: Now, call is going to be one of the first lower level commands that we actually use in our solidity code because this call function is actually incredibly powerful and we can use it to call virtually any function in all of Ethereum without even having to have the ABi. We'll learn the advanced ways to use this call much later. For now, we're just going to learn how to use it to send Ethereum or your native blockchain currency. Call is going to look very similar to send. We're going to do payable message sender call, and this is where we'll put any function information or any information about the function we want to call on some other contract. We actually don't want to call a function, so we're going to leave this blank. We can show that we're leaving it blank by just putting in these two quotes here.
00:05:03.150 - 00:06:01.730, Speaker A: We instead want to use this like a transaction. And as we saw in our deployment, there's always this message value bit. So we're going to use this call function as if it's a regular transaction and we can add stuff like message value. So in here we're going to add these squiggly brackets and we're going to say value, address this balance. This call function returns actually two variables. And when a function returns two variables, we can show that by placing them into parentheses on the left hand side, the two variables it returns are going to be a boolean that we're going to call call success, and also a bytes object called data returned. Since call allows us to actually call different functions, if that function returns some data or returns a value, we're going to save that.
00:06:01.730 - 00:07:04.518, Speaker A: In the data returned variable it also returns call success, where if the function was successfully called, this will be true, if not, this will be false. And since bytes objects are arrays, data returns needs to be in memory. Now, for our code here, we're actually not calling a function so we don't really care about data returned, so similar to what we saw with the price contract, we can just go ahead and delete that and leave the comma to tell solidity. Yeah, we know this function returns two variables, but we only care about one. And then, similar to the send piece above, we're going to do require call success call failed, meaning that we're requiring call success as true, otherwise we'll revert with an error that says call failed. Now, if learning the difference between these three is a little complicated for you right now, don't let that slow you down. Feel free to come back to this after you've learned more about how some of these lower level functions work, and a little bit more about how gas works.
00:07:04.518 - 00:07:58.180, Speaker A: Solidity by example does a fantastic job, though, of saying what the differences between all three are. Transfer has a maximum of 2300 gas and throws an error if it fails. Send has a maximum of 2300 gas, returns a boolean if it fails, call forwards all gas so doesn't have a capped gas, and similar to send returns a boolean if it is successful or if it fails. As of recording. Right now, using call is the recommended way to actually send and receive ethereum or your blockchain native token for now. If this part's a little bit confusing for you, for now, just look at this and see ah, that's how we send and transfer ethereum or native blockchain currency tokens. And I'm going to delete this part for the video, but I'll keep those comments in the code repository associated with this course.
00:07:58.180 - 00:08:00.980, Speaker A: You.
