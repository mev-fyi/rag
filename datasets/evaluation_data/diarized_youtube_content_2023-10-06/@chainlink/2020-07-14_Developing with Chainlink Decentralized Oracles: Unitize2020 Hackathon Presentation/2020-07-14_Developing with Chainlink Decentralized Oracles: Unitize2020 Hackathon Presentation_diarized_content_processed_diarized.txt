00:00:00.890 - 00:00:51.594, Speaker A: What's going on? Unitize hackathon engineers and blockchain enthusiasts. At this exact point in time, we have an extraordinary opportunity in front of us. The world of smart contracts is knocking at our doorstep, and history will show who will be the pioneers to push us into the fourth industrial revolution. But that's not going to happen unless we get to interact with the outside world and connect these smart contracts to obtain data APIs and traditional payments. So let's get right into it. Let's talk about Chainlink, the problem that it solves, how it solves it, where Chainlink is already now, some of the untapped potential that it has, and the tools you can use now to become a part of history. So in order to understand Chainlink, we must first understand that smart contracts are not able to regularly connect to external data or any off chain resource on their own.
00:00:51.594 - 00:01:48.702, Speaker A: This is a big limiting factor for smart contract adoption, because it means the only thing that we can currently do in a smart contract is token transfers. So you might be asking, why can't I just make a regular API call? That's what I do in every other language, and this is really important. And the simple answer is that the blockchain is deterministic and it needs to be validated by all blockchain nodes of the chain. If making API calls is part of the validation, then each node would get wildly different results in the case of an API being updated, depreciated, or even hacked. So to interact with the outside world, we need to call what's called an oracle. Any device that interacts with the off chain world to provide data to smart contracts, they report the result of that data on chain so that the blockchain can stay deterministic. This is a crucial, crucial piece of the blockchain, and this is also where Chainlink comes in.
00:01:48.702 - 00:02:38.714, Speaker A: It's connecting with this off chain data and storing it on chain. There are thousands of APIs out there that are already providing high quality data that people need for their applications. We make it easy to enable connectivity between those APIs and smart contracts, even if they require authentication, so that you can have a decentralized application powered by the same reliable APIs that the rest of the world and current applications use today. A single chainlink oracle is called a chainlink node, and I'll be using them a little bit interchangeably moving forward. Now, a lot of users today still don't understand the blockchain, and sending payments to cryptocurrencies isn't quite universally accepted. Yet when a smart contract is executed, people need the ability to get paid in a currency that they want. Chainlink makes it easy for off chain payments to take place based on on chain interactions.
00:02:38.714 - 00:03:24.334, Speaker A: This also works for cross chain communication and sending payments to other chains. Chainlink uses something called external adapters, and we'll talk more about that later. To enable connectivity to any resource, be it an open API, an API that requires authentication, payments API, or another blockchain. It works essentially as a wrapper around an API so that you can make these upgrades to provide authentication, processing, or anything to reduce on chain gas costs and privacy. External adapters can be written in any language you want, and they only need to react to specific requests sent to a chainlink node. Because of this, it's very easy to introduce new functionality to chainlink without needing to know anything about solidity or even ethereum. Now here's where we turn up the heat a little bit.
00:03:24.334 - 00:04:23.630, Speaker A: A centralized oracle service or a centralized oracle or a centralized node becomes a single point of failure for the entire smart contract. This is why we create decentralized oracles. Saying that chainlink node by itself is decentralized is kind of like calling a tree a forest. One single entity does not make up the whole to make applications that are truly never needed to rely on one entity, be it a company, a landlord or government, or anything of the sort, you need a network of chainlink nodes. Why am I stressing this point? Well, we've already seen attacks that have lost projects literally millions of dollars since their centralized oracle was hijacked. So Chainlink is designed to be a modular infrastructure and can build a decentralized oracle network used to connect smart contracts to any API. You can select as many oracle nodes, or Chainlink nodes as we call them, as you like, and use as many data sources as you like in order to trigger the execution of your smart contracts.
00:04:23.630 - 00:05:22.430, Speaker A: Then again, Chainlink also enables off chain payments based off of these decentralized oracles for the execution of the smart contract. So if the result of a smart contract said that someone should get paid $100 USD, you can utilize Chainlink to send that transaction. To get you started with DFI or decentralized finance, the Chainlink project has gone ahead and found many of the best blockchain node operators on the planet and combined their prowess to build what's called reference data contracts, or price reference contracts or reference contracts. These are decentralized on chain reference points that can be considered source of truth for various currency pairs like the price of ETH in terms of USD. For example, each node in the network independently gets data from some of the highest quality data APIs and reports their answers. On chain. You can see the answers that each provider reports so that everything is transparent.
00:05:22.430 - 00:06:25.682, Speaker A: Many of the most popular cryptocurrency or fiat currency pairs are currently supported, and the best part is, if you don't like it, you can always create your own network anyways. Currently, these reference contracts are already being used by a slew of some of the top DeFi projects in the world. The proven safety, reliability and powerfulness of these applications is a testament to the power and security that Chainlink has and to reference contracts. Here are some of the projects that are currently using Chainlink in the DeFi space we have synthetics, loopring, set, protocol, AAvE, and these all have acquired large amounts of secured dollars for their projects. Some other places that are starting to get some traction but aren't quite there yet is the gaming realm. Until now. And here's a big reason why getting random numbers on chain has been an issue since the current conventional way to get a random number, you have to rely on the eth miners for a random hash or a centralized API like random.org
00:06:25.682 - 00:07:11.814, Speaker A: that can be hacked, hijacked, or even changed. Chainlink has a decentralized, provably random system, and the surface is barely even scratched. We saw one project implement the Chainlink VRF, our last hackathon and one product push the gaming potential into the limelight with their no loss betting application. So this is one of the areas of blockchain that I want to emphasize because there is a huge opportunity here. The Defi project pool together has also implemented the Chainlink VRF, allowing their no loss audited savings game to be truly unpredictable, which is crucial for the project. They currently have about three quarters of a million dollars worth of DAi, and they're constantly growing. This brings me to our next point.
00:07:11.814 - 00:07:51.646, Speaker A: We have a blog that gives a list of ideas to power your smart contracts. So if you're coming into this hackathon and you have no idea what to do, I definitely recommend you check that out. The blockchain space is literally thirsting for chain linked secured, decentralized applications. Let me rapid fire some of my favorite ideas off. So first off, d five, as we mentioned before, is constantly one of the major areas of pushing for project and has a ton of momentum and knowledgeable people working in the field. Chainlink supports already some of the top projects in DFI. At the moment, there's over $1 billion in assets in decentralized finance, which is a huge accomplishment and major milestone.
00:07:51.646 - 00:08:12.090, Speaker A: And you may think, wow, a billion dollars. That's a lot. But then you have to compare it a little bit. It's not even 0.1% of the traditional finance space. The math is too hard for me to calculate how small it is. The average hedge fund has over a billion dollars.
00:08:12.090 - 00:08:58.520, Speaker A: There are over 700 hedge funds that have singular hedge funds that have over a billion dollars and about $3.2 trillion in asset managers in general. And we're not even talking about how much money banks high net worth individuals or other financial instruments are. Securing Chandler makes integrating with financial instruments really easy with reference data contracts. Now, this may seem like an insurmountable feat to reach these heights, to reach what the traditional finance world currently has, but I promise you, it's here. It's here, and it's right now, and it's knocking at the door. The window of opportunity, though, won't last forever, but we're here to make sure we can build some amazing tools and have fun doing it.
00:08:58.520 - 00:09:19.534, Speaker A: Boom. Next one. Fantasy sports. Fantasy sports players pay on average $100 per league on a decentralized application on blockchain. You can cut that down by a fraction of a fraction without having to trust that the scores are being updated unfairly. Or the ods being skewed. Texas hold them, or any card board game.
00:09:19.534 - 00:10:00.182, Speaker A: Chainlink VRFs make this possible with giving access to truly random numbers while still being way cheaper than a buy in at a major Texas hold Em tournament. Tokenized assets. You can split up your car, plots of land, shares of stock, making it easy to keep track of who owns what without having to deal with paperwork. And since your data is coming from decentralized oracles, nobody can mess it up. Insurance. This one really hits home for me. Let's say you're a farmer and your crops are all ruined from two seasons where the weather was terrible and your insurance, being a centralized entity, has decided that they're not going to pay out because some preexisting condition.
00:10:00.182 - 00:10:45.254, Speaker A: Now you can go to court and you can fight it, and you could win, which would be great. You would still have to go through all this time and effort fighting the insurance company through court. Or worst case scenario, you go through all that pain and you still lose. With a decentralized smart contract, you don't have to trust that insurance company is going to do the right thing. Since the right thing is infrastructural with Chainlink by this time, you should understand what the power that Chainlink has when it involved with smart contract. So let's dive right into what exactly this looks like at an engineering level. We're going to be going over the reference data contract first because it is the easiest implementation of Chainlink while also being one of the most powerful.
00:10:45.254 - 00:11:42.614, Speaker A: If you're using a defi technology like uniswap compound or any defi technology, a quick check on their oracles with a Chainlink price reference feed called a chainlink anchor can save you heartache, bug fixing panics and possibly millions of dollars down the road. Let's see what that looks like now. So if you're looking to use reference data contracts or price reference data, the first thing you want to do is just come right to the docs. Docs have all the information that you're looking for, talking to you about how it works, the aggregator interface and everything. Now something important to note is that the syntax for all these is for truffle and for node js. We'll get to that in a little bit. For now we're going to be using remix, which is an ethereum ide and it's really really powerful for just spinning things up quickly on a testnet and seeing exactly what it's going to look like when you actually deploy the main name and interacting with it really efficiently.
00:11:42.614 - 00:12:19.366, Speaker A: So we'll go over the truffle in a little bit. But basically what we're going to want to do is come here. You can read everything that you didn't know and we have a complete example at the bottom, which is great. We have this little copy paste button right here and you just copy it, come over to your remix id, hit this little plus tab, make a new file and paste it into here. So I cut it down a little bit to make it simpler. And all these functions that we have here are to interact with the reference contract easier. So we have get latest timestamp to see where we are.
00:12:19.366 - 00:13:03.000, Speaker A: You can see the previous answers, you can go back as far as you want and get the previous timestamp as well. I cut it down to be just get the latest price and if that's all you want. This is literally how small your contract can be. So the other important thing when dealing with remix, it doesn't work with that nice node JS syntax that we saw. So we're actually importing directly from GitHub. Be sure to look at our boilerplates to make sure that you have the right link and we'll have a link to that as well. But yeah, we're going to start with solidity version six, we're going to import from GitHub, we're going to start our contract, which again, if you're new to solidity, this is kind of similar to starting a class.
00:13:03.000 - 00:13:53.266, Speaker A: We have our aggregate interface internal ref, which is kind of like a global variable. We have our constructor, which is the same as any other language. Once this gets deployed on a testnet, this is what gets called. And we have this get latest price which literally calls, literally calls from this reference feed. And we can see a full list of reference data contracts for pretty much any pair that you can think of. Be sure to note that they start or that the address are different on Mainnet and the different testnets. So ETh USD will have a different address for Robson than it will for Mainnet.
00:13:53.266 - 00:14:37.606, Speaker A: Be sure to test on testnet before you go right into Mainnet. And again, if you want to see what these feeds look like, you can come to the feeds chain link page and you can see, okay, well what are the nodes looking like, who's returning what answer? And you come to here and you can literally see the visualization and all the data around here are the node operators that were returning data. And here's the aggregated the consensus of the answer in the middle here, which is really cool. So going back to remix super simple code, it's literally this small. We have it in here. Great. We're going to choose, our version is going to be solidity that brings this file up here.
00:14:37.606 - 00:14:58.940, Speaker A: We're going to choose our file, which I called referencedata Sol. For solidity files, you need to do Sol. We're going to compile, it's going to compile everything. Great, looks like it compiled successfully. Let's go ahead and deploy. We're going to want to go to injected web three here. It's going to ask for our permission for Metamask to connect.
00:14:58.940 - 00:15:28.646, Speaker A: So if you're unsure how metamask works, be sure to follow our other tutorials in the docs and follow our videos as well that show you how to install Metamask. So you can work with this really easily. You can also learn how to get test ETH and test link so that you don't have to pay any money when deploying these test contracts and playing around with them. Great, so we have brave giving me money. Yes. Great. So we're going to do injected web three, which is literally taking our web provider, sticking it in our browser here.
00:15:28.646 - 00:16:06.926, Speaker A: And this deploy button right here is what's going to deploy the contract and the address that we're looking for is going to be here. This is the address of that reference contract that we were talking about. And again, we can get that list for full list of reference contracts. We can get that from here again, which just has everything and you literally just copy and paste that into right here and it'll be whatever feed you want. So we've copied from ETh USD, not this one. We've copied from this one right here on the Robston because we're on the Robston testnet right now. Place it in here.
00:16:06.926 - 00:16:38.342, Speaker A: We're going to deploy the contract. Metamask is going to pop up, say are you sure about that? And we are going to say, yes, we are definitely sure about that. It's going to give us a link and it's the same as deploying pretty much any contract. You wait a couple of minutes, you wait a couple seconds. Once it gets deployed, we're good to go. And you'll see it actually pop up in the bottom left of your remix screen. And you can click that and it'll show all of our functions and how we can actually interact with this contract.
00:16:38.342 - 00:17:07.990, Speaker A: Since we only have one function, this get latest price and it's a view function, which means it's not actually changing any state. We're not actually going to be sending receiving any link. We're literally just reading from the blockchain. We don't have to pay anything. So we can just call it and Metamask will not pop up and it will give us the response of the price reference contract, which is $255.81, which is great. And as you can see, it looks like it's a lot more.
00:17:07.990 - 00:17:47.226, Speaker A: That's because it's been multiplied because blockchain doesn't work with decimals very well. But that's it. It's that simple. Now you can take this and do some simple stuff like if anchor is less than 10% of oracle, this is some pseudocode here, then don't run. Smart contract. Literally that simple. And the rest of the integrations are literally that easy too.
00:17:47.226 - 00:18:18.886, Speaker A: So the next step I would say would to be do this request and receive data tutorial. We have a video coming out on it as well as the docs are really thorough. I highly recommend doing it in remix first so that you really go in depth and figuring out how it works on a testnet contract. We have video on our chainlink YouTube. You guys should definitely check it out. That goes really in depth at it, but we're going to skip that one for now. We're going to go to setting up a chain linked project using truffle and using node js.
00:18:18.886 - 00:19:03.914, Speaker A: This is a really powerful tool because we can actually test our smart contracts and we can deploy from an IDE or a text editor that we prefer, like visual studio code or vs code or whatever you want. And so this is going to be the same as that request and receive data tutorial, except with Node JS. Hey engineers. Now we're going to learn how to build really powerful front end applications integrated with Chainlink smart contracts. There's a fantastic technology out there called Truffle and it makes it really easy just to get everything in a node JS application and for you to start coding as you would a regular node JS application. So we're going to just dive right into it right now. So it's pretty simple.
00:19:03.914 - 00:19:22.254, Speaker A: Come to the documentation page here and we're literally just going to copy paste stuff. So first we're going to install truffle. We're going to install it globally. NPM install truffle. Make sure that you have the most updated version of NPM, otherwise you might get issues. So great. And then same thing.
00:19:22.254 - 00:19:50.422, Speaker A: Now we're just going to copy this, hit the little button. What it's going to do is going to make a new directory for us. We're going to CD into it and we're going to unbox this smart contract kit. So this is basically an SDK, a software development kit that has a whole bunch of boilerplate stuff for us to go ahead and start developing. So let's go ahead and do that. And this may take a few minutes to actually download. Great.
00:19:50.422 - 00:20:20.740, Speaker A: And then once it's actually done downloading, the box is done. We're going to see over here, we're going to have a new project that's going to have a ton of stuff going on in here. So just to kind of give you the rundown contracts, this is where all your smart contracts are going to be. This is the same thing as remix. Or you can kind of ignore this error for now. This is basically what it would look like in remix. Obviously there's a lot more notes here for you guys, so you can read and kind of figuring what it's doing out.
00:20:20.740 - 00:21:09.630, Speaker A: This contract that we're doing is going to be the request and receive data tutorial in the chainlink doc. So if you haven't checked that out, be sure to do that. We also have a YouTube video coming out that's doing it in remix. So it'll be the same thing as that video just now in node JS, which is really exciting. So this is where all your smart contracts, live migrations, you don't really need to worry about, but it's going to help us put our code on chain. Node modules is obviously node modules for node JS scripts. These are some quick scripts basically to help us fund contracts and read and request data from contracts so that we don't have to be interacting on, remix or interacting with the contracts more directly.
00:21:09.630 - 00:22:21.322, Speaker A: And then test is one of the most powerful features of this is this right here. We can build these tests to make sure that all of our code does what we want it to do in relation to our smart contract. So this is a really important piece and if we jump in here we can kind of see what it's doing. It's setting up an ethereum chain saying hey, these are going to be the accounts that we're going to be playing with. And before every test which we can see down here and describe before every test we're going to set the link token, we're going to set an oracle and we're going to set my contract, which is this contract here. We're going to set my contract and we're going to start running the test, right. So for example, this first test we are going to describe or say hey, we're going to create a request without link and we're going to literally create a request without link and we're going to hope that it errors out when it doesn't have link and it is successful when it does.
00:22:21.322 - 00:23:00.194, Speaker A: And we can run these tests. Actually right now we don't need to be connected to anything. We can just do NPM test and it's going to run this NPX truffle test. And this truffle command is kind of the magic command that is setting all this up is interacting with the ethereum chain so that we can do all this, which is really exciting and powerful. But yeah, while that's running, the rest of this is kind of more node js stuff. This piece is pretty important when we're doing migrations. And by migrations I mean deployments.
00:23:00.194 - 00:23:26.846, Speaker A: Anytime we do a deployment, if we say we're going to do a live deployment, we're going to place those contracts on a live net. So either main net or testnet, depending on your RPC URL, will determine that. What's an RPC URL? It's basically what connects you to an ethereum client. So it could be a main net one. Oh great. All of our test passes a main net one. A testnet one.
00:23:26.846 - 00:24:07.478, Speaker A: It really depends. And you can find some of those either at fuse's free one. Right. So if you use this as your RPC URL, obviously it'll be connected to Robson. I'm actually going to use infura, but just so that you guys can see what it would look like, it's going to be an environmental variable. So you would do this export syntax, export RPC URL and then you're going to equals blah, blah, blah, blah, right. And so this export command only makes this environment variable live for this terminal.
00:24:07.478 - 00:24:41.510, Speaker A: So if you delete your terminal, it'll delete it. If you want to make a Env file and put this export RPC piece in there, you absolutely can do that. But I would caution because I wouldn't want you to send it to your git repo and have everybody see your RPC URL. And the more important bit is actually this bit over here, process env mnemonic. So this is the twelve word seed phrase that you get when you set up your metamask account. If you haven't watched that video yet, definitely watch the video. So you can get that set up in metamask.
00:24:41.510 - 00:25:24.702, Speaker A: I'm not going to show you guys, but you can actually go in here, go to like, I think it's settings. It's one of these buttons. Oh, settings. If you go to settings, you're going to reveal your seed phrase and that's going to be the mnemonic device that you're going to save. So you're also going to want to export that. So you're going to do export mnemonic equals and you're going to want to put the quotes here and it's going to be like dog, cat, mouse, frog, blah, blah, whatever twelve words are. So those are the two really important pieces and they're super important because like I said, the RPC URL is what's going to connect you to an ethereum client.
00:25:24.702 - 00:25:53.760, Speaker A: So actually be able to deploy contracts on chain, whether it's a testnet or mainnet. Obviously, if you want to do testing here, you're going to want to set it to be a testnet RPC URL. And the mnemonic device is what it's going to actually allow to interact with that wallet. With that eth wallet. So that's why it's really important to get metamask set up. So you have this eth wallet that you can interact with and that's where it'll pull gas costs from and link from and everything. So definitely watch that video.
00:25:53.760 - 00:26:43.214, Speaker A: And this here, if you want to do some local testing you can set this up so that you can do migrate dev and do like a dev environment. But we're not going to focus on that for this tutorial. Great. So we're actually going to just run right into it. And we do have to edit one thing because there is a bit of a, right now there's a bit of a glitch with the truffle box. So we just have to change this truffle HD wallet provider to next metamask updated their software recently and it caused some stuff to break. So we're just going to come in here, hit next and then run NPM install.
00:26:43.214 - 00:27:24.314, Speaker A: Depending on when you watch this video, that bug might be gone, but for now this is what we're going to do and. Great, cool. So like I said, this truffle box does a lot of different things. So we want to focus on just figuring out how do we deploy a contract, how do we mess with the contract, how do we do tests? And that's pretty much it. So I just showed you how to run the tests. If you want to write more tests, you come in here and you can add more context, add more stuff to do more interactive with contracts depending on what your contract actually does. Obviously this is my contract underscore test.
00:27:24.314 - 00:28:13.302, Speaker A: So if you want to build more smart contracts or more contracts, you're going to want to build tests for each one of those as well. You can use this as the rubric. But yeah, now what we want to do is we want to actually deploy this contract to the Robson testnet. Like I said, I was using export rpc URL equals I'm using HTTPs URL. So this is going to deploy to a Robson testnet, which is really awesome that we can do it right from vs code. That's the editor that I'm using by the way, if that wasn't apparent and it's with a simple command NPM run migrate live. Now again, this live is an important keyword.
00:28:13.302 - 00:28:44.446, Speaker A: You can also do dev and that will connect to whatever you have in here. So we're going to do live though. We're going to say, hey, we want to connect to our Robston testnet based off the RPC URL that we gave. So we run this, we're going to take a minute or so and we're actually going to deploy nothing because there was an oh. And if you run into an error like this, don't worry about it. It could just be an issue with whatever RPC URL are doing or whatever. It's a testnet.
00:28:44.446 - 00:29:19.946, Speaker A: It's not perfect, but yeah, we're just going to run it again and it looks like it's working this time. So that's perfect. We're doing this migration, like I said, the migration, you can think of it as the same as deploying. And the contract that I really care about is the mycontract sole because this is the interesting one. If you haven't checked out the request and receive data video, definitely check it out, definitely read the docs, see what we're doing. But basically we're picking a chain. So what the smart contract does is it creates a request to a certain chain link, oracle.
00:29:19.946 - 00:30:11.886, Speaker A: So a single node, single job id gives it some link pay and it requests an arbitrary URL and gets the data from that URL, which is obviously really exciting because any API in the world has a URL that we can connect to and this is how we do it. This is kind of the code that does it all withdraw link in the whole nine yards. So we have a lot of the basic functionality here. So as it's saving this migration to the chain and this is some interesting as well. The reason that this is an important piece is this is kind of defining how we're deploying the contract. So we're saying hey, if it's live, here's what we're going to do to actually deploy it and make sure it goes smoothly. So that's basically what's going on.
00:30:11.886 - 00:30:49.820, Speaker A: So now we're actually deploying my contract. We have the transaction hash, we have three blocks, we have the contract address which we want to save for. I'm actually just going to put it there for a reason. I will tell you in a minute. And then we have some other stats that are really cool. Great. So now we have, it's actually deployed and oh so important thing is again make sure that your wallet has testnet eth in it and testnet link, otherwise you're not going to be able to deploy anything.
00:30:49.820 - 00:31:27.782, Speaker A: So we can actually go to Etherscan Robson, testnet Robson and we can see this contract here just to double check. Great. It was created 1 minute ago by us, which is really cool that we can deploy contracts right from our vs code right from our node JS application. Great. So we've deployed it. Now we have some scripts that can help us interact with this fund. Contracts right now is not working super well because of that buggy that I was telling you about.
00:31:27.782 - 00:32:15.350, Speaker A: So we're just going to fund it the manual way here, which is fine. This is really quick anyway, so we're going to send it to link. Why not send it fast? And again, just in case you didn't know, there's the ETH gas that you need to do any transaction on the Ethereum chain. There's also the chain link gas that you need to interact with oracles. This is that oracle gas that we're going to be using. The chainlink token is that chain link gas. So once this finishes sending, our contract will actually be funded and we can go ahead and start trying to request data out of it, which again go check out the longer video on how it works.
00:32:15.350 - 00:32:33.966, Speaker A: It does it in remix. I'm going to skip over exactly what's going on in this. We're just going to deploy it and go. We already deployed it, we're just going to go there. So great. So now we're going to do this request data script which has pretty much all the parameters that we want in it. So we're choosing an oracle address.
00:32:33.966 - 00:33:20.942, Speaker A: You can choose any oracle address that you want that returns this type of data. We're actually returning a, what are we returning? We can see it on our contracts. It's going to be a fulfill, it's going to be a Uint 256. So we just need to find an oracle that has a job that can get an arbitrary API, returns a U 256. Obviously we can go to market link again, find an oracle like this. Yes, we have the oracle there, we have the job id here, right? We have the payment here, which at the moment is just one link on Mainnet. It would be much less.
00:33:20.942 - 00:34:53.046, Speaker A: And we have our arbitrary API, we can make this anything we want and then we're just going to make this request. So we're going to go ahead and run the script to do this and it's just going to be NPX truffle truffle exec scripts, request data. Once the funding one works, it'll just be like Fundcontrix js with the same rest of the syntax here. But we're going to do request data JX js and then network is going to be live again live connected to our testnet. So this is going to do the same thing as we saw in remix of us clicking that button like request price or create request two in this case, since our contract has this function create request two, which if you watch the other video, like I said, it's request eth price in that other video. So we're creating the request on this contract, which is perfect because that's the contract that we just deployed and we funded it. So we can actually watch on Etherscan.
00:34:53.046 - 00:35:34.716, Speaker A: The transaction just came in and it's pending. And once it completes, we're going to see that show up back here. Perfect. And that's the hash right there of the completed transaction. And we can see, great, it looks like it's completed here. That's fantastic. So now, because we've requested this data, now we have this stored data on chain.
00:35:34.716 - 00:36:18.168, Speaker A: And again, if we look at the scripts here for requesting data, we can see that the URL is for the price of ETH and USD. So we want to read right off the contract. And luckily we have another script that does this. MPX truffle exec scripts read contract network network live. And again, you can edit these as you like right in here. This read contract we have, we got an error here up. Same error.
00:36:18.168 - 00:36:57.064, Speaker A: We can just rerun off of that. But yeah, if you have different contracts or you deploy different contracts, you're going to want to come in here and adjust these, right? So this is saying, hey, we're going to create a new variable called mc, stands for my contract and we're going to do data call. So if we look in my contract, we have a variable right at the top called data. So we're just calling that, and that's what this read contract is doing. It's calling the contract, it's saying, hey, let's call that data right there. Request data, obviously is a little bit more involved. Cool.
00:36:57.064 - 00:37:29.830, Speaker A: So if we look down here, boom, we have the answer right there. So $228.13 again, the blockchain doesn't do great with decimals, so all the decimals are obviously removed. We have in our contract, we define times not in our contract, in our request data times to be 100. So we move the decimal place over twice. And that's why we can see this right here. And that's it, guys, it's really that simple.
00:37:29.830 - 00:38:09.008, Speaker A: I hope that this was helpful for you. Like I said, some of the most powerful, awesome reasons that truffle helps out here is you can integrate this with a full scale front end, back end web application. Since node Js, you can run some of these tests so that you can actually run tests on your smart contracts both locally and on a live testnet, and you can configure it to be part of a custom testnet as well. And it's just really powerful in that sense and super customizable. Well, that's it. See you guys next time. So that is it, guys, there is a lot to unpack there.
00:38:09.008 - 00:38:38.904, Speaker A: There's a lot to uncover, there's a lot to do. There's a lot of really exciting opportunities. Chainlink is an open source project that's always improving. There's some really cool stuff coming up soon, like threshold signatures, which will help reduce costs and improve the security of the system in general. But to kind of get to there, you still need to figure out how everything works. So getting started now is fantastic. And you'll be miles ahead of the curve here.
00:38:38.904 - 00:39:00.620, Speaker A: So we have tons of resources out here to help you out. I'm always around. You can ping me in discord, you can ping me on Twitter, on LinkedIn, slack, whatever. We have a number of out of the box examples as well as examples from previous winning hackathons. We have this. Let me get out of the way here. We have these winning hackathon resources.
00:39:00.620 - 00:39:31.812, Speaker A: I'll just leave it in the description. We have hackathon resources for you to check out, all the docs, tutorials, everything you guys need. Definitely jump in the discord chat. The community is some of the happiest and most helpful people and they just all want to build really cool stuff. And we're all in there time in there and definitely check out the documentation because that's going to be the best place to start. So that's pretty much it. And what are you waiting for? Go start building some chain link projects.
00:39:31.812 - 00:39:32.230, Speaker A: See ya.
