00:00:12.810 - 00:00:23.390, Speaker A: Hey, what is up, everyone? We should now be lived.
00:00:27.530 - 00:00:28.278, Speaker B: It.
00:00:28.444 - 00:00:30.120, Speaker A: Can everyone hear me okay.
00:00:35.690 - 00:00:36.246, Speaker B: It.
00:00:36.348 - 00:01:34.830, Speaker A: Hey, how's it going? Welcome. We'll give people a couple of minutes to join the stream and then we'll get started. How's everyone doing today? Let's get some GMs in the chat. Awesome. I'm excited to give this talk. Hope everyone's having a great and productive chain link hackathon. Really excited to see what everyone builds.
00:01:34.830 - 00:02:31.350, Speaker A: All right, we'll give it one more minute, everyone, and then we're going to get started. Yes, it is a great day to learn chain link. Do we start directly from rust? There is going to be some rust involved here today. However, if you're not too familiar with it, don't fret too much. You'll still be able to follow along. It's just a matter of the syntax, but I'll be kind of explaining everything as best I can. Cool.
00:02:31.350 - 00:02:46.166, Speaker A: All right, I think we might get started. Welcome, everyone. I hope everyone's having an amazing chain link 2022 spring hackathon. Today we are going to be talking about all things anchor Solana and using Chainlink on Solana.
00:02:46.278 - 00:02:46.650, Speaker B: Right?
00:02:46.720 - 00:03:35.910, Speaker A: So I'm just going to share my screen here. Hopefully, you guys can see that might switch my view. There we go. So, my name is Harry Papacrusu, and I'm a developer advocate for Chainlink Labs. And today, like I said, we're going to be talking about building on Solana, how to use anchor on Solana, how to use Chainlink on Solana. So first we're going to go through just a quick introduction of what Solana is and the architecture and programming model, because it's quite different from other chains such as Ethereum. Then we're going to give you an introduction into what anchor is and how it increases your productivity.
00:03:35.910 - 00:04:10.498, Speaker A: And then we're going to just do a quick demo workshop using anchor to create just a simple program and deploy it and get it working. And then we're going to do another demo with anchor and Solana that uses chain link price feeds in your Solana smart contract. And then we'll wrap things up by talking about where you can learn more. So let's go. Intro to Salana. So, Salana is an open source public blockchain, and the unit of account is a sol, or a fraction of a soul is a lamp port.
00:04:10.584 - 00:04:10.834, Speaker B: Right?
00:04:10.872 - 00:04:20.410, Speaker A: So there's about 1500 nodes, and there's a number of real enhancements under the hood to kind of achieve the higher TPS and bandwidth that it has.
00:04:20.480 - 00:04:20.906, Speaker B: Right?
00:04:21.008 - 00:05:03.590, Speaker A: So if you're interested in that kind of real low level stuff, I recommend checking out this article that I'll paste in the chat here. Now we'll move on. So Solana has multiple clusters. So they call a network a cluster, right? So their main net is called mainet beta. They have a devnet, which is like a test network for developers. They have a testnet, which is another non mainnet network that's mainly for infrastructure type things and deployments and testing things like that. And you can run a local cluster or a local Solana instance on your local machine, which we'll be doing today as well.
00:05:03.740 - 00:05:04.294, Speaker B: Right?
00:05:04.412 - 00:05:48.322, Speaker A: So Solana uses a byzantine fault tolerant proof of state consensus mechanism and this thing called proof of history to maintain its state. Now, the biggest thing I want to talk about before we go into anything else with Solana is the program and account model, right? So in the case of Ethereum and other chains, the smart contract also holds the state. It has the logic, which is the code that says, do this, do that. But then it also has the state that stores all the variables, the arrays and all those types of things in that same place. On Solana, it's different, right. A program is essentially just an on chain smart contract that is just code, right. It doesn't store anything, it just gets executed.
00:05:48.466 - 00:05:49.254, Speaker B: Right.
00:05:49.452 - 00:06:02.226, Speaker A: And it has a program ID, which is basically the address or public key address that the smart contract is deployed to, just like Ethereum. However, there is no state stored in that program.
00:06:02.348 - 00:06:03.018, Speaker B: Right.
00:06:03.184 - 00:06:07.980, Speaker A: So the way Solana works is data for programs is actually stored in these things called.
00:06:08.510 - 00:06:08.970, Speaker B: Right.
00:06:09.040 - 00:06:26.698, Speaker A: And an account is basically just like a buffer, but you can kind of think of it as like a file in an operating system. And so it just has a bunch of data just like a file, and has a bunch of metadata as well that know who can access the data and how, and it's held in validated memory.
00:06:26.794 - 00:06:27.102, Speaker B: Right.
00:06:27.156 - 00:07:09.834, Speaker A: So the biggest difference to note with Solana is you have programs, which is just the smart contract code, and then you have accounts that store the actual data for smart contracts. So in an ERC 20 example or a token example, in Ethereum, you have one contract that stores the token details as well as the balances of each person that holds the token all in that same contract. In Salana, you'd have a deployed program, which is like a token program that has the token information. It has all the functions to send tokens, mint tokens, et cetera. And then you'd have multiple counts for each person that holds the token.
00:07:09.962 - 00:07:10.446, Speaker B: Right.
00:07:10.548 - 00:07:52.878, Speaker A: Because once again, you do not have the logic stored together with the state in Solana. So here's basically what an account looks like on Solana. You've got a public key, which is like just the identifier for the account. You've got a bunch of metadata that says, is it a signer? Is it writable? Who owns this account? Is it an executable? Is it a smart contract, this account, or not? Because smart contracts are also accounts weekly enough. And most importantly, it's got a data section where it stores a byte array of data. So that's how data is stored. And it's got lamp ports, which says how much Solana is in that account.
00:07:52.964 - 00:07:53.214, Speaker B: Right.
00:07:53.252 - 00:08:28.102, Speaker A: And we'll get into that very soon. So in terms of how you interact with Solana, blockchain to call smart contract programs and things like that. Pardon me. You basically have to generate what are called instructions, right? So you can think of an instruction as like a function call, right? An instruction basically has three parts to it. It has a program ID, what program you're interacting with. It's got like an array of accounts that you send it to. Say, here are all the accounts that I want you to interact with with this program ID.
00:08:28.102 - 00:09:22.098, Speaker A: And it's got a byte array of instruction data, which is like input parameters, right? So if you have a function that takes in the price of ethereum or something, you need to send that in, in the instruction data section, right? So that's kind of the three things that an instruction is comprised of. And then a transaction is basically just a list of instructions, right? So you can have first do this function call, then do this, then do this, et cetera. So here's just a small example here where you have instruction one interacts with this program ID here. So we want to call this program ID here. We want to pass in these two accounts to basically have data modified or stored. And these are our input parameters for interacting with this program here. And then similarly for instruction two, it's the same thing, but slightly different data, or slightly different program ID.
00:09:22.098 - 00:09:57.342, Speaker A: Different accounts, different instruction data. And then we bundle those up into a transaction that contains both of them, right? So basically, this is very important that you understand this if you're going to be playing around and building on Solana, because this underpins the whole programming model, right? You have an on chain program that's just code, no logical state. And you build up these instructions off chain that you use to interact with the on chain programs. And you submit these instructions via adjacent RPC API to the Solano cluster, and then basically they get executed.
00:09:57.406 - 00:09:57.598, Speaker B: Right?
00:09:57.624 - 00:10:04.406, Speaker A: And you also pass in all the accounts to the program that you want to have data modified for.
00:10:04.508 - 00:10:05.160, Speaker B: Right?
00:10:06.010 - 00:10:50.280, Speaker A: And any instruction data you pass in in the instruction data by array, so very different. You can't just call a function and pass in a string or an input parameter, and then everything's in that function. Once again, it's very different. You say you have a program ID, which is just the logic the accounts get passed in. So that program ID knows where to basically modify data, and then it takes in input parameters in the form of that instruction data by array. So once again, the instruction data is just a byte array of an arbitrary size, and it's used for sending input data to onchain programs, right? So there's just an example of some instruction data. I think it's like a string of glass tube or something like that.
00:10:50.280 - 00:11:35.170, Speaker A: So let's talk about the flow of developing and interacting with programs just quickly again. So you compile the programs, you can build Solana programs in rust C or C. You compile them, they get deployed as bytecode to Solana. And then to interact with them, you have a JSON RPC API that's exposed. And then you build your clients, which could be a front end, a web app or whatever, and then they can submit via that JSON RPC API to basically call programs on Solana network. But yeah, just to reiterate, the program itself is stateless. It doesn't store anything.
00:11:35.170 - 00:12:34.838, Speaker A: So when we call programs, we need to pass in accounts to it to say, here, use this account for doing the first thing that you're going to do with accounts, then this account for the second and so on. So let's just talk quickly about rent now. So Solana is similar to Ethereum and other chains where basically validators get paid transaction fees and things like that. However, because we have these things called accounts that store data, we also have this thing called rent, because validators need to get paid to store this data as well, right? So basically storage rent basically covers the cost of storing data in accounts over time. And there's two methods that are used for it. There's this one called set and forget, and there's one called pay per buy it. So set and forget is basically where if you have two years worth of Sol in the account, you'd never have to pay rent again.
00:12:34.838 - 00:13:05.760, Speaker A: So you just have to prepay like a large amount. Otherwise, if you don't have two years worth, you can pay per byte. And in terms of how much is two years worth? It depends on how big is the account, how much data is in there. And there's also a set amount per kilobyte, which is set somewhere. I'll grab it from the Solana docs and paste it when we get to our first exercise. Generally, most people go with option one. They just put two years worth of rent in an account, and then that way they just don't ever have to pay rent again.
00:13:05.760 - 00:13:46.810, Speaker A: However, you have to be careful with that, because if you add more data to your account over time, you need to make sure that two years worth is still true, because the bigger the account is, the more that two years worth of rent is going to be. So you need to be careful about that too. Seeing a couple of questions in the chat. Can we select versions of solidity in Solana? Yeah, so you can't program with solidity in Solana. In Solana you can only use with native Solana anyway. You can only use Rust C or C. There are some projects that are dealing with trying to get EVM compatibility going with Solana.
00:13:46.810 - 00:14:19.480, Speaker A: However, I haven't played around with them. And are Solana programs immutable like Ethereum? Great question. Just to reiterate from earlier, the Solana programs do not store any data. They're just the logic, right? So in terms of the smart contract getting deployed and the logic, yes, it's immutable. That can never be changed. But there's no data in that smart contract, right? It's just the logic. All right, let's move on.
00:14:19.480 - 00:14:40.960, Speaker A: So just quick recap. On instructions that we send to the Solana network, you have a program ID, a list of accounts and instruction data that the client sends through as an instruction, right? However, if you need to send some input parameter to a Solana program.
00:14:42.690 - 00:14:43.066, Speaker B: Let'S.
00:14:43.098 - 00:15:38.386, Speaker A: Say it's a string. You can't just send it as a string like you do in Ethereum. You need to basically serialize it into a byte array, because once again, the instruction data that we send is in byte array form. So if you need to send the string Harry as an input parameter program, you basically need to turn it into a byte array, right? So that's what serialization is, converting an object in memory into a stream of bytes. And then when that byte array gets accepted in the Solana program via the program to basically do stuff with it, you then need to deserialize it. You need to turn it back into a string, right? So it's a bit finicky in Solana, in raw Solana anyway, where you need to basically serialize and deserialize this instruction data if you want to use it on chain. However, when we get to anchor soon will see that kind of stuff kind of gets abstracted away.
00:15:38.386 - 00:16:20.794, Speaker A: So just a quick visualization here. So examples of serializing and deserializing on to you'll be serializing instruction data sent from a client via the JSON RPC API onto a Solana program, where it's then deserialized and turned back into its original form. Or it could even be the other way around. You could be serializing account info data that's going to be stored in the accounts via the program as well. But enough about that. Let's start talking about anchor. So in the web two world you have things like rails, and in theorem world you have things like hard hat truffle and web three Js.
00:16:20.794 - 00:17:21.342, Speaker A: And basically these are all tools designed to increase your productivity, right? And they do that by abstracting away some of the more low level details of the underlying platform. So in Solana we have this thing called anchor that basically does that for you. So anchor is a framework built by Project Serum, which is a decentralized exchange and DeFi ecosystem built on Solana. And Anchor basically is a framework for quickly building secure Solana programs, right? And it basically does this by reducing coding efforts and by generating various boilerplate code for you. So I'm just going to paste a link to the anchor docs in the chat before I continue. For those that want to read more, anchor basically uses a number of tools. So once again, we build smart contracts.
00:17:21.342 - 00:18:20.120, Speaker A: In this workshop, we're going to build them in rust. It generates these files called IDL files, interface description language files, which is very similar to an ABI file in the Ethereum world, if you're coming from a solidity point of view, and we're going to go through that in a minute, and then you generate your clients or off chain kind of programs using uni, JavaScript, or typescript, et cetera. And Anchor has its own CLI for interacting with programs and deploying them and things like that as well. So in terms of how the workflow of anchor works, first we have our smart contracts, which in this case we're going to write in rust. And then with those smart contracts we build them, which basically compiles the program into bytecode, just like if we're not using anchor. However, also with anchor, it generates this idl file as well that says how to interact with the program. And from that idea we can then generate clients, and with the clients we can then talk to our program and test them and things like that.
00:18:20.120 - 00:18:31.646, Speaker A: So an anchor program basically consists of three parts. So it's just a rust program with some little hooks and macros added to it, which you'll see in a minute.
00:18:31.698 - 00:18:31.914, Speaker B: Right?
00:18:31.952 - 00:19:14.694, Speaker A: So we have a program module that defines, this is all the logic in the program. We have these things called accounts structs, which is where all the accounts that are passed in are validated. And we have this thing called a declare ID macro that stores the address of the program that's been deployed. So the actual program that you're in, we actually store the address of the public key address of it in there. So that when the Solana accounts get validated and stuff, it knows who owns them and things like that. So here's just a basic example of an anchor program, basically. So all the bits in red are the anchor hooks or macros that are added in.
00:19:14.812 - 00:19:15.094, Speaker B: Right.
00:19:15.132 - 00:19:37.066, Speaker A: So this is basically saying this program is located at this address here. This is the public key address. This little program macro basically says, this is where all the logic of the program is. So in this case, we have a module called hello anchor. And we have a function called initialize. And then in the account struct here, we basically define a struct called initialize.
00:19:37.258 - 00:19:37.854, Speaker B: Right?
00:19:37.972 - 00:20:16.602, Speaker A: So these are like the anchor hooks or macros that you basically put into your program, and we'll go through them in more detail right now. So in terms of these accounts macros here, basically this is where you define which accounts your instructional function call expects and what constraints these accounts should follow, right? So in this example here, we have this set data function here. And with anchor programs, you always have this thing called a context that's passed in. And you need to define in the context what the context is.
00:20:16.656 - 00:20:16.874, Speaker B: Right?
00:20:16.912 - 00:20:51.062, Speaker A: So we're saying the context for this function call is set data. Basically, what that means is it's going to look down here in the account structs and look for one called set data. So it says, okay, when this function call gets called, the accounts that we're expecting to be passed in are going to be specified here in this set data struct here. So in this case, we're saying we're expecting one mutable account. So mutable means it can be modified, and we're expecting one account to be passed in, called my account. And it's of a type, my account, which hasn't been defined yet. Oh no, sorry.
00:20:51.062 - 00:21:44.070, Speaker A: My account is here. So that's basically saying this is the account that data that we're expecting, and we're also expecting an unsigned integer 64 bit parameter here. And over here in that account definition, we're saying we're expecting this one account called my account. It's of type this. So then in your account, little macro here, you can then define what this is. You say public struct my account, this is just a struct that has one unsigned into just 64 bit called data, right? So that's how we can kind of combine the logic, the account that defines how the data is stored and stuff, and then the accounts that defines what accounts we're expecting to be passed in within this context here. So the program module, as I've said before, is where the business logic is defined.
00:21:44.070 - 00:22:10.960, Speaker A: You can then call them from off chain clients and things like that. So they're just kind of like where your functions go. And as I said before, each defined endpoint takes a context type as an argument that provides access to the accounts of the executing program and the program ID that we specified up here. So in this example here.
00:22:14.530 - 00:22:15.086, Speaker B: We'Ve got.
00:22:15.108 - 00:22:57.178, Speaker A: This set data function that we define here. And like I said earlier, in the context we're saying we're looking for a set data thing down here in this section here that's going to define what kind of accounts we're expecting. And it can take one input parameter here as well. So just like earlier I said, you need to serialize and deserialize when using Solana, when you use anchor, you can actually take in input parameters directly on the function definitions, just like I have here. So that abstracts away all of that serializing and deserializing for you. So that's one of the cool things about anchor. Yeah, and the instruction data can be added by adding arguments to the function after the context argument.
00:22:57.178 - 00:23:42.560, Speaker A: And anchor will automatically deserialize the instruction data. So as I said earlier, you don't need to serialize things into byte arrays, pass them in and then deserialize them back. With anchor. You can literally just pass in integers, strings, et cetera, on your function definitions here and just deal with them directly. And anchor will automatically do all of the serializing and deserializing required. So the IDL file is generated very similar to the ABR file in the solidity world, and it's basically used by clients to be able to interact with the deployed anchor programs, right? So it just defines what are all the function definitions, what kind of accounts are they expecting, what kind of arguments are they expecting, and things like that. So here's just a simple example of one here.
00:23:43.890 - 00:23:44.302, Speaker B: Cool.
00:23:44.356 - 00:23:59.650, Speaker A: Let's do a quick demo. Now what we'll do is we'll just build a simple anchor program that just takes in a string parameter like a name, and it can just basically say Gm to that name.
00:23:59.720 - 00:23:59.954, Speaker B: Right.
00:23:59.992 - 00:24:38.190, Speaker A: So something very simple. So the first thing I'm going to do is bring up my vs code. Here we go. So I've got my console here. What we're going to do, the first thing we're going to do is we're going to go. So I've got anchor installed and I sent you guys the link to the docs there. It's got all the info on how to install anchor.
00:24:38.190 - 00:25:26.462, Speaker A: So I got version 24, two installed. So the first thing we're going to do is we're going to use the CLI and go anchor init. It's going to initialize a new project for us with some boilerplate code and then we're going to just build upon that project. So give that a minute to complete. In this example, I'm going to be deploying things and using things on a local anchor cluster. So I'm going to start a local anchor validator and we're going to do everything locally. Also, as you can see, we've got a whole bunch of stuff that's been generated, including some boilerplate rust code here and yeah, we can get going now.
00:25:26.462 - 00:25:37.314, Speaker A: So we have a function called initialize here that takes in that as a context of initialize here and it just returns nothing.
00:25:37.432 - 00:25:38.050, Speaker B: Right.
00:25:38.200 - 00:26:16.478, Speaker A: So the first thing that we're going to do is we're going to change this to execute and context as execute change that to execute as well. And in this case we're going to take a string parameter in name string. And then what are we going to do? So we want to take the string that's passed in and just store it in an account that's passed in maybe, right? So we're going to say let GM count equals mutable context accounts count.
00:26:16.564 - 00:26:17.054, Speaker B: Right.
00:26:17.172 - 00:27:06.718, Speaker A: So what does this mean? Just basically taking in looking in this execute context for something called GM account right now, but there's nothing in here yet. So let's define that next. So what we want to do is we want to specify, using our anchor tags, one account that we're expecting to be passed in a new account that's initialized. The person who's going to pay for that initialization of the account is going to be the person generating this transaction. And the initial space we're going to allocate for the account is eight plus 32 bytes. So there's always like an eight bit discriminator at the beginning. And then we're just going to say we're going to store 32 bytes worth of data.
00:27:06.718 - 00:27:26.180, Speaker A: That should be enough for a name. So once we've specified this little anchor hook here, we can then define the account. So PUBGM account, it's of type account, and data that we're going to be storing is of type greeting account.
00:27:28.230 - 00:27:29.090, Speaker B: Oops.
00:27:32.070 - 00:28:27.702, Speaker A: And next we're going to be expecting another account passed in, which is the account that's signing the transaction, and that's going to be the, we're going to call it user and they're going to be who's signing the transaction. I think that's the syntax there. And then one more thing. When you create accounts, which is what's going to happen here, you need to pass in the Solana system program. So we need to basically specify that too. The system program is the program into the protocol that does a whole bunch of protocol type things, such as creating accounts and things like that. This is all pretty standard boilerplate anchor type things.
00:28:27.702 - 00:28:59.140, Speaker A: There's nothing that's very different yet. So once that's defined, the next thing we need to do is define what is this data look like that we're storing in this GM account. So we're going to have our kind of hook here. We're going to create a struct called greeting count, and we're going to store a name here.
00:29:02.630 - 00:29:03.282, Speaker B: Cool.
00:29:03.416 - 00:29:26.730, Speaker A: I think that is okay for now. Account info, greeting accounts. Let's see what's one here. Execute info.
00:29:27.470 - 00:29:28.540, Speaker B: There we go.
00:29:28.990 - 00:30:01.240, Speaker A: So basically we're taking in when this function gets called, we're saying from the context here, get this account here, create this account here, which stores data using this kind of structure here. And then once we've done that, all we want to do is say gmaccount name equals name, which basically says grab this name that's passed in here and store it in this newly created account, which is of this type here. So store it in this part here.
00:30:02.010 - 00:30:02.760, Speaker B: Right.
00:30:03.450 - 00:30:07.190, Speaker A: And we might as well print it out to the program logs.
00:30:09.470 - 00:30:10.378, Speaker B: Why not?
00:30:10.544 - 00:30:56.914, Speaker A: And then we'll end. Anything else? My anchor directory here. So there's my anchor project. Run anchor build. Start compiling my program now. Now this program ID here that I talked about before, anchor is a bit weird in that you need to kind of specify the program ID that gets deployed.
00:30:56.962 - 00:30:57.606, Speaker B: Right.
00:30:57.788 - 00:31:41.890, Speaker A: However, you don't know what the program ID is going to be until you actually build it for the first time. Because it generates it randomly. So there's this kind of double building thing that you just have to do in anchor for the time being until they find a solution. So you need to build it, and then you need to extract the generated program ID, which is stored in the IDL file, I think. And then you can then paste that generated program ID in here. And then you actually need to build it again because you've changed the source code. And once you've built it once, it will reuse the same program ID, as long as you don't blow away your target folder here, which contains all the metadata, so that you need to kind of build it, get the program ID, paste it in there, and then build it twice.
00:31:41.890 - 00:32:03.470, Speaker A: So it's a bit weird like that. So to extract the address, I'm going to run Solana address from Solana Cli and we can kind of get it here. I'm going to paste it in there and I'm going to do anchor build one more time and it should be quicker this time.
00:32:03.540 - 00:32:04.160, Speaker B: Cool.
00:32:05.730 - 00:32:42.990, Speaker A: Now, before we deploy, I'm going to tell Solana that I'm going to be using my local validator. So Solana config, set URL, localhost, and then in another terminal session, I'm going to go Solana test data to spin up my local Solana instance. And once that's running, we're nearly ready to go. So first we're going to generate a new wallet address using the Solana cli. Solana Cli. Sorry. So I'm going to call it ID JSon password.
00:32:42.990 - 00:33:09.460, Speaker A: So as you can see, I've got an ID Json here. The first thing I want to do is just airdrop some Solana tokens to it. So with Solana, you don't need to go to a faucet. You can use the airdrop program if you're on a testnet. However, there's no airdrop program for main net, for obvious reasons. And id Json. Let's try that.
00:33:09.460 - 00:33:18.226, Speaker A: Oh, we got two sol on our account. I think we're ready to deploy now to deploy it to our local cluster.
00:33:18.258 - 00:33:19.670, Speaker B: Let's give it a shot.
00:33:21.930 - 00:33:42.634, Speaker A: Actually, one more thing. So, anchor, we need to specify an environment variable. I think that's for the client. Let's try deploy to deploy it. And we specified earlier that we're working with a local cluster and it's deployed. And as you can see, the program ID here matches the one over there.
00:33:42.752 - 00:33:43.420, Speaker B: Right.
00:33:44.190 - 00:34:24.314, Speaker A: So now that we've deployed it, the next step is to kind of get a client going. So just quickly though, when using a client. In this case we're going to generate just like a JavaScript script to run to simulate a front end. You need to export this anchor wallet environment variable because we're going to be using that anchor JavaScript library. It uses it to know what wallet should be used to kind of generate transactions. So in this case we want to specify the ID json public key or wallet that we generated here. So we're going to basically say set that environment variable to that.
00:34:24.314 - 00:34:28.700, Speaker A: We're doing double dots because I'm going to create my client file in this app folder here.
00:34:30.270 - 00:34:30.778, Speaker B: Cool.
00:34:30.864 - 00:35:31.326, Speaker A: So let's go to the app folder and let's create a new file called Client JS we're going to open here. Now in the anchor, in the anchor docs there is a simple example that I've pasted in the chat and I see there's a bunch of questions. I'll get to them at the end of this exercise. So we're going to basically go to that minimal example and we're going to start with the boilerplate code that's there, right. So I'm going to paste it in here. So basically the first thing it does is it grabs the generated IDL file because it needs it to interact with our deployed program. We're going to get our deployed program ID, which was this one here, and we're going to paste it in here to say this is the program ID we want to interact with.
00:35:31.326 - 00:35:42.690, Speaker A: And basically all the anchor web prepackage does is it gets connection to that deployed program using the IDL and the program Id. And then you can go program RPC function name.
00:35:42.840 - 00:35:43.540, Speaker B: Right.
00:35:45.510 - 00:36:09.020, Speaker A: So the first thing we're going to do is go anchor equals require project serum anchor use the anchor web three library for JavaScript and provider is a way to get a connection to our.
00:36:12.130 - 00:36:12.826, Speaker B: Network.
00:36:12.938 - 00:36:27.140, Speaker A: In our case it's the local network. We're going to call that provider and then we're going to have everything in a main function.
00:36:30.230 - 00:36:30.690, Speaker B: Right.
00:36:30.760 - 00:36:46.360, Speaker A: And then all we're going to do is call our main function and then just say done.
00:36:49.550 - 00:36:50.106, Speaker B: Cool.
00:36:50.208 - 00:38:03.754, Speaker A: So we don't need that. No, we do need, that's fix a syntax issue here. So let's see what in our program. So in our case our generated IDL file is going to be called GM anchor Json. So we're going to change this to GM anchor, right. And what we're going to do next is we have a connection to our program ID here. So we need to basically generate a new account address to pass in as that account that we want to initialize.
00:38:03.754 - 00:38:54.190, Speaker A: So we're going to say account equals anchor web three key pair generate. So it's going to generate a new account address for us. And now put that under here. And now we're ready to interact with our program. So we're going to say let transaction equals await program RPC execute because execute was our function name here and it takes in a string parameter here, the context you don't need to specify. So we're going to say, and then we're going to pass in a name. Oh, we need to set the name actually.
00:38:54.190 - 00:39:43.118, Speaker A: So let's go const name equals Harry, we're going to pass in a name and we also need to specify the accounts. So accounts that we want to pass in GM account is the GM account that we specified. Just further up, the user, the person that's signing for the transaction is our ID JSON one that we generated just before, which it gets from the provider because we set that environment variable and then finally the system program. So system program anchor web three. Specify it like this.
00:39:43.204 - 00:39:44.240, Speaker B: There we go.
00:39:46.770 - 00:40:42.260, Speaker A: Then once we pass in the account, you don't need to do this, but I'm just going to say our starting point for this instruction call is on all confirmed transactions, right. And signers who's signing this transaction. We also want to include the GM account that we created just so that it knows that we have access to that to basically store stuff in that. Okay, so that should be it for that. Let's see, I've got a name.
00:40:43.270 - 00:40:44.420, Speaker B: Here we go.
00:40:45.590 - 00:41:32.180, Speaker A: Accounts needs a colon call. So once we've called that function call, then that's going to store that name in the account that we passed in. So we basically just need to double check that it's been stored. So we go const store name equals await program account Greetingaccount fetch. So we're basically calling this in our deployed program, we're saying get the greeting account which is this here fetch. And we want to get the name right. So gmaccount public key.
00:41:32.180 - 00:42:45.180, Speaker A: Then we're just going to go console log sword name name. So it's going to basically, just for this GM account that we created here and passed into our call, it's going to basically look up the account data and fetch the green account name value. Okay, I think that's it. So one other thing we just need to do quickly is set the anchor provider URL. So when working off chain in these JavaScript libraries or typescript or whatever anchor needs to know you can't access the anchor CLI to know that we're working with a local host. So we just need to specify it using this environment variable here. So just going to set it to my local host and then we're going to go CD app.
00:42:45.180 - 00:43:29.140, Speaker A: We're already in app, sorry. So I'm just going to run node client Js to run it and we have an error. Let's see what we're going. Ah, we need to go back one extra folder because we're in the context of the app folder here. And let's see what the next issue is. Valid arguments system program not defined program ID.
00:43:31.510 - 00:43:32.260, Speaker B: And.
00:43:34.590 - 00:44:14.102, Speaker A: Oh, Harry, done. So it did a console with our name here. It basically called this execute function. It passed in this GM account to get initialized and we passed in the string Harry. So the program executed, it took the Harry parameter, it took the account that was passed in and created it as a new account to store this type of data in it. And it basically just stored the, it set the name here to the name that was passed in here and then off chain. Once the program completed, all we did is just read the data from the account.
00:44:14.236 - 00:44:14.534, Speaker B: Right.
00:44:14.572 - 00:44:54.082, Speaker A: So just a very simple example of using anchor. How are we doing with the time? We got 15 minutes. Do you need curl to install rust and Salana Cli? I think you can download pre built binaries depending on what system you have. Great question. But definitely check out the Solana docs, which I'll paste in the chat here, and the anchor docs, which I pasted already I think. But yeah, great question. Now I see a few other questions.
00:44:54.082 - 00:45:04.950, Speaker A: I'll try to get to them at the end, but for now I just want to go on to the chain link stuff because we are running a bit over time. So let's go back to the presentation.
00:45:09.610 - 00:45:09.974, Speaker B: Cool.
00:45:10.012 - 00:45:48.750, Speaker A: So now let's talk about Chainlink price feeds. So Chainlink price feeds are live on the Solana devnet for anyone to use. They will be available on Mainnet for anyone to use very soon. But for now they're live on Devnet. So if you want high quality, accurate price data, chain link price feeds is the way to go. So if you go to docs chain link, there's a Solana tab at the top here and all the info about our price feeds is here. So we have, I think a few on Devnet right now, btc ETH link, sol and a couple of stablecoins.
00:45:48.750 - 00:46:37.534, Speaker A: So if you need price data for your chainlink hackathon submission and you want to build on Solana. This is where you go to basically to do that, right. And what we're going to do next is we're going to go straight into a demo. So if you go to our GitHub repository, I'll paste in the chat once again. We have this thing called a Solana starter kit, right? So if you need to build something on Solana that uses price feeds, this is the place to go. So it's pinned to our repo here, Solana starter kit. And it is a prepackaged repository that contains an anchor example program that uses chain price feed.
00:46:37.534 - 00:47:09.280, Speaker A: So you can just use it to kind of work out how to do it. You can use it as a starting point for your project. You can use it to just see how to do it, basically. So what we're going to do is we're just going to run this starter kit and I'll just kind of walk everyone through it and then hopefully I'll have time to answer some questions. So I'm in my root folder here. So we're going to go git clone. I'm going to paste the URL of the starter kit here.
00:47:09.280 - 00:47:15.950, Speaker A: And as you can see, I have a whole bunch of stuff here now. So we're going to go Solana.
00:47:16.770 - 00:47:17.194, Speaker B: Cool.
00:47:17.252 - 00:48:03.326, Speaker A: So the first thing I want to do is just install all the NPM stuff that needs to get installed. While that's going, I'll basically walk everyone through everything. So here is the deploy program. It uses anchor, just like we saw, not too much in here. We have a declared ID. We define the way in which we're storing the price data here. So this example program just literally takes in a price feed account address such as SOl USD account and basically looks up the latest price and stores that data in another account that's passed in.
00:48:03.326 - 00:48:48.942, Speaker A: So there's a function for just formatting price data. And the thing to note here is we're using the Chanic Solana library here. Sorry. And then using that library we can call functions such as latest round data description, is it a Sol USD link, USD, et cetera, and decimals. How many decimal places is there in the, what's the precision of the price feed data? So we can basically call those functions. And all that it's doing is it's basically just calling those functions and it's just setting the latest round data for a price feed into a variable and it's basically storing it into an account that's passed in.
00:48:48.996 - 00:48:49.214, Speaker B: Right.
00:48:49.252 - 00:49:20.534, Speaker A: So we're taking in a new account to store the price data in this boilerplate code. We're taking in the specified Chainlink feed which we grab from here on Devnet. They're just accounts. We're taking the deployed chain link program. So there's one deployed chain link program on Devnet that has all the functions and everything that defines how to interact with price feeds. So it's a static value and we're passing the system program because we're initializing accounts here. So that's the program.
00:49:20.534 - 00:50:08.440, Speaker A: Let's see if we can get this built now. So firstly, I'm just going to once again generate a new ID JSON wallet. Now the difference is this time we're going to be dealing with Devnet, the public Devnet network, instead of our local validator. And as you can see, I'm doing an airdrop here, I'm doing it twice actually to our ID JSON generated wallet address. And I'm specifying the Devnet RPC endpoint here API devnet solana.com. So I'm just going to kill my local validator here because we don't need it anymore. So we're going to airdrop ourselves some Sol and then we're going to try to build the anchor program.
00:50:08.440 - 00:50:47.550, Speaker A: So while that's building, I'll go through the client. So we have a client called client JS here. We actually have two clients. We have client JS and readata Ts. So client JS is very similar to the example that we just went through in our first workshop. In this case where we have the stored program ID, that's just a static value of the Chainlink program. On Devnet we have a price feed specified here, which I think is the sole USD feed.
00:50:47.550 - 00:51:45.990, Speaker A: Is it w six? Yes, but you can pass in another feed address on the command line when you run the script if you want. And all it's doing is it's getting a connection to our deployed Solana program. It's generating a new account just like we did before. And then it's calling the execute function like we did before, passing in all the account information. So passing in the new account that we're creating our ID JSON wallet address for signing the transaction, paying for it, the chaining price feed which we're getting from here that we want to get. The latest price for the chain link program is this one here, that static value and then the system program, because we're going to be generating new counts. So once that's done, we've built it once again, we need to extract.
00:51:47.850 - 00:51:48.166, Speaker B: The.
00:51:48.188 - 00:52:42.442, Speaker A: Generated ID for this program. We need to go back to our anchor program and put it in the declare ID section up and then do that, build one more time to build it with that in place. And once that's done, we should be able to deploy to Devnet. So we say anchor deploy provider cluster equals Devnet here. So that might on Devnet, it usually takes a little bit of time, maybe a minute or so, hopefully not. So what I'll do is I'll go through the rest of the client. So once we call that program, it will basically store the latest price for the feed that we specify in that account.
00:52:42.442 - 00:53:40.068, Speaker A: And then we're just printing out the contents of the logs here and it looks like the endpoint is down. That is not good using a free public endpoint here. So let's try do that again. Um, and once we, once we have called that function, once again we're just reading the value of that account that we passed in to get that latest price information. So very similar to our last example that we ran. Now we also have this read data script as well that you can use. So if you're building an app that you just want to use price feed data in your front end, if you're building a CiFi application or something, you don't need to generate transactions on Solana.
00:53:40.068 - 00:54:16.070, Speaker A: If you want to read price data, you don't need to pay Sol and land ports and things like that. You can just read the price feed data off chain as well. And that's exactly what this read data script does. We specify a chain link feed address and a program ID, and we get a connection to that deployed feed and it basically just looks at the logs for that feed and it just basically keeps printing the latest price. So you can do this off chain in your web app or whatever it is. You don't need to pay sole land ports or generate any transactions, and you can use it just to read the price data off chain. So that's what this read data script does as well.
00:54:16.070 - 00:54:46.576, Speaker A: So hopefully we can deploy to Devnet. I'll just give it a minute to complete. I'll have a look at some questions while we're waiting. Is anchor kind of like Docker, but for rust, anchor is kind of like more of like a hard hat sort of. For Solana, I'd say, than Docker. Yeah. Will the default Solana rust template run with cargo run? I think so.
00:54:46.576 - 00:55:31.864, Speaker A: I think it does, yeah. Can we access system program IDL files, the system program that's baked into Solana? I don't know if it's got an idl file because I don't know if it was built using anchor. Can a program access data created by another in your account? Great question. So when you specify your accounts here, you can specify who owns them and things like that. And in this case we're saying whoever pays for it owns it. So you need to basically have access to the account to be able to access it on chain.
00:55:31.992 - 00:55:32.670, Speaker B: Right?
00:55:33.360 - 00:55:37.824, Speaker A: So because this program is doing it here, the program has access to it.
00:55:37.862 - 00:55:38.208, Speaker B: Right.
00:55:38.294 - 00:56:01.130, Speaker A: However, once again it's just byte data stored. So if you know the address of an account that you want to access from off chain and you know the structure of that data because you know the source code or something of the program that uses it, you can theoretically off chain just read the byte array and then deserialize it into something meaningful. So there's nothing stopping anyone from doing that. But yeah, great question.
00:56:01.580 - 00:56:01.944, Speaker B: Cool.
00:56:01.982 - 00:56:55.832, Speaker A: So that's deployed. Now the next thing we want to try and do is run the client now. So I'm just following the steps here in our Solana starter Kit repo, which I'll paste here again in case anyone hasn't seen it. So once again, we need to set some environment variables. So we're saying the anchor provider URL is the local devnet, RPC endpoint and the wallet that we want to generate account that we want to generate transactions with is our ID JSON that we created. So once that's done, we should be able to just run our client script. So in this case we're saying nodecline Js the program we're passing in dynamically using the Chainlink CLi, but it's essentially just going to return this program ID here.
00:56:55.832 - 00:57:40.056, Speaker A: And the feed that we're passing in is, I think it's the ETH USD feed. So we're going to see what the latest price of Ethereum is. So we run that client. Cool, there we go. So we see a bunch of program log data, ETH USD price there, and then price is, that's our client Js here just reading the account info from off chain and then basically just stripping out the. So, so there you go. We deployed a Solana program that basically looked up price data on a chain price feed, the latest price Ethereum, and then stored it in a passed in account.
00:57:40.056 - 00:58:13.880, Speaker A: And then you can do stuff with that data in your hackathon submission. So the last thing I want to show everyone is the read data script. So once again, it's a great use case if you're building something where you just need high quality price data off chain and it's actually really easy to run. So you don't need to change the program ID. You just basically say, what is the feed address you want to look up data for?
00:58:14.030 - 00:58:14.392, Speaker B: Right?
00:58:14.446 - 00:58:34.924, Speaker A: In this case we have ETH USD as well, and you basically just run NPM, run read data to just run the script and it'll basically go in, it will read the price data from the account, it will look at the events generated and it will basically just keep printing out the latest price as it gets stored.
00:58:35.052 - 00:58:35.344, Speaker B: Right?
00:58:35.382 - 00:58:55.590, Speaker A: So I think the roundtime is set to 1 second or a couple of seconds or something like that. So as you can see, there's the price of Ethereum and it basically just keeps printing it out. So you can just use this as a means to kind of know how to do it and then you can basically just incorporate this into your off chain web app or front end or whatever it is you're building.
00:58:57.480 - 00:58:57.808, Speaker B: Cool.
00:58:57.834 - 00:59:33.896, Speaker A: So that's really, as you can see, quite easy to use price feeds on Solana. There's a perfect boilerplate project to show you exactly how it's done and then you can just use this as a starting point or just as a reference point to using your own submission. So I'll get to a couple more questions in a minute. I just want to talk about where you can learn more about Solana and Chainlink quickly. So where you can learn more a really good place to go is the Solana cookbook. I can't recommend this site enough and I'm going to paste all of these in the chat. So it's a really good developer resource.
00:59:33.896 - 01:00:14.844, Speaker A: It's got tutorials and guides for doing all kinds of things on Solana and it's very popular with Solana developers, so highly recommend you check that out if you're interested. Another place is soldev. This is like a content aggregator for Solana. So whenever people build published tutorials or blog posts or guides on how to do things, they usually end up in Sol dev here. So you can search for things really easily. Once again, really great resource. So the Solana labs have a Solana developers page as well, with a bunch of more resources, videos, content, starting, how to guides, et cetera.
01:00:14.844 - 01:00:47.864, Speaker A: So definitely recommend checking that out as well. Anchor's got this thing called Anchor book, which is awesome. So if you're using Anchor, definitely recommend checking this out. It's got reference information on how anchor works. It's got example projects like Tic Tac toe projects and stuff so that you can follow along and just see how everything works. We discussed the Solana starter kit, I pasted it in the chat earlier. So that's our prepackaged boilerplate repo for interacting with Solana programs and yeah, our docs.
01:00:47.864 - 01:01:20.116, Speaker A: So you go to docs chain link, click on Solana and it's got information on how to use data feeds and the reference information for the data feeds on our Devnet and soon to be mainnet as well. Cool. We are time. So I just want to say thanks everyone for tuning in. I will answer a couple of questions now, but yeah, really excited to see what everyone builds. If you are building something for the hackathon on Solana, awesome. Really happy to see.
01:01:20.116 - 01:01:52.850, Speaker A: Can't wait to see how you use our price feeds and I think there might be some really interesting projects. So once again, thank you. If you have any questions or issues, hit us up in our discord. Or if you have Solana specific errors or issues, definitely recommend checking out the Solana discord which is here as well, and asking questions there. They're very active there as well. But thank you for tuning in and looking forward to see what everyone builds. I will spend a couple of minutes just checking out a couple more questions here.
01:01:52.850 - 01:02:44.294, Speaker A: Why isn't there a bigger market for blockchain cybersecurity? I'm not sure. Can we select versions of solidity in Solana? Yeah, so once again, I don't think you can use solidity in Solana yet. However, I do know that there are some people trying to bring EVM compatibility to Solana, but I haven't played around with it myself. Do you recommend us learning Rust? Yes, if you want to spend time building on Solana, Rust is definitely the way to go. I think personally it's not hugely hard. If you know any other programming language, you can pick up Rust fairly easily. There's not a huge amount of rust used on Solana as well.
01:02:44.294 - 01:03:16.738, Speaker A: It's just like a subset of rust, kind of like the basics. So yeah, if you want to get in the Solana ecosystem, getting up to speed on Rust is the way to go. And there's this thing called the Rust book, Rust book, which is a good online reference. I'll paste in the chat. However, if you want a hard copy, let me see if I got it here. This is what I've been using here. I'll see if I can throw it up here.
01:03:16.738 - 01:04:10.546, Speaker A: Programming Rust this is a really great resource for learning rust. So probably the first six or seven chapters is applicable for Salana. So I can highly recommend that one as well. Does Salana have prizes in the hackathon? I'm not 100% sure. I don't know if there is yet. However, you can build on any chain with chain link and be applicable for any of the major prizes. So if you're building a DFI app, you can build it on Salana, you can build it on binance smart chain, you can build it on Ethereum, and you're still applicable for the main prizes because as long as you use chain link in some way, so you can build on Solana for the hackathon, you can definitely get prizes with it.
01:04:10.546 - 01:04:44.574, Speaker A: I'm not sure if Solana has a sponsor prize at this stage though. What is anchor? So just definitely watch the replay of this workshop. But anchor is basically a library for making building Solana smart contracts a lot more pain free. Definitely. Okay, we're definitely over time here, so I think I'm going to end the stream. But once again, thanks to everyone for tuning in and really look forward to seeing what everyone builds. Sorry, just one more thing.
01:04:44.574 - 01:05:17.074, Speaker A: I want to plug my bootcamp. I forgot. If you want to learn more about Solana, if you go to chain link bootcamp, we do have a Solana bootcamp that we recently ran. I'll paste it in the chat. You can sign up and do this bootcamp on demand, so it goes for about 8 hours. So you learn all about Solana, anchor and building Solana programs and stuff like that. You can just do it by watching the pre recorded sessions and I think there's about five exercises.
01:05:17.074 - 01:05:54.320, Speaker A: So if you want to get more into Solana, definitely recommend checking that out as well. But for now, I will stop sharing it. Cool. All right, thank you everyone. Yeah, really looking forward to seeing what everyone builds. And yes, the boot camp is free. It's 100% free.
01:05:54.320 - 01:05:55.820, Speaker A: Thank.
