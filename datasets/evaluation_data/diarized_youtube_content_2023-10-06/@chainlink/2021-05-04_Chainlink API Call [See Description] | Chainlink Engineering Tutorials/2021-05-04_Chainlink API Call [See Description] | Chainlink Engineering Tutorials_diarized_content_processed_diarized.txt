00:00:00.410 - 00:00:02.762, Speaker A: Welcome back to the Chainlink Engineering tutorials.
00:00:02.826 - 00:00:52.666, Speaker B: The advanced section for this. We're assuming you know a little bit about the request and receive cycle of working with Chainlink smart contracts. So if you haven't watched the Chainlink VRF tutorial yet, definitely go back and watch that before coming to this video. At the end of this video you'll understand how to pull data from a public API, understand what Oracle jobs are and how initiators and core adapters and external adapters all work together. Be able to find Oracle jobs for your smart contracts, and then of course how to request data from an Oracle job. Before we go ahead and pull data from a public API, we need to actually understand how chainlink nodes know how to go out and get that API or even with the chainlink VRF. How did the chainlink node know that it needed to kick off a job to get that random number? What started the chainlink node down? The process of returning data.
00:00:52.666 - 00:01:30.098, Speaker B: When we made our request to the chainlink VRF node, we actually requested that node do a job for us or a task. We were requesting a random number to be returned to us. So this is actually the first introduction of the concept of jobs. Whenever we request something through a chainlink oracle, we request that thing through a chainlink job. And chainlink job is going to define all these different parameters for understanding how the data is going to get returned, when it's going to get returned, and everything like that. These chainlink oracle jobs are split into two parts, the initiators and the adapters. The initiator defines when a job needs get kicked off.
00:01:30.098 - 00:02:11.574, Speaker B: For example, with the chainlink vrf, the initiator was when that request randomness function was called. Once that request randomness function was called, it kicked off the rest of the tasks or the rest of the adapters to actually go get that random number. There are many different types of initiators which define how and when to actually kick off one of these jobs. Another good example is the cron initiator, which runs cyclically or periodically. In the example that we're going to go over, we're going to use a run log initiator. This is the initiator that we're going to use to actually make API calls. So if the initiator defines when a job runs, what do the adapters define? Well, the adapters, also known as the tasks, define what tasks for the node to carry out.
00:02:11.574 - 00:03:05.090, Speaker B: In the chainlink VRF example, the tasks were for the node to create a provably random number and return it on chain. In our example, to call an API, we're going to look at a job that's using five different adapters, HTTP get, json parse, multiply, Fu 256, and FTx. Those are the different tasks or adapters that the chainlink node takes in order to get that data and then return it on chain. So what do those adapters actually do? Here's an example of what a full chainlink Oracle job looks like end to end. So after the initiator defines, it's time to kick off the tasks or adapters list, the first adapter is run and the rest are run sequentially. So the HTTP get adapter makes an HTTP get call to whatever API that's passed in from the smart contract. Then it takes the output of that first adapter and pipes it into the second adapter, which is the json parse.
00:03:05.090 - 00:03:43.442, Speaker B: The json parse defines which part of the response from the HTP get data that we're going to use. For example, if we get a json response from the API, like so, but we only want this certain specific piece of data, we can walk down the JSON to that specific point. We don't want to return this massive json object on chain as that's going to cost a lot of gas. The json parse will parse the data to get the specific value that we want. Then we'll take the output of the json parse and pipe it into the multiply. As we know, solidity doesn't work with decimals, so we need to multiply this number by something so that we can return it back on chain. And that's what this multiply or times adapter will do.
00:03:43.442 - 00:04:21.482, Speaker B: Then once we've done that, we need to once again convert it into an FU 256. This is the Ethereum readable version of that number. And then once we have the Ethereum readable version, we pipe that into STX, which is the adapter that actually makes the transaction back on chain. Now these are some examples of core adapters, and you can see a list of all these adapters from the Chainlink documentation. They're called core adapters because these are tasks that come prepackaged with the chainlink node and you can just go ahead and call them on any run log job. However, you've probably also heard of external adapters. These are custom built adapters that anybody can build, anybody can define and add to their node.
00:04:21.482 - 00:04:47.862, Speaker B: We talk about these in a different video and there's a link in the description to building and using and working with your own external custom adapters. So based off the initiator and the adapters list here we know that this job will make an HTTP get call and return a UN 256. This is important to note because if we want to return a different data type we're going to have to use a different job. But let's look at this from the smart contract perspective and let's see what it looks like here.
00:04:47.916 - 00:05:16.698, Speaker A: Due to this bleeding edge technology moving so fast, always be sure that when you click on one of our technical videos you scroll down to the description and check for any updates. That way you'll know you're always up to date. If you're following along with the documentation we can just scroll down to the deploy this contract with remix button and we can jump right into our example again. I have a number of extra gists on the left here. We're going to be working with this API consumer soul contract which shows us end to end working with one of these jobs and one of these oracles.
00:05:16.794 - 00:05:18.082, Speaker B: And like the rest of our video.
00:05:18.136 - 00:05:36.546, Speaker A: We'Re going to be working on the coven testnet. But you can use any other network that you like. Just be sure to change the oracle and the job id to the network that supports it. So the first thing is we import the chainlink code and we inherit the chainlink code into our contract. We're going to set a couple of global variables here. Let's take a look at the API.
00:05:36.578 - 00:05:37.494, Speaker B: That we're going to be pulling from.
00:05:37.532 - 00:06:09.970, Speaker A: We can just pop it into a new tab, see what this API would normally return. We're going to be looking for the volume 24 hours which is going to be this value right here. We're going to save that volume to this volume public variable at the top. We're also going to be setting these different variables which we'll define in a minute. Let's go to the constructor. In our constructor we have this function set public chainlink token which tells this contract which chainlink token to use for this network. If this line errors out we can actually set the chain link token manually with using set link chainlink token and then the address of the link token here.
00:06:09.970 - 00:06:41.754, Speaker A: Then we choose our oracle and our job id. We choose a specific chainlink oracle contract to actually pull the job from. Each oracle is going to have a different list of job Ids. Where can we find these different oracles and these different job Ids to define the different jobs that we want to use? Well we can use a node listing service to actually look up different nodes and different jobs. Let's say we want to find a job that makes an HTP get request and returns a UN 256. We can now scroll through a list of nodes that have this job, or we can scroll through a list of jobs that have this job. Let's look at this one.
00:06:41.754 - 00:07:12.370, Speaker A: For example. We can see the node's job ID on the side here, and if we click on the node we actually will get the oracle address. Now back on the job we can actually see the tasks and make sure this is what we want. So it makes an HTP get request, a json parse, a multiply adapter, an SU N 256 adapter and etx adapter. So this is a job that we'd use. Just be sure to note that you're on the right network. Each network is going to have a different set of oracles and job IDs associated.
00:07:12.370 - 00:07:53.922, Speaker A: Now that we've gotten an oracle and a job ID that we want, we also need a fee. When looking at the jobs, you can go ahead and see the fee of the job right below the job iD. Now that we have the oracle, the job ID and the fee, we can actually start defining our request. We're going to define our function in request volume data. So the first thing that we're going to do is build a request object of type chainlink request. We can build the chainlink request with this function, build chainlink request and we pass it the job Id, the callback address, which is going to be this smart contract and then the fulfillment function. We're saying this smart contract has a method called fulfill and if we scroll down we do indeed see that we'll get to that in a little bit.
00:07:53.922 - 00:08:24.010, Speaker A: Since we're doing request and receive. This is the function that's actually going to request the data and this is the function that's actually going to be the callback and be receiving the data in the second transaction, same as the chainlink VRF. Now we get to add the adapters to this request. We don't have to add adapters if we don't want to, but we want to add these adapters and add parameters for these adapters. The first adapter is going to be the HTTP get adapter. We want to get this call, we want to get this URL. So we add request, add get and then the URL.
00:08:24.010 - 00:09:03.770, Speaker A: Now we want to walk down the JSON to get the volume 24 hours so we can add the JSON parse adapter which is identified by the path keyword here, and we add the path. We want to walk it down. We want to go to raw FUSD volume 24 hours. Then we're going to add the multiply adapter which is identified by the Times keyword. So we're going to times it by ten raised to the 18th. We're not going to add an FU 256 or an FTx adapter here because the run log initiator actually passes parameters to these adapters. So the chainlink node already knows how to return it back.
00:09:03.770 - 00:09:53.546, Speaker A: Then we're going to call this send chainlink request two with the oracle that we defined above right here, the request that we just got finished defining and the fee that we defined above this is going to send the request and kick off that first transaction in the two transactions of the request and receive. Once it's been finalized, the chainlink node then will respond by calling this fulfill function. It'll respond with the original request ID and then the data that we provided and we're just going to set our global variable volume equal to the responded value. Let's try this out. So let's compile. We'll deploy it on injected web three again on coven. This specific contract won't work on a different testnet we're going to deploy and same as the chainlink VRf, we have to send it some testnet link.
00:09:53.546 - 00:10:19.150, Speaker A: Once it's confirmed we can call this request volume data function and we'll kick off this first transaction. If we hit volume right now it's going to be zero, same as the chainlink VRf. We need to wait for the second transaction to come back to actually return the volume data. Now when we click volume we can see that we get a response. Remember it's going to look a lot bigger because we've multiplied it by ten raised to the 18th.
00:10:19.230 - 00:11:03.050, Speaker B: So great we're able to return a UN 256 from a public API into our smart contract. So remember, if you want to return a different type of data or you want to use a different blockchain or a different network, you're going to have to use a different oracle and a different job ID. And if there's a job that hasn't been built, you can 100% reach out to some of the node operators in the discord and ask for some help there. Now of course you may be asking, well, what if I have an API key that I don't want to put on chain, or what if my data does something really interesting or really peculiar? This is where the external adapters come in. If there's something that you want to do that isn't covered by these core adapters. The external adapters can do literally anything you want them to do. And we have a video on building, using and deploying those in the description.
00:11:03.050 - 00:11:04.880, Speaker B: Thanks all, and I'll see you next time.
