00:00:09.050 - 00:00:37.026, Speaker A: This is perfect. We've now got a successful deploy JS script that can deploy, verify and then interact with our code. This is fantastic. This hard hat thing seems pretty cool. What else can we do with Hardhat? Like I showed you before, Hardhat comes with these tasks, and the number of tasks that hardhat can come with can be extended by us writing plugins. We can actually write our own tasks in hardhat. And in our hardhat config it came defaulted.
00:00:37.026 - 00:01:18.738, Speaker A: With this task account we can see task accounts, prints the list of accounts, and just prints a list of accounts here. Actually go to the hardhat documentation to learn more about creating our own tasks. One of the ways that you can define tasks is directly in our hardhat config js. But typically what people do is they have a new folder called tasks where they put all their tasks. So for now I'm going to go ahead and delete this section here, and we're going to create our own task. You'll notice that now that we've deleted that section, if we run yarn hard hat, we no longer see the accounts task in here because we've just deleted that task. So let's create our own new task.
00:01:18.738 - 00:01:58.100, Speaker A: We'll call this block number js, and we'll use this to get the current block number of whatever blockchain that we're working with. So let's create this task. First we need to import the task function. We can get it by saying const task equals require hardhat config. The hard hat config has the task function in it. To define a task, we can now just say task, give it a name and a description. The name is going to be block number, and then the description is going to be prints the current block number.
00:01:58.100 - 00:02:40.238, Speaker A: Now that we have this task, there's a couple of things we can actually do with it. We can add different parameters to it by using the dot add command, which allow us to pass parameters to the task. And then we could also set actions which define what the task should actually do for us. We're just going to do setaction and define what we want this function to do. So we're going to make this an async function that's going to take as an input the task arguments, which are going to be blank for us, and the hre, which I'll define in a second. Now let me explain the syntax really quickly. This might look a little bit weird, but this is what's known as a javascript arrow function.
00:02:40.238 - 00:03:29.438, Speaker A: In JavaScript you can actually define functions without even using the function keyword. For example, if we go back to our deploy function, we have our async function verify down here. However, another way we could have defined this is without using the function word at all and actually turning this whole thing into a variable. We could have said, instead we could say const verify is going to be an async function that takes contract addresses and arguments. And here's the function definition. These two lines are essentially equivalent. There's some slight differences between using the function keyword and having your function be a variable, but for the purpose of this course, they're basically the same.
00:03:29.438 - 00:04:08.842, Speaker A: Which means though that this by itself is a function just not assigned to a variable. But essentially the two of these are exactly the same. And that's the syntax that we're doing here. You can imagine this sort of being like const block task equals async function, which takes the params and then runs that arrow function. Or you can think of it as async function block task parameters, and then the function definition. These are all essentially the same. The major difference is that we're never giving our function a name.
00:04:08.842 - 00:04:44.022, Speaker A: We never give it this block task variable. This is known as an anonymous function in JavaScript because it doesn't have a name. Now that we have our function in here, we can now call some function to get the block number. Well, how can we get the block number? When we run tasks, we automatically pass our anonymous functions, the task arguments, which in this one we don't have any. But we also pass this Hre object. This Hre is the hard hat runtime environment back in our deploy script. This is basically the same as this require hard hat in here.
00:04:44.022 - 00:05:21.186, Speaker A: So this HRe can access a lot of the same. This HRE can access a lot of the same packages that the hard hat package can. So we can do hre ethers, just like how you can import ethers from Hardhat. And in our ethers package there's actually a number of functions we can use like provider get block number. Let's save this to a variable const block number equals, and this is going to be asynchronous. So we're going to want to add a weight here. And then we'll just do console log block number.
00:05:21.186 - 00:06:08.866, Speaker A: Or better yet, we'll string interpolate this and say current block number like this. Now though, if I try to run this task, you'll notice it doesn't show up in the hardhat list of tasks. Let's do yarn hardhat. I don't see block number in here. Well, this is because we need to add it to our config. In our config, we'll add requiretasks block number and in order for us to import it, and let's add a module that exports. I'll explain what this does a little bit later, but now that we've required it, if I run yarn hardhat, I now see block number is one of the tasks that I can use.
00:06:08.866 - 00:07:02.610, Speaker A: So now if I run yarn hardhat, block number, we get current block number is zero. And this makes sense because this is defaulting to our hard hat network, which gets reset every time we run it. But if I run yarn hardhat, block number network, Rinkabee, what do you think I'm going to get? I get a much larger number. Current block number is right here, because this is the actual block number of rink b versus the block number of our hard ad network is going to be zero because it gets reset every single time we run one of these scripts. Now, scripts and tasks both can basically do the same thing. They both can interact with contracts, they both can deploy smart contracts, they can both pretty much do everything. I prefer scripts just as a general rule of thumb, because I don't always think adding a special thing from the command line makes sense.
00:07:02.610 - 00:07:30.360, Speaker A: So I prefer scripts, but you'll see a ton of tasks and examples out there as well. I think tasks are really nice for specific use cases, but for the most part, we're pretty much going to use exclusively scripts. But it is good to know what a task looks like and how to use it. I think tasks are better for plugins and scripts are better for your own local development environment. But if you want to do everything with tasks, you absolutely can. You.
