00:00:00.490 - 00:00:54.554, Speaker A: Chainlink's verifiable random function, or VRF version two, just released. It gives developers better scale, flexibility, and control. Hi, my name is Stephen Fluin, and today we're going to be taking a look at Chainlink's VRF version two that was just released. VRF version two has a few different mental models that we should be aware of, and, and I want to show you what it feels like to be using it. The big important thing to know about VRF version two is that instead of the VRF one model, where you'd be funding your contract with Link, instead you're going to be funding a subscription, which is basically an account that allows you to fund and maintain balance for multiple consumer contracts. Let's dive into the docs and see what using VRF e two looks and feels like. In order to show this off a little, I'm going to dive right into the get a random number guide in the chain link documentation.
00:00:54.554 - 00:01:33.894, Speaker A: And so it's going to go through a few of the requirements, some of the technology we're going to use today. And the first thing it's going to ask us to do is to make sure that we are on the rinkby testnet. So let's go ahead and jump over to rinkby, make sure my metamask is unlocked here. And now that I'm on rinkby, great, I should be able to use the VRFV version two testnet. Now we're going to jump over to subscription manager, and the subscription manager is where we're going to manage our subscription account. Basically, this is the place that you put the funds in order to be able to use it across a bunch of different chains. So we're going to go ahead and connect our wallet here in order to use the subscription app, and then we're going to go ahead and create a new subscription.
00:01:33.894 - 00:02:08.478, Speaker A: So we'll just use my address as a subscription address here. I'll approve the creation, and as soon as that transaction is confirmed, our subscription should be created. All right, now we have a subscription. Basically, this is the account where we're going to fund it, and then we can use that account for all of our randomness requests. So I'm going to go ahead and just put in ten link here. You can put in however much you want. The price and link of every random number you request is going to be based on the current gas rates on a given chain, as well as the gas lane that you've chosen.
00:02:08.478 - 00:02:28.940, Speaker A: All right, our funds have been added. Let's go ahead and add a consumer contract. So it's asking us for a consumer address. We don't actually have a consumer address yet. So let's go ahead and jump over to the documentation and create a contract that is going to request a number. So if you scroll down, you're going to see this VRFV two consumer sole contract that we can open in remix. Let's just jump right there.
00:02:28.940 - 00:02:52.962, Speaker A: We're going to notice a few different things in this contract. At the top we've got some imports. So now you've got VRF consumer base version two. We've got an interface for the VRF coordinator and then also a reference to the link token interface. So all of those are specified for you on the Rinkbee network here in the example code. And then you can refer to the documentation for whatever chain you're going to be deploying to. And then you're going to see a few new options here.
00:02:52.962 - 00:03:29.822, Speaker A: So the key hash option is the way that you specify that gas lane that was described in the documentation. So depending on the key hash you choose for the given chain you're on, the gas limit will be set differently for your random number request. So for example, on Ethereum main net we have a 200 Gwe key hash, a 500 Gwe key hash, and 1000 guay key hash. You can also see in our contract here that we have a callback gas limit that you're in charge of. So depending on how much gas you're willing to spend in the fulfill random number, you should set this value appropriately. Next up is request confirmations. So this was something in VRF V, one that you could not control.
00:03:29.822 - 00:04:16.538, Speaker A: But here now, depending on the chain you're on, depending on the request and the type nature of the request you want to make, you can actually change this number. And then one of the most important and useful features that gives you a lot more flexibility and control of your VRF is you can actually specify the number of random numbers you want. So you specify the num words and then that will specify how many random Un 256s you get back from the network. All right, here in the constructor, we're going to see an address for the coordinator and address for the link token, and then you'll see that the subscription ID is going to be created as we deploy the contract. And so I'm going to go ahead and get that. So if you remember when we created the subscription, after we funded it, we see the subscription iD. And now when I deploy this, I'm going to use that subscription ID and we've got two methods that should look very familiar.
00:04:16.538 - 00:05:21.294, Speaker A: We've got fulfill randomness method that takes in the randomness that's going to be fulfilled by the VRF Oracle as well as you've got request random words, which is how we're actually going to initiate that request to the oracle. So I think we're actually already ready to go ahead and deploy this. So let's jump to the deploy screen here and select the right contract which in our case is VRFV two consumer and I'm going to make sure that I am on injected web3 so that we can actually deploy to the rinkby network. And I'm going to paste in the subscription Id here and I'm going to deploy let's go ahead and pay for that transaction and as soon as that is confirmed by the network we'll show up here and we'll be able to copy this address and then add that as a consumer and authorize this contract to use my subscription account. So let's go ahead and authorize this with another metamask transaction. All right, we can now view our subscription, we can see how much link we funded it with and we can see our consumer contract. So now by doing this we've authorized our consumer contract to make requests for randomness.
00:05:21.294 - 00:06:05.050, Speaker A: So let's go ahead and make a request for randomness here. So we're going to go back to our contract that we deployed here and we're just going to use the remix interface here to keep things simple and I'm going to request some randomness. So obviously this is going to use all of the configuration that I specified in my contract, just kind of hard coded here. So we're going to get two words of randomness here. So we're going to hit request randomness, confirm the rinkbeat transaction, and then as soon as that transaction comes back we should notice that we actually have a request. And then what we'll be doing is we'll be waiting for the oracle to call fulfill random words on our contract and then we'll be storing all of those random words in this s random words storage variable. Let's go ahead and check to see if our random numbers come back from the oracle.
00:06:05.050 - 00:06:36.214, Speaker A: So I'll go in here into random words and let's request the 0th item of the array. Looks like we've got a random number there and because we requested two random numbers we should also have an item in index one. All right, we've got our randomness there and if we go back to the subscription manager app, you're going to see that there's actually an event history item here. We'll see that. We spent about 00:33 link to get those two random numbers. We've just taken a journey to see what it looks like and feels like to use VRF version two. Give it a try and let us know what you think.
00:06:36.214 - 00:06:38.760, Speaker A: Thanks very much for watching and we'll see you in the next video.
