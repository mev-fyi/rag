00:00:06.240 - 00:00:35.310, Speaker A: You co founder, CEO, Salana. And Salana is the web scale blockchain. So what is webscale? Google coined this term in, like, I think, 2002. Web scale is the entire web, the entire Internet. It's bigger than a single company, a single country. It's the global Internet. And that includes the full 7 billion people plus the billions of devices on there.
00:00:35.310 - 00:01:11.380, Speaker A: So to us, web scale for a blockchain means super high performance. So we're launching a main net, and right now we're in the process of booting this network with an awesome validator like iris nut. And the goal is to demonstrate 50,000 tps and 400 millisecond clock time. Because high TPS. What's the point of high TPS? Like, who cares? Yes. Yeah, I forgot.
00:01:14.040 - 00:01:34.780, Speaker B: Yeah. CEO scale two. Pioneer jiggle. Web scale. Should I go web scale? You should die. So, yeah, die. Ego touching.
00:01:34.780 - 00:01:49.360, Speaker B: So the. Do you gotta. Yeah. Jungle man. Yeah. TPS nurse.
00:01:56.280 - 00:02:26.860, Speaker A: So what's the point of high TPS? Why should anybody care? TPS is really a measurement of capacity. And capacity in a constrained resource means price. So we can demonstrate high TPS. That means we can have a very low price for transactions or gas fees. And our target for price is ten to the minus $5 per transaction, which is 1100,000 of a dollar.
00:02:29.280 - 00:02:51.830, Speaker B: Number. Golf CPS Yogi Wagehore woman. But yeah. So don't be your home. Be knowledgeable, maybe produce $5 or refuse to.
00:02:55.640 - 00:02:56.390, Speaker A: Yeah.
00:02:57.480 - 00:03:00.036, Speaker B: Link and ling ling. Ling ling one.
00:03:00.138 - 00:03:03.150, Speaker A: Yeah. So the one divided by 100,000.
00:03:07.280 - 00:03:08.620, Speaker B: Each niche.
00:03:10.320 - 00:03:47.270, Speaker A: Yeah. And so why would you care about block time? So why do you care about 400 millisecond block time? Because a block means block is kind of a single thing that a blockchain can register. So when you, as a user, you send a transaction to the blockchain, and it registers it in somewhere around 400 milliseconds, it means that your interaction with the chain is so fast that you feel like you're talking to a regular Web 2.0 application, and it's no longer this very slow, terrible experience that we have today.
00:03:51.360 - 00:04:12.060, Speaker B: Just about trying to go to quiet uajo mates, the back of your whole general, uh, web argument.
00:04:15.880 - 00:04:32.500, Speaker A: So how do we do this? Like, what's the secret sauce? It's all open source, so you guys can go steal it. It'll be your problem. But our secret sauce is verifiable delay function that we use as a clock. Consensus.
00:04:35.080 - 00:04:39.270, Speaker B: No issues. So that.
00:04:54.400 - 00:05:40.700, Speaker A: And just the reason why I came up with this and why we're building it this way. I spent most of my career at Qualcomm working on mobile operating systems and working with mobile cellular protocols. Time is a fundamental thing that cellular networks use to increase capacity and scale. It's something that's been around in radio protocols from early 20th century. If you intuitively think about it, you have two radio towers that transmit over the same frequency at the same time. They get noise. So the first thing that people figured out was, why do we give everybody a clock that's synchronized and we take turns by time when we transmit it? And therefore, you don't have noise and you can increase the capacity of the network.
00:05:54.480 - 00:06:29.484, Speaker B: Formal against. Yeah, but woman said you don't. Shooting the shujian Rahul round. One go to the may go. May found and go like y'all show to go. One go to the twins jiggle Indian. The show don't show yoga Indian tattoo say how number.
00:06:29.484 - 00:06:49.780, Speaker B: You know don't. So you haven't family, but yeah. Tony go king.
00:06:52.360 - 00:06:59.690, Speaker A: So challenges of your networks. Consensus is slow, latency is high, throughput is low, and our goal is to fix all three.
00:07:04.460 - 00:07:10.360, Speaker B: She on the map to to be on map.
00:07:12.080 - 00:07:44.996, Speaker A: So what is a verifiable delay function? It's a function that takes fixed amount of time to execute, and the time to verify is less than the time to solve it. There's functions that might be much, much less, as in they take less than the log of time to solve the polylog. And then there's functions that take the same amount of computational power to solve, but you could parallelize the verification and.
00:07:45.018 - 00:08:01.820, Speaker B: Therefore speed the circuit the machine show Yamshu putting the shin like this jiggle.
00:08:15.380 - 00:09:00.860, Speaker A: So we use the kind of function that requires parallel verification. And our implementation is a very, very simple one. So, shot to 56 is the same function that bitcoin uses for mining, but instead of running it in parallel, you take its output and use it as the next input so it's run sequentially. And therefore, that process of the sequential generation requires real time to pass. It cannot be parallelized. But if you record the count and the state as you're doing this and you sample this process periodically, you can take the start and end of every sample and run that on a different core. So an Nvidia GPU card for 4000 cores can verify a second worth of samples in a quarter millisecond.
00:09:15.800 - 00:09:48.456, Speaker B: Benjamin woman, you want to go don't measure, but may sudden output input. So you have he by one. Gosh.
00:09:48.648 - 00:10:28.420, Speaker A: So you can use this data structure as a clock or as a source of time. And how you can do this is you take any one of these samples, and it guarantees that if you include that sample in a message that you sign, it guarantees that the message was created after that sample was generated. Right. If you take a bunch of these messages and you hash them into this process, and you record that you did that, because it modifies this single threaded shot to 56 loop, it guarantees that this message was created before that modification. So now you have an upper and lower bound of time when these messages were created, relative in the clock, in this data structure.
00:10:30.520 - 00:10:31.270, Speaker B: You.
00:11:05.480 - 00:11:35.980, Speaker A: So that's the same kind of thing as in the real world. You take a picture yourself with a newspaper like the New York Times, and that proves that you existed sometime after that New York Times was published. But then the next week, the New York Times publishes that photo in the newspaper, and that guarantees that you existed before that publication. Right? So now that you have the photo and the next newspaper, you have this guarantee that you were alive sometime before and after those two newspapers.
00:11:45.800 - 00:12:10.890, Speaker B: Pouches. Rahul Krie jamming woman PI jumping to be. Don't be arpian and woman Pijai shiva chubba. Just. Yeah, no more you should. Yeah. So don't do your.
00:12:15.040 - 00:13:01.804, Speaker A: Cool. So, imagine you're in an island somewhere, and a bottle flows by and there's a thumb drive in it. You plug it into a computer, and you see this data structure of hashes, of messages. You can take a look at this data structure alone and verify all those hashes, and then compute the state of the network from the data alone, without actually having any peer to peer messages with anyone else. Because when you look at this data structure, you can see votes in the structure, and then you can compute that, let's say, in the last ten minutes worth of this data structure, parts of the network voted and parts of it didn't. And that gives you a view of the network itself. And then you can decide whether to confirm this ledger or not.
00:13:01.804 - 00:13:07.710, Speaker A: Right? And you do this just from the data alone, without any communication with anyone else.
00:13:08.720 - 00:13:56.860, Speaker B: Yeah, sure. So you go fully pinning Johnny, but you pan even. But you panhy and go to go hardly. So, see, now can you kind she can shoot you, but shrink Hansu or push you outside, don't, you know, even so the top how the thing she so and so, the shoes. You so don't even give it one quick kind of so don't see you JC shows you like children to jump.
00:14:01.760 - 00:14:38.360, Speaker A: So that property gives us a very nice, very simple way to compute the safety of the ledger. Right? Safety meaning, is everybody else voting on this? And should I vote? So is this ledger safe to vote? Well, in the last ten minutes, Bob and Charlie and Dan voted and Alice didn't. But that's three fourth of the network, and therefore, this ledger is safe for me to vote on. And I can take the last sample that was generated in this data structure, create a message that includes it, sign it, add it to the thumb drive, and throw the bottle back in the ocean.
00:14:41.280 - 00:15:08.820, Speaker B: So function like this one. Jiggle, junk, jump, and the ancient sing. You should know Jung should be so. Yeah, don't forpel. Sometimes you click and Bob, Charlie, Alex, milk. So you just koi kind. Yeah.
00:15:08.820 - 00:15:14.950, Speaker B: So Jung choi on the soho ti team. Yeah.
00:15:21.420 - 00:15:37.100, Speaker A: So we have time that can be cryptographically verified, and we have guaranteed that the ledger took real time to generate, so it can't be fake. And we can use this property to also have very nice assumptions about liveness.
00:15:41.680 - 00:15:51.630, Speaker B: Woman show you. Woman Shu Yong. Yummy. The function. She Yin Jin Jin Shujano. And she know. But.
00:15:54.800 - 00:16:46.030, Speaker A: So how do we actually produce blocks? Well, bitcoin does this process where blocks are randomly produced, and that's why there's a difficulty that forces the network to only produce one block, on average every ten minutes. But because we're trying to get to 400 millisecond blocks, what we do instead is we schedule the leaders ahead of time, the block producers. So in this example, Alice, Bob, Charlie, and Dan, as block producers, take turns appending messages into this sequential hash based ledger. And how do they know when it's returned? To append, it's based on the actual count of hashes. So for Bob to append to the ledger, Bob needs to generate a ledger up to hash 3000. And therefore, real time has to pass.
00:17:20.480 - 00:17:34.860, Speaker B: Shaker jiggle. Hash comes to Hashi, but to go beyond. But how San Diego should waiting.
00:17:35.440 - 00:18:43.960, Speaker A: Um, so how do we actually vote and make sure that this ledger and this network maintains liveness? So, like tendermint, where you have these specific state transitions between propose, pre commit, and so forth, what we use is time, in terms of hashes, of how long a particular vote lasts. So every time you vote, you have a commitment to safety for a short amount of time, or about two slots, but every time you vote, your previous commitments double. So now, as you're voting, this exponentially growing function forces safety to converge. Right? So, because after 32 votes, you have a commitment to safety for two to the 32 slots. So if every slot is born a millisecond, that's about 50 years and effectively forever. But this should also tell you that liveness is almost trivial to prove because these votes eventually expire and then you can unroll and take a different fork.
00:18:46.380 - 00:19:35.270, Speaker B: Number 40 so tender makes you know, like yo shu top yo and they will show ten times he may talk to me to yeah, good power join yeah good slot the jigga and chin jaw food surrender and yeah honey Jubilee thousand jiggle commitment jiggle fake number one to hold on to but yeah, forgive us, but now my ego spot teaching. And so.
00:19:40.040 - 00:19:58.620, Speaker A: Actually, here's the example of it actually working. So you have a network. There's a partition, and partition one is kind of moving along and voting and then partition two starts producing blocks and partition one is locked out until its votes unroll and then it can synchronize.
00:20:03.120 - 00:20:15.380, Speaker B: And shit number die jiggles district.
00:20:22.920 - 00:20:24.930, Speaker A: And that's basically it. That's the whole thing.
