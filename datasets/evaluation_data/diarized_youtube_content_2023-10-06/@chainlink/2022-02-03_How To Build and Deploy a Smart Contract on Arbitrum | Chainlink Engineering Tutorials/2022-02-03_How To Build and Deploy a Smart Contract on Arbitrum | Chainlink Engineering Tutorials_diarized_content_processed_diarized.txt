00:00:06.490 - 00:00:53.050, Speaker A: Hello everyone. My name is Andre and I'm a blockchain engineer and developer advocate for Chainlink protocol at Chainlink Labs. In this technical tutorial, we will cover how one can build hybrid smart contracts and defi apps on arbitrum using Chainlink price feeds. But before we start, what's exactly is Arbitrum? Arbitrum is one of the optimistic rollups on Ethereum. At the moment. Transactions are expensive and slow on Ethereum, and because of this, there are several different scaling solutions, including L2 rollups, state and payment channels, sidechains, plasma and validium. The most important difference is that rollups and state channels inherit the security of layer one or ethereum blockchains.
00:00:53.050 - 00:01:34.060, Speaker A: That basically means that one builds on top of layer one, and that's why they are called L2. Layer two roll ups are composed of optimistic rollups and Ziki roll ups. They are both through L2 solutions, which means they execute a bunch of transactions very fast and very cheap on L2 and then verify that bulk of the transactions on layer one with optimistic rollups. We optimistically believe that these transactions really happened on L2. These roll ups are optimistic because the bundles are considered innocent until proven guilty by fraud proofs. So let's dive right in.
00:01:34.430 - 00:02:29.770, Speaker B: So arbitram one, as I said, is the L2 of the Ethereum mainet. We are going to cover the development on arbitrum testnet, which is a L2 for rinky by Testnet, but the same applies for Mainet later. Of course, the whole working example is available at this GitHub link. So you can just clone it and just clone it and start working with it. So all the instructions are in the readme file, but we are going to cover the development step by step. So the first thing, because arbitrum testnet is a L2 testnet for rinkabyte testnet and arbitrum one mainet is a L2 for Ethereum mainet. We first need some rinkabyte testnet.
00:02:29.770 - 00:03:09.846, Speaker B: So first we need to go to fossils chain link and grab some rinky by testnet. Okay, so here I'm going to switch to rinkyby testnet, grab my testnet account, select here rinky by testnet, paste my wallet account, and select 0.1 test eth. I need to go through this captcha. So select all these images. Good. And now I'm sending the request.
00:03:09.846 - 00:03:49.314, Speaker B: Here is my transaction hash. I just need to wait for confirmation. And that's pretty much it. So at faucet chain link, one can grab a lot of test tokens from various different networks, not just rinkyby. Okay, the request is completed. I can just check this transaction hash for a moment. So it's still pending on etherscan.
00:03:49.314 - 00:04:37.770, Speaker B: Etherscan needs some time to grab it, but if I go to my metamask, I can see that I got all of these test coins. Okay, the transaction was successful. Good. Next thing. So we need to deposit now these ethers from rinkibai to arbitrum testnet on rinkibai. So we need this to bridge these test eaters in order to pay fees on arbitrum L2, testnet. So to do that, we need to go to arbitrumbridge.
00:04:37.770 - 00:05:23.582, Speaker B: So this is bridge arbitrum IO network. I'm just log out to see the whole flow. So I need to connect my metamask wallet and boom, we're connected. Just wait a couple more seconds. Okay, we are connected. You can see my balance on rinky buy and also my L2 balance because I already bridged some tokens during making this repo. Okay, so to bridge these tokens, I need to select some amount of tokens.
00:05:23.582 - 00:05:43.930, Speaker B: I will bridge whole amount. So I get from the faucet 0.1 and I need to click just deposit. And that's it. Okay, this is like info message. It will take ten minutes. Would you like to proceed and just need to click deposit.
00:05:43.930 - 00:06:26.040, Speaker B: I need to confirm my. So you see here, this is a rinky byte test network transaction. Click confirm, and we now have appending deposit l one transaction. The bridging was a success. We have this amount of test arbitram ethers on ring carbohydrate testnet. But in order to see it in metamask, we need to add arbitram rinkab testnet as a new network. So go here.
00:06:26.040 - 00:07:20.600, Speaker B: Now select settings networks and then add arbitram testnet with these parameters. So arbitram testnet Rpc URL is HTTPs rinkiby arbitrum IO RpC chain id is four to 1611. So four to 1611 optional parameters. Symbol is currency, symbol is eth, block explorer URL is testnet rbscan IO. Save this and then you can see your coins on arbitrum testnet. So this is arbitrum testnet. This is our L2 amount.
00:07:20.600 - 00:07:53.570, Speaker B: Nice. Now that we have some arbitrum eaters. Lastly we can go to this fossils chain link. I will just refresh it to see this default page. And then you can see there's arbitram rinky by testnet. So if I choose arbitram rinky by testnet and paste my wallet address. Again solve this capture.
00:07:53.570 - 00:08:56.470, Speaker B: I can request ten testnet link tokens from this faucet on arbitram rinke by testnet this is on arbitram rinky by testnet now we can start coding. We can start by creating a new solidity project in your favorite code editor. As I said, the fully working example using harhead with typescript is available on this GitHub repo. So feel free to check it out. But for purpose of this demo I'm going to use remix id. So this is a remix id. I created a new workspace, I will going to create a new contract and I will just name it price feed consumer on arbitram or price feed consumer v three whatever.
00:08:56.470 - 00:10:11.954, Speaker B: So price feed or this is even better, arbitram price feedconsumer sol we have a new contract. So if I go to this page in the documentation, so using data feeds I can grab this solidity boilerplate code for getting price fits. But I will adjust it a little bit so we can grab for now this solidity version and import chain link tracks from chain link contract aggregator wave three interface. Our contract name is contract arbitrum price feed consumer. And I will zoom this a little bit so it can be easily to follow. Okay, now it's easy to follow. Nice.
00:10:11.954 - 00:11:50.130, Speaker B: So if I compile this, everything should work in fine. If I selected a proper version of compiler and I did now the next stuff. So as I said we are going to use this sample but I will arrange it just a little bit so I can just grab this function return to get latest price it's a view function and now inside this function I will do something like this. So aggregator v three interface price feed is aggregator v three interface and I will pass here address price feed address and price feed address price feed let's price feed. It should working fine in a docs. The price feed is hard coded in constructor but with our solution we are passing it as function parameter and now we can query all of the available price feeds on arbitrum. So if I go here arbitrum data feeds, I can see all of the addresses on Mainet, both on mainet but also on arbitrum rinkabyte testnet which we are going to use right now.
00:11:50.130 - 00:12:56.914, Speaker B: Okay, next stuff. Now that we have our basic get latest price function, what I can do, I can pass this address for example. So this is eth in terms of USD as like parameter of this function. So if I just create a comment section here and I can just specify it like this. So the network is arbitram rinkabi and aggregator. As I said, aggregator is ETH USD, and the aggregator address is the one that I copied right now. So I'm not going to hard code it inside the constructor, but I will pass it as an argument.
00:12:56.914 - 00:14:14.750, Speaker B: And this is just as an example. I can use all of these bright feeds for arbitram rinky by, but this is not everything. We're almost done, but before finishing, let me present to you l two sequencers health flag so optimistic. Rollups keep all execution off chain and keep all transaction data available on chain using a special off chain component called sequencer. So what is this sequencer? The sequencer executes and rolls up all the L2 transactions by batching them into a single one on layer one. If sequencers becomes unavailable, it becomes impossible to access APIs that consumers are using and only experienced developer will know how to interact with the contracts, which will be unfair. Because of that, we need to include because of that, we need to include an extra track in our solid code base for this tutorial.
00:14:14.750 - 00:14:56.790, Speaker B: This doesn't mean that the L2 network has stopped. This is just important not. So to do this, we need to import this line of code. We need to import flag interface. Okay, and we need to, according to this doc, we need to expand our contract with the next line. So we need this. And I can just put it as a constant right here.
00:14:56.790 - 00:15:31.630, Speaker B: Okay, address constant private this is all good. This is flag arbitrary sequencer offline flag. Okay, this is a flag to notice if a sequence is offline or no or no. Next line. We also need this. So flags interface, internal chain link flags. Perfect.
00:15:31.630 - 00:16:10.564, Speaker B: And I need to do something like this in a constructor. So constructor chain link flags equals flags interface. And we need a value. So if I go back to sequencer, okay, so flag address is this one. I can just put it in this comment to have it here. But this is the flag interface. Sequencers for arbitrum rinkibi testnet.
00:16:10.564 - 00:17:14.550, Speaker B: Okay, so this is on arbitrum rinkibai. You can see in the official docs that they also did this in a constructor. And the final track we need something like this. So I'll just copy paste this code and then I will explain to you why we are doing this. Okay, copy paste boolean is raised. If the flag is raised, we shouldn't perform any critical operations because the sequencer is down. So a raised flag will determine that the feed wasn't updated in some amount of time, t, for example, and its data can be considered stale in other words, the sequencer went offline and your contract shouldn't perform any critical operations.
00:17:14.550 - 00:17:54.602, Speaker B: When the sequencer comes back up again and the L2 chain link data feeds are updated, you can continue using your contracts as usual. So this extra check is final step to create price feed consumer on arbitrum. And that's it. We are all done. I can just zoom out this so you can see the whole code base again. But yeah, this is it. This is our whole code base for this tutorial.
00:17:54.602 - 00:18:31.580, Speaker B: Last step is to deploy this to testnet. If I go to select injected to web, just need to I'm on arbitrage testnet. I have this amount of test token, should be working fine. If I go to arbitram price with consumer I can just deploy it. I need to sign this transaction. This is a contract deployment. Confirm it.
00:18:31.580 - 00:19:14.668, Speaker B: Transaction is confirmed. Okay, this is the price with consumer. And last step, I can just query for ETH price in terms of USD on arbitrum and I got it. I just need to zoom this a little bit so you guys can see this. This is the current price of ethereum in terms of USD on arbitrum. Rinky vibe. So thanks everyone for following this tutorial.
00:19:14.668 - 00:19:18.670, Speaker B: I hope you find it interesting and useful and see you around.
