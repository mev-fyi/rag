00:00:13.690 - 00:00:14.560, Speaker A: Is it started?
00:00:15.490 - 00:00:20.670, Speaker B: Yes, it started. So let's just give it like 30 seconds. Let some people pull in here from discord.
00:00:21.170 - 00:00:21.870, Speaker A: Perfect.
00:00:22.020 - 00:00:48.430, Speaker B: Welcome, everyone. Really excited to have Dave from the graph joining us today. We'll give it just a, a few moments. Let's. When people join in, let me share this in our channels. And where are you calling in from today, Dave?
00:00:48.850 - 00:00:50.570, Speaker A: I'm in Toronto, Canada.
00:00:50.730 - 00:01:11.874, Speaker B: Nice. Okay. Yeah, sweet. Welcome. All right, well, yeah, without further ado, really excited to welcome Dave from the graph joining us today. Again, if you have questions throughout this, drop them into the YouTube channel. If there's time at the end, we'll be able to answer those.
00:01:11.874 - 00:01:25.580, Speaker B: If not, definitely just drop your questions into the graph section on the discord and we'll be able to get to those and help you all with your projects. Otherwise, love seeing all the excitement of the discord. Really exciting times. And Dave, I'll let you take it away.
00:01:26.430 - 00:01:59.758, Speaker A: Awesome. Thanks a lot, Keenan. So, yeah, I'm here today to talk about how you can use the graph and what the graph really does and explain what you could do in the Chainlink hackathon. I'm sure many of you who will be watching this video are aware that the chain link hackathon is happening right now as you signed up for it. And there's all these sponsors and all the subscriptions here. And you can find here that the graph is actually doing a $5,000 prize. And it's actually five different prizes of $1,000.
00:01:59.758 - 00:03:05.490, Speaker A: And so just to start off describing what those are, the five prizes are going to be for five different blockchains that could be powering any blockchain network, such as Ethereum or Phantom, or using IPFs as well. Basically, anything that the graph works with and the types of subgraphs we are looking for, the five that are each worth $1,000.01 would be just the best new web three subgraph, the best NFT subgraph, the best DFI subgraph, the best governance subgraph, and the best subgraph using chain links oracles. So that's kind of what you can expect to see if you're going to submit a project using the graph. If you use one of those, you could win a prize as well. If you somehow incorporate both of them, you could also win two of those prizes right there for sure, as well as whatever other prizes are going on in this hackathon. I'm sure you're allowed to combine them as well, but that's a little bit of a download of what you can win for this hackathon.
00:03:05.490 - 00:03:47.926, Speaker A: And now let's get into the details of what it means to build a subgraph and how you can do it. So if you guys have heard of the graph before, you can go to the website thegraph.com and there's a lot of explainers there. You can download in your mind what the graph is. But today what we're going to go over is mainly just developing subgraphs, and I'm sure I'll be able to give a lot of information about what the graph is overall. But we're going to focus on just developing the subgraphs and writing a little bit of code to show you to get yourself off the ground with an example that you could use if you're going to build and hack in the hackathon and use the graph. So what you want to do is go to the graph.com
00:03:47.926 - 00:04:10.974, Speaker A: and then go to docs, and once you're there, you're going to see these two sections, the hosted service and the network. And so the network is focused on the main net and all the indexing and delegating and actually doing transactions on chain. So we don't have to worry about that. For this hackathon. What we want to look at is the hosted service. So we're going to click into there. And first I should describe what the hosted service is.
00:04:10.974 - 00:05:13.950, Speaker A: So the graph network is a decentralized network that does basically indexing on top of a bunch of different blockchain networks. And it works in a decentralized manner in that there are many different nodes around the world, which we call indexers that are indexing all this subgraph data and then allowing users to query that data. Now, the network that is live on Mainnet right now is still very new and there's only one subgraph there, and we're not really dealing with that for the hackathon. What we're dealing with is the hosted service and being able to submit a sub graph to the hosted service and see it working. Basically technically, the subgraph you build for this hackathon could end up on the main net in the future. But this is just kind of like when you're doing a hackathon, you're usually going to hack something together and put it together, hack something together quickly, and the hosted service lets you do that so quickly. I'm going to leave the docs for a second and go to the explorer.
00:05:13.950 - 00:05:51.774, Speaker A: And this is basically the hosted service. And what it does is it has all of these different subgraphs which contain a bunch of different blockchain data and they're available for the community to look at and to use and to explore data from. So if you go to the Uniswap subgraph, you'll see that there's some high level information here and then there's all these different entities on the right side. And this is a graphql schema. And then we're actually querying the data from the subgraph right here. And if you press that, you're getting data back from the blockchain. And so this is what the hosted service is.
00:05:51.774 - 00:06:41.450, Speaker A: It's really a playground that allows you to see all this information. It's very rich and very human readable here as well as you can query the hosted service directly and get all its information. And you could do thousands or tens of thousands of queries and get historical data or do some data analysis for specific prices. And so that's what the hosted service really is. It's a place where anybody can go deploy a new subgraph that they want to play around with or get other people to use. And as you can see, these top ones up here, these are all featured subgraphs that we want to put up front because they get used a lot and then they have a lot of good information. And if you scroll down, there's all the community subgraphs here, which is basically anybody can upload a community subgraph.
00:06:41.450 - 00:07:29.742, Speaker A: And we're going to do an example of that today. And once you're doing that, a subgraph creates an endpoint. So you would essentially query this URL, and when you query that URL, you would send in the payload, maybe this specific query, and then you're going to get back this payload from the subgraph. And so that's really what the hosted service is. It allows you to use the graph, it allows you to get any blockchain data. And it's a service that we provide and it's all free as opposed to the network itself, the main network, which would obviously cost money to query, but we don't have to get into that today. So that's the hosted service.
00:07:29.742 - 00:08:12.250, Speaker A: It's this free service that allows you to build subgraphs, deploy them to there, and to actually start using the graph. And so when we go to docs, we're going to quickly go to defining a subgraph. So this is going to get into the details a little bit of what a subgraph actually is and what it does, and then you'll be able to understand what you can do with it in the hackathon. So really a subgraph it's index of data from Ethereum. But really we're adding multiple blockchains. Every month we're adding new blockchains. And that's the goal of the graph, is to be blockchain agnostic, to be multi chain, to include every chain that the community wants.
00:08:12.250 - 00:08:57.066, Speaker A: And that's ultimately the goal. And so now that's what a subgraph is supposed to do, is take specific subsets of blockchain data and define them really well so that people can use them. In a sense, it's like a subgraph is an open API that you can rely on to return specific data that you expect to be returned. And so what we've done with the subgraphs is we split them up into three different, three different pieces of code that really define a subgraph. And they're the manifest, the schema and the mappings. And so there's a lot of stuff here that is definitely worthwhile to read. And I'm going to go over a lot of it in more so of an example.
00:08:57.066 - 00:09:37.270, Speaker A: But we're going to skip straight to the subgraph manifest right here, which is really like the instruction manual for a subgraph. And how it works is if you look at all the blockchain data in the world from every single blockchain, bitcoin, Ethereum, all of them. And then what we're trying to do is compress it into a specific subset of data that you as a subgraph developer wants to look at. So if you look at, that's essentially what the manifest does. So if you look at this file right here, it's doing a few things. It starts to identify data sources. Okay, so that's the data that we're going to ingest into the subgraph.
00:09:37.270 - 00:10:17.694, Speaker A: What kind? And this is an Ethereum contract. So already we've decided that it is the Ethereum blockchain and it's a contract. And now we've also defined that it's going to be from the main net, Ethereum blockchain, as opposed to Robson or rinkby or something like that. And then we keep going down even further. And now it's, what's the source? And it's this address that's on chain zero X two, e six. And we start indexing it at this block. And so what we've essentially done there is we've taken all the possible ethereum networks, all the possible blockchains that the graph can index.
00:10:17.694 - 00:10:57.534, Speaker A: And we've decided, okay, just going to go with Ethereum, just going to go with Mainnet. And we're going to go look at this specific smart contract on the blockchain. So that's how far we've narrowed it down. And now we can narrow down even further and look at specific handlers or specific events on that blockchain and then write handlers for those. So we have these things down here called event handlers. And if you guys are familiar with solidity, solidity contracts can emit events which are essentially just objects of data that get emitted. And it makes it easy for people external to the blockchain to consume and understand what happened.
00:10:57.534 - 00:11:43.838, Speaker A: So events are used very frequently when you're designing a subgraph, because most of the time, a smart contract developer will create events that emit the important information. And usually you can build a subgraph from just using event handlers. Sometimes, though, there might be situations where you need specific information from a call handler. So this would happen when a specific function is called on a smart contract. So in this case, they're saying the create gravitar function. And so maybe when that function is called on the smart contract, the event that gets emitted, when that function runs, didn't have all the information you needed. So in some cases, you're going to have to just actually run a handler over top of when a function gets called.
00:11:43.838 - 00:12:52.754, Speaker A: And so what's happening is we're tying the information we want to pull from this specific contract from function calls or events that are emitted. And then when we get that, we get that specific data from that event or that function, and then we can store it into the subgraph. And the subgraph is essentially a database that it stores all this information from the blockchain and organizes it in a way that you want to organize it. And so, as you can see, we've just been able to really what the subgraph manifest lets us do is pinpoint the exact type of data that we want. And that's what's so powerful about the subgraph manifest. When you look at a subgraph, if you want to go explore some of the existing subgraphs today, like the Uniswap subgraph, or even like any chainlink subgraph that exists, you would want to look at the manifest first, because it's going to be the most straightforward way of telling you what information this subgraph is grabbing from blockchains. And if you're a subgraph developer, it's probably going to be one of the first things you figure out and define like you're going to be looking at Chainlink smart contracts.
00:12:52.754 - 00:13:53.974, Speaker A: You already know you almost have your subgraph manifest written, you might have to find the specific smart contracts that you want from Chainlink. There could be maybe three different smart contracts on Ethereum mainnet that you want to get the data from that are all part of the Chainlink protocol. So then this manifest would have three different source files, right? But essentially, yeah, if you know what you want to index, you can pretty much build your subgraph manifest very easily. Now, the next part that is worth getting into is the graphql schema. And so we've defined what data we're getting from the blockchain, and what the graphQl schema really does is it allows you to define how you want to store that information in your subgraph and the order of how you want to store it, if you want to add any rich information to it. And we can look at this example down here to see what exactly a graphql schema is. And this is a very simple entity type.
00:13:53.974 - 00:14:31.278, Speaker A: It's basically an entity, an object, whatever you want to call it. But we're naming this type gravitar. And so gravitar is an example. It's a super simple smart contract, and we're actually going to use it for the example that I'm doing today, and we'll see how it ties into the subgraph overall. But we're storing this entity in the subgraph and it's basically an entity or an object with five fields, one being a unique ID, which every single entity in a subgraph needs. And then there's four fields here that are determined from the subgraph or from the smart contract itself. And likely these are emitted from events.
00:14:31.278 - 00:15:25.910, Speaker A: And so you'll have the event emit something like an owner, and that's going to be an Ethereum contract or an Ethereum address. It's also probably going to emit a display name and an image URL, and whether or not it's been accepted. And so when we get that information, we're going to store it with mappings, and you'll see that very soon. But essentially what the GraphQL schema is, is it's a pretty straightforward kind of way to store information. And GraphQl is something that was developed by Facebook and has been around for multiple years. And there's actually a lot of documentation on GraphQL external to everything. We're giving a little bit of information here, like the supported scalars that we have, but there's a lot of graphQl information out there in the world that you can definitely dig into and learn about the proper syntax and the proper best practices to follow when using GraphQL.
00:15:25.910 - 00:16:25.370, Speaker A: And there's more information here. We have relationships that can be written into the schema and reverse lookups. So it makes it easier, because at the end of the day, the graphQl interface that we build on top is connecting to the subgraph, which underneath is actually a postgres database. So this is all interesting stuff that you don't really have to understand completely if you're designing a subgraph, but it is like kind of the important details of how it works underneath. And then after that, this is also part of GraphQl is the queries that you have to write in order to get that information from the subgraph. And you saw that in the playground that I showed earlier, where there were just example queries for like the uniswap subgraph and the other ones as well. So that's all really useful information.
00:16:25.370 - 00:17:06.920, Speaker A: It keeps on going. I invite you to read more about all the documentation here if you're going to build a subgraph. But the next important thing to share is writing mapping. So at this point, we've used the subgraph manifest to get the specific data that we want from all the blockchains that can be indexed. And then with the graphql schema, we've decided how we want to organize that data. The last major thing to do is to write the mappings and what mappings are. They're essentially just whenever an event is triggered, or event is emitted on chain, one of these mappings gets triggered and the mappings are doing.
00:17:06.920 - 00:17:38.810, Speaker A: It's basically mapping over the information that's being admitted from the event and storing it in the subgraph somehow. And you can see it here. So these are all written in typescript. If you want to be a subgraph developer, mainly you need to understand typescript and graphQl. It would also help to be able to read and write solidity. But solidity is even not that complex of a language to read. So even if you can just read solidity, you can be a subgraph developer as well.
00:17:38.810 - 00:18:35.342, Speaker A: And you don't have to be a prolific solidity developer. So that's really good news for anybody who just understands GraphQl. And even if you just understand typescript or JavaScript, you would be able to make good progress on a subgraph, because a graphQL schema could end up being very simple if you're just building a simple subgraph. And so what these mappings are doing, there is an event called new Gravitar that is being emitted on chain by a smart contract and there's this handler that gets run. And what this means is whenever this event is emitted on chain, this block of code is going to get run. So we're going to create a new entity which is the gravitar entity, give it its unique ID, and we're going to set these three fields that belong on the entity. If you remember up in the graphql schema, these were three of the fields that were required to exist on the entity.
00:18:35.342 - 00:19:28.082, Speaker A: So what we're doing is we're setting the owner and this is simply an event field from the event that's emitted from Ethereum. And we do this for all three of them. We set the owner, we set the display name, we set the image URL, and then we store the entity in the subgraph with the save function. And essentially right there, this is a subgraph in a nutshell is a bunch of these mappings running over and over again from block zero to block 12 million or whatever Ethereum is at, or whatever. If the smart contract that you're looking at was deployed on block 10 million, you're going to start there and you're going to index the next 2 million blocks that have existed. And over time this smart contract exists on chain and it's emitting events and it's emitting events. And every time these events get emitted, these handlers are run.
00:19:28.082 - 00:20:29.270, Speaker A: And that's storing information in the subgraph which is then available in the graph network and can be queried by anybody through the whole entire open API system. And there's a lot of information about, you might notice, like the dot save and all this stuff in two hex. These are basically functions that we provide to help write the mappings. And ultimately the mappings are written in typescript or assembly script, which is a subset of typescript and assembly script actually compiles down to wasm. And then these wasm files are uploaded to graph nodes, and these graph nodes actually execute all these function calls and run the subgraph essentially. And those are details you don't really have to understand. But if you're going to write mappings, you're obviously going to have to understand some of the patterns of like using two hex and using this kind of handler where if it's null, you're going to create a new object or a new entity.
00:20:29.270 - 00:21:25.654, Speaker A: And all these details are really provided in here. As you can see, the documentation is very long. I invite you to read all of this. We've been working on it for years and it's been refined very well. And so it's very clear and it'll help you build a subgraph. And if there's anything that isn't clear in the documentation, I invite you guys to come to our Discord channel where we have a ton of different channels here for people that are coming to learn about how to use the graph. And if you're doing a hackathon, some of the channels that are really good to come to are the subgraph development one, the hosted service one, the hackathon one, and there's a few others that you could join in as well and just come in there, ask us if there's any questions that you have and ask the community as well.
00:21:25.654 - 00:22:13.834, Speaker A: There's a lot of people who don't work at Edge and node or who don't work at the graph foundation who are just part of the community, who also help out a lot of the time. So it's super vibrant community and there's a lot of people who are happy to help out with developing subgraphs. And so what I'd like to do now is get into an example of developing a subgraph. And we can do that by going to the explorer and clicking on if you're in the explorer you're going to have to create account which is essentially just linking your GitHub through oauth. And then you get to your own account and you see all these past subgraphs you've made. I'm going to create a new subgraph and now you're on a page. You got to give your subgraph a name.
00:22:13.834 - 00:23:17.646, Speaker A: So I'm going to name it Chainlink Hackathon two because I have one that is named Chainlink Hackathon from the past and we're just going to give it a subtitle title because it's required and you can provide a description if you want in a GitHub URL and you can also hide the subgraph if you want. This just means it won't be shown publicly. And so I'm actually going to hide this because it's just going to be a practice subgraph that not too many people will be interested in. So I'm going to create this subgraph and I've created it in the hosted service and now you're provided with this page and essentially it's created but this subgraph has not been deployed to the hosted service yet. So what we're going to have to do is just follow the commands here and they're actually very straightforward. So what we need to do is install graph CLi onto your computer. We're going to do a global install.
00:23:17.646 - 00:23:51.670, Speaker A: So you just copy it by clicking this button here. And I'm going to go to my terminal and so I just paste that yarn globalad graph protocol graph cli. And so this installs that. We go back to here. So I've finished this command, now we go to the knit command. And this is basically setting up a hello world subgraph that allows you to index data off the Ethereum mainnet. And once you have this set up, you'll be able to change your subgraph in order to index other data.
00:23:51.670 - 00:24:48.538, Speaker A: And it kind of is like a really great starting point for anybody who wants to create a subgraph. And so now we have this information here, right? So this is how you basically start that kind of boilerplate subgraph, copy that command. And now the directory I'm going to make is just called Hackathon. And now here I want to do the subgraph name, which is chain link hackathon two, which is the one that I just created and now just my GitHub username. And this command will now be run and it usually takes about 30 seconds here to set up the whole repository. So what it's doing is it's just generating a bunch of different subgraph boilerplate code that allows you to get a project started right away. And ultimately this is the gravatar example.
00:24:48.538 - 00:25:49.614, Speaker A: And it's going to be really easy to deploy or to the hosted service and you're going to see all this happen in the next 1020 minutes. And it's really good, it's really easy. And then what I would recommend people do is take this exact process, do it, but then start replacing the files and the information with the specific information that you want to build your own subgraph, which could be using Chainlink or using Aave or using their contract, something like that. Right? So now we have this folder built. If we look, there is a folder called hackathon, and if we go into there and open it up with vs code, you're going to see all these files here have been auto generated, which is really great. And before we get into that, I just want to head back to the Explorer. And now it also wants me to run yarn install on yarn code gen.
00:25:49.614 - 00:26:32.630, Speaker A: So that's actually really easy to do. Perfect. Yarn code Gen. Perfect. And then the last command is to deploy and we'll do that after I look at the smart contract code here and all the subgraph code. So now we're back in the, this is the auto generated file or folder that gets created on graph knit. And now I'm going to step through a lot of these files so you can understand what's going on and use this boilerplate code to build a more interesting subgraph that you're going to use for this hackathon.
00:26:32.630 - 00:26:51.818, Speaker A: And quickly, I'm going to go over all the files that I just explained through the documentation. So this is the subgraph manifest that I was talking about before. And as we can see again, we look at the data source. Okay, great. There's one data source. It's an Ethereum contract. We've named it gravity.
00:26:51.818 - 00:27:23.394, Speaker A: It's on the Ethereum main net, and it has this Ethereum smart contract address, and it has two event handlers. And that's pretty great. It's pretty straightforward. Some of the other stuff I haven't talked about before is this Abis thing. So every single smart contract on Ethereum has an ABI associated with it. And what we're doing is we're connecting this ABI to the subgraph. And an know essentially contains all the event signatures and the function signatures.
00:27:23.394 - 00:27:55.106, Speaker A: And it's all kind of know messy right here, but I can organize it like that. And you see it's a little bit more of an organized json file, but you just have to get in the abis for any smart contract that you want to look at. And that's when some of this code gets auto generated. So that ABI helps us create this generated code. I'm not going to get into that here because that's code you're not really supposed to touch. It's just auto generated and you use it in the mappings. But let's look at some of this other code here.
00:27:55.106 - 00:28:32.630, Speaker A: So we've kind of described the manifest and how it works. Here's the graphql schema that I was talking about before. Right here we have one entity called gravitar. And gravitar is just like the smart contract itself is just kind of like an object that has an ID, has an owner, has a display name and an image URL. So it would be like a little circle that you see in a website somewhere. Kind of like an account, right? Like similar to this. You have your face and maybe like your name.
00:28:32.630 - 00:28:53.282, Speaker A: That's all gravitar is trying to do. It's just trying to be a simple way to represent like an account. And so that's all this graphql schema is doing. It's really simple. Sometimes you might see a subgraph manifest. That's a couple hundred lines long. A subgraph schema could be a couple hundred lines long.
00:28:53.282 - 00:29:30.654, Speaker A: And then what you're going to see in a little bit is the mappings can actually be thousands of lines long for a really big subgraph like uniswap. And we'll get into that in a second. But yeah, that's the subgraph schema and the subgraph manifest. Then I'll quickly go over all these files you see here. These are basic, just project files like git, ignore, package, json license, readme, truffle, JS. None of these are super important. If you understand a little bit of ethereum and coding, you'll get all this stuff.
00:29:30.654 - 00:29:58.626, Speaker A: If we quickly hop to the contracts. These are just solidity code. That is, this is basically the gravity smart contract or gravitar, right? And it's only 60 lines of smart contract code. Really easy to understand. And that's what I've said before, solidity isn't that hard to read. It's hard to write securely. But if you're just reading it and you're not a solidity developer, you can still create a subgraph.
00:29:58.626 - 00:30:39.218, Speaker A: And so, as you can see, there's these two events right here. And these events just emit simple information. It's a new gravitar and an updated gravitar. They both have an ID, they both have an owner, they both have a display name, and they both have an image URL. And we're going to take that information that's emitted from the blockchain, and we're going to store it in the subgraph by using our mappings. So now if we hop to the source folder, go to the mappings, you're going to see we're importing the updated gravitar and the new gravitar events. Essentially, these events store those four fields that we saw that information, and these are auto generated from the ABI.
00:30:39.218 - 00:31:20.078, Speaker A: And then we're also importing the entity gravitar that we created in the. So these are both generated files. You would have to make sure you import these in your subgraph, but it's pretty straightforward. And now you just start writing basically typescript functions. So whenever this function, new gravitar, or this event, new gravitar, is submitted by that smart contract, we're going to run this function and we're going to do a new gravitar or save a new gravitar. We're going to store these three fields on it, and then we're going to save it into the subgraph. It's pretty straightforward.
00:31:20.078 - 00:32:03.940, Speaker A: I've kind of described this mapping before, and you can see both of these are very straightforward and it's just a very easy subgraph to understand. But as I was describing before, these can get thousands of lines long. And when you think about a subgraph, there's a couple of different things you can do. You can store the live data that's on the blockchain, whatever is the most up to date information. Or you could also store historical data on the blockchain. Right, and maybe I'll show an example of that later on. But when you're storing historical data, you might store the amount of trades that happened every day and how much volume happened and how much volatility there was and all this really interesting information.
00:32:03.940 - 00:33:38.390, Speaker A: And that's actually what's so powerful about subgraphs, is you can really take any data from the blockchain and create very rich subgraphs that have all this complex data that really make it a lot easier for humans to understand what's happening on the blockchain. And so now I've described all the code in this repository and now I want to hop back and just deploy this subgraph. So as you can see, you got to authorize yourself and you just run this command graph Auth and you delete the placeholder access token and use your access token that's given to you in the explorer. And so now I am authorized. And then we're just going to deploy the subgraph. So I'm going to copy that and replace the subgraph name with the one we're working on and that's getting deployed right now to the hosted service and it's done. So if we go back here and as you see the page already refreshed, this subgraph is now deployed to this endpoint in the hosted service.
00:33:38.390 - 00:34:36.096, Speaker A: And so if you go down an example query is auto generated for us and if we just click that, we'll see all these gravitars that have been created on Ethereum before. And there you have it, there's all this data on the blockchain. We went from all of the possible data on the blockchain and we've basically condensed it into just this one single smart contract on Ethereum and a couple of events on Ethereum. And now we've created an open API that anybody can query and get this data back. And what's really interesting about the whole entire graph network is all this stuff is done in a deterministic manner. And any indexer around the world can index a subgraph from scratch by just downloading all the manifest files and everything. So if you have this file, right, the manifest and the files that connect to it, the mappings and the schema, you can then build a subgraph from scratch.
00:34:36.096 - 00:35:20.964, Speaker A: And now you have this system where there's open APIs all around the world that anybody can join in and participate in the network, know, start earning query fees in the real network and build this amazing kind of open network that anybody can participate in that powers, defi powers all these other blockchain applications that exist. And that's what's so interesting about the graph and what makes it so powerful. And so that's kind of like high level an example. And now I want to show an example too, of just how uniswap works. This is probably one of the most used subgraphs. Everybody knows uniswap. There's so many transactions that happen.
00:35:20.964 - 00:36:22.324, Speaker A: As you can imagine, this subgraph takes a long time to actually index. Like, there's 76 million entities that are stored in this subgraphs database, which is a lot. And so if we quickly go to the code here, this is a subgraph that is public, it's a uniswap B two subgraph. If you look at the schema really quickly, there's 300 lines here, right? They're storing a bunch of historical data, like the price data for a token, for a specific token pair. We're doing hourly volumes and daily volumes, and then we're kind of also aggregating the entire Uniswap volume, total USD volume, ETH and USD. So there might be a couple thousand trading pairs on uniswap, but there's no way to see the total volume that happens in a day just by reading the blockchain and querying an Ethereum node. It's just way too complex.
00:36:22.324 - 00:37:29.256, Speaker A: But when you have a subgraph that's running over top of every single event that happens in Uniswap, it can basically index all this information and return that information to you in a very rich way. So if we go to uniswap info, this website is basically run off of a subgraph. And so all this information you're seeing here, all this rich data, this chart data from last year may up to here, we're seeing how much the liquidity has increased over time and then decreased and increased. There's probably millions of different handlers running over top of all the Ethereum events that happened in the last year and a half here. And you're seeing really interesting stuff. And we're even calculating the volume, right? So these are usually you wouldn't be able to get this information just by looking at an Ethereum node, but it does exist. And now all of a sudden with this information, you start to get a Dex like uniswap that has rich information that a centralized exchange could provide, right, like CFI.
00:37:29.256 - 00:38:03.508, Speaker A: And you start to have defi starting to look like CFI. And really, that's what we've seen in the last year and a half. Is Defi really taking a large portion of users capital and liquidity. And if you even click on something like USDC, you get specific information for this token. You get the total volume that it's had, the total liquidity. The price obviously is going to be pretty close to one because this is a stable coin. But yeah, this is what can be built with the graph.
00:38:03.508 - 00:38:41.748, Speaker A: And the sky is really the limit. So for the hackathon, we're really excited to see what people can build, and we love to see somebody build with Chainlink. Once again, I'll repeat the five prizes that we're looking to see. The best subgraph using chain link oracles, the best governance subgraph, the best D five subgraph, the best NFT subgraph, and the best web three subgraph. So each of those subgraphs will get $1,000 for a prize. And we're super excited to see what everybody builds. That's pretty much all I have to say today.
00:38:41.748 - 00:38:47.610, Speaker A: And I stop the presentation here and open it up for questions that people have.
00:38:48.540 - 00:39:10.670, Speaker B: Awesome. Thanks a lot, Dave. Yeah. When I first got into web development and I started learning about graphql, I was like, holy shit, this is genius. Why hasn't SQL always kind of been this way? Sql. And then heard about the graph and web three. And I think that's where people, they're like, wait a minute, this didn't exist before.
00:39:10.670 - 00:39:41.220, Speaker B: It's just like something that is so needed. And what you're saying just makes all these applications on web three really come to life. And I think that's so amazing about what you guys are working on. We have some really good questions here in the chat that kind of came through and appreciate everyone's good discussion here about this. The first one, I know you guys have been hard, hard at work, and it seems like every single day, like there's another blockchain. Can you use the graph on Solana?
00:39:43.580 - 00:40:28.404, Speaker A: I am not up to date on whether or not that actually, I don't think it works right now. And I'm not even 100% sure personally because I'm not always on that side of the team of if we're integrating or not. But as far as it works, it's like really what the community wants is what blockchains we're going to add. And from what I've seen, I think Salana has been in high demand. And I have a feeling that Solana blockchain will be indexable by the graph, but I'm pretty sure it's not right now. And part of that reason is for a little bit of more technical details. It's like any EVM chain is really easy for us to index because that's what the graph started on.
00:40:28.404 - 00:41:02.610, Speaker A: Right. So if you look something like Phantom, we just have to change a little bit of configurations and we can index that chain. Solana is a completely different blockchain. So we're going to have to write this core code from the graph node, which is all written in rust. We're going to have to add a bunch of new code to index that blockchain. So those kind of blockchains like Solana and Polkadot, they just take longer for us to do. But all those blockchains are on our roadmap in some way, and we're hoping to basically query, or we're hoping to index basically every single blockchain that people want.
00:41:03.300 - 00:41:21.720, Speaker B: Cool. Yeah, another one. Are there other data sources or indexing triggers planned with the graph, similar to Chainlink's initiators, where you can trigger a crone job or webhooks. Is that something that's possible with the graph or planned?
00:41:22.780 - 00:41:47.170, Speaker A: Yeah, that's interesting. It's a great question. I think there's a lot of research there that could be done. There are specific things. Right now, the graph only really reads data. Right? Like all that stuff that I showed you here is reading data off the blockchain. There are plans to add mutations to the graph, which would essentially be.
00:41:47.170 - 00:42:38.592, Speaker A: You can write directly and do function calls through a subgraph. So instead of like, if you're a front end developer, you might have to write basically code in this wrapper code around using ethers, Js and hit smart contract functions in order to have people execute transactions on chain. If you've used any DeFI application like Aave, like compound, that's basically what it's doing. Some front end developer wrote the code there, and now you hit the Ethereum chain and you did a transaction. Now what mutations are is basically putting it all behind the scenes in a subgraph. In a similar way, we've just seen how we index everything for you, and it allows the API to be used very easily. We could have mutations work.
00:42:38.592 - 00:43:43.076, Speaker A: So you just hit a subgraph and maybe you're going to do a function call and compound to put more USDC in the protocol to earn more income. And instead of having 100 different front end developers around the world write that code custom, you just hit the subgraph API endpoint and give it the parameters that you want to give it. And it's going to submit it to a blockchain. So that's really cool. And when you think about it, that enables a lot of possibilities that would allow these hooks that can be done. And the graph foundation is also thinking a lot about event hooks and pushing notifications to people because that's kind of hard to do right now, right. If you had a subscription that you were paying for something like Sabler or even if you start getting your Spotify subscription on chain somehow in the future and you need to top that, like nobody's going to email you right now because it doesn't work like that.
00:43:43.076 - 00:43:49.000, Speaker A: But the graph is really thinking about how can we get that set up so a subgraph could do that automatically.
00:43:50.140 - 00:43:54.650, Speaker B: Yeah, that'd be fascinating. Yeah, that'd be really cool to see happen.
00:43:56.140 - 00:43:57.770, Speaker A: Excited to see that.
00:43:58.220 - 00:44:12.456, Speaker B: Yeah, I know. And your team has grown like crazy, right? Are you guys hiring any specific positions, at least on your team that you know of or anything for the hackers and other people that are listening in for jobs and careers?
00:44:12.648 - 00:44:46.840, Speaker A: For sure? Yeah, I might as well go to the jobs page right here. We have a lot of open positions. Some of these. We've been growing like crazy. I think we've hired ten people this year and we were probably a team of 17 or 18, and now we're probably 28 or so. We've hired a lot. I'm on the smart contract team and we still are looking for a solidity engineer and like a software engineer, software engineer being somebody who knows a lot of typescript, right, who understands blockchains but might not necessarily know solidity.
00:44:46.840 - 00:45:06.430, Speaker A: So yeah, we're looking to grow the team. It's only two of us right now in the smart contract team and that's definitely somewhere we need to hire. And there's still other positions here, but I'm not too up to date with them. But I know there's a UI designer we're looking for and then a couple of others for sure. So yeah, we're 100% looking to grow.
00:45:06.960 - 00:45:22.404, Speaker B: Cool. Awesome. Yeah, a lot of room to grow and exciting times. Dave, really appreciate you coming on here. I know it's your birthday next week, so happy early. Really appreciate pagan and everyone on the graph team for everything that you guys do.
00:45:22.602 - 00:45:24.132, Speaker A: Awesome. Thank you so much.
00:45:24.266 - 00:45:33.410, Speaker B: Cool. Thanks, everyone, for listening in. If you have questions, definitely hop into the graph discord as well as their section in our discord, and we'll see you soon.
