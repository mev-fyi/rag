00:00:00.570 - 00:00:21.214, Speaker A: YouTube just also has issues. Yeah, it looks like it's working now. Yeah. So strange. I guess I just had to restart Zoom. Well, the other video, that one actually kind of makes me sad because the DMM team, they're doing some really cool stuff. Yeah, I wanted to watch that one.
00:00:21.214 - 00:00:51.850, Speaker A: I couldn't join the zoom because I was on another one but wanted to have it on in the background but excited to watch it. Oh, no worries. Yeah, once it finishes buffering from zoom we can upload it. But cool. We are live on YouTube and we are going to be doing some cool stuff. Welcome, welcome. What's going on, everybody? Today in this workshop we're going over external adapters and how they work, how to build one, what to do with them, what they do.
00:00:51.850 - 00:01:27.794, Speaker A: Hopefully you guys have been following along with the other workshop so far. I see a couple of you in the chat have been to a number of these, so that's fantastic. Yeah. External adapters are really one of the key pieces that make chainlink so versatile. Basically, whenever you make a request to get data, external adapters will wrap your data requests and you can just do a ton of stuff with external adapters. You can have API authentication so you can get into secure locations without having to store your passwords and stuff on chain. You can store this all off chain, which is fantastic.
00:01:27.794 - 00:02:17.970, Speaker A: You can do a lot of off chain computation, which is really powerful because everyone knows gas fees. Everything you do on chain costs gas. So you want to offload that off chain as much as possible. And external adapters are the tool that will allow you to do that really easily and really seamlessly. And external adapters, if you went to the Polkadot workshop that we had, that's one of the key pieces of interoperability of Chainlink, is writing these custom external adapters to write back onto non Ethereum chains because there is already a Ethereum adapter built into the core chainlink code. So that's what we're going to be going over today. If you want to get a written version of this, the documentation is a great place to go.
00:02:17.970 - 00:02:57.234, Speaker A: I'm going to share my screen now. Probably going to be bouncing around sharing screen and I want this to be a really kind of like, what's the word? I'm looking for a seminar session. Please ask questions. Please jump in. Pretty much everything that I'm going to do here is on the YouTube channel actually in this video building and using external adapters, we also put out a blog on it on how to do literally everything. Here. It's here so if you want to see another written step by step, you can go there.
00:02:57.234 - 00:03:49.318, Speaker A: But this will definitely be for those of you who want to ask a ton of questions and kind of walk along with me as I build this external adapter. So to get started, we're actually going to start with a template. So this is the chainlink external adapter node js template. External adapters can be written in any language, right? They can be written in anything because they're off chain. So just to rephrase again, your smart contract, it's going to make a request to a chainlink node and your chainlink node is going to do a bunch of stuff to get the data right. And this is where the external adapter comes in, because we write an external adapter which defines hey cool. Once you get that data, I want you to do this to it, right? And since it's off chain, we can do it in whatever language we want.
00:03:49.318 - 00:04:40.470, Speaker A: For this tutorial we're going to be going over a node JS or JavaScript example. But you can write this in any language, Java JavaScript, go whatever you want. Because at the end of the day, one of the simplest ways to make an external adapter is just by making it an API itself. So not only you're kind of getting a double whammy of content here, not only are you learning how to build an external adapter, you're also learning how to build your own API server, which is really cool and really powerful. If you want to deploy this in a serverless environment, which if we have time, I will go over a lot of the professional nodes, deploy these in a serverless environment, we can go over that as well. We should have time, but if we don't, if somebody wants to ask about it, definitely hit me and we can go over it. So this is the template.
00:04:40.470 - 00:05:32.818, Speaker A: It has a lot of really good boilerplate for us and you can build one from scratch, but it's just really nice just to start from somewhere. I'll go over the pieces that if you wanted to build it from scratch, we can kind of ignore everything in here except for these two. This is some package and yarn. These are like standard node JS packages, but these are the two files that we want. So we're going to clone this. I have to reshare my screen new share share here, CD code. Let's do CD demos it for those of you demos, we'll do make dir.
00:05:32.818 - 00:05:58.320, Speaker A: Actually let's just do git clone, boom, get clone that and then we'll call it Node Js walkthrough cloning node js walkthrough great. CD node js walkthrough. Okay, cool. So I'm actually going to open this up in my code. Editor vs. Code. Give me 1 second.
00:05:58.320 - 00:06:32.060, Speaker A: Node js walkthrough. And then I'm going to share this with the screen and then let me know if it's too small, if it's too big, whatever. And then I have my terminal in here. Make it an amazing day. Clear. Okay, cool. Hopefully you guys can all see that.
00:06:32.060 - 00:06:57.790, Speaker A: Yeah, looks like you guys can all see this. Great. So this is going to be our starting point, right? And we can see all our files in here. The two ones that we really care about and the two ones that we're going to be looking at are app Js and index Js. And in fact, we're really only going to be looking at. Sorry. We're really only going to be looking at index Js.
00:06:57.790 - 00:07:50.820, Speaker A: So app Js is, this is really just some boilerplate code. If you've never worked with node JS before, this is like some simple boilerplate for an express server. Basically we have this app like listen for requests to be made to it, right? So we do kind of this boilerplate stuff and now we're saying, hey, we're going to listen for requests so we can even, oh, sorry. We have to actually install all the packages with yarn. So let's do that first. And now we do yarn start and we start our application and it says listening on port 808. So while that's running, I can open up a new terminal and then is this big enough for you guys to see? Should I zoom in? I'll zoom in a little bit.
00:07:50.820 - 00:08:19.498, Speaker A: Now it looks massive, but that's fine. Going to make a new terminal. And then again, you don't have to use the terminal in your code editor. If you want to use the terminal or on your Linux box or whatever, you're free to use that. But while this is up, I'm just going to show you basically what's going on with it. And we're going to run a command that's going to mimic what a chainlink node is going to call when it calls your external adapter. I already ran it.
00:08:19.498 - 00:09:12.046, Speaker A: Let's do this. And then actually let's open up a new, I like to do like a notes MD file sometimes. So this is the command I'm going to run for those of you who are new here to kind of programming. It's just like a Linux command. It's going to make an API call. So it's going to make a HTTP post request type JSon to our local host, which again, these are my two terminals right here, which we have, and then that's the response right there, which we have the server running on this terminal, right? So it's running on this terminal and it's running at localhost 808 and we have this data flag that we're adding to it. And I'm going to explain all of what this is doing in a minute, but just to show you guys what's going on.
00:09:12.046 - 00:09:54.954, Speaker A: So I'm going to call this curl command and it's going to respond with this two. So we are calling this and it's responding with this. This is going to be our first look into how these external adapters work. So whenever you call an external adapter, it always needs an ID and a data object, this data flag. That can be a little confusing. So in our data flag we also have a data object. So just make sure that those are different.
00:09:54.954 - 00:10:50.380, Speaker A: This is the data flag for the command. This is the data object here we need an ID and we need a data object. The ID is going to be the ID of the job, which gets spit back out with this job run ID. See how they're both zero. See if I do like job ID is like blah, blah blah, that I'm going to get job run id this, right? That's just so that in your node, in the node it knows, okay, this ID is associated with this job run. And then in the response we also get a data object which is going to be this piece of JSON right here, right? So we get USD this and then we also get result this and then we also get these two other results and status code flags as well. Every single external adapter for Chainlink needs to respond with a job run ID and a data object.
00:10:50.380 - 00:11:32.540, Speaker A: But it's good practice to add a result and a status code and I'll get into why that is in a minute. So that's really the important pieces. And again, if there's questions like, okay, well, how does this work with an API or excuse me, how does this work with a chain link node? Please jump in, ask questions. If you're totally lost, feel free to put something in the questions here. And again, you never want to deploy one of these without running tests. So this test, we're probably not going to go into it because we're not going to have time. But this test file is really good.
00:11:32.540 - 00:11:56.850, Speaker A: It's really easy to edit with whatever new API you want. So let's look into how this is actually happening. Let's see. Just save that. So this is our index JS file, right? So this is where all kind of the logic is going on. Like I said, this is kind of the basic express stuff. To start a server, to start this.
00:11:56.850 - 00:12:29.258, Speaker A: Hey, I'm listening. I'm looking for requests, but this is where it's all in. So the Chainlink team has actually built this external adapter package, which makes validating your calls a lot easier. So it's just like a check to make sure it has the job ID. It has kind of all the pieces that it needs. But again, you're more than welcome to start this from scratch. And this template has a lot of nice comments in it as well.
00:12:29.258 - 00:13:04.440, Speaker A: So if we have a custom error, we can pull it up here, right? So return true for the adapter to retry so we can divide some custom errors and stuff. So this is the first bit of logic that's actually going on here. So we have this const, custom parameters. So base quote, endpoint. We have base from coin. Actually, let's even take it one more step back. Sorry, I think I might have been speeding ahead here.
00:13:04.440 - 00:13:45.886, Speaker A: The reason that we were able to get this data that we got is the USD price of Ethereum. So this external adapter gets us the USD price of Ethereum at the time. So how is it actually getting that? So our adapter is actually calling another API. So it's literally like, it's as simple as our API is wrapped around another API. And again, the reason that we want to do that is because we can do authentication with it. We can do a lot of other off chain computation and we need it to be understandable by the chainlink node. So we need to edit the API to make it understandable by the chainlink node.
00:13:45.886 - 00:14:21.440, Speaker A: But you also don't have to call another API. Again, this is why it's so fantastic, because you could have it do whatever you wanted, right? You could have it just return two. That would be a really silly external adapter, but you could do it. Let me switch sharing screen here to this one just real quick. So the API that we're calling, hopefully you guys can see that. I'll put in a comment when we get back there is just, it's a crypto pair price API. Let's zoom in a lot here.
00:14:21.440 - 00:14:53.722, Speaker A: And we can see this is the URL for the API. And this is all. It's returning, it's returning USD 366.87. So I just refresh it and it changes. So we're returning the, returning the price of Ethereum in USD. So that's what we want to get with this external adapter and make it understandable by the chainlink node. And again, you probably wouldn't want to do this in an external adapter because it's so simple, but it'll show you how to write one of these so you can do more complex, more interesting things.
00:14:53.722 - 00:15:30.150, Speaker A: Anyways, so we saw, oh, I got to go back to sharing my screen here. Node JS walkthrough. Okay, perfect. Looks like we have two questions already. Going to jump on the questions. Are there changes that you are making to the code saved locally and are there changes that you're making to the code saved locally? Yes, they're saved locally. And is the terminal in the application that you use connect to any kind of server? The terminal that I'm using here is just my local machine, so it's not connected to any server, it's just my local machine.
00:15:30.150 - 00:16:43.238, Speaker A: If you want to flesh that question out a little bit, it sounds like I didn't quite get at your actual question there, but let me know what is the sequence of events here? The contract gives the URL, sends it to the oracle, and the Oracle contracts or context or external adapter, ie the node Js. Yes, good question. So it sounds like you pretty much got the just to go know from the smart contract, a smart contract will emit an event saying, hey, I'm looking for Oracle x to get me data y using external adapter. The chainlink node says it's constantly scanning the ethereum chain and goes oh, that's me, I'm going to get that data and then it goes out and gets the data. And either in the job specification or in your smart contract, you'll say use this external adapter. Then the chainlink node will make a call to this external adapter and it could also not be an API itself, but most of the time it will be, makes a call to this API server, this external adapter server. The external adapter does its thing, returns the data to the chainlink node.
00:16:43.238 - 00:17:22.054, Speaker A: The chain link node goes, okay, great, post it on chain in a transaction, and now your smart contract can read this data and the chain stays reliable. So hopefully that answers that. It sounds like you pretty much got it, but if you're a little bit confused with the sequence of events there, it's the same as the regular adapters or the core adapters, just this one is an external one. So you're just reaching out to an external service to do this adaptation to the code. And that's a good point too. There are two types of adapters when we're talking about here. There's the core adapters and there are the external adapters.
00:17:22.054 - 00:17:44.930, Speaker A: Core adapters are the adapters built in to the chainlink functionality. So like HTTP, get copy, multiply. If you've been to my other workshops, those are all examples of core adapters. External adapters are hey, build whatever you want. I almost think of them as packages for Chainlink notes. It's where you can customize it to be whatever you want it to be. So good questions.
00:17:44.930 - 00:18:07.922, Speaker A: I'll check the YouTube real quick too. May have missed this, but some providers require we are going to get into API keys here. Good question. Stay tuned. Eric, I think you can connect your EA to a database to store your key securely. You can also do that. Yep, you can connect it to a database and store your key off chain.
00:18:07.922 - 00:18:47.714, Speaker A: And we'll get into that in a second here. But anyways, so in our URL here, this is the URL that we're calling. And I'm going to pretend most of you are just kind of unfamiliar with APIs in our, I'm going to say this is our base URL. This is what we're connecting to. Our endpoint is price. And for those of you who don't know, the question mark at the end of an API means everything after this is going to be query parameters. We're calling Fsim equals f and Tsim equals USD, which we know from reading this API's documentation that this means from Sim Ethereum and to sim USD.
00:18:47.714 - 00:19:23.434, Speaker A: So we're getting the price of Ethereum in terms of USD. So that's what this means. And in here we're going to add some custom parameters. We're going to say for base we want the parameters to make it easily readable because f sim and t sims is kind of confusing. We want it to be base from coin and then quote to or market. So when we run that curl in this data object here and then hopefully this is big enough. Again, we have from and to.
00:19:23.434 - 00:20:10.880, Speaker A: But we also could do coin and market and we get the same result, right. So this is just kind of like a nice fun tool to have to make it a lot more easily readable because sometimes the APIs you're working with are a little bit weird. Endpoint is going to be another parameter that we can pass. If your API has multiple parameters, you could pass for this one. It's just price and we know we're only looking for price, but you could have the endpoint be something else you wanted here too. So that's exactly what this piece is doing. Moving on, the create request part here.
00:20:10.880 - 00:21:07.218, Speaker A: Yeah, let's just go over it. The create request, this is where a lot of the nuts and bolts is happening. So this validator, Const validator, this is that package that we're importing from the top, right? Const validator equals new validator callback, input, custom params. This is helping us make sure that what we're doing makes sense. We always need to have our job run our D and we get that from that validator object that we just did, our endpoint, which again, we can have it in our validator object, but we know that we only care about the price endpoint, right? This is the only one that we care about for this demo here. So we say or price, great price of what we're going to use. This is our base URL, and then this is that endpoint that we just created, which we know is going to be price.
00:21:07.218 - 00:21:52.946, Speaker A: And this is kind of a way to input that variable into your URL string with these ticks, that dollar sign syntax there. And then we have the actual names of the parameters in our URL, which is Fsim and Tsim, which is going to come from base and quote, which again we defined up here, base and quote. So we could also do, we can make it similar or simpler if we want. We can do from two again, and then we got to come down here and do from and to. Great. So that's going to be from sim and two sim. Those are going to be the parameters that we're going to pass.
00:21:52.946 - 00:22:34.800, Speaker A: So we want to put it into this parameters object here, const params, is this struct, I believe it's called struct in JavaScript, or I usually just say object f sim, tsim. And then we also have our config. This is what we're actually going to be passing URL and param. So the URL we got here, the params are going to be these ones which we validated with this chunk of code here. And then we actually create the request down here. This is using a little bit of that node Js syntax. Again, requester is a package that we import.
00:22:34.800 - 00:23:26.282, Speaker A: It's really nice because it defines like some retry parameters and some other parameters that we would otherwise have to do ourselves. So that's really nice. Request the config, which has our URL, it has our parameters and also customer if we want. And once we get it, we're going to take the response and we're going to add this result parameter to it. So remember when we just did the API call in the browser, we got just that small, hey, USD 365 or whatever it was, right? We want to make the response a little bit more robust, a little bit easier readable. Sometimes you'll get a response that's like 50 keys with each value having 50 keys. So it can be kind of hard to triage.
00:23:26.282 - 00:24:19.406, Speaker A: And it's really nice if you just bring whatever value you want right up to the result field. That way in your smart contract, in your chain link node, you can just always point it to result, whatever the result is of my external adapter, that's what I want to grab. So we're creating this response data result variable, which is going to be requester validate result number in the response and of TSIM. So this is going to be the path of the response and we'll get into that deeper in a second. But we know that when we saw that response, it was USD 336, so it was just USD of that path. Anyways, then we call back, catch some errors and cool. And now we have the result there.
00:24:19.406 - 00:24:49.350, Speaker A: And that's literally it. That's basically how it works. These functions down here make it easy to upload to a certain and then we export it. But these functions here make it easy to export to a serverless function, which are really cool. There's gcp and Aws in the template. It shows you how to do that. And if we have time we will do that, but we'll get into.
00:24:49.350 - 00:25:49.402, Speaker A: So this is kind of the basic run of it. Now what I'm going to do is we're going to find a different API that we want to make an external adapter for that requires an API key, and we're going to adjust the template accordingly to do that. But before I jump in, are there any questions so far? Does everyone understand kind of what's going on? Great, no questions. Okay, let me switch screens again. So this is the API that we're going to use. It's openweathermap.org. What we're going to do is we want to get the temperature in Boston at the time, and this API requires an API key.
00:25:49.402 - 00:26:22.840, Speaker A: So we'll also get to see how to do that. A couple of people have asked, hey, my authentication is weird, why do I need to do this? A lot of APIs have their own authentication. You'll see like headers, some will have tokens. Just read the docs a lot of times it's pretty straightforward how to adjust it. But we're going to do an API key in the URL. But it's usually pretty simple to add it to whatever other parameters that they specify. So for this one we need an API key.
00:26:22.840 - 00:27:13.794, Speaker A: I guess I need to create, can I create, how quickly can I create account? Or maybe I'll just use. Hold on. I'm just going to use an account that I've already made. 1 second map. Remember my password? Sign into your account. You'll like this. And this isn't a paid subscription.
00:27:13.794 - 00:27:45.150, Speaker A: So I'm going to show my API key here. But yeah, you're not going to get any use out of. So this is the API that we're going to be using. We want to go to the documentation here for our API keys. No services. Where do I go here? It's a view. Aha.
00:27:45.150 - 00:28:02.360, Speaker A: No, I already have an API key. I get to the docs, please. Documentation. Aha, API doc. Okay, cool. So we go to the docs here. Hopefully you guys can see this.
00:28:02.360 - 00:28:32.026, Speaker A: We go to the docs here and I'm just going to skip down to the documentation here. And I know that, okay, this is the API call, right? And so you can see that this is pretty similar to the URL that we were working with before. This API also makes it. The docs here make it really nice and straightforward. Sometimes the docs will leave the base off and just have the endpoint. So just got to find the base. And they're all pretty much the same with a couple of tweaks and sometimes they make it harder.
00:28:32.026 - 00:28:54.402, Speaker A: But I really like this because I can just copy and paste it. So cool. So I know that this is what the request looks like and I know that this is approximately what the response will look like. And yes, okay, cool temperature. I'm smart enough to know that this is actually in Calvin. So cool. So this is what I should get if I do it correctly.
00:28:54.402 - 00:29:28.420, Speaker A: And this is what the URL looks like. So now we're going to swap back to vs code. We even want to test, we want to test us doing it correctly the first time. So we're going to do that. Let's put in a city, let's put in Boston our API key. I'm going to grab that real quick. Which we saw was in that API key.
00:29:28.420 - 00:30:02.318, Speaker A: We saw was in that API key URL. Great. So we can test this in our browser or we can also do another curl. Actually, curl is a great command. I might have to do a get instead of a post, but let's try. Okay, no post works. So we ran our curl command and we see, okay, yes, this is what we want.
00:30:02.318 - 00:30:16.180, Speaker A: Where's the temperature? Blah, blah, blah. And see how long this is and why we'd want to squeeze it down. Just a result. Because this is kind of long main temp. Okay. 299. Calvin, that's probably correct.
00:30:16.180 - 00:30:28.454, Speaker A: So cool. So we know that. Let's even toggle. Okay, cool. Toggle. Word wrap. So we know that this is going to be kind of approximately like the URL that we're going to be working with.
00:30:28.454 - 00:30:58.160, Speaker A: So great. So we can continue and then we can also stop this because we are no longer going to be using that old server. We're going to be updating to this new server. So cool. So we have to our first one, custom parameters. We only care about city right now and it looks like for those same pieces, if we go to our notes, actually we can just keep playing with it in here. We know that.
00:30:58.160 - 00:31:41.494, Speaker A: Okay. We know that before we had price was our endpoint and we were using from Sim and to sim. Now, weather is our endpoint and our parameters are going to be Q and app ID and app ID is going to be our API key. So let's do this. Let's do city. And let's say you can pass Q pass city, you can pass town, comma. And we're going to keep endpoint false because we know we're only going to use Boston.
00:31:41.494 - 00:32:16.310, Speaker A: So the reason I'm not using my API key here, even though you're, hey, like the other parameter is app id. Why aren't you putting that in there? I'll show you why in a second. It looks like I have two questions here. So in API keys, my understanding is that you can put your API key in your smart contract and it will work with the oracle, but you should really keep your key off chain in your own adapter for. Yes, exactly. So you can totally put your API key in your smart contract and just pass it as a regular parameter. But because blockchains are available to everybody, then everybody will be able to see your API key.
00:32:16.310 - 00:33:14.218, Speaker A: And that's really bad because then, especially if there's a limit or if you're using your API key to actually make updates to maybe like a private account or something, now that's available for everybody to use, you absolutely do not want to do that. So unless your data is like really only if you're working with an open API like this one for example is an open API. Those are usually fine to put on chain because there's no authentication, but for anything with an API key, you really want to put in an external adapter. So good question. What kind of use case in DeFi would have weather data? Good question actually. So let's even just do one for insurance data. Let's say you have crops that you need insurance on and you want your smart contract to pay you out when the season has been terrible to you.
00:33:14.218 - 00:33:43.298, Speaker A: So you could call some weather data and some decentralized weather data. And if that weather data says hey, the season was terrible, then you're going to get paid your insurance for your crop data. So that's one for insurance for DeFi and weather data. I don't know. That's a good question. I don't know, maybe if there's a thunderstorm you get some yield farming token or something. I have no idea.
00:33:43.298 - 00:34:10.534, Speaker A: This is where your creativity comes in. But the API is more just to kind of show the authentication with the API key. But there's definitely use cases for weather data outside of DeFi. Like for example, that one insurance one is probably one of the most powerful ones that I could think of. So good question. I'm going to flip over to YouTube real quick. Yep.
00:34:10.534 - 00:34:34.740, Speaker A: Okay, cool. Moving on. Yeah, I'm not going to go into the API key because we really don't want to hard code our API keys. So we could do app ID, app Id, whatever here. But we don't want people to pass it in aura. We don't really want to hard code it. So I will get to that in a second.
00:34:34.740 - 00:34:55.146, Speaker A: Cool. So that's our API. Now we're going to get to creating the request here. So I know that our validator is going to be good because our custom params are good. Our inputs, good job, run. ID is going to be the same, right? We're not going to need to update this at all. Our endpoint is different.
00:34:55.146 - 00:35:33.266, Speaker A: We know that it's going to be weather because we saw right here before this question mark, which again is the query part, it's going to be weather. So we're going to update with this with weather. And if you want, you could have this be true and you could have someone pass the weather, excuse me, pass the endpoint with the custom params. This is why this framework is so fantastic. It's super module, super customizable. But yeah, we're going to do weather consturl. We know that the URL is actually our new URL is this great and const fsim, we know that it's no longer fSim.
00:35:33.266 - 00:36:09.186, Speaker A: We know that it's Q data city. We also don't need this to uppercase Const Q validator. Validator data city. Right, because we called it city here, the parameter is going to be Q. So in our parameters that's all we need is Q and Q. And what was the other one that we needed? We needed app ID, right? So after this, just to make it a little bit clearer after that question mark and then the ampersam here is what separates them. We had Q equals Boston and app ID equals this.
00:36:09.186 - 00:37:03.460, Speaker A: So we know we need Q and app Id. So for app Id, remember that's our API key. We really don't want to hard code this, but we also don't want them passing this as a parameter. So what we're going to do is, is that right? Process env API key. What's it giving me for an error comma expected? Q const app id equals process envi key. And this is going to set our API key as an environment variable for us. So this is where we're going to be running it.
00:37:03.460 - 00:37:36.846, Speaker A: There's a number of ways to make environment variables. We're just going to do a real simple way. There's also an E and VRC file here which will show you, hey, this is what it'll approximately look like for us. We can even new file envrc. We do export API key equals, equals this. That's what it would look like. And we would absolutely want to keep this out of source code.
00:37:36.846 - 00:38:06.434, Speaker A: So make sure in your git ignore files you have this in here. And then we can do export API key equals this. And now it's set as an environment variable. So it's basically set as part of our terminal and as part of whatever command line interface that we're running. And that's how we're going to kind of keep it safe. There's a number of other things you can do for security here. You can keep it in a database.
00:38:06.434 - 00:38:38.034, Speaker A: You probably should encrypt it as well because otherwise you're kind of just asking to be owned. But for now, we're just going to have it be, that's kind of like a whole nother security bit. For now we're just going to have it be an environment variable. So, cool. So we're going to pass Q and we're going to pass app ID and then we're going to give it the URL and the params here and we're going to make the request. The only thing we need to change here is this path. Right? So again, we want to pull the result up to the top.
00:38:38.034 - 00:39:07.750, Speaker A: And we saw. Do I still have that open? Let me share back. Zoom in a little bit. We saw that we want temp, right? So this is the answer that we really want to get. We don't need the rest of this data and that's something to keep in mind whenever you're building these because gas is a thing. Anything you don't need to do, you don't want to do because otherwise you're going to have to pay for it. So we only want to get this temp.
00:39:07.750 - 00:39:47.510, Speaker A: So we look in this JSon thing and brave actually doesn't have great syntax for. There's a JSON prettier Chrome extension, by the way. Is there json prettier Chrome extension? Add to brave add extension has been added. Okay, well, thank you. Thank you very much. Cool. So we can find the path of the temp by going through this.
00:39:47.510 - 00:40:03.742, Speaker A: No, it's not on cord. No, it's not on weather. It's in Main. So we know the path is going to be main temp and that's where we get our attempt here. So thank you for that. I've been looking for that. I looked up brave JSOn extension, but pretty.
00:40:03.742 - 00:40:22.082, Speaker A: Yeah. Thank you. So we know it's going to be main comma temp. That's where our result is going to be. It's going to be in that path. And again, we're going to ignore the rest of it for now. And that's really it.
00:40:22.082 - 00:41:02.190, Speaker A: So we really only made like two super quick updates and we should be good to go. So let's go here so we can do yarn start again. We have our new server running and now we're going to make the request. Now, again, the request is not going to be this. We're going to do our new request based off of our API here. So I see, Tom, your hand raised. If you could type your question first, that would be fantastic.
00:41:02.190 - 00:41:21.058, Speaker A: We're going to do, yep, curl post, localhost. The data is going to be different. Right. So instead of all this, we're just going to do city. Kind of looking for your question now. Oh, it looks like there's a lot of questions. Boston.
00:41:21.058 - 00:41:33.100, Speaker A: I will slow down to answer some questions. Didn't understand the job ID bit. Okay, let me understand. Answer live. Oh, screen not updating. We can't see the screen. Yes, good call.
00:41:33.100 - 00:42:06.994, Speaker A: Sorry, I forgot to flip back. Sorry about that. Let me just refresh where we were. Yeah, sorry, I'll just undo that. So right here, before, this is where we're going to get our path. So we're going to put in main and temp, remember, because on that response we got main and temp. And then what I did was then I restarted the server because now this will be our new updated code.
00:42:06.994 - 00:42:20.440, Speaker A: And that's really it. That's really all we have to do. So thank you for flagging that there Tom's screen not updating. So I was, yeah, like, could you ask a question? We can't see your screen. Can't see what you're doing. Can't see what you're doing. Okay, cool.
00:42:20.440 - 00:43:05.538, Speaker A: Didn't understand the job ID bit, honestly, don't worry about the job ID bit for now. Just know when the chainlink node runs, it needs to assign a job ID to all these external adapter runs. So don't worry about the job ID part, honestly. Cool. So now we want to make, now we want to make the new request here. So before we ran with the curl post, blah blah blah, same thing, we're still running on localhost, the data object is just going to be different, right. So we defined before we want it to be city and something like Boston.
00:43:05.538 - 00:43:24.634, Speaker A: Right. So we should be able to run this and get a good response. And remember, could also use Qtown city. Right. We could use all those. So server is running, should be able to get a response and we do. Fantastic.
00:43:24.634 - 00:43:53.222, Speaker A: And we can even see here the result is pulled up to the top, 299.47. So now we have, we've just updated the template to work with an API key that needs authentication with a brand new API. So it's really simple. And again, this is using the template. You're more than welcome to build your own raw external adapter and API server. You can do kind of whatever you want. And that's the other fantastic bit.
00:43:53.222 - 00:45:05.840, Speaker A: But it's really that simple. So I will go over serverless architecture because we have some time, but before I do that, are there any questions about what we've gone over so far? It's pretty straightforward. All right, cool. So it's pretty straightforward. So the last bit is a serverless architecture. So is there a max timeout for when we have to respond to the chain link node? Yeah, good question. So I believe there is, I believe it's in the, it's in this package here.
00:45:05.840 - 00:46:42.362, Speaker A: I believe that's all handled in the requester package. No, I don't really want to. Why can't I see no modules in here from my vs code just go into here. Okay, so yeah, the timeout is defined in here. I forget what the parameter is though. It. Yeah, I'm being slow here, but yeah, if you look into this requester package up here, the timeout I believe is in there so you can bounce around on the code and set the timeout to be longer.
00:46:42.362 - 00:47:17.622, Speaker A: That's actually a really good question because especially if you have an API that's doing something really long on the chain link node itself, I don't think there is a timeout. I don't think there is a timeout. So the chain link node could be kind of blocked forever if you're taking a really long time. I don't think so, but that's a good question. I kind of want to test timeouts now. Yeah, good question. Is there anything else before I do? Oh, sorry.
00:47:17.622 - 00:47:47.230, Speaker A: Okay, there is one more thing before I talk about serverless functions. So then the question becomes, what do I do now? I have this external adapter, I can do all this awesome stuff. This is so great. I can do all this awesome stuff off chain now. Okay, what do I do? There's a couple of things that you can do. You can run a node yourself. Obviously since we want our smart contracts to be decentralized, we would want other nodes to be able to use our external adapters.
00:47:47.230 - 00:48:28.926, Speaker A: And keep in mind, you would never want to use just one weather source weather API because again it becomes centralized. You'd want to use multiple, but you'd want other nodes to be able to use your external adapter. At least you could either run your own node and that would be the first part, or if you're just doing development, you don't want to have to deal with running your own node. You can come to a number of places like market link, sign in. I'm not going to though. Let's look at some adapters. You can see some adapters here, right? And once you sign in, you can add your own adapter and you put all the parameters in it.
00:48:28.926 - 00:49:04.534, Speaker A: So let's even look at, this is for COVID here. There was another one that I was really familiar with. Did I make this one? Who made this one? I didn't make this one link butler. Yeah, you know what, let's even just look at that one. So it has all the, oh wow. It has all the parameters in here and the docs in here for how to use it. And perfect, you say, okay, rec at, match, ID or slug.
00:49:04.534 - 00:49:28.546, Speaker A: Oh, this is great to get answers about what is this? Esports data. To get esports data with API authentication. So this is really cool. And then you can even see the nodes that support it. Looks like no COVID do any main net. Looks like Linkbuttler is the only node that supports it on Mainnet. They probably made it but let themselves use it.
00:49:28.546 - 00:50:15.394, Speaker A: But if you're another node, you could add this to your node and now other jobs can call it and use that data. And if you're looking to get something spun up real quickly again, I don't super recommend spinning up your own node if you don't plan on running a node because then you have to work with that as well. A really easy way is just ask a node operator. In that discord we have an ask a node operator channel. I might rename it to ask about external adapter or something, but you can ask a node operator and say, hey, I have this external adapter, I'm looking to host this data somewhere. Can you host it on your node and they can host it on their node for you and you can access it there to test your jobs. So that's a ways that you can actually start using it.
00:50:15.394 - 00:50:58.910, Speaker A: Now I don't have like a test GCP account here. Serverless architecture is when, if you're running a node or you're running a node or you want to host this without having to kind of run a server, there's a lot of places where you can actually run this server and run this adapter yourself. A really popular method is to run a serverless architecture, which I probably will have to sign up for a new GCP here. Otherwise I'll have to sign into my GCP. Oh, I don't know, I guess there's a. Oh, I have a fake account that I made a while back. Cool.
00:50:58.910 - 00:51:21.030, Speaker A: Oh, it looks like your free trial is over, but you can always sign up for full account. So I won't be able to do anything because my free trial is over. What you can do, let's go to cloud functions. So this is the GCP. This is an example of what it would be on GCP. I can't do it because I don't have billing enabled. My free trial is over, but you can deploy one of these to what's called a serverless function.
00:51:21.030 - 00:52:11.190, Speaker A: So it'll just be like a URL that it'll give you, and it won't be like a server constantly listening, but whenever you call that URL, basically Google will spin up a VM with all your code. We'll run the request and then we'll shut it off. So it actually has a server that it spins up on call, but then it just turns it back off whenever that request is done. And this is kind of nice because you don't have to worry about maintaining a server. And that's why it's called like serverless, because you don't actually have to maintain a server, right. It's almost like a server as a service type deal, but it's called like a serverless architecture. A lot of nodes will spin up an external adapter on one of these and they're really easy to deploy.
00:52:11.190 - 00:53:00.786, Speaker A: The GCP, I think is a little bit easier to deploy and all the docs for doing that are right here. AWS is really powerful though still, and has really good reputation, really good uptime, everything. But all the note for how to install the AWS lambda, which is their serverless function. The GCPs is that cloud functions that you saw. All the docs for how to do it are in this template. If you want to look at that updated weather one, you can come to Patrick Alpha C here I forked it and I have two branches. The weather, which, excuse me, the main one is this master branch, and then the weather one that we just did is on the weather API branch.
00:53:00.786 - 00:53:40.018, Speaker A: So all the code will be there for you guys to check out. What fees are involved for running and querying an external adapter? Good question. Usually if you're going to run it with serverless, the GCP and AWS is going to have a charge for using their services. It's usually per call, so it's usually pretty low. They usually won't even charge for the first million or something like that. So it's usually very cheap. If you run your own server that the external adapter will run on, it'll be more.
00:53:40.018 - 00:54:30.062, Speaker A: But the answer is it's the same costs that go into running an API. And that's really the answer. Because at the end of the day, this type of external adapter in particular is just an API with specific adherences to the chainlink node. So the answer is the same there. Does anyone know any good gamification APIs? I'm assuming you mean like gaming APIs? I'm not sure what gamification like. How would you gamification something? If you look up gaming API, you could rapid API, which is a good service. It has a lot of little bit slow, but it has a lot of APIs in it and it even has fortnite API.
00:54:30.062 - 00:55:01.254, Speaker A: Interesting. So there you go, if you want a Fortnite API, you go there. Panascore, which is one we just saw, that is something that we can do. And the cool thing about this is that it does have like headers and stuff, but it'll give you the code to actually modify your, we can even do like. So that's node JS, we can do whatever we want. Whatever we want for node JS. It even gives you the code to like and you can just code to call and you just copy paste.
00:55:01.254 - 00:55:42.566, Speaker A: So that's a cool place you can check out. But yeah, if you just Google X API, stock API, gaming API, something's going to show up because there's a lot of companies out there that want your business. Good question. But only node operator can make income from external adapter. No, not necessarily. I mean, so you could, so that's a good question. Actually, you could have your external adapter be an API and then just charge a fee, right? You can make the node operator sign up for a service for your external adapter.
00:55:42.566 - 00:56:24.278, Speaker A: You could absolutely 100% do that. Keep in mind they're never going to exclusively use your external adapter because it's not decentralized in that sense. No, there's tons of places to be creative and economically creative here. So good question. Any other questions here? That's pretty much the tutorial adapters have to return something. Thinking of an external. Good question.
00:56:24.278 - 00:56:41.614, Speaker A: No, absolutely not. So that's a great question. Actually thinking of an external adapter sending an email and not returning. Yeah. So no, it's probably good if you do return something because then you can verify if your thing actually got sent. But no, absolutely not. That's a great question.
00:56:41.614 - 00:57:21.734, Speaker A: You could have your external adapters send an email. Somebody was messaging me about making a trade on a centralized. So that's a great question. External adapters can be used to also make your smart contracts, do things in real life like there's a PayPal external adapter, PayPal external adapter which allows you to pay in fiat through PayPal. There's a lot of external adapters that have already been made and this is actually link pool is one good place. This is another goodapters.com. Oh, this was me.
00:57:21.734 - 00:57:48.340, Speaker A: But you can know different API providers. What is this? There's a rating scale, apparently different platforms it runs on. Yeah, that's a great point. You can do whatever. This is why external adapters are such an insane feature, because they allow you to do whatever you want to do. Good question. When is the new white paper coming out? I don't know.
00:57:48.340 - 00:58:31.040, Speaker A: We got like three minutes here. I guess I'll hang on and answer any other questions. Here's. But if that's it, it sounds like everybody basically gets it, which is great because this is fairly straightforward. Thank you guys for coming and for watching this. I'm really excited to see what, you know, this is, this is just a really powerful feature. Isn't Ea meant to write onto calling smart contract? It absolutely can.
00:58:31.040 - 00:58:55.126, Speaker A: It absolutely can. And so what you'll do is in your chainlink node you'll specify to use this external adapter and it'll use this to write the result onto the chain. So yes, it is. It is meant to write onto a calling smart contract. All right, well thank you everybody for coming. I hope you guys learned something. If you want to leave me some feedback, feel free to ping me.
00:58:55.126 - 01:00:11.454, Speaker A: Feel free to ping it in the discord. Do you know if there's a centralized index of it? Oh, great question actually. So again, this is kind of like the nature of how this whole thing works is everything's free form, right? Like the chain link adapters is one place you can go, link pool is another place you can go, someplace that a lot of professional node operators use. Is this external adapters? Monorepo, this is a good question where there's a lot of external adapters in here. So external adapters JS smart contract kit and it has a ton of adapters already built for a lot of really popular cryptocurrency price data APIs and it has all the docs how to deploy them to AWS, how to deploy one yourself, and it's really simple to use. So this is a really popular one that a lot of the professional node operators use. So that's a really good question.
01:00:11.454 - 01:00:35.862, Speaker A: Thanks for bringing that up. I'm glad you learned something. Hopefully we'll see you guys tomorrow for another question. Is there an option to use? Oh, another great question. Is there option to use Python? Yeah, again, you can use any language that you want. I will just say one thing. For the serverless architecture, Python is like a little bit slower but it still works and it's really easy because it's Python and Python is really easy.
01:00:35.862 - 01:01:02.960, Speaker A: And my first external adapter was actually written in Python. So if you do GitHub Chainlink external adapter template Python. Glad you guys enjoy that. That's really good feedback. Please don't write external adapters in assembly. So Thomas also made an external adapter in Python. That's really easy.
01:01:02.960 - 01:01:25.558, Speaker A: Python template. So yes, there's one in Python link pool has made some templates in go if you want to use go. They're all pretty straightforward. Well, I think they're straightforward, but, yeah. If you have questions again, feel free to just drop it in the discord and looking forward to see what you guys make. Time to write external adapters and assembler. All right, thank you, guys.
01:01:25.558 - 01:01:26.210, Speaker A: All right, bye.
