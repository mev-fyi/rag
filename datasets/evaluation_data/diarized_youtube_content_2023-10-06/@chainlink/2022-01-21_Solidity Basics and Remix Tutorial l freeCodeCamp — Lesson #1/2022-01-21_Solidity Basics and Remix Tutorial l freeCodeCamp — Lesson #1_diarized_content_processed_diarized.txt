00:00:08.650 - 00:00:38.374, Speaker A: Hi Al, and welcome to lesson one of the Freecodecamp solidity smart contract and blockchain tutorial. This is going to be the fundamental piece of learning everything about solidity. So in this lesson we're going to jump into what's called the remix ide and can start teaching you everything about solidity and how to write code and what solidity code looks like. So have fun. And remember, all the code is in the GitHub repository associated with this course. So with that, have fun.
00:00:38.492 - 00:00:56.702, Speaker B: Now again, in the description of this video, there is a link to this GitHub repository that's going to be the home base for all the code that we work with in this tutorial. We scroll down to this main section, this readme. There's a table of contents in here. We can go to lesson one, simple.
00:00:56.756 - 00:00:59.722, Speaker C: Storage, and we'll have links, helpful tips.
00:00:59.786 - 00:01:39.530, Speaker B: The itinerary of what we're going to learn, and everything else that you need to work with here. All the code that we're going to be working with is located in this simple storage link that we can go ahead and click. It's in its own different repository. We can go ahead and click the file to see all the code that we're going to be working with, so let's jump into it. Additionally, back in our full blockchain solidity course right at the top there's this resources for this course section. If you have questions engaging in GitHub discussions, stack exchange, Ethereum and Stack Overflow are going to be great places to get help and get support. I highly recommend making a stack overflow.
00:01:40.050 - 00:01:44.926, Speaker C: Stack exchange, ethereum and a GitHub account.
00:01:45.028 - 00:01:47.840, Speaker B: So you can participate and engage with the community.
00:01:50.130 - 00:02:24.746, Speaker D: Welcome to the remix Ide or the remix integrated development environment. This is going to be where we're starting to teach you how to work with solidity and work with smart contracts and deploy to blockchains. We're going to use Remix to get us up to speed as it has a lot of nice features that allow us to really see and interact with blockchains and really see what's going on. But eventually we're actually going to move off of remix to another platform. But all the solidity that we're going to learn here obviously is going to apply everywhere as well. When you come to remix, there's a whole lot of different plugins like solidity, learn, ETH, Soul, Hintlinter, and a whole bunch of other plugins as well.
00:02:24.848 - 00:02:25.914, Speaker C: I'm going to go ahead and start.
00:02:25.952 - 00:02:49.954, Speaker D: By clicking the solidity plugin but we're not going to use any of these plugins for now. But later on you can kind of go back and learn a little bit more about what these plugins do. So let's start perusing. Let's start coding some things. On the left hand side over here is where we're going to interact with everything. So let's go ahead and click the files up here. Now, you can always go back and peruse this a little bit more, and in fact, I highly encourage you to because that's how you're going to learn.
00:02:49.992 - 00:02:50.894, Speaker C: The most, the quickest.
00:02:50.942 - 00:03:21.014, Speaker D: But for us, we're actually just going to go ahead and start with our own brand new file. We're going to create a little application that can store information on the blockchain for us. And this is our first project that we're going to do in solidity. So we're actually going to create a new file and we're going to call it simplestorage Sol. All solidity has an extension of Sol at the end stands for solidity. Now let's take inventory of what we're going to be working with here. This is the solidity compiler tab.
00:03:21.014 - 00:03:45.010, Speaker D: It compiles all the solidity code down to machine understandable code or machine language here there's a whole bunch of different parameters we can choose when working with solidity. We can choose the compiler version, we can choose the language which we're only going to be working with solidity, the EVM version. Don't worry about this for now. So let's code our first solidity contract here. Now we are going to use something.
00:03:45.080 - 00:03:46.482, Speaker B: A little bit special here.
00:03:46.536 - 00:04:08.010, Speaker D: When we actually deploy these, we're going to use a JavaScript virtual machine. So we're going to use a virtual machine that's going to simulate actually deploying to a testnet or a real network. We're not actually going to deploy on a real network. We will in a little bit, but just to get started, we're going to work with a JavaScript VM, which is kind of a fake environment for now.
00:04:08.080 - 00:04:08.650, Speaker C: Okay.
00:04:08.800 - 00:04:53.340, Speaker D: Testing locally and understanding how to test locally will make your coding experience a lot faster. As you saw, when we sent some transactions, some of them actually took a lot of time to actually deploy. We don't want to have to spend that much time waiting around for our tests to actually finish. So we're going to use a JavaScript VM to kind of dummy it for now, but let's just start coding and go from there. So the first thing that you're going to need in any solidity program is the solidity version. So that's always going to be at the top of your solidity code. It's defined by doing pragma solidity and the version we're going to be using some version between 0.6.0
00:04:53.340 - 00:05:20.914, Speaker D: and 0.9.0. So we're saying we want to use anything between 0.6 and 0.9. And as a force of habit I just automatically hit command s whenever I write anything. So that's why you saw some of this pop up here. Hitting command s or control s, depending on if you're windows or not, will hit this compile button and will compile everything for us. Now if we want a specific version of solidity, we can also do 0.6.0.
00:05:20.914 - 00:05:24.130, Speaker D: And if I go ahead and hit command s or compile.
00:05:28.200 - 00:05:29.316, Speaker B: Our compiler will.
00:05:29.338 - 00:05:36.808, Speaker D: Automatically vert to 0.6.0. However, if I try to do 0.8.0 with my solidity at 0.6.0, it's going.
00:05:36.814 - 00:05:37.572, Speaker B: To give us an error.
00:05:37.636 - 00:06:01.648, Speaker D: It's going to say the source file requires a different compiler version. We're using 0.8.0 and this is 0.6.0. So we're going to go ahead and hit compile and it's got automatically moved down to 0.6.0. We can also do carrot 0.6.0 and this will allow us to work with really any version of 0.6. It'll work all the way up to 0.7,
00:06:01.648 - 00:06:10.484, Speaker D: where if we hit command s or control s there, it'll give us an error. So this only works with any version below 0.7 and above 0.6.
00:06:10.602 - 00:06:13.620, Speaker B: We're going to be using version 0.6.6.
00:06:13.690 - 00:06:15.556, Speaker D: However, in future contracts that we work.
00:06:15.578 - 00:06:23.988, Speaker B: With, we're actually going to work with different versions of solidity. The reason we're going to be changing versions throughout this course is that solidity is a constantly updating language.
00:06:24.084 - 00:06:58.384, Speaker D: Being good at switching between versions is going to make you an incredibly powerful smart contract engineer. The next thing that we're going to do is we're going to define our contract. So contract is a key word in solidity, which stands for our smart contract that we're going to create. You can think of a contract similar to a class in Java or any other object oriented programming language. So we're going to give our contract a name here. We're going to call it simple storage. We're going to add this little curly bracket to say this is the contents of our contract, simple storage.
00:06:58.384 - 00:07:23.832, Speaker D: And I went ahead and hit command s and we can see it is compiling successfully. You could hypothetically deploy this right now and this would be a valid contract. So great job for making it this far. Now, in solidity there are many different types that we can work with. Let's go into some of the types of solidity. We can have integers, aka whole numbers. They can be un, as in an unsigned integer, meaning they're not positive or negative.
00:07:23.832 - 00:07:53.508, Speaker D: We can also have an int and we would define a variable by doing UN 256. Favorite number equals five, so we have an unsigned integer. Un 256 means this is an integer of size 256 bits. So we can have this be upped, this number be up to 256. You can also do un favorite number equals five, but if you want to be a little bit more precise, a.
00:07:53.514 - 00:07:54.708, Speaker B: Lot of protocols and a lot of.
00:07:54.714 - 00:08:21.580, Speaker D: Smart contracts will do the whole name like UN 256. We can also have booleans. Booleans are true, false. So we can have boolean favorite bool equals true. So this favorite bool would be true. It could also be false. We can have strings string favorite string.
00:08:22.020 - 00:08:22.880, Speaker C: Equals.
00:08:24.580 - 00:09:12.572, Speaker D: String a string is a string of text here, right? It's going to be some word or phrase or really any of these keystrokes here, similar to the unsigned integer. We can have an int 256 favorite int equals negative five. So it could be positive or negative. We can have an address which is going to be some type of Ethereum address. So we could do address favorite address equals, and then we can even copy right from our metamask and just paste it right in here. This is going to be a valid address here. You'll also notice that we end all of our statements with a semicolon.
00:09:12.572 - 00:09:56.952, Speaker D: We can have a bytes object size 32 bits favorite bytes. For our example, we're just going to use the word cat because cat is a string which can be converted down into a bytes object bytes 32 means that there's 32 bytes in this variable, favorite bytes. We can also do bytes, two bytes, three bytes, five, et cetera, with a maximum size of bytes 32, for example. We can't do bytes 64. We're going to be talking about some other variables as well, like arrays and mappings. But let's just stick here for now. If you want to learn more about the different types and the different variables that you can use, head over to the solidity documentation and there's a link in the GitHub and at a description to show you this section.
00:09:56.952 - 00:10:00.588, Speaker D: For now, for our simple storage, let's say we only want to store numbers.
00:10:00.674 - 00:10:02.268, Speaker B: We don't want to store anything else.
00:10:02.434 - 00:10:35.400, Speaker D: So we're just going to go ahead and delete everything and just have un 256 favorite number at the top. Now, in solidity, if I do this, favorite number actually does get initialized, even though I didn't have it initialized to five. If I leave it blank, it gets initialized to the null value. In this case it would be initialized to zero. So for now, let's just not initialize it to anything. That way it'll get automatically initialized to zero. This means that when we deploy this contract, as of right now, favorite number will start off as zero.
00:10:35.400 - 00:11:18.070, Speaker D: If you get confused, you could also make a comment on this. You could say this will get initialized to zero. This double slash here is the way to make comments in solidity, and it won't get executed as code, so we can write whatever we want as long as it's preceded by two backslashes. Now let's go ahead and create our first function. Functions or methods are self contained modules that will execute some task for us, and in solidity it's the exact same thing. They're defined by the keyword function. Let's make a function called store that will change the value of this favorite number here.
00:11:18.070 - 00:12:09.328, Speaker D: So we're going to call store and we're going to allow it to be passed a variable. So we're going to allow it to be passed a variable of type unsigned integer 256, and we're going to call it underscore fave orit number. We're going to make this a public function which we'll get to in a minute. And all we're going to do is we're going to set favorite number equals to whatever variable we passed in favorite number. So this in its simplest form is how you can define a function. Now, just to visualize what we're working on so far, let's go ahead and deploy this contract so we can actually start to interact with it. So if we hit this button, this will bring us to the deploy tab and will allow us to deploy our smart contract here using our JavaScript VM.
00:12:09.328 - 00:12:50.004, Speaker D: It's given us a fake account with some Ethereum in it. It has 100 Ethereum in it to start and same as before, anytime we want to interact with the blockchain we have to pay a little bit of gas even in our fake virtual machine here, and we want to simulate that. So you'll see it has some of the same parameters here as making a transaction like gas limit, for example. When we deploy a contract, it's going to cost a little bit of Ethereum or a little bit of gas to do so. So let's go ahead and hit this deploy button and see what happens. So once we deployed with this virtual machine, a few things happened. We have remix kicking out this section down here saying, great job, you've deployed something.
00:12:50.004 - 00:13:30.656, Speaker D: And if we scroll down, it says transactions recorded. One, we can look at all the transactions we've recorded, and we can see it says deployed contracts, and we have a contract here that we've deployed. Now let's zoom out just a hair here so we can see everything a little bit better in this simple storage contract. We see this big store button, because there's one public function that we can actually interact with. So we can add this number here and we'll hit store, and you'll see again we have a completed transaction. And if we look at our contract, we'll have paid a little bit more gas, right? We'll have paid a little bit more to interact with this function, because again, anytime we want to make a state change on the blockchain, we have to.
00:13:30.678 - 00:13:31.948, Speaker B: Pay a little bit of gas.
00:13:32.044 - 00:14:05.150, Speaker D: The reason metamask isn't popping up is because we're kind of doing it in this simulated environment. So this is great. However, it looks like we can't actually see what our favorite number is. We can't actually look at it. So how do we actually make sure that we can view this favorite number? Well, let's add another parameter to this as well. If we add public to our favorite number, we recompile by hitting command s or hit the compile button. We delete this contract, and we redeploy and scroll down.
00:14:05.150 - 00:14:15.568, Speaker D: Now we'll see two buttons pop up this blue button to show us favorite number, which again is initialized to zero. And we have this store function.
00:14:15.734 - 00:14:17.120, Speaker B: So let's talk a little bit about.
00:14:17.190 - 00:14:55.484, Speaker D: Why this public variable allowed us to see this new button, this new favorite number button. This public keyword defines the visibility of the variable or the function. There are currently four different types of what's called visibility in solidity. There's external, public, internal, and private. We're mostly going to be working with public for now, but it's important to note how the rest of these work. Public functions can be called by anybody, including variables. So odly enough, variables are a function call to just look at them and return whatever that variable is.
00:14:55.602 - 00:14:58.364, Speaker B: An external function means it can't be.
00:14:58.402 - 00:15:00.760, Speaker C: Called by the same contract.
00:15:00.840 - 00:15:03.084, Speaker B: It has to be called by an external contract.
00:15:03.212 - 00:15:11.170, Speaker C: So if in this contract I had this be external, I couldn't call the store function.
00:15:11.860 - 00:15:26.944, Speaker B: I couldn't call the store function inside this function. Because the function is external, it means somebody outside of the contract has to call this function. Internal functions, however, can only be called by other functions inside of this contract.
00:15:27.072 - 00:15:28.880, Speaker C: Or in its derived contract.
00:15:29.040 - 00:15:44.088, Speaker B: And then private is the most restrictive. As private functions and state variables are only visible for the contract, they are defined in and not derived contracts. Now the reason that we didn't see favorite numbers show up in our original contract deployment is that if we don't.
00:15:44.184 - 00:15:47.084, Speaker C: Give a state variable a visibility, it.
00:15:47.122 - 00:15:49.976, Speaker B: Will automatically get set to internal.
00:15:50.168 - 00:15:53.116, Speaker C: So if we want other people to be able to read it, we have.
00:15:53.138 - 00:15:56.800, Speaker B: To change it to public. Now let's see how this interaction actually works.
00:15:56.950 - 00:16:00.736, Speaker C: If we hit the favorite number button right now, we'll get this call thing.
00:16:00.758 - 00:16:02.624, Speaker B: That shows up and it'll show us.
00:16:02.662 - 00:16:07.604, Speaker C: Right here that the value of favorite number is zero.
00:16:07.802 - 00:16:17.464, Speaker B: Now this function, however, is set so that whatever value we pass it is going to change the favorite number to whatever we pass it as. So if we pass one, two, three.
00:16:17.582 - 00:16:21.256, Speaker C: Hit store, that transaction goes through and.
00:16:21.278 - 00:16:48.816, Speaker B: Then hit favorite number, we can see the value is now one, two, three. Now, I will also be using transactions and smart contract interactions and function calls a little bit interchangeably. That's because on a blockchain, whenever you call a function or whenever you make some state change to the blockchain, you're actually also making a transaction. That's what makes this whole thing so powerful. And again, that's why making a function call or deploying a contract costs a.
00:16:48.838 - 00:16:49.884, Speaker C: Little bit of gas.
00:16:50.012 - 00:17:01.092, Speaker B: Now the reason we can access this favorite number variable inside this function is because favorite number has this global or contract scope. So even if we made un 256.
00:17:01.226 - 00:17:05.636, Speaker C: Test equals four or equals four, we.
00:17:05.658 - 00:17:07.700, Speaker B: Wouldn'T be able to use this variable.
00:17:07.780 - 00:17:09.752, Speaker C: Outside of this function, right?
00:17:09.806 - 00:17:13.540, Speaker B: Because it's self contained. It's self contained inside this bracket.
00:17:13.700 - 00:17:27.056, Speaker C: And if I were to make another function, store two, perhaps public store two.
00:17:27.158 - 00:17:46.304, Speaker B: Doesn'T know that this test variable exists. Functions only know about the variables that are in the same scope as them. So favorite number is in this global scope because the only bracket that's above them is simple storage. And test is in this store scope because it has two brackets above it. It's inside of this store function and inside of this contract.
00:17:46.352 - 00:17:47.476, Speaker C: Simple storage.
00:17:47.668 - 00:17:57.736, Speaker B: Store two isn't inside of this store function or this store scope, so it can't access this test variable. So let's go ahead and make this.
00:17:57.758 - 00:18:00.744, Speaker C: Back to public and we'll compile again.
00:18:00.782 - 00:18:02.488, Speaker B: I'm hitting command s to compile, but.
00:18:02.494 - 00:18:04.508, Speaker C: You can go ahead and click the button if you like and let's get.
00:18:04.514 - 00:18:05.116, Speaker D: Rid of this and get back.
00:18:05.138 - 00:18:06.664, Speaker B: Now, as you saw when we deploy.
00:18:06.712 - 00:18:09.356, Speaker C: This, there's this button here that we.
00:18:09.378 - 00:18:10.968, Speaker B: Can click called favorite number.
00:18:11.074 - 00:18:13.664, Speaker C: We can also make a function called.
00:18:13.862 - 00:18:16.880, Speaker B: Retrieve and make it a public function.
00:18:17.030 - 00:18:28.948, Speaker C: That is of type view and returns un 256. And all this is going to do is return favorite number.
00:18:29.034 - 00:18:32.308, Speaker B: So we're going to talk about views and returns here.
00:18:32.474 - 00:18:43.464, Speaker C: So I'm going to go ahead and compile, going to go ahead and delete this contract. Going to go ahead and deploy it now. And we can see now we have.
00:18:43.662 - 00:18:45.912, Speaker B: Two functions or two blue buttons here.
00:18:45.966 - 00:18:51.196, Speaker C: We have retrieve and we have favorite number. And if I change favorite number by.
00:18:51.218 - 00:19:14.764, Speaker B: Calling the store function, favorite number and retrieve will both now say it's one, two, three. So then the question might be, well, why is this one orange and these two are blue? And the key relies in this view function or this view keyword. There are two special keywords that define functions that you actually don't have to make a transaction on, and those keywords.
00:19:14.812 - 00:19:19.876, Speaker C: Are view and pure. A view function means that we want.
00:19:19.898 - 00:19:44.684, Speaker B: To read some state off the blockchain. So we're just reading off the blockchain. If we're reading off the blockchain and we're not actually making a state change, then we don't need to make a transaction. These blue buttons are blue because they are view functions. Public variables also have view functions, that's why both of these are blue. This technically is a view function and when I click it I get to view and I get to read the.
00:19:44.722 - 00:19:46.620, Speaker C: State off the blockchain.
00:19:47.120 - 00:20:02.864, Speaker B: Retrieve is the same way. We could have this without a return, but it wouldn't do anything. Pure functions are functions that purely do some type of math. We could have you at 256 favorite number public pure and just have favorite number plus favorite number.
00:20:03.062 - 00:20:10.692, Speaker C: So we're doing some type of math here, but we're not actually saving state anywhere. We're going to do this math, but.
00:20:10.746 - 00:20:14.548, Speaker B: We'Re not going to save this favorite number anywhere. We're not going to save anything.
00:20:14.714 - 00:20:18.856, Speaker C: Deploy this now this pure function, we.
00:20:18.878 - 00:20:21.000, Speaker B: Would have this retrieve function.
00:20:21.150 - 00:20:22.200, Speaker C: One, two, three.
00:20:22.350 - 00:20:29.544, Speaker B: It's blue as well because it's again not going to change the state of the blockchain. So view functions and pure functions are.
00:20:29.582 - 00:20:31.310, Speaker C: Both going to have this blue color.
00:20:32.960 - 00:20:37.676, Speaker B: Now the reason that nothing shows up at the bottom is because we didn't return anything.
00:20:37.858 - 00:20:39.964, Speaker C: All we're doing is we're saying add.
00:20:40.002 - 00:20:47.856, Speaker B: These two numbers together and that's it. In order for this function to give us something back, we need to have it return something.
00:20:47.958 - 00:20:56.928, Speaker C: So if we go back to this retrieve, to this retrieve function, we have.
00:20:56.934 - 00:20:58.592, Speaker B: To define what we're going to return.
00:20:58.726 - 00:21:03.252, Speaker C: When we're defining this function. So we're going to say this is a public function, it's a view function.
00:21:03.306 - 00:21:08.276, Speaker B: Because we're going to read some state and it's going to return a UN 256.
00:21:08.458 - 00:21:09.540, Speaker C: So favorite number.
00:21:09.610 - 00:21:22.830, Speaker B: It's a UN 256, so that's what we're going to return. Our public variable, favorite name is also a view function that returns a UN 256. For now, let's just remove that so we can work with this retrieve function.
00:21:23.280 - 00:21:25.916, Speaker C: So let's go ahead and deploy. So now we see we don't have.
00:21:25.938 - 00:21:33.244, Speaker B: This favorite number button anymore because it is no longer a public function because again it gets initialized to internal so.
00:21:33.282 - 00:21:35.004, Speaker C: We can't actually view it.
00:21:35.042 - 00:21:44.640, Speaker B: Now keep in mind later on we're going to talk about how everything on chain you actually can see. And we'll talk about that a little bit later though. So retrieve is going to do zero.
00:21:44.790 - 00:21:47.196, Speaker C: We can call store, and now retrieve.
00:21:47.228 - 00:21:57.424, Speaker B: Is going to be one, two, three. Now this application is great so far. It allows a single person to store a favorite number and then go ahead and retrieve it later, which is fantastic.
00:21:57.472 - 00:22:03.416, Speaker C: But what if we want a list of people or a group of people and store their favorite numbers?
00:22:03.518 - 00:22:20.350, Speaker B: Or what if we want to associate a favorite number with a single person? Well, what can we actually do? Now we have a whole number of different choices, but the one that we're going to talk about is using a struct. Structs are ways to define new types in solidity. They're almost like creating new objects as well.
00:22:20.800 - 00:22:27.120, Speaker C: So we can create a struct called type people and allow it to start.
00:22:27.190 - 00:22:30.144, Speaker B: Storing a favorite number associated with a certain people.
00:22:30.262 - 00:22:41.588, Speaker C: So inside of our struct we can have different types as well. So we can have a UN 256 favorite number and we could also have a string name.
00:22:41.754 - 00:22:43.364, Speaker B: Now we have a new type of.
00:22:43.402 - 00:23:00.670, Speaker C: Type people that has a favorite number and a name inside of it. Now what we could do with this struct is we could say people, public person equals, equals people.
00:23:01.680 - 00:23:04.632, Speaker B: And then inside we add the variables.
00:23:04.696 - 00:23:25.848, Speaker C: So we could say favorite number. Oh my God. Favorite number is two and name is Patrick. And then of course, the semicolon at the end. And again, I'm hitting command s to save, but you can also go ahead and compile in the compile tab.
00:23:26.044 - 00:23:28.112, Speaker B: So let's go ahead, delete this contract.
00:23:28.176 - 00:23:30.070, Speaker C: And see what this looks like now.
00:23:30.680 - 00:23:32.736, Speaker B: So now we've deployed this new contract.
00:23:32.848 - 00:23:41.560, Speaker C: And we have this person struct, which at the zero index is the favorite number. And the variable stored in the first.
00:23:41.630 - 00:23:56.220, Speaker B: Index is going to be the name. Storing variables in solidity always works in this numeric index fashion. In fact, in contract simple storage Un 256, favorite number is at index zero. If we were to add another object.
00:23:56.290 - 00:24:00.508, Speaker C: Here like boolean favorite bool, this would.
00:24:00.514 - 00:24:01.692, Speaker B: Be at index one.
00:24:01.826 - 00:24:13.212, Speaker C: If we were to add bool favorite bool two, this would be at index 2012. And it works the same in structs.
00:24:13.276 - 00:24:15.596, Speaker B: This is at index zero inside the struct.
00:24:15.708 - 00:24:18.352, Speaker C: This is at index one inside the struct.
00:24:18.496 - 00:24:22.688, Speaker B: So we can see the variables associated with this person. We're going to go ahead and delete.
00:24:22.704 - 00:24:24.916, Speaker C: This for now, because instead of just.
00:24:24.938 - 00:24:26.436, Speaker B: Creating one person, we actually want to.
00:24:26.458 - 00:24:28.580, Speaker C: Create a whole list of people.
00:24:28.650 - 00:24:30.632, Speaker B: So how do we create a list of people?
00:24:30.766 - 00:24:37.604, Speaker C: Delete that contract? And what we can do is we can make what's called an array. An array is a way of storing.
00:24:37.652 - 00:24:40.632, Speaker B: A list or a group of some object.
00:24:40.766 - 00:24:41.948, Speaker C: So as you're starting to see, the.
00:24:41.954 - 00:24:46.316, Speaker B: Way this syntax works for defining any type of variable is going to be.
00:24:46.418 - 00:24:49.720, Speaker C: The type of the variable, the visibility.
00:24:49.800 - 00:24:53.084, Speaker B: Of the variable, like public, or if you don't declare it, it gets initialized.
00:24:53.132 - 00:24:57.580, Speaker C: To internal and then the name of the variable.
00:24:57.740 - 00:24:59.500, Speaker B: It works the same with arrays.
00:24:59.580 - 00:25:01.388, Speaker D: So we'll make a people array.
00:25:01.484 - 00:25:21.816, Speaker C: The people array is the type. We'll make it public and we'll call it people. Now if we deploy this contract, we go ahead and see, we now have a people array, but if we click this button, you'll see that nothing shows up. And the reason is because it's an.
00:25:21.838 - 00:25:37.500, Speaker B: Empty array to start with, right? We don't have anything inside of it. Now this type of array that we've created is what's known as a dynamic array. It's a dynamic array because it can change its size. Right now it's of size zero. And if we added something to it, it's of size one.
00:25:37.650 - 00:25:42.428, Speaker C: You can also create arrays of a fixed size. So if I were to do people.
00:25:42.594 - 00:25:45.376, Speaker B: One public people, this array could only.
00:25:45.398 - 00:25:49.968, Speaker C: Have a maximum of one person inside of it. So we're going to work with a.
00:25:49.974 - 00:25:54.484, Speaker B: Dynamic array though, because we want to add an arbitrary number of people into here.
00:25:54.602 - 00:25:55.748, Speaker C: So let's go ahead and create a.
00:25:55.754 - 00:26:02.790, Speaker B: New function called add person where we can add a person to this array. So we'll do function, add person.
00:26:05.240 - 00:26:06.180, Speaker C: String.
00:26:06.540 - 00:26:14.970, Speaker B: Memory name and I'll talk about this memory keyword in a minute, un 256 favorite number.
00:26:18.650 - 00:26:22.300, Speaker C: And then we'll make this a public function.
00:26:25.430 - 00:26:30.514, Speaker B: And inside we'll do, we'll add this person to our array. The way to add a person to.
00:26:30.552 - 00:26:44.246, Speaker C: Your arrays is using the push method. So we're going to push a new people or a new person and we're going to give it those variables again. So we're going to give it, so.
00:26:44.268 - 00:26:44.854, Speaker B: We'Re going to give it.
00:26:44.892 - 00:27:13.166, Speaker C: Favorite number is this variable that we passed in here. Oops, this needs a bracket and then we're going to give the name, going to be this underscore name and then end bracket. Oops, zoom out again here, just so I can see stuff. This needs a semicolon and perfect.
00:27:13.348 - 00:27:45.078, Speaker B: Now in that last clip we saw this little red box pop up. Whenever a little red box like this pops up after you compile, it means you have a compile error. This means that there's something wrong with your solidity code or your solidity syntax and it won't compile and deploy properly. Red is going to be this compile error. Now we're going to see a bunch of yellow warnings in the future if you get a little yellow pop up. These are okay to ignore, but they usually have some helpful tips about something that might be going wrong in your code. So to summarize, if it's red, if it's red, it's broken.
00:27:45.078 - 00:27:47.962, Speaker B: If it's yellow, you might want to check it out, but it could be okay.
00:27:48.016 - 00:27:48.906, Speaker C: So we can see we have our.
00:27:48.928 - 00:27:51.454, Speaker B: New function add person where we pass.
00:27:51.572 - 00:28:06.994, Speaker C: A string memory name and a UN 256 favorite number. And then we create this people person, this people object here and then we push it onto our people array. And I'm going to show you another.
00:28:07.032 - 00:28:08.274, Speaker B: Way we can actually create a people.
00:28:08.312 - 00:28:18.020, Speaker C: Person is just by passing favorite number and name and getting rid of this other bracket by passing favorite number and name.
00:28:18.490 - 00:28:26.182, Speaker B: Because we know that the zero th index of people is favorite number and the first index of people is name. So we can also create a new.
00:28:26.236 - 00:28:28.418, Speaker C: Person by adding it like this.
00:28:28.524 - 00:28:57.390, Speaker B: Now let's talk about this memory keyword here. Now in solidity there's more or less two ways to store information. You can store it in memory or in storage. When you store an object in memory, it actually means that it'll only be stored during execution of the function or of the contract call. If we hold it in storage, that means that that data will persist even after the function executes. A string in solidity is actually technically.
00:28:57.470 - 00:28:58.706, Speaker C: Not a value type.
00:28:58.808 - 00:29:05.346, Speaker B: A string is actually an array of bytes, a variable of type string is actually a special type of array that.
00:29:05.368 - 00:29:07.106, Speaker C: We can append text to.
00:29:07.208 - 00:29:17.798, Speaker B: So because it's technically an object, we have to decide where we want to store it, in memory or in storage. And since we only need this name during the execution, we can have it be stringmemory name.
00:29:17.884 - 00:29:21.658, Speaker C: And then when we create this new people object, we will create a new.
00:29:21.744 - 00:29:40.494, Speaker B: Copy of this name variable into storage. Memory means that after execution delete this variable and storage means keep it forever. If this is a little bit confusing for you, just know that for now, when you use a parameter that's going to be a string from one of your functions, you need to call it string memory. So let's go ahead and deploy this.
00:29:40.532 - 00:29:48.066, Speaker C: Contract and see what happens now. Now we have this new function, add person, and since we are making a.
00:29:48.088 - 00:29:52.674, Speaker B: State change here, we can see that this indeed is a orange button instead.
00:29:52.712 - 00:29:54.738, Speaker C: Of being a blue button.
00:29:54.824 - 00:29:56.742, Speaker B: So we can add in here a string name.
00:29:56.796 - 00:30:01.942, Speaker C: We'll add Patrick and we'll say his favorite number is two. Again.
00:30:01.996 - 00:30:06.022, Speaker B: Right now if we look at people, see people zero, there's nothing in here.
00:30:06.076 - 00:30:08.038, Speaker C: If we retrieve there's nothing in here.
00:30:08.124 - 00:30:11.706, Speaker B: So we're going to add person patrick. And now if we hit people of.
00:30:11.728 - 00:30:14.378, Speaker C: Zero, we can see that the person.
00:30:14.464 - 00:30:16.186, Speaker B: At the zero width index in this.
00:30:16.208 - 00:30:30.382, Speaker C: People array is going to be string Patrick. If we try at one, there's nothing in here, let's add another person, we'll add becca and her favorite number will be 24. Let's add her.
00:30:30.516 - 00:30:37.422, Speaker B: Now if we hit one, we see favorite number, 24 string name is Becca and retrieve is still showing up blank.
00:30:37.486 - 00:30:40.658, Speaker C: Because we haven't touched favorite number. Awesome.
00:30:40.744 - 00:30:47.426, Speaker B: This is great. We can just keep adding people. However, there is kind of an issue here. What if I'm looking for a person?
00:30:47.528 - 00:30:49.646, Speaker C: What if I'm looking to find Becca.
00:30:49.678 - 00:30:52.070, Speaker B: And find her favorite number in this array?
00:30:52.410 - 00:30:53.846, Speaker C: What if I know her name but.
00:30:53.868 - 00:30:54.998, Speaker B: I don't know her favorite number?
00:30:55.084 - 00:30:56.166, Speaker C: Is there an easy way for me.
00:30:56.188 - 00:31:02.390, Speaker B: To find that favorite number without having to triage the entire array? There's another data structure called a mapping.
00:31:02.470 - 00:31:04.902, Speaker C: So let's create this new data structure.
00:31:05.046 - 00:31:06.538, Speaker B: So this data structure is going to.
00:31:06.544 - 00:31:08.022, Speaker C: Be of type mapping.
00:31:08.086 - 00:31:17.374, Speaker B: A mapping takes some type of key and spits out whatever variable it's mapped to. So in this case, if we're saying we want to use the name Becca to find her favorite number, we would.
00:31:17.412 - 00:31:27.810, Speaker C: Say the string Becca is going to be mapped to the UN 256 favorite number and similar to all the other.
00:31:27.880 - 00:31:31.790, Speaker B: Variable declarations, the first part is going to be the typing.
00:31:31.870 - 00:31:37.670, Speaker C: So this is going to be a type mapping of string mapped to UN 256.
00:31:37.820 - 00:31:39.762, Speaker B: We're going to give this public visibility.
00:31:39.906 - 00:31:45.618, Speaker C: And we'll call it name to favorite number and without adding any other functions.
00:31:45.634 - 00:31:46.294, Speaker D: That work with it.
00:31:46.332 - 00:31:50.758, Speaker C: If we deploy this, we can see we have this blue button because we're.
00:31:50.774 - 00:31:53.498, Speaker B: Not making a state change name to favorite number.
00:31:53.584 - 00:32:01.742, Speaker C: And if we type in Becca in here, obviously nothing's going to happen because we haven't added this mapping in yet.
00:32:01.876 - 00:32:07.118, Speaker B: So in our add person down here, let's even have this add person also.
00:32:07.204 - 00:32:14.146, Speaker C: Add to the mapping so we can do name to favorite number and then.
00:32:14.168 - 00:32:15.986, Speaker B: The key is going to be this name.
00:32:16.088 - 00:32:17.746, Speaker C: So of Becca, we're going to say.
00:32:17.768 - 00:32:20.510, Speaker B: We'Re going to map the name Becca.
00:32:20.670 - 00:32:40.906, Speaker C: To the favorite number. Now we're going to go ahead and compile again. I'm hitting command s deploy. We can scroll down here. If we look up Becca in here, we're going to get nothing. However, if we add Becca and her.
00:32:40.928 - 00:32:42.700, Speaker B: Favorite number being 24.
00:32:44.510 - 00:32:45.658, Speaker C: This add person.
00:32:45.744 - 00:32:47.194, Speaker B: Is going to add it both to.
00:32:47.232 - 00:32:49.846, Speaker C: The array and to this mapping.
00:32:49.958 - 00:32:58.846, Speaker B: Now if we look up name to favorite number, we see that Becca returns 24. Now one other thing I want to show you guys, just because compilers are going to yell at you if you.
00:32:58.868 - 00:33:00.878, Speaker C: Don'T have them, is typically at the.
00:33:00.884 - 00:33:07.874, Speaker B: Top of these contracts. You'll want to add an SPX license identifier. Basically solidity and the Ethereum community found.
00:33:07.912 - 00:33:09.934, Speaker C: Out that trust on a smart contract.
00:33:09.982 - 00:33:19.846, Speaker B: Can be better established if source code is available. And in terms of legality and copyright, it just makes life a lot easier. If you add that license identifier right.
00:33:19.868 - 00:33:21.746, Speaker C: At the top of your solidity, we're.
00:33:21.778 - 00:33:38.106, Speaker B: Going to use the MIT license identifier because it's the most open license out there. It means hey, anybody can use this code and we don't care. So you'll see a majority of solidity contracts have this SPX license identifier MIT at the top and compilers will yell at you a lot less.
00:33:38.208 - 00:33:38.810, Speaker D: Awesome.
00:33:38.960 - 00:33:42.022, Speaker B: We now have a contract that we've decided that we liked.
00:33:42.086 - 00:33:45.918, Speaker D: It's got mappings, it enables us to actually store people and their favorite numbers.
00:33:46.004 - 00:34:10.658, Speaker B: This is fantastic. We've done all of our testing in this JavaScript VM and we've decided, you know what, we want to deploy this to an actual testnet or an actual main net. How do we actually deploy this so that other people can interact with this contract? We are again going to use Rinkbee because that's what we use to make our first transaction. Now again, you will need some type of test Ethereum in your testnet wallet.
00:34:10.754 - 00:34:12.726, Speaker C: So again, if you get lost you.
00:34:12.748 - 00:34:16.886, Speaker D: Can always just Google Rinkby faucet or.
00:34:16.908 - 00:34:20.070, Speaker C: Rinkbe testnet faucet and find a faucet.
00:34:20.150 - 00:34:49.170, Speaker B: Or a better alternative would be to come to the link token contracts in the chainlink documentation at Docs chain link and scroll down. Or just look up rinkby. This link token contracts page has the most up to date faucets for any testnet that it supports. So for example, we get a testnet ETH faucet right here, which also just happens to be that exact faucet that we used earlier. The only thing you need to change in remix is we need to change.
00:34:49.240 - 00:34:52.500, Speaker C: From JavaScript VM to injected web3.
00:34:53.350 - 00:35:09.446, Speaker B: And metamask will actually pop up and say, hey, would you like to connect to this application? Anytime you're working with a web3 application, or a web application that wants to access your funds or work with your metamask, Metamask will pop up and ask for authorization first.
00:35:09.548 - 00:35:10.986, Speaker D: This is really good so that we.
00:35:11.008 - 00:35:17.434, Speaker B: Know which applications we're actually connected to. So we're going to go ahead and say next connect, and we can see.
00:35:17.472 - 00:35:35.986, Speaker C: Here that we've even connected here and that our account on the main network has zero ETH and remix even tells us hey, you're on the main network. So let's go ahead and switch to the rinkby network and we can now see we're on the rinkby network and.
00:35:36.008 - 00:35:46.286, Speaker B: We have 17.74 ETH on this rinkby test network. Injected web3 means we're taking our metamask and injecting it into the source.
00:35:46.318 - 00:35:48.214, Speaker C: Code of the browser here.
00:35:48.332 - 00:35:53.846, Speaker B: And that's the difference between injected web3 and JavaScript VM web3 provider is if we want to use our.
00:35:53.868 - 00:35:57.346, Speaker C: Own blockchain node or our own web3 provider.
00:35:57.458 - 00:36:00.774, Speaker B: When we do injected web3, we're saying our web3 provider is our.
00:36:00.812 - 00:36:42.994, Speaker D: Metamask, which will work perfectly for what we're trying to do. So since we already have some test on Ethereum, let's go ahead and deploy this and see what this would actually look like if we deploy to a main net. The process is going to be exactly the same, right? The only difference is we would be on the mainnet instead of rinkby. So let's go ahead, hit deploy. We'll uncheck published IPFs, hit deploy. Metamask will pop up asking if we want to do this transaction, because remember, we are deploying a contract, we are changing the state of the blockchain, so we have to pay a little bit of gas fee for it. So we're going to go ahead and hit confirm and we get a link to Rinkbeeth scan, similar, exactly as we saw before when we made a transaction.
00:36:42.994 - 00:37:29.494, Speaker D: The difference here is that instead of sending Ethereum to somebody, we're actually making a transaction on the blockchain to create a contract. After a short while, it will show up here on Etherscan with a success. The number of block confirmations, which again is the number of blocks appended to the block that included our transaction, we see from which is our account here. And we see to is this new contract that we just created, and we can even click it. And we see that there's this unique transaction hash that created a new smart contract. And same as working with the VM, we have all the exact same functions in here. And you can see if I hit retrieve these three functions, since they're not making a state change, you can just click them and no transactions will be made.
00:37:29.494 - 00:37:58.186, Speaker D: However, what do you think is going to happen if I hit store? If you guess Metamask will pop up, you guess correctly again. We see the familiar pieces here. We have a gas price, gas limit. Go ahead and hit confirm. We get another transaction here. And once this transaction goes through, we should be able to call our retrieve function and see a new number. If we call it now, nothing shows up because our original transaction hasn't succeeded.
00:37:58.186 - 00:38:18.338, Speaker D: But I bet if we look at it now, it's still indexing, but it looks like it's been included. If we hit it now, we do indeed see this value here. And we can do the same thing with adding a person. We'll add Becca. We'll say her favorite number is 24. Metamask will pop up. We'll go ahead and confirm the transaction.
00:38:18.338 - 00:39:14.050, Speaker D: And if I look up Becca and the name to favorite string right now, it's going to show nothing because our transaction hasn't gone through yet. But if we wait a little bit, I should probably spell her name right. We do see 24, and if we look at the zero width index, we also see Becca's been added here as well. Now, all this solidity code that we wrote, and when we interacted with this blockchain here, all this solidity was compiled down to the EVM, also known as the Ethereum virtual machine. A lot of the blockchains out there today are what's called EVM compatible, and that means that all this solidity and all these functions that we're creating can still compile down to EVM and deployed on their blockchain. You'll find out a little later when we look to work on a non ethereum based chain, that we can still deploy our solidity smart contracts to these other chains as well. But that's a term you'll hear more and more, the Ethereum virtual machine, or EVM.
00:39:14.050 - 00:39:46.286, Speaker D: Now take a break. Give yourself a high five, because you just deployed your first smart contract and you learned the basics, the fundamentals of solidity. So huge congratulations on how far you've gotten. Now, in our second project, we're going to take the fundamentals a step further and start going into the more of the intricacies of solidity. But just as a quick recap, the first thing you always got to do in your smart contracts is name the solidity version. Then you'll have to name your contract. A contract in solidity is like a class and defines all the functions and parameters of your contract.
00:39:46.286 - 00:40:09.602, Speaker D: There's many different types in solidity, like unsigned integer, 256 boolean, and bytes. We can create structs in solidity. We can create arrays in solidity. We can create mappings in solidity. We can create functions in solidity. View functions don't make a state change. Memory and storage are two different ways to initialize where a variable is going to be saved.
00:40:09.602 - 00:40:18.774, Speaker D: All the solidity code that we're working with gets compiled down to the Ethereum virtual machine. And last but not least, congratulations on taking your first step in learning solidity.
00:40:18.822 - 00:40:20.186, Speaker B: Let's move on to the next project.
00:40:20.288 - 00:40:20.554, Speaker C: Wow.
00:40:20.592 - 00:40:39.726, Speaker A: We learned a lot in this course, and we even deployed a smart contract for the first time. Awesome work. Congratulations. Hopefully now is a good time to take a short break and digest a lot of the wonderful information you just learned. Next up, we have more solidity and some really basic patterns for you to learn and you to deploy your smart.
00:40:39.758 - 00:40:48.270, Speaker C: Contracts with have funny.
