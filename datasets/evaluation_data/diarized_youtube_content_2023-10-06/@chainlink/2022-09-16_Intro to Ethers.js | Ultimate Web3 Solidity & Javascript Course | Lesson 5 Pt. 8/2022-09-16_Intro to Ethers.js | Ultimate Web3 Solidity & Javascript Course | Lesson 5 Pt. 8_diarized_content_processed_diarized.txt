00:00:10.090 - 00:00:17.166, Speaker A: EthersJs is one of the most popular Javascript based tooling kits that allows us to interact with different blockchains, and it.
00:00:17.188 - 00:00:19.358, Speaker B: Has all these wrappers that make all.
00:00:19.364 - 00:00:54.670, Speaker A: These API calls and do all these things with Ethereum and Polygon and avalanche and any EVM compatible chain. The other incredibly popular package that does the same thing is going to be web3 js. And you've probably heard about this and you'll probably see it a little bit more throughout this course and throughout your web3 journey. The reason that we're using ethers is that ethers is the main tool that powers the hardhead environment and I really enjoy it myself. And remember, if you ever get lost with any of this, you can always come back to their documentation to install it. As you can see here, you can just run NPM install ethers. We're just going to do yarn add ethers.
00:00:56.130 - 00:00:57.806, Speaker B: And now you should see in your.
00:00:57.828 - 00:01:01.198, Speaker A: Package JSon we now have ethers added in here.
00:01:01.284 - 00:01:03.438, Speaker B: Awesome. Now back in our code, we're going.
00:01:03.444 - 00:01:08.354, Speaker A: To import ethers into our deploy JS script so that we can use all the wonderful tools it comes with.
00:01:08.392 - 00:01:13.970, Speaker B: So we'll say const ethers equals require ethers.
00:01:14.310 - 00:01:40.982, Speaker A: For those of you doing the typescript edition of this course, this will be import instead of require. Now that we have ethers in here, we can create our provider object in our main function. The reason we pull ethers outside of the main function is because we do want to pull our package into our script before we call main. We want to make sure all of this is done first. So you'll see this is kind of the normal setup of our scripts. At the top. We import any dependencies or external packages.
00:01:40.982 - 00:02:02.498, Speaker A: We'll have our main function and then we'll call our main function at the bottom. Const is a keyword similar to let. The const keyword makes it so that ethers can't be changed, so we can't change our ethers variable. Anytime we use const, require is a function for us to import the ethers package. Now remix does all this behind the scenes, but the way we're going to do it in our code here is.
00:02:02.504 - 00:02:18.434, Speaker B: We'Re going to say const provider equals new ethers providers jSonrpc provider and then we're going to pass this string as our provider.
00:02:18.482 - 00:02:22.970, Speaker A: So we're saying, hey, we're going to connect to this URL right here.
00:02:23.040 - 00:02:23.370, Speaker B: Awesome.
00:02:23.440 - 00:02:39.246, Speaker A: So this is the way that our script is going to connect to our blockchain, our local blockchain now let's get an actual wallet here with a private key and a balance and everything. We can see all of our wallets and private keys in our ganache here. So the way to get this set.
00:02:39.268 - 00:02:42.634, Speaker B: Up is we can say const wallet.
00:02:42.762 - 00:02:51.454, Speaker A: Equals new ethers wallet. And this wallet function takes in a couple of input parameters like a private key and a provider.
00:02:51.502 - 00:02:52.994, Speaker B: To get a private key, we'll go.
00:02:53.032 - 00:02:54.898, Speaker A: To Ganache here and just choose one.
00:02:54.904 - 00:02:58.806, Speaker B: Of these private keys and we're going to paste this right into our code.
00:02:58.908 - 00:03:00.130, Speaker A: And then we're going to do comma.
00:03:00.210 - 00:03:02.406, Speaker B: Provider and save that.
00:03:02.508 - 00:03:44.674, Speaker A: Now, pasting your private key directly into your code is a huge no no and we're going to learn how to avoid this in the future. It's okay. Right now since we're just using one of the Ganache private keys and you have no risk of having any money associated with this account. These two lines alone give us everything that we need to interact with smart contract. They give us our connection to the blockchain and they give us a wallet with a private key so we can sign different transactions. If you remember back to our blockchain basics section, this is the private key that we're using to sign all of our transactions to encrypt our transactions. Now that we have a provider and a wallet, let's go ahead and grab our contract objects from these two files here.
00:03:44.674 - 00:03:58.706, Speaker A: In order to deploy our contract, we're going to need the ABI and we're going to need the binary compiled code of the contract. So we're going to need to read from these two files. To read from these two files we're going to need to use a package called FS.
00:03:58.818 - 00:04:00.266, Speaker B: So back at the top we're going.
00:04:00.268 - 00:04:26.034, Speaker A: To do const FS equals require fs extra. I auto save all the time. You'll see like I'll do something and then my white dot will go away a lot. It's because my fingers have a habit of pretty much anytime I stop typing I save. So please remember to save early and often. This fs extra should come directly with your node project, but if not you can always add it with yarn. Add fs extra.
00:04:26.152 - 00:04:28.510, Speaker B: You should see it in our package.
00:04:28.590 - 00:04:36.210, Speaker A: Json now we can get the ABI and the binary. We can say const ABI equals fs.
00:04:36.550 - 00:04:40.758, Speaker B: Read file sync which means we're going.
00:04:40.764 - 00:05:04.880, Speaker A: To synchronously read from this file. We could do it asynchronously, but we want to wait for this file to get done. So we're going to say read file sync. And depending on your vs code, if you scroll over you might even get some information about this function pop up like this, which can be really helpful. We can see that we need the path for the file we want to read and then any options as well. Path of file that we want to read to get the ABI located at.
00:05:05.730 - 00:05:18.418, Speaker B: Simplestorage underscore Sol underscore simplestorage ABI. And then we're going to do a comma of UTF eight.
00:05:18.504 - 00:05:25.986, Speaker A: This UTF eight is the encoding that we do for this file here. Don't worry too much about what that means for now. So we need the ABI and we.
00:05:26.008 - 00:05:29.218, Speaker B: Also need the binary which is in.
00:05:29.304 - 00:05:35.026, Speaker A: This second file, symbol storage underscore Sol underscore symbol storage bin.
00:05:35.138 - 00:05:36.770, Speaker B: So we're going to say const binary.
00:05:36.850 - 00:05:40.310, Speaker A: Equals fs read filesync.
00:05:40.390 - 00:05:51.706, Speaker B: We're going to give it the path here which is going to be simple storage soul simplestorage bin and then the.
00:05:51.728 - 00:05:53.670, Speaker A: Encoding option which again is going to.
00:05:53.680 - 00:05:55.614, Speaker B: Be, and it should look like this.
00:05:55.732 - 00:06:08.974, Speaker A: Now that we have the binary, we have the ABI, we can create something called a contract factory, which is not to be confused with the factory pattern in ethers. A contract factory is just an object that you can use to deploy contracts.
00:06:09.022 - 00:06:21.126, Speaker B: So we're going to say const contract factory equals new ethers contract factory and.
00:06:21.148 - 00:06:23.458, Speaker A: We'Re going to pass it the ABi.
00:06:23.634 - 00:06:29.046, Speaker B: Binary and the wallet. We pass the ABI so that our.
00:06:29.068 - 00:06:40.938, Speaker A: Code knows how to interact with the contract, the binary obviously because this is the main compiled code in our wallet so that we have a private key we can use to sign deploying this contract. Then I usually like to write a.
00:06:40.944 - 00:06:45.760, Speaker B: Little console log saying something like deploying these, wait.
00:06:46.930 - 00:06:49.050, Speaker A: And we can actually deploy this contract.
00:06:49.130 - 00:06:59.170, Speaker B: With ethers by doing const contract equals await contractfactory deploy.
00:06:59.590 - 00:07:11.320, Speaker A: Now this is the first time we've seen this await keyword and you can only use the await keyword inside of an async function. The reason we want this await keyword, we're telling our code to stop here.
00:07:11.690 - 00:07:14.898, Speaker B: Wait for contract to deploy.
00:07:15.074 - 00:07:28.790, Speaker A: And this await keyword means that this will resolve the promise contract. And this contractfactory deploy with the await here returns a contract object. So now I could do something like console log contract.
00:07:28.950 - 00:07:38.910, Speaker B: Let's see what happens when we run this code node deploy js we scroll up, we see deploying, please wait.
00:07:38.980 - 00:08:18.198, Speaker A: And then we see this massive object that gets printed out. This is the contract object that we just deployed. And in fact if we go over to our ganache, we can see that the address that we use for our wallet has a little bit less balance and has a transaction count of one. If we were working with truffle, we'd be able to see the contracts here. We're working with hard hat, so you won't be able to see the contracts in here. But if you go to transactions we can indeed see the transaction that we just created. This is similar to Etherscan, but for our local blockchain we can see the sender address, the creation address, the value gas price, all this stuff associated with this contract.
00:08:18.198 - 00:08:35.630, Speaker A: We can also see the different blocks. Since we've only made one transaction, only one block has been mined. And this is awesome. We have all this other stuff associated with it. Great job. You just deployed a contract to your own local blockchain with ethersjs. This is fantastic.
00:08:35.710 - 00:08:40.978, Speaker B: Awesome work. Now let me show you what happens.
00:08:41.064 - 00:09:10.186, Speaker A: If we don't use the await keyword here. We're not telling our code to stop, we're saying hey, deploy this contract and then just keep going. So we never actually check to see if this deploy function finished. So let's see what happens when we run this instead. Instead of that big contract object, we get this promise in its pending state because our code actually finished before our contract could finish deploying. So we see promise pending here instead. This is why the await keyword is so important.
00:09:10.186 - 00:09:37.038, Speaker A: We're saying hey, wait for this to finish. The await keyword also resolves a promise, so it'll wait for the promise to exit its pending state and then it'll return whatever the pending promise returns. So contractfactory deploy returns a promise that returns a contract. In fact, if we go to the ethers documentation, we look up deploy in here we can see contract factory methods, contractfactory deploy.
00:09:37.214 - 00:09:39.606, Speaker B: If we look at the definition of.
00:09:39.628 - 00:10:12.910, Speaker A: The function, it says contractfactory deploy takes a whole bunch of arguments and some overrides. This arrow is saying this is what it returns. It returns a promise that resolves to a contract. And that's why we need this await keyword because contractfactory deploy by itself just returns a promise. But if we do await contractfactory deploy, we're saying it returns a promise that resolves to a contract and we're waiting for it to finish deploying to resolve to a contract object. So that's going to be a major difference here. Awesome work.
00:10:12.910 - 00:10:25.360, Speaker A: So that's going to be why this await keyword is so important. And again, you can only do that in asynchronous functions. So you need this async keyword at the top of your function names you.
