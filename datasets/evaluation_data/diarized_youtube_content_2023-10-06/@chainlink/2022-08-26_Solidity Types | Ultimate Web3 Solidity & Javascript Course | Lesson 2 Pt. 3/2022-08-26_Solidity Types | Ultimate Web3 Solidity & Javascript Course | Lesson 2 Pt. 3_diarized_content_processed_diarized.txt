00:00:11.690 - 00:00:25.238, Speaker A: Now, solidity has multiple different types or primitive data types, and if you go to the solidity documentation, which again is in our GitHub repository, you can read more and learn more about the different types that are in here. The foremost basic types are going to.
00:00:25.244 - 00:00:30.262, Speaker B: Be boolean, un, int, and an address.
00:00:30.396 - 00:00:51.034, Speaker A: Or bytes which is a lower level type which we'll talk about a little bit later. A boolean defines some type of true false. A Un is going to be an unsigned integer, which means it's going to be a whole number that isn't positive or negative. It's just positive. We have an integer which is going to be a positive or negative whole number. And then we have an address which.
00:00:51.072 - 00:00:53.194, Speaker B: Is going to be an address like.
00:00:53.232 - 00:01:14.900, Speaker A: What we see in our metamask here. There are some other types as well that you'll learn later on. The reason that we have these types is we use them to define what different variables are. Variables are basically holders for different values. For example, we could create a variable called has favorite number to represent if somebody has a favorite number.
00:01:15.270 - 00:01:17.890, Speaker B: And we would put this bool keyword.
00:01:17.970 - 00:01:46.922, Speaker A: Before has favorite number to say, okay, we have a variable called has favorite number and it's of type boolean. So this has favorite number is going to represent a true or a false to set its value. We could say has favorite number equals true. Now has favorite number is going to be true. We could also say has favorite number equals false. So this boolean has favorite number is now going to be false. For Un, we could say un favorite.
00:01:46.986 - 00:01:51.438, Speaker B: Number equals and then set a number, one, two, three.
00:01:51.524 - 00:01:59.426, Speaker A: This means that our favorite number is going to be one, two, three. Un is special because we can actually specify how many bits we want to.
00:01:59.448 - 00:02:01.010, Speaker B: Allocate to this number.
00:02:01.080 - 00:02:30.342, Speaker A: Bits and bytes are pretty fundamental pieces of information for computer science. We're not going to go over it here. However, there's a fantastic video in the GitHub repository that explains it more. Basically, it's how much storage or memory to allocate to this number. How big can it get? If we say a uint eight, it can have eight bits all the way up to UN 256. If you don't specify how big it is, it automatically defaults to UN 256. Oftentimes it's better when writing our code to be very explicit.
00:02:30.342 - 00:02:41.966, Speaker A: So usually you'll see me just do uint 256. To represent a UN 256, we could also do an INT favorite number equals one, two, three, or an INT 256. I'm just going to go ahead and.
00:02:41.988 - 00:02:43.678, Speaker B: Add this Boolean back here, we're going.
00:02:43.684 - 00:02:51.486, Speaker A: To change this back to UN 256 and let's change our favorite number to five here. We could also do something called strings string.
00:02:51.678 - 00:02:57.620, Speaker B: Favorite number in text equals five.
00:02:58.010 - 00:03:08.634, Speaker A: Strings represent basically words, and you can represent them by putting them in these quotes. It's going to be some word or phrase or really just kind of any combination of keystrokes in here.
00:03:08.672 - 00:03:12.950, Speaker B: Our ints can be positive or negative.
00:03:13.030 - 00:03:16.540, Speaker A: So we could say negative five or positive five.
00:03:16.910 - 00:03:26.526, Speaker B: Both are going to be valid ints. We can also do address my address equals and grab our address right from.
00:03:26.548 - 00:03:37.314, Speaker A: Metamask and paste it in. You'll notice that we end all of these lines of code with the semicolon. We can also have bytes object or a bytes 32, again representing how many.
00:03:37.352 - 00:03:44.372, Speaker B: Bytes we want them to be. And this says that we have called.
00:03:44.426 - 00:04:25.412, Speaker A: Favorite bytes, and we're just going to set it equal to cat. So strings are actually really interesting because strings are secretly just bytes objects, but only for text. So cat is actually a string, but can automatically get converted into one of these bytes object. Bytes objects typically look like zero x and then some random letters and numbers that represent the bytes object, but cat can automatically get converted down to bytes. We'll talk about bytes more in coming sessions. You could also do bytes, two bytes, three bytes, five bytes 22. You get the picture for our uns and our InT 256, lowest we can go is eight bits because eight bits is a byte, and we can go up by steps of eight.
00:04:25.412 - 00:04:35.510, Speaker A: So we can do 816 32, et cetera, all the way to 256. For example, down here we can't do bytes 64.
00:04:36.200 - 00:04:43.576, Speaker B: And if we go ahead and try to compile this, we get a little red thing here. And if we scroll down we get.
00:04:43.598 - 00:04:49.844, Speaker A: A declaration error identifier, not found or not unique. Byte 64, favorite bytes equals cats.
00:04:49.972 - 00:04:51.144, Speaker B: And we even get a little red.
00:04:51.182 - 00:05:15.420, Speaker A: Warning sign here in our remix. This is remix telling us there's something wrong with this line so we can switch back to byte 32. Since bytes 32 is the maximum size that a bytes can be, you could also do just a bytes object, which means it can have any size. But we typically want to be explicit, and we're going to stick with bytes 32 for now. If you want to learn more about the different types and how to use them and all the different features with them, be sure to check out the.
00:05:15.430 - 00:05:17.124, Speaker B: Solidity documentation for now.
00:05:17.162 - 00:05:24.580, Speaker A: For our simple storage, let's say we only want to store numbers. So let's go ahead and delete everything except for the favorite number section.
00:05:27.000 - 00:05:28.112, Speaker B: Now in solidity.
00:05:28.176 - 00:06:13.776, Speaker A: If I do this and I remove the equals five, this favorite number actually does get set to a default value. The default value for solidity is going to be whatever the null value is, which in solidity's case is zero. So saying un 256 favorite number is going to be the same as saying un 256 favorite number equals zero, since it gets initialized to zero. So for now, let's not initialize it to anything, so that favorite number will automatically start off as zero. Now, if you get confused as you're coding along and you're following along with me, be sure to write comments in your code so you know what's going on. So maybe, for example, a great comment here would be this gets initially allied to zero. And then if that's even confusing you.
00:06:13.798 - 00:06:28.580, Speaker B: You could say this means that this section is a commentary.
