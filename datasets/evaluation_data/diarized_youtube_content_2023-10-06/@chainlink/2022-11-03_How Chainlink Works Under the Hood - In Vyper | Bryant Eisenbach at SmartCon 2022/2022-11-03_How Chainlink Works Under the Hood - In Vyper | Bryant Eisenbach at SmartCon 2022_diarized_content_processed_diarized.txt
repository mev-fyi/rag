00:00:09.050 - 00:00:29.510, Speaker A: How about now? Okay, that's better. Hey, everyone. So, my name is Bryant. I work for a company called Aborks. We're a smart contract dev tool written in Python, very friendly for python developers and data scientists. Today, I'm just going to go really briefly, kind of first principles. Look at how you would an oracle using Viper, which is kind of a programming language people are excited about.
00:00:29.510 - 00:01:09.102, Speaker A: You can learn a little bit more about Viper, learn a little bit more about ape, which is our product, and just learn a little bit more about oracles. So really quick, this is kind of the overview what we're going to go through. It's a little tight on the slide deck, so any questions you have, save them for after the session, I'll answer in the back. So first, what is an oracle? What does it do? Basically, it's a purveyor of off chain information into the on chain environment. Because the on chain environment is sort of a walled garden. You need a way to import external information from the outside world into the chain environment. We also want that information to be safe, accurate and timely.
00:01:09.102 - 00:01:42.246, Speaker A: Right. So we don't want to be old, we don't want to be incorrect, and we want to make sure that we can rely and trust on it, because this ends up being really critical infrastructure for a lot of different types of applications. So how can we build one? I'm going to show that link there at the end as a QR code so you can scan it. But we have a repo reproducing this whole talk. We're going to build it using Viper, which is a python based smart contract language, and ApE, which is our framework for development of smart contracts for educational purposes only. It's just an example. There's a lot of gotchas.
00:01:42.246 - 00:02:35.098, Speaker A: I'm going to go over more at the end what the Gotchas are, and this is kind of the final look at what we're going to build at the end. So first off, what is an oracle? How do we build one? So this is kind of the most basic form of that written in viper. So we have a state variable price, which is public, which means you can reference it on chain, and we have a method set price, which will allow you to update that value from the off chain source into the on chain environment. It's unauthenticated right now, which means anyone can post an update to it, which is kind of bad. But we'll talk more about that. Last thing to mention is we have a little note at the top about the conversion factor at play, and it's always important to keep in mind what the decimals, the amount of decimals, conversion rates that you're talking about are. So here's how we're going to test it in ape.
00:02:35.098 - 00:03:17.978, Speaker A: Ape uses Pytest, which is a pretty awesome python based framework for testing. And we're going to create two fixtures which are kind of artifacts that you can use throughout many different types of tests. We're going to make a deployer account which is just fetching one of the test accounts so we can reuse it and have the special name deployer. And then the second on line eight you can see we have an Oracle fixture which is our deployment of the Oracle smart contract. You can see kind of on as an input argument to that we have project which is a built in fixture with ape and deployer which is the one we referenced from above. We have the deployer deploy the contract. So the test is going to look very simple too.
00:03:17.978 - 00:04:10.862, Speaker A: We're going to take in that Oracle contract, the deployer, and basically the deployer is going to update the price to 1500 and we're going to see that we can reference the price as 1500. So that's great, but should we let anyone update this price? Probably not, because they can update it to whatever they want and that can be bad. So we're going to add another variable called Oracle which is going to track the accounts that is allowed to make the update during deployment. We're going to track that as the deployer of the contract. Basically if we trust the deployer we can trust the updates. We're going to add an extra line on line 22 to basically gate the deployment to make sure that it only occurs from the account that is allowed to post a price update. So for testing we're going to add an extra account reader which is basically just another account that isn't the deployer so that we can show this functionality in the test.
00:04:10.862 - 00:04:38.246, Speaker A: So lines five through seven, basically the reader or any other account cannot perform an update of the price. Only the deployer account can. Right. So on line ten, only the deployer account can update similar to the previous part of the version of the test and then we can see the price. So being on time is actually really important. We want to make sure that the data is very timely. Right.
00:04:38.246 - 00:05:29.814, Speaker A: So we're going to add some extra functionality to basically ensure that the time between updates is basically about five minutes. So we create a constant called Max update delay that'll ensure that at least five minutes have passed between updates and then we're going to add another state variable called last update, which is going to track the last time the price was updated. It's public, so that means you can reference it on chain, which means if you read the price, you also want to read the last update time to see if it occurred within the time frame that you're looking for. Right. So inside the set price function we're going to add an additional line on line 28 that's going to check that at least five minutes have passed between the last update and the update being occurring now. And then we're going to track that last update as the current block timestamp line 31. So in our test we're going to add some extra stuff here.
00:05:29.814 - 00:06:02.558, Speaker A: So lines five through ten are basically the same as they were before. Line twelve through 14 there. We're now going to check to see that if there's no time elapsed between the last update and the one we're trying to do now, it will reject the update. And now on line 16 we're going to advance the time on the test chain by five minutes. And then on line 17 we're going to update that price to 2000 now and show that the price was updated. But here's really the important question. Right, so we have this oracle address.
00:06:02.558 - 00:07:03.806, Speaker A: Do we really trust it? Where is it getting its information from? Is that information source an accurate source of information? So we're going to use something called the open Oracle standard that didn't really take off too much. But basically Coinbase has a authenticated price feed that's signed by one of their infrastructure signers and you can take that price feed and basically replay it on chain, an on chain environment. It's kind of similar to what Chainlink does under in the hood, but obviously much more complicated. So when we deploy it now we're actually going to track this oracle address as an external address, not the deployer of the contract because we don't control that address anymore. And we're going to show in the set price function. It gets a lot more complicated now, but basically the message that's being signed is the timestamp on which the price update occurred and the price that we're tracking. RSV are the signature components of the signature made by the signer that Coinbase is operating.
00:07:03.806 - 00:08:03.062, Speaker A: We're basically going to show that when we take in the time we take in the message that we recover the signer of the message using the signature will obtain the open Oracle signer account that Coinbase is operating. So that's kind of lines 35 through 38 we're also going to add one more check on line 31 that shows that the time of the message, the price update occurred within the past five minutes to basically make sure that the data we're getting is accurate or as timely as well. Right? So not only do we have this check that there's at least five minutes space between updates. Now we have a check that when an update occurs it's from the past five minutes worth of time. So that kind of creates a reliable update procedure. So with the test we're going to update our fixtures a bit more. So you have to update the deployment of the Oracle contract to add the signer account.
00:08:03.062 - 00:09:06.218, Speaker A: The signer account for the purpose of the test, we're going to mock out with just another test account and we're going to add this encode message function which basically lets us convert timestamp and a price value into an Ethereum EIP 191 format for signing. So now our test is going to be updated more significantly this time we're going to take the time of price data, encode that message, get it signed by our signer account, deploy that price on chain and see that the price updates to the price that was signed. Next we're going to update the price but not update the time because there hasn't been enough time elapsed between the last update and this one. We're not allowed to make that price update. And finally, if we do update the price or we do update the timestamp on the chain and to five minutes in the future. Now if we sign that price and timed update, it'll be allowed to pass and we'll be able to show a price update to 2000. Okay, that's great.
00:09:06.218 - 00:10:05.134, Speaker A: Now that we have kind of fully working contract, or at least for the purpose of this demo, how do we ship it to production or basically launch on a testnet, see it in operation? So ape has advanced functionality around developing command line applications using the click framework. So we export a bunch of different utilities for creating command line applications, like a network option. So basically which network you want to work with on chain? An account option, basically which account from the previously registered set of accounts that you control keys for that you want to use to perform the script. And then now we're adding an extra option for the signer and the default value will be the coinbase signer. But if you wanted to test with another signer application for the purposes of just testing it, you can't. So the last line there will take in all that information, deploy the contract with the signer account and you're ready to go. We have a second script here and this one's more interesting.
00:10:05.134 - 00:11:00.254, Speaker A: This is going to be a daemon script. And basically what this is going to do is keep watching for updates from the Coinbase signed price feed through their API and convert it to the format we need to publish on chain. And then we're going to pull blocks. Basically, this is an infinite iterator just going forever in the future until you click stop and anytime every five minutes, which is line 56, it's going to see that it's able to post a new update, go fetch the update from the Coinbase Pro API and then publish that update on chain. So lastly, how can we screw this all up? There's a lot of things we're not considering here. It's important that we understand this because this is a very basic example and kind of the outcome here is a lot of these things have already been considered. Like Chainlink is a great example of this.
00:11:00.254 - 00:11:42.202, Speaker A: They've thought of a lot of redundancy, robustness, incentive issues. It's just important to use a robust, battle tested oracle like that. So there are many pitfalls, but let's go through a couple of them. Really one of the biggest ones is incentives. Like why would I run this infrastructure? What's the value to me? Like how do I earn money from it? Because it does cost a lot of money to actually run this, right? So there's not a robust incentive model behind running the oracle. No one's going to run it and you can't rely on it because it's not being updated frequently enough. Also kind of with incentives is that the cost associated with publishing the price feed is variable because gas costs are variable depending on network utilization, and they can vary a lot.
00:11:42.202 - 00:12:21.338, Speaker A: They can be a couple of dollars to hundreds of dollars, maybe sometimes even thousands, depending on network congestion. So you need an incentive model that ensures that no matter what this price update gets published on chain because it's going to be used in money market applications and others where it's really important to have that source of information. So along with that, we are only using the Coinbase Pro API right now. What happens if that infrastructure goes down? Right? So that's a centralized piece of infrastructure. You can only rely on it as much as they're as good as running it. So if one provider goes down, you lost your entire data feed. That's not great.
00:12:21.338 - 00:13:19.130, Speaker A: So you probably want to use multiple data providers. So this is kind of how Chainlink works. It fetches from multiple providers and basically rectifies the price into a single value. How do you build that into the smart contract system? That's kind of secret sauce, so that if one provider goes down, you have all the other ones and you can maintain a consistent price feed. But what happens if the price feed doesn't go down but it has a glitch in it? Maybe the signer infrastructure has a bug that's been exploited by some hacker or something, or there's just a large market movement on that specific exchange where the price value fluctuates a lot. Right? So we need a way of basically waiting, like average weighting the price updates so that outliers get tracked and removed from the data set. So all of those are kind of important to how do you build production oracle applications? There's a lot more things that I just don't know because I don't work on this every day.
00:13:19.130 - 00:13:46.206, Speaker A: But it's a really interesting topic, and I feel like being able to replicate this experiment using any project is a great way to understand how to build these things. That's it. That's it for my talk. I'll take questions in the back. We have about a minute left, but here's a link to the project. If you want to go check it out, you can download this project, run it locally, launch it. It's all using ape.
00:13:46.206 - 00:14:05.400, Speaker A: So you have to install ape first. Go to apeworks IO, ape W O R X IO, and you can learn how to install the framework, run this project, and kind of learn more yourself. So, yeah. A minute left. Any questions? You can come find me in the back. Thank you so much.
