00:00:01.130 - 00:00:14.350, Speaker A: Hi, I'm Richard, one of the developer advocates at Chainlink Labs. And today we're going to take a look at a way to use a contract to create self automating counters.
00:00:15.890 - 00:00:17.440, Speaker B: So let's dive in.
00:00:23.490 - 00:01:05.554, Speaker A: All right, as with, with almost every tutorial, the best place to start is the documentation. If you head to automate contracts and you take a look, there's something new, if you haven't noticed it already, and that's that we have time based automations as well as custom logic automations. Now, time based automations essentially mimic a cron tab and allow you to use that to automate any contract based on a time schedule. But today we're going to take a look at custom logic automations. These are the ones that have a check upkeep and perform upkeep function. But we're going to go a step further. We're going to create a contract that can automate itself.
00:01:05.554 - 00:01:07.300, Speaker A: So let's dig into that.
00:01:08.390 - 00:01:09.586, Speaker B: All right, here you can see an.
00:01:09.608 - 00:01:49.518, Speaker A: Explanation of how to create a contract with that custom logic that includes check upkeep and perform upkeep. But if you scroll down a little bit further, you'll notice there's an example here about creating an upkeep from your own contract. This is what I'd like to dig into today and take a look at how to use this to create self automating contracts. This example can take you straight to remix if you click the open and remix button down here at the bottom. But before we head to remix, I want to talk about a couple of things. The first are these parameters that you would pass into the contract. You have things like the name of.
00:01:49.524 - 00:01:52.302, Speaker B: The upkeep, an email which isn't used.
00:01:52.356 - 00:02:09.942, Speaker A: When you're registering them from a contract, and a few other items. We'll look at them a bit more in depth when we look at the actual contract. The other piece of information that is key are these registry and registrar addresses. Now, the address will depend on what.
00:02:09.996 - 00:02:11.800, Speaker B: Network you're deploying to.
00:02:12.490 - 00:02:54.478, Speaker A: In this case, we'll be using the go early test network. So we'll need those addresses to deploy to that test network. The final piece of information that you'll need you can actually find over here on the left at the bottom of our documentation, the link token contracts. You will need the address of the link token on the network that you're deploying to. So that's a few things to keep in mind, but let's head to remix and take a look at the contract itself. So here we have the example from the documentation, and we'll talk through it just a little bit briefly. But I have another example that we're going to look at that's a little bit more involved.
00:02:54.478 - 00:03:42.258, Speaker A: So this example, it does the normal things of setting up solidity, importing some contracts, one for the registry interface, the other for the link token. It creates an interface with that registrar, interface with the things that will be passed into it, such as the name, the contract that's going to be having the upkeep performed on it, check data, et cetera. We have our contract definition and constructor. The constructor is where you'll need those three addresses that I mentioned earlier, the link token address, the registrar address, and the registry address. We have a function to register and predict the ID. What this does is this will actually make the call out to the keeper's network and register that new upkeep. We'll dig into this more in the.
00:03:42.264 - 00:03:46.194, Speaker B: Other contract example, but that's it for the example.
00:03:46.312 - 00:04:23.226, Speaker A: It's fairly bare bones, this comment on line 78, where use upkeep ID however you see fit, that's where the magic kind of happens. That's where you can actually do something with that upkeep. So let's dive into that little bit more interesting example. In our upkeep examples, we traditionally use a counter and show that you can automate that incrementation of that counter. This example will do the same thing, except for it will use this contract to automate itself and create those counters. Now let's dive in a little bit deeper into each line of this code.
00:04:23.268 - 00:04:24.610, Speaker B: And see what's going on.
00:04:24.760 - 00:04:41.254, Speaker A: So again, we've got our solidity definition, we've got our imports. We're also importing a contract from Openzeppelin counters. What this will do, and things get a little crazy here with naming, but it'll allow us to count our counters, so we'll be able to keep track.
00:04:41.292 - 00:04:45.810, Speaker B: Of the ID of each counter. We have our interface.
00:04:45.890 - 00:04:57.722, Speaker A: Our interface essentially sets up what will be passed in when we register our new upkeep. We've got the name of the upkeep, the encrypted email, which in this case isn't really used, but we need it for that function.
00:04:57.776 - 00:04:59.978, Speaker B: Call the contract that we're going to.
00:04:59.984 - 00:05:06.974, Speaker A: Be performing upkeep on a gas limit, the address of the administrator check data if we need to pass data into.
00:05:07.012 - 00:05:09.726, Speaker B: Our check upkeep function, the amount of.
00:05:09.748 - 00:05:10.926, Speaker A: Link that we will be funding, the.
00:05:10.948 - 00:05:14.750, Speaker B: Upkeep with the source as well as the sender.
00:05:15.970 - 00:05:37.870, Speaker A: In this case, source will be hard coded to zero, but we'll see that in a moment. All right, let's dive into the contract and look at our self automating counters contract. First of all, we have our counters that we're using from that open zeppelin contract. Now these are the counters that we're not going to be incrementing with an upkeep. This is to keep track of the ID of the counter.
00:05:37.970 - 00:05:41.814, Speaker B: So we create a counter ID counter.
00:05:41.862 - 00:05:46.170, Speaker A: To keep track of which counter we're using. Because we can create multiple counters.
00:05:47.230 - 00:05:50.154, Speaker B: We will map that value of the.
00:05:50.192 - 00:06:16.726, Speaker A: Counter ID to the value of the actual counter. These mappings let us connect different values. So in this case it's the counter ID to the value of the counter. We also have a mapping to connect that ID to the timestamp of the last time that counter was incremented. And then we finally have a mapping for the counter ID to the upkeep ID. We set our interval. This is how often we'd like the upkeep to be performed to 60.
00:06:16.726 - 00:06:29.914, Speaker A: That means 60 seconds in this case. We then set some variables for the registry information itself, including the link token interface, the registrar, the registry, and the.
00:06:29.952 - 00:06:35.686, Speaker B: Signature for the register in the constructor.
00:06:35.718 - 00:06:50.720, Speaker A: We pass in those three values. I have here in the comments the values for the go early test network. Remember, keep in mind those values will change depending on what network you are on. Those are the addresses on that network of the various contracts that you'll need to interact with.
00:06:53.170 - 00:06:56.050, Speaker B: We have a function to create our new counter.
00:06:56.550 - 00:07:01.378, Speaker A: What this does is it creates a counter ID based on that contract that.
00:07:01.384 - 00:07:02.926, Speaker B: We imported from Openzeppelin.
00:07:03.038 - 00:07:15.686, Speaker A: It then increments that counter so that we can keep track of how many counters we've created. It sets the value of the counter we're creating to zero. It sets our timestamp to now the block timestamp, and then it returns the.
00:07:15.708 - 00:07:16.994, Speaker B: ID of this counter.
00:07:17.122 - 00:07:21.100, Speaker A: So when we call this, it sets everything up and gives us back the counter ID.
00:07:21.790 - 00:07:25.450, Speaker B: Now we can take a look at how to register this new upkeep.
00:07:26.430 - 00:07:32.454, Speaker A: So if we look at register and predict ID, we'll start by passing in a few things, the name, the gas.
00:07:32.502 - 00:07:35.838, Speaker B: Limit, and the amount you could pass in more.
00:07:35.924 - 00:07:37.406, Speaker A: I've chosen to hard code them in.
00:07:37.428 - 00:07:39.550, Speaker B: This example because they won't be changing.
00:07:40.130 - 00:07:42.094, Speaker A: We set up the counter ID by.
00:07:42.132 - 00:07:43.706, Speaker B: Creating our new counter.
00:07:43.898 - 00:07:56.050, Speaker A: We grab the registry state and we save some information about it. One of those things is the knots. This is going to be the number that is representing the current upkeep.
00:07:56.390 - 00:08:00.278, Speaker B: We get check data, which will be the counter ID.
00:08:00.364 - 00:08:06.566, Speaker A: We'll use that when we set up our upkeep here in a moment. And then we have our payload. This is going to be what we.
00:08:06.588 - 00:08:12.490, Speaker B: Pass on to the keeper itself when we register the keeper.
00:08:12.990 - 00:08:33.866, Speaker A: So we have the name. We pass that into this function. We have what would be the email address, but it's not used in this example. We have the address of this contract. We have our gas limit in our example. We'll set it to nine nine. You should set it to whatever is an appropriate amount depending on what you are automating.
00:08:33.866 - 00:08:37.234, Speaker A: This is way too high for what we're doing. Wanna test network though?
00:08:37.272 - 00:08:38.914, Speaker B: And it just keeps things easy.
00:08:39.112 - 00:08:44.930, Speaker A: We have our address, the address of our message sender. We have that check data. That's going to be that counter ID.
00:08:45.000 - 00:08:47.118, Speaker B: But it's going to be Abi encoded.
00:08:47.294 - 00:08:48.758, Speaker A: We have the amount of link that.
00:08:48.764 - 00:08:51.720, Speaker B: We'Ll be funding this upkeep with.
00:08:52.410 - 00:08:59.910, Speaker A: We have the source, which is hard coded to zero. And then we have the address of this contract again. So this is the payload that we'll.
00:08:59.910 - 00:09:02.250, Speaker B: Be passing to register our upkeep.
00:09:04.750 - 00:09:38.638, Speaker A: A little bit further down below we can see the actual transfer and call of that link token. This is one of the powerful things the link token allows you to do. It allows you to essentially attach a note to the transfer and say, hey, I'm giving you this link to perform this specific action. Here's what I'd like you to perform. That's what transferring call essentially lets you do. So we pass in the registrar the amount we take our payload and the register signature and combine them and pass that and get that information back. Once we have done that transfer from.
00:09:38.664 - 00:09:41.766, Speaker B: The registry, we then use that new.
00:09:41.788 - 00:09:56.746, Speaker A: State to get a new nonce and make sure that things look good there and that our nonce has incremented. That means, hey, we actually did create a new upkeep. If it did, we then grab the upkeep ID, which we then map to our counter ID.
00:09:56.928 - 00:09:58.042, Speaker B: If anything went wrong.
00:09:58.096 - 00:09:59.786, Speaker A: If something's amiss, we go ahead and.
00:09:59.808 - 00:10:03.790, Speaker B: Revert and throw a message out and that's it.
00:10:03.860 - 00:10:22.546, Speaker A: At this point we have registered a new upkeep. And we've used this contract as the contract that we're performing upkeep on. So this contract has registered an upkeep on itself. It's automated itself. What do we do in our upkeep? Well, we have our two functions, the.
00:10:22.568 - 00:10:24.610, Speaker B: First of which is check upkeep.
00:10:25.030 - 00:10:52.666, Speaker A: A lot of times in our examples, we don't pass in check data because we like to keep things simple, but here we need to pass in that check data and what's going to be in our check data is the ID of the counter that we're checking. So we'll need to decode that check data and get our counter ID back. Then we can check and see do we need to actually perform upkeep. We do that by looking at the current timestamp compared to the timestamp associated with the counter that we're looking at.
00:10:52.688 - 00:10:54.938, Speaker B: And seeing if that is greater than the interval.
00:10:55.114 - 00:10:56.622, Speaker A: If it is, we'll need to perform.
00:10:56.676 - 00:10:58.926, Speaker B: Upkeep and we will pass along that.
00:10:58.948 - 00:11:03.120, Speaker A: Check data which remember, it's the counter ID through to perform data.
00:11:03.490 - 00:11:04.666, Speaker B: In perform upkeep.
00:11:04.698 - 00:11:18.966, Speaker A: We take that perform data and we decode it again, get our counter ID, and we double check once more to make sure that we need to actually perform the upkeep. It's always recommended to do before you change anything on a blockchain, make sure.
00:11:18.988 - 00:11:20.550, Speaker B: That you actually need to do it.
00:11:20.700 - 00:11:48.046, Speaker A: This also allows us to have the perform upkeep be an external function. If someone else wants to pay your utility bill, you should let them. So if someone else wants to call perform upkeep, that's awesome. But you want to make sure that it only executes when you expect it to execute. So we check that if we need to perform upkeep still, we update the last timestamp for that counter and then we increment the value. So what does this look like when we deploy it?
00:11:48.148 - 00:11:49.434, Speaker B: Let's see it in action.
00:11:49.562 - 00:12:17.320, Speaker A: We'll head on over to the deploys and run transaction tab. We'll make sure we pick the correct environment. That's going to be our injected provider as well as the correct contract. Remember, this contract requires a few values and these values are going to be dependent on what chain you are on. I've put the ones for go early in the comments. You can find this code in the description below. There should be a link to a GitHub with this example contract in it.
00:12:17.320 - 00:12:39.230, Speaker A: We'll deploy this contract and we'll wait for a confirmation. All right, we've got our confirmation back. Our contract is deployed. We can head here and we can check out what we have available to us. The function we're interested in is this register and predict ID. Now remember, we have our name so we can call this counter.
00:12:41.010 - 00:12:41.760, Speaker B: Zero.
00:12:42.530 - 00:13:21.660, Speaker A: We have our gas limit and again, I've provided these values here as an example. The gas limit should be an appropriate value depending on what you need to do in your contract, as well as the amount of link that we'll be funding this specific upkeep with. Now, before you click transact, something to keep in mind. We're transferring and calling link. Where are we transferring it from? We're transferring it from this contract, the one we just created. So before we go any further, we need to take the contract address and we need to transfer some link to it. If you don't have link, head to faucets, chain link to get some.
00:13:21.660 - 00:13:23.774, Speaker A: Once you have some link, you can.
00:13:23.812 - 00:13:26.990, Speaker B: Send it to this contract.
00:13:27.410 - 00:14:03.290, Speaker A: In this example, we're using five link, so I always like to send just a tiny bit more to make sure that there's no weirdness with running out and we'll send that link over. We need to wait for this transaction to be confirmed before we go any further. All right, our transaction is confirmed. We've funded our contract with some link. We can now register and predict ID, which will create an automated counter within this contract. We'll click transact and then we can confirm this transaction as well. Once this is confirmed, we should be able to see a few things.
00:14:03.290 - 00:14:11.962, Speaker A: While we're waiting, we can take a look here. So we'll look at the counter to last upkeep for zero. The first counter we can see it's set to zero because that counter doesn't.
00:14:12.026 - 00:14:13.120, Speaker B: Exist yet.
00:14:14.930 - 00:14:35.682, Speaker A: As well as the upkeep ID. Once our transaction has been confirmed, we should see values start to populate there. All right, so our transaction has been confirmed. Let's take a look at the upkeep ID. We can see it's populated as well as the last upkeep. Next we can take a look at the value of the counter currently is set to zero.
00:14:35.816 - 00:14:36.978, Speaker B: I'm going to speed this up a.
00:14:36.984 - 00:14:55.398, Speaker A: Bit, but we'll need to wait for at least a minute to pass by before our upkeep triggers an incrementation of this counter. All right, about a minute has passed. Let's take a look at the counter value. Fantastic. We can see it's changed. It's now one. If we look at the last upkeep.
00:14:55.494 - 00:14:58.538, Speaker B: Time, it has changed as well.
00:14:58.704 - 00:15:30.358, Speaker A: So just like that, we've created a smart contract that can automate itself. I think the potential here is huge. There is so much opportunity to create contracts that can be self automating or that can automate other contracts as well. It's not limited to just automating itself, but it's really neat to see a self contained automating contract like this. From here, the sky's the limit in what you can automate. I would love to see examples of what you create. Thanks for watching.
00:15:30.358 - 00:15:36.260, Speaker A: I'm Richard, one of the developer advocates here at Chainlink Labs, and I look forward to catching you in the next one.
