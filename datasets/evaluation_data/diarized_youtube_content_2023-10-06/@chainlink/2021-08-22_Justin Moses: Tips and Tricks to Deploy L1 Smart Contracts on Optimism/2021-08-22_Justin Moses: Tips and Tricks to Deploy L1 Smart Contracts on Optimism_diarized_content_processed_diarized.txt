00:00:05.530 - 00:00:37.720, Speaker A: Hey, everyone. Yeah, thanks for the. Thanks for the kind words. I will try to make this technical because one of my pet needs is a talk, so don't get too technical, but I'll do what I can to make it accessible to is. Don't know if that's exactly my structure, but I'll try. So, yeah, I'm here today to talk to you about synthetics on optimism, and I think it's a very interesting space and we've been definitely working pretty hard, along with Chainlink, to bring together the synthetic experience on layer two. And I like to sort of walk you through a little bit of what we've been doing.
00:00:37.720 - 00:01:08.846, Speaker A: So where are we right now? Optimism has relaunched a public beta that many of you are probably aware of, and there are a few projects on there. There's synthetix, we have uniswap, and now chainlink as well. That's the current state of play now. It's still a public beta, so not anyone, you can't just deploy on there just yet, but you can sort of submit a form and get out there. And the optimistic team are slowly allowing people to get on there, trying to keep congestion to a minimum right now. So this is what it looks like right now. This is a quinta.
00:01:08.846 - 00:01:54.270, Speaker A: This is our dap, where you can trade between synthetic us dollars to ether, bitcoin and link. Right, it's up. It's been great, we're really happy with it, so give it a try. Basically, all you need to do is just go to Quinta IO and it'll help you sort of plug into the optimism network and metamask and you can get going. So why do we at synthetix, need another layer? What are the main reasons for it? So, I mean, the first one is obviously, as many would understand, is reducing gas consumption. Synthetics is quite a complicated set of contracts, a lot of them interrelated. We have this idea of a shared debt pool, and that means that there's a lot of constant interaction between what it's synthetics whenever users mint or burn or trade.
00:01:54.270 - 00:02:25.740, Speaker A: And so the advantage of going to another layer is that we can really bring down the gas consumption massively for users, so it's less cost to them. The next thing is, obviously, it's faster transaction throughput. We want to get. Users want to have a better experience of trading, like maybe what they would have in the traditional finance world and waiting for 15 2nd block times. It doesn't pass master. So we want to actually be able to get. Users get very quick responses to their trades and actually almost potentially subsecond reaction times.
00:02:25.740 - 00:03:07.906, Speaker A: And then the final thing is just future proofing the protocol, right? This is where Ethereum is going, right? We get scalings coming. It's inevitable. Sharding optimistic roll ups. We need to do this. And so it's just, for us, it's pretty critical that we find that we sort of move ahead early on and sort of get ahead of the curve when it comes to getting onto layer two. So why optimism? Our choice is really bound around the fact that it's pretty much the closest layer two implementation to the current EVM, right? So we can reuse all the code that we have from layer one contracts in solidity, which is obviously massive. If any of you manage maintain code bases, having different versions of code bases is a nightmare.
00:03:07.906 - 00:03:36.210, Speaker A: It's not something you really want to have to do. So the closer we can get this to the EVM, the better. It also means, though, that we can reuse developer tooling for the EVM. So hard hat and everything that the team at nomic labs have been doing is just incredible. And there's a lot of bunch of developer tooling that has been written for the EVM that we can just use almost out of the box with OVM, which is great. It's also a very likely candidate for e two scaling. And then finally security that you get through l one via roll ups and fraud proofs on chain.
00:03:36.210 - 00:04:31.106, Speaker A: It's very paramount to what it is to be on optimism. So for us, it's been a pretty critical choice. So in a nutshell, how does it work? Okay, so optimism, and actually, to some degree, arbitram is quite similar to this as well. There's a single sequencer and you access it like a provider, a URL. So very much like you would in ethers or web three, you would just use that, put that custom provider in, and then you as users can do things like, I want to mint some SNX, or transfer some SSD, or I want to exchange synthetics, right? Like trade, basically. So this is what happens on layer two. And what you'll also have is on layer one, you have actions like if a user does a deposit, then these things on the right, they're like contracts, like on layer one, right? And so if a user does deposit, it sort of goes into the contract on the right hand side.
00:04:31.106 - 00:05:36.578, Speaker A: And then the sequencer's job is to sequence things that happen on layer two with things that have happened on layer one. So users depositing on layer one is something that has to get to end up on layer two, right? So these sequencers jobs to sequence them together, and then finally what the sequencer will do every sort of inclusion period, which might be five to 10 minutes, it'll basically take all the summaries of all the transactions, persist it to layer one, and then persist a state root hash. It's just like, what would the state be if this would change? So basically what it does is it takes all the load off layer one from actually doing the execution, and then it has a fraud proof engine, which basically someone can say, hey, I don't believe that state root hash is actually what would happen if I were to apply that other transaction. So I'm not going to go into too much detail, but it's effective at a high level, how it works. Okay. So for us, we had to make a choice. Do we deploy synthetics completely isolated on layer two and have it as a whole different system, or do we connect them up layer two to layer one? And for us, the whole idea of synthetics is this concept of a shared debt pool.
00:05:36.578 - 00:06:03.326, Speaker A: Right? Sorry, people stake SNX and they can mint s usb, which could be turned into other synths, and there's a big pool of debt. So there's a lot of value for us to connect the two layers together. So, for us, in the synthetic protocol, we made the decision that we actually want these two layers, layer one, layer two, to actually interact. They're not separate systems. Completely. Uniswap is the opposite of that. Uniswap is they have Uniswap on layer one, and there's Uniswap on layer two.
00:06:03.326 - 00:06:36.358, Speaker A: And these are two different protocols. I mean, they might be the same code, but it's not like you're sending your lp tokens between layer one to layer two. You basically need to take your tokens, you need to send them to layer two, and then you can stake there separately. Whereas for us, we wanted to make a decision, we wanted to make the architectural choices so that we could actually do some communication between layer one, layer two, and I'll explain that. So the first one is messaging. How do you message between these two layers? So basically, what it works is like this. So here we have, like, ethereum, layer one, right? And we have our contracts.
00:06:36.358 - 00:07:24.054, Speaker A: Bridge to optimism, and a bridge escrow. And then the purple contract is optimism's contract. Right? So if a user says, hey, I want to initiate a deposit on layer one, what they'll do is they'll call a function in our bridge to optimism, which will do two things. It'll send a message to this generic message sender said, hey, the user wants to deposit, and then it will send the SNX that they've deposited to this escrow contract. And this is all on layer one, right? But then what happens is on layer two, you have this relayer who basically, after a few minutes, we'll say, oh, there's a message to send. Okay, I'm going to send that message through, which gets passed through the deposit, like we saw in an earlier slide, which gets sent to a messenger on l two, which then passes the messenger off to our bridge to base contract on layer two. So optimism is basically allowing to send any sort of data payload that we really want, in our case, deposit of SNX.
00:07:24.054 - 00:08:13.030, Speaker A: So all SNX that exists on layer two is basically deposited into layer one and just held in escrow. And then the message goes across to layer two, and the SNX is minted there. Now, when we're withdrawing, it's kind of the reverse of that. So on layer two, what a user would do is say, oh, I want to initiate a withdrawal. So they're reaching out to the bridge to base contract and say, I want to initiate a withdrawal, which then sends a message to the optimism's messaging contract on layer two. And then after a week, which is created to prevent ddosing attacks, after a week, that message actually gets relayed onto layer one through the optimism's messenger contract, which then sends a message to our contract, which says, hey, finalize this user's withdrawal, which then tells the escrow contract, hey, I need you to send you the SNX. Send the SNX off to this user.
00:08:13.030 - 00:08:37.406, Speaker A: So this is the way we do message passing on optimism, which I believe is actually quite similar to arbitrum. It's kind of basically take fairly generic messages and we send them between. And we have to wait a little bit of time. Even for deposits, it's not instantaneous. You still need to wait a little time, because these are two different systems, they're not strictly connected as such. Now, yes, everything that happens on layer two is rolled up to layer one, I. E.
00:08:37.406 - 00:08:56.740, Speaker A: It's in a contract in layer one. But it's not like layer one can say, hey, tell me what the state is in layer two. Right. In real time, it's not like layer two can say, I know what they need to know what the state is right now. The messages have to be passed between them in order to communicate. Okay, the next thing is contract management. Right.
00:08:56.740 - 00:09:33.772, Speaker A: So how are we handling the fact that now we are deploying contracts on layer one, the synthetics, and we're deploying contracts on layer two. Now, the nice thing is, because, as I said before, optimism. Very. The OVM optimistic virtual machine is quite close to the EVM. We basically can just switch on the compiler we use. We take the contract source code, and we say, if it's optimism, take their compiler, which is a fork of, in our case, Sol C 516, but they have it of all different versions of Sol C. For the source file, we say, if we're compiling with the OVM, let's do a slightly different version of synthetics, the mintable synthetics.
00:09:33.772 - 00:10:12.492, Speaker A: Right? And in our system, label it synthetics. So when you're coding, you're basically, or when you're a user thinking, okay, I want to deal with synthetics. You don't really care that the contract underlying is mintable synthetics or synthetics. You just really want to deal with synthetics. But the engineers and the protocol, the core contributors, they need to understand, hey, there's a version of synthetics that lives on l one. There's a version on l two, and they're slightly different because for synthetics to exist on layer two, it has to be deposited layer one, right? So we create this base synthetics contrast contract, which has the common functionality synthetics does. Very specific l one stuff like minting every week when there's supply, when our inflation kicks in.
00:10:12.492 - 00:11:09.732, Speaker A: And then layer two, all it can basically do is it can mint synthetics whenever it's instructed to from the deposit contract on l two. So we use polymorphism in our code to basically refer to things that happen in synthetics. And we try not to ever say as much as possible, never be saying, if OVM, do this, if not do that. We just basically say, in OVM synthetics, is this contract on l one, it's this contract. It conforms to the same interface, so it's polymorphic. A few gotchas with contract management, you do have the contract size limit that you have already on layer one, but it's actually a little bit trickier on layer two, because with the fraud proof engine that exists in optimism, the OVM transpiler, that little tool I said before, the compiler, optimism solc, that actually adds a bit more bulk to your contracts. So it's actually a bit more tricky to get under the size limit.
00:11:09.732 - 00:11:43.288, Speaker A: You also have opcodes that aren't allowed, like self destruct, which is pretty much, I guess it's kind of a known thing now. So most people have got away from self destruct anyway, you can't use native ether. You have to use wrapped eth. And block number and timestamp are actually the l one blocks. They're not actually the l two numbers. So you won't necessarily get the same fidelity that you're used to in layer one. Okay, so what about deployment and testing? So with deployment, we do sort of a similar thing, right? We just switch on whether or not it's OVM, we just switch on the providers, right.
00:11:43.288 - 00:12:18.372, Speaker A: The gas limit, if you're using OVM, the gas price, we actually don't supply a gas limit or a gas price. And that's got to do with the way the OVM handles gas. We don't actually want to specify the limits or the prices. We want to let the chain tell us. And the reason why is a little complex, but it's effectively the fact that we're trying to use the paradigm, or optimism is using the paradigm of the EVM on l two. But when you do something on layer two, when a user says, I want to mint or transfer synth on layer two, there's actually two types of gas. There's the gas to actually do the execution, right.
00:12:18.372 - 00:13:24.228, Speaker A: If I want to mint or whatever on layer two, that gets paid to the sequencer, but there's also the gas to pay the roll up, the summary of the action that has to live on l one. So what they've done, with the help of Vitalik, who's come up with a spec, is actually encode using significant digits of the gas limit, they actually encoded both the amount of gas required to pay for the l two execution, which is known. But the l one roll up gas is variable, based on the fact that the price of gas on l one is changing constantly. So when you're deploying or interacting with optimism, as you might have noticed, if you use any of it, the synthetic staffs, you'll see that when it comes to an OVM, basically, the gas limit is going to look a very unusual looking number, and the gas price is going to be very specific. Zero point 15. And that's determined by the algorithm that optimism have figured based on how much gas you're going to cost on l two, plus how much is it going to cost given the current rates of gas on l one? But for all intents and purposes, it doesn't really matter if you're a protocol developer, as long as it works, it's fine, right? You don't have to tweak things, and in fact, you shouldn't. So we don't tweak it.
00:13:24.228 - 00:13:58.576, Speaker A: We just basically, when we're deploying, we basically just use the defaults of the provider do, and ethers will just do it for you, which is amazing. Now, with testing. The nice thing with unit testing is it's pretty much the same source, right? Like, these contracts are the same, the OVM or the EVM that basically we can do our testing at hard hat and actually not even worry. We can use in a regular EVM node. We test out our mintable synthetics code in, effectively l one, and it should all work for unit tests. But then when we want to go a bit deeper, we go to integration tests. Well, we actually have three types.
00:13:58.576 - 00:14:36.224, Speaker A: So one integration test on layer one, we just do our high level l one things. Can I mint, can I burn, can I claim exchange? And we use a regular geth node. When it comes to layer two, what we do is we use the tool, that optimism given in Docker, and it fires up their fork of gath and their sequencer, and then we can do mint burn claim exchange on layer two. And then for the final test, if we want, and we do, we actually want to do this situation. We test out deposits and withdrawals. So we fire both nodes up and actually test sending messages, like I showed you before, a deposit and withdrawal. Does it actually work? If we were to speed up time and we actually make sure that the message passing is going correct.
00:14:36.224 - 00:15:29.564, Speaker A: So we have three types of integration tests. It's a way of basically making sure the system is robust and lives no matter what, based on any repackage that we do. Final thing is ownership. And so what we've done is what actually uniswap have done for ownership is instead of trying to deploy multi sigs on layer two, what we've done is actually lean on the fact that we can relay messages from layer one to layer two. So we can take a user at a multi sig on layer one says, hey, I want to initiate some message, some data to some target. The multisig can relay it on l one. It gets sent to the messenger, and then in a few minutes later, the relayer on l two will actually send that message through the optimism messenger that goes onto our contract, which eventually tells the target, hey, as the owner, I want to do this action.
00:15:29.564 - 00:15:49.784, Speaker A: The data gets decoded into the target. It's a really nice, graceful solution. That way, you don't actually need to have multi sigs on layer two. You basically just. Everything on layer two that is managed is owned by this contract, is owner relayer, and we just relay messages from l one to l two to do owner actions. Cool. So that's it.
00:15:49.784 - 00:15:58.670, Speaker A: That's a pretty high level, but I try to get a little bit of depth there for you. That's kind of how we've done it. Any questions, you can hit me up on Twitter. And thanks very much for your time.
00:15:59.280 - 00:16:10.910, Speaker B: Thank you so much. Justin. No, I think you totally nailed the dynamic. It was technical, yet accessible. Walks through the process. So very much appreciate your thoughts behind this and your work on it as well.
00:16:23.080 - 00:16:26.420, Speaker A: Close the.
