00:00:00.410 - 00:00:25.058, Speaker A: It's. So your new web3 project has an allow list, and you want to store that information on chain, but you don't have unlimited funds to store all that data. Let me show you how to do that. In a single hash. We can store your entire list of data, no matter how big it is on chain. Let's dive in. All right, so those were some big promises.
00:00:25.058 - 00:01:00.570, Speaker A: Storing unlimited data on chain in a single hash. How are we going to do that? The answer is merkel trees. Now, before we dive into creating a Merkel tree, let's cover real quick what a merkel tree is. Essentially, a merkel tree is a way of taking a bunch of data, the leaves of the tree, hashing that data and then hashing its neighbor and continue this process until there's only one hash left. That's the root. That's what we'll store on chain. So how are we going to create this tree? Well, we're going to create a hard hat project, and within that project, we'll create a script to generate our tree.
00:01:00.570 - 00:01:22.950, Speaker A: That data, the tree itself, will need to be stored off chain. You'll need to keep track of that in order to generate the proof. The proof is essentially the path from a leaf to the root itself. We'll do that, and we will show how to create a verification function in a smart contract, and also how to test it. We're going to do all this in Hardhat. So the first thing we need to do is install hardhat. Let's get started.
00:01:22.950 - 00:01:45.242, Speaker A: If you head to your terminal, you can say mpx hardhat. This will allow you to install Hardhat. I'm going to go with an advanced sample project that uses typescript. It'll ask you where you want to install it, and it'll ask you if you want a git. Ignore you, say yes, and it will install all of the dependencies that you need. All right, we've got all of that installed. The next thing that we'll need to do is install Merkel tree Js.
00:01:45.242 - 00:02:09.174, Speaker A: This will allow us to actually create the Merkel tree. Once we have that installed, we're ready to go. The first thing that we're going to do is we're going to focus on the scripts directory here. We'll create a new file here, and we can call it anything we want. I'm going to call mine Merkeletree Ts. Within this file, we'll need to do a couple of things. We'll need to import Merkel tree and Kekac two, five, six, which is the hashing algorithm we'll be using.
00:02:09.174 - 00:02:32.778, Speaker A: Once those are imported, the next step is to create the function that we'll be using. We'll call it generate tree. Within generate tree. We'll need to create our allow list. Now this is going to be the list of addresses that we'll be using. You may notice that first address looks a little strange compared to the other ones, which are obviously placeholders. That's the first address that Hardhat uses, and we'll be using that within our tests.
00:02:32.778 - 00:03:07.058, Speaker A: If you want to know what addresses hardhat uses, you can use NPX hardhat accounts. This will give you a list of all of the accounts that Hardhat uses and the order they come in. So this first address here, that's the address that we are storing in our allow list. Next, we'll need to create the tree. So the first part of creating the tree is to create the leaves of the tree. We'll map over our allow list, and we will hash each address to create a new array of those hashed values. These will be the true leaves of our tree.
00:03:07.058 - 00:03:39.906, Speaker A: Then we'll create our tree. It's a new merkel tree. We'll pass in our leaves the hashing algorithm itself, and we'll go ahead and sort those pairs together to make things nice and tidy within our merkel tree. At this point we can return the tree. This is the entire function that we need, but we can't really see what's going on. So how do we see what's happening within our tree? Well, we can get the root of the tree with tree githroute, and we can also log the root and the tree itself. Now this two string here is going to make our tree very nice to look at and read.
00:03:39.906 - 00:04:11.334, Speaker A: If we don't have that, things get a little weird. So we'll need that on there. And finally, we can go ahead and add this generate tree function call to the end here so that we can actually call our generate tree function. So let's go ahead and do that. Now, we can do that with mpx hard hat run scripts, Merkeltree ts that will actually run our file for us. And you can see here that it generates a merkel tree. Now what's cool is we have our root here, and you can see the root in this tree display.
00:04:11.334 - 00:04:37.014, Speaker A: They match. Then we have our branches of our tree. And then finally the leaves of the tree are the last elements that are displayed. I'm going to go ahead and leave the logging in this file just so we can look at it when we run our tests, but I'm going to take out the call. So at this point, our merkel tree file is done. We can generate a merkel tree you could pass in the allow list if you wanted to, instead of having it hard coded in here. That would be up to you.
00:04:37.014 - 00:05:14.458, Speaker A: So the next step would be to create our solidity contract itself. When it comes to merkel trees, you have the option of creating a verification function yourself or importing a Openzeppelin contract. Now, open zeppelin is an industry standard, and they are probably the most battle tested contracts out there when it comes to things like this. So we are going to use a Openzeppelin contract to import a Merkel tree verification function. In order to do that, we'll need to install the open Zeppelin contracts. We can do that with NPM install Openzeppelin contracts. All right, our contracts are installed.
00:05:14.458 - 00:05:44.010, Speaker A: Let's go ahead and create our new contract here in the contracts folder. We'll say new, and we'll just call this Merkel Sol. All right, so we have our new file here. The first thing we'll need to do is set up our solidity version, and then we can go ahead and import that Openzeppelin contract, the Merkel proof contract from open Zeppelin. Now we can define our contract Merkel. Within this contract, we need to keep track of our root. That's the one piece of information that we'll be storing on chain.
00:05:44.010 - 00:06:24.082, Speaker A: So we'll create a root value, and we can go ahead and define our constructor. This will allow us to create our contract, pass in the root when we create our contract, deploy it, and store that within our contract. Next, all we need to do is create a verification function. It should take in the proof and return a boolean value. Now it's going to use the message sender, the person who's calling the function, to check and see if they're in that allow list. So we have our verification function that takes in that proof, returns a boolean, and the return is going to be based on the Merkel proof verify. Again, it's going to need the proof and the root.
00:06:24.082 - 00:06:54.000, Speaker A: So we pass in the proof, we have the root stored in our contract, and then it will go ahead and hash the message sender. So this will return that boolean value. And that's all we need to check if a value is within our Merkel tree. It's pretty simple, and we store a minimum amount of data on chain. So how do we test this? How do we know if this is actually working? Well, we can go here into our test folder and take a look at index. We can see that we have one test already here. We can run this with mpx hardhat test.
00:06:54.000 - 00:07:26.378, Speaker A: This test tests the greeter contract that came with hard hat. I'll just leave it in there because it shows that everything's working for now and we'll need to do a new describe for our Merkel proof. Let's go ahead and create that now. All right. The first thing that we'll need to do is import our script to create the Merkel tree as well as the hashing algorithm. So we import generate tree from our file as well as the Kekac two, five, six from ethers. Next, we'll need to go ahead and create that new test.
00:07:26.378 - 00:07:59.282, Speaker A: So describe Merkel tree and within here, let's go ahead and create our test for a valid value so it should verify a valid proof. That's going to be when the message sender is within our allow list. How do we do that? The first thing we'll need to do is we'll need to actually create the entire Merkel tree. Again, this is a little weird because it's a test, but in reality you would have done this already and then deployed your contract. So we'll create our tree by generating the tree. We'll get the root. We need that for actually deploying our contract.
00:07:59.282 - 00:08:27.966, Speaker A: We'll go ahead and get the address of the first signer. Remember the hard hat accounts, that first value, the one that's in our allowed list, that's going to be what we're using here. And then we'll go ahead and use the hash of that address if we want to log those things to see what address we're looking for. We can do that here. And finally, we'll generate our proof. That's going to be the proof that the address is in the tree and how to get from the address to the root. That's what we'll be passing in to our verification function.
00:08:27.966 - 00:08:52.310, Speaker A: So we have everything we need to go ahead and deploy our contract. Let's go ahead and do that now. We can deploy our contract. We can get the contract factory, deploy it, passing in that root value and wait for it to be deployed. Then we come to our final step, the actual test. So we'll expect that the verification is true. So let's go ahead and run this and see if our test passes.
00:08:52.310 - 00:09:28.318, Speaker A: You'll notice all the logging from creating our Merkel tree is still in there. And the reason I left it in there is so that we can check ourselves and see if it's actually working. You remember this? 92266 is the address that we put in our allow list. And when we look at the hashed value, we can see that it ends in five. If we look in our actual mercury tree, which has the hashed values, we can see our five value is right here. So we can actually see that data. That leaf is in our Merkel tree.
00:09:28.318 - 00:10:04.430, Speaker A: That's awesome. So it works. Everything is fantastic. How do we do this from another account? And how do we test that? It doesn't work if we're not using an account that's in the allow list. Let's go ahead and clean this up and we'll create that new test. We can just copy the existing test that we have and change a few things. First, we can say it should not verify an invalid proof, right? And then we'll want to get the address of our second user, and we'll need to skip the owner.
00:10:04.430 - 00:10:47.342, Speaker A: We'll go ahead and change our addresses here to be address two, and then we'll generate our tree the same way we'll get the second signer's address. And when we go ahead and use our verify function, we'll need to add a little bit in here. We'll need to say, connect address two. This will use address two to call this value. And we should expect this to be false. So let's go ahead and run our tests again. And we see now that we have three passing.
00:10:47.342 - 00:11:15.240, Speaker A: So this means that the value of our second user. So we're looking for this address which hashes to this value. If you were to look in the Merkel tree yourself, you would see that that value is not there. So that's it. We've created a Merkel tree. We've deployed a contract that allows us to verify that Merkel tree on chain. And we've gone ahead and written a test suite that tests to ensure that everything is working the way that we expect it to.
00:11:15.240 - 00:11:29.680, Speaker A: So this is how you can take an unlimited amount of data, a massive allow list. Store one value on chain. If you have any questions, feel free to reach out. Leave a comment below and I'll do my best to answer them. Thanks for watching and I'll catch you in the next one.
