00:00:04.810 - 00:00:33.080, Speaker A: Hello everyone. We should be live. We're going to start in a couple of minutes. Until then, listen to some lopi bit. Welcome to another chainly hackathon workshop. If you can hear me, just send some GM us in the chat and we are going to start really really soon in couple of minutes. Enjoy.
00:00:33.080 - 00:01:51.850, Speaker A: It's, it's about time to start. I can see some GMs into the chat. Yeah, so welcome to another chain link spring 25 rehab workshop. Today's topic is, as you can already see, pulling data from AWS on chain. So we're going to use chain link functions for that. We're basically going to connect blockchains or our smart contracts on blockchains with AWS. Let's quickly turn this music off and we can slowly start with today's workshop.
00:01:51.850 - 00:02:34.830, Speaker A: So who am I? My name is Andre Rakich. I'm one of the developer Alexis chain protocol chain clubs. Here you can see listed my Twitter and blance handles. Sorry about that. If you want to follow along after this workshop, if you have any further questions that we will not cover during the Q A session at the very end. So feel free to write anything on my Twitter wall if that's the correct term, and I'll make sure to answer you in a timely manner. Okay, so today's topic again is pulling data from AWS on chain using of course, chain link functions.
00:02:34.830 - 00:04:03.134, Speaker A: Today's example, we are going to basically get the price of one fiat currency in another fiat currency, more precisely, british pound in US dollars in terms of US dollars. But as you can see, almost anything can be pulled from AWS to your calling smart contracts at the moment to sepolia, Mumbai and Fuji testnets because we're going to use, as I said, chain functions for this. Chain functions is currently in beta, so you'll need to sign up for beta if you want to follow along, but really soon it will be available on mainet as well. Okay, so what is channeling functions? So channeling functions is a new channeling service or product which allows us to execute any code we want in decentralized and verifiable manner. Which means that we can now pass JavaScript code snippets from our smart contracts to the dawn. And dawn will execute any given computation for us. Why? Because some computation is extremely costly to be done in solidity on blockchain, so you can actually outsource all this work to Chainlink Dawn.
00:04:03.134 - 00:06:13.138, Speaker A: Chainlink also has a service called any API which allows you basically to execute HTTP get requests from basically any given API. But the problem is that although this service is excellent for hackathon projects, it's a bit tricky to use it in production, because if you follow along our documentation, the demo or samples from documentation basically suggest you that you'll have only one node and only one API endpoint, while for production readiness app you will need to have multiple nodes with multiple APIs and you will need to make a consensus on all of these results like we have a consensus when it comes to database chaining database. That's why there is chaining functions now exist because any given, let's say HTTP get request is now going to be passed to the dawn by default instead of the nodes you will need to take care of, which means that any given node from the dawn will execute the given request in its own server environment, report the end result, then we appear to peer network to rest of the nodes, and then the whole network will need to reach a consensus and create a cryptographical proof and send all of that back to the calling smart contract as a callback. But more than that, more than just execute any API or any HTP get or any HTTP post request. Now you can provide arbitrary code, so any vanilla JS at the moment code is valid. For the beta, we only support vanilla JS, but you can provide more than just getting HTTP get requests. So it can be, as I said, some net computation that is needed on solidity or combination of get and post request whatever you want and then get the result back on a smart contract and do some arbitrary computation and solidity on the chain as well.
00:06:13.138 - 00:07:05.922, Speaker A: For today's workshop, we are going to get, as I said, prices of british pounds in terms of USD dollars from AWS. But at AWS you have multiple, multiple multiple services available, which means that you can literally do whatever you want with chaining functions that AWS can provide for you. So it's totally up to you, up to your creativity and imagination, what you're going to build with Chainlink functions during this workshop, or more precisely during this spring hackathon. I will show you just a portion of that during this workshop, of course. Okay, so what, as I said, it can be any code you want. So how this process works. So step number one, you will need to create a smart contract on a blockchain and it will have like two additional functions.
00:07:05.922 - 00:08:12.058, Speaker A: So the first one will be to send the actual request to the dawn, and you're going to send, among other config parameters, the JavaScript source code snippet, which every single node in the dawn is going to execute in its own server environment. Sorry, as I said before. So second function will be a function for fulfillment requests which will be called only by the dawn itself when we have a callback result. So smart contract sends the code to the dawn and then each dawn's oracle runs the same code in a separate server's environment. Step number two. Now, after the code is run by every single node, all of the nodes in the dawn will need to communicate between themselves using OCR or peer to peer network, and aggregates all of these independent computation results, applies consensus cryptographically, verifies it, and returns the final result to the calling smart contract, as I already said. So that's why you'll have that second function.
00:08:12.058 - 00:08:52.998, Speaker A: I'll show you the signature for it. It's fulfilled requirements. Basically it will be internal function mean that only donk will be able to call it. And inside that function you will need to put the actual computation or logic or whatever you want to do with the callback result from the dawn. Yeah, let's put this banner down. So how this works in practice. So you will need to create this left portion of the screen, and that's pretty much it.
00:08:52.998 - 00:09:30.210, Speaker A: So on the left portion of our screen you can see user depth or smart contract. And that's the only thing you will need to develop. This is your on chain logic. You will just need to make a function for sending a request to the dawn. And as I said, another one like for fulfillment requests, and that's pretty much it. The rest is totally upon chainlink Dom. So you can call this request function using obviously externally owned account or your wallet, or you can even automated it using Chainlink automation.
00:09:30.210 - 00:10:23.038, Speaker A: On the right side of the screen there is something called Chainlink function smart contract which is an oracle contract which can communicate with dot. So this is the on chain contract which communicates with decentralized oracle network. Now inside this is the more right approach of the picture. I just cropped this architecture diagram into the two slides. So we start with Chainlink function smart contract. One of the reasons why we'll need that oracle contract is for something called subscription management. So subscription management with four Chainlink functions work into the exact same way as with Chainlink, VRF, Chainlink Automation, et cetera.
00:10:23.038 - 00:11:19.698, Speaker A: How so? You will need to create only for the first time a subscription, right? So there is like a UI for that on functional Chainslink where you can just connect your wallet, click on create subscription, follow the steps. Really easy for you to do that. Or you can even manually call the function on the smart contract itself using meterscan or whatever method you want to use. After creation of subscription, you're going to remember the subscription id, and then you can create, and then you can add multiple consumer contracts to the same subscription. So you can have multiple smart contracts for completely different use cases for little different purposes. They can consume the same subscription. So lastly, you will need to fund that subscription with some amount of linked tokens, because each request to the dawn will cost some amount of link tokens.
00:11:19.698 - 00:12:28.106, Speaker A: Why? Because the nodes into the dawn itself will need to perform some computation, and you will need to basically pay for that computation costs like we have paying for gas on Ethereum or any other popular general purpose blockchain where we're paying for decentralization. That's how we are paying here for off chain computation. But the good thing is that you can fund one subscription while multiple consumers can consume the same subscription, meaning that you will only need to worry about the subscription funds rather than have funds in all separate consumer smart contracts. We have a couple of questions. Will feature versions of functions be able to run Python code? Yeah, I think so. I don't have like a written confirmation, but there will be more languages, more and more and more and more languages supported for sure. And Python is obviously one among the most popular ones.
00:12:28.106 - 00:13:16.940, Speaker A: So I assume that Python will be there at some point in the future. Don't know when, and this is just my assumption. I don't have, as I said, again, verbal or written confirmation from anyone from the team, but that seems like a logic step. How much time left before hits Mainet? At the moment I don't know, but this project is joined actually announced as beta during East Denver. That was February. I think we have now hackathon for you to try it a bit. So I assume it's going to happen soon, when it's ready, when we know that after all of us stress tested that it will work as expected on the main net as well.
00:13:16.940 - 00:14:09.498, Speaker A: Love the new docs. Thank you TP and hello, thanks for joining us once again. Okay, after creation of a subscription, with each single request, it will be passed through that oracle contract to the dawn. And you can see here that dawn consists of independent civil resistant nodes, can actually perform and do whatever you want, basically whatever actually you tell them to do with that arbitrary JavaScript vanilla JavaScript code. So HTTP get request, post request, multiple computations, et cetera, et cetera. So custom code execution will be present at this stage. Again, callback will be returned to the calling smart contract and then you can do whatever you want with it.
00:14:09.498 - 00:15:08.110, Speaker A: So what this JavaScript code can be, well, essentially it can be anything like this is just a couple of examples, but you can connect your smart contracts to some weather data to create dynamic nfts. You can connect them to password protected iot devices because if you want to pass API keys or any other secrets for HTP, get request or password for your iot device or whatever, these things are not stored on chain. This is extremely important for you to stress out. These things are not stored on chain. Those keys are not even present in env file as plain text. Rather they are present in env encrypted file. So one new thing that chainlink labs team engineering team developed along with functions is an NPM package for encrypting secrets.
00:15:08.110 - 00:16:30.570, Speaker A: So I will literally show in a couple of minutes when we start with the hands on part of the workshop how to encrypt all of these sensitive data API keys for AWS stuff. But essentially secrets are not going to be present or part or visible at any point to on chain entities. Basically they're going to be stored as encrypted part in a gist which only can be decrypted by Don's public keys, and immediately after the successful execution of the code, they're going to be deleted. So you can even access, as I said, password protected it devices. What else? Well, you can connect to an external database like MongoDB or whatever, or IPFs like decentralized storage providers, Filecoin, whatever you want, basically to pull the pool data from there. Yeah, AWS s three, Firebase, Google Cloud storage, all of these web two systems. I'm going to show you now how to connect with AWS, but basically you can connect with all of this stuff and yeah, Twitter API.
00:16:30.570 - 00:17:20.314, Speaker A: Again, another example what you can do with Twitter API endpoints, but it's totally up to you and your creativity what you're going to build. If you need more inspiration, there is a dedicated website for only these JavaScript code snippets called usechainingfunctions.com. So if you go to usechainingfunctions.com, you will see multiple JavaScript code snippets which they are read. You can literally copy paste to your project and send as a smart contract argument to the dawn to be executed. If you want your example to be present there, you're more than welcome to open a PR to be added there. Okay, we have a couple of questions.
00:17:20.314 - 00:17:59.014, Speaker A: Is this NPM secrets package a hard dependency of working with functions? Is there a spec we can use to implement our own insane. Rust in rust. Sorry. For this example that I'm going to show you is mandatory to be there. I don't think it's backward compatible. So I'm going to basically present to you like a hard hat project which use this secrets package to be present. So I'm not sure about the spec.
00:17:59.014 - 00:18:40.100, Speaker A: I will need to check the GitHub, but at the moment only JavaScript is supported, meaning that only this NPM package is supported. But yeah, if you want to re implement it in rust you're more than welcome to and also to open a PR and whatnot. Okay. Is it possible for chainlink to coordinate with Twitter's development team to give hackathon participants credit to Twitter API? I don't have that. Sorry about that. For future hackathon maybe? Yeah, for this one, I don't think we'll have time to do that. Okay, cool.
00:18:40.100 - 00:19:22.254, Speaker A: No further questions. This is just a feedback form. I'll present the feedback form at the very end of workshop as well. But this is just a simple type form to say to us whether you liked or disliked this and any previous and future workshops. So we can even improve more and more the quality of these workshops because they exist only for you to learn some new cool stuff. Okay, so let's now remove this from the screen and let's start with the hands on part. So I'm going to present you now the GitHub URL, the screen, and then you can follow along with me.
00:19:22.254 - 00:19:59.494, Speaker A: We'll just bit clone one repo and continue with the workshop. Okay, so I'm going to share my screen. Let's see here. So you should be able to see this GitHub page. So this is the repo where we stored the code for this example. For this use case, it's called functions AWS currency data. So I'm going to copy paste this thing to the chat so you can go directly to the repo.
00:19:59.494 - 00:21:02.186, Speaker A: This is basically the example that we are going to use today. So this is a hardhead project. And if I go back here so you can see that there is a couple of interesting stuff over there, I highly encourage you to, when you clone this stuff, to read the readme file carefully because it has step to step instructions how to run this thing, how to install it, and how to even expand it even more. So again, this use case is used to connect to AWS, specifically AWS data exchange data. There is this currency exchange API that we are going to use for you to be able to run this. The only requirement is to have node version 18. So make sure to have that and also to sign up for chain link functions beta.
00:21:02.186 - 00:22:45.202, Speaker A: So you will need to be whitelisted, whitelisted only for deploying these contracts to one of the given testnets for you to be able to follow this workshop. There is no need for you to be whitelisted because there is something called npxrhead function simulate, which will simulate the request so you can use it for testing purposes. And it's going to be simulated in local environment so you will not need even to be whitelisted, but you will need to whitelist your wallet address to deploy this, as I said, to testnets to confirm and finish with the development of your hackathon project. So let's go here and copy this thing and I'm going to git clone the repo now to my local machine, going to stop sharing this thing and I'm going to present my terminal, okay, so you should be able to see my terminal over here. What I'm going to type is git clone and the URL I copy pasted from the GitHub itself and hit enter. Okay, so the code has been downloaded to my functions AWS currency data folder. So I'm going to CD into it.
00:22:45.202 - 00:23:36.290, Speaker A: So CD meaning go into that directory. So CD functions aws currency data, hit enter. And now I'm going to open my code editor of choice and start with the development. I'm using visual studio code, but you can use whatever you want, even notepad plus, plus this command means that I'm going to open visual studio code in this folder. So this is just a shortcut, you can open it, hit enter, you can open it even with manually going and double clicking on visual studio code. Okay, so I'm going to stop sharing this. There is a question, so correct me if I'm wrong please.
00:23:36.290 - 00:24:24.418, Speaker A: But with that I could input, input any custom data to some smart contract. Actually the input itself, yeah, so you will have like a function insolidity. That function can have as an input any JavaScript code and then you will make a request to the dawn and then the dawn will execute that JavaScript code. So solidity will not be able to execute the code or whatever. The code itself will be only visible in transactions call data like encoded as I think, string or bytes data type. I'm not sure on that. Cool.
00:24:24.418 - 00:25:15.618, Speaker A: We don't have any further questions, so I'm going to present my screen once again. Let's go back to GitHub for a bit more. So let's go through this readme shall we? Okay, so the first thing is that you will need to create an AWS account. If you have not already. You will need to create an AWS account by going to AwS Amazon.com and here in the top right angle there is this orange button and the name AWS was the name again, create an AWS account. So I'm going to copy this here.
00:25:15.618 - 00:26:15.570, Speaker A: When you click it you will have simple sign up form where you can even verify this email address that it's correct and then you can set up a password. Or if you already have an AWS account, just sign in using this button. So I'm going to go back here to paste you the link for creating an AWS account. Once you have AWS account created, the next thing is to add this currency exchange API from this data provider. So again you can use a free tire AWS account. Obviously this will not cost any money, this particular example. So you'll need to subscribe to this API.
00:26:15.570 - 00:27:14.694, Speaker A: So when I click it it's going to navigate to this page. So this currency exchange in API is basically a listing consists of Amazon API gateway for free currency rates API currently including 150 plus currencies, including some common cryptocurrencies as well. So what you will need to do now once you sign in here and you will see your AWS username here, then you will just need to hit this subscribe button, subscribe orange button and you're good to go. Clicking on subscribe button. You will basically subscribe to this exchange API and it's free for you to join. You can see here it's a public offer like for twelve months. It's basically free.
00:27:14.694 - 00:28:25.390, Speaker A: If I click to overview over there, this is just an example usage of this API. So this API, this is an example for converting euros to to japanese currency. But basically you can see that you can create like a CLI request from AWS console or this is a plain JavaScript or yeah, this is a code that can be present even in JavaScript as well. So this is HTP get request with particular API endpoint with some parameters, et cetera. And you will see the response as a json file like this. So we are going to create from JavaScript HTTP get request using this specific format. And then when we have a callback value we are going to extract one of the properties of this object and format it as int two, five, six, not uint but int.
00:28:25.390 - 00:29:22.238, Speaker A: Because in some rare rare cases this can be a negative value and provides that value to the calling smart contract and then calling smart contract can do with that price whatever it wants. Basically that's it for the API thing. Let's just copy paste the link for you as well. Copy link address I'm going to go back to the chat AWS marketplace. Okay, so this is the link for connecting change API. Again, you can get it from the repo itself. And finally, for this thing to work, at some point you will need to set something called AWS secret key and AWS access key.
00:29:22.238 - 00:30:27.522, Speaker A: So this is specific to your AWS account, not to the subscribed services of AWS. So this is an excellent guide about AWS account and access keys, how to find them, how to generate them. It's extremely simple, just follow the steps. And basically access key and secret keys are going to be present at something like this, at this format with this number of characters, et cetera. So we will need those to be present of our env encrypted file in order to request to be successfully executed. Because this is basically telling. Hey, with these keys we are referencing to your AWS account while your AWS account has been subscripted to this currency exchange API.
00:30:27.522 - 00:31:41.582, Speaker A: So I'm going to quickly copy paste this link as well and then we can go back to the visual studio code and yeah, we have a couple of questions. Sorry, a bit late question. I still don't understand, what is the point of executing same code five times? If data query is wrong or malicious, it will be such all five times, so we don't get more trust. But yeah, this is specific for HTP get requests. And yeah, this is a valid question, but with channeling functions you can do more and more than just executing HTTP get requests like any kind of computation. So that's how you will basically eliminate the failure moment and also executing, as you said, like five times, meaning that each node is going to, that means that you will have in theory like five nodes. So that's where the five times comes from.
00:31:41.582 - 00:32:40.240, Speaker A: So basically if you don't execute it for five times, then basically the network itself cannot reach a consensus because all the nodes will need to provide their own version of computation and then to reach a consensus. That's the point. But this is still a valid question because if you have HT post request, like sending an email or a push notification, and if there's like 50 nodes in the dawn, you certainly don't want to send 50 push notifications or 50 emails. That's how you have for that particular use case. There is a property in config file. I will show you how to access this it's like literally array which says per node secrets. So these are the secrets per node that can node access.
00:32:40.240 - 00:33:54.520, Speaker A: This means that you will need to just have a tiny if else statement in your JavaScript code which will handle that use case. That means that if your node cannot access some flag for sending an email, it will certainly not send the email itself. So if you set up this per node secret, you can say that only first node can send email or push notification while the rest of them don't. And then you'll have just if else statement in the JavaScript to just simply not send the email or push notification and just continue with the execution itself. Hope that answered your question. Okay, so again, create AWS account, subscribe to currency exchange API and save AWS secret and access keys because we will need those keys to execute the request successfully. Okay, so again, share screen present.
00:33:54.520 - 00:34:46.920, Speaker A: Let's see visual studio code. Okay, you should be able to see this visual studio code screen. Okay, we have another question, sorry, just complimenting my last question about inserting data to a smart contract. I meant that in my smart contract I can call this chain link function and use that to receive data I need. Yes, from smart contract call chain link functions and then chain link functions will do all of this fancy stuff I said, and then you will have a calling request, basically callback value from that request. Basically. Okay, so let's jump straight into the code itself.
00:34:46.920 - 00:35:26.470, Speaker A: I'm going to zoom this a bit so we can see better. So this is basically hearth project as I said, so you're welcome. There are a couple of folders and files interesting to us here. So the first one is contracts. So inside contracts folder there is this functions consumer contract and a couple of other contracts. Contracts in different folders. Why? Because as I said, chainlink functions is not out of the beta yet.
00:35:26.470 - 00:36:10.626, Speaker A: So these contracts, like functions related contracts are still not part of chainlink contracts NPM package, so we cannot install it. That's why we're basically importing them locally. Once they are out of the data we'll just delete this and have this import, obviously. So this is an example smart contract of your DAP. This is an example of smart contract that use chain functions, but you can use and expand these contracts to do whatever you want basically. So there is this thing called functions library. So this functions library here.
00:36:10.626 - 00:37:08.600, Speaker A: So we're going to use it for functions request, a couple of events, and only two functions present here. These two are just for setting oracle address and simulator request API. We doesn't really need them for this workshop. So the first one is execute request, right? So this execute request have this as string source code. So this is JavaScript code that you're going to develop that you want to be executed using Internet functions, whatever you want. This is JavaScript code. Then secrets object again encrypted, they cannot be accessed on chain, they can be only decrypted with the don's public key, sorry with the don's private key, because they are encrypted with Don's public key.
00:37:08.600 - 00:37:49.460, Speaker A: Then some arguments. So these arguments are arguments for your JavaScript code. So if you have some custom arguments for your JavaScript code, you're going to pass them here. Subscription id as I said, remember subscription ID, that number you're going to fund that subscription ID. Add multiple, multiple consumers, this is just for Chainlink to know from which subscription to get links. And finally gas limit. Their current cap is 300,000, but you can set it manually to whichever value you want, basically.
00:37:49.460 - 00:38:29.738, Speaker A: And here we're going to create a request object, we're going to initialize request. We have a couple of IFL statements for handling secrets and arguments. So if there are secrets as remote secrets, if there are arguments, add arguments, if not, just continue. And finally sending the request itself, and that's pretty much it. Inside the smart contract we have three storage variables. So latest request ID, latest response, and latest error. So we're going to just store these values in a smart contract.
00:38:29.738 - 00:39:23.918, Speaker A: We're not going to do anything like advanced with those. That's totally up to you in your hackathon projects to use these data however you want. And like. So this line basically means I'm storing the request ID inside storage variable, and that's pretty much it. Fulfill request. So this function is internal, an override, which means internal coming from functions client over here, which means that fulfill request can be only called by the dawn, more specifically by the oracle contract, sorry, which communicates with the dawn. And here we'll have request ID which comes from here, from like send request function response, and if there is an error, an error.
00:39:23.918 - 00:40:14.930, Speaker A: So inside this response, this is a bytes character, so you can send whatever response you want, but it's up to you to know which response you're expecting, so you can then convert it and do whatever you want with that response. And if there is an error, we're just stored error here. But error means that you're going to need to handle errors if there are any errors. And finally we nothing fancy there coming back here, no questions. Fantastic. Let's continue with the workshop the second thing here is something called functions request config. So this is a config file for chaining functions.
00:40:14.930 - 00:41:26.466, Speaker A: So here we have a couple of JavaScript objects for location inline remote only inline depends like where your source code is stored, where your secrets are stored, arguments, et cetera. Inline or remote remote means that some encrypted gist while in line it at the project itself provided from this harkist orkit project, et cetera. Code language JavaScript Vanilla JavaScript at the moment again we're in beta, so we're going to expand this to more and more and more languages. Vanilla JavaScript means that at the moment you will not be able to install any NPM packages, so ethers and stuff like that. So Vanilla JavaScript means that only JavaScript, pure JavaScript can be used, but again that's going to be worked on for sure. Return type so return type is necessary for calling smart contracts. So as I already said, smart contract will need to know which data type you are going to send to it as a response.
00:41:26.466 - 00:41:59.970, Speaker A: So whether it's going to be unsigned integers or signed integers or string or bytes buffer or can be translated to bytes data type. So with bytes you can do basically anything. So bytes can be address. So when you have bytes you just need to cast it to address. It can be array, it can be a struct, it can be whatever you want. That's why we have those ABI encode and decode functions built into the solidity language itself. So we can convert bytes to whatever we want.
00:41:59.970 - 00:42:50.830, Speaker A: So with bytes data type you can send whatever you want. I have an example, I've written an example about connecting chainly functions with Facebook and Instagram business pages for galeway purposes. In that repo you can see the example of passing three array of three addresses to the calling smart contract as a byte. So you can see how to encode them on function side and how to decode them on solidity side as well. Then we have this request config object. So this is a config so code location where our code is located currently on the inline is supported. It's going to be meaning that it's basically inside this repo as well then language again only JavaScript, then the source.
00:42:50.830 - 00:43:35.586, Speaker A: So the source is coming from this functions request source API example JS and that's this file as well. So I'm going to open it as well. So this functions request source API example is the actual JavaScript code that we're sending to the dawn, and every single node into the dawn will execute the same JavaScript code again in its own serverless environment. By this line in config we are basically saying for source code, use this JavaScript code. That's it then. Secrets. So we specified here the secrets we need.
00:43:35.586 - 00:44:45.522, Speaker A: So we have AWS secret key and AWS access key and we will need three IDs, data set Id, revision id and asset id that are required from that currency API thing. These three we can copy paste from the readme, they're there. But for these secrets key and access keys, as I said, as I posted like a URL previously, they're your AWS account specific related, so you'll need to manually grab them from there. Similarly, you'll need to grab your wallet private key. It's specific to your account, don't share it with anyone. Same thing applies to those secret and access keys per node, secrets per node, secrets object assigned to each Don member. This property in config is related to the thing I spoke about earlier about specify that only one HTP post request should be sent when sending an email or push notification, et cetera.
00:44:45.522 - 00:45:45.660, Speaker A: So you will have as another secret, maybe a flag, you will say if this is true, then send a push notification, if not, continue. So you will basically need to have for each node a single secrets object and another one for that flag. While here for the first node the flag will be set, while for the rest one it's going to be some false or default value and that's how you're going to specify actually that it's per node. Secret wallet private key so this is a private key of your wallet which needs to be whitelisted on again Chainlink functions website, which you can find at the official documentation at Dogschain of link. We will need this wallet private key only for deploying the contracts to a testnet. So for this workshop you will not need to be whitelisted. So put whatever private key you want.
00:45:45.660 - 00:46:22.546, Speaker A: We should be able to simulate the request, but if you want to deploy it later, this address that comes from this private key should be whitelisted. So just apply for whitelisting. Enter the type form in under 24 to 48 hours. You should be whitelisted as hackathon participant and you're good to go. Arguments. So arguments are specific to the JavaScript code. So this JavaScript code, if I google for arguments, has two arguments, base and quote.
00:46:22.546 - 00:47:03.986, Speaker A: So we basically request the price of base asset. In terms of quote asset, these two arguments are related to the AWS currency API we're using. We're subscribing to, and that's why we passing them in this format. GbP, meaning means British pound, while USD means United States dollars. So I'm going to ask basically what's the current price of british pound in terms of US dollars expected return type. So this is important for a calling smart contract. So calling smart contract will need to expect the data type.
00:47:03.986 - 00:48:29.886, Speaker A: So as I said, we're going to return int, two, five, six, not unsight integer, but integer because in some rare cases maybe the price can be below zero. This is extremely important here to specify correctly, because if here is for example, string, while we are, if I go over there, here, I'm encoding this to be like integer, then the response object, which is going to be in bytes, the response parameter is going to be poorly encoded and it's going to be some dummy value. So just make sure that this is compatible with this encoding stuff here. Finally, secret URLs. If you have some remote secrets, off chain secrets to be point of, at the moment we don't need them. Okay, coming back to dar chat, are these secret keys passed directly without encryption into the smart contract? Sorry, I'm a bit late, excellent question. No, they're going to be encrypted and I'm going to show you right now how they're going to be also encrypted with the don's private keys don't public key.
00:48:29.886 - 00:49:47.602, Speaker A: So each node can decrypt it, win its own private private key, and then the secrets are going to be automatically destroyed. So how to use these secrets? Let's see right now. So first of all, I'll need to open integrated terminal and hit NPM install. So first I will need to install the project itself. Functions deploy client network Sepolia reverting browser version network sepolia doesn't exist. So this means that if I go to Harhat config, put in a second to close this thing here, Sepolia. Yeah, so this means that here is only harhead is defined.
00:49:47.602 - 00:50:18.038, Speaker A: Let's see what these networks are. Yeah, so this is the network. So you will need to specify it at Ethereum Sepolia instead of sepolia with capital S as well. So Ethereum sepolia is defined, not just sepolia. Okay, hope that answers your question. Do you have a team for this hackathon? Cool. One more question.
00:50:18.038 - 00:51:20.380, Speaker A: Okay, one more question. What is the benefit of getting prices from AWS, not just public endpoint like Coingecko performance reliability or like you have chaining data fits for getting prices. So I suggest for you to use chaining data fits instead of all these coingecko eWS stuff like forgetting prices. The thing with this workshop is that getting prices from this API is the most simple way to show to people how they can connect with the AWS services. But then you can expand it to even more complex examples. The problem with complex examples is that you will need to explain this using some simpler example because with some complex example, maybe it's hard for people to follow along. So definitely just because getting prices from AWS is extremely simple, that's the reason why we're using this service.
00:51:20.380 - 00:51:57.766, Speaker A: Yep. Thank you. You're welcome. Okay, let's now finally set up those secrets. Okay, so you have something called env example file over there. So env example means that we should set some of these values to be part of that env encrypted file. So we're not have env file with plain text.
00:51:57.766 - 00:52:28.650, Speaker A: Secrets with secrets in plain text. We will actually have encrypted version of env file. Sorry. And all of that comes from. Give me a second from. Give me a second from at chainlink envackage NpM package. Okay, how to use this link? So the first command that you should use is to set a password.
00:52:28.650 - 00:53:27.540, Speaker A: So you will set a password for this terminal session, particular session as well, so you can decrypt and see that the value was successfully set. So to do that, there is a command called NpX env set password. So npx envx env I'm going to paste it into the chat here. Okay. And I'm going to hit enter so it will says input the password. Now the input will be hidden. So I'm going to import the password so even I can decrypt these secrets and see that they are properly set.
00:53:27.540 - 00:54:07.390, Speaker A: So I'm going to import some password. Okay, and hit enter. Now for each of these secrets I will need to set them manually. For a contract to be compiled. I will need to set one of the following RPC URLs. So either Mumbai or Sepolia or Fuji not go early. We'll need to change that.
00:54:07.390 - 00:54:44.950, Speaker A: If anyone wants to be an open source contributor, now is your time. We'll just need to switch this from Gorli to avalanche Fuji. So one of the Rpcrls I will use sepolia and private key. I will need to pass like a wallet private key again for deploying to the blockchain. This should be like a private key of a wallet that has been whitelisted by chaining functions. But again, for this fridgehop can be any private key. And then I will set these five values.
00:54:44.950 - 00:55:20.834, Speaker A: Secret key, access key, data set ID, revision ID and asset ID. Why? Because if I go to the config file here in secrets, I have these five values. Secret key, Aws, secret key, Aws, access key, data set id, revision id and asset id. That's why I'll need to set them inside the JavaScript code as well. You can access them using secrets object. So secrets, the name of the property over here. Okay, and let's now set those values.
00:55:20.834 - 00:55:51.860, Speaker A: So to set them you will need to type npx env enc set command. And that's it. Now you will need to enter the variable name. To enter the variable name and press enter. After that you will need to enter the value for that variable name and press enter. And then we will be over there here for another variable, another variable, et cetera. Once we are done, we'll just need to hit enter to finish and that's okay.
00:55:51.860 - 00:56:27.946, Speaker A: There is no questions. Okay, so first of all, sepolia rpc URL. So I want to set sepolia rpc URL. I'm going to hit enter, enter the variable value. So I'm going to now enter just to grab the URL. For sepolia network I have like alchemy endpoint, but you can use infura, alhimey, whatever, whatever you want. So this is my sepolia Rpc URL, endpoint, even your node.
00:56:27.946 - 00:57:11.260, Speaker A: If you're running sepolio node, hit enter. Would you like to set another variable? If yes, again, hit it and press enter. So I want to now set private key wallet, private key here and the value of my dummy wallet account that I'm using for testing. So private key here, input will be hidden, hit enter. Would you like to set another variable? Now I would like to set these five variables. So again, secret and access keys come from your AWS account. So there is like in the chat a link for you how to grab them once you successfully create AWS account.
00:57:11.260 - 00:57:40.530, Speaker A: So I'm going to just grab mine. So secret key, hit enter value and I'm going to copy paste the secret key AWS key value. Hope I copied that correctly. Second one, access key. Okay, access key and grab the access key as well. Copy. Hopefully that was set correctly.
00:57:40.530 - 00:58:12.954, Speaker A: Enter. Next one, data set Id. Data set ID here. For this particular example, you can just grab them from here. So this is the data set id for british pound in terms of USD dollars. If you want to change them or to grab a new one, go to that API page on AWS console and grab the data set id from there. There is a link for you inside of the readme.
00:58:12.954 - 00:58:54.038, Speaker A: It can navigate you easily to there. Here I'm just going to copy this value then revision id. Revision id I'm just going to copy this value for revision id. And finally asset id. I'm just going to again copy asset id and the actual asset id here and hit enter to finish. That's it. I have encrypted all the secrets I need and now here you can see that a new file called env encrypted was generated.
00:58:54.038 - 00:59:43.062, Speaker A: And if I go here you can see all of the values I have set and their respectable encrypted values. So this is not an actual sepolia rpcrl, this is encrypted one. For example, for asset id we know that asset id is something a six, seven, whatever. Here is just r 52 ix whatever. So this is like an encrypted value of any single secrets object. If you want to decrypt them because you have set a password, there is a command called NpX env. You can validate locally that you have set them correctly.
00:59:43.062 - 01:00:22.200, Speaker A: I'm not going to do that. So just to not reveal my secrets, not because they are worth something, these are all dummy accounts with no funds and nothing. But because this is like a bad practice, so be aware of that. And for the sake of security please do not push this file to GitHub again. It's encrypted value, but you don't want to be brute force it by password, et cetera. So there is no point of deploying them and that's why they are present as git ignore. You can see here how they're grayed out and there is no new change in the source control itself.
01:00:22.200 - 01:01:19.914, Speaker A: Okay, let's go back to the chat one more time to see are there any new questions? Couple of them I getting a new error on deploy. Let's see the error deploying contract. Nothing invalid URL yeah, you will need to triple check that you set the URL correctly. Found the bug fantastically. Can't wait to see your PR. Okay, so each chain link, oracle that my smart contract connects to providers and permanent public key for encryption and our secret keys are encrypted using this key before being passed into a smart contract, right? You're correct. Right, thank you, thank you Tiffy for jumping in while I was blabbing over there in visual studio code.
01:01:19.914 - 01:02:16.362, Speaker A: Okay, and finally, let's now take a quick look at this JavaScript code and try to execute it and hope for the best. Okay, so this is just some error handling. So this is handling that. We have these secrets objects set correctly because we are going to actually need them for sending requests. I'm going to scroll all the way down here. So here we have response object, which is a callback object from functions make HTP request function. So functions is a library that comes with chaining functions and that allows you to make HTP requests, not just get request using this vanilla JavaScript thing.
01:02:16.362 - 01:03:12.558, Speaker A: So you cannot NPM install axios or something like that, but you can still use functions built in thing. And we're passing config object config object is an object we saw at AWS API at AWS console with API page how we should format our request in order to be successful so that we are passing here. This is just for code to be cleaner. And then we have a response again which is like a JSoN. So we have data. And then as I said, quote property. We have Jpw in a sample example on AWS API example page.
01:03:12.558 - 01:04:04.382, Speaker A: Well here we grab that value programmatically because we have this quote passed as a function argument which you already saw here. Here it is. Okay, so what is config? Config is just an object for creating this request. So we have this API endpoint. So host and URL are just host and URL specific to AWS services. Then we have set inside headers those three IDs, data set id, revision id and asset id. Then we'll need to provide a date which is basically timestamp now.
01:04:04.382 - 01:04:44.698, Speaker A: But we have this format to ISO date. So where this format to ISO date comes, it's just a helper function at the very top of our JavaScript function of our JavaScript file which formats JavaScript dates to ISO 8601 basic format. So this is a format that AWS console AWS can understand basically. And we have this short date as well. This is another helper function. Go all the way down. All of these functions are like really well documented so you will be able to find really easy to read this code.
01:04:44.698 - 01:05:24.920, Speaker A: Then there is this authorization part property of header which has access key specific to your AWS account. Then short date of this date. Another helper function we saw region. Region comes from this one service and then service is basically data exchange. This is like a service name. And finally we have something called build sign headers and signatures. So for these sign headers and signatures we have a couple of helper functions over there.
01:05:24.920 - 01:06:34.080, Speaker A: So if I go here after this short date we have a new helper functions called build signed headers which just return build sign header and very big, and probably the most big function over here to build a signature that AWS can understand. So it calculates signatures based on method, URL, host, secret key, security, token, date, payload, region and service. So we have a method for building queries, a method for building canonical request, a method for build string to sign, and finally a method for generate a signature from request using HMAC. Create hmac function which comes from crypto library. And crypto library is just coming from here. So you can use crypto library as well as part of like this vanilla Js setup with a couple of built in functions libraries. Everything is very well documented and official documentation and in the readme file as well.
01:06:34.080 - 01:07:19.582, Speaker A: So after that we'll just need to build queries, build analysis request, create hash and string to sign. Just call all of these functions with proper methods and that's it. All of these things are needed so we can properly create authorization header programmatically instead of like copy pasting everything from the API example. So you can basically use this for any two given pairs of assets. And finally, if there is like a security token present in secrets, we don't have that, we will just add another header. Don't worry about that. We don't have that.
01:07:19.582 - 01:08:34.520, Speaker A: Finally request, we have a price which we will going to multiple with 100, which means that we have two decimal places. And finally we are going to encode it as unsigned integer two, five, six. Okay, how to test this locally? So there is another handy thing in functions called NPX function simulate, which will basically simulate the request locally for you so you can see which amount of gas is going to cost, how everything's going to work. Are there any errors, unhandled, et cetera, before actually deploying this to a smart contract? Sorry, deploying smart contracts to a testnet and calling the actual done, which will save you from spending some of those test link tokens. Test link tokens again for testnets are free, just go to fossil chain link to grab them so you can test this theme on Testnet as well. But again, imagine that you're like on a mainet. So it's a good practice for you to try to test it locally before deploying and testing and everything.
01:08:34.520 - 01:09:31.874, Speaker A: Okay, so we will need to now call the simulate command and it is NPX hardhat functions. Simulate command and hit enter. So this command is now going to compile all these contracts and try to execute locally the code we provided here. And this is the response so we got this response over here. And while we convert it and encode it to be an integer which solidity can understand, this is the result, 126. So 126 is actually the price. But because we basically multiplied the price with 100, we have two decimal places.
01:09:31.874 - 01:10:14.310, Speaker A: Sorry. So one british pound actually equals 1.26 USD dollars. And that value is going to be. So 126 is going to be passed to the smart contract and smart contract will expect the number, will expect that there is two decimal places and then do the computation needed itself. I'm going to just go to Google to verify to USD to verify the result. But yeah, I can actually share that to see it's 1.25
01:10:14.310 - 01:10:51.294, Speaker A: pounds on Google, which means that there are probably some round errors present there. Okay, do we have any questions? Now it's Q and a time. So yeah, I can stop sharing this. Share the share Google string over here. So you can see this is the price. So we got approximate price. Again, this really depends on number of decimals.
01:10:51.294 - 01:11:47.022, Speaker A: So the more decimals you have, the more precise the price obviously is. Okay, NVM, nevermind, bug was in my local config, had the wrong variable name in. Yeah, that means that. Okay, I assume that that means there is no bug in the repo itself, but if you find any, please submit the PR. I'll be more than welcome to review it for you. Okay guys, do we have any final questions? This is now Q and a time. Again, I'm going to share the feedback form for you so you can scan the QR code, provide us some feedback, like 30 to 45 seconds max time form long so we can know how to prepare these workshops.
01:11:47.022 - 01:12:18.702, Speaker A: Even better. Was the pace correctly? Was too slow, too fast? Is the example too simple? Too complex? Have you understood anything? Et cetera, et cetera? Was I annoying? Maybe so you can replace me with Patrick, et cetera. So these are basically things we are looking for. But before that we have another question. How do you calculate the gas used for input source before it is executed in oracle? Excellent question. So I'm going to now share my screen one more time. Give me a second.
01:12:18.702 - 01:12:52.914, Speaker A: So I'm going to remove this present visual studio code. Where it is? Where is it? Visual studio code. Give me 20 seconds please. Yes, here it is. So you should be able to see again. So if you take a look here inside this thing, when you simulate the request, there is actually a gas usage recorded. So for send request transactions.
01:12:52.914 - 01:13:21.570, Speaker A: So the first one. Give me a second. Go back to solidity functions consumer. So execute request. This function will cost this amount of gas units. While this function fulfill request will cost this amount of gas units a lot, a lot less. Because here the call data object is actually really big.
01:13:21.570 - 01:13:55.420, Speaker A: So that's why it's more expensive. But you don't need to calculate them. There is like a calculation done for you when you simulate these requests. Hope that answers your question. Do we have any more questions? Any final questions? And if not, we can say goodbye to each other and finish another chain link workshop. Chain link spring 2023, hackathon workshop. I'm going to play some lo fi music once again.
01:13:55.420 - 01:14:01.420, Speaker A: And, yeah, if there are no questions. Thank you. And yeah, see you around.
