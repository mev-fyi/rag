00:00:01.370 - 00:00:32.162, Speaker A: Hey there. Today we're going to be talking about solidity and fuz testing using foundry. You thought fuzz testing was for your favorite stuffed animal. Well, buckle up, because things are about to get really fuzzy. So what exactly is fuzz testing? Fuz testing, or fuzzing, is a method of throwing a lot of random inputs at your smart contracts. Now, traditionally, this technique was used to find vulnerabilities where you would overwhelm a piece of software and cause it to crash. And that's not really a problem when it comes to smart contracts.
00:00:32.162 - 00:01:07.326, Speaker A: But what we do test is a smart contract's ability to deal with input that you wouldn't necessarily expect. This is actually called property or invariant based testing. In the context of solidity and smart contract development, fuzzing can be used to test the robustness and security of your smart contracts. Imagine throwing everything at your code, including that kitchen sink, and seeing if it can handle those ups and downs. It's basically like taking your smart contract, putting it on a roller coaster, and seeing if it can handle all the ups and downs and even upside downs. So how do you actually do fuz testing? Let's take a look. All right, so here we have a fairly straightforward erc 20 token contract.
00:01:07.326 - 00:01:37.270, Speaker A: Now, we set up a few things like the token name, the total supply, and the owner. We have a mapping for balances, and we have a transfer event. When we actually deploy this contract, we give the message sender, the person who's deploying it, the total supply of tokens, and we set them as owner. Now, the function I'd like to actually look at for this contract is this transfer function. It checks a few things. First, it's going to take in an address of a two who we're going to be sending tokens to, and the number of tokens that we'll be sending. It's going to require that the sender has enough tokens to do that.
00:01:37.270 - 00:01:55.242, Speaker A: Then it will make that transfer and emit transfer event. So that's what I'd like to test. How do we test that? So this is a foundry project. So we'll set up our test, and this is a fairly basic test here. You can see we set it up, we create our new token, and then we have this function, test, transfer. It's going to transfer 100 tokens. And it's pretty straightforward.
00:01:55.242 - 00:02:20.066, Speaker A: If we run forge test, we can see that it will actually run this one test and it passes. Cool. That's a pretty basic test. What if we wanted to use fuzz testing here? How would we do that, it would look something like this. The one thing to note here is that we're passing in a value amount. Instead of hard coding that in our test, this will cause foundry to actually run a fuzz test here. So if we go back and run forge test again, we're going to run into an error.
00:02:20.066 - 00:03:02.994, Speaker A: Now, what's happening here? Well, fuzz testing throws everything at this, any amount. And if you remember, in our original contract, we said our total supply is 1000, and then we have to have enough tokens to actually do this transfer. So what's happening is we don't have enough tokens to actually call this transfer. How can we get around this problem? Well, we know there's only ever going to be 1000 tokens, so we can assume that the amount that we're passing in is going to be less than or equal to 1000. We'll give this a save and now we can run it one more time and we'll see that our test is passing. And something interesting here to note in this line is that you can see the number of runs is 256. So foundry essentially threw 256 random values at our transfer and all of them passed.
00:03:02.994 - 00:03:17.220, Speaker A: And there you have it. You've successfully fuzz tested a smart contract. Give yourself a pat on the back or maybe even a fuzzy high five. Make sure you hit that like button and subscribe for more videos like this, and I'll catch you in the next one. Our.
