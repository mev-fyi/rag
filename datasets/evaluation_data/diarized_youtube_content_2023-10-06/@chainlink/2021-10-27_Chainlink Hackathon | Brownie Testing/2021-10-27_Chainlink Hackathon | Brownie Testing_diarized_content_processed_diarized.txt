00:01:59.940 - 00:02:14.570, Speaker A: You. Hello. Hello and welcome, everybody, to the Brownie testing workshop. Brownie Workshop. We're doing a little bit more python. Whoops, sorry about that. Welcome.
00:02:14.570 - 00:02:52.488, Speaker A: Reverberating in the background. How's everybody doing today? How are we doing hackathoning? We are. Wednesday, is it Wednesday, October 27? Yes, Wednesday the 27th. Few days into the hackathon, and I know we've already learned a ton. We're going to keep the journey going, the learning journey going, by teaching us how to kind of take all of our smart contracts and take what we've learned and take what we've built and test incredibly effectively and quickly. Right. Testing is this thing that's going to make us program and it's going to make us build these smart contract systems that are much easier to manage.
00:02:52.488 - 00:03:33.744, Speaker A: They're much easier to test to make sure they work right. So that's what we're going to be looking at today with Brownie again. So later on today, we have a hard hat edition of this as well, later on. So if you're interested in that, definitely be sure to check that out. I'm going to open up my vs code and we're going to jump right into it. Share my screen here. But how's everybody doing today? How's everybody doing in the chat? Feel free to say how you're doing today in the chat.
00:03:33.744 - 00:03:56.892, Speaker A: And again, I love making these collaborative, so please feel free to ask any questions in the chat here. I will be paying attention. JavaScript is superior. I disagree. I strongly disagree. All right, cool. Let's make this a little easier to see.
00:03:56.892 - 00:04:38.330, Speaker A: Okay, cool. It's too early for Js versus Python, so let's hold all that. Fair enough. Will you consider doing a Solana smart contract using rust? Great question, actually. So I think we have a Solana workshop at some point, but no, we're not doing it. Right. Yeah, and actually, if you want, we actually already have a getting set up with Solana YouTube video on the chain of YouTube, so definitely be sure to look for that if you're more interested in Solana, of course.
00:04:38.330 - 00:05:11.042, Speaker A: Low turnout for testing workshop. That's how we get crappy code, even though that's a joke. You're right. Right. If you don't have tests and you try to go to audit and you try to go mainnet and you try to go live, like go on a real main net, you are not going to do too well. Right. Having effective testing is really, we're human beings, and no matter how good you think you are as an engineer, you make mistakes you're going to make mistakes and you can't maintain your code without tests.
00:05:11.042 - 00:05:50.382, Speaker A: So building tests is absolutely important. I went ahead, I got started here with brownie init to create a new project in here. And again, for those of you who are unfamiliar with Brownie, I'm putting the brownie setup instructions in the link here. You can also look at the Brownie GitHub to learn how to install Brownie. Again, I'm working with visual studio code and yeah, I just posted the link here so feel free to check that out. Let's learn how to do some testing. So let's make a really simple smart contract.
00:05:50.382 - 00:06:32.446, Speaker A: I'm going to do simplestorage Sol again and I'm going to just rip through it. Pragma solidity seven. Actually, let me just grab it and I'll post a link to where I'm grabbing this contract from. That way anybody who's following along can follow along with me. Boom. And then we'll just do this as 0.8.7. Cool.
00:06:32.446 - 00:06:54.406, Speaker A: So I'm grabbing this from brownie simple storage. Here's where I'm grabing it from. Posted the link. So if you want to follow along you can just grab that copy paste. So I'm just grabbing, oops. Just grabbing the code here and boom. So we have a struct of people.
00:06:54.406 - 00:07:35.490, Speaker A: We have a mapping, a public mapping name to favorite number. We have this function store which just updates our favorite number. Here we have a function retrieve and then we have this function add people which adds a new name and a favorite number to our people array. So we have this people array which is an array of people, right? And yeah, then we map name to favorite number. Like so. So let me actually just do this. So it's a little bit easier to see everything's.
00:07:35.490 - 00:08:06.430, Speaker A: So we have a new type called people which consists of a favorite number and a name. We have a unit 256 favorite number which is kind of an overall favorite number. We have an array of people. We have a mapping here and then we have a couple of functions. Awesome. So let's go ahead and get started building some tests. And actually before I build my tests, I usually like to build a deploy script and then I can just use that deploy script in my test.
00:08:06.430 - 00:08:40.434, Speaker A: So if we do deploy py right in here, what I can do is I can say def main deploy. Then I'll do a def deploy. And right now I'm just going to do pass. I'm a fan of having my testing deploy. Deploy is not defined. Fix it in a second. I usually like to have my deploy script part of my testing.
00:08:40.434 - 00:09:08.930, Speaker A: That way I can just reuse my deploy script whenever I want. Right. And I think that that's been really helpful. Deploy is not defined but new lines, semicolons, es code is being added. Is the struct useful at all here? It seems like the mappings are more relevant. Yeah, this is just a sample smart contract. It's meant to just have a whole bunch of stuff in it.
00:09:08.930 - 00:09:39.820, Speaker A: That's pretty much it. All right, so if I run county run scripts but apply right now, see what happens, it should do a whole lot of nothing. All right, it does. If I do print high, let's make sure our print works. Cool. The script is running. For some reason, the linting is being mad at me.
00:09:39.820 - 00:10:19.160, Speaker A: Statements must be separated by new lines or semicolons. Figured out why it's mad at me later. But we're going to go ahead and grab what we're going to do from Brownie. Brownie import simple storage. Going to do simplestores, deploy from. I know I'm kind of speeding through this from accounts zero. We're going to import accounts as well.
00:10:19.160 - 00:10:58.900, Speaker A: Why is it mad at me about deploy? Okay, well, now, it's not generally. If you look at a lot of the code examples that we have, you'll see like account equals get account and get account is in this helpful scripts thing. I'm not going to use it for now since I'm just always going to be on a local network. But if you want to use that, you absolutely can. Statements mostly separated by new lines or semicolons. Why is it so mad at me? Ilance is against you today. Yeah, I guess it is.
00:10:58.900 - 00:11:24.090, Speaker A: Um, why is it so mad at me? It's mad at me all over the place. Elf and multiline statement. Yeah, pilots is being pissy at me for some reason. Sorry. But I'm going to ignore for now because it's working fine and I'll figure out what's wrong with my editor. Missing closing brace on dictionary. Well, that's.
00:11:24.090 - 00:11:43.202, Speaker A: Thank you. All right, well, now it's not pissing anymore. Great. And then we're going to do simple storage equals this. Then we're going to do return simple storage. And that's it. Right.
00:11:43.202 - 00:12:10.060, Speaker A: So let's do brownie, run scripts, deploy py. Let's see if everything works correctly. And cool. It looks like it's deploying. Things are working, but things are only working to our untrade eye, perhaps there is a massive mistake in here and that's what we would like to test. So let's go ahead and create some new tests here. Sorry, 1 second.
00:12:10.060 - 00:12:56.840, Speaker A: Wow, Harry, you're awake. Harry is awake right now. It is like, I don't know, some crazy time for him. Cool. So let's jump in to one of our tests. So typically when we make tests, we create two types of tests, unit unit tests, test and integration tests. So integration and unit tests, why? Unit tests are for running things locally.
00:12:56.840 - 00:13:39.600, Speaker A: This is like where you want to live basically. Before you go to a testnet, before you go on main net, you want to do everything locally as long as possible because it's going to make you very fast. It's going to make you much, much better at deploying quickly. Right. Integration tests are still incredibly important because you want to test when you're on a testnet or a main net. Maybe your oracle addresses are wrong, or maybe your VRF coordinator key hash is wrong. You want to do integration testing to make sure all your config stuff is right is good, right? We can also do mainnet fork testing as well, which can be incredibly powerful.
00:13:39.600 - 00:14:07.630, Speaker A: And we'll do an example time dependent here. We're already 15 minutes in. Oh my goodness. All right, so let's create a new unit test. Okay, so in typical python fashion, we're going to start it with test, and we'll call it simple storage py. And here's where we're going to write all our tests. Now, ideally when we write our tests, sorry about that.
00:14:07.630 - 00:14:29.508, Speaker A: Ideally, when we write all of our tests, every single line of code is covered, if you will. Right? Every single line of code is tested. So everything here is tested. Everything here is tested. Everything here is tested. All this stuff is tested for, and that gives us the most coverage. So let's go ahead and just start testing for store.
00:14:29.508 - 00:16:00.632, Speaker A: Okay, so in our test, what we can do is we can do def or define test store updates properly or something, right? Whatever we want. In typical python fashion, you typically want to make your test functions as verbose as possible, right? You want it to basically say exactly what they do properly is kind of a bad word here, but I digress. And in here, what we're going to do is we're going to deploy this contract here. So what we're going to do is we're going to do from scripts, deploy, import, deploy, and now we have that deploy script. Depending on your Python version, you might have to do new file init I for this to work, you just create this init file and boom, you're good to go. Now that we have this deploying here, we can do simple storage equals deploy. And now we can do some test stuff on this simple storage, right? So we can do, maybe we want to just check to make sure that our favorite number variable is zero, right? So we could do assert simple storage.
00:16:00.632 - 00:16:37.570, Speaker A: What do we call it again? Retrieve. Retrieve is zero or equals, equals zero. This is like the simplest test we could do. Now if we do brownie test, we see, yay. This little dot thing says, hey, good job, you passed the test. Hooray, we did it. Now typically I follow the arrange act kind of format for the assess.
00:16:37.570 - 00:17:20.654, Speaker A: Arrange is going to be like, hey, here's how you set everything up. And then you do the act. And then you assert, in this case, the act is this retrieve thing. So if we wanted to separate this out more explicitly, we would say like starting value equals simplestorage store. And then we would just assert a starting value equals, we'd say something like expected zero cert, starting value equals expected. And then we can just do brownie test again. And boom.
00:17:20.654 - 00:17:30.710, Speaker A: This looks nice. This is a nice looking test. So cool. Oh, just kidding. It's a terrible looking test. It's the dumbest looking test ever. Retrieve.
00:17:30.710 - 00:17:45.514, Speaker A: I always spell retrieve wrong. I before E except after c. Yes. Okay, now let's run it. Now it's a good looking test. Okay, cool. Perfect.
00:17:45.514 - 00:18:42.890, Speaker A: So this is our first test. Awesome. Now something else that you'll run into and that you might want to do is in our next test, def test something else. We're probably going to do this again, simple storage equals deploy. Depending on how you run your test, you might not always want to redeploy this, right? Because even though we're running it locally, every single time we redeploy, that's going to take time, right? So what some people do is they create what's called a fixture, right? So they could do something like def test or deploy simple storage. And then they just do this. Simple storage, deploy return simple storage.
00:18:42.890 - 00:19:36.720, Speaker A: And at the top we'll do at pytest fixture. And there's all this scope stuff. And then I got to import pytest. If you don't have Pytest installed, you'll have to do pip install pytest or pip three install, depending on what version of python you have. But now what we can do is we can pass fixtures as parameters to our tests and instead we can do something like this. We're passing our fixture as a test to simple storage. And now it'll use this simple storage fixture and you can do all this scope stuff to change when you should redeploy, right? If scope equals, is it module? Hold on.
00:19:36.720 - 00:20:43.090, Speaker A: I'd have to double check actually the specifics, but you could change the scope to say, hey, I want this deploy redeploy every test, every ten tests, every whatever, right? To make your life a lot easier. So now if we run this, run scripts Brownie test, it should function the exact same. Tada. Yay. Now one other thing that you'll see that's also incredibly clever is oftentimes people when you write their tests, they have like a ton of these, ton of these fixtures, right? For whatever reason, they've got a ton of fixtures that do who knows what and that's good. But that can be kind of cluttery having them all up at the top of our tests here. So what a lot of people do is there's a special file in python tests called conf test py.
00:20:43.090 - 00:21:44.566, Speaker A: What you can do in here is you can have all your fixtures and let's just import itest from scripts deploy. You can put them all in here. And when we run our tests in here now I don't need these lines anymore. Actually when we run our tests in here, I can still pass deploy simple storage because brownie automatically takes all the fixtures and stuff from here and sticks it into our tests. So if I went to run this again test, it's still going to pass because we've stuck in that conf test thing. Tada. So that's something that you're going to see a lot when you go through a lot of the professional code, which is cool.
00:21:44.566 - 00:22:01.114, Speaker A: They utilize this comp test thing to the fullest. There's all these different parameters you can use with fixtures to say when you want it to redeploy. When you don't want it to redeploy. It's really helpful. Definitely check it out. And another thing actually. Yeah, never mind.
00:22:01.114 - 00:22:12.240, Speaker A: Yeah. So boom. Great. We have a couple of tests here. Now let's go ahead. Let's write another one. Right? Let's do this add person one here.
00:22:12.240 - 00:22:59.070, Speaker A: Actually, no, let's do one that's more, let's just do store, right? Let's do store real quick. So we'll do def test. This is actually def test like initial deploy or something test. And initial deploy is good. That's not a great name, but you get the picture now, def test store updates properly and in here we could pass deploy simple storage. I'm just going to do it like explicitly so I'm going to actually go back. I'm going to do scripts.
00:22:59.070 - 00:24:04.306, Speaker A: My range, I'm going to say simple storage equals deploy act is going to be storage store. Let's do 77 and then we'll do, we'll say store transaction equals simplestorage store. And then we'll do assert actually, we'll do expected equals seven. Do it like that. We'll do store transaction, wait. The reason it's good to do to wait is actually Brownie kind of freaks out if it has transactions that are in flight that haven't completed while Brownie shuts down. So it's kind of just good practice to always do wait.
00:24:04.306 - 00:24:41.726, Speaker A: And it's good practice to always do wait anyways. Because if you try to check to see if a transaction, if a value equals something else and the transaction hasn't even finished, that's going to be no good, right? You're not actually going to be able to check to see if it's done. But now we can do assert simple storage retrieve equals expected. Boom. Okay, cool. Browning test. And now we'll have two tests and hopefully both of them pass.
00:24:41.726 - 00:25:12.082, Speaker A: Boom. All right, so when I'm coding smart contracts, typically I'm always testing as I'm building. The only way to really see if the functionality that we're doing is good is if you write like a test. Right. This is also how auditors will check what your expected functionality is. Right. If I want to go learn how to use some framework, too oftentimes I'll jump into the test because the tests say, hey, these are the things that we want this to do.
00:25:12.082 - 00:25:40.734, Speaker A: So this is what we're going to be testing for. Yeah, that's really helpful. Now a couple of quick tips on writing tests that I think are really fantastic. Brownie test K. And then you put your test in. We'll test just that test. So these are some helpful tips that are going to help you out, right? Only one ran and one was deselected.
00:25:40.734 - 00:26:39.434, Speaker A: So k is going to be really helpful. S is going to be really helpful, too. If I write in here, like print, what's up? Something and I run brownie test, this what up isn't going to get printed because python automatically, it turns off or deroutes standard output or something. When you run python tests, they don't do the print standard output. But if we do s, we do see what up s will get those back. And the other one that's amazing is PDB. If you run into an error, it'll stop at that error and allow you to kind of enter a python shell.
00:26:39.434 - 00:27:02.630, Speaker A: So, like, if you want to do, assert one equals two. So dash dash PDB. Sorry. Now it says, hey, one doesn't equal two. You're crazy. And we get to enter a shell here. So what I can do now is I can say, like, okay, well, what was expected.
00:27:02.630 - 00:27:22.862, Speaker A: Okay. Expected was 77 is my simple storage contract. What is my simple storage contract? Store storage contract look like? And I can see the simple storage contract. I can even call functions. I still don't know how to spell that. Iev retrieve. I can call functions to my smart contract.
00:27:22.862 - 00:27:58.294, Speaker A: And this is like my debug mode. This is like, typically when a lot of newer engineers start debugging and start getting into testing, they put a ton of print line statements everywhere. That's cool. But it's miserable to do. This is kind of the much more pro way to do it, I guess. Right? Because you're in the shell, you have access to all the variables and you can see everything. Those are some of my commands I use all the time in the test file.
00:27:58.294 - 00:28:10.978, Speaker A: You only define functions so it will automatically go through all them. What if you only want one of them? Oh, perfect. I answered that already. Yeah. So if you just do brownie test, it'll go through all of them. It'll go through this one. It'll go through this one.
00:28:10.978 - 00:28:42.940, Speaker A: It'll go through everything. Right. Cert one equals two. And like I just said, if you do K and you push the name of the function, just do one of them. Right? And that's something that you're going to use all the time. You're going to use that dash k all the time. Because when you build some new functionality, you're only going to want to test that one thing, right? You're not going to test everything because that's not good.
00:28:42.940 - 00:29:52.980, Speaker A: That's not good. All right, so those are some of the simple tests. Are there any questions with any of that so far? And then we're going to jump into some more advanced tests and we're going to jump into some integration tests. I know we only have 30 minutes left, hence why I'm going a little bit quick here. Are there any other tests here? And apologies about that. If there are no other questions, we're going to jump into the chain link mix. Switch my screen share here.
00:29:52.980 - 00:30:29.326, Speaker A: All right, cool. All right, so now we're working with the chainlink mix. I'm going to put a link to this in the comments section so everybody could take a look see. This is the Chainlink mix. It has a ton of tests. It has a ton of stuff in here for us to write smart contracts, write really effective smart contracts and write really effective tests as well. So we have our contracts here.
00:30:29.326 - 00:31:18.314, Speaker A: We have API consumer, counter price feed, VRF consumer. We have a whole bunch of scripts in here to deploy our stuff. And we've got a couple of really powerful tools in here in our helpful scripts. One of them is going to be this get account, which is going to help us swap between a local ganache or local hard hat versus like a real testnet. But we've also got a ton of tests in here. Now let's look at the VRF consumer, because this is a great one for learning a lot of really cool intricacies for testing our smart contracts. And if you haven't seen this code, it's available in the mix.
00:31:18.314 - 00:31:54.860, Speaker A: It's also available in the chain link documentation under VRF. So let me just walk you through really briefly what's going on here. And again, if you're trying to follow along, feel free to just copy paste this into your code editor. So here's what's happening. So we have a constructor where we're defining, where we're defining a bunch of stuff. Oh, that's weird. These aren't commenting out or syntax highlighting out, but whatever.
00:31:54.860 - 00:32:52.586, Speaker A: We're defining a new contract which has all the parameters for using a VRF coordinator. If you haven't watched the everything chain link, definitely watch that to learn what all these variables are for. We did that sometime at the beginning of the week or this weekend, I forget, which was great. All we have is this main function called get random number and fulfill randomness. So what this number does is it makes a request to a chain link node by calling this request randomness function, right? So this request randomness function returns a byte 32 called request id. Right? So the reason we can just do this syntax is because, well, you can always do the syntax, but we're saying there's a bytes 32 named request ID that we're returning. And this request randomness function is inherited from our VRF consumer base, and it's returning a bytes 32, right.
00:32:52.586 - 00:33:46.938, Speaker A: It's returning the request id. Now in our fulfill randomness function, this is what the chain link the VRF coordinator uses to give us that random number, it returns by giving that original request id. And then of course your random number. And then we have this global public variable called random result that we're using to call back. Okay, now pull up, got like a million tabs open. Now if you go into tests. There's already testvrf py.
00:33:46.938 - 00:34:19.570, Speaker A: Guess what? We're going to delete it. We're going to do it from scratch. And that's what we're going to do the rest of this demo here, because this is going to pretty much teach us everything we need to know about testing. Because the test VRF, working with asynchronous requests or channel link Oracles, is really one of the most interesting ways to test and has kind of everything that we need to do to learn everything. So let's do it. Let's create our own testvrf py. So we're going to do testvrf py.
00:34:19.570 - 00:34:57.570, Speaker A: And if you want to follow along again, all the code here is going to be in that chainlink mix. So we can just do everything there. Now, when we're building this contract, what do we want to test for? Well, we're probably going to want to test, really what we want to do is we want to test that. We can get this random number and we can get a return. Right? We can get this callback here. Actually, let me take a question real quick. Thoughts on team testings.
00:34:57.570 - 00:35:59.606, Speaker A: Should you have a test engineer making tests for everyone's code or everyone making their own tests strategy for hackathon ofytes? Great question. Everyone should make their own tests, ideally, right? Because if you write all this functionality and you have a test engineer who's supposed to test it, they don't know what the functionality does, and maybe the person wrote the code bad, and maybe you get your test to pass and you should be in charge of the quality of your own code. Right. And the way to ensure that quality is to write tests. You'll see on a lot of open source GitHub projects, too. They'll have a requirement. They'll say, hey, did you write tests with this code? If you try to make an improvement, if you try to fix an issue or something on some open source code, if you don't write tests, they shouldn't allow your code in, right? Because that's going to be the only way to ensure that whatever functionality that you put in is going to be there, and it's going to do what you want it to do.
00:35:59.606 - 00:36:24.480, Speaker A: So you should be in charge of your code. Great question. Thanks for the compliment, Stephen. But yeah, so let's do this. So we want to kind of test that. We can get a random number and we can get returned a random number. Now we're going to do kind of a kind of conglomerate like, massive test that just kind of does both of these things.
00:36:24.480 - 00:36:55.400, Speaker A: Ideally, you want to separate them out into separate tests and stuff. We're just going to make this massive monstrosity. So feel free to keep in mind that you don't have to do this massive monstrosity. We're just going to make our test. We're going to say def test and request and return random number. Yes. This is an insanely verbose test name.
00:36:55.400 - 00:37:19.620, Speaker A: I like doing verbose test names because I think it makes it more readable. Some people argue that it makes it less readable. It's kind of up to you. Our main goal is to try to find any situation our code could break for. And that's the importance of doing a test. Yes. And it's to try out like exploits and stuff.
00:37:19.620 - 00:37:39.894, Speaker A: Yeah, exactly. So let's do this test. So first I'm going to want to deploy this VRf consumer, right. Already have a deploy script. So in my script section, we're just going to go ahead and get this deploy VRF. Let's see. Let's make sure it's returning.
00:37:39.894 - 00:38:09.502, Speaker A: Great. It is returning this, which is perfect. What we're doing in here is we're giving it a key hash, VRF coordinator, link token, a fee, and then we're publishing source. If it's on a testnet, don't save. So let's go ahead and grab that script. We'll do from scripts price feed scripts, not price feeds. VRf.
00:38:09.502 - 00:38:34.550, Speaker A: Vrf scripts. Deployvrf import, deployvRf. Oh, right. I can't actually do that. I'm going to rename, what did I do in the, I'm actually going to rename this to deploy VRF py for the test here in the chain link. Nix. I actually just redeployed it manually.
00:38:34.550 - 00:39:06.422, Speaker A: But for the purpose of this demo, I'm going to rename this to deployvrf Py and then we're going to import it like this. That way it's just a little cleaner, a little nicer. If you want to redeploy manually, you can absolutely do that. And you can see the chainlink mix to do that, would using Slither help to develop tests for our code? Basically, what are best practices for developing our own tests? Great question. Slither is what's called a static analyzer tool, and it is really fantastic. Yes. You can use it to help test your code.
00:39:06.422 - 00:39:47.122, Speaker A: If Slither says, hey, these lines of code are bad, that can be really helpful. Another thing that you can do is you can run a brownie report, actually, what is it called? Again, coverage. Brownie, bake. Why am I drawing a blank? I can't remember the dash dash. Coverage. Coverage, that's right. What you can do is you can run.
00:39:47.122 - 00:40:29.140, Speaker A: So brownie has this built in coverage testing tool, and I broke it because I just changed a whole bunch of stuff. Make sure your test module packets have valid python names. Deploy VRF. Can't import. Deploy VRF from VRF scripts. Deploy VRF. Mad because it was unused? Is that why it's mad? No, it's mad because of something else.
00:40:29.140 - 00:41:19.730, Speaker A: Make sure your test modules have valid python names. Do I need this? Do I need this in here? Is that what I need now? Are you mad at me? All right. Well, it's mad at me for something, but that's what you can do one of those coverage tests to look at your code. But you can also look at your code and say, okay, is everything here tested? Right. So static analyzers like Slither and like Brownie coverage are great. They're definitely going to be helpful, but they're never going to cover all the use cases that can happen. Right? It might say, hey, this has been covered, but maybe you have some only owner stuff or some access controls and you didn't test all the different people.
00:41:19.730 - 00:41:54.970, Speaker A: You want to have access to your application. So Slither can help. Brownie coverage can help. But at the moment, there's still going to be a human component where you jump in and you have to go line by line through code and think, okay, what are some of the exploits that can happen here? Now, if I run Bernie test K, this should work, or is it still going to be metami? It's still going to be Metami. Deploy VRF from scripts. VRF scripts. Deploy VRF.
00:41:54.970 - 00:42:50.030, Speaker A: Why is this mad at me? Scripts Vera scripts. Deploy VRF. Deploy capital O. Somewhere in my script. Deploy vrf. Oh, I'm just terrible at spelling. Is that the case? Depoloy.
00:42:50.030 - 00:43:37.688, Speaker A: That makes a lot of sense. Deploy. There it is. Thank you. Is it okay, now we can do brownie test coverage, and this will give us a pretty verbose report. We don't have this configured to do all the excludes and stuff, but it'll run through the test and it'll give you something that looks like this. And so this is kind of a spot check to see how much of our stuff has been tested, right.
00:43:37.688 - 00:44:08.528, Speaker A: So we can actually see a whole bunch stuff here hasn't been tested. And again, this is because of demo repo, just to kind of show you how to do stuff. But for example, there's this buffer chain link contract that gets imported when we do import chainlink client. So what we can do in your browing config, if you don't want those, you can just kind of exclude those. So we could say, hey, buffer chain link is good, we don't care about that and we'll rerun it. And now buffer chain link will be gone. 845 already.
00:44:08.528 - 00:44:26.408, Speaker A: Oh my goodness. We got to go super fast here. And yeah, buffer chain link is gone. So that can be a good way to get a good sense of how much is tested. All right, now I got to go super fast. VRF consumer equals deploy. Great.
00:44:26.408 - 00:44:58.710, Speaker A: And this is going to be our arrange. We're going to have a huge arrange here because we're going to do a whole bunch of stuff. Great fear consumer equals deploy. Now in our script, our deploy script here, we do this get account thing which all it's doing is it's checking to see if this is a custom script that we've written in helpful scripts. It's just checking to see if we're on a testnet or not. And if we are on a local network giving us a local. If not, it's giving us a test.
00:44:58.710 - 00:45:29.052, Speaker A: These functions are interesting. These are special functions, again, that we have in our helpful scripts. They do something really clever. So this get contract thing, when we deploy our VRF code, we need a VRF coordinator address and a link token address. However, if we spin up a brand new blockchain like we do when we work with Ganache, when we work with a local chain, what are those addresses going to be? Nothing. Right. There's nothing deployed there.
00:45:29.052 - 00:46:02.644, Speaker A: So this get contract function is clever because what it does is it checks to see if we're on a local network. And if we are in a local network and that contract doesn't exist, it deploys it for us. So this is kind of the code that does that. We basically say, hey, if network is on a local blockchain environment, we're going to deploy mocks. Now what are mocks? Mocks are our fake contracts. Right. There's a function in here called deploy mocks.
00:46:02.644 - 00:46:36.580, Speaker A: And what it does actually, let's just find it. What it does is it deploys a whole bunch of mock contracts. Right. And this is an important thing for testing on our non forked local chains, which we're not going to have time to get to forking. But forking is also really powerful. If you all are interested in learning about forking and some more testing advanced features, I can send you some timestamps from that free codecamp video which has all this defined in here. And again, I'm watching the comments here.
00:46:36.580 - 00:47:14.112, Speaker A: Please feel free to ask questions. But in our contracts here we have this test folder to interact with Chainlink, VRF to interact with a price feed to interact with an API call there are these contracts that we need, right. First we need the link token, right. The link token is a contract that we need to work with. We need an oracle contract, we need a price feed contract and we need a VRF coordinator. So in our contracts folder we have this test folder and these contracts are just used for us to test. Right.
00:47:14.112 - 00:48:10.736, Speaker A: So we need to deploy a fake link token so that we can pay for our VRF calls and our API calls. We need to deploy a fake mock of V three aggregator which is our price feed, right? Because we need to read from a price feed. These are all these mock contracts, these fake contracts that we're going to deploy so we can interact with stuff. Now I'm going to go back here and try to speed through this. So we have this deployed and sometimes too to make sure this is a unit test, I'll do something like if network show active is like a local chain or I'll say is a local chain pytest and you can check the chain link mix to kind of see that code. We're going to skip it for now though. Great.
00:48:10.736 - 00:48:40.744, Speaker A: So we have our VRF consumer deployed. Perfect. Now once it's deployed we could check some stuff. We could check to make sure the key hash fee and stuff is all good. But we're just going to jump into testing this get randomness. Now to get a random number the first thing we need to do is we need to transfer some link token. So the other helpful thing about that get contracts script that I was showing you is we can use it to get our mocks and get that instance of that contract.
00:48:40.744 - 00:50:15.530, Speaker A: So we're going to do from scripts, helpful scripts import get contract and to send our address here some link token, we can just say get contract link token which this will return us the chain link token and we'll just say transfer herefconsumer address and then we'll do 112-34-5678, 910, 1234-5678 or yeah, and then from we'll do account, get account. We can do this because our get account is going to return the same account that deployed the link token, right. And in our link token deployment we minted ourselves all the link token, right? So we have a ton of link tokens so now we can just easily transfer it to the VRF consumer. Great. Now that we've transferred it, we can actually go ahead and start getting the random number. Right. So we can do VRF consumer get random number.
00:50:15.530 - 00:50:59.876, Speaker A: We can just say from account and this will give us a transaction. Right. We'll do TX, wait one. Now what we're going to want to do is we're going to want to see if a chain link, and then we're kind of in the act phase now. And we're going to want to do is we're going to want to simulate returning that random number to our smart contract. Now remember, on our local chain, do we have any chain link nodes listening for us to call this get random number? No, we don't. So we're going to be the chainlink nodes.
00:50:59.876 - 00:51:52.328, Speaker A: We're going to pretend to be the chainlink VRF to return these random numbers. So what we want to do is we're going to want to get that VRF coordinator contract and pretend that we're the chainlink node. So we're going to say get contract VRF coordinator and we're going to call the function that's going to call fulfill randomness. So if we go in here, we go to VRF coordinator mock. There's this function called callback with randomness, which takes a request ID, a random number and a consumer contract. And it's this function that is what the chainlink nodes are calling to return the random number to our smart contracts. And it's this function that's going to actually test to see that the number is actually random and stuff.
00:51:52.328 - 00:52:47.800, Speaker A: This is just a mock though, so it doesn't actually make sure the number is truly random. But you can check to see what this code looks like on a non mock because if it was checking to see if it was truly random, we'd have to make it truly random. And that's not something that we really want to do. So we're going to call this, we're going to get this VRF coordinator contract and we're going to do callback with randomness. And like I said, this is exactly what the chainlink node is doing. And it's this function call that will call fulfill randomness. So callback with randomness and we're going to give it, we're going to give it the request ID randomness consumer contract.
00:52:47.800 - 00:53:22.068, Speaker A: Now you might be asking, hey, how do we get the request ID? Where is that? I want that. Well, there's a few ways we can get that. And I got to explain it in like six minutes. The first way is we can use return value. So if we do request ID equals tx return value, boom. That's the easiest way to do it. Every transaction has a return.
00:53:22.068 - 00:54:07.068, Speaker A: Well, not every transaction, but get random number returns a byte 32 request ID. So the return value of this transaction is going to be that request ID. So that's why one another way we could do it is we could look into the events and you actually see this as pretty common practice. So you could say request ID equals TX events. Wow, something like this. Basically we'd have to emit an event in here to like, we do like emit requested random. Well, we'd have to do this after we created the request city.
00:54:07.068 - 00:54:39.470, Speaker A: But you get the picture. That's another common way that these values are returned, right? Because you don't always have a return value here. Sometimes you have the events instead. The events are really helpful. So we'll do callback with randomness request ID. We'll give it a random number and then we'll give it the address which is going to be VRF consumer address. And then again we'll just do from count.
00:54:39.470 - 00:55:40.740, Speaker A: Actually we'll do expected equals seven, seven, seven do expected instead. And I'll uncomment that. Cool, great. Now we should be able to assert VRF consumer random result, right? We should check that this number is being accurately updated by a VRF node. So we can say vrconsumer random result equals equals expected. And we can run this Brownie s k like so. And that thing I was talking to you about just happened.
00:55:40.740 - 00:56:17.952, Speaker A: So we got to make sure to do a TX wait so we don't get this weird massive issue. The thing is, if you get this and you scroll up, you'll actually see that all the code ran fine and it just got confused in the threading. If you see this, it's fine. You missed the TX, wait somewhere. Let's run it again. We did it. So that has been your incredibly quick crash course into testing with Brownie again.
00:56:17.952 - 00:56:59.436, Speaker A: If you want to learn more about testing, we do some really cool creative, well, not creative. We do some cool stuff in that freecodecamp video. Feel free to ask me about it. I can drop you some timestamps or point you in the direction of the lessons that can teach you more testing stuff. But yeah, this is the crash course and it's these tests that are going to make you way better as an engineer. How good your tests are are the first thing an auditor should look at in your code and it's one of the first things that you should point people to, to say, hey, here's how I want you to interact with my protocol. So that's it.
00:56:59.436 - 00:57:19.184, Speaker A: We have two minutes left here. We sped through a lot of stuff here. We sped through. Any questions here? I think you can run tests on COVID. Yes. So what you can do is you can do the exact same way you deploy to a different network. You can just do network like COVID.
00:57:19.184 - 00:57:48.892, Speaker A: Now, for the test that we just ran, you would need to do an if statement for your say, hey, if this is on a local network, don't pretend to be the chainlink node. Right. So you would need to do that if statement for a testnet. But yes, you can run these on COVID, on testnet. And in fact, you should. You should do integration tests. So that's what I was showing at the beginning, having unit tests and an integration test.
00:57:48.892 - 00:58:19.876, Speaker A: To do the integration test, you'll just do brownie test, network COVID. And you'll want to specify in your tests to, hey, only run this if you're on COVID. Only run this if you're on COVID. How do you configure tests to directly on COVID? Yeah, you'll put an if statement in your tests. You'll say, if network is COVID, proceed. If not, stop, and that's it. You can set up env with inferior.
00:58:19.876 - 00:58:48.700, Speaker A: Yep. When you submit a contract for auditing, do you submit your tests as well? Yes. In fact, you should. And if your auditors don't look for tests or don't ask for tests, you should question how good those auditors are. If I'm auditing a contract, tests are the first thing I'm looking at. I'm trying to run your test suite, because if your test suite doesn't pass, I'm going to tell you, hey, there's something wrong with your code. It is a pain to see code without documentation.
00:58:48.700 - 00:59:07.456, Speaker A: Yes. And good tests are in a know documentation. I want to do tests in Brownie, but infra, which Brownie only supports, is having issues with Polygon network. Great. You can change your network using brownie networks. Add and you can change your host. You can also do brownie networks.
00:59:07.456 - 00:59:22.830, Speaker A: Edit. If you're running into problems there, sorry. If you're running into problems there, feel free to make a stack overflow question. Hey, how do I switch from inferior to alchemy? Drop it into the discord. Excuse me. Ping me. I got to go.
00:59:22.830 - 00:59:32.490, Speaker A: I'm cutting into the next workshop's time. Thank you so much for being here. These have been amazing questions, and we'll see you in the next one. Bye, everybody.
