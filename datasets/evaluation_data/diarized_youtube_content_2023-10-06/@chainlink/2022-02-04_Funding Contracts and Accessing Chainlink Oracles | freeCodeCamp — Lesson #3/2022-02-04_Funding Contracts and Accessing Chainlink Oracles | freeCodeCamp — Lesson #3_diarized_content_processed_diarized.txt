00:00:09.050 - 00:00:53.510, Speaker A: Hello and welcome to lesson three, the fundme lesson. This is one of the most important lessons in the entire course, and if you're successful here, you'll have the majority of the tools you need to be a successful smart contract developer. Now, just because you have all the tools, though, doesn't necessarily mean that you know how to use them all. So be sure to watch the subsequent lessons as well to get even better. But in this video, we're going to learn about sending money and working with Ethereum and working with the Ethereum tokens in our smart contract application. Additionally, this is going to be the first lesson that we work with a Chainlink oracle to empower our smart contract to be a hybrid smart contract. This way, our smart contract actually knows things about the real world, empowering it to have even more features.
00:00:53.510 - 00:01:27.074, Speaker A: We'll also learn how to import packages from NPM, import other people's code into our code base so we don't always have to start from scratch. We'll learn about the Chainlink data feeds and how these data feeds are one of the most important pieces in Defi and how we can use it to make our applications some of the most important applications in DFI. We'll learn a lot more low level solidity pieces, including Safemath, which we're actually not going to use because in version zero eight of solidity and on, it's built in. So with that, best of luck and looking forward to seeing you on the other side of this lesson.
00:01:27.122 - 00:02:06.550, Speaker B: The GitHub repository associated with this course also has all the code for this lesson. So let's jump into it. So we're back in remix now and we're going to go to contracts and same as before, we're going to create a new file. We're going to call this fundme Sol now, same as last time, we're actually going to add this SPDX license identifier MIT right at the top and then we're going to choose our solidity version. So we're going to go pragma solidity and for this we're just going to do greater than or equals to 0.6.6 and less than 0.9.0 and great.
00:02:06.700 - 00:02:08.630, Speaker C: This should look pretty familiar.
00:02:08.970 - 00:02:47.698, Speaker B: Now we're going to do contract fund me and we're going to get start working. So what again do we want this contract to do? We want this contract to be able to accept some type of payment. So let's create a new function that can accept payment. We'll call it fund. So we'll do function fund public? And we'll add a new keyword in here called payable. When we define a function as payable, we're saying hey, this function can be used to pay for things. When you call a function, every single function call has an associated value with it.
00:02:47.698 - 00:03:32.746, Speaker B: Whenever you make a transaction, you can always append a value. This value is how much wei or gwe or Finney or ether you're going to send with your function call or your transaction. As we mentioned before, way, Gui and ether are just different ways to talk about how much ether you're going to send. So if we look at away to Ethereum converter, one eth is this much way. One way is the smallest denomination of ether. You can't break up Ethereum into anything smaller than one way. This is why when you're talking about how much something costs, everything always defaults to way or the smallest unit of measure in Ethereum.
00:03:32.746 - 00:04:13.982, Speaker B: So again, for us to test, we're going to stick with the Javascript VM for now. If we hit deploy, we get a new contract and this button is now red. It's red because it is a payable function. So now if I hit this fund button, I can add a value associated with it. So what do we want to do with this funding? What do we want to do when people send us something? Well, let's keep track of who sent us some funding. So what we can do is we can create a new mapping between addresses and value. So let's do a mapping of address to un 256, which will represent the value.
00:04:13.982 - 00:05:02.940, Speaker B: We'll make this a public mapping and we'll call it address to amount funded. Now in this fund function, let's keep track of all the people who sent us money or all the addresses that sent us some value. To do this we can use some keywords that go along with every transaction. So we'll say address to amount funded of message sender equals or plus equals message value. Message sender and message value are keywords in every contract, call and every transaction. Message sender is the sender of the function. Call and message value is how much they sent.
00:05:02.940 - 00:05:50.686, Speaker B: So whenever we call funddow, somebody can send some value because it's payable. And we're going to save everything in this address to amount funded mapping. So if we deploy this now in our Javascript Vm, we now have again a new view function called address to amount funded, and we can even hit the drop down to see the full name. Now if I hit fund, nothing's going to happen right, because my address is going to be sending zero. In order for me to send something, I have to add some value along with my transaction. So let's send, for example, one guay, which is going to be equal to 112-345-6789 this much way. So before I hit fund here, if I copy this fake account which is.
00:05:50.708 - 00:05:53.246, Speaker C: Up here, and I put it in.
00:05:53.268 - 00:06:46.474, Speaker B: This address to amount funded, it's going to return zero. But now if I add 112-345-6789 in here and we go ahead and hit fund now, we've now just called this fund function with a value of one guay associated with it. So if I call this address to amount funded now with the same address, I can now see how much we've funded this smart contract, and we can even add more guay. We'll add eleven gwe, for example, we'll call fund. And if we call this now, we can see that even more has been added when we send our funds to a contract. This actually means that this contract, wherever this is deployed now, is the owner of this amount of ether. So this is fantastic.
00:06:46.474 - 00:07:14.882, Speaker B: We now have a way to fund our smart contracts. Now here's the thing. In this smart contract, in this funding that we're doing, we want to create a minimum value for people to be able to fund our endeavors, which, whatever they may be, we want to set some minimum value here. And ether is great, but for whatever reason, we want to work in USD or maybe we want to work in some other token. So how are we going to get the conversion rate from that currency to a currency that we can use in this smart contract?
00:07:15.026 - 00:07:24.940, Speaker C: Well, the first thing that we're going to need to do to set this value is we're going to need to know what the ETH to USD conversion rate is.
00:07:25.390 - 00:07:28.390, Speaker D: Because if I want to accept Ethereum.
00:07:28.470 - 00:08:21.098, Speaker C: As the token, but I want it in its USD currency, well then I'm going to need to know what that conversion rate is. So how are we going to get this data into our smart contract? Where are we going to get this data from? Now, remember how we talked about blockchains being deterministic systems and oracles being the bridge between blockchains and the real world? Well, this is exactly where oracles come in when we're talking about these systems, these blockchains, they can't connect to real world events, they can't connect to external systems, they can't do external computation. They're intentionally these deterministic systems, these walled gardens. So in order for us to make this connection. We need a blockchain, oracle, we need some type of network here. Now, just to get a little bit more technical for you, if we look at a blockchain, a blockchain can easily say one plus one equals two and every other node can easily verify this.
00:08:21.264 - 00:08:24.862, Speaker D: However, a blockchain can't easily say okay.
00:08:24.916 - 00:08:53.814, Speaker C: Let'S all grab the same random number because each node is going to get a different random number. They also can't say, hey, let's make an API call, because if one node calls the API at a different time, another node calls it, or specifically like an HTTP get there could potentially get very, very different results. And if another node tries to replay these transactions by calling these APIs again, maybe ten years in the future, there's a good chance that that API is.
00:08:53.852 - 00:08:56.566, Speaker D: Going to be depreciated and they could.
00:08:56.588 - 00:09:38.994, Speaker C: Be hacked, they could be malicious, et cetera, et cetera. The other reason that blockchains intentionally can't make API calls is because then they would be making assumptions about the real world, and layer ones typically don't want to have an opinion on any political or geopolitical issue, whereas an oracle network, on the other hand, can make those assumptions. The other main thing we need to talk about here is centralized oracles being main points of failures. If you or I say, hey, I'm just going to be the oracle, I'm going to be the one to put this data on chain. We now have this massive centralized point of failure. We've done all this work to make our decentralized computation decentralized and on chain, but we ruin all the decentrality by having a single point of failure.
00:09:39.122 - 00:09:40.918, Speaker D: Remember, one of the whole purposes of.
00:09:40.924 - 00:10:21.666, Speaker C: Blockchain is so that not a single entity can flip a switch and restrict our freedom to interact with a centralized oracle. A single entity can flip a switch and restrict our freedom to interact with each other. We also need to get data from many different decentralized sources or do any type of computation in a decentralized manner. This is where chainlink really shines. Chainlink is a modular, decentralized oracle infrastructure and oracle network that allows us to get data and do external computation in a highly civil resistant, decentralized manner. It can be as customizable as you want, as you can run with one node or many nodes, or do as.
00:10:21.688 - 00:10:23.220, Speaker D: Many nodes as you like.
00:10:23.670 - 00:10:29.922, Speaker C: Now, currently one of the most popular features of chainlink is their data feeds or their price feeds.
00:10:30.066 - 00:10:33.960, Speaker D: We can even go check them out over at data.
00:10:35.770 - 00:11:01.390, Speaker C: Chain link. We can see a number of different price feeds and the networks that are providing the prices for these specific pricing points. We can see here by looking at the UI, there is a whole number of decentralized different oracles returning data for different price feeds. This one, for example is FUSD, and it's also exactly the price feed that we're looking for. Having a decentralized network bring this data.
00:11:01.460 - 00:11:03.658, Speaker D: On chain and have it as a.
00:11:03.684 - 00:11:51.326, Speaker C: Reference point of definitive truth allows users to all collaborate and use this common good, and it will be cheaper, more secure, more efficient than anybody even running their own centralized oracle. So these price feeds are incredibly powerful. Additionally, they're being used by some of the top protocols in the DFI system right now, like synthetics, which at the time of recording is securing around $2 billion sushi swap for leveraging trades, set protocol, commodity money ave for understanding the price of an underlying collateral. Now this is an example of an out of the box decentralized solution that's already been packaged in a decentralized manner for you to consume and for you to use. This makes going to production a thousand times easier than building everything yourself.
00:11:51.508 - 00:11:53.866, Speaker D: However, if you want to make API.
00:11:53.898 - 00:12:23.098, Speaker C: Calls and build your own decentralized network, you absolutely can with the Chainlink API calls. We're not going to go into that here because using the Chainlink price feeds, Chainlink VRF keeper network and all these other pre boxed decentralized services are going to make going live and going mainnet a lot easier. You can always make a chainlink HTTP get call as well. We're not going to go over this though, because putting this into production is a little bit trickier. And working with Chainlink VRF, if you ever want to try them out by themselves, you can always head over to.
00:12:23.104 - 00:12:25.770, Speaker D: Docs chain link and head over to.
00:12:25.840 - 00:13:01.202, Speaker C: Get the latest price feed. There's usually a remix button actually that we can click and it will kick us out to a remix edition with all the code already ready to go for us. If we just hit this gist right here, this will include all of our code, which we'll go into in a second, but let's go ahead and compile it. We're going to deploy it to a real network here. This one looks like it's actually for coven, so we're going to go ahead and switch to coven. Looks like I don't have any coven Ethereum, so we're going to grab a coven faucet. We can usually find different faucets in the Chainlink documentation.
00:13:01.346 - 00:13:07.446, Speaker D: Let's look up coven here. Aha. There is a coven faucet here. It looks like in order for us.
00:13:07.468 - 00:13:14.458, Speaker C: To get some coven Ethereum here, we have to log in with GitHub. Then we can add our address in here and get the ethereum. In the interest of time, I'm going.
00:13:14.464 - 00:13:17.674, Speaker D: To skip ahead from me doing that. Great.
00:13:17.712 - 00:13:31.920, Speaker C: It looks like I've got some coven testnet. Now, being able to switch between testnets is going to make you a lot more effective as an engineer as well, because you're going to be able to understand how each network actually works. So now we've compiled this, let's deploy this.
00:13:33.810 - 00:13:37.934, Speaker D: Again. Metamask is going to pop up and.
00:13:37.972 - 00:13:44.766, Speaker C: Let'S go ahead and click the get the latest price, and we can see that this function does indeed return the latest price of ethereum.
00:13:44.958 - 00:13:46.946, Speaker D: Now you might be asking, why does.
00:13:46.968 - 00:13:51.986, Speaker C: This number look so big? Well, remember how we talked about Wei and Gui and ether?
00:13:52.178 - 00:13:53.926, Speaker D: Well, the reason that those exist is.
00:13:53.948 - 00:14:40.166, Speaker C: Because decimals don't work in solidity. So we actually have to return a value that's multiplied by ten to some number. So this value is actually 2614 times ten raised to the 8th. Now, the next question you might ask is, well, why did we work with this on a testnet? Why couldn't we do this on a local network? And the answer to this is because there is a network of nodes looking at this testnet and delivering data onto this testnet. When you spin up a local network or do a simulated vm, there are no nodes actually doing that. We'll learn later how to actually mock these interactions and mock a chainlink node returning data onto our blockchain. But for now, let's head back over to the contract that we're working on so we can learn how to implement this in any contract that we ever want to.
00:14:40.166 - 00:15:18.578, Speaker C: Another contract called, in this case called price feed, has a function called latest round data which returns a lot of data. It returns a round id which defines how many times this price feed has been updated. It returns a price which is the actual conversion rate between the two assets. It returns a started at which defines when this was last updated. It returns a timestamp and it returns an answered in round. Don't worry about answered in round for now. If you want to dive a little bit deeper into what these rounds mean and what answered in round means, you can definitely check out the Chainlink documentation and some of the faqs to learn more.
00:15:18.578 - 00:15:27.446, Speaker C: Now, how do we implement this data feed into our fundme application? Well, the first thing we're actually going to need to do is we're going to need to import the chainlink code.
00:15:27.628 - 00:15:29.958, Speaker D: So we're going to do import at.
00:15:30.044 - 00:15:39.110, Speaker C: Chainlinkcontractsourcev zero point sixintervaces.
00:15:41.050 - 00:15:47.400, Speaker D: Aggregator v threeintervace sol.
00:15:49.530 - 00:16:18.790, Speaker C: Now let's talk about what this is actually doing. Oops, looks like I spelled aggregator v three interface wrong. All right, great, now it's actually compiling. So let's talk about what imports actually do. As we know, an import will take whatever code you're importing and stick it at the top of your project. So when we import from at Chainlink contracts, we're actually importing from the at Chainlink contracts NpM package. We can look up at chainlink contracts.
00:16:19.850 - 00:16:24.214, Speaker D: In NPM and we can see and.
00:16:24.252 - 00:16:26.710, Speaker C: Read more about this repository.
00:16:28.090 - 00:16:30.082, Speaker D: This links us back to the GitHub.
00:16:30.146 - 00:16:43.034, Speaker C: Which will tell us a little bit more about what's really going on. If we follow that import path that we got from the documentation, we'll end up on this file in front of me now we have what's called an interface. You can see these contracts don't start.
00:16:43.072 - 00:16:46.986, Speaker D: With the contract keyword, but they start with the interface keyword.
00:16:47.098 - 00:16:50.622, Speaker C: They have the exact same pragma solidity at the top, but the main difference.
00:16:50.676 - 00:16:53.022, Speaker D: Is that you can see that their.
00:16:53.076 - 00:16:59.026, Speaker C: Functions aren't completed, they just have the function name and its return type.
00:16:59.208 - 00:17:00.466, Speaker D: Now, just to be a little bit.
00:17:00.488 - 00:17:24.902, Speaker C: More explicit here, I'm actually going to go ahead and delete this import statement at the top and replace it with that interface code from GitHub just to show you exactly what's going on. However, if you've already typed that at import syntax, feel free to leave it in there and just remember that it's going to be the exact same as me copy pasting the interface code in, in our code here, solidity doesn't natively understand how to interact with another contract.
00:17:25.046 - 00:17:27.894, Speaker D: We have to tell solidity what functions.
00:17:27.942 - 00:17:39.600, Speaker C: Can be called on another contract. This is where interfaces are actually going to come in, similar to structs. What we can do with interfaces define a new type. So if we copy all this code.
00:17:40.130 - 00:17:47.554, Speaker D: From this section and place it at the top of our code here above where we're declaring a contract, we can.
00:17:47.592 - 00:18:23.824, Speaker C: Actually then interact with contracts that have these functions. If we go ahead and even compile this, we can see that this does indeed compile correctly. Remember how we said before we talked a little bit about abis? Well, interfaces actually compile down to what's called the ABI or the application binary interface the application binary interface tells solidity what functions can be called on another contract. We need solidity to know what functions it can use and what functions it can call other contracts with.
00:18:23.942 - 00:18:25.076, Speaker D: And if that was a little bit.
00:18:25.098 - 00:18:55.976, Speaker C: Confusing, just know anytime you're going to interact with another contract in solidity or smart contract programming in general, you're going to need that contract's ABI. We'll go into what these abis look like a little bit later. Anyways, to simplify it. Interface compiles down to an ABI. We always need an ABI to interact with a contract. So how do we actually work with this contract here? To interact with an interface contract, it's going to work the exact same way as interacting with a struct or a variable. Let's define a new function called get version.
00:18:55.976 - 00:18:57.912, Speaker C: And we're going to call this version.
00:18:57.976 - 00:19:07.090, Speaker D: Function on this other contract. So we'll start out doing function get version public.
00:19:07.540 - 00:19:17.940, Speaker C: Remember, it needs to be a view since we're just going to be reading this state. And even in the interface, it even defines it as a view returns.
00:19:18.280 - 00:19:22.484, Speaker D: So we'll even grab this whole bit right here.
00:19:22.682 - 00:19:45.852, Speaker C: View returns un 256. Now the exact same way we define variables and structs, we define working with other contracts and interfaces. So the first thing is we name the type, which in this case is aggregator v three interface. Then we'd name the visibility. But since again we're inside of this contract, we're going to skip it. Then let's give it a name.
00:19:45.986 - 00:19:48.104, Speaker D: We'll call it price feed.
00:19:48.152 - 00:19:51.484, Speaker C: Since this aggregator v three interface is going to be giving us a price.
00:19:51.522 - 00:19:53.492, Speaker D: Feed, then we can do equals.
00:19:53.576 - 00:20:23.530, Speaker C: And this is where we're going to initialize the contract. So how do we actually choose where to interact with this contract? Well, we just type aggregated v three interface and then we put in here the address of where this contract is located. In order to find where this FUSD price feed contract is located on the Rinkbeat chain, we can look at the Ethereum price feeds chainlink documentation. It has a ton of different price feeds and even more, not price related data.
00:20:24.380 - 00:20:28.236, Speaker D: Let's scroll down to Rinkbeat because again.
00:20:28.418 - 00:20:33.724, Speaker C: On each different chain, the contract address that has all this price feed information.
00:20:33.842 - 00:20:41.250, Speaker D: Is going to be different. Let's scroll down and find FuSD, which is right here, and we'll copy it.
00:20:41.780 - 00:20:43.890, Speaker C: And we'll paste it into here.
00:20:45.060 - 00:20:47.136, Speaker D: Now what is this line saying?
00:20:47.318 - 00:20:58.036, Speaker C: It's saying that we have a contract that has these functions defined in the interface located at this address. If that's true, then we should be.
00:20:58.058 - 00:21:06.146, Speaker D: Able to call price feed version and.
00:21:06.168 - 00:21:10.040, Speaker C: We should be able to return it. Whoops, looks like we forgot to add.
00:21:10.970 - 00:21:14.200, Speaker D: Those here and we need a semicolon here.
00:21:14.650 - 00:21:19.894, Speaker C: Hit Ctrl s or command s compiles. It looks like we're compiling successfully and.
00:21:19.932 - 00:21:23.286, Speaker D: We do need to deploy this on a testnet.
00:21:23.478 - 00:21:49.746, Speaker C: Remember this address here is located on an actual testnet. It's located on an actual network. It's not going to be located on our simulated chain here. So we do need to deploy this to injected web three. We do need to deploy our contract to rinkby because the rinkby chain has this address. We'll learn later on how we actually can work with a simulated chain and work with these price feeds. But that's much later in this course.
00:21:49.848 - 00:21:52.078, Speaker D: So let's go ahead and save, we'll.
00:21:52.094 - 00:21:55.570, Speaker C: Deploy, make sure we're on injected web three.
00:21:55.720 - 00:21:57.670, Speaker D: Now we can go ahead and hit deploy.
00:21:58.410 - 00:22:07.670, Speaker C: Metamask is going to pop up per usual. Confirm we're going to get a transaction link to Etherscan showing us our contract.
00:22:09.050 - 00:22:11.126, Speaker D: And once it actually is confirmed we.
00:22:11.148 - 00:22:42.798, Speaker C: Can see we have our contract right here. Now we have our familiar functions with one additional function. We have our fund button which is red because it's payable. We have our address to amount funded mapping which is blue because it's a view. And we also have this get version button that's also blue. If we go ahead and click it we can see that the version of our aggregator v three interface is version three. This is the third version of the aggregator interfaces, hence the name aggregator v three interface.
00:22:42.798 - 00:23:02.970, Speaker C: So we just made a contract call to another contract from our contract using an interface. This is why interfaces are so powerful, because they're a minimalistic view into another contract. So this is great. We have a get version function but this still isn't the function that we want. We want to call the get price.
00:23:03.040 - 00:23:05.306, Speaker D: Function which if we look at our.
00:23:05.328 - 00:23:21.534, Speaker C: Interface we can see there is a latest round data function that returns an answer. This is the function that we're going to want to call on this contract. So let's go ahead and make a function that calls that instead. So we're going to do function get.
00:23:21.572 - 00:23:31.246, Speaker D: Price public view returns uint 256 Uhoh.
00:23:31.438 - 00:23:35.598, Speaker C: This latest round data function though returns five variables.
00:23:35.694 - 00:23:37.314, Speaker D: So how do we actually work with that?
00:23:37.432 - 00:23:45.558, Speaker C: Well, let's find out. To work with this contract we're going to do the exact same thing. We're going to do aggregator v three interface because this is the type of.
00:23:45.564 - 00:23:49.510, Speaker D: The contract price feed equals.
00:23:51.230 - 00:23:57.580, Speaker C: Aggregator v three interface. We'll do this same address in here because this is the FUsd address.
00:23:58.430 - 00:24:03.600, Speaker D: Then we'll do price feed latest round data.
00:24:05.010 - 00:24:14.518, Speaker C: Now since this is going to return five different values, we can actually have our contract also return these five different values.
00:24:14.714 - 00:24:19.700, Speaker D: We can copy paste like this and literally do this.
00:24:20.150 - 00:24:23.006, Speaker C: These five values equal price feed latest.
00:24:23.038 - 00:24:27.278, Speaker D: Round data and you can see that even compiles correctly.
00:24:27.374 - 00:24:47.562, Speaker C: Let's adjust the formatting a little bit here so it looks a little bit nicer. A tuple is a list of objects of potentially different types. This is the syntax for getting a tuple. We can define several variables inside one of these tuples. Although our compiler is going to give us some warnings. It's saying unused local variable because we're not actually using these for anything. We'll come back to this.
00:24:47.562 - 00:24:49.290, Speaker C: Now we can go ahead and do.
00:24:49.360 - 00:24:51.338, Speaker D: Return and we can pick one of.
00:24:51.344 - 00:25:19.074, Speaker C: These variables that we want to return. Answer is going to be the price. So we're going to do return answer, but uhoh, we're going to run into an error return type argument. Int 256 is not implicitly convertible to expected type. Answer is an int 256 and we want to return a uint 256. So how do we rectify this? We can fix this by using what's called typecasting. If we just return answer, we're going to be returning the wrong type.
00:25:19.074 - 00:25:38.906, Speaker C: However, integers and solidity are really easy to cast into each other. So we can just do un 256 and wrap it around this answer and then compile and save that instead. As you can see now, our compiler is happy because we've changed this answer into a unit 256.
00:25:39.088 - 00:25:39.818, Speaker D: Awesome.
00:25:39.984 - 00:26:03.220, Speaker C: So now this get price should return the latest price of Ethereum in terms of USD. Let's go ahead and deploy this new contract with this new function. So same thing. We're going to come to our deploy section, hit the deploy button up. Remember we got to go to the fundament Sol, let's deploy it. Confirm with metamask here.
00:26:05.030 - 00:26:05.934, Speaker D: And let's scroll.
00:26:05.982 - 00:26:43.822, Speaker C: Down to our newly deployed contract. As you can see, we have our get version function, which still works exactly the same, but we have a new function too called get price. And this should return a UN 256 answer. Let's go ahead and click it. Amazing, we've actually returned an answer. Now again, if you're a little confused on why this number looks so big, you have to remember that this actually has eight decimals. We could call this decimals function on the contract to learn that 1234-5678 and we know that the current price of Ethereum in terms of USD is 2482.
00:26:43.956 - 00:26:44.350, Speaker D: Awesome.
00:26:44.420 - 00:27:51.480, Speaker C: So now that we have the price we can actually get the conversion rate. But let's clean up this function a little bit before we go on up there. As you can see, one thing that the compiler is complaining about is we have a lot of unused local variables but latest round data returns five different variables. So how do we actually return the five variables but make our compiler happy with us? Well we can actually just return blanks for each one of these sections with commas in between each other to say hey, there is a variable here but we're not going to use it. This will also make our code look a lot cleaner because now this function is a lot smaller. We say something's here, we're ignoring it in 256 answer we're going to use something's here, ignore it, something here, ignore it and ignore this too. And we can even test this out by compiling it, deploying it, checking on rink b, scrolling down, hitting this and hitting get price and you can see indeed it's the exact same as before.
00:27:51.480 - 00:28:38.002, Speaker C: Awesome. So now we're all done cleaning things up, right? Not quite yet. See the other thing that's really annoying here we have this massive chunk of code at the top that is probably a little redundant. There's a good chance that a lot of our contracts are going to want to use this aggregator v three interface. So let's just go ahead and add that at chainlink contract syntax back in because it's going to look a lot cleaner here and do at chainlinkcontracts if you ever get a little bit confused with what you should be importing to work with their contracts, we can see right in the documentation at the top. This at syntax is what this is going to use. Now you can also go ahead and browse that NPM package of at chainlink contracts to see what other applications are in there and what other files are in there.
00:28:38.002 - 00:29:07.578, Speaker C: Or you can just peruse around the GitHub. Now the third way we can actually do imports is we can import from contracts that are in the same file system as our contracts. Well awesome. Our contract is starting to look more and more put together. Now one other thing that I usually like to do with these is I usually like to put everything into the guay way standard. So as we saw this get price had eight decimal places. However the smallest unit of measure aka.
00:29:07.674 - 00:29:10.366, Speaker D: Way if we look at it has.
00:29:10.468 - 00:29:25.998, Speaker C: 18 1234-5678 910 1234-5678 so typically in these I like to try to make everything have 18 decimals as well. You don't have to do this and it'll save some gas if you don't.
00:29:26.094 - 00:29:28.370, Speaker D: But I usually like to multiply everything.
00:29:28.440 - 00:29:39.206, Speaker C: So that everything has 18 decimal places. So since I know this has eight, I can just do 1234-5678 910. And now this will return the price.
00:29:39.308 - 00:29:41.946, Speaker D: With 18 decimal places instead of ten.
00:29:42.048 - 00:29:51.770, Speaker C: Now we have the price of Ethereum in us dollar, which is fantastic. So we could set the price of our funding function to anything that we want here.
00:29:51.920 - 00:29:54.366, Speaker D: For example, let's say $50.
00:29:54.468 - 00:30:03.760, Speaker C: We could convert whatever value that they send us to its us dollar equivalent and see if it's greater than or less than $50.
00:30:04.150 - 00:30:10.002, Speaker D: All we have to do is make a new function that converts that value.
00:30:10.056 - 00:30:12.734, Speaker C: That they send to its US dollar equivalent.
00:30:12.782 - 00:30:17.502, Speaker D: So we could do function, get conversion.
00:30:17.566 - 00:30:22.518, Speaker C: Rate, and it'll take a unit 256 f amount.
00:30:22.684 - 00:30:24.006, Speaker D: Let's get this out of the way.
00:30:24.028 - 00:30:34.366, Speaker C: For the rest of this it'll be a public view function since again, we're not actually going to have it make any state change. We'll do returns un 256.
00:30:34.368 - 00:30:37.898, Speaker D: And then in this function we can.
00:30:37.904 - 00:30:47.774, Speaker C: Do un 256 f price equals get price. And we can call this get price function up here.
00:30:47.972 - 00:30:51.598, Speaker D: Now we have the price in here. What we want to do is we.
00:30:51.604 - 00:30:53.374, Speaker C: Want to convert whatever value that they.
00:30:53.412 - 00:31:06.210, Speaker D: Send as f amount. Let's say they send one guay or again, that's going to be this much way. How do we convert this to Fusd?
00:31:06.570 - 00:31:15.974, Speaker C: Well, we can now do un 256 f amount in USD equals this f.
00:31:16.012 - 00:31:18.200, Speaker D: Price times.
00:31:20.090 - 00:31:36.766, Speaker C: The eth amount that they sent. This is actually going to result in a much bigger number than we're looking for. And then of course we're going to return it. Let's test this out and see why we have to do one more thing here. So let's again fund me.
00:31:36.868 - 00:31:45.310, Speaker D: We'll deploy rank b and we'll scroll down and we have this new function called get conversion rate.
00:31:45.380 - 00:32:00.040, Speaker C: Let's grab this one guay and put it in here. Whoa, this seems like it's a really big number. We're saying that one guay is equal to 1234-5678-1234-5678-9 ten.
00:32:01.050 - 00:32:02.440, Speaker D: This many dollars.
00:32:03.610 - 00:32:13.466, Speaker C: Now, I don't know about you, but I don't think the price of even one ethereum is that many dollars. Maybe in the distant future, but definitely not right now. The reason that it's off is we.
00:32:13.488 - 00:32:16.730, Speaker D: Have to then actually divide by this number.
00:32:16.800 - 00:32:20.314, Speaker C: The reason that we have to do this is because both f price and.
00:32:20.352 - 00:32:24.666, Speaker D: F amount have an additional ten raised.
00:32:24.698 - 00:32:26.526, Speaker C: To the 18th tacked onto them.
00:32:26.628 - 00:32:27.886, Speaker D: So now we have to divide it.
00:32:27.908 - 00:32:29.440, Speaker C: Out in order to get the right number.
00:32:30.130 - 00:32:39.454, Speaker D: So we're going to compile, compile, deploy, confirm, we can scroll down.
00:32:39.652 - 00:33:04.186, Speaker C: And now let's try this one way. We'll get the conversion right here. And we can see we get a number that makes a little bit more sense. Now remember, this has 18 decimals as well. So the real number is 1234-5678-1234-5678-9 ten. And we know that this number is actually accurate because we can go ahead.
00:33:04.208 - 00:33:07.146, Speaker D: And pull up a calculator, pop that.
00:33:07.168 - 00:33:11.798, Speaker C: Into here, and we know that this is one guay in us dollar.
00:33:11.974 - 00:33:14.578, Speaker D: If we get the conversion rate, we're.
00:33:14.614 - 00:33:17.882, Speaker C: Saying that this many guay equals one eth.
00:33:18.026 - 00:33:19.534, Speaker D: So we can check it back by.
00:33:19.572 - 00:33:29.874, Speaker C: Multiplying this number by that. And we see that we do actually get the price of one ethereum in us dollar. So our math here checks out.
00:33:30.072 - 00:33:30.626, Speaker D: Awesome.
00:33:30.728 - 00:33:59.100, Speaker C: Now, since we're on the topic of math, I do want to talk briefly about some of the pitfalls of solidity, especially when it comes to math. Prior to solidity 0.8, if you added to the maximum size a un number could be, it would actually wrap around to the lowest number that it would be. And in fact you can even demo this with a contract here. Now you don't have to follow along with this contract, but just watch to see the example. We're going to call this overflow Sol.
00:33:59.710 - 00:34:01.258, Speaker D: Now in here we're going to add.
00:34:01.344 - 00:34:10.714, Speaker C: All kind of the normal stuff, contract overflow. And we're going to add a function called overflow.
00:34:10.762 - 00:34:13.338, Speaker D: We'll make a public view and we'll.
00:34:13.354 - 00:34:48.502, Speaker C: Have it return a uint eight. I'll show you why in just a minute. A Uint 256 is a really, really big number, and it's hard to kind of imagine going over the maximum cap of a Uint 256. But a uint eight is a lot smaller, with the maximum number actually being 255. So if we create a uint eight and we call it big equals 255, and then we just do return big, what do we think we're going to get here for this? We can go ahead and use Javascript VM because we're not interacting with any other contracts.
00:34:48.646 - 00:34:52.070, Speaker D: Let's deploy this and we'll see in our contract.
00:34:52.150 - 00:35:26.486, Speaker C: If we call overflow now we're just going to get 255. However, what happens if we add one to this number, or try to add one to this number. If we do it just like this, solidity actually knows that there's an issue here and says, hey, try not to do this. But if we typecast this as a uint eight, solidity gets a little bit more confused and goes ahead and lets us do this. Now, what do we think big is going to be? It should be 256, right? But big is a uint eight, and this is the maximum size that it could be. So what happens when we deploy this?
00:35:26.668 - 00:35:30.300, Speaker D: We look down, we actually get zero.
00:35:30.750 - 00:36:05.180, Speaker C: What happens if we do 100 and we deploy that? We actually get 99. And this is because integers can actually wrap around. Once you reach their maximum cap, they basically reset. This is something we need to watch out for when working with solidity. If we're doing multiplication on really big numbers, we can accidentally pass this cap. Luckily, as of version zero eight of solidity, it actually checks for overflow. And it defaults to check for overflow to increase readability of code.
00:36:05.180 - 00:36:32.144, Speaker C: Even if that, it comes a slight increase of gas costs. You can use this unchecked if you want to have it. Keep that wrapping functionality. So just be aware, if you're using a lower version than 0.8, you're going to have to do something to make up for this. And we could write a whole bunch of code here basically to check all of our math. Or we could just import something called safemath from another package, similar to how we imported chainlink.
00:36:32.144 - 00:37:14.216, Speaker C: We can go ahead and import a package called safemath from a tool called Openzeppelin. Now, Openzeppelin is an open source tool that allows us to use a lot of already pre built contracts. We can go ahead to their documentation and go to their utilities and see Safemath. And they even have a little sticker here saying Safemath is no longer needed. Started with solidity 0.8. SafeMath is a tool and a way for us to avoid some of these problems with doing math and solidity. Now, I'm not going to spend too much time on the contracts that actually fix this, but we can actually import right from the Chainlink directory as well, a solidity file called SafeMath Chainlink.
00:37:14.216 - 00:37:41.436, Speaker C: And what we can do is right after our contract, we can do using safe math chainlink for UN 256. And what this will do is it'll use safe math chain link for all of our UN 256 and SafeMath Chainlink doesn't allow for that overflow to occur. Libraries are really similar to contracts, except that they're isolated code that can be.
00:37:41.458 - 00:37:43.260, Speaker D: Run in a reusable context.
00:37:47.480 - 00:38:24.352, Speaker C: In this case, we're attaching the safe math Chainlink library to un 256 so that these overflows are automatically checked for. Just keep in mind, if you're using anything less than 0.8, you're going to want to use some type of safe math just to check for your overflows. Now this is for those of you who are familiar with safe math and integer overflows and underflows, we are not going to be calling the functions that SafeMath provides us, like div add, mole all those functions, simply because in 0.8 moving forward, we no longer have to use those, and we can just use our regular operators like plus and minus. So this is great. Our contract is coming along really well.
00:38:24.352 - 00:39:01.420, Speaker C: We now have a way to get the conversion rate of whatever f is sent and turn it into uS dollar. Now we can set a threshold in terms of Us dollar, but how do we guarantee that whatever amount that the users send when they call fund is going to be at least $50? Well, first, we might want to set a minimum value so we can do un 256. Minimum USD equals, let's say $50. And again, since we're using everything in gui terms, we want to then multiply this by ten raised to the 18th.
00:39:01.760 - 00:39:03.208, Speaker D: And just wanted to take a pause.
00:39:03.224 - 00:39:21.620, Speaker C: For a second because this line is actually wrong. This should be raised to the 18th. So this line should really look like this, where it has the double star. So apologies. The rest of this has that single star, but it should be the double star here. If you do have the single star, though, the rest of the contract will still work fine. So this will be the minimum value.
00:39:21.620 - 00:40:24.064, Speaker C: It'll be $50 times ten raised to the 18th so that everything has 18 decimals. Now that we have a minimum amount, how do we actually make sure that this minimum amount is met in the value that they send us? Well, if you're familiar with if statements, we could do something like if message value is less than minimum USD, then revert. Or we could do something a lot easier and better practice, and much cleaner. We could do what's called a require statement. When a function call reaches a require statement, it'll check the truthiness of whatever require you've asked. So in our case, the converted rate of message value needs to be greater than or equal to our minimum USD. This line says that if the conversion rate of message value to USD, if they didn't send us enough ether, then we are going to stop executing.
00:40:24.064 - 00:40:46.940, Speaker C: We're going to kick it out. We're going to say, hey, this doesn't count. And we're going to do what's called a revert. We're going to revert the transaction. This means that the user is going to get their money back as well as any unspent gas. And this is highly recommended. We can also then additionally add a revert error message, something like, you need to spend more eth.
00:40:46.940 - 00:41:14.308, Speaker C: So now let's try this out. As we saw, one guay is going to be way less than $50. So if we send one guay along with this fund contract call, it should kick out and say you need to spend more eth. So let's actually try this. Let's go to the deploy tab. We'll get rid of our overflow. We use injected web three because again, we are working with the chainlink aggregator contracts that are on chain.
00:41:14.308 - 00:41:38.156, Speaker C: We're going to move to fund me and we're going to hit deploy. Metamask is going to pop up and we're going to hit confirm. Now if I try to hit fund, let's see what happens. We're getting a gas estimation failed. Says gas estimation error failed with the following message. Execution reverted. You need to spend more eth.
00:41:38.156 - 00:41:49.810, Speaker C: So the contract isn't even letting us make the transaction. We can go ahead and try to send the transaction, but here's what's going to happen on Etherscan. Once this goes through.
00:41:51.720 - 00:41:53.424, Speaker D: You can see that once this transaction.
00:41:53.472 - 00:42:33.600, Speaker C: Finished, we got this status fail with error. You need to spend more eth. We don't want to force these transactions to go through. If we look in our metamask, we can even see this failed bit here. So whenever you see these gas estimation failed errors, usually that means something reverted or you didn't do something that was required. However, if we go to value here and we spend a lot more, let's say zero one ether, which if we take out our calculator 2500 times, zero one is going to be $250. This should easily be well and beyond past our $50 threshold.
00:42:33.600 - 00:42:57.800, Speaker C: So let's add zero one ether. And remember, we got zero one by adding it in the converter and grabbing the way. Again, the way is the smallest denomination. Now if we change this to way and hit fund, this should go through. We go and hit fund. Now you'll see metamask pops up because metamask goes, oh yeah, this transaction isn't going to revert and that's what we want. So we can go ahead and hit confirm.
00:42:57.800 - 00:43:34.244, Speaker C: And now we'll finally have sent some funding to our contract. And now that this is confirmed, we can go ahead and grab our address here, pop it into our address to amount, and we can see that indeed our funding has gone through. Now we can be part of this crowdsourcing application with our minimum value, which is fantastic. Awesome, great job. Awesome. So now we can fund this contract with a certain minimum USD value. In this case, it's going to be $50.
00:43:34.244 - 00:44:04.792, Speaker C: Now, you'll notice though, that right now we don't do anything with this money. So we're going to fund this contract, however, that's it. And we don't have a function in here to actually withdraw the money. So there's no way that even though we just sent this contract some money, there's no way for us to get it back. So how do we fix this? Well, we can add a withdraw function in here. So let's go ahead and add that function, withdraw. And this is also going to be a payable function because we're going to be transferring eth.
00:44:04.792 - 00:44:40.920, Speaker C: We'll make this public and we can do message sender. Transfer is a function that we can call on any address to send eth from one address to another. This transfer function sends some amount of ethereum to whoever it's being called on. In this case, we're transferring ethereum to message sender. So all we need to do now is define how much we want to send. Well, we're going to send all the money that's been funded. So to get all the money that's been funded in this contract, we can do address this balance.
00:44:40.920 - 00:45:19.972, Speaker C: Now, there's a couple of special things going on with this line. First, we're saying address of this. This is a keyword in solidity. Whenever you refer to this, you're talking about the contract that you're currently in. And when we add address of this, we're saying we want the address of the contract that we're currently in. Whenever you call an address and then the balance attribute, you can see the balance in ether of a contract. So with this line, we're saying whoever called the withdraw function, because whoever calls the function is going to be the message sender, transfer them all of our money.
00:45:19.972 - 00:45:21.300, Speaker C: So let's go ahead and try this.
00:45:21.370 - 00:45:25.764, Speaker D: Let's deploy fund me, and now let's.
00:45:25.812 - 00:46:05.030, Speaker C: Fund this with a lot of ether so that we can see it. We'll fund it with one whole ether so that we can see it go into the contract and get pulled out of the contract, we'll hit the fund button and you'll see we're sending one whole ether into this contract. Now, if we look at our balance, it's gone down from 17 to 16, or if you're still at 18, it went down from 18. So let's try to get it back. If we call this withdraw function now confirm once this transaction goes through, we should get all of our ether back.
00:46:06.520 - 00:46:07.776, Speaker D: Let's look at our metamask.
00:46:07.808 - 00:46:40.096, Speaker C: And boom indeed, we have got all of our eth back. However, looking at this contract, we can see that, well, maybe we don't want anybody to be able to withdraw all the funds in this contract. That seems like it might be a really bad idea. Maybe we only want the funding admin to be able to withdraw funds. So how do we set this up in a way that only the contract owner can actually withdraw funds? Well, we learned before that the require function can actually stop contracts from executing unless some certain parameters are met. We can do the same thing here.
00:46:40.198 - 00:46:49.952, Speaker D: With require message sender equals the owner. But we don't have an owner to this contract yet.
00:46:50.006 - 00:46:53.700, Speaker C: So how do we get an owner to this contract the instant that we deploy it?
00:46:53.770 - 00:46:57.300, Speaker D: Well, we could have a function called.
00:46:57.370 - 00:47:02.772, Speaker C: Create owner, but what happens if somebody calls this function right after we deploy it?
00:47:02.906 - 00:47:04.948, Speaker D: Well, then we wouldn't be the owner anymore.
00:47:05.124 - 00:47:24.892, Speaker C: So we actually need a function to get called the instant we deploy this smart contract. And that's actually exactly what the constructor does. So typically at the top of your smart contracts you'll see a constructor, and this is a function that gets called the instant your contract gets deployed. We don't even need to do add function here.
00:47:24.946 - 00:47:29.132, Speaker D: We can literally just call it constructor.
00:47:29.276 - 00:47:48.004, Speaker C: Because it's what constructs the smart contract. So we'll make constructor public, and whatever we add in here will be immediately executed whenever we deploy this contract. So one thing that we could do is we could have an owner be set the instant we deploy the smart contract. So in the top we could add.
00:47:48.042 - 00:47:53.176, Speaker D: Address owner, and in our constructor we.
00:47:53.198 - 00:48:08.156, Speaker C: Could say owner equals message sender, because the sender of this message is going to be us. It's going to be whoever deploys this smart contract. We can even test this out in the Javascript VM to be a little bit quicker, because we're not actually going.
00:48:08.178 - 00:48:10.428, Speaker D: To be calling the fund or the.
00:48:10.434 - 00:48:11.916, Speaker C: Get price function for now.
00:48:12.018 - 00:48:12.424, Speaker D: Oops.
00:48:12.472 - 00:48:32.176, Speaker C: Let's also make this public so that we can interact and see this owner variable. So now if we go to fundme we deploy this in the JavaScript VM. We should be able to see who the owner of this contract is and it should be our address because this constructor function should have been immediately called the instant that we deployed the smart contract.
00:48:32.288 - 00:48:32.612, Speaker D: Awesome.
00:48:32.666 - 00:48:53.450, Speaker C: We can see the owner of this smart contract is indeed our wallet. Because remember, when working with the Javascript VM, our wallet is these fake wallets that they kind of give us. We can even try this with an injected web three with deploying this, and the owner should be this ox seven five seven, et cetera address.
00:48:54.780 - 00:48:56.312, Speaker D: Let's go ahead and look at fundme.
00:48:56.376 - 00:49:32.916, Speaker C: See the owner, and we do indeed see the owner is us. Okay, great, now we have an owner. We can go down to our withdraw function and use that same require so we can call require message sender equals equals owner equals equals is the way that solidity understands. True false. We're saying that message sender has to equal owner. Now let's go ahead and try this and we'll try it with the JavaScript VM. Again, for speed reasons, let's deploy this.
00:49:32.938 - 00:49:36.330, Speaker D: Funby and if we go down here.
00:49:36.700 - 00:50:33.320, Speaker C: We can try to call the withdraw function and it looks like it is successful because currently this is the address that deployed the contract, and it's also the address that is calling withdraw. However, if we switch to a different account and call withdraw, you'll see that remix actually freaks out down here. It says uhoh, something wrong happened. And this is essentially the require statement kicking out. If you want to try it with injected web three as well, we can absolutely do that too. And remember, the way to switch accounts in metamask is to either create account right here, or just switch like this, and then we'll connect with account two. So if I try to withdraw from this second account that didn't call the contract and I hit withdraw, now it's going to give us gas estimation failed because the require statement is going to kick out.
00:50:33.320 - 00:50:57.724, Speaker C: But again, if we switch back to account one and we call withdraw, metamask is going to pop up and it's going to allow us to withdraw. Now obviously there's nothing in this contract right now, so we're going to withdraw nothing. But we can still call it. It's going to do message transfer zero. So this is great. We can now require this. Withdraw function is only callable by the owner.
00:50:57.724 - 00:51:51.620, Speaker C: Now what if we have a ton of contracts that want to use something like this? They require the message sender to be some owner. Or maybe it's more complicated than this is there an easier way to wrap our functions in some require or some other executable? Well, this is where modifiers come in. We can use a modifier to write in the definition of our function, add some parameter that allows it to only be called by our admin contract. Modifiers are used to change the behavior of functions in a declarative way. Let's create our first modifier. We'll call it modifier, which is a keyword only owner, and we'll add this require statement in here, require message sender equals owner. Then after this we just add an underscore and a semicolon.
00:51:51.620 - 00:52:39.376, Speaker C: What a modifier is going to do is it's going to say, hey, before you run this function, do this require statement first, and then wherever your underscore is in the modifier, run the rest of the code. So we could also do a modifier where the underscore is up here and then this is afterwards. But we want to run the require first. So now what we can do is we can make this function withdraw payable only owner public. And what's going to happen is before we do this transfer, we're actually going to check this modifier, we're actually going to run this require message sender equals owner. And then again, where this underscore is, that's where we'll add the rest of the function. So again, for speed reasons, and since we're not actually going to be interacting.
00:52:39.408 - 00:52:41.908, Speaker D: With the Chainlink data contract, we can.
00:52:41.914 - 00:53:24.160, Speaker C: Go to JavaScript VM switch to fund me deploy, and we can call withdraw. Obviously we can call withdraw from our account, but if we switch accounts and try to call withdraw, we're going to get an error, which is perfect, because that means our modifier is working correctly. Awesome. Now we have a fantastically succinct fundme contract here. The only thing that we're really missing is that when we withdraw from this contract, we're actually not updating our balances of people who funded this. So even after we withdraw, this is always going to be the same. So we need to go through all the funders in this mapping and reset their balances to zero.
00:53:24.160 - 00:53:56.060, Speaker C: But how do we actually do that? We can't actually loop through all the keys in a mapping. When a mapping is initialized, every single key is essentially initialized. Now we obviously can't go through every single possible key on the planet. However, what we can do is create another data structure, an array, something we're already familiar with. So let's go ahead and create a new funders array. That way we can loop through them and reset everyone's balance to zero. We'll do an address array because it's going to be an array of all the funders addresses.
00:53:56.060 - 00:54:31.972, Speaker C: We'll make it public and we'll call it funders. Now, when somebody funds a contract, what we're going to do is we're going to do funders. Now, whenever a funder funds this contract, we can go ahead and push them onto our funders array. So we can do funders push message sender. Now, if somebody funds multiple times, the funders array is going to be a little bit redundant. But we're going to ignore that for now. Now that we have an array of funders, when we withdraw everything, we're going to want to reset this to zero.
00:54:31.972 - 00:54:37.480, Speaker C: When we withdraw everything, we want to reset everyone's balance in that mapping to zero.
00:54:37.630 - 00:54:39.892, Speaker D: So we're going to do what's called a for loop.
00:54:39.956 - 00:54:45.710, Speaker C: A for loop is a way to loop through a range of numbers to do something. So we're going to say for.
00:54:48.240 - 00:54:55.132, Speaker D: UN 256, funder index equals zero, because we.
00:54:55.186 - 00:55:11.620, Speaker C: Want to start with the zero th index. We're going to give it a max size to go to. We're going to say the funder index has to be less than funders length. Length is how we get the length of our array.
00:55:12.280 - 00:55:16.004, Speaker D: And then we're going to say funders index plus.
00:55:16.202 - 00:55:41.644, Speaker C: This means that we have an index variable called funder index, and it's going to start from zero. This loop is going to finish whenever a funder index is greater than the length of the funders. Every time we finish a loop, we're going to add one to the funder index. That's what that funder index plus does. It adds one to the funder index. And every time, whatever code is in this for loop executes, we're going to restart at the top.
00:55:41.762 - 00:55:42.876, Speaker D: And all we're going to do in.
00:55:42.898 - 00:55:45.816, Speaker C: Here is we're going to grab the.
00:55:45.858 - 00:55:57.696, Speaker D: Address of the funder from our funders array. Funders. So the funder at the index in.
00:55:57.718 - 00:56:00.084, Speaker C: Our funders array, we're going to use.
00:56:00.122 - 00:56:03.380, Speaker D: This as the key in our mapping.
00:56:04.280 - 00:56:07.140, Speaker C: So we're going to take address to.
00:56:07.210 - 00:56:11.748, Speaker D: Amount funded of funder and we're going.
00:56:11.754 - 00:56:23.672, Speaker C: To set it equal to zero. So now our mapping is going to be all updated to people having zero funded in there. We do have to do one more thing as well. We have to reset our funder array as well.
00:56:23.806 - 00:56:24.988, Speaker D: Now, there's a couple of ways to.
00:56:24.994 - 00:57:16.502, Speaker C: Do this, but a really easy way is just to set funders equal to a new array. So we could do funders equals a new blank address array. So all right, it looks like we've got everything in here we need right away. When we deploy this, we are set as the owner, we can allow anybody to fund whatever public good that we're doing and they have to fund it with the minimum USD value that we actually set. Whenever they fund, we'll keep track of how much they're funding and who's been funding us. We can get the price of the Ethereum that they send in the terms of USD and we can convert it, check to see if they're sending us the right amount. We have our only owner modifier so that we're the only ones who can withdraw from the contract.
00:57:16.502 - 00:57:59.206, Speaker C: And when we do withdraw everything from the contract, we reset all of the funders who have currently participated in our crowdsourcing application. Awesome. Let's see if everything works end to end. So we're going to go to fundme, we're going to deploy it, we're going to confirm from Metamask. And remember, if you're ever confused about what's going on or something weird is happening in your transactions or your deployments, you can always go into Etherscan and read more about your transaction and what's going on. Now that our transaction has been deployed, let's go ahead and just take inventory as what's going on. We have our owner, which is our address right here.
00:57:59.206 - 00:58:36.210, Speaker C: We have the aggregator v three interface version, which is version three, which we can kind of ignore. We have the price of Ethereum in terms of USD with 18 decimals instead of eight. We have a function that allows us to get the conversion rate of any Ethereum amount to its US dollar equivalent. We have an array of funders which right now starts out as empty. We have a mapping of addresses which also right now starts out as empty. Let's go ahead and try to fund this contract. We'll use way just so that we're always on the same page and we'll fund it with 0.1
00:58:36.210 - 00:58:59.050, Speaker C: way. Remember, everything has 18 decimal places. So if we want to do 0.1, we just do 17, so we can do 1123-4567-8123-4567-89 and that'll be 0.1 ethereum. Now we can go ahead and hit fund and we're going to send 0.1 Eth to this contract.
00:59:01.070 - 00:59:01.482, Speaker D: Great.
00:59:01.536 - 00:59:05.434, Speaker C: So if we look at the zero width index of funders, we can see.
00:59:05.472 - 00:59:15.262, Speaker D: That indeed, we have funded this contract. Let's even have our second account fund this contract. So all we got to do is.
00:59:15.316 - 00:59:18.526, Speaker C: Switch to this contract in Metamask, we.
00:59:18.548 - 00:59:25.940, Speaker D: Can go ahead and put zero one etH back in here for a value and hit fund.
00:59:26.630 - 00:59:40.520, Speaker C: Now, as you can see, we're deploying this from account two. Let's go ahead and hit confirm. Funder at index Zero is going to be our admin, and the funder at index one is going to be our second account.
00:59:42.090 - 00:59:44.662, Speaker D: And if we go ahead and we.
00:59:44.716 - 01:00:10.090, Speaker C: Add this funder in here, we can see we've indeed sent zero one ether with this account. If we go back to our account one and put this in here, we can see that that address also has zero one ether. Fantastic. So let's try to be malicious. Let's try to have account number two actually withdraw all the funds in here. Let's hit this withdraw function. Uhoh.
01:00:10.090 - 01:00:35.782, Speaker C: The transaction has failed. We're relentlessly malicious. We want to send this transaction regardless. So even though I'm not the admin of this contract, I've gone ahead and still tried to send its withdraw. So what happens now? We can see that remix is saying, hey, something went wrong. And again, if we look at ether scan, we can see that there was a fail here, since in our modifier, we didn't give a reason. Here, nothing shows up.
01:00:35.782 - 01:01:23.414, Speaker C: But we could have always put a reason in there and something would show up. So, all right, let's go ahead back to the actual admin, and now let's try to withdraw everything. So if we hit withdraw now, we can go ahead and confirm. What should happen is everything in here should be back to zero, and this array should be back to zero as well. And if we watch our address, we can see it literally just went from zero four to zero six because it got zero one from the original funding that this account put in and the zero one that our second account put in. So now if we look at Funder zero, we can see it actually errored because it is now a brand new array, and there is nothing at index zero. If we try to see how much this address now has funded, it's back down to zero.
01:01:23.414 - 01:01:35.450, Speaker C: Awesome. You've now learned how to deploy a relatively simple, yet effective crowdsourcing application where users can fund and an admin can withdraw those funds to go spend them on things.
01:01:35.520 - 01:01:41.674, Speaker A: All right, you did it. Lesson three in the books. Congratulations. That is absolutely massive.
01:01:41.722 - 01:01:42.030, Speaker D: Here.
01:01:42.100 - 01:02:31.050, Speaker A: You've just learned how to use one of the most powerful tools in all of the smart contract world, which is these chainlink data feeds as of right now, which it'll probably change depending on when you watch this video. The Chainlink data feeds are securing something like $80 billion in the DFI network, an absolutely massive, battle tested application here. Now, we're going to start moving into the python portion of this course, and we're going to introduce you web three Py, which is an incredibly powerful Python package that's going to help us deploy our smart contracts, test our smart contracts, and interact with blockchain applications in a programmatic way, making us incredibly powerful developers here. So with that, I'll leave you to the next lesson. Good luck, have fun, and remember to take a breather, to take it all in. I'll see you in the next lesson.
