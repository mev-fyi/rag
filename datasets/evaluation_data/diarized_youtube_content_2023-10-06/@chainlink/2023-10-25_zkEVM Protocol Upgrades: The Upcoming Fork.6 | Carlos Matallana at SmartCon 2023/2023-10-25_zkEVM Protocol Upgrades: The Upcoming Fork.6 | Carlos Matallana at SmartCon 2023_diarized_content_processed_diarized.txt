00:00:00.090 - 00:00:28.450, Speaker A: You. Hi. Hello everyone. My name is Carlos Matayana and I work at Polygon CKBM and I am the protocol team lead. Basically today I will be just talking a little bit about the next major protocol upgrade that we will have. It will be the fork six. You will see later on all the changes that we have known in the ZKVM.
00:00:28.450 - 00:01:11.950, Speaker A: So first of all, I want to just to do a little brief little introduction about what is a fork in the ZKBM. Because it's a little bit different rather than in Ethereum. Why forking the ZKBM? There are different aspects to take into account when doing that. A little bit, the history that the ZKBM in Mainnet, all the forks that we have been done previously. Then I will just talk a little bit about the features regarding the fork five that we did on September. What are the new features that will be introduced in the fork six? And I would say what we have in mind, that could be the future, the future ones. Okay, so first of all, traction.
00:01:11.950 - 00:01:57.940, Speaker A: What is a fork in the ZKVM? Well, as you may know, in Ethereum there are this kind of hard forks and they have different names like Berlin, London, Shanghai, the upcoming the Cancun one. And basically those upgrades to Ethereum protocol are proposed by the EVM developers. They just introduce some new opcode, some new eips, consensus rules and basically what it happens, it's a hard fork. So the chain is fork it. And basically the majority decides which is the canonical chain. So they decide to go to the, I would say to the left or to the right. So they choose the canonical chain in order to follow.
00:01:57.940 - 00:02:36.990, Speaker A: This is regarding Ethereum, but what happened in the ZKBM? In the ZKBM it's basically an upgrade of the smart contracts. So we basically have a definition of what we call the state transition. So you have some transactions and the state route and when you process some transaction then you have an output state route. And this is the state transition. And what smart contract assures you that this transition is valid? Well, it's the verifier. If you upgrade the verifier it means that you are upgrading the ZKBM. It means that you are kind of forking because the state transition function will be different.
00:02:36.990 - 00:03:18.442, Speaker A: In fact, the thing is like, okay, I'm just upgrading, I'm just doing a fork. But as in Ethereum, you can choose whether to stay in a previous hard fork or whether to continue in the new one. So in the ZKBN, basically we have this time lock smart contract. It's very commonly used in the protocols, I would say. And here, this time locker smart contract just assures you, you propose the upgrade and then before executing the grade, you have some time. So you give to the user some time in order to leave the contract if necessary. Okay, and here is why.
00:03:18.442 - 00:03:57.426, Speaker A: Forking the ZKBM, as I mentioned previously in Ethereum, they are proposing new opcodes for more efficiency, more gas efficiency, new pre compiled smart contracts, maybe because of the Zksnar for example. So whatever. And in order to adapt to these new EBM opcodes, the ZKBM also needs to do a fork. Also, there are some specific features that are very related to the ZKBM. I will commit it later, the effective gas price and the data compression. But they have no relation to the EBm itself. It's more a specific future of the ZKBM.
00:03:57.426 - 00:04:49.714, Speaker A: If we want to update it, we will do just another fork also. Well, as you may know, in general knowledge ecosystem, there is a lot of research ongoing, a lot. So we are kind of always willing to embrace all this new research that has been done. And basically it's about new hash functions, new verifiers, new optimization and so on. When you want to integrate those into the ZKBM, you also need to do this kind of fork. Also move to a type one ZKBM. What does it mean? It means that, well, currently there are a lot of zkbms in production in mainnet, but I would say that none of them, it's a type one ZKBM, type one CKBM means that the ZKBM behaves exactly as the EPM.
00:04:49.714 - 00:05:24.530, Speaker A: There are type twos, there are type three, there are type four, there is a blog post of Vitalik explaining them. And if you want to move forward, if you want to move from the type two to the type three, type two to the type one. So you need to do protocol upgrades as well. So it's meaning that you need to do a fork and removing training wheels, as you may know, zero knowledge. Very cute. Edge technology. I mean, some parts of the protocols are a little bit centralized in order, I would say, but for safe and in order to remove those training wheels in the smart contracts also you need to do some forking.
00:05:24.530 - 00:06:04.642, Speaker A: Okay, so this is basically the fork history that we had. You can notice that I started in fork four, the previously three forks, they were in testnet. Then last month we introduced the fork five. And probably in Q four 2023 we will introduce the fork six. And now I'm going to explain the two features of the fork five and the three ones of the fork six. Regarding the fork five, okay, you may hear about in Shanghai hard fork in Ethereum, it was addition of an opcode. It was the push zero.
00:06:04.642 - 00:06:43.360, Speaker A: Okay, this opcode, I would say it's kind of straightforward opcode. No, instead of using push one and then zero zero, you just call the opcode push zero and you insert zero into the stack and that's it. Then you basically save one byte and basically save one gas. This is very important. Well, basically it's safe bytecode to be stored on the state tree in Ethereum and basically reduce cost when you deploy some smart contracts. Why this is very important? Well, as you can see here, there is just an implementation of the push 01234 lines. Not that much.
00:06:43.360 - 00:07:24.774, Speaker A: This is mainly the zero knowledge assembly language that we are using. But here the important thing is that you can see that there is no so much lines here in the push zero. And why the addition of the push zero implementation is important? Well, the push zero implementation was added to the solidity version zero 820. So what happens is you write a smart contract with this solidity version and you compile it and then you deploy it on the AVM. Okay, it's perfect. Nothing happens. But what happens if you do exactly the same, but you try to deploy it in a L2 network that the push zero is not supported.
00:07:24.774 - 00:08:04.822, Speaker A: So it will just trigger an error. One of our developers, Jesus, just make a comment in this sergity report just saying, hey, be careful of that. Nobody cares. But, well, turns out that hard hat, one of the most development kids use it in the ecosystem, basically just do kind of a rollback. Okay, so by default it was set that by default uses the Shanghai hardware, which includes the push zero. Okay, but hard, just make a rollback that says okay, don't use the push zero by default. I mean, if you say to use it, then use it, but by default not use it.
00:08:04.822 - 00:08:42.514, Speaker A: Okay. I would say this cause some issues and troubles to developers. And this is very important because the L2 networks, we are aiming to be exactly the same as the ABM. So we should follow obviously the ABM because normally they introduce some these new ips in order to be more gas efficient or bytecode efficient or whatever. Okay. I think that quarterly we are the only ones that support push zero. You may not next one effective gas price.
00:08:42.514 - 00:09:25.422, Speaker A: What is this? Well, basically this is just a single byte that allow us to charge less gas to a user. You may know that in an ethereum transaction there is this gas price, which is a signet field. And then this byte basically allow us to charge a percentage of this gas price that the user signed it. So basically you church the user the gas price that he signed it or less. Okay, this is a trick, I would say. Well, it's not a trick. This is a protocol definition that we made in order to charge fair gas prices to the users.
00:09:25.422 - 00:09:57.990, Speaker A: Because as you may aware of in L2 transactions, the cost of a L2 transactions is basically the data availability cost. And how do you know the cost of data availability? So you need to know the layer one gas price when you publish those transactions on chain. Okay. And you don't have this price on layer r1 time in L2. Sorry. So layer one gas price needs to be moved to L2, but it's kind of difficult to do that. Furthermore, eip 4844 will be introduced in the Cancun hard fork.
00:09:57.990 - 00:10:52.270, Speaker A: How do you price the data that will go into the blobs in the proton something eip you don't know in L2? So thanks to that, we kind of, kind of computing off chain and we can apply this kind of reduction to the user transaction. Okay. Of course, there is always a trade off here. The trade off is basically that we have kind of a centralized sequencer, so the sequencer can choose this percentage freely here. The cool thing of our protocol is that the user, it's freely move out of the protocol if he wants to do so. Okay, what about the fork six? So the fork six basically introduced one important concept that we didn't take into account at the beginning of the protocol. Okay.
00:10:52.270 - 00:11:42.874, Speaker A: This concept is the block. Okay. You may hear about, you know, what is a block in ethereum, okay? So that we have a batch, and we thought at the very beginning that the batch will be the block. Okay? So we naming that differently in order to not to confuse block and batch, and this batch, the header of a batch, we have the timestamp and the global exit route. And all the transactions that fit into inside the batch shared this kind of batch header, which includes the timestamp and the global exit route. But we realized that we can add a lot of transactions into a batch. Okay, so what happens if you take just 30 seconds to add a lot of transactions to this batch? Because of course, we want to fulfill the batch as its full capacity.
00:11:42.874 - 00:12:33.054, Speaker A: It's very important. It can present the very last transaction has that the timestamp span would be 30 seconds. So what we introduce here in order to improve the performance is this concept of block inside the batch. Okay? So now in the fork six. What we have is, I would say a granularity of this timestamp and global extent root inside the batch. Okay, well, I already said this, allow multiple blocks to be builded inside the batch. Nowadays, blockchain, if you have a block time of 30 seconds, 40 seconds, decentralized finance applications, oracles and so on, they don't like that.
00:12:33.054 - 00:13:20.006, Speaker A: So they need more IoT in timestamp, probably 3 seconds, 4 seconds, 5 seconds, 12 seconds. This also will increase this batch performance. This looks like more standard blockchain approach, since we didn't have this kind of block concept inside the renewable circuit, inside the batch, but we will have it in the forexes. So basically it looks like more blockchain approach. Okay. And as I mentioned, it's very important for oracles and centralized finance. And when we include this change kind of block inside the batch, then what we could do is a block hash.
00:13:20.006 - 00:14:03.590, Speaker A: But in L2, you may know that of course there is a block hash in layer one. So if you call to the RPC endpoint and you receive some data thanks to the block hash, maybe you can briefly that does data is correct or not? Okay, we do not have this in L2, so you need to kind of trust of the ERP set node. But with this we're going to introduce this block hash, L2 in the batch, in L2. So it means that when you call the RPC and you get some information, you can kind of verify that this information is correct. Otherwise you need to trust the RPC. Well, this is basically the specification. It's a little bit different rather than the theorem.
00:14:03.590 - 00:15:00.934, Speaker A: We basically took all the data, so we built sparse Merkel tree using the hash function, the positon. And we don't have multiple trees like in ethereum that you have the transaction tree, the receipts tree, and then you build the block hash. Now here we only will just have one Merkel tree, which we call block info tree. And inside this block info tree it will be, well, of course the previous block hash and the veneer is a blockchain, block number, gas limit, gaming, stam, global, et cetera, that got used here. The different field is the global exit route, which is used by the bridge. And well, the transaction data is probably exactly a little bit the same when you compare to the ethereum. So you hash all the signnet parameters of an ethereum transaction, and later on the outcome of the transaction, which will be the status, the accumulated user and all the logs triggered by the transaction will be hashed as well and added into the tree.
00:15:00.934 - 00:15:40.870, Speaker A: And at the very end this will be the block hash. Layer two is what we call. And the pre compiled one, well the pre compiled is just a table just to let you know what we are currently working on. And basically in the fork five we just supported is a recover and identity. And in the fork six we are currently working very hard in order to support the shadow 156, identity Mondex and a list of cure ones related add mole and padding. Okay, this is very important in order to be from type two five to type two GKBM. Okay.
00:15:40.870 - 00:16:39.580, Speaker A: We decided to not put a lot of effort in the ripe MD 160 and the Blake two f pre compiled because they are not used too much in Ethereum and it will take a lot of time to implement in the zero knowledge part of the ziggyba. So what about the future? Well, you may know that the future basically is EIP 4844. What we will do is just, we will add a new circuit that we will call Ziki blob and this circuit will manage the Ethereum blob. Okay, this is very important. This is very important because it will reduce gas cost from data availability from 16 gas to three gas per byte. And basically this will reprocute the L2 transaction cost of users. If the data availability cost reduces, the L2 transaction cost will reduce exactly the same.
00:16:39.580 - 00:17:07.480, Speaker A: And also we are working very hard on the data compression. Data compression. What we're going to do is custom data compression protocol. Okay. So we study the Ethereum transaction fields basically and how to compress them. If you compress them, then you put less data on chain, then the transaction will cost less on chain on layer to on the user side. Okay.
00:17:07.480 - 00:17:17.380, Speaker A: And these are the two fields that we are working on, probably forks seven, eight and nine. We will see. And that's pretty much. Thank you.
