00:00:00.170 - 00:01:11.458, Speaker A: Hello, my name is Andre and I have some exciting news. The Chainlink Hardhead starter kit now supports typeScript. Curious to know more? Let's dive right in. As you already know, Harhead is a javascript and typescript based development environment that enables developers to compile, deploy, test, and debug EVM compatible smart contracts. A year ago, we released the Chainlink hardhead starter kit, a single repo with everything developers need to start building with Chainlink, including smart contracts in contracts folder over here, then tests in test folder over here, advanced tasks in tasks folder, obviously, and deployment scripts in deploy folder one year later, these projects come with a brand new typescript version. To switch to the typescript version, you obviously need to git clone the repo itself and pull the latest changes and then check out to the typescript branch. So just type git checkout typescript and hit enter.
00:01:11.458 - 00:02:09.186, Speaker A: Then you'll be switched to the typescript branch and you can notice over here already a lot of typescript or ts files. Yeah, so about testing testing has truly been level up with this new addition. Now, test files are divided into two separate categories. Inside test folder we have unit folder and staging folder. So this means that the tests are now divided into unit tests and staging tests. Each test listens for a specific event when waiting for a callback from the Oracle network. Each unit test is independent, and callback responses from the Oracle network are mocked using a wide palette of test contracts and helpers from the official chainlink repository to yarn unit tests to run unit tests, you first need to compile this whole repo.
00:02:09.186 - 00:03:41.298, Speaker A: So typing by yarn compile okay, everything's compiled. And now to run unit test just type yarn test, we can see that all unit tests passed. As I said, because unit test basically each test is independent from each other. This means that we can save some time and optimize the performance by running them in parallel. So to run unit tests in parallel, just type yarn test and then add flag parallel parallel and type enter. You can now see that all tests are passed, but API tests come last before because this price consumer unit test or keeper unit test executed fasted, executed fast because of parallelization of processes. Additionally, because we are now using typescript, we can even more speed up hardhat by preventing tsnode from recompiling and type checking your project on every run by setting up the tsnode transpile only environment variable to one.
00:03:41.298 - 00:04:42.898, Speaker A: So either go to your env file and type ts node transpile only equals one, or just type it here inside the terminal and just follow up by yarn test. This means that your unit tests will run even faster and we can see that again. All test passed. Staging tests, on the other hand, use already deployed instances of contracts on various test networks while listening for the events. There are no mocked contracts or simulated callbacks. To run staging tests, you first need to deploy your contracts to some testnet of your choice and then run them by flag network and the name of the network of course. What else? We added typechain so you can see here the typechain folder.
00:04:42.898 - 00:06:05.540, Speaker A: What is that? Typechain generates its typescript typings so these d ts files you can see here factories and basically with javascript you need to remember not only the name of a given smart contract method or event, but also its full signature. This wastes time and might introduce bugs that will be triggered only in runtime. Typechain enabled more precise and efficient tests, tasks and scripts, so we tend to use typechain whenever is possible, wherever is possible. So if we go here we can see types for API consumer link, token and mock oracle contract and here you can see that they are statically typed. What else? Nutspec so Ethereum natural language specification format, or nutspec for short, is a form for comments meant to provide rich documentation to solidity smart contracts. If we go to apicconsumer sol smart contract, we can see nutspec above the contract itself with title and notice. Then above each function.
00:06:05.540 - 00:07:19.992, Speaker A: Again notice with short explanation what the function does listed parameters, additional comments, and optionally return parameter if function returns something, of course. So these comments use tags such as notice, params return, and many more. And these tags can be used to describe pretty much anything from contract itself to functions including variables, events, or even modifiers. But not just that. The messages generated by Nutspec are directly meant to be displayed to the end user when they are interacting with your contract functions, for example, signing a transaction. So let's return to the tests in spark contract development understanding code coverage is an underrated skill, especially if you practice test driven development. It is a measure in percent of the degree to which the smart contract source code is executed when a particular test suit is run.
00:07:19.992 - 00:08:42.360, Speaker A: A project with high test coverage has a lower chance of containing undetected bugs compared to a project with low test coverage. To develop secured apps, you should reach at least 90% of code coverage. However, don't try to chase 100% code coverage at all costs because this can result in unexpected side effects. To run code coverage, just enter yarn coverage and hit entertainment. Okay, the coverage is done so you can see that we reached 90 plus percent for most of the smart contracts here. There's a couple of branch uncovered in some tests, basically because we didn't test some revert functions, withdrawing and transferring link tokens and funding smart contracts with link token. But you probably saw this, let me scroll a bit up.
00:08:42.360 - 00:09:50.422, Speaker A: So yeah, a couple of tests was skipped for coverage. So some solidity files like mock contracts whose only purpose is to serve as a test helpers will display low coverage percents to exclude them from checks. You need to update Solcover Js file like this. So module experts just skip files and name all of the solidity files you want to skip. And that's pretty much it. Another thing is that if you want to use forking, so forking is when you test your solidity contract in a copy of real environment. So you want to fork some mainet chain in a particular block, you need to go to harheadconfig ts file find forking JavaScript typescript object block for URL set mainet RPC URL for example alchemy URL for Mainet.
00:09:50.422 - 00:11:06.450, Speaker A: Then you need to add specific block number because if you don't specific this number, by default hardhead will fork the latest block, which can be tricky because you are going to run tests against different state every time, which is not good. And finally, to enable it, just need to set enabled to true and that's it. About testing programming programming smart contracts for EVM compatible chains means programming with limited resources. For these reasons, developers tend to optimize their code as much as possible. So because gas optimizations can be tricky, a mocker reporter has been added to the test suite that displays gas usage per unit tests and other various metrics for method calls and deployments. So this is gas reporter. So to enable this gas reporter, you just need to set report gas environment variable to true.
00:11:06.450 - 00:12:36.560, Speaker A: And then as always, just run yarn test. As you can see here, the output will be stored in a gas report TXT file. If you don't specify this output file, it's going to be displayed inside the terminal itself, the same as this code coverage. So let's try it. So report no report gas equals true and yarn test okay, you probably noticed that gas reporter TxT file was generated automatically. If I click here, I can see all of the gas reportings generated by my unit test. So salts version optimizer enable disable all contracts, all methods average gas usage, minimum gas usage, maximum gas usage block limit, number of calls and all of this really helpful stuff.
00:12:36.560 - 00:14:16.268, Speaker A: Okay, so did you ever spend weeks building a smart contract only to encounter the max code side exceeded error during the deployment process? This means that you hit the smart contract code size limit and that you'll need to reduce the size of the contract before deploying or split it into several smaller contracts and libraries to avoid massive refactoring. At the end of the development process, a simple command to display the size of each smart contract in the project has been added, so you can be aware of this limitation way earlier and act accordingly. So to view contract size, just run yarn, run hard hat size contracts and hit enter. I made a typo hard hat once again and yeah, this is the result. We also added really new great new thing so I can just preview this readme file to see it better. So let's go to fuzzing so we are going to use a kidna as a fuzz testing tool. You need to have Docker installed with at least 8gb virtual memory allocated by default.
00:14:16.268 - 00:15:00.748, Speaker A: The docker client will allocate two gigs of this virtual memory. So to update this parameter, go to settings resources advanced memory and just scroll that bar to add gigs. To start a kidna instance, you just need to run yarn fuzzing. So I'm going to clear this yarn fuzzing and hit enter. If you're using it for the first time, you will need to wait for Docker to download this eth security toolbox image for us. It's going to take a couple of minutes, so be prepared for that. Depends on your Internet connection and memory and other like the power of your machine.
00:15:00.748 - 00:16:04.962, Speaker A: But eventually it's going to download this image and run it like this. So right now I'm inside the Echidna docker container. So to start fuzzing I need to type all of this. So Echidna test and then to specify the path to my keeper counter echidna test sol contract inside fuzzing folder and I also need to provide this config file which I'm going to discuss a bit later. So just run this and wait for fuzzer to start fuzzing this smart contract. What we are seeing now is a fuzzing of this keeper compatible echidna smart contract. So if I go to contracts folder test fuzzing, I can navigate navigate to keeperscounter echidmatest.
00:16:04.962 - 00:17:17.270, Speaker A: So this is the smart contract for fuzzing and it basically fuzzs the timestamp. So because the keeper counter example in our hardhead starter kit is set to have a time interval of seven days, what we wanted here is to text this perform upkeep to never be called whatever the inputs or fuzzing or whatever the sequence of function calls is being present. So no matter what we want counter to stay zero. So this counter value should never be incremented. That way we know that our modifier in keepers counter contract is working. I also mentioned this config yaml file. It basically tells the echidna how to run a specific test.
00:17:17.270 - 00:17:59.862, Speaker A: So I set the test limit to 10,000. The default is 50,000. Then I set the maximum time delay, maximum block delay because we are fuzzing the timestamps and also some additional arguments for creating compiler. So we're somewhere to the half of this fuzzing. So we need to wait for a couple of more, let's say minutes. Okay, fast forward we are almost done. So we are monitoring this fuzzing boom.
00:17:59.862 - 00:18:35.750, Speaker A: It's passed. So all of our fuz testing passed, which is great. So I can just click escape to exit this campaign or just type exit escape call. I escaped. And finally to exit this docker container I just need to type exit and done. I'm back inside my own terminal. The last addition is of course vrfv two.
00:18:35.750 - 00:19:44.698, Speaker A: So if you go to contracts folder you can find random number consumer v two solve file. So this is the example of contract which is using VRF v two. So you can see a couple of more storage variables which can be adjust. So for example this s num words I specified here that I want to request two different random values from the BRF. If I change this value to, I don't know, three, four, I will then get three or four random numbers from the oracle network as a callback. To see how to test this new VRF to consumer contract, go to unit go to tests, then unit tests folder and find random number consumer v two spec ts file. So you can see here how you can test to successfully request a random number.
00:19:44.698 - 00:20:41.310, Speaker A: So this call should emit a random vert requested event. How to get a result by simulating a callback from the Oracle network because this is a mock test and also how to successfully fire event on callback. So this test is listening for specific events when the Oracle network sends the random numbers back to the calling contract. So that was it. I hope you found this video interesting. I hope you like the new addition to Harkistarter kit and I highly recommend and encourage you to write more tests and script in typescript because it's going to result in much safe differ projects, which is very important in web three world. See ya.
00:20:41.310 - 00:20:47.420, Speaker A: You close?
