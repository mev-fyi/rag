00:00:00.170 - 00:00:40.490, Speaker A: Us really want to thank the greater cryptography and chain link and crypto community for joining us today, especially IC three. Our special guests really grateful to have them here to share the cutting edge research that they've been working on. If you have questions again, feel free to drop them in our chat. I'll also share all the IC three links and resources in the description afterwards. And yeah, really want to thank Mahimna Kelkar for joining us and presenting on his research today. Cool. Sarah, do you want to maybe talk about IC three and then you can introduce Mahimna?
00:00:41.550 - 00:01:04.414, Speaker B: Sure. Thank you Keenan. And thanks Chainlink for partnering with us for this event today. So, my name is Sarah Allen. I am the community manager for the initiative for Cryptocurrencies and contracts, also known as IC Three. IC three is an academic blockchain research initiative that has faculty across nine global campuses, and we're based at Cornell Tech in New York City. So today we're going to have a presentation.
00:01:04.414 - 00:01:35.130, Speaker B: We have roughly monthly webinar events. You can find them announced on our Twitter channel and the IC three website, which you can find through the event page for this event. So today Mahimna Kelkar, who is a PhD student in computer science at Cornell, is going to present his work that he has done jointly with his PhD advisor, Ari Jules and others who he'll mention on fair ordering of transactions in consensus protocols. So I'll turn it over to Mahimna.
00:01:36.510 - 00:02:05.640, Speaker C: Thank you, Sarah, for the introduction. I'm going to go ahead and screen share. Just give me a secondary it.
00:02:06.810 - 00:02:08.246, Speaker A: Yes, looks good.
00:02:08.428 - 00:02:43.838, Speaker C: Awesome. So thank you for the introduction. I like to thank both IC three and chain link for sort of organizing this webinar. As Sarah said, I'm a PhD student at Cornell and Cornell Tech, and today I want to talk about our recent work on order fairness for blockchains. So this talk is primarily based on two of our papers on fair ordering protocols. The first is titled Order Fairness for byzantine consensus, which was sort of the first work to formalize a notion of fair ordering for permission consensus. And this appeared at Crypto 2020 earlier this year.
00:02:43.838 - 00:03:37.490, Speaker C: And this was joint work with authors at Cornell and Cornell Tech, Fan Zhang, Stephen Goldfeder, and re Jules. The second is more recent work on order fair consensus in the permissionless setting, which is with co authors at the University of Washington, Seattle, Saulbek Deb and Sriram Kanan. The preprint of this work will be released shortly, and it's currently in submission. So to begin, I wanted to talk briefly about the state machine replication or consensus abstraction that is core to this blockchain mechanism. So this should be familiar to most of you, so I won't spend too long on it. But traditionally, in the classical or permission setting for the consensus problem, there is a set of servers, or nodes that receive transactions from clients, and the goal for these nodes is to order these transactions in a consistent manner. So some of these servers can be faulty or even actively malicious, and even then, security should still hold.
00:03:37.490 - 00:04:28.180, Speaker C: So protocols that solve this abstraction are what we call consensus protocols in the permissionless setting, say, using proof of work, these servers can be replaced by miners who can enter or exit the system dynamically. But the basic problem, abstraction is the same. There are transactions that are coming in from users, and the network as a whole needs to agree on a consistent, ordered log of these transactions. Now, usually we expect two properties from consensus protocols. So the first is consistency, sometimes called safety, and the second is liveness. So consistency will ensure that all of the honest parties agree to the same view of the final output log, and essentially means that adversarial nodes cannot split the network's view. Liveness, on the other hand, means that new transactions that are sent by users are incorporated into this log soon.
00:04:28.180 - 00:05:19.890, Speaker C: So essentially, adversarial nodes can't stall the network. Now, while these properties are enough for classical applications like building replicated databases, they may no longer be sufficient for a lot of blockchain applications. So primarily this is because neither consistency nor liveness provides any guarantees on the actual ordering of transactions. So this is particularly discomforting, seeing how it's so easy usually to manipulate this ordering. So let's take a couple of examples looking at classical protocols. So classical protocols in practice today are what we call leader based, where a leader proposes an extension to the order log and all the other nodes or replicas follow along. So protocols like PBFT or Paxos have a single leader that gets voted out only if it's acting maliciously.
00:05:19.890 - 00:06:05.154, Speaker C: Some modern protocols, like hot stuff, rotate the leader every once in a while. But still, in all of these protocols, whoever the current leader is, it can propose any transaction ordering. So whenever there is an adversarial leader, it has the power to arbitrarily manipulate the ordering. And no prior permission protocol really guarantees any notion of fair transaction ordering. Well, you might think that maybe permissionless protocols are better, but surprisingly, even protocols like bitcoin aren't much better in the context of order fairness. So even though they're sort of fundamentally more decentralized, a block miner still has complete control over the ordering of transactions in the block that it's mining. And this happens all the time.
00:06:05.154 - 00:07:06.500, Speaker C: So you could imagine miners being bribed or incentivized to prioritize a specific set of transactions. A miner with like a small but non negligible mining power will be able to impact the ordering for a small but again, non negligible amount of blocks. And this is what we call an ephemeral or short term centralization for the ordering, even in permissionless protocols. So all this talk sort of raises the central question that drove our paper. Why exactly is fair ordering so important? You might say consensus of the primitive has been studied for four decades now, and the field is quite mature. Well, new protocols still come out every year at top conferences, but most of what they optimize us for is like communication complexity or reducing the number of rounds for liveness. The standard requirements of consistency in liveness have largely remained the same.
00:07:06.500 - 00:07:46.350, Speaker C: We think that our work actually looks at this consensus problem in a fundamentally different way. And in the next few minutes, I want to hopefully convince you why fair ordering is especially important as consensus moves more and more to the blockchain world. So the easiest reason to see this is that it can affect validity. So let's say we had three users, Alice, Bob, and Charlie. And Alice sends $5 to Bob, and Bob sends $5 to Charlie. If Alice's transaction is ordered before then, both the transactions will be valid. But if Bob's transaction is ordered first, then assuming that he started with no money before these two transactions, his transaction will be invalidated.
00:07:46.350 - 00:08:49.650, Speaker C: Only Alice's transaction will go through. A more catastrophic problem, though, is seen in the context of decentralized finance, or DeFi, as it's popularly called. DeFI has been a particularly hot topic on permissionless blockchains in the past few years, and by some estimates, the market cap for DFI on just Ethereum is $14 billion, with something like ten or $11 billion being currently locked in DFI contracts. And here's just a partial list of the companies and products that have risen in this space in just the past few years. To see why fair ordering is so important in the context of DFI, let me give you one specific example of trading on decentralized exchanges. So, for some context, there was this New York Times bestseller expose by Michael Lewis, published in 2014, that brought to light the high frequency trading in the early days of Wall street. And this is when Wall street firms spend millions of dollars to build low latency channels to the New York Stock Exchange and the Nasdaq.
00:08:49.650 - 00:09:38.818, Speaker C: So that they could retrieve information about a trade and act on it in the matter of microseconds. And firms sort of capitalized on this information asymmetry to realize small profits on an extremely large volume of transactions. And over the years, high frequency trading has been subject to a lot of regulation by the SEC. And today, it's no longer the wild beast it once was. But in some sense, this type of high frequency trading is exactly what we're seeing on decentralized exchanges on blockchains. For example, a recent paper that many of you might be familiar by now that came from our group led by Phil Diane, found exactly this. It showed the rampant rise of transaction reordering attacks and the instability that's caused because of this in decentralized exchanges.
00:09:38.818 - 00:10:20.366, Speaker C: And unlike in real world exchanges, there's not really so much regulation in these blockchain exchanges. So it's important to use cryptography to provably prevent these new types of attacks. So I'll quickly run through what I mean by front running and arbitrage. So let's say we have a user, Alice, who wants to buy a token, say one BBT for $1 from a decentralized exchange. So she sends a buy order to the exchange, but let's say Alice makes a typo. So instead of writing one dollars, she writes $100. Now, any adversary that's sort of snooping around the network can try to sell any BBT tokens that it already owns.
00:10:20.366 - 00:11:27.000, Speaker C: What's more is that it can even try to quickly buy another token from the exchange and turn around and sell it to Alice for a profit. And this the adversary can do if it can sort of reorganize the transaction, ordering that the decentralized exchange executes to make sure that its transactions are ordered first. So this is what we call front running and arbitrage. So front running, as in the adversary was able to place its order before the honest user and arbitrage was able to buy, and then quickly turn around and sell that to the honest user. So, as I said, if the adversary can change the transaction ordering, it can profit from Alice's mistake. And what's even more interesting is even if the decentralized exchange supports a cancel order and Alice can send it, if the adversary can control the ordering, it can place this cancel order at the very last to seal its profits. So, especially in exchanges on permissionless systems, bots were found to wait for these arbitrage opportunities and wait for orders that deferred in the market value.
00:11:27.000 - 00:12:08.694, Speaker C: The intuition was to pay slightly higher transaction fees in order to have these decentralized exchanges prioritize their transactions. So these are not hypothetical or theoretical tax. Here are a couple examples from Phil's paper. We have these comments saying I'm a stay at home parent, I day trade to keep my family above water, or I really needed to pay for my education, I might need to sell my car to pay, or I'm a single parent just trying to make ends meet at a job I hate. Please have some mercy. Seems like a lot of single parents trying to day trade to support their family. Not something I usually support, but you got to do what you got to do.
00:12:08.694 - 00:13:13.850, Speaker C: Anyways, there's a lot more of these examples in Phil's paper, and I'm only really scratching the surface here. The crucial takeaway that I want to highlight is that front running and order manipulation attacks affect regular users the hardest. This is sort of reminiscent of the impact of high frequency trading on traditional exchanges and on Wall street. And all of this was sort of done by bots, not even in charge of the actual ordering in the exchange. So can you think about the impact that would happen if the adversary itself was a consensus node? So clearly fair ordering has a lot of practical relevance. But we think there's an independent theoretical motivation as well, in that it generalizes the validity condition from the closely related byzantine agreement problem. So similar to validity where the output needs to be some value v if all of the honest nodes are input, that value order fairness, which I haven't defined yet, but will output a message m one before m two if all honest nodes receive it that way.
00:13:13.850 - 00:14:17.120, Speaker C: So you can kind of see this analogy to the more multicontuous setting that is the state machine replication problem. So I want to also talk about some, briefly about some notions of unfair ordering. So you have broadly, you have censorship, which is used to suppress specific client transactions. Adversarial nodes can insert their own transactions in an unfair manner, or more broadly, they can try to reorder specific client transactions, and this can be done by being bribed by the client, or even when they're colluding with a client. All of this can also be done blindly, so without knowing the actual transaction ordering. So there's a lot of work in literature that achieves the so called censorship resistance property, which basically means that any honest users transaction will eventually be added to the blockchain. So here I'd like to highlight that reordering and insertion attacks are still possible.
00:14:17.120 - 00:15:12.794, Speaker C: Another technique that's used in literature is of random leader election. So for every slot you elect a random leader that can extend the chain. But here, adversarial leaders are also eventually going to get elected, and they can still order unfairly for their own slot. Some more sophisticated techniques that are used recently are. One is like hiding the transaction data, so trying to confirm the ordering of the transactions without the transactions being seen first. So you have techniques like threshold encryption or commit and reveal schemes, but here even sort of blind reordering is possible. You're also able to manipulate via the metadata, like IP address, or even in some cases, be able to collude with the honest user and know the decryption of their transaction or the decommitment of their transaction.
00:15:12.794 - 00:16:13.314, Speaker C: In case of these threshold encryption or committed reveal schemes, there's also a notion of choosing a completely random transaction ordering so that the adversary has no influence over the ordering. So you just choose a random set of transactions in the current pool of transactions. But here, surprisingly, manipulation is still possible through just flooding the network with a lot of transactions. So this is actually still not fair. And I'll emphasize that order fairness is strictly stronger than previously considered notions. So just to highlight this random versus fair ordering difference in a random ordering, adversarial transaction can be ordered before an honest node, which arrived earlier, even with a 50% chance, because you're sort of choosing a random pool of transactions. If now the adversary tries to flood the network with many adversarial transactions, you can bring this probability as high as you want.
00:16:13.314 - 00:17:30.570, Speaker C: And on the other hand, in a fair ordering protocol, we want to guarantee that any honest transaction that arrives first is always ordered earlier, regardless of any adversarial behavior. So continuing on this sort of comparison to the current techniques, there's usually two main types of adversaries considered in literature. One is that tries to break consistency by equivocating, and the second is that tries to break liveness by attempting to stall the protocol. But there's this third type of adversary that's seen in many recent blockchain applications, which tries to break application specific guarantees and fairness invariance by reordering transactions or inserting their own transactions, or censoring transactions. And order fairness or fair ordering protocols in general are built to deal with exactly this kind of new adversary. So I talked a lot about motivating order fairness, but just a quick recap here is we have this independent theoretical motivation is that it generalizes byzantine validity. We use order fairness to prevent front running and arbitrage in decentralized exchanges, and you can also prevent unfair ordering from bribery inclusion.
00:17:30.570 - 00:18:15.626, Speaker C: Now, I'd like to move on to a little more technically of how we define our notions of fair ordering. So here is sort of a natural definition that we started with. We call this gamma receive order fairness, where gamma is this order fairness parameter between half and one. So the definition is as follows. If gamma n nodes are input m one before m two, then all of the honest nodes deliver m one before m two. So this is in a permission setting where you know the end nodes that are interacting with the protocol. While this definition is very natural and intuitive, it turns out that it suffers from an impossibility result.
00:18:15.626 - 00:19:09.754, Speaker C: Specifically, global orderings can become non transitive even if the individual orderings are transitive. And for this, we draw on a surprising connection with social choice theory literature, or voting theory literature, and specifically the condor state paradox. So, to illustrate why this applies to fair ordering, I'll give you a simple example. So suppose we have three notes, Alice, Bob, and Carol, and they receive transactions in the order xyz, y, zx, and zxy. So now you can sort of see that two of these notes have received x before y, two of them have received y before z, and two of them have received z before x. But now, if you look closely at these ordering constraints, you'll find that you need to have this cyclic ordering, which results in a contradiction. So basically, we just showed that when n equals three, no protocol can achieve gamma equals two.
00:19:09.754 - 00:19:52.810, Speaker C: Third receive order fairness. So for the simplest case of gamma equals one, it's possible when the adversary is non corrupting, but it's impossible even in the presence of a single byzantine node. And I'd like to highlight that this byzantine node doesn't actually have to do anything malicious. It's just the presence of this node that has this impossibility. So here, just the very informal description of our result. For, in a permissioned protocol, for any n and any f greater than equal to one, and for any order fairness parameter gamma, no protocol can achieve all of this consistency, liveness, and order fairness for a large enough network delay. So I'll go into weakening the fairness requirement.
00:19:52.810 - 00:20:32.594, Speaker C: But we start with two sort of alternate definitions before we get into the actual definition that we settled on. So here's a couple of natural definitions. So one is sort of using a separational barrier, and one is median fairness, which I'll explain just in a bit. So I'll start with this separational barrier definition. I know this looks like some sort of linear classifier example taken right out of some data science textbook, but hear me out. Let's say we have two transactions, the one in purple and the one in green. And the graph here shows the node receive times for these transactions, again in a permission network.
00:20:32.594 - 00:21:41.158, Speaker C: So you can kind of see that these purple received times are all before the green received times. But what's more is that you can have this barrier between the two received times, such that above the barrier all the purple transactions have been received, and below the barrier all the green transactions have been received. So it's natural to have a definition that says, well, if you can create a barrier before that sort of splits these two transactions, then your protocol should order this purple transaction before the green transaction. So informally you can write this definition as follows. If all of the nodes are input one transaction TX one before any of the node is input TX two, then all of the nodes should deliver TX one before TX two. But if you look at this if statement very closely, it turns out that it's not very practical, because the adversary can easily make receive times globally interleaved by front running a transaction. So once the adversary gets to know of a transaction, it can try to quickly spread a competing transaction through the network.
00:21:41.158 - 00:22:35.962, Speaker C: And we expect that that competing transaction may lag a little bit, but usually its times will be globally interleaved. So you're going to have a situation that looks something like this instead, where you have just one node that received it in the opposite ordering. So every other node received the purple transaction before, but the transaction received times are sort of globally interleaved. So this means that for most practical attacks, the if part of this conditional can be made false, which results in a totally vacuous definition. So this is not really useful for understanding practical attacks. Another natural example is, well, why don't we just use a median timestamping protocol, have some fair ordering definition based on median timestamping. So it turns out that a single adversarial node can cause an unfair ordering by flipping its own local ordering.
00:22:35.962 - 00:23:38.942, Speaker C: So let's say we had like five nodes, ABCD and E, and two transactions in yellow and green. And all of the nodes, as you can see, have received the yellow transaction before the green one. And if you calculate the median now, you'll see that the median for the yellow transaction is smaller than the median for the green transaction, which is perfectly normal. But if e was adversarial and tried to flip its own ordering, then you can see that this median property no longer holds, and your protocol will order the green transaction earlier, even though all of the other honest nodes received the yellow transaction before. So what I want to highlight with these two definitions. Is that the problem of choosing a good fair ordering definition that's achievable but still sort of captures all of the interesting attacks is highly nuanced. There's still a lot of research to be done in this area, but here's sort of the definition that we settled on eventually.
00:23:38.942 - 00:24:45.270, Speaker C: We call this block order fairness. So the difference between the block order fairness definition and the receive order fairness definition is that honest notes can now deliver m one no later than M two, which means they can deliver in the same block. And we don't consider this to be a violation of fair ordering. So when I say block, it doesn't necessarily mean like the block in the setting of a proof of work block, there can be multitude of blocks inside, like a proof of work block that have their own equivalent ordering inside them. So the key idea that allows us to circumvent the impossibility to result from before is that we can now deliver these transactions with a nontransitive global ordering or a paradoxical ordering into the same block. So there's some really nice properties of our block order fairness definition. It's sort of minimal in the sense of our weakened definition, in that our protocols achieve the stronger receive order fairness definition, except when it's impossible to do due to this condor stay paradox that I mentioned earlier.
00:24:45.270 - 00:25:39.210, Speaker C: The second is that it's achievable in practice and it's also not made vacuous for most order manipulation attacks. So this is the sort of definition that we chose to run with. I'd now like to move on to just describing very briefly our fair ordering protocols. So we'll start with the permission setting in a protocol that we call Aquitos after the roman personification for fairness. So abstractly, Iquitos will function in three stages, the gossip stage, the agreement stage, and the finalization stage. So all of the transactions that are input into the system will go through each of these three stages before being finally output to the blockchain. So I'll talk briefly about what these three stages mean in the next couple of slides.
00:25:39.210 - 00:26:43.770, Speaker C: So the first stage that every transaction goes through is the gossip stage. So in the gossip stage, honest nodes broadcast transactions that they're received to all the nodes and at the same time honest nodes store broadcasts from all of the other nodes in local logs that contain their views of other nodes broadcasts. So for example, local log subscript I, superscript J will contain node I's view on how the transactions were received by J. And we use the gossip stage to guarantee that honest nodes have consistent local logs. So we use standard broadcast primitives for this, specifically the fifo broadcast or the first in first out broadcast, which can be realized from the very standard reliable broadcast primitive. The second stage that every transaction goes through is the agreement stage. So in this agreement stage, we have the nodes agree on which local logs to use to order a transaction.
00:26:43.770 - 00:27:44.370, Speaker C: So from the gossip stage we know that the logs are consistent, but each node may have a different nodes logs or a different set of nodes logs. So the agreement stage sort of guarantees that all of the nodes agree on which of the nodes local logs to use to order a specific transaction. And this can be done using standard byzantine agreement primitives. So the agreement stage will guarantee that the honest nodes will use the same local logs to finalize their transaction. The third and final stage of our protocol is the not so cleverly named finalization stage, where nodes will finalize the output ordering and get retrieved, a fair ordering, from these local logs. So our finalization stage is leaderless and requires no extra communication. And intuitively, this is because at the end of the agreement stage, all of the nodes will have agreed on any data that they need to order a specific transaction.
00:27:44.370 - 00:28:42.098, Speaker C: So how does the finalization stage work? So the core primitive that we need to solve is, well, how do we order two transactions? So let's say we have two transactions, tx and TX prime. Then if many local logs contain TX prime before TX, then we'll say that TX is supposed to wait for TX prime to be delivered. And these relations between transactions can be viewed as a dependency or waiting graph, where we'll have vertices represent transactions and edges represent these dependencies. So an edge from A to B represents that the transaction B is waiting for the transaction A to be delivered. So this is when there's a clear winner between two transactions. So many local logs contain one transaction before the other. So what if there's no clear winner in these two transactions? So there's two problems to solve for this.
00:28:42.098 - 00:29:13.018, Speaker C: The first is that a graph may not be complete or even connected. This means that some of the transactions may not be comparable. So this is when there's no clear winner between these two transactions. We don't have an edge between them, so they're not currently comparable. And the second is that the graph may actually not be asyclic. So this is thanks to the condorcete paradox that we still need to get around. So the key idea to solve the first problem is to wait for a common descendant for transactions without an edge into the graph.
00:29:13.018 - 00:30:18.500, Speaker C: And once this common descendant arrives, we can show that any honest node will have any other transactions in this graph that will also be used to order the particular given transaction. So this is sort of a necessity to guarantee our safety or consistency condition and have all honest nodes output the same log. So now once this common defendant arrives, we order using the maximum number of dependents, and if there's the same number of dependents, we can use some predetermined ordering function. The second problem that we still need to solve is that these graphs can still have cycles. So to get a total ordering from our graph, we can compute the condensation graph by collapsing the strongly connected components. And then we can sort of use this key Idea that I mentioned before and deliver transactions in the same strongly connected component into the same block. So our permission protocol sort of requires n greater than two f over two, gamma minus one.
00:30:18.500 - 00:31:25.990, Speaker C: So in the easiest case of gamma equals one faIrness, we still require an honest majority for our protocol. And our asynchronous protocol requires n greater than four f over two, gamma minus one. So for gamma equals one, again we have n greater than four f. A cool sort of byproduct of our protocol is that it relies on very simple primitives like FIFO broadcasts, which can be achieved by reliable broadcasts, and Byzantine agreement, which are sort of weak primitives in the sense that they can be realized from any consensus protocol. So this sort of results in a very interesting observation, in that our techniques provide a general compiler that can take any consensus protocol and transform it into one that also provides order fairness. So I now like to talk very briefly about more recent work. The second paper that I mentioned on fair ordering protocols in the permissionless setting.
00:31:25.990 - 00:32:27.494, Speaker C: So so far, all these node orderings that we had were restricted to individual nodes. So every node got one saved vote at a transaction ordering, and that ordering was not influenced by anyone else. So if we had n nodes, then we had n orderings, and we could run this dependency graph based on those n orderings and extract the fair ordering. So our main strategy at a very high level to convert the permissionless setting is to use this so called player replaceability lemma to transform a permissionless problem into an analogous one in the permission setting. So this will allow us to use our finalization technique from the permission protocol to determine the final fair ordering. So we call this the player replaceability lemma, which I'll really only talk very abstractly here. So in the permission setting, each node, as I said, had one vote in its input orderings.
00:32:27.494 - 00:33:30.670, Speaker C: And if there's n nodes, there's n transaction orderings. Now, the player replaceability lemma will allow us to continue the transaction orderings from other nodes using proof of work mining or proof of stake. Essentially a number of orderings, let's say k will be fixed at the start of the protocol, and all of the nodes in the system, when they enter or exit the system, will add on to these global orderings with their own input orderings. So whatever receive orderings they receive, they will use their orderings to influence these k global orderings. And now the final fair ordering can be computed using a distilled version of our permissioned iquitos finalization algorithm. So this turns out to be slightly tricky because the adversary can now influence all of these k orderings instead of just the adversarial ones as in the permission setting. But I won't go into the details of how we solve that problem, but just a point to note.
00:33:30.670 - 00:34:28.850, Speaker C: So I'll start with a very intuitive single chain protocol, and in this, all of the nodes will mine a single proof of work longest chain. So I'll describe just proof of work for concreteness, but we'll say that it works with any longest chain protocol in general. So the K orderings will be taken from this single permission chain as like the modularization of the chain, which I'll explain in just a bit. So here we'll split the single proof of work chain into modular chains. So, for example, in this diagram, we have three modular chains, the blue one, the green one, and the red one. So all of the blue blocks are in one modular semantic chain, all of the green ones are in another, and all the red ones are in a third chain. So intuitively, although the proof of work continuation is on top of the previous block hash, each block will logically follow a different block.
00:34:28.850 - 00:35:29.234, Speaker C: More specifically, it'll follow the previous block in its own modular chain. So for example, here, if you look at the second blue block, it's mined on top of the red block, so its hash is included in its proof of work mining. But it's going to logically follow the previous blue block in terms of what transactions it should include. So in this example, we'll end up with three modular chains. We'll have the blue chain, we'll have the green chain, and we'll have the red chain. A transaction will be mined into all of these modular chains, which means that each transaction will be mined a total of k times if we have k modular chains, and each of these modular chains will represent an ordering of transactions, and we can sort of use these k modular chains to extract out the fair ordering. So these k modular chains can be thought of as k virtual parties in a permission protocol.
00:35:29.234 - 00:36:27.926, Speaker C: So we show that this is sort of equivalent to thinking about these as virtual parties and extracting the fair ordering using just the permission protocol that we had earlier. So this will sort of now allow us to use this iquitos finalization technique to compute the final fair ordering. I'll also note that we have a second, more parallel protocol design where we mine the k chain simultaneously, using a p for one or k for one. Mining trick from previous literature. This protocol is very intuitive, but our proofs are somewhat complicated. So I won't go into too much detail here, but effectively all these nodes will mine these k chains simultaneously. And we can now use these k chains to extract out a fair ordering, because each of these chains will represent one vote, as you can say, of transaction ordering.
00:36:27.926 - 00:37:45.380, Speaker C: So we'll have k votes in total, and we can again use this permission style technique to extract out the fair ordering. All right, so that sort of concludes my discussion on our fair ordering protocols, and I'd like to move to some really cool applications where we think there's a lot of scope. So first I'd like to talk about this incredibly powerful property, which we call soft ordering, which comes as a direct consequence of our fair ordering protocols. So we show how this can lead to the so called zero block confirmation, where transactions can be securely confirmed even though no block has been mined that contains that transaction. So to see why in any fair ordering protocol in a synchronous network, if a transaction tx prime is seen by an honest node more than two delta time after Tx, where delta is our network synchrony bound, then any fair ordering protocol will always order Tx before tx prime, because all of the honest nodes will have received TX before. So this holds true even in the permissionless setting. And here it is that its true power can be seen.
00:37:45.380 - 00:38:44.638, Speaker C: So our protocols will achieve this property of soft ordering for delta equals one. But if we're satisfied with a weaker fairness definition like the separation base that I described earlier, then we can modify our protocol a very straightforward way to achieve this property for any known delta. So in any synchronous environment with a known delta value. So this sort of results in a very powerful observation in that honest nodes can confirm transactions within this two delta time if no conflicting transaction is seen in this time. And they can do this because the underlying fair ordering protocol will guarantee that any conflicting transaction that arrives later can never be ordered before. And I'll emphasize that this can be done without a single proof of work block being mined. And still we can provably show that this cannot be displaced later by a conflicting transaction.
00:38:44.638 - 00:39:44.680, Speaker C: And since honest transactions will not have a conflicting transactions or double spends, this will allow them to be confirmed by nodes locally in two delta time. So I'll emphasize this again, is that the transaction is not yet mined and it's not really globally confirmed, but a node can still locally or soft confirm the transaction with the guarantee that it will not be invalidated. So essentially, this is very powerful in that we're predicting something about the future, about the future global transaction ordering without it having been done by the entire network. So, to see why this is sort of useful in real world, let's look at an everyday purchase example. So let's say we have a user, Alice, who loves coffee and is trying to visit his coffee shop owned by Carol. And Alice orders the coffee and pays for the coffee in bitcoin. She takes her coffee and leaves the coffee shop in a couple minutes.
00:39:44.680 - 00:41:06.718, Speaker C: Now, for Alice's transaction to be confirmed by the network, it could take bitcoin like a couple hours or like an hour at least. So in this time, Alice can try to double spend her coins, or try to bribe a miner to order her double spend transaction before. And basically, there's no way for Carol to prevent this, unless she has Alice wait for the total confirmation to receive her coffee. So the total confirmation is in like an hour to receive her coffee, which is completely impractical. So what usually happens in practice is that, well, Carol can wait for a small confirmation period and see that there was no conflicting transaction, and then give Alice her coffee. But here, if the underlying protocol is not really a fair ordering protocol, then this doesn't really guarantee that any conflicting transaction can never be processed before and invalidate Alice's purchase. Furthermore, if you have an adversarial or selfish minor, then these sort of attacks can be done in like ten minute intervals or 20 minutes intervals with a sufficiently large processing power of the network.
00:41:06.718 - 00:42:15.862, Speaker C: So there's sort of no guarantee. But these ad hoc techniques try to use a small confirmation period to still be fine with everyday purchases. But the crucial point here is that if you use a fair ordering protocol in this blockchain underneath, then if you wait for this small confirmation period of two delta, then you will be guaranteed that no matter how the network acts in the future, whenever it's confirmed in like an hour or 2 hours, this Alice's transaction that you use to buy her coffee will never be invalidated by a double spend transaction. So this is also very powerful for so called latency reduction techniques. So there's a long line of work in recent literature solely focused on scaling blockchain protocols by reducing their global confirmation latency. So all of them reduce this global confirmation latency by the time in which all of the nodes have agreed on where to place this transaction. So our work sort of solves the latency problem in a completely different way.
00:42:15.862 - 00:43:45.806, Speaker C: In a fair ordering protocol, honest nodes can locally or soft confirm a transaction without a single block being mined. As I said, basically, however much you can reduce the global confirmation latency in previous protocols, it's impossible to do it without a single block being mined, which is something that our protocols can achieve. Again, I'll emphasize that it's not that it's globally confirmed by the entire network, and you don't know the actual exact placement of the transaction, but you're still convinced in that you can predict the future of no other conflicting transaction will be placed earlier. There's some other works like Thunderella, which give fast confirmation similar to ours, but only in the optimistic case, and they'll revert to standard bitcoin latency whenever there's a problem. So our notion of two delta soft confirmation is comparable to the best latency and permission protocol, like sync hot stuff, for example. So just to summarize this talk, our work is sort of the first to formalize a fair ordering property that's useful for decentralized finance. Order fairness, we think is very important for many blockchain applications, in specific those related to financial derivatives.
00:43:45.806 - 00:45:09.120, Speaker C: We think the space is still emerging and there's a lot of more research to be done here, but I'll end with just a few examples that we thought of, of where fair ordering can be beneficial. So as I described earlier, fair ordering can be very helpful in decentralized exchanges to prevent front running and arbitrage attacks. And it'll sort of ensure that users get a fair transaction prices instead of adversarial ones, or even like a random transaction price depending upon the ordering. Fair ordering can also be used to conduct fair initial coin offerings or ICOs in a first come first serve basis. You can also have incentives from the developer, like a better buy price for the first hundred or 1000 tokens, to encourage people to get first in line. Fair ordering can also be useful for fair auctions, so that you can no longer temporarily censor bids received before the closing time and claim that they were received, let's say, later. So as I said, these are just some of the applications that we think fair ordering protocols can be used, and the space is very emerging at this point, and we see a lot of research being done in this space, as well as a lot of cool applications that can be taken forward.
00:45:09.120 - 00:45:33.080, Speaker C: With that, I'll sort of end the talk. I hope you had interesting insights from this fair ordering talk. Thank you. I have posted my Cornell email address as well as a link to my website if you want to reach out and have a discussion on fair ordering protocols. Thank you.
00:45:34.810 - 00:45:57.230, Speaker A: Awesome. Thanks a lot, Mahima. Really appreciate you presenting and it's amazing how you can take these such complex topics and break them down to be so manageable again. I really want to thank the IC three community for joining us. Really want to thank Sarah for helping set this all up. I dropped Mahimna's Twitter into the chat. I'll do that again.
00:45:57.230 - 00:46:01.760, Speaker A: If people want to follow your research is the best way, just through the website here.
00:46:02.130 - 00:46:17.810, Speaker C: Yeah, I think that's a reasonable direction. You can also leave in my Twitter as well. Also, feel free to reach out to me over email. I've also listed that. Happy to always hear questions. Perfect.
00:46:17.880 - 00:46:27.320, Speaker A: Yeah, really appreciate it. And Sarah, if people want to follow IC three and all the exciting things that you're working on and other events that you're hosting, where's the best place to follow you?
00:46:29.210 - 00:46:39.686, Speaker B: So IC three's Twitter tends to be where we announce things first, and then any events or research will eventually end up on the IC three website. So both places are good. But if you want news first, our.
00:46:39.708 - 00:46:42.990, Speaker C: Twitter is where to go. Perfect.
00:46:43.060 - 00:46:56.090, Speaker A: And I just dropped both those into the chat. And yeah, that concludes our virtual meetup today. I really want to thank everyone for joining us, and I hope you have a great rest of your days. Bye.
