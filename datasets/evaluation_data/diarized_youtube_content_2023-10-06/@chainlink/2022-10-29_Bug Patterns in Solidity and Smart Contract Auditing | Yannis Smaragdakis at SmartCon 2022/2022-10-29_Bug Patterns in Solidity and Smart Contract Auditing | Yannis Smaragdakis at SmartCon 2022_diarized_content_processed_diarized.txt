00:00:08.730 - 00:00:28.034, Speaker A: Thank you. Thank you for having me. So, I'm Janice. I'm with DDOB. As you just heard, we are a security company in the web three space. So what does that mean? What do we do? Well, we certainly do auditing, like all security companies, but we also have lots of technology. And I'm going to talk a little bit about our technology vulnerabilities.
00:00:28.034 - 00:01:08.706, Speaker A: We've found in the past advice that we have for auditing to all our clients or to clients to be, and we only have 15 minutes, so it's going to be exciting, but you're in the wrong room because I'm going to demand your attention for the entire 15 minutes. So let's see if we'll make this. So, DDoB, we do security, but most people, unless they've worked with us, what they know us from, is contract library. It's a service that we've been running for the past four years. It decompiles all deployed contracts on Ethereum and related networks. And basically it's the smart contract security analyst's most trusted tool. So people who do security, especially people who analyze hacks, they use us a lot.
00:01:08.706 - 00:01:52.110, Speaker A: So you may have seen us on Twitter, when people use things, they analyze hacks. Contract library is this blockchain explorer over here. So I don't have time to give you a demo, but please visit contract library if you haven't already, and if you have security needs. Now, we are a security company, which means we analyze code, and obviously we do it manually, but we also do it through automated techniques. So we have algorithms for analyzing code, and that's our core DNA, that's our research and technology as a company. And very, very briefly, what we do is we have developed our own analysis algorithms. They're specified as many thousands of rules that build up a progressive understanding of the program.
00:01:52.110 - 00:02:52.062, Speaker A: And here is one sample rule that says this loop is bound by that variable and it's written in a language that's kind of exotic, but we build our logic in this rule based language, and that's how we have our technology understand what smart contracts are trying to do. So how do we commercialize this? How do we develop this technology and how we deploy it? So right now, we have this watchdog system built on top of our contract library infrastructure. And Watchdog is actively looking for vulnerabilities. And we have two major customers so far. They're both aggregators. So we are monitoring protocols on behalf of those customers, like 17 protocols in one case, 18 in another, and by next month, by the end of October, we hope to offer the watchdog for individual protocols to sign up now. Watchdog has been behind many past vulnerabilities, many tens of vulnerabilities, but actually nine of them are well documented because they got public bounties.
00:02:52.062 - 00:03:36.130, Speaker A: And we've had several vulnerabilities that have gotten pretty good press. Lots of stories since the beginning of 2021. And the biggest one is one that I'm going to talk about, the phantom functions vulnerability. And basically those nine public bug bounties have gotten us a total of 3 million or more in bounties already. So that's been pretty significant, of course, many, many more vulnerabilities that were kind of silently disclosed or not worth doing very much about. Now I want to give something very interesting to just bite, to have something to take from this talk. So I'm going to show some code.
00:03:36.130 - 00:04:07.514, Speaker A: And what am I going to show? I'm going to show the two simplest code patterns that have actually gotten us high value vulnerabilities in solidity. So these are dead simple and they are behind bugs. And one of them is entirely trivial. So the first one is entirely trivial. If you've ever written solidity code, you're probably aware of it, but it has been behind one actual vulnerability. In deployed contracts. In most object oriented languages, if you write this fun, it's the same as the sync fun.
00:04:07.514 - 00:04:53.610, Speaker A: Well, not in solidity, because in solidity this fun results in an external call and the message sender changes. So if you have any access protection based on the message sender, that's pretty dangerous right there. So if you've allowed this font to call your own function with a, this pointer. So this was behind an actual vulnerability. Very, very simple bug pattern that was behind the vulnerability in contracts that had money. Here's the bigger one, which is also a simple bug pattern. So back at the end of January or early February, we disclosed probably the largest would have been hack in history.
00:04:53.610 - 00:05:19.134, Speaker A: It would have been valued at over a billion. And it's based on something that we call phantom functions. That's something that we named and it's very, very simple. So the code was something like this. The contract has a deposit function that does a transfer from in a safe way that's perfectly safe in solidity. You just get money from the message sender. And to do the transfer from the message sender has to have pre approved.
00:05:19.134 - 00:05:55.470, Speaker A: The contract has to called approved before and it had a second path. That's deposit with permit. And that one you may have used it. It's an alternative way to give approval to someone to spend your money, you just sign an external certificate. So you do a permit, you use off chain signatures and then you just supply there the signature and then you do the transfer from. And internally the permit will either fail or it will actually do the approve that allows the transfer from. So where is the billion dollar bug in this code? It looks perfectly safe.
00:05:55.470 - 00:06:45.146, Speaker A: I want you to visualize for 1 second, what's the definition of the permit function for the west contract for the wrapped ether contract, which is the top ERc 20 token in ethereum because it wraps ether itself. So what does permit look like for wrapped ETH? Imagine it for three, two, one. Well, there's no permit. Okay, then it will fail, right? No, because there's what we call a phantom permit. There's a fallback function. There's a function that catches all calls that are not handled by existing functions. And what it does is just deposits ether that got passed.
00:06:45.146 - 00:07:19.980, Speaker A: So the important thing here was that the function is not reverting. You can call permit unwrapped ether and it will not revert. It will not stop the transaction right there. It will just silently fail. And let's go back to the previous code. Okay, well, it silently went through, it didn't revert. So why does the transfer form go through? Because this contract has another path and about 8000 customers have given approval because they have used this other path in the past.
00:07:19.980 - 00:08:24.186, Speaker A: But now I can steal their money through the bottom path, which silently passes permit and transfers from anyone I want, not from the caller. So that's a very, very simple bug pattern that's behind an extremely high value vulnerability. And obviously the simplest the pattern, the higher value the vulnerability. So with this, I'm going to go into the second part of my talk for however much time I will have for it because this is kind of an open ended part and I will talk a little about writing what I might call correct or secure, but really it's well, auditable code. So that's the advice that we would give as auditors to our clients or to anyone else who wants to employ good auditing services and just the top level bits. And by the way, catch me the rest of the day and I will be around. And I also have my email at the final slide as well as the original as the initial.
00:08:24.186 - 00:09:10.178, Speaker A: And do send me email if you want to follow up or talk to me afterwards because I'm not going to exhaust this topic by any means. So there are some unpleasant truths in smart contract auditing and the first one maybe it's kind of obvious, but really not at all. It's very hard to internalize. Auditing will not catch all of the bugs. But even worse, auditing is not even the best way to find many kinds of bugs. For many kinds of bugs, like for unit mismats, the best way to find them is like simple unit testing. There's no way like a human will be a million times slower just trying to understand the code compared to writing good tests.
00:09:10.178 - 00:09:51.782, Speaker A: So it's not always cost effective. So what's auditing really great for? Auditing is not good for finding what's going to go wrong with real normal use of a contract or any program. It's good for finding what can go wrong with really maliciously crafted inputs. So auditing is unique in that it combines an understanding at many, many different levels. You look at things that can go wrong in the low level code. You look at things that can go wrong in the specification, the protocol, financial level attacks. No one can do this as well as an experienced auditor.
00:09:51.782 - 00:10:23.714, Speaker A: So that's what auditing is for. Now, the second inconvenient truth here is that not all audits are equal. And there is a wide range of confidence. An audit does not stop when we think we are confident. It stops when the time allocation is over. So confidence will never be 100%. I've audited many, many tens of protocols, some very visible ones, some very prominent ones.
00:10:23.714 - 00:11:02.910, Speaker A: Anyway, let's leave it at that. And confidence is never 100%, but it can get close to 100%. It can get pretty high at the same time with the same allotted time. If the code is structured in good ways, then I can get a lot higher confidence than otherwise. So there are standard practices, and I'm sure that, you know, good coding practices, documentation, comments, informative variable names, et cetera. Very good practice. Top practice is to have well tested code before you go to auditing and a great communication channel.
00:11:02.910 - 00:11:26.322, Speaker A: If throughout the audit we can ask questions, we can communicate with the developers. That's best. But most top quality projects do. Okay. And these are kind of vague, so let me try to make it a little more concrete. What I mean by good comments. For instance, the biggest difference making maker in understanding code deeply is invariance.
00:11:26.322 - 00:12:03.234, Speaker A: And by invariance, I mean properties that should hold no matter what. And I'll give you examples. And I'm trying to appeal to your intuition. I'm going to give examples not just in this slide, but also in follow up slides of different kinds of invariants and things that we have seen that really give us a lot of insight, and then we can check for violations and can do a great job as auditors. So, for instance, we can have some temporal invariants, some state invariants. We only get to this internal function with lock called before. That's great.
00:12:03.234 - 00:12:44.734, Speaker A: I can analyze for that, I can look for that, and I know what guarantees to expect when I get to this point. But I can actually also check that there are only seven ways to get here, and all of them satisfy this invariant, or this is only reachable from methods that are called by this contract. Great invariant. A very common invariant arises in pretty much every audit. There are contracts that are not supposed to ever have token or ETH balance, native token or ERC 20 token balance. That's a very, very common invariant. It needs to be stated.
00:12:44.734 - 00:13:13.980, Speaker A: It's very useful for the auditor for this to be stated in comments in the code, and not to have to be discovered. Other invariants, functional invariance. This quantity is denominated in the last of the tokens in that array. So we have an array of tokens, and there's one quantity that goes with it. There's a unit that goes with it. Well, what are the units of that? Well, this gives me a lot of information. If I have a comment like that.
00:13:13.980 - 00:13:45.510, Speaker A: When you try to do smart things, if you say things like this quantity, if it's positive, it means the input amount, if it's negative, it means the output amount. Very useful to put in a comment instead of letting us read it from the code and doubting whether that was your intent or not. The scale, that's pretty obvious. What's the scale of a quantity? Other kind of interesting. Invariance. Structural invariance. And these are particularly important at the protocol level.
00:13:45.510 - 00:14:15.438, Speaker A: I wrote a contract and I wrote a collection of contracts. I wrote an entire protocol. Some contracts are strategies. Strategies have some obligations. If you write very clearly in the documentation that the strategy, a strategy has to override functions, reinvest and report profit, that's extremely useful. That's the kind of property that will enable an auditor to have much deeper insights. Understand what you expect in the code.
00:14:15.438 - 00:15:04.750, Speaker A: You have it in your mind. It should be stated, another property, if a strategy issues rewards, it should override the reward token function and the reward rate function. This thing of being coordinated between two different functions, that you cannot just change one without changing the other. And that's kind of a common source of bugs. That's very, very useful. And of course, there's many, many more examples that I can give here are actual examples from code that they are comments that are extremely useful, and we had sometimes to invent them, and some other times we have actually seen them in the code. So you have sub until zero, and it gives a different behavior depending on whether x or y is greater than the other.
00:15:04.750 - 00:15:49.526, Speaker A: Or we have something like this liquidity lower d eight when you have some protocol like uniswap v three, and then you need to know what's the exact definition of this quantity? And I'm not going to go into that in more detail because I'm almost out of time. Similarly with this, it may require a five line comment, but it may also require one day of auditing to establish this property if it's not clearly communicated. And the same with other local properties that are particularly interesting. So here's the final inconvenient truth of auditing. Auditors are not the owners of your code. They're not the owners of your project. You are the owner.
00:15:49.526 - 00:16:28.840, Speaker A: The auditor is not committed. The auditor is involved in the old joke about the chicken and the pig. So an auditor can help you see things a little differently, but they're on your side. You have to follow any question, any issue raised, and have to follow it to its logical conclusion. An auditor may catch one little inconsistency. It's your job to find three more based on that, if they exist, of course. So you have to always keep in mind that you have ownership and work with a good auditor to help your security.
00:16:28.840 - 00:16:38.340, Speaker A: So that's all I had to say. Again, I'm Janice. This is my email from DDOB and thank you for all the bugs that keep us in business.
