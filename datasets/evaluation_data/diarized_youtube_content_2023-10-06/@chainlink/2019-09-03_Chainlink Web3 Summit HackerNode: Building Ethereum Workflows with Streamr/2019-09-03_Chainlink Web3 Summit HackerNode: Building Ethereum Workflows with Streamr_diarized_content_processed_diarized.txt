00:00:07.440 - 00:00:47.150, Speaker A: Hi everyone. We have here some people from people from Chen that I haven't met yet, but we can meet afterwards, you, some of your colleagues. Hi. So the I'm going to present quickly streamer show quickly the integration with the chain link and maybe we can have a demo of our drag and talk editor to work with.
00:00:48.480 - 00:00:52.950, Speaker B: So I.
00:01:04.600 - 00:02:09.850, Speaker A: Speech is focused on smart city, but you can think about any other kind of iot devices you can apply to anything. So if you think about smart city, you have lots of iot devices that contain useful data. It's not only cars, it's also roadside units and others. And it would be great if they could collaborate, if they could talk to each other, exchange data, trade data with each other, utilize micro payments and trading. The data and data could be used for many useful things, like to warn you of the collision ahead, to warn you of the changed road condition, to find you the best price of fuel or charging on your way. However, if you look on the reality of a current smart city, what you see are many iot platforms that act as a silos. And these are preventing devices from collaborating together.
00:02:09.850 - 00:03:17.280, Speaker A: And these iot platforms are typically based on proprietary solutions. Very often when they're working, when you decide to work with one of these, and there is no open ecosystem where all these devices could exchange their data and where they could collaborate. And if we briefly look into the history, we can find a parallel with the beginning of Internet. So back then you also had computers connected to intranet based on proprietary solutions that came the iot platform. And these intranets were not able to talk to each other. And what had happened? Someone had to develop nails or protocols to connect all the computers into Internet, as we know at night nowadays. So if we want to inspire ourselves here, and if you want to find a solution for the iot city, the solution has to be open, it has to be permissionless, and you have to use Naruto protocol and standard for the communication between the iot devices and the smartphone.
00:03:17.280 - 00:04:11.536, Speaker A: And also in addition, the successful solution has to make data globally available in an open and secure way for the streamer network. It's using cryptography instead of silovolves to keep the data safe. And the second aspect for the success is to enable data exchange or value exchange between devices. So you cannot do this, of course, with bank accounts because they are only for humans. So that's why iot and blockchain is great match. We can have a value exchange between devices in a form of cryptocurrency on the blockchain. Actually this economical aspect is very important because it motivates the data owners to share the data they have from the devices in exchange for the money they.
00:04:11.558 - 00:04:12.240, Speaker B: Receive.
00:04:15.400 - 00:04:35.172, Speaker A: For the streamer network. It's a decentralized peer to peer network. The model is publisher to subscriber. You can publish data to any topic. We call it stream. It's designed with a low latency in mind and scalability. You can scale it by adding new nodes.
00:04:35.172 - 00:05:21.620, Speaker A: It's an open ecosystem. Anyone can run the node, and there is no sense of point of control or no sense of point of failure, which makes also the network less prone to cyber attack. So if you think about this network, this could serve as a medium in a smart city where all the devices could exchange their data without any central party in the game. And the second part of the technology is the streamer data marketplace. So any device can offer its data in the form of live data to be sold on the marketplace. And any other device can purchase this data. Once it's being purchased, it's always a time based subscription.
00:05:21.620 - 00:05:29.450, Speaker A: So you can buy subscription to your stream for some time, one day, 1 hour, one week and so on.
00:05:34.460 - 00:05:35.124, Speaker B: It.
00:05:35.262 - 00:06:52.612, Speaker A: And of course the marketplace is decentralized, as you may know, it's running on Ethereum blockchain, and we are contracted to record the asset, right, and to record the settlement when the data is sold. So this is our recipe, how it improves functionality of a smart city. And to showcase this, we've done recently a pilot in a company with lens code group providing hardware, wallets for cards and also for other devices, and a Porsche that provides us access to the data in the car. And pilot goes as following. So you had cars selling their data via the streamer network. Some were equipped by the car OEM with the technology, some have been retrofitted with a tablet or smartphone, and they've been sending the data to the streamer network and offering them on the marketplace. And then you have different independent AI companies buying the raw data from the car.
00:06:52.612 - 00:07:20.248, Speaker A: So the raw data, like speed, position, velocity, angle of the steering wheel, and so on, and these are processing the raw data and building their products on top of this data. So the problem that many companies have is they don't actually get access to data. They need to develop their products. And it's like a closed loop. If you have good products, you have good products, you have more customers. If you have more customers, you have more data, and then you can even improve your product. Furthermore.
00:07:20.248 - 00:08:27.860, Speaker A: But you have to start somewhere. So we have different companies focusing in different fields having different products and they can resell the higher level data back on the marketplace, not only for cars to profit from it, but also for other devices like roadside units and animate speed signs and so on. As you can see, what's interesting on this graph is that the back end part and the field part is overlapping because this is not only you can have node runners running the node, but you can also place the stream or network node directly into car to support the network. So if you have resources in the car in terms of CPU power and in terms of connectivity, even if you go waste it, you can utilize and support the network and eventually earn some money for running the Nopus. This is the overview of the marketplace for the streamers. I just overview. The main part is the streamer network and the data marketplace.
00:08:27.860 - 00:08:34.180, Speaker A: What we'll see now from Duncan will be engine and editor.
00:08:45.100 - 00:09:20.164, Speaker B: But basically I'm not going to demonstrate how to use Ethereum with streamer. So I'll demonstrate two modules, one, well actually three. One for compiling solidity code and deploying it. One is for making Ethereum calls to compile modules and then a get events module which is notified when events happen. I'll show you how that works with the streamer canvas. I'm using the example of a stock picker. So this is a simple Ethereum contract I have.
00:09:20.164 - 00:09:36.808, Speaker B: So basically there's an owner of the guy who creates the contract. The owner can update the price. And then when you update the price you can see a price updated event and actually include the index symbol, the symbol twice here because the index symbol would actually sort of hash of the.
00:09:36.814 - 00:09:37.864, Speaker A: Symbol if you do it index.
00:09:37.912 - 00:10:32.876, Speaker B: So you won't actually see it on the output. But I have the streamer canvas, so how do I get that? Let's take a look at the canvas here. That's fine. Okay, so this is the module to deploy code. So the way that works is you enter your code here, let me move this. So here, that price sticker that I had in vs studio, that's the code for it. It's already been deployed, but I can redeploy it also, in which case I'd have to change the inputs probably.
00:10:32.876 - 00:11:05.940, Speaker B: I think all these connectors will disappear. So I'll save it for now. But it's been deployed on the Robson network. And you can choose which network you're using by looking at the options over here. So right now it's running, you press stop, then it goes back into like edit mode. And over here you see the options it's running on the Robson network. And I should say also you set up your Ethereum account in your preferences.
00:11:05.940 - 00:11:36.110, Speaker B: So this key over here is actually specified in the preferences section. So basically you give us your private key. So it's not recommended that you throw off the ether on these keys. That's the value of the key. So you just copy and paste your private key here and that's where that's the last key in the previous candidate comes from. Make up a private key.
00:11:38.720 - 00:11:41.870, Speaker A: Well, I mean private key.
00:11:55.960 - 00:12:25.890, Speaker B: And one of the things that I set up in this demo is a stock figure. So streamer allows you to buy and sell stream data. So the way you set that up is also with this Gui. And in my case, I'm going to be taking the output. So this demo will be compiling code for the stock ticker, making Ethereum function call with that module and then looking to the output. And the output will actually be pumped to a streamer stream. And so I've created a streamer stream over here with symbol timestamp and price.
00:12:25.890 - 00:13:13.100, Speaker B: That's where you set up your streamer stream. So when we go back to the module here, we have, this sends a stream over here. When you type in the stream name over here, it autocompletes and finds the stream with that name. So one called test stock ticker is the one that I selected. So I'll run. So just to go over all the different modules, this one does compile and deploy once it's been deployed as a contract output. The contract output is piped into both the Ethereum call, which tells us contract to call, and this get events module.
00:13:13.100 - 00:13:56.156, Speaker B: And once you give it the contract, it automatically fills the event parameters. And then for the Ethereum call module you can call both static view methods and transactional functions. You specify your Ethereum key if it is a transaction. And as inputs over here, I just have a constant input, which is the word streamer, some fake soft ticker name. The clock over here actually output the timestamps every 5 seconds. But I've turned off the driving input, so driving input means that it'll send the new value, then it'll trigger the.
00:13:56.178 - 00:13:57.724, Speaker A: Module that send it to.
00:13:57.842 - 00:14:36.776, Speaker B: So in this case I've turned off the driving input that I want to drive it from this thing down here, and that's where I'll actually put in the price and way. So that's a button over here, and this is actually a driving input. When I press the button, that should trigger this module, create an ethereum transaction, and then this module independently from this module, listens to new data from this contract. So if I press start, let's see what happens. Should be live. And so when I press this button now, that should actually trigger ethereum transactions. These are transactions I've done in the past.
00:14:36.776 - 00:15:12.132, Speaker B: So if I press this a few times now, this is the ether scan for that account. And you see that we have two of the transactions over here 1 second ago. So these transactions were just called by pressing that button, triggering the Ethereum call module. And hopefully when these transactions come back, we should see them in the get events module. I've seen that there's some lag, actually. So we're using infura and it's possible that there's some lag in between. We use websockets to receive the event.
00:15:12.132 - 00:15:46.240, Speaker B: So it's possible there's some lag there. But eventually we should see the data in the output here. So. Right, so when it's complete, you should see output over here. And also you should see it piped to the center stream. So with inputs, you can only have one input, but the output can be piped to multiple modules here. So in this case, we're piping the output to a table and we're also piping it to the center stream.
00:15:46.240 - 00:16:28.124, Speaker B: I've seen missing events. Also, I'm still debugging this, but it may or may not come. I think it will. But you be able to refresh or something. Um, that's okay. No, that was at 351. So I noticed that.
00:16:28.124 - 00:16:42.544, Speaker B: But I've been noticing this before that there's some either missing ticks sometimes or sometimes like a bunch of them come at once. I'm still debugging this, actually. I think it might be Fiora. That's actually not setting the page. But I noticed it the other day. But anyway. Yeah, there it goes.
00:16:42.544 - 00:17:08.808, Speaker B: Now it's coming through. That might have gotten all the ones that are missing. So sometimes there's a bit of lag. So these are the transactions that were just triggered. And you can see that we actually decode the events as much as possible. So in the case of index event parameters, they're only posted as a byte 32 hash. In the case of an index string, for example, you'll just see the hash of it.
00:17:08.808 - 00:17:33.776, Speaker B: But because I'm posting the string twice, once is an index parameter and once it's a non index parameter. We see both over here. And then this is timestamp generated by the clock module. And the price that I put over here, the price that came from this over here. And then if you go to the stream that I was piping to. You should see the data there as well. I had to send the stream module.
00:17:33.776 - 00:17:40.310, Speaker B: And then over here, if I look at the data, you see the new data points over.
00:17:44.520 - 00:17:46.740, Speaker A: You can turn it like so. It doesn't.
00:17:52.680 - 00:18:36.310, Speaker B: So then you can see this is the actual stream for all the. Yeah. Any questions about. That's how it works.
