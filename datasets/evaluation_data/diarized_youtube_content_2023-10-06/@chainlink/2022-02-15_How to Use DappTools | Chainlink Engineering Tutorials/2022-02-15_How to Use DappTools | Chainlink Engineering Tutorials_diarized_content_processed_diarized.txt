00:00:00.250 - 00:00:07.354, Speaker A: So maybe you don't know JavaScript, maybe you don't know Python, maybe you don't want to have to learn one of these languages to deploy your smart contracts.
00:00:07.402 - 00:00:08.766, Speaker B: You know how to code solidity, you.
00:00:08.788 - 00:00:44.650, Speaker A: Know how to do command line, you know Bash, you know Linux, and you're ready to deploy your smart contracts and you want to use those tools. If only you could. Well, you can. Daptools is a powerful minimalistic command line based tool to help you create, test, deploy and interact with your smart contracts. It was written with Haskell and is the primary tool used by the Makerdao team, the team behind the dai stablecoin. More recently the paradigm team has taken this and made a rust implementation which does the exact same thing called foundry. Today we're going to be learning about this fantastic Daptools tool.
00:00:44.650 - 00:00:48.182, Speaker A: However, everything that we teach you will also apply to foundry.
00:00:48.246 - 00:00:50.122, Speaker B: Just a couple of commands will be a little bit different.
00:00:50.176 - 00:01:10.558, Speaker A: Daptools is a great option for a smart contract development framework if you like minimalistic command line based tools. And you don't want to have to learn Python or JavaScript or any of these higher level languages to do your compiling and your deployment. Today we're going to learn how to make an advanced project ourselves using the Daptools starter kit which is in the smart contract kit repository.
00:01:10.654 - 00:01:45.246, Speaker B: So let's jump in and here's our agenda for the video is going to be first we're going to set up our coding environment. Then we're going to install some requirements. Then we're going to walk you through the quickstart, and then we're going to make a new lottery contract from scratch using Daptools. We're going to write it, test it, deploy it and interact with it. So let's first get our coding environments set up. I'm using visual studio code as my code editor. Link to it in the description to download it and get started.
00:01:45.246 - 00:02:11.154, Speaker B: Make sure you don't download visual studio. You want visual studio code? Visual studio is something different. You want visual studio code, not visual studio. Along with visual studio code I'm using the solidity extension. So just look for this little thing here, look up solidity and install it. I'm actually using a different solidity extension, but this one that shows up at the top by Juan Blanco. This one that shows up at the top right here is fantastic.
00:02:11.154 - 00:02:48.910, Speaker B: Additionally, I have a metamask with some testnet Ethereum in it, also some testnet link. We have a video on this to both install and set up metamask. If you need Testnet link, testnet ethereum, you can come here to faucets chain link, just put your address in and get both testnet link and testnet ETH. Once you have vs code open, you can hit file open folder and you can even do a new folder and maybe we'll call it dap test. Great. And then we'll go ahead and open it. Now if you hit terminal, new terminal, a terminal will pop up here and we'll be using this a lot.
00:02:48.910 - 00:03:16.522, Speaker B: I'm going to be using a screencast mode, so anything I type will show up on the screen like this. All right, great. Now that we have our coding set up, let's go ahead and download the requirements. Now if you're on a windows, a lot of the commands that we're going to be working with might not work for you. So I highly recommend installing WSL and working with WSL so you can run all the Linux commands. I'm working on a Mac, so all the commands you'll be seeing me do are going to be Mac commands. Now let's go ahead and get into the DAP starter tools kit again.
00:03:16.522 - 00:03:40.222, Speaker B: A link in the description to get this repo and work with it. The first thing we need to do is download some requirements. So we need to make sure we have git installed. Link in the description to install git you can make sure it's installed by doing dash version. You'll also need daptools installed so you can come to the daptools. GitHub repo link is in this, our Daptools starter kit repo. Look at that super cute logo.
00:03:40.222 - 00:04:10.822, Speaker B: And you can scroll down to installation. So first you would just need to copy paste this into your terminal and run it and hit enter. I've already done it, so I'm going to skip that and then same thing. Copy paste this into your terminal and hit enter. Once you've done this, you should have Dap sulk, Seth, Hevm and ETH sign in your terminal. You can check by doing DAP version and you should see something like this. You should also have the make command already installed.
00:04:10.822 - 00:04:41.190, Speaker B: This should be installed by default, but just to double check you can do make help and you'll see something like this. All right, great. Well, now that we have everything installed, we have all the requirements. Let's do our quick start. This is where we're going to just quickly show you the functionality of this repository and what it can do. It's a fantastic template for working with code and getting a project spun up. So we'll do git clone and we'll paste that address and hit enter and we'll see something like this.
00:04:41.190 - 00:05:18.350, Speaker B: And then additionally, if you want to work with the exact commit that this video is working with of this repo, what you can do is you can go to this commits, you can click this commit, copy this commit and do git checkout and then paste that commit. And now you're going to be exactly at the exact same commit we are for this video, but that's optional. Main is always going to be the most up to date branch anyways. And great. In the left here you'll see a whole bunch of files get pulled in. Let's do a quick walkthrough of what each of these do. The image folder is just for some cute daptools and foundry chainlink images.
00:05:18.350 - 00:05:54.022, Speaker B: The lib folder is going to be different libraries for external packages that we're going to be using like Openzeppelin and other chainlink contracts. Scripts is where we have a whole bunch of bash scripts or command line scripts for working with our contracts. Src is where we have all of our solidity code. This is similar to contracts folder in brownie or hardhat. Daprc is a configuration file similar to the hard hat config or the brownie config. Env example is an example env file which we'll get into in a bit. These git files are GitHub config files.
00:05:54.022 - 00:06:19.622, Speaker B: We have a license file. For the license of our code we have a make file which we'll get to in a bit. We have a readme which just has all the instructions, remappings, which we'll talk about in a bit, and shell Nix, which we'll pretty much ignore. Alright cool. But once you have everything installed, we can start working with daptools. So let's go ahead and CD into our daptools starter kit. We can compile all of our contracts by running DAP build.
00:06:19.622 - 00:06:54.446, Speaker B: Whoops. Actually, before we run DAP build, we need to run the make command in our make file. When we run the make command, we need to run this DaP update to download all of our external packages because right now some of them are blank. So let's go ahead and run make running make looks at the make file and just executes the first command it sees. And the first command it sees is DAP update. When you see a colon followed by a semicolon in a make file, that means this is going to be a command and this is the first command it sees. We could also just do Dap update, which does the same thing.
00:06:54.446 - 00:07:31.130, Speaker B: Now if we look in our lib, we see these are now installed. Now that we have installed, we can now run DAP build and we've now compiled everything to our DAP soul Json. We can also run tests. We either do DAP test, which is the DAP version way, or we can do make test because in our make file we have a test target which just runs DAP test. So make test or DAP test are going to do the same thing because our make file says hey, if you say make test, you're going to run DAP test. We could also run make build which runs DAP build. We could run make clean, which runs DAP clean.
00:07:31.130 - 00:08:00.322, Speaker B: You get it. So let's go ahead and run make tests and we'll run all of our tests here and we can see that they all are indeed passing right now. Now, I'm not going to be showing how to do the deploy in the quickstart, but as we go through building our lottery contract, we will get to that section. If you want, you can go ahead and skip ahead to the chapter where we work on actually deploying and interacting with these contracts. But that's the basic breakdown of what's going on in this repository. You can make all your contracts in here, add all your tests in here. The tests are in solidity.
00:08:00.322 - 00:08:28.206, Speaker B: They're not in JavaScript or Python or anything. These are tests right in solidity, but okay, cool. So you've git cloned this template and now you're ready to build some awesome smart contracts. Let's go ahead and start from scratch on what doing something like that would look like. Let's say we wanted to build a lottery contract. That's going to be the purpose of what we're doing here. So let's go ahead and create a new file in our source folder called Daplottery Sol.
00:08:28.206 - 00:09:04.970, Speaker B: Now, the contents of this file don't really matter so much. In fact, we're just going to borrow the VRF consumer code that comes pre populated to populate our DAP lottery. And we're just going to change this to DAP lottery is VRF consumer base and we're just going to change get random number to start lottery and that's it. What this solidity does is it imports the VRF consumer base from the Chainlink code. Definitely. Check out docs chain link to learn more about how the chainlink VRf works. We have a constructor which takes a ton of different parameters for working with the chainlink VRf.
00:09:04.970 - 00:09:36.130, Speaker B: And we have a start lottery function which starts our lottery using a request randomness call. And then the chainlink node has a callback function called fulfill randomness where it'll give us a provably random number. Obviously for a lottery. This isn't the full implementation of a lottery, of course, but it's definitely the starting pieces of one. Now that we have a contract, what is the first thing we'd probably want to do? Well, let's make sure it actually compiles. So we'll do dap build. And it looks like there were no compilation errors, so that's great.
00:09:36.130 - 00:10:19.346, Speaker B: There are a couple of warnings, but we can ignore those. Now you'll see at the top we're using this at syntax to import VRF consumer base daptools knows that this at sign is actually coming from our lib. How does it know this? Well, in our DaPRc we have this export DAP remappings equals catremappings text. And if we go into this remappings, we can see a little key here where it says at Chainlink slash equals Lib Chainlink Brownie contracts. This means that anytime daptools sees at Chainlink, it's going to look in Lib Chainlink Brownie contracts for any contracts. And that's exactly what we have here. Awesome.
00:10:19.346 - 00:10:57.214, Speaker B: So we've written a smart contract. What's the next thing that we want a framework able to do? Well, we definitely want it to be able to test our smart contracts. So let's go ahead and set up a test for DAP lottery. So in our Src folder we have a test folder and it has a number of different files in here. You'll see it has mocks utils and then these tests here let's look at counter test to get a good idea of what these tests are doing and what's going on with these, because this might be the first time you've actually done solidity tests. The first thing you'll notice is of course it's importing the contract that it's going to be testing. Right.
00:10:57.214 - 00:11:29.170, Speaker B: In order for solidity to test solidity, the solidity needs to know the solidity. This counter test file is pulling in counter. It's also pulling in this dstest test sol. This is one of these things that's in the library that we've imported. And in fact, if we look up dstest source test sol, we can see this file here comes with a number of fantastic functions like assert true to check to see if a condition is true. Assert true with different parameters. Assert equals.
00:11:29.170 - 00:12:21.770, Speaker B: Assert equals decimals. A whole bunch of different asserts in here for us to actually do our tests. And we also install this hevm from our utils folder. If we look in utils, we have this hevm Sol when you run your tests in daptools, daptools actually spins up a local hevm blockchain that has some functions that allow us to actually control it, like warp where we can set the block timestamp or roll where we can set the block number. This is obviously really helpful if we have any time or block based functions. So we import the two of those into our countertest. Now we have some variables up at the top, of course, but the first thing that gets run in any of our tests is this setup function where in this test we're setting up some time, we're setting up a new counter contract and we're also setting the specific time of the entire blockchain to some time that we wanted.
00:12:21.770 - 00:12:55.182, Speaker B: Then we have a whole bunch of tests. You can see we have test check upkeep, we have some test name, it does some stuff, and then we assert whether it's true or not. Daptools will just go test by test making sure things that asserts come out to be true. And that's it. So let's go ahead and design our own test for our DAP lottery. All we want to do is check to see if we can start the lottery. So let's go ahead, we'll create a new file called DAP lotterytest Sol and let's build this.
00:12:55.182 - 00:13:33.220, Speaker B: So SPDX license identifier, we'll say MIT. We'll do pragma solidity 0.8.0 and we'll call it contract. DAP lottery test is dstest. We want our DAP lottery test to inherit everything from dstest so we can have those assert commands. So of course we need to go ahead and import them. Import dstest test Sol.
00:13:33.220 - 00:14:11.770, Speaker B: So let's go ahead and create that first function, the setup function. The setup for all of our tests. We'll do function setup public. Now we're probably going to want to have a DAP lottery. So we're going to need to import that. So we'll do import DAP lottery Sol and we'll probably want it to be a global variable here. So we'll say DAP lottery public Dap lottery and then we'll say Dap lottery equals new DAp lottery.
00:14:11.770 - 00:14:54.342, Speaker B: And then we'll add the construction parameters for our DAP lottery. So if we look in DAP lottery, we see it takes a key, a VRF coordinator, a link token, and a fee. Well, where do we get those from? Well, as we know, when we run our test, it's going to be running on a fake local blockchain where none of these actually exist. There's no link token deployed on a fake blockchain that we just deployed from scratch. This is where our mocks folder is going to come into play. We're going to mock and deploy our own fake link token as well as our own fake vrf coordinator, which is necessary for the chainlink VRF. So the way we do that is at the top we're going to import our mock link token.
00:14:54.342 - 00:15:33.810, Speaker B: So we're going to do import mockslinktoken Sol we're also going to import mocks mockvrf cordinator Sol. And for those of you who have worked with Chainlink VRF before, you know that there's also an oracle component in here. So we're going to do import mocks mockvrf Oracle Sol. Excuse me, it's in utils. I guess it could be in mocks, but it's currently in utils. In any case, now that we have those, let's go back to see what we need. Okay, we need a key hash.
00:15:33.810 - 00:16:09.726, Speaker B: So we could really just give this anything as its key hash. So we'll just say bytes 32, public key hash, and then we'll just pass this as the input parameter. Since we're not actually going to sign it, it's just going to get defaulted to zero. Then we need a VRF coordinator address. We don't have that address, so we need to mock one. So up at the top, mock vrf coordinator public VRF coordinator Mock. And we'll do VRF coordinator mock equals new mock VRF coordinator.
00:16:09.726 - 00:16:40.790, Speaker B: And then we can check what the mock VRF coordinator takes as input parameters. And it looks like it just takes a link token. So we're going to have to mock that too. So before we do this, we're just going to do up at the top we'll say link token, public link token. We'll say link token equals new link token, like that. And then we'll pass the address of that link token to our VRF coordinator mock. Perfect.
00:16:40.790 - 00:17:13.766, Speaker B: And now we can do address VRF coordinator mock for our next parameter. Okay, great. What's next? Perfect, the address of the link token. We can do address of the link token that we already deployed. And finally we need a fee which for our tests we could set to really anything. So we'll just do un 256 public fee and we'll just pass that fee in here. Now that we have all of our setup done, we can go ahead and move forward with this.
00:17:13.766 - 00:18:09.820, Speaker B: Now we're just going to run one test. We're going to say function test lottery can start, right? Because we have a start lottery function that calls the chainlink VRF. First we need to send some link token to our newly deployed DAP token contracts. So that's pretty easy. We just do linktoken transfer address DAP lottery and then we'll give it, sorry, we'll give it 112-34-5678 910, 1234-5608 it's going to be one link token and then we'll make a request. Byte 32, request ID is going to be equal to our DAP lottery start lottery. And then we're going to assert true that the request Id does not equal nothing.
00:18:09.820 - 00:19:02.118, Speaker B: And what we can do to test this is we can do DAP test m and then paste this. The name of that test m stands for match. So we're just matching the name of whatever comes after the M and we're running it and it looks like we do indeed pass, which is awesome. Now we can go ahead and cheat and look in the VRF consumertest sol to see a little bit more interesting that second test that it has in there where we actually pretend to be the VRF oracle ourselves and call back with randomness to make sure the rest of our code actually works. So that's definitely something to check out as well. But it looks like if we run DAP test, all of our tests are passing, including the new tests that we just added from daplotterytest Sol, which is awesome. So we've created smart contracts.
00:19:02.118 - 00:19:41.570, Speaker B: We've tested our smart contracts. Now we want to go ahead and deploy the smart contracts. Now the way you deploy your smart contracts is with the DAP command create, so we can do DaP create and then the name of your contract, ours is DaP lottery. Now, if we run this right now, we'll actually run into an error. We'll get this error saying ETH from not set send from which account it's looking for an ETH from environment variable for us to be able to do all of this. The f from is going to be the account that you want to send transactions from. We are going to be sending from our metamask.
00:19:41.570 - 00:20:34.598, Speaker B: So we're going to come to our metamask, we're going to copy the address, and we could either do export f from equals and paste our address in here and then hit enter, or we could add it in a new file called our env, and we would do export f from equals and then paste your address in here. Now, we could run source env, which would activate our environment variables, but we don't want to do that because we'll have to do that every single time. So this is where again, our make file is going to come into play. At the top of our make file, it has this line called include env. This means whenever we run a script from the make file, it's going to automatically have anything from our env automatically dropped in. And it looks like I actually put it in the wrong folder. I'm going to just move it into the right folder here.
00:20:34.598 - 00:21:09.934, Speaker B: Okay, cool. Also, we could just say f from equals this and then run Dap create Dap lottery, and that'll do the same thing. Now, when we run this, we'll run into a different issue. We'll run into this weird call stack hem. But this is the actual error, wrong number of arguments. As we know, our DaP lottery takes a number of arguments, takes a key hash, a VRF coordinator, a link token, a fee, et cetera. So we'd have to add those afterwards as arguments.
00:21:09.934 - 00:21:40.486, Speaker B: So we'd add like key hash here, an address here, another address here, fee here. As you can see, these commands are starting to get pretty big. And this again is where our MiG file is going to make that process also a lot easier. Plus, these addresses might change across networks. The VRF coordinator might be different. On coven rinkby mainnet avalanche, the link token is going to be different. So we want some way to deploy to different networks and work with different networks easily.
00:21:40.486 - 00:22:32.746, Speaker B: So if we go to our make file, we can actually see there is a deploy command which runs a command, right? Because we have the colon semicolon, which means anything after is going to run a command called scripts deploy sh. So if I run make deploy, it's going to run whatever is in deploy sh and it looks like it's getting a little confused and very angry, and that's okay. So if we go to deploy sh, we can see what's actually in this file. First, we run this set Eo pipe fail. This just will kill any command that breaks. We run this common sh which goes into this common sh folder and pulls all these environment variables and all these different commands into our deploy script. We also pull in this helper config sh.
00:22:32.746 - 00:23:04.354, Speaker B: If we look in here, we can see a whole bunch of different arguments and parameters. Now this is the file that we have that updates all of the arguments and parameters here. So if you see, if you scroll down a little bit, we have some if then statements. So if we're on coven, these are the variables that we're going to use. If we're on rink B, we're going to use some different ones. If the contract is the counter contract, our arguments are going to be here. If the contract is price feed consumer, arguments are going to be price feed.
00:23:04.354 - 00:23:51.622, Speaker B: If the contract is VRF consumer, those initial arguments are here. We're going to add one more now for our DAP lottery, saying, else if contract equals DAP lottery, our arguments are actually going to be the exact same as VRF consumer. So we pull in our helper config stuff, we look for a contract name, and we run deploy contract with the arguments. And again, if we're looking common sh, there is a deploy command right here that does all this stuff. And if you look, it does a whole bunch of wonderful stuff. But if you look down here, it finally runs exactly that command we were talking about, DaP create, name the contract, the arguments. It does some gas stuff and then some RPCRL stuff, which we're going to talk about in a second.
00:23:51.622 - 00:24:34.098, Speaker B: So I know there was a lot there, but this make file really makes it easier to deploy across networks and with different parameters, a lot easier. If you want, you can still 100% deploy things with DAP create. You're just going to have to add a whole bunch of flags and environment variables in here yourself. So the two environment variables that we need are going to be ETH from and also export EtherPC URL. This is going to be your connection to the blockchain. If you wanted to, you could even use one of Daptool's built in local blockchains. If you run DAP Testnet, it'll actually spin up a fake blockchain that you could add to your metamask or do whatever you want with.
00:24:34.098 - 00:25:10.670, Speaker B: But we're not going to use that. We want to actually deploy to something like coven. So I'm going to go over to alchemy and get a free coven RPC URL. Once you sign in, you can create an app and then get a key or get an HTTP endpoint, which will look something like httpalchemy IO slash blah blah blah blah blah, something like that. For the purpose of this video we're going to be deploying to COVID. And I actually already have an environment variable called Coven RPC URL that I'm going to be using in my env file. But again, yours is going to be like something like HTTPs, blah blah blah, whatever.
00:25:10.670 - 00:25:46.810, Speaker B: Now that we have our ETH from and our ETH rpcrl, there's one more thing. We need to send transactions, including creating contracts. We need a private key, and that's where Ethsign comes into play. Ethsign is another command line tool that comes installed with daptools. So to add our private key, we'll do f sign import, and this will give us a prompt to enter our hexadensible private key, which again we come to Metamask. Click the three dots account details, export private key, add your password, and you'll get it there. You can then paste it in here.
00:25:46.810 - 00:26:11.620, Speaker B: And after you do that, it'll prompt you for a password. And then once you enter again, I've already done it, so I'm not doing again. But once you hit enter, if you do f sign ls, you'll see one. Well, I have three here, but you'll see one. One key store. These are your encrypted private keys that can only be decrypted with your password. You'll want the private key, obviously for the same address as your ETH from.
00:26:11.620 - 00:27:16.614, Speaker B: But once you have all that, we can finally go ahead and run our deploy command, right? So we could totally export, or we told you ETH URL or ETH from equals and then our from and then know URL equals and then our thing, and then depth create and then the name, and then all the arguments and blah blah and all that stuff. But again, our make file has that deploy helper here. So now we can run make deploy, and then we just have to choose our contract. We'll just say contract equals DAP lottery. And this again is going to run our deploy sh, which is looking for the name of the contract. And that's how we define it right here by saying contract equals DAP lottery. Now, if we hit enter, what's going to happen? It's going to make this huge command here, Seth Send.
00:27:16.614 - 00:27:51.518, Speaker B: So daptools under the hood uses its own command called Seth to actually create transactions. And then you're going to be prompted for your password to actually send this contract. So I'm going to enter my password in. It's going to go ahead and create a transaction for me. And finally, once it's deployed, it's going to give me an address here so I can go ahead on coven Etherscan, pop that address in and after a brief delay we can see it right on Etherscan, contract created. We're going to additionally verify it later on once we get an etherscan API key with something as simple as this. Again, that's in the readme.
00:27:51.518 - 00:28:27.438, Speaker B: All right, so the only last thing that we need to do is we need to know how to interact with these contracts. So how do we do that? Well, we do it mainly through our Seth command. So Seth has a whole bunch of different commands here, but the ones we're mainly concerned about are going to be call and send. So if we want to read something off of a contract that we've deployed, we'll use the call command. So for example, maybe I want to read what this fee is. I will do ETH RPC URL and then for me it's coven RPC URL. For you it's going to be your alchemy key or inferior or whatever it is.
00:28:27.438 - 00:29:24.642, Speaker B: But we could do Seth call the address of the address we want to call to and then the function that we want to call. Yes, let's just call random result, which right now is just going to be zero. So we'll say random result like that. For those of you who didn't know, any public variable is secretly just a view function. So that's why we have these parameters here, because this is kind of the same as if we had a function random result, right? And if our function took parameters, we would just do like un 256 bool or whatever, and then we would add them as arguments over here, like 55 and true or something like that, right? But since random result doesn't have any, we can just call like this and we're going to expect to get zero back, right, because random result right now is nothing. And that's exactly what we see. Now we could additionally, instead of just reading off the blockchain, we could send a transaction by doing Seth send.
00:29:24.642 - 00:30:06.330, Speaker B: The only thing we'd have to add is ETH, from, which would know an address here, our address Seth send, the address of the contract, the function we want to call, and then any input parameters. I'm not going to run it right now just because obviously random result isn't one we want to send. But that's it. We've just gone through everything in this Daptools starter kit. Now obviously there's a ton more things to play with when it comes to Daptools, right? If you just look dap help. There are all these different commands, all these different things in here. You can come say hi to them in their daphub chat where the team hangs out, answers questions, which is fantastic.
00:30:06.330 - 00:30:18.222, Speaker B: Working with a tool like Daptools really is about as minimalistic but also incredibly powerful as it gets. So hope you all learned something fantastic here and take it with you to your next project. So that's it.
00:30:18.276 - 00:30:20.540, Speaker A: Remember to like and subscribe and we'll see you next time.
