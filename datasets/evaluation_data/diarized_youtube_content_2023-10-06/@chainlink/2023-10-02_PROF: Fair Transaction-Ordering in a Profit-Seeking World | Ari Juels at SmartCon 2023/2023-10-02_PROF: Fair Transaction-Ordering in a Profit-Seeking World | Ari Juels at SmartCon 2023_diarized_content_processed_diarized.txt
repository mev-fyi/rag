00:00:03.690 - 00:00:59.020, Speaker A: Good morning. At last year's Smartgon I talked about a tool we're building at Chainlink called fair sequencing services. It's designed to protect user transactions against exploitation, in particular a type of manipulation that involves changing the sequencing of transactions, or to protect against what's called Mev, which I'll explain in a moment. Today I'm going to explain to you why fair sequencing services doesn't work. In fact, I'm going to give you a kind of argument or informal proof that shows that it can't work. But don't worry, that's not the end of the story, I promise. First, let me explain the backdrop to fair sequencing services.
00:00:59.020 - 00:01:52.220, Speaker A: Let me explain to you, or remind you of the problem it's trying to solve. That problem begins with an unfortunate fact about blockchain systems. Blockchains in general, of course, are decentralized. This is their main technical accomplishment. But there's a kind of dirty little open secret about blockchains, which is the fact that the process of ordering transactions is in fact temporarily centralized, ephemerally centralized. What do I mean by that? Well, when a bunch of transactions comes into the system, enters the mempool, it's taken up by miner or validator. The miner or validator forms a block and it gets to decide unilaterally how transactions are ordered in that block.
00:01:52.220 - 00:02:56.028, Speaker A: So, for example, transactions may come in transaction one, transaction two, transaction three, and the validator may choose to order the transactions exactly as they've come in, one, two, three, or it may decide to reorder them in some way. Might put transaction three before transaction two. It has complete, essentially temporarily centralized control over how transactions appear in a block, and also what transactions appear in a block. The validator can decide, for instance, that it wants to insert its own transaction. Okay, well, what's the big deal? So what? Why does it matter that a validator can choose how transactions are ordered? Well, as it turns out, this subtle feature blockchains matters a lot. Let me give you an example to explain why. Suppose a user, our canonical user here, Alice, is interacting with a decentralized exchange automated market maker, and she wants to buy some BBT, Bob's bubble token.
00:02:56.028 - 00:03:32.616, Speaker A: She's willing to pay 1000 eTh. And let's suppose that the two assets are at parity at the time that she submits her transaction. So assuming no interference for her 1000 eth, she'll receive 1000 BBT. Well, her transaction, of course will cause the price of BBT to rise relative to ETH. This is what a buy transaction does in general. Now, the validator, of course, will observe Alice's transaction before it gets processed. After all, the validator is the one placing her transaction in a block.
00:03:32.616 - 00:04:32.080, Speaker A: So effectively it will know in advance that the price of BBT is going to rise. Now, what would you do if you knew that the price of an asset was going to rise in the future? Well, of course, you'd buy up lots of it, and that's something that the validator can do. Remember I mentioned the validator can insert its own transactions into a block so the validator can buy BBT before Alice does, take advantage of the rise in price resulting from Alice's transaction, and then turn around and sell BBT for a profit, of course. Well, where does this profit come from? The validator's buy transaction, like Alice's, will cause the price of BBT to rise, and consequently Alice will get worse execution. She will pay a higher price for her BBT, and she'll get less BBT in consequence. So essentially, this is money out of her pocket. And of course, this makes Alice very sad.
00:04:32.080 - 00:05:44.920, Speaker A: This is the phenomenon referred to as minor or maximal extractable value. And this is the thing that FSS is designed to protect against. In fact, today the ecosystem around MeV is quite complicated. There are a bunch of players who work together in what's known as the MeV supply chain. Validators don't construct blocks themselves, typically, but rather the entities in the supply chain construct blocks and try to extract as much MeV as possible, much, in fact, most of that MeV gets returned to the validator as a kind of bribe or reward to pick up a particular block. So you have competition at multiple levels among these entities, trying to maximize mev extraction and return as much as possible to the validator to get their particular block taken up. Where does fair sequencing service fit into this picture? Well, fair sequencing service, of course, as the name suggests, sequences transactions fairly.
00:05:44.920 - 00:06:55.428, Speaker A: In particular, it will sequence transactions on a kind of first come, first serve basis, according to what I like to refer to as the deli counter policy, and as a result, it reduces mev extraction. This is one of the ways that it protects users. It will protect users in general or often against the type of manipulation I showed you in the example I gave involving the Dex. Well, this is all well and good, but when you think about it, isn't reducing MEV a losing strategy as far as getting a particular block taken up is concerned in the MEV supply chain, you've got all of these entities competing to maximize MEV extraction so they can successfully bribe the validator to get their blocks taken up. If FSS is reducing meV, then we may have a problem. And this is the basis for the argument I'm going to give you that FSS doesn't work. The problem is that MEV maximization is inevitable, required to get a block accepted.
00:06:55.428 - 00:07:49.170, Speaker A: So let me run through the argument here. Suppose that validator is offered a choice between two blocks a or b, and a includes a reward of r. In this particular example, $200, and b includes a reward of r plus a little epsilon, a little extra, a dollar in this case. So it offers a total reward of $201. Which block is the validator going to choose? Well, it's pretty obvious the validator will choose block b because it's better to have $201 in your pocket than to have $200. Well, where does this extra dollar in b come from? It comes from MeV maximization. It comes from having squeezed user transactions a little harder than in block a.
00:07:49.170 - 00:08:23.952, Speaker A: As a result, if you extrapolate from this little example I've given you here, you can see that a validator will always select the block that maximizes meV. But remember, I said that FSS lowers mev extraction. So FSS blocks are not going to get validated. They're not going to be competitive, and this means that FSS doesn't work. Okay, but I promise this was not the end of the story. And indeed it's not. This is a good time to invoke the maxim.
00:08:23.952 - 00:08:56.020, Speaker A: If you can't win the game, change the rules. So now I'm going to give you an argument or informal proof of just the opposite, that MeV maximization is, in fact, not inevitable. Here's how it goes. Suppose the validator is given a choice between two blocks a and b, and as before, block a pays reward r, and block b pays reward r. Plus a little epsilon. Right? A tiny bit more. A dollar.
00:08:56.020 - 00:09:38.096, Speaker A: But there's something special about this dollar. The extra dollar in b comes from a collection of transactions. Of course, the validator will choose block b again because it provides the horror reward. But block b is special in that it has appended to it a collection of transactions that are ordered fairly often. A collection of transactions in the context of MeV, and a group of transactions in this context is referred to as a bundle. So it has this bundle of fairly ordered transactions. Well, it doesn't matter that these transactions are fairly ordered.
00:09:38.096 - 00:10:36.784, Speaker A: If these transactions offer a little extra reward to the validator, they offer this extra dollar. Then the validator will pick block B as the more rewarding. But now MeV isn't maximized. Part of the block includes transactions that have been ordered fairly and therefore protect users against mev extraction. So we've escaped the pitfall of the previous example. Question, of course, is how are we going to get a bundle of fairly ordered transactions into a block? How do we prevent these transactions from being attacked or manipulated by the MEV supply chain? This is the key question, and the way that we can do this is using a system that my group at Cornell Tech has recently proposed called Prof. Stands for protected order flow, or professor.
00:10:36.784 - 00:11:19.520, Speaker A: Of course, this is joint work with the groups of a couple of colleagues, Andrew Miller and Don Song at UIUC and UC Berkeley, respectively. In case you're wondering, by the way, what the image in the background is, we asked stable diffusion to sketch a picture of a professor seeking justice in a dark forest kind of metaphor for what Prof. Is doing. And I noticed, strangely, that the professor is carrying a sword. I was wondering, where did this sword come from? I realized, you see Lady justice back there. The professor stole the sword from Lady justice. Such is generative AI.
00:11:19.520 - 00:11:54.830, Speaker A: Okay, while that's a bit of a sidebar, let's go back to Prof. How does Prof. Work? Prof. Makes use of a technology known as a trusted execution environment. This is a system or environment within which an application can run with some special security properties, two properties in particular, and these are supported by hardware within the cpu. The first of these properties is integrity. The program can't be tampered with.
00:11:54.830 - 00:12:29.450, Speaker A: It can't be tampered with, even by the owner of the host. The computing device on which the program is running. This particular property should look somewhat familiar. Smart contracts have this property. The second property, one that smart contracts don't have in general, is confidentiality. This program can have secret state. It can protect secrets, and those secrets are opaque to the entire world, even, again, to the owner of the host or computing device on which the program is running.
00:12:29.450 - 00:13:50.404, Speaker A: Now, if you're familiar with trust execution environments, you'll realize that there are a lot of big provisos here, concerns about side channel attacks, many of which have indeed arisen in the wild, and so on and so forth. I'm not going to have time to talk about those in any detail, but we're quite aware of them. The one thing that I will point out is that trust execution environments are already being used in the MEV supply chain, and in fact, they have been building blocks in the supply chain for about half a year. So we have this protected environment, and you can think of a program running in this protected environment as being roughly like a confidential smart contract. It's like a smart contract in that it is protected against tampering. And it's also like a smart contract, of course, in that users are familiar with or get access to all of the code that it contains. How does this work exactly? The application here? Prof.
00:13:50.404 - 00:14:27.404, Speaker A: Is going to run in a trust execution environment, and it ingests private transactions, private order flow. It ingests transactions that aren't sent elsewhere and which are encrypted, which are private to the Prof. Application. Prof. Will take these transactions and assemble them into a bundle, and it will order them fairly. I'll explain in a moment how it might order them fairly, but it orders them fairly in this bundle. Once it's constructed, this bundle, what it will do is ingest a block.
00:14:27.404 - 00:15:23.330, Speaker A: Block a, constructed by the MEV supply chain, from which a lot of the MEV may have been squeezed out. And it will enrich this block. It appends to the block the fair transaction bundle that it's created. Where the te comes into play here is in protecting the fair transaction bundle. The confidentiality and integrity properties of the tEe, plus some technical trickery, ensure that the transaction bundle fair transaction bundle can't be manipulated by the MEV supply chain. The transactions within the fair transaction bundle can't be reordered by any of the entities in the supply chain. So in a nutshell, te protects the fair transaction bundle, ensures that b block B can't be tampered with.
00:15:23.330 - 00:16:02.620, Speaker A: Well, I said that these transactions are ordered fairly, but what does that mean? You can choose your favorite definition of fairness as a policy according to which the transactions in the bundle get ordered. One natural tool to use to order those transactions is FSS. So the important point on this slide is that FSS is not dead. In fact, it can work. It just needs to work, economically speaking, with a tool like Prof. So Prof. Revives FSS, as it were, sidesteps the problem that I talked about earlier.
00:16:02.620 - 00:16:44.780, Speaker A: Prof. Then offers the validator a choice, the choice that I showed you earlier. Validator can take a block a, from which as much MEV has been squeezed out as possible by the MEV supply chain and be rewarded $200, or can choose a Prof. Enriched block and get a reward of $201. And this block, of course, has the fair transaction bundle appended to it. Which is the validator going to choose? Well, if the validator is economically rational, it's trying to maximize its profit. Of course it will choose block B another nice feature, Prof.
00:16:44.780 - 00:17:25.650, Speaker A: Is that actors in the MEV supply chain, given the existence of Prof. Actually have to use Prof. To be competitive. Why is that? Well, remember, they're all competing to produce the most profitable block so that their block will be taken up by the validator. The validator is going to choose the block that puts the most amount of money in its pocket, and a Prof. Enriched block is going to provide more reward for the validator. It will allow extraction more MEV and therefore enable provision of more reward for the validator than a block that isn't enriched.
00:17:25.650 - 00:18:02.558, Speaker A: Using Prof. So if you want to compete in the MEV supply chain, you have to use profels its own adoption in this sense. And that means that given the existence of Prof. The MEV supply chain is going to construct blocks that include fairly ordered transactions. The user also has a choice here. The user can submit her transaction. Alice can submit her transaction here to the mempool in the usual fashion and then run the MeV gauntlet, allow MeV to be extracted from her transaction.
00:18:02.558 - 00:18:58.610, Speaker A: So maybe a dollar gets squeezed out of her transaction, and then her transaction lands in the thick of block a. Or she can submit her transaction to Prof. Pay a tiny bit of money so that that epsilon, that dollar can be paid to the validator as extra reward and have her transaction land in the fair transaction bundle, be sequenced fairly, and enjoy some degree of protection from MeV. Well, given the choice between these two options, of course an economically rational user is going to choose option b. It's better to pay a penny than it is a dollar. So, in summary, here, all of the actors in the ecosystem are incentivized to use Prof. The user will use Prof.
00:18:58.610 - 00:19:23.434, Speaker A: Because it's less expensive. Validators will pick up Prof. Enriched bundles because they offer a higher reward. And as I mentioned, the MeV supply chain, our actors in the MEV supply chain are essentially compelled to use Prof. To be competitive. Now, this is true in the short term. In the long term, the hope, or at any rate, my hope, is that Prof.
00:19:23.434 - 00:20:21.118, Speaker A: Is going to grow to the point where essentially all transactions are fairly ordered. Again, according to your favorite notion of fairness, which may involve FSS. As you've been listening to this, a few questions may have entered your mind. For example, what happens if blocks are full? Where is that fair transaction bundle going to go? Well, as it turns out happily in Ethereum, thanks to EIP 1559, and in fact, in most blockchains today, blocks typically are not full. EIP 1559 aims for blocks to be only half full and so typically there is room for these transaction bundles. Can Prof. Work with l two? Well, the economics of l two, l two s are in fact very similar to l ones in the sense that Mev becomes an issue.
00:20:21.118 - 00:20:46.210, Speaker A: Transaction ordering is an issue, and in a nutshell, yes. Prof. Can provide protection against mev in l two s as well. Can Prof. Do anything else? We're making use of this very powerful tool, a trusted execution environment which provides these security properties that I described, integrity and confidentiality. And it turns out you can do other interesting things. And in fact, Prof.
00:20:46.210 - 00:21:16.220, Speaker A: Harmonizes very well with decentralized oracle networks. So, for example, it can allow you to inject Oracle reports fairly, by which I mean in a way such that they're not exposed to front running attacks, for example. That concludes my talk. If you're interested in learning more, we published a blog post about half a year ago. You can find it at the URL shown here. Thank you very much.
