00:00:18.630 - 00:00:42.750, Speaker A: Awesome. Welcome everyone. We'll get started here in a couple minutes. Let some people join in from the discord. I'll share this link with you too, Brian. Really excited to have Brian Chen, the co founder and cto of a call, joining us today, his morning, early morning. So yeah, really appreciate you taking the time.
00:00:42.750 - 00:01:18.388, Speaker A: If you guys have questions throughout this, drop them into the YouTube chat and then at the end we'll do some q and A and be able to answer any of those questions for you and we'll just give it about 30 seconds. Let some other people join in here. Also make sure to stop by the Akala discord channel and if you have questions in there, just drop them in. Otherwise, yeah, Brian, if you're ready, we can go ahead and get started.
00:01:18.554 - 00:02:13.096, Speaker B: Yes, thanks for having me. So in today's workshop I'm going to talk about how to deploy smart contract in Akala Evn and I'm going to just do a quick demo of implementing a sample arbitrage bot using oracle and scheduler. So everything will be running on chain. So there will be no off chain components in the spot, which is still an interesting part. You cannot really do it on currently. So the agenda will be talking to give us some quick overview of Akala and describe some unique feature of the Akala EVM and how to deploy solidity project into the Akala EvM because we are not 100% compatible with existing tools. So there will be something you need be aware of.
00:02:13.096 - 00:03:16.990, Speaker B: And in the workshop part I'm going to show you how to implement and deploy a fully automated on chain arbitrager to the Akala EVM. So start with Akala. So akala is a defi hub for the Polkadot ecosystem. So we provide a few defi primitives including a multi currency stablecoin and also provide a liquid dot staking derivative so you can stake the dot and exchange for LDOT and then which can be used to issue a stable coin. We also offer a simple AMN exchange, decentralized exchange on a chain and we also have a decentralized selling west fund, so the fund controlled by the governors. So we have a live testnet now. So current Testnet is a TC five, but we're going to just release a new testnet with the fully updated Akala EVM feature, TC six in the next week.
00:03:16.990 - 00:04:02.328, Speaker B: So Akala to be a device hub. So we self have built a few device primitives after actual, but also offer smart contract platforms with EVN capability. So people and other projects will be able to leverage all the existing Defi protocols of Akala and deploy your own Defi applications on top of it. So this is a high level architecture of Akala. So Akala is a power chain of the Polkadot. So all the applications built on top of Akala will be enjoying the shared security of Polkadot. So it will be using the dpos.
00:04:02.328 - 00:05:08.930, Speaker B: So there's no need to worry about the mining and all the unstable block time, et cetera. And what we'll be also will be able to enjoy all the power chain ecosystem of Polkadot. So there will be different kind of power chains and bridge to Ethereum, bridge to bitcoin and other power chains connecting to Polkadot. And with the shared security we can easily do cross chain communications between power chains. And so all the applications built on Kapakala will be able to access resource and assets in other power chains as well as in other bridge chains including Ethereum and bitcoin. So Akala, we have built a few protocols within the network and on top of the protocols then people will be able to write smart contracts and build your own Defi applications deployed in the that's all the overview of Akala. So let's get into the technical part.
00:05:08.930 - 00:05:53.090, Speaker B: So for the development of the smart contracts, one easy way is just run your local node. So we have the docker command, the ceds way just run a simple node. There's also nodes have a special flag instant ceiling. So this means it will produce a new block as soon as the transition appear in the transition pool. So there's no need to wait for a few seconds of block productions per transition. So it just makes things easier during development. We have also eBay examples, so the stock command will be inside this remit file and for all the examples code I'm going to show you today.
00:05:53.090 - 00:06:51.984, Speaker B: Just one thing to keep in mind is the goal of aka EBN is inherent the goodness from Ethereum which is the developer community, all existing projects and mature ecosystem and development tools. But we all know there are some legacy decisions on Ethereum, that things can be improved but cannot be improved due to various reasons or still pending for new EIP to be merged in half fork to be solved. The issue Asakala is a new project. We want to inherit the good things but not all the legal citations. So we want to improve the existing EBM ecosystem. So this means if we want to become 100% capabilities we need to inherit all the legacy decisions. So this will be a tough decision for us.
00:06:51.984 - 00:07:47.664, Speaker B: So we have made a decision to improve for the existing EVM, which means we're not going to gain 100% capability, but of course we're going to make a lot of improvements. So hopefully also provide support and make sure all the changes are easy to migrate and minimum change required. So most of the existing projects can be just deployed without change with minimum change on Akaibian. Some of them might need some change here and there, but it should be all fairly minimum scope. So those are a few unique features of Akaibn that I would like to highlight. There's a lot more just work in progress, so we'll be coming in a later version of the release. So we have a lot of system smart contracts.
00:07:47.664 - 00:08:43.590, Speaker B: Those are the bridging between the Akala EBN and the Akala runtime, which is the one we're having all the Polkadot features such as bridge, all the Akala protocols such as stablecoin protocols and other bridge assets which including for example the bridge dot and bridge to bitcoin. So those are the address of all assistant smart contracts. You can easily recognize the assistant smart contract just by looking at the address. Obviously we can pick whatever address we like, so we just pick one with just pick those numbers. So let's start with the Merrot token. So here you can see for every token in our network we have created a mero token. This is Yasi 20.
00:08:43.590 - 00:09:41.690, Speaker B: It's very similar to a wrap token like we, but there's no wrapping required. In order to use, we need to wrap it first, convert east to Yasi 20, and then you need to redeem it on wrap it later if you want to get the original east back. So this obviously is more transitions and more work. It's also confusing for the users as well because we have the full customizabilities on the EVN itself. So we can just expose the underlying storage as the EVN as a Yasi 20. So this is just a new interface, but it's sharing the same underlying storage of all the native token, so there's no wrapping required. If someone sends you some dots from the Polkadot relation to the Akala power chains, and then you can query the value on the smart contracts and you will just read the value.
00:09:41.690 - 00:10:30.840, Speaker B: And if you spend do a 20 transferred of the dot tokens to another smart contract or somewhere else, and from the substrate side so akala runtime side you will see the change appeared as a normal substrate smart contract transition. Just to quickly show you this. So this is la color ibN. So currently it's connecting to our Neotesnet TC six. So we have preload. This will be the primary tools that the UI tools can be used to interpret with Lakaibm. So we have preloaded a bunch of license smart contracts and then here we'll be able to select for example this ac is our native token so it's all ERC 20.
00:10:30.840 - 00:11:40.700, Speaker B: So you can just using all the standard ESC 20 features so I can query my balance of this account and I can make a transfer. So I need to just transfer myself it so this will be equivalent to a native transfer so you can see the transfer success and I query my balance, I'll transfer myself. The balance doesn't change, but there's a transition fee involved. So you see the sum amount of fees deductible from the transition fee. So this means join the development. Then the smart contracts will be just easily access the native tokens without worrying about wrapping the tokens. Another unique feature we have is the scheduler.
00:11:40.700 - 00:12:38.240, Speaker B: So this will allow smart contracts to schedule a call after number of blocks to be called. So we will reserve some transaction fee upfront and refund unused fee after call is dispatched. There's no guarantee the schedule call will be called on a particular block because obviously if things are blocked are full, things are busy on the network, then the schedule call lower each priority so it could be delayed. But at least it's possible to schedule a call without offline components so there's no need to for example build a bot to trigger particular rebalance smart contracts on your everyday or everyone once in a while. So this will make a lot of things much simpler and easier. So again this will be system smart contract. So you can see there's just a schedule call.
00:12:38.240 - 00:13:42.688, Speaker B: So we have a bunch of parameters. So country address is the country you want to call, the value is the native token you would like to send along with the call you need to pass a guest limit storage limit so we have a simple state renting system, so the storage limit will limit how much additional storage can be used during this call. There's all the management delays so you can schedule this to be after say 100 blocks, so it will wait at least 100 blocks to call the smart contract and the input data will be just the data to be invoked along with the call. So it will be the selectors and all the arguments. So let's see how to schedule a call should be very straightforward. Join the testnet to keep things easier. So I've disabled the fees you still limit applies, but there's no fees reserved when making a schedule call, just to keep things easier.
00:13:42.688 - 00:14:29.328, Speaker B: We will be enabled again in the later testnet. So this basically means people will be able, so this is just one time schedule call, but you can of course in the method to be called or in the smart contract to be called itself can just schedule another call. So that's the way to implement recruiting payments if needed. So this is the interface. We also have some other methods that can be used to cancel the call and manage the call. So just to quickly show you the code. So we have a lot of examples like for example the examples for the scheduler.
00:14:29.328 - 00:15:14.640, Speaker B: So just check things here. So there's smart contract interface. So in this printable contract you can see all the system contracts. So you can check the schedule, so the system interface, so you can schedule a call, there's an event, you can cancel a call, you can also reschedule a call. So to use it, it's very simple, just passing all the parameters, the right values and just API cosignature the things you want to call. You can also pass additional parameters. So it's just pretty standard encode.
00:15:14.640 - 00:15:54.000, Speaker B: So this will allow, so in the pay function it will first require. This can only be called by itself. So someone else cannot just manually trigger this call. Of course it still needs to be public to be called and then if needed, so this can schedule another call to be called in the future. So this will reduce the count by one. So you can upfront say that I want to call this five times for every three blocks and every time this will reduce account by one. So this can be used to implement a simple recruiting payments.
00:15:54.000 - 00:16:38.460, Speaker B: Of course you can autocode available so you can study in detail later. So another feature we have is oracle gateway. So as the Akala we have a few device permitted. One is the stablecoin which of course needs oracle to assess the price information of the kertos. So we would need oracle. So we have created Oracle gateways and various protocols including Trendlink will be feeding the price data into the oracle. So we also expose this as a solid interface.
00:16:38.460 - 00:17:30.690, Speaker B: So other depths or the smart countries build within academia will be able to access all this price data using this interface. It's very straightforward, just get a price of a particular token. In the later revision we will be also adding more APIs to get more fine grant details. So for example you can just read information from Chainlink for this token. So just another quick example. So let me actually copy the dot address and we have the oracle. So I can just get price of dot which is almost $36 now.
00:17:30.690 - 00:18:14.616, Speaker B: So currently it's all 18 decimals position. So this is also including a time step so you know when with the last feed of this token. So you can determine if this is too old or something. Yeah. So now yeah, I've show you the all but most of the interesting feature so we can start just deploying things on our testnet. So this is the archive. By default it's connecting to the TCX testnet.
00:18:14.616 - 00:19:18.000, Speaker B: You can also switch to the local node or it's switching so you can also use custom endpoint. So if you deploy your nodes or server elsewhere you can exchange endpoint. So just connecting to tc six for now. In order to use this you'll need to have the polka dot extension installed and then you need to create a new account in the pocket extension and after that you can use the faucet to request some file. So right now this faucet pattern is not really integrated. So later we'll make this actually give you some testnet token on the tc six. But once you have some test token, you can either create an email address that's using metamask and bind this with your account.
00:19:18.000 - 00:20:12.310, Speaker B: So you can use the metamask to sign messages. Or the simple way is just where we use auto generated email address from the account address. So it doesn't have any private key, but you can use the pocket address extension to do the signing. So that's the binding account. And then you'll be able to just deploy or call smart contracts. So you can use remax to deploy or compile the smart contracts because we are not using metamask so you won't be able to using remix for now you can use remix to deploy your smart contracts, but you can still use it for the development to compile. So this is a sample so you can just compile this code.
00:20:12.310 - 00:21:26.004, Speaker B: After you compile, you see this JSON file and you just basically save this to your local decks and then upload here. So just upload the JSON file and then you have this thing uploaded and then you can deploy your smart contracts. After deploy you have those smart contracts here so you can just execute it. So again I can just query my balance and you can just using all the methods or you can make transfer. So this is the easiest way to using that purity, the GUI, the front end to build and deploy the smart contract into the Caribn. But for more large projects you probably want to have some build scrap instead of using remix. So we have created JS SDK.
00:21:26.004 - 00:22:09.320, Speaker B: It's called body JS. So this one is one you'll be needed to deploy smart contracts into the Akala testnet. Because we are not 100% capable with Ethereum RPC, we'll be using a substrate RPC to do the deployment. So this will wrap the substrate RPC and expose the webster providers. And then you can use your existing Ethereum to JSSDA to access the test name changes for iPhone. So this is uniswap example. So there's some pre built uniswap artifacts.
00:22:09.320 - 00:23:03.560, Speaker B: This is the setup code. So it's basically creating a provider from a body which you're connecting to the websocker provider from a Polkadot JS. So passing in this case to the Websocker endpoint the connecting to the local testnet or you can make it connecting to some remote server. Let's create the wallet or it will use the testnet key ls. So which type a lot of test token in the local testnet by default and then set up the wallet assignment. So this one will be just standard, the easiest shares wallet. And then from now on you can just using the standard ethers to interact with the blockchain.
00:23:03.560 - 00:24:01.260, Speaker B: So you can just create the ethers contracts. So that's all for ethers, deploy smart contracts and those just the normal workflow on the Ethereum. So in here you can see I've deployed the Uniswap smart contracts and approve some token, add some liquidity, do a bunch of scenes and disconnect. So that's how you deploy the Uniswap smart contracts to that kind of testnet. I won't run this because I'm going to show you this arbitrager bot. So for the normal arbitrager, because we have the decks in Akala testnet or in Akala network. So obviously for every decks there will be arbitrage opportunities.
00:24:01.260 - 00:25:16.276, Speaker B: So you say all our decks will have that trading pair of for example dot or RembDC or other cross chain bitcoin for example like Polka BTC. If you see the price between, let's say the dot price in our dex is different than other centralized exchange, then you will be able to make some arbitrage. So they will be either buy in L Dex and sell on the centralized exchange or do the other way just buy on exchange and sell here. So in this example, I'm going to show you all on chain component, mostly existing decks arbitrager. They will be just either arbitrage between multiple decks or they will be arbitraged between decks and centralized exchange. But they usually needs to be triggered by have an offline server sending transactions to the blockchain to trigger arbitrage opportunities. But with the scheduler we don't need to do this.
00:25:16.276 - 00:25:50.960, Speaker B: We can just having the smart contract schedule a call. So it will just run, for example, every five minutes to check if there's arbitrage opportunities. If there is, then it can just do the arbitrage trade. This is a very simple arbitrager. It's using a strategy. They'll probably make you lost money. But of course you can build on top this to develop some better strategy that will be actually profitable.
00:25:50.960 - 00:26:48.112, Speaker B: You can see in this particular example, I will be using the Uniswap as the decks to be arbitraged. Later you'll be able to use the similar API to assess the. So for now. So in this code, join the deployment. We will actually deploy Uniswap smart contracts that's similar to the other uniswap example. We'll be adding a bunch of liquidities, adding dot and AUSD, the stablecoin trading tier. So people will be able to trade Dot and AUSD in this and then we'll be deployed arbitrager and say we would like to arbitrage this trading peer and deposit some money and then we'll just run it.
00:26:48.112 - 00:27:28.350, Speaker B: And then without any other applied transitions, arbitrage itself will just run and making trade based on the oracle price feed by Latinic or some other oracle providers. So in the code you can see it will schedule itself a call. It will call itself, there's no value to transfer. There's a guest limit, storage limit. So just some large bigish number because there's no fee involved. So right now this will just always assess. But at later version when fee is enabled, then you need to make sure this number is not crazy large.
00:27:28.350 - 00:28:20.904, Speaker B: And you need to make sure the smart contract itself. When you deploy the smart contract, you have sent some native tokens for it to be used as the trading fee. So during the constructor you can set the period and how frequent you want to run this architecture bot. And then every time, every this period, it will just call this trigger function, which is this one. So the trigger function itself will require, it can only be called by itself. So there's basic, it can only be called with scheduler that other people cannot trigger this externally and then it will immediately just schedule another call to be called later. So this will make sure it never stops.
00:28:20.904 - 00:29:08.620, Speaker B: Well it will only stop when this run the album tokens as transition fee. So then you will be able to just deploy this and forget about it and maybe come back later. See, it's making a winning strategy. So it's accumulated a lot of money or it's losing money so it will run our fees and just stop running anymore. So we'll be using the oracle. So we have deployed address contracts, they're having all the address of the system contracts which, including the scheduler and oracle. So we can use the oracle interface and using a get price to get the price feed by the oracle.
00:29:08.620 - 00:30:14.100, Speaker B: So in this case we just ignore the timestamp, which probably not a good idea for production ready contracts, but for the demo purpose we'll just ignore it. We check how many token we have for the trading peer and we ask the Uniswap what's the reserve token. So basically get the price from the Uniswap and do some math to figure out if the price of the oracle is higher or lower than the price in the uniswap. This is super hacky and simple way, there will be some helper libraries from the Uniswap to help you to do this properly. And after that when we figure out if I could buy or sell, then we just figure out how much to buy and sell. So in this case we're just using the balance we have. Of course this is a very poor strategy.
00:30:14.100 - 00:31:03.280, Speaker B: You probably want to figure out that by looking at the price difference and the liquidity to figure out the maximum amount of tokens you would like to trade. But again, you can just try to figure out, there are some uniswap examples on calculating this part. But to keep things simple, we're just doing this. If amount is not zero, then we will just do the trade and sell this amount. The path will be depending if we want to buy the first token or sell the first token and just order respond or send it to this contract. So this is the arbitrage code. It's fairly straightforward, a simple strategy.
00:31:03.280 - 00:31:52.180, Speaker B: If it is making a profit, then itself can just run, hopefully forever. But if it's losing money or if it's lost all the money, then you have no fees to pay and it just stops for production. Really. You probably want to have some external controls, like for example, you would like to post this contract to cancel the schedule, et cetera, but those are up to you. You can also maybe ask one of the Hexon idea, just build on top of this to actually make this production ready. So the setup code is same as new swap. Just setting up the RPC endpoints, the keys and then using the body you get the webster provider and the wallet.
00:31:52.180 - 00:32:42.928, Speaker B: And in the deploy this will just deploy a standard uniswap and then deploy the arbitrager and send some money to help it get started. And we're also using this API to feed the oracle price because I'm going to run this in a local testnet. So the LS key will have the permission to feed the price. So you can just write some scrap to manipulate the price and see how does upcharge report run in action. Because the local test is running with instance any mode. So what it does is basically produce a new block on transition. So for scheduler to work it needs to wait for a particular block.
00:32:42.928 - 00:33:22.370, Speaker B: So we have this code that send a dynamic transition just to trigger a new block. So I can just run this. So let's deploy the uniswap. So this is the docker image. I'm running the local node. So you can see I have enabled a lot of tracing logs. You can see all the inner details of the smart contracts course.
00:33:22.370 - 00:34:11.410, Speaker B: So you can see after running you have successfully deployed the arbitrage, deployed the uniswap contracts. Deploy the arbitrage book. Initially you have this amount of money and then it will feed some value. So in this case we'll make the dot token more expensive than ASD. Initially the joint initialization trading PA adds the same amount of dot and ASD. So the price will be one to one. But if I make the dot more expensive than USD, then the arbitrage bot will figure the dot on the dot price in the decks is lower than the market price.
00:34:11.410 - 00:35:22.260, Speaker B: So it will just do some trades to upshot you the trade. Oops. So actually I think there's some, yeah, the insurer have some issues because I just started node, it doesn't have any oracle feeds so I need to rerun it. So it has, I probably need to have the slide before all the deployment anyway. So in this case you can see initially I have this amount of token and it will just figure out the dot price is higher. So it will spend some of us dollars to buy the dots so end up being having the sum of tokens. And after I have set us run the bot every two blocks.
00:35:22.260 - 00:36:44.766, Speaker B: So after two blocks it will schedule will be scheduled again. You will see another 10% of the stablecoin will be used to purchase dot and then I have make it. So now the stable coin is more expensive than dot on a dot price decrease, much more. So now it will try to sell amount of dot to buy to get back some stable coin and just keep doing this until the price of the decks match to the price of the oracle. So you can also in the polo js apps I can just connecting to the local node to see the actual transitions in action. I need to just rerun it. So you can see why it basically produces a new block for everything.
00:36:44.766 - 00:37:32.018, Speaker B: So let's start from beginning. So there's a bunch of evn creators. So let's deploy smart contracts. So create a smart contract and then you can see probably just pick some example, maybe this block. So in this block you will see there's no actual transitions, there's only a system remark, the dummy transition to trigger the production actually with multiple. And then in the scheduler you can see all the events associated with this call, you can see all the event log which will be the logs from eBay itself. You can also see the currency logs, the substrate runtime logs.
00:37:32.018 - 00:38:48.130, Speaker B: So you can see in this case this amount of thought is transferred from this account to this account. So those account will be the corresponding account of the arbitrage bot and the Uniswap trading period. So you can see, so in this case this amount of dot is traded with this amount of stable coin. And you can see this ebay and transition is executed. So the schedule is dispatched, but it also schedule something else to be called on the block 47. So in this case you can see all in the details of how the scene run in action. So this is all the work needs to write and deploy a simple arbitrage bot that doesn't need any offline components, that you don't need a server to trigger the bots, you don't need a server to monitor the price, you don't need a server to just figure out how to do fencing.
00:38:48.130 - 00:39:54.460, Speaker B: Like at later stage we could have multiple decks deployed on the akala that we have, the Akala swap. Then for example someone else might be deploying their own version of the uniswap or some other decks with different trading algorithms, bounding curve, et cetera. And then you can easily just write this arbitrage bot, maybe trigger every hour they will seek for the arbitrage opportunities that perform arbitrage trade. All these just deployed and forget about it. And if it's making profits, then we just run self sustained forever if it's not making profit and then you can of course have some damage control and then have itself killed itself. Or you just run up transition fee and get killed and not be able to reschedule again and just die. So this will be allowed a lot of new interesting creation of a smart contract it's actually just a self involving, could be a self involving contract it doesn't need the owner itself can make money for itself.
00:39:54.460 - 00:40:56.110, Speaker B: So that's all the demo I have for you today. So for Akala's challenge we have two challenge. So first one is deploy a dev on Akala using Akala EBN. So it should be fairly straightforward. Just follow the thing I've just showed you before. You can either build your projects using the remix and download the JSON file and deploy it using the EBM playground or you can just using the waffle to build your project and you can use the body Js to deploy it to public testnet or to deploy your own local testnet. You just need to make sure you can show us that you have actually deployed us to Akala testnet, not just for example the COVID testnet because the goal is be able to deploy your contracts in the Akala EBM.
00:40:56.110 - 00:42:04.318, Speaker B: The Chineseu, which is a better price is build a decks that not only deploy Akala EBM but it's also using the on chain scheduler function. There will be a major plus if the smart culture integrates with oracles, allow you say in future access the training data. Like for example the arbitrary chargeable is the perfect example for chargeable, but of course you cannot resubmit it, but you can maybe as I said, there's a few things, a lot of areas can be improved, so maybe you can build on top it or you can build something else, for example some subscriptions, payments or I don't know. And a lot of things that can use on chain scheduler just to make a lot of things much simpler. So you just update and build a smart contract using this feature. And of course you still need to demonstrate how to deploy it to that kind. Another additional bonus will be if you can have the front end connecting to the smart contracts.
00:42:04.318 - 00:42:56.180, Speaker B: Again, you will be also using double djs to do the connection between the ethers js and the substrate RPC. But as I showed you before, it's very straightforward, just in the depth side or in the front end side. You mostly just need to worry about ethersjs which is standard Ethereum library. So the next step for you will be check out Akala hacker guide with all the resource and links. Also join the discord server. We have the Akala channel here so feel free to ask any questions and I and some my mates will be able to help you there and just get start hacking. Hopefully you'll be able to build something amazing.
00:42:56.180 - 00:43:24.278, Speaker B: Yes, so this is all the useful links and you'll be able to find. So that's including the heckle guide and the evm playground, all the system contrast if you want to check the API, et cetera. And of course all the examples is in the Eva examples and the blockchain nodes is here. So that's all my content for today's workshop. Thanks for having me here and thanks for listening. Awesome.
00:43:24.384 - 00:43:43.778, Speaker A: Thanks a Brian, really, really appreciate that presentation. That's fascinating. Yeah, not a lot of questions. One of them is if we can get the GitHub repo which you just showed, maybe you can just send that to me and then we can just drop that into the Akala channel. Words.
00:43:43.944 - 00:43:52.886, Speaker B: Yeah, I will share the link of the slides to the Akala channel in the Discord server which the slides will contain all the links. Perfect.
00:43:53.068 - 00:44:16.310, Speaker A: And I dropped that discord link for you that we're asking in the channel as well. But yeah, a lot of thank yous and wonderful demo. So that was great. I really appreciate you taking the time, Brian. And yeah, if you guys have questions, join the discord and reach out if you guys have questions specifically about your projects. Otherwise, keep up the good work. And again, thanks Brian.
00:44:16.310 - 00:44:28.130, Speaker A: And also I want to thank Dan for helping organize and get a call into the sponsor and being a part of the hackathon, so really appreciate the work that he's doing and everyone in the polka dot ecosystem.
00:44:29.990 - 00:44:32.690, Speaker B: Looking forward for some great submissions.
00:44:33.350 - 00:44:35.040, Speaker A: Cool. Have a good rest of your day and.
