00:00:09.690 - 00:00:40.206, Speaker A: Everyone, is this working? All right? Yeah. Hey, everyone, I'm Frisky Fox. This is Magnus. We're from Kingdom Studios, the studio behind DFK chain and the original Gamefi protocol Tafei Kingdoms. We launched last August on Harmony one, and since then we've expanded to our own chain as a subnet of avalanche. And we're currently in the process of expanding to Clayton. So we're on a few chains.
00:00:40.206 - 00:00:42.940, Speaker A: Magnus, do you want to spend a minute and sort of introduce yourself?
00:00:43.390 - 00:00:47.770, Speaker B: Yeah, I'm Magnus iron root. I'm the lead solidity dev at King of Studios.
00:00:48.910 - 00:01:41.098, Speaker A: Yep. So this guy, he's very modest. He does a lot more than that, but he also helps to manage our chain, which we started off as adapt on Harmony one. And we didn't really have any plans to ever have our own chain, but that opportunity presented itself, and so we actually were able to launch our own subnet, which is its own EVM compatible chain. And that was amazing because it added a lot of utility for our Juul token, which was our main protocol token that was used with our dex. But I always get asked a lot, like, why create something like this? What is DFK? Why did you do it? How did you get the idea? And it was back in the time where everything was going crazy with, like, uniswap, sushi swap, pancake swap, everything swap. Right? There was all kinds of vegetables and whatever else.
00:01:41.098 - 00:02:33.138, Speaker A: And I had some friends who were like, hey, man, you need to get on this. You need to start staking and doing these things. And I was like, what is this? How does it work? What are LP tokens? What are pools? What's liquidity? And I finally understood it after a while, and then I had to explain it to my family and my mom and all my friends would ask me, what is this? And I was like, why isn't there an easier way to explain this to people? So that's kind of where the start of all this came about. Why not make something that's easier to understand, that has a very interface, have NPC in a marketplace that could explain it to you, and actually trading things, and how would you show liquidity pools? That's easy to understand. I'm like, well, it's kind of like a garden and having things grow. And so that's where it started to formulate. And that's why we created this in the first place, was to make it easier to educate people and bring them on board for things like DeFi.
00:02:33.138 - 00:03:41.806, Speaker A: But the other part of it was, I'd seen many of these protocols launch and explode overnight because of the insane aprs, and then within a week or two, it'd be dead because everyone would be onto the next protocol that has the next high aprs. And it's because all of the protocol tokens that were there didn't really have any utility besides just inflating and then going away. So the idea was, how do we make something that's used for more than just farming, that has use outside of the whole ecosystem there with Defi? And that's been our ethos sort of all on the way is how do we make utility token that has staying power? So when you think about games, like on phones, those games generally have some kind of crystals or jewels or something that you can buy and get access to in the games. And I was like, why not use that token for that? So long story short, that's where we're at. We're currently on harmony, one that we're kind of transitioning into Clayton and also on our own chain. Here's some really cool graphics from our game. We've got hero nfts, which can be used to augment things in game and change how much you're earning from things and also have them do quests and earn items.
00:03:41.806 - 00:04:17.470, Speaker A: And all those items are ERC 20 tokens. We're trying to have everything be a very standardized thing on the blockchain so that our players own their assets and can trade them in the marketplace. You can have your hero do a quest for trying to have some fish get caught, and then those fish you can go sell straight up for ethereum or something at the marketplace. Anyways, there's also some metrics and some numbers. I forgot that that one's not showing there yet. So we've got three hundred and thirty k plus hero nfts. We also have a lot of pets that have been minted, which are also nfts.
00:04:17.470 - 00:04:37.486, Speaker A: Transactions have been skyrocketing. On our own chain, we do a ton of transactions. And so having that scale up has been a large part of what Magnus here has been doing. And then we have a really good and really active community that's really friendly. So we encourage you guys to come over and check us out. So, randomness.
00:04:37.598 - 00:05:17.150, Speaker B: Yeah, so I can talk a little bit about randomness on the blockchain, but first I'm going to answer the question, why do we need it in games? Well, it makes games fun. A deterministic game would be very boring. And so if you think about board games, video games, even the most basic dice games, all use randomness, and so we use randomness everywhere in our games. So we have hero NFT summoning. So things like rarity, appearance, and stats can be affected by randomness. Same with hatching pets, which are another NFT in game. There's also quest rewards and then leveling up the heroes.
00:05:17.150 - 00:05:22.340, Speaker B: Even things like duels and raffles, and then many other contracts use randomness as well.
00:05:22.950 - 00:05:56.878, Speaker A: Right? Yeah. So, like, you think about games, what makes the game fun? Obviously there's a skill aspect, but a lot of the awesomest games out there, that's not even a word, but have to incorporate randomness to make it have extra challenge. Every single game you can think of pretty much has randomness in it. But the problem is, randomness doesn't work very well in the blockchain because the blockchain, the same input has to result in the same output on every single node on the blockchain. It has to be very deterministic. Right. But randomness is not supposed to be able to be known ahead of time.
00:05:56.878 - 00:06:22.546, Speaker A: So how do you balance those things? And that's been an ongoing challenge for us that we've had stuff that we would say, here's how we'll do it. Let's just take all of the user input and add as many things as we can into the randomness so that it's more random. But actually it resulted in it being less random and more predictable in some ironic ways that we had to see, and then basically work around as we went. So I don't know if you want to talk about some of those things there, Magnus.
00:06:22.658 - 00:07:00.290, Speaker B: Yeah, so there are a few different strategies for getting randomness on the blockchain in kind of a deterministic world where everything has to come to consensus. So there's a strategy called commit reveal, where basically you commit to kind of a certain result, and then later on down the line you will kind of process that result in a second transaction. And that's kind of what we've used primarily. There's also oracles where you can take data off chain and get randomness there and then submit that on chain. And then of course, VRF combines both of those solutions together. And I will talk about how that one is a great solution.
00:07:01.110 - 00:07:39.406, Speaker A: Right? Yeah. So the commit and reveal one is a pretty common pattern because it requires you to put something in and say, I want to do this thing, I'm committing to it. I don't know the outcome yet, and I can't know the outcome yet because the outcome can't be decided until a few blocks in the future. The reason we do that is because we use the block hash for a part of the randomness. And the block hash is impossible to see what it will be in the future because it's very much dependent upon the validator and their private key, but also all the transactions that are going into that block. So that's basically like the pattern that we did. We wrote a function that would do that, and Magnus can probably explain the code there a little.
00:07:39.588 - 00:08:10.214, Speaker B: Sure. So right here, it's a small code snippet. It shows how we get a random number on the blockchain. So I've got three things highlighted in blue there, three inputs. One of those is the block number, and in that commit reveal scheme, that's the block number from the first transaction. And then we use that in two places. And there's also the unique key, which is the hero id or the meditation id or summoning id for those particular contracts.
00:08:10.214 - 00:08:38.642, Speaker B: And then there's also a knot. So if you need to use that same block number and a unique key multiple times inside of one block, you can keep getting a fresh number every time for subsequent randomness calls. And then we basically use a modulus to get a number from that 256 bit value that ends up being the range we need it, and then we simply return it.
00:08:38.696 - 00:08:57.270, Speaker A: That's exactly right. So this is actually a real snippet from our randomness strategy. So we're just going to talk a little bit about that here. This is kind of our learning process as we went. But I sort of mentioned that they have to do a start transaction to commit. They signal that they're doing it. A follow up transaction is then needed.
00:08:57.270 - 00:09:47.622, Speaker A: This kind of sucks for user experience, because when you're playing a game, you don't want to have stuff pop up, like sign this all the time. But that's kind of the reality right now with blockchains is in order for you to do things on the blockchain, you need to also sign it and make sure that you're really the actual person doing it. But hopefully that's a thing that we can improve as we go, and that is one of the hurdles that we'll be talking about in a second. But there is also, like a current weakness where validators can actually influence the block hash by figuring out which transactions they want to put into a block. So you have to a little bit trust that the validators aren't going to screw with randomness to make it be in their favor. A lot of places out there say a rule of thumb is to make sure that the value of that transaction is less than the value that the validator would be getting from the rewards of that block. And that's sort of a general rule of thumb there.
00:09:47.622 - 00:09:59.690, Speaker A: But there's other things too. Like for example, unique seeds. If you get the same input, you'll get the same output. So why do you need unique seeds? Do you want to talk a little bit about that?
00:09:59.840 - 00:10:38.882, Speaker B: Yeah, sure. So that unique seed is kind of what I mentioned earlier with the hero ID and the token id for the various different contracts. So we want to make sure that say like token id one and token id two. If they happen to have that one similar input that we can validate that that will always be different for each one. And so they basically can't get the same rewards or the same skills from those two NFts. And I also mentioned nonsense as well. So each time that randomness is used, we'll basically increment that nonce within a contract or even contract to contract.
00:10:38.882 - 00:10:52.298, Speaker B: So it keeps rolling over and it makes sure if you have a level up call and then a call to basically compute stats or things like that, those two values would be different given those same two inputs that would be the same between those.
00:10:52.384 - 00:11:30.220, Speaker A: That's exactly right. Because if you didn't have nonsense, then every single contract within a block that calls the random function would use the same hash and will get the same random number for every single contract. So that's why inside of that you have to have the unique id like the hero id, and say that's put into the seed. But also if you have multiple calls to a thing that will get a random number within one transaction for the same unique id, like for this hero, perhaps he does ten roles as a part of his thing. You have to have a non set increments for each of those as well. Why can't we let users provide input into the randomness calls that can be controlled by them? That's a very tricky one that we had to overcome as well. Do you want to talk about that?
00:11:30.590 - 00:11:31.798, Speaker B: You can take it away, Fox.
00:11:31.894 - 00:12:08.326, Speaker A: Sure, I got it. So basically what happens is you'd see smart and hacky users would basically create their own smart contracts and say, hey, try to do this thing on the blockchain with this input and look at what the result is. And if it's a result that I don't like, revert it. So using that attack, you could have somebody try it every single block until they get the result that they want and then they're like, yeah, that's what I want. And it'll actually go through. So we had to think about, okay, let's make sure that we don't use anything that the users can put in and change as a part of the randomness seed, or else they can game it. So basically what we do is we just have to make sure.
00:12:08.326 - 00:12:51.518, Speaker A: Let's control all the inputs, but let's also have those inputs, aka the block hash, be unpredictable ahead of time. So that was very important. Let's see, the other one, which is really tricky as well, is how do we make sure that the block hash isn't being tampered with? And we don't have a really good solution for that right now, which I guess we'll talk about in a minute. That's kind of where Chainlink VRF comes into play and we're kind of running a low on time. Holy crap, this goes by fast. There was an issue too where on the blockchain, and actually a guy previous to us just talked about this, you can only go so far back in history to look at block information. They only store the last 255 blocks.
00:12:51.518 - 00:13:36.042, Speaker A: And on some chains that comes out to about ten minutes because there's like every second there's a block or something. So we have to look at that and say, if a smart user is able to wait for more than ten minutes, then that user could say their randomness output would change after ten minutes. Because then up until that point, it was this block hash. After that point, it's just blank. So basically there's kind of two roles that a smart user could get from that and could have their randomness change in their favor if they wanted to. Not controlling the output, but at least getting two roles. So that was another thing we had to overcome, and we actually had to build our own little oracle that would basically archive every block hash, and we would use that instead of the on chain block hash.
00:13:36.042 - 00:14:12.394, Speaker A: So that was a whole thing, but we did it. More problems. This is what I was alluding to. Validators can still influence it, and I can't spend too much time on this slide because we're running out of time. But basically what this amounts to is a validator can say, let's look at what the output of this hash is. And if it's something that I don't like, because I might have a transaction in there that I'm trying to get a very rare NFT. If I don't like the outcome, I'm going to take this transaction and just be like, I'm going to do that next block, rehash it, it'll have a new hash and then inspect the output and say, oh, that's something I do like, I'm going to go with that.
00:14:12.394 - 00:14:47.974, Speaker A: So how do you stop that last part that we haven't yet overcome? How do you prevent validators from trying to make the system be gamed in their favor? And that's the part that's tricky, because currently on our chain, we run eight of our own validators, and it's somewhat centralized in a way. And we're actually in the process of trying to open that up for anyone who wants to be a validator. But we're not there yet. But basically we're saying, trust us, we're not screwing with the randomness. Right. And how do you get around that? Well, you need a third party, a trusted third party to control randomness. And that's really the end all, be all of this.
00:14:47.974 - 00:14:50.550, Speaker A: And that's where Chainlink starts to come in.
00:14:50.620 - 00:15:27.974, Speaker B: Yeah. So of course it's Chainlink conference. We have to mention Chainlink, and we wouldn't want to mention anything else besides Chainlink because it's the gold standard of randomness in the blockchain world. So it's very well trusted, it's decentralized. They have their network of nodes running and making sure that the most important point is it's verifiable. So it's signed with a private key, and then it's checked in a smart contract on chain. And then basically the users can know that that random number was not tampered with.
00:15:27.974 - 00:16:07.120, Speaker B: Also, in addition to those cryptographic proofs and things like that, that is a very great user experience. It's also awesome because they have great Dev docs and examples and it's very easy to get started. When I was kind of a novice blockchain dev, I got chainlink working in like an hour by following the great guides they have. So it's very kind of easy to jump in and add that to the contract. There's really a lot in favor. And then one of the biggest things as a dev is you want to be able to sleep at night and so they can kind of handle all the randomness concerns for you. And you just focus on building your smart contracts, in our case, building out our game and growing our community.
00:16:07.650 - 00:16:20.754, Speaker A: That's right. And that's it. So, Chainlink, stay tuned. We're in active talks with them, trying to get them to come to our chain and seeing how we can use them in our protocol. But we have our site set on that. We're excited to be here. And go Chainlink.
00:16:20.754 - 00:16:31.060, Speaker A: So thanks, everyone, for coming. I don't have time for questions, but come over and speak with us after. I'll be in the corner with magnus. We have some merchandise if you guys want to get some merchandise. And happy to meet you all. Thank you.
