00:00:00.250 - 00:00:49.158, Speaker A: Hi, I'm Richard, one of the developer advocates here at Chainlink Labs, and today I have something really exciting to share. We've launched a new product, Chainlink functions, which brings the power of serverless functions and cryptographic guarantees to your decentralized application. So what does this look like? Let's find out. It Chainlink functions provides your smart contract with access to a trust minimized compute infrastructure. It enables your contract to send code to a decentralized oracle network, or Don. Each oracle will run the code in a separate serverless environment. Once the oracles have their results, the Don then aggregates that information using OCR two and returns the final result to your smart contract.
00:00:49.158 - 00:01:31.342, Speaker A: Your code could be anything from a computation saving gas by running it off chain to fetching data from an API. Now it's important to note that this currently is in beta. In fact, it's a closed beta. There will be a link in the description to sign up, given that things may change from the state they're in when I am recording this, but most of you should see something that's fairly similar. You will need to take a few steps to get everything set up and running, and then you can look at both of the examples. So what does this setup look like? Well, first you're going to need to install node JS version 180 or greater. You'll need to clone the functions hardhat starter kit onto your machine.
00:01:31.342 - 00:01:56.042, Speaker A: You'll need to give some link and matic because we'll be using the Mumbai test network. You'll need to obtain an RPC URL from a node provider like infura or alchemy. You'll be using alchemy. If you follow along with this example, you'll need an API key for Polygon scan to verify your contract. And finally, you'll need your wallet's private key. Remember, that's something you never want to share with anyone. Now that you have those set up, the foundation is laid.
00:01:56.042 - 00:02:22.354, Speaker A: Let's look at the starter kit. All right, so here we have the starter kit. It's on GitHub. Let's take a look at the readme and see what we need to do. It walks through an overview explaining functions lets you know what testnets are currently supported, gets you through setting up your wallet, getting funds, and providing step by step instructions in our getting started guide if we need that. But we can skip straight to the quick start. Make sure you have node version 18 installed, and then you'll need to clone this repository to your machine.
00:02:22.354 - 00:02:43.150, Speaker A: I've gone ahead and done that the next thing we'll need to do is open up that directory and run NPM install. So let's do that now. All right, so here we have the repository cloned to my machine. I'm using vs code and we can see here that we're in the repository itself, the functions hardhat starter kit. So the first step is to run NPM install. This will install all of the dependencies that we need for this project. Great, that's done.
00:02:43.150 - 00:03:21.370, Speaker A: So what's next? Well, we'll need to go ahead and get a GitHub account set up and get a personal access token from GitHub. This will allow us to share our encrypted secrets with the Oracle network. So how do we do that? If we head back to the readme we can visit GitHub.com slash settings and from here we can set up a new token. All right, so we'll click set up new token and we'll see something like this. We can create the token name functions example, set the expiration. This is how long it will be available for description, if you like, who the owner is.
00:03:21.370 - 00:03:47.282, Speaker A: And the only thing that we need to change is we need to go to account permissions and we need to change it. For gists we need to say read and write. Once we've changed that we can generate the token. And here we have the token we'll need to copy this and use it later. We'll head to our starter kit. I'll just make a new file and we'll paste the token in here. So remember this is private, right? You don't want to share this.
00:03:47.282 - 00:04:11.726, Speaker A: I'll be removing this token after I get done recording this video so it won't be of any use. But this is one of those pieces of information that you wouldn't want to share because it does give read and write access to your gists. All right, so we've got that value stored. What's next? Well, we need to set up the environment variables. Now the way that this is done is through the Env Enc package. It will encrypt our sensitive information. So we need to set that up.
00:04:11.726 - 00:04:38.990, Speaker A: The first thing we need to do is run this NPX env enc and set a password. This will set the password to actually encrypt those values. So we'll set our password and that's it. All right, so we set up that encryption password. Now we need to set some of the environmental variables up. Which ones do we need to set up? Well, for this tutorial we'll need to set up our private key. That's going to be for the wallet that we're using to deploy the contracts.
00:04:38.990 - 00:04:58.506, Speaker A: We need to set up our GitHub API token. That's the one we just generated. You can see it above. We'll need a polygon Mumbai RPC URL. Remember, I'm going to be using alchemy for that. We need a polygon scan API key if we want to verify our contracts. And then finally, one of the examples here uses a Coinmarketcap API, and we'll need a key for that.
00:04:58.506 - 00:05:31.394, Speaker A: You can get one@coinmarketcap.com slash API how do we actually set these up? So we use NpX env from here it'll prompt us for the first variable name that we want to enter. So I'll use private key for this example. Then it'll ask us to input the value for that variable. I am not going to input my actual value here, and you'll see why in just a moment. But I'll put private key here. Do we want to set another variable? Sure, let's set another variable.
00:05:31.394 - 00:06:13.522, Speaker A: We'll set GitHub API token, and we'll set this to the value we have above. Once you've set all of these different variables, you press return and we're done. Now, why didn't I enter my actual private key? It's because if you want to check what you've set, you can type mpx env enc view, and this will show you everything that's set. So we have our private key and we have the value. Remember, I typed in private key here, you should actually input your private key. We have our GitHub API token, and I need to go through and set the rest. The polygon Mumbai RPC URL, the polygon scan API key, and the coinmarketcap API key.
00:06:13.522 - 00:06:45.710, Speaker A: So once you've got all of those set, you're ready to move on to the next step. I'll go ahead and set them now off screen and we'll be back. All right, so you set those different values, your environment is ready to go. What are we going to be looking at? The first is going to be this calculation example JS. Now, what this file is, is it's a calculation that would be very expensive in terms of gas on chain. It's a continuously compounding interest rate, and you can see here it takes in a few things. So we have the principal amount, which comes from Args four.
00:06:45.710 - 00:07:19.894, Speaker A: What is Args four? We'll get to that in just a moment. We have the APY times 100, and then we have our decimal percentage time and years, Euler's number, and the actual calculation itself. This is a very complex calculation in terms of what it would cost on chain. We're running it in a JavaScript file like this. It's super simple. We run that calculation and then we return the value rounded, this value we pass back to our contract. So we have this args value here.
00:07:19.894 - 00:07:53.170, Speaker A: Where is that coming from? Well, if we take a look at functions request config, we can see a few things here. In the actual request config, the first thing to note is the source. That's going to be that file. We just looked at that calculation example, right? That's what's going to be reading in to actually run within the functions. We also have the args, if you remember it was four and five that we were looking at and they start at zero. So we have 01234 and five. So those two values that we're passing in come from this arguments array that will be passed in to our JavaScript.
00:07:53.170 - 00:08:24.862, Speaker A: Cool. From there, the other thing to look at is this functions consumer contract. You can see how it's laid out here. We set up our contract, we have a few things set up like the last request ID, any error or response. We have some events, we construct our contract and then we have this execute request function. This is what's going to be actually making that call out to the oracle network. So you can see it initializes a request, it loads some information in.
00:08:24.862 - 00:09:01.580, Speaker A: We actually make that request and then we get the request ID back. If you're familiar with VRF functions, is kind of similar in the workflow. We make a request to the oracle network, we wait for the oracle network to get back to us with the response, and this can come back into our contract with another function. The other function is this fulfill request function. So we go out, we make the request, it runs our JavaScript code, and then it's going to come back into our contract with fulfill request. Here the fulfill request is very simple. All it's going to do is update the latest response and error values and then emit a event.
00:09:01.580 - 00:09:47.766, Speaker A: We can run it with NPX hardhat functions simulate, and what this will do is it'll run it locally on our local machine. Now we can see it got back here, this decoded value of 1 million and some change. So that's going to be the value that's actually calculated by this calculation example here where we have our total amount of interest, right? Our continuously compounding interest. Great. So we've run that locally. How do we actually deploy this? The way to deploy this is with NPX hardhat functions deploy client. We'll need to pass in the network that we want to deploy it to.
00:09:47.766 - 00:10:10.554, Speaker A: That's going to be Polygon Mumbai for this and we'll go ahead and verify it. So with this command, it will actually deploy our contract, our consumer contract. This functions consumer Sol to the Mumbai network. We'll need to wait for the block confirmations to come back and we'll have our contract verified if we want to check it out on polygon scan. Great. So it's done, right. So we've deployed our contract.
00:10:10.554 - 00:10:40.634, Speaker A: The next thing that we need to do is we'll need to go ahead and create a subscription so we can do that with mpx hardhat functions subcreate. So we'll use mpx hardhat functions subcreate we'll pass in our network. Again. The amount is going to be how much link that we're going to supply our subscription with. And then the contract address will need to be the address of the contract that we just deployed. We'll press return. It will go ahead and create that subscription for us.
00:10:40.634 - 00:11:01.882, Speaker A: Again. We'll need to wait for those block confirmations and our subscription is confirmed. Now, something to keep in note here is this created subscription ID. In my case it's seven, seven, eight. Yours will be different. We'll need to keep track of that because we'll use it in the next step as well as our contract address. So we've deployed our consumer contract.
00:11:01.882 - 00:11:33.634, Speaker A: We've created a subscription. How do we actually run a function into the Oracle network? We do that with NPX hardhat functions request we pass in our network. Gin, that's Polygon Mumbai Pass in the contract address. That's the contract that we deployed our consumer and we pass in our subscription ID. When we press return, it's going to check a few things and ask us if we're sure, if we want to continue. We'll say yes, we do want to continue. And now it's actually running that request in the Oracle network.
00:11:33.634 - 00:11:50.666, Speaker A: So submitting our request and we'll get the response back from the Don here shortly. And there it is. We've got our response back. That's pretty cool. We've run this code in the distributed Oracle network. We've saved a ton of gas because we're not actually doing these calculations on chain. Right? That's massive.
00:11:50.666 - 00:12:16.920, Speaker A: But this is just running a basic calculation. What if we want to do something more interesting, like hitting an API. Well, if we head to API request example here, we can take a look at this file really quick. It's going to use some arguments that are passed in. Remember those are going to come from our request config. So it's using one bitcoin BTC, bitcoin and BTC. It then will check and see if we have our secrets API key.
00:12:16.920 - 00:12:42.970, Speaker A: The reason we'll need that is for coin market cap. If it doesn't have that set, it'll error out. It'll then create some requests for us. Right? So these are the actual API requests. We'll hit four different APIs, one from Coinmarketcap, one from Coingecko, one from Paprika, and one from a bad API. Just see what happens. If we have one API that's not working, we'll use those, we'll make those requests.
00:12:42.970 - 00:13:13.834, Speaker A: We'll check for errors, we'll log the errors if we have them now, console log. We'll see what that looks like here in a minute because we will get an error from our bad API. And then finally, once that's done, it will go ahead and calculate the median price based on the responses. So how do we actually run this? Well, there's a couple things that we need to do. We need to go into our functions request config. You'll notice this calculations example, that's what we used just a moment ago. We'll comment out this line and we'll uncomment the one below it.
00:13:13.834 - 00:13:49.570, Speaker A: This is going to change the source file of our JavaScript. The other thing is that that new API request example, it needs those secrets, right? So we'll need to uncomment the secrets line as well, give it a save, and we'll run the same exact command that we just ran. Our contract hasn't changed. We've changed our config. So that'll get picked up by this functions request command and we're ready to go. So we'll go ahead and run this command and we'll see things look a bit different. We'll say yes, we're sure we want to run this, and we can see here that locally it decoded this new value based on those API calls.
00:13:49.570 - 00:14:23.194, Speaker A: Sweet. How does this look? When we get to the Oracle network? You can see it's using our encrypted secrets from our gist. That's really cool. And it's actually making the request to the dawn right now. Now, the reason this works is because we're using a UN in both examples and our contract's not really doing anything with the value other than logging it. If you had something more complex set up, you need to change your contract as well. But we can see here that we have our value came back here as the value of bitcoin.
00:14:23.194 - 00:14:49.300, Speaker A: We can see the transaction cost, and we can see that our gist was taken care of. So that's really cool. We've used chainlink functions to reach out to an API and bring data on chain. I think this is super powerful. I'm excited to see what you start building with this. I'm really looking forward to the potential and the power that's being unlocked with chainlink functions. So go out there and build, and I'll catch you in the next one.
