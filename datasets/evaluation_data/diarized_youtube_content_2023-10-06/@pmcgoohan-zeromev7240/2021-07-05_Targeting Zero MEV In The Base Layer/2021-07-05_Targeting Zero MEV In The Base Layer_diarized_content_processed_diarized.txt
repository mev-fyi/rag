00:00:00.570 - 00:00:28.620, Speaker A: So targeting zero mev in the base layer. So I'll start with a quick definition of mev. So mev is the profit to be made by Reordering and Censoring transactions. So this is very close to the original Flashboys 2.0 paper. Yeah, and deliberately so. It does not include block rewards or gas fees or just all the different ways miners can make money.
00:00:28.620 - 00:01:03.220, Speaker A: It also does not include latency arbitrage, and I'll come back to that a bit later. So Reordering and Censoring transactions is data corruption. Transactions are data, and so reordering that data is corruption. Now, you might be thinking, I don't see what the problem is here. Transactions seem fine to me. They're atomic, they're validated by thousands of nodes, and they're digitally signed. What's the problem? Well, my point is that data order is as important as data content.
00:01:03.220 - 00:01:46.370, Speaker A: So imagine, for example, a picture file. So how would that picture look if I took every one of those pixels in the picture and I rearranged them? So I kept the same content, but I just rearranged the pixels? Well, I might come out with something like this. Now, would you say that that is a corrupt data file? I definitely would. All right. That's corrupt data. So I've got some bad news for you, which is that each one of those pixels represents a transaction in Ethereum. So on this side, the transactions are ordered by arrival time, and on this side, they're ordered by inclusion time.
00:01:46.370 - 00:02:32.350, Speaker A: So the time they're actually included on the Ethereum blockchain. And what you're looking at here is the genuine corruption caused by the Ethereum network, which comes from the extraction of mev, gas price auctions, and meva. Mev auctions. So that's real corruption happening in the Ethereum network data was taken a few days ago. So what's going on here is that we're selling the right to corrupt transaction data in this way. So I suppose the point I'm making is you can't sell the right to corrupt transaction data and then wonder why your transaction data is corrupted. And you're getting mev.
00:02:32.350 - 00:02:54.840, Speaker A: So the point here is that mev is equivalent to Reordering and Censoring transactions. It's actually how we defined it. And Reordering and Censoring transactions, as I've just shown you, is data corruption. Yeah. So these three things here, I've done them as a triangle, but actually this is more accurate. They're equivalent. They're actually different names for the same thing.
00:02:54.840 - 00:03:21.630, Speaker A: And this is only preventable in the base layer. This is the layer it's happening in. And that's why only a base layer fix will work. So, in terms of some stats rather than some pretty pictures, the average inclusion time on the Ethereum network for a transaction is two minutes, 30 seconds. All right, that's high. That's twelve blocks, right? That's high. So that's transactions going through the mem pool.
00:03:21.630 - 00:03:55.740, Speaker A: The standard deviation is 20 minutes. 20 minutes. That's the variance. So time order is corrupt in Ethereum, and that's why latency arbitrage is not possible because latency is a measure of time. You can't have time based arbitrage when your time order looks like this. So the upshot of that is that I'm afraid to say all mev is bad. All mev is bad because it all comes from the same thing, which is selling the right to corrupt data.
00:03:55.740 - 00:04:27.094, Speaker A: So what we need is some transactional order integrity. Yeah, we need fair order. People ask, well, what's fair order? By what measure? Fair for who? How do we decide? Well, it's actually quite simple. Turns out it's send time order. Yeah. If Alice sent her transaction before Bob's, it should be included first. If Bob sent his before Alice, his should be included first.
00:04:27.094 - 00:04:49.722, Speaker A: And that's it. It's uncontroversial. So I'm not saying this is easy to do, but what I am saying is it's objectively fair. Objectively fair. And that's because it models reality. And that's what any transaction processing system is actually trying to do in the end. It's trying to audit and log and record what's happening in the real world.
00:04:49.722 - 00:05:11.474, Speaker A: And that's this. This is what's happening in the real world. So remember, mev is the profit to be made by reordering and censoring transactions. So if you do this send time order, you don't have any mev. You don't have any mev. And that also means we can now measure order integrity. Yeah.
00:05:11.474 - 00:05:48.094, Speaker A: We can define it as minimal divergence from send time, but as significantly. We also want symmetrical divergence from send time. So, for example, an example of asymmetry in traditional finance, citadel always have zero milliseconds latency. Pretty much Wall Street bets traders always have 300 milliseconds past latency. Yeah. So there's an Asymmetry between the different participants. So although the transaction order is broadly okay, on Nasdaq, the Asymmetry is not.
00:05:48.094 - 00:06:10.802, Speaker A: So looking from worst to best, I've got to tell you, I'm sorry to say this, but where Ethereum is now, we're the worst. All right? We've got high asymmetrical sentiment. Our transaction order is very corrupt. Wealthiest, best, resource benefit, inclusion time average is two minutes, 30 seconds. The variance is 20 minutes. Yeah, it's bad. So Nasdaq is our sort of nearest.
00:06:10.802 - 00:06:42.362, Speaker A: It's a good example of a centralized, regulated competitor. Now, they have quite a low error, actually, but they have an Asymmetrical sometime error. So their transaction order is broadly okay, but the wealthiest and best resource benefit, we're just going to leapfrog them, we're going to jump over them, we're going to get to here Ethereum soon. The best, right? Low symmetrical send time error, transaction order, approximates send time. All participants treated equally. This is the vision for Ethereum, right? This is where we've always wanted to end up. This is why we're all in it.
00:06:42.362 - 00:07:11.370, Speaker A: Yeah. I would suggest point is centralized exchanges can't do this. Because they're centralized, the best they can do is arrival time, which has these Asymmetries. We can do better. It's my belief that fair ordering will give us symmetrical send time order. So sounds good. Right, how do we get there? So I propose a class of solutions called content layer, solutions that could have many implementations, but broadly speaking, three characteristics.
00:07:11.370 - 00:07:50.822, Speaker A: So why do we let miners order if it leads to all of these terrible effects? Well, we can't stop them because content is centralized. So what we've got here is, and if you can see this oh, I can move this. Great. What you've got is a distributed application layer and a distributed structural layer, a blockchain. But at the moment that it most matters, when a block is created, the miner has full control, full tyrannical control over that. They're in God mode, they pick exactly what transactions they like. One computer.
00:07:50.822 - 00:08:24.594, Speaker A: All right, so the solution to this should be no surprise to anybody at this conference. It's the way Sartoshi solved double spending. Yeah, it's how we'll solve mev. We decentralize, it's not a shock. Right. So many nodes will decide the content of one block and then we get a distributed application layer, a distributed content layer and a distributed structural layer. So the next big problem we got to solve is the structure of the mempool, or rather the fact that it doesn't have one.
00:08:24.594 - 00:08:56.710, Speaker A: It's an unstructured mess. It's a graveyard for said and time order. We have hundreds and thousands, literally hundreds of thousands of transactions sloshing around at any moment. And that increased choice of transactions leads directly to increased mev opportunities. All right, so what can we do? What we can do is we can chunk up the mempool at low latency like every one to 3 seconds. And we can do this quickly because there's no need to execute transactions. We're just doing simple validation checks.
00:08:56.710 - 00:09:35.158, Speaker A: We're not updating state, we're not creating any testing blocks. So the idea is, at 3 seconds, that's about 70 transactions that anyone's got to exploit per chunk. Not 100,000 plus 70, so less mev. So for this to work, it's got to be non optional, it's got to be a base layer solution. So the content layer creates chunks. Here the validators. Write the chunks in order to the blockchain or they fail attestation that's it, there's no wiggle room.
00:09:35.158 - 00:10:06.850, Speaker A: And the idea of this is that at that point, corrupting transaction order. So disrespecting the content there would require the resources to pull off a 51% attack. And that's what we're trying to do. We're trying to escalate transaction reordering to the same level as it would take to do a block reorg. What I've described here is plain, Alex. It's the most basic content layer that I could imagine. So these are the advantages just of this most basic version of it, the simplest implementation.
00:10:06.850 - 00:10:47.950, Speaker A: So looking at me V by type, this is based on flashbots bundles and my analysis of them. It looks to me like we got 27% of mev is three, flashpots is sandwich attacks, 16% is back runs. All right, these are unambiguously exploitative mev types. So that's 43% overall. So if we have twelve second content chunks this is based on real data that I've extracted and analyzed. If we have twelve second content chunks, that could result in a 40% reduction in the most exploitative mev. Okay, sandwiching and background.
00:10:47.950 - 00:11:06.820, Speaker A: But we're not aiming to do twelve second content chunks. We're aiming to do one to three second content chunks. So the mev reduction could be greater than that. And we're not doing anything really. All we're doing is chunking up the mempool. We're not enforcing any order, we're not encrypting at this point. We're just doing something really quite simple.
00:11:06.820 - 00:11:33.446, Speaker A: So I'm not sure I've got time to go through all of these. I will quickly. These are some other advantages. So you know about the 40% reduction. We've got lower user costs, we've got better data integrity, we've got user experience improvements, we've got the remaining mev is more democratized. We've got a bandwidth reduction potentially. And I'm not even going to go into the last one, but it's good, right? So here's a possible roadmap.
00:11:33.446 - 00:12:29.578, Speaker A: All right, how do we get this stuff out there? How do we get from reducing mev to solving it? So I would propose we start with plain Alex, which is what I've described, and we can implement that relatively quickly, relatively simple. That could give us an immediate and significant mev reduction. But the fun really starts when you start doing other things with the content layer. So for example, you can have users encrypting transactions and sending them to the mempool. If we're able to chunk transactions every 3 seconds, we could use time lock encryption, decrypt them after 5 seconds, get no block delays. So what you're doing is you're encrypting transactions while the order is being established in the content there and then you're decrypting them so you get no block delays and you've got an encrypted mempool essentially. So another way of doing it would be threshold encryption.
00:12:29.578 - 00:12:56.994, Speaker A: So other speakers have spoken about this today. I quite like this idea actually of a reputation market for key spit holders. That might be quite a good way to go. Thing to bear in mind is that if we manage to do this all right, then mev is actually solved at this point because you cannot exploit transaction order to your benefit because you don't know what's in the transaction. So I wouldn't stop there. All right, we can then go on to Fair Alex. We've had Dark Alex.
00:12:56.994 - 00:13:50.490, Speaker A: We go on to Fair alex let's finish the job. So it actually looks to me as if pickers the pickers in the content. Now I'm proposing map quite closely to equitas replicas. Now if you can encrypt before you do fair ordering, you're in a really nice situation because you've mitigated collusion because bad actors are minimally incentivized to order encrypted transactions fairly. I mean, good actors are going to do it anyway, but bad actors are actually minimally incentivized to do the same because it's the least work for them, it's the least overhead just to order by arrival time, pop a transaction on a list. So it's pretty big news. And at that point, Mev is solved and we have an objectively, fair distributed system for all best on the planet.
00:13:50.490 - 00:14:30.114, Speaker A: And I've written Yay here to remind me to say Yay. Yay. Thank you everybody. So just to let you know, that best way to get hold of me if you want to continue this conversation with me, if you like the ideas or even if you hate them, is probably Twitter. So at guencrypto and that most of the documentation is a bit out of date. So, for example, most of the documentation about the content layer is based on is about Random addicts, which was a random ordered version, which I've shelved for now. It's actually got some uses, but I'm ruthless like that.
00:14:30.114 - 00:14:35.360, Speaker A: So I've shelved that particular variant for now. Okay, thank you so much.
