00:00:10.890 - 00:01:29.558, Speaker A: I'm a professor of computer science at UIUC, also the founder and CEO of runtime Verification. And today I will talk about universal proof systems, which is a framework that allows you to have verifiable computing for any programming language and any virtual machine, correct by construction, and hopefully also very fast. So what it is and where it's coming from. So, PI squared comes from proof of proof. Specifically, it will be a cryptographic proof of a mathematical proof. And PI squared combines the state of the art in mathematical logic and in cryptography, as indicated in this figure by Zk, which is the cryptography part, and k, which is the mathematical part. So what happens here is that for whatever computational task for which you want to have a correctness argument, you first generate a mathematical proof using the k framework, and then from that mathematical proof, you generate a cryptographic proof.
00:01:29.558 - 00:02:16.994, Speaker A: So you have a proof of proof. Let me tell you a few words about k, because most of you heard about Zk already, many times today. So what is k? Is a programming language framework, which was invented more than 20 years ago. And what that means is that you take a programming language, which is defined as what we call in the programming language field, a formal semantics. A formal semantics is a rigorous mathematical description of the programming language. It addresses the question what the programming language is, what is c? What is Java, what is EVM? It cannot be just an ad hoc implementation. It has a rigorous mathematical definition.
00:02:16.994 - 00:03:28.410, Speaker A: The k framework allows you to define such languages, and then it gives you tools for your language, as indicated by the blue boxes here, interpreters, compilers, model checkers, symbolic verifiers, and even full fledged formal verifiers for a programming language. Okay? So it achieves a massive separation of concerns where all these tools are implemented generically without having any particular programming language in mind, and it generates then the right tool for your language, customized for your language. Think of interpreter here, and think of EVM. So, if you define EVM in k, and then you take the interpreter of k, that gives you an effective ethereum virtual machine, an EVM, an implementation of EVM. It behaves exactly like an EVM, is almost as fast as the best implementations of EVM. It just achieves a massive separation of concerns. And it gives us this intrinsic network effect, because, as you know, languages evolve, tools evolve.
00:03:28.410 - 00:04:21.230, Speaker A: Now, you don't have to look at the combinations between languages and tools. You evolve the languages separated from the tools. All right? But what is important, so, this has been evolved by many, many researchers. I invented it in 2003, but it has many developers and researchers working on this. But what is really, really important here for this talk is that everything that these tools do, in the end, they construct a rigorous mathematical proof for what they do, even the interpreter, which is what matters here. So the interpreter given by the K framework, when it executes your program, it actually generates a mathematical proof that your program executed correctly. Indeed, that has nothing to do with cryptographic proofs, yet.
00:04:21.230 - 00:05:34.310, Speaker A: It's just a rigorous mathematical proof that your program does exactly that. So if you have the program foo and you pass the input 17 to it, and it evaluates to 42, you will get a very rigorous mathematical proof that foo of 17 equals 42 according to the mathematical definition of your programming language. It doesn't look at any interpreter or at any compiler for your language, just the mathematical definition of the language. Okay? So that's very important, because actually most tools out there, starting with interpreters, vms, and ending with formal verifiers or optimizer of some sort, all of these build on top of such kind of tools, basic bricks like symbolic execution, verification tools, and all of these generate, in the end, the mathematical proof. All right? So that's all I want to mention on this slide, that for any programming language, the K framework gives you an actual rigorous mathematical proof that the task is indeed correct. And now the interesting part comes. Let's combine that with cryptography.
00:05:34.310 - 00:06:11.378, Speaker A: Specifically, let's verify that mathematical proof with a proof checker that is implemented as a cryptographic circuit. And this way you generate a cryptographic proof of existence for a mathematical proof for your claim. Architecturally, this is how it looks. So, with the K framework, you first of all, plug and play your language. Say you want evM, or maybe you want python. You don't want any particular low level language, no wasm or EVM or anything like that, or x 86, just directly python. It doesn't matter.
00:06:11.378 - 00:06:50.046, Speaker A: So you plug your language into the K framework, and now the K framework will take claims, in particular, execution claims, which is what gives us verifiable computing. Take claims like that, and it generates a mathematical proof, this big PI phi. Think of it as a mathematical proof. Why the claim Phi is correct. For example, Alice transfers one token to Bob, right? That's a claim that you make with an ERC 20, let's say token. And what he gives you here is a mathematical proof that, yes, that claim is correct, has been executed correctly. All right, so we are here.
00:06:50.046 - 00:07:15.480, Speaker A: Now we have a mathematical proof. Now for the claim. Well, mathematical proofs are complex. They are big, they are huge, but they have a very nice property. They are very easy to check. They are hard to find, hard to generate, but once you have them, they are very easy to check. Many mathematical logics have only very few proof rules that you need to check.
00:07:15.480 - 00:08:03.334, Speaker A: In particular, our proof checker for the logic underlying the K framework has only 200 lines of code. Okay, imagine this. 200 lines of code that can verify any claim about any program in any programming language. And now the next step is to implement this proof checker as a zero knowledge circuit, which a very small circuit has nothing to do with any programming language. It's not like you have a circuit for RISC five or you have a circuit for EVM or for WASM. Forget it. You have a circuit for mathematics, which is a super small circuit, but as powerful as all the others.
00:08:03.334 - 00:08:42.226, Speaker A: Why? Because it can verify proofs generated for all the other languages. And what you get at the end of the day is a cryptographic proof, this little PI phi, that you have a mathematical proof for your Clem Phi. So it's a proof of proof, cryptographic proof of mathematical proof. Okay, so this is the ultimate argument to correctness. That's why we say it's correct by construction. You don't have to trust any ZK circuit for a particular VM, right? So some, as you know, ZK VM has big. It's a big piece of code that you have to trust here.
00:08:42.226 - 00:09:38.198, Speaker A: You don't have to trust any circuit for any VM, just one circuit, very small for mathematics. That's it. That is used with all languages and all claims. All right, so why I'm here now in this event? Well, we believe, and we started working, collaborating with the Al layer friends, that this can power the next generation ration of roll ups, and moreover, we can have universal roll ups. What does that mean? Imagine that you have a roll up in which you can write programs in any programming language or VM without having to compile to any other programming language or VM. The roll up doesn't have any hardware or predetermined VM. It's not like you have an EVM roll up or a Wasm roll up or a risk roll up.
00:09:38.198 - 00:10:15.486, Speaker A: No, you just have a roll up. And the programming languages or the vms themselves are data because they are stored on the blockchain. So I have the semantics of solidity stored on the blockchain, I have the semantics of python stored on the blockchain, the semantics of rust stored on the blockchain. So if I want to run to write programs in Rust, once I have the semantics of Rust. I can do it. And those programs will never be executed on any VM on the blockchain. It will be executed or remote, and it will generate the ZK proofs as I showed you in the previous slide.
00:10:15.486 - 00:11:13.540, Speaker A: And the roll up will just verify the ZK proofs and then approve the claims. Okay, and this is real, and this way we get consensus from the destination chain. And there is only one program, literally that needs to be run here, which is a ZKP verifier for that little proof checker. All computation happens outside no hardware, programming language, or VM. Yet you can write smart contracts and programs in any programming language or VM. And yeah, that's it for questions. Do you have an idea how big is the mathematical proof? The mathematical proofs tend to be very big.
00:11:13.540 - 00:11:44.602, Speaker A: Imagine like you have a very detailed log of your program execution, and each step in the log has like ten or so proof steps in the mathematical proofs. But here is the beauty of it. It doesn't matter how big it is. Why? Because you verify it as you generate it. You pipe the generation of the proof with the verification of the proof. Moreover, and also very importantly, mathematical proofs have a beautiful property. They are embarrassingly parallel.
00:11:44.602 - 00:12:30.880, Speaker A: To check if you have a mathematical proof which has a billion steps, I can check all 1 billion steps completely in parallel and independently of all the other steps, and I don't have to wait for the other steps to be proved. It's a perfect instance of Mapreduce. So actually, we are playing with several implementations right now of our circuit on this slide, this circuit, and we are seeing better and better and better results as we go further and further to parallelism. It will be like the ultimate recursion that we see in cryptography in snart starts because you can literally check every single step, atomic step, completely in parallel with all the others. Good question. You.
