00:00:24.650 - 00:01:04.370, Speaker A: Hello everyone. So far. I hope you enjoy all the sessions around my sort of roll up and share sequencing restaking. Meanwhile, also the economics around the brass systems. And I'm Yao Chi. Today I'm glad to share a little bit about what we've done for the past one and a half years to really help recognize multiple roll ups and try to build something, I would say brand new for this roll up space we call beacon layer. Basically it's instrument roll up interlayer for Ethereum and other chains.
00:01:04.370 - 00:02:50.078, Speaker A: So as we go into this instrument roll up, we need to talk about sort of what are the existing roll up categories we have. So one is we call smart contract roll up or classical roll ups, right? Like Arbitron, Optinesium and various Ziki roll apps like Polygon, ZKE, EVM and Ziki sync. So for these roll ups, we have sort of a sequencer network right now, mostly single sequencer by the same time, since we say it's a roll up, basically we derive the security from the l one, typically Ethereum, right? So we also place smart contracts like validity proof or fraud proof contracts, and also bridge contracts on the l one to allow user depositing and withdrawal assets. And meanwhile, as we can see, right, most of these roll ups, we also post the data, typically the comprise transaction data to the l one to make sure this data available on the l one. So later if some users or people want to challenge the existing sequencers, right, so they can just download data and just do the verification on it. And beyond that, recently we also got a lot of progress from this celestia and this sovereign roll up site. So compared to this classic rollout, right, basically we derive security from the Ethereum or the l ones, and also do all the DA and replication of the L one for sovereign rollout, typically like these roaming and submarine labs.
00:02:50.078 - 00:03:46.978, Speaker A: So what they do is they have a separate sequencer network and all the sequencing and verification are done by the sequencer network. And beyond that they also post the data to a typical DA layer like last year DA or the Eigen DA. And in contrast to doing all the proof on Ethereum on the l one, and also the bridge contract on the l one for the sovereign roll up, basically you have more sovereignty. So you can have your own sequencer network by the same time, you don't really derive the security from a dedicated l one. So basically you have the sovereignty to really handle all the staking and sequencing by your sequencer network. Meanwhile you can also rely on different bridge providers. Probably some of them will give talks later this conference.
00:03:46.978 - 00:04:44.034, Speaker A: And as you can see, right, classic rollout mainly depend on security from the l ones. And for sovereign roll up, we have more freedom to run the nodes and sequencers and posting the data to a dedicated DA. And compared to the existing these kind of two types of rollout, right, there's another new type recently being discussed a lot by Ethereum community. It's about instrument roll up compared to all the two types of roll up. For the instrument roll up, it's to another sort of extreme. As we all know, for Ethereum, the future for Ethereum scaling is really about this roll up centric scaling approach. In that case, as we can imagine for the next few years, once the roll apps become more and more mature, so we can see Ethereum becomes the main settlement layer for all different rollups and applications.
00:04:44.034 - 00:05:54.506, Speaker A: So that means you can issue tokens and transfer assets on Ethereum. And at the same time, Ethereum will also become sort of the go to DA platform. So for all the roll ups you post the data on the ethereum, and Ethereum will host the data. So right now, for most of the existing rollups, like the classic roll up, we still place the smart contract for fraud proof and validity proof and bridges on Ethereum. In that case, as we all know, right, since it's a smart contract, Amos can be controlled by multisate wallet, right? So in that case, the security IG really derived from the multisate wallet operated by the developers of different Rola teams to enhance or improve the situation, as I just mentioned, for the classic rollout, and some researchers proposed the instrument rollout way. So in that case, as we just mentioned, for the verification logic, like fraud proof, the validity proof and also bridge logic, previously they are in this smart contract. But in shrine roll up, we embed this logic into protocol.
00:05:54.506 - 00:07:13.170, Speaker A: In that case, as you can see in the future for Ethereum, if we have hundreds of roll ups, right, for this roll up, we can still have the execution in different sequences. But regarding the proof, verification and the settlement and also breeding logic, it can be in the Ethereum protocol. In that case, for any major upgrade. For each role, probably we require the Ethereum to do some software or hard fork. So the benefits we can have, as I just mentioned, basically we can further enhance the security from this smart contract security to the protocol security for the attacker. If you want to compromise one insurer roll up, right? You have to compromise the protocol level, like this Ethereum protocol level. So it's super difficult compared to zany to target attack, a bunch of modesty wallet holders right? On the other side, since we can move sort of the logic from the smart contract to the protocol, sometimes we can use precompel or even we implement at the protocol level with rust or Goco.
00:07:13.170 - 00:08:18.554, Speaker A: In that case, we can massively enhance the performance for handling this verification or bridging logic for the existing or the future roll ups. In that case, as you can see from this diagram, user can send the transaction to the execution client. These clients can be run either by Ethereum existing validators or by some other validators. But for the rollout block and the consensus client, they will be handled by the Ethereum validators. In that case, we can really improve the security guarantee for all the roll ups and also improve the performance for verification of these roll ups. And meanwhile for upgrade, right, previously, typically we do something like we snapshot or the option voting or governance mechanism, right? People do this option voting and if the proposal passes and we can upgrade version, for example from 0.1 to version 0.2.
00:08:18.554 - 00:09:48.742, Speaker A: But in the end, still a developer need to execute the proposal, right, by upgrade the smart contract chain with his own admin key or basically signed by some modes wallet without the enshrined approach, as you can see, right, it's a little bit dangerous since in the end it's sort of controlled by the modesty wallet. But once we put into protocol level and then we can light the protocol, I mean all the users can directly vote via their sort of ethereum level governance, right? So we can have a better security guarantee for the upgrade. But as we can see, right, there are so many benefits and advantages for insurance rollout. But why it's not that popular. I think the main sort of reason, it's requiring the protocol changes, as I just mentioned, either for the sort of the logic implementation, for the verification, or for the bridging or even for the upgrading, right? Right. Now mostly at the smart contract level, but once we move it into protocol level, right, it requires a lot of changes on the validators and also sometimes a consensus protocol. So it's sort of like a major refactoring of the existing l one protocol.
00:09:48.742 - 00:11:05.122, Speaker A: And meanwhile it's sort of like we push this l two responsibility to the l one. So if someone, remember Vitalik previously posted this post, right? So he's saying that I don't overload ethereum consensus. So sometimes if we push too much logic into protocol, right, then the protocol, I mean the l one protocol itself has to make the decision for your l two or roll up protocols. United case is sort of like we need to find sweet spot or balance to really sort of have the good position between the roll ups and l ones. If we put a lot of logic back to the l one protocol level and then it becomes a bit burdened. But at the same time, if we can offload some of the logic to the l one without sort of challenging too much on the performance of ethereum protocol, then it's also good, right? Because we can achieve better security and performance compared to the existing smart contract implementation. So since it's a little bit tough to modify the existing r one.
00:11:05.122 - 00:12:10.818, Speaker A: But as I just mentioned, there are so many benefits to adopt this kind of enshrined roll up approach since earlier, as you guys all know, right, we launched a lot of roll ups and the users can directly via our dashboard to launch your roll up yourself. So we need to manage this roll up. And on the back end we have these automation tools and infrastructure to automate the interpretation. By the same time we want to provide the best security and also the best performance for all these roll up since the L one doesn't really provide the infrared roll up implementation at the moment. So we come up with the beacon layer. So as you can see, beacon layer, you can treat it as an interlayer basically between the l one and also the roll ups. So beacon layer will help to provide all the benefits we just mentioned, right? The decentralized sequencing verification upgrade and also further with some social governance cross roll up messaging via this beacon layer.
00:12:10.818 - 00:13:39.182, Speaker A: So you can treat it as really orchestration layer for the rollabs. And the rollabs will be all enshrined to beacon layer, but at the same time it still derives security from ethereum because all the fraud proof bridging and all things still be deployed on the ethereum. It's like beacon layer is sort of the way for you to do a double check and as an augmentation or instrumentation layer to provide further security guarantee and also further decentralization for different rollout systems. And we just know why we need this sort of beacon layer, right? It's sort of like we want to have all the benefits provided by the insurance roll up by the same time since our not ready. Also we can have this interlayer to provide these benefits for the roll ups at this moment. So what are the parts the all layer beacon layer can provide at the moment? The first thing is about decentralized sequencing. As we all know right now, for all the optimistic rollabs or ZK rollaps, especially zkvms, we are still adopting the single sequencer approach to really provide better performance and fast improvement on the existing development.
00:13:39.182 - 00:14:48.738, Speaker A: In that case, we may have a bunch of drawbacks, right? As some people posted comments on various forums like it's still a single sequencer, it can censor user transactions. And sometimes due to the massive participants from the community for airdrops or sort of these claims, sometimes we overwhelm the single sequencer and there will be downtime for the l two s or rollouts. So then the sequencer becomes a single point failure. And beyond that, even we can say that right now, most of the sequencer run by the team, right? The team doesn't really have the incentives to basically front run user transactions. But there is still a potential in the future. Like this sequencer can have the ability to front run or create bad Meev against the users. So what we provide via the beacon layer, the first thing is about decentralized sequencing.
00:14:48.738 - 00:16:03.230, Speaker A: So we already have the multi sequencers for the rollab. So that means either via dashboard and you can quickly spin off number of sequencers for your roll up. In that case we can immediately avoid the single point failure, right? So since you have a lot of like we don't save backup nodes, but is there like you have a lot of alternative sequencers, one is done, you still have a bunch of them can really help you to produce the blocks and verify the transactions. And beyond that, since you have multiple sequencers and for the users they have more choices to send the transactions. And in that case, somehow we can mitigate these kind of mev issues beyond I, right. As we all know, for roll ups we have a sequencer also have the verification that basically before posting data to the underlying layout, l one with beacon layer, right. Since a lot of application actually rely on some soft finality from the sequencer.
00:16:03.230 - 00:16:46.234, Speaker A: For example, for most of the rollout, right, we finalize blocks within 2 seconds. For software finality, basically the sequencer generates the block within 2 seconds. But beyond that we also have another finality called hard finality. The nodes typical verifier or the proverb need to post this comprised data to the l one. And then at that time, so far we say hard finality. And some application can confirm the transaction on the l two side. But for a lot of bridges application also some malware, they want to have soft finality, but at the same time with a better confidence.
00:16:46.234 - 00:17:54.562, Speaker A: In that case, they need to run sequencer of verifiers themselves to quickly verify whether the transaction blocks are correct or not. In that case, as you can see a lot of bridges to provide this fast liquidity across different rollabs. So they have to run a lot of infrastructure nodes. And meanwhile for a lot of exchanges, they also need to make sure the transaction blocks are correct before they confirm the user transfer across different rollabs or across the rollab to the exchange server on our side. As you can see with the beacon layer, it's relatively decentralized layer to do this verification before basically the verifier posted this data back to the l one. So you can really get a more confirmed finality from the beacon layer instead of running dedicated sort of node to do the verification yourself. So in that case, with this decentralized verification feature provided by beacon layer, right.
00:17:54.562 - 00:19:20.218, Speaker A: So the applications or some middlewares, they can further reduce the cost of running dedicated nodes for dedicated rollout. And beyond that, since all the roll ups are opt in for the instrument to begin layer. So as you can see, right, with the decentralized sequencing and the verification, all the rollabs actually can have some finality on the beacon layer before we have the finality on the l one. So in that case, for some application they require this cross roll up messaging or cross roll up like this asset transfer. They can also rely on the beginner to give them some soft commitment before they really finalize their transaction or data on the l one. In that case, as you can see, right, the beginner can behave as a role to really help to interoperate across different rollabs. So in that case we can say it's sort of like we make sure the message across different roll up can be atomic, which means like when rollab a message roll up b if the beacon layer passed the message and confirmed the web beacon layer.
00:19:20.218 - 00:20:27.154, Speaker A: So in that case you can treat it sort of like finalized across these roll ups. So it further help different rollout to do quick messaging across each other. With a bunch of these nice features and benefits, we can achieve very beacon layer as this enshrined roll up interlayer. What kind of roll up architecture we have for the current all layer, as you can see from this diagram, right, we have a well structured sort of structure compared to other roll ups, because we sort of provide this roll up for a lot of applications like games, NFT and social applications. So they really need this structure as robust as possible. So as you can see, right before the sequencer we have, this aggregator actually behaves like a load balancer to handle massive traffic. Previously we did some FT mint, we got like over 30 or even 50,000 participants.
00:20:27.154 - 00:21:20.982, Speaker A: We need to scale this aggregator or load balancer elastically to really handle these users before they crash down our sequencer. So in that case the aggregator is a mass and after that it's a normal producer sequencer to precise transaction. Right. And after that, as I just mentioned, we also have this verifier system. But the cool part, the verifier is sort of like in the wasm block. So people can run it either in your pc, laptop or server and sometimes you can rerun in your browser as a live client. In that case for lot of applications, if you really want to make sure your transaction to be verified as early as possible, you can just embed this verifier into your application on the website.
00:21:20.982 - 00:22:07.778, Speaker A: So when user send transaction it can quickly verify all the transaction from the user side. And beyond that I just mentioned, right. All the things approving system are still on the l one, but at the same time we also have the extra security guarantee from the thicken layer. So regarding the typical precise to set up a roll up and user can just send a request either at our dashboard or in the future via our public API to the backend. Of course you don't really interact directly with the beacon layer and you send a request to beacon layer. Beacon layer will set up this dedicated rollout for you. It's quite customized.
00:22:07.778 - 00:23:31.626, Speaker A: Like you can specify your da, you can specify your l one. You can also specify a bunch of parameters you want like block time and also the gas limit per block. Aphrodite the beacon layer as a decentralized infrastructure, it will select some of the top reputation nodes as sequencers for the roll up, as sort of the first set of sequencers to service the user. And all these things will happen in the backend. Users or developer won't see the entire protocol is decentralized and possible. And typically I just show you right for the finality side for most of the roll ups, right, we have this soft finality and also this hard finality, soft finality when these sort of sequencers finalize the block on the sequencer level itself. And the hard finality basically finalized when the verifier or this submeter approver submeter comprise the transaction data to the l one and with being augmented by the beacon layer.
00:23:31.626 - 00:24:36.190, Speaker A: Right, we have this beacon layer to do an extra verification for all the rollabs. As you can see, apart from this soft finality and also half finality, the beginning layer will do another verification called proof of validity verification. You can treat it as this one shot fraud proof, because as we all know right now, for most of the proof, it's step by step proof with the bisection. But here the begin layer is strong enough to directly precise the proof for the entire period, time period or challenge time, basically for the verification. So in that case you can treat it as a canary detection when the sequencer generate blocks and before these blocks are submitted to the l one. And the beacon layer will do the extra verification and detect whether these blocks are correct or not. So that's why we call it canary detection.
00:24:36.190 - 00:26:07.806, Speaker A: And once the beacon layer finds, okay, your block is not valid and the beginner will signal the challenger to do the challenge to the l one much earlier than this seven day challenge period. Or it can just happen within a few seconds cinetis as a cannery detection, right. The beacon layer can quickly do the verification and further secure this security guarantee for the l two by the same time signal the challengers to do the challenge as early as possible as a summary, right, compared to the existing l two or roll up solutions right there, this beginner, as you can see, we have sort of two more lines of defense for the security guarantee. The first one, as you all know, right, if it's a single sequencer, then the software finality will be a little bit weak. But since we run multiple sequencers, then software penalty at least much stronger than a single sequencer, that's called stage one, the execution level, softer finality. Beyond that, I just show you, right, we have the picking layer to do this canary detection for all the jolaps via these proof of validity checks. In that case, if all the checks pass, that means at the verification level, we are sort of quite secure.
00:26:07.806 - 00:27:08.018, Speaker A: And for a lot of application and bridges exchange, sort of can trust this level because decentralized verification layer for them. And of course on the stage three, it's a typical hard finality. We also have basically we implemented all the verification installated for the Wasam instructions, so all the proof and execution for the blocks and transactions can be verified on the l one if there is a challenge happens. And beyond that, beyond this decentralized sequencing verification and also this message passing, right. We also have this staking and slicing for the sequencers and verifiers as you know. Right. Once we have multiple sequencer verifiers and also the proof, sometimes we need to know who behaves on a good manner and who behaves wrongly.
00:27:08.018 - 00:27:58.290, Speaker A: In that case, we need to apply this penalty mechanism. It's called staking slashing. So you can either do the staking slashing on the beacon layer, which is in an enshrined way, and you don't need to deploy smart contract, it's highly sort of secure with beacon layer, or you can also do it on the l one side where the smart contract we already deployed for these different rollabs. And beyond that, as we just mentioned at the beginning, the upgrading is very important because we don't want the smart contract to be upgraded by a single admin address. Right. So in that case, beacon layer will also handle the upgrade for you. So you can lie to the community, do the on chain voting on beacon layer.
00:27:58.290 - 00:29:21.754, Speaker A: And if the proposal is passed, and then we can sort of pass over the wasm battery basically for the next upgrade where the beacon layer pushed to different rollouts. That's how we really handle and manage multiple rollouts and for their security batches and also this upgrade for some major features. So everything is automatic via the beacon layer and pushed to different rollabs. And meanwhile you can also arrange some on chain governance beyond this upgrade and since it is fully on chain, you can just get all the traces for the votes and everything is transparent. So as I share so much about this beacon layer, right, as the infrared roll up interlayer for Ethereum and in the future, probably for body chains, the end goal is really to provide the best security guarantee and also decentralization for the roll ups as much as possible for a lot of these customers and projects who embrace the web three as the future. So right now, what are the stuff you can do in the community, so you can participate in our beacon layer staking and also this Rolab staking. As I just mentioned, these features are quite advanced.
00:29:21.754 - 00:30:07.230, Speaker A: You can just try it out right now. Meanwhile, you can also interact with this decentralized sequencing rollab. And we already run a bunch of these sequencers for the rollab and with proper proof. And beyond that, what you can expect to come soon, one is like soon you can start to use the docker and some other tool to join our beacon layer. There is a no joining page. And later on you can also try to do some challenge to these setup by us or by some community members. And meanwhile the ROS dashboard will also support this persistent flash layer.
00:30:07.230 - 00:30:35.940, Speaker A: And as Amroid and just mentioned, the arbitrum orbit is also integrated into our rust platform very soon. And meanwhile there's another very big partnership announcement coming soon and just stay tuned. Yeah, thank you for your time and hope you really enjoy this new concept of beacon layer. And meanwhile, hope you really enjoy your future sessions in today's. Conference. Thank you.
