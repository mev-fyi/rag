00:00:25.410 - 00:01:11.230, Speaker A: My name is Neil and I'm the founder of Eclipse. So for this presentation, I'm going to just go through one slide deck, which basically explains some of the technical things that we think about at Eclipse and how we're approaching them. And then we're also going to get into what we think are ideal use cases for app specific persistent roll ups, such as what we're building at Eclipse. So I'm gonna go ahead and pull up this deck here. You all right. So this is a technical explainer, so it assumes some knowledge of what roll ups are and things like that. So this gives a little bit of context on what were the scaling solutions that historically existed.
00:01:11.230 - 00:01:59.262, Speaker A: One being, you have alt L1s like Salana, you have what was previously Terra. You have a bunch of near aptos. So these are all basically new layer, one blockchains that do their own consensus, and they also handle execution and other functions that a blockchain typically does. And then you have in that same vein, in the sense that they're trying to find a scalability solution that provides a general purpose chain for everyone. You also have roll ups or traditional roll ups that's like Arbitrum, which is anchored directly to Ethereum. They have a canonical bridge contract, and then they do a bunch of execution off chain and eventually commit that result back to ethereum. So these are shared chains, and I grouped them together because you might think that it makes more sense to group the alt L1s with app chains, which I'll get into next.
00:01:59.262 - 00:02:44.730, Speaker A: And then roll ups would be its own category. But in our opinion, the way that these are grouped, and the reason why we've grouped them this way, is because you have a shared chain, which is inherently non customizable, but it's highly convenient. And on the other hand, you have an app chain which is extremely customized. But in order to spin up like a Cosmos app chain or a polkadot parachain, you have to typically, in the case of Cosmos, you have to bootstrap security, meaning that you have to get a validator set, you have to put up stake. And in the end of the day, your fixed cost for running this chain ends up being seven figures or more, as opposed to using something like Solana or one of these shared chains where your fixed cost is basically zero. You don't have to run any activity if you don't want to. But now you have this marginal cost, which is whenever a user runs a transaction, they have to pay some amount in rent.
00:02:44.730 - 00:03:25.482, Speaker A: So you're basically paying rent to this shared chain, or you're trying to roll at your own and be a homeowner. So the question is, given that app chains give so much more customizability, they give a lot of dedicated throughput, why did they not take off? And our answer is that it really comes down to convenience and it's really difficult to spin up an app chain as it exists right now. The other part of it is that you end up with security fragmentation and we'll get into that. So these are the properties of roll ups that we really like and we want to borrow that. So that's what we're offering with Eclipse. In the same way that Alt layer offers these temporary roll ups, which are intended as burst capacity, eclipse offers a permanent roll up. And this is intended to be app specific.
00:03:25.482 - 00:04:30.218, Speaker A: We support some chains that are not app specific, such as what we're doing for injective or Polygon, but a lot of our chains, probably over like 90% of them, are dedicated to a single app and they build in customizations that make sense for their application. So this is just a thesis on what this will do to value accrual once a bunch of apps are on their own layer threes. And layer three is kind of a term that's a little bit fraught because typically, like L two implies that you're using Ethereum for DA and you have a bridge contract there, which is not what an Eclipse roll up looks like. So instead we'd want to separate it a bit and we'd say its own execution layer. So when you have an app that's on its own execution layer and it's free to switch a DA layer, then that basically forces the data availability layers into competition with each other, whether it's Ethereum or some other DA layer. And that's good for the app because it means that the layer one doesn't have as much pricing power. So historically, the Fat protocol thesis was basically that if you're an app on a layer one blockchain, people will speculate on the layer one blockchain if your app succeeds and therefore the layer one blockchain will get a lot of the upside, even if you're an app that's very successful.
00:04:30.218 - 00:05:17.342, Speaker A: Whereas when you're on your own chain, you can capture a lot of that value yourself. So that's one of the big values of being on your own chain in our view. So these are some of the design trade offs because what we want to do is offer customized roll ups where you can pick a virtual machine, you can pick a base layer, and sometimes you can pick some other features such as a customized gas token or custom block times that are suited to your type of app. So how can we provide that in a way so that we don't have to do everything in a one off manner and we don't have to do something that doesn't scale? So the first question is how do you offer multiple bytecodes? We want to offer EVM and we want to offer SVM in the future. We want to offer movevm bytecode or possibly something else. So there's a few different ways we could do that. One is we take an existing roll up framework and we basically implement an entire virtual machine within it.
00:05:17.342 - 00:05:58.966, Speaker A: And that's actually something we might do with Sovereign Labs, where we take the Sovereign SDK and add in. I mean, Solana has the virtual machine implemented as Solana RBPF. Of course, then you lose the that's more of like a bytecode interpreter rather than a highly parallelized virtual machine. But my point is that you basically have to take this for every bytecode. You take the roll up SDK, you'd implement the new bytecode and you'd get it working with the rest of your systems. Hopefully the settlement for whatever roll up framework you use is built generically so that you can support arbitrary VMs like that. Hopefully your Bridging doesn't need to be rebuilt substantially, but this ends up not really having a lot of there's no wave that you can ride.
00:05:58.966 - 00:06:32.338, Speaker A: There's no one else who's going to be doing this work for you. You're going to basically have to re implement all this yourself, similar in that same vein as Zksync. And what they did with the LLVM intermediate representation, where they basically compile everything down to this IR. So they did this with Solidity, with Yule, with a bunch of other languages. And that's nice because it's one general intermediate representation that you can build all of your infrastructure around. But the downside is, again, you have to kind of do this all in like a one off way. You have to compile everything to this IR.
00:06:32.338 - 00:07:07.198, Speaker A: So what we did was we basically picked the Solana VM largely for this purpose, which is mean. One, it's highly parallelized, you get a lot of throughput, but two, it's already on the path to supporting multiple bytecodes. And most of our chains are actually EVM and we support that by using a project called Neon on Solana. Solana obviously supports its own bytecode, which is sometimes called SBF Solana bytecode format. And then we have other bytecodes that are on the way, like movevm. So this is a huge advantage in the sense that we get local fee markets, we get all the tooling that's built for the Solana VM. It's a very powerful execution layer.
00:07:07.198 - 00:07:44.670, Speaker A: But the downside is it's really not built to be a roll up. So we have to do things like insert a smart merkel tree. We have to sometimes change some things about how the in the future we might have to change the mempool in order for it to work with shared sequencers. So these are all things that we have to make like we have to roll on our own. So the next question is how do we do settlement? Should we do a typical smart contract roll up, which would be on Ethereum, and that would be the smart contract that determines the canonical chain. Another option is you make it do sovereign settlement, so somehow you pass proofs directly to Litecoins. And one big advantage here is Verifiability.
00:07:44.670 - 00:08:43.690, Speaker A: The advantage of being on a smart contract on Ethereum is that people say it's trust minimized in the sense that if you run an Ethereum full node, then you know that whatever state that Ethereum full node contains is the correct state for the roll up as well. But that only works because running a full node on Ethereum is essentially running a light client for every single roll up on Ethereum because that smart contract bridge is a light client. So alternatively, you can just write a settlement. You can run a roll up that directly passes those fall proofs to a light client that your community or your users run, and they can directly verify the correctness of the roll up. And then the last option is actually what we ended up going with, which is we have everything deploy the one event trust assumption smart contract roll up onto a shared settlement layer. So that's nice because you get that trust minimization with respect to the settlement layer, where anyone can submit a fault proof. In the case of it being a ZK roll up, then you can just validate the ZK proof within the settlement layer.
00:08:43.690 - 00:09:23.354, Speaker A: But then the settlement layer itself is a sovereign roll up. So the settlement layer passes fault proofs directly to Lite clients, and in the future the settlement layer will be a ZK roll up. So that's the design that we ended up going with, and it also gives us a lot more ways to build in convenience features for our roll ups. For example, you can imagine a world where you don't want to move your liquidity between every single Eclipse chain. So instead you just leave all your money on the Eclipse settlement layer and you use account abstraction or something to sign transactions for these different chains, and then someone relays those transactions and they get compensated on the settlement layer. Or you could use a settlement layer as a sequencer set. So that's the idea behind why we have the settlement layer.
00:09:23.354 - 00:10:02.998, Speaker A: You don't have to use it. You could theoretically run your own Eclipse chain, run the sequencer yourself, but then you're lacking a lot of these network effects. The next question is how are we going to get from an optimistic roll up to a ZK roll up? We built the fault proof ourselves in house, but we really didn't want to build a full ZK VM in house because it's a lot of work and it's kind of an arms race in the sense that we'd have to continually update this virtual machine. So we really didn't want to build our own in house one. So we looked at a bunch of existing ZK VMs or ZK proof systems as a service, and that's things like Risk Zero. That's like Axiom Neil foundation. Ultimately, we picked RISC Zero for the reason that it's highly portable.
00:10:02.998 - 00:10:36.994, Speaker A: Risk Five bytecode is pretty generic, and we could probably switch to something else down the line if we really needed to. But the Risk Zero team is also interested in working with us. And we found through our cost benchmarking that it ends up costing about ten cents to prove a nontrivial transaction. And that's without any additional optimizations. It's just using straight risk five bytecode. And what I mean by that is we take a Salana program and rather than compiling it to Berkeley packet filter bytecode, which is the normal bytecode for solana, we compile it to risk five bytecode instead, and we run that within the risk zero virtual machine. So that's a high level implementation.
00:10:36.994 - 00:11:07.214, Speaker A: In the future, let's say we wanted to cut down that cost even more. We might natively implement the BPF circuit and we can still reuse risk zero's proof system. So this is just summarizing what I just went through. This is on decentralizing the sequencer. This is enough of an open question that I won't go into, and I want to start getting into the applications that we're able to support. So I'm going to just gloss over this. This is stuff on Wallets Bridging and this is the application part.
00:11:07.214 - 00:11:56.490, Speaker A: So this is a case study on Worlds. Worlds is a game that's building on Eclipse and they basically use the blockchain as an open API, so they write a bunch of read only data onto the blockchain. These guys built Unreal Engine Five previously, so they're really hardcore game developers. But they see the purpose of the blockchain as a highly composable API where players in the community can build things like financialization on top, they can build their own primitives, they can build their own user generated content, but you also have this base read only primitive which people can use and compose on top of. So that's what they're doing. And if you think about it, they're already conceding that to some degree this is centralized because the company themselves is acting as the oracle. They're signing off on the data that's being posted to the chain, so they don't really care about the base layer being decentralized.
00:11:56.490 - 00:12:33.286, Speaker A: Right here I have Celestia written as a DA layer, but actually in practice right now we just have them on centralized DA because it's a very high volume of transactions and they're very low value on average. So that doesn't make a lot of sense for them to be posting and paying money to an actual decentralized DA layer, at least in these early stages. So that's what the base layer looks like. The sequencer itself is centralized because they don't really need to have a sophisticated decentralized sequencer set up. And this is a very consumer oriented chain, so they even take USDC for gas. So that's the setup of a consumer chain on Eclipse. This is what we're doing for Worlds.
00:12:33.286 - 00:13:07.874, Speaker A: We're doing this for a handful of other projects like Gridiron Boulevards, Ether Games. We have Social Future on the social side. So it's basically like a highly centralized chain that supports extremely high throughput, but it can compose with a bunch of decentralized chains on the side. You can build your own primitives on top of it as a community, and that's how they use the blockchain. And this is just a way that we think about different types of applications. This gaming template is more like a general consumer template at this point. And as you can see that it's running the SVM, but it's actually running EVM bytecode within the SVM.
00:13:07.874 - 00:13:40.766, Speaker A: This is not actually what our DeFi template looks like, but we're still hammering that out with some of our DeFi design partners. We do a lot of SVM roll ups for layer one blockchains. So this we're still thinking about how we're going to incorporate into our self service offering. But basically you spin up a chain that has a custom data availability layer, so it posts blocks somewhere. And then Eclipse needs to also know how to read those blocks as well. So this might require in the future, maybe teams would make a PR against the Eclipse code base. They'd show how to post and read from some new DA layer and then they can spin up an Eclipse chain that does that.
00:13:40.766 - 00:14:10.170, Speaker A: And then we do a bunch of deep end projects or decentralized physical infrastructure networks. That's like a react wave wind IoTeX. These guys are taking real world things and they're doing some work off chain and they're able to prove that it happened on chain. And then they can incentivize people to participate in the network via some tokens such as what Helium did. They can take that data, they can optimize it so that they can save you money in the real world. They can sell the data. There's a bunch of different business models that you can do once you have that all on chain.
00:14:10.170 - 00:15:02.278, Speaker A: So this is just a bunch of other more fringe use cases and that's pretty much this Dag. So that's the first presentation that I wanted to get through and I think we have a little bit of extra time. So I'm going to go through some more detailed case studies. So I'll go ahead and pull up this case study, which is just a deeper dive into worlds. And what I want to drive home here is that for a consumer chain, like a game that's posting, if it's fully on chain, posting something on the order of hundreds of thousands or millions of transactions on chain, then even if they're paying something like ten cents a transaction, that's probably prohibitively expensive for them. And why would I even say it's $0.10? It's because if you look at the Ethereum DA cost, which is a fee market, it ends up being about ten cents to post 200 bytes to Ethereum.
00:15:02.278 - 00:15:46.882, Speaker A: And then maybe you'd want to charge a little bit of a markup on that because you have a fixed cost associated with running the sequencer for your roll up. So maybe you charge like an additional two or transaction so you'd end up paying something like fifteen cents per transaction. So you'd have to ask whether users are really comfortable with paying fifteen cents per transaction, and whether it's worth it for them to post millions of transactions on chain, given that the value of each transaction is pretty low. So given that structure and given the economics of it, it doesn't really make sense, and we'll see what the fee market on Celestia ends up looking like. But in practice, this kind of chain should use some sort of centralized DA. And in the future, once this is a ZK roll up, it's probably not that big of a deal either. It's essentially a validium construction, and by centralized you could do a DAC like a data availability committee.
00:15:46.882 - 00:16:31.560, Speaker A: You could make it quite affordable to have data that theoretically could be withheld, but at least you get guaranteed correctness by virtue of the validity proof. So that's what we have as far as how we've been thinking about gaming and why our setup makes a lot of sense. For games, we let people pick the DA solution. So if you do have higher value transactions, and of course you could use a decentralized DA, it's EVM because they wanted that portability, they don't mind a centralized sequencer, and then they want to use something like USDC for gas. So they've demoed their game in a couple of our game nights. We had one over in Denver, we had one over in San Francisco at GDC. And if you're building a game, then we'd love to chat with you because we can likely arrange some similar setups with you.
00:16:31.560 - 00:17:00.538, Speaker A: Okay, so that's worlds. And then let me go ahead and pull one up for Injective, since this is another one that we're pretty public about. So Injective's chain is called Cascade, and this is a Solana virtual machine chain that Injective runs. So they're a layer one blockchain. Injective supports WebAssembly programs, so it's rust as well. But let's say a Solana program wanted to deploy to the Injective ecosystem. They'd basically have to rewrite a lot of their logic.
00:17:00.538 - 00:17:32.650, Speaker A: So by having an SVM chain, Injective can basically promote these projects. They can encourage them to deploy to this SVM roll up. They can easily deploy and they don't have to rewrite any smart contract logic. And then that chain charges Injective's native token for gas. So that's like the high level on how the value accrues back to Injective. Of course they also have an IBC connection back to Injective. We're working around some other stuff they want to do with the sequencer, whether it's by adjusting the block time, they might want to use a shared sequencer such as Espresso.
00:17:32.650 - 00:18:06.530, Speaker A: But this is a high level setup of what these roll ups for L1s typically look like. It's bringing them a new execution layer and it's charging Gas their native token. So soon we're going to be actually deploying an EVM chain for Injective as well, because they want EVM compatibility. So this setup is pretty general, so there's probably not as much to cover on this one. We gave a couple of options for them initially because this was one of the earlier L1s that we ended up working with. Since then, we've engaged with BNB chain Polygon Near. We are spinning something up for Nibiru.
00:18:06.530 - 00:18:29.900, Speaker A: There's a few other Cosmos chains which we're still in the works with, and we haven't quite finalized what that would look like. But we've basically done this a handful of times, so that's what we've been doing. Been doing roll ups for L One, has been doing games and consumer, and more recently we've been entering DeFi. That's the high level on what Eclipse has been doing, and feel free to reach out if you have any questions.
