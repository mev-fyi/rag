00:00:09.370 - 00:00:46.390, Speaker A: I know it's been a long day. I thought I'd start off with just quick question for the audience. Who here has played a web three game? Can I get a show of hands? Okay, there's a few I can see, maybe about ten. Hopefully after this presentation that number will go up. Look, my goal for this one, hopefully it's not too heavy. I know there's a lot of really in depth technical sessions. My goal is effectively just to showcase what we build and how we think that this is going to be, again, the gaming infrastructure for the future of web three games.
00:00:46.390 - 00:01:27.270, Speaker A: So, a bit about myself. I am a principal engineer and product lead for immutable, previously working on immutable X, but more recently we've been building immutable ZKVM, as well as the app chains and everything else. Okay, so I thought I would give a quick, high level overview of immutable. Right, so I think you guys might have heard like immutable gaming, gaming platform. But what exactly are we building? So this too gives, I guess, a good overview of exactly what we're building. As you can probably tell, there are components in the infrastructure. You've got the roll ups, immutable X and immutable ZKVM.
00:01:27.270 - 00:02:05.074, Speaker A: We've also got a suite of products on top of it. So for the player experience we've kind of categorized it this way. But we have checkout down at the bottom, which is effectively a fiat on and off ram solution. It's also a bridging solution as well. We have passport, which is one of our key products, which is an identity and wallet solution, which I'll talk a bit more about. For the revenue engine, we have what we're calling the global order book. So effectively, if you publish orders to our order book, then effectively this is shared across applications and games that are building on immutable platform.
00:02:05.074 - 00:02:39.102, Speaker A: We also have a minting service that just generally makes it easier to mint. And this was one of our core ips on immutable X, so we're bringing that over to immutable CKVM. We have a commerce set of products. So this is things like primary sales, effectively, different ways for games to monetize on their side. We have a suite of products on that front as well, and we have developer experience. So things like gaming sdks, we have a unity SDK, the blockchain data APIs, to effectively make it easier to read structured data for games on chain. And we have a developer hub as well.
00:02:39.102 - 00:03:37.914, Speaker A: So that effectively, if you want to set up a new project if you want to basically just configure your collections and everything else and you want to see them all in one place, that is the place to go. Okay, so this is just a quick comparison between immutable and some of the other platforms that you guys might have heard of in the space. But as I mentioned previously, we build not just the infrastructure or the platform level, we build basically the entire vertical integration as well. And yeah, these are again, some of the other those you might have seen like obviously Arbitram, avalanche suite, Aptos and so on and so forth. So obviously the reason being for this is that we think that in order to build a successful web three game, we can't just build the platform level. We have to build both the roll ups, tweak certain parts of it, make it fit for purpose, and kind of build the different layers of this vertical gaming stack. Okay, so I thought I'd quickly just cover passport.
00:03:37.914 - 00:04:12.506, Speaker A: This is one of our key products, but the rest of the presentation is going to be on roll up, so don't worry. But passport is effectively what we're calling a wallet and identity infrastructure for web three games. Games generally love this product, but one of the key benefits is that it offers a single identity, so we can effectively integrate with different ssos and so on and so forth. And you effectively have a single on chain identity across any immutable chain. The second thing is it's a secure wallet. So you guys might have heard of account abstraction. We've effectively designed a centralized version of it that is inspired by 4337.
00:04:12.506 - 00:04:49.000, Speaker A: And we also have an NPC wallet version on immutable X as well. So if you are building on any of the immutable chains, you will effectively have this single identity, single wallet that you can use. We have this thing called immutable Guardian as well. This one is a bit unconventional, but it's really important because it provides that fraud detection and second layer protection for users. So for example, let's think about, let's say session keys. Let's say you define a set of scopes and domains and let's say you have some unusual activity happening on your account. So we can effectively protect gamers from these sort of situations as well.
00:04:49.000 - 00:05:14.320, Speaker A: A few other things just we're cross platform. It's a one wallet for all marketplaces and games. Building on immutable, we have this thing called the passport Relayer, which effectively provides currency and gas abstraction. So gas is one of the biggest, obviously friction points. And we've built this relayer as well. And of course we have, through passport, more monetization opportunities for games as well. So quite a few things over here.
00:05:14.320 - 00:05:40.730, Speaker A: All right, so we're getting to roll ups now. I just wanted to quickly do an overview. So sometimes people get confused. The company is sometimes called immutable X, but actually immutable X is just the roll up that we build with Starquare. So it's an optimized, game specific ZK roll up. There are only a very custom and small subset of primitives that you can actually operate on. So for example, things like trading, minting, depositing and withdrawing.
00:05:40.730 - 00:06:22.466, Speaker A: It's obviously super fast, it's super cheap, there is no gas over here, and we have obviously zero knowledge roll up. So it's effectively a validium that's game specific or optimized for games. On the other side, we've got this Evmzik roll up, which I'm going to talk about for the rest of the talk itself. Obviously, one of our biggest requirements from games is that they also want to be building with a lot of the EVM ecosystem tools and also have the ability to deploy EVM contracts as well. And so this is the reason why we build the ZkVM as well. So yeah, you guys can see a quick summary of the differences. There is obviously gas on ZKVM.
00:06:22.466 - 00:06:57.460, Speaker A: So this is one of the biggest friction points that we're trying to solve as well. All right, so I thought I'd get into for the rest of the talk, talking about firstly, ZKVM, how we've built it, and effectively, what our plans are in the future as well. So in terms of very briefly like requirements. One, obviously we prioritize heavily on safety, right. Games operate at a very high tick rate, at a high frequency. And so we need to make sure that there are no forks or reorgs. And basically the state of the game will proceed forward.
00:06:57.460 - 00:07:15.382, Speaker A: Obviously, high throughput, low latency. Latency is a really big issue. So definitely do keep that in mind as I go through the solution itself. And obviously low costs ideally. Right. Hence why we're building a roll up. Okay, so what do we have today? Well, today it's quite simple.
00:07:15.382 - 00:07:40.814, Speaker A: We have immutable ZKVM. It's an l, two, it's a roll up, but more technically, more technically correct. It's a validium. So we don't post the data on chain onto Ethereum. So having run the numbers, the data cost today would take up, let's say 85% of the cost itself. So that itself is very expensive. And obviously, if we do post the data on chain, we'll have to in some way kind of pass the buck to the user as well.
00:07:40.814 - 00:08:18.058, Speaker A: And so that will generally increase the cost as well. So we effectively run avilidium today. And yeah, this is what we have today. Now in the near term future, we do plan to have app chains again, you guys probably have seen this sort of topology quite frequently. The app chains are going to be settling on ZKVM. So basically we get this benefit of obviously these execution charts that are running and effectively still being secured through ZKVM to Ethereum. And yeah, so this is what we plan to have.
00:08:18.058 - 00:09:03.530, Speaker A: I'll also mention over here that obviously as games, we have specific requirements, for example, for games supporting a billion transactions per day and so on. And so you can kind of see the bottle like if everyone was operating on just a single chain. So that is one of the requirements. The other side is, some of them want to have their own native gas token, their own staking token. I talked about the throughput limitations as so, you know, as these requirements come on board, we do need to be able to support and scale multiple different app chains as well. Okay, so I thought I'd talk briefly about the question of why and what the purpose of ZKVM is. So the first thing is, as you guys know, like with l three s settling to l two, it's shared settlement and security.
00:09:03.530 - 00:09:54.026, Speaker A: Now, to us, this is really important for the cross chain experience. So, as I mentioned, you have games that are spanning or requiring a billion transactions per day, and they need to span multiple different app chains. So let's say, to put some more concrete numbers, at a 30 million block gas limit, at 50% consumption, you generally need about 20 different app chains in order to support that kind of load. So not a single digit number or like a single app chain can do that. So, one of the really good things about running on zero knowledge proofs is that we don't have that challenge dispute period. Right? So you guys might have seen with optimistic rollups, you've got that challenge period. You can obviously reduce that down with something like any trust on arbitrum with Redstone, you have like an additional challenge period, which I like to call like an optimistic, optimistic roll up.
00:09:54.026 - 00:10:37.650, Speaker A: So yes, there are ways using the optimistic roll up point of view, but there is a lot of complexity built in on that front. And there's a lot of trust if you want to try to reduce the challenge period. And so we do ultimately believe that zero knowledge proofs is the way to go especially for us. So in order to enable that really good crosschain experience, and obviously the security of having messages passing to and fro our different app chains, this is effectively the underlying technology that we use. Okay, so purpose number two, shared liquidity. So, as I mentioned, you have games spanning 20 different app chains. And it's not uncommon to have situations where, as a user, as a gamer, you've got, let's say, USDC on multiple different app chains, and you want to use it on another app chain.
00:10:37.650 - 00:11:30.550, Speaker A: Right? Now, you guys might have heard of the problem, liquidity fragmentation. And what this means is effectively, without ZkVM, you could have a situation where you're bridging to one of the app chains, let's say one and then two, and then let's say someone else builds another bridge that goes from two to one, and then these two tokens will not be fungible with one another. So one of the purposes of ZKVM is that we want assets to go through ZkVM such that you have a single fungible token without any of the liquidity fragmentation problems. And obviously, if you overlay something like immutable and the passport solution as well, you can create a really nice experience such that it all feels like a single chain. And that's really that unified experience is the goal for ZKVM. All right, the next thing I want to talk about is shared data availability. So as I mentioned, immutable ZKVM is a validium.
00:11:30.550 - 00:12:02.386, Speaker A: So that means we don't post our data on chain to Ethereum. Right now, the data is effectively hosted and run by the validators of the network. So the sequencers is another term for it. But we can also use things like a data availability committee, which we do use on immutable X. So we effectively have a set of eight partners that are running as a DAC. But additionally, we can also use other external DA layers as well, like avail Celestia and so on and so forth. So we're not vendor locked in any way.
00:12:02.386 - 00:12:37.866, Speaker A: And we can always extend to support those. Now, in terms of the app chains. So obviously one option is that app changes, just post all the data onto Ethereum directly. Right? But we all know the throughput limitations with doing so. And so the alternative is effectively you post both the zero knowledge proof and the data blob to immutable ZkVM. So you may think, okay, immutable ZkVM is a validium. Does that mean all the app chains also have to be validiums? Well, they're validiums with respect to Ethereum, but they're roll ups with respect to immutable ZKVM.
00:12:37.866 - 00:13:34.510, Speaker A: So it's more of a point of reference thing. Now, I think one of the interesting things that we are looking into is, again, having the DAC participate in some way. So there is some overlap between the DAC and the validators and sequences on ZKVM. So there is some skin in the game in a sense, between, again, Doe is participating in DA and Doe is participating in census for the execution itself. I would also mention that once 4844 comes along and we get that two orders of magnitude reduction with ethereum, we are considering more of a volition setup. But we think that at least today the UX challenges are we have to cross those UX challenges in order to support a volition. So you can imagine gamers seeing the option to either post their data on chain or off chain, and they're like, what exactly is going on here? And so there's a lot of ux challenges that come along with that.
00:13:34.510 - 00:14:11.066, Speaker A: So something to keep in mind as well. And finally, purpose number four is shared sequencing. So the benefit of having available as AVM is that we can be able to act as a, let's say atomic interoperability layer. So we get transactions from multiple different app chains, we effectively sequence them. Let's say we perform some degree of soft execution to make sure that the chance of it being reverted is much lower. And then we basically distribute those blocks to different app chains. Right? So this is a term that you guys might have seen in different conferences and talks, but this is something that we are considering as well.
00:14:11.066 - 00:14:55.094, Speaker A: This is definitely more of a future facing thing. And the goal of this is to basically couple the shared sequencing layer with something like passport, right? So you can imagine at the UI layer you have passport and let's say define some sort of intent. DSL, you can define your requests, you can define your constraints, and then under the hood you have something like ZKVM that acts as a shared sequencing layer as well to provide that atomicity. All right, so I thought I'd now deep dive into immutable ZKVM, talk a bit more exactly, of what is going on inside this black box, and talk about where we plan to go from here as well. Okay, so this is what we have today. Looks super simple. We effectively have a single sequencer, it's running a go Ethereum fork.
00:14:55.094 - 00:15:27.038, Speaker A: We've modified, we haven't touched the VM or the execution layer itself. We effectively just made it a bit more enterprise friendly. So we introduced things like transaction block list, an allow list for deployments and things like that. So you can say a minimal, a vanilla get fork with RPC modifications. And then we have a set of RPC nodes that are basically what other people will connect to. So none of them effectively connect directly to the validator itself. Now, we've set to become a single sequencer.
00:15:27.038 - 00:16:20.226, Speaker A: We've set it n is equal to one to avoid having forks or reorgs with a validator. And there's a lot of other smart engineering things that we've done over here to make it such that no forks will ever, ever happen. So we've introduced things like invariant checks and so on. All right, so one of the requirements that we have is that we have certain games which have a very strong, what you would call like localization and trust with entities within their region. And so part of that is they require one of those parties to run a validator node as well. And so the reason why the next phase in this, instead of zkps, which a lot of other roll ups are prioritizing first, right, the proverb first and then decentralization is for that reason. So we're thinking of introducing pos BFT like algorithm.
00:16:20.226 - 00:17:04.254, Speaker A: We don't expect it to go beyond n is equal to 30 because at that point it will affect the latency as well, because you have multiple different round trip times for consensus rounds to go through. And yeah, you have, I guess, this topology between the validators and the RBC nodes as well. So yeah, this is where we're thinking. And then the next one is effectively introducing the zero knowledge prover. So here, this is where we plan to, or at the moment, we're looking at something like type one zkvms. Obviously, Polygon has zero that we're looking at, but we're also not limited to type one. So we're also looking into things like type two s and so on, which are generally more ZK friendly.
00:17:04.254 - 00:17:49.026, Speaker A: So for us, as you guys should also know, is that games are very cost sensitive. And so yes, compatibility is super important. But remember, type two s are also equivalent at the VM level. So the other side to this is effectively the cost as well as, I guess, the future compatibility of these zero knowledge provers. Now, the one thing I do want to call out over here is what I call the multidimensional knapsack. Problem is, as you know, with gamers, even the concept of gas and execution is already very sometimes difficult to grok and so that's why we build passport. One of the very key ux problems that we need to solve over here is effectively, when you have this multidimensional markets where you have execution, you have data.
00:17:49.026 - 00:18:30.782, Speaker A: Let's say we post the data on chain. It has its own market, right? The blob space market. And then you also have this thing called proving now, right? So proving with itself brings certain constraints within the circuit, and it also has potential overflow plotments, right? So we want to be able to surface all these market and their constraints early on in the transactional experience. And so effectively, when we introduce a ZKP, we need to be able to solve these UX problems. So that's another thing to consider. It's not just adding the prover, it's also considering all the other UX problems to solve as well. And yeah, as part of this, obviously we need the zero knowledge verifier, we need a roll up contract as well.
00:18:30.782 - 00:19:46.066, Speaker A: And obviously, one of the benefits of what we call inheriting ethereum security is that we can always fall back to a anti censorship route through something like ethereum, which basically forces the sequencer to process a transaction, let's say, in a situation where there's like liveness issues with the sequencer as well. So this will come with the phase that introduces a zero knowledge prover. Okay. And then client diversity. So today we only run with, as I mentioned, a vanilla get fork, right? But in the future, we also want to be able to, and we think this is a principle, and we're basically adhering by, which is we want to have architectural decentralization, right? Not just political decentralization with the n is equal to 30, but also architectural decentralization. And so with that, let's say we can introduce execution clients like Aragon, rest and so on and so forth, as well as different consensus clients, right? We plan to run pos BFT, but that's not to say we might not introduce something else like, let's say, tendermint or anything else, right? So we try not to be vendor locked into a specific implementation and try to be quite agnostic to this, because we do know the value of diversity. Okay, the next thing is what we call prover diversity.
00:19:46.066 - 00:20:48.170, Speaker A: So this is something that our head of research, Peter Robinson, is already looking into and has already reached out to a lot of different prover teams. But as a result of being vendor agnostic, is that we need some standardization, right? So we need to basically define some sort of common API that goes between the execution clients with the provers themselves. Right. So this is a bit difficult right now because you have a lot of coupling between the clients and the provers, and you have certain provers which don't have a client, and they're basically just a standalone prover independently. And so as part of our hypothesis that at some point there will be some convergence between type one and type two s, we need to have some sort of common API between the clients and the prover themselves. And so this is a research area that we're doing right now. And I would also mention as part of the convergence, we are also looking at defining, I guess, the largest subset of EVM opcodes that will again be compatible across all the different execution clients.
00:20:48.170 - 00:21:15.106, Speaker A: And finally, this is what we call multi prover verification. Now this one is interesting. I think you guys might have seen Vitalik talk about this quite a bit. Some people argue that having multi prover verification is obviously very gas intensive as well. I guess you can do it off chain and have this architecture off chain as well. That's a possibility. But I think what I wanted to highlight over here is, again, we are not vendor locked in.
00:21:15.106 - 00:21:58.562, Speaker A: We have architectures that can scale and you can easily plug in different messaging layers. So if you want to have a ZK lite client, you want to have a second ZK lite client with a different implementation, you want to have one which is a POS network, you can do so. Right. So ultimately for us, we just want to make sure we have enough redundancy in place, we have enough architectural decentralization to basically support not just immutable ZKVM and Ethereum, but every other app chain as well. So this is effectively like a zoomed in version of the bridge itself. And then at that point you have things like quorums, right? You can define quorums where at least two out of three must agree to the same state update before that state update is actually processed. Right? So the chances of the same bug existing in two completely different implementation is again, extremely, extremely low.
00:21:58.562 - 00:22:27.080, Speaker A: And that's the goal. All right, that's pretty much it. I thought I'd just show this again if you guys want to just kind of reference exactly where we just talked about, which is effectively that the immutable ZKVM box and how that's going to effectively be powering all these other platform products as well. And that's pretty much it. So if you guys want to keep in touch, or if you have any questions or you want to reach out about games or games that you know, these are my contact details, so. Yeah, thank you very much.
