00:00:00.250 - 00:00:03.754, Speaker A: Let's see what happens here. I think it's recording. Maybe it's recording.
00:00:03.882 - 00:00:04.270, Speaker B: Okay.
00:00:04.340 - 00:00:05.290, Speaker A: I think we're recording.
00:00:05.370 - 00:00:08.526, Speaker B: All right. Okay. Yes. What's up?
00:00:08.628 - 00:00:10.474, Speaker A: I'm Austin. I'm here with McTody.
00:00:10.522 - 00:00:11.600, Speaker B: And we got.
00:00:12.130 - 00:00:47.866, Speaker A: So the Dex is a cool way to teach you how to build a decentralized exchange where you exchange tokens to ETH and ETH to tokens. And it's all done by using nerves in the smart contract. There's no centralized party or order book or anything like that. But the problem is slippage. Someone could sneak a big trade in right before your trade and then sneak something in afterwards. I think we're going to learn about it today, but basically shift the price back and forth right as your transaction goes in. And McToty is going to show us how that works.
00:00:47.866 - 00:01:08.900, Speaker A: Next. And in uniswap, like in production level, you basically say, I want to go tokens to ETH and I want to receive at least this minimum amount of tokens. So you put some kind of guard on that so they can't sandwich attack you. But the Dex doesn't have that. So I'm going to hand it over to McTowdy and we're going to get into it and learn some more. Are you out there?
00:01:11.590 - 00:01:52.080, Speaker B: Okay. Hello, can you hear me? Oh God. So as can the, the simple Dex has all the goodness of uniswap, but doesn't have any kind of slippage protection. So in a world without slippage protection, it's quite easy, it's quite simple. Attack vector on the blockchain. So sneak something in before them and then sneak something in after them and you can exploit whatever transaction they're trying to make. You can make small profits of it depending on the size of their transaction and obviously how much gas you have to spend to do it.
00:01:52.080 - 00:02:00.722, Speaker B: But hopefully I can show you some profitable testnet fake transactions just to show how it works. Awesome.
00:02:00.776 - 00:02:01.874, Speaker A: Let's do it.
00:02:02.072 - 00:02:35.134, Speaker B: Just talk you through what we're going to go through. So yeah, a little bit of ethers, JS script writing, something I've been playing with more recently. So hopefully this will show you something new, especially the next one, like reading the mempool, which was something was kind of like one of those mythical beasts that you don't think you can do. It's just like only the hackers know how to do that. It's actually really simple. So I can show you that too. And then we'll go through just basically how the sandwich attacks built and just how you can replicate it using the.
00:02:35.134 - 00:02:53.202, Speaker B: All you need is challenge. Four completed decks. I've got one in this repo. There is one, the one I made. But yeah, if you've already done it, then perfect. You can just slap on an extra package and just add some scripts. So yeah, we'll skip all of this and we'll go straight to the code.
00:02:53.202 - 00:03:07.382, Speaker B: So yeah, here we are. Perfect. I've made it a bit bigger. Hopefully this is visible by human eyes. The packages. Yeah, hard hats, all exactly the same. Just in here.
00:03:07.382 - 00:03:43.390, Speaker B: The balloons contract as it is important that you get Eth sent to your deployer address because this is also going to be the address you use to attack. So if they're trading balloons to Eth, you need balloons to front run them. So yeah, just good to make sure your deployer gets some of the balloons. And the Dex, I think I did some stuff different to the prototype. What are you going to call it? Just some custom errors and threw away safe math. But other than that, it works exactly the same as anyone else's. That's the hard hat.
00:03:43.390 - 00:03:56.520, Speaker B: And I think all I've changed in the react, which I should have opened somewhere. All I've changed was to set us to girly. That's not how you highlight girly. Set us to girly instead of the testnet local host, whatever.
00:03:56.970 - 00:04:00.250, Speaker A: And it looks like you're using the alchemy RPC for Gorli.
00:04:00.670 - 00:04:05.302, Speaker B: Yes, we're using alchemy. I will get maybe to. There's.
00:04:05.366 - 00:04:06.570, Speaker A: It was there earlier.
00:04:07.550 - 00:04:24.898, Speaker B: Oh, it's hiding where are wrong folder. So yeah, in this folder what you need is the Abis. Not APIs, Abis for both contracts, just to make your life easier. The env, I guess these are all.
00:04:24.984 - 00:04:27.460, Speaker A: Don't click it. It probably has a private key in it.
00:04:28.790 - 00:05:10.414, Speaker B: It has a private key, but yes, there it is. Nothing serious. So in here you'll just store your alchemy key, which I probably should change this afterwards, but yeah, that one is slightly. Yeah, your alchemy key just to get. I'm using a websockets API, which I think is a bit faster than just using a regular alchemy or infuria endpoint, just to help you get those pending transactions as soon as possible. Because one of the issues I ran into with this is if you're a little bit slow, sometimes your attack will go on to the next block, which makes it not an attack and just two trades going either way for no reason.
00:05:10.612 - 00:05:11.694, Speaker A: I have my node running.
00:05:11.732 - 00:05:13.246, Speaker B: Do you want to get there as fast as possible?
00:05:13.428 - 00:05:15.078, Speaker A: And I can read from the mem pool.
00:05:15.114 - 00:05:44.970, Speaker B: Yeah, that is one of my very fast improvement ideas. Just like stuff to speed things up to make sure you do get your things through that you want to get on the thing. We have first just a couple of very simple scripts. I guess this is the first one, the scaffold e. There we go. Yarn generate. When it makes you an account it gives you a mnemonic in here somewhere.
00:05:44.970 - 00:06:15.570, Speaker B: One of these, I think they're both the same but yeah on these you get them a mnemonic. So I just made a quick little script to turn that into a private key just to make it a little bit easier to get the scripts, the signers and providers ready. So yeah, first you run this. I could probably go through it. Let me turn it on please. We want to CD into one of these spaced cool CD into packages scripts.
00:06:19.290 - 00:06:21.910, Speaker A: What is it doing with the spaces?
00:06:22.330 - 00:06:29.820, Speaker B: What was look at that. Okay, we got some stylized versions. Do you know how to stop this?
00:06:35.870 - 00:06:45.520, Speaker A: It's doing the weird space thing though, isn't it? Let's see. Yeah, I don't know if you want to, you might need a different terminal or something here. Something weird is going on. Maybe a new shell or something.
00:06:46.530 - 00:07:23.074, Speaker B: I think we're still weird. Here's one I made earlier. Anyway, this is pretty simple. All you want to do is CD into the scripts folder and then run this and it'll give you your private key which we've all seen already. My private key, it'll just print in the console the wallet's private key. And then the second one, again you just node approved token js. And this will max approve your deployer contract for balloons towards the decks.
00:07:23.074 - 00:07:50.418, Speaker B: Just so when you're making the transactions you've not got to worry about. Oh, I also need to in the sandwich attack you don't want to have to include an approval of the contract. Got it. So here as you can see we just approved the max two five six. So you're never going to hit this number. So you can go backwards and forwards many times without ever worrying about having to get fresh approvals for the contract. Those are just simple ones.
00:07:50.418 - 00:08:15.180, Speaker B: We've got some utils here. This is just helping us with getting the signer and the provider and also addresses. This is where I store because I think approved token and our index js use both of these. So I just stored them in one contract. In one contract put it out in one file and then they can just be spread across the. Yeah, here's the meaty one. This is the fun one.
00:08:15.180 - 00:08:16.858, Speaker B: What is this here? Can I move?
00:08:16.944 - 00:08:20.362, Speaker A: Looks like function signatures for the two different swaps there.
00:08:20.496 - 00:08:50.566, Speaker B: So, yeah, we start off, we need the function signatures for eth to token and token to eth. So going both ways here is just getting the providers. Like I said, the websockets provider, mine is just free alchemy. It's not any sort of super powered one, but it's worked. Fingers crossed. It's worked like nine times out of ten. I assume on main net you might be in trouble, but this is not anything you'd be doing on main net.
00:08:50.566 - 00:09:25.870, Speaker B: Unless you're crazy. You probably want your own in a moment. Yeah, they take a lot more steps to get this through on main net, but, yeah, we'll get back to these because they're going to crop up shortly. We just initiate some contracts, both for the decks and for the balloons, just so we can call functions easier. Okay, so now we're into the thick of it. This is how we get to the mempool transactions. So we use our provider and we look just for pending transactions.
00:09:25.870 - 00:09:50.242, Speaker B: So these are ones that haven't made it onto a block yet. And we just take the transaction and we can get each transaction's info. And I will do it when it comes to it because it might get a bit messy. So we're checking first. This is just simple. Skim through this. Some of the transactions come through null, and if you get a null transaction, my contract keep calling everything contracts.
00:09:50.242 - 00:10:30.040, Speaker B: My script just explodes. So I just don't want those there anymore. You look for specifically, there's one of these things I tripped up on, but yeah, you just want to find any transactions that are going towards your decks. And this is what I originally got myself in an infinite loop with. They're not transactions coming from your address because when I first got it running, yeah, I sandwich attack myself about 30 times. So that's the whole block of me, of me trying to sandwich attack me. So that was a lot of wasted gas on my part.
00:10:30.040 - 00:10:56.000, Speaker B: This one's important. Just make sure the transactions you're looking for aren't your own transactions that you're putting on from the script. And then we have two parts. First is if it's eth to token, relatively simple, because the transaction data, which I think I have, ether scan open. Ether token. Yes. So ether token, the transaction data is literally just this.
00:10:56.000 - 00:11:00.366, Speaker B: There's no arguments or anything. It just should be the same as.
00:11:00.388 - 00:11:02.400, Speaker A: It just looking at the value. Right.
00:11:03.010 - 00:11:03.470, Speaker B: Value.
00:11:03.540 - 00:11:05.410, Speaker A: It gives you tokens back. Yes.
00:11:05.560 - 00:11:52.030, Speaker B: All you're looking for is the value of the where are we? Skip this part for now. All you're looking for is the value of the transaction, the amount of eth sent to the function, and the data, which is this part. When you find one of those, all we do is we want to make two transactions. So I'm building transactions here. You can read the comments for a more detailed spin in the first transaction should be faster, I think I only need faster priority, but I wasn't sure. So I'm doing both, but I think it matters. So you want one transaction to have a little bit more gas and then one transaction to have a little bit less.
00:11:52.030 - 00:12:26.410, Speaker B: So that when they go onto the block, your first transaction is there and then their transaction, the one you're attacking. And then your next transaction comes immediately after sandwich attack. Again, this is definitely not production ready on Mainet, but yeah, it has worked as planned so far. We're just preparing our fees that we're just going to edit. Same here. This just goes into the overrides as one of the arguments in the transaction. So yeah, this is how we do the attack.
00:12:26.410 - 00:12:53.314, Speaker B: Now we're into the real thick of it. So first we need to know how many tokens we're going to get. So we're sending ETH and we're getting back some tokens. We want to know how much it's going to be because we want to sell those tokens. And at the time of making both transactions, we don't know how much our balance is. We can't do like balance of because it would be zero at the time. So yeah, we just work out how many we're going to buy.
00:12:53.314 - 00:13:31.662, Speaker B: Then transaction one, we are just mimicking the transaction we found. So the attacked the victim, whatever you want to call it. We're mimicking that transaction and just adding a little bit more gas to make sure ours goes through first. So we're exactly the same transaction, just a little bit faster. Then our script will just say, okay, that was a valid transaction we made and we'll then proceed to transaction two, which is just the opposite transaction. So whatever tokens we bought here, we're going to sell. So we bought some.
00:13:31.662 - 00:13:41.794, Speaker B: Then our, I guess I was going to say friend, but I assume they wouldn't be our friend if they found out what we're doing. But our friend then buys their tokens and we just sell them straight away.
00:13:41.992 - 00:14:47.174, Speaker A: So to talk through that real quick, basically I'm going to uniswap and I'm swapping 100 die for $100 worth of ETh or something like that. And as soon as that lands in the mim pool, many seconds before it gets mined into a block, as soon as that lands in the mim pool, two other transactions are going to land in the mim pool also. And those transactions are crafted in a way that the gas is a little bit more and a little bit less. So if we were to look at the mim pool right now, after we've got all three of these transactions in there, there's basically a transaction where you are swapping for $100. Then you're letting me do my swap, and then you're swapping back with another transaction. And all of those are happening basically in the same block in parallel or in series, but at the same time, as soon as the block happens, basically. And that's going to shift the price, and then they make their trade and then shift the price back, and you're going to make a little bit of money on that.
00:14:47.174 - 00:14:48.022, Speaker A: Is that right?
00:14:48.156 - 00:15:25.358, Speaker B: Yes. So as my powershell, my terminal seems to be, maybe I can do it via. I'll try this way, just so I can show you the. You get every single mempool transaction, what we're trying to do, actually. So hopefully we can do this live. If it doesn't work, I can show you some earlier ones because you can see here, if I go bigger, let me zoom for ease of view. You can see here there's three transactions, always on the same block.
00:15:25.358 - 00:15:46.982, Speaker B: So here, token to ETH from one address, and then token to ETH, different address, and then this same address again. This same address again, then sells their eth. They got back for tokens all on block 52 there. Yeah, all block. Four, five, two. And then there was one slightly before, again, opposite way. So this was token to ETh.
00:15:46.982 - 00:16:21.222, Speaker B: Token to ETh. To token, and then Eth. Token, Eth, token, token to ETH. So you have sandwich attack each way, and if it doesn't work using git, we can just look at these and you can see the attacker address, the four one nine, they'll get back a little bit more of whatever they had in the second transaction. So on the first one, they were on the wrong block. I'm pointing my screen, no one can see my fingers. In the first one, they sent 0.3
00:16:21.222 - 00:16:53.840, Speaker B: e here. And in the second one, hopefully they got a little bit more back. So let me. Where are we? This one? Yeah, they got back 0.5. So it's probably 2%, maybe more. Obviously, these numbers are really small, but you can imagine if it was two e, three being traded by the victim or the attacked person. 2% of that would be enough to cover whatever gas you're paying, basically.
00:16:54.930 - 00:17:15.720, Speaker A: And the amount you can move the market is based on how many balloons you have or something like that. And really you're only just mimicking their, you could, you could mimic their trade times 100 or something like that and also make more money. Here you're just like kind of just naively saying, okay, whatever you're trading, I'm going to do that same trade ahead of you and then let you make.
00:17:17.210 - 00:17:53.054, Speaker B: On this would be how you can optimize your buys and sells to make sure you're getting the most money possible from them. You could make a massive buy and then they are trading like 0.1 e for nothing, basically. And then you trade it all back and make a bigger number. And also if you wanted to get really deep in the matrix, you could deploy a second Dex and take all the money out of one and then buy some more just to strengthen your position in whichever side eth and then sell it all into them after their.
00:17:53.092 - 00:17:56.502, Speaker A: Trade goes through flash loan or something.
00:17:56.556 - 00:17:56.774, Speaker B: Right.
00:17:56.812 - 00:18:04.630, Speaker A: You could flash dump the amount that you borrowed, make the swap.
00:18:06.090 - 00:18:06.550, Speaker B: Yeah.
00:18:06.620 - 00:18:33.360, Speaker A: But I think that the TLDR here is that in uniswap and in any production level thing, there's just a second parameter that happens. And if you tried to sandwich attack me on uniswap, I've got some minimum amount of tokens, and as you move the market away, it changes the price enough that I'm not going to get those tokens and my transaction just fails. And then it's just basically like you're kind of griefing me and that's not really working.
00:18:34.390 - 00:19:04.780, Speaker B: Become annoying. Right. But that's another thing for people who finish decks four. Decks four. The challenge for the decks, trying to think about how you would add slippage protection kind of things in is like a nice kind of next step. You've got the basic decks down. Just starting to think about how you would stop someone doing this to you is like an interesting little project you could do.
00:19:05.230 - 00:19:05.834, Speaker A: Exactly.
00:19:05.952 - 00:19:06.282, Speaker B: Yeah.
00:19:06.336 - 00:19:44.854, Speaker A: In fact, I would say that's even probably the next step after the decks. You should know that this sandwich attack is possible probably by reading content and finding this video along the way. But I would say the next step after building the decks is to build slippage protection into the decks, not to learn how to sandwich attack it. Like this is more of a later on. But it's great that you did and we can kind of provide this for folks along the way. But yeah, along your journey, if you can build something that can watch the mem pool and create a sandwich attack, I bet Mick Toady, I bet you learned a ton about scripting. I bet you learned a ton about writing ethers JS scripts here.
00:19:44.892 - 00:20:19.540, Speaker B: Yeah, this has been very useful. Just the mempool itself. I had to do a bit of googling just to work out how do you this pending provider on pending, I've only ever previously looked at actual mine transactions already. It feels quite powerful, like being able to read transactions before they get on the block. Because the script currently when it's running, which I think it's just potentially do node js, it should.
00:20:19.990 - 00:20:32.120, Speaker A: So the pending is that as soon as something goes into the mem pool or if there's already 5000 in the mem pool and you say on pending, it hits you with a whole bunch of events right up front.
00:20:32.730 - 00:20:37.366, Speaker B: No, it gets them as they come into the mempool. Okay. If you try to, you got to.
00:20:37.388 - 00:20:44.010, Speaker A: Have the script up and listening to be able to sandwich someone. You couldn't run the script and it finds it right away and gets.
00:20:44.080 - 00:21:10.818, Speaker B: No. Okay. Yeah, start it running how I've been doing it because with the alchemy thing you can overuse your key and they get angry and it shuts down your code. Yeah. Start it just before you then send your attack transaction and then it'll find it immediately and build two transactions and throw them in. And it's worked like nine times out of ten.
00:21:10.984 - 00:21:11.810, Speaker A: That's awesome.
00:21:11.960 - 00:21:15.106, Speaker B: There's lots of stuff you could do with this year and do we have.
00:21:15.128 - 00:21:23.830, Speaker A: A readme that folks could follow too? Let me make sure to post your repo along with this video if you challenges.
00:21:24.170 - 00:21:50.400, Speaker B: Here we go. But this should be easier to follow with as well as the once you get to this part, I've commented quite nicely, if I do say so myself. I've commented through the with a bit more in depth of what's happening along the way, but not this code new sausage. But this will give you how to get to the last script and then you're there.
00:21:50.850 - 00:22:03.600, Speaker A: Cool. Awesome. Great work, McTody. I'm going to throw the link in the video notes and I'm going to share the video with build guild folks. Any closing remarks here? Great work.
00:22:04.290 - 00:22:06.480, Speaker B: Just keep hacking. Yeah.
00:22:08.330 - 00:22:16.306, Speaker A: Keep hacking. Yes. Okay. Thank you so much. Peace out. Later, McTodie.
00:22:16.338 - 00:22:19.650, Speaker B: Thank you everyone. Merry Christmas.
