00:00:00.810 - 00:00:20.990, Speaker A: Good morning. Happy bowty Friday. This morning we're going to do a speed run. Look ahead. So a lot of the things we're going to see here aren't covered yet in the episodes, but it's meant to kind of just get weird and look at a new topic. And we're going to look at meta transactions just to kind of get an idea of how crazy it's going to get as we kind of get smart contracts together. So I'm just running on a local testnet.
00:00:20.990 - 00:01:01.738, Speaker A: I have a wallet that's created from a key pair that already has some value to it. And this is my address, this green blue guy. Okay, so just to cover real quick some previous topics, basically, we know that we can just generate a 64 character hex string, and that could be a key pair or a private key, and that produces or that derives a public address from a public key. So it's this easy for us to create an account. Okay. But it's really hard for us to get EtH because we have to go buy it somewhere and bring it. So the cool thing about metatransactions is it helps with onboarding.
00:01:01.738 - 00:01:50.720, Speaker A: So what you can do is when someone lands on your site or your DaP or whatever we're talking about here, you can just generate them, oh, look at that. Looks like a cool, looks like Zeus or something, right? You can generate them an account, and that can happen just on the fly as they land. You can start in local storage, whatever, and then you can sign messages and actually interact with the blockchain with that address. And we'll see how to do that here. So going back to things that we've already covered, you can basically sign a message, right? Like given a key pair, you can use that private key to sign any kind of message. Oh, what am I doing here? Let's just say hello, world, and we'll see that a signature comes out over here. Right? So that's just us signing that message.
00:01:50.720 - 00:02:24.860, Speaker A: What we'll do is we'll put that on chain and it will be recovered in a smart contract, instead of being recovered like this, where we can put in the signature and we can put in the message and we can get the address back. Look at that. It's the same, dude. We can do that off chain too. But this is going to be really powerful when we can do this inside of smart contracts. Okay, so if we go to, let's go back here. Oh, whoa, what am I doing? Let's go back to our, sorry.
00:02:24.860 - 00:03:07.410, Speaker A: Okay, so let's dive in and look at this smart contract. So I have this deployer set up. It's allowing me to compile and deploy the code. And if we look at the code, let me just clean up down to like, all of this stuff is just splitting the signature. And I'm doing it really inefficiently here. But this is what we really want to see is basically you're going to send in a message and a signature to this smart contract, and it's going to be able to recover, given that message. And that signature is going to be able to recover the address that signed it, not specifically the address that paid for it to go on chain.
00:03:07.410 - 00:03:27.066, Speaker A: Okay, so let me just back out there. Okay. And then we're going to store it on chain. So this smart contract just stores two things. It stores a signer and that signer's message, right? So you take a message, you sign it, and then you put both of those things into the contract. And when someone else puts it in, it just overwrites the last one. So this isn't like a real world smart contract.
00:03:27.066 - 00:03:53.062, Speaker A: We're just kind of demonstrating how this EC recover works. Okay, so we've compiled it, we've deployed it. It's at five Bc five or something. And we'll see that right here. Okay, so what we can do now is we can talk to that contract and we can ask it who the current signer is and what their current message is. Right? So if I hook that up, and I hook that up, and we're going to need this guy all the way over here. Okay.
00:03:53.062 - 00:04:15.342, Speaker A: So we can ask it what its current message is, and it's nothing. And we can ask it who the current signer is. Actually, let's just hook this up to the same button. Right. And that should be the deployer's address. So that's me, the guy who paid to put the contract out there. Right.
00:04:15.342 - 00:04:39.342, Speaker A: Okay. So now I'm going to call a function on this contract. I'm going to call this sign hash function. So let's get in there and look at that one more time. So there's this sign hash function that takes a message and a signature and then saves it, but it saves the signer, not the signature. So we'll know who signed that message. So it's like kind of like being able to put an attestation into the blockchain.
00:04:39.342 - 00:05:07.150, Speaker A: So here we go. So now we've got this message and signature ready to go in, and this guy's going to help us just pack things up. So one thing we need to do, we can't put this in like this. We're going to need to go to bytes 32 because that's how that's stored in the smart contract. So let's go there and then let's put that in as our message. So then our message and our signature will go in here. Okay, cool.
00:05:07.150 - 00:05:40.858, Speaker A: So this is actually just call data. We're not actually calling the function here, we're just preparing it to send it to the smart contract. So let's get into that just a second. So to deploy our smart contract, we're sending a transaction but without a to address. And the data field in the transaction is actually the bytecode of the contract. Right. But to talk to a contract now that contract's out there, we are going to send another transaction and we're going to send that transaction to the smart contract's address.
00:05:40.858 - 00:06:04.110, Speaker A: And this time in the data field we're going to have some call data. Basically the call data is this packaged up. I want to call this function called sign hash. And here's my message and here's my signature. Right? So it's like the arguments of the function that we put in there. So this guy down here signed it our Zeus. So Zeus signed the message, but Zeus doesn't have any eth.
00:06:04.110 - 00:06:30.930, Speaker A: It was just generated for him. He probably doesn't even know he has a key pair, right? Maybe, right? He's got like this little burner private key. This guy is the one who has deployed the contract. This guy is the one who has Eth. He's the one who's signing these transactions and sending these to the blockchain. So he's actually going to take this call data that was produced from Zeus and he's going to send it in here. So we're going to make a transaction with that call data as the data.
00:06:30.930 - 00:07:11.826, Speaker A: So I pay for it and I put it on chain. And then if I go back here and we ask the contract now who has signed and what is their message? Look at that. It's Zeus. And if we do, let's see from hex here, let's see what Zeus's message was. Cool. So Zeus was able to put an attestation on chain that's cryptographically backed that proves that only the person with his private key could have signed this message. So there's all sorts of cool, cool stuff you can do with that, right? Like what if Zeus just said, send five of my stable coins to Bob, right? You could just have that built into your contract and it could respect these signed messages.
00:07:11.826 - 00:08:06.018, Speaker A: But something even cooler is a smart contract can also, this contract in here can also take that call data. Okay, this is going to be weird. It can execute call data. That's how I should say it. So this smart contract could also have a function in here that basically calls a new set of a function and arguments. So what we could do is back here with Zeus. Zeus could actually go to some third party contract, another contract, and he could do this little encoding thing that we do, and he could plug in whatever he wants into whatever function and get some call data, and then Zeus could sign that call data, and then I would send that into the contract and it would execute.
00:08:06.018 - 00:09:10.074, Speaker A: So I would pay the gas for Zeus to be interacting with some other third party contract. Now the gotcha here, there's a small gotcha, and that is if this recover contract. So this contract here is kind of like a smart contract wallet, right? And the reason is when it goes to this contract, it recovers, it figures out it's me, and then it takes my new call data inside the call data and sends it as a new call on chain. The from address is going to be this contract, it's not going to be my target contract. So there's a little gotcha there where this guy basically acts as your identity if you use this call method where you send call data in your call data and it's executed. So there's kind of two different ways. There's sort of like this idea of native metatransactions where your contract basically does an EC recover, figures out who signed the message, and then you sort of do something on behalf of what that message is.
00:09:10.074 - 00:09:58.342, Speaker A: Like transfer stuff within the balances of the contract that we're looking at. And then there's this other idea of sort of this bouncer proxy metatransaction system, where the bouncer proxy is sort of your contract wallet, right? And you keep all your tokens and all your money in that. And then you have sort of like these whitelisted, like your phone with some ephemeral private key is allowed to just send a message through some relay that's incentivized to put it on chain and pay the gas. You don't have to have gas, you don't have to have ETH, and that relay will put it on chain, it will get recovered and execute, or actually just move your code around if it's just a contract wallet. So crazy, crazy stuff. Super fun. Meta transactions allow a user to basically just get an account, just generate an account.
00:09:58.342 - 00:10:16.654, Speaker A: Willy nilly sign some message and throw it in. And the logic of the smart contract can react to the signer, which is super, super powerful. And we'll get into that later. This has just been a quick little look ahead. Happy bow tie Friday. Last question. Do I have pants on? We'll never know.
00:10:16.654 - 00:10:21.690, Speaker A: We will never know. Happy bow tie Friday. Eth build speedrun on metatransactions. Look ahead. Woo.
