00:00:00.730 - 00:00:42.026, Speaker A: Good morning. I'm Austin Griffith. If you've seen my mug before, you know that I like metatransactions. It helps you abstract away the gas costs. Sometimes even wallet downloads lets the user get right into the app and use it while still preserving that cryptography and ownership of tokens. The thing I want to talk about today is native metatransactions. So instead of having a bouncer proxy that has to proxy these signed messages or calls into an existing set of contracts, we're going to build metatransactions, or at least signed message recovery directly into the contract so then it can natively figure out who the signer is and use that instead of having to.
00:00:42.026 - 00:01:09.262, Speaker A: With the bouncer proxy model, you have to kind of trace back and figure out who the message sender is. And this way you can kind of do it natively. So here's the article down below, and I go through how to do this step by step. But basically what you end up building is this coin, this ERC 20 coin. What I'm going to do. So this is safari right here. This is an ephemeral key pair that was generated on the fly.
00:01:09.262 - 00:01:33.526, Speaker A: There's no metamask down here. Up here, I do have metamask. Let's switch over to an account that can mint, and that is set up in the article. You'll see it. But basically, let's go ahead and mint this dude down here, 100 of these tokens, and we pay for gas. And that happens normally. And then there's a transfer from zeros to this dude, and this dude has 100 tokens.
00:01:33.526 - 00:02:10.294, Speaker A: Okay, so the cool part is here, basically, let's switch over to a new dude and copy his account, and then let's transfer 50 from. Oh, we got to get our relayer running. Always got to get that relayer running. Okay, so now there's a relayer running in between. So instead of this guy talking directly to the chain, he's going to talk to the relayer by sending him a signed message, and then the relayer is going to put it on chain. And by on chain, he's not going to drop it into some kind of bouncer proxy, but he's going to put the message directly into the ERC 20 contract. That's what the difference is here.
00:02:10.294 - 00:02:29.162, Speaker A: Okay, so now this dude down here with his safari and his ephemeral account is going to transfer 50 tokens up to this dude up here, and he's not going to pay any gas to do it. Here it goes. Boom. 50 coins are transferred. This guy has 50 coins. You can see the transaction goes through down here in Daparatus. Okay, very cool.
00:02:29.162 - 00:03:03.062, Speaker A: So let's go ahead and do one more piece of this demo. And that would be we're going to send tokens back to this minter from this account that doesn't have any. Now, this account is injected metamask, so we didn't even have to sign anything down here. It kind of did it automatically. Right. But if we now send 25 of these tokens back to the original minter from this account, he doesn't have any ether, right? So it's still going to need to send through a relayer that'll pay for his gas, but here's where he has to sign. So a little bit different.
00:03:03.062 - 00:03:34.730, Speaker A: But basically these guys don't have any eth, but they can send with signed messages. And those messages go to a relayer. The relayer puts it right into a contract. Contract unrolls it natively and says, okay, instead of doing a transfer to the message sender, we're going to do the transfer to the signer. Okay, let's unpack that a little bit more and look at this contract. So this is just an ERC 20 mintable contract. Basically those lines are actually probably these lines right here are all I need to make a mintable ERC 20 token.
00:03:34.730 - 00:04:14.222, Speaker A: Thanks to the beautiful work at open zeppelin, they have a lot of good contracts you can use. But what we're going to do is extend that a little bit more and add a little extra functionality. And instead of having a transfer function, we're going to have a meta transfer function. And that metatransfer function will take in everything that a normal transfer function does, a two and a value. But it's also going to take in a nonce to avoid replay and some kind of a reward to maybe kick a couple of these tokens over to the relayer as a thank you to just keep them incentivized to push your signed messages on chain. And then there's a signature of all that data. Okay, that's basically it.
00:04:14.222 - 00:04:53.590, Speaker A: So those same arguments are passed into a hash. The hash brings together the address, the function, and then the argument. So basically the off chain user can sign all of this information saying he wants to transfer to a person, and it can get recovered on chain. We use this git signer that I use all the time in a lot of my metatransaction demos. But basically what it is is it takes a message and a signature and you get an address back. So given some hash we can use the signature to get the signer back. And now natively within the contract, not some kind of call, not some kind of execution.
00:04:53.590 - 00:06:05.102, Speaker A: But what we're doing is now we have the signer, and instead of using message signer to do the transfer, like we will, let's look at the ERC 20 here. We say message sender to value, right? So we're sending tokens from message sender to the two address, and we're sending that many tokens, but with the metatransfer, we're actually using the signer as the from address, not the message sender. And in fact, the message sender is the relayer. So we have this last little bit of reward that we roll into it, and that's where we send some reward tokens. So I could say send 50 tokens to Jimmy, but also give two to whoever puts this on chain, right? And then I could just broadcast that to everybody and someone is going to put it on chain because they're going to get two tokens and Jimmy is going to get his tokens. So I guess the bottom line here is, if you're going to redeploy your contracts, I would build message signing right into the contract natively, instead of trying to have a bouncer proxy layer and then a contract layer. So what does this look like in the app? So this button right here, this little send button is right here.
00:06:05.102 - 00:06:55.650, Speaker A: And basically we're checking, is this an ephemeral account like this guy is, or is your balance zero, like that guy was? And if it is, if it's not, it's just going to send a normal transaction. But if it is a meta account or a zero eth, an etherless account, then we're going to need to create this signed message. And we do that by. We'll grab our current nonce from the contract. We've got our method there. Right now, I'm using reward zero because I'm just assuming there's a centralized relayer, but you could set that to reward to whatever, and there's tons of different ways you can incentivize and how the relayers work, and that's a bigger picture kind of thing. And I put a link in there about relayer mechanics and attack vectors, and we still have a ways to go on that, but we're making good progress.
00:06:55.650 - 00:07:36.350, Speaker A: Props out to the metacartel. So let's go back to. Okay, so we've got our nonce, we've got our arguments, we go get our hash. Given our arguments, we go get the hash from the contract. Then given the hash, we sign it either with our metamask account or our ephemeral account. And then we create a post that packages everything up and then we ship it off to our relayer over here. So then if we go look at our relayer, he just accepts some, oh, where'd I go? He just accepts some post address, oh, here we go.
00:07:36.350 - 00:08:11.018, Speaker A: He accepts a post, he recovers that signature using web three. And then you can do all sorts of different types of checking of whether or not you want to pay the gas for this account. Maybe you could just check to see what the reward is. You want to be pretty sure that the transaction is going to go through. You want to not collide with someone else again. All of these things are still tricky pieces of peer to peer relayer networks that we're still trying to figure out. And there's a link down here somewhere, go find it and participate in helping us tackle the game theory of this.
00:08:11.018 - 00:08:50.338, Speaker A: But assuming we've got this nice centralized relayer for now, we don't even need a whitelist. I'm just paying for everybody's gas, but I get the account, I make sure the account is good, and then I package up the call and just send the arguments on chain and pay for the gas. So that's basically it. That's the whole thing right there. The article has a step by step of how to do the whole thing. So if you're interested in following along and building this, check this out. But the main theory here is if you're able to redeploy your contracts, build message recovery right into the contract.
00:08:50.338 - 00:09:30.494, Speaker A: Don't worry about building a bouncer proxy layer on top of it, unless those bouncer proxies are basically like identities, and those bouncer proxies are actually going to hold tokens and you're sending signed messages to them and then they're doing delegated execution, or they're sending tokens and stuff like that. That's another thing. And that's like NOSA safe and all the other cool stuff that's coming out. This is more like, okay, I'm building a voting contract. So when you submit your votes, it would be cool if you could just submit signed messages instead of having to interact on chain, right? If you're building a contract like that, use these signed messages and it's pretty easy stuff. It's 1015 lines of solidity and you're set. Awesome.
00:09:30.494 - 00:09:35.330, Speaker A: So that is native meta transactions. Happy Friday, dudes.
