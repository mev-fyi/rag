00:00:02.570 - 00:00:02.926, Speaker A: What's up?
00:00:02.948 - 00:00:33.670, Speaker B: I'm Austin. I'm here with Edda and Carlos. And we are on day five of week two, the 10th day, the 10th day of building. Today we're just going to kind of rehash those. Not rehash hashing is like a verb already. We're going to cover, we're going to recover, we're going to cover again the solidity basics. I think yesterday, last session, we did hard hat and kind of like how you can write solidity and then run tests against it.
00:00:33.670 - 00:01:14.562, Speaker B: I think today let's do solidity, but let's do it in scaffold ETH, and we'll use a little bit different tool. And that tool is going to help you have a lot more insights and give you the ability to tinker with your contract. So I feel like we should start with just like a simple installation of scaffold E, since it is kind of a pain in the butt to install. It takes like ten minutes. So maybe we could kick it over to you, Eda, and you could show your screen, and we could start from, like, complete scratch, pull up a terminal, go to the repo, start cloning it, start the install. That's going to take time. And then I'll steal the screen back and show my version that's already installed and ready to go, and we can kind of tinker while the installation is going.
00:01:14.562 - 00:01:16.658, Speaker B: All right, let me kick it over to you.
00:01:16.744 - 00:01:17.646, Speaker A: Yeah, you got it.
00:01:17.688 - 00:01:18.342, Speaker B: You got it.
00:01:18.396 - 00:01:18.950, Speaker C: Awesome.
00:01:19.100 - 00:01:21.880, Speaker B: We just basically googled scaffold ETH, right?
00:01:22.250 - 00:01:46.480, Speaker D: Yeah, just googled scaffold ETH. It's the first repo that comes up and let me pull up my terminal over here. But before that. So, yeah, you also have the readme over here on how to do this. But let me just go over here, get the repo. Going to go to my machine. I'm just going to go to the desktop, and then let's make.
00:01:46.480 - 00:02:08.980, Speaker D: Going to call it zoom because that's what I've been calling everything. So this is going to take a few moments to get all set up. But, yeah, basically just google scaffoldies, go to the first website that pops up, it's going to be GitHub, and then clone the repo down.
00:02:09.990 - 00:02:15.734, Speaker B: Awesome. Okay, so we're cloning it down. I might even steal the screen back because I don't even know how long that's going to take.
00:02:15.852 - 00:02:17.698, Speaker D: Yeah, it takes a few moments.
00:02:17.794 - 00:02:44.474, Speaker B: Yeah, it does. Okay, so here we go. Let's see. Let me pull this over here. And we got the Sanford token we might mess with a little bit, but once you get Scaffold ETH all the way, there's I did the scaffold ETH IO, so you clone it down, and then you're going to do this step next. But I've already done this. And then you yarn chain, and that brings up your hard hat node.
00:02:44.474 - 00:03:12.554, Speaker B: So just like hard hat like we had before, you'll have a hard hat node with scaffold ETH, and then you have a front end. This was the yarn start. Okay, and let's do this all again on your machine too. But I kind of want to speed run through it. And then you do a yarn deploy, and that's going to deploy your contract. This time it's probably going to say it's reusing your contract. This is the first little you need to do a yarn deploy reset if you want to force that contract to go.
00:03:12.554 - 00:03:20.266, Speaker B: Okay, so then we've got our contract here, and oh man, I've got this zoom bar. Let me get out of here.
00:03:20.288 - 00:03:20.762, Speaker A: There we go.
00:03:20.816 - 00:04:02.186, Speaker B: And then here's the front end. That same mode that we were in, where we were kind of making a small change in solidity and then compiling it, and then making sure our tests run, you get into a similar iteration loop with Scaffold ETH. But what you're doing is you're basically tinkering with your solidity and then yarn deploying, and then you'll get your contract over here in the front end and you'll kind of tinker with it. See how we got a new contract address there. Let's do it again. And we should see a new contract. So this is a little bit different than the hard hat version where we were just like editing solidity and then we were running our test or writing our test to make sure it works.
00:04:02.186 - 00:04:29.358, Speaker B: This is a little bit more like visceral and upfront. You kind of can make a small change. Let's just add some more exclamation points just to make just a simple string change. You deploy, and then you should see it show up in your front end as it deploys and hot reloads. So this is just a different iteration loop that you can get in, but very powerful and very quick to be able to edit some solidity. Let's see. So you did a git clone.
00:04:29.358 - 00:04:34.430, Speaker B: I suppose you're probably about to run your yarn install, or did you already run that EDA?
00:04:34.590 - 00:04:38.614, Speaker D: I'm on 72%. Okay, we're still waiting for that.
00:04:38.652 - 00:04:55.034, Speaker B: Okay, I'll just steal the screen and hold it here. Yeah. Okay. So let's just edit some solidity, right? Let's get into this mode of editing solidity. So let's see, we talked about primitives and data types and globals, right? So we talked about globals solidity. Let's have those up.
00:04:55.072 - 00:04:55.274, Speaker A: Right?
00:04:55.312 - 00:05:03.994, Speaker B: You'll want to have your globally available units. Let's even just pick one out real quick. Let's look at the block timestamp.
00:05:04.042 - 00:05:04.398, Speaker A: Okay.
00:05:04.484 - 00:05:35.430, Speaker B: And let's just create over here. Let's just create a read function real quick. And we'll call it timey. And it's going to be public and it's going to return a UN 256, right? And let's just return the block timestamp. So anytime you're just like dinking around with these globals and you want to know how they work, let's go ahead and deploy some new function that has some new timing. And let's see if it adds it over here. There we go.
00:05:35.430 - 00:05:46.762, Speaker B: And we can call this, oh wait, that should be a read function. Public views. Come on. It gave us a warning even. Yes, there we go. This is the kind of iteration public view.
00:05:46.816 - 00:05:47.740, Speaker A: Is that right?
00:05:48.430 - 00:06:07.470, Speaker B: Why didn't it turn view into maybe I have an old there we go. There we go. And now we've got our time. And as we kind of make transactions, that time should change. Or if I deploy again, we get a new timestamp. Okay. So now we've got our global units.
00:06:07.470 - 00:06:14.162, Speaker B: We've got a way to kind of view those global units right away. A nice way to tinker. The next thing is solidity by example.
00:06:14.296 - 00:06:14.690, Speaker A: Right?
00:06:14.760 - 00:06:17.234, Speaker B: And we talked through, I think, primitives.
00:06:17.282 - 00:06:17.782, Speaker A: Right.
00:06:17.916 - 00:06:23.480, Speaker B: So we talked about you can bring in a bool. Let's throw one in here.
00:06:24.090 - 00:06:24.550, Speaker A: Okay.
00:06:24.620 - 00:06:28.426, Speaker B: And you could bring in UN 256.
00:06:28.528 - 00:06:29.180, Speaker A: Right?
00:06:30.110 - 00:06:31.580, Speaker B: Let's do that.
00:06:31.950 - 00:06:32.700, Speaker A: Right.
00:06:33.790 - 00:06:40.570, Speaker B: Oops. Okay. And you could bring in an address.
00:06:40.720 - 00:06:41.420, Speaker A: Right.
00:06:41.870 - 00:07:08.626, Speaker B: All of these primitives and data types, we're just kind of pasting into our contract. And then I'm going to do a yarn deploy and then I'm going to go look at it on the front end and tinker with it and make sure it does what I think it's going to do. There we go. So our bool is true. Let's maybe even build a function real quick called toggle that does something like boo equals not boo.
00:07:08.818 - 00:07:09.510, Speaker A: Right.
00:07:09.660 - 00:07:17.462, Speaker B: Just simple functions. Let's see if we can flip that bit. Let's see what it does. So now we should get some, what did we call it?
00:07:17.516 - 00:07:18.422, Speaker A: Toggle. Okay.
00:07:18.476 - 00:07:32.650, Speaker B: We should get some toggle function over here. So now boo is true. And if I call toggle because I don't have gas, we need to explain wallets real quick. But I'll get to that. Grab some funds from the faucet, and then when I hit toggle boo toggles.
00:07:32.730 - 00:07:32.974, Speaker A: Right.
00:07:33.012 - 00:07:35.454, Speaker B: We're toggling our boolean. There we go.
00:07:35.492 - 00:07:36.302, Speaker A: There we go.
00:07:36.436 - 00:07:58.482, Speaker B: Okay. I'm going to dump that stuff out of there. Just kind of getting it shown off. How you can get into this habit of throwing some solidity in here and tinkering with it over here on the front end. I'm going to delete is our un there. Let's just pull out all this stuff, get back to our simple contract. Okay.
00:07:58.482 - 00:07:59.182, Speaker B: Wallets.
00:07:59.246 - 00:07:59.474, Speaker A: Right.
00:07:59.512 - 00:08:13.686, Speaker B: We did something really weird with wallets there. I feel like that's worth explaining. With Scaffold ETH, if you open up a new incognito window, look up in the top right here. We're going to have a new address. There we go. There's that red address. Now if I close it, see how he's kind of like this red dude.
00:08:13.686 - 00:08:24.990, Speaker B: You can grab some funds from the faucet for the red dude. Let me close that and open up another one. We should have a new account. There we go. Now it's like green dude. Right, one more time. Localhost.
00:08:24.990 - 00:08:55.080, Speaker B: So scaffold ETH creates burner wallets for you on the fly, and it makes editing and tinkering with your contract a lot easier. Let's go ahead and redeploy our contract. Okay, so let's see. We're able to put in globals. We're able to bring in some primitives and tinker with them. Let's see, we've got burner wallets. We'll bring in the burner wallet in a little bit.
00:08:55.080 - 00:09:31.730, Speaker B: What I'm thinking is we should just probably write a small contract that does some kind of like using these primitives. Maybe we should even explain the contract that comes with scaffold ETH out of the box and then do some solidity tinkering. Does that sound good? Okay, so it looks like there's a string here. Hopefully that's very readable. This is very much like the greeter contract. There's a famous greeter contract where you have this greeting or you have this string, and then you have some function to set that string. Something really interesting here is a nice little console log here.
00:09:31.730 - 00:09:50.966, Speaker B: Whenever someone calls set purpose, it does a console log over in the hard hat node. Let's go do that real quick. Just to see it. So I'm going to need to call set purpose with some new purpose. So I'll say, hello, world here. And I have some money for gas. And you'll notice with that burner wallet, there's no metamask pop up.
00:09:50.966 - 00:10:11.438, Speaker B: Here's no. It just fires the transaction off, which is really nice. And then over here in the console log, we see, sure enough, we set the purpose to hello, world. Okay, so we're in the mode, right? We've downloaded scaffold ETH. We know what our globals are. We know what our primitives are. It's time to start tinkering a little bit.
00:10:11.438 - 00:10:26.290, Speaker B: Let's do what we did last time. I think we brought in, like, a little bit of an ownership pattern, right? We had some boss. Let's see. So we'll make an address public, boss. And we'll set that equal to our front end address. I'll just copy and paste that in. And let's ship it.
00:10:26.290 - 00:10:45.862, Speaker B: Okay. And we're just going to do like, a couple of lines of solidity, and ship it over and over and over again. We should see it. There we go. So now we see our boss, right over in the hard hat version, we kind of had a test that we would run, right? We would set the boss, and then we would make sure that the test made sure that the boss was set here. We're just kind of doing it visually.
00:10:45.926 - 00:10:46.106, Speaker A: Right.
00:10:46.128 - 00:10:53.486, Speaker B: We kind of like, we've got our boss, we've got it set. That looks good. Then maybe we require that you have to be the boss to set this.
00:10:53.668 - 00:10:54.014, Speaker A: Right.
00:10:54.052 - 00:11:08.770, Speaker B: So we're going to say message sender. That's that first global that we learned. It's whoever's making that message or whoever that it's coming from. Once we get to contract, to contract, this will be a little different. Equals boss, or we say, not the boss.
00:11:09.910 - 00:11:10.418, Speaker A: Okay.
00:11:10.504 - 00:11:11.570, Speaker B: And deploy it.
00:11:11.640 - 00:11:12.162, Speaker A: Right.
00:11:12.296 - 00:11:23.990, Speaker B: So just small changes to your solidity. Test your assumptions. Try it out. Now, we should only be able to set the purpose as the boss, so this should work.
00:11:24.140 - 00:11:24.454, Speaker A: Okay.
00:11:24.492 - 00:11:26.114, Speaker B: But then how do we test the counter?
00:11:26.162 - 00:11:26.760, Speaker A: Right?
00:11:27.770 - 00:11:31.498, Speaker B: In the last week, we had to basically write a test where we had a second account.
00:11:31.584 - 00:11:32.218, Speaker A: Try it.
00:11:32.304 - 00:11:37.542, Speaker B: Let's just try it with the second account here in just an incognito window.
00:11:37.606 - 00:11:37.882, Speaker A: Right?
00:11:37.936 - 00:11:46.510, Speaker B: So we've kind of got green guy over here. This guy's kind of green, too. Let's get a different one. Get an account so we can have a good bad guy, yellow guy.
00:11:46.580 - 00:11:47.102, Speaker A: Okay.
00:11:47.236 - 00:12:16.802, Speaker B: It's kind of still green. Come on. All right, last try. Whichever one we get here, we're going with. Okay, so this is bad guy, kind of yellow red guy, and then we've got green guy over here, grab some funds from the faucet. And if we try to set the purpose trying this, hopefully we get a message that we're not the boss. Okay, so instead of writing a test, which a test is really nice because you can have it automated, and any little change you make, you could run your entire test suite.
00:12:16.802 - 00:12:45.234, Speaker B: But when you're just getting started and you're tinkering with solidity and you're trying to figure it out, this is really handy. We can write a small require statement and then just using the front end, we can kind of quickly test if that require statement is working, and it seems to be working so far. What's the next concept we should go after? I feel like I'm talking a lot. What's the next thing we attacked yesterday or last session, I was thinking that.
00:12:45.272 - 00:13:06.230, Speaker C: Maybe we could take a look at the deploy script that we are using for this escapult deploy and maybe putting some params into the constructor function so we can send some ETH or some, maybe the owner. Like the boss address. Right. We can send that into the constructor.
00:13:06.650 - 00:13:07.302, Speaker A: There we go.
00:13:07.356 - 00:13:20.730, Speaker B: That's a good call. Okay, so we're going to have some address. I'm even going to make it immutable. Is it public? Immutable. So it's only going to get set once and we'll call it boss.
00:13:21.550 - 00:13:22.058, Speaker A: Okay.
00:13:22.144 - 00:13:26.990, Speaker B: And then we'll set the boss to the starting boss and it should never change again.
00:13:27.060 - 00:13:27.342, Speaker A: Right.
00:13:27.396 - 00:13:36.726, Speaker B: Quick little thing. Let's see if that worked. Quick little interaction. Let's see if this deploys. Oh, no, it did not. What did I do wrong? Let's see. Oh, arguments.
00:13:36.778 - 00:13:37.042, Speaker A: Right.
00:13:37.096 - 00:13:38.674, Speaker B: It needs an argument passed in.
00:13:38.712 - 00:13:39.010, Speaker A: Right.
00:13:39.080 - 00:13:48.494, Speaker B: So like you said, we go here, we're going to go to the deploy script in Scaffold ETH. And this is already commented out for you. There's a lot of scaffolding in Scaffold ETH.
00:13:48.542 - 00:13:48.802, Speaker A: Right.
00:13:48.856 - 00:14:01.260, Speaker B: This is just another little piece of scaffolding here where it's like almost ready to go for you. What do we need to do? We need to put in this dude's address probably. Okay. And let's try that.
00:14:02.030 - 00:14:03.098, Speaker A: There we go.
00:14:03.264 - 00:14:27.754, Speaker B: Okay. And one other thing I want to do, let's do another address and let's call this the deployer. And let's set the deployer equal to the message sender. There we go. So we're going to deploy our contract. We're going to pass in some boss, and then we're also going to have some other address that we track that's called the deployer. That's going to be whoever deploys the contract.
00:14:27.754 - 00:14:58.086, Speaker B: So there's kind of two addresses. There's the boss address, and then kind of whoever deploys. And we'll see that these are slightly different addresses. The deployer is going to be that first hard hat address. We've talked about this probably a couple of times before, but as hard hat spins up a new chain, it has a whole bunch of addresses attached to it. And so who's deploying our account? Is this the F 39? We've seen old F 39 before, yes. And another place you'll find F 39 is down here in the faucet.
00:14:58.086 - 00:15:17.150, Speaker B: If you open this up, this is basically F 39, totally loaded with 10,000 E. And this is a good time to kind of show off wallets in scaffold ETH. But if I copy this guy's address and I open up the faucet wallet, look what I can do kind of right here in the UI. I can give myself a whole bunch of money.
00:15:17.220 - 00:15:17.794, Speaker A: There we go.
00:15:17.832 - 00:15:47.770, Speaker B: So now I have enough money to do lots of stuff. Instead of kind of sending them around or dealing with accounts here, you don't want to be copy pasting private keys. You want to generate a nice burner address and fill it up with the money you need and then go interact with your contract. Okay, so we do have construction arguments now, right? And we are passing in some starting boss. And that boss is immutable. It only changes once and gets set here. But we've got our boss, we've got our deployer.
00:15:47.770 - 00:16:03.038, Speaker B: Only our boss can set this. Okay, this is a good time. This is usually where I. Sorry, I'm like stealing all the time here. You guys jump in if I need to. If you need to. One thing I like to do is I like to do a payable here instead.
00:16:03.038 - 00:16:44.320, Speaker B: So I make this payable right now. It's basically like an attestation smart contract. One person can get in and change something, right? One person can set the purpose. We know that smart contracts are more like these vending machines, always on permissionless programs that people can access and run. So let's make this a little bit more decentralized, and let's say message value needs to be greater than or equal to some amount of ether, right? And then we'll say not enough. So we just made a small change to our contract, and instead of one boss gets to set things. Now anyone can get in here as long as they pay a little bit of value.
00:16:44.320 - 00:17:21.286, Speaker B: And sure enough, our front end auto adapts to that, right? It notices that the set purpose now needs to take in some transaction value. And so let's set that to hello world again. And if I put in zero transaction value, it's going to say not enough, right? What we need to put in is 0.1. And then here's another little trick from Scaffold ETH. You need to take that times ten to the 18, right? We need to take it to way. And Scaffold ETH is going to force the developer to do this. If you're a builder, I want you to be forced to say, well, it's one times ten to the 18.
00:17:21.286 - 00:17:35.600, Speaker B: I want you to be thinking about that. But when you build your final app with Scaffold ETH, obviously you'll do a little different and you'll have it so your front end handles that kind of stuff. But here we go. Hello world. Let's put in.
00:17:38.370 - 00:17:39.214, Speaker A: Let'S take it times.
00:17:39.252 - 00:18:07.814, Speaker B: Ten to the 18 and let's pay. There we go. So we were able to test this line and make sure you have to pay. And now we see that there's a contract here and the contract has value, right? So we're able to set this up. Let's maybe even do a UN 256 public price, okay? And set that equal to zero one ether. And then we'll put that in here. All right, so we just have a price function now.
00:18:07.814 - 00:18:26.938, Speaker B: And anybody can see in the contract what the price is. Let's deploy that. Just making small little iterations, just showing you at home that you can paint some happy little trees here. Like you can build things very quickly, you can try things out and you can see them in the front end. Let's add one little line of code. Here's what we're going to get weird. We're going to get weird.
00:18:26.938 - 00:19:08.854, Speaker B: And financial mechanism, to me we're going to say once someone sets the purpose, the price is going to go up by 1% or something like that, right? Notice how we don't have decimals here. Let's see if this works. One little change to the smart contract. And now we have a price function that after I say hello world the first time and hit go, the price goes up. See that? Now the price is at 101. Hey, and I hit send again. And the price goes up again, right? So with the single line of code, our vending machine now accepts money only on a price curve.
00:19:08.982 - 00:19:09.370, Speaker A: Right.
00:19:09.440 - 00:19:26.130, Speaker B: Just random little things we can add in here that can make this really interesting. Okay, what things did we cover yesterday? I'd like to dive in and cover them. Speed quickly with scajolith. What are some more topics that we covered yesterday?
00:19:28.710 - 00:19:39.400, Speaker D: I think also it's nice to have solidity by example on the side to search for it. Like what can I use? It really helps out.
00:19:40.090 - 00:19:40.886, Speaker A: Awesome. Yeah.
00:19:40.908 - 00:19:50.074, Speaker B: So we did primitives and data types, variables, constants, immutable ether to way is kind of like happening a little bit right here.
00:19:50.112 - 00:19:50.314, Speaker A: Right.
00:19:50.352 - 00:20:09.226, Speaker B: We saw this where we typed in one ether and we took it two way. That's another big gotcha of solidity. You'll have to kind of learn that gas if else looping. I'm assuming you're like a programmer once you've landed here. So this stuff you should be able to pick up almost instantly. Mapping.
00:20:09.258 - 00:20:09.454, Speaker A: Right.
00:20:09.492 - 00:20:11.338, Speaker B: Let's get to the mapping. Let's build a token.
00:20:11.434 - 00:20:11.886, Speaker A: Right?
00:20:11.988 - 00:20:17.380, Speaker B: Okay, so we've got our deployer, our boss. I'm just going to clean a lot of this stuff out of here.
00:20:17.750 - 00:20:43.050, Speaker C: Let's see, maybe we can set the count. I mean right now only the boss can set. You augmented the line. So anyone can set the price, right? So maybe we can store the count of the people that have set the purpose. So we can have a mapping with address and account. So every time that you set a new purpose you can increment that count for that sender.
00:20:44.510 - 00:21:10.740, Speaker B: I'm going to make it a U at eight too. For some reason it only goes to 255. So there's like a your count, right? And basically every time anybody sets the purpose we do your count for the message sender plus, plus, something like that. Pretty simple, straightforward code. Let's see, our price isn't going up anymore. We've taken out our price curve. Let's see if this works.
00:21:10.740 - 00:21:40.266, Speaker B: So just right now all we're doing is we're learning how a mapping works, right? We're saying, okay, a mapping is just a mapping of some data type to another. For any given address there's going to be some un. I think we already talked about this. But the downfall of a mapping is that you can't iterate through it, right? So if we want to keep track of a bunch of balances, but we don't have to iterate through everyone's balance, a mapping is a great way to do that. What we're showing off here is that in scaffold ETH, this mapping is going to show up right away for you.
00:21:40.288 - 00:21:40.474, Speaker A: Right.
00:21:40.512 - 00:21:59.442, Speaker B: Let's see. Oh, I forgot to make it public. Boo. Classic. When you add something here and it doesn't show up here right away, it's that public. And you got to remember to set it. Okay, now, we have a your count variable down here, right? And if I check my account for green guy, it's zero.
00:21:59.576 - 00:22:00.066, Speaker A: Okay?
00:22:00.168 - 00:22:08.546, Speaker B: Then if I set the purpose. Hello, I can't spell world today. Hello, world. And we pay some money. And then we do.
00:22:08.568 - 00:22:09.314, Speaker A: Hey, hey.
00:22:09.432 - 00:22:16.150, Speaker B: And we do it again. And then we go check our count. Get out of here. We check our count now it's at two.
00:22:16.220 - 00:22:16.550, Speaker A: Right?
00:22:16.620 - 00:22:29.610, Speaker B: And then if we bring in another bad guy, they go to local host. I like how all the incognitos are bad guys. Everyone's a bad guy on the blockchain. That's what's cool about it. They're all adversarial parties and it still works, right? Okay.
00:22:29.760 - 00:22:30.460, Speaker A: Hello.
00:22:31.490 - 00:22:35.242, Speaker B: And this dude pays the one ETH.
00:22:35.306 - 00:22:35.934, Speaker A: There we go.
00:22:35.972 - 00:22:40.320, Speaker B: And let's check his count. Red guy's count should be one.
00:22:40.770 - 00:22:41.322, Speaker A: Boom.
00:22:41.386 - 00:22:58.822, Speaker B: Red guy's count is one. Okay, so that's just showing how mapping can work, right? We're going to solidity by example. We're picking up these ideas, these concepts, and we're playing with them. Let's do a token real quick. I'm just going to clear out. Yes, go ahead.
00:22:58.956 - 00:23:13.386, Speaker D: Just wanted to add, because I saw events over there, so I think it's nice to show how the events reflect to the app home page as well. We're looking to the smart contract, but since it's over there might be worth just showing that.
00:23:13.488 - 00:23:32.382, Speaker B: Okay, before we build a token, let's make sure this is deployed. Okay. Let's forget our mapping for a second. Let's forget this mapping and let's just think about. Do we even need the deployer? Let's clean this out. Just so we have a lot less stuff here.
00:23:32.516 - 00:23:33.086, Speaker A: There we go.
00:23:33.108 - 00:23:34.114, Speaker B: We don't even need this stuff.
00:23:34.152 - 00:23:34.834, Speaker A: Really?
00:23:35.032 - 00:23:59.394, Speaker B: Okay, so from first principles here we have a constructor that sets some boss and the boss doesn't even matter right now, does it? No, we're not requiring anything. Maybe there could be a withdraw function and only the boss could withdraw. But what we're doing here is we're allowing anyone to set the purpose. They pay a little bit of money when they set the purpose. And this event is emitted.
00:23:59.442 - 00:23:59.654, Speaker A: Right?
00:23:59.692 - 00:24:33.166, Speaker B: We talked about storage and how on chain storage is very expensive, but events can be used to kind of like, power your front end. So let's see how this event works. It should emit a set purpose every time someone sets the purpose. Let's go tinker with that. So let's go to the front end, let's reload this, and let's set the purpose to hello world and pay a little bit and hit send. Okay, that should have triggered an event. And within scaffold ETH you can use an event listener.
00:24:33.166 - 00:25:13.034, Speaker B: And I think it's right down here. Yep, there it is, right there. So over in our example UI, which we can see here, if you wanted to really look through the front end side, there's a front end that's created for you with Scaffold ETH. And what we're doing here is we're just showing you how there's an input field here, and then when it changes we have some state variable that's the purpose and the set new purpose. And then we have this button called set purpose. And what it does is it calls the set purpose function on your contract. So it's a nice little UI scaffolding that shows you how to build, whoops.
00:25:13.034 - 00:25:30.086, Speaker B: Shows you how to build a UI that will talk to your contract. And so if I say hello world here and my hello world, hopefully this works. Oh, not enough. See, this isn't paying. Okay, hold on, let's check it. Let's set it so it's not payable. No money going in.
00:25:30.086 - 00:25:52.442, Speaker B: Very a stock set purpose. So our example Ui works. Okay, now over in the example ui, let's try a hello world. So there are no events, right? So our events are empty. Let's do hello world. This time we're not paying anything. We should just be able to set purpose.
00:25:52.442 - 00:26:27.000, Speaker B: And let's see if those events show up here. There it is, hello world. Then if we do hey, hey. And we set the purpose, we see another event, right? So to go full circle on this, basically we're emitting the set purpose. And then the front end has an event listener in the example Ui that shows you how to handle your events. Nice little react component that shows you how to handle those events and display. Awesome.
00:26:27.000 - 00:26:53.650, Speaker B: So let's see, we did events. Before we do like contract to contract interaction, I really want to do a quick little token with a mapping. It's the same thing we built yesterday or the other day. Let's see, we got a boss. Do we even need a boss? We don't even need a boss right now. Let's take that out of this. Let's clean this down to a very simple contract.
00:26:53.650 - 00:27:17.302, Speaker B: We don't even really need the purpose. Look at this. There's nothing left here, right? Nothing. It's just a constructor. Why is the constructor payable? Does it need to be? All right, let's make sure this deploys basically an empty contract. It probably won't even show us anything. Yeah, it's nothing.
00:27:17.356 - 00:27:17.718, Speaker A: Right?
00:27:17.804 - 00:27:32.082, Speaker B: Okay, so let's make that token again. Let's start with that mapping. So we had a mapping from an address to a unit 256. We need to make it public, and we're going to call it balance. Balances. Balances.
00:27:32.166 - 00:27:32.654, Speaker A: I don't know.
00:27:32.692 - 00:27:33.322, Speaker B: Balances.
00:27:33.386 - 00:27:34.000, Speaker A: Right.
00:27:34.530 - 00:27:50.802, Speaker B: This is basically all you need to create a token. You need to have some list of balances, and then maybe when we deploy our contract, we'll have our address get 100, and let's deploy it. Let's see if it works.
00:27:50.856 - 00:27:51.170, Speaker A: Right.
00:27:51.240 - 00:28:10.922, Speaker B: We're just tinkering with solidity. We're seeing it in the front end, we're poking at it, we're making sure it does what it needs to do. Let's see what happens when we check our balance. Awesome. And if I connect my metamask or something and check its balance. Oh, man.
00:28:11.056 - 00:28:11.850, Speaker A: Was that it?
00:28:11.920 - 00:28:12.860, Speaker B: Oh, man.
00:28:13.390 - 00:28:15.994, Speaker D: Yeah. Carlos and I had to come in.
00:28:16.192 - 00:28:19.594, Speaker B: Yeah, come on. There we go.
00:28:19.632 - 00:28:19.882, Speaker A: Okay.
00:28:19.936 - 00:28:27.294, Speaker B: And now we're just waiting on metamask. Still waiting on metamask. All I want to do is just get an account.
00:28:27.492 - 00:28:28.894, Speaker A: Okay, there we.
00:28:29.092 - 00:28:45.538, Speaker B: This is another thing about scaffold ETH, is it notices what network you're on and switches you with a nice little button. Lots of little nice things with Scaffold ETH that I just needed for hackathon after hackathon, and I built it into this. Okay, so now if I check this guy's address after all that, it should be zero.
00:28:45.624 - 00:28:45.922, Speaker A: Right?
00:28:45.976 - 00:28:57.602, Speaker B: Okay, log out. That was not worth the wait. Okay, so we're keeping track of balances. We're setting someone's balance at deploy, but really we need one other function to make this into a token.
00:28:57.666 - 00:28:57.846, Speaker A: Right?
00:28:57.868 - 00:29:25.746, Speaker B: If we want to make a digital currency, we need some kind of transfer function, and we'll have our address two, and our un 256 amount. We'll make it public. Okay, and then what do we do? We talked about this last time. Usually we would want to have some kind of require statement here to make sure that the two address has the amount. But since we're using solidity eight, we don't need safe math. It's built in. So, basically, we do something like this.
00:29:25.746 - 00:29:38.760, Speaker B: We say balances of the message sender minus equals whatever this amount is and balances of the two address plus equals the amount.
00:29:39.370 - 00:29:40.118, Speaker A: Right.
00:29:40.284 - 00:30:06.094, Speaker B: And if we were writing this in hard hat, we'd build a bunch of tests to make sure that I send it and my money goes correctly, and I can't send money I don't have. But with Scaffold ETH, we're just kind of, like, trying things out here. We don't need to build any formal tests yet. We're just kind of tinkering with solidity and kind of learning the basics and the ropes. And this is what you're presented with. You've got balances, you've got transfer. If I check my balance, I have 100.
00:30:06.094 - 00:30:21.378, Speaker B: Okay, let's make another incognito address. All right, let's bring up this dude over here. We got blue guy. So we got green guy and blue guy. Blue guy can grab some funds from the faucet. If we check Blue guy's balance, he's at zero. So let's transfer two.
00:30:21.464 - 00:30:21.714, Speaker A: Right.
00:30:21.752 - 00:30:34.950, Speaker B: We're transferring to blue guy. Let's transfer ten. And by the way, this is ten way. By the way, this is ten way. We're doing all of this here as 100. Whenever you write a number in here, it's just way.
00:30:35.020 - 00:30:35.446, Speaker A: Right.
00:30:35.548 - 00:30:59.214, Speaker B: That's the same thing as way the smallest amount of ETH you can have. If I put ether, this is actually 100 times ten to the 18 and a much bigger number. Right now, we're just talking in way. We're just moving around a little bit of way. So I'm going to transfer ten way, right. Then if we check this dude's balance, should be 90. And if we go check this dude's balance, it should be ten.
00:30:59.332 - 00:31:00.094, Speaker A: Right?
00:31:00.292 - 00:31:27.142, Speaker B: So we're able to create a currency by just having balances. And then we give some initial mint to someone, and then we create a transfer function that allows people to move it if they have it. And if they don't have it, let's try that. So let's just grab some random address and try to send 999. And it's going to fail. It's going to give us an overflow, right. What it does is it's trying to subtract and it's getting an overflow there.
00:31:27.142 - 00:32:07.814, Speaker B: So this is yet another way to tinker with solidity and build a little token like we did last time, but in a way where you're using scaffold ETH and you can kind of quickly spin up these wallets and these front ends that can kind of help you tinker and learn. So I think eventually we're going to move to contract to contract interaction. But maybe we want to fill in some more details here. Maybe we could even go back to EDA and we could take last week's contract and kind of paste it in and you could show us how that looks on your scaffold ETH. How does that sound? Oh, I think you might be muted. I'm going to go ahead and stop sharing. Hand the screen off to you.
00:32:07.814 - 00:32:14.120, Speaker B: I've been blabbering too long. It's your turn. Let's do scaffold ETH on your side.
00:32:14.890 - 00:32:48.580, Speaker D: Okay, I'm going to share my screen. Okay, so all I did was a yarn install. So basically just went to the folder and did a yarn install because it takes a while, so not to wait to see it install. But yeah, I have it open on my ID as well. Didn't do anything. Just open the package so you can see a new scaffold ETH package going to go down to my contract over here. We can actually run it first as well, verifying something.
00:32:48.580 - 00:32:59.000, Speaker D: But maybe it would be good to just start by deploying the contract. Like setting up the chain. Right? I didn't do all that, but just quickly run through it.
00:33:01.770 - 00:33:09.270, Speaker B: There we go. So Yarn chain is like the first command. So you did a clone, you did an install, and now it's yarn chain. And that brings up your hard hat node.
00:33:10.350 - 00:33:15.562, Speaker D: Yeah. And then you can directly do a yarn start as well to get the front end.
00:33:15.616 - 00:33:17.020, Speaker B: That'll start your front end.
00:33:17.790 - 00:33:21.440, Speaker D: Yeah. So it's supposed to pop up. Okay, I have it here.
00:33:22.690 - 00:33:39.300, Speaker C: If you are curious about this command like yarn command, you can also check the package JSOn file and you can see, for example, the yarn deploy. You will see that the command that is actually executing is like hard hat deploy. Like the things that we did the other day.
00:33:40.390 - 00:33:40.898, Speaker A: Yes.
00:33:40.984 - 00:33:43.150, Speaker B: And yarn is like a fancy NPM.
00:33:43.230 - 00:33:43.618, Speaker A: Right.
00:33:43.704 - 00:34:14.090, Speaker B: The reason why we're using yarn is because it allows us to do workspaces and it allows us to bring in like three different projects at once. We have create react app, but we also have hard hat coming in and yarn sets that all up for us. But yeah, you can just look in the package JSOn to see what commands it's actually running underneath the abstraction. Okay, so we've yarn installed, we've yarn chain to bring up our local node, we've yarn start to create a front end. And then did you do the yarn deploy?
00:34:15.070 - 00:34:16.986, Speaker D: Yes, the yarn deploy.
00:34:17.178 - 00:34:23.280, Speaker B: Perfect. And then we deployed our contract. Awesome. So we have our stock contract, we have our front end. Here it is.
00:34:24.450 - 00:34:36.594, Speaker D: Yeah. And you can see like the burner wallet. Everything is up and ready. So just what Austin was showing. Yeah, just pull it. You have all the tabs before you do, like Yarn deploy. You won't have this.
00:34:36.594 - 00:34:43.890, Speaker D: You need to deploy the contract to have it show up. But yeah. So shall we go to last yesterday?
00:34:43.970 - 00:34:58.620, Speaker B: Yeah, let's just set the purpose real quick. Let's make sure the wallets are working. Let's make sure we can make a small change to the contract. And that works just a little. Like just double checking. Things are going. See if you can set the purpose, I would say would be the first thing to test.
00:34:59.390 - 00:35:03.870, Speaker D: Okay, sure. We can just use the UI, the debug.
00:35:08.450 - 00:35:09.694, Speaker A: It's going to tell us we need.
00:35:09.732 - 00:35:11.390, Speaker B: Some funds from the faucet.
00:35:11.890 - 00:35:14.894, Speaker D: Yeah. So I'm just going to use this.
00:35:14.932 - 00:35:28.500, Speaker B: Over here three different ways to do it. You could hit the little blue button. You could paste the address in and hit faucet, or you could bring up the wallet. And now we showed all three in this run. There we go. Now you have tons of.
00:35:29.030 - 00:35:30.242, Speaker D: So I'm going to get more.
00:35:30.296 - 00:35:30.638, Speaker A: Got it.
00:35:30.664 - 00:35:31.462, Speaker B: You got to do that.
00:35:31.516 - 00:35:31.926, Speaker A: Yeah.
00:35:32.028 - 00:35:33.426, Speaker B: It's more gratifying.
00:35:33.538 - 00:35:36.038, Speaker A: Yeah. Okay.
00:35:36.124 - 00:35:38.860, Speaker B: And we set the purpose right. Did it go?
00:35:39.790 - 00:35:40.810, Speaker A: There we go.
00:35:40.960 - 00:35:44.186, Speaker B: We see the event. We see that it's tracking it. The example.
00:35:44.288 - 00:35:44.650, Speaker A: Yes.
00:35:44.720 - 00:36:10.510, Speaker B: Awesome. Okay, so this is the stock scaffold ETH setup. If you have this set up locally, you should now have the ability to really iterate on solidity. You should be able to grab some solidity by example and paste it in. Let's go grab our old contract, our Sanford token, and let's paste in some of that stuff. And let's see it in the UI. Let's see how the Ui auto adapts to that new contract.
00:36:10.510 - 00:36:16.840, Speaker B: I suppose you could just grab the whole guts of the contract and try pasting into your contract and see what happens.
00:36:17.450 - 00:36:25.078, Speaker D: Yeah. So that's one of the days, contracts, right? Not sure which day it was.
00:36:25.244 - 00:36:28.700, Speaker B: Oh, here, I'll send it in chat. It's this one right here.
00:36:29.870 - 00:36:46.014, Speaker D: Awesome. So yeah, just going to week two and getting, actually just pull this up over here as well so you can see all the contract. I'm not going to. Just going to get the inside of it.
00:36:46.132 - 00:36:46.800, Speaker A: Yes.
00:36:49.090 - 00:36:50.766, Speaker D: You can just copy this.
00:36:50.948 - 00:36:54.980, Speaker B: I think you might have one extra brace there, but we'll be good. Brace yourself.
00:36:57.030 - 00:36:58.914, Speaker D: Okay, then I'll just delete one.
00:36:58.952 - 00:37:01.380, Speaker B: We'll figure it out. Yeah, we'll figure it out.
00:37:02.390 - 00:37:03.140, Speaker A: Perfect.
00:37:03.590 - 00:37:14.306, Speaker B: There we go. So this is an example. You just find some contract on the Internet. You can randomly just copy and paste that thing into your contract and then deploy. Does it have constructor arguments?
00:37:14.338 - 00:37:14.630, Speaker A: No.
00:37:14.700 - 00:37:16.130, Speaker B: This should compile and deploy.
00:37:16.210 - 00:37:16.840, Speaker A: Right?
00:37:18.170 - 00:37:22.280, Speaker B: Let's see what happens. There's only one way to find out.
00:37:22.650 - 00:37:24.940, Speaker D: I think we need to do reset as well.
00:37:26.350 - 00:37:55.570, Speaker B: Anytime the contract changes, you don't need to do the reset, it'll notice that there's a difference. Okay, so it gave us one little tiny warning, but we will ignore that for now. We don't need that, but our contract just totally deployed. And if we go to scaffold ETH and we look at the debug contracts tab, now we have all of these cool things from that original contract. We have the boss, which is the deployer, we have some buy, we have some create, we have some send. I don't even remember what this contract does. This was you, wasn't it, Carlos?
00:37:55.910 - 00:38:50.360, Speaker C: Yeah, but I mean, it's amazing to see because we have been for 20 minutes tinkering with solidity and it was super fast. If we try to do the same thing using hard hat like yesterday, it's way slower to do that. And I think we talk about the workflow, which is for me perfect, which is like going with scaffold e first, at least tinker like the first when you are writing from a scratch or contract and tinker a lot. And then when you have kind of like the final version, maybe you can start thinking about making tests, because if you want to make quick changes, the hard way is like the hard way, right? Yeah. So I just want people to appreciate how fast it's tinkering this way because you can see super fast, you make a change deploy in 2 seconds, you just get instant feedback from the UI, which is great.
00:38:50.890 - 00:39:48.714, Speaker B: And hard hat's like a wonderful tool. We love some hard hat, but basically writing your smart contract in the form of test driven development, right. If you write the test first and then write the smart contract, you really know what you're doing, you really understand all of solidity and you know exactly what that solidity needs to look like. And you're writing it for the test most of the time you're still learning and you're still trying to like, do I want to keep this in a struct in an array? Do I want to keep this in a set of mappings? So scalableth allows you to kind of tinker with things first and figure it out. And like you said, carlos, build the test after you have the contract kind of working the way you need it to, but assume that you can come into this kind of like pretty blind and you can try this out and you can learn things. So what do we have here? We've got a total supply. We've got a total, oh yeah, we had this total created and we paid attention to, yes, there's a creation price.
00:39:48.714 - 00:40:06.990, Speaker B: We kept a struct of votes and an array of all the votes. We have the boss getting set. Oh, we have a modifier so only the boss can set it. Then we have a create that increases the, oh, make sure the total supply isn't.
00:40:07.330 - 00:40:08.334, Speaker A: Oh, that's what it was.
00:40:08.372 - 00:40:20.258, Speaker B: It was a supply cap. We created a cap on the supply and we only let you create a certain amount. We let you send it around. What does buy do? Lets you pay.
00:40:20.344 - 00:40:20.754, Speaker A: Oh yeah.
00:40:20.792 - 00:40:25.538, Speaker B: Message value equals creation price. So you pay a little bit and you pay one and get one.
00:40:25.624 - 00:40:36.626, Speaker C: I think we have create only for the boss. It can be for free and then buy for the public. So they need to send some it along the transaction.
00:40:36.818 - 00:40:52.970, Speaker B: Okay, so the first thing I'm seeing here is the boss is the deployer account. And a lot of times we're going to want to have us as the boss. So this goes back to our deploy script and it shows something really cool with scaffold ETH. What we need to do is set it up so it transfers the ownership.
00:40:53.050 - 00:40:53.680, Speaker A: Right.
00:40:55.970 - 00:40:59.802, Speaker B: Which leads to maybe we should do inheritance and have an ownership pattern.
00:40:59.866 - 00:41:00.190, Speaker A: Right.
00:41:00.260 - 00:41:31.366, Speaker B: Okay, so right now it shows the boss and the boss is the deployer and we have our own modifier. Okay. Yeah. I think what we want to do is inherent open Zeppelin's ownership pattern here. Think we should. Okay, so, man, this is, it's kind of a tough transition to make because we have so much other stuff in the contract. The best way to show this off is just to have just the ownership stuff that we've written and then carve that out and inherit it.
00:41:31.366 - 00:41:40.106, Speaker B: And then you see that like, oh, we didn't write the ownership stuff. We've inherited it. But there's a lot here. So I don't know, it might be extra complicated, but I say we work through it.
00:41:40.128 - 00:41:46.606, Speaker C: Do you have a, maybe we can just test the olive OS modifier. I think the create function is using it.
00:41:46.628 - 00:41:47.246, Speaker A: Right.
00:41:47.428 - 00:41:54.410, Speaker B: The problem is that the boss is the f nine account. So we need to set us as the boss.
00:41:54.490 - 00:42:03.682, Speaker C: But we are using a scaffold, right. So we can super quick. So maybe we can just copy the front end address and just equal to that address.
00:42:03.736 - 00:42:12.402, Speaker B: Right, let's do that. So let's copy that address and let's go to the smart contract. Where is it setting that boss? It's setting the boss in a constructor.
00:42:12.466 - 00:42:12.790, Speaker A: Right.
00:42:12.860 - 00:42:35.406, Speaker B: So instead of using message sender there on line 29, let's just paste our address in very heavy handedly. Boom. Now we're the boss, right? Now go ahead and deploy that, and let's see if we're the boss. And this is exactly right. This is what scalpels is all about. Quick iterations like make big breaking changes and try things and see what happens. So look at that.
00:42:35.406 - 00:42:36.414, Speaker B: Now we're the boss, right?
00:42:36.452 - 00:42:36.974, Speaker A: There we go.
00:42:37.012 - 00:42:41.680, Speaker B: It's deployed, and we're the boss. So now let's do that. What was it was create.
00:42:42.450 - 00:42:44.830, Speaker C: So you can create like, ten tokens.
00:42:46.930 - 00:42:47.982, Speaker B: And let's see what happens.
00:42:48.036 - 00:42:49.200, Speaker D: We can create more.
00:42:49.590 - 00:42:52.274, Speaker B: 108. We created 108.
00:42:52.392 - 00:42:54.002, Speaker D: We can do more than.
00:42:54.056 - 00:42:56.354, Speaker B: Okay, now we need a bad guy, right? So we need to make.
00:42:56.392 - 00:43:06.310, Speaker C: You can also check the balance right on the balance on top, you can check your address there and see if we have, like, the 100.
00:43:06.380 - 00:43:06.758, Speaker A: Nice.
00:43:06.844 - 00:43:30.874, Speaker B: We have 108. Okay, now we need to have a bad guy. Can a bad guy create? And we should see that a bad guy can't create, right? Instead of writing a test and having the test say it passed, and having this weird, like, did it pass? Do I really understand what's going on here? You can see it visually and make sure you understand what's going on. Okay, so the first one, it's saying, sorry, not the boss, but also you don't have any gas. It's nice to make sure you have gas.
00:43:30.922 - 00:43:31.134, Speaker A: Yeah.
00:43:31.172 - 00:43:37.250, Speaker B: Now try it again. It's going to say, not the boss again, but it's always just a good practice to do that.
00:43:37.320 - 00:43:37.794, Speaker A: Yeah.
00:43:37.912 - 00:43:58.126, Speaker B: Okay. So without writing a complicated test, we basically just created another user and tried it, and we saw that it fails. So now it's set up. So I think only the boss can do the create. And that's great. But we've written our own custom logic. We've created this custom boss.
00:43:58.126 - 00:44:02.330, Speaker B: We've created the require statement. Maybe we did it wrong.
00:44:02.480 - 00:44:02.938, Speaker A: Right.
00:44:03.024 - 00:44:54.950, Speaker B: So the key here is that a lot of other people in the space have written some great contracts for us. And whenever we can inherit someone else's contract, unless we're, like, really low level, we understand what we're doing here. And arguably, with an ownership pattern, you have to keep track of one address and create one modifier. So in this case, maybe the ownership pattern could be something you write yourself but let's just inherit open zeppelin's ownership pattern. And let's carve out anything where we had to make our own owner. Instead of us keeping track of an owner and setting it, let's inherit the smart contract from Openzeppelin that keeps track of an owner, and let's use their ownership pattern. So on line five, we'll uncomment that, right? We'll import open Zeppelin's ownable.
00:44:54.950 - 00:45:01.050, Speaker B: Then on line eight, we need to inherit it. So we'll say your contract, and we'll say is ownable.
00:45:01.390 - 00:45:02.250, Speaker A: Yep.
00:45:02.910 - 00:45:06.314, Speaker C: And maybe we can also take a quick look into the contract.
00:45:06.362 - 00:45:06.526, Speaker A: Right?
00:45:06.548 - 00:45:10.560, Speaker C: Like into the ownable contract, so we can see what we are.
00:45:11.410 - 00:45:14.026, Speaker B: How do you do that? Do you usually just like, Google opens.
00:45:14.058 - 00:45:27.240, Speaker C: Up for me in my ID, if you click line five, it goes to the contract. But I'm not sure if vs code is going to work. I say, like, control and click into honorable no.
00:45:28.090 - 00:45:31.334, Speaker B: Okay, something happened.
00:45:31.532 - 00:45:33.030, Speaker C: Yeah, go to definition.
00:45:35.370 - 00:45:40.458, Speaker B: That's good enough, right? Yes, that's good enough. So this is the contract we're inheriting, right?
00:45:40.544 - 00:45:41.180, Speaker C: Yeah.
00:45:42.590 - 00:46:19.598, Speaker B: Cool. And it itself inherits some contract called context, but let's ignore that. So basically, what do we see here? We see that there is a constructor that transfers the ownership to the message sender, right? And then there is an owner function that gives us whoever the owner is. And then there's a modifier, just like our modifier, that says only owner, and make sure that the owner is the message sender. And if it is, it does the underscore and runs everything. And then there's a couple of other helper functions. Renounce ownership, transfer ownership, and transfer ownership.
00:46:19.774 - 00:46:20.138, Speaker A: Whoa.
00:46:20.174 - 00:46:51.598, Speaker B: What's the difference? One is internal and one is. Yeah, I think, man, this is classic. Like open Zeppelin, they do a little bit of extra stuff and burn a little bit of extra gas every time. They're making sure you don't transfer the ownership to the zero address. They have a separate function called renounce ownership that sends to the zero address. Whatever. But the cool thing is, lots and lots of people have had their eyes on this contract, and if there was something wrong, we would know about it already.
00:46:51.598 - 00:47:01.140, Speaker B: Now, when you inherit stuff, you still need to have your whole system audited. But understand that these contracts are pretty solid on their own. So let's inherit it.
00:47:01.670 - 00:47:23.850, Speaker C: We have the same thing that we have before, right? Like the only boss modifier, plus some other stuff that they added, like the transfer ownership. And also, like you say, a lot of people have tested and put their eyes into the contract. So there are probably no errors or bugs in those contracts. And if you do it yourself, you'll probably have some bugs at some point in your solidity career. For sure.
00:47:24.000 - 00:47:24.694, Speaker B: Totally.
00:47:24.822 - 00:47:30.060, Speaker C: Whenever you can go for inheriting stuff that is already done for you.
00:47:31.070 - 00:48:09.942, Speaker B: Unless your transmission is eleven and you think all of the open Zeppelin stuff is garbage and waste gas. Once you get super technical and super into the weeds, you may have other. But as you get started, this is absolutely the best way to go inherit stuff from open Zeppelin. Things like even the ERC 20 standard if you're trying to make an NFT. Basically, if you're trying to make an NFT, you inherit open Zeppelin's NFT and you set the name of it and you set up how the mint function works and that's it. Everything else is handled for you. So lots of things like access control, lots of helpers like cryptographic helpers and EC recover stuff.
00:48:09.942 - 00:48:28.778, Speaker B: Tons of different things that you want to get into you can grab from the open zeppelin stuff. And you just Google open Zeppelin GitHub, you'll see all their cool contracts. Okay, so back to our is. I think we set it so it is ownable. There we go. Yep. We have is ownable.
00:48:28.778 - 00:48:34.130, Speaker B: And then we probably don't need to track the boss anymore, right? So we can delete line 17.
00:48:35.590 - 00:48:38.658, Speaker C: Also line 27.
00:48:38.744 - 00:48:39.042, Speaker A: Yes.
00:48:39.096 - 00:48:53.730, Speaker B: We don't need the line for the constructor anymore because it's doing it in the constructor from the one that we inherit. We don't need the modifier anymore. And now on line 30 we can change it to only owner.
00:48:53.810 - 00:48:54.054, Speaker A: Right.
00:48:54.092 - 00:49:09.420, Speaker B: Which is the modifier that comes from the library. So there we go. We stripped out a handful of things from our own contract and we just inherit it from another contract. That's safer. Hopefully that's clear. But let's run it and see if it works. Let's see if it does the right thing.
00:49:10.350 - 00:49:13.310, Speaker C: I think there is another Oli boss in there.
00:49:13.460 - 00:49:15.774, Speaker B: Is there? It'll yell at us right here.
00:49:15.812 - 00:49:17.120, Speaker C: Yeah. Let's see.
00:49:18.610 - 00:49:29.138, Speaker B: 54. What was it? Maybe it'll withdraw function. Awesome. There we go. And boss call.
00:49:29.304 - 00:49:30.226, Speaker C: What are we going to have to do?
00:49:30.248 - 00:49:33.140, Speaker B: Is it underscore owner or owner or something like that?
00:49:33.670 - 00:49:40.178, Speaker C: But I'm not sure if that's private. I don't know if that variable is. I mean, we'll need to check the ownable.
00:49:40.274 - 00:49:45.090, Speaker B: Yeah, if we go to theownable Sol we can see how we get the owner.
00:49:45.170 - 00:49:46.406, Speaker C: So I guess we need to call.
00:49:46.428 - 00:49:47.974, Speaker B: There's an owner, right?
00:49:48.092 - 00:49:48.374, Speaker A: Yeah.
00:49:48.412 - 00:50:03.434, Speaker B: So we'll just call the owner function and it should return the address. So do we do owner? And then open parentheses, close parentheses, call. So I think we replace boss with owner parentheses. Yeah, like that. That's what I was thinking, too.
00:50:03.552 - 00:50:07.246, Speaker C: No, maybe without the parentheses. I don't know.
00:50:07.268 - 00:50:08.750, Speaker B: No, it's happy. It's happy.
00:50:08.820 - 00:50:10.670, Speaker C: Yeah. Let's try it.
00:50:10.820 - 00:50:25.970, Speaker B: It doesn't like the fact that we're not using that data, but that's fine. Let's see if this works. Yeah. All right. So now let's make sure that only the owner can call that create function.
00:50:26.120 - 00:50:28.754, Speaker C: But the thing is that now we are not the owner.
00:50:28.802 - 00:50:29.526, Speaker A: Right? Oh, yeah.
00:50:29.548 - 00:50:30.678, Speaker D: Look who the owner is.
00:50:30.764 - 00:50:37.746, Speaker C: Because if you check the constructor of the ownable contract, you will see that it sets the deployer as the first owner.
00:50:37.778 - 00:50:37.974, Speaker A: Yes.
00:50:38.012 - 00:50:42.010, Speaker B: And we can't heavy handedly paste our address into this one. We're going to have to do it, right?
00:50:42.080 - 00:50:42.650, Speaker A: Right?
00:50:42.800 - 00:50:43.258, Speaker C: Yes.
00:50:43.344 - 00:50:44.950, Speaker B: We're going to have to transfer ownership.
00:50:45.030 - 00:50:45.370, Speaker A: Right?
00:50:45.440 - 00:50:54.174, Speaker B: Yeah. Okay, cool. So if we go back to the scaffold ETH real quick, you'll see that the transfer ownership and the renounce ownership have showed up here.
00:50:54.212 - 00:50:54.414, Speaker A: Right.
00:50:54.452 - 00:51:01.870, Speaker B: We see that we could technically transfer the ownership, and if we look at the owner, it's our friend F 39.
00:51:01.940 - 00:51:02.174, Speaker A: Right.
00:51:02.212 - 00:51:15.250, Speaker B: So the deployer owns the account, and we need a way for the deployer to hand the account off to us. What we need is the deployer to call transfer ownership to us. And the place we do that is in the debug or in the deploy script.
00:51:15.750 - 00:51:31.190, Speaker C: Yeah. If you want, we could import the private key of the F 39, because that's really ugly. Maybe. But you can import that into metamask, connect with that account, and then you could call the transfer ownership from here.
00:51:31.260 - 00:51:37.546, Speaker B: But usually a lot of people do that, a lot of coders. Right away, they think that's a great idea, and it works.
00:51:37.648 - 00:51:38.106, Speaker A: Right.
00:51:38.208 - 00:52:10.520, Speaker B: And then you have this nice account in your metamask that has all the local money and it's all connected. But it's a bad practice to be copy pasting those private keys into your metamask like that. You need to definitely have a debug developer metamask if you're going to do that. As soon as you learn how private keys work and how the systems work, everyone does that. Everyone starts to copy and paste private keys around. It's a bad idea. You'll get yourself into a lot of trouble with that.
00:52:10.520 - 00:52:29.446, Speaker B: Technically, you can do that. You could easily go get the private key from hard hat. You could paste it into metamask as a new account. But let's not do that. Let's do a transfer ownership instead. Let's have a nice burner account, and when it deploys, let's have it transfer. So we need to go to our deploy script.
00:52:29.446 - 00:52:44.190, Speaker B: It's not that script. This is the old one, right? It'll tell us that's the one. And if we get in here, we see where those arguments were. This is the same thing I was doing. I uncommented line 23 and I added some arguments. But like that scaffolding. There's lots of scaffolding here.
00:52:44.190 - 00:52:47.422, Speaker B: See these comments that are set up on line 29.
00:52:47.556 - 00:52:48.306, Speaker A: Yes, go ahead.
00:52:48.408 - 00:53:06.358, Speaker C: No, I was going to say line 29 and line 30. Right. If you see on the line 30, it's calling one function of the contract, like the set purpose. We can call instead of set purpose. We can call transfer ownership and paste in the front end address that we have.
00:53:06.524 - 00:53:30.560, Speaker B: Yes, this is our deploy script. This happens when we run a yarn deploy on line 20, it does the deployment. And then once you have the contract deployed, it's going to do some extra stuff. And we can see on line 29 that loads the contract up so it connects to that deployed contract. So I think what we want to do is just uncomment that line 30 there. And we want to call instead of calling.
00:53:31.890 - 00:53:32.254, Speaker A: Yeah.
00:53:32.292 - 00:53:36.818, Speaker B: And then maybe trash that other stuff for now or maybe even comment that line.
00:53:36.904 - 00:53:37.298, Speaker A: Yeah.
00:53:37.384 - 00:53:40.530, Speaker D: So this actually does explain like the ownership pattern.
00:53:40.950 - 00:53:50.360, Speaker B: It's right there. Look at that. Thank you. Whoever put that in there. Let's just uncomment that one and then get rid of 30.
00:53:52.330 - 00:53:54.120, Speaker D: And we want our address.
00:53:54.810 - 00:53:55.560, Speaker A: Yes.
00:53:56.970 - 00:54:02.842, Speaker B: I don't think you want line 36 though. Yeah, no, you don't need line 36. Just.
00:54:02.976 - 00:54:03.514, Speaker A: Okay.
00:54:03.632 - 00:54:04.842, Speaker B: Yeah, right in there.
00:54:04.896 - 00:54:05.482, Speaker A: There we go.
00:54:05.536 - 00:54:26.930, Speaker B: And you need quotes around it when it's not in the smart contract. There we go. And we don't need line 30. We can comment that and let's just take a second to look at that. So on line 29, we load up our connection to our deployed contract. And then on line 34, we call transfer ownership to our front end address. And all of this stuff is being done by that deployer address.
00:54:26.930 - 00:54:37.662, Speaker B: So basically the F 39 guy deploys the contract and then makes a second transaction on it, setting us as the owner. Is that the right way to explain it?
00:54:37.736 - 00:55:05.722, Speaker C: I think so, yeah. And another option, like if we wanted to do only in one transaction, we could have our front end address into the constructor, into the arguments, and then calling the transfer ownership from the contract. Because right now we are calling from the deployer account is calling the transfer ownership, but the deployer account could deploy the contract. And then in the constructor function, we could call transfer ownership. It will be like the same effect, but in one transaction.
00:55:05.786 - 00:55:16.962, Speaker B: Right. Let's try it this way. And then let's go try that real quick. It wouldn't be hard. And we'd be changing our own constructor, not the inherited constructor. That's where we'd get why it would be easier. Let's try it this way first.
00:55:16.962 - 00:55:29.166, Speaker B: Just real quick. Let's make sure it deploys. And let's make sure we're the owner. What did we do wrong? Unexpected error. Your contract is not defined.
00:55:29.198 - 00:55:29.346, Speaker A: Okay.
00:55:29.368 - 00:55:32.142, Speaker B: I think it's a capital y every once in a while.
00:55:32.216 - 00:55:32.406, Speaker A: Yeah.
00:55:32.428 - 00:55:37.058, Speaker B: See, in line 29, it uses a capital Y, and then 34, it uses a lowercase.
00:55:37.154 - 00:55:37.800, Speaker A: Yeah.
00:55:40.830 - 00:55:43.594, Speaker B: So whoever helped us out almost got it.
00:55:43.632 - 00:55:44.220, Speaker A: Right.
00:55:46.350 - 00:55:50.766, Speaker B: And let's see, are we the owner? Sure enough. F six. F. That's us.
00:55:50.948 - 00:55:51.838, Speaker A: All right.
00:55:52.004 - 00:55:52.720, Speaker B: Okay.
00:55:54.610 - 00:55:56.270, Speaker C: You can call, like the create function.
00:55:56.340 - 00:55:56.478, Speaker A: Yeah.
00:55:56.484 - 00:55:57.694, Speaker B: Make sure we can call create real quick.
00:55:57.732 - 00:55:58.320, Speaker A: Yes.
00:55:59.890 - 00:56:16.542, Speaker B: Let's create 108. Yeah. I don't know why 108. That is our number today. The price of Ethereum next week. Okay. Some dark humor from developers.
00:56:16.542 - 00:56:36.038, Speaker B: We shouldn't even be talking about price, should we? Okay, so our balance, you check the balance of the contract there. There you go. Yeah, there we go. 108. Awesome. Okay, so what Carlos was saying is this is actually more expensive because we do the deployment, then we do a second transaction. And that second transaction has some overhead.
00:56:36.038 - 00:56:57.506, Speaker B: If we do that all in the same transaction, it's going to actually cost less. So if we go to. Let's go back to our deploy script and just comment out that thing. Yes, let's just comment out that. And you technically could comment out 29 if you wanted to too. But it doesn't matter. Knowing this, if we hit save and we hit deploy, let's do that.
00:56:57.506 - 00:57:15.634, Speaker B: Let's save and deploy, and let's see that. Sure enough, it should be back to F 39 as the owner is now F 39. Okay, now let's go to the constructor of our contract, the one that inherits their contract. And let's go look at our constructor.
00:57:15.682 - 00:57:15.894, Speaker C: Okay.
00:57:15.932 - 00:57:20.700, Speaker B: In our constructor, what do we need to call here? We want to call transfer ownership, right?
00:57:21.070 - 00:57:29.866, Speaker C: Yes. Maybe the best way would be to have a parameter in the constructor. Right. So we can send our address. Right. Like the address where we want to send.
00:57:29.968 - 00:57:47.246, Speaker B: Let's just paste it in. Okay. You totally should just have an address in the thing. But let's just paste it in like we were. I think it's just transfer ownership, right? Do we need to grab. Yeah, you could do that kind of. We're going to paste some JavaScript into our solidity.
00:57:47.246 - 00:57:54.222, Speaker B: It'll work though. I think we just need to call transfer ownership though. You can delete everything before the period, I think, and including the period.
00:57:54.286 - 00:57:54.802, Speaker A: Right.
00:57:54.936 - 00:57:57.502, Speaker C: You can also use like super. Right, like super dot.
00:57:57.566 - 00:57:59.510, Speaker B: Is it super transfer ownership?
00:57:59.930 - 00:58:02.214, Speaker C: I think you don't need to do that. I think.
00:58:02.412 - 00:58:03.622, Speaker B: Let's see what happens here.
00:58:03.676 - 00:58:06.994, Speaker C: Yeah, I usually do that because it's like more explicit.
00:58:07.042 - 00:58:07.206, Speaker A: Right.
00:58:07.228 - 00:58:09.430, Speaker C: Like you are calling the parent contact.
00:58:09.580 - 00:58:26.478, Speaker B: Let's see if this even works. And see, you don't have to be a gigabrain to figure this out. You just paste it in and find out if it works. F around and find out. That's what scaffold is all about and we're the owner again. It worked. Let's try super transfer just while we're here and we're talking about it.
00:58:26.478 - 00:58:28.000, Speaker B: Let's see if it changes anything.
00:58:30.210 - 00:58:30.718, Speaker A: Cap.
00:58:30.804 - 00:58:31.246, Speaker C: Super.
00:58:31.348 - 00:58:59.718, Speaker B: Yeah, it likes it. It's okay. Totally worked, right? Totally worked exactly the same. But you're saying this is a little more explicit and it's showing that we're inheriting something and we're talking to the parent when we call that. Awesome. And we saved ourself 21,000 gas by putting it all into the same thing. And probably a little bit of complication, like a little less of a headache.
00:58:59.718 - 00:59:28.258, Speaker B: Okay, inheritance, let's see. On speedrun Ethereum I have mappings, structs, modifiers, events, inheritance, sending ETH and payback function. So basically we're kind of like at the point where maybe we could show a little contract to contract interaction here and I can set that up over on my end. I could share my screen again. Anything else from here that we want to cover or anything you were thinking of, Carlos, that would be good to show off. Or have we covered it pretty well.
00:59:28.344 - 00:59:34.354, Speaker C: Like maybe the receive on the fallback functions? I'm not sure if we want to cover that.
00:59:34.392 - 00:59:36.818, Speaker B: How about I do that on my side too? I'll do that over here.
00:59:36.904 - 00:59:42.150, Speaker C: Like, like trying to send money to a contract without the receive function and see what happens.
00:59:42.300 - 00:59:42.982, Speaker A: Yeah, right?
00:59:43.036 - 01:00:07.424, Speaker B: Yes, that sounds great. Okay, let me get us back to. Let me share my screen. Let me get us back to hopefully like the starting scaffold ETH contract. Oh boy. Okay, back it up, back it up. Back it up, back it up.
01:00:07.424 - 01:00:23.608, Speaker B: It'd be right there. Okay, now we have our stock scaffold ETH contract. I can deploy that. We have our front end here. We've got our units, we've got our primitives. We've got solidity by example. All right.
01:00:23.608 - 01:00:35.500, Speaker B: Okay. So what we want to learn about, right, is receive. R a C E I E v E. Those French don't know how to spell. E I v e. No, it's the American that doesn't know how to spell.
01:00:37.680 - 01:00:45.570, Speaker C: Maybe search for send, callback. Maybe send, I think send ether send. Yeah.
01:00:47.860 - 01:00:51.570, Speaker B: This is how to send ether out of the contract, which we definitely should show.
01:00:52.820 - 01:00:56.172, Speaker C: I think it shows in there. Like in the other one? Like in the send.
01:00:56.326 - 01:00:57.380, Speaker B: It's in this one?
01:00:57.450 - 01:00:58.070, Speaker C: Yes.
01:00:58.440 - 01:00:59.190, Speaker A: Okay.
01:00:59.560 - 01:01:03.492, Speaker B: It's weird that it's there. Yeah, it's here.
01:01:03.546 - 01:01:04.420, Speaker A: Right. Okay.
01:01:04.490 - 01:01:05.844, Speaker B: Let's just experiment with it.
01:01:05.882 - 01:01:06.084, Speaker A: Right.
01:01:06.122 - 01:01:13.416, Speaker B: Again, you don't have to be a gigabyte. You don't have to have all this figured out. You can basically just get scaffold ETH up and you can tinker around with it. You could try it.
01:01:13.438 - 01:01:13.624, Speaker A: Right.
01:01:13.662 - 01:01:36.192, Speaker B: I'm going to trash this stuff and I'm going to trash this and I'm going to comment this out. So I'm going to have nothing in here but a constructor. This has just got a blank contract, actually, we probably need some kind of. Here, let's do this. Let's have it. That's not very fun. Does this even do anything?
01:01:36.326 - 01:01:36.720, Speaker A: Yes.
01:01:36.790 - 01:01:48.548, Speaker B: Okay, so let's. Or, hello. I'm just setting something up so it shows up in our contract. Hello, world.
01:01:48.634 - 01:01:49.124, Speaker A: There we go.
01:01:49.162 - 01:01:58.560, Speaker B: Very simple contract. We're storing the string world. This should get deployed. Okay, here is our dummy contract.
01:01:58.640 - 01:01:59.028, Speaker A: Right.
01:01:59.114 - 01:02:13.096, Speaker B: Nothing is happening here. What I'm going to do is I'm going to copy this address, I'm going to open up my wallet, and I'm going to try to send $100 to our contract. I'm going to send it directly to the address of the contract. I'm not calling some payable function, I'm sending it directly.
01:02:13.288 - 01:02:14.552, Speaker C: Blomp blomp.
01:02:14.616 - 01:02:46.464, Speaker B: It says there's no fallback or receive function. So just like when we had to make that function payable, right? Remember when we had to add that payable keyword? It's safety. Right? We don't want a function to take in money when the developer doesn't want money to flow in. Same thing here. You have to explicitly say, I want this smart contract to receive funds. And once you set that receive function and you deploy it, then your contract will be able to receive funds. And not until you add that will that happen.
01:02:46.464 - 01:03:03.692, Speaker B: Okay, and let's try that one more time. So now I have a new contract. Grab that address, grab the wallet. Let's try sending $100 this time. And Tada. $100 sends in, right? So just by adding that receive function. All right, I'm going to do one other thing.
01:03:03.692 - 01:03:36.244, Speaker B: I'm going to say let's make this a unit 256 counter and we'll set it, it'll start out equal to zero, right? And then anytime anybody look at this, anytime anybody sends some money in, we'll increment the counter. Very weird. Very weird. But that's what we're doing. We're just trying stuff out, we're learning stuff. We're seeing what we can do. All right, now we have this new contract and anytime I Yolo funds to that address, our counter should update.
01:03:36.244 - 01:03:43.208, Speaker B: Very nice. So let's send another $100 and there we go.
01:03:43.294 - 01:03:43.640, Speaker A: Okay.
01:03:43.710 - 01:04:26.756, Speaker B: I don't know why, but anytime you send some money in here. So this is really nice user experience, right? If you had some contract here that has some complicated investment strategy and there's some deposit function that someone needs to call to send in money, and that deposit function is probably public payable. A lot of times you'd like your user to just send the money in. So what we do is let's set this up. Console log. This would be message sender deposited. Oh yeah, good spelling deposited.
01:04:26.756 - 01:04:46.748, Speaker B: And then some message value. Okay, so we could call the deposit function directly, but what we're going to do is anytime it receives funds, it just is going to redirect those funds to the deposit function. Now let's try this out. I probably did something wrong here or maybe it's not going to let me do this. Totally did.
01:04:46.834 - 01:04:47.272, Speaker A: Totally.
01:04:47.336 - 01:05:09.152, Speaker B: Awesome. Okay, so technically I could just deposit 0.5 ether in there, right? And that's going to. Oh, our counter is not doing anything. Doesn't need to. I'm able to call deposit. But what I wanted to show here is I can also deposit funds by just sending money to the contract.
01:05:09.152 - 01:05:32.892, Speaker B: I can just send $100 to this. Just like anyone can open up their wallet. Maybe this is even at an Ens address like austinsgreatfunds ETH, right? If you want to deposit into Austin's great funds, you can just send to austingreatfunds ETH send $100 and it's automatically going to call that deposit function. And we see that so and so deposited that $100, whatever that is.
01:05:32.946 - 01:05:33.308, Speaker A: Right.
01:05:33.394 - 01:05:39.964, Speaker B: So we can see that over in the contract. Okay, so we've done payable functions. Fall back. Yeah, go ahead, please. Fill it in here.
01:05:40.002 - 01:05:41.020, Speaker C: What are we missing?
01:05:41.760 - 01:05:54.630, Speaker D: Maybe it could be nice since we have a bit more time to show the withdrawal function as well. So you have money in the contract, but no way out right now. So it'd be a nice time too.
01:05:55.320 - 01:06:04.580, Speaker B: So public. And who are we going to let withdraw? Should we let anybody withdraw for now? Let's do it. So we'll do message sender.
01:06:06.680 - 01:06:07.380, Speaker A: Call.
01:06:07.530 - 01:06:22.604, Speaker B: Let's just do transfer, right? We're going to go with the oldest trick in the book here. We're just going to do a transfer. Oldest trick in the book. This is weird. Okay, and here we go. We need the address. This balance a weird line of code there.
01:06:22.604 - 01:06:39.170, Speaker B: I think this even still needs to be payable. I think it's going to complain that that's not payable, but let's see if this works. Basically letting anyone get in here and call withdraw and take the money. Yeah, it's going to say it needs to be payable. A lot of little tricks you have to learn to get this quite right here.
01:06:40.180 - 01:06:41.964, Speaker A: Okay, there we go.
01:06:42.022 - 01:06:59.652, Speaker B: Now let's try saving that and deploying and see what happens. Nice. Okay. And so now anybody can go ahead and deposit half an ETH and then anyone can call that withdraw function and withdraw that ETH.
01:06:59.716 - 01:07:00.328, Speaker A: Right?
01:07:00.494 - 01:07:22.768, Speaker B: Okay. So we probably want some modifier there, making sure it's the owner. But I'm just going to build my own, require that message sender equals. Equals this dude or not the owner. So normally I would just inherit. Oh, man, it's right here. Why don't I just inherit it? We were just talking about it, right.
01:07:22.768 - 01:07:51.480, Speaker B: Is ownable. And instead of doing this, we just say only owner. And in this case, we would need to also transfer the ownership to our front end guy. How's that? Is it going to compile? I'm like 20% confident.
01:07:52.060 - 01:07:53.210, Speaker D: 80%.
01:07:55.420 - 01:07:56.664, Speaker B: There we go. There we go.
01:07:56.702 - 01:07:57.192, Speaker A: Same thing.
01:07:57.246 - 01:08:19.052, Speaker B: But now we have a nice ownership pattern. Here we see the renounce ownership and transfer ownership set up. And if we deposit some funds by just sending some money in. Let's send in $100. It should go. It should trigger the deposit. And now only we should be able to withdraw.
01:08:19.116 - 01:08:19.344, Speaker A: Right?
01:08:19.382 - 01:08:22.636, Speaker B: Only the owner and we were able to withdraw.
01:08:22.748 - 01:08:23.216, Speaker A: Awesome.
01:08:23.318 - 01:08:28.164, Speaker B: There we go. Now we've got the withdraw pattern. Oh, yeah. This is the last little bit here.
01:08:28.202 - 01:08:28.548, Speaker A: Right.
01:08:28.634 - 01:08:48.324, Speaker B: So that transfer, if you are transferring to another contract, that has a receive function that does some stuff inside of that receive function. It's going to cost gas. So this transfer isn't the right way to do it. You want to go to the sending ether and you want to do this.
01:08:48.382 - 01:08:48.990, Speaker A: Right.
01:08:49.520 - 01:09:02.990, Speaker B: Just kind of a little like pain in the butt, but you just kind of have to learn this stuff. So we'll say message sender, call and the value will be that.
01:09:03.440 - 01:09:04.188, Speaker A: Right.
01:09:04.354 - 01:09:16.688, Speaker B: And technically we can get rid of this to make sure we don't get that warning. And we can go ahead and require that it works. Totally copy and pasting. But let's see if this works. Does this need to be payable?
01:09:16.784 - 01:09:17.812, Speaker A: Doesn't look like it.
01:09:17.866 - 01:09:19.044, Speaker B: Looks like it's happy.
01:09:19.242 - 01:09:19.796, Speaker A: Yeah.
01:09:19.898 - 01:09:48.396, Speaker B: So even though this line looks a little bit more obvious, this is the right way to do it because of gas limits. And let's go double check that we can yolo into the contract. Oops, I didn't go to the right address there. Yolo into the contract and make sure the money goes in. Got $100 and then make sure we can withdraw and the money comes out. Okay.
01:09:48.498 - 01:09:48.860, Speaker A: Done.
01:09:48.930 - 01:09:49.516, Speaker B: We got it.
01:09:49.538 - 01:09:49.772, Speaker A: Right.
01:09:49.826 - 01:09:58.620, Speaker B: We were able to write our own there. Show the transfer, show the ownable, show the deposit, show the withdrawal. I feel like now we do contract to contract.
01:09:58.700 - 01:09:59.330, Speaker A: Right.
01:10:00.500 - 01:10:09.700, Speaker B: Are we about at that point? Have we filled in anything else? Anything I'm missing here? Any insights? Should we go for it? Time for a second contract.
01:10:10.120 - 01:10:17.972, Speaker C: Yes. Because you say online 22, right? You said that that can be a problem if you send money to a contract.
01:10:18.036 - 01:10:18.504, Speaker B: Right.
01:10:18.622 - 01:10:27.348, Speaker C: But for us, like message sender has always been one of us. Right. One of these accounts.
01:10:27.524 - 01:10:29.208, Speaker B: Externally owned account.
01:10:29.374 - 01:10:36.060, Speaker C: Yes. So what happens? How can it be possible that a contract to be the message sender?
01:10:36.640 - 01:10:57.344, Speaker B: We're about to find out. Right. Okay. So this contract is kind of like a bank where people can deposit and withdraw. Really what we could do is we could keep track of some mapping. How about we do that? How about we have a mapping.
01:10:57.392 - 01:10:57.920, Speaker A: Whoops.
01:10:58.000 - 01:11:06.356, Speaker B: I'd like that. Bring that back from some address to some unit 256. And this is your public balance.
01:11:06.468 - 01:11:07.130, Speaker A: Right.
01:11:07.820 - 01:11:16.680, Speaker B: And there's not going to be any ownership. The bank is ownerless. I think that's a really neat thing to have.
01:11:16.750 - 01:11:17.368, Speaker A: Right.
01:11:17.534 - 01:11:35.410, Speaker B: So let's see. So we're going to have this. We'll have no ownership. We'll actually not even have a constructor. We'll have a deposit. A withdraw. The deposit is going to balance of message sender plus equals the message value.
01:11:35.410 - 01:12:08.410, Speaker B: And the withdraw will do. Here's reentrancy. Let's just set it up so you can reenter into it. We'll talk about that later. We will first send you your balance and then we will reset your balance. Okay, we just made a bank, right? It allows you to deposit money. It keeps track of your money.
01:12:08.410 - 01:12:28.480, Speaker B: Oh, no minus equal. No, it just sets to zero because it sends you the balance. Okay, let's make sure this works real quick. Let's make sure our little bank works. And then we'll create another contract that talks to the bank, basically. Okay, so here's our bank contract. Let's have two different players that are going to play on the bank contract.
01:12:28.480 - 01:12:59.288, Speaker B: We're going to have green guy and purple guy grab some money for purple guy. Okay, so hopefully purple guy has some money. Let's get some more money for purple guy. Let's go. Okay, so purple guy wants to deposit $20 into the bank. They could call the deposit function or they could just send money straight to it. So we're going to send $20 into the bank from purple guy.
01:12:59.374 - 01:12:59.816, Speaker A: There we go.
01:12:59.838 - 01:13:26.564, Speaker B: So now the bank holds $20 and if we check the balance, we should see that this guy's balance. Oh, that's kind of weird, but yeah, that's 0.1. Be nice if that showed it in USD. Okay, now let's have green guy also deposit some funds green guy will use. Let's see, how much do we have? Oh, wow. Let's deposit an entire ETH kaboom. Now we'll see that the contract value goes way up.
01:13:26.564 - 01:13:33.344, Speaker B: Right now there's 1200 and some in there. And our balances are separate.
01:13:33.392 - 01:13:33.796, Speaker A: Right.
01:13:33.898 - 01:13:43.512, Speaker B: This guy has a balance of 0.1, this guy has a balance of one. And if they withdraw, they should only be able to get their money back.
01:13:43.566 - 01:13:43.736, Speaker A: Right.
01:13:43.758 - 01:13:52.444, Speaker B: So if I call withdraw from this guy, the balance of the contract goes all the way back to 20 and my address, my balance goes down to zero.
01:13:52.562 - 01:13:53.036, Speaker A: Right.
01:13:53.138 - 01:14:14.740, Speaker B: So simple, simple contract. We're keeping track of a mapping. We're letting people deposit and withdraw. We're making sure no one can deposit and or can withdraw from other people's funds. Very simple contract, but basically just lets people deposit and withdraw money and we keep track of everybody's balance. Makes sense there. Did I miss anything there? Does that look pretty good? Okay, here we go.
01:14:14.740 - 01:14:36.696, Speaker B: So I'm going to call that bank Sol. Okay, so we've got bank Sol and then we've got yourcontract Sol. That will do something different. But let's just set it up to be, I don't even know. Maybe we just set it up as ownable or something.
01:14:36.798 - 01:14:37.304, Speaker A: I don't know.
01:14:37.342 - 01:14:42.510, Speaker B: Let's see. Public. I don't even know what to do with this contract yet.
01:14:45.120 - 01:14:45.628, Speaker A: Public.
01:14:45.714 - 01:15:01.792, Speaker B: Let's just make it a string. I don't even know string. Public purpose. We always do this, right? This guy is hello world. Okay, simple, simple contract. Now we have two contracts. We need to deploy both of them, right.
01:15:01.792 - 01:15:24.600, Speaker B: First we probably will deploy our bank and then second, we'll deploy our your contract. So I'm going to head to the deployment now. I think technically, usually you duplicate this for a second contract. I think I'm going to go ahead and do that. So we'll deploy your contract and our zero will be deploy. I'm going to rename it. We're going to deploy the bank.
01:15:25.980 - 01:15:26.536, Speaker A: Okay.
01:15:26.638 - 01:15:46.640, Speaker B: And this will deploy bank. Man, I hope I'm doing this right. Let's see. And this will export bank. So hopefully we should deploy the bank as the first contract and then we should deploy your contract as a second piece. Let's see what happens. Let's just try it out.
01:15:46.640 - 01:15:49.088, Speaker B: Let's just try it out. See if I'm missing something here.
01:15:49.254 - 01:15:54.580, Speaker C: I think you will need to add to the react application, like the contract.
01:16:00.920 - 01:16:07.460, Speaker B: Something here, this right here, it's not finding your contract.
01:16:13.690 - 01:16:14.486, Speaker A: Yes.
01:16:14.668 - 01:16:25.194, Speaker B: Good to go. Okay, so now we should have both the bank and your contract. Okay, we got to go edit the front end now.
01:16:25.232 - 01:16:25.386, Speaker A: Right.
01:16:25.408 - 01:16:38.800, Speaker B: We're going to go here. I'm going to look for that contract component. There's a nice contract react component. Isn't this sweet? You just have this nice contract here and I'm going to bring the bank in right below it.
01:16:39.570 - 01:16:45.566, Speaker D: So maybe it would be nice to show the front end before editing as well. What pops up?
01:16:45.588 - 01:16:46.062, Speaker B: Oh, okay.
01:16:46.116 - 01:16:46.382, Speaker A: Yes.
01:16:46.436 - 01:17:04.902, Speaker B: It was just showing your contract basically without the bank there. It just shows that your contract with the hello world. And then I'm just going to paste in the bank. So we have a second contract there. There we go. So now we have two contracts we're talking to. There's our bank that we created that lets anybody Yolo some funds in here.
01:17:04.902 - 01:17:16.694, Speaker B: Like I have zero for my balance, I deposit 0.1 and now if I go check my balance, I've got 0.1 deposited. The bank is holding that I can withdraw.
01:17:16.742 - 01:17:16.906, Speaker A: Right.
01:17:16.928 - 01:17:26.522, Speaker B: So as an externally owned account, I can invest in my bank or I can lock money into my bank. But what we want to do is have this contract be talking to the bank.
01:17:26.586 - 01:17:27.006, Speaker A: Right.
01:17:27.108 - 01:17:28.858, Speaker B: And that's when it's going to get tricky.
01:17:28.954 - 01:17:29.310, Speaker A: Anything.
01:17:29.380 - 01:17:48.878, Speaker B: I'm not covering enough here. I feel like maybe there's some, any questions or thoughts here before we keep going. Okay, so our contract needs to set up basically an interface to talk to the bank contract.
01:17:48.974 - 01:17:49.522, Speaker A: Right.
01:17:49.656 - 01:17:58.390, Speaker B: The best way to show that at first might be to show our balance, but it's not going to be set to anything. So I feel like let's just set up our constructor.
01:17:59.930 - 01:18:00.680, Speaker A: Okay.
01:18:02.430 - 01:18:25.954, Speaker B: And in our constructor we're going to have an address. Actually, let's not even do that. Let's just have a connect to contract, something like this. This is going to be really weird. It's not exactly how you do this, but I want to call some connect to contract and I want to set up an interface to it. So what we need to do is we need to have the interface up here.
01:18:25.992 - 01:18:26.194, Speaker A: Right?
01:18:26.232 - 01:18:41.460, Speaker B: We need to have an interface like this. Here's what an interface looks like where it doesn't have the actual functions. It just has something that looks like this.
01:18:47.110 - 01:18:47.630, Speaker D: It.
01:18:47.720 - 01:18:48.534, Speaker A: Is that about right?
01:18:48.572 - 01:18:50.262, Speaker B: Is that what an interface looks like?
01:18:50.396 - 01:18:56.474, Speaker C: Yeah, maybe if you need like some semicolons at the end of the, like this. I think so.
01:18:56.512 - 01:18:57.100, Speaker A: Yeah.
01:18:58.990 - 01:19:03.340, Speaker B: Gotta have Carlos. Carlos. Got to have some semicolons. Oh, no, didn't like that.
01:19:04.510 - 01:19:07.420, Speaker C: Maybe we move the.
01:19:13.950 - 01:19:17.062, Speaker B: DK. Oh, they need to be virtual.
01:19:17.126 - 01:19:18.042, Speaker A: Maybe. I don't know.
01:19:18.096 - 01:19:43.314, Speaker B: I'm gonna go back to just it compiled. I'm gonna go back to this. Let's make sure this compiles. Oh, what did I do wrong there? Duplicate output destination bank JSoN. Because it's compiling this, isn't it?
01:19:43.432 - 01:19:52.710, Speaker C: Yeah, maybe you need to put the interface word instead of contract on line eight. That needs to be interface, not contract.
01:19:54.570 - 01:20:01.190, Speaker B: I don't think I've ever done it like that before. And then maybe I need those semicolons.
01:20:01.530 - 01:20:05.738, Speaker C: Yeah, maybe. And I think maybe they need to be external or something like that.
01:20:05.904 - 01:20:11.706, Speaker B: Okay. Yeah, but here's what we can do. Instead of bringing in the interface, which is really nice, to have the interface there, we can just import it.
01:20:11.728 - 01:20:11.866, Speaker A: Right?
01:20:11.888 - 01:20:15.170, Speaker B: We can say import bank.
01:20:15.350 - 01:20:16.080, Speaker C: Yeah.
01:20:18.690 - 01:20:39.270, Speaker B: And that will do the same thing. Let's see if this works. We're doing it like ten different ways. Okay, that actually worked. Okay, so it does deploy the bank, then it deploys your contract. We have the bank imported in. And what that allows us to do is we create some kind of bank.
01:20:39.270 - 01:20:41.938, Speaker B: We'll just call this bank contract.
01:20:42.034 - 01:20:42.680, Speaker A: Right.
01:20:43.370 - 01:20:57.690, Speaker B: And then what we can do is say bank contract equals equals. And we want to, now if we say new bank. It's actually going to deploy a bank contract.
01:20:58.030 - 01:20:58.538, Speaker A: Right.
01:20:58.624 - 01:21:27.218, Speaker B: So this is a factory. When you deploy your contract, it's going to deploy a new bank contract. But instead we're just going to say bank. We're not going to say new and we're going to put in an address here which will come in from here. Bank address. Okay, so now, really strange stuff, but this is how you set up one contract to talk to another contract. You create an instantiation of the bank and then you pass in a bank address.
01:21:27.218 - 01:21:57.694, Speaker B: And then it's going to create a connection to that second contract. And we can talk to this new bank contract in a second. By doing this, we need to edit our deploy and make sure we pass in our bank address to here. So we're going to have to do like get this right. We're going to say bank contract equals bank and then we'll do bankcontract address. Am I doing this right?
01:21:57.812 - 01:21:58.382, Speaker C: Yes.
01:21:58.516 - 01:22:16.294, Speaker B: Let's see what happens. 20% share. Yeah. Payable address here. Maybe we just say this is a payable. Or maybe we type defit to payable. Let's see if this works.
01:22:16.294 - 01:22:36.938, Speaker B: We're going with it. If not, well, there we go. Okay, cool. So what is happening here? First we're deploying our bank. Then we're getting the address of the bank and we're deploying our your contract with the address of the bank passed in. So then what we should see here. Let's make this public.
01:22:37.024 - 01:22:37.660, Speaker A: Right.
01:22:38.430 - 01:22:46.606, Speaker B: Can you do that? What happens if I do this? Hopefully it'll be an address. I don't know if it's going to let us do this. What would be nice is if it showed it.
01:22:46.628 - 01:22:47.422, Speaker A: It does. Okay.
01:22:47.476 - 01:22:57.986, Speaker B: That's pretty. I like that a lot. I like that a lot. Okay, so let's see this again. We'll deploy our bank, we'll get a new bank contract. Then we'll deploy our your contract. And you can see that the bank is there.
01:22:58.008 - 01:22:58.194, Speaker A: Right.
01:22:58.232 - 01:23:20.246, Speaker B: Notice this is the same as this. Our contract is tracking where the bank is and it knows how to get our address. So then let's just go over to the bank. What can we do? We can call balance, we call withdraw deposit. So let's my balance.
01:23:20.358 - 01:23:21.018, Speaker A: Right.
01:23:21.184 - 01:23:49.940, Speaker B: And what that's going to do is it's going to return bankcontract balance of address. This super weird. And this needs to be a view function that returns a unit 256. And let's see if that works. Basically, hopefully we can call my balance on your contract and it will get us our balance at the bank. Okay, it's zero. Okay, cool.
01:23:49.940 - 01:23:52.660, Speaker B: Then we need some other function.
01:23:54.870 - 01:23:56.098, Speaker C: Deposit maybe?
01:23:56.264 - 01:23:57.394, Speaker B: Yeah, go ahead.
01:23:57.512 - 01:24:03.830, Speaker C: No, I was going to say maybe like a deposit function so we can send some funds from our account to this.
01:24:03.900 - 01:24:05.074, Speaker B: Should we make it payable?
01:24:05.202 - 01:24:09.106, Speaker C: Yes. And then this contract will send that money to the bank.
01:24:09.298 - 01:24:25.274, Speaker B: Okay, let's do it in two different steps though. Okay, let's set it up. Okay. Yeah. So right now when we deploy this thing, we're not able to send money into our, your contract, right. Because we forgot about this receive function. So let's set it up.
01:24:25.274 - 01:24:41.378, Speaker B: So our contract, let's just prove that, right. If I copy your contract and I try to send money to it, it's going to fail. Saying it doesn't have a receive function. Okay, so let's put a receive. That wasn't what I wanted. Let's put a receive function into. Oh man, what did I do? Bank zero.
01:24:41.378 - 01:24:56.182, Speaker B: What am I doing? What have I done? I want this line of code. Please copy. And I want it pasted right here. Okay, fantastic. And I'm not going to do anything. I'm just going to allow money to flow in.
01:24:56.236 - 01:24:56.598, Speaker A: Right.
01:24:56.684 - 01:25:17.482, Speaker B: So now we can at least send money into our contract. This should get deployed and if I copy paste it, I should be able to send $100 to it. Yes. Okay, so we're going to send money into our contract and then we want to call another function, our contract that deposits it into the bank.
01:25:17.546 - 01:25:18.110, Speaker A: Right.
01:25:18.260 - 01:25:32.290, Speaker B: So what we'll do here is we'll say bankcontract, deposit. And then do I do this? There's like a value thing, right? Yeah. So weird.
01:25:33.030 - 01:25:37.350, Speaker C: I'm not sure if you need the parentheses of deposit.
01:25:42.090 - 01:25:48.650, Speaker B: It's called before that. I see what you're saying. You're saying move this like this, I think, right?
01:25:48.720 - 01:25:49.340, Speaker C: Yes.
01:25:52.750 - 01:25:55.002, Speaker B: One arguments and expected it to be zero.
01:25:55.136 - 01:25:55.820, Speaker A: Yes.
01:25:56.510 - 01:26:08.606, Speaker B: Super weird there. So I was thinking I needed to use it as an override like you do in ethers, but when you're in solidity, you do that weird thing where you have the overrides kind of before that.
01:26:08.708 - 01:26:09.358, Speaker A: Right.
01:26:09.524 - 01:26:17.870, Speaker B: Okay, now we should be set up first, let's put some money into our contract.
01:26:17.950 - 01:26:18.338, Speaker A: Right.
01:26:18.424 - 01:26:32.070, Speaker B: So let's send one ETH into our middleware contract. One ETH go. Okay, so now this guy should be holding value.
01:26:32.140 - 01:26:32.422, Speaker A: Yes.
01:26:32.476 - 01:26:41.750, Speaker B: So now he's holding 1200. Okay, then we want to call deposit. Let's deposit like half of it into the contract.
01:26:41.830 - 01:26:42.506, Speaker A: Right.
01:26:42.688 - 01:26:54.202, Speaker B: So this should hopefully. Oh wow. It even updated our balance and everything already so now we see $600 in the bank and $600 in our contract.
01:26:54.266 - 01:26:54.590, Speaker A: Right.
01:26:54.660 - 01:27:01.502, Speaker B: So half of the ETH still lives in our contract. The other half has been deposited. In fact, I could call that again.
01:27:01.556 - 01:27:01.822, Speaker A: Right.
01:27:01.876 - 01:27:06.354, Speaker B: 0.5 deposit. The second one.
01:27:06.392 - 01:27:06.594, Speaker A: Right.
01:27:06.632 - 01:27:10.094, Speaker B: There we go. So now we're doing contract to contract interaction.
01:27:10.142 - 01:27:10.740, Speaker A: Right.
01:27:12.070 - 01:27:20.002, Speaker C: I'm sorry. I was going to say that maybe you can check the balance on the back contract. On the bank contract with your contract address. Right.
01:27:20.056 - 01:27:24.086, Speaker B: So we grab this address and we go to the balance and we check it. And it's one.
01:27:24.188 - 01:27:24.966, Speaker A: Right? Yes.
01:27:25.068 - 01:27:32.214, Speaker B: Which is actually the same thing. This guy is calling, too. The key here is the message sender. Who is the message sender?
01:27:32.262 - 01:27:32.522, Speaker A: Right.
01:27:32.576 - 01:27:50.202, Speaker B: That's what we're really trying to get figured out. When someone calls deposit, it increments the balance of the message sender. So when your contract calls deposit, who is the message sender?
01:27:50.266 - 01:27:50.880, Speaker A: Right.
01:27:51.250 - 01:28:23.686, Speaker B: Let's put a console log in here and really see this. Right, console log. And we're going to say message sender, deposit and then message value. Okay, I want to put TX origin in there eventually, but let's see. Yeah, we want to do that too. Let's see that this happens. Okay, so we have a fresh contract.
01:28:23.686 - 01:28:43.886, Speaker B: We need to send money. This is why we want to do it all as one step, because it's a lot to get set up. But I'm going to send in 0.5. Okay, so now we've got the $600 in our contract. Then if we do the deposit of 0.5, actually, let's just do 0.1 and we hit send.
01:28:43.886 - 01:28:46.722, Speaker B: What we're looking for is the console log over there, right?
01:28:46.776 - 01:28:47.138, Speaker A: Okay.
01:28:47.224 - 01:28:59.190, Speaker B: Two e, two. So the message sender is two e, two. It's not us, it's not our seven, six, five. Even though we're triggering the contract, the message sender is this guy.
01:28:59.260 - 01:28:59.686, Speaker A: Right.
01:28:59.788 - 01:29:01.462, Speaker B: Of course it is. That makes sense.
01:29:01.516 - 01:29:01.734, Speaker A: Right.
01:29:01.772 - 01:29:23.962, Speaker B: So it's like we have the externally owned account, right? And then we have your contract, which is the middleware. And then we have the bank, and we're telling our contract to invest in the bank. So the message sender is our contract. And the last thing I want to add here, let's see. A TX origin is another units.
01:29:24.026 - 01:29:24.302, Speaker A: Right.
01:29:24.356 - 01:29:42.098, Speaker B: If we look at TX Origin, it's the sender of the transaction. It's always the person that signed the transaction. So almost always when it's an externally owned account talking to a smart contract, the Txorigen and the message sender are the same address. They're that originating address.
01:29:42.184 - 01:29:42.722, Speaker A: Right.
01:29:42.856 - 01:30:03.610, Speaker B: But when we're calling a middleware contract and that middleware is talking to the other contract, then that gets a little blurry. The TX origin is always going to be us, but the message sender will be that middleware contract. And we should see that here. Let's go ahead and deploy this last one. I don't know if it's going to. Let me do that with the console log. It did.
01:30:03.610 - 01:30:21.374, Speaker B: Very cool. Thank you. Hard hat. Okay, let's send in $100. Let's do this again. Right, so we go to our contract and we send in what, $1,000 fine. And then we go ahead and deposit zero one or something like that, and we hit send there.
01:30:21.374 - 01:30:48.538, Speaker B: Let's go look at that console log. Okay, so DC one, which is our middleware contract, is the message sender, but the TX origin is our account. Whoops. So see that? The seven, six, five is the TX origin. So just really, let's hammer that home. If I go to ETH bill, I can draw something that'll show this off really simply. And I think it's probably the way to go here.
01:30:48.538 - 01:31:04.910, Speaker B: If I select all this stuff and delete it, basically give me this. Right, so here is our, okay. And then it's talking to a middleware contract, right? Here is your contract.
01:31:06.610 - 01:31:07.262, Speaker A: Okay.
01:31:07.396 - 01:31:14.690, Speaker B: And then it's talking to a third contract. We'll make that green guy, right? And this is the bank.
01:31:18.550 - 01:31:19.300, Speaker A: Okay.
01:31:19.750 - 01:31:34.950, Speaker B: And so when we see the transaction here, there's the message sender. So message sender looks like a child.
01:31:35.020 - 01:31:36.040, Speaker A: Who wrote it.
01:31:37.790 - 01:31:39.210, Speaker B: Is the orange guy.
01:31:39.280 - 01:31:39.514, Speaker A: Right?
01:31:39.552 - 01:31:49.830, Speaker B: The message sender is the orange guy, but the dot origin is the blue.
01:31:49.990 - 01:31:50.794, Speaker A: Okay.
01:31:50.992 - 01:32:15.540, Speaker B: Super, super childish. We had to draw it in crayons to make it obvious. But that should make sense. When an EOA is talking directly to the contract, it's both the message sender and the TX origin. But when an EOA talks to a middleware contract, the message sender in terms of what the bank sees is that middleware contract. Hopefully that explains it all. Hopefully that shows it off.
01:32:15.540 - 01:32:51.150, Speaker B: We can hint at something here. Carlos, you brought this up when we were playing around with the wolf game. There was a specific piece of that contract that wanted to make sure that only externally owned accounts could access it. So if you wanted to make some function like this deposit, and you wanted to say only externally owned accounts can do it, if you try to have a middleware contract attacking it, we don't want to allow that. What you can do is require that the TX Origin equals equals the message sender.
01:32:51.570 - 01:32:52.366, Speaker A: Right.
01:32:52.548 - 01:33:14.950, Speaker B: And we say only EOAs or something like that, right. This line of code basically breaks if you try to hit it from a middleware contract. This says that the only person that can talk to this function has to be an externally owned account and that TX Origin has to be equal to your message sender. Maybe the other way around. What's that?
01:33:15.020 - 01:33:19.226, Speaker C: I was going to say that maybe we can try. You can deploy this and try.
01:33:19.408 - 01:33:42.330, Speaker B: Yeah, let's try. That's the best way to find out. Let's just deploy it and see. So now we can totally deposit some funds into this contract. Let's close up ETH build. We can deposit some funds in here as our externally owned account, right? This guy should have no problem talking to the bank. He wants to deposit 0.5,
01:33:42.330 - 01:34:01.282, Speaker B: he sends, there we go, money goes in, right? But if we put some funds into this contract and then we try to do the same deposit only EOAS, right. It doesn't let us go through our contract and deposit into our bank.
01:34:01.346 - 01:34:01.814, Speaker A: Right.
01:34:01.932 - 01:34:14.502, Speaker B: And when we built that smart contract game, I wanted only contracts talking to it, right? So in this case I required that the Txorigen does not equal the message sender. And this is only contracts.
01:34:14.566 - 01:34:14.842, Speaker A: Right.
01:34:14.896 - 01:34:29.262, Speaker B: Another weird one you could do if you wanted one smart contract. To never accept a transaction from an EOA, you have to use some middleware contract. You could set up the require like that. Super weird, though. Let's pull that out of there. Set it up. Okay.
01:34:29.262 - 01:35:00.514, Speaker B: I think we've gone through a lot of stuff here. We showed you at home how you can pull up scaffold ETH, get it installed immediately, start writing some solidity, and start tinkering with it and learn. We've talked about how the wallets work, how you use a burner wallet at first, but you can connect in another wallet. We've talked about a bunch of syntax and how to get started with primitives and data types and globals, and just like going through this, oh, we left reentrancy.
01:35:00.642 - 01:35:01.318, Speaker A: Right.
01:35:01.484 - 01:35:44.194, Speaker B: We've got a bug right here. Maybe we should end with this, because it really does kind of highlight all of the stuff that happens with all the weird things and how to get in here. And by the way, when you go to solidity by example, after you learn all of these different things, which if you're a programmer, you'll figure it out quick, except for maybe delegate call, that's some weird shit. But once you get that stuff, you'll get it figured out pretty quickly. There's a lot of good applications, but down here all the way at the bottom are hacks. And if you really want to understand how solidity works, once you get the basics of solidity, you should start looking at the attacks and figure out how this works. Reentrancy is one that we'll look at here, but learn the attacks.
01:35:44.194 - 01:36:01.030, Speaker B: And just to double down on that, there's something called the Ethernot. Yes. What did I do? Ethernot challenge. Here we go. Ethernot open Zeppelin. Here we go. So once you've kind of got a feel for that, you're able to learn how to tinker with solidity.
01:36:01.030 - 01:36:26.174, Speaker B: You want to start really testing your knowledge. The Ethernot is a great place to go, and it'll take you through kind of a lot of these different challenges. Okay, here we go. Let's talk about reentrancy to close it out. It's going to get really weird here, but we have to talk about it. So this withdraw function, what's happening here? Let's go ahead and just talk to the bank.
01:36:26.222 - 01:36:26.434, Speaker A: Right.
01:36:26.472 - 01:36:50.646, Speaker B: We don't even need the middleware contract here. Well, we would use the middleware contract to actually attack it, I guess. But let's just do a withdraw as us. So we go to the bank and we deposit some funds. So we are green guy, and Green guy wants to deposit 0.1. And he goes here and deposits and it's fine. And we can check Green guy's balance.
01:36:50.646 - 01:36:54.110, Speaker B: It's 0.6. And then Green guy can call this withdraw function.
01:36:54.180 - 01:36:54.510, Speaker A: Right.
01:36:54.580 - 01:36:59.486, Speaker B: And when we call withdraw, it's just going to transfer our balance to us.
01:36:59.588 - 01:36:59.998, Speaker A: Right.
01:37:00.084 - 01:37:37.878, Speaker B: No big deal. Basically, it works out of the box. This works fine. Now we've got an attack vector here, and it is kind of interesting. What happens here is when we call this withdraw, it's actually making an external call and it's actually going to send the funds. But let's say we have a middleware contract just like we have here, and it does something special when it receives funds. This is how we would attack this bank is what we would do is we would call withdraw.
01:37:37.878 - 01:38:10.214, Speaker B: And when it withdraws to our middleware contract, we would do something else here. We would actually call withdraw again. And we could get into this loop where we're looping, and we call withdraw. It goes to our attacker contract, and then our attacker contract calls withdraw again. And it loops over this, basically sending our balance to us over and over and over again. And it never gets to this line until it runs out of gas. So let's highlight that a little bit better.
01:38:10.214 - 01:38:49.262, Speaker B: Let's actually set up our attacker contract to do this. But it's really funny. The solution to this is basically to have a UN 256 temp here and we set that to our balance and then we zero out our balance and then we go ahead and send temp here. So this fixes reentrancy, this reentrancy bug. Millions of dollars have been stolen out of smart contracts because of this reentercy bug. And this is the fix. Basically, you do your state updates, you do any internal state updates.
01:38:49.262 - 01:39:15.580, Speaker B: First you make sure that balance is zero and then you do all your external stuff. You make sure that if you call this and it's going to some external thing, they can't reenter and still have a balance. We see we've zeroed out their balance before they get there. Okay, so let's go ahead and let's leave it attackable. And let's attack it. Right, what do we got? We got a little bit of time. We got a little bit of time here.
01:39:15.580 - 01:39:40.520, Speaker B: Let's attack it. Okay, so let's make sure all of this compiles and everything is good here first. Awesome. I like your deposit, making it payable. It'll just be easier if we take this out and do message value here. Of course, Carlos was right. I should have listened to him in the first place.
01:39:40.520 - 01:39:56.598, Speaker B: Okay, and let's make sure that that all works real quick, that we can basically do a deploy by just calling one function or do a deposit by just calling the one function here. So if we deposit 0.1 ETH, this should go all the way to the second contract.
01:39:56.774 - 01:39:57.162, Speaker A: Yes.
01:39:57.216 - 01:39:58.810, Speaker B: So it goes all the way in.
01:39:58.880 - 01:39:59.306, Speaker A: Right.
01:39:59.408 - 01:40:36.774, Speaker B: So by depositing into your contract, it immediately takes all of that money and deposits it into the bank. So you shouldn't ever have money here. Even if I yolo some funds here, what happens? Okay, that's not going to, yeah, funds are just going to go in because it's not doing anything here. Right. We could technically do this and then it would do the deposit, but we're going to do something special there. So let's not even mess with that. Okay, so we have our attacker contract here, we have the bank here, and now we have to assume that the bank has some extra funds in it.
01:40:36.812 - 01:40:37.062, Speaker A: Right.
01:40:37.116 - 01:40:59.840, Speaker B: There's going to be lots of people depositing. Let's just have some poor second person here who's going to lock their money up in this bank and it's a bad idea. This bank is going to be. So we got purple guy, purple guy is not going to be happy about things. Let's give purple guy some funds. Okay, well, purple guy's happy. He just got $10,000.
01:40:59.840 - 01:41:09.934, Speaker B: Okay, so how does this attack work? Basically we're going to deposit some funds in and there's going to be more funds in the bank and we're going to want to withdraw those funds.
01:41:09.982 - 01:41:10.674, Speaker A: Right.
01:41:10.872 - 01:41:17.160, Speaker B: So what's going to happen is we're going to have some function called do the attack.
01:41:20.090 - 01:41:20.840, Speaker A: Okay.
01:41:21.370 - 01:41:31.546, Speaker B: And what it's going to do is it's going to call the withdraw function on the bank contract here.
01:41:31.728 - 01:41:32.122, Speaker A: Okay.
01:41:32.176 - 01:41:46.634, Speaker B: So we know we need to do a withdraw. And let's see. So this will be bankcontract. We're going to have to check gas and stuff. It's been a while since I actually wrote this in solidity. It's a lot easier to explain it. Like, yeah, you have a middle contract.
01:41:46.634 - 01:42:11.726, Speaker B: It attacks it to actually write it up. This is going to be a little bit more time consuming, but let's figure it out. So we want to call withdraw on. Let's just do that first. Let's just make sure this works. Let's do this one step at a time and make sure the code all works. Okay.
01:42:11.726 - 01:42:31.378, Speaker B: So now we should have our starting contract. Everything is empty. Let's put in 0.1. We do the deposit, $120, show up there, my balance is 0.1. And do the attack isn't going to attack anything right now. It's just going to withdraw our funds back.
01:42:31.464 - 01:42:31.906, Speaker A: Right.
01:42:32.008 - 01:42:52.438, Speaker B: And then they land back in the contract for some reason, but whatever. Oh, there's no withdraw function. So actually they're locked there, which isn't great. Maybe let's build that real quick. Nah, don't worry about it. We're in a hurry here. We could even do something like pay the message sender.
01:42:52.438 - 01:43:17.794, Speaker B: We do what? Payable message sender, transfer address this balance, whatever. So whenever you do the attack, it withdraws and then sends the balance. Let's see if this works. I want the money to go all the way back to us just to see, you know what, it looks better when it ends in the contract. This is what you would do. I'm like rambling here. This is what you would do.
01:43:17.794 - 01:43:29.654, Speaker B: But let's just make sure this works. 0.1. Go ahead and deposit that in. And then what I want to do is just do the attack and make sure the money comes all the way out and lands back here. And it does.
01:43:29.692 - 01:43:29.846, Speaker A: Okay.
01:43:29.868 - 01:43:53.598, Speaker B: So there's no money left in the contract. Actually let's leave that out for now. Okay, here we go. We want to call withdraw. And when we call withdraw on the bank, the bank is going to immediately send us our balance. And what happens when they send us our balance? It's going to call this receive function.
01:43:53.764 - 01:43:54.480, Speaker A: Right.
01:43:55.730 - 01:44:16.930, Speaker B: Interesting. Okay, so let's see here. What if we did just one more of these? Okay, so we'll keep some state variable called un 256 times. Let's just say attacked. And let's just say bool.
01:44:17.010 - 01:44:17.494, Speaker A: Here we go.
01:44:17.532 - 01:44:18.294, Speaker B: We're just going to do this.
01:44:18.332 - 01:44:18.594, Speaker C: Bool.
01:44:18.642 - 01:44:20.390, Speaker B: Attacked equals false.
01:44:21.210 - 01:44:22.774, Speaker A: And we're going to say if it.
01:44:22.812 - 01:44:50.338, Speaker B: Hasn'T attacked yet, go ahead and set attack to true and call withdraw one more time. Okay, so basically when we withdraw, we're just going to withdraw one more time also. So we should actually withdraw twice for the price of one. We should be able to pull some money out. Kind of, kind of weird. We can talk through this some more. Let's see if this works.
01:44:50.338 - 01:45:07.782, Speaker B: And then we can talk through it some more. Okay, cool. So now we have our attacker contract. We have our bank. What we need is some extra funds in our bank. So we're going to have attacker guy. We're going to have just this guy who's going to have a bad time here.
01:45:07.782 - 01:45:11.880, Speaker B: They're going to put in 0.5 E.
01:45:14.090 - 01:45:14.786, Speaker A: There we go.
01:45:14.828 - 01:45:34.266, Speaker B: And so we could check their balance. Basically they have 0.5 E in the contract and if they want, they could withdraw. Okay, so poor purple guy has invested in the bank and they think everything is safe. They looked at the code. It looks good, right? They're like, oh, this bank looks good. It does ascend.
01:45:34.266 - 01:45:40.660, Speaker B: It sets it to zero. Fine. I'm good. I'm invested. I'm in. I got value locked in here. Okay, so we come along.
01:45:40.660 - 01:45:45.380, Speaker B: What we're going to do is we're going to deposit 0.5.
01:45:47.510 - 01:45:48.258, Speaker A: And that's going.
01:45:48.264 - 01:46:21.710, Speaker B: To go all the way in. So now the contract has one whole ETH in it. It has our half and it has their half. Now, when we do the attack, it's going to call withdraw. And when we call withdraw, the bank is going to send us our half ETH. And then when our contract receives, the half ETH attack is going to be false. So it's going to get into here, it's going to set attack to true and it's going to call withdraw again back into the bank.
01:46:21.710 - 01:46:39.314, Speaker B: The bank is going to send us another 0.5 e and then it'll land here. It won't do anything, it'll come back here and set our balance to zero. And if this works, we're going to run away with purple guys. Half E. If this works, let's find out. Here we go.
01:46:39.314 - 01:47:26.334, Speaker B: Let's do the attack. What just happened? Let's see what? The bank is empty and our contract now has the whole ETH in it, right? And this guy over here, if he checks his balance, he still has 0.5. If he looks right, he says, hey, what's my balance? The bank will say, you still have 0.5. And he's like, okay, let's withdraw. There's no money left in the contract, right? So even though this guy thinks his balance still is 0.5, the bank is empty, right? Does that sort of show off what happens here? I think what you would do is you would want to drain the contract, right? You wouldn't want to just pull twice your amount out. You'd want to run this thing until you're out of gas.
01:47:26.334 - 01:48:02.480, Speaker B: So you do something like, if the contract still has a balance and I still have some gas left, I think there's like a gas left. You could ask if I still have gas left and the contract still has money in it, keep attacking and keep going through this loop until either we run out of gas or the contract runs out of money, and then you drop out of the loop. Hopefully that kind of explains it. It's a pretty complicated attack, but it's pretty straightforward. Any questions or insight here to add to this? Does that cover it?
01:48:04.290 - 01:48:32.280, Speaker C: I think so. I mean, it was great to show the demonstration. I just wanted to say one thing, and that when you write some solidity, some methods, just keep in mind that there are not only users or external own accounts, users that are interacting with your contract. So also other contracts can interact with your contract. So just like keeping that in mind when you are writing some solidity, because things like this can happen, right?
01:48:34.330 - 01:48:45.350, Speaker B: Awesome. I'm just going to go plus plus, and I'll say if attacked is less than three or something like that. Or four. Let's just loop on it a few more times.
01:48:45.440 - 01:48:45.742, Speaker A: Right.
01:48:45.796 - 01:49:15.670, Speaker B: Redeploy this and let's see it go again. What did I do wrong? So this time it'll just loop like three or four times. We'll put some extra money in the contract. So this time maybe we'll only deposit 0.1. Okay, so let's see. So again, to set it up, this guy needs to deposit some funds. What's he have left? Let's deposit a whole ETH.
01:49:15.670 - 01:49:21.462, Speaker B: Okay, and then to attack that, we're just going to deposit, like, zero one.
01:49:21.596 - 01:49:22.280, Speaker A: Right.
01:49:23.290 - 01:49:28.570, Speaker B: So we've deposited 0.1. Now, when we do the attack, it's going to pull out, like 0.4 or something.
01:49:28.640 - 01:49:28.922, Speaker A: Right.
01:49:28.976 - 01:49:33.210, Speaker B: We're going to end up with four. X the money. Yeah, 0.5.
01:49:33.280 - 01:49:33.610, Speaker A: Right.
01:49:33.680 - 01:49:47.630, Speaker B: So we pulled out a whole bunch more. We looped a bunch more times. But, yeah, I think that the trick here is just knowing that when you write your contract like this, this is bad. You want to do something like temp here.
01:49:47.700 - 01:49:48.146, Speaker A: Oh, yeah.
01:49:48.168 - 01:49:49.074, Speaker B: Let's try to attack it now.
01:49:49.112 - 01:49:49.458, Speaker A: Right.
01:49:49.544 - 01:50:14.096, Speaker B: Let's go back to fool attacked, not attacked. Tact equals true withdraw. Okay, there we go. Let's deploy the whole thing again. Now, it should fail, right? It's going to tell us that we don't have a balance or something like that, and the attack will fail. But it's worth trying just to show that it works or doesn't work. And then I think we can call it.
01:50:14.096 - 01:50:31.690, Speaker B: I think this was a good day of solidity tinkering and a good day of getting your scaffold ETH set up. Okay, let's see. We need to deposit one ETH. There we go. Then over here, we deposit 0.1. Okay, now when we do the attack.
01:50:32.540 - 01:50:34.008, Speaker A: Oh, wait, it worked.
01:50:34.174 - 01:50:44.860, Speaker B: Wait, what did it do? It didn't withdraw. It only withdrew the 0.1. Oh, it called withdraw again, and our balance is zero.
01:50:45.010 - 01:50:45.420, Speaker A: Right.
01:50:45.490 - 01:51:08.044, Speaker B: So we could set a require statement here to say your balance has to be greater than zero to enter here. But whatever, we're letting them withdraw zero, so it doesn't matter. The point here is that this person's balance is still in the bank, and someone wasn't able to steal it. Right. We did it. We learned more solidity. We helped you at home set up Scaffold ETH.
01:51:08.044 - 01:51:38.590, Speaker B: Next week is going to be all scaffold ETH. We're going to speed run ethereum. We're going to assume that you've got the syntax down, you know how to tinker with smart contracts, and we're going to dive into what you can actually build with smart contracts, and why this expensive, decentralized substrate is so powerful and what things you would deploy to this and what things you wouldn't deploy to it. Awesome stuff. Happy 10th day. Five of week two is done. Thank you all for being here.
01:51:38.590 - 01:51:41.948, Speaker B: Awesome. All right, see you guys.
01:51:42.114 - 01:51:43.720, Speaker C: See you. Bye.
