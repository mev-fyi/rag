00:00:01.050 - 00:01:21.734, Speaker A: Hi, I'm Austin Griffith, and today I'm going to do a tutorial on how to build a DAP using meta transactions. So, to state the problem, basically, when you get in to use any kind of decentralized application, there's usually a huge barrier to entry right at the point where you need to sign up for Metamask or get, you know, you basically see this seed phrase up front before get to see any of the app. And so this is going to kind of try to set up a situation for a user where they get to see the app, they get to use the app, they get to provide value within the app, and then finally, after that kind of narrative has built up behind some kind of throwaway account, we can start to educate them on seed phrases and blockchain and wallets and good practices. Basically, the trick is you kind of get them into the app first and then work them out as they get more acquainted with it. So we're just going to kind of build step by step adapt, and then we're going to figure out how to kind of put a metatransaction layer on top of it. This will be the second part of my workshop in Prague. I think it's on October 31 at like 03:30 p.m.
00:01:21.734 - 00:01:47.518, Speaker A: Or so. I'll have more information about that a little later. But the first thing, if you're not familiar with Clevis or daparatus, check out the build guild. Zero X zero and zero X one. There's links right at the top of the article. You're probably watching this video in. But what we're going to do is we're going to create with Clevis and dapperatus, a dap called nuns upon a time.
00:01:47.518 - 00:02:19.722, Speaker A: So it'll be something where people can kind of build a collaborative story. So the first step is to fire up a project with the project name called Once Upon a time. Normally with Clevis you can just do a clevis init. But what I like to do with this, especially for a workshop where I'm going to have a lot of people, is to have a docker container. So sometimes when their environment's not quite the same as mine, there will be problems with Clevis. But with Docker you can kind of just fire up the container and it works. So I fired up the container over here.
00:02:19.722 - 00:02:57.222, Speaker A: It takes like five to ten minutes to fire up. So you kind of start it and go somewhere else, and then you'll have a react app that comes up with it and all your clevis files there ready to go. So we can just kind of dive in and look at. There's our app. Basically when you start up Clevis, you just get a shell of an app and let's see how it looks. Yeah, so that's basically it. Maybe we could even inspect the console and check out.
00:02:57.222 - 00:03:26.762, Speaker A: Yeah, so really not a whole lot is going on yet. It's just kind of just a metamask component and an empty shell of a react app. And we can change that here in a little bit. So let's just follow along with this article. We connected to the local host. Okay, so the first step is we're going to create a contract called stories. And then we'll get in here and edit this contract.
00:03:26.762 - 00:03:56.710, Speaker A: And it's going to be super simple. So this stories contract is just going to have a write function that takes in a string and then that string will be emitted as an event. So it's a stateless contract that emits events. And it just says like this sender sent out this line. So it's really simple. It's just kind of like broadcasting events. So we'll save that and we'll compile it with Klebus.
00:03:56.710 - 00:04:22.858, Speaker A: Again, if you haven't used Clevis or dapperatus, you should probably jump follow this link into the intro. Looks like it compiled fine. All right, let's go ahead and deploy it and then we'll publish it into the app. Oh, did something wrong there. There we go. Publish it into the app. Okay, so now we can start editing.
00:04:22.858 - 00:04:46.262, Speaker A: There we go. So we've published our contract on Ganache and now we can start editing our app. So that would be in source app js. The first thing it has us do is just get that contract loader ready to go. So now our contract is being loaded in. We could go check out the console log and if we see in here. Yes.
00:04:46.262 - 00:05:14.154, Speaker A: So contracts are ready. There's the stories contract. There's a write function that takes in a string, exactly what you would expect. Then the next thing we'll bring in is the Transactions object. And that will give us that little loader in the bottom right. That shows the blocks as they load, but it also will show our transactions as we make them. And they kind of link to ether scan.
00:05:14.154 - 00:05:54.334, Speaker A: So you can see like a little progress bar and kind of be able to click in and find out more about it. Okay. And then it looks like we get a little UI going and I'm just going to kind of copy and paste this. Let's see, just right there, I think it'll be this whole thing. So basically we have this if contracts check, and that's just checking to see if the contracts have been loaded in. Yikes, what have I done? Making a mess. There we go.
00:05:54.334 - 00:06:43.450, Speaker A: Okay, so basically if the contracts are loaded, we want to display this UI and we should see the UI show up there. There we very simple nonce upon a time and then you can kind of write your story in here. So let's see, the input is tracked by this write text object in the state. And then there's a write button, but there's no. So if I click that, it's not going to do anything yet. So we need to wire that up and to do that we'll pass in this. So the transactions object, as you know, if you've used clevis and apparatus, it kind of abstracts away a lot of the heavy lifting of making a transaction on chain and just gives you this nice TX function that then calls back with the receipt when the transaction is finished.
00:06:43.450 - 00:07:27.322, Speaker A: So what we're going to do is we're going to talk to the stories contract and we're going to call the write function and we're going to pass in this write text that was part of our state. And when it finishes we're going to clear the write very simple UI here. Just getting started. And what this is alluding to is if we were to type something in and hit write, it's going to tell us we have insufficient funds. Okay, so let's go ahead and reject that again. If you've used Clepsep Redis, you're going to know that you need to set yourself up with some funds and you do that in the metamask component right there. And what you do is you put your address in there and mine's already in here, but I wanted to show you.
00:07:27.322 - 00:08:05.110, Speaker A: So it's in test clevis js right in the metamask section. But now if we run clevistest metamask, we will get some funds showing up right over here. There we go, one. Okay, so now we actually have some funds. We should be able to. Once upon a time there was a frog named Willie. Now let's see if we can write to the chain, our event confirm, and there goes the transaction.
00:08:05.110 - 00:08:19.914, Speaker A: And nothing happens. And nothing happens because we're not displaying anything yet because we're not tracking those events. And I think that's probably what we're going to hear about next. Got plenty of eth. We submit the transaction. Exactly. Yes.
00:08:19.914 - 00:08:52.050, Speaker A: So we're not displaying anything. So we need to set up an event parser. And that is just another component in Daparatus. And I'm going to copy and paste because it's provided for us here in the tutorial. Let's see, we want to copy and paste this in, right? Let's see. Maybe like right here, we'll put it right in our UI. And we're also setting hide to false.
00:08:52.050 - 00:09:10.714, Speaker A: This is kind of like for troubleshooting. It'll look gross, but it'll list off our events as they're fired. Eventually we'll set them to true. So basically our contract is stories. Our event name is write. And then anytime you get events, go ahead and push them into the state. But for now we're not hiding it.
00:09:10.714 - 00:09:32.766, Speaker A: So we should actually see those events listed. There we go. So there was that first event, there was a frog named Willie. The sender was me. The line was that and then the block numbers there. So we're getting events and they're parsing now, but I'm guessing our next step will be to clean those up. Yep.
00:09:32.766 - 00:10:00.746, Speaker A: Let's add some Ui. Okay, so instead of let's go ahead and. Let's go ahead and hide these. So if I say true, this piece should disappear. Cool. Okay. And then above our Ui, basically, once we know that contracts are good, what we want to do is just parse through all those events and create a nice little display for each line.
00:10:00.746 - 00:10:30.194, Speaker A: And then we'll put the lines in probably right below once upon a time. So it kind of fits with the UI. There we go. So once upon a time there was a frog named Willie, and we could see that there's my little icon there that matches this icon. So cool. Basically we're writing a little story on chain and it says, I think, bonus points if you can supply multiple accounts. And I think in my clevis I have two accounts.
00:10:30.194 - 00:10:55.278, Speaker A: Hopefully that's this second account. Let's go see. Yes, he has 0.1 e also. And he had a very special magical talent. Right? And confirm. Cool.
00:10:55.278 - 00:11:24.626, Speaker A: Okay, so we're writing our story on chain. There's multiple people, they're collaborating, but right now they're basically paying the gas, right? I think I say something like, sweet. Our dap build is complete. Let's shiple it. Okay. Then I say, not so fast, Gibroni. Let's see what this looks like in safari, right? So if I pull up safari and we put in localhost 3000, what are we going to see? Gross.
00:11:24.626 - 00:12:13.350, Speaker A: And that's the point here, if someone is on their phone and they're scrolling through their twitter, and you tweet out about your new dap, and they click in and they see this, they see this big gray nothing that says hard stop. You have to install metamask before you can do anything. This is basically like the worst ux we can provide, right? And we'll see. Lots of dapps are getting a lot better at this, and this is awesome. This is where onboarding is really going to shine, is when we do a better job of bringing people in from Twitter and everything on our phones. This experience right here needs to be way smoother, and a lot of people are figuring it out. So I just want to help out with whatever.
00:12:13.350 - 00:13:22.218, Speaker A: I can kind of give some code examples and figure out what we can do best, right? And I want dapperatus to be something that a developer can just drop in and use and kind of solve some of this stuff. So let's see what we could do. Basically, we talk about, yes, there's a hard stop with developers. The first thing we can do is basically integrate infura, right? Instead of counting on metamask to be our link to the blockchain, we can actually just go talk to Infura, which means we can at least do reads from the chain so the user can't participate, but they can at least see everything. And I think that's a great first step, let them at least see the content, and that's a pretty easy thing to integrate with Infiro. But dapperatus will take care of that for you. So what we can do is, in our code, we are going to bring in a new component from dapperatus called dapperatus, and it's going to replace the metamask component.
00:13:22.218 - 00:14:07.430, Speaker A: So what we'll do is we'll bring in this. So we're just going to replace metamask with daparatus. And dapperatus just does a little bit better job handling these edge cases than the metamask component that I've previously created. And let's see, we need to do one more thing, and we need to set up some kind of fallback web three provider. Basically, if it doesn't find an injected web three, it's going to fall back to something. So eventually you'll put in like an infuria endpoint with your API key. But in this case, we're just going to talk to our local chain on 8545, and if I hit save, what do we see? Oh, look at Safari.
00:14:07.430 - 00:14:29.742, Speaker A: Look at that. Okay, but something else has happened here. Look at this. We actually have an id, right? And so what that is, is it's creating for us, it's creating an ephemeral key pair in memory. So let's just do like a new private window and try that again. Localhost 3000. Boom.
00:14:29.742 - 00:15:05.422, Speaker A: Look at that. It generated us a new, look at, that's a cool blocky. It generated us a new account that can see everything, right? So immediately, right, when you join the app, not only do you get to see the content that's on chain and actually interact with the blockchain in terms of reading, it also creates an account for you, a key pair. And that key pair is just a normal ethereum account just like any other one. It can sign things and kind of operate, just doesn't have any eth. And that'll be the next trick that we focus on. But this thing is kind of a throwaway account, right? It's definitely not the most secure thing.
00:15:05.422 - 00:15:42.066, Speaker A: It's something that's generated in memory. It lives in the browser. It could be lost, it could be stolen. So the point is there's like a trade off you're making here, right? You're saying, okay, I'll have this kind of throwaway key pair first as I kind of get in and kind of learn things, but then as I provide value, maybe I'm more incentivized to sort of protect this thing and I can kind of sweep the account to a new one. So let's see what's next. There we go. Okay, so when we visit from Safari, we get to see it, okay, now this is when we start talking about metatransactions.
00:15:42.066 - 00:16:29.942, Speaker A: So a meta transaction is similar to a normal Ethereum transaction. It's got like the call data and destination contract, and then it is signed. But instead of that thing getting shipped to the Ethereum network, it's shipped to a relayer, and then that relayer submits it on chain and pays for the gas. So what happens is it's submitted to what's called like a bouncer proxy or a proxy contract or an identity contract. And that contract is a special contract where it cryptographically proves that this ephemeral key pair here signed that transaction. And it uses cryptography just like it's elliptic curve cryptography, same stuff that ethereum uses for everything else, or. I think so.
00:16:29.942 - 00:17:21.014, Speaker A: I'm not expert at any of that stuff. But basically it uses the EC recover function to prove that this key pair signed this call data. And then once it can prove that, then it can actually take that call data and put it into the call function in assembly and fire it off, just like a normal ethereum transaction. So basically the contract itself is making the real transaction, but you're using this meta transaction to sort of sign the intent to transact. Right? Okay, so let's get into that. Oh, we should probably talk about this too. So at first, when we kind of talk about how do we pay the gas for users, we think, well, we could just do a custodial account, right? Like we could control the private keys for them on our server, and then they could basically tell us when they want to interact with something.
00:17:21.014 - 00:18:04.466, Speaker A: But that ends up being a really bad solution. First of all, we're holding their private keys, and that just throws all the decentralization and trustlessness out the window. But also it's susceptible to a lot of Web 2.0 attacks. So this other solution with this metatransaction solution, where they have the keys, they hold the keys themselves, the keys are kind of throwaway, and we are making some decisions there about maybe it's only good enough for just a little bit and only good enough for certain situations, but at least it gets them in here and they get to see this story, right? That's the important part. Like we want them to be able to see this, and now we want them to be able to interact with it. What we'd like is if they could write this and hit write, it won't go on chain.
00:18:04.466 - 00:18:50.360, Speaker A: They don't have enough ethereum to pay the gas. But what if they could just sign the call data that would normally go on chain and send it somewhere else? We'll pay the gas to get that call data to the contract, and the contract could execute the call data on their behalf, and then also kind of cryptographically prove that they signed it. So then when the contract broadcasts it, it can say that this ephemeral account signed it. So yeah, let's get into that. So the trick is we're going to have to create ourselves proxy contract. Now in this demo, I'm just kind of creating it myself. There's probably going to be a lot of different things out in the ecosystem coming out in the next year, where maybe there's probably already a proxy contract that's exactly like this deployed somewhere that you can just interact with.
00:18:50.360 - 00:19:18.782, Speaker A: Also the relayers, we're going to build our own relayer here. I want to make a kind of an end to end example here in the code for anybody to use, and then demonstrate that at the workshop. But I'm sure that a relayer just like this exists somewhere else. Right. Okay, so here is the contract, and let's go ahead and get that into the code. So here's our code. We'll go to the proxy contract, we'll paste that in.
00:19:18.782 - 00:19:46.760, Speaker A: Okay, so there's a couple of functions. There's the Githash function that takes in the destination, the value, and the data value is going to be zero. I probably could have taken that out too. I'm trying to simplify this as much as possible. If you've seen my other metatransaction demos, there's a reward in here. I'm not even putting the reward in. I'm simplifying this and assuming that this centralized server is incentivized to just pay the gas here, and we don't need to worry about the crypto economics of the whole situation.
00:19:46.760 - 00:20:20.834, Speaker A: So there's Githash, it'll just give you a hash of all the information encoded. What is RLP encoded? And then there's the forward, this is actually the real function that does the forwarding. It gets the hash, it increments the nonce. So then we have replay protection, make sure the signer is correct, and then it executes the call. And the execute is this little piece here. I think I got it from gnosis or uport, or they got it from each other. I think maybe uport got it from gnosis and I got it from uport, something like that.
00:20:20.834 - 00:21:03.210, Speaker A: But it's a very simple, it's just doing a call like you would a normal transaction, but it's passing in that call data. So you sign this data that says, I want to call this function with these arguments on this destination contract, and then it executes it on chain. So if you were to go look at the destination contract, the message sender is actually going to be this contract. And that's why we need to send emit, we need to emit an event within the proxy that says this transaction happened. And then the front ends can say, oh, this was a proxied event. Right. And then we go back to the proxy and read their events.
00:21:03.210 - 00:21:37.126, Speaker A: So it takes a little bit more work on the front end to figure out who did what. And then here's the cryptography here. You've probably seen this quite a bit, but it's cutting up the signature into the RSV and then figuring out who actually signed it. Does an EC recover to figure out who actually signed that transaction? So this is the cryptographic magic here. All right, so that's basically the whole contract and that's ready to go and let's go ahead and compile it. Oh, and there's a disclaimer there. This is not safe for production.
00:21:37.126 - 00:21:54.990, Speaker A: There's no whitelisting system. Basically anybody can run anything on this contract. I don't even know all of the implications of that, to be honest. But basically anybody can run anything through this contract. So this contract can act on anyone's behalf, which probably isn't good. I mean, can they destroy it? I don't know. Whatever.
00:21:54.990 - 00:22:30.726, Speaker A: I'm not going to worry about that. This is just kind of a proof of concept for someone to run a local setup that goes end to end doing meta transactions on behalf of the user. Okay, so now we know that every time someone, whoa. Every time someone does a clevis test full, they're going to have a stories contract and a proxies contract ready to go. And we can see the proxy is all compiled and good to go. Okay, what's next? Okay, so now we need to build a relayer. And a relayer is just, a lot of shops right now are just doing like this nice centralized relayer.
00:22:30.726 - 00:23:25.422, Speaker A: And by nice I mean not nice. It's not a good idea to have a centralized relayer in a decentralized world like web three. Any point of centralization within web three is sort of frowned upon. But right now we're just kind of building a demo. This is like kind of the happy user story here where we just want to make it work first. But it should be mentioned that with rewards, with crypto economics, with the correct incentives in place, these metatransactions can go out to a peer to peer layer and the peer to peer layer can submit it on behalf and then be paid for doing so. So there definitely is a peer to peer relayer network in the works, but for demonstration and for building purposes, we're just going to have a centralized web server that catches our transaction and submits it for us.
00:23:25.422 - 00:24:07.260, Speaker A: So let's just go ahead and grab that code. It's just like a little exprs server that has what? Like a post, a TX post that takes in the transaction, the body and the signature. We do a recover to make sure that the account is correct there. And then if the account is correct, we go ahead and actually run a formal like Ethereum transaction. We get the hash and there it is. So contracts method forward. So we actually push the content of that transaction, that metatransaction, into the blockchain right there.
00:24:07.260 - 00:24:48.326, Speaker A: Okay, so let's go ahead and create this relayer js and paste this stuff in and save it. Cool. What else is there? So there's also a get transactions and we'll see this in the transaction stuff. But when you look down here at the bottom right, you can see the blocks load. And normally when you have an account that's paying and it makes a transaction, that transaction shows up down there in the bottom right. Well, for metatransactions, it'd be nice if dapperatus basically displayed it exactly the same. And that's what this is for.
00:24:48.326 - 00:25:23.710, Speaker A: Your web server can have a git where dapperatus can reach out to it and say, hey, are there any transactions for this user? And if there are, I want to display them. Even though they're just like meta transactions and they're from this ephemeral account, I still want to display them the same. The trick with dapperatus is like let's let them have this just standard way of building transactions. And then whether it's a normal transaction or a meta transaction, let's make them look and seem the same to the end user and to the developer. And we'll handle the magic on the back end. Okay, so let's see. I think we need to install some packages.
00:25:23.710 - 00:25:51.050, Speaker A: Yeah. Okay. And over here in your docker container you're going to need to install exprs and helmet and cores. That's just to have this relayer working correctly. And one other thing is this app is going to be listening on port nine nine. And that is inside the docker container. And if you're familiar with Docker, you have to expose ports.
00:25:51.050 - 00:26:29.918, Speaker A: So once this installs we're also going to have to edit the port stuff. So we're going to have to edit this run sh. So clubbus creates a run sh for you. That's like anytime. So this command right here is the exact same command we ran at the very beginning. And I ran it before I started the video because it takes so long, but basically it sets up your docker container and initializes your project and gets ganache up and running and create react app and all this. But what we're going to need to do is add a p nine nine, basically exposing this relayer port on the container.
00:26:29.918 - 00:27:08.246, Speaker A: So then when the web app goes to talk to localhost nine nine nine, it's ready to go. So I'm going to go ahead and save that. And also within the relayer it's looking at this deploy network. And the deploy network is just for triggering different things on different networks. Actually, it's probably not even important here, but I'm going to add it in just so we have it. So I'm going to do an echo nine nine. Normally it'd be like one for Testnet and like three, or one for main net and three for some of the other.
00:27:08.246 - 00:27:27.178, Speaker A: But for now we'll just echo nine nine nine to deploy network. Okay. So we can fire it up with node relayer and that's fine. It should come up, we should see that it works. But the problem is those ports, that port nine nine nine is not exposed. Yeah. So it's up and running and it's working, but we can't get to it.
00:27:27.178 - 00:27:46.162, Speaker A: If I go to localhost, we get nothing. Right. And that's because the port is not exposed. So I'm going to go ahead and exit out of the container. I'm assuming that's what we talked about here. Yeah, there's where we edit it. And so you just change your run to add this little exposed port there.
00:27:46.162 - 00:28:27.806, Speaker A: Right. And I can just do. Oh, so CD into nuns upon a time and I can just do a run now. And I think this should bring up our container. But with nine nine nine open and now that we have the container up, we'll do a clevis test full that's going to compile both of not only our stories and like our DAP contract, but also our proxy contract, it'll compile all that stuff, it'll deploy it out to ganache, it'll set up our metamask, it'll publish it to the create react app. And then once that is all done, we'll fire up our relayer. And then hopefully we'll just have straight up access to our relayer and our app and everything should be wired up fine.
00:28:27.806 - 00:28:44.580, Speaker A: And we'll be able to kind of move over to the front end and start working on that. Go. Plug is go. There it went. So it deployed the proxy there. Now it's doing the metamask stuff. Cool.
00:28:44.580 - 00:29:11.734, Speaker A: Okay, so the next step, I'm just going to kind of assume all this stuff is going to be working. We're going to move over to the app and we're going to figure out how to integrate this relayer network and let's go ahead and fire up our relayer, please. Okay. And now I bet this works. There we go. Hello, world. Okay, so our relayer, and if I hit reload a bunch, we can see that it's.
00:29:11.734 - 00:29:34.590, Speaker A: Yes. Okay, so we are working. Our relayer network is connected. Let's just leave it there. Okay, so let's go back. What do we need to do? How do we build this into Daparatus? So you've basically built the infrastructure out to run your meta transactions. You've got your proxy ready to go on chain.
00:29:34.590 - 00:30:12.782, Speaker A: How do we wire up the front end to talk to that stuff? So with Dapperatus, there is this meta TX object that we create, and I'll put that right up here. It's kind of with this default provider, we kind of keep it up top here. So you may have a relayer that lives out behind some subdomain or just kind of some other DNS. Right now we're just going to do localhost. Nine nine nine. Also you may use infura for your RPC endpoint. Again, we're just going to use localhost and then it just needs to know where your proxy contract is.
00:30:12.782 - 00:30:49.420, Speaker A: So we're deploying ours along with this project. But a lot of times I'll just have an address in here and I'll have a pre built bouncer proxy out live somewhere on the main net or whatever. Okay, but in this case, since we're going to try to do an encapsulated end to end demo, we're just going to load it from the current project. That's where it's going to get the address. But basically this is just a contract address right here. Okay, so what else? Oh, and we need to add in meta TX to our, what element is that? To our dapperatus element. Okay, so in dapperatus we need to.
00:30:49.420 - 00:31:09.522, Speaker A: Where do I put it? In there? Right after the config. Oh, come back here. So right after the config, I'm going to create, I think it's meta TX object and pass in meta TX. And we go ahead and hit save there. Let's see. Yes, that looks good. Okay, that looks good.
00:31:09.522 - 00:31:29.990, Speaker A: Oh, and we need to create a meta contract. I should change that. That's not right because I can see a capitalize right there. But basically we say metacontract equals our proxy contract. And we do that when the contracts are loaded again, this source code will all be available. You can just go check it out. Also, it's kind of like copy and pastable.
00:31:29.990 - 00:31:53.802, Speaker A: But what this is doing is we're putting a hook right here is the on ready of the contract loader. So once dapperatus loads up the contracts, it will trigger this event. And so we can say our meta contract is. I think it's contracts proxy. I think. Let's go look at this one more time to make sure I got that right. Contracts proxy metacontract.
00:31:53.802 - 00:32:15.186, Speaker A: Okay, I think that's right. So we're just going to keep a state variable called metacontract, and then we're going to need to pass all that stuff into the transactions. So the transactions component is the guy that really handles all of this stuff. And that's right here. And I think we can just kind of paste this stuff in. So there we go. So our meta account would be the ephemeral account that got generated.
00:32:15.186 - 00:32:55.860, Speaker A: The meta contract would be our proxy. The meta TX is just kind of the configuration. We're also going to throw in the balance here. So this is a little trick that even though you have injected web three, if this user comes in and tries to interact with the app and doesn't have any eth, even though it's not an ephemeral account, we're still going to want to do a meta transaction there, right? Like, if someone comes in with a perfectly good metamask account, but doesn't have the ability to pay for the gas, let's go ahead and pay the gas for them. Right? It's still something worth it to us to pay the gas. Cool. Okay, so let's see.
00:32:55.860 - 00:33:26.334, Speaker A: We should have everything in. Oh, and then there's this metatx parts. This is different for kind of every dapp, so it's kind of exposed to the Dap developer. But these are the pieces of that hash. So if we go look at the proxy contract, you're going to have this git hash piece, this here. And that's the same thing that we have here, just all the parts of that hash, the meta TX parts. Right.
00:33:26.334 - 00:33:52.386, Speaker A: So now I think we're about hooked up. Okay. At this point. Okay, so let's try once upon a time, it was a small village. Okay. And we can write that, and that should be just a normal transaction. Uhoh, we're throwing an exception.
00:33:52.386 - 00:34:22.920, Speaker A: I bet I did something wrong. Let's make sure I am attached to the right network and everything. I wonder what I did wrong. Let's see. I feel like I may have forgotten a step here. Well, let's cancel any of these and let's make sure we're on the right network. And let's go back to using this user.
00:34:22.920 - 00:34:42.624, Speaker A: There was a small village. Let's see if this writes. No rejection. No rejection. Okay, so we're throwing. That is not good. I wonder what's going on here.
00:34:42.624 - 00:35:15.100, Speaker A: So we have, I am missing something here. Let's go back let's see here. Transactions, metatransactions. Our relayer is up. We're talking to the new network. Something is not quite right here. Maybe let's jump away from this network and then jump back to localhost.
00:35:15.100 - 00:35:59.230, Speaker A: There's nothing that's even going to reject here. So I don't know what I'm doing. And it published. Let's see if it works over on this guy. Let's just try like the ephemeral account, right? Inspect element and go ahead and give me the console. There was a small village. Okay, so this is like the ephemeral account.
00:35:59.230 - 00:36:40.220, Speaker A: Okay, so something is wrong. I think I must have missed a step in building a piece of this because it looks like the nonce isn't right. Let's just walk through the steps again and make sure we have everything correct. Let's see here. So we have our proxy. We have our relayer. The relayer is out here.
00:36:40.220 - 00:37:05.266, Speaker A: It's loading the Transactions. We have port 99 exposed. Let's just do a clevis test full here, I think. I'm almost sure I missed something in the front end somewhere. So we put that in apparatus. We've got our meta contract. Maybe that's not supposed to be.
00:37:05.266 - 00:37:38.680, Speaker A: Let's go look at our code. So the meta contract that gets passed into the transactions object is there. And that is set up contracts proxy. That's what we do there. And then in transactions we bring in metatx equals metatx. And we've got meta TX equals meta TX. There.
00:37:38.680 - 00:38:00.246, Speaker A: Boy, this seems. And then we fire up our relayer. And that worked. It's at. .2 it's on the right. Networking.
00:38:00.246 - 00:38:25.690, Speaker A: Okay, it's working now I think I just need to. Sometimes you need to do a clevis test full and redeploy everything. Okay. There was a small village. Okay, let's see if this is going to work. Now, I'm not exactly sure what I was doing wrong there, but a redeployment brought us all back. Okay, so that guy contributed.
00:38:25.690 - 00:38:49.362, Speaker A: Now let's do this, dude. But it had dark side. Okay, so it's working. All right. Now here's the big. So you can see the transactions going in there. What if we want to use.
00:38:49.362 - 00:39:14.506, Speaker A: Let's just go ahead and reload here. What if we want to use this ephemeral account? Right? There was an evil goat that lurked at night. Okay, here we go. Right. Oh, my gosh. It worked. Okay, so we do have an issue though.
00:39:14.506 - 00:39:38.002, Speaker A: So this little. It's kind of confusing. Between, because these two icons look very similar, but they are not. He was very hungry. Actually, let's not even send that from this account. Let's send that from like a new incognito window on localhost. So we should see a new private key.
00:39:38.002 - 00:40:11.638, Speaker A: Oh, look at that. That's a cool one. He was very hungry and wanted to eat toes, right? Okay, so see what's happening here. Basically we have this weird green one. It's not this one, but this weird green one, this weird green icon. And that icon is actually the proxy account. So what's going on is basically the message sender that the events are seeing is the proxy contract, not these ephemeral accounts.
00:40:11.638 - 00:40:48.050, Speaker A: And this is something that I mentioned earlier, that basically the front end needs to do a better job of parsing this. So the front end needs to do one extra step, not just read its own events, but detect that there's this proxy that's coming through and go to that proxy and parse the proxy's events and then kind of line these events up and then figure out who really posted it. So I think that we will do that now that things are working. Okay. Yes, there's a problem. The message stories is the proxy contract. What we need to do is parse the forwarded events, right? So the proxy throws events.
00:40:48.050 - 00:41:30.274, Speaker A: If we look at the proxy, there's this emit forwarded, and I've kind of talked about that earlier, but basically every time that a transaction comes through the proxy and is executed, it throws some events too. So we need to parse those events also. And we can do that with a meta event loader, just an events component, just like we already have used in dapperatus. We'll bring in another event and we'll probably put it right here. Oh, wait, we probably want it. So we have this meta events loader that goes and talks to the meta contract, and it looks for the forwarded. So we just need to put the event loader probably right there.
00:41:30.274 - 00:42:08.690, Speaker A: Okay, so now we're going to be parsing the events of the proxy along with the events of the story. Yes, we got that. Okay, now there's a bunch of code, a wall of code right here, and we'll unpack it here. But what this code is doing is that process of looking through the events. And I think what we do is replace this code here. No, that was not what we wanted to do. What is this code? This code happens.
00:42:08.690 - 00:42:45.256, Speaker A: Oh, right in here, I think. Yeah, there we go. Okay, so for each event that happens as a story like each line of the story, we're going to then check to see if that event sender is equal to our proxy contract. That means if it comes in and it's one of these two, it just knows it's fine. But if it's this guy here, we know that it's our proxy contract. So we need to do something a little different. And what that is is we parse through each event and come up with whether or not we know the sender.
00:42:45.256 - 00:43:08.260, Speaker A: And if we know the sender, then we add this extra blocky right here that will just put a new blocky kind of over the top of this one that represents the ephemeral account. And I think what we'll do is put that in right here. Let's see how we did there. There we go. Okay, cool. So now we can see actually who sent us. Right? Okay, so here's the brown dude.
00:43:08.260 - 00:43:37.452, Speaker A: He would sneak into your room at night and nibble, nibble, nibble. Right? And hopefully we see. There we go. So there's the brown dude through the proxy sent this line. Right. So there we go. That's basically like someone can come in to the app.
00:43:37.452 - 00:44:08.264, Speaker A: Let's see if we're about done. Someone can come into the app and fire off events and we can let them kind of get this kind of narrative going behind their account. So then this is kind of where we can start talking about onboarding and talking about wallets and talking about best practices and education. Right. We want them to first dive into the app. We want them to see, well, once upon a time, these people are writing this story about this evil goatoop. I want to get in on that, too.
00:44:08.264 - 00:44:29.852, Speaker A: Right. And then once they've kind of provided value here and they've kind of made friends or maybe earned tokens from writing this story. Right. Something is going to happen where this ephemeral throwaway account is sort of important to them now. Right. It wasn't important to them up front. The ephemeral account wasn't important to them up front.
00:44:29.852 - 00:44:48.164, Speaker A: Right. At first, if we would have just given them the seed phrase and thrown them at them before they see anything, it's going to turn them off. It's going to be a huge onboarding. But let's show them the app first. Let's show them the people interacting with this story. Let's get them in and let them interact also. Right.
00:44:48.164 - 00:45:04.170, Speaker A: We'll pay for the gas. We'll pay the onboarding a little bit there. Right. Let's let them write the story, too. And then once they've contributed. Once this ephemeral account becomes valuable to them, then they're much easier to educate on. Okay, this ephemeral account is not a good idea.
00:45:04.170 - 00:45:47.320, Speaker A: Let's sweep your tokens. Let's make a final event on that, using that account toward a new protected account that says, I swept here, this is my new account. And then the front end can kind of parse both of those and say, this was their ephemeral account. Now, this is their good account. So everything that they did with their ephemeral account, we can just consider this new account, and the front end can do kind of this trick here where it kind of shows this person, although it's interacting through a proxy, is this person. And you could say the same thing with the identity. Like, this identity is also this ephemeral identity, and we can kind of connect them right at the front end when we display it.
00:45:47.320 - 00:46:52.316, Speaker A: And it just makes it a lot easier to teach someone about these blockchain pieces after it's protecting something not right up front. And then kind of as we've built this narrative, maybe we've made some friends here. Same thing that's happening with metaconnect. We see that we've made these friends with this ephemeral account. So we already have made a perfectly good transition to, like, an m of n social recovery type thing, right? So let's say we deploy an identity contract, and then we can just say, okay, this guy, this guy and this guy, they're my buddies. If I have a problem or I lose my key, let me set up social recovery with them, which is a huge issue right now with people losing keys, kind of with my crypto and metamask, they have to have these really scary warnings for good reasons, because people are losing their keys. We need to do a better job as DAP developers to kind of get people into this space and get them understanding what it means to lose a private key and get some imovin social recovery and stuff like that.
00:46:52.316 - 00:47:33.204, Speaker A: Set up for the user and get them to the point where they're incentivized to be educated. And then the stuff like mycrypto and metamask doesn't need to be as scary, because it's actually a really awesome thing to have that in your browser, to have that chrome extension ready to go. Right. It's really cool stuff. So then, what are our other final thoughts and discussion? So, one thing is civil resistance. It's sort of like, as soon as I sell someone on the idea of, oh, yeah, you can use this cool cryptography trick to pay for the gas for your users. But you need to think about civil resistance up front, and it's going to be different for every single dap.
00:47:33.204 - 00:48:02.576, Speaker A: So for my music service, I made this silly example app called Ether Jam Jam, where you submit songs and then people can like your songs. If you have some kind of social login system already, that's perfect, right? That's perfect. Civil resistance. I can just say, okay, log in with Spotify. And if you have a valid Spotify token, I can just take that and say, okay, this person has a valid Spotify token. I'm going to pay for their, like, that's good enough. They're not attacking and maybe they still could and stuff like that.
00:48:02.576 - 00:48:24.984, Speaker A: We're going to have to be smart about this. But generally you just need, oh, that was the other piece. I'm going to have to patch it together. You just need some kind of civil resistance. Okay, and then what is the last piece? Replay attack. So this is something that I'll probably talk about more in my workshop. And let me show that right now.
00:48:24.984 - 00:49:15.704, Speaker A: If you're going to Devcon, find me in Prague. October in the colloquial room. I don't know, I'm bad at pronouncing things, but basically 03:30 p.m. We will be running through clevis and apparatus, and we're going to be building out a metatransaction set up just like this. So any questions you have, bring your machine and let's hack on metatransactions. But finally, kind of one thing that we'll discuss there is how we have that nonce in there for replay protection. We've kind of figured out some really neat things we can do by actually allowing replay with like token subscriptions and stuff like that, where this metatransaction that you push to this relayer network can actually be stored on the relayer network and the relayer can resubmit it as it becomes valid again.
00:49:15.704 - 00:49:39.088, Speaker A: And we can use a timestamp to determine when it becomes valid again. So then you can have like a subscription system that's like, set it and forget it. But we'll talk about that later. Thanks for keeping up with metatransactions. Let's build a better user experience. Let's get the user into the app first. Let's let them use it and then kind of educate them out on crypto as they're incentivized to do so.
00:49:39.088 - 00:49:43.390, Speaker A: Thank you. Hit me up on Twitter if you have any questions. Austin, Griffith. Let's build.
