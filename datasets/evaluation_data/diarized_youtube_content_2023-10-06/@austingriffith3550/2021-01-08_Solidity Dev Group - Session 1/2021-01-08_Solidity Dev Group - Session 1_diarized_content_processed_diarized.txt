00:00:00.170 - 00:00:11.690, Speaker A: I'm gonna. There we go. Recording. All right. Awesome. So this is what, what are we calling ourselves? Crypto testers dev group. It's a solidity study group and we're gonna, this is our first episode and we're gonna set up our local environments.
00:00:11.690 - 00:00:12.880, Speaker A: Is that the plan?
00:00:14.130 - 00:00:15.070, Speaker B: Indeed.
00:00:15.490 - 00:00:35.730, Speaker A: Alright, so let me share my screen. So it's gonna start with Scaffold ETH. There's, there's, there's a lot of tools. If you want to do like the most basic tool, like go grab ethers and write a script that creates a wallet, checks the balance. If there's a balance, you split it between two people and transfer some. That's like lowest level. Use ethers to write a quick script.
00:00:35.730 - 00:01:10.994, Speaker A: Next level up would be pull down hard hat and go through their tutorial and learn how to write a contract and test it. Scaffold ETH is going to do all of that stuff for us, kind of packaged in. It's going to have an example smart contract for you and an example app and it'll inject that smart contract in and kind of auto adapt. So this is kind of like a lot more than you need rather than starting from the very basics. But this is going to get you everything you need to get started. And it should be pretty simple to do, like make one small change in solidity, test your assumptions and see how that changes in the front end. And that'll make more sense once I get this going.
00:01:10.994 - 00:01:32.346, Speaker A: Let me clone this down. So I'm just doing a git clone of your next dap. I think you guys have probably already done this too. And please follow along if you're so inclined. And then we'll do a yarn install which I told you guys to do before the call. But here I am doing it. Let's see.
00:01:32.346 - 00:01:49.680, Speaker A: And then we'll get into your next dap. And so we're going to do eventually. Let's see. Let's bring up the code browser. So I'm going to bring up Adam, but you could use vs code two and a yarn. Whoa. Something I told you.
00:01:49.680 - 00:02:00.740, Speaker A: Oh no. I need to get into your next app and do a yarn install. I needed to get into the folder. I was doing it wrong. There we go. That's going to take a second. Okay, let's look at the file structure real quick in particular.
00:02:00.740 - 00:02:25.060, Speaker A: There we go. Okay, so ignore the Docker folder. That's for the graph. We'll get to that eventually. Know that there's a lot of stuff in here for you once you get to it. And you can do a full level production app with this setup, but it's also just like a nice little starting point. It has an infuria key ready for you to go.
00:02:25.060 - 00:02:55.088, Speaker A: A lot of things that you would have to do as a developer. It's kind of taken care of for you, but we're going to get into hard hat and contracts and your contracts. So this is kind of our back end, right. If we think of ourselves as app developers, Ethereum is going to be our back end. It's going to be our very expensive database that's slow and clunky, but has these really neat trust assumptions, has censorship resistance, has a lot of neat things to it. And then our front end is the react app, source app, JSX. So these are kind of your two files, your front end and your back end.
00:02:55.088 - 00:03:17.224, Speaker A: And your front end will have. If I scroll down, there's this contract component. This is probably the most important piece of the front end. This contract component is going to take your deployed contract and give you a nice little form, kind of like Etherscan has. So as we add new things to our contract, that's going to show up over in our front end, and I'll show you that in a second. Okay, we are installed. There's our yarn start.
00:03:17.224 - 00:03:40.540, Speaker A: So this will take a second, but it's going to bring up a dev server, some cool art that's getting released today. Watch these ships sail. Oh, it's gorgeous. It's gorgeous. Okay, let's go to localhost 3000. All right, that's going to take a second to load up, but you'll do a yarn chain, and yarn chain brings up the hard hat node. So this is going to spin up a local blockchain that works just like Ethereum.
00:03:40.540 - 00:04:20.940, Speaker A: It's also going to give us a bunch of accounts. So these accounts are pre populated with a bunch of money, and it's going to give us feedback from our chain. And then the third thing we need to do is a yarn deploy. And this will compile our contract, it will deploy it to our local chain, and then it's going to take the artifacts from that deployment and it's going to inject it into our front end. So our Dev loop is going to be let's tweak some solidity, let's yarn deploy and let's poke around in the front end. Let's see how that works in the front end. And once you get that dev loop down, you can start really kind of like writing solidity and learning really quickly.
00:04:20.940 - 00:04:39.312, Speaker A: The other thing that I tell everybody to have up is solidity by example. Look at how clean this is. It's right here in the repo. So if you go to the repo, there's solidity by example and solidity, global units and variables. If we look at this, it's like the cleanest. So let's see. You want to learn about an array.
00:04:39.312 - 00:05:05.820, Speaker A: Here's an example of how to use an array, right? You want to learn about a mapping. Here's an example of how to use a mapping, and it kind of explains it all here. So a lot of the things that you want to learn are going to be right here in solidity by example. And you can get in here and say, okay, I want to learn how un eight works. And you can just kind of, like, copy and paste it into your contract, and then you'll be able to see it show up in your app. Okay, so it looks like our app is up. Looks like everything is running.
00:05:05.820 - 00:05:19.600, Speaker A: Looks like our contract is deploying. Let's do one more reload to see it go all the way through. Right. I'm going to do one more even yarn deploy. So here's our contract right now. So this is that contract component. We can see that this e seven.
00:05:19.600 - 00:05:46.296, Speaker A: There we go. Now it's nine f. So this is my loop. I'm editing my contract, I'm yarn deploying, and then it's showing up over here in the front end. Okay. Just to get the mental model right, talking about what is Ethereum and why is it so expensive if this contract. So, this starting contract is just a string, and you have a function that lets you update the string, and anyone can call this function.
00:05:46.296 - 00:06:06.700, Speaker A: So this is kind of like this weird kind of public wall that people can write on, right? I can say, hello, world. Now, this is going to fail because I don't have gas yet. That lets us talk about accounts. Look at the price of e twelve two. What are we doing? 265 gas. What are we doing? I started mentorship sessions. This was just $200.
00:06:06.700 - 00:06:41.864, Speaker A: Man. What is going on? Okay, here we go. So, Scaffold ETH will generate an account for you up in the top, right? If I open up an incognito window and I go to localhost 3000, look at this, it's going to be a different account, right? And so what you do is you copy that and you paste it into the faucet down in the bottom left, and it will give you some funds to start interacting. Now, I can say, hello, world, and I can pay the gas and there we go. The purpose updates. And thinking of this like Ethereum is the greatest massive multiplayer RPG that's ever been created. These are just characters in the game, right? These are just players in the game.
00:06:41.864 - 00:07:00.770, Speaker A: And they can all read from this contract. This contract is censorship resistant, accessible. You can ask any node on the network, what's the value of my purpose? And they'll be able to tell you half of the world could explode and you can still read. You guys have questions yet? Sounds like someone's jumping anytime. Let's go. Let's do it.
00:07:02.420 - 00:07:06.640, Speaker B: Set purpose is one of the functions of the contract that you've created?
00:07:07.060 - 00:07:08.050, Speaker A: Yes, sir.
00:07:08.500 - 00:07:09.200, Speaker B: Okay.
00:07:09.350 - 00:07:24.440, Speaker A: And set purpose basically just does. A purpose equals new purpose. This stuff is not as important. It's a console log and an emit of an event. And we'll talk about events in a second. But yes, there's this one storage variable, and then there's this function to update that storage variable.
00:07:25.100 - 00:07:39.500, Speaker B: Okay, I got a question as well. You mentioned you use infura endpoint, but then you mentioned you have this simulated local chain. So what is infura used for?
00:07:39.570 - 00:07:59.072, Speaker A: Why infura? Exactly. Watch this. So Scaffold ETH has a bunch of components that you're going to want to use out of the box. A good example of that is like an address input. Look what happens when I type Vitalik ETH. It does the resolution. Right? So ens resolution is one reason why we have a main net inferior connection right off the bat.
00:07:59.072 - 00:08:22.596, Speaker A: And so if we wanted to send Vitalik one dollars, we can't right now because we don't have any money. But yeah, let's go to the faucet with this account too. Oh, here's another way to hit the faucet. There's a wallet. So this wallet component is an example of something you get out of the box with scaffold ETH. It's just a wallet component with that two address with the blocky preview. If I want to send one dollars, it's already in USD, and you swap between ETH and USD.
00:08:22.596 - 00:08:53.032, Speaker A: Just things that make the UX nice are all kind of built in. So we just sent a dollar to this person. So then if this guy wants to send fifty cents to Vitalik, he would do it like, whoa, am I even going to have enough gas money? No, if I want to send fifty cents to Vitalik, I have to pay more than $0.50 in gas. Of course. Okay, let's send this guy to. Sorry, is the gas in our local chain as high as the gas price? I mean as in Ethereum.
00:08:53.032 - 00:09:12.280, Speaker A: Good question. Let's see. So we're doing a hello world. It was 24, 98 and then it's 69. I don't think it is. I think it's using, let's see, where would I see the gas price of this? It can't be because it only cost me like twenty cents to update that storage variable. I feel like that would be more expensive.
00:09:12.280 - 00:09:44.372, Speaker A: I think it's supposed to be using this 137, but that just doesn't seem, it seems like that would be more expensive. Right. So I'm going to say no, I'm going to say it's using like one guay or something locally. But as soon as you go to the main net, it'll start using this stuff. And if you go to any other network, you'll change your gas. So that is just a hook in your front end. There's a bunch of handy hooks that sort of, here's a gas price hook, right? It just tracks gas price in the front end, but it's probably not using that.
00:09:44.372 - 00:09:46.420, Speaker A: Yeah, it's using that in that transactor.
00:09:47.160 - 00:09:55.850, Speaker B: What is the second terminal that opened up? Is that some logging of all interaction with the smart contract or what is that?
00:09:57.900 - 00:10:16.528, Speaker A: Are you talking about the second browser window I opened up? No, the terminal behind, we've got the web server here. We've got the yarn chain here. This is the chain. This is our chain. And you'll see the console log happen when I send that. There we go. We get the console log right there.
00:10:16.528 - 00:10:42.840, Speaker A: So in our smart contract, we've got a console log, right? Console log, thanks to hard hat. So whenever you're writing your solidity and there's weird shit going on, you can't figure out what numbers or why these numbers are what they are, you can throw a console log in there and then you can go look at your biddler, your hard hat terminal, and find out, oh, that's what's going on there. Okay, go ahead.
00:10:42.990 - 00:10:48.360, Speaker B: Why are you looping and deploying new smart contract? Why are you doing that?
00:10:48.510 - 00:11:26.948, Speaker A: Because I changed something, right? If I go over here and say, let's have this contract start out as programming, I'm going to change a little bit of solidity and then I'm going to deploy that smart contract locally and then it's going to show up in the front end with that new value. See this we're watching for this new purpose to get deployed. So as you iterate on your solidity, your front end will adapt to that. And let me just lean into that a little bit more. Let's go grab a un eight and kind of play around with a UN. So if I bring in a Un eight and I'm going to call it counter, I'm going to set it equal to one. This is actually not going to change in the front end because I didn't make it public.
00:11:26.948 - 00:11:39.672, Speaker A: We're not going to see any change here. We'll see the contract address change, but we're not going to get any new interface. This is going to make sense in a second. Let's go back here. Let's set this to public. Now let's make sure we can. And remember, public blockchain, everyone can read everything.
00:11:39.672 - 00:12:01.212, Speaker A: So public and private is where about function access? So public counter. Now I go ahead and deploy that. Now we're going to see a counter show up in our front end. And that's the loop that I'm talking about. You change some solidity. So right now what we're going to do is we're going to test our assumptions about what the heck a un eight is. So it's a number, it's tracking it using eight bits.
00:12:01.212 - 00:12:32.632, Speaker A: But what does that really mean? Well, I want to show you guys underflow and that will sort of really kind of show this off. So if I make a decrement function and I make it public and I say counter equals counter minus one, and then I send that off to the compiler and get that deployed, we're going to see a new function show up over here in our front end. And this is the loop that I'm talking about. Okay, so now we're testing assumptions here. We're learning about this counter. We've subtracted one from it. It's a un eight.
00:12:32.632 - 00:13:06.496, Speaker A: So it's using eight bits to track a number. It's unsigned, so that last bit is just for the number. What's going to happen when I subtract one from zero underflow? It flows around, right? It rolls around so those bits were all zero. And then when we subtract front one from that, all those bits go set to high. So you have to kind of be thinking about what those bits are doing underneath, right. You kind of want to think of your smart contract as like this really intricate assembly machine that everyone has a copy of, right. And when we're calling set purpose, everyone has to update that copy.
00:13:06.496 - 00:13:32.350, Speaker A: So it's very expensive to make little changes to this thing, but it is still just like a little machine at the end. And when we subtract one from zero, we get underflow. And that, by the way, doesn't happen anymore in version eight. If you change this pragma to version eight, it has safe math basically built in. If that underflow happens, let's see. We'll have to get a new compiler. I don't want to mess with it.
00:13:32.350 - 00:13:45.010, Speaker A: Let's see. Can we do this? Let's see. Greater than or equal to. Let's do eight and nine. Does this even work like this? Let's find out. We're testing assumptions, right? That's what this is all about. This is probably going to break, but let me see what happens when I switch this up.
00:13:49.460 - 00:13:51.456, Speaker B: What exactly? Underflow.
00:13:51.648 - 00:14:15.252, Speaker A: So underflow. When we went from zero, we subtracted one from zero and it rolled all the way around to the largest possible number. It's like overflow, where if your number gets bigger and bigger, think of. We're tracking a number based on bits, right? We're using eight bits to track a number. One or zeros. Right. So it would be like one one and then zero, one and then one one.
00:14:15.252 - 00:14:24.270, Speaker A: Right. All until it's all ones. And then if you add one to all ones, it's going to go back to zero. It rolls over, basically. Does that make sense?
00:14:24.720 - 00:14:29.208, Speaker B: Yeah. And this has been solved in the latest version of solidity, right?
00:14:29.314 - 00:14:29.920, Speaker A: Exactly.
00:14:30.070 - 00:14:31.068, Speaker B: On Twitter.
00:14:31.244 - 00:15:08.952, Speaker A: That's what I wanted to prove here, but I haven't. Let's see. I need to get into my hard hat config and find my compiler version. I don't even know where that is, by the way, while you do, like, you just added one variable in the solidity contract, like in the back end, but it already shows in the react app. Is this because we already coded the display of the counter in the react app? Yeah, the counter was already there. Okay, I think that's Hayden coming in, Hadrian. Okay, let's messing.
00:15:08.952 - 00:15:30.996, Speaker A: I'm trying to do this new compiler version I probably shouldn't have done, actually. I'm just going to back out of that. We're going to stick with six, seven. Know that once you get up to eight, though, your safe map is going to be built in for you. And if we do this underflow, it's actually going to fail. So in new versions of solidity, this will fail. But I wanted to show you that you can create this underflow problem.
00:15:30.996 - 00:15:55.384, Speaker A: And you do need to be mindful of that. If someone has zero tokens and is somehow able to subtract one from their zero tokens, and then all of a sudden now they have all of the tokens. Right. They have 255 tokens. That's going to be very bad if this is real money or someone's actual token. So I just wanted to show you how you need to be kind of understanding of what's going on with those bits. So now let's just do this real quick.
00:15:55.384 - 00:16:13.570, Speaker A: Testing assumptions, trying things out. Let's turn that un eight into a UN 256. This is how numbers are usually tracked in solidity. You get 256 bits, which means you can make a very large number. And watch what happens when we underflow that. So it goes to zero, then it goes to a giant number. Right.
00:16:13.570 - 00:16:19.110, Speaker A: So you can kind of see how bits are. Kind of. Go ahead.
00:16:22.920 - 00:16:29.200, Speaker B: An underflow gives you the largest number and overflow gives you a zero. Or how does that work?
00:16:29.370 - 00:16:42.964, Speaker A: Yeah. Okay, let's go un eight. Public counter. Let's set it to 250. Right. And let's have our function actually add. I don't know why it's called deck, but it's adding.
00:16:42.964 - 00:16:57.132, Speaker A: Watch this. So a counter will start at 255. It only has eight bits to track that number. So once we get to 256, it's going to roll over the other way. So 2525-1234. Boom. Right? That's overflow.
00:16:57.132 - 00:17:15.856, Speaker A: And then it throws. It normally would throw in a new version. If you bring in safe math, it throws. If you're using solidity 8.0 or more, it throws. But if you're not, you'll get this actual underflow and it'll happen in your smart contracts. It's really not a huge concern.
00:17:15.856 - 00:17:32.700, Speaker A: This kind of thing will be watched out for you. I just wanted to show you guys both how we can test assumptions and also that there's these bits, like the bits underneath, and they're doing some stuff, and you kind of need to understand it as if it was like this assembly machine, like knowing that there is stuff going on under the hood.
00:17:33.200 - 00:17:45.164, Speaker B: In what scenario would you use a un eight? And like you say, in most normal cases, we use un 256. But, yeah. Why do we need.
00:17:45.362 - 00:18:13.636, Speaker A: Well, remember, you're paying gas for all the extra bits that you're using, right? So each time I send some money, if it's a 256, and I'm not a genius with this stuff, I feel like there are probably other people on the call that know more about this stuff than I do. But a un eight is technically going to be cheaper. I think in a lot of situations, if someone only needs to send in from eight bits of information versus 256 bits of information, you're going to have just more gas spent to do those interactions.
00:18:13.748 - 00:18:14.410, Speaker B: Okay.
00:18:14.780 - 00:18:35.272, Speaker A: It's about size, about optimization word. Yes, exactly. And it may be about like contract size, not exactly the interactions, but we'll get to that later. And really you can play around with that stuff. You can see over here when I make this call, when I say, hello, world, we're going to see the gas of that. You can see it right here. It used 36,000 gas.
00:18:35.272 - 00:18:46.096, Speaker A: Right. Let me see if I do. Hello. If we send more money, what's going to happen here? Is it going to be more than 36? Three, six. Six. Let's see. Yes, it is.
00:18:46.096 - 00:18:57.524, Speaker A: Right. A little bit more money. So a little bit more information coming in. A little bit more. Adding the s store that, doing the storage. We're storing a little bit more information, so it's going to cost us a little bit more gas. What's that, 35.
00:18:57.524 - 00:19:11.752, Speaker A: That was less, was it? Oh, because maybe our storage was already set. Yeah, that's not a very good example. Let's see. Okay, let's do it. Let's do one and then another one. They should be exactly the same. Okay.
00:19:11.752 - 00:19:36.448, Speaker A: 35587. Now if I add some more. 36971. Okay, so something interesting happened here. And this is because the first storage is way more expensive than an update. So the first storage, I think is like 20,000 gas, and the second storage is like 5000 gas or something like that. Anyways, we're really getting into the weeds here with technical stuff that you can play around with and kind of understand on the own.
00:19:36.448 - 00:20:02.804, Speaker A: My goal here is to get you guys confident with just like iterating and building an app and kind of figuring out how you can write solidity and see it show up in the front end. One thing that we can dive into, really what I do is just, I would say go through solidity by example and learn. Let's just go look at another data type. Look at this address. Right. I'm guessing everybody here is kind of like a power ethereum user already. So you understand private keys and public keys and running with dapps.
00:20:02.804 - 00:20:29.008, Speaker A: So I'm going to kind of skip over a lot of the mental model talk. But if we have this address and let's track an address called the owner and let's set it up so only the owner can set the purpose. So what you do is write a require statement. So require. And we're going to sue message sender and I'll talk about that in a little bit. Equals the owner. And we'll say not the owner if it's wrong.
00:20:29.008 - 00:20:43.924, Speaker A: Okay. And then this owner I'm going to have as my front end address. So I'm going to copy my front end address. I'm going to paste it right in here. Look at that. That is ugly. And so now only me should be able to, I should be the only one that can update this purpose.
00:20:43.924 - 00:21:07.010, Speaker A: And if I go deploy that, we should see that a new owner shows up. What did I do? Oh, got rid of that event for some reason. I guess we're out, event is gone. And there we go. Okay, so now our contract deploys. We should see it update. We should see that we're tracking this new owner address, right? Oh, what do we forget? Public.
00:21:07.010 - 00:22:00.530, Speaker A: So we're tracking this arbitrary owner that we've pasted into the contract and we're saying that only the owner. So now how do we test that in the front end, right? The owner should be able to say, hello world. And then if we bring in an incognito window and we bring in a new address and we give that address some gas and they say something, this should fail, right? Not the owner. There we go. So we're able to kind of audit that line and make sure that that require statement is working the way that we want it to. Right, but this is super centralized, like super lame. What if this is more like, since we're talking about Ethereum being kind of a massive multiplayer game, what if this is more like, let's comment this require statement out and let's make someone pay to play to update this.
00:22:00.530 - 00:22:44.540, Speaker A: So we'll say the message value is greater than or equal to like, and then we'll say not enough. So instead of this being like a one player game that only the owner can get into, we're going to make it. So it's like a multiplayer game and anyone can get in and update the purpose if they're willing to pay a little bit for it, in this case, one ether. So one thing we need to talk about real quick is that these functions are trying to be safe. The smart contracts aren't trying to be safe. If I try to send value. So if I just copy this contract's address and I open up my wallet and try to send a dollar to it, it's going to fail because there's no receive function.
00:22:44.540 - 00:23:22.072, Speaker A: We haven't explicitly set up a receive function, so our contract is not going to receive ETH. Same thing here. I'm going to make a payable function. This will fail to compile if I don't explicitly say this smart contract or this function is payable this function is explicitly taking in some money and then we'll require that they put in a certain amount of money. But now that should go through and now our front end is going to update and there's going to be some new UI. There's going to be a value that can come along with this. So with our hello world that works, but then let's send in some value along with that.
00:23:22.072 - 00:24:14.520, Speaker A: And I'll have to take that times ten to the 18 and you'll notice that this is clunky. You as the developer are always trying to, you would rather the user put in 0.1 and hit go, right? But you as the developer using this scaffolding. At first you'll do it this way, but eventually you'll build an example UI and you'll do that stuff behind the scenes. But it's good for you to do kind of, as you're kind of working out what your contract is going to look like, it's good for you to do this kind of manually at first to understand it. There we go. So we paid money and we set the purpose and now our bad guy, our other actor, can always come in over here and they can say hello to and pay some amount of money and we should see that update, right? And if we go over here and we do a read from the network, we're going to see that hello too.
00:24:14.520 - 00:24:35.920, Speaker A: But something really interesting has happened here. Check out our smart contract. It has a balance now, right? So not only are we players in the game, but the smart contract itself is sort of a player in the game too. And the smart contract has value. So that's where we can really kind of learn what this address is for. Let's write a quick withdraw function. Okay.
00:24:35.920 - 00:25:10.156, Speaker A: And it'll be public. Go ahead. Sorry, can you add more than one require or how do you, let's say yes, that's really good. This is interesting because I can actually, let's dive into that a second. Let's not go down the withdraw side quest yet. Let's talk about the atomicity or the atomic nature of smart contracts. So if I deploy this, it's going to work the exact same way.
00:25:10.156 - 00:25:45.656, Speaker A: Watch it. So I'm going to move the require statement down here. So I'm going to let you set the purpose, I'm going to console log it, and then I'm going to require that you passed in the money and if it notices that you didn't pass in the money, it's going to roll back everything. So it's atomic and either everything works or everything doesn't. And you can imagine that's really good with money, right? Get $5 from Alice, get $5 from Chuck, take $10 and put it into uniswap and get ten die back, right? You wouldn't want Alice's money to fail and Chuck's $5 to go in and kind of half ass something, right? Everything's atomic, everything rolls back. But there's one. Got you here.
00:25:45.656 - 00:26:09.410, Speaker A: First of all, let's see that this works with this require statement at the end. Let's prove that it doesn't update the function if they don't pay, even though the require statement is down below. So let's go over here and pay for this. And it will work if we pay the right amount of money. And it will fail if I take a zero off of there. Yeah, not enough. Okay.
00:26:09.410 - 00:26:34.600, Speaker A: It doesn't update, right? Even though the require is after that. Now there's a gotcha here. You want to do your requires first. Even though it's atomic, you want to do your requires first. So you want to require everything. Then you want to do any state updates, local state updates, like changing someone's balance. Then finally you do any external things like sending and transferring or calling anything else.
00:26:34.600 - 00:27:02.844, Speaker A: And the reason is for reentrancy. If you don't update your internal state and you send something to someone else and they craft a contract to receive that and call it again, your state still hasn't updated the balance and they're sitting there recalling this, draining your contract. And that's how reentrancy works. You can learn more about it by just going to solidity by example and go down to hacks. There's a lot of great ones. And reentrancy is the first one there. So just like keep it in your head that it is all atomic.
00:27:02.844 - 00:27:18.388, Speaker A: And really the execution doesn't like, you can have a require statement anywhere in there as long as you don't open up yourself to reentrancy. So you should probably just do it. Require statements, state changes, and then external calls. Does that make sense?
00:27:18.554 - 00:27:42.076, Speaker B: Yeah, I got a question, just in terms of execution. So when a smart contract is executed, or a certain function, it's executed line by line. Or do these require statements, for example, get hoisted at the top of the function? Or are they executed later? And that froze the function and reverts everything that has happened in terms of.
00:27:42.098 - 00:27:51.072, Speaker A: State changes, they'll execute one by one. And when something bad happens, it will revert backwards. It basically unrolls everything. Does that make sense.
00:27:51.126 - 00:27:53.596, Speaker B: Everything is void. Everything that happened is void.
00:27:53.708 - 00:27:54.370, Speaker A: Yes.
00:27:57.940 - 00:27:59.648, Speaker B: If this require statement is at the.
00:27:59.654 - 00:28:03.732, Speaker A: Bottom, you would begin a little extra gas, I think.
00:28:03.786 - 00:28:07.408, Speaker B: Okay, so you pay for a transaction even though it fails.
00:28:07.504 - 00:28:07.812, Speaker A: Yes.
00:28:07.866 - 00:28:24.776, Speaker B: Okay, the public payable keyword, what exactly does it do? I understand what the whole function together does, but if, for example, the require wouldn't be in, but just public payable.
00:28:24.968 - 00:28:48.784, Speaker A: What does it do by itself, payable basically says this function will accept value. So let me take out the require and let's just test these assumptions. Right. Let's hit save. What's going to happen here is we're going to have that extra form that lets us send more money in. This function actually will accept value, but now it will accept any amount of value. Right.
00:28:48.784 - 00:29:12.200, Speaker A: I can do that and send it in and it'll work. And we probably won't even see that update because there's not enough zeros. There we go. There, I got it. To update there. So basically the payable says this thing will accept value and it's just being safe. If we pull that payable out and then we try to do something with message value, the compiler is going to say whoa whoa whoa, you need to be explicit and you need to say whether or not this thing is payable.
00:29:12.200 - 00:29:19.310, Speaker A: See how it throws that error about value. You can't use message value if you didn't make the function payable. Does that make sense?
00:29:19.760 - 00:29:20.750, Speaker B: Got you.
00:29:23.600 - 00:29:24.510, Speaker A: Go ahead.
00:29:25.840 - 00:29:31.760, Speaker B: Is that comparable like to statically typed languages in terms of like at compilation time? It complains.
00:29:33.460 - 00:30:05.596, Speaker A: Yeah, I think it's the compiler being safe. I'm not a genius, I don't know exactly, but I think it's the compiler being safe. Like at compilation it's like, oh, this guy's doing something he doesn't mean to do and it's just trying to help you out. Cool. Let's dive in real quick to those units and globally you'll notice that I can type one ether and that's actually like one to the times ten to the 18 of way. I can say right in my smart contract I can actually say 1 hour for some reason. But down here, this is where we're getting this.
00:30:05.596 - 00:30:44.484, Speaker A: So message sender, message value, you could get the block number, you could get the block timestamp, you could get how much gas is left within the execution from the limit. And this is linked to right in the scaffold ETH repo. Also it's this link right here, it gives you solidity and global variables. And this link right here gives you solidity by example. Okay, so we've done users, we're understanding that we've got this public variable. We've looked at our own ownership pattern, right. We were able to create an owner and we were able to require that only the, oh, no, let's do the withdrawal statement and this will come full stream.
00:30:44.484 - 00:31:17.588, Speaker A: Okay. So we deployed your contract and we allow people to, whenever they want, they can pay money to update this state variable. If we deployed that publicly, not even we could stop it. We could go to sleep, but we'd wake up in the morning and it would be full of money and we would have no way to withdraw that money. So I want to add a withdraw function here to show you how transferring value within the smart contract works and also how addresses are sort of these first class citizens. See how we have address owner. See how owner is an address here.
00:31:17.588 - 00:31:38.490, Speaker A: I can do things like owner balance. I can do things like owner transfer. Right. Transfer. I can do things like owner call and actually call a function on a contract. Right. So what we're going to do here is if we want to withdraw the funds, we're going to say message sender transfer.
00:31:38.490 - 00:32:13.492, Speaker A: And if I put a one in here, it's basically going to transfer one way from the smart contract to whoever is calling this withdraw function. So what we want to do is address this, which would be the address of the contract balance. So it's a really weird line, but basically message transfer. So we're going to send the message sender the balance of the contract. Let's see if that works out for us. I see questions, sort of. It's like a question face where you open your mouth a little bit and then you don't shoot the questions.
00:32:13.492 - 00:32:14.292, Speaker A: Let's hear them.
00:32:14.346 - 00:32:25.750, Speaker B: Yeah, the account owner is. So that's just an externally owned account. Like every contract has one owner like this, right?
00:32:26.140 - 00:32:44.044, Speaker A: No, this owner is just like this could be called public owner, right? Yeah. This address public. This could be anything. This is just an arbitrary value. Maybe this could be Alice and then we could have another one that is Bob, right. So it doesn't need to be owner. It can be anything.
00:32:44.044 - 00:33:06.790, Speaker A: And this could be Bob. Right. And we could decide to send maybe Alice some money and Bob some money. And by the way, these would need to be public payable if you wanted to do that. Notice I'm doing the transfer on message sender and making sure the message sender, because there's a difference between a payable address and an address. You'll get to that kind of as you go, though. Okay.
00:33:06.790 - 00:33:09.380, Speaker A: It's not like arbitrary.
00:33:10.220 - 00:33:15.496, Speaker B: It's not like the owner that has the admin rights over the contract or something.
00:33:15.598 - 00:33:38.640, Speaker A: Well, really, a good contract doesn't have admin rights. Right. A good contract is deployed and even the person who deployed it can't stop it, and it's doing exactly what it's supposed to be doing. In this case, we have an owner because we want this withdraw to happen, and we want only the owner to be able to withdraw from the contract. But really, that's kind of like not the. Oh, I guess there's some chats here. I'm sorry, guys, I haven't been paying attention to the chat.
00:33:38.640 - 00:34:04.010, Speaker A: Yeah, of course Hadrian's going to tell us that message transfer is bad behavior. But if we took a side dude tour every time we're doing something that's slightly not right, or like, we would, we would never get anything done. Right. Okay, so you want to transfer the fund. Let's make sure this works. Right. Let's see.
00:34:04.010 - 00:34:41.084, Speaker A: Can we set the purpose? Can we pay in some money and we see the contract gets value, right? And then if I do a withdraw, the money comes out of the contract and our balance goes up. Okay, so this is pretty much working. We would want to test this before we would deployed it. Like we probably want to bring up an attacker account and make sure that attacker account can't withdraw. But technically we're sort of crafting our backend, and our backend is starting to come together. Could you walk through how the scaffold ETH works?
00:34:41.142 - 00:34:44.516, Speaker B: Because my guess is that your contract tab is like the backend, and then.
00:34:44.538 - 00:35:07.352, Speaker A: You can move to the example UI, which is like the front end. Yes, that's exactly right. So your back end is sort of like your contract. You kind of think of this as your storage layer, your database layer. We're kind of creating some kind of storage elements. We have these functions that let them like, it's storage and execution on the back end. And then your front end is this app, JSX.
00:35:07.352 - 00:35:32.612, Speaker A: And that app JSX has a bunch of hooks and a bunch of things that are common for building apps, a lot of components. But this is the main component, this contract component. This contract component is looking for what you deploy, and then it's updating it with new values and letting you interact with it. But really eventually you want to get into this example UI. And I've got a button here. I think it's set purpose with value. There we go.
00:35:32.612 - 00:35:47.268, Speaker A: So we just paid to set the purpose with just a button click, and we can even see that those events. Oh, I took the events out. Darn it. We should really have those events firing. Oops. You normally have events here. You'll have events on your version.
00:35:47.268 - 00:36:20.464, Speaker A: Each time it fires, you'll see a list of events. And those events are good for reading off from your contract. Basically, contracts can't read other contracts events, but your front end can read the events from your contract. So it's kind of a way to do on chain storage, but in a way that the contract doesn't need to execute for it. So it's like cheap storage on chain, but only your app can react to it. We'll get to events later and you can always just go to solidity by example and click on events and learn the basics. Where is it? Learn the basics right here.
00:36:20.464 - 00:36:39.064, Speaker A: Right. It's going to tell us how an event works. You declare the event and then you emit the event, and then you can read the events from the front end. But like you said, your back end is here. This is your, your contract, and your front end is this app. And right now we just have this contract. But let me go look at that example UI real quick.
00:36:39.064 - 00:36:54.652, Speaker A: That button that we clicked, it's in here somewhere. Let's see. So here's a transaction that just sets the purpose. Here's a transaction that just sends the value. Here's a transaction that calls set purpose on our contract. So this is what the front end looks like. This is how you do things.
00:36:54.652 - 00:37:21.864, Speaker A: Oops, not that I want to zoom in. There we go. This is how we do things in the front end, we can say, I want to go to my right contracts, I want to select your contract, and I want to say set purpose to this. And I'm also passing along this override of value that says I'm going to pay for it also. So this coincides to this button here. So this button is that code right there. And whenever I hit this button, it actually sets the purpose to paying this one.
00:37:21.864 - 00:38:05.824, Speaker A: And you'll notice that my balance goes down and the contract balance goes up. Right. So eventually you carve out this scaffolding and put in a real UI, but it kind of scaffolds a fake UI for you at first to interact with your contract to sort of, I'm like a four out of ten solidity developer. So as I'm building my contract, I don't know exactly what it's going to look like, so I almost have to poke at it. And is this going to be a mapping? Is this going to be an array. What kind of data types are there going to be? So there's this kind of iteration of just writing my solidity, and then I kind of get that solid and I kind of start moving over to iterating on the front end. But both of these things should happen in parallel.
00:38:05.824 - 00:39:01.030, Speaker A: You're sort of writing your contract and you're writing your front end, and this has a lot of value because you can craft some small mechanism and you can deploy that app to do in the first mentorship session, we usually write either a token or something simple like this, your contract, and we deploy it to XDI or some other network, and then we do a yarn build and a yarn surge, and that builds a static app and deploys it to surge, and then we can share it with our friends. So not only do we deploy this thing somewhere to some public network, but we deploy an app that talks to that network. And so that ability to iterate not only on the solidity and the UI, but also on how humans are using your UI is pretty powerful. Awesome. Okay. Yes sir. Any questions yet, or should we, are we about ready to make a token? Anybody have any questions? Before I start diving into inheritance and bringing in.
00:39:03.160 - 00:39:16.940, Speaker B: Mean, I'd be interested to know a little bit about all the various services that you use within this repository. For example, which serves, you use to spin up this local chain that's running, that's hard hat.
00:39:17.680 - 00:40:16.930, Speaker A: That's what, right, hard hat. So we're using hard hat to basically, this node right here is a hard hat node, and hard hat has kind of rebuilt the EVM in a way where they can do introspection and they can give you that console log ability. Before hard Hat created this, you would use truffle, and when you would need to get some kind of introspection into your contract, you would usually just fire an event and you would have to go listen for your events and try to figure out what the heck was going on with your contract. They do tracing, now they do console logging. So hard hat just gives you a local ethereum node with a bunch of wallets full of fake ETH, but it also gives you some introspection into what the heck is going on with your contract and gives you the ability to bring in hard hat console log and then do a console log right in your solidity. In terms of services, hardhat and react are kind of the two major ones here.
00:40:17.300 - 00:40:25.900, Speaker B: All right, and Hardhat, where is that located in the repository? Is that some script that gets executed from one of these yarn commands.
00:40:26.060 - 00:41:12.812, Speaker A: Yes. So yarn chain basically goes into hard hat and brings up the hard hat node and yarn deploy goes to hard hat and runs a compile, it runs a deploy and then it runs what's called a publish, which is another script that I've written that injects it into the react. And those scripts are here, hard hat script. So if you want to look at your deploy, it's very obvious. Line twelve, your contract equals deploy your contract, right. And if we had maybe some arguments going in there that go in right there, we can get to that if we get to that, or maybe even in a second session. So other services, there's ethers, right? We use ethers Js in a lot of places here you'll see that both in the orchestration layer and in the front end layer.
00:41:12.812 - 00:41:16.160, Speaker A: We should see ethers Js here too somewhere.
00:41:16.900 - 00:41:24.660, Speaker B: Is deploy a function that comes with hardhead or how does it deploy the smart contract?
00:41:25.080 - 00:42:32.810, Speaker A: I would say, yeah, I kind of hinted at this in the beginning, but if you want to get the full knowledge of what's going on kind of underneath, I would start with just ethers Js and I would make just a wallet in a script where, let's see, can I just do wallet? Basically save a mnemonic to your local file system, have your script load that mnemonic up and have that thing check its balance and send some stuff like just do a balance check and ascend with just an ethers Js, like a vanilla node script. And then there's a hard hat tutorial and this will set you up with like your smart contract task runner, where you can create a contract, you can compile that contract, you can then run some tests and make sure it works, but you don't have anything to really interface with your contract. That's where Scaffold ETH comes in and kind of glues everything together. Gives you hard hat for your compiling, but also gives you a react app and a front end and this nice kind of contract component that lets you kind of poke at things and learn as you go. Does that make sense in terms of mental model of the services?
00:42:33.260 - 00:42:46.256, Speaker B: Yeah. Just one question with regards to would it be easy, like let's say you're production ready then would it be easy to within hard hat to just change some configs and deploy to mainnet? Or you would need to completely use different servers for that?
00:42:46.358 - 00:43:15.768, Speaker A: No, this is ready to go to Mainnet right now. Look at this, I'm in hard hat. Hard hat config, my default network. I could even do a network. But if I do Mainnet here and I do a yarn run deploy, it's going to try to deploy this contract and this app to Mainnet, and it's going to fail somehow. Yes, it failed, probably for a lot of reasons. This is a provider error, which makes me think maybe my infura is crapping out, but this is all it takes.
00:43:15.768 - 00:43:48.048, Speaker A: So right now I'm localhost, right? If I want to go to Rinkobee, I want to go to Robston, I want to go to anything else. I just change this default network and hit deploy. Now there's a deployer account. You can do a yarn generate, and this is going to make a local mnemonic. And then if I do a yarn account, this is going to tell me who my deployer account is and how much its balance is on different networks. And this is all in the repo, by the way, this deploy and this yarn generate and yarn account is all right here somewhere. There it is, yarn generate and yarn account.
00:43:48.048 - 00:44:14.644, Speaker A: So you can kind of just follow these instructions and it should tell you this stuff. But this is ready to go to production. This is production ready stuff. It's just you kind of want to probably do this on the Testnet for a long time before you start publishing to Mainnet. But you should know that this tries to mimic Mainnet as much as possible. You can even do something like yarn fork. No, not frock yarn.
00:44:14.644 - 00:44:41.264, Speaker A: I think this is brand new in this will spin up a hard hat node. Let me kill my current hard hat node. This is going to spin up a hard hat node, but it's going to be a fork from main net. So now if I go back over to my app, it's not going to be able to find the contract. It's going to hot reload and say, I don't know where your contract is, but I can go here, look, I have $64, and this is on ether scan. I actually have $64 in that burner wallet. Right? So this is main net.
00:44:41.264 - 00:45:08.508, Speaker A: Now I'm on a fork of Mainnet. So this is kind of just like a different flavor of how you could do your testing. Basically, give me a fork of mainnet where I can interact with all the composability layers of dye and compound and everything in a test environment where it's not actually going to spend the money. Right. Let's go back, bring our chain back up. Okay, so we'll look at deploying and we'll look at public networks in a second session. But let's just kind of get the understanding and get you guys confident with.
00:45:08.508 - 00:45:31.552, Speaker A: If the call ended right now, could you guys get in and build a smart contract that's like a decentralized bank, or could you get in and deploy a token? And that's the inheritance thing I want to add to this, but maybe we can stop there and open for questions before I dive into open zeppelin and inheritance dope.
00:45:31.696 - 00:45:39.956, Speaker B: Okay, just on the last note that we could fork the main net. Basically, would we pull all this data.
00:45:40.058 - 00:45:43.008, Speaker A: From like a cloud node from infura.
00:45:43.104 - 00:45:46.368, Speaker B: Or would it also be saved on our machine?
00:45:46.544 - 00:46:11.436, Speaker A: It's pulling. So when you need to do a read from something that's like an existing contract that's out there, it's doing that from infura. But if you start making state changes and changing away from actual real main net, that's going to be stored locally. So it kind of keeps things locally, but tries to go to the main net as much as it can for that stuff. I don't know a ton about main net forks either. I'm just like, kind of learning it all, too. Okay, let's bring in open Zeppelin.
00:46:11.436 - 00:46:51.000, Speaker A: We've got the open Zeppelin guys here to kind of guide us, too. Let me bring in just to show you inheritance, you really don't want to be writing your own ownership pattern, right? You would rather use something that has a lot of eyes on it already. So there's a link right here in the your contract. In the very first contract you get, this is going to be available for you. So what I want to do is I want to carve out this owner and I want to not use my own ownership. I'm going to use a modifier here called only owner, and I'm going to bring in open Zeppelin's ownable. And I'm going to say this contract is ownable.
00:46:51.000 - 00:47:25.544, Speaker A: So now I've inherited the ownership stuff. Instead of me keeping track of an owner myself and saying only the owner can do stuff, I'm going to use open Zeppelin's well vetted contracts that have had a lot of eyes and a lot smarter people than me working on them to make sure I don't make some stupid mistake. Right? So now if I do this, and let's see, where's our deployer? Need a new window here. All right, yarn and we'll see. Now we should have more than just two contracts. Yes. Compiling four files now.
00:47:25.544 - 00:47:43.832, Speaker A: So there's some new files coming in with that. I think it's. What is it? Context in probably ERC 20. There we go. But now look at this. The new things like there's a new transfer ownership and a new renounce ownership. There are these new variables and functions that come in just because we just inherited that from ownable and let's dive into that ownership.
00:47:43.832 - 00:48:32.012, Speaker A: So there's a private owner and there is a function to update the owner, transfer the owner, and then there's this modifier. So modifiers are super weird. Get into solidity by example and learn more about how a modifier works. Right, a nice, clean, simple example here. But basically what's happening is if I attach only owner to my function like I did here, then it's going to call this stuff first, and if all of that works, then it's going to fill in. This underscore semicolon means go do the rest of the function. So by doing only owner, the Openzeppen library is going to make sure that the message sender is my owner, and then if it is, it's going to run the rest of my function.
00:48:32.012 - 00:49:03.864, Speaker A: So this all is let's do a yarn deploy. So now we've basically carved out our code and we've used open Zeppelin's code. And you want to do that probably as much as you can. And for ownership, maybe fine, that's like simple enough. Maybe you can get away with writing your own, but really you're going to really hit the ground running using open zeppelin contracts when you can get in here and go look at all the other contracts they have in particular. Let's go look at those tokens. Right.
00:49:03.864 - 00:49:12.970, Speaker A: If you want to make a million dollar ICO, you're going to need to bring in an ERC 20, right? Yes, I'm listening. Hit me up.
00:49:13.840 - 00:49:20.200, Speaker B: So the ownable is another contract, right? It's a solidity contract that's also on the chain.
00:49:20.360 - 00:49:31.968, Speaker A: Yes. It's not on the chain. No. It's another set of solidity that we're inheriting within our own code. So our own contract is going to get bigger because it inherits ownership. Okay.
00:49:32.054 - 00:49:42.004, Speaker B: I was wondering if it was making a call then to another contract on the chain, but then it's not the case. We're basically adding lines to our code without actually having to write them. Sort of.
00:49:42.122 - 00:49:59.690, Speaker A: Yes, exactly. And there are libraries that could be pre deployed and you'll get to that eventually. And also you'll do contract to contract interactions and we'll get to that eventually. But in this case, our contract is just getting bigger as we're inheriting new things. And when we do deploy, we'll deploy all of that. Okay, cool.
00:50:01.760 - 00:50:15.052, Speaker B: You can even inherit from contracts from famous protocols or the same way you inherit the ones you inherit from open Zeppelin. This case.
00:50:15.106 - 00:50:31.072, Speaker A: Yep. You could do something like, I'm going to import my other contract soul. Right. And you could bring in your other contract right there and then you could inherit it by saying, is my other contract. Does that make sense?
00:50:31.126 - 00:50:32.324, Speaker B: Okay. Yeah.
00:50:32.522 - 00:51:10.444, Speaker A: Awesome. So what we're going to do is we're going to inherit the ERC 20 token and let's go look at that real quick. What does it look like? It keeps track of a balance. You guys probably already know what the ERC 20 contract is going to look like, but it's a smart contract that keeps track of balances and lets us transfer the token around. Before ethereum, if you want to deploy your own decentralized currency, you had to spin up a whole crypto economically incentivized network of miners and have proof of work and all of that stuff. If you want to deploy a decentralized currency now, you just deploy an ERC 20 from open Zeppelin. Okay, it looks like Hadrian.
00:51:10.444 - 00:51:30.164, Speaker A: Did you have something to say there? You in? Yeah. Hello, I'm here. I'm sorry, I had to change laptop. All good, man. So we're going to bring in the open Zeppelin ERC 20 token. We're going to say that this, your contract is. And actually, let's go ahead and change our your contract name.
00:51:30.164 - 00:51:55.832, Speaker A: So we're going to do a couple of changes here. We're going to say this, your token, and we're going to inherit the ERC 20. We're going to not have that. We're going to not have this. Really? We're going to make this really tiny. So in our constructor, we're going to need to call the ERC 20 constructor and this will be my token, your token and the symbol. And it's going to automatically do 18 decimals.
00:51:55.832 - 00:52:15.044, Speaker A: And the last thing we're going to need to do is mint. Let's just mint to message sender. Actually, let's mint straight to our address first. Whoa, come back here. Just paste that bad boy right in there and say we're going to mint 100 ether for some arbitrary reason and that should compile. Let's see if that works. Let's see if I get it.
00:52:15.044 - 00:52:19.984, Speaker A: Please work. First try. I need to have a. There we go. Seven contracts.
00:52:20.032 - 00:52:20.484, Speaker C: Hello.
00:52:20.602 - 00:52:38.590, Speaker A: What did I do? Oh, okay, here we go. I changed the name of my token. So I need to get in here and change this guy and then in my deploy. Right. I'm not deploying your contract anymore, I'm deploying your token. And now that should work. And we'll have to make one change in the front end if this works.
00:52:38.590 - 00:53:03.396, Speaker A: Dope. Okay. And then in the front end we've changed our contract name. So remember that contract component, we're going to change that to your token. And now we should have a token deployed to our local testnet. And if we check our balance of that token, we've got 100 ETH of that token. And if we set up a second user and we'll give that.
00:53:03.418 - 00:53:13.320, Speaker B: I don't really get the 100 ether that you put in as a parameter because ether, it's its own currency.
00:53:15.660 - 00:53:31.790, Speaker A: Yeah, that's a good point. That's a good point. Okay, so how about this times ten, pow pow. 18, is that better? Same exact thing. Ether is just a unit that lets you do ten to the 18. But you're right.
00:53:33.760 - 00:53:36.364, Speaker B: You'Re actually referring to ether, the number.
00:53:36.562 - 00:54:06.808, Speaker A: Yeah. The ten to the 18 decimals. Yeah, it's more like it's just a nice way to do it, but we can do it exactly like this and it's going to do the exact same thing too. And maybe it is better to do it like this, just to be explicit about it. But yeah, there's other people on the call that will probably tell you a different way to do it too. Right? It's like you do what makes sense to you when you're working on it and other people will have their eyes on your contract. Your contracts are going to be very public and they're going to be attackable until the end of time.
00:54:06.808 - 00:54:20.780, Speaker A: So you want to have a lot of eyeballs on your contract. So when you have little things like that, get it out and get it in front of people and see what you prefer, what they prefer, what's best. There's probably a standard somewhere. Okay, so we have a token now, right.
00:54:20.850 - 00:54:29.168, Speaker B: Also, just one last thing. Musa also had a question. Yeah, Musa, do you want to say it?
00:54:29.254 - 00:54:52.736, Speaker A: Where does the ownable sole file live? Yeah. And does hard pull that? Yep, it's pulling the open. So we probably have some installer that's bringing open zeppelin in. So there's an open Zeppelin NPM repository and I bet. Gotcha. There it is right there. So it's included as part of hard hat.
00:54:52.736 - 00:55:01.864, Speaker A: Gotcha. Makes sense. Cool. Okay, so we've got our token deployed, we can check. Go ahead please.
00:55:01.982 - 00:55:15.168, Speaker C: Just to clarify there, it's not included as part of hard hat, but just as hard hat, which is a dependency that you install. You can install the contracts as another dependency, so they are more side by side.
00:55:15.334 - 00:55:40.996, Speaker A: Okay, basically I've brought, and I don't remember, but I've brought open Zeppelin into the hard hat project already within scaffold. Good clarification there. Thank you. Yeah, I don't remember doing that, but I did it at some point. Okay, so, yes, we've got those coming in. We've got our open Zeppelin contract, we've got our token here, we've got our balance. Let's do a transfer too, and let's check it out.
00:55:40.996 - 00:56:00.060, Speaker A: So let's see, this guy's going to need some gas, right? He's going to have to spend a small amount of gas to transfer these tokens. But let's transfer to this guy, maybe. What do we have? We have 100. So let's do one of those. And boom. Now if this guy checks his balance. There we go, one.
00:56:00.060 - 00:56:23.908, Speaker A: Okay, cool. And then this guy's balance should now be 99, right? Cool. So that's working. This is how you would inherit stuff. If I was on a mentorship session, our next thing would be let's build a vending machine contract that sells our tokens. Like a crowd sale. But the open Zeppelin guys actually have a crowd sales contract and they're on this call.
00:56:23.908 - 00:56:52.190, Speaker A: So I feel like I should hand this off to them if they wanted to talk more about their contracts or something. I don't know. They're on this call. I would like to hear their opinion, like to hear what they have to say and, yeah, I don't know, let me hand it off to them and see where this goes. And then if we have some more time, I'd be happy to deploy a vending machine or a crowd sale contract and show you how to sell your token or do contract to contract interaction. But here are the open Zeppelin guys. Let's see if they have anything for us.
00:56:53.600 - 00:57:44.592, Speaker C: Yeah. Okay, so first of all, regarding the crowd sale contracts, we used to have a crowd sale contract in the previous version, but we removed it. And the reason that we removed it is that there's like a ton of different ways to do crowd sales. So there were many, many different variants and you were able to combine them, but that got kind of hard to do with the latest solidity versions. So now the recommendation is if you want to do something like a crowd sale, or there are many different patterns to distribute tokens that are not necessarily crowd sales, you should write your own. And the ERC 20 contract provides the mechanisms to do that like the underscore mint function that you showed. There is an article in our documentation site that is maybe interesting to look at.
00:57:44.592 - 00:58:11.590, Speaker C: So Austin, if you want to go to docs, open Zeppelin. Yeah. And then in here go into contracts. And then in the sidebar you can see tokens. ERC 20 creating supply. Yeah, so this is a guide that shows different ways of creating and minting contracts and distributing them in many different ways.
00:58:12.200 - 00:58:14.696, Speaker A: So we could just copy and paste that in there.
00:58:14.798 - 00:58:52.310, Speaker C: Yeah, exactly. And it explains why the underscore min function is important, that it keeps track of the total supply at the same time as the balances. And it also emits the events that are important for the ERC 20 standard. But then it gets into some more complex ideas that you can have for how to distribute your tokens and how to implement those using the ERC 20 contract. The article is there, you can look at it. I don't think we need to go through it right now, but I thought it could be interesting as a next step for people who are learning.
00:58:53.000 - 00:59:39.248, Speaker A: That's exactly right. I like to make a vending machine because the vending machine has to inherit the interface or has to bring in the interface for ERC twenty s and has to be able to do the dot transfer on a contract. So it's like the next logical thing is to build a crowd sale or to build a vending machine, because it teaches you now that you've got this token contract, how to do contract to contract interaction. So either today or maybe later, maybe another session in a week, we could do that. And a lot of people what I do after the first session, I have some homework. Let me bring up the scaffold ETH repo. Again, I have some homework that is basically like go build a decentralized bank, which sounds really fancy and hard, but really, so you learn how a mapping works and then I say, go build.
00:59:39.248 - 01:00:04.590, Speaker A: I think there's like structs and arrays of structs are sort of the next thing you want to learn in terms of your solidity journey. And also I think events in there somewhere too, but I'm not sure. I feel like we've got the open zeppelin guys here, so I feel like we should use them while they're here. And then maybe we could do another session and we'll build our own crowd sale after that. But I don't know how long this is supposed to last either. So I'm up for whatever at this point.
01:00:06.000 - 01:00:09.470, Speaker C: Yeah, sorry, go ahead.
01:00:10.240 - 01:00:26.288, Speaker B: You said you had to jump out. I think in 55 minutes, Austin. Right. How long until then? This is super interesting. So whatever you guys want to show us, I'm taking it all in.
01:00:26.454 - 01:00:47.000, Speaker A: Okay, awesome. Yeah. So I guess that if I was going to continue I would just build a crowd sale contract and show you how to interface with the token. Maybe we can just do that with the opens up and guys here and they can dive in and talk. Yeah, for sure. Okay, let's talk about the dot transfer thing real quick while you guys are here. We were talking about transfer send.
01:00:47.000 - 01:01:21.460, Speaker A: I think the answer there is we were supposed to do, instead of doing message sender transfer and sending some value, I'm guessing the right way to do that is message sender call. And you give it some value like that and then no call data. Is that the preferred method? Yes. Or you open Zeppelin's tooling. There's an actual, like, where's that over here?
01:01:21.530 - 01:01:25.732, Speaker C: You would find that in utilities, I think, which.
01:01:25.786 - 01:01:27.120, Speaker A: Oh, I can't click utilities.
01:01:27.200 - 01:01:30.756, Speaker C: Yeah, sorry about that. Something we need to work on.
01:01:30.858 - 01:01:47.052, Speaker A: Let's see if I shrink everything up and then bring it down. There we go. Got it? Yeah. A counter is something that you use all the time in open zeppelin code, right. It's interesting where counters are, but counters are everywhere in their code. There's a sender or what is it.
01:01:47.106 - 01:02:21.216, Speaker C: You would look at? Address. The address library. So something that, to understand what's going on here, there's a couple of things. First, so the address transfer function that you just used, the problem with that is that it will send very little gas, what is called a stipend. And due to some recent changes, sometimes this doesn't work. All right, because you are sending to a contract and that triggers the fallback function. I don't know if we saw a fallback function today, but that can consume too much gas and the dot transfer doesn't work.
01:02:21.258 - 01:02:21.560, Speaker A: Right.
01:02:21.630 - 01:03:12.970, Speaker C: So you want to do a call that sends all the available gas. However, the problem with using dot call is that you then need to be aware that there is a return value of the dot call, which is a boolean that tells you whether the transfer succeeded or not. And that is very important because if you don't look at that, it's like a boolean success we tend to call it. If you don't look at the success you can assume that your transfer went through and that something happened and then continue working. But maybe if it didn't, your logic is going to be all wrong because your assumption is going to be wrong and that opens up the door for an attacker to do something with that. Now you have these two lines of code, and ideally you want that to be simpler. So that's where the address library comes in.
01:03:14.060 - 01:03:16.760, Speaker A: Oh, I see, over here. Okay, got it.
01:03:16.830 - 01:03:22.000, Speaker C: Right. The send value function will do essentially those two lines that you just wrote.
01:03:22.180 - 01:03:22.910, Speaker A: Interesting.
01:03:25.200 - 01:03:26.792, Speaker C: Were you going to show something in solidity?
01:03:26.856 - 01:03:53.508, Speaker A: Yeah, I was going to go to solidity by example and show, I think it's in the multi sig, I don't know, somewhere I had a call. Yeah. There's this right here. Right. Exact same line here, but just in code that if anybody wanted to go find it and look at this code, it's right here, but it's doing the same thing we're doing, just not in my junkie contract. This is a much cleaner and easier way to see it. Yeah.
01:03:53.594 - 01:04:47.844, Speaker C: So in here, there is a third concern that you need to keep in mind, which is when you call a function in solidity, what we call like a high level function, which is like, there is no example here on the screen, but if you called the execute transaction from another contract, you begin to connect contracts between them. Solidity does this thing where it'll check that the target contract is actually a contract, and it's not an account like a wallet, someone's off chain wallet. Right. So it'll check that there is code at the target address before doing the call and revert otherwise. So that's also where you can use the same address library. But instead of using the send value function, there is a function call. It's called function call helper function that will do that.
01:04:47.844 - 01:05:07.436, Speaker C: But that's kind of advanced. So I don't expect you to really understand why this is necessary or when you would use it, but it's just to keep in mind that there are many tricky details, so it makes sense to look at the patterns that have been implemented and see if you need to use them or not.
01:05:07.538 - 01:05:43.850, Speaker A: I think that's the too long didn't read is start using these packages that these well seasoned veterans are creating for us and get used to just using your stuff, because there are these weird gotchas, and you guys have thought of the gotchas ahead of time and kind of crafted it for us. And this dot transfer might work fine for me in all my contracts, but then something goes wrong. At some point, there's some edge case, and I just didn't know about that until it happens. Right. Yeah, that's really good advice. Okay, go ahead.
01:05:44.300 - 01:05:52.456, Speaker C: No, I was just going to say that we didn't really prepare anything. So if you want to move on with creating a vendor contract, I think that would be great.
01:05:52.558 - 01:06:22.016, Speaker A: Let's do that just real quick. The vendor contract will have fallback function. So we'll get to fallback functions after we create the vendor. If everybody's cool with that, we'll dive into, now that we've deployed our token, right? Our token is out there. We know, we've verified the source code on chain. We've shown everybody that this isn't an inflationary token. If we minted this token and we put it on an exchange, you know that I'm not going to rug pull you by minting a whole bunch more and dumping them on the exchange.
01:06:22.016 - 01:06:53.820, Speaker A: But at this point, all it is is a token. And if you wanted to buy some of this token from me right now, you'd basically have to be like, hey, Austin, send me some token. And I'd be like, okay, send me some ETH. And we'd do some kind of like over the counter thing that flies in the face of decentralized permissionlessness, right? So what we want to do is now that we have our token contract, let's build a vendor that allows anyone in the world to come in and buy some of that token without us even being a part of it. Right? Totally decentralized. Was there a question there? Yeah.
01:06:53.890 - 01:07:08.092, Speaker B: The mint function, will it only be deployed once when the contract is deployed? Or can you as the contract owner or like, I don't know, someone else in this case call it and mint some new tokens?
01:07:08.156 - 01:07:35.928, Speaker A: Great question. Yes. So basically we can see right here in the contract that mint is only called in the constructor. If there's not another function around here that's mint, anywhere else we can kind of like audit. Okay, so we are inheriting ERC 20. So we would technically have to look through all of the ERC 20 token to make sure these guys haven't snuck in some kind of mint in here. But that's the thing, we can lean back on them and assume that they're not doing any mints in here.
01:07:35.928 - 01:07:48.016, Speaker A: And the only mint that's ever going to happen is the one that we explicitly call. And the fact that this is in the constructor means it's only ever going to get called once. Does that make sense? Yeah, something else that.
01:07:48.118 - 01:07:49.250, Speaker C: Yeah, sorry.
01:07:49.780 - 01:07:52.124, Speaker B: No, you go ahead, I'll ask afterwards.
01:07:52.252 - 01:08:15.530, Speaker C: So I was going to say that in case you didn't notice, mint is an internal function so it's not exposed to the outside world. And that's the underscore there. It's just a convention that we use. Everything that has an underscore at the beginning, it means it's internal. So if it is not explicitly in a public function, nobody will be able to call it.
01:08:17.260 - 01:08:21.224, Speaker A: That's good. Yeah. Even the access there. Okay, next question. Or did that.
01:08:21.262 - 01:08:31.704, Speaker B: Yeah, I just have a quick one. When you talk about these vending machines, is it similar to what we sometimes see, like these bonding curves to distribute a token?
01:08:31.832 - 01:08:38.624, Speaker A: We could, yeah, maybe if we have time, we'll add that in. Basically it's like, well, you add them.
01:08:38.742 - 01:08:41.388, Speaker B: In the ESC 20 contract.
01:08:41.564 - 01:09:02.820, Speaker A: No, I don't think we want to add them into our token. Basically, we want our token to be isolated. We want to deploy that token. We want to only have 100 of them. We don't want to add any extra complexity so people can see that token and trust it. We want to do this next stuff in a second contract. Even the vendor stuff, technically, we could set it up so you could deposit ETH right into the token contract and get some of the token back.
01:09:02.820 - 01:09:38.588, Speaker A: And that's how weth works. Actually, if you go check out weth, it has basically a deposit function. Let's see if we can go look at it real quick and allows you. Sorry, I hear my kids yelling at me. It has a deposit function and lets you basically put ETH in and get tokens out. Just like a vendor might work, but it's built into the token. But the only reason you would want to build that into the token is if you're doing this wrapped ETH stuff, right? If we want a separation of concern, we want to have our vending machine over here, have it super simple, have it selling tokens, and have our token contract over here, and have it super simple, and have it basically just the token.
01:09:38.588 - 01:09:49.380, Speaker A: And let me double check in with the open zeppelin guys to make sure that is like I am saying the correct thing there, right? You do want a separation of concerns. You do want a crowd sale contract that's separate from your token?
01:09:51.340 - 01:10:23.520, Speaker C: Yeah, absolutely. The idea is to follow a separation of concerns kind of principle in the past for the crowd sales, the crowd sales would last seconds or days. So it wouldn't make sense to keep the vending code in there if you would only use it for a little while. So keeping that code in there would increase the attack surface for someone to engineer an attack against your contract, so it makes more sense to keep them separate.
01:10:24.740 - 01:10:28.740, Speaker A: Awesome. Any more questions coming up, or are we ready to build a vendor?
01:10:29.960 - 01:10:53.500, Speaker B: Maybe just, is there some. In terms of this concept of separation of concerns, are there some specs or some generally followed guidelines? Let's say if we now play around and build some of these contracts, are these architectural decisions or are there some guidelines?
01:10:54.080 - 01:11:21.270, Speaker C: No, there are architectural decisions. Maybe you will have a requirement when the contract handles ether, and so you don't want to mix ether from different purposes, but that's a little bit different. What I was talking about before is more of an architectural thing that you just kind of have to get a feel for it and make a decision. There is not necessarily a right one.
01:11:21.880 - 01:11:53.960, Speaker A: And let's just pretend like I'm some mediocre degenerate trying to buy some not sushi coin, some food coin. Right. Someone deployed eggplant coin. I'm going to go to ether scan and I'm going to go, okay, what does eggplant coin look like? And I'm going to say, oh, this is a standard ERC 20. There's no extra shit here. I can basically trust that at least the token itself is going to work exactly like an ERC 20. If there's some weird functions in there that looks like there's another mint happening somewhere else, like, wait a minute.
01:11:53.960 - 01:12:27.210, Speaker A: If this person can mint more, then they can inflate it and they can kind of rug pull from the exchange. So it's just like me as an average user, I want to see that that token looks exactly like all the other tokens I've been interfacing with. And my mental model is the same and I can kind of pattern match and say, okay, this is the thing I can transfer around. Nothing else is going to happen here. If there is a second contract, if there is something weird happening, that's where you want that kind of bespoke code to live word. All right. Yes, please.
01:12:27.210 - 01:12:53.532, Speaker A: You cannot change the token or any contract once it's deployed. That's the whole upgradability pattern. So again, open zeppelin has a lot of good content on that. I bet we can come look at upgradability. This goes back to even the ethos of decentralized programming, decentralized money. And how does this work is, in a way, you don't want to have an owner of a contract. In a way, you don't want a contract to be upgradable.
01:12:53.532 - 01:13:15.928, Speaker A: You want it to do exactly what you want it to do and continue living there. But of course, in the real world, as we deal with humans and as you find mistakes and as new things come out, you are going to want to upgrade your contract and to be honest, I'm like a two out of ten in terms of my understanding of the different patterns. There's some really good content out there. I don't know. Open zeppelin. Do you guys have like a place I could click here to go find.
01:13:16.014 - 01:13:51.856, Speaker C: Your upgrade pattern here? There's using, with upgrades, they're near the top or they are upgrades. Right. So the tool that we recommend now is these upgrades, plugins. So now you guys are using hard hat. This is a hard hat plugin that you need to configure and it gives you a function called deploy proxy and another one called upgrade proxy. And so essentially what that does, it implements the proxy pattern. And I think that's enough to discuss some other day, but in essence it's just deploying some contracts.
01:13:51.856 - 01:14:29.360, Speaker C: Right, but the reason that we recommend using these plugins is that you need to have some extra care with the things that you do with the storage variables that you use and your constructors. And the plugins will run all of these checks for you and make sure that you are not messing up with the extra upgradability requirements. So yes, when you assess and you agree that you need upgradability in your contract, the recommendation is to use those plugins and the proxy pattern.
01:14:29.940 - 01:15:21.856, Speaker A: And this proxy pattern I think uses delegate call, right? Basically you carve out your storage and your execution into two different places and you put your execution into the proxy, but your storage will be into that new contract that you deploy. And so you can redeploy your execution layer while keeping your storage layer. But everything has to be exactly right. And I'm like a one out of ten in terms of my understanding of delegate call and how you have to have your variables structured exactly the same and it can cause problems. You're much better off deploying a very simple contract that isn't upgradable, that doesn't have an owner that does exactly what it needs to do and does that forever without you ever being able to stop it. But these resources are available and there are good proxy patterns already established that great developers have put together. I would look at that when you need to do it.
01:15:21.856 - 01:15:43.610, Speaker A: But remember, there's a lot of weird stuff going on under there and you got to know what you're doing. And could this allow the developer to mint new tokens, for example, that we were saying exactly, they make it so it only mints in the constructor, but then they deploy a new one that mints, they add a new function of execution that mints more. Right? And then it's like all of a sudden. Yeah. You can't trust them. Yeah, exactly.
01:15:44.460 - 01:15:50.516, Speaker B: Well, theoretically you could have a democratic instance that manages the contract owner.
01:15:50.548 - 01:15:50.744, Speaker A: Right.
01:15:50.782 - 01:15:56.636, Speaker B: Like a dow or something that allows large communities to vote on it.
01:15:56.738 - 01:16:23.910, Speaker A: And I think that's where the space is moving. Right. You do see this ownership pattern persist, but what they're doing is instead of that owner being some externally owned account, that owner becomes like a gnosis safe, and then everybody is voting on whether or not to execute that. So you can still have an ownership pattern, but you can kind of abstract it away from an externally owned account. So just like one Gibroni can't just trash the whole thing. Yeah. Okay.
01:16:23.910 - 01:16:28.580, Speaker A: You're muted.
01:16:30.940 - 01:16:50.220, Speaker B: Thanks. All the functions that, for example, allow one user to transfer an ESC 20 to another user, or for example, the approve transaction, is that all part of the ESC 20 library or contract that we've inherited from?
01:16:50.370 - 01:17:11.670, Speaker A: Yes. Let's find the approve there. So the approve is going to up some allowance. Right. And that allowance is tracked up here at the top, but yes, that approve is built into ERC 20. Okay, does that answer that, was there more there or was that. Yeah, just the approval pattern.
01:17:11.670 - 01:17:41.618, Speaker A: We'll learn about that if we set our vendor up. So if we set our vendor up to just sell, then we won't get into this. But if we set our vending machine up to actually provide liquidity, basically buy and sell, then we'll have to have the approved pattern. Because if we wanted to sell our tokens to the vending machine, we don't just send our tokens to the vending machine. Right. We approve the vending machine to take them, and then we go call some function on the vending machine, and it goes and gets them and does stuff with it. And that approved pattern is like another thing to get your head around.
01:17:41.618 - 01:18:31.950, Speaker A: And maybe we'll get to it with the vending machine, but if not, we'll set up another session and we'll do stuff like create an amm and have kind of liquidity on both sides and go through that prove and transfer function. I think we're about ready to get a vending machine going, but this is some really great discussion. Really great questions, guys. Anything else before we try to sell our shitcoin? Okay, so this is going to take you through how to add a new contract to scaffold ETH also. So that's nice too, but I'm going to just create a new contract in here called vendor, and I'm just going to copy and paste my token because I want to bring probably a lot of that with me. And we're going to need not, this is interesting too. We're going to need not the ERC.
01:18:31.950 - 01:18:51.418, Speaker A: Actually, we are going to bring in just our token. No, we can't. We can do IERC, right? We could do boop. Right? And then we can use an IERc. Technically we could have imported our whole token in, but then the logic comes along with the token. And I think what we want to do is bring in an interface. Let's talk about interfaces real quick.
01:18:51.418 - 01:19:29.330, Speaker A: That's good to do with the open Zeppelin guys, too. Let's see. So if I grab this, I bring that back over here. Let's go look at Openzeppen's token and the difference between the interface and an actual token. And the difference is basically there's the code for actually doing stuff versus the interface of just like how I interface with it. So if we look at the IERC 20, this is the interface, we're not going to have any code that does anything. See that? The transfer function, the allow function, there's no open brace, closed brace.
01:19:29.330 - 01:20:01.534, Speaker A: And that means this is going to be a lot thinner for us to bring into our contract. If we bring in our token directly, then it's going to have all that transfer code. Oh man, I'm clicking all the way around here. Let's look at just the transfer function between IErC and erc. So if we get here to, there we go. Okay, so see this code right here? That is in the ERC 20, that is not over here. In the IERc 20, there's no code.
01:20:01.534 - 01:20:35.546, Speaker A: So the implementation just tells you there's a function and it takes these arguments and it returns this value and it's external or internal. The implementation just tells you, here's how you basically talk to the contract, not how the contract works itself. Because what we want to do with our vendor, our vendor needs to interface with the token. It needs to move stuff around, but it doesn't need the actual logic of the token. I hope that makes sense. I'm kind of explaining a little weird here, but we've got our interface token and it'll make more sense. We're not going to inherit anything.
01:20:35.546 - 01:21:10.018, Speaker A: Yes, please. So is it basically defining the functions without the function logic, so to say from code lines, basically gas? Yes. And what we'll do is we'll keep track of some. We'll just call this your token. And there's this real weird trick we can do, but I'm going to do it the other way. First what we're going to do is we're going to have some address come in here that will be our token address. Let's not even put that there, I don't know.
01:21:10.018 - 01:21:45.722, Speaker A: And then we can do token address. So there's a cool way to do this, but I'm going to do it the slow way first. And I'm going to say your token equals the interface with the address in. So what this is doing is going to establish this token that we can talk to now. So now we can do things like yourtoken balance of, right. We can call these functions of that token now, now that we've established this interface to the token. So we're going to deploy our token and then we're going to deploy our vendor passing in our token's address and that's going to establish an interface to our token.
01:21:45.722 - 01:22:12.380, Speaker A: Now I think there's something cool there's a trick you can do in solidity and I think the open Zeppelin guys would tell me I could actually just say IERC here and not do any of that stuff. And if this is an address it's going to know to do this, but I'm just going to explicitly set it up to do it and I don't know if there's a difference there. This just works for me. That's a particularly bad way to do it here. I just want to do it the more explicit way. But you guys tell me if I'm doing it wrong here.
01:22:13.950 - 01:22:26.522, Speaker C: No, I think this is fine. I don't think you can. There is no implicit storing it in the. Okay, but you can definitely define the type as IERc 20 in the argument.
01:22:26.586 - 01:22:44.354, Speaker A: Yeah, that's what I was saying. You do this and then. Oh yeah, no, you still would have to say your token still needs to be. Yeah, so this could be the token or something like that. Right, right. And then we would say your token equals the token and that would work there. We mean there's not even that much extra code to do it this way.
01:22:44.354 - 01:23:20.570, Speaker A: So maybe it's, I don't know. But what we're going to do is once this contract gets deployed, we're going to send it an address and that's going to be where our token is and we're going to use this IERC library to tell our contract how it can interface with that token. So now that we have this token, we're going to want some kind of function that is by token. Right. And what we'll do is we'll make this function payable and we'll set it up just like Wes right now. So it's basically just wrapped ether. But what we'll do is we'll do our token transfer to message sender.
01:23:20.570 - 01:23:37.320, Speaker A: And what we're going to do, this is really where, but we're just going to do message value. So if you send in one ETH, I'm going to send you one token back. But really, when you're talking about bonding curves, you're talking about all the cool things you can do. You're going to do it right here. Whoa, that's awesome, dude. You're going to do that right here. Like, you could have some.
01:23:37.320 - 01:24:16.750, Speaker A: And again, when you do bonding curves with fungible assets, you have to do, like, this calculus stuff. Go look at the Bancorp model. But let's imagine these things are non fungible and we're buying them one at a time. What you would do is you would have some multiplier here that is like a numerator over a denominator. And every time someone gets in here and buys something, the cost would basically be multiplied by our multiplier, something along those lines. So the first token costs one, then the second token costs like 1.1. The third token costs like 1.14
01:24:16.750 - 01:24:49.366, Speaker A: or something like that. Right? So you can kind of have a multiplier where the price basically goes up on a curve, and as people buy and sell, it gets multiplied and divided. You can do that with NFTs when they're one at a time, but when you're buying an ERC 20 token, you have to do this weird calculus stuff. And check out the Bancorp model. There is actually a scaffold ETH bancor example in the repo. If you go to scaffold ETH and just look at all the crazy branches we have, there probably is some kind of. Is it called bancor? Nope.
01:24:49.366 - 01:25:14.690, Speaker A: Is it called bonding curve? Nope. I don't know what it's called. There is one in here that uses the Bancorp method and implements that and does a bonding curve kind of for fungible asset. Okay, let's see. We want to buy the token. We want to make this function payable. So they send in money, and then what we're going to do is whatever money they send us, we're going to send them that amount of token.
01:25:14.690 - 01:25:38.938, Speaker A: I don't even know if this is going to work, but this is how scalable works. We make a change and we go mess around with it, and we see if it works, and we kind of iterate on that. No, I broke something oh, it needs to be IERC. Wait, what? You are calling the ERC 20 constructor in your vendor. In the vendor. Oh, get out of here. My bad, my bad.
01:25:38.938 - 01:26:09.852, Speaker A: Okay, here we go. All right, so there goes our token. But our vendor didn't get deployed because we need to remember to come over here and add this other deployment. So our token gets deployed, then our vendor gets deployed. And remember, our vendor takes in some argument here of the address of our token. And what you can do is you get the artifacts in your deploy script. This is an artifact so we can do something cool like yourtoken address right there.
01:26:09.852 - 01:26:43.000, Speaker A: Awesome. And we're going to have to do one more thing in a second. But this should deploy and it should have both our token and our vendor. And then in our front end, we're not going to be able to see our vendor yet. So we need to go to our app and we need to add in our vendor here too. And now we'll have a vendor and we'll have a token and we have this buy token function. But even if I try to buy tokens right now, it's not going to work because this guy doesn't have any tokens yet.
01:26:43.000 - 01:27:21.552, Speaker A: So if we go check our vendor's balance, none, right? If we go check this guy's balance, none, right? If we go check our faucets balance, this is where they all are. Yes. Okay. Because our faucet, when we spin up our node, we have all those wallets that are there and our local blockchain is doing the deployment for us. So the deployer is actually that faucet account. So what we can do is in our deploy, we're going to do one more line. We're going to say await, and we're going to say your token transfer, and that'll be to the vendor's contract.
01:27:21.552 - 01:28:02.496, Speaker A: So we'll do vendor address and how much are we going to send? We'll do utils, parse ether 100. Okay, so now we deploy our token and when we deploy it, it mints 100 to us. Then we deploy our vendor with the token's address and then we transfer the tokens from us into our vendor. And with one quick move, basically, we've created sort of this vendor that everyone can see on chain. They can see that our token isn't going to be inflationary. They can see a lot of stuff and they can form a lot of trust because they can see our code and they can trust the code. Okay, now let's see if this has gone through.
01:28:02.496 - 01:28:17.480, Speaker A: Let's check this guy's balance. There we go. Our vendor now has 100 tokens loaded up. So we've deployed the vendor and we've loaded it up with tokens. Now let's see what happens when we buy 0.1 worth. All right, it worked now.
01:28:17.480 - 01:28:32.750, Speaker A: Okay, now let's check. The balance of our contract is now at 99.9. Let's check. Our balance is now. It's going to show it like this. But you could always take that two way. By the way, anybody used ETH build.
01:28:32.750 - 01:28:55.296, Speaker A: If you have some number that you'd like to kind of play around with and see, look at that. You double click, it just takes it from way automatically for you. So this is fun too. If you ever need to do stuff like mess around with blockchains and stuff. I just want to see that work. There's the current block number. Okay, so we own tokens now, we can buy them from the vendor.
01:28:55.296 - 01:29:12.970, Speaker A: If we really want to dig into the approve pattern, we probably should add in another function in our vendor that lets us sell tokens, right? Not just buy tokens, but sell tokens. But let's open it up right now for discussion. Let me know if I'm doing anything wrong. Let me know if you guys have any questions. How are we doing so far?
01:29:13.580 - 01:29:23.230, Speaker C: So I want to make a comment on something that has to be improved in the vendor contract. You called the.
01:29:24.560 - 01:29:26.364, Speaker A: It's probably going to be right here.
01:29:26.562 - 01:29:44.790, Speaker C: Right? So you called your token transfer, and one of the features of ERC 20 is that the external functions like transfer, approve, et cetera, return a boolean exactly in the same way that we discussed before. So you need to make sure that it went through.
01:29:46.360 - 01:30:17.932, Speaker A: Right, there we go. But we did see that it failed. But you're saying there are some implementations of some tokens that don't fail on that transfer. And so you want to be careful. There are certain exchanges out there that bring in some token that isn't exactly to the ERC 20 standard. The transfer doesn't fail and people are able to attack that or even mint their own shitty ERC 20 and expose this transfer function in a way that it doesn't work and cause it to fail. So you want to have that required statement there to make sure.
01:30:17.932 - 01:30:18.464, Speaker A: Okay, cool.
01:30:18.502 - 01:30:34.992, Speaker C: Yeah, exactly. So in this case, your token is just an IERC 20, so you don't know what it's doing. And it's not that the token would be against the standard, it's just the standard allows to return false. And you just need to be aware.
01:30:35.136 - 01:30:44.188, Speaker A: Of that got it. So just like always, anytime you do that token transfer, wrap it in a require statement and it's something perfect or great feed.
01:30:44.224 - 01:30:50.024, Speaker C: We also have a library for that that does this, which is called safe UC 20, kind of.
01:30:50.222 - 01:30:52.568, Speaker A: I've seen that like safe transfer from.
01:30:52.734 - 01:31:03.230, Speaker C: Yeah, exactly. So it just checks the return value basically. Sorry.
01:31:03.920 - 01:31:27.716, Speaker B: So transfer failed will be the message if the boolean returns false, so the transfer doesn't succeed. The Boolean, is that what you called emit events before when you said the contract emits events? Are those Booleans, those events that while it's listened for and stuff, or is it something else?
01:31:27.818 - 01:31:48.844, Speaker A: It's this Boolean right here that gets returned from the transfer. So here's your transfer function. It's going to return some Boolean. That's the Boolean we're talking about. Does that make sense? So our transfer function will give us, will return a Boolean. And so that's going to check that bool right here. It's going to check that that bool is true right here.
01:31:48.844 - 01:32:40.104, Speaker A: And if not, it will revert. I mean, we have a little bit more time. Oh, I promised receive function. Let's get that first. Okay, so if I wanted to make this a better ux, right, instead of someone having, first of all, if I wanted to make this better ux, I'd build an example UI that lets you get in here and buy tokens without having to do that nonsense with the ten to the 18 stuff, right? Like the very first thing I should do is probably make a buy token UI that says you can get in here and just say, I want 0.1 e and go and not have to do this junk, right? But next, after that, after you have a DaP, you want to make it even easier for your users to use. Basically we can have our vendor contract receive ETH directly.
01:32:40.104 - 01:33:07.156, Speaker A: So let's say I just open up my metamask and I fire a dollar off to this thing. This is going to fail now, right? It's going to fail because we don't have the receive function. But if we, let's see, I always copy and paste it. There's a perfect copy pastable example right here. Okay. Because right now it's not buying, right? It's only requesting to receive. Let me understand that.
01:33:07.156 - 01:33:40.880, Speaker A: Say that again. Right now, the person who goes to the vendor and enters the 0.1, they are not giving 0.1 of their ether or another token to receive 0.1 of your token, are they? I don't think I understand. So if I do 0.1 it's going to send the, wait, what did I do? What? I mean, I just need to reload something dumb.
01:33:40.880 - 01:33:58.016, Speaker A: What I mean is that if I have one ether and I want one of your token, I put there one, then I click send and my ether doesn't go down. Right, right. Because that's one way. Right. You need to do. Yeah, that's what I mean. You are not buying.
01:33:58.016 - 01:34:09.444, Speaker A: Exactly. You are just, hey, send me one. No, we are, we are buying if you do 0.1. Watch this. So I have eight. I'm going to do 0.1. I need to take it times ten to the 18.
01:34:09.444 - 01:34:39.984, Speaker A: That's the key piece. But then once I hit send, look, that went down to 0.6, right. I am actually putting ether in and we can see the contract is gaining ether. We can see that the balance of the contracts went up and it is gaining ether because we made this function payable and we're sending along this extra value with it. So yes, we are sending money to the vendor and the vendor is checking to see how much money we're sending and sending us that much ETH. But you were probably seeing, maybe you were doing one here and it was one way and you weren't seeing that.
01:34:39.984 - 01:35:04.900, Speaker A: This updates right here because it doesn't, because it's such a small amount. Right. You need way more zeros before it starts to show up in that list. Okay, I forgot what to say. If I try to send a dollar to this contract, it will fail because there isn't a receive function. If I try to send this dollar, it's going to say you don't have a receive function. Going back to how we made that function payable, we need to make our contracts payable.
01:35:04.900 - 01:35:20.984, Speaker A: So we need to add this receive function in here. Let me go copy and paste it again since I can't spell the word receive. I blame you french guys, by the way. It's such a hard word, I don't even know if that comes from French. Okay, here we go. Now receive is payable. Now this thing will accept funds.
01:35:20.984 - 01:35:42.212, Speaker A: So what we want to do, first of all, let me just deploy it like this. Basically it'll take money but it won't give us anything back. It's just going to take the money. But let's just prove that it can take the money. There we go. Our app will reload. And now if I copy this contract and I open up my wallet and I send it a dollar, it works, right? The money comes in.
01:35:42.212 - 01:36:20.064, Speaker A: Okay, so what we want to do here is actually execute the buy token function, right? So if someone sends money to our contract, it's actually going to execute this code. So without having a Dap, without having to call the buy token function, without anything, we could even point an Ens address to our vendor. It could be austinshitcoin ETH. Someone can just send ETH straight to Austinshipcoin ETH and it will get to this point and it will say, oh, he's sending in money. I'm actually going to trigger the buy token contract and let's go make sure that all works. Let's actually buy tokens by just sending money to an address, which is way cooler and much better. Ux, right.
01:36:20.064 - 01:36:44.836, Speaker A: No one has to kind of come to our app and trust our code or anything. They can basically just say, give me this contract address, this ETH address, whatever, and give me one dollars worth of tokens. And now we're going to have them, right? We can go here and we can check our balance and there's going to be whatever one dollars is equal to in ETH right now. Good lord. Okay, cool. So that's the fallback function. Now we're calling our deposit.
01:36:44.836 - 01:37:16.068, Speaker A: I think the next step, if we have maybe like 15 more minutes, we can cover just selling a token. And now our vendor is more like a liquidity pool, right. Our vendor basically holds some tokens and holds some ETH and you can buy and sell as you wish. And what this is going to teach us is the very clunky but necessary approve and call pattern. And you guys are used to using it, right. You've approved millions of tokens and die and stuff. But actually writing the code will really kind of illuminate what the heck is going on there.
01:37:16.068 - 01:37:44.748, Speaker A: So let's just get started. Just not even thinking ahead. We know we want a sell token function, right? And it will be public, it won't be payable, right. Because there's not ETH coming in and they're probably going to want to tell us how much tokens they want. So we probably want a UN 256 amount. So they're going to call this sell token function and say how much they want to sell to us. And what we're going to do is we're going to require, we're going to just copy this line that we know that works.
01:37:44.748 - 01:38:28.588, Speaker A: We are going to do not a transfer, but we're going to do a transfer from. And let's go look at kind of how that works. There's the transfer from right there and it has an extra field, basically a sender. And I think we already kind of alluded to this before, like the ERC 20 has this allowance that it keeps track of and you can approve some address and that gives it an allowance. And that's for this kind of clunky approve and call method. But what it does is it's going to allow us now to do a transfer from, and we want to go from the message sender to the address this right to our contract. So we want to say, I want to go get the tokens and give them to me.
01:38:28.588 - 01:38:58.564, Speaker A: And if anything goes wrong, right, we're going to blow up here just like you guys have set us up for. But if that goes correct and that all works, now we owe them some ETH. They sent us in some contracts. So now we want to do a message sender. Now I would normally do message sender transfer, but I'm going to do it this way since we've learned how to do this. And this is going to be amount, I think that's right. Let's see, does it compile? Go ahead.
01:38:58.762 - 01:39:01.460, Speaker B: Why is it not message value anymore?
01:39:02.520 - 01:39:29.736, Speaker A: Because the message value is how much ETH they're sending in. And in this case they're not sending in any ETH. They're actually calling a function and telling us to take tokens from them. It's a really weird paradigm. That's why it's so important to build this vendor contract, to understand the mental model between sending around ETH and sending around tokens. It's totally different. And if you start pattern matching, it's not going to work the same way.
01:39:29.736 - 01:39:50.292, Speaker A: Right. Like that fallback function does not, there is no fallback function for ERC 20s, eRc seven seven seven s and some new standards. Right. That does exist. But that is a great question and that's why we do this stuff, to kind of get the mental model and get your brain around it. So we aren't sending any money, we're not triggering off message value. There's actually no ether getting sent at all.
01:39:50.292 - 01:40:08.220, Speaker A: Tell right here. And it's getting sent from the contract back to the user. Let's see, what did it tell us? Something about. Oh, wrong argument count. Wait, 40. You have to pass empty string to the call. Look at that.
01:40:08.220 - 01:40:29.384, Speaker A: Goodness. What about like a zero X? Can I do zero X? Now? I'm just screwing around, but I want to see if it works. I have to send some kind of call data. No, it didn't even like that. What about if I put. No, that's not going to be right either. Okay, let's just go with the empty string.
01:40:29.384 - 01:40:32.964, Speaker A: Okay, cool. And what is it warning about?
01:40:33.002 - 01:40:45.480, Speaker C: I think you can do maybe B string, but that's no, outside of the quotes. But no, I don't know, like that or b quotes.
01:40:46.220 - 01:41:13.408, Speaker A: Oh, B. And then like this or something, isn't it like that? No, there is a way though. Yeah, you're right. You could say, but let's just go with those empty quotes. Awesome. Okay, now let's go to our vendor and let's go buy 0.1 worth.
01:41:13.408 - 01:41:43.464, Speaker A: By sending in some ETH. We see the contract gets the ETH, we see our balance goes down. Now how many tokens do we, let's see how many tokens we have. Let's take our address. So we have this many tokens. Now if I try to sell those tokens back, and basically I can get that same number by doing that, if I try to sell these tokens back, it's not going to allow because the allowance isn't there. Why did that fail? Because it gets to this line and it tries to do the transfer and we haven't approved the vendor to take anything yet.
01:41:43.464 - 01:43:07.408, Speaker A: So in a clunky and clunky blockchain fashion, what we have to do is take the vendor's address and come down here and approve the vendor to spend this money, right? So when you do a swap on uniswap, there's an approve and then there's a transfer, right? So the approve is actually going to the token contract and telling the token contract we're going to give an allowance to the vendor. Once I call this, now the vendor has access to transfer those tokens, then I hit send, you will see the balance goes down and I basically put my tokens back in and got the value back from it. And right here you're already thinking, man, we need the example UI, right? Instead of using this scaffolding, you should be building buttons, you should have an approved button. The approve button should just do this automatically. You can see how having this scaffolding here and having all these nice components, it's like an easy next step to just turn this into a DAP, right? To provide a nice user interface for your user and do this same step but with some extra goodies, right? Clean it up. One thing you can do, here's a little, I don't know, maybe the OGs will poo poo this, but you can actually craft this approve and this transfer in the same block. So you basically craft two transactions, one with a nonce of five and the next one with a nonce of six, basically an incrementing nonce.
01:43:07.408 - 01:43:45.616, Speaker A: And you craft both transactions at once. And basically we prompt the user, do you approve? And then we prompt the user, are you okay with the transfer? And they hit go twice, and in the same block, this whole thing could happen. So there is a way to provide a little bit better user experience. There's some gotchas, I think, with the wallet and the nonce and stuff like that, but it is a little bit nicer. Like, you can do a little bit nicer things when you're controlling the UX. Okay, what do we got for questions? How are you guys doing? How are we doing? Got to be about time for a beer, right? No questions. Does it make sense?
01:43:45.718 - 01:43:48.896, Speaker B: Well, I would have one if no one else has one.
01:43:48.998 - 01:43:49.650, Speaker A: Sure.
01:43:52.120 - 01:44:07.704, Speaker B: This Ux that you just described, where the proof transaction happens in the same block than the actual transfer afterwards, is there any daps where this is implemented? I've never seen it that way, only.
01:44:07.742 - 01:44:38.000, Speaker A: In the ones I build. I haven't seen anybody do it. Well, there must be an obvious reason why they're not doing it. So I made this x moon exchange where we bridged moons from Reddit onto XDI and then bridged XDI onto the main net, so you could bring in die and you could bring in your moons and you could exchange those. And I implemented this in that, and it worked fine with Metamask. It just gave me two prompts. I think what I did is there was like a 1.5
01:44:38.000 - 01:45:07.128, Speaker A: 2nd delay where one prompt leading to the second prompt, and I think it has to do with metamask, seeing the wrong knots or something like that. So what you do is you prompt for the approve, and then you set a 1.5 2nd timeout, and then you prompt for the send. And that works. And it did work in that app with Metamask. And I bet, honestly, we probably do see that pattern implemented, or maybe there's a really good reason why you don't do it, but I've done it in my app so far. But really, that's just like a side quest that's not even important.
01:45:07.128 - 01:45:34.132, Speaker A: The important stuff here is we created a token. We created a vendor. The vendor can buy and sell the token. We kind of learned that approved pattern, and hopefully we learned how to kind of be confident with scaffold ETH. And you guys could kind of go async and kind of build some things. I would say, like homework assignment, go build that decentralized bank kind of do what we've done here, just go through this process to understand it. But in the repo, it just explains it straight out.
01:45:34.132 - 01:46:14.448, Speaker A: How to build a few different things, including learning more about events, learning more about how to work with the UI and how the components work. You could go to ethersjs and write your own little scripts. You could go to hard hat and just do some hard hat isolated stuff. But then get into structs, get into arrays of structs, build yourself like your own multi sig wallet, and then eventually we'll deploy. I think we should have another session, and I think you guys should build a bunch of stuff. And then we should come back in like a week or two. And in the next session I'll show you guys how to deploy your scaffold ETH projects to a public network and how to deploy your app.
01:46:14.448 - 01:46:22.230, Speaker A: So anyone can go to just like a website and interface with your contract and your token and your whole app. Really?
01:46:23.480 - 01:46:37.690, Speaker B: That sounds amazing. Would you also recommend to do the wallet with ethos Js before doing this decentralized bank you said would be good to start with that.
01:46:38.300 - 01:47:07.964, Speaker A: It's sort of like just like tools in your toolbox, right? There are two different tools that you're going to want in your toolbox. There are two different side quests. It almost depends on if you need a script right now. Do you need a script that could receive money and send some value around? Right. Start building things that you'll actually use. Start building tools that you actually need. Maybe you do need like, I wish I had a script that was running that someone could send money to austinriffit ETH and it would split.
01:47:07.964 - 01:47:35.230, Speaker A: Like maybe 10% of it goes to some savings account and 90% of it goes to my normal account or something like that. Like some little thing you might use some little script that's like fun and interesting. Go on a side quest and build that thing. And also to add on top of that, I'm available anytime. I'm in the Telegram channel. If you guys have questions, post them up there. There's a lot smarter people than me that can answer them better, but I can do my best job of answering what there is to answer.
01:47:36.000 - 01:47:49.420, Speaker B: Yeah, it would also be super cool at some point eventually to build something in defi, like a trading bot or flash loan, something that we can use afterwards.
01:47:49.760 - 01:48:04.800, Speaker A: Yep. Let's go. Baby steps, right? Let's get our token, let's get our vendor. I can show you how to do an amm next. Actually, there's a really good MVP. It's right here in the repo, actually. So you could see there's some tutorials that are kind of older.
01:48:04.800 - 01:48:39.184, Speaker A: This is one of those, but it's a minimum viable exchange. So basically the code is right here. It's uniswap, but the code is right here. And there's actually a bug in that picture, but no one knows about it. But what it does is it sets up an amm and it lets you deposit and withdraw liquidity. And you can also see that as I adjust the price, there's this nice little graph that shows how that Amm works, right? You've got reserves of both the token and ETH, and if you put in a little bit of this one, you get out a little bit of this one. And it uses a constant product to keep them together.
01:48:39.184 - 01:49:13.112, Speaker A: And also just launched, like before this call, let me go to my Twitter real quick. Just launched before this call is. Yeah, it's this right here. So my buddy Adam just put a new swap component right into scaffold ETH. So now you can just drop in this swap component and you basically get a uniswap swap component ready to go for you to swap between tokens, right. So there's a lot of stuff to explore. There's plenty of other things like rabbit holes to go down.
01:49:13.112 - 01:49:58.584, Speaker A: Oh, I'm sorry, I'm going on a million tangents, but I also want to show in the scaffold ETH repo, like all of those branches, there's tons of different branches, but a lot of these branch or some of these branches are explanations. So if I go to, I think it's signature recover. If you want to know how like EC recover, basically you can recover signatures in solidity, which is super dope. But what we do is it looks like Scaffold ETH and you get it all up. But then there's like a tutorial here and I walk you through the steps of how to use the UI to learn how EC recover works within contracts. And then from there there's like a meta multi sig and there's all sorts of other stuff. Have we talked about Nifty Inc.
01:49:58.584 - 01:50:28.604, Speaker A: Yet? There's actually products getting deployed to production that are built with Scaffold ETH, you'll notice. Look at this, look at this. It's the same exact interface, right? This is Nifty Inc. This is an NFT platform that we built that upgrades from XDI to the main net. And this is just like an NFT platform, but all of this is open source. And all of this uses scaffold ETH also. So there's kind of like this nice community of collaborators and composability kind of loading up around Scaffold ETH.
01:50:28.604 - 01:50:41.110, Speaker A: So even if you build something and you have a cool component, let's bring that back into the master branch for other people too. All right, guys, any other questions before I jump? Go. You got it.
01:50:41.800 - 01:51:08.676, Speaker B: I just wanted to say it was amazing, really interesting on my side. I have a feeling I really understood most of the solidity part. I think where we'll struggle most is actually the front end because I have no idea about how react works. I learned a bit of Ruby on rails and raw HTML and stuff, but I don't really know how these hooks work and components.
01:51:08.728 - 01:51:46.344, Speaker A: Let's do that. Let's do next session, next session. Our goal is learning front end and deploying our front end to a public network, right? So go async, build something cool with scaffold ETH. And then our next session, I'll show you all the kind of front end stuff, I'll show you all the hooks, I'll show you all the tools in the toolbox in terms of the front end, and I'll also show you how to put that out on. Basically deploy your contract to a public network and deploy your app to a public thing. And then we will actually share our app. So whatever it is you build, we'll build an app for it next week and we'll deploy that to an actual website and we'll use it.
01:51:46.344 - 01:52:11.540, Speaker A: So we'll cover that soon. I would say go async and just do that loop where you edit your solidity, you learn solidity and you poke at it. So just to ask suggestion from your end, because I saw that there are a lot of examples there and a lot of ideas what we can build. So if you would say top three, that would be kind of like the best round. Decentralized bank. Just first up. Just a second, budy, you got to give me a second.
01:52:11.540 - 01:52:49.292, Speaker A: 1st thing, decentralized bank. Build a decentralized bank that keeps track of a mapping of users accounts, let them deposit and withdraw. The second thing is do a to do list, anything, or a multi Sig wallet, anything that has structs and has a raise of structs. Okay. And then the third thing, build something fun. Like maybe it's a staking app where you have to get some threshold of people staked by some timestamps, somehow. Use the date timestamp, use the block number or the block timestamp and trigger off of that somehow build something that, like, you need to have a certain amount of ETH staked or then people can withdraw it.
01:52:49.292 - 01:53:00.596, Speaker A: But if they have enough staked, it sends it off to some contract or something along those lines. Down. Good. Basic rock pool, I guess. Yes. Thanks, guys. This has been great.
01:53:00.596 - 01:53:09.350, Speaker A: Was there a last question or. Yes, go ahead. No, thank you. Thank you so much. Okay.
01:53:09.960 - 01:53:10.596, Speaker B: Thanks so much.
01:53:10.618 - 01:53:11.540, Speaker A: Happy Wednesday.
01:53:11.880 - 01:53:12.852, Speaker B: Thanks, everyone.
01:53:12.986 - 01:53:15.136, Speaker A: Hit me a link in chat. See you. Bye.
