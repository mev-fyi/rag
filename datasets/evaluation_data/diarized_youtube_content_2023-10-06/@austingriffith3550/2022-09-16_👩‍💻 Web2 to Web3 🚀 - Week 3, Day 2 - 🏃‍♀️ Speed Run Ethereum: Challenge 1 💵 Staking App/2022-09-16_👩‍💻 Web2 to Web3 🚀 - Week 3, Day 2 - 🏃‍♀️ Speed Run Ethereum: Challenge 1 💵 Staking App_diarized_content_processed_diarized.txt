00:00:02.650 - 00:00:25.062, Speaker A: What's up? I'm Austin. I'm here with Carlos and Etta. We're on day two of week three, which would be challenge one of Ethereum. Let's dive in and look at Speedrun Ethereum and just kind of, like, talk through this first challenge. We don't want to show off the code. It's very important that you at home, the builder, has to really kind of think for yourself and write the solidity. But let's just go.
00:00:25.062 - 00:00:47.818, Speaker A: I think we've all gone through this challenge a couple of times before, so we can just kind of, like, talk through it. And I have kind of a finished example, too. Let's go look at it. All right, so speedrun Ethereum, hopefully you've been through this. You know how to tinker with solidity. You know how to kind of just tinker around and kind of learn things with solidity. Hopefully, you've been through challenge zero.
00:00:47.818 - 00:01:13.234, Speaker A: You learn things like burner wallets. You kind of learned how to just kind of, like, build something quickly with Scaffold eth. You've learned how to deploy to a public think. I think that takes you through that. You know, how to deploy an NFT. Okay, challenge one, decentralized staking. So, Carlos, you said that staking was kind of a new term to you when you came in, and we do see staking and value locked a lot of times.
00:01:13.234 - 00:01:22.786, Speaker A: Do you want to lean into that? Just talk through kind of? I don't know. Yeah, we'll get into it more, but I'd like to have your opinion on it. What do you think about staking?
00:01:22.818 - 00:01:52.914, Speaker B: Yeah. When I landed in Ethereum, all that I can heard was staking. Everyone have some kind of staking in the app or whatever. So for me, at the beginning was, so what is this staking? What is the meaning of staking? And maybe it's because I'm not, like, an active speaker, but staking basically means that you stake something. It can be like an NFT or it can be some tokens or some eth, and you usually get some rewards, right, for doing that?
00:01:52.952 - 00:02:18.886, Speaker A: Usually, yes, exactly. And another weird kind of theory. Kind of when you're locking your money up in another smart contract, it's still your money in a lot of ways, right? It's not like you're giving someone else control of it. You're basically putting it into this vending machine, this machine, this trustless machine. Right. You're kind of locking it up in a machine where if it's written correctly, no one else has control. Of it.
00:02:18.886 - 00:02:48.482, Speaker A: It's still your money, and it's still operating by the rules within that smart contract. And it's kind of just like a weird, I don't know, mental model to get over of this. Like, we see total value locked in a lot of protocols and how much money is locked in it. And if you want to take out a loan, you usually have to deposit some kind of over collateralization, like put more money into it. Okay. And another really interesting thing along with staking is trust. Trust is kind of like something that we're really going to kind of lean into here.
00:02:48.482 - 00:03:19.994, Speaker A: Thinking about this vending machine that we're programming. It's sort of like we're programming a machine or we're putting our tokens into this machine that plays by these rules that is not owned by anyone. There's no particular person that's in control of this machine. It's basically owned by everyone. And it follows the rules that it's owned by no one, and it follows the rules that we create. So this trustlessness is really important because you can do things like escrow. Like when we think of escrow and trust.
00:03:19.994 - 00:04:01.626, Speaker A: If Carlos wants to sell Edda a pair of shoes and Edda and Carlos don't trust each other, then you almost have to have this middleware layer where Carlos puts in the shoes, Edda puts in the money. And if the money and the shoes are both locked up, then they kind of go on to the next party, and Carlos gets the money and Edda gets the shoes. This idea of escrow is when you don't kind of trust the other person. You need this middleware layer. And a smart contract really operates as that middleware layer in a whole new way where now it's just this machine that we code up, and then anyone can interface with it from anywhere, and it just plays by the rules that it's written that it's coded in. Hopefully, I'm sort of explaining that. Right.
00:04:01.626 - 00:04:57.994, Speaker A: You at home, you will take on challenge one right here. And I think that we should even go through this. The superpower of Ethereum is coding up these little trustless machines, right? You're creating a vending machine that anyone can get to, and it allows you as the builder to create a simple set of rules that an adversarial group of players can use to work together. And you're really going to lean into that here in this staking example, because what you're going to do is you're going to build a contract that anyone can stake into, and you're hoping to get some threshold of value stored in that contract by a certain amount of time. So you're going to track time using block timestamp, and you're going to track everyone's balances using a mapping. And then if you get at least the threshold of ether by some timestamp. I don't know where the timestamp is.
00:04:57.994 - 00:05:55.962, Speaker A: Here. Oh, here it is. Here's the deadline. Yeah, by some deadline, then some new state is going to happen. It's kind of like if you think of it like a state machine, there's like this depositing phase and then there's some timestamp that once we cross it, we need to call some execute function, and at that time we decide did we collect enough money? And if we collected enough, we'll go to kind of a success state and we'll call some other function on some other contract and we'll send in the value, or we kind of go to a failure state, but still safe where we let people withdraw from the contract. So you as the programmer need to make sure you write this contract so no one can grief anyone else, no one can steal anyone else's money, right? We basically have this value locked. We have this timestamp when something is supposed to happen, and then after that timestamp, if there's enough value locked, we either go into one phase or the other.
00:05:55.962 - 00:05:59.278, Speaker A: Did I explain that? Right? Is there some more stuff to fill in? Yeah, go.
00:05:59.364 - 00:07:09.430, Speaker B: No, like you said before, it's a bit scary to send your Eth into a contract with more people money, right? So it's your money, but also like some other people's money. So it's a bit scary to think of how do we make sure that I'm going to get back my money, right? So I really like the last sentence that is on the first paragraph. Like the users only have to trust the code, which is true in Ethereum, right? That's the thing, you only have to trust the code because we are talking about all of this. But of course, when you interact with a contract, especially if you are sending money to it, you really need to understand what the contract is doing, right? Because for example, in this, in mind that there is like this sneaky contract creator that have a withdraw function and it can withdraw the funds from the contract without any permission from anyone, right? So that can be written into the code. So you just need to be careful and understand all the parts of the code, right, because the rules are there. But maybe some people want to make some sneaky rules for them for their benefit. So just to need to be careful on that.
00:07:09.580 - 00:07:54.862, Speaker A: Reminds me of the underhanded solidity coding contest. This happened a while ago, but it was very interesting where the person writing the smart contract is actually supposed to make it look like it's all written normally, but then kind of put like backdoors into their solidity code. Really cool thing to check out after you get through the speed run and you're kind of starting to think about more advanced auditing. Make sure to check out the underhanded solidity contest. Just some beasts there, some ogs. Awesome. Okay, should we look at the app? Should we try to stake something on localhost and see, you will follow these steps and you will code up your initial smart contract and just follow these goals.
00:07:54.862 - 00:08:24.414, Speaker A: Each one of these goals kind of takes you through what you need to do. The faucet was a little bit goofy. Let me show that off. If I grab this person, and I can do that right, I can hit the grab funds from the faucet, but I can also go down here and paste it in. One thing I noticed that if I hit send and then I hit send again, I've started get failures and I'm not able to clear this out too. So we have a little bit buggy faucet that we need to attack. So if you get to this, you run into that problem, you beat us to it, but I bet we'll get it fixed soon.
00:08:24.414 - 00:08:48.740, Speaker A: But you'll need quite a bit of eth for this since we have a threshold of one eth that needs to get locked in the contract. So one trick that you could do is just head down to this faucet, that faucet down in the bottom left, and you can paste in your address and just set yourself up with like ten e or something like that. So you have plenty of value. Let's see that. Come in here. There we go. So that's just one little trick tip or trick along the way.
00:08:48.740 - 00:09:20.650, Speaker A: So let's see, that was one of them. Let's just go through kind of what we're looking at. So we have some deadline. You'll have 30 seconds after you deploy. Obviously, if this was a production level thing, this would be more like seven days or 30 days, but we want it to be quick because we're working on localhost. At first, this is kind of a big scary line, but it shows you how to call the complete function on this external contract and pass in the value of basically everything that's locked into the staking contract forwards. On and goes into this contract.
00:09:20.650 - 00:09:25.842, Speaker A: And this contract, by the way, is not very insecure. Right?
00:09:25.896 - 00:09:26.066, Speaker B: Yeah.
00:09:26.088 - 00:09:54.474, Speaker A: So try to just imagine this as some secure third party contract that you're staking into. Not like, oh yeah, we're flipping a bull and now it's true. And you can call this over and over again. So there's no security in this function. Just imagine it like an external contract that you're staking into some other third party kind of, it's another vending machine somewhere else. Don't worry too much about the security here. And that is brought in here.
00:09:54.474 - 00:10:27.634, Speaker A: Right. Here's to that interface. We're importing it and then we have an interface to it, and then we set it up by initializing it, by sending in the address of that other contract. Okay, so let's see, what are our goals here? Basically what we want to be able to do is stake into this contract. Now there's no time left, so I'm going to redeploy it. We only get, here's another got you the reset. You'll find yourself deploying and it'll reuse the same contract, the same contract where the time has already ran out.
00:10:27.634 - 00:10:35.350, Speaker A: So if you need to reset your counter, you need to do a yarn deploy reset. Another little tricky thing that you'll run into.
00:10:35.420 - 00:10:52.466, Speaker B: And that is because you are not changing the contract, right. Because if you make a change into the contract, if you don't specify the reset flag, it doesn't matter, right, because it will compile it again and it will redeploy. But in this case we are not making any change. We just want to reset everything. So you need to do like the reset flag?
00:10:52.598 - 00:11:12.014, Speaker A: Yes, exactly. If your contract code changes, then it'll automatically deploy. But if your contract code doesn't change, that reset will be needed. Okay, so we redeploy a new contract. We've got 30 seconds left. We can go here and we can send a transaction and we should be able to see the time go down. Right, but you got to get it within 30 seconds.
00:11:12.014 - 00:11:36.890, Speaker A: You need to be able to. I'm going to go ahead and stake half an ETH and I'm going to go ahead and stake it twice. So we make sure we get a full eth staked in by there's 11 seconds left. Heck, I'm going to stake another one. I'm rich. I got free testnet money. Okay, now by this time we should be out of time and we should be able to call execute.
00:11:36.890 - 00:11:57.806, Speaker A: If we think of the state machine, there's the deposit phase. And that goes until some deadline is reached. Right. And we keep that deadline, keep track of that deadline here. And then we call the execute function. And your execute function needs to make sure that the deadline is passed. And you can decide whether or not you track whether or not you've executed.
00:11:57.806 - 00:12:09.374, Speaker A: That's another thing. But then you call execute. And what it's going to do is it's going to move that money. There we go. We did it. This is a success. It's going to move that money into that external contract.
00:12:09.374 - 00:12:30.074, Speaker A: What you can do is you can spend a lot of time over here in debug contracts really looking at this. Let's go ahead and do that real quick, too. Let me deploy a fresh copy of this. And we'll get a new contract over here. We'll see that there's no money in it. And let's use, again, I'm using this debug contracts tab. Let's just stake like 0.1,
00:12:30.074 - 00:12:49.860, Speaker A: like a very small amount of eth. And we stake that in there. Now we can go look at our balance within the contract. Okay, there's that 0.1. If we staked another 0.1, we should be able to see that balance increasing, and that's important. And then we're also watching time left right as that goes down.
00:12:49.860 - 00:13:04.790, Speaker A: And we're looking at this external contract. Once we, let me actually put in, what do we need? 0.8 e man, 98 eth. I don't know. That should be enough, though. That should get us into the. Yeah, there we go.
00:13:04.790 - 00:13:27.120, Speaker A: So we have exactly one e stored in this contract. And then once we execute, we'll see that that one EtH moves out of this contract and into the external contract. And so let's do the failure case now. Right. Let's go ahead and deploy it and let's not get enough money together. Okay, so there we go. It's clear.
00:13:27.120 - 00:13:48.242, Speaker A: Let's go ahead and put in only 00:25 or something like that. And let's watch our full money here. So now we're down to 7.27. The zero point 25 is locked up. Now we're just keeping an eye on that time left. And if we try to execute early, it's going to say not yet. Right.
00:13:48.242 - 00:14:16.826, Speaker A: So we just kind of keep hitting this execute button until it happens. Now, in this case, we're going to move to the failure state and it should say we weren't able to get enough funds together. There we go. There we go. So now it is executed and it is open for withdraw. So we have this new variable called open for withdraw, and we basically just let people get their money back. So there's zero point 25 in the contract, we failed to coordinate.
00:14:16.826 - 00:14:41.590, Speaker A: We weren't able to get a bunch of jerks together to coordinate financially, so at least we'll let everybody withdraw their funds. So I have zero point 27, and when I hit withdraw, that should go back up to 0.5 something. Yes. There we go. So those are kind of the things you're testing. And go ahead and follow through with each one of these to dos and just make sure then there's kind of some fun questions to ask at the end.
00:14:41.590 - 00:15:15.874, Speaker A: But again, this is about creating a trustless machine that anybody can go talk to. Let people that don't trust each other just trust the code. Have the code, have our rules written correctly in the contract. So we track time correctly, we track staking correctly, and then we don't let anyone grief each other or attack each other or steal each other's funds. And then eventually you'll go to a public network and get this thing deployed, and you'll submit it to speedrun ethereum right here. Submit challenge. Oh, I'm not logged in yet.
00:15:15.874 - 00:15:46.954, Speaker A: First you'll connect, and then you'll submit challenge. Anything else I'm missing here? What other things? There's this send thing that needs to happen. Actually, there's a couple of things I'd like to talk to. I don't want to give away the code, but I do want to show a few gotchas. The first one is when you send eth. So in that withdraw function there where you need to send them their money back, you'll want to go to solidity by example, sending eth. Oh, man.
00:15:46.954 - 00:16:23.794, Speaker A: I didn't spell any of those words correctly, but luckily, here we go. And where's the sending eth? Yes. So this is one thing that you'll really want to zoom in. Normally you might do an address transfer or an address send to send out your eth, but really the correct way to do this is call. And you use some pretty weird syntax, but it's this right here where you do two address call, and then in value, you send the value along. This just helps because it sends more gas. You have a higher gas limit.
00:16:23.794 - 00:17:01.070, Speaker A: So then when the receive function is triggered and it uses a little gas on execution, the thing doesn't revert. Maybe we're mansplaining too far into this, but I want to just show some pitfalls. And another is this receive function. One thing that you'll want to do as you get toward the end is you build a receive function. And really all this receive function is going to do. I'm just going to give this one away because it's an easy one, is it's going to call the stake function. So if anybody sends any money directly to the contract without calling the stake function, you just call the stake function for them and that moves them into this stake function where they stake their funds.
00:17:01.070 - 00:17:04.020, Speaker A: I think those were the two big gotchas I found.
00:17:05.030 - 00:17:41.678, Speaker B: Yeah. Also something that also was like a gotcha for me was that you mentioned that you can think about a smart contract as being like a state machine, right? So the thing is that the contract itself can't change its internal contract, right? Because I don't know, maybe like web two developers, we always think about this like the cron. So let's set up a cron inside the contract so it can update or whatever. So I think it's important to mention that the contract always needs someone or some other contract to send a transaction to this contract to update or to change the state. I think that also was like a.
00:17:41.684 - 00:18:14.186, Speaker A: Big one for me, 100%. That is a great thing to bring up. And hopefully we've talked about the web two to web three kind of cron job idea in the video. If not, I might lead with that in the very first video once we shoot it. But exactly when you hear something like Dow and you hear the word autonomous inside of it, you think this thing is actually automatic. And there's nothing about blockchain that's automatic. Everything is a transaction and everything has to be initiated from some externally owned account.
00:18:14.186 - 00:18:49.800, Speaker A: Sometimes you'll go externally owned account into contract and then contract to contract, but know that everything has to happen from an externally owned account, signing some transaction and paying some gas. So when we talk about our state machine, we're in a deposit phase to move into the withdrawal phase. It doesn't happen automatically. At some certain time. We set a rule that says anywhere after this time, someone has to poke this thing to move it from the deposit state to either a success state or a withdraw state. And that's that execute function. That's a really good insight to lean into.
00:18:50.330 - 00:19:28.350, Speaker B: But also keep in mind that we already know how to write some scripts, right, to talk with this contract. So you could, if you want, imagine that I'm like the owner of this contract. So it's on my interest that whenever the time is right, I want to press execute to get the money, right to fund the other contract. So you could, if you want to set up a cron job like the web two style in your server to go to this script and check the time left or whatever and make a transaction automatically from your server. Because we already know, we already saw that last week, I think. Right. So we know how to write some script.
00:19:28.350 - 00:19:52.700, Speaker B: And I'm going to select a side quest of a sidequest here. You could write some scripts here if you want in this challenge. It's not required, but you have the scripts folder there. So just go there and try to call executor whatever from there. I think that's a good side quest to make. So you can remember some of the stuff that we saw on the scripting week.
00:19:54.990 - 00:20:44.854, Speaker A: Awesome. Yes. Incentives are important, right? Like in this case, people are probably maybe naturally incentivized, but if you really want someone to call that execute function and you really want it to work well, you may have something like a reward here that's worth something like 1% of the contract, right. And then whoever calls execute, you make sure it can only be called once and it has to be called after some timestamp gets paid some reward for doing so. Then it's the combination of correctly written rules in a machine that no one owns with incentives on top of that to incentivize folks to make the click and make the behavior. And then you take that script that you've written and you make it super open source. So then anybody can just run some open source script.
00:20:44.854 - 00:21:19.762, Speaker A: Maybe even someone rewrites the script, right? So there's not some weird bug and we're all homogeneous all the way across. It's like, let's have multiple people write different scripts to make sure that it gets checked in. And you probably will still get front run by some mev bot that's like, oh, this guy's making a transaction and making $50. What if I make that transaction with a little bit more gas? But that's good. That means your execute function gets called even earlier. Awesome. Anything else we want to fill in here? Anything else on challenge one, it really is like, this is a quintessential starting point for blockchain.
00:21:19.762 - 00:21:46.960, Speaker A: Once you've gotten through all of this stuff, you can write a little solidity. You can write some scripts. This is the very first, best challenge. And you'll have to sit down and you'll get to this point right here where you write, okay, I got to make a staking function. Okay, what is this going to do? And you've got your blinking cursor ready for stake, right? You need to get to that point, and you, as a developer, need to write the code yourself. And it's important for you to fill in what happens in the staking function.
00:21:47.890 - 00:22:18.278, Speaker C: A few things I can add is what really helped me was before getting to the code was just like having a design of how it actually works. When you start the staking period. After the staking period, you can't stop. When we talk about it, it's easy, but when you go to the code, it's like, I had to have that design in front of me. So I'd highly suggest to kind of think about what's actually happening there. The code is actually pretty open. Like, you can see when you follow the steps, you can see what you need to add.
00:22:18.278 - 00:22:41.200, Speaker C: And one other thing, just looking at my notes over here, is I think this is, like, a really good first practice to study both solidity modifiers and events, because, yes, we did them a lot, but here you really interact with them and have to write them yourself. So I think that's, like, a really good challenge to recap the modifiers and events as well, and the next ones as well. But this is, like a first step.
00:22:41.570 - 00:23:09.340, Speaker A: I'm drawing some weird withdraw. Right? And then maybe you have a success over here. So you move from the deposit phase, and then there's some kind of check. Have we collected enough money? And if we have collected enough money, we go into this phase, and if we haven't collected enough money, we go into that phase, and you can't go back. This is such an ugly draw, but, yes, something like this, but better.
00:23:11.150 - 00:23:13.580, Speaker C: I like the colors, though. Like, mine was.
00:23:17.150 - 00:23:44.418, Speaker A: Like, I tried to make each build feel like you're, like, playing with crayons a little bit. So definitely going for that. Awesome. Anything else with challenge one? I think that's the way to go. So Edda's advice there at the end, just map it out, draw it out. So by the time you get to that point where you feel like you've got writer's block and the cursor is flashing in the stake function and you need to figure out what to do, you have those kind of diagrams, and you can make those choices. What happens when they actually stake the funds? Right.
00:23:44.418 - 00:24:01.346, Speaker A: Well, you're going to increase your balances, and then you're going to trigger an event, I think, is what's going to happen. And then you'll see it in the front end. Let me share that one more time. Let me show those events right here. Right here. Yes. Staking.
00:24:01.346 - 00:24:17.934, Speaker A: Events. So you'll see when someone stakes there. Let's go ahead and do that one more time just to see those events, just to show those off, because you're kind of looking at that to see what will happen. And if I stake one right, 1230, it's not letting me.
00:24:17.972 - 00:24:18.526, Speaker B: Oh, man.
00:24:18.628 - 00:24:34.978, Speaker A: I think I hit it too hard. Let's see. I got two of them in there, but you'll be able to see those staking events there. Awesome. I think that covers it. Any last thoughts on. I think it'll have you go all the way and deploy it to a public network, but hopefully you've done that with challenge zero already.
00:24:34.978 - 00:24:53.490, Speaker A: You understand? Yarn generate and funding that account. This will take you through that again and then deploy it and turn it in at speedrun ethereum.com and start building up your profile of web three builds. Awesome. We did it. Thanks, Eda. Thanks, Carlos.
00:24:53.490 - 00:25:00.782, Speaker A: We'll see you for the next challenge. Challenge what? Challenge two. We'll do challenge two next. All right.
00:25:00.836 - 00:25:02.254, Speaker C: Is it the decks? Yeah.
00:25:02.372 - 00:25:13.614, Speaker A: No, I think the next one is token vendor, then dice and then the decks. So we still have a few to go. You at home. You're going to learn so much. It's so great. All right, see you.
00:25:13.732 - 00:25:15.450, Speaker B: Take care. Bye.
