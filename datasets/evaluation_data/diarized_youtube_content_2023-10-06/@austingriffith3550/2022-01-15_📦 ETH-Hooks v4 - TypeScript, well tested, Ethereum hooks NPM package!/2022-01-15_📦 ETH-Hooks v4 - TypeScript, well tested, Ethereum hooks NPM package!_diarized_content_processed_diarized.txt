00:00:03.930 - 00:00:04.670, Speaker A: Okay, great.
00:00:04.820 - 00:00:08.160, Speaker B: Here we go. Siobhan, take it away. Eth v four.
00:00:08.930 - 00:00:43.930, Speaker A: All right. Hey guys, so I'm going to talk about ethics v four. Basically I've been working on it since December and I got some feedback on v three. So it's mostly based on how to make it easier for us and to reduce some of the pain points. So to focus in just overview for the principles of FIFOR, I just wanted to focus on a couple of things. The first is flexibility. So I know we have a lot of issues with over hitting the RPCs too much, things like that, especially when people are learning.
00:00:43.930 - 00:01:24.802, Speaker A: So I wanted to help have more flexibility for the hooks to update. Basically choose your update polling or every block number or like every ten blocks or whatever you want. So some flexibility on that. The second is the ease of use with context, and I'll go into examples more. So ether's app context was reduced in b three. And the reason I wanted to do that was just to make it easier for people to understand that they don't have to pass around provider and easier for new people to use it. And I do know that context is something new for somebody new to our space to learn if it's react.
00:01:24.802 - 00:01:53.466, Speaker A: But I want to show the way I've done it and it's actually very easy. They don't even have to know how context works in react to actually use ether's app context. And then what's new in v four is context for contracts. So I'm going to be going through that as well. And it's the same thing to be able to access your contract easily anywhere in your app. The third one is this is from feedback from v three. So compatibility for different ways of passing in ether provider.
00:01:53.466 - 00:02:42.782, Speaker A: So now we have context, but there has to be different ways for people to pass in provider if they need to or use a secondary provider. And these are all things that came up with multiple projects. Bliss brought this up for some of the products he had to work for in moonshot. So I was looking into that and the fourth one is again about the RFPC call. So really have some kind of caching layer. I noticed a lot of projects were using redox or some other ways to cache data, but I found it easier, much better way to use it. I'm using react query under the hood to cache any RPC calls so that you can use the hooks anywhere in your app and you don't have to worry about optimizing anything.
00:02:42.782 - 00:03:09.670, Speaker A: It'll automatically get data from the cache layer and doesn't make extra network calls. And the fifth one is typed contracts. It basically make it easier for noobs and anyone writing secure contracts not to make mistakes. So you don't call something the DAI contract can't do. You don't pass in parameters that can't do. And that's the whole reason for working with typed contracts. So that's the principles behind eat the hooks four for stats.
00:03:09.670 - 00:03:37.314, Speaker A: I just want to give some stats. So e three downloads are actually weekly. Downloads are actually the same level as v two. So v two is about 650 downloads a week and v three is about 500 downloads a week. And so people are using context. Right now, the JS version only uses v two, so that's something to keep in mind. So people are using the typescript version and v three, which is surprising because not a lot of people ask me questions.
00:03:37.314 - 00:04:05.494, Speaker A: So I guess it works. I have no idea. So there's that. So as an overview, there is an eat components v three that's updated to match v four. And the typescript repo has been completely updated to work with eathooks v four and eat components v three. So I'm going to go into some of these things. So the first one is the provider.
00:04:05.494 - 00:04:18.080, Speaker A: So right now, the new way that was introduced in v three was the ethers context. So there's an app wide context. And how it works is.
00:04:18.690 - 00:04:28.930, Speaker B: And when you say ethers context, it's not actually ethers js. Right. It's our own context that holds like contract. Say that again.
00:04:29.000 - 00:04:35.546, Speaker A: No, it's built on ethers. It's built on top of ethers. That's what we use in scaffolding anyways.
00:04:35.678 - 00:04:40.360, Speaker B: Okay, so this would be like a context that Rickmoo has set up within.
00:04:41.290 - 00:05:11.662, Speaker A: No, no, it's a context that's here, let me show you. Okay, so basically how it works is that we have a context in eth hooks. It uses ethers under the hood. So if you want to use it, all you have to do is wrap your main app with this. You don't have to set anything up. You don't have to do anything. And what that gives you is anywhere in your app you can call use ethers context, and you get access to the provider, the signer, the account, everything.
00:05:11.662 - 00:05:14.066, Speaker A: You need the price to actually function.
00:05:14.168 - 00:05:15.220, Speaker B: Cool. Exactly.
00:05:18.310 - 00:06:04.830, Speaker A: And then this is what all the hooks use as well. So you have access to the current context and you have access to the hooks going back. So that is what ethers context is. So I just wanted to iterate that the complexity is kind of hidden. They don't have to know how context works, they just have to wrap their app in it. So if we look at something more complicated like scaffold, there's different contexts in scaffold like Apollo and many other things, right. But for us in our app it's just imported and wrapped and that's it.
00:06:04.830 - 00:06:05.678, Speaker A: Right.
00:06:05.844 - 00:06:20.678, Speaker B: And the user can be like at their home page or whatever, and they could use the spread operator or whatever that is. And they can say price and read contracts equal the context and squiggly braces around it and it's loaded up.
00:06:20.844 - 00:06:24.498, Speaker A: Yeah. No, if you want to get price you have to use the price hook.
00:06:24.594 - 00:06:25.334, Speaker B: Okay.
00:06:25.532 - 00:06:32.554, Speaker A: Right. So for example, there's one for use, I think there's one quote use eth price.
00:06:32.592 - 00:06:33.770, Speaker B: There it is, Dex.
00:06:34.590 - 00:07:10.674, Speaker A: Yeah. Or there is something like if you want to use use balance, you don't have to pass in, but that was the v three way. So after some feedback, I also have another option. The library that we use called web3 react also allows you to have multiple contexts. So the big use for this is say you're on polygon and you need the ens from main net. So you would create a static RPC client and then pass that. So that would be your secondary context and there's a key to it and then you can use that anywhere.
00:07:10.674 - 00:07:49.250, Speaker A: So now v four supports that as well. So this really kind of helps with prop drilling. And usually most apps have one main context and some static context, sorry, one main provider and static providers like main. Net and BSc or whatever they are using right now. And that's the reason for this, it's to cover like the 80% case in this general way. And there's another way to override this as well. So for this I just wanted to ping out Jason because he was mentioning to me that he had some problems with the vanilla Javascript and prop drilling.
00:07:49.250 - 00:08:15.100, Speaker A: I can see this being very handy, trying to get an updated hooks version into the JavaScript scaffold for sure. Yeah. Right now in JavaScript we have to pass down the providers into all the components. Right. And so on. Exactly.
00:08:15.630 - 00:08:25.702, Speaker B: And a lot of this I feel like I see what you're presenting and I get it, but for me to be able to really know it and feel it, I basically just have to build something with this to be able to.
00:08:25.856 - 00:08:27.726, Speaker A: We have that on Monday. Yeah.
00:08:27.828 - 00:08:28.094, Speaker B: Okay.
00:08:28.132 - 00:08:30.026, Speaker A: We're going to be doing a speed run on Monday.
00:08:30.138 - 00:08:31.022, Speaker B: Sounds great.
00:08:31.156 - 00:09:06.778, Speaker A: And we can do both and both Javascript and typescript and we'll figure it out. The last one is for other people who need to use this and they have their own use cases. There's an override mechanism so you can pass in a provider just like you do in etox v two. So I'm just going to go to that example. So this is to provide people compatibility, right? So for example, I have two things here. One is use balance and this one's using the context. So you just pass in the account, you don't have to worry about anything else, right.
00:09:06.778 - 00:09:53.926, Speaker A: And it automatically knows you're signed into Mainnet and gets your balance from Mainnet. Or if you're signed into, say for example, in this example you've signed into Polygon and it'll get you a balance from Polygon. But say you want to pass in your own provider. So what you're doing is you're passing in the main net provider and getting this exists in some form in v two as well. You're getting an adapter which is like this composite object that has the signer provider chain id and I think not account address. And so you pass that into the use balance hook, the same hook. So you pass in the account and then you say I want to enable the override, so adapter enabled.
00:09:53.926 - 00:10:35.158, Speaker A: And then I want to pass in my own adapter. So that way you can do it the old way. But this complexity is hidden from new users. So someone who specifically wants to pass in a provider will be using this. So this is mostly for people who want to do something more complex or something easier. So the idea is to hide as much complexity from noobs as possible, but give also opportunity for other people to do whatever they want and have more flexibility. So for this one, say I'm building a project on Polygon, I would want to use a polygon provider and inject it here for my main net.
00:10:35.158 - 00:10:52.678, Speaker A: Actually, if you want to get the main net balance. Yet if you want to get your polygon balance, the user is already signed into polygon, so you don't have to provide anything, you just have to do it the way I did it in this line right here. So you don't have to pass in any provider. It automatically from the context.
00:10:52.854 - 00:11:29.720, Speaker B: Got you. I would say from a builder standpoint, when they get started with this stuff, it'd be really awesome if there's just like two or three examples in line where it's like here's the typical use case and it's uncommented and it's obvious, but then right above it or right below it are like three or four lines that are commented out that are like, all right, here's a couple of weird things you can do with this. Here's a couple of copy paste, just templates of how you might go about doing some weirder, more complex stuff. So just like kind of hitting on that. It'd be great if we could have kind of in line with the comments, some examples of how to use.
00:11:31.210 - 00:11:56.882, Speaker A: There is, I'm going to work with Jason with this, but in the typescript version there is a hook called scaffold lead examples. And literally this is just a bunch of comments and different ways of doing things, like exactly like you said. So I have tons of comments. This is how you do this. This is how you do this. So we can replicate this and put that into scaffold eat. So that's not in the main page, but the user can just go into this hook and find out all the examples that they can use.
00:11:56.882 - 00:12:36.414, Speaker A: So it's easy for us to direct them to it. And going back, I wish it didn't reset me. That's the first one. So this is just to give people flexibility on what provider they're going to use and ease of use. If they don't want to worry about it, they just sign in using the web3 modal and they just logged in as. It's kind of like the old web two stuff, right? You log in and you're logged in. So the secondary thing, this is one of the big things I was thinking about when I was making eth hooks before.
00:12:36.414 - 00:13:16.442, Speaker A: It's that there's a cache now it's part of ethers. So as long as you add that ethers context around your main app, you'll get this. And this will prevent any repeated calls to the network. So you don't need to pass in any variable, say at some part of your app. For example, in your main page you need the balance, and then you need the balance again in the examples page, or you need the balance again in some other page that's deep in your app. You can just use the hook now, you don't need to worry about it making repeated calls to the network, it's just simple. The user doesn't have to worry about it.
00:13:16.442 - 00:13:50.690, Speaker A: It automatically hits the cache and then it will use the cached value. It won't make a network request. I think that's a really big deal for us. It makes it easy for us to use hook and not have to worry about this mental overload of hitting the network too much. And when there is a network change. Say for example, the network has changed, the signer has changed, it automatically invalidates the cache so that you're not getting the wrong values. So all of that is built in using react query and built into ethers context.
00:13:50.690 - 00:13:57.190, Speaker A: So that's one of the big changes in before. Yeah, I'm hoping people use it and see how it is.
00:13:57.340 - 00:14:03.660, Speaker B: Well it should just work, right? People using it, they won't even know. Right. That'll be the best part. It'll just be more.
00:14:05.710 - 00:14:31.454, Speaker A: Calls. Yeah, exactly. I think some people like Adam noticed so he always bugs me when things hit the network too much. So I'm like okay, I got to figure out a better way of doing this. And before it felt like whack a mole, like oh, this hook was being called too much. There's too much use of it because there's something happening all the time. Like fuck, how do I prevent this? So the last part is updates.
00:14:31.454 - 00:14:58.378, Speaker A: So this is another big piece. In the past we had this on block polling in V two, but it was very complicated. Each hook had this complicated way of polling. So I made everything into. Everything is hidden from the user now. So there's option that you can pass into the hook. These are again, you don't have to worry about it if you don't care.
00:14:58.378 - 00:15:14.878, Speaker A: It'll just update every block. But if you want to manipulate that you can change that. So all hooks have these options and you can pass in if you want. Default is updating every block. You can also set it to update every 100 blocks. You can tell it update every thousand blocks. You can tell it update every ten blocks.
00:15:14.878 - 00:15:40.380, Speaker A: So Bliss was saying that this would be really useful in polygon because they have block time of 1 second or something like that. The other option is polling. I took it out in V three, but I added it back in v four. But it's a better way of doing it now. So you can poll. The minimum polling time is 10 seconds because I don't want somebody to accidentally spam the network. But you can set whatever polling time you want.
00:15:40.380 - 00:16:04.462, Speaker A: The thing is that if you set up polling, it'll disable the update on block. So you have to pick one. There are other options as well. You can tell the hooks to automatically refresh when the window is focused on so the user starts using the site again. If it was in the background or something you can tell it's refresh on mount. You can also tell that the data is going to be sale in 30 seconds. Update every.
00:16:04.462 - 00:16:48.270, Speaker A: The maximum time you can wait is 30 seconds. So there's all these other options that you can add in, and it's all part of the options variable, and it's only exposed to users if they actually want to dig in and do these things. This also ties into the third one, and this is something is about hook return. So right now the signature of the hook is returned. So before the on block was just, you get the block number right, or the balance, you get the balance number. Now it's kind of like you state, you get an array that is tuple of result and updater. So you can manually update, tell the hook to update, which is this, or you can tell the hook to, or you just get the result, so you can manually update in any part of your app.
00:16:48.270 - 00:17:20.360, Speaker A: How this works is that if I go back to this, so see here, this use balance is in an array. Now, it used to be that the use balance is like this, right? So this is actually what that means is that it's kind of like you state. So you have an updater. So the update is, updater is a function that you can call in your app to force your hook to update. And this is something that bliss and some other people asked me for, so I've added that into the system.
00:17:20.890 - 00:17:25.274, Speaker B: Is it a set function or is it a function you call to trigger it? Or how does that.
00:17:25.392 - 00:17:27.466, Speaker A: It's a function you call to trigger it.
00:17:27.568 - 00:17:33.902, Speaker B: Okay, so I just call updater or whatever and something else happens. It's not like I have to set it and send it a value.
00:17:34.036 - 00:17:36.734, Speaker A: Make sure you don't have to send it a value.
00:17:36.772 - 00:17:40.606, Speaker B: It's just something you trigger. Okay. That triggers everything to cool.
00:17:40.788 - 00:17:55.426, Speaker A: Yeah, I think there were some use cases for this in moonshot, so that's one of the reasons why I added it. And then there's some possible upgrades to this that I'm going to talk to bliss about later. But we wanted to get this version out.
00:17:55.528 - 00:18:37.218, Speaker C: One thing I wanted to point out, sorry to catch up, but one thing I wanted to point out in this case is if you can use one hook to manage multiple address, let's say for example the use balance one, and you want to have access to the balance of multiple addresses and utilize that. In some case, maybe you can use the updater and pass in like an extra address and your local balance object updates with that address and its balance. So you could just call your local balance pass in the address or the ENS name or something, and then it gets you the balance for that particular address. But it's still something that we're discussing a lot more and Chevron has done.
00:18:37.224 - 00:18:59.980, Speaker A: A great job at it. So that's good. Thanks. Yeah, it's something we will add as an update to view four as a minor update because it's not going to change the signature. But basically we have to figure out which hooks actually need this and then do it on a case by case basis, kind of. So we're going to do that later. The next part.
00:18:59.980 - 00:19:34.900, Speaker A: So that's the hook return the last part and then I'll do a quick demo and then go over what's done. And what needs to be done is the contract context. So there is a contract context. There's three ways of getting contracts. You can get the hard hat contracts, you can automatically get external verified contracts. So for example, you want to load Dai, you don't need to have the DAi API in your project. You just give it the address and give it the name of the contract and it'll get the contract for you.
00:19:34.900 - 00:20:14.574, Speaker A: And then you can also load contracts from ABI. For unverified contracts, the context automatically types this and then you can access that via hook anywhere in your app. So for this I need to actually show you the code. So I'm going to go to the typescript version. So how this is set up is that the flow is slightly different. So right now I have a configuration, and in the configuration what I have is like this is the simple typescript version, right? So there's your contract. That's a hard hat contract.
00:20:14.574 - 00:20:38.746, Speaker A: There's die and then there's uni. So this is a hard hat contract. So it has a special function to call it. This is external contract. So there is a file called external contract config. And I'm telling it that in Mainnet there's a contract called die and then this address. And I want you to get the API and the contract from it so we don't have to store this.
00:20:38.746 - 00:20:41.690, Speaker A: And it's using eats SDK under the hood.
00:20:43.470 - 00:20:44.890, Speaker B: Where is it getting it from?
00:20:45.040 - 00:21:03.700, Speaker A: It's getting it from etherscan or source. Depends. No, eat SDK does it. The guy who developed typechain is the one who did this project as well. It's been out for a few years, actually.
00:21:04.550 - 00:21:06.258, Speaker B: The death crypto guy, right?
00:21:06.344 - 00:21:06.946, Speaker A: Yeah, that's right.
00:21:06.968 - 00:21:12.020, Speaker B: What a beast. What a beast. Shout out to death crypto, whoever he is, someone.
00:21:13.030 - 00:21:13.634, Speaker A: Exactly.
00:21:13.752 - 00:21:14.660, Speaker B: Love it.
00:21:15.430 - 00:22:11.510, Speaker A: And then this is an example of loading just an external API and you can do that as well. So how this works now is that I'm going to clear all my contracts and what I do now is now I run yarn contract build. So it's going to, sorry, contracts. So it's going to build all my hard hat contracts and put the types into the app. It's going to get all the external contracts and create types for them and then we can do a yarn deploy. So see here, it's getting the APIs for ether scan, sorry Dai and Uni and so on and so forth. So now I'm going to split the terminal and then I'm going to do your yarn deploy as usual.
00:22:11.510 - 00:22:55.520, Speaker A: Maybe I have to wait for them. Okay, it's done. What that means is that, okay, so now I've created this configuration, I've loaded the data, it automatically has done this. And then anywhere in the app. So anywhere in the app right now this is all part of the ether's contract. Sorry, ethers context. This one loads the app contracts, this one tells it that.
00:22:55.520 - 00:23:25.686, Speaker A: Connect the contracts to Mainnet and connect the contract to the current ethers context. So now I can get a used app contract and then I can just pass in your contract and I get a fully typed your contract. So you guys are kind of familiar with this, like your contract and that's.
00:23:25.718 - 00:23:35.610, Speaker B: Across providers, which is kind of interesting. That list that you had to select was there's two that are on Mainet and one that's local. And you're selecting the one and it's going to know what to do.
00:23:35.760 - 00:23:55.186, Speaker A: Well you have to pass in the chain id. So right now I'm going to pass in the ethers context chain id. So I'm saying that I want your contract for this chain id. I just declared it twice. I'm just going to do this. So your contract you can call purpose. So it has purpose in it.
00:23:55.186 - 00:24:19.206, Speaker A: No one can make a mistake. It knows exactly what purpose is. It knows exactly what set purpose is. It knows that set purpose only takes a string. So if you're a noob or even if you're an extreme experienced programmer and you're developing like a production app, you're not going to make a mistake because it's going to catch it in compile time. So it knows that you can't pass in a number to this or something like that. So something more complicated is die.
00:24:19.206 - 00:24:52.020, Speaker A: Right? So I'm going to do const. Die contract equals use app contracts. This is also type. You can only pass in the contracts that you're defined. And I'm going to say I want this from Mainnet. So networks mainnet chain id. I spelled const wrong.
00:24:52.020 - 00:25:53.754, Speaker A: Die contract has all these things that are only specific to die, like allowance balance off because that's an ERC 20 token. Some generic stuff that all contracts have like estimate gas and stuff. That's all part of ethers, but you can mint for die. So only things that are specific to this contract is given to you. So you can do this for nfTs, ERC 720 tokens, whatever. So it just makes it super easy if you're using typescript, and even if you're not using typescript, you'll get autocomplete even though it doesn't check your types. For people who are learning this and for people who are making production apps and they want to catch issues and compile time, and basically the things that are needed to use this is this configuration file and then the external contracts list and then that's it.
00:25:53.754 - 00:26:45.722, Speaker A: And then you have to set up your contracts here in your main app. So you just load the contracts, connect the hooks and connect app contracts. Again, there's an advantage to this, so it also uses the cache so you're not going to make repeated calls to the network. If you call purpose 200 times, it's going to just get it from the cache unless you actually tell it invalidate or you have an update schedule for it and you can use it anywhere in your app, you don't have to pass around anything. You don't have to pass around your write contracts, you don't have to pass on your read contracts, you don't have to do anything. So v four still has use contract loader still has the use contract reader untyped, the older version. But if you want to use a use contract reader, there's a new one.
00:26:45.722 - 00:27:17.982, Speaker A: So use contract reader. So this is the cool thing about typing. So I have this use contract reader, right? I pass in your contract and I have to pass in the thing I wanted to call the function I want to call in that contract. And this is automatically typed properly. It's typed as a string and there's an update function. So if you do this you have purpose and update. So you can actually tell it to manual.
00:27:17.982 - 00:28:05.090, Speaker A: Say you know that the contract has been changed and you can tell it to go update manually, if that makes sense. Is it? You have a manual update function. The other advantage is that I see here that I'm passing in the filter for the event. So use contract reader can be updated on block or every 10th block or with polling, or you can tell it to update only when it gets an event that the contract has changed. So that's another improvement there where you can actually tell it to update the app, update all the values in the app and the contract actually has an event happen so you don't make a billion calls to the network. Do you guys have any questions?
00:28:05.240 - 00:28:23.254, Speaker B: It's awesome. I feel like again, the complexity, it looks like there's a lot abstracted away. It looks like that there's going to be some complexities here. It looks like it's going to work really well. I think this is the right way to go and it looks good. I don't have any red flags. It just comes down to I just want to get my hands dirty and build something with it.
00:28:23.254 - 00:28:34.570, Speaker B: And it sounds like we'll do that Monday. So I feel like this has been a good intro, but let's kick it down the road to Monday and build some stuff with it. And that's when I can really give feedback and figure out how it feels.
00:28:34.910 - 00:28:45.040, Speaker A: Yeah, and I think I'm going to pair with Jason to update the scaffold lead vanilla app. So I'll just pair program with him. He can do the Javascript early work and I can just.
00:28:45.730 - 00:28:53.346, Speaker B: I would love to. If you guys going to backseat drive good, let me know if we need more help there. That's awesome. I'd love to see.
00:28:53.368 - 00:29:17.882, Speaker A: Yeah, that would be great. Once the documentations are better, I'm going to actually reach out to people and the build Guild channel and scaffold channel and just do introductions to people or maybe make a recording and stuff like that. So just as a last part for updates, what's done. So etox four is feature complete. It's in scaffold typescript. It's already deployed. It works.
00:29:17.882 - 00:29:56.806, Speaker A: I've checked it with the basic apps. My next step is to try some of the challenges or update some of the challenges that mark has been working on or help him update it. So to do it and also teach other people how this works. V three of eat components has been updated to use this already. There are unit tests for eth hooks and they've been updated. So right now we have 24 tests but it's not full coverage, but it is more professional now it's like more dependable because there are unit tests. So people can actually start trusting this for production environment rather than just believing that we are doing a good job, I guess.
00:29:56.806 - 00:29:58.150, Speaker A: So there's tests.
00:30:00.170 - 00:30:18.240, Speaker B: It'll be great to have an external non scaffold eth library or build or template or something using this. Also to show that we've ejected all this cool stuff out of scaffold eth and you can use it in any app you want. You don't even have to use scaffold eth to get a lot of this value.
00:30:18.690 - 00:30:53.318, Speaker A: I think there is cool, but I don't know how to find them because the NPM usage doesn't match up to what scaffold downloads are. So I have no idea how to track these people down. But it would be nice to get feedback on how people use this and what they have found. The pain points and the good points to do is I need to update the documentation. I've started already. There is a website for the documentation, so this is in GitHub. I don't know if you guys can see it, but this is kind of like the document in progress for V four, but it was complete for V three.
00:30:53.318 - 00:31:20.702, Speaker A: But it tells you how ethers contexts work, how to use it. It has full documentation on all the signatures and stuff. So everything here is actually written in markdown. In each of these hooks, see, there's an explanation for how the hook works. Everything is fully documented. But for V three and V four, I'm updating this and how to use it too.
00:31:20.756 - 00:31:29.938, Speaker B: Is there like an example? It'd be nice to have some examples here. Just like a little. What Rick Moo does is he has a little cookbook. Have a little cookbook here of like, here's how you do this. Here's how you do that.
00:31:30.024 - 00:31:32.694, Speaker A: That would be an awesome. Actually.
00:31:32.892 - 00:31:33.590, Speaker B: Cool.
00:31:33.740 - 00:31:41.942, Speaker A: That'd be great. Yeah, I think I might need some help with that too. So if you know people who are good at docs, I can help them.
00:31:41.996 - 00:31:47.802, Speaker B: Yeah, I think we actually have a couple of folks coming in that are like technical writers too. Sean's a good one too.
00:31:47.856 - 00:31:48.218, Speaker A: Yeah.
00:31:48.304 - 00:32:05.866, Speaker B: Awesome. Okay, I got a dip. Awesome work, Siobhan. I look forward to Monday we'll do an actual let's get our hands dirty and build with this. But this has been an awesome introduction into eth hooks v four. And I'll probably just throw it up on YouTube for anybody searching eth hooks v four so they find this intro. But yeah.
00:32:05.866 - 00:32:08.420, Speaker B: Thank you very much. Thanks, everybody here.
00:32:08.870 - 00:32:09.280, Speaker A: All right.
