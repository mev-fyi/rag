00:00:02.170 - 00:00:14.478, Speaker A: Here we go. Okay. I'm Austin Griffith. Yeah, you got to do some of this. Some of this. I feel like this is a highly technical talk, so I feel like my silliness needs to fill in a little bit. I don't have as much technical stuff.
00:00:14.478 - 00:00:38.898, Speaker A: I'm a lowly application developer, and I try to build things on top of Ethereum. But this is a fun chat where we can kind of get into some of the details of what Zke is going to look like and what that's going to look like for an application developer. But first, maybe let's start in on just, like, some ZK stuff first, like an introduction, maybe. I'm Austin. How do I pronounce you? It is it. Yes.
00:00:38.924 - 00:00:40.460, Speaker B: Yes. My name is.
00:00:45.710 - 00:00:58.586, Speaker A: Okay. Awesome. So ye. Hi, Chen. How's it going? Welcome. Thank you for being here and talking to my caveman brain about ZK stuff. Okay, so here's my understanding of zero knowledge.
00:00:58.586 - 00:01:54.714, Speaker A: When I try to explain ZK to my five year old, I use the where's Waldo technique, where there's a big where's Waldo? And there's a big image, and he's hidden somewhere in the image. And I can prove to him that I know where it is with a big piece of paper that has a hole in it, that I moved the hole to show where the Waldo is, but it's covering where the book overall is. So you have a hard time of knowing where Waldo is there. But I can prove to you that I know where Waldo is. And the second analogy is the bouncer at the door of a bar, where I have to prove that I'm 21 years old to get in, but I don't want to show him my id that says my address. I put my id in a special. So I go out to the door to the bouncer, and I put my id in a special box that is the prover.
00:01:54.714 - 00:02:28.374, Speaker A: And that thing prints out a little receipt. And that little receipt isn't the thing that proves it. It's just some numbers. But then I give that receipt to the bouncer, and he puts it in his special box, which is the verifier. And out of that box it says, yes, this guy is 21 without ever having to reveal any of my other information. So you kind of have this prover and verifier, and there's this circuit that both the prover and the verifier are using. And that circuit has some public input and some private input, and then it has some output.
00:02:28.374 - 00:03:14.220, Speaker A: And that's the trick, is you can have that private input. And the information that happens inside of the circuit is a lot of times like one directional math, like a hash function or something like that, or some kind of proof. That's basically my level of ZK knowledge. I think there's also a little bit of there's zero knowledge stuff that's used for compression, and sometimes there's zero knowledge stuff that's used for privacy. And the roll up stuff would be like kind of the compression stuff. So that's like where my mushy brain, I think I have a very high level view of this stuff. But would you fill anything in there? In terms of the high level view? Is there more to talk about there, or should we expand on that and move forward? What do you guys think?
00:03:14.830 - 00:04:05.722, Speaker B: Yeah, I think those are very excellent examples. For what? Is there another proof and how you hide information? But actually, as you mentioned, there are two functionalities. One is hiding all information where you prove something, prove that you have this property, you are over 18, or something to a bar, or whatever property you have without reviewing your identity. But another huge benefit is that you can also prove this very efficiently. So for example, if I want to prove that my data belonged to a very complicated database, so basically you need to, for example, proof was all the entries. So you need to do a lot of computations there. But what do not proof can provide you another property that if you have this proof, anyone, any verifier can verify this proof strategy, even if your initial computation need to execute for maybe days, hours.
00:04:05.722 - 00:04:47.650, Speaker B: But your proof verification only takes you milliseconds. So that's why it can fit very well into this blockchain technology, because blockchain is all about public verifiability, right? Anyone can verify your transaction. So xeonaut proof can basically compress a lot of thing as your security input. They don't necessarily need to be secret, but also, even you don't want this privacy property. You just need to compress a lot of computation into one and make this proof become publicly verifiable. And any node can verify this small proof instead of re executing the large computation. So that's how you gain a huge benefit of efficiency, because you are compressing a huge amount of computation into a small proof.
00:04:47.650 - 00:04:50.198, Speaker B: And anyone can be the public verifier.
00:04:50.374 - 00:05:37.250, Speaker A: So another analogy, if we use our bouncer at the door analogy and the me with my prover, let's say instead of putting in my id, I actually put in thousands of hours of video, and it's thousands of hours of video of me growing up. It's like, here's me at age one, here's me at age two, here's me at age three, all the way till age 21. And basically I put all those years of video into this first prover box, and it prints out that little receipt with like four numbers on it. Yes. And then that little receipt can be used by any bouncer at any bar to prove that I have thousands of hours of video that prove that I have grown up and I actually am 21. Interesting. Okay, cool analogy.
00:05:37.250 - 00:05:38.502, Speaker A: Cool, exactly. Awesome.
00:05:38.556 - 00:06:30.540, Speaker B: Yeah. That's a very good example for how you can make that both privacy and also efficient, because you have this very small receipt to prove for large computation and maybe prove some property during your grow up. And so that's actually the key property we use in Zikirap when we are scaling ethereum, because we only need to compress a lot of transactions, re execution of those transactions into a smaller proof, so we don't actually need the key property. So that's why people gave Zikirap another name called validity Rob, because you just need some validity proof to prove something is valid. It's not for zero knowledge proof. When people are mentioning some privacy preserving, they kirap, they might mention like they kiro up, because first they k will be zero knowledge. The other is abuse term for this.
00:06:32.430 - 00:07:03.906, Speaker A: Zkzk roll up is both compression and privacy is where you start getting that. Okay, so I can see ZK EVM fitting in here, where we're just going to do a whole bunch of actions and we're going to feed them into the prover, and then there's going to be this little slip that proves that all of these kind of EVM actions were valid. And then is there then like a challenge period and stuff like, there's probably so many things to go into, but maybe we should just at a high level, how does the ZkeVM come into this?
00:07:04.088 - 00:07:09.846, Speaker B: Yeah, so Zke EVM is that you generate a proof from a very high level. We can dive into more detail.
00:07:09.948 - 00:07:13.014, Speaker A: We need to be at a high level for me to understand. Let's stay at a high level.
00:07:13.132 - 00:08:06.934, Speaker B: Yeah. So for example, you can generate one proof. So basically, assuming that you are application developer, right, and users are playing, interacting with your smart contract. So users send some transactions and after some ECM node receive these transactions through some RPC interface. So it need to re execute this transaction like on a guest node, right? Let's assume we just use go Ethereum as our node implementation. And so this transaction will be parse interpreted into some EVM bytecode, it will execute opcode by opcode to execute this smart contract logic, right? And so initially on layer one, every node need to reexecute this transaction to move from state one to state two. And that's a security guarantee you get from the decentralization, because there are so many nodes reexecuting the same transaction to move from the same state one to same state two.
00:08:06.934 - 00:09:08.774, Speaker B: But the problem is that such re execution is inefficient and because everyone needs to redundantly re execute that. So what the KVM can do is that instead of reexecuting all the transaction, you hide that or behind the door. So basically you receive, for example, ten smart contract transactions, and initially you should execute that on EVM, but instead you generate one thing to prove, to prove that those ten transactions are executed correctly on ECM virtual machine like to move from state one to state two. So from a high level, the public improve for the keywm should be your transactions, maybe ten smart contract transactions, and your old state, and also your new state after executing the transaction. And the proof will prove that applying those ten transactions to state one, you will get state two. And then you send this proof with some necessary data to ECM layer one. And then every node need to verify this proof and know that, oh, it's moved correctly from state one to state two without reexecuting.
00:09:08.774 - 00:09:42.550, Speaker B: And because it's a lot cheaper. So that's why you can be more efficient and how this scaling work. And as far as you mentioned, some challenging period. So basically optimism or optimistic rob, in general, how they are doing that is that they directly post state one and state two unchained and waiting for anyone to challenge whether if you post some crack like incorrect new states, right. So what they give up can provide you is that as far as you can provide this new state route with a proof, and it's verified to be correct, then there is no chance.
00:09:42.620 - 00:09:44.706, Speaker A: There's no challenge because it's verified.
00:09:44.818 - 00:10:03.118, Speaker B: Okay, but the latency come from, you need some latency to generate the proof, right? The verification computational, yeah. And so that's why you still have some wait for some time for withdrawing from layer two to layer one, because you need to generate this validity proof and wait for a verification on layer one.
00:10:03.284 - 00:11:02.222, Speaker A: Okay, so let me make sure I understand that. So right now, the current state of operating is I have my ethereum node right here. And anytime anybody makes a transaction to a smart contract to update some value, every one of the nodes all across the network run those transactions in a raw opcode way. But in this case, we're taking all that stuff that runs and we're running it in our own black box verifier, and we're printing out that receipt again, and instead we're sending the receipt across the network, the numbers that prove things. And basically anybody can take their prover box and put the receipt in and prove that that transaction works without having to run through all the verification of it. So it seems like this verification that's happening, is that happening on the client side, or is there like some verifier that you have to go to? Is it computationally intense? Does the verification process create centralization? I guess might be a question, yes.
00:11:02.276 - 00:11:05.430, Speaker B: So I think there are some slightly terminology.
00:11:05.610 - 00:11:08.194, Speaker A: Oh yeah, maybe I'm using them wrong too. Yeah, sorry.
00:11:08.392 - 00:11:25.254, Speaker B: So when you are generating this proof, it's actually a centralized large prover. Like for example, I'm running a large layer to node and I receive all the transactions, and I run some proving algorithm to generate this small receipt. So that's on the pro side. But anyone on the ethereum node will.
00:11:25.292 - 00:11:30.986, Speaker A: Be the verifier, because the verifying is easy, right? Yes.
00:11:31.088 - 00:11:44.646, Speaker B: And verifier need to be run by everyone because it's actually encoded. This verification logic is encoded on smart contract, so you need to verify that on smart contract. So basically everyone need to verify this and verify proving it.
00:11:44.688 - 00:12:17.254, Speaker A: A centralized prover is not really that big of a deal. The part that needs to be decentralized is the verifying, and everyone needs to verify easy. It's not that big of a deal if you send it to a centralized prover to get your receipt back, because it's the receipt, and it's getting the receipt to everyone else and having them verify it. That's the important part. This prover could go down and someone else could spend up another one, and it's a point of failure, but it's not a point of centralization. I don't know. I think I'm understanding what you're saying, though.
00:12:17.254 - 00:12:33.594, Speaker A: It's like the proving can be on a big machine or a set of big machines, but the verifying needs to be decentralized, and every node on the network, everyone at home, needs to be able to verify. But that's a quick and easy process thanks to ZK proofs.
00:12:33.722 - 00:12:36.560, Speaker B: Yes, exactly. That's correct.
00:12:37.570 - 00:13:18.490, Speaker A: Okay, cool. Yeah, I think I understand from a very high level as we get into this, maybe good questions might be what will change for me as an application developer or maybe even like what are some of the assumptions or new things that this unlocks as an application developer? Can I make games that have some bits of privacy to them? Can I make games that have faster speed when it comes down to it, when we have the ZK EVM implementation live and people can be hitting this, what's the difference for an application developer?
00:13:19.150 - 00:14:08.538, Speaker B: Yeah, I think Haichung can talk more about maybe on the concrete deployment side and what were changes and I can talk more about on the application side. So one thing like you can benefit on layer two is that you get some more instant pre confirmation because you are running a centralized proving node. All the transaction will be sent to a centralized node. So you will get some much faster pre confirmation, like for one block generation time as far as your transaction included, I will send you some pre confirmation so that you know it's already included there so you get better UI and UX. And also another benefit you get is that you can inherit this security and decentralization from Ethereum because everyone is verifying your receipt and because it's equivalent to re executing the transaction. So that's why you get this decentralization and security guarantee. So that's all for the application.
00:14:08.538 - 00:14:18.366, Speaker B: So basically you can do some more crazy stuff with lower gas fee and with a better pre confirmation within layer two. And Hai Chung can maybe talk so far.
00:14:18.468 - 00:15:05.406, Speaker A: So first thing is, since we can go to a centralized prover that can prove a whole bunch of complex actions and give me that nice little receipt back that I can send to anyone across the network and they can verify it. And first of all, I can verify it myself quickly, I can get the receipt, verify it, make sure it works in a verifier and then share it with everyone else. So because of that I get just like fast, it's like network bound, basically there's some compute bound on your side, but it's mostly network bound. And then you guys will scale your compute to handle it. So it's mostly network bound transactions. Instead of waiting for proof of stake or proof of work to happen, every 15 seconds I fire a network command and I get a receipt back from you guys. And that receipt can be quickly verified by anyone.
00:15:05.406 - 00:15:12.702, Speaker A: So first of all, just quick and just fast, right? Okay, cool, go ahead. Yes please.
00:15:12.756 - 00:15:43.994, Speaker C: Yeah, also I want to add in a little bit on the finality stuff. So if you look at our testnet, so currently we have three different level of the finality. So first of all, I guess pre committed, which means a block is included inside the layer two blockchain, meaning you send a transaction like RPC request to us and then we say, okay, now this transaction has been accepted and also included in the layer two block. And it's sealed in a layer two block. Then we call it, yeah, pre committed. So that means it's only included in the layer two. And then we're running the decentralized node right now.
00:15:44.032 - 00:15:45.580, Speaker A: But that comes back right away.
00:15:46.030 - 00:16:28.970, Speaker C: Yeah, that comes back can be very fast and then faster than the layer ones. And then the second layer state, we call, I guess committed state. So where committed state is, we roll up the transaction data to the layer one. That means anyone who, they can reproduce basically a layer two blocks with that transaction data. So that means it has more confidence that this block was included. And then you can replay this transaction and then know, okay, you get the same state route as we uploaded to the layer one, and then the third state will be the finalized, which means like you're already using the Zkevm to generate a validity proof. And then you upload this validity proof to the layer one and then being verified by a verifier.
00:16:28.970 - 00:16:50.878, Speaker C: Smart contract there. And then that means all the transaction within that block is finalized and it's sealed. No one can change that. It's definitely corrected, executed on the layer two. And then you don't need to really like using the transaction data to reproduce the block yourself to be sure that your transaction is correctly executed on the layer two.
00:16:51.044 - 00:17:19.830, Speaker A: So let me make sure I understand that we have like three levels of how committed and how solid your transaction is. I want to make a transaction on a smart contract. Basically I send that to your verifier and I get the pre commit back almost immediately. It's like network bound. I send my transaction, I get back a pre commit that says that it's in, then it's written on the l two, and then it's written on the l one. And those are kind of the three layers. Okay, cool.
00:17:19.830 - 00:18:13.450, Speaker A: Okay, just from a high level. That's a high level. Where can things go wrong? Let's say I make a transaction on a smart contract and I get the pre commit back. Can something break along the way where that pre commit isn't good? Or is it basically as the application developer? As soon as I get the pre commit back and it proves and it verifies correctly, I'm assuming that everything else down that line, down the chain will get committed. Can things fall apart there? Like what can happen there as a, okay, let's say it's a lottery and I just made the transaction that generated my random number somehow and I'm about to pay out the person. Do I need to wait? At what point do I make the transaction that pays the person out? And how can they grief the game or something like that? Just trying to think of this from an application layer development kind of standpoint.
00:18:13.950 - 00:19:04.310, Speaker C: Yeah, I think that's a great question. I think there's different level of confidence there. So usually once you get pre committed you just know like in the future you will be committed on the layer one. So that's like if you trust us and then you can sync pre committed, then the transaction, it should be included in the future and then the data will be uploaded us. But let's say you're making a very important transaction, you don't want to trust us and then you just want to wait. So one thing is you can do is you can wait until we roll up the data into layer one and you can run a node like yourself, a sequence of node, they just follow up on all of the data you uploaded to the transaction on the layer one. And then at that point you can re execute that transaction on the locally and then see if you get the same state route.
00:19:04.310 - 00:19:39.990, Speaker C: If that's right, you can get like a faster Kubernetes and then you can all like if it's not in a rush for your need, and then you can just change to the, you can wait for the final, you don't want to re execute the transaction yourself at a local node or if it's a mobile phone, you won't be able to do that. Then can just wait a little bit longer until that validity proof has been generated and uploaded and verified on the layer one. At that point I guess all the transactions definitely can be sealed and then no one can change that or touch that anymore. And then in that case you don't need to trust us and you don't need to re execute them, you just wait for the validity proof.
00:19:40.650 - 00:19:53.500, Speaker A: What kind of time are we? So pre commit is probably like almost network bound and a little cpu bound. And then the finalization on the l two, how long does that take? And then finalization on the l one, how long does that take?
00:19:54.110 - 00:20:05.920, Speaker C: Yeah, for the data availability. So for the committed estate you probably wait a little bit longer, probably most like 1 minute. And then you can just wait for, and then commit the data into the layer one.
00:20:07.410 - 00:20:13.742, Speaker A: You're committing to l one at least every couple of minutes, is that right? Yeah. Okay. Yeah. Sorry to interrupt. Right.
00:20:13.876 - 00:20:52.102, Speaker C: No, it's totally okay. To clarify things, and then for the final validity proof. Currently I take about 15 minutes to finalize, 15 to 30 minutes to finalize a state to generate a proof for that. And now somehow it's also depending on how much proving power we have in the network. But in the future, for example, if we launch a far future in a year, we think if we have enough improving power so that time will be within an hour. So usually that proof can be generated around the 15 to 30 minutes, and then you can just send in that proof to the layer one and that will be verified out there.
00:20:52.256 - 00:21:32.220, Speaker A: So if you had some very sensitive stuff and you had millions and millions of dollars you were about to pay out, you could set it to kind of close the lottery, get the random number, and then maybe wait even an hour before you do the finalize and payout, just in case someone's griefing the system somehow. Okay, cool. So you're writing to the l two every minute or you're writing to the l one. I don't understand how you're writing to the l one every couple of minutes, but you still want to wait for an hour of finality there. Maybe that's too far in the weeds to talk about, but if maybe you could hit it at a high level or explain it at a high level.
00:21:32.830 - 00:22:01.710, Speaker C: Yeah. First of all, every few seconds you can generate a layer two block, right? You accept a few transactions and pack them into a block, and then you can do like, what you can do is you can just getting those transaction data and then sending that to the layer one so people, everyone can download that block and also like transaction data once it's written in the layer one. So you cannot change in the layer two. Right. You already sending. Okay. After applying these transaction with those transaction core data, which we will switch from the original state route to a new state route.
00:22:01.710 - 00:22:03.762, Speaker C: That's like the on the layer one.
00:22:03.896 - 00:22:33.150, Speaker A: Transaction data versus transitioning to a new state route. And it's transitioning to a new state route that takes that half an hour, hour time. But transaction data is hitting main net pretty quickly. Within a couple of minutes, your transaction lives on main net, but there's not a state transition to a new route except for maybe every half an hour or an hour or something like that, which then bundles everything up and gives you one state route on chain that's fully validated. Okay, cool.
00:22:33.220 - 00:23:11.820, Speaker C: I think I understand. And then also adding just one more point is those transactions that will actually be used as a public input to verify your proof because you cannot say, I hidden everything as a private input. Then I just verify all those transactions. So you are never sure you are using the same transaction that you use inside proof. So those transactions that we roll up in the previous states, you will be used as a public input to verify your proof. Okay. You're actually taking those transient data and then using to verify the proof and then making sure the state root is transitioning to the correct new one from a high level.
00:23:12.590 - 00:23:44.242, Speaker A: Let me make sure I. Okay, so there's this circuit, right? There's the circuit. And the circuit has a handful of different inputs. And one of the most important inputs to the circuit is the previous state of the whole block. And that's very public, and everyone has that. And it's key that everyone has that to be able to do their verification. They have a very public previous state route, and you put in the previous state route and then whatever new transactions you have at the same time.
00:23:44.242 - 00:23:49.702, Speaker A: And then out of that comes a new state route, and that's okay. Making sure I understand that. Cool.
00:23:49.836 - 00:23:51.160, Speaker C: Yeah, that's correct.
00:23:51.930 - 00:24:19.162, Speaker A: Awesome. Okay, so let's see. As a new developer, it's going to be similar to other l two s or even side chains for me. I connect to an RPC and it's just like my transactions happen faster basically, but everything is pretty EVM compatible. I remember the difference between optimism and arbitrum. Gas was a little bit different. Like the gas limit when I deployed to arbitram.
00:24:19.162 - 00:24:32.450, Speaker A: Had to be a lot higher for some reason, but I ended up paying about the same amount. Will things like gas limit and gas prices be things that we need to worry about or think about as we're interfacing with the Zke EVM?
00:24:33.430 - 00:25:11.002, Speaker C: Yeah, we may like the tweak a little bit on the gas cost for the different opcodes. Sample certain opcodes, it's fairly cheap to execute them. But if you want to verify them in the ZkeVM, then it could be a lot more expensive. So maybe make a little bit small tweak to a few opcodes. But in general, it will be staying the same as the overall gas cost model for every opcode you have. So it's just like to prevent anyone trying to ddos the network. So you're just using those very cheap opcodes with gas cost, and it will just generating like you were spending a lot of cost to the Zke EVM.
00:25:11.002 - 00:25:14.674, Speaker C: And then basically that would be blocking the network. Like how many transactions can include it.
00:25:14.712 - 00:25:52.634, Speaker A: Inside a single circuit in a normal evm, with all of us having our nodes here anytime you store something, it's very expensive because all the nodes on the network have to store that thing. But what's expensive in this situation is the proving of the thing. And that prover is the cpu bound piece that you guys have to spin up. So what's an example of an opcode that's difficult to prove? Maybe that's two in the weeds, but maybe we could get example of just like storage is really expensive over here, but what's really hard to prove? Is it some mathematics stuff or what is it? Yeah.
00:25:52.672 - 00:25:56.030, Speaker C: So for example, one example is the catch hack of code, the sha three.
00:25:56.100 - 00:25:56.720, Speaker A: Okay.
00:25:57.490 - 00:26:06.078, Speaker C: Yeah. Hash function. So that's like using a lot of the bitwise operations. And that would be very expensive to prove that inside the ZK circuit.
00:26:06.254 - 00:26:31.180, Speaker A: Got it. And you also mentioned that your network has more proving capabilities. Now at first that would just be your centralized prover is spinning up, but it sounds like you're going to maybe even decentralize the proving, and other people will be incentivized to run their own provers and people could hit someone else's prover and get an example back. Am I thinking about that? Right? Yeah.
00:26:31.550 - 00:27:09.202, Speaker C: Okay. Yeah, that's correct. So the idea behind it is that you can generate the blocks very fast, at a very fast pace, and then you can keep a few recent blocks open for generating the proof. And then all the proof generation can happen in parallel. And then different parties, different community can run their own prover node. And then to get some task job like that we distributed from the network and then say, okay, you are going to prove the block number 100 and you are going to prove for the block 101. And then once you are both getting those proof generated and then sending out the proof, and then you will get some rewarded and incentivized to generating the proof.
00:27:09.202 - 00:27:20.726, Speaker C: And then, so with the decentralized proving network, we believe we can have support a lot of the throughput, and then we can also have all of the community to participate in our network.
00:27:20.918 - 00:28:07.334, Speaker A: And the trick there is just providing the correct incentives for folks and creating it so other people can run it. Okay, very cool. So at a high level as an application developer, I'm going to be going to an RPC, I'm going to be sending receiving transactions like normal. I'll be deploying smart contracts. The gas will be a little bit different based on how expensive it is to prove, not how expensive it is on the EVM, but it'll be very similar to that. It's not private. The stuff that I'm putting in here eventually lands on chain and is public, but it's fast and cheap and easy for me as a developer, and that's the key.
00:28:07.334 - 00:28:55.400, Speaker A: So it's still public, but the ZK we're doing here is compression and we're getting it. So you can do lots of things over on this l two and then that will now and then get verified with a state route on the l one, but it's just fast and cheaper over on the l two. I think I understand most of it, but I mean from a very high level, of course. What are maybe some other gotchas, things like randomness or things like what are some of the other gotchas with account abstraction, anything like that, that you guys do differently in terms of how randomness works or how account abstraction works or anything like that? Or is it strictly like EVM? It's going to work exactly like your EVM network works that you're used to.
00:28:56.650 - 00:29:28.660, Speaker C: So right now, actually we are just working as exactly what EVM looks like, which makes sense. First I want to make sure we're being compatible for both of our wallets, like metamask or other wallet you're going to use, and so you get same functionality. But actually we're also looking to actively researching about the account abstractions and I think we all believe I'll be like a future. So you feel like it can support all flexibility to those account, and then we're just looking to that and then we support and then rolling out the new research results there.
00:29:29.270 - 00:29:40.706, Speaker A: Cool. Awesome. So. So as a developer, it's easier if I just think of it as it's exactly the EVM, it's just going to be faster and probably cheaper.
00:29:40.738 - 00:29:41.858, Speaker B: And just think of it like it's.
00:29:41.874 - 00:30:22.642, Speaker A: The EVM, but faster and cheaper and let you guys handle all the details in there. And basically step one is getting it to work, and step two is getting it to work and having that prover be more decentralized or something like that. I'm assuming it's still decentralized like you guys said, because the verification is decentralized. And that's what's key is even though this node is getting every transaction, it can quickly verify it, but it has to run through everything. But the EVM is so simple that that's okay, but at a high level, at like an l two level kind of bandwidth, it wouldn't be able to keep up with that. And that's where the ZK proofs come in and make it easier. I don't even know where I'm going with that just kind of down there.
00:30:22.642 - 00:30:28.760, Speaker A: What else should we talk about? What else should we cover? What are some other blind spots that we have even from a high level still?
00:30:31.210 - 00:30:37.110, Speaker B: Yeah, I think that's mostly from the high level. They still had great knowledge side.
00:30:37.260 - 00:31:14.162, Speaker A: Okay, yeah, as a builder, great, we did it. You can tell at my knowledge I only have just enough. So as a builder though, I can just think of this as a new network. I'm just going to talk to it on an RPC. I might have to tinker a little bit with my gas limits and gas prices, but that'll be probably somehow built in or somehow pretty automatic for me. You have to know going into it. Is this a privacy preserving thing or is this a compression thing? This is more of the compression side.
00:31:14.162 - 00:32:29.450, Speaker A: So I know that my transactions will still be public, so don't assume anything's private there. But I think these are the concerns that I have as a builder is will my tools work with it as long as it's EVM compatible, it sounds like yes, and then what? The assumptions are about cost and gas and time, but I think we've covered almost all of that stuff. So basically I think if you guys gave me an RPC endpoint at this point, I'd be able to understand what I'm talking to and understand what I should expect and be able to just make transactions on it. Thankfully, because you're making it EVM compatible, then all my other stuff just plays with it normally. So I think that as a builder, I think I understand everything here and I think that if you released an RPC, I'd be able to start talking to it and tinkering with it. Are there extra tools maybe like the verifier needs to be a new tool that I need to learn how to use, or are there just new concepts that we didn't cover? It sounds like we've covered most of this stuff from a very high level, obviously. But can you think of any other things for an application developer that I should go research or I should learn more about to prepare myself to be able to build apps on ZKE evms?
00:32:31.070 - 00:33:22.542, Speaker C: I think one point is we're trying to hide everything complexity behind that. So from a developer point of view, you don't need to know about verify, about ticket proof, you just need to know what you're working on. You just know solidity and how to deploy your contract, that should be enough. But if you want to sample, to do debugging, and then once you know about how those status of different commit level of that. We have developing some front end website to show up. What's the current status of the block? Is it like currently stay as the pre committed, committed or finalized state? And this is showing that actual information to the users and then to the developers to see how is your transaction and how everything like that in the current status. Because that's kind of the actual things like the new to the l two than the l one.
00:33:22.542 - 00:33:43.890, Speaker C: So in the layer one you see everything like if it's included and then you can find out in the ESA scan like in the block explorer, then that seems should be good. Probably only thing you need to wait is like how many extra blocks to confirmation you have for that. But for layer two it could be slightly different because you need to do the roll up stuff. The rob status will be like a new things like to the developers and to the users.
00:33:44.230 - 00:34:22.240, Speaker A: It's interesting. Yeah. So even though it's EVM compatible, a lot of the tools work. But since there are a handful of very new things that you guys are working on and trying to keep that abstracted, there's going to be new interfaces, there's going to be a new ether scan for this that's going to be able to tell me in more detail about that pre commit and what stage it's in and as we get committed and how many blocks deep it is. Interesting. Okay. And are you guys building most of that? Are you trying to find a community to help build a lot of that stuff? What's the roadmap for some things, like an ether scan that shows this kind of stuff on l two?
00:34:23.010 - 00:34:52.140, Speaker C: Yeah, for the ether scans and we're collaborating with their team and then we're just also collaborating with other community members to build things and to make sure all of experience. And then we're also trying to collaborate with community as much as possible. Initially we maybe build some temporary solution to show up actual information, but on the role we were just working with the community and then to integrate with all of their tool set and their interfaces. And then we just don't change a lot to the user experience and developer experience.
00:34:53.470 - 00:35:54.350, Speaker A: Awesome. Usually when I talk to l two s as an application developer, as I'm thinking about how to build on an l two, I always try to think about what is the technology that makes it different than everyone else and how can I show that off. If it's an l two that does like high computational stuff, then I want to do like a whole game of life simulation that can all happen in a heavy compute and then come down to a single proof that it did end up at a certain state or something like that. Would you say that those are the kind of applications that you'll see deployed here? Of course, since it's EVM compatible, everyone will be deploying all their nfts and everything else here. But is there a specific application use case that works really well in your ZK evm, that if someone built it, it would be a good display of the EVM and showing the capabilities?
00:35:56.290 - 00:36:33.990, Speaker C: Yeah, I think that's also a great question. It's like table applications in general. We just want to support every application that people are working on and people are excited about. So those applications, which requires very high frequent transactions. Like high frequency transactions. Yeah, like a game, like social apps, but they both require a lot of the transaction throughput, but with the low cost, those kind of applications, I think will be very good on the ZK. But also sometimes the DeFi also sometimes say if the transaction fee is too high, then it will just stop some normal users and retail users to use play with that because of transaction fees.
00:36:33.990 - 00:36:48.080, Speaker C: And those D five applications, they also require very strong security guarantee. So those will be also very suitable for the ZK six, because the ZK is built to be secure and then inherit security from the Ethereum itself.
00:36:48.610 - 00:37:31.920, Speaker A: Great, that makes sense. So it's more like, I feel like Ethereum is moving more and more toward mainstream audiences as we implement these new kind of layers where things are cheaper and faster. And on l one, it's expensive and it's slow, but it's very secure. And then as we have these l two s, they can be just as secure because they settle to the l one. But we can have faster, quicker transactions. And the best application for that is something like games and social apps. But you can run all your other EVM compatible stuff here and it will work the same, but this will unlock new powers where you can have quick and fast transactions, like a game or a social app.
00:37:31.920 - 00:38:15.820, Speaker A: I've seen people building EVM games right now, and they're building them in roll ups on a side chain. So, like very cheap. Is there another level here that goes even farther? Where we have l one settling, we have l two, kind of rolling up a lot of information. Is there an l three that leads to basically real mainstream stream apps? If we think of Facebook right now, and we think of all the interactions that are happening on Facebook that can't even work on l two? Right. Do you foresee farther abstractions here, or what do you guys think will happen? In the future.
00:38:18.110 - 00:39:17.562, Speaker B: Yeah, I think that makes total sense. So I think comparing, if you directly compare with our layer two with a side chain, I think the biggest guarantee is still like we inherited the security and decentralization from layer one. Because my prediction for the gas based on our layer two will still be a little higher than side chain because that's what you pay for security, right? Because you still need to post your data on ECM. If you want to accept that, you can post your data, your transaction data, like another data availability layer or something like that, you can be cheaper than side chain. But if you still post your transaction data on ECM and following this standard Zikiro up diagram, it's still more expensive than side chain. But if you build something on top of layer two, as you mentioned, like layer three, you open even more possibilities. For example, if our layer two is the key EVM base, which means EVM compatible EVM equivalent layer, it supports solidity and everything that's running on EVM.
00:39:17.562 - 00:39:43.910, Speaker B: But on layer three, you have more flexibility. You can have different choice of VM models you are running as far as you verify your proofs on layer two cheaply. And also you get a lot of self control over this layer three, you can use any SDK and anything that you want to use. So I believe that in the future l three will be more suitable, especially for certain applications over sidechain, because it can offer a higher security guarantee.
00:39:44.570 - 00:40:19.870, Speaker A: That was my question. Basically, we're just waiting for the technology to be there. But these folks that are deploying mainstream like applications over on side chains or over on roll ups on sidechains will eventually move into this l two or l three world because of the security guarantees that you don't get that with a side chain. Yeah, that's what I was wondering is like, eventually this is going to be the right environment for those folks and they'll be deploying those same games, but those same games will now have the security benefits of l one. Ethereum.
00:40:19.950 - 00:40:21.940, Speaker B: Yeah, cool.
00:40:22.470 - 00:41:13.140, Speaker A: Awesome. Honestly, as a developer, I think that since you guys are doing all the work to make an EVM equivalent or compatible as a developer, I don't really need to know that much. I need to know some of the high level stuff like is this private or not? And what is this thing doing that's really good? And maybe even where are the centralization points now? And how can that be more decentralized in the future? But we've already covered those questions, I think, on this call. I think I understand most of them from a very high level, of course. But yeah. Anything else that we should cover? Basically if you gave me an RPC endpoint and sent me some money to one of my addresses, I think I would be off to the races and I'd be able to just build things. Is there anything else that would stop that or any concerns you'd have or should a developer just be watching for that RPC endpoint to come out in the future?
00:41:14.230 - 00:41:58.740, Speaker C: Yeah, I think developers can just waiting for the RPC endpoint, then we just will support the contract developer very soon. So another thing, one point we want to add is currently the sequencer. All of the block generations like l two block generation is centralized, but we also have the roadmap to make that decentralized as well. In the future everything will be decentralized on a scroll. And then that makes the pre committed even more confidence to pre committed because it will be pre committed to probably like a few blocks and then a few sequences and they will be kind of running a small pos in the future. That's giving the pre committed state or even more confidence to do that and also removing the trust and then from the essential entity from us.
00:41:59.110 - 00:42:43.230, Speaker A: Great, just like knowing that that's on the roadmap is important. I think for a builder to know that yes, it'll be cheap and fast right now, but there's some implications there of centralization. Of course the verifying is still decentralized and that's what's key. But the proving needs to be decentralized eventually. And if a builder is thinking about building on one of these different ZKe evms, they're going to have questions about which one is going to be most decentralized in the future or most popular in the future. So that comes up. Other questions for a builder might be like bridges, is there anything interested about bridging in or will that all work the same way as other l two s? Sorry, I think maybe you were going to say something.
00:42:43.230 - 00:42:47.586, Speaker A: First, we can talk about bridges. Second, if you've got something.
00:42:47.768 - 00:43:03.590, Speaker B: Yeah, just because you quickly mentioned know there are different leaky vms. And so we are only talking about this leaky vm version we are building with the privacy and scaling exploration team at XM foundation. It's called a community version because it's built totally in the open source way.
00:43:03.660 - 00:43:04.280, Speaker A: Cool.
00:43:05.210 - 00:43:51.270, Speaker B: But there are still some other key implementations. But so far we are the most closest to the Ethereum implementation. First our sequencer node. So as you mentioned, when you are sending RPC requests to this node, our node is directly a fork of gas, but other implementations are not. It's not necessarily exactly the same environment as gas. So for example, they might build their own executor and build their own interpret logic after receiving this transaction, and generally proof for their own logic, their own execution logic. But we are so far the only one which directly using a fork of gas, which makes that lower level compatible and make especially developer become more comfortable because it's not only the RPC interface will be the same, but also the interpreting logic will be the same.
00:43:51.270 - 00:44:43.686, Speaker B: And also another interesting feature is that there are different terms, especially in term of EVM. They are sometimes called EVM like bytecode equivalent. There is language compatible, there is a lot of terms, and I can elaborate a little bit more how that differs from the application level developer. So we are building something called bytecode level equivalence, which means we are directly pooling for the initial evm opcode execution opcode by opcode. But there are some constructions where you can only be compatible with solidity because you build a different virtual machine and you need some different compiler to compile your solidity to this virtual machine. So from developer perspective, they can still be language compatible because you can use solidity, but it's compiling to a different target VM and different executor. So that's something which make that difference.
00:44:43.686 - 00:45:21.314, Speaker B: So that's why people, I think Vitalik also classified that into different types where it's language compatible, bytecode level compatible, and eventually become ethereum equivalent because your implementation will be exactly like current Ethereum. So that's three different levels. And also that's also very interesting trade off due to the proving cost, because as we discussed earlier, shard three and catch hack. Those type of hash are very expensive when you are proving. But there is one type of hash function which is really easy to prove, like for example you just replace or something like that.
00:45:21.352 - 00:45:22.660, Speaker A: I see. Exactly.
00:45:23.990 - 00:45:50.506, Speaker B: And the pruning overhead for Mem say comparing with catcher can be 100 smaller. So that's why people are pursuing for they keep friendly hash function, but they sometimes break the compatibility. For example, you need create tool to compute some address and you need to do something like that. So that's a trade off between approving overhead more compatible, or you want a more efficient prover. So yeah, that's something I want to.
00:45:50.528 - 00:46:09.780, Speaker A: And there's nothing comparison, there's nothing I can do on the application developer side. All I have is catch act and I can just use catchack, but that's going to be expensive to prove. Are there other pre compiles coming into the EVM eventually that might be more MEMC friendly, or is that not even a thing?
00:46:10.870 - 00:46:26.054, Speaker B: Currently we want to support the initial pre compiles as some, like, we just build some specialized parts to proof for those pre compiles because precompet is usually very expensive, like pairing and those stuff. But we plan to support that wall.
00:46:26.172 - 00:46:48.346, Speaker A: Cool. Awesome. Great stuff. And yeah, I'm guessing bridges going on to the bridges. Bridges will work the same way too. Eventually you'll be able to. Again, I like how we zoom in and talk about something kind of cool and then zoom way back out to the caveman developer who's like, I just need to get an RPC and some eth so I can deploy.
00:46:48.346 - 00:47:14.738, Speaker A: And I think all of that stuff will work the same. Right? Bridges will work the same. The RPC endpoint will work the same. Gas might be a little bit different because certain things are a little bit different in terms of proving cost, but that will be built into the network and will be probably pretty agnostic to me as a developer. I'll just make the RPC calls I need, I think. Is that right? Yeah. You guys will handle all the complexity beneath the abstraction.
00:47:14.738 - 00:47:15.480, Speaker A: Yeah.
00:47:16.330 - 00:47:38.618, Speaker C: And I was talking a little bit more about the bridge. So, the bridge, there are two ways. One way is deposit from the layer one to the layer two. That would be like, work as similar as the other existing bridges. Like, you just wait for a few confirmations on the layer one. Then the fund will be actually, will be founded on the layer two wallet, and then the exit will be a little bit different. So the exit is like for the bridges.
00:47:38.618 - 00:47:45.502, Speaker C: You're just waiting for the block to be finalized, and then all of hash gets written.
00:47:45.566 - 00:47:46.034, Speaker A: Okay.
00:47:46.152 - 00:47:46.722, Speaker C: Yeah.
00:47:46.856 - 00:48:00.710, Speaker A: So it's not the 1 minute thing. It could be a half an hour or an hour, but then that hash gets written and the funds get bridged. So the bridges on the exit will need to wait for that state route to get written, is that right?
00:48:00.780 - 00:48:01.254, Speaker C: Yes.
00:48:01.372 - 00:48:01.846, Speaker A: Okay.
00:48:01.948 - 00:48:05.506, Speaker C: Wait for the state route to get it written and are being verified by the related crew.
00:48:05.538 - 00:48:26.170, Speaker A: Okay. Which is still only like an hour. Some of these roll up solutions for fungible assets. They create a market around them so you can exit quickly. But there's like a week long challenge period on some of these, right? There's no challenge here. There's no game being played. It's verified.
00:48:26.170 - 00:48:32.750, Speaker A: It's verified by the prover in the first place, and anyone can verify it with the verifier. Okay, cool.
00:48:32.820 - 00:48:47.814, Speaker C: Yeah, that's right. That's the point of the VK roll up. It's trying to reduce the breaching time. Avoid this one week challenging time. Just using the mass, prove the mass, secure the ZK proof to do that.
00:48:48.012 - 00:49:25.506, Speaker A: Awesome. Okay. I think my last question, I think I've already asked it and I think I've already gotten the answer. I'm always looking for what's something unique that I could build here that I can't build anywhere else? And we talked about like, just mainstream apps. It's going to be faster, it's going to be cheaper. Are there any secret moves or secret things I can do on this network that I can't do in other places? Or do you guys perceive any kind of specific applications being run here that wouldn't run anywhere else? Or is it mostly about it's all the EVM stuff. And the most important thing is just making sure we have that full compatibility and all the stuff you can do on evm you can do here.
00:49:25.506 - 00:49:29.460, Speaker A: Or is it all of that? Plus there's some secret moves that you can do.
00:49:32.870 - 00:49:36.642, Speaker C: I think right now we're just being EVM equivalent. That's great.
00:49:36.696 - 00:49:38.260, Speaker A: That's hard enough as it is.
00:49:40.630 - 00:49:42.822, Speaker C: But more fun stuff will be coming later.
00:49:42.956 - 00:49:56.506, Speaker A: Okay. It's not like something that's not like a promise on the roadmap or anything, but just from a high level. Just so I understand what kind of interesting things can be built into these in the future. Yeah.
00:49:56.528 - 00:50:19.730, Speaker C: So some thoughts in our mind. For example, we can support some new pre compiles or even something like new, which will be further reduced the cost of the whole transactions. Like for example, put some very useful, like a very common use cases into some pre compiles. And then you have a specialized circuit for that that can further reduce the cost of those transactions. I think that would be like some interesting things I could explore.
00:50:20.150 - 00:50:28.934, Speaker A: Awesome. Cool. Yeah. And it'll depend on the circuit I noticed when I was. Sorry. Go ahead. You got it.
00:50:28.934 - 00:50:29.654, Speaker A: Hit it. Let's go.
00:50:29.692 - 00:51:03.140, Speaker B: Yeah, I mean, just as we discussed earlier, it will open your imagination to build layer three and use any type of SDK. Because as a layer two, we still think it's still a base layer. Although like layer one is settlement layer, layer two is execution layer. Layer three, maybe for imagination. Like you can use any type of VM and you can use more like Ziki friendly virtual machine. But verify proofs are layer two and then you still inherit this security from. But I think layer two is still built for security, inherited decentralization and with a cheaper gas cost.
00:51:05.110 - 00:51:31.066, Speaker A: Awesome. Yeah, I think it's for building mainstream apps, or it's maybe the stepping stone that will lead us to building mainstream apps, and these apps will be somewhere in between mainstream and the current EVM stuff, and it will lead to kind of the next step of mainstream apps. I think that's a cool way to put it. Awesome. Okay, we probably better dip. Oh, actually, we're right at time. You guys.
00:51:31.066 - 00:51:44.590, Speaker A: Got to go. My last question might be, is there any kind of ZK ZK that you guys are thinking about when we talk about privacy preserving stuff? Is there any future roadmap of privacy preserving stuff within the scroll architecture?
00:51:45.010 - 00:52:16.440, Speaker B: Yeah, I think as far as we can support cheaper proof of vacation on our layer two, then we can definitely support, like, VK, VK Rop, and especially novel VK applications on layer two because we can verify their proofs or have a better compatibility model to interact with those applications. So that's our plan as a base layer. We just want to make sure that all the functionalities are working correctly and cheap and also build some cheaper proof application to support those VK applications built on top of us and things like that.
00:52:16.970 - 00:52:23.642, Speaker A: Awesome. Great. All right. Hi, Jen. Thank you guys so much. This is awesome. I learned a bunch already.
00:52:23.642 - 00:52:41.200, Speaker A: I have a lot more to learn, but I think from an application layer, you guys are doing all the work for me. I just need to deploy things and use the same tools I'm already using. I'm just waiting for it to be available, and then I can start deploying stuff. Thank you guys for being here, and thank you guys for letting me know.
00:52:41.570 - 00:52:46.506, Speaker C: Yes, thank you for having us. It's like a very fun, interesting session.
00:52:46.698 - 00:52:56.614, Speaker A: It's fun to talk about it at a high level and ask stupid questions. I've got a lot of stupid questions. Thank you guys very much. Awesome. Thank. All right, thanks. See you guys.
00:52:56.652 - 00:52:57.330, Speaker C: Thank you. Bye.
