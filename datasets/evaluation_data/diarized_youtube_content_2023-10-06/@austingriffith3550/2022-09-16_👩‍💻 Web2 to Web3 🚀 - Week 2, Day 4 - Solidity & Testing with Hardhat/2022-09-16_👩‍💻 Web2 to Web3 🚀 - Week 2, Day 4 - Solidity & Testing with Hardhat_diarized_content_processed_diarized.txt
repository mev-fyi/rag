00:00:03.450 - 00:00:31.442, Speaker A: I'm Austin Griffith. I'm here with Carlos and Edda. And we are. I don't even know what day we're on. We're like probably day nine of our day four of week two, which is about day nine of our hour long series or hour long sessions. Today we want to get you confident with tinkering, with solidity. And what do you mean by tinkering? I mean you write a little bit, you deploy it, you poke at it, you see how it works and you repeat.
00:00:31.442 - 00:01:02.960, Speaker A: Right. Lots of iteration and lots of tinkering. So I'm going to steal the screen just for a second. It's going to be more of a preview of Scaffold ETH that we'll do next week just because I've written something that I think makes tinkering really easy. But then we'll kind of zoom back out and look at other ways to tinker and then we'll zoom in on Carlos and we'll tinker mostly just with hard hat. So let me share my screen real quick and show Scaffold ETH. And in particular I want to show solidity by example.
00:01:02.960 - 00:01:17.362, Speaker A: So let me hit share. There we go. Okay, so here is Scaffold ETH, and this is just a preview. Don't worry. There's a lot going on. There's a lot going on here. What I want to show is that you make a change to your smart contract.
00:01:17.362 - 00:01:42.170, Speaker A: So I've got a smart contract here and I'm going to hit save and I'm going to go ahead and deploy that. And then over here are. Oh, man. Compounding interest, I have a whole bunch of stuff on this I need to probably reload over here. It's on coven. Oh, no, I was just doing a demo. Sorry, local host.
00:01:42.170 - 00:02:09.190, Speaker A: Okay, my bad. Let's show that again. Okay, there we go. Okay, so tinkering with smart contracts, you'll have a smart contract and you want to be able to make some small changes. Like this time I'm going to change this to all question marks. Right. And you'll deploy it and it will show up on your front end and you can kind of tinker with how that works.
00:02:09.190 - 00:02:39.534, Speaker A: Right. Maybe you want to create a counter or something. Okay, so the first thing we're going to look at probably is primitive data types. I think as a programmer, when you get in, you want to kind of understand the syntax first. And the primitives are probably the first place to start. So let's just say we wanted to look at integers and un. Let's just grab some un and paste it in, right? So solidity by example is the first place I'm going.
00:02:39.534 - 00:03:04.354, Speaker A: I'm grabbing a un, I'm pasting it into my code. I don't need any of this stuff right now. Let's just get rid of all of it. Here is my whole smart contract, just some counter. And then let's just make a function real quick called increment. And we're going to tell that thing, holy cow, here we go. To what? Counter plus plus, right? This to me is tinkering.
00:03:04.354 - 00:03:52.662, Speaker A: We write a little code, we deploy it, and then in our front end, we should see that show up and it should allow us to. Okay, we got a counter of one. And an increment should allow us to sort of increment our counter, right? And what if that is like plus equals two? Now all of a sudden our counter goes up by two when we click it or something like that. Or maybe we have some address, public county, and that's going to start blank. And then we set that to the message sender, which we will get to in just a second. We'll talk about globals, but the message sender is the person who's calling the function in solidity. And if I deploy that now, it's going to switch to me when I end up doing this.
00:03:52.662 - 00:04:16.718, Speaker A: Notice there's a county and it's set to zero. And the count. And as soon as I count, it's set to me, right? And this is tinkering. We're writing a little code. We're seeing it in the front end, we're poking at it, and we're getting kind of some instant feedback from it. So we'll get to scaffold ETH soon. I think the key here is just like, there's a lot of different ways to tinker, and hopefully Edda can show us remix also.
00:04:16.718 - 00:04:41.686, Speaker A: I think that's another cool way to tinker, really. You're just going to solidity by example. You're picking out some of these topics, you're pasting them into your contract, you're compiling and deploying, and then you're kind of like poking at your contract and kind of learning about it and kind of just like testing your assumptions. So that's scaffold ETH. That's one way to tinker with it. If Edda, do you happen to be able to. Oh, I probably have to set you to share.
00:04:41.686 - 00:04:50.790, Speaker A: There we go. Do you think you should show off remix for a second? And then we'll go to Carlos and we'll start speed running solidity.
00:04:52.570 - 00:04:53.030, Speaker B: Awesome.
00:04:53.100 - 00:04:55.826, Speaker C: I'm just going to share my should.
00:04:55.868 - 00:05:05.326, Speaker A: Where do we go for globals and units? We need to be able to have a good global units. There we go. There's remix. So this is browser based? Yeah, go ahead.
00:05:05.348 - 00:05:26.290, Speaker C: Sorry, exactly. I was just going to say it's an online ID so you don't need anything else. Just remix ethereum.org and it gives you some basic smart contracts which you can directly compile in the browser what Austin was doing with the deploys. And yeah, when you go there, it already has like a default workplace.
00:05:27.750 - 00:05:32.998, Speaker A: What's the contract in there? Yeah, if you go to contracts is there just like a contract we could see?
00:05:33.164 - 00:05:36.390, Speaker C: Maybe let's create a new one because I think this is bringing my like.
00:05:36.460 - 00:05:41.450, Speaker A: Oh, there might be contract. You don't want to alpha leak your new NFT.
00:05:42.510 - 00:05:57.550, Speaker C: I have something over there, but I'm just going to choose the default. Let's do this again. Zoom and yes. So it brings us like a storage solve, the sol extension, the solidity file.
00:05:59.490 - 00:06:08.340, Speaker A: I don't see anything changing. Oh, there, I see it now. I see your mouse moving there.
00:06:09.110 - 00:06:10.738, Speaker C: Okay, I shared the wrong screen.
00:06:10.824 - 00:06:16.120, Speaker A: I think that's what it is. Yeah, I think that's what it is. I was like, am I going crazy? I could be going crazy.
00:06:17.610 - 00:06:23.160, Speaker C: I had a wrong screen shared over there. Let me try again. 1 second.
00:06:24.970 - 00:06:29.078, Speaker A: Oh yeah, I got global units now too in the solidity docs. Okay, cool.
00:06:29.244 - 00:06:31.874, Speaker C: All right, do you see like my owner saw?
00:06:31.932 - 00:06:33.338, Speaker A: Yes, we've got it.
00:06:33.504 - 00:06:33.978, Speaker B: Super.
00:06:34.064 - 00:06:53.466, Speaker C: I actually just created like a new workspace. Let me do that again. So when you come here, it gives you like a workspace. I'm going to create Zoom too because I did it on the wrong screen. But you basically have like your storage Sol file and then owner and I think this is ballot.
00:06:53.578 - 00:07:00.900, Speaker A: Bunch of smart contracts. Yes, we've got structs and arrays and mappings, all sorts of things.
00:07:02.630 - 00:07:18.002, Speaker C: Yeah. And the cool thing is you can directly deploy the contract over here and also connect to your metamask and deploy it from your own wallets. But yeah, I think it's easy to get started. But of course, like online, so limited functionality.
00:07:18.146 - 00:07:48.358, Speaker A: Yes. So the goal here is just to get you the coder if you know how to program the syntax of solidity is going to be easy. We're going to give you a great introduction today. But the goal here is just like there's a bunch of different ways you can get started tinkering, whether it's scaffold ETH or remix or even just using hard hat locally. And I think Carlos can show us. That is basically just like you're going to write a little smart contract. You're going to run compile, you're going to deploy it locally, and then you're going to kind of poke at it on your local chain.
00:07:48.358 - 00:07:59.320, Speaker A: And you can do that with remix, you can do that with scaffold ETH, or you can do that with hard hat locally. And is it cool if we switch over to Carlos now and see the hard hat stuff? Yeah.
00:08:00.890 - 00:08:03.640, Speaker B: Let me check if I can share.
00:08:07.450 - 00:08:29.178, Speaker A: Either any of these different ides or environments. Right. You pick the one that you like the most. You're going to need some kind of environment that allows you to write solidity, compile and deploy, and then access that information in some way. And you're also going to need a handful of resources. The first resource is solidity by example. Solidity.
00:08:29.178 - 00:08:54.374, Speaker A: I don't know. If I drop it in the chat, do you think maybe I'll have it? Oh, you've got it up on your screen. Oh, and you've got the units in globally. The second thing you're going to need is units like these global units that are available to you within solidity, and then we'll just kind of go through the list. I don't know, maybe, Carlos, you might want to steer. I think you've got some ideas about how we get started. My gut feeling is like we would just do primitives and start pasting stuff in, but you take us away.
00:08:54.374 - 00:08:55.958, Speaker A: Let's go from here, we'll ask questions.
00:08:56.044 - 00:09:31.170, Speaker B: Well, I have to say that scaffold ETH is really hard to beat, right? Because you just deploy a contract and you have the UI right there. So it's super easy to interact with the contract. If you go with hardhat, that's like the hard way, right? Like you start the hard project and if you are really geeky like me, then it's more. Yeah, because it's like more low level, right? Like you are interacting with the contract, with your script. So it's like more low level, I think. But if you just want to play a little bit and tinker like, scaffold is great, but that's something for next week.
00:09:31.320 - 00:10:01.930, Speaker A: And if we even zoom in more, if you're a command line hero and you're writing low level stuff and you like that stuff, check out foundry. Also, foundry is a new one that's come out that's written in rust. That's even faster than hard hat. It probably lacks some of the deployment stuff, but I bet it'll catch up quickly. So just like putting that on everyone's radar, there's truffle, there's hard hat, and there's foundry and probably some other ones. But here we go, we've got it up. What do we have? We've got a node.
00:10:03.010 - 00:10:28.482, Speaker B: So I guess let's start with a new folder with day four, right? Day four and let's go. Let's install hard hat again. I mean, we are installing like hardhat and everywhere. And what happens is that then you are going to have your computer filled with all node modules folder and it's going to fill all of your space. But that happens.
00:10:28.616 - 00:10:40.854, Speaker A: I wrote a script that goes through and looks for node modules in my home folder and deletes it if it's a certain age. It was like 250 gigs on my machine, it was so much.
00:10:40.972 - 00:10:44.106, Speaker B: That's what happens when you tinker a lot, right?
00:10:44.208 - 00:10:45.100, Speaker A: That's right.
00:10:45.950 - 00:11:24.680, Speaker B: Okay, so let's start with installing hardhat. You remember from, I think yesterday we did like MPX Hardhat, and that setup can set up a new project with Hardhat. And we are going to choose the sample project, which is going to do a bunch of stuff for us like installing dependencies and the hard hat config file. And it's going to set up some tests, some scripts. So it's like a really nice way to start because everything is wired up for you. So you just have to start like writing solidity, which is what we are going to do today.
00:11:25.210 - 00:11:50.782, Speaker A: And I wonder if it relies on the Soul C compiler. But when I first got in, I didn't have hard hat or truffle. I built my own orchestration software from the start. And it's basically you use Soul C and then you have a bunch of orchestration scripts, right. That's basically what all of these are. But I think that actually some of them have rewritten. It might not even use Soul C anymore because I think they've rewritten some of the EVM stuff.
00:11:50.782 - 00:12:10.994, Speaker A: So then you can have things like console log and also with foundry, I think he rewrote it in rust, so it even runs faster. So even some of these old dependencies like Soul C that really got us all started are probably rewritten now in faster languages, but it's still installing.
00:12:11.122 - 00:12:16.326, Speaker B: Yeah, maybe we can start checking out some of this.
00:12:16.428 - 00:12:22.506, Speaker A: Yeah, right? Yeah, maybe. Hello world. What does a solidity smart contract consist of?
00:12:22.608 - 00:13:07.750, Speaker B: Oh, maybe we can also talk about the pragma, right? Like the version. So this is the same thing that we do when we install a new, for example, node dependency, right, that you say okay, I want to install something that is above this version. So this is the same, but just for the compiler. So you are telling the solidity compiler that you want to use this version or higher, right? I guess this should go until 0.9, not included, right. So that's very important because for example, all these overflow and underflow issues that we have like before 0.8, right? What is the library safe math, right, that was like the library.
00:13:07.750 - 00:13:27.280, Speaker B: So before 0.8, everyone needs to use this safe math library because we have these overflow issues with solidity. But now with this version and above you don't need to do that anymore, right?
00:13:27.810 - 00:13:53.110, Speaker A: Yeah, that's exactly right. I think if we have time today we should do like an unchecked math on a un eight and show some overflow. Let's put that up as a pin as a thing to show. But that's exactly right. We had overflow issues in solidity versions before seven, and they built it into solidity after version eight or above. So your contracts are going to change. So that versioning is very important of which one you're choosing.
00:13:55.130 - 00:14:34.334, Speaker B: And what else do we have here? This is just like the contract declaration, right? Like when you declare a class, you just have the contract keyword and the name, and then we have the first state variable. I think we talked about this the other day, but usually when you are thinking about object oriented programming in your node or in PHP on Java, whatever you think about this, that this will be stored in memory probably, right? This is going to be stored in memory and then you will store that into a database at some point. But in this case, all of these class properties are going to be stored on chain, right? That's what we call storage, I think like store variables.
00:14:34.382 - 00:15:00.220, Speaker A: Storage variables, yes, exactly. This class that we're talking about is actually going to live on thousands of machines when we deploy it. And this storage element is going to be stored on thousands of machines. And you can go to any one of those machines and say, hey, what's the greet variable? And it will say it's hello world. And so that's why it's pretty expensive and pretty redundant when you have thousands of machines all storing that information for you.
00:15:01.310 - 00:15:02.638, Speaker B: What else do we have here?
00:15:02.724 - 00:15:12.670, Speaker A: All right, first application. I'm surprised, no constructor. I figured the constructor would be the next place we go, but no, we're going to be functions, right?
00:15:12.820 - 00:15:13.520, Speaker B: Yes.
00:15:14.450 - 00:15:36.854, Speaker A: And we have a view function versus a read versus a write, right? A read, you can ask any node in the network and they can read. So reads are super easy and super cheap because everybody communicating peer to peer has all the information and you can ask any of them, right? So a read is very cheap, but a write is very expensive. When you have to write something. Yeah, you go, you go.
00:15:36.892 - 00:15:45.898, Speaker B: No, when you say read, it's cheap, it's actually free. Right? I mean, at least when you do like from your client, it's basically a.
00:15:45.904 - 00:15:50.250, Speaker A: Network call or even a local HTTP request to your node.
00:15:50.590 - 00:15:51.194, Speaker B: Okay.
00:15:51.312 - 00:16:02.110, Speaker A: Kind of like when we were writing the scripts, right, we would do a read and when I had my local node it was way faster because it was just hitting the node and responding right away instead of going to an API like infiro.
00:16:03.250 - 00:16:13.026, Speaker B: And what about this? Because for example, we have this count, this state variable, but we have the type. And what is this public? Is it the visibility? Right?
00:16:13.128 - 00:16:13.730, Speaker A: Yes.
00:16:13.880 - 00:16:22.690, Speaker B: So it's like in other languages. So how many visibility options do we have? We have public, right? We have private.
00:16:22.770 - 00:16:38.714, Speaker A: Private, immutable, I don't know, external. It's probably just public, private and external, right? Yeah, immutable is something else. I think visibility, here we go. Solidity by example will just show us. Oh, internal and external, yes.
00:16:38.912 - 00:16:39.994, Speaker B: Okay, that's good.
00:16:40.112 - 00:17:11.030, Speaker A: But the gotcha here is great big disclaimer, everything is public. We're writing this stuff to a public blockchain. So even if you mark something as private, that thing is not actually really private. Private means if someone inherits your contract and deploys a new contract, they're not going to be able to access that private variable. But everyone can see everything on a public deterministic blockchain. So just making sure we're not like private private, it's more like access and programming control private.
00:17:12.570 - 00:17:27.420, Speaker B: Okay, so you were mentioning also like this view, right. So what is that view? Because we have the function, the name of the function, then the visibility and then this view. I'm not sure what this is.
00:17:28.350 - 00:18:06.438, Speaker A: Thanks for the slow pitch, Carlos. By marking it as view you're saying, hey, we're not going to change any state here. This function, you're able to call it and get a value right back from it. When we call increment or decrement here, that's actually going to update that state variable. So that's a transaction and that's going to have to get mined into the block and a whole bunch of expensive things. But since this is marked as view, anyone can go ask that contract what the count currently is and it will immediately return you an integer and tell you what the count is. Does that cover it?
00:18:06.524 - 00:18:11.714, Speaker B: Yeah, I think so. And what happens if I try to put this view inside this sanction breakfast?
00:18:11.762 - 00:18:28.158, Speaker A: I don't think the compiler is going to like it. It's going to say, yo, you're changing some kind of state variable. This can't be marked as view. Or if you forget to put view on the get, you'll get a warning that says, hey, this can be marked as view and you can make it so people don't have to pay to call this function. Right.
00:18:28.324 - 00:18:51.266, Speaker B: And we also have pure function. Right. I mean we have view and pure. So the thing is that view is something that is going to return something from the state, but it's not going to change anything. But pure is something that doesn't read or change anything from the state. So it's going to be always the same. It's deterministic 100% because this view is not deterministic.
00:18:51.266 - 00:19:13.310, Speaker B: Right. Because you can have, for example, this changing x, so this x can change in the future. So this is going to be different each time you call it in this case. I mean, I'm not sure why you want to do this because it's going to be like expensive soon. Right.
00:19:13.380 - 00:19:16.320, Speaker A: A very expensive calculator adding for you.
00:19:17.890 - 00:19:27.810, Speaker B: Yes. Okay. So I don't know about you, but I'm starting to feel a little nervous and I need to paste some of this code into the ide and start like compiling and doing some.
00:19:27.880 - 00:19:28.926, Speaker A: I got a tinker.
00:19:29.038 - 00:19:30.290, Speaker B: Yeah, on a tinker.
00:19:33.350 - 00:19:54.220, Speaker C: Just one note I wanted to add there. I didn't realize before, but apparently on solidity by example, when you go to the contract, you can also directly open it in remix. Like there was the line below. Yeah, you have the Tryon remix. So I think that's just like to flag that. If you can just try it over there.
00:19:54.670 - 00:19:55.740, Speaker B: That is good.
00:19:58.590 - 00:19:59.578, Speaker A: That's awesome.
00:19:59.744 - 00:20:08.560, Speaker B: Yeah. I guess this will paste this code into remix, right? Bad.
00:20:09.890 - 00:20:10.686, Speaker A: Okay.
00:20:10.868 - 00:20:12.910, Speaker C: Or maybe just opens remix.
00:20:14.310 - 00:20:28.882, Speaker A: I bet it's in there somewhere. I don't know. Maybe not. No. I don't know. My grief with remixes, it's just so complicated. There's so much stuff here and it's hard to land here and feel comfortable.
00:20:28.882 - 00:20:43.180, Speaker A: But I don't know. Use the tool that. Whichever tool that gets you to the point where you're building and you're tinkering, use that tool. So I don't mean to be opinionated about the tools. Use whatever tool gets the job done.
00:20:43.630 - 00:20:48.874, Speaker B: But for example, let's see how easy is to paste this into hardhat project.
00:20:48.912 - 00:20:49.820, Speaker A: Here we go.
00:20:51.730 - 00:21:11.570, Speaker B: Okay, everything is installed now. So as we saw yesterday, we have like a contract. Some tests, some scripts, some configuration. So it's all set up for us. So we even have this contract. So we were talking about having view. Well, let's see if we do.
00:21:11.640 - 00:21:13.570, Speaker A: Yeah, maybe compile and run that one first.
00:21:13.640 - 00:21:22.570, Speaker B: I think this is our compile. Right. Not too fast.
00:21:29.250 - 00:21:37.634, Speaker A: It may be downloading the compiler. There we go. It's that slow every time.
00:21:37.832 - 00:21:49.320, Speaker B: Okay, so this is like a set greeting. So let's try to do like view. Right? We are talking about this having the view here. So let's see what happens if we do that.
00:21:51.370 - 00:21:52.600, Speaker A: Did you hit save?
00:21:53.130 - 00:21:54.054, Speaker B: Yes, I think so.
00:21:54.092 - 00:22:02.120, Speaker A: Okay, cool. Yeah, there we go. It's like, wait a minute, you're updating the state but you have this marked as view. Something's not right.
00:22:02.970 - 00:22:14.560, Speaker B: Well, they are nice. They say potentially modify the state. It's not saying that you are modifying the state. Potentially you are modifying it. Okay, cool. So I don't know what else.
00:22:16.290 - 00:22:37.598, Speaker A: Yeah, let's start copy pasting examples in. Let's start compiling and let's poke at those. I think the first app is great. The counter, I really like the counter because it's just like it's one un and you can increment or decrement it. And I feel like it really leans into. This is really simple code. Most validity is very simple, obvious code.
00:22:37.598 - 00:23:07.070, Speaker A: It's just the substrate on which it's running that's really complicated. The fact that you have a counter where you can increment the value is like, that's pretty boring. But if that value lives on thousands of machines and anyone can pay money to increment it, then it's like, oh, wait a minute. What kind of stuff can we build with this? What didn't it like? Something about your compiler version in hard hat. But this is good. We need to run into these problems and have. There we go.
00:23:07.070 - 00:23:07.566, Speaker A: Yeah.
00:23:07.668 - 00:23:19.540, Speaker B: So I think we have like eight, four here and here. Oh, this is 813. So I guess we have two options here. We will do this. Right? And this will work.
00:23:20.950 - 00:23:33.880, Speaker A: Yeah. Maybe set that to 84. Or if there's some new thing, we would need to just set that one to 813 and have hard hat. Let's see if it'll download it. Yeah.
00:23:36.090 - 00:23:37.080, Speaker B: Not here.
00:23:37.690 - 00:23:40.214, Speaker A: My assumption is it will download it and compile it.
00:23:40.252 - 00:23:40.454, Speaker B: Fine.
00:23:40.492 - 00:23:51.180, Speaker A: It may give us a warning that's like, well, this is like a really new version of solidity not fully supported. Yeah, exactly. It compiled, it compiled good enough. Ship it.
00:23:52.210 - 00:23:58.430, Speaker C: Warnings are not important as long as there's no error, like warning.
00:24:00.850 - 00:24:01.600, Speaker B: Okay.
00:24:04.850 - 00:24:24.630, Speaker A: Well, can we count now? How do we deploy it? Okay, so it compiles. Right. And basically compiling means it's going from this solidity that we can all read and understand into bytecode. Should we look at maybe the artifact that comes out of that? Just for a second. I think there's an artifacts folder. Cool. Yeah, there it is.
00:24:24.630 - 00:24:27.240, Speaker A: Either one of those, I think. Oh no, I'm sorry.
00:24:28.010 - 00:24:34.410, Speaker B: Yes. So here we have the ABI, we talked about it the other day, and the bytecode right.
00:24:34.480 - 00:24:51.200, Speaker A: There it is. That's actually the contract. That's what's going to live on. Chain is all that information right there. Right. Our little simple counter with one little state variable and two functions. One to increment that state variable and one to decrement that state variable is all of that bytecode right there.
00:24:52.050 - 00:24:56.370, Speaker B: So what if we create like a simple super fast test?
00:24:56.520 - 00:24:58.420, Speaker A: Okay, sounds good.
00:24:59.030 - 00:25:26.474, Speaker B: We already have this here. Yes. So let's call it well read counter. Maybe we need to change the name of the, change the name counteractor then. Okay, so what is this inside the deploy function? I guess this is the.
00:25:26.592 - 00:25:29.542, Speaker A: I don't think, I don't think there's any arguments.
00:25:29.606 - 00:25:35.738, Speaker B: Yes, this is the argument for the constructor. Right. But we don't have a constructor.
00:25:35.834 - 00:25:37.098, Speaker A: Yeah, there's no constructor.
00:25:37.194 - 00:25:42.510, Speaker B: Maybe we can add it one for example, by default, right?
00:25:42.580 - 00:25:43.200, Speaker A: Yes.
00:25:43.730 - 00:26:46.242, Speaker B: Let's first create the test and then sample counter. Okay, so this is going to deploy the control, right. The first three lines. And now let's call counter well ink transaction. And it's going to be counter ink. Then as we know, we can wait until the transaction is mined and then we can do like the assert or the expect. I guess the count is start at zero, right? I mean, we don't say that the count start at zero, but by default, when you declare a new variable, it start with some defaults, right.
00:26:46.296 - 00:27:12.286, Speaker A: Maybe a good mental model there is just thinking of like embedded programming. Like we're programming a little chip or something. And that chip has memory and that memory is empty, but it's not actually empty. Empty means zeros, right? So if we just declare a counter, it's just full of zeros, which comes up to zero. Right. And everything has this default value of zero because you have to allocate memory for it. And if you go ask that memory what the value is there.
00:27:12.286 - 00:27:13.518, Speaker A: It's going to tell you zero.
00:27:13.684 - 00:27:26.514, Speaker B: Yeah. So now if we do ink. Sorry. Counter count. Right, count, this will be equal to.
00:27:26.552 - 00:27:32.260, Speaker A: Equal one, I guess, right after incrementing. Yes.
00:27:32.950 - 00:27:35.986, Speaker B: Okay, let's see. Can do the test with.
00:27:36.088 - 00:27:45.080, Speaker A: You could even expect it to be equal to zero after deploying it and then increment it and then expect it to be one after that. Yeah, something like that. There we go.
00:27:48.670 - 00:27:57.610, Speaker B: I think it's like, that's.
00:28:03.470 - 00:28:04.130, Speaker C: Capital.
00:28:04.230 - 00:28:05.120, Speaker A: There we go.
00:28:06.530 - 00:28:18.930, Speaker B: Yeah, this is like the factory of the contract with the capital C. And then this is like the instance of the. Okay, it's working. Nice.
00:28:19.080 - 00:28:55.726, Speaker A: Cool. There's a lot going on behind the scenes, though. This is why I like Scaffold ETH a lot, because I can make a small change in the contract and then I can see it over here and I can poke at it. How could we deploy the contract locally and just read the count from it or something like that? Is that possible within hard hat? Just like deploy it, go talk to it. I feel like we almost need scaffold ether remix for something like that. And maybe we should just lean on the syntax right now and kind of go through all the different interesting syntax within hard hat to get you, the developer, prepared for when we have a more fancy environment where we can tinker more.
00:28:55.828 - 00:29:26.402, Speaker B: Yeah, I think the only way to tinker with contracts is just like creating tests and script and write against the contract. It's not super fast, but I think what I like is tinkering with the scaffold ETH and then when I have a final version, then put it into hardhat and then writing tests against it, because it's way faster doing it that way. Because if you start from the beginning with this, you are going to be slower. But that's like my preference.
00:29:26.546 - 00:29:42.646, Speaker A: No, I think that's great. So know that eventually you can take your contract and you can write an extensive test suite and go through and test all the different things about the contract. But for now, we're probably just going to write and show off a bunch of solidity and just get you, the programmer, ready to understand this language.
00:29:42.838 - 00:30:12.566, Speaker B: Maybe tomorrow we can create like a react application and make it to talk with our contracts right in our hard hat network. And that will be, I think, like a good introduction to scaffold next week. But for now, let's stick with the black screen. Let's do it. Okay. We talk about creating a constructor which is like a special type of function which is called when the contract is deployed, like only once. Right.
00:30:12.566 - 00:30:26.474, Speaker B: And it can take also arguments. So let's say what is the difference? Do you know the difference between Un or uint 256?
00:30:26.592 - 00:30:37.866, Speaker A: Same thing. It's just shortened and I think we should just write un 256 just to be explicit about it. When people write un, I kind of cringe a little bit because they're writing a smart contract and it should be very explicit.
00:30:37.978 - 00:30:40.702, Speaker B: Yeah, I feel the same. I always try to put like 256.
00:30:40.756 - 00:31:04.680, Speaker A: Because, and that 256 is the number of bits you're using. Right. If you did a Un eight, you would be using eight bits and you could have a number between zero and 255. If you did a UN 16, you could have a number between zero and like 65,000 something. Right. So it's the number of bits. A UN 256 is freaking huge.
00:31:04.680 - 00:31:13.818, Speaker A: Un 256 is such a big number, somewhere between zero and two to the power of 256. So it's a very large number.
00:31:13.984 - 00:31:18.460, Speaker B: Yeah. Okay, so what about this.
00:31:21.490 - 00:31:23.694, Speaker A: Looks good. I like it.
00:31:23.812 - 00:31:30.894, Speaker B: Yeah. So what happens if we try to test again? It's going to break, I think, because.
00:31:30.932 - 00:31:37.620, Speaker A: It'S going to say something like the constructor needs one argument and you're not sending in any arguments, or something like that.
00:31:41.030 - 00:31:45.940, Speaker B: Missing argument. Right. So let's fix it. Let's start with ten.
00:31:49.990 - 00:31:55.510, Speaker A: Our test will need to change. Yes. Ten and eleven, like this. All right, ship.
00:32:01.360 - 00:32:02.652, Speaker B: It. Nice.
00:32:02.706 - 00:32:30.404, Speaker A: Okay, awesome. So we know the structure of a contract, we know the constructor, we know how storage variables work. We know how to write functions. Now whether those are view functions or write functions, what are some other primitives? We've got numbers down. Addresses are really weird when you put an address in. Can we put, I don't know how we could put in an address here, but maybe. Go ahead.
00:32:30.522 - 00:32:38.452, Speaker B: I was thinking about introducing in our contract the concept of owner. Something like that.
00:32:38.586 - 00:32:44.584, Speaker A: Yeah. And then we can introduce a require statement and require that only the owner can increment or something.
00:32:44.622 - 00:32:57.020, Speaker B: And also the modifiers with being like only owner. So yeah, I think we are going in the right way. Yeah, the right direction. Okay, so address, I say public and owner. Right.
00:32:57.090 - 00:33:18.656, Speaker A: And always remember that public. You'll get into a situation where you're writing your smart contract and something's not showing up in the front end. It's that dang public. Just make them public. Trust me, they're all public anyways. Unless you're building something that's going to be inherited somewhere else and you don't want people to access it. Just remember to have that public there and just get really used to adding it.
00:33:18.758 - 00:33:23.396, Speaker B: So what is the default? Because if I don't say it's private, the default internal, it's not going to.
00:33:23.418 - 00:33:42.860, Speaker A: Show up in the ABI, I think. And then anything that parses the ABI or any kind of front end that wants to talk to it can't just call some function. I think maybe the public getters or something set up, but still the nerds can get in there and find the bits and still read that number. Just, it's not as accessible to us. Non gigabrains.
00:33:43.760 - 00:33:49.340, Speaker B: Yeah. Okay, so when should we initialize the owner?
00:33:50.640 - 00:34:02.192, Speaker A: So technically you could just say owner equals right there. And it's the same thing as setting it in the constructor, right? Yeah, but for us, we're programmers, maybe we should put it in the constructor and make it obvious. Right.
00:34:02.246 - 00:34:05.440, Speaker B: And also we can take a look at these globals that you mentioned before.
00:34:05.510 - 00:34:06.732, Speaker A: Message sender.
00:34:06.876 - 00:34:19.344, Speaker B: Yeah. Because you could do this if you want, you can do like address and then the owner. And you can pass the address directly on the constructor. But you can also do owner equals to message sender.
00:34:19.472 - 00:34:49.090, Speaker A: Okay, let's dive into globals real quick. Can we go look at them? Because it's like, whoa, message sender, what is this? You have a bunch of cool variables available to you within the execution of your smart contract. The base fee, the chain ID, the Coinbase, the difficulty, the ones that out of all of these, you're going to use message sender the most. You'll use message value now and then, and you'll use block timestamp now and then. And that's basically it.
00:34:51.380 - 00:34:58.188, Speaker B: And also this is interesting, the TX origin. And then, well, this is like, we'll.
00:34:58.204 - 00:35:06.512, Speaker A: Get to this when we start talking contract to contract interaction. You can talk to a contract that can talk to another contract, but not today. That's too complicated.
00:35:06.576 - 00:35:17.400, Speaker B: Yeah, because it's tricky. Right? Because it says sender of the message and this is the sender of the transaction, which is weird, right? It's like kind of the same thing, but not, but yeah, that's for another day.
00:35:17.470 - 00:35:17.704, Speaker A: Yes.
00:35:17.742 - 00:35:18.040, Speaker B: Okay.
00:35:18.110 - 00:35:18.730, Speaker A: Yes.
00:35:19.180 - 00:35:46.280, Speaker B: So that's perfect, right? I mean, the owner. And then let's create a new test. Well, let's do it here. Deploy. And this will have the contract deploy with the initial count of ten. And then the owner should be, who is the owner here? Because hard hat is doing a lot of things for us out of the box. So we don't know who is really like sending the transaction.
00:35:46.280 - 00:36:19.900, Speaker B: I think we saw something the other day, maybe, but you can do with hard hat heathers. You can do something like size signer zero equals to. I think it's ethers. Get Cyrus. Yes. So also keep in mind that we are not using ethers directly. We are using the ethers version, like the hardhead version, which is like heaters with more stuff.
00:36:19.900 - 00:36:42.052, Speaker B: Right. So it has this function which is going to return an array of all the signers. Like the development this deterministic signers that we saw when we started the chain. I think it was like 20 or ten signers that had set up for you. So it's written an array. So if we do this, we can get all the signers that we want.
00:36:42.106 - 00:36:55.784, Speaker A: Could we even add a little console log on line seven that says something like deploying counter contract as signer zero. Just so we see really obviously who that signer zero is. Yeah. Cool.
00:36:55.902 - 00:36:59.220, Speaker B: And then something like signer zero restlight.
00:36:59.380 - 00:37:00.090, Speaker A: Yeah.
00:37:00.540 - 00:37:16.590, Speaker B: Okay. And now we can do some newest expect doing something like counter owner to be equal to signer zero address. Right.
00:37:18.020 - 00:37:31.732, Speaker A: One thing that I think people get caught up on is the idea of this owner. It sounds like a contract has like a special keyword for owner. This could be just like Carlos. Right? It's just boss. There we go.
00:37:31.786 - 00:37:32.196, Speaker B: Exactly.
00:37:32.298 - 00:37:41.024, Speaker A: It's any arbitrary thing. So just be careful not to think owner. Is that some special thing? It's not some special thing. We just defined it as. Yeah, let's just keep it as boss.
00:37:41.072 - 00:37:48.728, Speaker B: Right now it's not going to be like a built in thing, right. In Ethereum, like boss seems like a made up thing.
00:37:48.894 - 00:37:52.580, Speaker A: It does. Bosses are made up. I think I agree with that.
00:37:52.750 - 00:38:04.796, Speaker C: And just wanted to add something so we could also get the addresses and who's signing by, I think hardhat accounts or. I think that was like the command to run. If you want to display all the.
00:38:04.818 - 00:38:09.520, Speaker B: Accounts on your console like this and then accounts.
00:38:10.100 - 00:38:13.984, Speaker A: And that first one should be f one something or something like that, right?
00:38:14.022 - 00:38:15.840, Speaker B: Because it comes with F 39, right?
00:38:15.910 - 00:38:18.550, Speaker A: Yes, F 39.
00:38:21.720 - 00:38:29.430, Speaker B: It's actually here. Right. You see the console log? This is the one. Yeah. Okay, nice.
00:38:30.280 - 00:38:40.984, Speaker A: So our tests all passed there is that. Right? It deployed and the boss is the message sender. And we double check. That is our deployer. And it worked. Cool.
00:38:41.022 - 00:38:55.164, Speaker B: So what if we only allow the owner to do like a deck operation? This is going to be public and this is also going to be public. But we only want to allow the owner or the boss to decrement the account.
00:38:55.282 - 00:38:58.476, Speaker A: Anybody can increment, but only the boss can decrement that's.
00:38:58.508 - 00:38:58.848, Speaker B: Fun.
00:38:58.934 - 00:39:27.604, Speaker A: Yeah. So I think this is one of the most powerful things of all solidity of all the smart contracts. Everything we're talking about here, the most powerful thing is this require statement. Require is going to be one of the most powerful keywords here. And I think that's what you're about to write here. You basically get to create a rule within the execution that says this rule has to be true, or we revert everything and everything rerolls or unrolls rolls.
00:39:27.652 - 00:39:33.390, Speaker B: I was going to see if I can find the revert or required here, but I'm not sure where.
00:39:34.400 - 00:39:35.628, Speaker A: I don't know either.
00:39:35.794 - 00:40:05.124, Speaker B: Yes. So maybe people can also look into this. So lady by example is nice. It has all the things that you need to start with smart contracts. So let's do a require here. So what are we going to require to run this function? So we are going to require that the message sender. Right? Like the person who is sending the transaction is equals to the boss, right?
00:40:05.242 - 00:40:05.908, Speaker A: Yes.
00:40:06.074 - 00:40:20.596, Speaker B: And this is the message that you say. This is the rebirth message. So if this is not true, then this is going to get display. Display, I guess, or return. Right. This is going to be like the rebirth reason. So you can say, like, sorry, not the boss.
00:40:20.596 - 00:40:21.620, Speaker B: Something like that.
00:40:21.710 - 00:40:46.064, Speaker A: Right. We can even flip around. Let's not do it yet, but let's show the atomicity of a transaction. And let's swap lines 24 and 25 eventually and show that it doesn't matter. But let's just run this real quick and make sure it works. So let's write something that. What do we have to do? We need to prove that only the boss can decrement it.
00:40:46.064 - 00:40:54.020, Speaker A: Right? Again, this is where I want Scaffold ETH, where I can just click the buttons and show it off. It's so much harder to have to write a test to interface with your contract.
00:40:54.680 - 00:41:14.508, Speaker B: Yes. So let's create a new test and then we can do, I guess, signer one. Deploy. Deploy. We can also, like, I think we did this the other day, like, we can copy this into a before function.
00:41:14.674 - 00:41:16.060, Speaker A: You taught us that already.
00:41:16.210 - 00:41:42.276, Speaker B: Yeah, that's fine. So let's do, I think something like counter, I think is connect. Something like that. I think with disconnect, you can send the transaction with that account by default. If you don't say anything by default, it sends a transaction with the signer zero.
00:41:42.378 - 00:41:44.516, Speaker A: It's always signer zero. Yeah.
00:41:44.698 - 00:41:50.650, Speaker B: What we want to do is connect. Yes. And then let's say deck, right?
00:41:52.060 - 00:41:54.680, Speaker A: I have no idea. I hope so. Let's see.
00:41:54.830 - 00:42:16.520, Speaker B: Well, I mean, I'm not sure. So this is deck transaction. Wait, well, let's see if that should throw an error. Right. Just trying to call that function. That's perfect.
00:42:17.610 - 00:42:23.910, Speaker A: Oh, okay, cool. It threw the correct error as signer one, we tried to decrement and we got the. Sorry, not the boss.
00:42:23.990 - 00:42:24.426, Speaker B: Awesome.
00:42:24.528 - 00:42:26.634, Speaker A: And if you switch that to zero and run it.
00:42:26.752 - 00:42:38.094, Speaker B: Yeah. Or this thing, the same thing. I think on day three we also did that. We have this.
00:42:38.212 - 00:42:38.542, Speaker A: Yes.
00:42:38.596 - 00:42:50.900, Speaker B: There, it works. Revert to be revert. We can also assert or expect that the transaction is going to be worked. Yeah. Yes. Okay, so this is working.
00:42:53.750 - 00:43:24.154, Speaker A: I feel like maybe the atomicity of it is probably for later with Scaffold ETH when we can show the front end and the back end kind of more obviously. I think here we should just tinker around with syntax. Right? So we've got functions down, we've got require statements. These require statements are pretty critical. Once we have that, let's see, have we gone through all the primitives and data types we've talked about? Bools? I mean, a bool is a bool. You at home should already know what a bool is. It's either going to be true or false.
00:43:24.154 - 00:43:39.106, Speaker A: A uint is going to be a number. Right. An address is probably the weirdest one. And you can paste an address right into the syntax. But let's assume that we've got our primitives and data types out of the way. We have our global units kind of out of the way. Right.
00:43:39.106 - 00:43:43.374, Speaker A: We've talked about message value, message sender, block, timestamp.
00:43:43.502 - 00:43:46.446, Speaker B: What about modifiers? Modifiers?
00:43:46.478 - 00:43:47.314, Speaker A: Is that next?
00:43:47.432 - 00:44:12.334, Speaker B: Yes. All right, I just copied this function and I call it like super ink, which is like increment the count by ten. But only the boss can call that function. Right. So as you see here, maybe we will have, this contract is going to keep growing and we'll have this line all over again, because some function are only for the boss. Right. To run.
00:44:12.334 - 00:44:20.240, Speaker B: So this is where modifiers can help us. So let's see. I'm sure that this will have.
00:44:20.870 - 00:44:26.050, Speaker A: Yes, copy, paste example. Go to solidity example and hit copy.
00:44:26.550 - 00:44:31.262, Speaker B: Oh, only owner. So I'm glad that we stuck with the boss.
00:44:31.326 - 00:44:32.558, Speaker A: Yeah, we want only boss.
00:44:32.654 - 00:44:40.360, Speaker B: Only boss. Okay, so can you like Austin or Ella, do like an introduction of what a modifier is?
00:44:41.690 - 00:45:08.090, Speaker C: Yeah, of course. Modifiers are so basically when you use the modifier, and please correct me if I'm wrong, you can call it before your function. So it can say, check go to only owner, and if it passed, go into the function. So instead of having the require statement, you can create this modifier which allows you to easily use it over and over again. That's my, the syntax is super weird.
00:45:08.170 - 00:45:31.606, Speaker A: The little underscore semicolon thing, that is the weirdest part. But just imagine it like it's going to run the stuff inside the modifier, and then wherever it finds underscore semicolon, it's going to run your function. So it wraps the function, does some stuff, and then runs the actual function. Well, it makes more sense if we see it in the code, I think.
00:45:31.708 - 00:45:37.340, Speaker B: Yeah, what is it? Let's copy this one.
00:45:42.910 - 00:45:57.326, Speaker C: Sorry, I was going to say the only owner one is one which is very commonly used. Like, you will have a lot of functions which you want only the owner, especially like withdrawn money. Just like as a side note, and.
00:45:57.348 - 00:46:33.930, Speaker A: If it's, imagine it like this, imagine you need to check that it's only the owner and a certain timestamp hasn't passed yet, and the balance of the contract is greater than some amount. Right. There could be a bunch of different factors you need to check. And you need to do that for like four or five different functions. You'd find yourself writing those same require statements in the top of all those different functions. This modifier saves you basically, you write those requires once and you test those requires once, and then you can add those modifiers to any function. So let's see, we've got an only boss.
00:46:33.930 - 00:46:41.162, Speaker A: Yeah. And it checks to make sure that the boss is right. And then it underscore semicolon.
00:46:41.306 - 00:47:06.920, Speaker B: This is weird. This is weird as they said. But if you have used some middleware, if you use a node or express. So it's the same thing, I think in express is like next. So it's just run what is here and then it just keep going with the execution. So that is like the way that they implemented that. I don't know, maybe it's not pretty, but it's the way it works.
00:47:06.920 - 00:47:20.298, Speaker B: Okay, so how do we use that? Because I guess we can remove this now and also this. And it's just adding the modifier here, right?
00:47:20.384 - 00:47:39.214, Speaker A: Very clear. Yeah. And hopefully if you're a programmer at home, that makes sense to you. We just added only boss to Super Inc and decrement. And mentally you can clearly see like, oh, this is a function that only the boss can run. This decrement function only the boss can run. And you can go up to that modifier only boss and double check it.
00:47:39.214 - 00:47:42.100, Speaker A: But now we can test it and make sure it works the same way.
00:47:43.750 - 00:47:50.180, Speaker B: It should revert. Right? Because we are using the signer. Yes.
00:47:52.490 - 00:48:09.074, Speaker A: Let's see. So only the boss can run a decrement, and signer one is not a boss, so it should fail. Okay, cool. Okay, modifiers. We've got functions. I think we're ready for mappings. Are we ready for mappings?
00:48:09.202 - 00:48:10.618, Speaker B: Yes. Okay.
00:48:10.784 - 00:48:21.774, Speaker A: I feel like a good example of a mapping is just making a token, right? Once you have a mapping and a transfer function, you have a token. So maybe we should just build a little digital currency here.
00:48:21.812 - 00:48:26.000, Speaker B: Next. Yes. I love it. Okay.
00:48:26.850 - 00:48:54.646, Speaker A: Sadly, if Ethereum was an App Store, the number one app in the App Store for the first couple of years is digital currencies. And we had digital currencies at a lot of other places. But by creating decentralized digital currencies, there was a big wave of ICOs and money moving around. And sadly, a lot of bad things happening in web3. That kind of gives us a bad name. But we're here for the tech. We're in love with it.
00:48:54.646 - 00:48:58.234, Speaker A: I'm all about it. How do we make a decentralized currency? What do we need?
00:48:58.352 - 00:49:03.782, Speaker B: We are going to save it the day, of course, with the token. Right? Ooh.
00:49:03.846 - 00:49:05.690, Speaker A: Sanford token Ico.
00:49:09.870 - 00:49:18.574, Speaker B: Okay, where is three? Sorry. Here.
00:49:18.772 - 00:49:19.834, Speaker A: There we go.
00:49:19.972 - 00:49:48.550, Speaker B: Yeah. Okay, so let's start from the beginning. Let's copy this and then contract Sanford token. Okay. At least when I think about a token or NFT or whatever, usually I think about the mint function. Always, right? Like mint is like the creation. We can even call it like create if you don't want to use mint.
00:49:48.550 - 00:50:19.810, Speaker B: So yeah, I'm going to do like the skeleton of the function and then I'm going to ask for help. So, Eda. Or you can ask and help me with this. So let's call it create. And this is going to be public. And let's do 56, like quantity. So I want to be able to mint quantity tokens, like 100 tokens, for example.
00:50:19.810 - 00:50:35.910, Speaker B: So, yeah, how can we keep going from here? Because from the test or from the UI, I'm going to call this create function with 100. And I want to be able to the contract to track that I have 100 tokens.
00:50:36.970 - 00:51:26.086, Speaker A: I might push back a little bit and say that what we want to do is create some digital scarcity here. And it kind of worries me that this create function is public and anyone can get in here and create it. So maybe we would add something like an only boss modifier, but I want to do even better than that. What if this is the constructor and we only create the quantity once and it could never run again? It's a little bit different than your mint function in terms of creating an NFT, but I'd like the scarcity to be in place from the start and I'd like even the owner to not be able to just create this stuff willy nilly. I'd like for us to just have the constructor make 100 of these tokens and never be able to mint them again. Right. So I would replace this with just like constructor quantity and set it.
00:51:26.086 - 00:51:29.254, Speaker A: But I think what, you've got a different idea here. So maybe we go down that path.
00:51:29.302 - 00:51:37.210, Speaker B: No, that's fine. I totally get it. So maybe another option would be have like, because we haven't talked about constants, right?
00:51:37.280 - 00:51:37.900, Speaker A: Right.
00:51:38.350 - 00:51:45.840, Speaker B: So we can also have something like, I think it's public.
00:51:47.730 - 00:52:15.778, Speaker C: So just to kind of add something to that, to just make it like the Stanford token a bit more clear. So basically we're going to create a token which has a total supply which is limited to a certain number. So you can't mint more than that. Like minting means creating. And I guess our token will have a name and probably like a symbol. And I guess we're going to do step by step right now that just to kind of set the statement.
00:52:15.794 - 00:52:28.006, Speaker A: Yes, I guess all we need is a require statement inside of this create. We need to require that the current supply is still less than total supply or something like that. We would be limiting it.
00:52:28.128 - 00:52:33.566, Speaker B: I'm sorry. So maybe like total created something like that. And can I start with here?
00:52:33.668 - 00:52:34.320, Speaker A: Yeah.
00:52:37.810 - 00:53:01.400, Speaker B: Like Ella said, usually if you are going to create like a token, you are probably going to use like ERC 20 or ERC like 721 and inherit from that. Because we haven't talked about inheritance yet. But that's probably the way that you want to go. But I guess here for the learning purposes, I guess for the sake of learning, we are going to go from scratch, if that's okay.
00:53:02.410 - 00:53:03.462, Speaker A: Sounds great.
00:53:03.596 - 00:53:38.482, Speaker B: Okay, here, what do we want to do? We don't want to get over this total supply, right? And we have this total created. So something that we can do is require that the quantity plus the total created should be less or equal than the total supply, right? And if not, we are going to say, okay, total supply rich, something like that.
00:53:38.536 - 00:53:49.350, Speaker A: And just by writing that one rule, now we've created this idea of digital scarcity. Like there can never be more than a thousand Sanford tokens because we wrote it very explicitly in this contract.
00:53:50.170 - 00:53:53.062, Speaker B: I'm sorry for your constructor idea.
00:53:53.196 - 00:53:54.200, Speaker A: That's all good.
00:53:54.650 - 00:54:28.626, Speaker B: Same thing. It's the same thing, right? I mean, that we did here, right? We initialize the count. With this initial count, it should be the same, right? We could do like total supply and then having the total supply initialized by the constructor. I guess it's the same. Okay, so now we have that problem solved. We can mint like, anyone can't mint more than a total supply, even the owner, right? At least for now. But now if I want to mint like 100 tokens, what do I need to do this.
00:54:28.626 - 00:54:35.278, Speaker B: Sorry, here. What do I need to do here to keep track of that minting or that version of tokens?
00:54:35.374 - 00:54:50.060, Speaker A: We're still not really keeping track of who has what. All we've done so far is set a limit. This is where our mapping comes in, right. We need a storage element that's a mapping that keeps track of, for any given address will keep track of a number.
00:54:50.990 - 00:55:23.606, Speaker B: So a mapping, if you are coming from another dictionary language is like a dictionary. It's just like you have the key and the value, and the key can be like any of the types that we have seen so far. So in this case, I will say that we want to be an address, right? And then you int 256. So we are going to map people's addresses with the token balance that they have, right. And we can call it, this is going to be public and we can call it the balances, right, perfect.
00:55:23.788 - 00:56:07.390, Speaker A: And the gotcha here, between a mapping and some other data struct, is you can't iterate through your mappings. Your mappings are just one primitive to another primitive and you can't loop through those. If we needed to know, like say we weren't keeping track of total supply and we actually wanted to calculate our total supply, it would be terribly inefficient. But if you wanted to loop through all of the balances of all of the people and add it up to get the total supply, you couldn't do it with a mapping. You'd need to use an array and you need to use something that you can loop through. So think of it like a hash map. It's a mapping where it's like a one time address, two number, and they all start at zeros.
00:56:07.390 - 00:56:11.170, Speaker A: And it's more memory efficient than keeping track of a big array.
00:56:11.590 - 00:56:25.558, Speaker B: Yeah. For that reason, like you said, sometimes you have to create some extra variables, state variables, to keep track of things like that. Right? Because if you want to iterate and get the total created. It's impossible to do with the mapping only.
00:56:25.724 - 00:56:26.486, Speaker A: Exactly.
00:56:26.668 - 00:56:50.510, Speaker B: Okay, so EDA, what do you think that we need to do with the balances? Because we are trying to create this quantity for who? Because also we can also have an address here and two, but for now maybe we can say that the person who is sending the transaction, the message sender, is the one that is going to receive the balance, right? The token.
00:56:51.750 - 00:57:05.626, Speaker C: Yeah, exactly. So we can directly use message center, like add into that balances, mapping who the message center is and the quantity of tokens they get equals quantity.
00:57:05.758 - 00:57:07.640, Speaker B: If we do this, what will happen?
00:57:08.970 - 00:57:11.080, Speaker A: We might have just destroyed some value.
00:57:12.090 - 00:57:26.582, Speaker B: Because if you do this, then the first time that they create some tokens, it will be perfect. But the second time it's going to override their balance. Right. So we can add this real thing to the plus sign here and it's going to keep adding the balance.
00:57:26.726 - 00:57:49.730, Speaker A: And there are some programming languages where, like JavaScript, where if that balance isn't initiated or initialized and you try to do a plus equal, you start getting weird stuff like Nan, remember this is more like embedded programming, and when you create that balance, you're actually making a space in memory. So any given balance is already zero. So plus equals works fine without any initialization.
00:57:50.230 - 00:57:59.830, Speaker B: And we talked about overflows before and that we don't need to worry about that with this version. But what if we were using this with an other version?
00:58:00.890 - 00:58:31.374, Speaker A: That's another thing we'd want to check is if you take the balance and you plus equals and it rolls around, something really bad has happened. Right? If you're not using enough bits to track this, let's say balance is only a un eight and we're at 250 and someone adds ten, they're going to get four. It's going to go from 250, plus ten is four and you're going to say what? And that's because it rolled around, all those bits were high and now they're low again, right?
00:58:31.492 - 00:58:31.918, Speaker B: Yeah.
00:58:32.004 - 00:58:35.170, Speaker A: So you would want to double check that you're not going to overflow.
00:58:35.590 - 00:58:58.390, Speaker B: Yes, because also if they will go over this required, and they will mint for themselves like a lot of tokens here, right? Because here there will be four, but here will be like the full quantity that they wanted to mint. So yeah, be careful with that. But in this case we don't have to worry because we are using this version. Okay, what else we can do?
00:58:58.540 - 00:59:21.134, Speaker A: We need two plus equals the total created in this case too. I kind of think we're really keeping track of a lot of extra stuff here. And some contract auditors would probably tell us we could probably get away or figure out a way to do this with less variables. But this is very explicit. It's easy to see what's going on here. We've created a quantity. We've given that quantity to the message sender.
00:59:21.134 - 00:59:30.500, Speaker A: We've made sure that when you're creating your quantity, you can only go so much. This looks pretty good here. Are we missing anything else?
00:59:30.870 - 00:59:37.970, Speaker B: I don't think so. Now we can create a test to test this, or we can keep creating if you want. Maybe we can keep adding like functionality.
00:59:38.130 - 00:59:42.166, Speaker A: I think we need a transfer function, probably transfer, right? Is that what's next?
00:59:42.268 - 00:59:46.570, Speaker B: Yeah, let's call it send. We don't want to.
00:59:46.720 - 01:00:08.814, Speaker A: Yeah, let's assume that it works. And what's happening is we can deploy this, and the owner, whoever deploys it, will be able to call create with any amount. And whenever they call create, it's just going to add to their balance. But then they can't send any out of their balance. Right. So it's basically just the owner keeping track of their own money or their own counter. Right.
01:00:08.814 - 01:00:10.970, Speaker A: So this send function is going to.
01:00:10.980 - 01:00:22.482, Speaker B: Be really critical and I think something that we are missing. Okay, we can do the send first, but it's like the payable functions. We haven't talked about payable, right?
01:00:22.536 - 01:00:28.802, Speaker A: No, not yet. No. Like if we wanted to be able to let people buy the token and send in some ETH to get the token.
01:00:28.866 - 01:00:29.238, Speaker B: Yeah.
01:00:29.324 - 01:00:32.758, Speaker A: Maybe we could add a buy function down at the bottom or something like.
01:00:32.844 - 01:00:50.540, Speaker B: Okay, so let's deal with the address too republic. Okay, so we want to send some tokens to the two address. So what should we check first?
01:00:51.950 - 01:01:08.654, Speaker A: Luckily, because of safemath being built in, we don't have to check anything. We can basically just say the to address plus equals the quantity and the from address minus equals the quantity. I'd maybe even start with the from address first. So I'd say balances of message sender.
01:01:08.782 - 01:01:12.290, Speaker B: Yeah. So you're saying that we are doing.
01:01:12.360 - 01:01:15.938, Speaker A: This and then minus equals the quantity. Yes.
01:01:16.024 - 01:01:43.498, Speaker B: So you're saying that because of the version of solidity, right. If we do this, then this will revert if we overflow. Because this is like a u int, right. So it needs to be like a zero or positive number. So if we try to go, if this person has like 100 tokens, and then we try to send 200 tokens, this is going to overflow or underflow in this case, and it's going to rebirth. Right. So we don't need to worry about that anymore.
01:01:43.594 - 01:02:23.370, Speaker A: But perhaps if we wanted to be very explicit about it, maybe we should write that require statement just to make it obvious to developers at home that we're very sure that we have the right quantity. And what we would do is just require that the balance of message sender is greater than or equal to the quantity. And then we'd send them a message saying you don't have enough, or something like that. Right. So it's not super important and it's going to work anyways. But we're going to spend the extra gas. Normally you wouldn't do this, but in this case we're going to spend the extra gas to have a nice little error message here that tells you that you don't have enough, but normally that's not going to be in a production contract.
01:02:23.370 - 01:02:27.658, Speaker A: Okay, looks good.
01:02:27.824 - 01:02:55.926, Speaker B: Yeah. And this is how actually it works in real contract, because this seems like we are just like playing here. But in reality, if you want ERC 20 in production, it's going to be way different than this. But actually it's going to look like super similar to this. This is how a sense function looks like. This is minus the balance, the quantity here and plus the quantity here. So it's going to be like the same thing.
01:02:56.028 - 01:03:20.190, Speaker A: You're programming money. It's crazy to think about it, but you're like programming value in a decentralized way. It's a really neat, like when we think of a token, nothing is actually getting sent around. Going back to the talk about bitcoin and sending bitcoin through wires. Right. It's all actually just a smart contract that's keeping track of values. And when you transfer, you're getting in there and subtracting some from one and adding it to another.
01:03:20.190 - 01:03:23.360, Speaker A: And that's what a token is. That's how this all works.
01:03:23.890 - 01:03:24.640, Speaker B: Yes.
01:03:25.250 - 01:03:36.050, Speaker A: Should we write a test? What should we do now? It seems like we should probably try to send something and make sure it sends to someone or something along those lines.
01:03:39.670 - 01:03:53.030, Speaker B: Yes. That's going to be. And then the first could be like the set should be able to create tokens.
01:03:54.410 - 01:03:57.338, Speaker A: First we create, then we send. That makes sense.
01:03:57.424 - 01:04:09.702, Speaker B: And then let's do the before here. So this is going to run every time? Not every time. Well, before each is going to run before each statement.
01:04:09.766 - 01:04:10.380, Speaker A: Yeah.
01:04:11.950 - 01:04:57.420, Speaker B: Then we can have the counter. Not the counter, the token here. And then this is going to be token and Sanford token tokens create transaction. I think we don't need this for this one. Great. Token create. Let's do like 100.
01:04:57.420 - 01:05:05.294, Speaker B: Okay, so now we can, I think the expect here would be that the.
01:05:05.332 - 01:05:07.950, Speaker A: Token expect our balance to be 100.
01:05:08.020 - 01:05:12.546, Speaker B: Yeah, I guess that we need the address of the signer, right?
01:05:12.648 - 01:05:13.300, Speaker A: Yes.
01:05:13.910 - 01:05:26.726, Speaker B: So the balance of the signer address to be equal to 100. Right? What do you think?
01:05:26.828 - 01:05:31.960, Speaker A: Yeah, it looks good so far. Maybe run it and see. I'm mildly confident. I don't know.
01:05:32.490 - 01:05:34.418, Speaker B: Can you give me a percentage?
01:05:34.594 - 01:05:43.690, Speaker A: I don't know. See, I would say like 90%, but then there could be some little weird syntax that could catch us. Let's find out.
01:05:43.840 - 01:05:44.682, Speaker B: Okay, let's see.
01:05:44.736 - 01:06:04.660, Speaker A: There's one good way to find out. We needed an argument in the deployment. We still have an argument laying around wamp wa.
01:06:08.790 - 01:06:11.460, Speaker C: It was a hard one to catch though, to be fair.
01:06:11.910 - 01:06:14.194, Speaker A: That's why we have all these testing suites.
01:06:14.322 - 01:06:14.902, Speaker B: Yes.
01:06:15.036 - 01:06:28.522, Speaker A: Okay, so we deploy our smart contract and we call create and it creates 100. And now our deployer has 100 tokens. Can we transfer them? Can we send them?
01:06:28.656 - 01:06:34.218, Speaker B: Let's do first, like the test, the rebirth, if we try to mint more than one house.
01:06:34.384 - 01:06:34.858, Speaker A: Okay.
01:06:34.944 - 01:07:10.200, Speaker B: Yeah, so rebirth if creation creating more than total supply. So I think we could actually read the total supply from the contract, right? So we can do total supply. I mean, we could hard code it like the total supply here. But if we want to go, we can do token and this of course is going to be a big number, I think, right?
01:07:10.650 - 01:07:11.800, Speaker A: I think so.
01:07:12.410 - 01:07:25.260, Speaker B: Total supply. And then we can do total supply then as, I don't know, like 100.
01:07:26.350 - 01:07:35.966, Speaker A: We need to do what? Like 1000 though, right? We want to roll it over. Oh, you're just creating. I got it. Could be one. Yeah, I got it.
01:07:35.988 - 01:07:36.174, Speaker B: Okay.
01:07:36.212 - 01:07:40.606, Speaker A: Yeah, it's the total supply plus a little bit more to cause it to break. Got it.
01:07:40.708 - 01:07:59.462, Speaker B: Yeah. So I think we can do something. Wait, I think we need to remove this. This is weird. When you need to check the revert, sometimes it's weird to be reverted. Okay. I don't know.
01:07:59.462 - 01:08:02.440, Speaker B: Let's test. Let's see if it works.
01:08:04.010 - 01:08:08.522, Speaker A: Only like 40%. Confident. Right now we're just changing stuff around so quickly.
01:08:08.576 - 01:08:09.434, Speaker B: I don't know.
01:08:09.632 - 01:08:28.814, Speaker A: It worked. Okay, so now we know that we're able to create tokens and we know that we're only able to create so many tokens. We have this sort of scarcity model where there's only 1000 that can ever get created. So now it's about creating those tokens. And can we send them around?
01:08:29.012 - 01:08:40.820, Speaker B: Okay, so we can copy the same test that we have. Right. Like for the signer zero minting, like creating some tokens like 100. And now let's send.
01:08:42.550 - 01:08:56.778, Speaker A: So for each it statement, it's redeploying the contract. So up above when we're creating 100 and down here, you want to be clear that it starts over at zero again with each one of these it statements and make sure that's clear in everybody's mind.
01:08:56.864 - 01:09:05.674, Speaker B: Yes. We could also remove this each. And this will get deployed once and then this will create 100 tokens on.
01:09:05.712 - 01:09:16.702, Speaker A: Top of each other statement. But it's easier with the before each to say within each one of these chunks, you get a completely clean contract. And you can test that one situation that you wanted to test.
01:09:16.836 - 01:09:24.626, Speaker B: Yeah. And you can also create some describes inside the describes with the before. So you can create different setups if.
01:09:24.648 - 01:09:45.174, Speaker A: You want mocha or chai. You're basically looking for the syntax, Google Mocha testing. And you'll find. And it might even be called waffle. Now, is that right? Is mochate? I don't even know. There we go.
01:09:45.292 - 01:10:01.594, Speaker B: Yeah, I think you can look it up here. Yeah, this is the expect is the one that we are using because you have the suit or the shirt. So, yeah, I think waffle. Just add some stuff. Just specifically.
01:10:01.642 - 01:10:03.370, Speaker A: Just probably like that reverted.
01:10:03.530 - 01:10:10.622, Speaker B: Yes. You can also create mocks for some contracts and get events from contract and things like that.
01:10:10.756 - 01:10:16.498, Speaker A: And probably some big number stuff where you can check to see if it's like greater than or equal to some other big number. Yeah.
01:10:16.664 - 01:10:47.822, Speaker B: Okay, so let's do this send transaction. And we want to call token send. And the first argument was the address and then the quantity. So let's send to shiner one address, like 25, for example. Right. Then let's await to the transaction to be mined. And now we could do this, right.
01:10:47.822 - 01:11:05.780, Speaker B: Signer zero should have 75 and signer one should have 25. Okay, 90%. Yeah, I don't know.
01:11:13.220 - 01:11:34.810, Speaker A: There we go. All right, so we're able to deploy the contract. We're able to mint some amount. We're sure that we can't mint too many. So we have some set amount that we're able to create ever. And now we're able to send them around and it correctly sends from you to the other address. And we can test that.
01:11:34.810 - 01:11:52.524, Speaker A: Now these tests are all automated too. So over in scaffold ETH, we could be poking around and doing things quickly and sending it around and seeing it quicker. But then if we change one little thing about the contract, this is really nice because we can run our whole test suite again and double check that some weird situation didn't come up, right?
01:11:52.642 - 01:12:06.076, Speaker B: Yeah, that's what I think for me is really useful to tinker with scaffold if until you have kind of like a final version of your contract and then when it's almost ready, like go into hardhat and do all the tests.
01:12:06.108 - 01:12:27.400, Speaker A: Because then, right, all those different test cases and even things like in foundry, they talk about fuzzing, right? Like all sorts of weird fuzzing that you can do. And try a bunch of random values and try this plus one and try this minus one. And make sure these weird edge cases don't come up in your tests also. And you can automate all that as part of a test suite.
01:12:28.620 - 01:12:38.524, Speaker B: Okay. So I don't know, I think we can go with sending some it to a contract or maybe showing some extracts also.
01:12:38.722 - 01:13:03.136, Speaker A: Yes. Let's get that payable function out of the way pretty quickly. Let's see, so maybe the admin can create, but maybe let's copy the create function and create a buy function. And in this case, you wouldn't have to be the admin. Wait, can anybody create, oh, we're missing a require statement there. Don't we need some kind of require statement?
01:13:03.248 - 01:13:07.188, Speaker B: We didn't copy like the only bosses in this contract, but we can copy if you want.
01:13:07.274 - 01:13:31.612, Speaker A: We need the only boss. Yeah, get it back in there. So that's something we didn't test, right. You write this cool test thing, but you forgot about this one thing where anybody can create it and you forgot to write the test for that. And now it's, yeah, there we go. So we want only the boss to be able to. And are we saving the boss somewhere? There we go.
01:13:31.746 - 01:13:33.244, Speaker B: We can copy this.
01:13:33.442 - 01:13:34.588, Speaker A: There we go.
01:13:34.754 - 01:13:52.020, Speaker B: Okay, then we need to copy also like the state variable, and this is nice because we are making a lot of changes. And now if we run our test, everything is going to break, which is a good thing, right? A good thing. Okay, that initial count out of the constructor.
01:13:52.440 - 01:13:53.636, Speaker C: Sorry, I was just going to say.
01:13:53.658 - 01:13:55.540, Speaker B: The initial count is going to erase.
01:13:56.680 - 01:14:08.328, Speaker A: It's like nerds start getting goosebumps on the back of their neck when you forget to put the semicolon down or something. When you're watching another nerd code, it's like you detect the things that they don't see right away.
01:14:08.494 - 01:14:20.124, Speaker B: For me, something like this works better. Like having this extra space for no reason. That gives me bumps I can stand that. So I can do this. And then a lot of people will be super nervous at home.
01:14:20.242 - 01:14:22.636, Speaker A: Get that white space out of there. Is that what you're saying?
01:14:22.738 - 01:14:25.470, Speaker B: Yes. Okay.
01:14:27.380 - 01:14:38.390, Speaker A: We want to create function that's not going to be only boss, and we want to make it payable. So we want people to be able to send in ETH and get back some of our token. Right?
01:14:38.840 - 01:15:01.912, Speaker B: So what if we only allow to mint, like, one to get one? Okay, so that's easier. So we can say like five, then the quantity will be plus one, and then this will be. I guess we can do this right now.
01:15:01.966 - 01:15:15.070, Speaker A: Got it. Yeah. So you're saying it could be total, created plus one is less than equal to the supply, but since it's plus one, you're just taking it out. That was a little programmer magic there. But hopefully all you kids at home follow along with that.
01:15:16.800 - 01:15:35.380, Speaker B: Okay, so I think, well, we are not checking anything. I mean, this only means that this function can receive heath. Right. But we are not actually checking anything. We are not keeping track of how much they are sending. Is that enough or what?
01:15:35.530 - 01:15:37.072, Speaker A: Our next global variable.
01:15:37.216 - 01:15:58.190, Speaker B: Yes. So it can be public and mint price. I mean, this can be constant, right? Constant mint price, creation price. And then we can say something like this.
01:15:59.440 - 01:16:22.960, Speaker A: I've got another one we can add here. While we're here, the boss gets updated once and then never changes again. There's no function to transfer. So what we can do is we can make the boss immutable and it's going to save us a lot of gas. So on line ten, you could do address public immutable, just like your constant. But this is saying two M's.
01:16:23.040 - 01:16:26.576, Speaker B: Imm, sorry, spanish speaker.
01:16:26.688 - 01:16:37.640, Speaker A: And then delete the n. Yeah, I think immutable. Oh, no, it didn't highlight. Oh, no. How does immutable work? I thought I was being, let's see.
01:16:37.710 - 01:16:43.484, Speaker B: Maybe is my ide. It's working.
01:16:43.522 - 01:16:56.216, Speaker A: Maybe that was it. Okay, just the IDE doesn't highlight it yet. Okay, cool. That just saves you some extra. It's like making it a constant. Yes. Rollback.
01:16:56.216 - 01:17:32.424, Speaker A: Sorry for that side quest. Okay, so the boss isn't going to change, so we can make it immutable, but what you've created is a price, and you've made that price constant. And all of this stuff like immutable and constant is saving a little bit of gas. But when everything costs money to run, these little nice little changes are going to help save your users money. Okay, so we have a creation price now. So what we need to do is make sure they paid the price right. So we probably need some require statement here that looks at the message value, which is our new global variable, needs to be greater than or equal to or maybe even equal, equal to the price.
01:17:32.542 - 01:17:35.484, Speaker B: I mean, if it's greater, they can send more money, right?
01:17:35.682 - 01:17:55.296, Speaker A: They could, which in the case of, I'm running the vending machine, I don't care if you put in a 20. I'm just going to give you a bottle of water back. But in the case of the user, if the user puts in a 20 and then just gets a bottle of water back and no change, they might be unhappy about things. So you might want to do equals equals in that case.
01:17:55.478 - 01:17:56.064, Speaker B: Okay.
01:17:56.182 - 01:18:22.350, Speaker A: The only time I use greater than or equal to is when I'm on a price curve and there's lots of people buying, and that price is changing as each person buys. So you don't want to have collisions. You could have two or three people buy at the same time and send in just a little bit more, and it would work. In this case, let's just do equals equals. In case they send too much money, we want to revert to save them accidentally, like adding a zero or something weird here.
01:18:23.040 - 01:18:31.544, Speaker B: Okay, so maybe let's run our test again and see how everything breaks.
01:18:31.672 - 01:18:35.728, Speaker A: It should break, right? Let's see. Well, we're not testing buy. Everything should work.
01:18:35.814 - 01:18:39.840, Speaker B: Yeah, no, but, I mean, I think we changed. What did we? I don't know.
01:18:39.990 - 01:18:42.370, Speaker A: Okay, let's find out.
01:18:45.300 - 01:18:50.980, Speaker B: Okay. Because this is the constructor, and it doesn't have any arguments. Okay. Yeah. Okay.
01:18:51.130 - 01:19:07.384, Speaker A: We probably should have written something to test whether signer one can call the mint function the create function, and then in this case, that would have been failing until we added the only boss thing, and then that would work. There we go.
01:19:07.502 - 01:19:10.490, Speaker B: If an unboss tries to create.
01:19:12.960 - 01:19:14.110, Speaker A: There we go.
01:19:17.600 - 01:19:37.590, Speaker B: Okay. And then I think it was signer one. Not sure if this is going to work, but let's try.
01:19:41.800 - 01:19:46.692, Speaker A: Create. It's not total supply. It's got to be, right? Yeah.
01:19:46.826 - 01:19:51.850, Speaker B: Okay, here. Create.
01:19:52.940 - 01:19:58.330, Speaker A: Yeah, you don't even need to know total supply. You can just have it. Try to create one. Right? Yeah.
01:20:01.840 - 01:20:03.070, Speaker B: Okay, let's see.
01:20:06.800 - 01:20:14.108, Speaker A: This is just making sure some random person can't get in and call our boss function, which we've just added. There we go. Awesome.
01:20:14.194 - 01:20:15.212, Speaker B: Okay, nice.
01:20:15.346 - 01:20:26.550, Speaker A: So the boss, and only the boss can mint them for free. But now we have this new buy function, and we want to test it. Can a rando get in here and pay a little money and mint one.
01:20:29.080 - 01:20:34.452, Speaker B: How do you spell rando? R a n D o, maybe like that.
01:20:34.506 - 01:20:35.110, Speaker A: Yeah.
01:20:40.200 - 01:20:51.360, Speaker C: It was confusing for me that the money doesn't go to the owner of the boss, it goes to the smart contract. So just to be clear, it's not going to this boss person when you deploy.
01:20:51.460 - 01:21:08.880, Speaker B: Go ahead. No, I was going to say that. That's a really good point because right now that money is gone forever. We'll get into that because that money is going to be locked into the contract because we don't have any withdrawal function or anything.
01:21:09.030 - 01:21:23.030, Speaker A: But a really cool insight there. When you deploy a contract, that contract now has an address and that contract can hold money just like an externally owned address, right? Yeah. And we'll get into that too. But let's see where we are here.
01:21:23.480 - 01:21:39.048, Speaker B: Let's get some signers and then let's connect this one. But instead of calling create, we're going to call by and to send some value.
01:21:39.214 - 01:21:42.700, Speaker A: I think there's any arguments, is there? Yeah, because we just said one.
01:21:42.850 - 01:21:58.816, Speaker B: Yes. So to send some value, you have to put like this square bracket and send the value. And then we have our friend ether's utils parse either. And then we want to send a.
01:21:58.838 - 01:22:19.504, Speaker A: Couple of weird things all at once. Right. So we're sending an extra argument in to be able to send value. And this is a little shaky. Like, everything is a transaction and every transaction has a to and a from. But there's also this value and data field. And the data field can be like if you're deploying a contract or if you're talking to a contract.
01:22:19.504 - 01:22:36.060, Speaker A: And then this value is like money that comes along with the transaction. And so we're sending a little money along with it when we call this function on this contract. And then we also use the parse ether to be able to get to the big number. A lot of gotchas here all at once.
01:22:36.130 - 01:22:58.580, Speaker B: Yes. We could also check this price, right? Like getting this price from the contract and sending that directly instead of like doing this hard coded. But I think we already did that for something. So let's do it this way. So this looks good. Just creating a transaction. This will be like buy right by transaction.
01:22:58.920 - 01:23:04.980, Speaker A: And then do we need to connect signer one on line 55, token connect.
01:23:05.050 - 01:23:07.284, Speaker B: Yeah, I guess we could. I mean, it will work the same.
01:23:07.322 - 01:23:10.272, Speaker A: Because we're just going to buy it as the boss.
01:23:10.336 - 01:23:12.890, Speaker B: Yeah, I mean, what makes sense, because you can do it for free.
01:23:13.500 - 01:23:17.172, Speaker A: Okay. Anyone can, including the boss.
01:23:17.316 - 01:23:21.770, Speaker B: Let's do it because we have signer one there. So let's do it.
01:23:23.360 - 01:23:36.576, Speaker C: And so the hard hat accounts by default, I believe, have ether inside them. But when you're using another wallet, it needs to have that testnet value or whatever you want to add there.
01:23:36.678 - 01:23:46.390, Speaker A: Yes. If you were deploying this to some testnet, you would need to charge up all these accounts with some ETH so they have money to interact. Okay.
01:23:47.720 - 01:23:48.580, Speaker B: Everything's working.
01:23:48.650 - 01:23:49.590, Speaker A: All right.
01:23:51.320 - 01:23:59.024, Speaker B: So let's see what happened. If we send like less than the money. That could be like another test, right? Like sending less than the.
01:23:59.082 - 01:24:01.800, Speaker A: A little bit less. Yeah. Should cause it to fail.
01:24:03.100 - 01:24:04.410, Speaker B: We should get.
01:24:06.940 - 01:24:07.690, Speaker A: Awesome.
01:24:09.420 - 01:24:10.170, Speaker B: Cool.
01:24:10.700 - 01:24:43.780, Speaker A: Okay, so what can our token do? Our token can. Now it has a limited supply and anytime you try to mint. Okay, so if someone calls the buy function, are we still limiting it? Yes, we are. There's that first require statement, which since we're writing that require statement more than once, we probably should almost make that into a modifier too, right? There should be a modifier of like within total supply or something like that, because that happens on both the buy and the create. But we don't need to do that right now.
01:24:43.850 - 01:24:52.490, Speaker B: Okay. In this case also, we'll take some arguments. Right. Because you will need to get like the quantity right to compute this.
01:24:53.100 - 01:24:57.464, Speaker A: Yes. Oh, that's right. Yeah. Then it gets a little hairier, doesn't it?
01:24:57.502 - 01:24:58.090, Speaker B: Yes.
01:24:58.940 - 01:25:22.080, Speaker A: Okay. The goal today is just to get you at home the resources and the exposure to be able to start tinkering with solidity. We've kind of gone through a lot of those early use cases, but then there's probably like a handful of things to go try or to try next. And maybe we should just jump over to that solidity by example page real quick and just kind of like. Yes, exactly.
01:25:22.150 - 01:25:23.010, Speaker B: Let's link.
01:25:23.780 - 01:25:44.356, Speaker A: Exactly. And a struct you can see here is there's a struct to do, and it's just a structure of other primitives. Right. You could have strings, bools, even other structs maybe. I don't know if you can do that. Strings, bools, un. All of those things that are the primitives.
01:25:44.356 - 01:25:51.092, Speaker A: You can have that. And notice this is a cool, like to do list. Right? So we're getting two things here. We're learning structs and we're learning arrays.
01:25:51.236 - 01:25:51.592, Speaker B: Yes.
01:25:51.646 - 01:26:17.350, Speaker A: There we go. So we create an array of our structs, and then you can see in the create function, it's showing you three different ways to populate that array. There's a push function, there's a push function where it's explicit about the data types, and then there's like an equals function where, oh no, they're all push functions, aren't they? It just depends on what you're pushing into there. Cool.
01:26:17.880 - 01:26:40.852, Speaker B: So I wonder, how can we add some extract into our contract, maybe like having some kind of identification in our contract, some people can have some data from them. It will be like a token holder data and have a name or country or whatever. And then we can, in a mapping.
01:26:40.916 - 01:27:15.760, Speaker A: Or something like that, something we would need to iterate through basically. So going back to that mapping, you can't iterate through mappings. Mappings are like a one directional, you put in the thing, you get the thing back. An array is actually something we can iterate through. We could write a for Loop and we could look through all of them. Just like thinking out loud here, what if there was a way to vote on increasing the total supply? And if enough people have voted on it, then we can increase the total supply. To be able to check those votes.
01:27:15.760 - 01:27:54.450, Speaker A: We would have a vote in a struct and we would need to loop through with a for loop checking all the votes to see if there's enough votes to increase the total supply. And if there is, we would increase the supply. So just know that you would have to increment through things. I don't think we have time to actually build that in today. But just like getting you at home just exposed to this process of tinkering and you go to solidity by example, you want to learn each of these topics. You kind of can paste them in here. You can make sure they compile, and then you can write tests to make sure that they do what you want them to do.
01:27:54.450 - 01:27:56.450, Speaker A: Yeah, there you go.
01:27:56.900 - 01:27:58.770, Speaker B: Something like this, right, would be.
01:27:59.620 - 01:28:37.980, Speaker A: And hopefully you at home know how to write a for loop. But that would basically you would do these pushes where you would push each vote in. There would probably be some vote function, and then you would loop through in a for loop checking that you have a certain amount of vote threshold and maybe some quorum together before you make that total supply change. I think that's a pretty good run through. What else? Okay, so two last things I want to cover. Let's talk about that payable function real quick. When we made that payable function, if you tried to send value in to a function that's not payable, it's going to revert.
01:28:37.980 - 01:29:09.160, Speaker A: If we scroll down, we see that non payable there versus payable. Yeah. See how there's a deposit function that's payable and then there's a non payable function. So if you as the user, try to send value to a function that's not payable, it's going to revert because it's trying to be safe. It wants to be very explicit about things. So it makes you, the programmer, write in for sure that this is payable. So another concept very similar to that is sending money directly to the contract.
01:29:09.160 - 01:29:22.348, Speaker A: Since the contract gets deployed and it has an address, then. So sending ether is the second thing I want to talk about. But the first thing I want to talk about is the receive function. Yes, it is there. Okay. It is there. Okay.
01:29:22.348 - 01:29:58.632, Speaker A: So the smart contract has an address and you're able to send ether to it. Let's just say we open up our metamask, our wallet, and we paste in the contract's address, and we try to send it $100 worth of Ethereum. The contract has to have this receive external payable in it. And if it doesn't, it's going to revert just like the payable function. But this is actually like a payable contract, right. Without having the receive function, that address actually can't receive E. You could just open up your metamask and you could paste in the contract's address and you could try to send $100.
01:29:58.632 - 01:30:32.580, Speaker A: And when you hit send, it's going to revert, it's going to fail right away because it doesn't have this receive function. So if you want people to be able to send ETH to your contract, you'll want to write in this receive function here. Basically you would throw that. Yes, you'd throw it right down in there. And you can actually write some things within those squigglies. If maybe you wanted to keep track of, I don't know, who did a deposit, or maybe you trigger an event, right? That's the payable. And then the other thing I want to talk about is just the sending ETH because it's kind of a gotcha.
01:30:32.580 - 01:30:59.550, Speaker A: If you wanted to send ETH within a smart contract, you would probably do a send or a transfer. Do we have that here? Yeah, there we go. See how it's address transfer, right. That's going to send money to. Basically that function is going to send whatever value comes in on the payable to the to address, right. So it's going to send it back. Oh yeah, send it to them.
01:30:59.550 - 01:31:34.324, Speaker A: An address is kind of like a first class citizen in insulin. You can say address balance or address send or address transfer. But there's a huge gotcha here because that's not what you actually want to send. You want to use to send ETH another gotcha. You want to actually use this call. And it's some ugly syntax, but this is the correct way to send ether in a contract. And the gotcha is sometimes you're going to be sending to a contract that has that receive function and it's going to have to do a little extra execution.
01:31:34.324 - 01:31:56.944, Speaker A: And so there's this gas limit issue. But forgetting all of that for now, this is just one of those like, let's put the gotcha out there and put it into your pocket. Don't use send and transfer, even though it's easier. You need to use this call with value anytime you're sending ether within your contract. Just to make sure that that gas limit thing doesn't spark up.
01:31:57.142 - 01:32:04.112, Speaker B: Yeah, I think like a good exercise for people at home is just writing the withdrawal function that we just talked.
01:32:04.166 - 01:32:07.410, Speaker A: Let's write the withdrawal function as people are buying this. Yeah, exactly.
01:32:08.420 - 01:32:18.980, Speaker B: So this will be only for the only boss. Right. And then do we want to do this live or should we keep this for people to do as an exercise?
01:32:19.720 - 01:32:33.320, Speaker A: Well, I mean, it's pretty ugly. We should copy and paste it. I think. I think we should do it because normally you would say, oh, we need to send the money to the message sender. So you'd probably do message sender send and then a balance of the contract.
01:32:33.400 - 01:32:38.828, Speaker B: Yes. So just copy this. And these two would be like the boss, right?
01:32:38.914 - 01:32:39.550, Speaker A: Yes.
01:32:43.780 - 01:32:52.652, Speaker B: This is interesting. This wanted to be something like this, right? So this will send the balance of the contract.
01:32:52.716 - 01:33:19.240, Speaker A: Weird line of code. You can see how weird this is, but this is just one of those gotchas. And all solidity developers sort of just get used to just doing it this way. And you look up sending ether solidity by example, and you copy and paste that call in here and you fill it out. And also that one weird thing you did there about the address, you're basically getting the entire balance of the contract using that piece right there. Pretty strange.
01:33:19.980 - 01:33:23.210, Speaker B: It's a really strange but really powerful line.
01:33:23.600 - 01:33:53.716, Speaker A: So there's one other thing I have in my list that we haven't covered, and that's events. So we've talked about storage and we've talked about memory variables for storage variables. But there's another kind of interesting sort of on chain storage that's not on chain storage. And those are events. And you can have your smart contract emit an event. And what that allows you to do let's say we're building a ledger, and we let a little bank. We're going to build a little bank, and we're going to let any user deposit or withdraw money.
01:33:53.716 - 01:34:29.424, Speaker A: We would use a mapping to track balances. When someone deposits it would be a payable function, and whatever message value you put in, it would increment your balance. When you withdraw, it would decrement your balance. Right. The user, if you came to the contract, would only have a current balance. And you could ask the bank, what is my current balance? But the user wants to probably see a whole ledger of all their deposits and all their withdraws. So the way you do that is you would have an event, and you would emit that event each time they call one of those.
01:34:29.424 - 01:35:11.832, Speaker A: And what that does is it allows your front end to say, hey, what are all of the events for this specific address? And it can show you, here's all the deposits and the withdraws. So it's kind of like a way to do on chain storage where you're asking a contract for some information and it's giving you back those events. But the gotcha with events is that other contracts can't read them. So as we get into contract to contract interaction, probably next week, one contract can't go look at all the events of another contract. They're only for off chain reading, but it's stored on chain. It's something that's stored on all of these machines. And you can ask any of the machines for my deposit history if you have those events.
01:35:11.832 - 01:35:31.936, Speaker A: So it's like a way of doing cheap on chain storage with the gotcha that other smart contracts can't read it. Did I cover that pretty well? You want to have events in your smart contract just so you can have your front end kind of reflect all of these things that have happened and you can read those events.
01:35:32.048 - 01:35:40.970, Speaker B: Yeah, probably in our example, emitting an event when a person buy a token will be like a nice example. Right?
01:35:43.980 - 01:35:49.336, Speaker A: Even like sends. Like if you wanted to look at recent sends, we would want to have that in there.
01:35:49.438 - 01:36:03.084, Speaker B: Yes. So for buying what will be like the buy log, and then we'll have the buyer here. And what else? Anything else? Or maybe not, because they can only.
01:36:03.202 - 01:36:08.168, Speaker A: Normally it'd be an amount, but you have it at one. Yes.
01:36:08.354 - 01:36:14.930, Speaker B: So then to emit one, it's just like, I think it's emit. Right. Emit and then buy.
01:36:17.220 - 01:36:52.060, Speaker A: It's a capital letter there. And that's kind of the naming convention. Yes. Looks good. And so then that would allow you to quickly get a list in your front end of each purchase, rather than having to parse all sorts of crazy stuff to be able to get that information. And kind of going into how web two developers start using smart contracts, a lot of times they'll create structs and they'll have arrays of structs. And in that struct is like first name and last name and address and how much they put in.
01:36:52.060 - 01:37:28.452, Speaker A: And that is going to cost your user hundreds of dollars every time they interact with your smart contract because you're storing so much information. But say you want that information somewhere on chain so people could look at it. You would use an event, not a giant struct, right? You want to have the minimum viable stuff in the smart contract and as much else off chain as you can. But sometimes you need that on chain storage. But in this case, if another smart contract doesn't need to read it, you can just emit it as an event. And those events are really powerful for the front end. Yes, solidity.
01:37:28.452 - 01:38:04.112, Speaker A: Solidity, crash course. Have we covered everything? Anything remaining? I think we may have really gone over time here in terms of, yeah, you at home, you should be able to hopefully use MPX. Hard hat, get hard hat down. Tinker with smart contracts, go to solidity by example. Look through each one of these. If you want to start opening your world up even more, you can scroll down a little bit farther on solidity by example. And there's like attacks and they start talking about reentrancy, they start talking about applications.
01:38:04.112 - 01:38:18.090, Speaker A: So just get in and start tinkering. Right? Use remix, use scaffold ETH, use hard hat, get in and just start tinkering. Any closing thoughts on solidity? You as a programmer should be able to figure it out. It's easy.
01:38:19.660 - 01:38:56.148, Speaker C: I think this was a good one to show also. Then we're going to get into Scaffold ETH and show like you can actually visualize what you're doing in the smart contract. Like the tests are a bit more pro to go in and just code that, but when you directly see, it's also easier to modify. And I just really want to reiterate the mappings part as well. That was really like a call for me because it's really painful to iterate real mapping like you can't. And yeah, I think the challenges really show you that when you get to speed run Ethereum as well. But yeah, just to reiterate that, because it took me a long time to.
01:38:56.154 - 01:39:25.760, Speaker A: Get that, I'm not going to lie. It's almost painful for me when we get that counter built and I'm like, okay, now let's go increment and decrement and make sure it does its thing. It's like, no, we got to go write another file that tests that. And let's write a test file for me. I want to poke at it, and I want to play around with it, and I want to see if it does what it does very viscerally. And we'll do that soon with scaffold ETH. But it's good to go through it on the hard hat side first, just to show that what, what's going on underneath the abstraction there.
01:39:25.760 - 01:40:09.912, Speaker A: And writing tests is also a good thing. You should write tests. You should write all these tests as you're writing your contract, and it's, like, fresh in your mind how it works. But a lot of times, I think traditionally, folks have just lived in the hard hat world and just written their smart contract and made sure it was super safe and deployed it and shipped it without writing the front end. And then later on, retroactively, someone writes a front end and then they realize, like, oh, my gosh, the user experience here is really not great. And so this is another thing that scaffold ETH will show you is as you're building your contract, you can kind of iterate on the front end, too, and it helps get that user experience solid, too. But we'll get to all of that later.
01:40:09.912 - 01:40:23.324, Speaker A: Thank you, Carlos. Thank you, EDTA. We did it the day one solidity. Hopefully you at home know how to tinker and know how to get started and you feel empowered by hard hat. Anything else? Any closing thoughts?
01:40:23.452 - 01:40:24.624, Speaker B: I think we're good.
01:40:24.742 - 01:40:27.168, Speaker A: Awesome. Thanks, guys. Thank you.
01:40:27.334 - 01:40:27.676, Speaker B: Bye.
01:40:27.708 - 01:40:28.110, Speaker C: Thanks, everyone.
