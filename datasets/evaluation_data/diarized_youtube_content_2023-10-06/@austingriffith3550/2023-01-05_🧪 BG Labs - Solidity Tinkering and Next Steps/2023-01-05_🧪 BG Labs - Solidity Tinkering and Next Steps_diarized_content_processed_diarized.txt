00:00:09.290 - 00:00:40.246, Speaker A: What's up? I'm Austin Griffith. Welcome to BG Labs. We explore all sorts of cool, interesting topics and deep dives into the Ethereum space. If you're getting started, if you're an intermediate developer, this is for you because we're going to get in and just figure out all the cool next steps that you need to take. Today we're doing, I think, tinkering with solidity. Carlos has set up a little curriculum for us, for us to speed run. How are you guys doing? You feeling like a good deep dive into solidity? Yes, and it won't be that deep of a dive.
00:00:40.246 - 00:00:43.178, Speaker A: We're talking arrays of structs, not delegate. Right?
00:00:43.264 - 00:00:46.410, Speaker B: Yeah, that will be like part three, but for.
00:00:46.560 - 00:01:14.434, Speaker A: Yeah, yeah. Okay, here we go. Let me share my screen. There we go. Awesome. Ok, so Carlos, you have set us up with a solidity deep dive that's going to take us through kind of first tinkering, then we're going to get through structs, inheritance, our deploy script, adding a new contract. I think we're going to look at what kind of things.
00:01:14.434 - 00:01:36.650, Speaker A: I think we're going to set it up. So you have to have a contract. Talk to the other contract. Let's just dive into it and get going. So you at home, you hopefully have done some scaffold ething, right? We've got Scaffold ETH up here. I've already installed it, but you can go to scaffold ETH IO or just Google Scaffold ETH and it's going to take you to this repo right here. I've already cloned it down.
00:01:36.650 - 00:01:56.080, Speaker A: Yarn install takes a little bit, so you want to kind of run that ahead of time. But then once you're ready you can yarn chain and then you will yarn start and then you will yarn deploy, right?
00:01:58.050 - 00:02:03.522, Speaker B: Yeah, that's going to deploy like the default contract that we have as an example.
00:02:03.576 - 00:02:37.680, Speaker A: Let's go take a look at it. Yeah, that is how you set up your stack and you have this kind of default contract. Where'd it go? You have a default contract here, let me zoom in a little bit more. And scaffold eat sets you up with this ability to kind of tinker with this default contract. You have this and every time you go over here, you go over here and do a deploy, then you'll get a fresh contract at localhost that you can tinker with. Okay, let's just show that one more time. I'm going to add some extra exclamation points.
00:02:37.680 - 00:02:54.450, Speaker A: If you haven't seen me do this demo ten times. You're not paying close enough attention. Because I do it all the time. There we go. So we just shipped a new contract with exclamation points. Let's see it again one more time. Can we put an emoji in there? We can't put an emoji in there unless I do something like Unicode.
00:02:54.450 - 00:03:05.430, Speaker A: Turn that into the fire emoji. No, no. BG labs. What are we talking about? BG labs. Some of that, right? Boop. Yeah. There we go.
00:03:05.500 - 00:03:06.294, Speaker C: Here we go.
00:03:06.412 - 00:03:26.958, Speaker A: Ship it. Ship it. Awesome. Our purpose is to learn stuff, to tinker, to play around. Okay. So we have our local stack, which is scaffold ETH. We're able to make changes to our smart contract, and then we're able to see those changes reflected in the front end, and then we're able to tinker with that.
00:03:26.958 - 00:03:30.938, Speaker A: So what is our first goal? Go ahead. Were you going to say something, Carlos?
00:03:31.034 - 00:04:02.250, Speaker B: No, I was going to say, how do you call this? It's like the adaptative front end. When you make a change into your contract, you can redeploy and you will see the changes on the UI, which is super nice when you are starting out with solidity because you can see directly on the front end what the changes that you have made. Because if you go through another way, you have maybe to write a test or deploy it live or something, but in this case you can just test it right off the bat with the new UI.
00:04:03.150 - 00:04:05.706, Speaker A: I think a great. Yeah, go.
00:04:05.888 - 00:04:22.902, Speaker C: I was just going to add on to, for folks that are new. Just coming to our first video ever. If this is it, it's just like a really hands on and direct way, like direct feedback loop. You have it with solidity. So it's just like a really hands on way to actually get deep with solidity.
00:04:23.066 - 00:04:28.820, Speaker B: Yeah. So you are adding like a counter in there?
00:04:29.590 - 00:04:54.006, Speaker A: No, I was actually adding a banner because it's like when you're like a radio guy who just first figured out how to do a podcast and you have that little button that makes all that sound. And I was going to do direct feedback loop and then I hit enter and I throw it on. Oh my God, that's hot. Yeah. Okay, so we've got our total counter streamyard.
00:04:54.038 - 00:04:55.050, Speaker C: Deep dive.
00:04:56.110 - 00:05:12.682, Speaker A: Exactly. Of playing around with streamyard. Okay, but look at that. So we added in a UN 256 counter and I deployed it with one quick thing and then we have a total counter over here. Right. And it's already set to zero. Okay, now we're making some headway.
00:05:12.682 - 00:05:13.840, Speaker A: What do we want to do?
00:05:14.310 - 00:05:17.922, Speaker B: Maybe you want to increment it. Yes.
00:05:18.056 - 00:05:34.374, Speaker A: So let's just look at that purpose real quick. That's another thing. So it's basically a string, and anybody can get in? I think anybody can get in, yes. There's not, like, an only owner here. Anybody can get in and set the string. So I could say, hello, world, and I could send that. And I don't have any money.
00:05:34.374 - 00:05:58.814, Speaker A: Okay, now we have to talk about faucets and burner wallets, right? Hopefully you know some of this stuff. But if you don't yet, when you land on scaffold eats for the first time, it generates you a wallet. It doesn't connect your metamask in. It doesn't connect any of that stuff in because usually you're on a local chain, and that's weird. With metamask, what you want is just have this nice little burner wallet and then hit this little button. And now we have money on our local chain to say, hello, world here. There we go.
00:05:58.814 - 00:06:08.482, Speaker A: We spent a little gas. We made a transaction. We called set purpose, and we updated our purpose to hello, world. Oh, wait. Is our direct feedback loop. There we go. I got to hide that.
00:06:08.482 - 00:06:26.146, Speaker A: There we go. Okay, so now we can tinker, right? We're able to add things to our contract. We're able to see it in the front end. We added a total counter. Let's set it up. So every time someone sets the purpose, the counter equals counter times counter. We're going to square the counter.
00:06:26.146 - 00:06:48.686, Speaker A: Who even does that? Oh, it needs to start at one then or two then, or it's going to be all weird. Right? Let's see what this does. I don't know. We're just tinkering happy little trees and whatnot. We're just coming up with stuff here. Okay, so now if I say, hello and I send that transaction, it goes to four, and if I say, hey, it goes to 16. And if I say, hi, hi, it's going to go to 256.
00:06:48.686 - 00:07:18.822, Speaker A: Okay, so we definitely are changing our solidity. We're deploying it. We're making some weird little code thing here, and we're getting to see that in the front end. That feedback loop is super important. Like, Carlos, you were saying when we did the scripting in week two of the web two to web3, we added an ownable. And then we spent 20 minutes writing a test of whether or not the owner could set something or not. Right, but it's so much easier if you add ownable here to test for the very first time.
00:07:18.822 - 00:07:45.650, Speaker A: It's so much easier just to come over here and say, can this account do it? And then if I open up an incognito window, can this other account notice how this is a different account than this? Can this other account access it? Right? So we have the ability to test things. We have the ability to throw code in and get to work. So let's dive in. We're looking at an array of structs. Of structs. Guess what? I'm making a banner for it. Boom.
00:07:45.650 - 00:08:19.826, Speaker A: And what do we do when we're trying to learn some solidity? Of course, you go to solidity by example, the best place to find out information. And I think we're looking at structs, right? What the heck is a struct? Okay, so I got like a struct here. All right, let's bring it in. Okay. It's probably not going to be to do since we have these purposes, maybe this will be like, I don't know, an entry. Let's see what you added here. So you say we should create a struct.
00:08:19.826 - 00:08:21.694, Speaker A: I'm just going to copy yours, actually. Come on.
00:08:21.732 - 00:08:22.320, Speaker B: Okay.
00:08:24.130 - 00:09:01.754, Speaker A: And the struct has two primary data types, right? It has a string and then it has a timestamp. And instead of creating like a mapping where we have an ID, and then with that Id you could go to either of these two. It's much easier to have a struct of those things. And I'm guessing it encodes it better in solidity too. I'm assuming that a struct does some packing and does some good stuff where if you tried to reference each one, like if you had an array of each one of these and then some ID, you could look it up, but I bet it would be way more expensive. But I am not a genius. I don't know anything about that low level stuff.
00:09:01.754 - 00:09:31.806, Speaker A: Carlos is learning by the day though, so he could teach us in the next episode. Okay, so we have a struct, which is going to be a proposed submission. Then we're going to set up a mapping to that struct. So given some address, we will have an array of proposed purpose submissions. Okay, so for each user. So we're going to track an array for each user. So Carlos will have his own array, Eda will have her own array.
00:09:31.806 - 00:09:56.458, Speaker A: I'll have my own array by address. And then what do we need to do? So when someone sets the purpose, we are going to create a new, this is interesting. How you did this. Okay, so you did a push. And inside of that push, it creates a new struct and it does it this way. Okay, there's different ways to do this and let's look at those real quick. Right.
00:09:56.458 - 00:10:24.754, Speaker A: And I love solidity by example because it gives us a to do list and it gives us all three different ways to initialize it. Here's the method that Carlos chose. I'm actually going to switch it up to this method. I think this is more explicit. That's where I'm going for. Yeah, this is more explicit. Instead of saying that, I want to say it like this, and that gives me like an object and I can say the text is this.
00:10:24.754 - 00:10:50.870, Speaker A: So let's see, we have text, right? Text needs to be equal to our new purpose and then completed needs to be, oh, what was that? Date stamp. I'm going to copy your thing again. Oh, you're just doing block timestamp. Okay, no big deal. And it's actually timestamp right now. Is that happy? Okay, so that's just a little bit more explicit. So you kind of have text equals new purpose timestamp equals block timestamp.
00:10:50.870 - 00:11:09.874, Speaker A: Instead of doing it, just arguments in order. In this way we can kind of be explicit about it. So let's see, can we just ship this? Let's see what it does. Let's go straight to the deploy. Hey, work first try. Okay, so now let's go test it. Right? Let's go over to the app.
00:11:09.874 - 00:11:29.074, Speaker A: And now let's see, we'll set purpose, right? I'll say one, two, three. Okay, so now there should be an array of structs for this address, right? So can I do this? And then it needs a number. So zero.
00:11:29.132 - 00:11:31.180, Speaker B: That should be one, right? Yeah.
00:11:31.630 - 00:12:12.934, Speaker A: And then if I put in my address and I ask for number two or number one, that's going to give us number two because it's zero indexed. But yeah, basically what we see here is we're able to access that array and get information out of it at different indexes for a different address. So let's come in from a different address. Right? Let's come up with an incognito and let's dive in and let's grab some gas. All right, so we got this green dude and this teal dude here, right? And if we, for instance, try to grab the zero, it's going to blow up when I do this. Basically we're asking for index zero. Oh, yeah, it did not like that.
00:12:12.934 - 00:12:39.166, Speaker A: Did it blow up over here? Transaction reverted. Okay, didn't even tell us anything. But basically there is nothing there until we say hey. And now when we ask for item zero, we get hey back. Okay. So it seems to, without writing an intricate test bench, it seems to be working. It seems to be creating these elements and adding them to the array and tracking a struct of things.
00:12:39.166 - 00:13:11.926, Speaker A: Let's just go ahead and add one more thing and let's say value, right? Let's say they send in money every time. And that would be the value is now message value. And we need a comma and let's deploy that. So now you can set a purpose and you can add a little money in and it's going to track how much money you added in too. So now I'm going to do the zero indexed so zero, and I'm going to send in one ETH. I might need some more money. Let's see, I got to take it times ten to the 18.
00:13:11.926 - 00:13:43.742, Speaker A: Come on now, come on now. Now if I look at my address and the zero th element, we should see that there was also some value. Now. So we added a new thing to our struct and we added that to the constructor and now we can kind of track that. So that is arrays of structs. And you see this, the best example of this is go build a multi sig that tracks the transactions all on chain. You'll notice this multi sig wallet at solidity by example, keeps track of transactions.
00:13:43.742 - 00:14:15.882, Speaker A: Look at this struct. That's a heck of a struct. Basically it's an ethereum transaction, right? A two, a value, a data, whether or not it's been executed, how many confirmations it has. So you as a user, you would add one transaction here and then people would get in and they would confirm your transaction. And if enough people confirm your transaction, they would execute it. But holy cow, that would be expensive imagining having to do all that stuff on chain. The gnosisafe and other multisigs now use a signature based system and it's a single transaction, even for batch transactions.
00:14:15.882 - 00:14:35.300, Speaker A: But I'm down a tangent. You guys should be zapping me to get me back on course. So what is next here? So we've added our array of structs. We are able to iterate through the mapping. We're able to read it and test it. Are we ready to move on to inheritance or did I miss anything there?
00:14:36.230 - 00:14:40.118, Speaker B: No, nothing's good. Yeah, I have the banner ready here.
00:14:40.284 - 00:15:26.606, Speaker A: Inheritance. All right, here we go. So inheritance allows us to bring in other contracts, right? The ownable is one of the first ones that you'll see in a lot of smart contracts. Basically, you set up some kind of owner address, right? Some kind of address owner. And then you have a set of functions that only that owner can call. And you would rather just inherit that logic from open Zeppelin or someone who has created this and has lots of eyes on the contract rather than us just bang it out right now and write an ownership pattern, which we could do. And honestly, I bet I could do it in a way that's probably pretty secure.
00:15:26.606 - 00:16:13.826, Speaker A: But then as soon as you start getting to beyond just like role based access stuff, tokens like ERC 20s, ERC 720 ones, tons of different standards, tons of different things, you can go to these open zeppelin contracts and find a working version that has had many nerds poring over it, thinking about how to make it secure and make it better, rather than just banging out your version of it live on a session, right? So inheritance has this nice pattern of, first of all, we can have many smart contracts that we inherit in, and it keeps our main contract looking thin. But also the stuff that we're importing in has had many developers looking at it, so it's just more secure and just better practice to use their code rather than rewrite our own code.
00:16:13.928 - 00:16:33.210, Speaker B: I think, by the way, it's really good to learn just to implement your own patterns, but just for the sake of learning. But like Austin was saying, if you are going to deploy live, you are probably better if you just use some battle tested version from a third party, like open seplin.
00:16:33.790 - 00:16:58.340, Speaker A: But definitely write your own ownership pattern first. Write your own ownable. And basically you would write it natively into your contract. And you would be like, okay, I want to extract this out to its own library or its own contract, and I want to be able to inherit it, but go through the motions of now. Now, you would import ownable, and you would have your own ownable right here locally. But instead we can also bring it in from open Zeppelin. Basically uncomment this.
00:16:58.340 - 00:17:27.542, Speaker A: Here we go. Here's inheritance, right? You import something, you say that it is ownable, right? You add that extra is ownable. And now let's not do anything else. Let's just deploy that and let's look at the difference of this contract. Whoa. Some new things got added, right? We see like a new owner here, we see a renounce ownership. We see a transfer ownership, and if we try to renounce ownership, that should fail, right? We're not the owner.
00:17:27.542 - 00:17:54.946, Speaker A: And that also adds this new modifier, only owner. And so let's go here. And let's say only owner can set the purpose now, right? That's probably not the right order, but let's go with it, see if this works. There we go. So now only the owner should be able to call set purpose. And what we're going to run into here is it's not going to be me, right? We are not the owner. What is happening here? Who is the owner? Might be a good question to explore here.
00:17:54.946 - 00:18:18.700, Speaker A: So this f nine Gibroni, this guy is the owner, F 39. And we are this 428. So who's this F 39? And I think a kind of hint here is if you go down to the faucet and you open up this wallet, you'll also find this, you'll find F 39 here, and you'll notice that they have millions and 10,000 e, right?
00:18:19.710 - 00:18:20.122, Speaker B: Yeah.
00:18:20.176 - 00:18:58.774, Speaker A: So this is the hard hat account. Basically, when we spin up this node over here, it gives us a bunch of accounts with a bunch of ETH in them, and that's this guy and that's who's doing the deployment. So what we need to do is transfer the ownership, right? We'd love to deploy the contract from this deployer account. And you should always have a deployer account for a separation of concerns. You create a deployer account, you only send $100 to it. So then when it deploys, it doesn't spend thousands of dollars on accident, and then it's isolated to that address. But then you need to transfer the ownership to some account that you can use in the front end.
00:18:58.774 - 00:19:00.460, Speaker A: And I think that's what's next here.
00:19:00.910 - 00:19:01.660, Speaker B: Yes.
00:19:02.430 - 00:19:07.098, Speaker A: So let's see, it looks like you added pausable too. Should we add that in too?
00:19:07.184 - 00:19:13.926, Speaker B: I mean, that was only to show that you can inherit from multiple contracts.
00:19:14.118 - 00:19:27.410, Speaker A: But it's cool to show. Let's do it, let's do it. Let's do it. So let's bring in, I'm just going to copy paste your stuff, but say you want it to be ownable, but also you want to be able to pause it. Right? What is it? Just comma separated. Right. We do ownable and we do positive.
00:19:27.410 - 00:19:51.322, Speaker A: And also sometimes if it's an ERC 20, you're going to need to call the constructor of the inherited thing. This is pretty weird, but you do it right here, like, say ownable somehow had some thing that you would send in. I think you'd do it just like this. And you would send in some other argument. Argument, which is pretty weird. But you'll see it a lot with ERC 20 because you need to do.
00:19:51.456 - 00:19:53.370, Speaker B: Token name or something.
00:19:53.440 - 00:20:14.770, Speaker A: Symbol. Yeah, token name and token symbol, something like that. Where you're inheriting ERC 20. You're inheriting ERC 20, but you need to send in some arguments to make that ERC 20 happen. And that's a token and symbol. You do it right there in line with your constructor and it's pretty strange, but you'll figure it out. It's ownable and pausable.
00:20:14.770 - 00:20:19.940, Speaker A: Do we call pause anywhere? Oh, you just added it. Just to add it.
00:20:21.030 - 00:20:23.854, Speaker B: If you deploy it, you will see some of the functions.
00:20:23.902 - 00:20:31.986, Speaker A: I guess more functions like a pause function is going to show up and I'm guessing that only the owner can pause it. Right. Let's see, where's that pause?
00:20:32.018 - 00:20:37.682, Speaker B: Let me see if I think it's like an internal function. So you need to call it. It's not visible, I think.
00:20:37.756 - 00:20:42.650, Speaker A: Got it. So is it like pause? Maybe? Is it like underscore pause?
00:20:45.950 - 00:20:48.010, Speaker B: Yes, underscore pause.
00:20:53.250 - 00:21:05.050, Speaker A: Nice. So now it's going to start not paused, but then as soon as we set the purpose. Oh, we're not the owner yet. Dang it. Okay, so let's go transfer that ownership.
00:21:05.210 - 00:21:05.822, Speaker B: Yeah.
00:21:05.956 - 00:21:33.510, Speaker A: Doing a lot of things at once here, but this is going to get us into the deploy script, and this is going to show off how the deploy script works. So we used hard hat deploy from Wigawog, and that works really well. You have this deploy script here, and it's going to deploy your contract. And if you have arguments you want to send in, you can send them here. And then it lets you orchestrate some stuff. You can do some stuff. So what we're going to do is we're going to deploy our contract.
00:21:33.510 - 00:21:52.938, Speaker A: And remember, it's going to be this dude's address. F 39 is going to deploy it. And then F 39 has access to the contract. What we're going to say is we're going to say yourcontract transfer. Oh, it didn't autocomplete it. Okay, there we go. We want to transfer ownership to this dude.
00:21:52.938 - 00:21:54.962, Speaker A: All right, that didn't work.
00:21:55.016 - 00:22:01.940, Speaker B: Yeah. So this is like a one time thing that you are going to do, right when you deploy your contract. What's happening?
00:22:03.350 - 00:22:22.506, Speaker A: Transfer ownership is not, I think maybe I need to do reset. I spelled it wrong. That's what's going on. Do deploy. Okay, now we'll see a second transaction. Actually, let's put a console log in there. I want to do it? Oh, wait.
00:22:22.506 - 00:22:37.082, Speaker A: Do I need to await that? I need to await that too. Let's see if it's not working. This would be a good thing to troubleshoot. Transfer ownership. Okay, now let's do that. Deploy and let's see who ends up being the owner. Aha.
00:22:37.082 - 00:22:55.710, Speaker A: Look at. It's not happening. What the heck, right? It's this dang await. If you don't await it, it's not work. Okay, so you're running this transfer ownership. You're seeing the transfer ownership, but then you're seeing the contract doesn't have the right thing. What the heck is going on? You forgot the await.
00:22:55.710 - 00:23:13.660, Speaker A: You need to await it. Be patient, sir. All right, now let's try it again. Transfer ownership. The owner. Okay, it worked, right? So now that we're the owner, we should be able to set the purpose to hello world. And we should be able to send in some amount of money.
00:23:13.660 - 00:23:26.206, Speaker A: And when we send it in, it should pause too, right? Yeah. Now the contract is paused. Look at that. All those things happening at once here. Hopefully you at home, the developer are following all these weird things we're trying.
00:23:26.388 - 00:23:30.734, Speaker B: So maybe now you can. Sorry, I was just going to say.
00:23:30.772 - 00:23:34.654, Speaker C: Maybe it would be cool to quickly show that you can't do it from an incognito account as well.
00:23:34.692 - 00:23:47.854, Speaker A: Okay. Yes. Let's just make sure that go to local host. So this is a bad guy, right? And bad guy wants to, not the owner. Yeah, let's see. So can he do this? No. Caller is not the owner.
00:23:47.854 - 00:24:05.882, Speaker A: And can he do things like try to pause it? Oh, pause is internal. But if he tried to renounce ownership, that doesn't work. If he tries to set the purpose that doesn't work, he can't do anything. He's totally useless. Which means that our smart contract is useless and it needs to be more accessible to more.
00:24:05.936 - 00:24:18.240, Speaker B: I was going to say that you can add like this when not post modifier to the set purpose. So if you do that, we will get locked when you set the purpose for the first time. Right?
00:24:18.930 - 00:24:26.786, Speaker A: Okay, so you're saying maybe there could be another function that's like a mint function that does something else, but it.
00:24:26.808 - 00:24:36.360, Speaker B: Can be like on the set purpose next to the only owner. You can say when not pause there. Yeah, the same.
00:24:37.050 - 00:25:08.266, Speaker A: Oh, do we still have our counter? There we go. Yeah, let's do it. Total counter times equals two. So now we have a mint function that you can only call when it's not paused and it increments our counter. So let's go try that out. Okay, so now we have our kind of external person, and that person should be able to call mint because things are not paused so they can call mint. And we see our counter going up every time someone calls mint.
00:25:08.266 - 00:25:47.690, Speaker A: So anybody in the world can call mint until we pause it by setting the purpose for some reason, now it's paused. So then if this person comes over here and tries to mint again, they see that it is paused and it fails. So by bringing in the pausable, we make the contract possible by inheriting it, and then we pause it in the set purpose. And then that function only works when not paused. So it has that nice modifier there. Does that kind of COVID it? It's a little wild, but I think we covered it. Okay, so now transfer ownership.
00:25:47.690 - 00:26:08.462, Speaker A: This transfer ownership we're doing here. Let's do this in a little different way. Right? Let's do this. In the smart contract, Carlos is telling us you're making a second transaction here. So there's a lot of overhead. You're burning an extra 21,000 gas to make this second transaction. What we can do is we can make this happen in line with the deployment.
00:26:08.462 - 00:26:23.160, Speaker A: We can say on constructor, we want to transfer ownership, but not to the message sender. We want to send it to this brony right here. You did something else. You did like this.
00:26:24.010 - 00:26:30.102, Speaker B: So you can pass it as an argument. Right? You see, like the address initial owner.
00:26:30.166 - 00:26:51.086, Speaker A: Oh, I see. Someone could bring it in here. Okay, so this could be an address, underscore owner. Right? Here we go. Yeah. And then that underscore owner can go here. So what's the difference between me calling transfer ownership like this and you calling transfer ownership like this?
00:26:51.188 - 00:27:05.106, Speaker B: It is the same thing. But you were saying before, in this case also, I like to be more explicit. Right. Because if not, you can guess it. But this is like, okay, explicit about it.
00:27:05.128 - 00:27:11.334, Speaker A: We're writing a smart contract that's going to hold millions of dollars. We need to be explicit about it. Okay, so now what happens?
00:27:11.452 - 00:27:13.298, Speaker B: But you need to pass that argument.
00:27:13.394 - 00:27:41.760, Speaker A: All right. In our deploy script. Now we have arguments here. When we deploy it, an argument will come in and that will be an address owner. So kind of same thing. We're just going to grab that stuff and kind of move it up into the constructor. But now a single transaction happens, the contract deploys, and some contract arguments come with it, and we get that extra little bit of execution right there.
00:27:41.760 - 00:28:00.454, Speaker A: And we should start out as us as the owner. Okay, let's try that. Where's our Gibroni over here? Let's bring this guy in. Let's make him the owner just to prove that it's working here. Let's see that new owner show up here. Okay, it is, it's working. Okay, so now we're able to, let's see.
00:28:00.454 - 00:28:58.882, Speaker A: So what have we done so far? We've tinkered, right? We've showed you how to make changes and deploy. Then we've showed you how to create a struct and then populate an array of those structs, which is like, honestly, that's the level of complicated that most smart contracts are is about there, right? Arrays of structs is like, that's when you're putting so much stuff on chain, it's starting to get so expensive. Most solidity smart contracts are about that level of complicated. And then people get really complicated with gas optimizations and writing things in assembly and stuff like that. But in terms of you as a developer, what you need, this is getting you pretty far into it. We've talked about inheritance, how you can inherit some other scripts, then the deploy script, how you can orchestrate that stuff. I think we're ready for new contract.
00:28:58.882 - 00:28:59.930, Speaker A: What do you guys think?
00:29:00.080 - 00:29:02.540, Speaker B: Yeah, it's time.
00:29:02.910 - 00:29:22.750, Speaker A: It's time. Okay, so now we want to create a new, so this is kind of tricky because with this deploy script, we're deploying your contract. With the display, we're displaying your contract, we need to bring in this new contract here. Okay, so let's create, I'm just going to create a new file, right? And it looks like you called it withdraw.
00:29:24.450 - 00:29:26.354, Speaker B: Like withdrawer something. I don't know.
00:29:26.392 - 00:29:28.850, Speaker C: Yeah, withdraw our contract.
00:29:29.590 - 00:29:33.346, Speaker A: Withdrawer. Like that. Or the, or let's see.
00:29:33.368 - 00:29:33.666, Speaker B: I don't know.
00:29:33.688 - 00:29:34.530, Speaker A: It doesn't matter.
00:29:34.680 - 00:29:38.518, Speaker B: You are the one that knows English better than really.
00:29:38.604 - 00:30:08.366, Speaker A: Not really. Okay, here we go. Let's see. So we called it withdrawal contract. I want to hear Carlos say, okay, so it looks like we have, we have our usual stuff. We have a off from function that takes in an address and then we're allowed to receive some ETH for some reason. I don't know if we even need to do that, but it's there.
00:30:08.366 - 00:30:30.358, Speaker A: Okay, so this isn't going to get deployed. If I hit save and I hit deploy, all that we have is your contract going out. Right. It's still not deploying our withdrawal contract. So what we need, I think we duplicate this, right? Don't we usually just kind of just like copy paste this and then you.
00:30:30.364 - 00:30:46.010, Speaker B: Can do it on the same file. And sometimes you need to do it in the same file because you are getting the address from a previously deployed contract and use that address to do a next transaction to the new contract. But in this case, I think it's fine.
00:30:46.160 - 00:31:05.982, Speaker A: I think you can do that here too. Let's try it. So let's say we pass in this contract here, but then let's say in this second contract. Watch this. I think I can do the same. Your contract line. And I think we could pass in yourcontract address right here as an argument into the second contract.
00:31:05.982 - 00:31:12.980, Speaker A: This will be a fun test. We'll find out. So our second contract is called, I have to copy and paste it.
00:31:13.430 - 00:31:14.350, Speaker B: Withdrawer.
00:31:14.430 - 00:31:29.334, Speaker A: Withdraw contract. Okay. And it's going to take in our, your contract. And then if we wanted to, we could access our withdrawal contract down here. And I think there's even that thing right there. Okay. The last thing we need is our withdrawal contract to take in.
00:31:29.334 - 00:31:36.666, Speaker A: We need a constructor to take in a random address for some reason. Just to say that we did it.
00:31:36.688 - 00:31:48.702, Speaker B: No, I mean, it can be like the contract that you are going to withdraw funds from it. So maybe we can remove it from the line 14 and getting that address on the constructor. You know what I mean?
00:31:48.756 - 00:31:52.254, Speaker A: Okay. Instead of taking in an address here.
00:31:52.372 - 00:31:53.938, Speaker B: Yes, you can remove that.
00:31:54.024 - 00:32:12.950, Speaker A: We'll just have like a withdraw function and it will withdraw from wherever we set up here. So let's see. Really, we might set up a contract. Let's just do contract address. Let's just do this. Let's say contract address equals underscore Addie for now. And it'll be public and we'll be able to see it.
00:32:12.950 - 00:32:37.022, Speaker A: That's far enough. Let's see what happens when we deploy this f around and find out. There we go. There we go. So our withdrawer account contract did deploy. Now if we go over here, though, we don't see it yet. The last little piece here is you're going to have to jump into your front end for a second and you're going to have to go to the source app JSX and find we're going to get better at this since caffeine too.
00:32:37.022 - 00:32:54.930, Speaker A: You don't have to scroll down this far for this, for the next ones. But what you do is there's this contract object. This contract object is so handy. It's basically giving you this whole thing and it's auto adapting to everything. Look at this. We can grab this and I can just paste in another one. And I can paste in with, please just auto.
00:32:54.930 - 00:32:59.990, Speaker A: And now, oh, I didn't even need to redeploy, but I just redeployed.
00:33:00.810 - 00:33:06.230, Speaker B: That's like the withdrawal.
00:33:06.890 - 00:33:41.026, Speaker A: Oh, wow. Okay. The AI gave me the wrong answer, which happens a lot actually, and it gives it to you in full confidence. Like here, sir, here's the thing you need. Okay, so now you can tell that this contract is now tracked in this contract because we're passing it in this deployment here. When we deploy the withdrawal contract, we pass in the address from the previous contract. So let's just run it a few times.
00:33:41.026 - 00:34:07.754, Speaker A: Let's run the deployment. We'll get a new address here, and we'll see that it's plugged in here. Do it again. We'll get a new address here, and we'll see that it's plugged in here. See how that's working? So now we can kind of deploy our, your contract sets us as the owner, then it deploys the withdraw contract and passes in this contract. So our second contract knows about our first contract, and now we can interface with it. Okay, so let's see what we got here.
00:34:07.754 - 00:34:14.234, Speaker A: Oh, deploy script. Right. We got that. Okay. And we added that into the front end. Yes. Okay.
00:34:14.234 - 00:34:55.194, Speaker A: So then it looks like, what do we want to do for this withdraw function? So it looks like in the first contract we're going to implement a new function. So back in our your contract, in this big mess of things that we're tinkering with here, let's create a new function here. And what happens here, it requires. Okay, this is a fun line of code right here. You only see this in games and stuff. You rarely ever see this in production or anything like this. But what this is doing is that the TX origin is the person who signed the transaction, and the message sender is basically the from address in terms of who is calling this function.
00:34:55.194 - 00:35:39.298, Speaker A: So if you have one contract that calls another contract, the message sender is that previous contract, but the TX origin is the original account that signed the transaction to make everything work. I may not be explaining it perfectly, but you know where you can find this information? You can go to solidity by example and find origin. And it's going to say phishing with TX origin, and it's going to teach you about that stuff. There's probably even, no, it's just that one, but worth checking out. But also you can tinker with Scaffold ETH, set up a txorigen, set up a message sender, see who those are, and see how those values work. But all we're doing here is we're forcing it to be a contract. We're not letting what's called an EOA, we're not letting an external account call this withdraw.
00:35:39.298 - 00:35:59.822, Speaker A: We're basically requiring that you call this withdraw from a contract. So that's where we need that second contract. So basically we'll have some second contract call withdraw on this first contract and then it's going to call, oh, wow. Okay. It's going to send money. This is just sending money. Okay.
00:35:59.822 - 00:36:20.318, Speaker A: Yes. Technically it could call a function, but it's basically doing a blank call. There's no call data, but it's sending value. So withdraw basically says, are you a contract? And if you are a contract, I'm going to send you all my money. Is that about right? Okay, cool. So now we need to set up. Let's go ahead and just deploy that.
00:36:20.318 - 00:36:22.214, Speaker A: Right? Let's make a baby step here.
00:36:22.252 - 00:36:25.266, Speaker B: So maybe you can test that. It's not going to allow you to withdraw.
00:36:25.298 - 00:36:26.246, Speaker A: This should not work, right?
00:36:26.268 - 00:36:30.474, Speaker B: No, but not that one because it needs to be like the other.
00:36:30.592 - 00:36:53.178, Speaker A: Oh yeah, it's this one here, withdraw, not a contract because we're calling it as an EOA. So what we want to do is have a withdraw in our new contract that's going to reach out and call the withdraw in the other contract. Right. So we need to go to this guy. Oh, look at that. You've already got us started, so look at this. Thank you to the AI.
00:36:53.178 - 00:36:54.974, Speaker A: Wait, that is not right at all.
00:36:55.092 - 00:36:59.810, Speaker B: No. Maybe you can go, what do we want to do? We want my notes.
00:37:00.150 - 00:37:03.780, Speaker A: We want to create a new contract instance. Right?
00:37:04.870 - 00:37:07.460, Speaker B: You can do with this interface, yes.
00:37:07.990 - 00:37:21.010, Speaker A: Here we go. Okay. Contract to contract interaction. This is so much fun. You as the builder, you've probably done this a couple of times. You've probably done this to the token vendor. The token vendor contract, I think teaches you a lot about contract to contract interaction.
00:37:21.010 - 00:38:04.210, Speaker A: But if you want one contract to talk to the other, you can do this raw call thing that we are doing there and pass in some call data. But that is not the way you want to do it. You could technically call something on another contract. That way what you want is you create this interface, and an interface basically tells you about the functions and the arguments you're going to call without actually implementing the contract. So we have this nice, your contract interface now. And what we'll do is we'll instantiate this and we'll say this is your contract and it's going to be equal to this and the contract address. So it says we're going to go to this contract at this address and we're going to talk to it with this interface.
00:38:04.210 - 00:38:32.590, Speaker A: Assuming that this contract is going to have some withdraw function now we should be able to go your contract withdraw and we should be able to call that. One little side note here. If we put a new in right here, totally changes the functionality. If we put a new in here, this is going to deploy a new contract with this code. So basically it creates a factory. Right. So very different functionality between if you have a new there or not.
00:38:32.590 - 00:38:40.766, Speaker A: But instead we don't want to create a new contract. We want to go out to an existing contract and call withdraw on it. Let's see if that's close to what you have in your notes.
00:38:40.878 - 00:38:41.442, Speaker B: Yeah.
00:38:41.576 - 00:38:57.462, Speaker A: Oh, look at that. You instantiate it and do it in one line. Oh, that's nice. Probably should save some gas somehow. Okay, so now we can't call withdraw on your contract, but we should be able to call withdraw on.
00:38:57.596 - 00:39:01.370, Speaker B: I mean, we don't have any money. Maybe you want to send some money to the.
00:39:01.520 - 00:39:16.618, Speaker A: Yeah, because you're not going to be able to see it happen. Right. Okay, so we need to send some money to this guy. Bam. Should have $100 in it. There we go. Then when I call this, it should sweep the $100 up to this contract.
00:39:16.618 - 00:39:29.842, Speaker A: It did. Hooray. I want to get an emoji like a clap. What do we got? Clap emoji. I'm just having a great time with these banners. Boom, boom. There we go.
00:39:29.842 - 00:39:35.294, Speaker A: A couple of claps. Yes. Send it. Yes. There we go. Okay. I don't know what I'm doing.
00:39:35.294 - 00:39:38.502, Speaker A: Okay. Is that it? We finished it.
00:39:38.556 - 00:39:45.320, Speaker C: Okay, one last thing is we probably don't want everyone to withdraw the money. Right?
00:39:46.410 - 00:39:50.794, Speaker B: Yeah, I think that was on the extra. Right? On the extra part of the.
00:39:50.912 - 00:39:52.042, Speaker A: You've got an extra part?
00:39:52.096 - 00:40:05.818, Speaker B: Yeah. I didn't implement it, but yeah, that's something that maybe we can have like an allow list on the purpose contract and we can set the addresses that are allowed to withdraw.
00:40:05.994 - 00:40:29.734, Speaker A: Okay. So right now all we're checking in the withdraw statement is that you're not an EOA. Basically you have to be a contract to get in here. But what you guys are saying is let's have some address, public allowed or something like that. And let's set that to. We'll have to be able to update that address. Right.
00:40:29.734 - 00:40:51.094, Speaker A: Because that will change as we deploy things. Let's do this. And then you could have a function this set allowed or something like that. And it will take in an address and set it. Right. Only the owner can do that. And then we need to require that message center equals allowed.
00:40:51.094 - 00:41:20.920, Speaker A: Okay, did we do it? Was that it? Let's ship it, put it on main net. Okay, so how do we test that now? So what we need to do now is if I call withdraw over here, it's going to say something like not allowed, right. And if I call withdraw here, it's going to say not the owner. So we have to orchestrate some stuff here. We need to set allowed equal to this guy's contract. Right, set allowed to that. What did I do? There we go.
00:41:20.920 - 00:41:37.862, Speaker A: There we go. And now allowed is set to that. So now when we call this, we're allowed. Tada. So now only our contract can call the withdraw and still take the money out. All right. That was like a quick deep dive for you as a developer.
00:41:37.862 - 00:42:16.194, Speaker A: You should be able to get scaffold ETH up quickly. You should be able to go to solidity by example, pull in these concepts. You should be able to tinker and try things out. Don't write a bunch of scripts just to check that it's working like Tinker around with it first. Of course you'll need scripts eventually, but you want to kind of just have this nice feedback loop where you can try these things out, paste them in, test your assumptions, add your new deploy scripts. You should be able to sit down in a quick session and really try a lot of these things out. We just wanted to kind of scratch the surface and show you a little bit more about how you can get a little bit deeper into tinkering and just kind of like next steps with new contracts.
00:42:16.194 - 00:42:41.934, Speaker A: And let's just real quick, don't forget that when you want this other withdrawer here, you need to come in here and make that new contract object. I think that might be one of the trickier things that we did here. It's not technically tricky, but it's just like this is how the tool works and you need to bring in that contract object. Awesome stuff. Solidity, deep tinkering. Yeah. Hopefully you are started at home on this.
00:42:41.934 - 00:42:44.980, Speaker A: Anything else? Eda and Carlos, did we cover it?
00:42:45.350 - 00:42:47.540, Speaker C: We covered a lot, yeah.
00:42:49.110 - 00:43:25.882, Speaker B: I want to say that, don't forget about testing. I mean, we are saying that this is better than testing in a sense that it gets you this feedback loop right away. So you can just write, tinker and test real quick. But at the end when your contract is like 95% there. Maybe you should start thinking about writing tests, because your contract is not going to change a lot. But I think the tests are important, but maybe not in the initial phase. So I think what I always do is just tinker a lot with scaffold, and when I have my contract almost ready, I start writing tests.
00:43:25.882 - 00:43:29.482, Speaker B: I mean, I just want to say that in a favor, we should say that out loud.
00:43:29.546 - 00:43:47.714, Speaker A: Definitely. I don't want to be a bad influence. Yes. I don't write enough tests, so I know I'm a bad influence. Write tests. Get to the point where we're here, where we're like, okay, at first, I don't know exactly the solidity I'm going to need, so I need to tinker around and get it right. But now that we've got one contract, we've got the other contract.
00:43:47.714 - 00:44:06.634, Speaker A: We've tested it. It seems to be working. This is the way I want it to work. Now you start writing a bunch of tests, right, get in here. Can you do this with this one? Can you do this with this one? Prove that you can't have a nice little test suite. And then if any little thing changes here, you can run your test suite and make sure that nothing falls apart, too. So definitely protests, but just not right away.
00:44:06.634 - 00:44:26.714, Speaker A: You want to tinker first. You don't want to have to write a bunch of tests just to see that the owner works or just to see that one little thing works. You want to be able to raw kind of just tinker for a little bit. But then once you start solidifying things, then it's a good idea to start writing tests. Good shout. All right, BG labs. BG labs.
00:44:26.714 - 00:44:30.640, Speaker A: We did it. All right. Solidity. Deep tinkering. Thanks, everybody.
00:44:31.010 - 00:44:32.586, Speaker B: See you. Thank you. Bye.
