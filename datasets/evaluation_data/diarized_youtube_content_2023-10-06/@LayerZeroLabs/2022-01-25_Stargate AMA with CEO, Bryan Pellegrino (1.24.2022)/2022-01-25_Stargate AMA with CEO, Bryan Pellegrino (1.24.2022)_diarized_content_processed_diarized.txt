00:00:00.170 - 00:00:16.302, Speaker A: First, Stargate Ama. I'm your host, Tangle, along with Brian Pellegrino, or as some of you know him, Primo. Thanks for taking a bit of your time out of your busy schedule. Happy to get started here with all the stuff that's going on with Stargate and layer zero. How are you today?
00:00:16.356 - 00:00:18.090, Speaker B: Absolutely, man. Thanks for hosting.
00:00:18.170 - 00:00:44.698, Speaker A: Yeah, right on, right on. Let's just hop right into it here. Yeah, I'll be asking. I got a few questions here for you and then we can kind of go through all of that stuff. If people have questions via, if they want to ask, they kind of do that here in the discord and just raise your hand at the bottom. We can get you to come up. I'll bring you up after we go through a few things.
00:00:44.698 - 00:01:10.260, Speaker A: We've also got questions that can be aggregated through either twitch, YouTube, or the Discord voice text channel. So if you want to ask questions that way, all of those questions will come in. We'll keep an eye on those and bring those up as they kind of see fit here. But, yeah, well, to start things off here, Brian, if you don't mind, many people may know you by now, but for those who don't, can you give them a little background about yourself and your involvement with Stargate and Layer Zero?
00:01:11.350 - 00:01:52.634, Speaker B: Yeah, absolutely. So I am the CEO of Layer Zero Labs. I co founded it with two of my closest friends. We've been working on it for a little bit over a year now, or just about a year. Stargate was really the brainchild of necessity, so it was something we felt we had to do. I can sort of dive in a little bit later, but we were working on layer zero and you have this cool messaging primitive that can do almost anything. We just realized that if we waited, we just launched layer Zero with this awesome generic messaging that it would be many months until people came up with the core primitives to really allow the system to adopt it and sort of like the retrofitted part of the system.
00:01:52.634 - 00:02:09.334, Speaker B: And so we started working on all of the ways we might be able to really sort of help that or grow what was most needed to grow the sort of multi chain ecosystem. And Stargate was absolutely top of the list.
00:02:09.532 - 00:02:18.460, Speaker A: Yeah, of course. Can you just give us a brief kind of intro to Stargate and just like a high level overview on how it works?
00:02:19.230 - 00:02:57.506, Speaker B: Yeah, absolutely. So Stargate is composable bridge, so it's different in that most prior bridges really focus on an individual user going and you have a sort of bag of money and you want to bring that bag of money over a rainbow and land in some other place where you can spend that money. Right. It's really just about an individual user taking their assets and bringing to somewhere else, and that's fine. And I think that's like a reasonable use case. It's certainly helped over the last year or so as sort of all the layer ones and L2 s have been proliferating. But for us, one of the bigger things is really how applications use this.
00:02:57.506 - 00:04:03.322, Speaker B: It's kind of our firm thesis that 90% to 95% of all bridging volume is going to be driven at the application layer. So if you're uniswap or a sushi swap, any decks, what they don't want is the way that things work right now. And the way they work now is the user will kind of do a swap on some chain A, let's say ethereum, and then we'll have to go and they'll kind of survey the landscape of bridges and they'll use a bridge and they'll land on kind of the destination chain. And then hopefully they make it back to their application again and end up back in Uniswap or sushi swap to complete the second leg of the swap there. And it's typically maybe four or five transactions on the user side, a matter of sometimes 30 plus minutes overall. To do everything, they have to have kind of source gas, destination gas, and building that flow into an application right now, like trying to keep them within that uniswap sushiswap Ui, that's a nightmare. So the big thing about Stargate was sort of just abstracting all of that away, right? Make it so those applications can own that user flow the entire way.
00:04:03.322 - 00:05:05.262, Speaker B: So when you want to do a swap from chain A to chain B and you're doing it on sushi swap, you can do that entire leg of like swap on chain A and swap on chain B. In the same way that if you're a yield aggregator, right, you're surveying kind of 20 farms across five chains. What a yield aggregator wants to do is they want to interact with those two contracts. They want you to unstake your tether or your mim or your USDC on chain A and then just stake it on chain B, right? They don't necessarily want to solve for how do I get my tether, my USDC, my mim from chain A to chain B. And it's that intermediary step of liquidity transfer that Stargate is really solving for is abstracting that away from every application and giving them this element of composability. Because we have this property called instant guaranteed finality, which effectively means, you know, when you hit the other side, there will always be the asset for you. There is a guarantee when you resolve on source, you already know the state of the destination chain, or you already know that it will never be sort of worse than the transaction that you're doing.
00:05:05.262 - 00:05:30.214, Speaker B: So this allows you to build in native assets without thinking, well, I'm sending a request from source and I'm going to hit the destination and hopefully there's enough sort of asset on that side. But if it's run out now the application has designed for, how do you revert that transaction? What happens? It's just a really messy process. And so we've been able to eliminate that completely. And the goal is make it as easy as possible to build on top of.
00:05:30.252 - 00:05:37.560, Speaker A: Yeah, beautiful. And just quickly, how did you come up with the name Stargate? Or where did that come from?
00:05:39.470 - 00:06:10.578, Speaker B: To be honest, I don't remember the real inceptions of it. I've always been terrible at naming. My co founders are definitely better than I am. We're just iterating on a bunch of different stuff. Originally we wanted to call it pylon. We thought like a couple of different names, and once we settled on it, I think we just all really loved it. So after we had sort of settled on it, it stuck, but I don't think there was any grand moment where it came from.
00:06:10.744 - 00:06:12.580, Speaker A: Okay. Yeah, all good.
00:06:13.670 - 00:06:13.986, Speaker B: Yeah.
00:06:14.008 - 00:06:37.740, Speaker A: And you started to kind of touch about. You were touching on a couple of things here, and you mentioned like the bridge trilemma instant guaranteed finality was kind of the last thing you touched on there, but unified liquidity and native assets being the others. So how does the delta algorithm work or solve this and how does it kind of work? If you can give us a little more insight into that.
00:06:39.230 - 00:07:10.674, Speaker B: Yeah, so you have these issues where there's these three sort of trade offs when you're thinking about bridging. There's unified liquidity, there's native assets. It's the first. I think it's pretty apparent that everybody wants to be dealing in native. You want to have your real USDC on chain A and your real USDC on chain B. You don't necessarily want to have a wrap synthetic of like bridge USDC or bridge B USDT or whatever this may be. And this gets even more apparent when you have sort of applications that are deploying natively.
00:07:10.674 - 00:07:38.462, Speaker B: So this could be your aves, your curves, et cetera. Before, we used to only have tokens that were deployed on ETH, and now we would wrap them to kind of bring them to other chains. But now that they natively live on other chains, the wrapped versions are just like vanilla ERC 20. So if your token rebases, if it has inherent rewards, any of these things, all of that is stripped away. You don't have any of that. And so what you really want to be doing is just dealing in actual native assets on both chains. That's the first.
00:07:38.462 - 00:08:31.566, Speaker B: One of the reasons people can't do that is a couple of reasons. One, when you have the ability to mint this wrap synthetic, you just lock it up on source, and you mint the synthetic on the other end. You don't need to necessarily know that you have enough asset on there. So if you hit the other chain and you don't have enough asset and they're in natives, that becomes a really tricky situation. And that becomes tricky for a couple of reasons. So the user has spent gas on source chain, you've hit destination, you don't have enough asset for them to withdraw there. So what do you do? Does the user need to go to that chain and pay to roll it back? Does the application pay to roll it back? Does the user pay two x gas ahead of time in case they need to roll it back, and then they get refunded on the other end if they don't, and if the application is paying for it, this becomes kind of an attack vector where people can just spam a ton of transactions from cheap chain to expensive chain and make them pay to roll it back.
00:08:31.566 - 00:09:29.826, Speaker B: Pool is drained. A bunch of issues that sort of go into that. And then another thing is unified liquidity. So unified liquidity being right now, almost every bridge, even if they don't do native assets, even if they were, they have this pairwise structure where you have a pool of assets that go from Ethereum to avalanche. But that same pool doesn't also go to Salana or polygon or these other chains, right? So you might have $3 billion locked up in that one pairwise pathway, but if you wanted to go into another chain, you need another one. Two, $3 billion, right? So this becomes extremely capital inefficient, and then instant, guaranteed finality is kind of the property that I described of knowing, having a full guarantee on source chain that it will resolve on the destination. For that same reason, you don't ever want to run in that situation where you're an application, you've wrapped this, you're doing a transaction and you hit the destination chain and you have this fail state that you sort of don't know how to manage and who pays for it.
00:09:29.826 - 00:09:58.794, Speaker B: It is just very hard to build an application flow around that. So Stargate addresses all three of these in that the pools on each chain are 100% native asset pools. So you have a pool of USDC on chain A. You have a pool of USDC on chain B on chain C, and the same with tether, mim, weth wrap, bitcoin, any of these other user assets that you might want to have. Right. And you can think about it as if you're just adding to one side and subtracting from the other. Like that's really how the transaction works.
00:09:58.794 - 00:10:35.126, Speaker B: And there's all these curve style pricing in the bounds and there's sort of these mechanisms for rebalancing, but at its core you're adding to one and subtracting from the other in native. Now each of those pools are unified liquidity. So you'll have one pool of USDC on Ethereum and that will be tied to all chains. So you'll tie that to five different destination chains at the same time. And the LPs from that are not only lp and single sided USDC, but they're also taking their accruing fees from all five pathways. Right? So not only is it extremely capital efficient, but it's extremely fee efficient from the lp side. Right.
00:10:35.126 - 00:11:06.414, Speaker B: And it's single sided deposit, so it's no Il and all that. So that's great. And then you have this property of instant guaranteed finality that allows it to be completely composable. And that's the biggest thing if you want a Dex or a yield aggregator. Any of these early applications that need that liquidity transfer portion, well, a lot of them are going to need to reinvent sort of the bridging portion on their own because it's such a nightmare to manage that. This basically allows them to abstract that. I wrap sushi on chain A, sushi on chain B, I compose Stargate.
00:11:06.414 - 00:11:39.770, Speaker B: Done. You can now transfer across sushis immediately. From day one you have a yield farm on chain A, yield farm on chain B, wrap them, you can post Stargate, you can do unstake, bridge and stake all in one transaction. So you live in your sort of yield aggregator Ui, and you say, oh, this farm has 8% APY and this farm, new farm, has 68% APY single click. You don't even have gas on that chain and you're in that chain farming, right? And that's the biggest goal is doing something that allows it to drive adoption very early on. And we've seen a very positive response to that, let's say.
00:11:39.840 - 00:12:03.380, Speaker A: Yeah, absolutely. And, yeah, I really like that you brought up your talk, started talking about the pools and the single sided staking that LPs will have, so taking on no impermanent loss. And so all of those pools are going to be, will just live on Ethereum and then be able to go across all the other chains. So there's only one place that you need to stake and that'll just be on ETH, is that correct?
00:12:03.830 - 00:12:43.890, Speaker B: Well, to be clear, there will be a pool of USDC that lives on ETH and a pool of USDC that lives on, say, avalanche and Solana and any other polygon. And so. But the point is there isn't a separate pool for ETH to avalanche, a separate pool for ETH to Solana, a separate pool for ETH to Polygon. There's one pool of asset that's shared between each of those chains. So basically each of the chains get assigned a weight that's sort of like the allocation that you're sort of allowing them to have access to from that pool, but allows you to share the assets between a. Rebalance them between, which is largely what the delta algorithm does.
00:12:43.960 - 00:13:01.190, Speaker A: Right. Got it. And then, yeah. Being able to accrue fees from all the chains together, that's pretty sweet. Cool. We had a question come in here about just if they can get a quick explain it. Like, I'm five on the ultralight node.
00:13:02.330 - 00:13:30.558, Speaker B: Yeah, 100% the ultralight node in an Eli five. It's basically, I'll just give a very high level overview of the two other options prior to this. Two options. One, you have two chains. They're atomic in state, and they want to communicate. You have to pass state between them. The first option, which is almost everything you'll see, is somebody's going to throw their own chain in the middle.
00:13:30.558 - 00:13:59.138, Speaker B: That chain is going to confirm the transaction on the source, and then it's going to write out to the destination. So you have this kind of thing that sits in the middle, and it is really the thing that's communicating. So even if you're the one sending a message on source, this middle chain is communicating and it kind of has the power. If it's broken, it can just send messages everywhere and tell them whatever it wants and everybody's going to believe it. So you kind of have this big risk of whatever lives in the middle. So even if you have Ethereum and you're transacting with another chain. They're both super secure.
00:13:59.138 - 00:14:26.994, Speaker B: If this thing in the middle is broken, it's just basically going to tell lies and it's going to be inherently believed. That's effectively how that works. The other way was you're going to take every block from one chain and write them to the other chain and vice versa. And then you have kind of the complete history of each blockchain on the other. Incredibly expensive. The writes on blockchain are really expensive. And so if you did that with one chain to Ethereum, it would cost you like $100 million a day or something.
00:14:26.994 - 00:15:04.326, Speaker B: It's just not a practical approach. The ultralight node is effectively the ability to stream one single block on demand and validate it directly on the chain. So you split this up into two pieces, you have a block header and you have a transaction proof, and you send them both to the other chain, combine them, and then validation happens directly on that chain. That's really what the ultralight node is. The middle chain that I described is like very easy, but it's super insecure. And then you have this traditional light node that was like Cosmos IBC style, which is really secure but way too expensive. You can't do it in any practicality.
00:15:04.326 - 00:15:29.014, Speaker B: And the ultra light node now is this ability to stream blocks in demand. So rather than needing every block in all of history. So even if you only use one, every 1000 blocks, you only have one that you care about. In the old system, you need to write them all. You need to write every single one of those chain. Now you just stream the one that you care about. So hopefully maybe that was a little bit too deep, but hopefully you sort of grasp the concept there.
00:15:29.212 - 00:15:41.290, Speaker A: Yeah, perfect. And they just asked as well. They said yes, super clear. Thank you. Can you talk about the security trade offs with an ultra light node, given that it's much less data intensive?
00:15:42.750 - 00:16:08.574, Speaker B: Yeah. So in ultra light node, you're effectively this system. So again, your two chains, they're atomic, they know everything about themselves, but nothing about the outside world. There's no way they're ever going to learn about the other one unless sort of somebody passes that state. That's the only way communication will happen between these chains. And so the way that we handle this is we basically split that data up into two pieces. Again, your block header, which contains your receipt route and your transaction proof.
00:16:08.574 - 00:16:47.662, Speaker B: So for an EVM, that's a merkel Patricia proof. And we have two parties sort of responsible for passing this. We call them oracles and relayers, but they're both completely open and permissionless. So an oracle is just any system who takes a block header and passes it to the other chain, and a relayer is just any system who takes a transaction proof out of a full node and passes it to the other chain. So now that's fine, you have these sort of entities passing this back and forth, but sort of what's different about this system is that each application, so again, both of those roles are open and permissionless. Anybody can run them. But there's no civil, there's no consensus, there's no round robin, there's nothing like that.
00:16:47.662 - 00:17:48.020, Speaker B: Each application has to opt in to exactly what Oracle it wants to use and exactly what relayer it wants to use. What that means is that let's say you are Ave and you're sort of responsible for $30 billion in liquidity, and you decide you're going to run your own relayer, or you have some relayer set, you're going to use a relayer, again, can be anything. This could be the tendermint validators, this could be your multi sig, this could be some POA from another network. A relayer is really just any system that can grab this transaction proof out of a full node and pass it to the other chain. But let's say you're Ave, you control your own relayer. What it means is that even if every other participant in the entire network was malicious, unless you are colluding with the oracle against yourself, you have a 100% security over the security of your transaction, 100% control over that, too. It doesn't matter if everybody else is malicious, it doesn't matter.
00:17:48.020 - 00:18:32.554, Speaker B: Basically, there's just nothing that anybody can do. It's not like a traditional system where you can take over a consensus and then you destroy every application, right? Everybody's not opting into the same pool of risk. So you move from this giant pool of systemic risk. So in the middle chain model I described, maybe you have $5 billion at risk, sort of this middle chain consensus mechanism, but then uniswap comes in, and now you have $20 billion of risk, and then Ave comes in, and now you have $50 billion of risk, and each application needs to opt into that same pool of risk. And that pool is growing and becoming a larger and larger honeypot. In this model, everything is sharded into very narrow bands of application specific risk. So you might have 5 billion in one band, and then uniswap comes in and they make their own band of risk.
00:18:32.554 - 00:18:59.110, Speaker B: And then Ave comes in and they make their own band of risk, and then another application comes in and they make their own band. And then people can choose to sort of opt into existing bands, but it doesn't force everybody to sort of opt into the same pool of risk. And you have the ability to sort of shard that. And that means if any part of the system sort of breaks or any part of the system is corrupt, it's not complete and total failure. And every application has total control over their own security levers.
00:19:00.430 - 00:19:22.000, Speaker A: Beautiful. Yeah, that's such a cool setup. And, yeah, this has totally answered their question, too. They're amazing. Thank you. So I'm glad that that answers your question there, zooks. And if anybody else has questions that's on the stage here in discord, put your hand up and we can get you up on stage and you can ask your questions that way as.
00:19:22.000 - 00:19:38.210, Speaker A: Yeah, then that's really good that we've talked about. The relayer. Yeah. When it comes to fees, I guess, for both the user and for relayers, what to kind of expect on both of their ends.
00:19:39.830 - 00:20:10.078, Speaker B: Yeah. So the relayer is passing this message from chain A to chain B. One of the really nice features about this is that if you've ever seen the demo, you basically get to see that you might be going from sort of Ethereum to Solana. You don't need to have ETH and Saul in your wallet. You can pay if you're coming from ETH, you pay the entire transaction for both sides in ETH. If you're coming from Sol, you pay the entire transaction from both sides in Saul. Right.
00:20:10.078 - 00:20:37.714, Speaker B: So you don't need to have both ETH and Saul. And so the relayer is effectively doing that. They're telling you upfront how much gas it's going to cost on the destination chain, and you're paying it in a bundle, and then that's being executed across chain. So what's really going to happen is if you're transacting between ETH and Solana, you're going to pay one ETH transaction and one Sol transaction. You still need to write a transaction on both blockchains. There's no way to avoid that. But everything is sort of bundled up and aggregated from the source.
00:20:37.714 - 00:20:59.310, Speaker B: So you only sign one transaction and you pay all of the gas up. So that means if you're going between two relatively cheap chains, you're going to pay $0.10 here and a dollar there. You'll pay a double ten total. If you're touching Ethereum, you're probably going to pay more than that because you're going to have an ETH transaction bundled in, but it's really just like the sum of the gas on the two chains plus whatever the relayer is quoting.
00:21:00.610 - 00:21:07.554, Speaker A: Got it. And the relayers can change or quote their prices differently. And that's all specific.
00:21:07.672 - 00:21:40.060, Speaker B: Yeah. It will be sort of a marketplace for relayers. You'll be able to again in a relayer is like an open construct, right? So you can choose one specific relayer that can be sort of this network of nodes. Like I said, the tendermint validator set could be like a relayer independently. You could have a POA of Solana validators be a relayer. But you could also have a relayer that's basically a one inch style aggregator of like four different relayers that are acceptable to you and it just kind of queries them for best price and uses the sort of best quoted price.
00:21:41.810 - 00:22:01.682, Speaker A: Cool. All right. Yeah. And of course if we have any other questions here with people, please put your hand up. We can get you up from the audience. I think we've got one now with Morphe, if you'd like to come on up. Should be there.
00:22:01.682 - 00:22:18.176, Speaker A: Yeah. Morphe, you're on mute. Unmute yourself and you should be good to go, Morphe. Just have to unmute yourself, Morphe. There you go.
00:22:18.358 - 00:22:19.580, Speaker C: Yeah, I'm audible.
00:22:19.660 - 00:22:22.208, Speaker A: Hey, there you go. How are you doing today?
00:22:22.294 - 00:22:22.930, Speaker D: Hi.
00:22:23.940 - 00:22:25.490, Speaker C: Good, how are.
00:22:26.200 - 00:22:27.350, Speaker A: Good, go ahead.
00:22:28.440 - 00:22:47.310, Speaker C: So I just want to ask, I just explained the fee structure, so I just want to know that the fees which earlier was opposed by the change that will be the same, but the transaction speed and the steps, you are just decreasing it, right?
00:22:47.760 - 00:23:49.452, Speaker B: Yeah. So you're still writing a transaction on both blockchains. So there's nothing any external party can do that will make avalanche fees or ethereum fees cheaper. What you can do is bundle them all up together and yeah, the transaction time and sort of like how long it takes to propagate from one chain to the other is going to be based on the source chain and based on the application's own security metrics you can think of. I sort of been giving this example lately. There's sort of the use case of let's say verifying on a game on an opposing chain that you own like a copper sword on the source chain. So just verifying that fact and sending 100 million dollar transaction, those are two just completely different things in terms of sort of what security you would want on those and so each application has the ability to specify whether they want to wait five blocks, 15 blocks, 35 blocks, 100 blocks, whatever it might be.
00:23:49.452 - 00:24:12.150, Speaker B: So when you're coming from avalanche, you're going to have this very fast finality. When you're coming from other chains you'll have fast finality. But if you want to bypass an optimistic roll up, you're able to. But ultimately it's sort of like your application that's absorbing that risk. If you want to wait for the optimistic roll up, then you're able to. So we put all of that in the hands of the application. Their defaults if they don't want to think about it, but each application sort of has the ability to control that.
00:24:12.150 - 00:24:15.750, Speaker B: Thanks.
00:24:15.820 - 00:24:16.760, Speaker C: That's what.
00:24:19.450 - 00:24:39.040, Speaker A: Awesome. All right, thanks, morphe. Cool. All right. Yeah, there was another thing coming in here about I guess docs and the white paper for Stargate. Any timelines on that or where we at?
00:24:39.890 - 00:24:56.482, Speaker B: Yeah, so docs are available. You can pm me and I will drop you docs. If you're a developer, you want to build on it, start playing around with it. That's live. People are building on testnet on top of it now. So I can do that. We'll open source or just like openly publish all docs and all implementations on launch.
00:24:56.482 - 00:25:01.640, Speaker B: We'll probably do the docs a little bit before launch and then as soon as we launch we'll open source everything.
00:25:05.130 - 00:25:16.140, Speaker A: Cool. And as far as, can you give some, a little bit of insight or an idea of what it's like to build on top of generic messaging protocol with layers? Building on top of layer zero?
00:25:17.310 - 00:26:13.934, Speaker B: Yeah, I think you'll see once you test any of the other teams or anybody else has built on top of us, we've really tried to make it as simple as humanly possible to the point that we've probably had ten or 15 teams now we're sort of building on other solutions and they spent 24, 48 hours with our docs and kind of trashed their existing work and moved over. So really building on layer zero. We think about it as we think about sort of packets on the Internet, right? You implement send and receive and that's it. You have a small header, that's the destination chain and destination contract. And other than that you're just sending a bytes payload and you can sort of put in that whatever you want and you're interpreting that those generic array on the other side. So you're just sending messages and interpreting those messages and any contract, any logic that you're able to build on chain. If you can write it in solidity and rust and whatever your native smart contract language is, you can do it across layer zero.
00:26:13.934 - 00:26:22.210, Speaker B: It's just interpreting messages that are coming in and out. And so the goal is as easy as humanly possible, and you really do just implement that. Send and receive.
00:26:24.070 - 00:26:34.470, Speaker A: Awesome. Okay, and we've got another one here from Cesiro Cesaro.
00:26:35.930 - 00:27:20.062, Speaker D: Hi. Thank you. I think you've actually answered my question with what you just said. I wanted to ask if there was any significant difference between, if you're trying to connect non EVM chains. So you were giving example of, between optimism, for example, or avalanche. But for example, imagine if you're trying to go from, I don't know, an arbitrum to a solana that's going to be different. But with what you just said, correct me if I'm wrong, it sounds like you just have to implement the nodes on both the chains, and then they just talk to each other and the message gets interpreted on the receiver chain.
00:27:20.062 - 00:27:20.834, Speaker D: Is that right?
00:27:20.872 - 00:27:53.466, Speaker B: Yes, that's exactly right. So for us, our role is kind of deploying, we call them endpoints. But an endpoint is just a library of smart contracts that lives on each chain. It's responsible for validating and for messaging. And so the sort of contract that lives on Solana and the contract that lives on Ethereum, each application will interact with them exactly the same. They're still just implementing send and receive and sending the message. But to kind of under the hood, what's happening is you need to be able to take a Merkel Patricia tree and validate it sort of in rust on Solana and take kind of a slice of proof of history and validate it in solidity on the EVM.
00:27:53.466 - 00:28:07.330, Speaker B: So there's like proof translation that goes into dealing with EVM to non EVM. But from the builder side, from the applications building on top, they don't see any of that. It's still just send and receive. It's still just generic bytes. Whatever message they want to send, communication will be seamless.
00:28:07.990 - 00:28:19.960, Speaker D: Understood. And then I guess it does limit. So if you're looking then at a bitcoin, for example, which doesn't have as extensive smart contract programmability, then you're a bit limited, right?
00:28:20.410 - 00:28:52.274, Speaker B: Yeah, that's exactly right. So one of the underlying requirements is that there has to be enough smart contract capability on chain to validate an income. So you have to be able to take an incoming proof and do the validation directly on chain. If we were not doing that, you basically would lose security. So could we throw something together to make something work with bitcoin, like. Absolutely. And again, there are side chains, there are other ways to sort of address this, but you're not going to get that validation where it's happening and being walked directly on the chain and having this verifiable proof that sits there.
00:28:52.274 - 00:29:09.960, Speaker B: So anything that sort of shades away from that, you start to lose a little bit of the security guarantee. So we're definitely focused on smart contract enabled chains connecting messages between smart contract enabled chains early and we'll sort of think about everything else down the road and sort of best ways to approach that.
00:29:10.730 - 00:29:12.310, Speaker D: Gotcha. That makes perfect sense.
00:29:12.380 - 00:29:13.206, Speaker B: Thank you.
00:29:13.388 - 00:29:32.560, Speaker A: Hey, thanks for coming up. Awesome. Okay, morphe, have you got something for us here again? And one other thing I saw from zooks here was just asking if there's any way non technical folks can get their hands on this or contribute or test it out.
00:29:34.530 - 00:29:54.600, Speaker C: Yeah, hi, again, it's just a small theory. Like in pancake swap, if something we want to swap, then it shows the gas error, that we can't determine any gas fees and all that. So do you have any exception handling it like that?
00:29:57.050 - 00:30:24.734, Speaker B: So all of that would live at the application layer. Right. So basically you're coming from a source chain and you're saying, I'm sort of sending a message to this contract on that chain. So you're coming from, I don't know, call it radium on Solana to pancake swap on binance smart chain. Right. And so you arrive and you're going to sort of execute a transaction over there and you're just saying, here's how much gas I'm paying. You're basically bundling this.
00:30:24.734 - 00:30:44.950, Speaker B: You're saying, here's a message, here's an asset, or however you're doing this, and here's the amount of gas that I'm going to pay. So any error handling anything like that will live at the application layer and it can be done again, if it can be done on BSE, if it can be done how it's done now, there will be no sort of loss of that doing it across chains.
00:30:47.450 - 00:30:49.960, Speaker C: Okay, that explains. Thank you.
00:30:50.570 - 00:31:34.802, Speaker B: Yep, no problem. And in terms of Zook's question on ways that non technical people can get, like, there isn't a public UI that you can come and play with right now, in the very near future, you will have the ability to use this stuff out in the, you know, it's an AMA. So maybe I'm supposed to hint at a couple of things, but we're very close to just being ready to be live. Let's just say that. So you guys are going to be able to come and play very soon. You're going to be able to come and use all of this stuff in real time. We're going to have everything open sourced and.
00:31:34.802 - 00:31:43.062, Speaker B: Yeah, I don't know, I guess I shouldn't say too much more than that. It's coming extremely soon. You'll be able to touch and play with it extremely soon.
00:31:43.116 - 00:32:11.370, Speaker A: Perfect. I think that addresses any when questions and yeah, I think that's great. That's probably a really good place for us to wrap up there. Unless if there's any final questions, please feel free to bring them in. Of course you can bring them in through Twitch, YouTube or discord. Yeah, we can answer that way. But the final thing here is Stargate is adapt based on layer zero protocol.
00:32:11.370 - 00:32:12.830, Speaker A: Yeah, based on layer.
00:32:17.110 - 00:33:09.602, Speaker B: What we realized very early went to maybe a little bit of a longer tangent here, but we realized very on, is you can launch this really awesome messaging layer. So again, think like TCP IP on the Internet. Think of ways like you can now send packets and communicate on the Internet for people to actually use it. There's a lot of primitives that need to be built, and if you want an existing protocol to build on top of you, one of the kind of most simple primitives you could think of that you want to do across chains is like a cross chain swap, right? You have asset A on chain X and you want to go to asset B on chain Y. But if you ask an existing Dex to implement this now, it's actually fairly tricky for them to do it. The really naive way to do it would be you have a pool of ETH on Ethereum and you have a pool of Saul on Solana, and that becomes your ETH Sol LP. And so you would need to have single sided liquidity pools on both sides, which the protocol doesn't support.
00:33:09.602 - 00:33:51.878, Speaker B: You need to incentivize those liquidity pools. You need to recreate these liquidity pools across all the chains you want to connect across. So this becomes like a very heavy lift for the DEX, where they need to make significant changes to core protocol. They need to expose those LP to messaging risk. There's all of this stuff that comes into that. And maybe like a less naive way to do this would be, okay, we already have ETH to USDC LP on Ethereum, or we already have USDC to solve LP on Solana, and so we're going to do USDC pools and so now you don't need to recreate every LP. So it's a little bit less capital intensive, but you still need to implement single sided liquidity pools and you still need to incentivize those pools.
00:33:51.878 - 00:34:27.526, Speaker B: And you still have these USDC pathways across all of these chains. And then if Uniswap does this, sushiswap and quickswap and trader Joe and radium and every yield aggregator, anybody who deals in liquidity, like they need to reinvent sort of this mechanism of being able to deal with going between them. And so now the goal was with Stargate. Well, if we do this, it does a couple of things. Sushi swap, let's say on chain a gets an ETH, spits out USDC, that's atomic. That's exactly how it works. Now that USDC is then taken and moved over Stargate, all messaging risk lives within Stargate.
00:34:27.526 - 00:34:57.778, Speaker B: So any risk liquidity lives there. Sushiswap LP takes on zero risk, and then Sushiswap on chain B gets in, USDC spits out asset X. That's atomic. That's exactly how sushi works now. And now you have the seamless cross chain swap immediately from day one. So for sushiswap to implement this, now there's zero changes to core protocol, there's zero liquidity to incentivize, there's zero messaging risk or risk to LP. And immediately they can basically wrap and connect sort of all sushi swaps across all these chains.
00:34:57.778 - 00:35:51.560, Speaker B: And this is the same for yield aggregators or everybody else, Dexes, anybody who deals in sort of this liquidity transfer portion between chains. And so the goal was let's not just launch this and have layer zero, be this cool messaging layer and wait for everybody to invent kind of these primitives and wait for each of these early people who are sort of integrating, needing to invent themselves. Like I mentioned, your quickswap, Trader Joe, all of them kind of implementing their own version. Let's give them something that makes it unbelievably easy to adopt on day one and sort of help force that adoption and then people can build. So Stargate basically makes it when you're thinking top down adoption, when you're thinking retrofitting existing Defi and opening up across sort of every chain, making them omnichan makes that incredibly easy. And then over time, people can build those new primitives, they can build new things from the bottom up, and then you'll see a lot more kind of unique interactions across that.
00:35:53.050 - 00:36:17.760, Speaker A: Yeah, awesome. But it's a great way to bootstrap all of this and get things kicked off. So very excited. Yeah. If there's any further questions, if anybody has, please feel free to throw them up or raise your hand and we'll get you up on stage. But, yeah, we've covered a ton here today. Yeah, if anybody.
00:36:17.760 - 00:36:34.310, Speaker A: Going once, going twice. No, that's all good. Okay. If anybody else has further questions later on, what's the best way to get a hold of you or ask questions about it? Yeah. If they want to talk to you directly.
00:36:35.450 - 00:36:52.346, Speaker B: Yeah. Telegram, discord. You guys will see me in there like, 08:00 a.m. Until 02:00 a.m. Almost, almost every night, obviously, as well, I'm very active on Twitter, so at Primordial A on Twitter, you can find me anywhere. I try to be as responsive as awesome.
00:36:52.368 - 00:37:29.250, Speaker A: Awesome. And for those that haven't seen it yet, Stargate finance is the website. And on there, you'll be able to pick up all the socials and the medium article and all of that is on there. Yeah, we, of course, thanks to everybody here that's been in the discord. This has been live streamed over to Twitch and YouTube for layer zero. We'll be posting this up on the layer zero YouTube afterwards as well there. And, yeah, I think that's fantastic.
00:37:29.250 - 00:37:52.954, Speaker A: So awesome. Brian, thank you very much for helping with all this today and coming out and sharing the good knowledge and, yeah, thank you very much, Tanala's for putting stargate finance in there. Check that out. And, yeah, any questions? Hit us up in the discord. Hit us up on Twitter. Hit us up wherever. Okay.
00:37:52.954 - 00:37:55.980, Speaker A: Thank you very much, everybody. You take care. Have a great day.
00:37:56.750 - 00:37:57.800, Speaker B: All right, thanks so much.
