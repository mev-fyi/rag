00:00:00.570 - 00:00:22.974, Speaker A: I think that this is working. Yeah. All right. I'm going to need Max and everybody else to tell me that this is definitely working, but I think we're good to go. So I'm going to give it a couple of minutes. I kicked it off five ish minutes early to give people time to kind of trickle in and start asking questions. I know we have a log of saved questions.
00:00:22.974 - 00:00:58.062, Speaker A: I actually don't know how we're going to handle of those. I'm just going to assume Max is going to feed them to me somehow. But we're here. Hello, everybody. I'm going to be doing layer zero's first AMA so we can talk about anything in the papers, the meeting articles, Stargate paper, Stargate medium article, the demo yesterday, general plans, whatever you guys want. I'm here for probably 45 ish minutes to answer questions. Okay.
00:00:58.062 - 00:01:09.940, Speaker A: Yeah, I can see it. I can see it now. So we got some people coming in. Yeah, I'll wait around and start answering as we go. Let me know if you guys can hear. Fine. Everything else is all good.
00:01:09.940 - 00:01:56.210, Speaker A: Set up will progress over time, but I think we're probably pretty good. Let me just make sure we tweeted and everything is all good. All right. Yes, perfect. So very first question is about token and investment. I'll just preface it now and saying early, we're not going to talk about investments, all that kind of stuff, like talk about tech, talk about integrations, talk about everything that we're doing. Yeah, everything else, basically we're not going to do right now.
00:01:56.210 - 00:02:18.996, Speaker A: How long is this project going to take? A to Z? It depends on what your A and what your z is. How long has it taken to build? About a year now. Like ten months to a year. How long is it going to take to launch? Well, we're in testnet now. You saw the demo yesterday, right? Layer zero code has been done for two and a half months at this point. Completely done. Three audits wrapped.
00:02:18.996 - 00:02:41.996, Speaker A: Stargate is under its second audit right now. They're live on Testnet. We're playing with them, released a demo about them. People are building on top of them. So if Z is launched, that Z is the not too distant future. If that Z is like, what is the end game? The end game is every contract on every chain. That's our highest level goal.
00:02:41.996 - 00:03:04.472, Speaker A: Connect every contract on every chain. And that Z, that's a longtime thing. You got a lot to build, a lot of integrations to come. It's just one step at a time. Thanks, man. In terms of congrats on all the hard work. Tony, thanks so much.
00:03:04.472 - 00:03:36.880, Speaker A: Yeah, clearly it's not just me, right? The team is amazing. I can't talk enough about how awesome our team is, even that there's a lot of people in the team you guys have never seen or heard about. The team is growing, but like an unbelievable group of people. Brilliant, brilliant people, amazing backgrounds. Yeah. Happy to go into that at some point as well. All right, so here, let me go through economic model of the protocol.
00:03:36.880 - 00:04:17.864, Speaker A: We're going to release a full paper, right? So the first paper we released was pure technical paper. Like, here's how a technical system works, here's how n communication happens, here's how these packets are formed, here's how they're being passed back and forth, and what the actual technical system looks like. We will absolutely release a full economic paper for both layer zero and Stargate. So that will come in time, but that hasn't been released yet. So let me see how these work. I'm going to throw them up on the screen. Well, I actually can't read it when I do it like that, which is weird.
00:04:17.864 - 00:04:50.760, Speaker A: It hides it from me and then it's cut off here, so I'll read it out. Hey, Brian and the team. I'm a high school teacher and want to be programmer. In your opinion, what would be the best two to three programming languages that you focused on? If you're in your twenty s and willing to work in crypto, project like Layer zero one day, or maybe, what are the programming languages that have more upside for the crypto space, in your opinion? Thanks. Congrats on all hard work, everything you've been doing. Yeah, I think pretty clearly solidity is your best bet right now. If you're coming from scratch, very little experience in programming.
00:04:50.760 - 00:05:35.112, Speaker A: I would say if you're coming from a C plus plus background or you have a different set of experience, maybe go rust, maybe go play in Solana, do something like that. But if you're talking about wanting to get in there, make smart contracts, deploy something, have people use it, you're not going to find anything better right now than solidity. It's just a fact of the matter. It has largest audience lives there. Tons and tons of projects that are all open source that you can fork and modify and change hyperparameters and mess around with. There's just tons of things that you can do that you can test things in the real world and watch them working, and a lot of just prior things written up on it. Right.
00:05:35.112 - 00:06:07.228, Speaker A: Go play through crypto zombies, which is still insane that today that's the way that people iterate into. But it's still probably one of the best ways. Go through crypto zombies, dive into, poke around existing contracts and just go from there. All right. I wonder what the difference is between symbiosis and layer zero, if you know that project. So there's been about, I don't know, 500 people who have mentioned this to me in the last day. It seems to be like a very big symbiosis Twitter crowd.
00:06:07.228 - 00:06:34.016, Speaker A: I don't know anything about symbiosis. I'll start with that. But I will say that basically every other project falls into one of two broad categories. Almost every other project, right? Almost every other approach that we've seen. That was like the reason we started working on the parts of what we're working on. Either validation lives in a middle chain, right? It gets offloaded into some middle chain where it's its own chain. That's the ultimate signer on the destination chain.
00:06:34.016 - 00:07:08.896, Speaker A: And we've written a lot on sort of this structure, or it's an on chain light node. And those are the two broad things what we've made this ultra light node is something novel. That's something that we've invented. I would say when you're talking security properties, that's one of the biggest differences. And then most other, and again, I'm not totally sure what symbiosis does, but most other things that people have brought to us is like, oh, because the demo showed a swap of asset A to asset B across two chains. They're like, oh, well, other projects actually do that. But the point of that demo is not, we just happen to show two dexes because that's a common flow.
00:07:08.896 - 00:07:50.516, Speaker A: But the point of layer zero is not to swap two assets, right? That's like a very small use case. The point of layer zero is pure generic messaging, pure interoperability. So when you have layer zero and Stargate, you can combine any two contracts on any two chains. So imagine like a yield aggregator, right? Like what do you want to do in a yield aggregator? You have a website, one site you're living on, and it's tracking five chains and 20 different farms. And you have some pool of USDC farming on Ethereum. And what you really want is to unstake from Ethereum and stake in avalanche or in polygon or whatever other chain that is at the yield aggregator level. That's what they want.
00:07:50.516 - 00:08:21.064, Speaker A: They want to take their money out here and put their money in here where the destination chain is some foreign contract or some contract on some foreign chain. And so what actually needs to happen is that money needs to get moved from chain a to chain B. So like Stargate is the piece that facilitates that. Stargate is just a bridge. Anybody can build a bridge. Tons of bridges can be built on top of layer zero. But what this enables is that in one single transaction from the source paying only gas, in source gas, you don't need to have both source and destination.
00:08:21.064 - 00:08:42.724, Speaker A: You don't need to independently go and trigger these. A user can, in that UI, click once and have that entire process of unstake bridge stake all done in one flow. So you were going to Polygon, but you don't actually have any matic in your wallet. You've never done anything with matic. Boom, one click done. You're already farming there. And so there's just a lot of power to that.
00:08:42.724 - 00:09:38.308, Speaker A: And again, I threw out other examples, but this is anything, any two contracts, any two chains. So this can be unified governance, right? Your governance protocol consolidates on Ethereum, but it lives on all these other chains, right? Because your application is deployed on all these chains. Well, now, rather than needing to swap and bridge and come back and get the voting rights on that chain, you can just remotely cast your vote from those destination chains and just cast them into Ethereum. NFTs and gaming, we talk about it all the time where you are doing something. So you probably want to move your high throughput part of your game. So this is like how Axie and Ronan is structured, right? It's like you have one chain or one area or maybe in multiple areas where your game lives and you can play and you can do things and you're doing a thousand actions. Maybe you're signing 100 cheap transactions to do these things and all this stuff is happening.
00:09:38.308 - 00:10:31.348, Speaker A: But then you're going to roll that back to maybe the chain that has the highest economic activity, so maybe they're going to roll it back to Ethereum. And now all that stuff you've done now gets rolled back to Ethereum just in a message. And then that can be like sharing metadata between this NfT that's getting mutated, that can be granting rewards, that can be a lot of things. You can have staking where you're getting rewards on Ethereum, but for a bunch of people, rewards are just way too expensive to claim, right? You're like, you've got $500 staked in this contract, but for you to claim your rewards, you're going to pay like $1,000 in gas to have this complex claim process. Well, what you can do now is that protocol can just roll off their entire set of rewards to any chain that has the same address mapping. So you want to throw it to Arbitrum, you want to throw it to avalanche, you want to throw it to Polygon, it doesn't matter. You can push in one transaction, all the rewards go there.
00:10:31.348 - 00:11:02.764, Speaker A: And anybody can just go there and claim their transactions for extremely cheap. And then you have applications with, like, state share, whether you have an index price or you're doing something that is changing on chain and the protocol needs to know about. But you're deployed across multiple chains. Well, maybe you want to share that across chains. Right? So now you can effectively run a cron across chains. So, yes, the demo showed a swap. What was really happening is two dexes on different chains and a bridge all interacting in one flow from one transaction.
00:11:02.764 - 00:11:37.964, Speaker A: Right. That's the powerful part, is that all of this stuff, now, once you have generic messaging, the possibilities are effectively limitless. Right. So I think that's kind of in terms of what's the difference? Again, I don't know anything about symbiosis, so I can't comment on it particularly. But what's special about what we are doing? That's what's special about it. When do you expect to have first implementation? Live in Mainnet. So if you haven't seen the demo yesterday or I think maybe the day before, losing track of time, watch it.
00:11:37.964 - 00:12:00.708, Speaker A: So we're live on testnet now. It works, right? These things are happening. People are building on top of it. People are building contracts that play across all these chains. So all of that is live now on Testnet. When will we go live on main net again? As I mentioned, kind of state of the world is layer zero. Code has been frozen, done for ten weeks.
00:12:00.708 - 00:12:27.544, Speaker A: Three audits have been completed that's ready. We could launch that today if we wanted to. We're going to launch that alongside with Stargate. And Stargate is in its second audit right now. Soon. As soon as what I can tell you, we have people kicking tires, testing auditors. You guys probably saw me on Twitter the other day recruiting white hats like, we're doing everything we can to just harden the protocol.
00:12:27.544 - 00:13:07.816, Speaker A: Right? That's like part of it. All these audits, these five different audits are part of it. But we're almost there. Are there any other amazing projects in Stargate that are in active development on the protocol that you're able to tell us about? So, yes, definitely. I don't think I can tell you about them yet. I can tell you that my expectations are extremely high. When I set internal metrics for myself in terms of the amount of TVL that's going to be natively integrated over layer zero, those numbers are extremely high.
00:13:07.816 - 00:13:48.672, Speaker A: And even those extremely high metrics that I set for myself, I think we're going to just completely crush. Yeah, look at the cap table, look at the people involved in the project, look at their portfolios, look at, there's a lot of breadcrumbs, I guess, that you can dive into. But we're talking to everybody. We want to work with everybody. We have a lot of amazing teams from brand new building, something completely native to some of the biggest protocols in the world building. And yeah, I guess I can just leave it at that. We'll have a lot of things to announce.
00:13:48.672 - 00:14:32.164, Speaker A: But yes, development is very active and we have a lot of incredible teams working with us. We're super excited about all of them. Let's see, v one supports ERC 20 and compatible chains when Cardano dlts others. So the only requirement for layer zero is that there is enough smart contracts functionality on chain to validate an incoming proof. That is the only requirement. So we're already starting to develop for Salana, for tendermint substrate, looking at algorithm, all of these other things are things that we are actively doing. So any chain that's ERC 20.
00:14:32.164 - 00:15:20.212, Speaker A: Now if it's using Merkel Patricia proof is effectively near trivial. Right? There's some work that needs to be done in terms of what's being passed, in terms of the block header and all these things, and making sure that those pathways are supported. But in general, the actual endpoint, the validation, the messaging, extremely easy, extremely fast ad non EVM stuff. Soon again, I guess I can say very soon. Development is already underway. So yeah, it's at the very top of our priority list and we see no significant hurdle from where we are now to launching on them. It's just about some gritty technical stuff, some proof translation and just getting there.
00:15:20.212 - 00:16:16.340, Speaker A: So yeah, it's happening. And I guess I can loosely say within a couple of months we plan to be supporting a lot of chains. All right. Okay, there's another one that's, that's too long. So I love some of the angel investors, particularly one that may be under the radar, in my opinion, one of the best brands in the world and in crypto. These angel investors are just putting the money or also involved in the project from the inside anyway, are they going council? So we love the people involved in the project, I think we've attracted both an unbelievable quality of talent internally, and I think, again, the more that kind of the team will make all of that kind of more and more public, just in terms of who's working on this stuff, unbelievably, group internally. Unbelievable group externally.
00:16:16.340 - 00:16:46.436, Speaker A: So, yeah, all of our investors, we think, are incredible. They've all been amazing, super helpful. All of them. We have open lines with. So I have regular where it's like weekly or multiple times a week, I talk to some of these people. Some of our investors are very involved. We want to bounce ideas in terms of different parts of the system, different parts of sort of strategy of integrations in BD, of sort of, like, hardening economic systems.
00:16:46.436 - 00:17:20.456, Speaker A: All of these different things. Yeah. Everybody's been amazing, super accessible, and I regularly talk to almost all of them. So most likely, yes, whoever it is on your list is actively involved. But we were very fortunate in all of our raises that basically were more or less, like, we had a lot of interest. We were able to choose who we worked with, and one of the biggest things we did in optimizing for that was working with people who. The tone we set very clearly are people who would go to bat for us, who.
00:17:20.456 - 00:17:39.904, Speaker A: People who actually cared. Right. So we didn't want people who were just going to write a check. Capital is not the determining factor in the market today. It's just not. Right. It's about the quality of people that you're working with and just how good they're going to do by you and you by them.
00:17:39.904 - 00:18:05.696, Speaker A: Right. We love all of these people. We love working with them, and, yeah, it's people that we want to spend time with, and we brought them in because they're brilliant at certain things, and so we leverage all of that. Absolutely. Let's see it. All right. Okay, this is another one.
00:18:05.696 - 00:18:23.080, Speaker A: That's. That's too long. I got to work on this display thing. I've seen the demo, and I can say the design is pretty good, but I have a suggestion which might sound stupid. The button designs can be more oval instead of square. I know it's just a demo, but I just want to let you know, since the project is layer zero. Gonzalo, I'm just going to throw that one to you, buddy.
00:18:23.080 - 00:18:54.150, Speaker A: So, Gonzalo is our designer. I think you guys can see, like, our brand stuff is awesome. We've had so many comments on it. He's amazing at what he does. I will say that I constrain his time more than anything. So I throw a lot at him in terms of, like, he's really focused on really maybe like, the core stuff. And I'm like, can tell, like, we get to do a demo because we've got to show everybody how awesome this thing is and we've got to get this out to the world and everybody see what we're actually doing.
00:18:54.150 - 00:19:38.096, Speaker A: So a lot of this is time constraint, but he's amazing. And I think you'll see from a UX perspective as we go deeper and he gets to really kind of flex and show off what he's capable of. I think you'll find the UX is going to be world class. How will layer zero work with L2? So, again, completely agnostic. Only requirement is the chain has enough smart contract capability to validate an incoming proof. So we do not care if it's layer one to layer one, layer one to L2. Layer two to L2.
00:19:38.096 - 00:19:56.132, Speaker A: Layer two to layer one. Right. Doesn't matter to us at all. Everything is just a chain that can support smart contracts that can validate incoming proof. So we leave a lot of all of this in the hands. I think that's one thing. And hopefully we dive into some questions about that.
00:19:56.132 - 00:20:34.676, Speaker A: What's actually different about some of these integrations and things? But one of the most important things is we leave it at the smart contract level, at the user application level, to have sort of controls over all aspects of these systems. So even things like if an application wants to bypass the challenge period of a roll up, that's totally fine. If they want to wait for a roll up, it's totally fine. All of these things that ultimately affect the user application, we give them those levers to be able to make those decisions. But in terms of technically a L2, it just doesn't matter. We will absolutely support L2s. If you've seen our kind of list of chains that we will be supporting from day one and ongoing, there are L2s on it.
00:20:34.676 - 00:21:04.990, Speaker A: So, yeah, no issue at all. Where did you get those headphones? I got it from a place called headphone bar. So I went in, I looked at a bunch of headphones over a wide variety of price ranges, and these were on the cheaper end of the scale, but I thought sounded better than any of them. So I love them. You can see that they're very well worn in here. The leather is peeling, but they're fantastic. Let's see.
00:21:04.990 - 00:21:33.270, Speaker A: Smoothering question on laser and CCIP in general. Right. Go out and you're going to see 30 different messaging protocols. Right. A lot of people are trying to accomplish the same things. It's really just about how you're going to accomplish them, how they actually approach these things about integration, it's about security properties. Security properties probably being the most important one.
00:21:33.270 - 00:22:05.810, Speaker A: So we work very closely with the oracle. So Chainlink band, et cetera, while our system is kind of completely open and permissionless. Right. Anybody can perform the job of an oracle. An oracle to us is just a system that takes a block header and passes it from one chain to another. But all the oracles are kind of like doing this, right? So we have great relationships with all of them and yeah, we work quite closely with them. Any idea? No, can't talk about that.
00:22:05.810 - 00:22:37.368, Speaker A: What would you say your biggest differences are from other interoperability protocols? Okay, so it's a question. We're going to get a lot. I guess I can just. Sorry for this chair. It's killing me with that sound. I'll just walk in. Some of you may have, if you've listened to me on recent podcasts, you've heard me talk about this, but here are the biggest ways that most things are structured, right? So you have two chains that are atomic in state, and they want to communicate between them, right? So they don't know anything about each other.
00:22:37.368 - 00:23:15.584, Speaker A: 98% of solutions that you see today are this. We're going to take our own chain, we're going to put it in the middle. You're going to write a transaction from source. This middle chain will come to consensus as to the validity of that transaction, and then that chain will write a message out to the destination chain. And that is the most important part, that that chain is writing the message out. That chain is the ultimate signer of the transaction on the destination chain. What that means is that if that middle chain is corrupted for even a matter of a couple of blocks, right, this has the ability to arbitrarily send messages to all destination chains and effectively just tap all liquidity immediately.
00:23:15.584 - 00:24:08.650, Speaker A: So this is what we saw in the polynetwork hack and plenty of others where polynetwork, the hacker made himself the only validator and just sent messages to the destination chain, said, hey, don't worry, I definitely gave it to you. On the other side, like, all that money belongs to me, sended this address. And so when you're doing that, these systems in general are like fairly weak security properties. Ten to 30 validating nodes, a couple of hundred million dollars bonded, they're meant to secure tens of billions or hundreds of billions of dollars while becoming more and more decentralized. And consensus itself is like a really hard problem. A really hard problem, as you'll see with many layer ones like reorgs, just like happen. This stuff happens where having basically perfect consensus without having this long length of time where that can be changed is a difficult problem.
00:24:08.650 - 00:25:03.160, Speaker A: And so these things are effectively just like extremely large honeypots where if that middle chain is ever broken, you win everything, right? So another approach is sort of like cosmos style approach, where you're going to run a complete light node on chain. You're going to take the block header from each block sequentially, write it to this other chain and vice versa. So now you have a complete block history on both chains, and you can just submit a transaction and do the walk and validate. This is like a valid transaction. That's great once you have it, extremely versatile. But the problem is that rights on blockchains are very expensive, right? So to do this with even one chain to Ethereum, you're talking $100 million a day right now with current gas per pairwise chain that you're tying, right? So it's just like not a really viable solution in the current state of gas in the world. So layer zero invented an ultra light node, which is effectively the process of taking one single block in isolation and streaming it on demand and validating it directly on chain.
00:25:03.160 - 00:25:41.030, Speaker A: I can kind of leave it at there for now. I think if somebody has more questions on that, I'm happy to kind of dive in deeper. But the ultralight node is like one of the biggest differences when you talk about security properties. The amount of control that we give the user application is another thing. So the user application has complete control over the exact oracle, the exact relayer, the exact number of block comps are waiting from source chain. So all this means they have absolute control over their security. If they operate one of those levers, then there's nothing that anybody else, any foreign system, anything can do to corrupt complete security.
00:25:41.030 - 00:26:12.364, Speaker A: And then the other side is like the integration side. Try to use many of the users, just go even as a user, and try to bridge an asset from two sources. It's a nightmare. I think we showed pretty clearly in our demo. So one single click, one transaction from source chain only source gas, you don't need both source and destination gas. Entire flow is executed. Right? Like that's a world of difference when you're talking about trying to integrate at the application level.
00:26:12.364 - 00:26:52.700, Speaker A: So again, I'll jump to some others. I could talk all day about this stuff and kind of differences and why. Again, what I think what we're doing is quite special, but I'll jump some other stuff and maybe come back for it. Can you say roughly how long the team and I have been working on this project? So the other two founders, or there's three of us who founded this, we've been working together on and off for 16 years. We all started working at an ieee testing and conformance networking lab way back in the day. Really low level, early Internet technology stuff for ieee standards. So, like, I was voiceover IP, Ryan was data center bridging, Caleb was DSL.
00:26:52.700 - 00:27:29.960, Speaker A: So we built a lot of things together. We've been together a long time. This specifically, we started playing around with frameworks, not specifically around messaging and bridging about 18 months ago, 18 to 24 months ago, we were just building things generally around the space. And then about twelve months ago, we wanted to build something. We're just like, well, we really just did not like the state of the world at the time. There was nothing that we would entrust a million dollars to, let alone like tens or hundreds or billions. So we're just like, okay, we can't build on anything.
00:27:29.960 - 00:27:57.972, Speaker A: We just started tinkering of like, what can we build? That's kind of novel. And then very quickly as we started to do that, we realized that we're onto something that was far more impactful in terms of just like a general problem. And that ultimately became layer zero. So layer zero itself is about ten months full time. Yeah. So it's a completely agnostic platform, as long as execution layer can handle it. Exactly right.
00:27:57.972 - 00:28:19.512, Speaker A: Yes, 100%. Exactly right. Let me see. I can see your excitement from your body language. Yeah, I'm known to wave my hands around and get kind of animated when I talk. It's in my nature. But I do, I love this stuff.
00:28:19.512 - 00:28:55.784, Speaker A: I spent a lot of time thinking about it. I'm very passionate about the kind of stuff that we're doing and kind of the impact this is going to have. So, yeah, I hope that shines through. Few words on real role incentives. So again, we haven't really released any of the economic constructs around either system. Clearly, the relayer plays a very critical role in the system overall. Obviously from any game, theoretical sense, that's going to need to have strong incentives, they're going to need to have applications, are going to need to have sort of controls over this.
00:28:55.784 - 00:29:36.756, Speaker A: All of that stuff, I think, has been thought through quite well. We will absolutely release details on it. If you listen to the Delphi podcast, there was a hypothetical discussion on what some of this stuff might hypothetically look like if one were to design a system around them. But, yeah, we will absolutely be publishing more details on that's what has nobody asked yet. But you think is really cool about layer zero that we can share? Yeah. Generally everybody both thinks it's more and less than it actually is. Right.
00:29:36.756 - 00:30:00.124, Speaker A: Layer zero is pure generic messaging, right? Not a bridge, not a Dex, not a lending protocol. Those are things that are built on top. It's messaging. It's just packets in, packets out. Just like you think about the Internet, right? Except that you don't, right. Nobody thinks about that layer of the Internet anymore. Even people who are like CS majors, our students, have all of that stuff abstracted away.
00:30:00.124 - 00:30:44.836, Speaker A: You don't think about it unless you're taking a specific networking course or a specific aspect of diving into this stuff. So I think in terms of that, it's very clear that interop is needed across all these chains. And it's very clear that fundamentally nobody wants to think about that in the way people just want to write code, they want to make a website, they want to interact with some other system across the world. You need modules, you need ways of doing that, but everybody doesn't need to know about it or think about it. It can be this thing that's in the background. And so people talk like nobody ever believes me when they talk about integrating because integrating on a lot of other stuff is like messy and hard. You literally have two functions.
00:30:44.836 - 00:31:07.148, Speaker A: When you integrate on layer zero, that's it. And nobody believes that until I show them the docs and they start to actually integrate. So the two functions you're right are send and receive, right? So that's all you're doing. There's a small header on each message that's being sent. That's just the destination chain, the destination contract, but you're just sending and receiving packets. That's it, right. So you receive, it's like a generic bytes payload.
00:31:07.148 - 00:31:41.804, Speaker A: So you have this header, and then you fill that bytes payload with whatever you want, whatever information you want. And however you're going to interpret that information on the other chain when you're receiving it, totally up to you. You can have any information. Even the systems that are sort of like validating the transactions, none of those have any clue of like you're just sending this generic packet and it lands and it gets interpreted on the other side. When you're talking about GVM, it's just like an ABI encode and decode type system. Right? So that's really what it is. And maybe that seems quite simple.
00:31:41.804 - 00:32:08.980, Speaker A: And people are like, oh, it's just that. But that in itself is extremely powerful because that means you can build anything. If you can write it in solidity, if you can write it in rust, you can build it across layer zero. All of the logic, everything is completely modular. All of the security controls over the system at the application level are completely modular. The application has full control of this. And so all of that just means that every application can now build whatever it wants.
00:32:08.980 - 00:32:38.312, Speaker A: You want games that live on certain chains, fine. You want systems that actually live across three chains, like modern server architectures, where each chain is like, orthogonal and trade off. And this chain is really good at this sort of operation. So you're going to offload a bunch of stuff there and this chain is really good at that. Or has a huge user base and you have certain things that gets consolidated there. There's just so much that you can do once you have this fundamental layer. So building out that fundamental layer, a lot of people again go back and want to work on TCIP.
00:32:38.312 - 00:33:02.228, Speaker A: That's not sexy. Nobody wants to think about that, but that's fine because I love that stuff. And to me, that is sexy because of what it enables. Right? So I'm like, okay, TCP IP itself is like, it's pretty boring for me these days. You're right, I don't want to go back and work on that. When you're talking about this around everything that's happening now and needing that so critically in the space and everything that can be built on top. Yeah, that's freaking amazing.
00:33:02.228 - 00:33:22.284, Speaker A: So, for me, that's the coolest thing. It's not about layer zero is not going to be the sexiest thing in the world. It's going to be the thing that powers all the sexiest things in the world. And that's totally fine. I'm happy to live there. So, I'm most excited about what gets built on top. And Stargate was just one thing that's built on top, and it's really cool.
00:33:22.284 - 00:33:40.556, Speaker A: It has these amazing properties and this massive piece of composability that allows you to just wrap any two contracts on any two chains and now just connect them easily without needing to go through all the native integration. Now it's just like day one. Okay, yield. Agreed. Or like, you want to go from here to here. Done. You want to do this pathway of a deck? Done.
00:33:40.556 - 00:34:15.352, Speaker A: Like, super easy. But there's so much more that can and will be built on top. Okay, let's see who's doing the audits for layer zero and what. God, this thing. Who's doing audits for layer Zero? What's the limiting bottleneck and how fast messages can get communicated? Is it just the block finality for the source chain? So all great questions. Audits for layer zero or trail of bits, Zokio and slow mist? Audits for Stargate are Zokyo and Quantstamp. And then we've written thousands of tests ourselves.
00:34:15.352 - 00:34:46.344, Speaker A: We're bringing in more independent third parties, just like try to break things. So I'm of the opinion that there is no number of audits. That is too many audit times are really hard. We've had to really finesse to get people to take us and put us in the auditing pipeline. But the more audits, the better, in my opinion. And that's kind of how we've approached it, is we want people to play in the same way that we're like inviting teams right now to come and build and play on Testnet. We want all of this stuff to be used as much as humanly possible, and then we're going to go.
00:34:46.344 - 00:35:33.910, Speaker A: But everything, all the audits were great, no issues. And those audit reports will all be public, limiting bottleneck for how fast the messages can get communicated. So it is a combination of source chain finality and the user application. So this is something that I think is pretty important when applications are being designed. So people ask this, and I don't think it makes sense for layer zero, the protocol, to decide how long an application waits to get a message on the other side. Like in probabilistic finality, there is no pure finality, right? Like every amount of time that you wait or number of blocks that you wait is just harder and harder to roll back. And it's more and more certain that that's going to be the final state.
00:35:33.910 - 00:36:22.630, Speaker A: And so for us, we leave it up to the user application, like their defaults, if the user application doesn't want to think about this stuff. But if you want to wait one block on Ethereum, ten blocks, 35 blocks, 100 blocks, totally up to you. And as I mentioned, if you want to bypass a roll up or the challenge period and a roll up to come, ultimately it's that user application's liquidity is at risk. They're performing some action on chain B, some destination chain, based on the belief state of chain A, that it's going to be there, that's the final state, right? So we don't think it makes sense for us to decide that. Totally up to them. But that said, it's as fast as they want it to be. And when you're coming from fast finality chains, like you're leaving avalanche, you're going from any chain that is fast is going to be near instant, right? Just a matter of a couple of blocks, yeah.
00:36:22.630 - 00:37:15.682, Speaker A: Okay, let me see. How can ethereum 2.0 affect layer zero? It's really like, for us, you're validating right now, you're validating like Merkel, Patricia trees in EVM systems, right? Like that's what's happening. But when we go to Solana, right? You need to be able to validate Merkel, Patricia tree in rust on Solana. And then you need to be able to validate, like a Solana proof of history slice in solidity on the EVM. And one of the bigger changes, actually, that we're going to sunset Merkel, Patricia trees at some point for vertical trees, presumably that's going to happen, right? Those kind of things that are happening within systems, those become a big deal. They don't really break anything.
00:37:15.682 - 00:37:52.030, Speaker A: Like you just need a new library for validation. So it's not the end of the world, but we're going to support Ethereum 2.0 just as like Ethereum supported. If anything, hopefully we'll solve a lot of the scaling issues where it will make all of this even easier to communicate. Because right now you're trying to offload a bunch of stuff or go between these other chains and only roll back to Ethereum when you really need to. And now it's like Ethereum can kind of be more of a primary hub when it comes to actual interop. Let's see.
00:37:52.030 - 00:38:27.210, Speaker A: Are your cross chain interops another one that's too long. Let me read it out. Are your cross chain interactions on layer zero effectively limited by the slowest chain in the transaction? I'm specifically wondering if you could do atomic swaps across chains like ETH to Matic, or take a flash loan on ETH and execute a transaction on a different and faster chain. So you're not going to be able to do a flash loan because a flash loan has to be atomic. Right. It has to resolve within that block, that atomic period. And so you're not going to be able to do that across different chains.
00:38:27.210 - 00:39:02.450, Speaker A: Yeah, you just won't. So that for sure won't. But in terms of general speed, it's just source chain, and then you need to be able to get into a block on a destination chain. So imagine you're going from a chain that does 1000 blocks a second and has immediate finality on every block. Right? Like, yeah, you're going to be able to get out a ton of transactions on that chain. But when you're coming into Ethereum, if you have finality, it doesn't matter, right? It can immediately resolve. It resolves like any other transaction resolves on Ethereum.
00:39:02.450 - 00:39:29.440, Speaker A: But what you do need is to get into an Ethereum block, right? So you might need to wait 13, 14 seconds to get in the block and have the block resolve. Right? So that is kind of a limiting factor, but the chains you're communicating with are the factors themselves. We don't make it. So Ethereum gas isn't magically cheaper. You can't magically fit more into an Ethereum block. None of that happens. Right.
00:39:29.440 - 00:40:02.682, Speaker A: That's sort of not what's being solved here. But what you can do is like, oh, you can communicate with a L2 and do that extremely fastly and then roll back to Ethereum when you need to. Looks like we need to create an OS like model for blockchain networks. Yeah. Keep your eyes open. Keep your eyes open. Very soon I'll say, how can you multiplex message in multiple chains? Is this desired? So, yeah, you can absolutely go to multiple chains at the same time.
00:40:02.682 - 00:40:49.506, Speaker A: Is it desired? It depends on what you're doing. So you can imagine, again, imagine like a state. Imagine you have a state of something that lives on Ethereum and you make all your decisions around that state, and you want to propagate that state out to three other chains simultaneously because you want their state to also match your state. Right? Now, how that might look like is some individual dow or a multi Sig needs to go to each implementation on each of these chains and say, hey, state is x. State is x. State is x. State is X, right? So now what you can do is you can resolve state is X on Ethereum and that goes out to these other chains and everything is like nonsense forced, right? So no other messages can go before that resolve.
00:40:49.506 - 00:41:44.742, Speaker A: So you understand that that will absolutely be resolved before anything else comes in. There's no way to bypass that when you're growing across these channels. And so then now you know that atomically with that block, like, okay, state is at the same time also going to be updated in all of these other implementations. So yeah, there are certainly examples where you want to update multiple things at one time, but it's more of like state share than value transfer. Say, what is the biggest risk or threat to layer zero? So absolutely, in any system, security properties matter, right? So when I talk about this middle chain model, the big threat there is like consensus gets broken and that middle chain arbitrarily writes messages to destination chains. And the honeypot is only broken, it's only corrupted for a short period of time, but it just has the ability to take everything with layer zero. The way we design the model is there's like two parties.
00:41:44.742 - 00:42:37.142, Speaker A: To validate a proof directly on chain you need a block header which contains a receipts route and you need a transaction proof. So for EVMs it's a Merkel Patricia proof, you can combine those and validate them directly on chain. Now you still need to get that information from one place to another, right? And you need to do that in a way that is as trust minimized as. So you know, we have two systems, oracles, relayers, both totally open and permissionless. Oracle is passing a block header, relayer is passing a transaction proof. What's really important is that the user application has the full control over all of these, right? So there is no like we form no consensus, we don't have a chain, there's no round robin, there's no civil attack. Somebody can do if you, the application, let's say run your own relayer, right? So you're ave sushi, whoever, somebody responsible for like tens of billions of dollars in liquidity and you run your own relayer.
00:42:37.142 - 00:43:52.254, Speaker A: There is nothing any malicious party can do, right? It's not like some oracle can be malicious and they can go in and get into your liquidity unless you, that relayer, you the ave relayer is colluding with the oracle against yourself. There's nothing any other party can do. And I think that's the biggest thing is allowing each application to have complete control over those security measures, right? And so the user application specifies exactly their oracle, exactly their relayer, and exactly the number of block comps. And so more than anything it's just a matter of what is application optimizing for. Are they optimizing for ease? Like okay, offload this to anybody else who's running relayers, layers or labs is going to run a relayer, a bunch of other applications and third parties are going to run relayers. They'll each have, again, we haven't dove into it, but there'll be all these incentives for why you may be willing to use those parties, or you just run your own and you have again complete control so you can run any part of the system. And the other really nice thing that this reduces to is that the worst case security of this configuration still reduces to the best case security of the chosen oracle.
00:43:52.254 - 00:44:24.394, Speaker A: So let's say oracle is Chainlink, right? So we've chosen chainlink as our oracle. The worst case security of this configuration is that your oracle and your relayer are the exact same entity. They're one person, they are the same party doing both things. Complete collusion, the whole nine yards, right? That's still as secure as a chain link don. Like it still defaults to being as secure as the oracle. So the worst case security property is still as good as the best case security of the chosen oracle. But every other system, like, let's say your oracle was broken, it's malicious.
00:44:24.394 - 00:45:23.274, Speaker A: It's like in collusion with relayer a, only user applications using exactly that Oracle and exactly that relayer are impacted, right? So anybody using relayer B through Z, anybody relaying their own transactions, anybody using any other oracle, completely unaffected. So you've taken what was a central pool of risk where all of that risk can be tapped and broken to heavily sharded and siloed risks across the system, right? So now, even if you break an oracle and you get it to collude with a relayer, you only win one tiny sliver, right? So one 30th or one 300th of overall system risk, and that's like a very attractive property. And then more important than that, each application specifies that relayer. So even if that oracle is malicious or that relayer is malicious, if you're running your own relayer, there's nothing any other party can do. Same thing, malicious, Oracle can't affect that relayer. And even if your relayer turns malicious, right, if you're running your own relayer and something goes rogue, you're still backstopped by the oracle. So your relayer is malicious.
00:45:23.274 - 00:46:08.778, Speaker A: If you haven't convinced the oracle of Chainlink band, whoever you're using as your oracle to collude with you, nothing happens. You're also backstop from a security wise. So, yeah, from security properties. That's how we think about it. We think the most important thing is that the application, at the end of the day has absolute control over all of those levers and can always have complete control over security. There should be no case where some huge application with $10 billion of liquidity wants to run a relayer or wants to participate in the system and have control over a piece of the security in that some other party basically can just corrupt that and take everything that is not possible here. All right, could layer zero power dapps built across Salana and Ethereum.
00:46:08.778 - 00:46:27.080, Speaker A: Absolutely, yes. And we are talking to many about that. And we're writing the Salana endpoint now. So 100% yes. We will open up Salana tendermint substrate. All of these other ecosystems will have endpoints in and we will interact between. So 100% yes.
00:46:27.080 - 00:47:01.866, Speaker A: Okay. All right, I have only got a couple of minutes left, so could you touch on how NFTs would benefit from layer zero and how bridging an NFT via the protocol will work, which requirements these NFT projects would have to fill? So there's a couple of things. Right. Remember that layer zero, pure generic messaging. So you'd send any information that you want. So this could be metadata where you're locking in up NFT. Here you're sending over the metadata and like, you're minting the NFT on the other chain, an exact replication.
00:47:01.866 - 00:47:26.882, Speaker A: And you can lock in, unlock it here. Right? So it can be metadata sharing. It can be updating of metadata. So again, you're playing a game. You're doing something that's generating some events and you want to go and you want to mutate some NfT on the other chain. You want to go and you want to update its metadata. Say, hey, now I have, I don't know, some flaming sword plus three attribute or something like totally fine, you go update it and that's updated.
00:47:26.882 - 00:47:54.938, Speaker A: Or you've swapped out. You're building a castle on this other chain where you're signing like 1000 transactions, but you actually go and mint the piece where you have your apartment in the metaverse or your castle or whatever is that you're building. Like, okay, now that happens in Ethereum. So tons and tons of ways that you could do this. You could run races in Zed, run in your own chain. That's like fast and cheap. And then resolve that back to another chain.
00:47:54.938 - 00:48:18.386, Speaker A: It really just depends on what you're doing. You can propagate results, you can share state. Yeah, so there are a ton of people. Originally we were thinking like in a very defi lens. And the amount of inbound from NFT and gaming has been unbelievable. There are a bunch of people working on really cool things, but the possibilities are effectively endless. Again, generic messaging.
00:48:18.386 - 00:48:53.730, Speaker A: If you can write it in the native language of the smart contract, the chain you're working on, you can build it with layer zero. All right, I think some of you guys are going to be able to miss this, but what's Stargate? Stargate. Check out the medium post to Google the bridging trilemma. And you'll kind of read all of our thoughts on Stargate. We have not published the actual paper yet because it has full implementation details of the delta algorithm. So we will absolutely publish that. But Stargate is a liquidity transfer layer.
00:48:53.730 - 00:49:10.406, Speaker A: All right, I'm supposed to leave now. I'll answer this question, and then I'm going to go. But first of all, thank you all so much. Number one, Ama, like, first Ma has gone pretty well. These are a lot of great questions, so thank you ahead of time. But Stargate was effectively this. We launched with layer Zero.
00:49:10.406 - 00:49:49.054, Speaker A: We have this really cool generic message layer. Awesome, fantastic. Anybody can build anything, but realistically, you're talking, I don't know, a couple of months until people come and start to build the really cool primitives that start to enable everyone else to build easily there. So even if you take, like, a really simple example of a cross chain Dex, and this is an example, I give all the, like, the really naive way you might implement a cross chain dex is like a pool of ETH on Ethereum and like a pool of Saul on Solana, and that becomes your ETH Sol LP. And so for a Dex to do that, they need to implement single sided liquidity pools on both chains, which they don't currently support. They need to incentivize those pools. Xy equals K needs to be processed sequentially on the pools.
00:49:49.054 - 00:50:22.730, Speaker A: So one chain needs to be responsible for managing the state of the pools. You have a one directional transaction in one way, and the other one will need an act. And obviously, you need to recreate all the LPs that you want, because maybe you want ETH to Ray and ETH to Phantom and ETH Avax and ETH to everything else, right? So you need to create all this LPs. So a huge amount of capital injection. So that's like a really big lift when you're asking a Dex to do that. Like, definitely months and months of work, lots of core protocol change, messaging, lay risk, all of that. So, like, a less naive way, maybe you do the same thing, but with pools of some bridging assets, say USDC.
00:50:22.730 - 00:51:14.522, Speaker A: So you already have ETH to USDC lp over here, you already have USDC to sol lp over here. And so now you can leverage all of your existing LP, and you just do, like, ETH to USDC, you move the USDC, and then you do USDC to solve. Great, fantastic. But you still need to implement single sided liquidity pools. You still need to incentivize these. Like, it still becomes like a very big lift. And if one Dex needs to make this layer, if they finally do make this layer, well, then every other Dex and every other person who wants to deal with liquidity transfer also needs to make that layer, right? So the whole point of Stargate is making day one integrations incredibly easy, right? So now when you're talking for a decks, sushi swaps on like 13 chains, right? Now, if Sushi wants to integrate with layer zero over Stargate, well, what can happen now is it's literally just a pull request to the UI.
00:51:14.522 - 00:51:32.454, Speaker A: You just wrap the two contracts. Sushi on chain a gets in ETH and spits out USDC atomic transaction. That's exactly how Sushi works. Now, USDC is taken and moved over Stargate. All the messaging risk lives in Stargate. So it's Stargate's liquidity at risk, not Sushi's. Sushi on chain B gets in, USDC spits out asset X.
00:51:32.454 - 00:52:08.930, Speaker A: That's exactly how sushi works. Now, zero changes to core protocol, zero risk to any of the LP, zero need to add incentives to any sort of liquidity. One pull request in the UI, done. All sushi is now connected. And more than that, if you want to connect anybody, any third party wants to connect any two contracts over any two chains using liquidity transfer, you can now do that and compose it over Stargate. So you want to go uniswap on Ethereum, it's a one inch on polygon. Trader Joe to quickswap, quickswap to radium, farm on chain A to farm on chain B, all of that.
00:52:08.930 - 00:53:02.034, Speaker A: Anybody can now wrap any two contracts, compose it over Stargate, and it's done. So like the example of yield aggregators that we're giving where it's unstake, bridge stake, that's now one transaction from source, just wrapping contracts. But it doesn't need to be the native apps themselves anymore. Now it can be any third party, right? You make a defi portal connecting all of this stuff, just opening up all these pathways to all of these different contracts and saying, okay, now you can just route like one inch to one inch on any chain across all these multi chains, or you can go from this farm to that farm and you bake in like five bips yourself, right? There can be some business model around there, the people making this portal. Yeah, wallets who want to integrate. So we've talked to huge wallet providers across the board. Like, okay, you want to be able to do all of this defi stuff in one single transaction from within your wallet without ever leaving, without ever going to any UI trivial to do.
00:53:02.034 - 00:53:46.640, Speaker A: Just wrap the contracts composer or Stargate done, right? So the entire purpose of Stargate is to make these day one integrations dead simple. Like that's it. And again, not even like you don't even need the sushi to do this. Some other party can come and just connect all the sushi chains by just wrapping the contracts and it's done. And now all the users have this sushi to sushi interaction where you just want to jump between these two chains or between these two dexes. That was the point of Stargate, was, hey, we realize we built something really amazing like layer zero as a messaging layer is freaking awesome, but we need to make it so people can integrate very easily early on. So this allows day one very easy integration done.
00:53:46.640 - 00:54:14.934, Speaker A: And then people can have the time to integrate natively, build all the really cool stuff they want to build. So it just leverages connect any two contracts and any chains and have that liquidity transfer layer just abstract it away from you. You don't need to think about it, you don't need to be your own bridge, you don't need to be anything. So that is Stargate. It's the first application, it lives on top of layer zero. But that's just it, it's just one bridge right there probably going to be a hundred bridges written on top of layer zero. So yeah, hope that answered the question.
00:54:14.934 - 00:54:24.380, Speaker A: I am going to jump now. Thank you guys all so much and we'll see you soon. I think Max should post this recording up on YouTube at some point. So thank you all.
