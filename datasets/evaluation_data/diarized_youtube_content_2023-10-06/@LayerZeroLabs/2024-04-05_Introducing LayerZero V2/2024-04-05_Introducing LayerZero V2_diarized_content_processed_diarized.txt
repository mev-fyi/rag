00:00:00.240 - 00:00:33.642, Speaker A: We care deeply about permissionlessness, about censorship, resistance, and about having contracts be immutable. And those used to be very popular things, they don't seem to be that popular anymore. Like the Internet is a protocol for connecting all computers in a way for them to communicate. Layer zero is a protocol establishing a way for blockchains to communicate or send state data between each other. It's not a messaging standard. It's not its own blockchain. It is a protocol that enables communication across blockchains.
00:00:33.642 - 00:01:08.704, Speaker A: Our core design principles that are at the root of every design decision made within layer zero is that this infrastructure must be immutable, must be censorship resistant, and must be fully permissionless. What this means is that anybody can interact with layer zero itself. Any smart contract, any user, there is zero restriction on that side. There is a state of the protocol that will exist forever. If every existing party right now stops running that infrastructure, somebody new can step in. This will always exist and can always be run by any party. The way that v one works is that there are a library of smart contracts that lives on both chains.
00:01:08.704 - 00:01:50.030, Speaker A: We call these endpoints. They are a completely immutable set of smart contracts that any application can permissionlessly interact with. They have an append only version of a validation library so that you can always add new validation techniques as they come out. Our original thesis was that the versions that existed for validation methodologies when we launched that were not going to be default or defacto five to ten years from now, and there would always be evolving technology. Applications now interact with those endpoints when they want to send a message to another chain, and a message is just an arbitrary packet of bytes, like a packet on the Internet. An application is saying, I want to do something, and I want to trigger a contract on the other chain to do something there. So arbitrary contract invocation with a bytes array.
00:01:50.030 - 00:02:27.484, Speaker A: Now, those transactions happen on a source chain. You have this off chain infrastructure that are oracles and relayers. Oracles and relayers are entirely permissionless. It has always been the structure that anybody can run any of these. That means an application can run all of their own infrastructure, they can own all of their own infrastructure without relying on any external party. They listen for events that happen on chain a, they pick up those packets, hash the packet itself, write that transaction onto chain b, that transaction is verified on chain b, and then a transaction is executed on the destination chain to do something again. That can be anything, that can be arbitrarily moving funds across chains, that can be transferring state.
00:02:27.484 - 00:03:06.946, Speaker A: It can be any sort of mutation or invocation that you want on any of these chains. The thesis for us in doing this was that these oracles, these relayers, right? An oracle can be any number of nodes. It could be the complete validator set of a given chain, it can be 1000 nodes, it can be a single node. The protocol of layer zero is completely agnostic as to what that topology looks like, and anybody can come in and run that infrastructure. And the market has evolved drastically in the last year and a half over what that looks like. These started with potentially individual or small number of subsets of nodes, two now being things like polyhedra, ZK lite client with 300,000 ETH signatures being aggregated. That will continue to evolve again.
00:03:06.946 - 00:03:38.264, Speaker A: Layer zero as a protocol is entirely agnostic. The relayer itself is something that we expected many groups to run and want to run. What the relay is doing is actually quite complex. We're talking 50 plus chains. You're quoting gas abstraction on n squared pathways. You're dealing with tens, almost hundreds of billions of RPC calls, tens of millions of packet submissions, or sort of actually writing and inserting transactions to blockchains. Dealing with RPC infrastructure across all of these, managing gas assets across all of these.
00:03:38.264 - 00:04:10.976, Speaker A: What we have found is that it has been tremendously difficult for people to run these. So what we have in the current topology is a landscape of many oracles that people run and operate. An oracle is an easy operation. It is listing for state events and writing them to another chain, and a very small set, a single set right now, of relayers that are running. When we think about our own principles and how you build a network that is not something that was acceptable to us in any way, shape or form. Again, immutable, permissionless, censorship resistant. It was built so that anybody can do this practically.
00:04:10.976 - 00:05:07.274, Speaker A: We found that it is too difficult for anybody to do, or for people to want to do. So, as we move to this v two model that I'm going to describe, we have taken away that vector entirely. There's a complete decoupling of liveness and security, which is one of the most important iterations that we've made in the protocol's history, and moves more towards being that pure infrastructure that we always envision. So now, as you move to v two, v two is the same structure. You still have endpoints on each chain, you still have immutable libraries of smart contracts that any application can permissionlessly interact with. Now, when you move to the security layer, the validation layer, you have this decoupling of liveness and security, which is one of the biggest changes when you're going into v two. Security now is a structure of x of Y of N, which means that you can define any validator set.
00:05:07.274 - 00:05:55.886, Speaker A: You can say, there are 15 verifiers that are being run, these dvns, decentralized verifier networks, 15 of them that are being run. I want any nine out of 15. So that's my threshold. Nine out of 15 must sign off on my message for my message to be sent across. And then you can define specifics so you can say, and I must be one of them, right? I want veto rights as an application to make sure that this party, this group of deviant networks can't collude against me. That is the, you know, if you wanted maximum security, what you would do is you would provide some structure like that that gives the rest of the parties as a fallback against your own issues and gives you as veto rights to anything that's running across. Security has now moved this completely permissionless x of Y of N, where you could already do this with oracles in v one, but it was hard, it was complex.
00:05:55.886 - 00:06:40.146, Speaker A: Now it is implicit in the underlying protocol itself, extremely easy to do. And you can run any third party validation network. This is any verifying network that exists today. So any validator set, any external messaging protocol, native bridges for l two s, all of that can be used as these verifiers that live there now, execution. So this is where the relayers lived before. Before the relayers were doing both security and execution, so they were providing part of the state and they were executing the transaction. And that became an issue because if they didn't provide the securities piece, then the message itself wasn't actually valid yet.
00:06:40.146 - 00:07:18.050, Speaker A: It wasn't fully verified on the destination chain. So what happens now is as soon as your message has been signed off from your security, from your verifiers, anybody can execute that message. Completely permissionless execution. That means the end user can go and can execute the message directly on the chain. The application can go and execute every message that's going across for its users. Or you can have these third party executors that do this really complex task of managing gas across all these chains and giving this user the experience of gas abstraction. So you're on Ethereum and you're going to polygon, you have ETH in your wallet on the source chain, but you don't have matic in your wallet on the destination chain.
00:07:18.050 - 00:07:58.730, Speaker A: How do you actually execute the other leg of that transaction? Do you want the user experience to be executed, transaction here, wait however many minutes for that to resolve, somehow get matic in their wallet on the destination chain, and then execute a transaction over there. That experience sucks for most users. And what most people want is that to be abstracted away, that makes the UX so much better, it makes the developer experience so much better. But what you don't want and what you can't have is for that to affect liveness. You don't want a governance vote to be happening where there's some vote going across, it's favorable to whatever the executor is. And they go, you know, quorum has been hit. This is in our favor right now.
00:07:58.730 - 00:08:29.778, Speaker A: We're just going to have a couple hours of downtime just to make sure that that sort of stays in status quo. Maybe there's some party who could have voted against it. Oop, liveness issue. None of those votes count now. It's resolved, right? That's forms of censorship that should not exist in the protocol with permissionless execution. It means as soon as the security stack is signed off, as soon as the verifiers have signed off, the end user can go and execute it yourself. You can make sure permission that your vote has been counted on chain, you can make sure your transaction goes across, that your trade is executed.
00:08:29.778 - 00:09:05.968, Speaker A: All of those things are now in the hands of anybody who's able to execute these things on chain. So in v one, every single message must be delivered in the exact order that it was received. So if you are talking votes, you do not want to be able to censor votes, anything. Governance should have strict non sort of enforcement. That means full execution. And the reason was because security and execution, or security and liveness were so tightly coupled. Now with this decoupling of security and liveness, in v two, every message must be verified in the exact order it was received.
00:09:05.968 - 00:09:58.996, Speaker A: And that keeps all of those properties of censorship, resistance that you want, but you don't need to consume them in the order that they're received unless the application strictly enforces this. So if you think about a bridge moving money across, moving an NFT, you don't care if you're first or 15th or 37th. All that you care about is that your item, your money, arrives at the other side. And again, you can go and execute these things yourself whenever you want. And it allows the execution layer to throw as many of those transactions on chain at a single time as they want, increasing throughput, basically the maximum throughput of the destination chain. If you want strict execution, as well as strict verification times where you might like that might be a financial application. What you don't want is execution layer to be able to hold back your transaction, impair somebody else's first that they favor, or make sure they get to buy the asset that you were trying to buy and queued up to buy.
00:09:58.996 - 00:10:51.204, Speaker A: In many of those applications you're going to want to have strict execution, but for most you don't. And this is a huge throughput unlock in v two. Those are some of the largest shifts. When you're talking about layer zero, v two, the third and sort of final thing that is a really big shift is this movement from vertical composability to horizontal composability. Vertical composability causes a number of issues when you talk about how applications are stacking in tying these transactions together on the destination chain and in sort of like one atomic state. If the final application decides to fail everything before it fails, that thing that has been composed now is sort of in a bricked state. So you can imagine if I wrapped Uniswap on Ethereum and then my wrapping application failed and now Uniswap itself had failed, or was like in a frozen state.
00:10:51.204 - 00:11:40.926, Speaker A: That doesn't make any sense. It's not the way that you want applications to be able to compose together. Their horizontal composability makes it so that every resulting application in this stack has a completed state and is sort of being bundled and composed together by the next application of the chain. Again resolves a huge amount of developer experience, expands the way the applications can compose each other, and is a massive transition in how applications function with layer zero. When you're talking about how this stuff is developed, if this is going to be used for the financial world 510 20 years from now, having a rails that can be corrupted, will be corrupted. There are parties. Whether this is again future DeFi protocols and you're talking about verifies whether this is traditional, fine.
00:11:40.926 - 00:12:52.824, Speaker A: It doesn't matter who it is, if it is able to be corrupted, somebody will be will corrupt that layer and this will be a tax that is just added on the end consumer and anybody who's using this network, if you're ever going to expand to any other network, if you're ever going to do anything else, what you want is unified semantics with the same set of security guarantees with layer zero, allows you to have all of the security properties the same verification that you would have normally within the underlying validation methodology while still having unified semantics when you go everywhere else. What you don't want as an application or as a developer is to go to 15 different chains and have to write 15 different interfaces, each with their own security surface, each with their own set of risks, and each with totally different security models. By having unified semantics built into the protocol, you have all of this bundled up into one. You keep your security properties and you're fully extensible to any blockchain ever. Most people don't think about these things now. It's easy to want to build a system that just works. The state of crypto right now is so bad and the experience sucks so bad, that just having something that works is a huge step forward.
00:12:52.824 - 00:14:09.584, Speaker A: And the problem is that people will make extreme compromises just in the pursuit of being able to send their token across chains, being able to move their nfts, because it's so bad they'll take any system that works. If we build rails in this method, and we don't think about these things now, and like deeply think about the way that these systems work in the most adversarial possible manner, we're going to arrive at a future where the financial rails are rigged against the end consumer, the end thing that all of us were here in the beginning to actually fight against and move away from in this decentralized platform, this world of self sovereignty, where the end user has control and there isn't this privileged position from broader institutions. And it's extremely important now to think through, do the underlying systems actually have these properties? Is there real censorship resistance at the packet level? Can anybody run the infrastructure and participate? And if the contracts are immutable, you might have that now, you will not have that later, or you're not guaranteed to have that later. Anytime there's immutability, whatever the rest of the state is, the protocol now, if it is not immutable, then those things can change the entire protocol. And these underlying beliefs are at risk anytime that there is upgradeability or mutability in those contracts. And that is something that people have strayed very, very far away from.
