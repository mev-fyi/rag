00:00:14.410 - 00:01:32.152, Speaker A: Hello again, everybody. Welcome to day two of Devcon Zero. I'm going to start by talking a little bit about solidity, the new contract language, and then Christian, where is Christian? Christian is going to continue with the implementation and a lot more sort of details and roadmap of the future of it. So I'm just going to basically go into what drove the original sort of need for a new language. So our main issue is that we need people, lots of people, to write contracts. And as often it is brought up, these contracts need to be correct, because once they're on the blockchain we can't change them unless you've got some sort of update mechanism in place. But that brings along a whole slew of other questions, like how do you trust that the updates are going to be legitimate? So these are the two main things that we're concerned with.
00:01:32.152 - 00:03:09.400, Speaker A: Lots of people are able to write contracts and that these contracts are correct. So one of the obvious ways of getting more people to write contracts is to allow them to write it in a language that they're already reasonably familiar with. So since a lot of our prospective developers are going to be people who already understand web technologies, HTML, JavaScript, CSS, it makes some sense to have the contract language be syntactically similar to one of these for Javascript, leverage the existing skill set as it's there. We also need to a language is only as good as the concepts it can express easily, so it makes sense to build in the concepts that we know we're going to need to use often a contract language. It makes sense to have contracts as a first class citizen in that language. So what we do is we take the notion of contracts and we take a paradigm that already exists, object oriented programming. And if you think about it, contracts can very easily be considered classes or objects, depending on whether you look upon the instance of the contract or the contract, the prototype of the contract.
00:03:09.400 - 00:04:02.520, Speaker A: And so we base the language around this notion. Similarly, within Ethereum, contracts have storage. Now, having to store things in terms of literals is almost like having a beautiful high level language and having to store your integers as bytes. It doesn't really make sense. So what we do is we say, right, well, we are going to support the storage, but we're going to do so with an abstraction layer. And actually what the programmer sees is just what they're used to, which is to say usable types, strings, structures, integers of various sizes, booleans, and then finally contracts do a lot of I o. And whereas in normal object oriented languages you may have ways of passing parameters, as in parameters and out parameters.
00:04:02.520 - 00:05:03.612, Speaker A: C, for instance, uses pointers or references to do that. If you've got, there are language idioms that allow you to have multiple outputs, sort of as part of, again, a first class portion of a language, I believe go is one of these. Jeff will probably be able to confirm that wherever he is. And so this makes a lot of sense within contracts where we are going to want to call things in and then take data out of the contract without having to worry about things like references. So then we come on to making things. How do we make things correct? How do we make it most likely that these contracts are going to be correct? Well, the most obvious way is unit testing. Right? But unit testing, at least with traditional sort of basic unit testing frameworks, are going to require effort, at least a small amount of effort from the programmer to put the unit tests in.
00:05:03.612 - 00:06:25.430, Speaker A: So what we do is we devise the language, or at least the language development environment combination, to make unit tests actually easier to have in than not. So we do things like already have a space where the unit test goes, and then the ability just to press enter and you get another unit test. So just make it incredibly easy to place the expected results, or a set of expected results in there. The second thing that really helps us guarantee that a contract is operating according to specification, for some simpler specification than the definition of the contract in code, is this notion of formal proofing. So who is familiar with formal proofing? Anyone at all? A little bit. Okay, so formal proofing is the notion that you can specify some expectation of a program, and that this expectation can either be proved or not proved. But that happens at the point of compilation, not at the point of running the program.
00:06:25.430 - 00:07:35.112, Speaker A: So you can specify, for instance, that you expect, no matter what state the program gets into, you can expect that all the balances will add up to a particular number. And what you can do is if your program is written using a particular, non true, incomplete, but a particular language, still relatively rich subset of it, you can use this. The compiler can use this at compile time in order to guarantee that that statement always remains correct, always, no matter what, as long as you only use the methods. But of course, there's no other way in Ethereum than to use the methods that will always remain true. This is used in existing, I think it's used in a lot of safety critical environments. Nuclear power plants, I believe, use techniques like this. The Rolls Royce, the big engines that you see on the side of airliners, the reverse thrust mechanism, this also uses the microcontroller for that, also uses formal proofing.
00:07:35.112 - 00:08:33.580, Speaker A: I know that because my old university helped develop that particular piece of technology. So it's in use already, but it's not widely used. And so it makes some sense for contracts which cannot be changed once they're in there to use similar technology. And then the final thing is the documentation. Documentation is absolutely fundamental to our security model. When the decentralized application wants to make a transaction with the blockchain, wants to sign something with the user's key, it's really really important that the user can read a statement as to what is going on with their key, because if they can't do that, we're back to step one. This is absolutely fundamental to this notion of having a sort of more trustworthy interface to massively multi user applications.
00:08:33.580 - 00:09:18.636, Speaker A: And so we build the documentation system actually into the language. Now you could argue that doxygen Java doc already sort of have something similar, and they do. But what we're going to do is we're going to build on that and we're going to have, rather than just placeholders, actually have evaluatable expressions within the documentation itself. So contractors, first class citizens, here's an example. Can I stand in any one place that will allow everybody to see? Probably not. This gets most people, I guess. So you got the idea.
00:09:18.636 - 00:10:01.610, Speaker A: People who code a bit in C plus plus will probably this will dear you can void is wrong. That should be better. That should read the function so it looks a little bit like a class as you might expect. You got set and get you pass a parameter into one. This should read function get returns un but the other slides are correct and then you would use it by saying, right, well we've got an instance of this contract. Ignore how we actually get that instance. For now we can set it just call function.
00:10:01.610 - 00:10:05.820, Speaker A: So super easy oo style.
00:10:07.760 - 00:10:20.210, Speaker B: Interfacing Kevin, sorry. In this case it's quite counterintuitive, like store number should just be a function or like why?
00:10:24.340 - 00:11:54.780, Speaker A: I'll answer that later. So if we move on to the storage facilities again, it should be relatively easy to see that we have this notion of a state, right, which is also known as the field, the members of a class. In this case it's a uint, and then we can define our set as just setting it in our get as returning. So this to a C Plus plus programmer will be super simple, but to a JavaScript programmer as well, this portion of it will also be reasonably familiar. The returns bit is a bit different and the fact it's tight but can't really get around it. Now the storage facilities extend, so what we also are able to do is map, and this is a fundamental construct in this language we can provide a mapping from an original domain range range from an original range, in this case the range of addresses. So this is the type of address which is 160 bit integer into some arbitrary domain, in this case endpoints.
00:11:54.780 - 00:12:41.340, Speaker A: And we've specified an endpoint as being ipv four and four. This is a bit c. The syntax is still up for alteration. If anybody here has some ideas to make it slightly more javascripty without making it too difficult, too fast. And then we have the idea of setting, and we can make a new one, assign it super easy stuff, delete for killing it. Variatic returns. So if we want to get the information of an address, we can just specify the two return types.
00:12:41.340 - 00:13:12.874, Speaker A: Easy enough. Now the formal proofing is probably the most interesting and challenging part of this. I imagine Christian is looking forward to that particular portion of the project. The idea behind it is that we have, here's an example of a cash contract. So you give to somebody some amount, and you check that the amount is greater in the caller's balance. Then you subtract it and add it to the destination. Check the balance.
00:13:12.874 - 00:13:38.634, Speaker A: That's easy enough. We could do a mapping. So map our address to a numeric type, and that's the balances. Again, easy enough. We got this construction. So this is the initializer. So we're just going to initialize whoever created the contract to a billion or whatever, some pre mined amount, and then we have an invariant, right? This is the really clever bit.
00:13:38.634 - 00:14:35.366, Speaker A: So this is the bit that says at all times, no matter what, this contract must always satisfy this piece of sort of prototypical set theoretic math. What we're actually doing is we're reducing, well, we're going to map the idea of value of. So value of just in this case is the idea of taking each item in the balances and just taking the value, so the balance itself rather than the address. So we're going to map that to balances, just get a set of addresses, and we're going to reduce that set of addresses with a plus operator. So that's to say we're going to sum some of them. And what we're saying is that sum sum of the balances should always equal a billion. And what the compiler is able to do is go through the only non const, the only mutable method.
00:14:35.366 - 00:15:37.066, Speaker A: So the only method that actually changes the state, which is this one, and do a formal proof of this code to check that if it satisfies this constraint at the beginning and this code executes, it will always satisfy the constraint at the end. And in this particular case it does. And so the compiler would be happy. Now what that gets the auth there is the ability to state in the documentation that for this line of code it says at all times total balances will be a billion. Now someone coming to this contract who maybe has some reputation, it could be like the Ethereum foundation or the EFF, or, I don't know, whoever it is, will be able to check that line of code indeed is well representative of the documentation line above it. Give that a tick. Yes, that's valid.
00:15:37.066 - 00:16:12.454, Speaker A: And then they don't need to check anything else because the compiler does it for them. So when the user comes along and they say oh, the foundation ticked, this line that says cash at all times in this contract is a billion, they can trust it. They're like great. And in none of that did we have to actually look at this code. I'll come to it at the end, Victor. So the final thing is the inbuilt docs. So that's kind of what I was saying earlier.
00:16:12.454 - 00:16:57.154, Speaker A: We have the doxygen style at the moment, triple slash, which I guess most of you are probably familiar with. The interesting thing of this is the backtick. So the backtick allows us to insert arbitrary expressions, JavaScript expressions into the documentation. So what this does is it provides a notice for the user. So when the user sort of clicks through on some DAP and gets a transaction, the DAP wants to submit the transaction into the network. This is the message that comes up in the browser before it signs it. So there's like a sort of black box in the browser, right, that contains all the secret keys.
00:16:57.154 - 00:17:46.902, Speaker A: And ultimately this could be controlled, actually not in the browser itself, but it could be controlled by a trusted computing portion of the hardware. So something for which even the operating system doesn't have access. And what, this would bring up a message, it would say transfers, and then it wouldn't actually say underscore amount, right? It would say the actual amount. It will place the amount in there. So it'd evaluate what underscore amount is and then stream it into this text, cash from your account message or call. It would give you either the name, if you've got a name attached to it, if name Reg has got a name that you trust, or just the hex, or maybe even a little graphic to the account controlled by. And then again the same thing, but the destination returns the cash.
00:17:46.902 - 00:18:06.042, Speaker A: We don't really care about that. And then you've got the construction. Creator of the contract is endowed with a balance of a billion. That's easy enough. It would probably insert Miss Scott caller so you can get the address. And then finally this magic line. Total cash in the system is always a billion.
00:18:06.042 - 00:18:43.450, Speaker A: And this is the thing that the auditor or whoever, whoever is that, there are many auditors. I mean, it's decentralized checks this line, that's fine, that means this. And that's the magic. When the user comes to look at it, they get an absolutely trustable statement. Cool. So those are the basic driving factors and rough solutions to them. Christian is now going to go into a little more detail.
00:18:43.450 - 00:18:47.100, Speaker A: Then we'll do a question and answer session at the end and you can bring up your points.
00:18:52.350 - 00:19:55.150, Speaker B: Okay, so yeah, now let's see how this is all implemented. First, what were the requirements for solidity? Gavin already told us about that. So it's a contract oriented language, which means that classes are contracts. It is statically typed from the syntax close to Javascript, and when you add types to Javascript, you get something which is close to c or c, the built in language documentation and some language subset that allows formal proofs of correctness. Yeah. So coincidentally this is exactly the contract Gavin also showed. So you already know that the ubiquitous coin contract.
00:19:55.150 - 00:20:50.244, Speaker B: There we see something we've not seen in Gavin's talk. The language is statically typed, but still it's not necessary to always specify the types. You have this keyword VAR, which can be used for local variables, and it's similar to c plus plus eleven's auto keyword, which means the type is just taken from the type of the first assignment to this variable. I think that's quite convenient. Yeah. Okay, then we see something. Users can define their own types so they can define structs, and then mappings can map basic types to any type.
00:20:50.244 - 00:21:34.636, Speaker B: So we can have a struct as the value type. We can also have mappings, again as value types. We can also have contracts as value types. And this vote is the struct type here. So you can retrieve from the storage from this mapping here the value which is stored at the sender's address, and then assign values to this local variable. But this doesn't really. So this actually assigns it directly to storage because vote is not a local variable that is stored on the stack, it's just a reference to the storage.
00:21:34.636 - 00:22:19.630, Speaker B: So you can directly access storage here. Okay, some details about the compilation process. It consists of six stages. The first stage is just parsing. After parsing we have the basic abstract syntax tree, so we know the structure of the program. The next step is resolving identifiers, so words identifiers, strings can refer to user defined type names, they can refer to function names, whatever. And these are all resolved in their respective scope and assigned in the abstract syntax tree.
00:22:19.630 - 00:23:31.022, Speaker B: And after that step it's possible to infer and check the type so that assignments do not conflict in types and functions are called with the correct number of arguments, and so on. And after this third step, it's possible for an IDE to actually use the abstract index three for things like autocompletion or checking where a variable is used and all this nice stuff we want to have. And the fourth step is compilation to an assembly language. Then this assembly language is optimized and finally compiled to bytecode some details about the type system. Statically typed means that all expressions in this language have a fixed type that is known at compile time and an operation. So it's not possible for an operation to involve two different types. So you cannot add a string to a number, but it is possible to do manual type conversions.
00:23:31.022 - 00:24:37.420, Speaker B: So if you manually explicitly convert the integer to a string, then you can add them, and at some point automatic type conversions are done, if it makes sense and if no information is lost. So we will see that later. The types that are currently implemented are unsigned integer signed integers and hashes of various sizes. So this x is always the size in bits from eight bits to 256 bits in eight bit steps. And the difference between integers and hashes is that arithmetic operations are not allowed for hashes because it doesn't make sense. And a special case of 160 bit hash is address. And for an address not even bit operations are allowed, but instead you can send ether to that address or query the balance at that address.
00:24:37.420 - 00:25:44.500, Speaker B: Then we have boolean type mapping structs and contracts. Later we will also have strings, but that's not implemented yet. Okay, I hope you've seen this already. So this is also available online. It's the solidity compiler, compiled to javascript to be run offline in a browser. Sorry, that's what always happens. Okay, so this is a basic contract without any content, and on the right hand side we see the compiled opcodes, the compiled binary or hex version of the binary, more detailed assembly, and at the bottom we have the abstract syntax tree it.
00:25:44.500 - 00:26:22.934, Speaker B: And if I enter something in the function we will see the types that are insert from these literals. The type of a literal is always the smallest type where it fits. In this case, it's an eight bit unsigned integer. And if we add an eight bit unsigned integer to an eight bit unsigned integer, we again get an eight bit unsat integer. Nothing too fancy. So it gets interesting when we use larger values. So 7000 is a 16 bit unsight integer.
00:26:22.934 - 00:27:50.310, Speaker B: And we add an eight bit unsigned integer to a 16 bit unsigned integer. This eight bit integer is implicitly converted to a 16 bit integer. And what if you add like 200, 200? The type system ignores overflow, so it's just about, yeah, so one, we always know that the type of the result of a binary operation is one of the types of the operands. So only one of the operands is converted. We can now assign that to a variable and we will see that x will have type 60 bit unfinished integer. Okay, what happens if we, if we want x to be an eight bit integer, we get the error that the 16 bit integer that is on the right hand side is not convertible to an eight bit integer on the left hand side. Okay, something that is perhaps also interesting is what happens if we add a negative number to a positive number.
00:27:50.310 - 00:28:43.620, Speaker B: So the compiler complains that it cannot find a common type. The type of minus one is signed bit integer of eight bits, and eight is an unsigned integer of eight bits, and so you cannot convert one into the other. So there's no common type. Of course we know that both of them can be converted to an assigned integer of 16 bits without losing any information. But because of this restriction, I told this is not automatically, but we can of course force that manually and convert this minus one to a 16 bit sight integer and then it works. And X is also assigned integer of 16 bits.
00:28:45.960 - 00:28:48.580, Speaker A: Okay, you check it also on the variable.
00:28:49.960 - 00:28:56.196, Speaker B: What do you mean? If you have variable plus variable, you check the questions for authority instead of.
00:28:56.218 - 00:29:00.250, Speaker A: Doing the very translation can we do the questions?
00:29:01.100 - 00:29:59.224, Speaker B: It works on arbitrary expressions. Okay, the optimizer, so solidity does not compile to LLL, but it compiles directly to EVM assembly, and it uses LL's assembly class, which also includes the optimizer. So if we improve the optimizer, then solidity serpent and LlL will benefit from these improvements. I already did some improvements. So the LLL optimizer is, so most of the steps in the LL optimizer is just a pattern of opcodes is mapped to another, to another set of opcodes. And if the number of opcodes decreases, then this is applied. One of these patterns is constant folding.
00:29:59.224 - 00:30:52.780, Speaker B: So if you write seven plus eight, then the optimizer will not do this addition at runtime, but it will do it at compile time and just directly push 15. And I added some other operands for this constant folding because they were more widely used in solidity. And another optimization is pop optimization. This happens if you do some computation and it does not have side effects and you just discard the result of the computation. Then the optimizer removes the whole computation. Okay, let's see an example. Okay, first without optimizer.
00:31:01.590 - 00:31:03.100, Speaker A: So it.
00:31:04.990 - 00:31:58.150, Speaker B: Okay, so we have to look at the assembly now from tag zero to this tag three, that's the body of the function. And we see it does push zero. That is, it initializes the local variable to zero, then it pushes the two operands, eight and seven adds them. And this swap stores it at the location of x. And pop removes the old value of x. And if we activate the optimizer, so it pushes zero, and then it pushes f, which is 15, swaps it, stores it and removes the old value. So this is not yet optimal because we know it's not necessary to initialize x to zero when we change its value afterwards.
00:31:58.150 - 00:32:51.320, Speaker B: But yeah, optimizer is not finished yet. I would say to see pop optimization, we have to remove this x. Let's see. No, you also have to remove the local variable. So yeah, what happens here now is, okay, yeah, take zero, that's the function body, and nothing happens. Okay, how does solidity use memory and storage? We've already seen everything is serial initialized, we can trust on that. And lockup variables are currently used only on the stack.
00:32:51.320 - 00:34:08.548, Speaker B: So it doesn't actually use memory. It uses memory only for opcodes, for operations where it's really necessary. This might change later because the EVM can only look at the stack at the 16 topmost position in the stack. So if we have many local variables or very complex expressions, and we want to store something in the first local variable, we might have to look too deep into the stack. So we have to copy it to memory first and then unwind the stack and save later. Again, the storage is allocated in a contiguous way, so if you have one struct and then another struct, then they will sit directly next to each other in storage, where mappings are an exception, because mappings don't have a size. So to compute the offset of a mapping, you take the, or to compute the offset of a value in the mapping, you take the offset of the mapping concatenate the key compute sha, three of that and that's the offset of the value.
00:34:08.548 - 00:35:00.624, Speaker B: I think that's more or less exactly how it's done in serpent with the introduction. So in serpent 2.0 the obvious way, I would say, okay, reference to other contracts. Gavin already gave an example for that a bit more detailed. We can include other contract files, contract source files, and use contracts also as values for mappings or directly in storage. Namewreck adder is an address, so if you write it like that, namereg is a contract type. This is just usual type conversion.
00:35:00.624 - 00:35:51.568, Speaker B: So address can be converted to a contract type and then we store it in storage. From this point on we can use namereg and call functions on that. And for that we don't need the full definition of the namereg contract, we only need to know its interface. So this namerexol file can be a simple file which has all functions but not the function bodies. It's different for this line here where we create a new contract and store it at this point in storage. So here we actually need the full definition of the coin contract to create it. And when it's stored we can use it to call a function send amount to.
00:35:51.568 - 00:36:35.956, Speaker B: So that's a function we've seen in the second example. Yeah. What are the plans for the future? I think we will have a complete first usable version by the beginning of December. So yeah, after Defcon zero the current state is that most of the basic features are there. What is missing is actual access to the blockchain. So query balances and send funds and references to other contracts. But that's not much work.
00:36:35.956 - 00:37:43.140, Speaker B: I would say future areas of work are yeah, I shall write some tutorials or actually create a specification of the language. I think then depending on feedback from users we might add some new features to the language. We might need to improve the optimizer, but that depends on how the language is actually used. So we will have to look at some real world example contracts, then work on documentation. So this net spec documentation where the next so we'll see that in the next talk and actually creating the ide and then work on static analysis and formal verification and of course bug fixes and refactoring. That can always be done. Am I on time? Okay, so yeah, one planned language feature.
00:37:43.140 - 00:38:46.408, Speaker B: I don't know if that's interesting. Anonymous structs so you can do mappings from a struct type without actually creating a name for it. So functions that return multiple values you can just store them in local variables directly and also return them like that. So I think that's something we want, but that's not implemented yet. Some ideas for the optimizer I think it's really important to be able to use other contracts as library contracts somehow, at least for simple functions like computing the minimum or finding something in a list. And for this it's important to so calls to other functions are quite expensive because you have to move all arguments to memory create. So run this call up code and then retrieve them from memory again.
00:38:46.408 - 00:40:17.800, Speaker B: And if the function is small, then it's much more efficient to just copy the code to that location. And another benefit of inlining function calls is also that the optimizer can actually optimize something there, then it's perhaps necessary to reorganize the local stack. So for example, if two local variables do not really overlap in a function, they can use the same stack slot. And if the feedback results in really really bad performance for the compiler, then it's perhaps necessary to consider some simple intermediate language where more optimizations are possible than on the stack based EVM code. So some ideas for static analysis const functions are not enforced currently that should be done. Then what is also quite easy, I think without doing the whole process of formal proofing is to determine the value ranges of local variables and check whether some overflows can happen. So if some addition was protected by priority prior to that, checking that an overflow can happen, and perhaps also checking that from the value range, some equality comparison or inequality comparison can never be true.
00:40:17.800 - 00:41:28.950, Speaker B: And then we see that the developer did some error there, so some code is not reachable at all. What is also useful, I think, is to estimate the gas usage at some source line, so that while writing a contract you actually see how expensive the line is and you can perhaps change it to be less expensive. And what we probably also want is if you issue a transaction, you have to set the gas value, and you probably want to have some estimate on how expensive it is, some lower and upper bound. This of course will in the end, so the actual gas cost will in the end depend on the order transactions are introduced into the blockchain. So yeah, will not be absolutely correct, but I think we can provide good lower and upper bounds for the gas usage. Okay, that's it.
