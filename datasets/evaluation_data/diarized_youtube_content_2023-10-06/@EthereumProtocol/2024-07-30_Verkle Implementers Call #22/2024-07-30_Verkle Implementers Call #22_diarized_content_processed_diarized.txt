00:00:03.800 - 00:00:39.275, Speaker A: All right, welcome to Virkal Implementers call 22pm issue 1119 in the PM repo. We have a pretty short agenda today. We have the usual updates from client teams. Then up next, SSC measurements, some updates from Guillaume there, then CAL updates. And last up, Ignacio wanted to go through his new EIP for the state conversion. So just those four things on the agenda right now. Does anyone have any.
00:00:39.275 - 00:00:45.335, Speaker A: Any client teams have any updates? Start with.
00:00:51.395 - 00:01:15.805, Speaker B: I guess I can start. We are still working on several things at the same time. One of them is implementing the field cost. So we made. We made some progress in this. Yeah, we also worked on the NIOTA cost. So there was a gigantic issue that we had that I wasted a couple of days on, but Perry helped me fix it last week.
00:01:15.805 - 00:01:46.005, Speaker B: So we're going to resume that effort Overall. Yeah, we're not going to be able to do the. We're not going to be ready for testnet relaunch by the end of the month obviously, but we're getting there. So hopefully by the end of the summer we'll be ready. And what else? Yeah, we did a series of measurements, but we'll be sharing this later. So that's it. Ignacio, you got something to add?
00:01:47.305 - 00:01:51.875, Speaker C: No, not much else. I will share the AAP updates. Later is fine.
00:01:58.855 - 00:02:30.733, Speaker D: Yep, I think I can go next. So in other mind, we have implemented all the changes that we discussed for Devnet 7, so we are almost ready for Devnet 7. We still need to pass the hype test. I'm not sure if we have like state test. I know we have transition test. That's one question. Like, do we have like test apart from transition test as well for vocal and second thing is I'll be off like later this week and the next week, but if we launch the test net next week, I'll probably be available for that.
00:02:30.733 - 00:02:32.265, Speaker D: So yeah, that's it.
00:02:35.365 - 00:02:45.865, Speaker B: Just to add. Yes. I'm also off starting Thursday for two weeks, so I don't think we're launching anything. I mean, unless Ignacio wants to do that by himself.
00:03:02.065 - 00:03:02.497, Speaker C: Cool.
00:03:02.561 - 00:03:21.455, Speaker A: Any other updates on the question of which test we currently have available? I don't know, Spencer, if you're free to maybe answer that question for Tanishq.
00:03:21.995 - 00:04:00.405, Speaker E: Yeah, sounds good. So it's currently just the transition test. In the last call we discussed creating a new release with the updated Geth branches that were used to fill the tests. But those branches produce the same fixtures for the transition tests. So the existing release for the transition tests is sufficient for now with regards to state tests. My assumption is that those tests are starting at. Starting at the VIRCO fork.
00:04:00.405 - 00:04:33.145, Speaker E: We don't have tests for that currently. I do have a branch to fill starting from Virko on our existing tests, but they're not yet working on the test cases that Ignacio has produced. However, if it's worth having them working before Devnet 7, we can make a push for that.
00:04:38.245 - 00:04:53.665, Speaker D: Yes, if it's possible to get them working before Devnet 7, that'll be great because it'll be a good test bet to test all the implementation against it so that we don't start the test. Net and within 100 blocks we find our issue a consensus issue.
00:04:54.965 - 00:05:00.795, Speaker B: Yeah, that would save a lot of time if we could have that. Yeah. Ready before we launch.
00:05:05.015 - 00:05:05.955, Speaker E: Sounds good.
00:05:08.295 - 00:05:36.535, Speaker B: I also had a question so we discussed this morning about. Yeah. Because I have a lot of branches to merge, so thanks for that. Like, I was able to check against what was filled, but if I want to fill again, like, I'm still a bit not sure what I need to do. If I want to fill again, like, are you still blocked by a bug? Or could we use the field test to refill new tests so that I can check that my filling is correct compared to what I replay?
00:05:38.915 - 00:05:58.259, Speaker E: Yeah, we can, we can, we can still do that. I can send you information to refill. Refill the tests. I think it's the way we're currently doing it is. It's. There's like a lot of steps and it's using a different. Different tooling, so it can be kind of confusing.
00:05:58.259 - 00:06:11.375, Speaker E: So ideally I want to make it as easy as possible for everyone to just run a command and just build to test everything. But I can send you the information to refill and then re. Execute.
00:06:13.715 - 00:06:51.785, Speaker F: We can also use the tagging feature of the. Of the repo. I don't know if that. Have you. Have you tried that in the inner repo for Verkle? Because what we're doing for EOF right now is that we push new tests and if there's a modification in EVM1, we tag any branch in a repo and it automatically fetches the latest EVM one compiles and then refills. So we could do something similar here. So basically we tag something for Burkle, it fetches latest glance branches, builds and refills automatically.
00:06:51.785 - 00:06:55.825, Speaker F: It's pretty easy to do. We can set that up to make it easier.
00:06:57.725 - 00:07:20.547, Speaker B: But wait, because if it's the latest of one branch, what if I want to use a different branch? Right. Because what I would like to do is currently I have a branch that's not merged into the main branch and I would. Before I do, I don't want to break anything, so I would like to test that branch before I merge it into the main one. Would that be possible to somehow specify that?
00:07:20.731 - 00:07:45.035, Speaker F: Of course. How long do you think it's going to take until you merge that other branch into the main? Because if it's going to be like a long time, we can simply just push a PR right now to point directly to that branch, that other branch that you're working on, and this tagging method should automatically fill using that other branch. It's a super simple change we can do very quick.
00:07:45.335 - 00:08:07.475, Speaker B: That branch is just waiting for this to be merged, unless I find a bug, of course, that branch would just be merged immediately. Then we have another one which is Ignacio's branch that we are trying to use for test at Genesis. We would like to merge this one too. So we need to test to test it as well.
00:08:08.455 - 00:08:47.685, Speaker F: I see, I see. In that case. So what we can do then is that we can create a branch in execution vectors that points to whatever branch you need to fill and then just stack make. The tags that we make for Berkeley for Berkeley releases can just point to this alternative branch. And the only difference between main and that this alternative branch is either verkle changes, but on top of that, the EVM building and fetching all that stuff will point to this other branch. I can create this alternative branch today if I can just give us the branches that you need to point to.
00:08:48.145 - 00:09:02.335, Speaker B: Ok, that would be awesome. Thanks. Cool.
00:09:03.675 - 00:09:09.575, Speaker A: Okay, next up on the agenda, Guillaume, you had some updates on the SSE measurements that you were doing.
00:09:10.795 - 00:09:37.973, Speaker B: All right, let me share my window. Yeah, this one. So this is a document I'm currently working on. So it's not quite. It's not quite ready. So you'll see a lot of to dos. But as a summary, we were trying two different ways to encode the witnesses and now we have yet another one.
00:09:37.973 - 00:09:51.609, Speaker B: Oh, the description is missing one of them. Not good. Okay. Oh no, sorry. That's the. So there's the one that's specified in the consensus spec, which I guess I can. If the link works.
00:09:51.609 - 00:10:42.723, Speaker B: Yeah. Where is it? Right, so there's the traditional one where you have the STEAM state diff as a stem and then the list of suffix state diffs. So for each suffix you have an optional current value and an optional new value. What we discovered is that because optional is not really supported by most SSD Libraries, yeah, including the GO ones. It tends to create very, very large witnesses. So we were experimenting with other ideas to try to reduce the amount of. Well, first to remove the use of optionals, and on top of that, try to reduce the amount of nulls so that they are encoded properly.
00:10:42.723 - 00:11:27.839, Speaker B: Well, turns out nulls are quite difficult to encode in the GO library and presumably in other libraries. So we wanted to try to avoid this. So we tried this first method where we put all the suffixes together, then all the current values together, and then all the new values together. So the index, for example, suffix like index I into suffixes will have. We also have an index in current values and in new values, so the value can be null. So it's not perfect, but it was saving some space. We tried a second approach where we tried to remove any instance of null.
00:11:27.839 - 00:11:51.155, Speaker B: So we would differentiate all the use cases. So, for example, there was the case where the value existed before and was overwritten. We call that an update. There was the case where the value did not exist before, before N was written to. So we call that an insert. And there was the case where the value existed before and was not modified. We call that a read.
00:11:51.155 - 00:12:46.185, Speaker B: And then there's simply what we call missing, which is a value that did not exist before and is still not inserted. So you just need the list of suffixes. Ignacio came up with a third method, which is an improvement on the second one, which. In which you get rid of the idea of the suffix state diff, and you put everything in the same state diff directly. So you have the stem, and then you have a list of all the updates and all the reads and all the inserts and all the missing. And what you get out of this is that you remove, because for each one of those lists you have a counter. So if you repeat that structure multiple times, you have, sorry, not a counter, but a header.
00:12:46.185 - 00:13:13.881, Speaker B: So you repeat that header. So what we wanted to do. Excuse me, is we wanted to get rid of this repetition of the. Of the list header. So we put the list itself inside the stem state diff. And every type of update is a fixed container, so it doesn't have any header. We try to see if it would save some space as it stands.
00:13:13.881 - 00:14:14.145, Speaker B: Yes, it does. You can see that the spec, on average, I have the numbers here, the median witness size for the spec that includes witnesses that were produced between during the transition and after. So it's like a global view, but the median witness size is 700 kilobytes, which is quite large. And we go almost to 200, sorry, 2 megabytes when we steep type 1. So as a reminder, type 1 is just grouping the suffixes and the current values and the new values in lists, we do get a better approach. So it's already much smaller. The median is almost about 372 kilobytes and the maximum block size we could find was.
00:14:14.145 - 00:14:41.763, Speaker B: It's been done by replying, by the way, I should have added it's 1.3 megabytes about. So it's much smaller. Then what we did was try the second method. So as a reminder, the second method is you try to get rid of all the nulls because the nulls were poorly encoded. So we expected it to be smaller and indeed it is smaller. The median is now 322 kilobytes.
00:14:41.763 - 00:15:33.435, Speaker B: So we shave 50k on average and the maximum block size is less than 1 megabyte. And the final method, the one we propose, where all the structure is removed to try to shave off the list headers, it does work. Because the median size for the witness is less than 300 kilobytes, we still have the maximum block size. So it doesn't really have an impact on the maximum block size. But that's because this block is most likely very pathological. So these are preliminary results. For example, this is a bit surprising that they have exactly the same maximum block size.
00:15:33.435 - 00:16:34.269, Speaker B: So yeah, we need to dig into this. We also need to dig into how much of that space goes to the previous current value and how much of that space goes to the new value. Because even though we say, well, it should be fine to also have the new value, maybe if it takes more than 50% of the block size, maybe we want to get rid of it. So yeah, that's the first graph I wanted to show and I'm skipping ahead to the end where like this, this diagram was conflating both the sizes during the conversion and after the conversion. Here we ignore the conversion because it's not really representative. It's only values that were not existent and got copied from the, from the mpt. So we see that once the conversion is over, the tree is a bit bigger.
00:16:34.269 - 00:17:29.875, Speaker B: So the median size in case of type 2 is almost 400 kilobytes and the type 3 still shaves some space. But the worst case is still the same. The type 1 is not as bad. I'm trying to remember what the value was. Yeah, it's a bit worse than the overall view, but it's still less than half a megabyte. So the conclusion at this point, even though the document is not completely written, is to say, well, maybe for the new testnet we should be using that new type, that new transaction. Sorry, that new transaction, this new witness type that is much smaller and the problem with this approach is that it requires some input from the cls.
00:17:29.875 - 00:17:45.495, Speaker B: But yeah, I just wanted to know what people thought. Do we want to change the witness format at this point? We can do it later too. Just trying to gauge if it's worth the effort at the moment.
00:17:50.555 - 00:18:08.495, Speaker D: I think if we have this wave of differences we should try and change the size. But I'm not very sure if we should do it in the next testnet. Like it also depends on when we are starting the next test. But what I'm thinking is that we are changing a lot of things at once.
00:18:09.035 - 00:18:09.483, Speaker B: Yeah.
00:18:09.539 - 00:18:32.675, Speaker D: And there's a lot of. There's a. There's a lot of chances of like some of the things break and some doesn't and that kind of creates it hard to debug as well. So if we can like kind of only do the changes we discussed in Interop or basically other things that we added to that in Devnet 7 and then we can move this change to Devnet 8, that'll be good. But I'm okay with doing this in Devnet 7 as well.
00:18:35.735 - 00:19:13.515, Speaker B: Yeah, I'm also quite on the fence about this. I like the size gains, but we still are going through some testing so we might find an even better approach. Yeah, I guess. I guess we like Tanishki is right, we should not do this. I'm still open for other people's opinion, but since, yeah, there's more work to do, maybe. Maybe we should wait. Actually on the CL side I can probably make the changes.
00:19:13.515 - 00:19:14.699, Speaker B: That is not a big deal.
00:19:14.787 - 00:19:17.307, Speaker D: Depending upon whether we want to do.
00:19:17.331 - 00:19:19.775, Speaker B: This change for the next or next or next.
00:19:32.195 - 00:19:34.695, Speaker A: Sharing a link to that note?
00:19:36.795 - 00:19:52.337, Speaker B: Not yet because it's work in progress and I need to. A lot of the text is nonsensical. I need to keep editing. So if you don't mind, I'll share it. Yeah, mid summer when. When it's a bit more thought through and ready.
00:19:52.521 - 00:19:54.045, Speaker A: Yeah, sounds good.
00:19:56.425 - 00:19:57.205, Speaker B: Cool.
00:20:00.145 - 00:20:05.725, Speaker A: Then. Next up on the agenda, any updates on K?
00:20:19.275 - 00:21:11.003, Speaker B: Yeah, I had two questions actually. One of them, the answer is probably going to be the same as the. As the previous one in Kenya, Kev was pushing to replace the proof format from this SSD stuff we've got. So just to be clear, there's the witness part, the state diffs right and there's the actual cryptographic proof, all the IPF actors, the final evaluation, et cetera, et cetera. Kev was pushing to move this back from SSZ JSON into an opaque binary format. I mean we agreed we should do that in the long run. The question is when? So my question was roughly do we want to do it for healthy then 7? I expect the answer is going to be the same.
00:21:11.003 - 00:21:21.895, Speaker B: Let's focus on the Exactly. Tanish, I agree with that, but yeah, I just wanted to put it out there so that people have a say.
00:21:24.035 - 00:21:50.305, Speaker G: One small point. I was involved with Kev when that was discussed and one of the reasons was because one of the underlying ROS cryptography wasm that we use notably in Ethereum JS required the OPEC format rather than the explicit format but since then we've modified the underlying library to be able to consume the explicit format that is that we have in KUST 7.
00:21:50.376 - 00:21:50.697, Speaker B: 6.
00:21:50.801 - 00:21:54.125, Speaker G: So I don't think there's any urgency to do that in Kustenin 7.
00:21:55.205 - 00:23:22.745, Speaker B: Cool. Well then that settles it because at the same time we don't want to have to like to change the CL twice, so might as well wait for when we do the SS update as well. My second question about Chaos 10 was initially we said we should do Cal State 7 including the cost, sorry, the cost we agreed on in Kenya and also the field costs on my side I've been working on trying to integrate more stuff into Geth Master to simplify the rebase the rebase on top of Cancun, which hopefully we can do on Devnet 8. And as it turns out there's a lot of changes currently going into Master that will make the implementation of the field cost much easier. So I wanted to ask if everybody would be fine with changing the spec for Devnet 7 which would be to have all the Kenyan costs except for field cost, because yeah, for us that would incur a rebase and we're probably going to need another two months to do this. So yeah, if that's what we need, if there's some pushback, we'll make it happen. But it's going to take two months.
00:23:22.745 - 00:23:25.545, Speaker B: Just. Yeah, let me know what you think.
00:23:28.565 - 00:23:34.585, Speaker D: I think if it's going to take that long, then we can probably skip it with this testnet.
00:23:46.135 - 00:23:48.235, Speaker B: Any opinions from Ethereum js?
00:23:54.095 - 00:23:57.555, Speaker G: I personally don't have a video or a vaccine on this.
00:23:58.415 - 00:24:16.787, Speaker B: Cool. Oh, Gary's here as well. Gary. Did you guys implement field cost already? No, we did not implement fill costs. Ok, so for you that would be actually also a good thing not to. Not to have that for the next test. Net.
00:24:16.787 - 00:24:47.471, Speaker B: Yep, exactly. Excellent. Yeah. I don't know, maybe Subnet or Oliver, you have a comment on this for your own implementations? Oh, Roman is here too. Not in from there. Okay, cool then. Thank you.
00:24:47.471 - 00:25:04.555, Speaker B: I guess we're. We're doing this and. Yeah, so that we can have a new testament. Sorry, go ahead. Yeah, I was gonna say I arrived a bit late. Do we have a link to this? The criteria, apart from the Kenya costs that are going to Devnet 7. Is it.
00:25:04.555 - 00:25:24.547, Speaker B: Is it mostly going to be the Kenya costs? It's. So I think we haven't merged the PR yet. I need to check. But it's. Yeah, it's the Kenyan cost, except the field cost. So if the EIP has not been updated, we will merge it. Yeah, we should merge it today.
00:25:24.547 - 00:25:37.245, Speaker B: Get vendor if we haven't done so. And yeah, it's just the eip. So all you have to do is check the EIP and set all the field cost to zero. Great.
00:25:48.425 - 00:25:57.925, Speaker A: Okay, cool. So then, last up on the agenda, Ignacio, do you want to go through your new EIP for the state transition?
00:26:00.185 - 00:27:06.705, Speaker C: Sure, I will share my screen. Yeah, so before talking about that one, I also made a lot other two PRs that I shared in the matrix channel. But just in case I'm mentioning them here. One of them is some quick fixes on 7612. Nothing really that interesting here, but I will share this link in the chat some minutes. The other one is an update in 6800 and here it's basically a naming fix. But also I clarify how we encode the fields in the new basic data leaf.
00:27:06.705 - 00:28:47.725, Speaker C: This is part of the change that were designed in Kenya. So previously the PR kind of assumed that we encoded the co size, nons and balance in Little Endian, but that was problematic because we had the intention. Okay, so if we remember something important is that we have four reserved bytes between the version and the code size. And one of the ideas was that choosing this ordering where we have these four bytes before the code size was interesting because if in the future we want you to bump the size of the code size, like things will be properly aligned so we can use one of those four bytes for extending the code size. But the problem with that was that if we were saving this in Little Endian, this was wrong because like we need this reserve byte to be the new most significant byte of the call size, not the least significant byte. So what I proposed and this Got merged a bit fast because automerge did it was just changing everything to big Endian. So basically that means that code size will be big endian and then we can kind of extend this in the future using this extra byte that is on the left.
00:28:47.725 - 00:30:23.085, Speaker C: So that was like the main intention. So just be aware of this because this is part of a change that you should account for the next devnet. It should be pretty easy, just like change the calling from little Endian to big Endian and should be fine. I will share the link also in the chat in some minutes and then I created a new EP which yeah has number 7748 and basically it's a formalization of all these state conversion algorithms that we have discussed like in the last months or even more. So I will switch to a better view here. So I won't go through all these in detail because might be quite long but the style of these CIPs like quite related to the execution specs code base. So it's mostly described as code which I hope will make things even easier to understand because I know maybe explaining all these in text will be a bit confusing.
00:30:23.085 - 00:32:19.265, Speaker C: So yeah, if you are used to the execution spec test, execution spec in Python, this will make hopefully a lot of sense. But if not that's fine, it should be pretty intuitive. So basically in this first like four or five code sections I just described some helper functions or some co additions in existing files and basically the last code chunk is the actual main logic for the conversion where you basically walk through the MPT and for each thing you have to migrate you have like all the logic. So yeah, I added a lot of comments so just to make things as clear as possible. So hopefully this should feel simple, I mean there shouldn't be any kind of weird thing. And I also in the rationale section added like multiple sections with expected questions that I guess most people reading this AAP might have like why we chose to put the conversion in the proposed place in the execution pipeline, like why we choose the conversion stride number. Yeah, miss lots and other things.
00:32:19.265 - 00:33:14.795, Speaker C: Something also that I want to say is that I included in this proposal also this idea of like removing all these remaining accounts that are related to EAP158 because we have still some of them and we have talked about many times that during the conversion we can finish up this cleaning. So that is included too. So yeah, so feel free to simply take a look and make any comment. All the code here is very like high level. Nothing around this really depends directly on the workle tree itself. So we have to do another migration in the future. Probably will be pretty similar.
00:33:14.795 - 00:33:45.045, Speaker C: So yeah, I think it's like useful to mature this because we have to eventually do a conversion. So I think is useful to make progress on this and really solidify if this is the right strategy or we have to include something else. That's it.
00:33:54.105 - 00:34:08.805, Speaker A: Cool. Anything else? Oh, there's a question from Gary in the chat. Just confirming that there's no other changes, just the gas witness cost. I think that's right. Guillaume, maybe you can confirm.
00:34:09.425 - 00:34:41.155, Speaker B: Yeah, sorry, I need to remember. I mean it's mostly that and bug fixes. We have a list in our repo that we tagged every PR that is connected. Yeah, it's a. It's a fixed. So the only major difference are the costs. Indeed we add the parent state route in the execution witness so that stateless clients don't need to download two blocks to run to execute the second block.
00:34:41.155 - 00:35:24.241, Speaker B: And we also used 2935 that was agreed on in Pictra. So the difference is that instead of add block activation, inserting everything into the contract, we just insert the last block and that's it. It should make a difference for that testnet because we start at Genesis but the behavior is a bit different. So just be aware of that and. Yeah, that's pretty much it. Oh, right. So there's.
00:35:24.241 - 00:36:13.055, Speaker B: It's a bug fix. But I can share the issue in the. In the chat the major difference is where we charge the witness gas cost because there are two cases where 1 64th of the gas is subtracted. One of them is in create and the other one is in call and they don't happen at the same time. Meaning in. I'm trying to remember, but it's explained in the issue I just shared for call. I think they are charged before executing the contract, whereas for contract creation they are charged as part of contract execution.
00:36:13.055 - 00:36:26.185, Speaker B: There's a bit of a finicky thing like this I don't quite remember, but yeah, if it's not clear from the issue I just shared, we will. Yeah, we'll discuss about it and we'll make sure we all agree.
00:36:33.645 - 00:36:41.985, Speaker A: Okay, cool. If nothing else, we can end the call there. Thanks everybody. Talk to you soon.
00:36:42.435 - 00:36:43.107, Speaker B: Thanks.
00:36:43.251 - 00:36:45.175, Speaker A: When do we Want to launch Net7?
00:36:46.715 - 00:36:48.615, Speaker B: Not before end of August.
00:36:50.835 - 00:36:54.855, Speaker A: Okay. Spencer, did you have something?
00:36:55.155 - 00:37:15.055, Speaker E: Yeah, just a small thing. While I remember, would it be okay for us to change the fork name from frag to a different name? Maybe we want to do this after Devnet 7 but. And just from our side. And there's some workarounds because we have the practice as well, within our framework.
00:37:16.435 - 00:37:37.477, Speaker B: Yeah, it's a bit of a pain, I agree. Yeah. We can change them. We can change them. It's not a big deal. Yeah, let's do that. Change what? In fact, we should do that in Kurtosis, too.
00:37:37.477 - 00:38:06.439, Speaker B: Currently, everything is activated on Prague. When you set a fork activation time, you say override Prague time. Because when this branch that we use was created, Verkal was supposed to be in Prague. Now it's Osaka. Yeah. Now we want. I mean, in Guest Master, it's already known as Verko and not Prague.
00:38:06.439 - 00:38:19.115, Speaker B: But in that branch it remained as Prague. I think everybody was okay. I don't know. I get the impression that every other client was doing the same. But it should not be known as Prague. It shouldn't be known as Vertical time.
00:38:31.785 - 00:38:32.601, Speaker A: All right.
00:38:32.753 - 00:38:40.365, Speaker B: And I just want to point out that Perry was the one insisting that it should be called Prague, and now he's the one insisting it should be called vertical.
00:38:45.705 - 00:38:46.057, Speaker E: Yeah.
00:38:46.081 - 00:38:53.215, Speaker B: Yeah. All right. Enough. Yeah. Any other question?
00:38:59.275 - 00:39:03.775, Speaker A: Well, all right, that's it then. See you all soon.
00:39:04.195 - 00:39:05.099, Speaker B: Take care.
00:39:05.267 - 00:39:05.875, Speaker A: All right, bye.
00:39:05.915 - 00:39:06.923, Speaker B: Thanks, bye.
