00:00:00.600 - 00:00:29.467, Speaker A: Like to welcome everyone to EOF implementer call number 55 on the 7th of August 2024. A lot of agenda items relating to testing. We'll get there when we get there. One is a spec question, but the rest is mostly testing. But we'll go ahead and start with client updates. Besu implemented Fuzzer over the past few weeks. It was guided by Java coverage and it's differential against the others.
00:00:29.467 - 00:00:51.145, Speaker A: And I've had good overnight runs with EVM1 and RET with no findings between the three of us. And I found some items in geth and JavaScript. So that's some of the stuff that basically has found in their development. Next is EVM1 I think no updates.
00:00:51.276 - 00:01:18.235, Speaker B: On the implementation of EVM1. We are. We're kind of done. But also maybe others can share some on fuzzing as well. And the rest of the team is also involved in testing. Pavel, can you share on the housing part? We cannot hear you. At least I cannot.
00:01:20.015 - 00:01:22.109, Speaker A: Yeah, your microphone's not coming through, Pal.
00:01:22.287 - 00:01:25.685, Speaker B: You know, it's like just noises, clicks.
00:01:29.185 - 00:01:32.925, Speaker A: How about we go to rest and wait for Powell to fix his microphone?
00:01:37.505 - 00:02:09.175, Speaker C: Red side. Pavel found with his fuzzy some bugs that on verification that was fixed and there were some unimplemented things there. That's mostly it. I still need to need to figure out that metrics and update the tests. I don't think I'm running east tests so I need to check that later today, maybe tomorrow.
00:02:09.715 - 00:02:17.233, Speaker A: Okay. Do you run your tests by dropping the fixtures in a directory and running it the main way you run it or you have a tool that you.
00:02:17.249 - 00:02:29.725, Speaker C: Can point to the file I'm pointing it to folder. Basically. I basically downloaded Mario Bundle of tests and I'm running those.
00:02:30.705 - 00:02:48.415, Speaker A: Okay. Because I have some automation for the ones that will run it from a CLI tool. But I haven't updated much of my automation. It wasn't very. Wasn't very expensive. Any luck on Peter's audio situation?
00:02:50.555 - 00:03:00.135, Speaker B: Pavel's right. You meant Pavel, correct?
00:03:01.195 - 00:03:06.219, Speaker A: Yeah, Paul, not Peter. Wasn't he the one that was going to talk about. Oh, he's.
00:03:06.267 - 00:03:12.851, Speaker B: Yeah, yeah, yeah, yeah. Exactly. So I don't know. You're on mute. Pavo, in case you. Is it on the good.
00:03:12.923 - 00:03:16.535, Speaker A: Yeah, now. Perfect. Great. You're going to talk about EVM1 fuzzing?
00:03:16.995 - 00:03:17.815, Speaker D: Yes.
00:03:21.315 - 00:03:22.695, Speaker B: It'S broken again.
00:03:24.955 - 00:03:34.735, Speaker A: Such bad luck. So is the fuzzing that the EVM1 runs, is that checked into any directory anywhere that people can run?
00:03:40.755 - 00:03:41.775, Speaker B: I don't know.
00:03:43.075 - 00:03:56.187, Speaker A: Okay. Pal's Microphone is still very unhappy. We need Mike Dow. We need a. We need microphone Guild, I guess.
00:03:56.331 - 00:03:59.575, Speaker B: Oh he. He wrote in chat. Oh actually.
00:04:01.125 - 00:04:03.425, Speaker A: Okay. So there's the fuzzers that he runs.
00:04:04.285 - 00:04:06.425, Speaker C: It is on EOF branch.
00:04:09.485 - 00:04:10.285, Speaker B: Yeah.
00:04:10.445 - 00:04:12.945, Speaker A: And this is just for the EOF validation, right?
00:04:14.085 - 00:04:14.865, Speaker C: Correct.
00:04:17.045 - 00:04:31.065, Speaker A: Ok. Because we got EF Validate which is the newest. This is probably. We'll save this for testing. Actually. I don't see Geth on the call. I don't see nethermind on the call.
00:04:31.065 - 00:04:59.255, Speaker A: I don't see Ethereum JS on the call. Ethereum JS do have a couple of findings from the Java fuzzer but they don't seem like, you know, they seem like the findings that other clients have had. So they're nothing out of the ordinary. Nothing truly bizarre. Geth has more findings. I've fix some in a PR that I'm going to push to Marius when he's back from vacation. He's out on vacation this week.
00:04:59.255 - 00:05:07.915, Speaker A: But I haven't fixed all of them. I've been building other things. Powell, do you think you got your mic fixed now?
00:05:14.295 - 00:05:20.075, Speaker D: I can try this. Is this one working?
00:05:20.465 - 00:05:22.525, Speaker A: This one is working, yeah.
00:05:22.945 - 00:05:33.449, Speaker D: Hopefully when I close the settings on zoom it will still work. Okay. Can you hear me?
00:05:33.617 - 00:05:37.593, Speaker A: Yeah. Yeah. So tell us. Tell us about the EVM1 fuzzer.
00:05:37.769 - 00:06:52.883, Speaker D: Yes. So it's similar to Bessel except the coverage is taken from EVM1 Revm and Beso is integrated on the side. So we don't have coverage but we can ask it for validation. So I think I can confirm Bessel Revm and EVM1 are in sync in this and I need to update the mutator for the fuzzing because it's pretty bad and. Yeah, and I think that's the story so far about integrating others. I think we can do go code with coverage and the others probably without coverage. But I think I will put the baseline that the other projects needs to pass the existing tests so at least have confirmation they are there.
00:06:52.883 - 00:06:58.735, Speaker D: Because I think we know that the gaff code is not great.
00:07:02.835 - 00:07:03.615, Speaker A: Yeah.
00:07:04.525 - 00:07:35.783, Speaker D: So I'm not sure this really benefits. Yeah. But that definitely can be done. Also there's option to export all these kind of generated tests into JSON. Not sure this is worth doing this but that can be also kind of the one more gates to cross to be included. But I plan to include everything and.
00:07:35.799 - 00:08:10.795, Speaker A: I honestly think any good fuzzing find probably indicates a testing blind spot and it's usually the. The combinations you don't think of like Tripping the reverse jump and the forward jump with two are jumpies, two conditional jumps in between. That's, that's one thing that got BASIC and helped us find what implementation thing that we weren't doing correctly. But yeah, I think any, any good fuzzing find usually should be followed on with something added to the reference tests because if one client coded it wrong, the odds are other clients or future clients will make the same mistake.
00:08:12.895 - 00:08:42.195, Speaker D: Yeah, there's also this list of issues found so far. So it's kind of work in progress. So so far we are collecting this as the someone remember the link. It's. It's on Ypsilon EOF actually. So they need to be processed later and submitted to execution spec tests.
00:08:44.055 - 00:09:12.935, Speaker A: Yeah, so this is. Yeah, good, good fuzzing findings are being found here. So let's see compiler updates, spec updates. Let's do some of this fuzzing stuff first before we go too deep while we're on it. So if we find fuzzy stuff we should post it here. But that also gets to some of the standards. I don't know the phrase, the way to phrase it, but when we find bugs in pre production code it's generally fine.
00:09:12.935 - 00:09:55.197, Speaker A: Secure security. There's a security aspect for it. Pre production code we can post it here. But if we find a bug in production code we should probably have a narrower disclosure for operational security. So if you find a bug that is live in Geth or Besu or nethermind or EVM one that could be used on older versions of the code, that some of the stuff might show up as we do the fuzzing, we need to have a narrower scope and I think there is a key based disclosure or we can disclose it privately. But when we're talking about code that we haven't shipped to main. Net and that's a new feature, I don't think we have the same risk of just disclosing all the bugs that we find.
00:09:55.197 - 00:10:21.143, Speaker A: So eventually this, this will shift. We will need to have more limited disclosure on some of these. But for now we can just disclose freely anything that is an E EOS specific bug. And so that's what these will be filling up. Okay, so I think that's all the client seems. Go ahead.
00:10:21.239 - 00:11:10.635, Speaker D: There's one more thing about fuzzing. So this is the issue that I'm hitting probably with every project is that my expectation is that we, we kind of validate in runtime mode. I think that comes from the fact the runtime containers are simpler and that's also how the validation tests are organized to my understanding. But I think it's maybe that's actually the bad decision to do it this way because that's actually not something we'll have in the client because the client will always validate in code. Because that's. Because we only validate the EOF transactions. Right.
00:11:10.635 - 00:11:15.775, Speaker D: So we always kind of validate top level starting from INIT code.
00:11:17.955 - 00:11:25.763, Speaker A: We also need to validate Genesis files. So if you get a Genesis file with an existing EOF contract, we need to validate and parse that as well. I believe.
00:11:25.819 - 00:11:54.101, Speaker D: Yes, it's true but maybe for fuzzing it's actually better to switch to INIT code. I'm not sure if to have opinion so far that's fixed but I had to kind of. Yeah. Kind of work around it a bit for both peso and revm and we kind of hitting some. A bit more complicated entry point for that. So I'm not sure that's a good idea. But yeah.
00:11:54.101 - 00:12:42.875, Speaker D: So I don't know if you have any suggestions. I was thinking maybe there's also a way to actually combine these two somehow. Let's say you pass an input for validation and you get. Instead of specifying what the type is, you get this as the answer and then you can compare if they agree or it's not like exactly how EVM is implemented, but EVM1 is implemented. But yeah, I have this issue probably I will not do any actively try to change it, but I wanted to mention that and if you have strong opinions that we should actually change the validation mode by default for fuzzing, I can also do this.
00:12:44.135 - 00:13:22.427, Speaker A: You should probably fuzz both input mode and non input mode, non naked mode. But that creates more. It creates difficulties in fuzzing because there's a lot more different ways that you can be invalid with INIT code and bring everyone into INIT code failure. So that's. Yeah, that's. That's something we'll need to think about over the week. I can add a flag to basis code, validate to expect INIT code and I can do some runs where we start from INIT code.
00:13:22.427 - 00:13:29.895, Speaker A: Getting the seed, getting. Getting initial corpus for INIT codes is going to be what's difficult. But that should be fine. We should be able to figure that out.
00:13:32.395 - 00:14:27.115, Speaker D: Yeah, there's at least a flag in the JSON test that specifies this and this runtime by default. But you can specify also for bessel. I kind of fix that by just. Yeah, just adding some neural to Java. But I think that's done. So it's not something I need directly right now, but it's kind of repeating pattern that when I try to find the entry point for validation in other projects it's a bit difficult to specify it sometimes and I kind of want to make sure that we f something that is then directly used in a like bigger client implementation, not something that is kind of internal API to something that it's not used.
00:14:28.815 - 00:14:32.475, Speaker A: So like a transaction fuzzer, we want to spam the transactions. Mario?
00:14:34.295 - 00:15:15.125, Speaker E: Yeah, this is unrelated to fuzzing, but I wanted to mention that we also need to generate status for the container runtime validation test that we have. Basically just wrapping the runtime container into an INIT code and then use that as the transaction counter creation data. Just want to mention that we don't want to miss this coverage because yeah, as you say, most of the container validation in an actual chain is going to happen during INIT code. So yeah, I think we should do. We should do. This is in my to do list. I just haven't gotten the time to do it yet.
00:15:15.665 - 00:15:40.115, Speaker A: Okay, cool. So let's table testing for now. Come back to it further down the discussion. Do compiler inspect updates? I don't see any compiler people online. There's no updates to the Solidity PLC I take it.
00:15:42.695 - 00:15:50.475, Speaker B: I know Radix working on it from Epsilon, there's some progress but he's not here.
00:15:51.135 - 00:15:51.955, Speaker A: Okay.
00:15:52.375 - 00:16:59.605, Speaker D: I think the situation for Solidity is that the implementation has been kind of submitted as a pre request and this under review and yeah, so that's the main, main thing. There are some optimizations that are probably a lot of optimization that has been disabled because uf. So they also work on a way to re enable some optimizations that had to be disabled because they're not like directly compatible with UF. And I think and finally we want to make EVM1 release and EVMC release so that Solidity can update this dependency that they use for testing and then that will be like separate work that we also want to. We kind of need to put in between the EOF is merge. But yeah, I think that the end goal is to actually merge this code to the. To the main branch.
00:17:00.665 - 00:18:44.415, Speaker A: Okay. Okay, so I think next we have spec and there's a couple of things. First we need to figure out contract detection and then I think I had on there some tracing changes. So first contract detection. Alex isn't here yet but he did post some stuff to Discord. Basically we got you know, six options to go around it and there doesn't seem to be much excitement around some of the more larger changes like multiple return codes, multiple return items on the stack, features like this. And really what a lot of the interest is around either A completely punting for the first release of EOF and coming back later, or B using reintroducing EXT code size or C changing EXT code size in something like E is contract.
00:18:44.415 - 00:18:58.675, Speaker A: Yeah. Any. Any comments on. On the state of that. Do we want to fix on the design or. Honestly, a lot of the speed we're going the, the do nothing inertia is getting a lot of weight behind it.
00:19:05.175 - 00:19:12.805, Speaker B: Well, the do nothing has the. As the big advantage that we can fix forward fix it.
00:19:13.665 - 00:19:33.641, Speaker A: Right, Right. We can fix it with a compatible change in the hard fork after eof. We can do a better time evaluating these options, prototyping them, seeing how they would work. Because if we bring any of the other fixes in, we have to live with them forever. Even if they're the right fix, that would be fine. But if you bring in the wrong fix, then it's. It's, it's a change.
00:19:33.641 - 00:20:05.895, Speaker A: It can't be undone. The not supporting 721 and 1155 contracts on the first pass is the most undoable of the options. And it's also got the potential of being the correct option if account abstraction really gains traction. But that would basically preclude EOAs from holding some 721 and 1155 contracts. But you know, that might be acceptable if AA is really going to take off.
00:20:07.995 - 00:20:35.225, Speaker B: I mean, to comment on that. 721 and 1155. Right. They can still. I mean, we're not making them impossible. We're just either they need to be written in legacy EVM and deployed as such, or they need to call out into a legacy contract which does the EXT code size or whatever they need for them. But it's.
00:20:35.225 - 00:20:49.985, Speaker B: It's still possible they just need to pay, I don't know, extra. Right. Or am I wrong on this?
00:21:00.735 - 00:21:05.755, Speaker A: Hello? Hello. Writing this down again.
00:21:06.055 - 00:21:07.871, Speaker B: You're writing it down. Okay.
00:21:08.063 - 00:21:08.835, Speaker A: Yeah.
00:21:11.135 - 00:21:19.955, Speaker B: Oh yeah. That's the third option. Right. They can somehow not use the safe trans transfer from.
00:21:21.455 - 00:21:22.195, Speaker A: Right.
00:21:22.615 - 00:21:42.925, Speaker B: But I guess when we are sticking to principles, then I mean either a contract satisfies the interface, the standard, or not.
00:21:47.265 - 00:23:01.345, Speaker A: All the calls will just fail. I mean, yeah, I mean the interface 721 has got a lot of optional calls, but all the major markets require safe transfer from if you want to make your NFT marketable. So it's Practically a requirement we can't do. If we don't do the return code changes now, we can't do them in the future. But ASIC and Discord said that the UNIX standard is zero means success and anything non zero means failure and there's really no distinguishment between success types. So we would move contract we would move transferring money to an EOA into a failure mode if we did that from the standard. But I think the return code changes are what had a lot of resistance.
00:23:01.345 - 00:23:59.135, Speaker A: I do think we should probably just stick with the do nothing for now since it's something we can fix later with the lead of the others I think is contract or exc code size was something we could bring back into the future. So I'm fairly comfortable just sticking with the spec we have unless there's any call for action on that. Now whether that's going to be in Osaka or Amsterdam remains to be seen. If you called in all core devs a couple weeks ago or last week there's some concern about post quantum cryptography and Verkel. So that might be shaking up the schedule. So anything in the future there is no promise it'll ever show up and there's also no promise that it won't show up. So it's just an unknown there.
00:23:59.135 - 00:24:11.825, Speaker A: Okay, moving on from so contract detection I think the soft answer is.
00:24:24.005 - 00:24:25.105, Speaker B: Sounds funny.
00:24:27.005 - 00:25:08.039, Speaker A: Okay, so the next thing I want to talk about is tracing changes and this is going to become kind of an issue when we go into execution fuzzing. There's a couple of features that we're adding in EOF that aren't. This is the eip. What is the. There's a standard tracing API that most clients follow. 3155 and this specifies most. Most clients spit code out like this.
00:25:08.039 - 00:25:44.835, Speaker A: This is what a standard trace looks like and this is what a lot of the the trait the fuzz the fuzzers fuzz off of. But we're adding a couple of features that I think we need to consider updating. So right now it's actually stagnant. It's not final. Probably if I do a change of this I'll change this to a living instead of a draft. But there's a couple of fields that I think we need to consider adding to this trace. We're going to need code section and I think we're also going to need the immediate arguments because I also know that tracing some ZK systems they arithmetize the trace.
00:25:44.835 - 00:26:10.745, Speaker A: They don't actually run the evm. Someone Else runs the EVM produces a trace and they arithmetize the trace and prove that it's consistent. So they'll need this information to do ZK out of if they continue to do tracing as their solution, they'll need this information to figure out, you know, what. Not a push, but like, you know the call F what sections you were going with? Call F. Pooja, you raised a hand.
00:26:12.255 - 00:26:25.555, Speaker F: Yes. Can you please repeat the EAP number? And is it actually being used by the client? I don't like that it is an Instagram status. I might want to check with the authors and push it towards, you know, whatever active status it should be.
00:26:26.415 - 00:27:04.695, Speaker A: So it's 3155 and I think the reason it got swept into stagnant is because it's not final. All of the clients have updated it and to various degrees and we have this and it's just, I bet, you know, Martin and Marius just, you know, they're not very attentive to process things on this. So they didn't push it to final. But it is not, it's not consensus critical I think is one aspect for it. You can have a consensus client or execution client that doesn't have this. This is just a tool that is being used for standardizing testing.
00:27:06.325 - 00:27:15.065, Speaker F: Sure. I would try to get in touch with Martin and Marius and try to move this proposal out of stagnant if it is being used by most of the clients.
00:27:16.005 - 00:27:19.985, Speaker A: Right. What status would you recommend? Would living be appropriate for this?
00:27:21.845 - 00:27:34.345, Speaker F: I think that would depend upon EAP editors. Given any of the interface proposals are never been in living status, I highly doubt that is possible. But moving to a final status can be very much possible.
00:27:35.315 - 00:28:02.227, Speaker A: Okay. Because the problem that I have with final status is the changes we're discussing now where there's a new feature where we need to update it. All of a sudden we're going to have to have a new EIP number for the tracing standard for something that's basically the same. And I think this is like the poster child for virgin EIPs. It is tracing. But then the EIP editors are going to impose their will and say, I'm going to go on a rant I should stop about. I really don't like the way the EIP editors govern this.
00:28:02.227 - 00:28:04.775, Speaker A: So I'll just stop there.
00:28:05.955 - 00:28:44.265, Speaker F: No worries. I mean like the general solution right here is like, if you think that after it being final, we might want to add one of the EIPs to the list, there could be a new EIP with the required section as 3155 and this true line of change would be there and that can move faster because this has already been here. I see the number 3 1. That means it is pretty old proposal and I can understand get teams sometimes need some support to move the proposals to different status. But I hope going forward there should not be a challenge moving proposals. Please reach out to me, ping me or even join the editing office hour. We will push the proposal as soon as possible.
00:28:44.805 - 00:28:50.785, Speaker A: So what's your recommendation? Should I add the EOF stuff here or should I just do a new EIP for EOF tracing?
00:28:51.485 - 00:29:27.035, Speaker F: It would be a good idea to have a new proposal because I would want to see UF moving with the pectoral upgrade. I don't know how much time would this proposal take to, you know, move into the following directions? I mean like the next status. There are two ways to go about it. Either the initial authors have to open a new pull request. I can make sure that they get merged as soon as possible. But if either of these authors are not open to the idea, we might want to add someone as a co author. You can be added as a co author or champion for the proposal and then when you create a pull request, we will move it forward.
00:29:27.695 - 00:29:31.915, Speaker A: Yeah. The thing is, I'm fairly certain Martin and Mary's have given up on eips.
00:29:32.615 - 00:29:46.615, Speaker F: Oh. If you would want to propose yourself as a champion or co author of a proposal, the only requirement would be for them to approve you as a co author. And then from there you can take it forward and I'm happy to help push it to the next level.
00:29:46.655 - 00:30:18.055, Speaker A: Okay. Okay. So we'll move the, we'll move this process discussion elsewhere. But what I want to discuss is get people's temperature for temperature check for some of the changes I want to put into this into the EOF version, add an immediate that would post immediate. This would show up for pushes, call left. Anything that has an immediate add a section number and then.
00:30:20.155 - 00:30:20.659, Speaker C: PC.
00:30:20.707 - 00:30:38.775, Speaker A: Whether we do 0 from section or 0 from container, I want it. That's the biggest open question I have here is what people think about that. Andre and Dragon, do you have much opinions? Or Peter or Powell? I'm thinking PC should be relative because.
00:30:39.435 - 00:30:43.979, Speaker D: PC together with this section are uniquely identified location.
00:30:44.147 - 00:30:49.027, Speaker C: Otherwise it's a bit redundant. If PC is absolute, then section is.
00:30:49.051 - 00:30:49.811, Speaker B: Kind of not needed.
00:30:49.883 - 00:30:53.175, Speaker A: Yeah. Okay. Zero section. Okay.
00:30:55.395 - 00:31:42.525, Speaker D: It kind of depends like you want like efficiency or just readability because like the same what Andrew said kind of because the code sections are adjusted to each other kind of the PC started from section one kind of works for all of them. You just need to figure out which which section are you in outside of the trace. Right. Maybe that's I don't know then usually these traces are not really efficient in terms of the There's a lot of redundant information and sometimes it's kind of to actually have all of it.
00:31:44.945 - 00:33:06.375, Speaker A: So I guess that's that leads into my next question is some of the musts. So whenever I do my tracing and I test it out I actually only pick out the PC the gas cost the top item of the stack and the memory size when I do my diffing because those are the most reliable ones that are consistent across clients clients Some clients will do basically used to just do not the recalls they used to do the gas that did not include the stipend. Now we change that because Linnea needs it. But gas cost I've been seeing get spitting out two lines for the same opcode one static and one dynamic for gas costs which is going to cause buzzing issues and then yeah so what required fields so one of the things I want to do is make sure that we have gas costs have a specific meaning. It'd be the gas stipend Gas okay. Gas must be gas available to the operation. The PC inspection must be present and correct.
00:33:06.375 - 00:33:22.695, Speaker A: So the gas that's available to your call must always be that value. I think these are the two musts we must put in for tracing. Correct for using these for fuzzing. Any other people been using these traces and have Japanese on it.
00:33:26.995 - 00:33:31.259, Speaker D: Go EVM lab. Buzzing lab.
00:33:31.307 - 00:33:31.895, Speaker A: Yeah.
00:33:32.675 - 00:33:42.251, Speaker D: They also had issue with gas so I think from some of the products they just ignore it because it's not consistent across the yeah.
00:33:42.443 - 00:33:43.455, Speaker A: Gas cost.
00:33:45.435 - 00:34:58.005, Speaker D: Yeah. I don't know it's like always I I we've had a number of discussions about it what exact meaning is and it's like for EVMR for example it's not always practical to have the full gas cost and I mean it's doable. I plan to actually make it consistent and I plan to compare it with GAV mostly it can be any other project to find differences and then fix that the cores are kind of separate topic to that like what's it's like is the gas put to the caller is actually cost or not. I think we kind of on the position that it's not because gas cost is something that is kind of burned by the instruction so it's not available to anything else just gone But I'M not sure this is consistent with what the other project actually put there. And I think that's. We can step by step fix this and that, but it's kind of overwhelming process considering that goes to E or something.
00:35:00.065 - 00:35:00.885, Speaker A: Okay.
00:35:02.065 - 00:35:18.815, Speaker D: Yeah. So I don't know if you want the section. Section. I think I'm fine with that. It probably puts shorter names, but that's the only comment I have.
00:35:24.875 - 00:35:43.267, Speaker C: There was a request from GOVM Lab to have no memory and maybe even no stack. No memory for sure. Because repeating memory in the traces in JSON can be very performant. Very.
00:35:43.371 - 00:35:43.891, Speaker A: Yeah.
00:35:44.003 - 00:35:54.539, Speaker C: It would take a lot, lot, a lot of time. I'm not sure about no stack. No memories for sure, but no memory for sure.
00:35:54.587 - 00:35:58.135, Speaker A: That's. Yeah. I mean no stack. Maybe we could just have this top stack item.
00:35:59.045 - 00:36:15.985, Speaker D: Yeah, I was also like talking about it like if you only have the top stack item or even for. Only for the instructions to actually put new value on the stack, you can put one item and for the others actually you can skip it.
00:36:16.525 - 00:36:19.669, Speaker A: Yeah. You can derive the stack state from there. Yeah, you can.
00:36:19.717 - 00:37:06.925, Speaker D: Kind of only having a JSON, you can figure it out what's going on. So you can. So like for example, Go has this kind of debugging tool that you just take a trace and then you have the interface that you can pretend you're actually debugging existing program and you can step in, step out and like step over different instructions. Yeah. So I think I'm open to also because most. Maybe it's enough to just put like some number of top stock items or we can decide there's like a marker that says there's more stack items, but they are not just included in the JSON.
00:37:07.905 - 00:37:32.055, Speaker A: Okay, so I'll draw up a mock of this. We can discuss it online here in two weeks. Again, I think we need to move on from this for a time. We got a few other issues. Yeah. So to drop a comment in this thread, if you have anything else to add, let's go to testing. Mario, what's some of your testing? What's the top of your mind for testing?
00:37:34.515 - 00:38:13.945, Speaker E: Okay, so I think. Okay, can we go to the checklist that you posted? I think there's some interesting. Oh yeah, I. I can address cortosis first. So I think for time being cortosis, I wouldn't think that this is absolutely necessary. What we can do instead of cortosis is just using East's Consume Engine tool. Basically what this does is it relies on Hive, but Hive spawns the client and Basically we send every single test that we have using, using this thing via the Engine API.
00:38:13.945 - 00:39:20.307, Speaker E: There's not much difference between this and Kurtosis while the difference being that Kurtosis does spawn the consensus client to do this. But I think it's too much overhead for the spot that we currently are in. I don't think we're going to find any significant differences between Consume Engine and Kurtosis. The only thing that comes to mind that maybe Kurtosis could maybe point out is that for example, if we do call EOF calls to the, to the, to the system contracts that are being introduced in Prague. So for example the deposit contract or the, or what else? The withdrawal request contract, maybe if the call comes from an EOF contract, maybe there could be some interesting, some interesting things that could come up when Kurtosis spawns the consensus client. But I, I really don't think it's worth the effort of setting up kurtosis at the moment. So yeah, coming back to the, to the, to the Consume Engine.
00:39:20.307 - 00:40:08.105, Speaker E: I think Consume Engine does everything that we need so far and it's just a matter of running every single test that we have written for UF using Consume Engine Assertors. Also coming back to the, to, to. To the, to the, the point of the east test that we have. I think if we could write some EIP interactions between for example the deposits EIP and eof, which is really easy when we. Since with the markers that we included in. I'll link the PR in a moment. But anyway, I think the assertors, it's just free for us if we run the east tests in the devnets.
00:40:08.105 - 00:40:18.025, Speaker E: In the devnets as we have it. Yeah, exactly. East can produce assertors. Exactly.
00:40:21.165 - 00:40:26.695, Speaker A: Okay, cool. Any testing blind spots you're worried about?
00:40:26.815 - 00:41:31.693, Speaker E: So yeah, basically I think we should update the checklist and the main reason is that I think a lot of the tests, if not all of them, are currently implemented in east. But mainly what I would like for us to have ready for next ACDE is just the. Is just quantify the progress. So what percentage of the checklist that we have is currently implemented, which I think could be close to 100%. And most importantly I would like to go over the eips and just make sure that every single test case is actually in the checklist to begin with. I haven't got enough time yet to do this, but I will try to do this in this week before acds so we can have an updated checklist and also missing test cases from the checklist also and just basically come up with a Percentage of readiness regarding spec tests. Yeah.
00:41:31.693 - 00:41:32.385, Speaker E: Yeah.
00:41:35.325 - 00:41:51.745, Speaker A: Okay, cool. So how do we feel about. I know Tim was pushing this. Do we think we're Ready to add EOF to TestNet 3 the next test net?
00:41:55.045 - 00:41:57.105, Speaker E: Is that a question for me or for everyone?
00:41:57.605 - 00:42:01.065, Speaker A: For you or for everyone? You could start and everyone could chime in.
00:42:02.325 - 00:42:04.789, Speaker B: I think I can say okay, yeah.
00:42:04.877 - 00:42:22.995, Speaker E: I think I'll have a better opinion once I go through the checklist and the, and in the, in the rest of the aps more thoroughly. Maybe in the next couple of days I will. But listen, anyone else can chime in.
00:42:23.775 - 00:42:26.791, Speaker A: Okay. I think Peter was going to talk. Yeah.
00:42:26.823 - 00:43:11.075, Speaker B: So recently we put out a PR to add a sort of testing matrix which is clients versus different kinds of tests that we have now mainly to you know, make. To make sure that given clients are passing the tests that we have before we proceed into fuzzing. But this also applies to Devlins. I guess this should be like I guess the. Maybe the most basic checklist that we can take off right now. So in there we want to. Want to gather information whether given client passes a given version of test that we have right now.
00:43:14.095 - 00:43:19.355, Speaker A: Do we need to be 100% before we go to a devnet? I mean what's, what's the advantages and disadvantages?
00:43:21.575 - 00:43:45.755, Speaker B: I don't know. I mean for fuzzing it makes at least, you know, the sense is that we don't pick on. We don't find issues that are covered already but not used. I mean, sorry, so the filing doesn't pick up issues that are covered by tests but the client doesn't run those tests.
00:43:46.935 - 00:43:47.675, Speaker A: Right.
00:43:49.295 - 00:44:16.885, Speaker D: I think it doesn't make sense for a client to join a devnet if it doesn't pass the tests, don't even run it. So that this kind of. But I will show how much does it matter, right? Because it's not like every client has to join at the same time. But maybe we should make it clear that's kind of prerequisites for joining Devlet is to pass the test first.
00:44:18.705 - 00:44:36.725, Speaker B: I would say it's not only the east test but also the Ethereum tests where some of the coverages right now and I mean as an extra is deviant one tests which slowly re migrated over to east but still not there.
00:44:37.945 - 00:45:13.913, Speaker E: So I think, I think it's important to have at least most of the tests in east. If there's any outstanding tests that are important that are only in Ethereum tests, those we cannot run them with Consume engine. And I think it's important that we run with Consume engine. So if you guys can think about any test scenarios that are missing from east that need to be ported to Ethereum test, I think I would like for us to make the push to port them over.
00:45:14.089 - 00:45:30.155, Speaker D: Yeah, that's definitely our goal but I think it's. We are moving a bit slowly towards this. So yeah, definitely there's this even big. There's even like EAPs, like full EAPs that are not covered yet.
00:45:31.495 - 00:45:52.385, Speaker C: Well, definitely it's maybe best to focus on AIP 7702 because there are additional changes that needs to be implemented. I would not like to get in situation where UF is blocking other IPs but I don't know if other clients start started implementing it.
00:45:53.965 - 00:46:35.753, Speaker A: So Another thing I've noticing is 7702 is very much going with the test and prod approach because only Mario's written reference tests for it. None of the other 7,702 implementers have gone for it. Again holding us for different standard but you know, we'll run with it. But I think that's a valid point. We don't want to cause 7702 problems but at some point we need to get into Devnet and we need to join it. So maybe we could present that, you know we'll join when 7702 is stable. One question, which clients are ready to that have a flag and could join a test net today? Bret Rett and Basu.
00:46:35.753 - 00:47:23.905, Speaker A: Okay, so I mean we get two. That's. That's really what we need to run a DevNet. Okay, how about Aragon 3? How close are they to participating in tests like this?
00:47:30.375 - 00:47:34.295, Speaker D: I think it's unclear if they will. So.
00:47:34.335 - 00:47:34.735, Speaker A: Okay.
00:47:34.815 - 00:48:03.070, Speaker D: It's still unclear if Ergon 3 will be ready for picture. So I think they are discussing if they are able to switch to Aragon 3 architecture for picture. So kind of replacing or even 2 or not. But I think the main picture work is done still in arrogant 2 which is stable instead of these. Yeah.
00:48:03.174 - 00:48:06.265, Speaker A: Is aragon 2 part of these devnets right now?
00:48:08.245 - 00:48:09.225, Speaker D: I don't know.
00:48:09.765 - 00:48:17.585, Speaker E: Okay, but didn't they have a lot of issues on devnet too? They were not following if I recall correctly.
00:48:18.085 - 00:48:18.905, Speaker A: Okay.
00:48:21.775 - 00:48:24.675, Speaker D: But at least they are trying. Right?
00:48:26.215 - 00:48:26.955, Speaker A: Right.
00:48:27.735 - 00:48:43.115, Speaker D: Okay. So yeah, I think like it's probably unless this will change. I think the Oregon 2 is the client that we are expecting to be in devnets.
00:48:53.065 - 00:49:52.757, Speaker A: Any other general commentary or questions about where we're at? Any other anything anyone else wants to say or any directions? They think we're missing. Okay, August is here, people will be on vacation, but I'm fairly certain September will be kind of a crunch time to make sure we can get into the dev nets and be ready for the discussions of when they start getting seriously talking about flipping test nets is when they're going to have to deeper cut certain features. So that's going to be kind of a crunch time for us. So we'll need to have everything ready. I'm probably gonna work on the tracing spec and then I'm going to work on trying to write a execution fuzzer. So hopefully we'll have better signal there. But if anybody else has experience writing EVM fuzzers or could, you know, modify Mariuses to work with eof, that would be some.
00:49:52.757 - 00:50:08.703, Speaker A: Some good stuff to do. Any other comments? Cool. I'd like to thank everyone for calling in. Just go ahead.
00:50:08.799 - 00:50:18.995, Speaker C: Last thing we should ask, get another mine on ACD about ToF progress because they're not like appearing here and.
00:50:20.415 - 00:50:20.751, Speaker A: Right.
00:50:20.783 - 00:50:22.755, Speaker C: It would be good to know where they are.
00:50:24.095 - 00:50:48.345, Speaker A: Yeah, I know, I know. Marius is on vacation. I'm a bit surprised another mine didn't show up. I was expecting them to show up, but yeah, we should pressure them for status and. Yeah, yeah, make it. I mean, they're going to complain that it's not being thoroughly tested, but you know, it is being tested. You know, we need to make sure that if it's not progressing, it's clear why it's not progressing, what it is, so.
00:50:48.345 - 00:50:55.305, Speaker A: All right, maybe I'll ping them. We should ping them also on Discord. Cool.
00:50:56.655 - 00:50:57.395, Speaker C: Great.
00:50:58.775 - 00:51:04.095, Speaker A: Well, if there's nothing else, give everyone three whole minutes back. Thanks for calling in.
