00:00:02.600 - 00:01:07.335, Speaker A: Okay, so let me quickly tell you what it is and then we can just discuss offline. So there are two issues. One is an implementation detail. It unnoticed that if you're a validator, you call just to propose a block, say, and you need to propose next block, and then it just so happened that the current slot, your head is the empty node, then you're kind of screwed because the beacon state for the beacon block, I mean the beacon block was imported, you deducted the withdrawals, and you cannot obtain those withdrawals anymore because on the state we record only the root of the withdrawals and the beacon state has already changed. So the withdrawals might be different. So either the implementations need to cache the withdrawals or we need to make it part of consensus. And then instead of keeping the roots, we keep all of the withdrawals that we executed last time.
00:01:07.335 - 00:02:04.297, Speaker A: So both are solutions. I'm not sure if we should make it, if we should leave it as an implementation detail and everyone should cache it, or if we put them in the state and then we have them available there, so we avoid like caching problems. So it's an issue of like having either implementation bugs or having, or having consensus bugs. So I kind of believe that implementation bugs is probably better, but I'm not sure that's the one thing. And yeah, so I'm not sure what's the people are going to prefer, but that's one thing to think, and I am not changing it for the time being. I'm only going to change to use Francesco's algorithm in the next few weeks. So there's no urgency on this.
00:02:04.297 - 00:03:16.905, Speaker A: But this is something to think about, because I believe Prism, for example, is broken. Prism doesn't do either now. So if we have an empty block with withdrawals going to be kind of screwed in the next lot, then what else? The issue with the staking pools. So if we allow any validator to be a builder, then that's going to break like the CSM for Lido, for example, because I would just deposit 1 ETH and then withdraw 32 by just sending all of my, my validator to another validator of my own. So of course there's an easy solution, which is just add a new withdrawal prefix and then staking pools will not allow those validators to be builders. But the problem with this is that now we no longer can have builders that are just normal validators. I was hoping to get like normal validators being sending P2P bits, but now we're going to have to have these special builders to be sending these P2P bits and that's centralizing.
00:03:16.905 - 00:04:16.305, Speaker A: So I've been talking to people in LIDO to see if they can come up with a scheme to allow CSM validators to be builders. I think I have an idea to solve this, but it would require more thinking. They are on board and they want to help on this, which is very good because in that case we will have a very decentralized way of having builders that can actually build with one E in a decentralized and trustless manner, which is something that they cannot do today. Today they need to be blacklisted by the relay. So the idea would be that we put a limit. So one way, for example, could be that either the withdrawal credential decides, the withdrawal credential decides what is the maximum bid that the builder can actually bid for. That's not so bad.
00:04:16.305 - 00:05:17.757, Speaker A: We could handle that situation. We could handle it by having a new request, for example on the el signed by the withdrawal credential. And then we keep on the validator structure we add something that says, I mean for these new validators that have this new withdrawal prefix, we add this condition of like how, how much is the maximum bid that it's allowed? I'm not so keen with this because I'm not happy with changing the validator structure. And also like having something that you need to cache on every validator is complicated, but perhaps it's not so hard. The other solution that I think it might be better is if we don't, if we only allow to bid for the excess balance. So in that situation, since anyways we're gonna have to have these special validators that are like this builder validator, we can make those validators to be by default maxcb. And then in that case LIDO would allow validators to like say deposit one bond for one eth.
00:05:17.757 - 00:06:09.261, Speaker A: They will deposit 33 eth. They are not partially withdrawn because they're max CB validators. And then they are only allowed to bid for up to 1e because that's the excess balance. I think this works. This requires that the pools will periodically need to send partial withdrawal requests because otherwise they're going to be accumulating the earnings and eventually the builder can steal them. But I think this is a good compromise and LIDO would, would allow it. But anyway, so those are the topics that I wanted to mention that I'm thinking about how to deal with the fact that it seems unavoidable that we need to add a new prefix for builders and that's it.
00:06:09.261 - 00:06:12.345, Speaker A: That's all that I have on my end.
00:06:13.925 - 00:06:29.365, Speaker B: For the withdrawal thing, I realized we did not update the EPBS validators back to mentioned that for the payload attribute we need to somehow get a withdrawal. So that part is missing. I just realized that.
00:06:29.525 - 00:06:32.309, Speaker A: Yeah, we're not even doing it in our proof of concept.
00:06:32.357 - 00:06:35.517, Speaker B: Right, Right. But that's also not in a spec either.
00:06:35.701 - 00:06:39.585, Speaker A: Yeah, but that's irrelevant. I think we shouldn't be in the spec.
00:06:40.845 - 00:06:50.327, Speaker B: But for the capella, it's actually in the spec. Right, in the capella. Well, in the compiler validated spec.
00:06:50.431 - 00:06:54.675, Speaker A: Yeah, but that's. There's no change. You only put in the spec the things that you're changing.
00:06:56.735 - 00:06:59.115, Speaker B: It's true. That's right. Yeah, you're right.
00:07:06.615 - 00:07:22.485, Speaker A: I mean, we can add a comment that the expected withdrawals are the ones that are either in the state, if we keep them in the state, or you need to cash them. But I'm not sure what's better. I mean, I don't know if people have an opinion on this.
00:07:23.745 - 00:07:40.201, Speaker B: I think it's fine. I don't think we need to do anything because in the spec it says that just co get expatriate, withdraw the helper you pass in your state and then you get a withdrawal. So that should still work for Epps, right?
00:07:40.273 - 00:07:48.155, Speaker A: No, it doesn't. That's the thing. If you're building on top of an empty block, if you do that, you're sending the wrong withdrawals.
00:07:49.295 - 00:07:53.415, Speaker B: Yeah, no, that's right. That's right. Okay then.
00:07:53.455 - 00:08:03.335, Speaker A: So I think Prism is. Our proof of concept is broken in that sense. It's just that since we never had withdrawals, then that's never gonna be a problem.
00:08:03.495 - 00:08:09.555, Speaker B: Yeah, I think the spec does need to mention that part because that part is changed, right?
00:08:09.635 - 00:08:15.775, Speaker A: Yeah. Yeah. If it says explicitly to call get expected withdrawal, then yes.
00:08:19.715 - 00:08:28.035, Speaker C: Yeah. For te, I think caching would be more simple and it would avoid changing the spec. I mean like changing the state to.
00:08:28.115 - 00:08:28.835, Speaker A: Changing the state.
00:08:28.915 - 00:08:36.205, Speaker C: Cache this. Yeah, no, I mean we would prefer to cache rather than changing the state.
00:08:36.325 - 00:08:37.013, Speaker A: Yeah. Okay.
00:08:37.069 - 00:08:38.901, Speaker C: It will be simple. At least for now.
00:08:39.053 - 00:09:08.155, Speaker A: I also think it's simpler for us, so I'm happy to leave it as an implementation detail. I think Ethan wasn't happy with having Ethan as an implementation detail, but I think it's fine for now anyways. And regarding the other issues, I don't know. I do not know. It would be nice to have some fresh eyes on it. How close are you guys from having an interrupt?
00:09:11.735 - 00:09:28.909, Speaker C: Well, now that it was mentioned that fork choice doesn't need to be implemented fully then for Teco, I think. Yeah, I need to revert few changes and should not be too far from an interruption.
00:09:28.987 - 00:09:57.219, Speaker A: Oh great. But there's no need to revert things out there, I suspect, because I mean, whatever fortress you have, it won't really make us break in any way. But also the hardest part is the thing that you need to implement, which is having to deal with empty blocks. So that's already quite hard. The rest is sort of like simple. Yeah, yeah.
00:09:57.307 - 00:10:00.055, Speaker C: I mean I started implementing all of these boosts and.
00:10:00.715 - 00:10:01.655, Speaker A: Oh yeah.
00:10:03.595 - 00:10:06.135, Speaker C: I would prefer to have it cleaner.
00:10:07.275 - 00:10:30.969, Speaker A: Yeah, yeah. So I still, I think we still have them. I'm not sure if in the branch, even the interrupt branch we remove them, but yeah, I need to remove them as well. All right, so if we're soon to it, that's fantastic news. I'll try to start merging our intro branch. All right.
00:10:31.097 - 00:10:45.885, Speaker C: Actually, so it's going to be rebased on top of Devnet 5 or what's the actual plan like? Rebase on top of what?
00:10:46.465 - 00:10:55.583, Speaker A: We are rebasing our branch on top of develop, which I'm not sure what's following. And do you know, Terence?
00:10:55.759 - 00:11:06.235, Speaker B: Yeah, that should be on top of Devnet 5 eventually, but Devnet 5 were pending EIP 7742. So yes, I think we will be based on top of Devnet 5.
00:11:06.735 - 00:11:08.635, Speaker C: Okay, yeah, sounds good.
00:11:14.655 - 00:11:28.705, Speaker A: All right, um, that's. It really says it's a short call. All right guys, I'll see you then in a couple of weeks. For next few weeks.
00:11:28.825 - 00:11:30.097, Speaker C: Bye. Bye.
00:11:30.121 - 00:11:30.633, Speaker A: Bye.
00:11:30.769 - 00:11:31.497, Speaker C: Cool. Bye.
