00:00:56.020 - 00:06:01.894, Speaker A: Sadeena. Sadeena. I think I can give a quick update from the DevOps team. Over the last week we focused on local testing with the kurtosis package and we are still waiting for the remaining client images to get ready. We found several small issues with various clients, but most of these issues are already fixed by now and we also have received images for Packtrade Fnet one from all clients now, but we are still facing problems with two of them. Specifically, Prism is splitting out with some pairs at slot 32 and Erican is splitting out with the first block with deposit requests. So yeah, unfortunately we also reached a limit with local testing because we can't spin up all the client pairs anymore locally.
00:06:01.894 - 00:06:32.262, Speaker A: So yeah, next stop is probably Devnet one and our account plan is to launch Devnet one next Thursday with all clients pairs if they are ready by then. So yeah, that's all from us from now. Awesome. Thanks. Okay, sorry. Yes, the sound for YouTube was muted. Okay, so TLDR, we've received all of the client pairs for all the image for all the clients for Devnet one.
00:06:32.262 - 00:07:58.050, Speaker A: Some issues with Prism and Aragon, and we're hoping to launch this next Thursday with all client pairs. Any of the specific teams want to share an update? Okay. And then I guess in that case, yeah, if we launch Devnet one next week, we can see how things go, and if things go very smoothly and we don't find more issues, then we can put us back together for Devnet two next week. But yeah, it seems like we're in a good spot for Devnet one. Any concerns? Other comments? Okay, in that case, is Marius on the call? Yes. Okay, Marius, do you want to give a quick summary of your Eof blog post and we'll start things from there? Sure. So I said in the past, multiple times that I am not a big fan of eos and I decided to write my thoughts down why it shouldn't be in Pektra.
00:07:58.050 - 00:09:09.840, Speaker A: And so I did that in the post. Basically, my argument boils down to it's an extremely complex change and the benefits are small in my opinion, or not enough to justify such a large change. And especially because we can never get rid of the legacy EVM. We will always have that. And now we need to maintain two versions of the EVM in perpetuity. At least two versions. With every larger update of EVF we might add some new version of VOF that we need to be maintained in parallel.
00:09:09.840 - 00:10:28.414, Speaker A: And yeah, those kind of my thoughts feels like a bunch of people are sharing my general feeling, but also a lot have come up against it. At this point, I'm kind of tired of arguing, to be honest. I've said my grief and grievances multiple times, and it seems like people still believe this is a worthwhile change that is worth taking the risk. I don't believe so, but I would like to make it very clear that I'm not for this change. I think it's risky, and I think the risks outweigh the benefits. And if we decide to do it, and I will, don't want to be held responsible for anything that basically does my position. I would still keep working on it.
00:10:28.414 - 00:11:15.766, Speaker A: If we decide to do it, I will provide the code for Geth, but I don't want to be involved in anything. If anything breaks or if Mainnet goes to shit, then I have a clear conscience. Thank you. Also, there's a really funny thread on ACD if you want to read up on all of the discussions that we had. Thanks and I'll flag that. Yeah, I appreciate you putting the blog post together and out there and sharing your perspective, even though yeah, clearly there's high disagreements around it. I think.
00:11:15.766 - 00:11:52.590, Speaker A: Yeah, we should encourage people sharing their views, especially when it evolves as you've spent time working on EOF itself. Yes. So there was many, many messages exchanged about this on the R and D discord. I guess one thing that came up a lot was around just the support for EOf with solidity and other teams, you know, actually support this. Does it benefit them? It seems like it clearly does. But we do have Danielle on the call from the solidity side. So do you maybe want to take a minute or two to talk about.
00:11:52.590 - 00:12:15.450, Speaker A: Yeah. How solidity thinks about this change, why EOF makes things better for you all. I know you posted a few messages about this already, but just so everyone here has the context. Yeah, of course. Yeah. I mean, we've always been strongly in favor of UF. The previous version that was supposed to be going to Shanghaied already, and the current version definitely.
00:12:15.450 - 00:13:05.938, Speaker A: Also, there is a few aspects that were raised in the blog post and the channel that I would like to get into that claim that there would be alternatives to solve the technical problems by UF, which I would try to debunk. I mean, we have Swapn and Dubn, which significantly simplifies our compiler infrastructure, which we have been trying to get into legacy VM for years. The ERP number is 663, but yeah, it can't be done without immediate arguments which rely on EOF. There have been a lot of arguments about that for years. Dano made the point in the chat and I think would be happy to elaborate if there is any questions about that. The other thing is getting rid of jump test analysis and banning relative jumps. That's also not possible without EOF.
00:13:05.938 - 00:13:39.046, Speaker A: We have function calls that have return locations which are inherently dynamic. People build jump tables and whatnot. I mean, all these things rely on a construct like UF. I mean, even if it was theoretically impossible to build all that, there would be a series of hacky changes which would never get the support to actually become be done in mainline EVM. So UF is the proper solution for these issues. So I would say UF is in that sense for us. And the stack below is the superior design by orders of magnitude.
00:13:39.046 - 00:15:07.434, Speaker A: That's not only compiler infrastructure that gets simpler, but also verification and auditing, bytecode analysis. All that becomes simpler with EUF. There's the other argument, quick question, like when you're saying all of this becomes simpler, will you not support the normal legacy version of the EVMs, or will you move the whole compiler to the new version, or will you just need to maintain two versions in solidity as well? We will move to EF by default because it's superior in all metrics once it's available. I imagine that we will need to maintain the legacy compiler version for some time until the community has caught up with the change. But long term, I would prefer to only support an EOF backend. And there is no incentive once the UF is live to produce more legacy contracts because, yeah, the metrics are superior in all aspects, really. So l two s will need to follow eof at this point? Yes, I would.
00:15:07.434 - 00:16:11.694, Speaker A: I mean, that's also an interesting question about l two s in general. I would say there is this idea that UF could just be done on l two s, but there is no evidence for l two s actually going beyond mainnet compatibility. That's the first and foremost goal of L2 at this moment, which is understandable because we are not the only things that you need to actually produce an ecosystem that works on L2 s. There is an entire stack below us that also needs to have that support. UF not only has in general invaluable properties for l one in gas cost simplification of bytecode analysis and whatnot, but l two s actually can, if you want to have more development of l two s, actually putting UF on l one makes things simpler because you can use UF contracts and transpile them to any new kind of execution engine. I mean, Alex made the point for Ck implementations earlier. I mean, all that becomes simpler once Eof is on mainline on l one.
00:16:11.694 - 00:17:14.888, Speaker A: So actually I would even argue the opposite. That if you want to have L2 innovation and want to facilitate that, putting UEF on layer one is probably the missing link that actually makes it possible to import the entire ecosystem to Ul L2 while still innovating on it without losing the entire infrastructure that's built for l one. Okay, thank you, Peter. You had your hand up as well. Yes. So I think Daniel mentioned a few things that basically uof simplifies that we don't need jump test analysis, that we don't need a lot of stuff and or gas introspection or code introspection. And all in all, I think the world that Eof kind of brings is a better one.
00:17:14.888 - 00:18:25.170, Speaker A: So I completely agree there. My only concern is that when we're talking about how many things we won't need after EOF, I think that's kind of a false fallacy argument, because as long as we don't have a way of deprecating legacy EVM stuff, I mean, we will still have to support basically everything apart beside EOF. And basically there's been some arguments that even though I mean, yes, EOF can be better in a number of aspects, I kind of agree. But basically we will just end up with having two independent evms, having to, basically having to maintain them. And plus we will need all of a sudden care about the interplay of those two evms. And every argument which says that, well, we can solve this or that or whatever thorny issue that might crop up in the EVM is not really true. The moment we allow EVM and legacy Evm, sorry, EOF and legacy VM goes to cross call each other because you can just.
00:18:25.170 - 00:19:11.808, Speaker A: So, for example, removing the gas introspection in EOF is completely pointless. If I can just call a contract in legacy EVM and that one just has access to it. And I don't know. So personally I kind of. I would say that EOf is probably a good idea, but I don't know. I personally would feel a lot better if there was a way to transition out of the legacy EVM so that we should either stop supporting it or we should somehow prevent people from running. Basically, if we would have any sort of mechanism to transition everything towards EOF, even if it's midterm.
00:19:11.808 - 00:19:58.370, Speaker A: So not immediately. I think it would make the case for EOF a lot better, because nobody's arguing that EOF is on its own. The merits aren't worth it. Just the problem is that we're just creating a very, very large risk surface that we will have to maintain. Thank you, Ansgar. Yeah, I just want to say, because I definitely agree that on Mainnet, with kind of the situation that we have so many legacy contracts already, and we'll have to support both of these versions forever, that the kind of the benefit cost trade off is a little unclear for you. But I definitely think that's why I think really at the core of this issue is the question of the relationship between l one and l two.
00:19:58.370 - 00:20:42.596, Speaker A: And I really think that we have quite the responsibility here to acknowledge that, at least for now, l one still very much sets the defaults for in terms of client, but also in terms of solidity, all the tooling, everything. And just if we don't support something on mainnet for now, for the next few years at least, it will just not reach L2s. It just won't. And we can always say, well, it should, but it just won't. So we can work on changing that and hopefully in 3234 years, L2 will be in a position that they can ship things independently. So basically our decision here would be to say, well, we are kind of delaying progress on L2 EVMSD, where it would clearly be a beneficial impact for a few more years. And I think this will not only come up in this context, but for example in the future, with account obstruction and things like that.
00:20:42.596 - 00:21:27.972, Speaker A: It will be the exact same question, same thing. If you have a chain that already has a lot of UA's, and then you move them over to smart accounts, basically, now you also have this extra complexity to manage both of them, and it's much messier than new chains. But basically we just have to acknowledge that we have responsibility for the overall evm ecosystem. So I would still very much be in favor of bringing you f two l one, thank you. Just to interject, I kind of agree with Asgard on that. L1 basically sets the stage for l two. So if you want uf and l two s, you need to get it into l one.
00:21:27.972 - 00:22:15.698, Speaker A: So that's kind of clear whether that would be, whether that would be an ideal in an ideal world or not, that's kind of irrelevant. It's kind of the reality we are in. And I think this is at least true for now. You could imagine a world where four or five years from now, the second Eofv two or whatever is something that l two s can ship on their own. But I agree that today we're at the level where they can ship their own free compiles basically, and maybe coordinate on standard address for one of them. And so, yeah, there's security a few years to standardize things a bit more, Dano. So one of the questions that was posed is, what's the plan to get rid of legacy of EVM? And I think we totally should do that.
00:22:15.698 - 00:23:16.292, Speaker A: And it would start with just banning new deployments at one point. And then once we have that, we can get a better hands around what bad behaviors that were banning any of that, we would then need to figure out basically system contracts that we could do compiles or whatever. We could just freeze them in place and just support them with another one of the problems. Yeah, sorry for that Biden moment, but one of the problems is that EOF has got the mandate to ban on certain things that legacy EOF has deployed today and we have to support. So no matter what that ban looks like, we're going to have to support that for existing contracts, even if we expire contracts, because all the expiration proposals have resurrection involved in those expirations. So if a behavior is out there, we have to support it. We can ban new deployments of those, but we can manage them so that they're limited set.
00:23:16.292 - 00:24:08.130, Speaker A: We know what those issues are kind of like, you know, the empty account and account number three, so. Right. And I think, yeah, obviously, step one towards banning legacy deployments is having an alternative on Mainnet. And then if you just think in terms of, like, our fork cadence, it's like, okay, if we ship EOf in this fork, I don't know that, like, next fork, banning legacy deployment is like quick enough or long enough. So it's like you probably waited another three years or something before you ban these deploys. And then the time that it takes you to figure out the backwards compatibility is probably another year or two. So realistically, we're saying maybe in five years we could do this transition.
00:24:08.130 - 00:25:09.050, Speaker A: Not that this isn't a good or possible thing, but it's also something where most of the people on this call, you know, for the foreseeable future, should assume that we're going to have to maintain both. Yeah, Peter? Yeah, I don't really think that's realistic, honestly. So if you're going to ship EOF now and you expect to maybe potentially address legacy EVM stuff in five years, well, in five years time, either if ethereum dies a horrible death due to the chain split, or if nothing bad happens, then basically everybody will say, well, okay, screw that it kind of works. Don't touch it. Right. And so I guess that's my point, is I think it's maybe. I think deploying EVF, sorry, EOF, with the premise that we can then migrate from the legacy EVM feels wrong.
00:25:09.050 - 00:25:46.138, Speaker A: I think what Ansgar said, that l, one might just have to accept more messiness because of its higher historical state, is what we should accept as a status quo. And then maybe we come up with a solution for legacy contracts. But I would almost treat that as like a bonus in a way, and not like our base case going into this. Yeah, Daniel. Another thing I want to address is the notion that we're maintaining two separate evms. We aren't. If you look at the code of all clients, it's all the same one loop.
00:25:46.138 - 00:26:18.410, Speaker A: We are adding a new container parsing functionality that is new and only supported by EVF, by EOF. But when it splits it out and we have the containers in the code, the loop runs through the same set of operations. We just have more operations that are context dependent, whether the current stack frame is EOF or not. Certain operations will be valid and certain operations won't be. But the memory model is the same. The transient memory model is the same, the storage model is the same, the PC model is the same, the stack limits are the same. A lot of the stuff between the two evms is absolutely the same, to the point that it even uses the same loop.
00:26:18.410 - 00:27:18.356, Speaker A: Got a text? Yes, but it's 19 year opcodes, and in the past we've shipped maybe like two opcodes per hard fork. And even then we had issues with consensus splits. EOF has already had three consensus issues introduced, not in the UAF code, but in the legacy code. And I don't know, it's just a risk that you guys apparently are willing to take. I'm not comfortable with that risk of introducing so many opcodes, so many gas computations. The code verification, just stack verification. These are incredibly complex changes in a very important part of Ethereum, and I don't see it being tested super well.
00:27:18.356 - 00:28:27.094, Speaker A: There's been good tests, but it's like the risk is, in my opinion, extremely high. It's hard to test it super well when there's only two complete implementations. Just in the past week we finally getting more complete implementations of clients. Now we can do the real testing, now that there's implementations out. Thanks. And I think maybe on that, one thing that would be valuable is to think, even though we don't have the full test coverage today, and you know, we depend on implementations for that is to think about what does our ideal test coverage look like? So, you know, if we can sort of come up with our, what, like, our bar for feeling comfortable with this is ahead of time, that might be a good way to, like, yeah, not, yeah, not have to, like, make a decision in, like, a very local way where we just look at what exists today and. And keep asking yourself, is this good enough or not? But, like, yeah, what would we want to see? Like, I assume we'd want to fuss this extensively.
00:28:27.094 - 00:29:04.840, Speaker A: I assume we want to. You know, we have already a lot of. Of static tests, but are there some test suites that we think are missing that we think we should have? And maybe this is a better discussion for the EOF call than this one, but, yeah, I think defining that bar ahead of time can be useful to. And by no means, we're not done writing tests. We're like, maybe halfway through the test cycle, maybe. So to judge the quantity of the test by being halfway done, I think is a bit unfair. Let's do Guillaume, and then we'll do Andrew and Luke.
00:29:04.840 - 00:29:57.004, Speaker A: Yeah, just point when Dano says we don't have to touch the state. That's true. Maybe today. I'm not even sure you'd have to ask Marius, but it's definitely not true in the future. So, not that it's showstopper in itself, but I want to remind everybody that this claim is not going to last very long, like, to hold true for very long. Andrew? Yeah, I think I agree with Marius that it is a very big and complicated change, but. But I think we have time in Pectra to actually concentrate on it and push for it and extend the tests and make it work.
00:29:57.004 - 00:31:20.968, Speaker A: Like, the merge was also complicated, but we managed to pull it off. And, yeah, I'm sure that if we spend enough brain cycles and effort, we'll pull UAF off as well. And I think because if we don't do it, basically we freeze progress on EVM development. And I kind of, to my mind, EOF presents a coherent improvement to the EVM, and it opens up further potential improvements like EVM Max. And if we don't ship it in Pectra, then a lot of people, because we've been postponing it for so long, and basically, a lot of people will give up, and they will give up on EVM Max and other EVM improvements, and it will be a bad outcome for Ethereum and blockchain in general. Thanks, Lucas. So while I agree that the changes are very complex, they need to be complex because we don't want to ship this in parts or even can't in some places.
00:31:20.968 - 00:31:55.444, Speaker A: We don't want to create even more feature fragmentation. So if we want to ship some big improvements to EVM, we want to ship them as one. So we cannot kind of do it in any other way and having a big complex change. If you won't ship it now, we probably won't ship it for years. So that's another concern. In terms of testing. I totally agree that it's not yet tested, but I'm also a bit optimistic in terms of that.
00:31:55.444 - 00:32:43.570, Speaker A: We found, for example in Nevermind, multiple issues based on the current testing setup already. So the tests are doing a pretty decent job of showing those. We probably have more that haven't been yet uncovered between the clients in terms of benchmarking and DOS. We at Nevermind are planning to do Dos benchmarking for all the new opcodes and see what kind of mega gps throughput we can get. And we have, we have a tool that we can do this cross client. So compare all the clients. And the last thing I wanted to say I asked that few times but didn't on the chat in the discussion, but I didn't find an answer is fuzzing.
00:32:43.570 - 00:33:56.540, Speaker A: I would love to have very extensive fuzzing between clients on this, but to have the fuzzing working well, we have to have multiple implementations which we are just having. So before someone answers me that, how is the fuzzing going and how is the fuzzing state? My opinion is that we should continue as is and just revisit it later. If we find it, if we still will be finding out convinced we will be not confident in this in EOF, then we might want to remove it, but it's a bit premature in terms of testing. It's still in progress, like it's half done the most. And that's fine that we are doing it at the moment and I don't see a problem with that yet. My question would be are we going to delay the fork if we decide if we find more issues with EOF? Well, it depends when we get there in my opinion. Right.
00:33:56.540 - 00:34:54.388, Speaker A: If, when we find issues we will address them. And if, if, would he have drastically delayed the fork? Maybe we'll remove it from the fork and move it to a second one. I don't know, we'll see. It's like we're speculating right at the moment. So yeah, I'd agree with this that it's a bit hard to make a call about like the relative readiness of things, especially with something like pure Das on the Cl as well, and a lot of other big changes. So yeah, I would keep the conversation around like is this valuable at all? Rather than, yeah, is this the right time? Or if we find a bug at this time, you know, do we remove it or not do a dragon. Yeah, I see two arguments against uF.
00:34:54.388 - 00:35:56.082, Speaker A: One is it's too complex. That argument can be mitigated by making new tests. Basically the current test yet is not enough, but the argument is we are basically making new ones and adding it and improving it. Second argument against EOF, is it deduce complexity that's maybe needed, not needed for l one. And against that argument, if Ethereum wants to improve itself, to improve l two s, change needs to come from l one on complexity of the changes. What I want to say is EOF introduces ads and extends opcode sets that are already present. It's not introducing new complex logic to the legacy bytecode.
00:35:56.082 - 00:36:42.660, Speaker A: It introduces new validation that's outside of the bytecode. So complexity is not that tight and overlap with the legacy bytecode. So even if we have two versions of UF, two versions of the bytecode inside your evm, they are not going to be a lot divergence between those. And just to mention again, we all add new opcodes and we have good framework for testing your evm so we can reuse those. That's it for me, thank you. Yes please. There are a bunch of bytecodes that are different.
00:36:42.660 - 00:37:35.556, Speaker A: So for example x call x delegate call x, the other call. There is, there is, I mentioned those, there is. Sorry, those have like they almost do the same thing, but they change in the way the gas is calculated, they change in the arguments. They have all of these subtle changes that it's a new opcode. It's not, it's not just take call and modify it slightly, it's. You have a new call of basically. So yes, there are some, there are most of the opcodes, most of the 80 op codes are the same, but there are 20 new opcodes.
00:37:35.556 - 00:38:07.610, Speaker A: 19. Sorry. For example, in REBM implementation I'm using the same framework for the calls. The change is that the gas is changed and how gas. Gas limit exchange how gas limit is calculated. There is additional code that's duplicated, but it uses the same framework as the ordinary calls. Additionally, interaction between legacy and EOF is between how the external code is fetched.
00:38:07.610 - 00:38:54.830, Speaker A: And additionally there is change how the UF gets created with create intersection, those like interaction. Basically the points where the legacy and Uf cross paths. There are not a lot of those. Okay, let's do Guillaume. Yeah, I actually just wanted to ask a practical question, although I would like to note that I can see another issue with EOF. It's the lack of future proofiness. And I would like to know if when Daniel says it's going to make things simpler for ZK.
00:38:54.830 - 00:39:24.800, Speaker A: Oh, was I muted the whole time? Sorry. No, no, you were fine. We lost you for like half a second, but okay. Yeah. So I would be interested in finding, if you have references about this, that UF indeed makes it easier for ZK stuff. But okay. My question was actually, when EOF launches, will we already have compiler support or not, or do we still have to wait a bit longer for that? We will have compiler support.
00:39:24.800 - 00:40:23.280, Speaker A: And just quickly, the point about CK is also in general, the point is that UF code can be transpiled to a new execution engine, be that in ck one, or an improved non CK execution engine and whatnot. That's possible by the design of EOF. That's a nightmare. Or impossible for legacy EVM. Thanks, Andrew. Yeah, I'd like to note that I don't want to delay Pectra, but maybe delaying pectoral is not a bad thing, because from the panel on account abstraction, it looks like the design of 7702 is not settled yet and people need more time to figure out the proper design. A good design for 7702.
00:40:23.280 - 00:41:01.160, Speaker A: That's it. Thanks to. Yeah, I feel like the conversation is very focused on the practicalities of shipping EOF, but I don't think that's like the right direction for the conversation, or at least the conversation that we should be having. And, you know, EOF is useful. Like, I don't think that we're generally arguing that there is not usefulness in the things that EOF provides. I think in general we can ship EOf given enough time and resources. So I'm not.
00:41:01.160 - 00:42:23.190, Speaker A: There are questions about how long will that take, and we've been talking a lot about that. And will we be able to get the testing done in that amount of time if we spend a couple of years on EOF? I think we can ship it, but we're not asking the question as much. Should we be making changes to the EVM? Should we be making this of changes to the EVM? Why are we actively making l one more complicated for a proposal that clearly is not necessary to the survival of Ethereum? And I would rather us focus at l one on doing things that is necessary to the survival of Ethereum looking at inclusion lists, reducing the size of l one clients, making it easier for people to run l one clients. We as a core dev group have sort of said that we want to focus on being a settlement layer and allowing l two s to take the baton on developing the execution layer for Ethereum, yet we are trying to centrally plan the future for them. I don't think that that's our place. I don't think that that is useful for the future for Ethereum. Thanks.
00:42:23.190 - 00:43:07.026, Speaker A: Dano thinks it's actually necessary, so I don't know if you want to maybe expand on that. Yeah, I think it's not a two year threat like inclusion list. Some of those things might be a two year threat. I think it's more of a five to ten year threat for ethereum if we don't improve the base case of the EVM, because I very reasonably see a future where if we don't improve the EVM and there's other alternative vms out there, I won't name them on this call. There's some really good ones out there that the recommendations from smart contracting auditors are going to be use a modern vm. And if l two is use those modern vms, we're draining a moat that keeps Ethereum being Ethereum, and these are EVM chains we're talking about. And if the recommendation is don't use the EVM chain, then we're draining them out.
00:43:07.026 - 00:43:47.022, Speaker A: So I think it's a five year to ten year threat. I don't think it's not a threat, it's not a next year threat, but it's something that we need to keep in mind as we go forward. Building Ethereum. I really don't like that framing that we're forcing the entire community to use this new vm just so that Ethereum can retain users and keep a moat and keep a stranglehold on the innovation of execution. That's not what we're trying to build here. We're trying to build an open platform for people to experiment and to build different virtual machines. And if a good virtual machine comes that doesn't start with e, then we should be very supportive of it and that still exists in the world.
00:43:47.022 - 00:44:14.030, Speaker A: But the default of l two s is to just fork an l one client and work from there. So we're not foreclosing these other vms they're building. They're going to be out there. But if the evm is the last choice it's going to be, then why use EVM as a main layer. We need to make it better for l two s and l one s to align. And if they're not aligned, that's the five to ten year threat. We're using it on the main layer because it is what is on the main layer.
00:44:14.030 - 00:44:51.704, Speaker A: No one here is going to say that this is a great vm, the best vm ever built. It's just what we have, and we should try to make some incremental improvements to it. We shouldn't ever go back and say, this is the second version of the EVM. We're past that point. Now it's time to let the l two s make the second version of the evM or whatever other vm they want to make. And I don't get the argument of saying l two s will move to these other evms or these other vms. And we can stop them by making eof on Mainnet.
00:44:51.704 - 00:45:56.296, Speaker A: Because if they see a benefit in moving to move, or moving to whatever stylus or whatever, then they will move there and no amount of your app will ever make them make them reconsider. And if EOF is like this great improvement over the eVM, then there should be no argument for l two s to adopt eof. What we're doing is we're bringing the EVM up to standards established in years like 1941 and 1996, with some of the container structures and static jumps. I mean, we're not. No one's getting a PhD off of Eof. We're just applying stuff that is known to be good, and that is, if we don't have that good base, it's about remaining competitive. The base has clearly gotten us to be one of the biggest blockchains in the world, one of the most successful development blockchains in the world.
00:45:56.296 - 00:47:08.882, Speaker A: So I don't think that we need to go back and like, rebuild the base from first principles. I don't know if I agree with that. I think maybe there is a case to be made to rebuild the main blockchain from first principles. But is that what we is Eof? What we would end up with? Is this the best version of the EV or a virtual machine? Or is something that is really not EvM? Doesn't look like EVM at all. Something better for l one? Guillaume, did you have your hand for another comment, or did you? Yeah, I just had two questions, but it's okay. Can wait if let's do Asgard and then Dragon. But I guess my sense at this point is the get team is still opposed for a bunch of different reasons and other teams still see all in favor.
00:47:08.882 - 00:47:59.592, Speaker A: So I, my sense is at this point, we would keep it in and obviously focus on testing and whatnot, but that if I made this, we actually started the conversation by saying we will let it. We're not going to try to block it, we're just not going to support it like we usually do with the rest of the forks. What does that mean? Meaning other people will have to do some testing as well? Yeah. And if so, Ipsalon and I myself have been writing most of the tests for EOF. We're already there. No, you're nothing. And if it blows up on Mainnet, I will not stand up on a Saturday at 02:00 a.m.
00:47:59.592 - 00:48:23.842, Speaker A: and try to fix it. I think this is like the decision that I'm going to take. If it ever happens. Might not happen. It might everything go perfect, but if it happens, then I will not be there to help. I'm sorry. Okay.
00:48:23.842 - 00:49:26.670, Speaker A: And yeah, I think there is like the capacity from other teams to help with the testing and shipping this. So, yeah, I think my sense is we would keep it in the fork for now. And obviously, like with any change, we'll re evaluate as we get farther down the testing stage stack, you know, like, is this too complex? Do we think that there's, you know, far, like, too great a risk of bugs and consensus issue? But given that we don't have like, full finished implementations yet, we haven't started fuzzing. There's still a lot of static tests that needs to be written. It seems like there's still a lot of work to do to even get it to a spot where we can have like, this final call around security and other client teams are in. Other client teams seem to be willing to take on that work. Yeah, that's my read so far.
00:49:26.670 - 00:50:20.750, Speaker A: We can close with Guillaume, Greg and Matt, and if anyone has any final comments on it, please raise your hand so that we can have them all on the screen. Otherwise, I think we can move on to the rest of the agenda. Yep, yep. So I'll try to be quick, but I had a question about the conversion, like, deprecating legacy in the future. What if we had some kind of. I'm just basically throwing mud at the wall here, but if we had some way to deactivate all the introspection instructions before we actually duplicate all legacy code, would that be an interesting medium step, let's say? I'm just curious. I would like to ask the EOF people and the compiler people.
00:50:20.750 - 00:50:50.100, Speaker A: There's a whole category of contracts called data contracts that would break. So we need to put a special handling for that. They start with code zero zero, and they just put data on there because the gas schedule currently encourages it. That's going to change with vertical, but the data is out there and they still want to access it. Even if we deprecate it. We need to have facilities for them to access some of these things that they've been building their nfts off of. We would definitely need to audit it and make sure that we know what we're getting into.
00:50:50.100 - 00:52:00.540, Speaker A: The first step is to ban legacy deployments, and then we can analyze what the close set of what the real issues are and what we really need to fix, rather than having all possible trolley issues come out when they find a new way to cause problems with the solutions we proposed. Okay, thanks, Greg. Yeah, I just wanted to go into one paragraph of Marius critique, which is static program analysis, and he points out correctly that as long as we have non static jumps, the analysis of a program is in the worst case. Order n squared EOF removes dynamic jumps, which reduces the analysis to order n in the worst case. And over and over, people seem not to get how very important this is. Marius goes on, I'm not convinced that the difference is significant. Someone not being convinced doesn't mean that it's not significant.
00:52:00.540 - 00:52:50.140, Speaker A: The people who care about this are totally blocked. The difference between linear time and quadratic time is the difference between being able to do something and something being impossible. In particular, this is so important. What do you want to do, Greg? I want for nine years to get rid of static jumps and introduce a subroutine instruction. And this, I believe, is pretty much our last opportunity to do it. It's bigger and more complicated than we'd like because we haven't been able to do it incrementally over the last nine years. But it is good enough.
00:52:50.140 - 00:53:14.632, Speaker A: We can't just keep trying to get it perfect. It's good enough. And if we don't solve the problem, we simply create a dead end for all kinds of research and improvements involving this. It's very diffuse. You asked on another channel. I'm not hearing people complaining about this. No, they've gone away.
00:53:14.632 - 00:54:02.390, Speaker A: They have work to do. Pushing on the core devs to make their life easier is a waste of time. They have to improve the speed of their code now they have to validate that their customers code is correct. Now we can help them hugely. The ZK people, some of them are going to heroics using GPU's in parallel because their proof size is blowing up quadratically when they hit these jumps. This is a small kernel that's very important to get in. If EOF fails, I'll happily write a proposal that puts in, again just those two instructions and a validation routine.
00:54:02.390 - 00:54:45.368, Speaker A: But I'd rather see all of the of go in because there's so, so much work and support and so much good that can come out of it. I understand that you want to get this in. My question is why? What is the use case that you're trying to make that you need to get rid of the dynamic jumps for? I've been trying to explain this for nine years. Lots of people have been explaining it for nine years. I don't even know how to answer a question that's. I don't know where to start. Yeah, sorry.
00:54:45.368 - 00:54:59.760, Speaker A: We're already pretty deep into this, I think. Let's. And you know, it seems like we're just going to keep working on it for now. So. Yeah. Matt, you had your hand up as well. Yeah, I'll make it super quick.
00:54:59.760 - 00:55:58.930, Speaker A: We keep talking about, in many instances, trying to push these innovation to L2s, but in very real circumstances, they're reliant on the l one clients for most of their infrastructure and operations. So it's not worth understating the fact that if we ship it into the clients themselves and use the kind of l one mechanism to get that forward and push all of this stuff, then it opens the door to this type of innovation on L2. With the EVM specifically. I think this is what Dano was discussing when he talked about the moat that we would have. And there's proposals for basically being able to extend the capabilities of the EOF container and the burgeonings. So I think that it can't be understated that right now the developer push on L2 is broad compatibility so that people can deploy their dapps across all of these chains. And making sure that we can meet people where they are now is, I think, valuable, as opposed to saying, let's kind of punt this innovation and see what shakes out.
00:55:58.930 - 00:56:43.270, Speaker A: Because, you know, I think that would kind of remove the reality of the situation that we have now with. With both clients and L2's kind of marketing and positioning with developers. So at least that's my, that's my take here. One last quick thing. What is, what is stopping us from merging it into the client and not activating it on mainnet? Then the L two s can take the code and run it and do whatever they want with it. And I don't get this argument that we need to do the work for the L two s and we already did the work for the L two s. They literally just need to take our code and run it.
00:56:43.270 - 00:57:04.860, Speaker A: I don't know. It's fine. We've had this conversation. It's still in, it's going into Petra. I don't think we should have any more discussions on the chat. Thanks. Yeah, I think this is a good spot to move on, and especially given there's no l two s on this call.
00:57:04.860 - 00:58:24.118, Speaker A: Speculating about why they won't support it probably isn't super productive. But yes, to recap, we keep it in, we keep it in Pectra. I think Geth has been pretty clear that even though they won't like oppose change, even though they disagree with it, that the amount of testing and security work that they usually perform should be performed by others who actively want to champion the of and this has already started. This has already started happening, but we should basically double down on that. And then, as always, if we get to the point where we're close to shipping the fork and we feel uncomfortable with the safety of EOF, we keep finding bugs that we don't think we're going to fix in time, then we should reconsider having it in the fork. We should continue working on it, testing it, and yes, as soon as we have multiple final implementations, start fuzzing them against each other, find other bug. Does that make sense to people? Okay, thanks everyone, and appreciate people being civil in this discussion on the call.
00:58:24.118 - 00:59:11.450, Speaker A: I know that a lot of people have very strong opinions about this. Yeah. And so moving on to something else where people have very strong opinions account of so there was, I believe, meetup around 7702 near etc. A proposal came out of this to add the code reset functionality and then there was a response posted on the agenda, sort of opposing opposing this. I've posted both of these links in the chat. I don't know if any of the supporters of code reset is on the call and wants to give a quick overview. Hi, can you hear me? Yes.
00:59:11.450 - 01:00:12.610, Speaker A: Yeah, so I wrote some of the proposal in the doc and I can give a brief overview of the overall discussion and what was proposed. So hi, I'm from Frontier. I do research over there and give some context. The proposal is with respect to some of the concerns a few teams have about the latest version of 7702, which makes the smart contract code persistent. Before this latest version of 7702 or before even the 7702, there are generally two types of accounts in Ethereum EOa or smart contract accounts. We believe that the current proposal basically adds a new type of account where in EOA you have a private key which can issue transactions. In a smart contract account you have code on chain which basically needs to run and validate before things, you can do things with that account.
01:00:12.610 - 01:01:00.164, Speaker A: With the 7702 spec, you have a new type of account which has code, but it also has the EOA private key which is basically the super user of the account. So it introduces this new type of account. You had eoas, you had smart contract accounts, but you have this new smart contract account with EOA as the super user. EOA private key as a super user. And it makes, there are two issues with that. Firstly, because this is a new type of account, there are some ways in which you can dos the network layer, and I'm sure like there are proposals to mitigate that. But one of the proposals that we, one of the suggestions that we make also reduces that network, network layers.
01:01:00.164 - 01:02:16.602, Speaker A: And then secondly, because you have the EOA private key which can behave as a super user, you can bypass all the constraints that you have put in place on your smart contract account. People also call these policies and just move users assets using the EOA private key. And so this makes some of the use cases unviable. So to give an example, if you have a multisig now, the security of your assets is still dependent on the OpseC of your private key and not on the Opsec of these multi segs. Or if you have some type of resource lock mechanism, which will be beneficial for instantaneous multi chain transactions, the user can bypass these resource logs because they have the way to unilaterally move assets. And so the proposal, what is the proposal? Proposal are basically three things, each a little bit independent with each other, but they try to solve these issues. The first one is there's this line in the current 7702 spec which basically says that we should remove, basically, EOA should be able to generate transactions using the private keys.
01:02:16.602 - 01:03:24.422, Speaker A: If you remove that, and that is a very simple change, you would remove this new type of account. You would also resolve the network layer, DOS, because the network layer understands how to interpret transactions coming from eoas or smart contract accounts. And so overall, the proposal is instead of creating this new account, you should only have these two type of accounts with the network layer can understand and give the users or the wallets the functionality to cleanly switch from one type of account to another. And so proposal number one is removing EOA's ability to initiate transactions on its own. The second one is if you want to switch from the smart contract account back to the EOA, you should have some way to delete the code. And that's what we call as code reset. And then the third one is, it's not dependent on the first two, but basically right now, you don't have a way to atomically initiate the storage in the smart contract account when you do 7702.
01:03:24.422 - 01:03:47.102, Speaker A: And that's the optional call data. So those are the three different proposals, each trying to tackle different things. And so that's the overall proposal spec. Thank you. And I believe there was a response to it. I don't know if the authors of that are on this call. If not.
01:03:47.102 - 01:04:05.114, Speaker A: Yeah. Ansgar, you also have some concerns. Gm. Oh, okay. Julianne. And then we'll do. Yeah, yeah, I won't spend too much time and, you know, thanks unkid, for the, for the, you know, for the proposal and everything.
01:04:05.114 - 01:04:55.560, Speaker A: You know, I thought I would provide a small analysis from the other side, trying to, you know, I think, balance both, I guess, technical stewardship, but also, like, the end users and the, and the actual, like, account holders and what they actually, like, want at the network, wherever. And I guess, like, since Ankit did as well. I am the CEO of Oatum Labs. We spent the greater of the past nine months thinking really deeply about, like, how do we get to this next future of smart accounts. Broadly speaking, we spent a lot of time implementing 3074 on the contract client level, obviously moved on to seven center zero two, spent a lot of time thinking deeply about that. You know, have basically been there end to end for the process. And seeing the proposal, you know, the proposal grow.
01:04:55.560 - 01:05:55.090, Speaker A: I won't dive too deeply into it. Our doc is obviously, like, posted, like, in the chat. And obviously there's clearly a couple things here that are extremely important. Like, number one is, like, obviously, ephemeral delegation become the concern for, like, dos, which obviously I need to do some more reading on my end to better understand. And then also just like, the greater high level of what this proposal is bringing to the current spec state. We're firm believers that actually, given this new proposal, actually being able to take the step back and think back to the original proposal or the current proposal that Matt wrote, it's, I think, more in favor of like, you know, open innovation. Obviously, it's not gonna push back like, 772, which obviously we would absolutely hate.
01:05:55.090 - 01:07:08.680, Speaker A: And, you know, not introducing like, additional, additional things like this would be technically a new opcode. I understand it's a variant of of self destruct, but understand that the current version of 702 doesn't actually touch or edit the behavior of the VM. Rather it's something like more something that doesn't involve actually interacting with it. We propose a potential alternative if people want to actually ephemeral delegations must like proposing a flag to add, to add to delegations in the authorization list that would designate this particular thing as ephemeral, and then clearing the code hash at the end of the execution. We've been writing a bunch of experimental contracts, 7702 implementations, and been thinking about like, yeah, what are other ways that we could do this without touching the VM, et cetera. There's other things about shared storage. We've obviously read the namespace, the namespace PR, which has obviously gotten some pushback as well.
01:07:08.680 - 01:08:19.080, Speaker A: And yeah, I'll kind of stop there. I try to keep it as high level as possible, but feel free to take a look at the doc, and I'm happy to answer any additional questions in the chat. Thank you. Anskar yeah, I just wanted to say that I also wrote it down in chat that I think, I personally don't like this new idea with quote reset, primarily because it basically goes 90% of the way to a permanent upgrade, but then stops 90% of the way, which I think is a really weird spot to stop because it still has this now the special type of contract that in principle at some point in the future can return back to becoming an UA, which just makes it so much harder to reason about. You also might have the false sense of security that you can actually do this with your account, but then it turns out maybe there is some bug in the implementation, and actually the code path you relied upon for getting there doesn't actually work. And so you are stuck after all. So it basically creates this false sense of extra security over a permanent upgrade that really isn't there.
01:08:19.080 - 01:09:08.854, Speaker A: It's basically the same security guarantees as a permanent upgrade. So then I think if we want this, if we like this, then we should just commit and making it a permanent upgrade, and the alternative should be that. So basically, just for people that maybe haven't followed this, you know, because I feel like we have been on level 25 of the discussion now. So basically, you know, if you stop paying attention, a couple of weeks ago, initially it was that the swapping in the code was only done within the scope of a single transaction. And at the end of the transaction, basically you're back to an UA, and then we changed that specifically because it is kind of nice to actually have the delegation target stored in your account. But my proposal would be instead of just because we're storing it, it doesn't mean it has to be active all the time. I think storing it was an improvement, but basically now we decided as long as it's stored, it also has to be active.
01:09:08.854 - 01:09:56.188, Speaker A: I think we should store it, but then still only flag on individual transaction scope whether that it should be active, and by default it should still be an EOA while it's sitting there. I think that would be a much cleaner version that basically is closer to the original idea in terms of what we should do. Next steps. I just want to say I think clearly that we keep having these discussions means that we are not close to a super final spec yet, so we should keep having breakouts. I don't think ACD is necessarily the right forum for this. In the meantime, I actually think the current demerged version, that is the change from Matt from a couple of weeks ago that basically did add this on chain storing of the delegation target. I think that's a very reasonable target for testing because I think any changes we will make from here on out will be relatively small.
01:09:56.188 - 01:10:40.210, Speaker A: So my proposal would be we just stick with that version for now. We keep with Devnet targeting that version. In the meantime with breakouts, we try to get to final spec, and only once we have an actual final spec do we then move to that for testing. Thank you. I agree that yeah, there's a lot of context in these conversations and we may not be able to resolve everything here. And yeah, before accepting the change in. Yeah, we should have teams be much more confident in the actual proposals.
01:10:40.210 - 01:11:50.300, Speaker A: Ankit yeah, I agree. I just made this proposal to basically get feedback on where everyone's head is at. I agree this proposal is not to hey, let's change the seven, seven and two spec right now. But I also wanted to highlight some of the things that some of the smart contract wallets care about, which is if you give the user the ability to bypass the on chain policies that they have encoded, then it basically makes the current migration path less secure. And also it removes some of the use cases like instantaneous question transactions, unfeasible for these type of accounts. And so I wanted to highlight that I'm happy a lot of people who were in the whiteboarding session and there are list of names over there as well who have reviewed the doc, are happy to basically come to another breakout session where we can have a video call to basically update the spec or propose changes, whatever. What I wanted to say.
01:11:50.300 - 01:13:04.972, Speaker A: Yeah, I guess this is the question. Do we think that we can resolve this async in the next couple of weeks, or do we feel like we need to have a breakout to discuss this more thoroughly? Pedro? Yeah, I mean, like, I'm sorry, did I client in the chat and on discord? This is something that just reopens the concerns we had around EOA migration. Specifically, like, how do you deal with the fact that a user might think that they've migrated their wallets to a more secure access control policy, yet the private key still is able to sign messages that are accepted on chain via ECR cover. So there is a reason that we stopped going down the path of full EOA migration is because we didn't have good answers for that. That's not to say there isn't a good answer. It's just that we couldn't really come up with something and it felt like the right thing to do would be to give users the sort of hybrid ability to both be a smart contract, act as a smart contract wallet in some cases, but always have the EOA private key as the master control for the account, and allow it to originate transactions. That's why we ended up on 7702.
01:13:04.972 - 01:13:50.252, Speaker A: I don't really think that there's something that we need to do here to change that direction because we spent a lot of time talking about it earlier this year and didn't find a better solution to the EOA migration. So unless someone finds a better solution to fully EOA migration dealing with EC recover, then to me, like, this is just not really a possible change to make the 7702. Got it. Pedro. Richard, were your comments, were either of your comments about this specifically? Yeah, yeah, it's about 7702 as well. Basically. I think the most problematic thing that this proposal addresses is that one line exception.
01:13:50.252 - 01:14:56.028, Speaker A: In my view, it feels a little bit like 3607 made it very clear that if there is contract code, then it cannot, like, send transactions, and then that one line exception overrides that and it makes like, 7702 do 3607, but if it does has a delegation, then it still can send transactions. I think that one should be addressed where you're either with contract deployed or you're not. You shouldn't be like, in this in between, you're an EOA, but sometimes you're a smart contract, either one or, I mean, you have to look at why. You have to look at why 3607 was implement in the first place and 3607 was implemented because we were worried about somebody potentially deploying a smart contract, or they found the private key for in secret, and the smart contract looks like an application and then secretly later on they use the private key to drain the application's funds. Whereas with 7702 allowing them to submit transactions, it's very clear that this is not an application. It's got this delegate designator in front of it. And so you can just see on chain that this is not an application, this is a user wallet.
01:14:56.028 - 01:16:09.418, Speaker A: So that's why it's okay to break the 3607 requirement. But then do you still have the ability to revoke? Because the idea of code reset is that you're able to essentially come back to being an EOA experience. And the reason it was chosen to be an opcode is to be able to do that either after several transactions or atomically in the same transaction. And that's why I like this proposal is like broken down into multiple pieces because it's trying to address users who want to have smart contract capabilities per single transaction, some that want to have it for like multiple transactions, and most importantly, to have the ability to unmigrate as well. Yeah, I mean, you can unmigrate by simply setting your delegate designator to zero address. It's not possible in the same transaction currently, but 7702 is not designed for users who want to have execution abstraction on the single transaction level. It's supposed to be helping users use a smart, have a smart contract wallet like inner experience for the longer term.
01:16:09.418 - 01:16:54.822, Speaker A: And if they want to completely turn that off, there is a way, but you just can't do it in the same transaction. Why is there any concern of doing it in a single transaction? Because this proposal. Because if you do the same transaction to be ephemeral. Yeah. And one thing that we sort of realize is that if you make it ephemeral, this was the problem with 74. Also is that if you are allowing people to make things ephemeral, then you're sort of allowing them to have this different user experience from how smart contract wallets work. One thing that we have shifted the thinking on a lot in the last six months is that we want users to, however they're going to interact with the chain, like whether it's Sarasota, two, a smart contract wallet, whatever.
01:16:54.822 - 01:17:44.668, Speaker A: Then in general, we want them to interact with the chain as if they have a smart contract wallet. And that allows us to streamline a lot of the way the tooling works and the way that applications can expect user accounts to. Look. If we also have this other alternative path for users to do execution abstract things then now we have this whole other ecosystem side quest world for developers to go down and build out different experiences. It's just not something that is a priority for the people working on account abstraction. I just feel like there's two camps though. IO was also a big proponent of making it permanent because single transaction was not sufficient and that I'm glad that that change went through.
01:17:44.668 - 01:18:39.308, Speaker A: But now the single transaction is not possible as well. So why isn't there a solution that essentially makes it optional? You can do it in a single transaction or you can do it in multiple transactions. And the opcode approach was actually just a rename or self destruct seemed to be the best of both worlds that you are. Why do you want a single transaction approach? So one example of a single transaction is because some cases like a little bit more institutional, they already have these policies built off chain with NPC and other infrastructure, but they still want the batching and gas sponsoring. So they want some of the functionality that is enabled by 437 without actually having the permanent contract code on chain. That kind of puts the policies on chain. But then you have like a little bit more the retail case where the smart contracts would like to be more permanent.
01:18:39.308 - 01:19:03.376, Speaker A: And I think this is a more opinionated case where we went from single transaction to like permanent. And I think we can have both. And I don't think it's problematic to have both at this point. We can add everything, we can put the whole kitchen sink in there. But like everything we add may makes the proposal more complicated. And so now what we're proposing, this code reset, this has to add a new opcode. We have to deal with implementing this instruction.
01:19:03.376 - 01:19:27.350, Speaker A: And we can do these things. There's not theoretical reasons that we can't do them. It's just like everything that we do just adds more complexity. And I am one, trying to minimize the complexity of L1, as you heard with EOF. So I don't think that we need to add anything to 772. That's not absolutely critical. And two, I don't think that we should constrain the way that we design the L1 protocol to support business use cases that already exist out there.
01:19:27.350 - 01:20:23.150, Speaker A: We need to do the right thing for l one today and not care too much about the types of businesses that are already built around the things. Well, I think that that's one point of view. I'm not going to reply to the fact whether or not we should cater to businesses that exist today, but one thing that I wanted to point out is that the opcode is actually bringing back. It's more like a renaming of self destruct, actually. It's not realistically just adding a new opcode. We tried to actually make this proposal in a way that was a little bit more frictionless by bringing back self destruct with a code reset that is specific. Okay, yeah, I think we're not gonna, like, resolve this on this call.
01:20:23.150 - 01:21:15.940, Speaker A: We have the Discord channel to continue discussing it, and it seems like there might be other ways we want to modify the spec like Ansgar was mentioning. So I would just move this conversation back to the discord for the next couple weeks. And yeah, I think we don't even have Devnet one fully launched yet, which is still unlike an old spec f 7702. So yeah, let's keep discussing the spec async. And then, yeah, once we reach something and we're discussing in the future that nets we can figure out what we put in. Can I ask a quick question to this topic, especially on this comment that you made? It feels like the specs are still moving extremely. And why? You know, I'm a smart contract.
01:21:15.940 - 01:21:49.310, Speaker A: I come from the smart contract, smart account perspective. So I'm actually, I would be happy with these changes, but I'm more concerned about the timeline, actually. And for me, it's really like moving specs and changing the specs constantly makes it very hard to build tooling. And I mean, I have talking with Julian, I think it's two months now to get a test net up. Obviously, if we change the spec constantly, this doesn't make this easier. And it's very hard to reason about even how the current ip would turn out because nobody has a testnet. We cannot play with this at all in any form and don't know any implications really.
01:21:49.310 - 01:22:23.532, Speaker A: What is our timeline until when we really say, okay, for now, let's really first freeze the spec launch. Like maybe a devnet where we can play around, or testnet where we can play around it before we make further changes. It's very hard for me as an application developer. We have a devnet that's launching next week with, I believe, an old version of the spec. So we've effectively already done this. And then I think maybe the way to think about this is more from the client side. We do these devnets to find bugs and resolve issues.
01:22:23.532 - 01:23:39.056, Speaker A: So then when we ship devnet one, I imagine we'll find bugs, we'll find some issues, we'll fix them, we'll see whether or not it makes sense to fix them on devnet one or relaunch devnet two. And I think when we launch the next devnet, that's a logical point to look at what the spec is. And are there changes we want to bring in? Realistically, in a week we're going to have a 7702 version live on a Devnet with an old spec. And then, I don't know, a couple weeks after that, probably another Devnet. And whether or not we update the spec on that one I think depends on just do we feel like there's some thing that's stable enough at that point that we learn more by like changing implementations than we would by keeping the old version? And I know that's not like ideal in terms of just building tooling on it, but I think in terms of shipping the fork as a whole, that's probably the best we can do. And then, yeah, like Perry and Merus are pointing out in the chats, there's a bunch of ways we can launch local Devnet or just run dev branches that have specific commits or spec versions in. But yeah, for the Devnets as a whole, I think we have to consider the entire fork.
01:23:39.056 - 01:24:29.330, Speaker A: And then when we plan the next one, what's the state of 7702? And is there something we want to pull in? And then, yeah, have an old version of it live next week. Okay, so we only have eight minutes left. We did not get through nearly everything on the agenda. I think probably what makes the most sense is that for the three other proposals that were there. So basically the log system contracts, decoupling blobs, El and Cl, and then 7212 have the champion just give a quick update and then invite people to just review and discuss async. And I don't think you need to make a decision about any of those on today's call. Yeah.
01:24:29.330 - 01:25:04.660, Speaker A: So live client, you had the logs proposal for the system contracts. You have a pr for this? Yeah, I'm not the original proposer. PK was the original proposer, but we sort of said soft yes to this last all core devs. I just wanted to get a double check that for Devnet two. And going forward that we deploy the system contracts with the events. This is an event that happens whenever the user submits to the queue, not anything related to the system call. Got it, thanks.
01:25:04.660 - 01:26:00.880, Speaker A: And you post? Yeah, the pr was like a bit recent today, but what I push for is that if we can get people to review it async in the next week, and then on the next Cl call we can get it merged at the latest. That sounds good. Okay, next up, so Alex has a new Eip for Petra 7742. I don't know if Alex is on the call, but the idea is to decouple blobs. Decouple the blob, count on the El and Cl. And then yeah, have this just be a cl concern. Again, this is a pretty new proposal, so I think having teams review it in the next week and discussing it on the CL call makes sense.
01:26:00.880 - 01:27:26.910, Speaker A: I don't know if there's any quick comments on it. Okay, and then next up, so rip EIp 7212 Ulysses wrote a summary of the current state of things, I think. Yeah, so I think like Anzagar saying, there's like a couple of decisions to be made here. First is like do we want this on l one? And then second is like if we do what, you know, how do we approach it? I'm personally a bit skeptical of adding more stuff in Petra given we spent basically the entire call discussing in process spec changes about like the core things in the fork. But yes, I don't know. Ulyss, do you want to give a bit of context? And yeah, if anyone else wants to share their strong views on. Hello? Yes, yeah, first there were some debates around the EIp and rip stuff, and I want to firstly mention that the EIP documentation is outdated and we have migrated all things to an rip.
01:27:26.910 - 01:28:48.210, Speaker A: And last and final spec is there. And this final spec has been accepted by most of the rollups and already on the main net in most of them. So even if Pector is very complex hard work from now, but this proposal is already on Mainnet in some chains and if we want to add it to l one it will be easier as it's on mainnet for some chains and it's relatively small change. And we have nearly all of the client implementations which some of them are used on the roll ups. And I can mention some of the significant use cases about adding support for this elliptic curve. The first is we know the account abstraction, things are getting stronger and if we are adding more power for account abstraction, we need more signing methods. And if we don't allow using this curve in more efficient way, the account abstraction will be less powerful.
01:28:48.210 - 01:29:57.740, Speaker A: And this curve is supported by almost all of the device and native hardware. So I think it's important. And the second is ENS team is willing to support this elliptic curve to use for DNSSEC and verify web two domains. And I have read lots of documentations from lots of roll up teams including scroll Taiko and also flashbots. And they are using some trusted execution environments like SGX, and these environments only support this elliptic curve. And it's a proposal that can improve how they do remote attestations for different purposes, like some verifications for their mechanisms or private encrypted mapples. So I think that it's a very valuable proposal for also the l one and very easy to implement as it's a basic change and already in live by all of the roll ups.
01:29:57.740 - 01:31:09.198, Speaker A: Thanks. Yeah. Okay, we only have two minutes, I think. Any quick comments on this otherwise? Yeah, it seems like there'd be a ton of work on Devnet one and then eof and 7702 before we can consider other stuff. Marius, there was a counter proposal to it in the RP report, I think 7969 7696 which adds a generic verification pre compile. Apparently it's much more expensive. I don't know, I just wanted to select the scene that there is something as I would rather also do specific precompiles instead of a generic one because generics are never really used.
01:31:09.198 - 01:31:51.980, Speaker A: We did it with Blake two f and it's not used. So just. Just wanted to flag. Thanks. And okay, we only have 1 minute, but any updates on four? Four that people want to share or things that someone thinks we should look at outside of this call? Okay, guess not. Well, in that case, thanks everyone. Yeah, please review the like three last proposals we discussed, async and then.
01:31:51.980 - 01:32:12.504, Speaker A: Yeah, we'll discuss them further on the next calls. Any final comments, questions? Okay, well, yeah, thanks everyone. Talk to you all soon. Thank you. Thanks everyone. Bye. Thanks.
01:32:12.504 - 01:33:07.020, Speaker A: So, bye. Sadeena. Sadeena.
