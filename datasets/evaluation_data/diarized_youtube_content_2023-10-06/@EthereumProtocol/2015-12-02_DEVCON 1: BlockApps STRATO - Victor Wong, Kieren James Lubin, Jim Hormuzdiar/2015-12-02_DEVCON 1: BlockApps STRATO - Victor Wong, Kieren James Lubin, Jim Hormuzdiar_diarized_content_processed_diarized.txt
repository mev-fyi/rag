00:00:18.730 - 00:01:10.900, Speaker A: So I'm Victor Wong, one of the founders of Blockapps, and I'm here to introduce to the world Block app straddle on Microsoft Azure, the easiest way to build blockchain applications. You've seen this comparison made countless times. Bitcoin as a blockchain, we know is limited in functionality. And thanks to Vitalik and the work of the Ethereum foundation and Ethev, we now have a completely new global computing platform. But because of that, the success or failure of almost any computing platform is actually based on the number of applications that are being delivered on it. So block apps has a simple mission. We want to be the easiest way to build and deploy blockchain applications and businesses on the Ethereum platform.
00:01:10.900 - 00:02:09.242, Speaker A: We're the team behind the Ethereum Haskell implementation and we want to be able to provide the facility to easily deploy private blockchains, but also have these blockchains be able to communicate with the public blockchain. Lastly, we want to make sure that applications built on our platform can communicate with existing systems and devices. In a sense, what we want to provide is a bridge to the existing world with Ethereum. But here's the challenge. Now, many of you know all these terms, you know what this entire ecosystem is about, but I can tell you, when you show this slide to regular people, they are terrified. They have no idea about where to begin. Because truly the Ethereum ecosystem is not just one tool, but a series of interconnected technologies and tools.
00:02:09.242 - 00:02:57.590, Speaker A: And you have to understand the entire picture to really be able to maximize the use of it. So many people come to us and they say, well, where do I start? Where do I begin? And that's where blockap straddle comes in. Basically what blockap straddle is a full Ethereum blockchain as a service framework that gives you everything you need to start building blockchain applications today. That goes all the way from spinning up your own blockchain, a middleware API connector, wallets, faucets, everything you need to build and deploy applications. And we're going to show you a live coding demo by one of my co founders, Karen James Lubin, our chief data scientist. Gareth.
00:03:02.170 - 00:03:36.450, Speaker B: Thanks, Victor. Let me maximize this. So the first thing I'm going to do is actually launch a live instance of strato. It takes a minute to spin up and we've got network latency. Then I'm going to go into one of our demos. So we have to pick exactly what I'm going to code. I've got about five minutes to do it.
00:03:36.600 - 00:03:37.870, Speaker A: Can I make a suggestion?
00:03:37.950 - 00:03:38.530, Speaker B: Sure.
00:03:38.680 - 00:04:00.614, Speaker A: So, Karen, since we're partners with Microsoft now, I'd like you to change our revenue sharing agreement. So add Microsoft into our company and let them share part of the revenue. And I'd also like to make sure you have five minutes. Right, yeah. Make sure everything you write can run on any Internet connected device, including a mobile phone and any browser.
00:04:00.742 - 00:04:02.854, Speaker B: Okay, got it. Let me fire up the instance.
00:04:02.982 - 00:04:03.900, Speaker A: No problem.
00:04:05.070 - 00:04:49.030, Speaker B: All right, starting the deploy here. So this will all get listed on the marketplace soon, but this is the block apps login for the moment. Let's call this stratodev. All right, looks good. Let me go into the contract. So I'm about to show you a command line tool called block. These are the commands it supports.
00:04:49.030 - 00:05:17.410, Speaker B: And what I've set up here is a scaffolded blockchain application. Kind of looks like a web app. You can see we've got HTML, Javascript, CSS, an app, JS to run a web server. We've got a contracts folder. And in the contracts folder we've got some standard solidity contracts to get you up and running quickly. So let's take a look at what's there. A couple samples.
00:05:17.410 - 00:05:47.034, Speaker B: The payout contract is the contract that Blockapps has been working on. This encodes the revenue split or the ownership split between Victor, Jim and I. And we're going to cut Microsoft in in a moment. Let's look at our instance. Looks like it's almost ready. And show you the code. Okay, very simple.
00:05:47.034 - 00:06:32.730, Speaker B: Solidity contract, three addresses. Victor Gemini, ownership, distribution, a setup function in which we split the equity and a dividend. Let's see how we're doing here. It's almost ready. Okay, good. So now what I'm going to do, I'm going to cut Marley in. Let's give Marley the address with four c's.
00:06:32.730 - 00:06:54.190, Speaker B: And because he's been so kind to us, we're giving Marley 70% of blockouts.
00:06:56.050 - 00:06:57.520, Speaker A: We have to talk on.
00:07:01.670 - 00:07:34.560, Speaker B: Got to add a line here. Normally I don't roll over like that in negotiations, but. Okay, looks like we're good to go. I've set the URL up already. So what we're going to do now is compile this contract. It's a command called block compile. Okay, that looks good.
00:07:34.560 - 00:08:07.780, Speaker B: And let's go visit our web server. So if I type block, start this, launches a local web server, and we'll just see what our contract looks like. So that's a localhost 3000 and payout. So what block has done here is scaffolded a user interface for this contract. It's automatically generated and we can see that. Hey, we've compiled the contract, but I don't have a wallet yet and I still need to upload the contract. Make it bigger.
00:08:07.860 - 00:08:08.490, Speaker C: Yes.
00:08:10.220 - 00:08:40.640, Speaker B: So block is here to guide you through the process of creating an application. It will remind you about things like deploying contracts or when you need to upload a new version of your contract after it's been updated. Excuse me. Okay, so I'm going to go ahead and generate a key. Got network. There we go. Now I'm going to go upload this contract.
00:08:40.640 - 00:09:14.520, Speaker B: All right. And when I refresh this page, you see it has an address. Now type in the password in. We've got some data and storage. You can see these addresses have not been filled in because we haven't called the setup function just yet. I have about 1000 ether in the bank. The contract has zero ether, so I'm going to send the contract some ether and do the setup.
00:09:14.520 - 00:09:55.378, Speaker B: Okay, you can see that Marley now has an address, as does Victor Gemini, and the contract is ten ether. So here's Marley's address. There's nothing at it. This is actually what we want and I'm about to carry out the dividend. There we go. All right, so if I check this, Marley should have a balance now. And there it is.
00:09:55.378 - 00:10:11.302, Speaker B: It's in a way. You can see you got 70%. We should label those units a little bit better, but there we go. We didn't need any lawyers. We set up the revenue split. They're the back. They're the.
00:10:11.302 - 00:10:46.914, Speaker B: Ah, well, we let them in for this conference, not the next one anyway. So that's how you can get up and running in five minutes and build your first app with block on block apps. Ryan later will. Thank you. So block is a wrapper around block apps js, which is our every purpose JavaScript API. So blocked takes care of the scaffolding and the onboarding. But block apps js, you can drop into any project that you already have.
00:10:46.914 - 00:10:52.310, Speaker B: So maybe when you do something more complicated, you want to use blockapps js. Thanks, Victor.
00:10:58.570 - 00:10:59.560, Speaker C: Thank you.
00:11:06.310 - 00:11:56.454, Speaker A: So as you can see, Blockap Straddle is designed for very, very rapid deployment and development. Some of the key features are that it's designed for building customizable, private Ethereum compatible networks. You do rapid deployment on existing infrastructure like Azure, as Marley mentioned. Coming soon, the marketplace will be one click deployment. It has a restful API which is designed for integration with existing services and devices. And one thing is it scales easily from small private sandblocks deployments into multiple consortium deployments, and even elements of the public Ethereum blockchain. It's right once used on any network that you want.
00:11:56.454 - 00:12:12.170, Speaker A: And all of this is built on the technology we developed for the Ethereum Haskell implementation. And to talk about that, I'm going to introduce my other co founder, James Hermazdior, PhD and creator of SSL VPN. Thanks, Karen.
00:12:16.030 - 00:12:17.290, Speaker C: Thank you, Victor.
00:12:18.190 - 00:13:01.110, Speaker D: So about a year ago, Kieran actually contacted me, and I learned a little bit about Ethereum. And I became fascinated right away with Ethereum. And I went out and started reading everything about it, and I immediately wanted to dig in and understand how it worked. And for me, the natural choice of a language to use to work with Ethereum was Haskell. I've been using Haskell for about five years now, and it's over that time become my favorite language. It's got a lot of features that are extremely nice. First of all, as you heard yesterday, Haskell is a functional programming language.
00:13:01.110 - 00:13:42.070, Speaker D: And the thing about a functional programming language is that the specification is the executable. The code that you write with Haskell looks a lot like the description of the code that you are writing. Second of all, it's one of the most strongly statically typed languages that exists. So generally speaking, if it compiles, it's correct. And I've had many experiences over the last year where I've had to make changes to the code, and I've spent hours ripping it apart, rewriting it. And I'm generally very surprised. At the end of the day, once it compiles, it tends to come up and it just works without bugs.
00:13:42.070 - 00:13:55.354, Speaker D: And third of all, it's very performant language. So when you compile Haskell, it compiles to native executables. And if you write your Haskell code properly, it can run as fast as.
00:13:55.392 - 00:13:55.980, Speaker C: C.
00:13:58.350 - 00:14:53.882, Speaker D: Generally speaking, if you want to write something and you just want to make sure that it works and it works fast, Haskell is your language. And it's been, as you can see here, we put a few examples of companies that have been using it in the last few years. Let me talk just a moment about the architecture of Strato. So Strato, as you can see from the beginning, we wrote Strato to be fully modularized. And in the center we have a SQL database, and around that SQL database we have many pluggable modules. For instance, the VM itself is just one process that runs, and it connects grabs the data out of the database and processes it. We have all of our communication to the outside world, our separate pluggable modules, we have analytics that are occurring, so forth.
00:14:53.882 - 00:15:13.640, Speaker D: But the important thing here was we put SQL in the middle, and we chose that deliberately because we wanted Strato to be an architecture that would plug right into existing enterprise environments today. Thank you very much.
00:15:20.250 - 00:16:06.354, Speaker A: So one thing about Strato and the Ethereum architecture that we've chosen that Jim has created is because of its modular nature. It's actually completely compatible with many of the existing Ethereum tools. You can spin up a private network and also connect it to a guest node or C node. You can use front end tools that are being developed all over by the community, such as Ethercamp, truffle and embark. So really when you use straddle, you're not restricted to only our tool set. Now, the one thing is, in order to really get Ethereum applications created, simply having the technology is not enough. Education is a big piece of the puzzle.
00:16:06.354 - 00:16:59.918, Speaker A: And in order to accomplish that, we've been holding a bunch of workshops. We call them zero to blockchain app, where you come in for a couple hours, you start playing around with the tools, and you walk out having built your first blockchain app. In addition, we've been actively involved in a series of hackathons co sponsored by consensus and Ethercamp. And without our prompting, it seems that our tools have now gotten picked up by other developers who found it's a very easy way to build a blockchain application. In fact, the recent winner of the rise, Barclays hackathon won using block app straddle. And here's the thing, he had never looked at a single line of solidity before that hackathon. So what we're trying to do is essentially provide a complete solution with Microsoft.
00:16:59.918 - 00:17:35.520, Speaker A: We now have one click deployment on the Microsoft Azure cloud. We're providing hands on workshops and education efforts to make sure people can use these tools. And lastly, with our parent company, Consensus enterprise, we're helping companies figure out how to build and use these technologies in the long term. This is our team. Come look for this t shirt. We are very friendly and open. We'd love to talk to you about how to use our tools and how to make our tools interoperate with whatever you're doing.
00:17:35.520 - 00:17:51.810, Speaker A: So the key message of all of this is this isn't about the future, this is about today. What can we start building right now? Thank you very much. Thank you, Victor.
00:17:57.290 - 00:17:57.702, Speaker C: Yeah.
00:17:57.756 - 00:17:59.560, Speaker A: Okay. Right, you're up.
00:18:03.790 - 00:18:04.700, Speaker C: We have.
00:18:06.830 - 00:18:10.090, Speaker A: And a limited amount of lockout.
00:18:12.450 - 00:19:34.220, Speaker C: I don't need audio, so my Google calendar wants me to know that I have a yes. Thank you, Google. Okay, so I'm Ryan Reich. I'm the author of the Blockapps JS JavaScript library. Blockapps JS connects Ethereum to the web block apps itself, as Jim just told you, exposes Ethereum as a database using our restful API. You can query any number of aspects of Ethereum, both by native metadata and by metadata that you can only extract by having run those transactions. You can query blocks, transactions, accounts, or account storage, and you can query those transactions by such features as what accounts have changed in them and other such things that might be of interest as analytics.
00:19:34.220 - 00:20:46.336, Speaker C: Blockapps JS builds upon this API by wrapping it in high level JavaScript. In fact, it supports solidity very transparently. It wraps solidity contracts in JavaScript objects, thus realizing the programmatic structure of a solidity program as the programmatic structure in JavaScript, so that you can easily integrate it into an application. Since any network communication necessarily is asynchronous, BlockfJs uses a popular promise library bluebird to make your interaction with this asynchronous activity powerful and comfortable. Nope, there we go, not done yet. So let us now take a look at something that you might write with lockups JS. So this is a little bit too expanded here.
00:20:46.336 - 00:21:08.776, Speaker C: We are still large enough to see. Hopefully the color scheme isn't too dark, is it too dark? All right, well, I'm going to just attempt to power through this anyway, because select what?
00:21:08.878 - 00:21:09.930, Speaker A: Select all.
00:21:12.880 - 00:22:16.256, Speaker C: Very good. Okay, so this is the HTML portion of adapt that you might write with blockfjs. It's very simple and it just produces a little interface that looks like that, just a box with a couple fields you can fill in. You'll notice that it's fetching its JavaScript from the Strato dev address. This is a azure instance that we started up for ourselves where Strato is always running and this library is available. All that happens when you open this page is that it runs a function and waits for you to push the button. All right, so the code, the solidity contract that is behind this, behind this application is a simple crowdsourcing thing.
00:22:16.256 - 00:23:02.504, Speaker C: Basically people can submit their names, a little bit of ether, and they can get contributed to the contract. And after a certain point you can just decide to pay it out. So this is not intended to be clever, it's just intended to be instructive. You'll notice that little way down. I have this set profile option. This is one of the features of blockfjs that makes it easy to use different blockchains or different strato nodes. We have at the very least a strato live node in addition to a Strato dev node, and that is running rather than a sandboxed blockchain, a live Ethereum blockchain.
00:23:02.504 - 00:23:59.872, Speaker C: And by simply changing the word let me just dev to live, I could make it run on the live network. Now it wouldn't be wise, because I have decided to use an address that has no ether, and I've also put its public key up on the screen, so it better not have any ether. But if I had architected this just a little bit more carefully, then just by making that one change, it would in fact be a real daP. So blockfjs has a number of modules. It has a solidity module for one thing, and that's the module you're going to be using the most often. It has some basic support for Ethereum concepts below solidity, but in fact solidity just abstracts all of them to a higher level. So for the most part you're just going to be using that.
00:23:59.872 - 00:24:38.060, Speaker C: However, as you'll notice in Kieran's contract, you can sometimes find yourself submitting values in whey when you really meant to submit them in ether. So you can in fact convert them back and forth pretty easily with the units module. This faucet thing is a testing facility. Like I said, this address has no real ether on it, but on the Testnet Strato dev, it doesn't need ether. Or rather it does need ether, but it doesn't need real ether. But we need to give it something so that the VM will work. The faucet just supplies any address I want with 1000 fake ether.
00:24:38.060 - 00:25:56.500, Speaker C: So let's change that back to Stratodev so that I don't accidentally try to spend something I don't have. All right, so let's go down and look at this code. So what's going on here is that it remembers the address of the individual who you are benefiting with your contributions, as well as various information about the people who have paid. As you can see, this is a fairly complex solidity structure. It's a mapping from addresses to a user defined struct. And the blockfsjs library actually does support interpreting the values of even such a complex object. It reads the storage, it interprets the structure of this solidity code, and it figures out what of the hexadecimal nonsense that lives in the Ethereum storage corresponds to the values you meant to put in there, and it converts them into javascript types so you don't have to worry about any of the implementation details of Ethereum.
00:25:56.500 - 00:27:11.180, Speaker C: When you are working with lockfjs, it does as much as possible to take care of them for you. So when you create this contract, all it will do is store the name or the address rather, of the person who's supposed to get the money. It also initializes that array of contributors, and then when you contribute, all right, so when you contribute it, well, it does a little check to see if you haven't given anything, but otherwise it simply adds the contributor to the end of the array and adds the value to the struct corresponding to that contributor which lives in the mapping. Then, and then it tells you that the transaction succeeded. So if I were to try to give some ether to that right now, say myself, ten ether, then you would expect to see something pop up. And it does in fact pop up. I've been thanked generously for giving ten ether to this person.
00:27:11.180 - 00:27:53.592, Speaker C: So how did that happen exactly? This is where blockapps JS actually does its work. So at the beginning of this app, before I even came here, I loaded this page and it created that contract. All I did was I took that code, I plugged it into the solidity module, and I called the new contract method. Since most of these operations are asynchronous, the call looks a little strange. You would expect it to be a member function, and it is, but is a member function of the return value of a promise. So I'm using some promise syntax for that. And all it does is it creates a contract and saves that contract in the page for later reference.
00:27:53.592 - 00:28:33.146, Speaker C: And it also activates that button, since there was no error. I don't care about the other function. Now, when I pushed that button, it went through a long chain of promise operations, the beginning of which was to run this function, which I've called patronize. Maybe I should have called it contribute. So let's look at how that works. That's based on these three functions. So the core piece of functionality is the second function there, patronize, which takes a name and a value for things that appeared in those boxes.
00:28:33.146 - 00:29:26.074, Speaker C: So all it does is it takes that contract object, which is perhaps not creatively called contract looks in its state, which is a sub object which is automatically created by the library. And in there it finds a method called contribute. And if you remember back at the solidity code, that was the method in the solidity code, it's named the same thing, and it's only natural that it should in fact be a function object in JavaScript. So that thing takes a variable which is the same argument as it would take in solidity. And I can also specify that it sends some other stuff in the transaction parameters. Tx params I can specify a value which you'll notice that I've specified in ether, and it's pretty clear that I meant to specify it in ether from the syntax. I could also have said gas price or gas limit if I wanted to, but I don't, particularly because those are implementation details.
00:29:26.074 - 00:30:41.160, Speaker C: And the profile back up at the top, which was set to stratodev, also has somewhat permissive defaults in the case of stratodev, and in the case of strato live somewhat less permissive defaults that seem compatible with the existing ethereum clients geth and c, so that the transaction will likely be accepted and you don't have to worry about it unless you're really concerned with the fine print. After I've set all that up, I just call it from, well, something I need a private key. And the private key in this case is just being created on the fly from a library, from a wallet that I have spun up in the page. This is not a very secure wallet. It just every name it takes, it randomly generates an address for it, and then with the fund function at the top of the screen, it applies the faucet to that address and gives it 1000 ether. Once it has the address, it has the private key also, and it just sends that into the patronize function and submits the transaction. And that was what you saw happen here.
00:30:41.160 - 00:31:42.486, Speaker C: Of course, what you haven't seen yet is actually obtaining the values that are printed. There aren't very many values, but something had to be done to get them. So this is where the placard is printed, this is where the contents of the contract are interpreted by blockapps js. If you remember, the contract had a recipient who was the creator of the contract, a number of contributors, and an array of contributor addresses, as well as a mapping of contributor data. So I've done a little bit of functional style coding to extract the information from the contributors there. What I did was I happened to know that the contribo member of the contract, remember that was a mapping in the solidity contract. And a mapping is nothing other than a function from its keys to its values.
00:31:42.486 - 00:32:41.180, Speaker C: And that's how mappings are represented in blockfjs. So I just took this function and I applied it to each member of the contributor's array whose elements are addresses. And that turns the array of addresses into array of objects containing the contributor information that was put in there when the contract was invoked. And after I've obtained all of those things, I join the contracts with the function that uses their values. And in this case, it just takes the recipient, the contributor, the number of contributions, and the information of all the contributors, and prints out a number of lines explaining what exactly was in all of that. Well, you can see the results up here. I don't need to go through the, the user interface formatting that goes into that easily the least interesting part of any program, writing text to output something I could give more.
00:32:41.180 - 00:32:59.250, Speaker C: Turns out that I really like this guy. I'm going to give five more ether. So I contribute once again, and now I've given 15. My brother Doug, who makes more money than I do, wants to give 20. He makes more money because he works at a bank.
00:33:01.430 - 00:33:02.370, Speaker A: For now.
00:33:02.520 - 00:33:37.280, Speaker C: Yeah, soon I hope I will be the one making more money. So Doug has given 20. And so let's close off this little round of crowdsourcing and pay the guy, whoever that guy is. So pay the recipient. Turns out he raised 35 ether. And what actually happened when I did that is I had a final method in the contract. Let me just sort of scroll back up to the source code so I can point that out to you, because it was very small.
00:33:37.280 - 00:34:42.340, Speaker C: Payout suicides the contract, it closes it out and pays all the money to the recipient. And way down here, the payout button just invokes the payout function, calls it from the private key, and that function invocation returns a value, but in this case it doesn't return anything. So in contract language, I just replace the return value with what I want to see, which is the balance of the contract, and then I format a line that displays it. So as you can see, this is the same basic operation that you witnessed with Kieran's example in Strato, but more customized. Strato has your scaffolded page already for you. With blockapps js, you'll want to write your HTML yourself. Or if you start with your Strato page, you can tweak it a little bit.
00:34:42.340 - 00:35:28.080, Speaker C: And knowing how blockaps JS works, you can add more functionality than simply showing the storage contents of the address you're working with. BlockfJs is the power user's inroads to connecting Ethereum to the web. Anything you can do with solidity, you can benefit from in your application by running this library. So let's go back to this slide and press spacebar. Again, thank you for perceiving this presentation. We're happy to give this technology to you to enjoy and to build wonderful Ethereum apps with.
