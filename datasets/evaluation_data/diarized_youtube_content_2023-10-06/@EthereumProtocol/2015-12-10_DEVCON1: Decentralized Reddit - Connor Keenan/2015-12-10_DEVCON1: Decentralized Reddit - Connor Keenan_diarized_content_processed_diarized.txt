00:00:19.020 - 00:00:51.340, Speaker A: Hello. My name is Connor and I am a developer at consensus. I've been working on a a platform for having threaded discussions that are difficult to censor. They are built using Ethereum, ipfs and Whisper. And the first part of my talk, I'm going to explain how you could use this as a foundation for building a decentralized Reddit. Really like an ecosystem more than like one particular app. And later I'll give a demo and explain some more technical details.
00:00:51.340 - 00:01:59.968, Speaker A: So the working title right now is nonsense, like not easy to censor. And why would we want a decentralized Reddit? So many people here probably venture into the r bitcoin sometimes and have noticed that generally the moderators receive a lot of heat for questionable moderation policies. And I personally noticed that as the community grew during the rise of bitcoin, that the quality of the content on the site actually suffered more and more due to the moderators expressing their own agendas. So this even applies to people who are deeply involved in the bitcoin space. We're not being able to voice their own opinions, so that's one reason. But that same thing applies to pretty much any open public online forum. You can see the same ways that companies or investors or corporations or organizations with legal agendas may censor certain voices on the Internet.
00:01:59.968 - 00:03:15.548, Speaker A: And I think that we should change the paradigm and look for ways to have censorship to be hard by default. So how could you do this? On Ethereum, what I've built uses the middle pieces, ipfs, whisper, and Ethereum to structure a very basic threaded discussion system. But one of the benefits of building on a public blockchain. Julian alluded to this earlier in the game panel, the game developer panel, that on Ethereum, it's unrestricted for any third party to build services on top of content that is on the blockchain or on. So that is one way I could definitely see a Reddit type of ecosystem developing, serving all of these pieces, permissions, moderation, notification, search, and so on, are currently done by the centralized Reddit or Facebook or Twitter organizations. And on ethereum, we can actually have competing services in each of those areas offering different services for a discussion platform. So the colors mean, just briefly, that the blue is like stuff that has to be on chain and trustless and you have to pay for it.
00:03:15.548 - 00:03:45.796, Speaker A: But the purple is a combination of on chain and or off chain or both. And ipfs warm whisper notifications are off chain services that could be provided. So that's how I see that evolving. I'll go ahead and talk about what I built and how on chain storage works. So there's two ways you could do this. One is with contract structs that we all know and love. The other way is logs, and I'll describe the trade offs between those.
00:03:45.796 - 00:04:29.940, Speaker A: So for onchain storage, basically there's two methods that are important. Add and edit. When you add a post, you are designating a parent that that post will be referenced to as a child, and a string of data which could be anything. I like using strings there because they could be a IPFS hash, a URL, or potentially just raw text. So then that will create a struct which will be saved in this array right here. It just expands with each new post, and that index of the array is implicitly the id of the post which is used in this mapping of posts to children. And edit is a method I wanted to add.
00:04:29.940 - 00:05:04.796, Speaker A: So if you submit a post, you can edit the content of it if you are the owner. And so that is checked from this address and I'll go through the other data types. So we have two uns for timestamps for when the post is created and when it is edited. We also have a number of children, which makes lookups easy. If you're looking up an array, you would like to know how big it is. You don't want to look up ten if there's only two objects in the children, and then the data type. So just to point out something, I wanted to cast these to un 32s.
00:05:04.796 - 00:05:43.704, Speaker A: They're uns as environment variables to contracts, and it would make sense to store timestamps as uns, and I was able to save a storage slot by doing that, but it does limit me to 90 years. So maybe you'd want to go with un 40s, but that's worth considering if you're a developer. Also. Yeah, I already mentioned data strings are very flexible. So what's the upside of events? Why would you use events instead of structs? Events are much cheaper, they require a lot less gas to use. They're append only logs. And the other upside is that they're very light, client friendly.
00:05:43.704 - 00:06:35.980, Speaker A: So the downside of using a log though is that they're more difficult to edit. So with the struct for posts, you store the owner in one of the fields and the contract can look that up and verify that only the meshed sender that equals that owner can actually change the data. But for a post event or log, the contract doesn't have any way to read the data from past logs. So it can't verify that the meshed sender is equal to the owner of a particular log. So what you can do maybe to get around this is have an event for editing and let the front end filter through the edits to find the ones where the owner matches the original log id. But that seems a little bit annoying and it just kind of depends, I guess, on what your use case is. If you're an application that doesn't want to allow edits, then logs would probably be the way to go.
00:06:35.980 - 00:07:33.256, Speaker A: If you do want to allow them, you may have to consider the trade offs there. Post count is necessary here so that each event would have its own id. Right, and those are the gas costs trade offs for logs versus s stores, where each log is 375 plus 375 per topic, which I think you can go to three or four topics and then eight gas per byte. All right, so I'll show you a very alpha demo of what I've built so far. This is a video, so we'll start by adding a couple of accounts that I already generated with these seeds that I was able to get using coworker Christian Lundquist library Eth Lite Wallet. So this is how you would create one in the app, but I'll just go ahead and import an existing one. These seeds have been preloaded with some ether.
00:07:33.256 - 00:08:15.816, Speaker A: I'll add a password to encrypt them in my browser so I can unencrypt them when I need to sign transactions. And you can see my initials ck under the accounts comes from the uport Persona schema that saved in ipfs. I use that to associate names and images with ether addresses. So we'll add the second account to demonstrate one without a Persona, and you'll see that in the next videos. So that is adding an account. And this is the identity schema for the uport where we have name and content URL are really the important fields there. But this is cool because it's just a json.
00:08:15.816 - 00:08:24.240, Speaker A: So you could add other schemas for different use cases and they could all be derived from the same ether address. So now I'll create a couple of threads.
00:08:27.620 - 00:08:27.984, Speaker B: Right?
00:08:28.022 - 00:08:51.956, Speaker A: So I'll use my named account and enter in a thread name. This is going to use a string data type. So I found the exact gas cost per character count on the right. You'll see that transaction price increases with each character that I add. So this is going to be half a cent. And I'll make a random one and a meta one. And this bubble on the left means that the transaction is pending.
00:08:51.956 - 00:09:38.296, Speaker A: It hasn't been received in a block. Real quick I'll do a refresh on the browser just to prove that I keep that data around associated with the transaction before it gets received in a block. So that tends to be something that users like to do when they don't understand what's going on. They'll refresh the page. And if it's just blank because the data is not on chain yet, then I wanted to prevent that scenario so it'll get received. And I have another method that you can use to wrap components that use that mechanism for tracking state to determine based on the current block which they'll receive as it updates, what the percentage of confirmation is given, some confirmed count. So this will increment up to the height of the div and I'll just skip through.
00:09:38.296 - 00:10:26.772, Speaker A: So this is that utility I mentioned. It's a way to keep track of transaction state. You add transaction hashes and you associate some data with those hashes and you can filter through that data to match those transactions to components on your front end and select receive any updates from these states from transactions that match that filter. So for this I'm just using pending and received, but the arrows indicate the different directions that those transitions can happen and that's been really helpful. So let's do some chat and comment example. So we'll go into the random thread and with the CK account we'll write some. Yeah, so this is 0.7
00:10:26.772 - 00:11:04.372, Speaker A: cents at current cost. So yeah, first post, sign the transaction and it will do the same thing. And you see a picture that's associated with that account there. And now we're going to send a whisper message while that's waiting to get received in a block because this is much faster and it's free. So some people might find a use for that if they don't have any ether or don't want their message to live forever. So I'll demonstrate how this wYSIWYg editor can throw in some arbitrary HTML that my front end will sanitize when it picks it up. And I'll also add an array of files, just one for this demo.
00:11:04.372 - 00:11:38.520, Speaker A: But you can add multiple, you can rename the file name, add a description to the moon. You actually also sign these whisper messages with your same light wallet accounts so that signature gets appended to the payload so the front end can derive the ether address of the sender. Otherwise it's stored on the client. It's not really usable for these types of apps. So I switch accounts, I'm going to reply, very cool. I'm going to save this. And you see how there's a jdentacon associated with that because it doesn't have a Persona.
00:11:38.520 - 00:12:34.524, Speaker A: And I just saved the other accounts whisper message into iPfest and stored that ipfest hash on chain and the front end was able to figure that out that this was a whisper object, looks at the signature, drives the sender address and uses CK as the sender of that comment, even though three owner of that post object. So offer a thank you. And that's pretty much the meat of this. The rest is I'll just go through and show that you can chat and comment on any of these on chain posts or whisper messages. So we'll move on. This is a schema of the ipfs content that I saved. Pretty straightforward, just an HTML string and an array of file descriptions and IPFS hashes.
00:12:34.524 - 00:13:18.648, Speaker A: And then on the right is the whisper object that I've modified a little bit with the signature recovery param and the hash. The topic that I use for Whisper is a hash of the contract address and the post id that you're whispering to. And these are the libraries that I use that were really helpful for me. Obviously web three, the IPFS teams node, IPFs API exposes pretty much every ipfs command to HTP. So that was really helpful. Hooked web three provider Tim Coulter wrote, so super easy way to sign transactions in your browser. Eth light wallet is what Christian wrote, and that's a key store and key manager for signing transactions.
00:13:18.648 - 00:13:41.830, Speaker A: That and hooked web three go really easy together. And then finally, reflex TX is the transaction manager I wrote. So that's all. If there are any questions, I have a few minutes. Two minutes. Yeah, we have time for one question.
00:13:49.500 - 00:14:15.730, Speaker B: So I think one of the bigger problems with Reddit and any thread is the matter of how do you get reputation, how do you count karma or in any sort of system on how do you fight spam while keeping good content on the top? How do you plan to solve that in a system without having single user, single person?
00:14:16.900 - 00:14:37.460, Speaker A: Yeah, so I think that is a really hard problem and I don't claim to know the answer, but I think that we should, all, anybody interested should try to build something like that, and I'd advocate using some of these tools to do so. I'll also be working on that. Unfortunately, we do not have any more time for questions. Thank you so. And your defense.
