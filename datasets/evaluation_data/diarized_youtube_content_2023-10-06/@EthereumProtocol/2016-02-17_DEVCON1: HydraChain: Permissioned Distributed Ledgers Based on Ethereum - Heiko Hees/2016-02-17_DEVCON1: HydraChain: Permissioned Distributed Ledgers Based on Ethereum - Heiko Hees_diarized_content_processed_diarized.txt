00:00:22.170 - 00:01:21.250, Speaker A: I want to tell you about hybrid chain, which is, it's permissioned shared ledger based on an ethereum. So what's that? It's basically an extension to the Python Ethereum client. So it shares say 90% of the code base, and it's really an extension, not a fork. And it's also licensed under the MIT license. So I will walk you through some features it adds. And the main use cases are private chain settings consortium chains connecting multiple chains, and it's also good for testing and prototyping. So why would you do that? I've been working with clients from the financial industry since March this year, and they basically had reoccurring requirements which we do not fulfill with the stock clients.
00:01:21.250 - 00:02:24.966, Speaker A: So that's mostly compliance issues. They want to know who proposes the plots and brings the transactions in order, and they want to support that. Only registered users can have transactions on that chain. They are happy if they get transaction finality without waiting for a certain number of blocks. They all want scalability, and transaction privacy is also an issue. So what we did is we swapped out the consensus protocol for something which is pretty standard in distributed systems called byzantine fault tolerant protocol, and it's based on validators signing blocks which they validated. So that's no economic consensus, but a consensus which requires that you have agreements with those which participate in the network.
00:02:24.966 - 00:03:11.222, Speaker A: Good thing about this is that you will not have forks, and therefore you can have instant finality. So if you send in a transaction, just wait for the next block to be mined or to be proposed and validated, and then you can be sure that this transaction is really in the state and won't get reverted. So what are the validators here then? They can be legally accountable because you should have agreements with them. You would add them to a set of chosen validators, and only these participants are allowed to sign blocks. And also from the validators. From the set of validators, the proposer of the next block is chosen. We do it in like a round robin fashion.
00:03:11.222 - 00:04:10.560, Speaker A: We know for every block height which should be the proposer, we should also know who should be the first, 2nd, 3rd, backup proposals. Every node knows this, and proposed block is acceptable if there's two third, if there's signatures from the set of two third of the eligible validators for a block. So an important feature here is they must not double vote. If they double vote, consensus might break, might break, so therefore the system would just stop. And that's something in order to ensure that you would have to kind of punish them out of band by maybe having agreements, service level agreements, that they should behave well. The set of validators can be managed in a contract, so you can also implement sheems to update the set of validators if you want to. Onboard new participants, for example.
00:04:10.560 - 00:05:00.060, Speaker A: Yeah, and for the implementation it was really easy. We just swapped out the east wire protocol for what we call the hydrochain wire protocol, which adds messages for proposals, votes and Lockstead. So Lockstead is a detail and we also disabled proof of work checks. Then we basically got what we wanted. One difference here is that blocks are only created if director pending transactions, otherwise there's no need to create new blocks. The implementation for this part of hydrogen is around 2000 lines of code, so not too much. And maybe the other clients will implement something similar.
00:05:00.060 - 00:06:04.750, Speaker A: There's an in detailed explanation of this on GitHub. So another thing was know your customer compliance. So we call this proof of identity. That is, we only want you allow participants to transact if they are registered with the system. And therefore we have something called registrars, which can add users to the system, which allows us to, in case of a suspicious transaction, to trace back coming from the account to the registrar to the identity. So with the account with the address, you could ask the registrar, or you could resolve the registrar and ask the registrar, please reveal the identity behind this transaction. And registrars can be cascaded, so a registrar can add sub registrars.
00:06:04.750 - 00:07:14.646, Speaker A: And one important thing is that if you come from different jurisdictions, for example, you might have different compliance requirements, and therefore registers could also specify with which other registrars they are compatible. And we could enforce that only transactions between participants which are signed up as compatible registers go through. Again, implementation, it's a mapping between accounts and a register, and sub registers to registers. And then we have like a hook in what is apply message, a code base. And then we simply check is transaction center registered? We would also check is transaction center and message two even for sub calls compatible or are they both registered with compatible registrars? It's pretty simple. That's something that without too much effort could be implemented in all the other clients too. Then we have something called native contracts.
00:07:14.646 - 00:08:12.420, Speaker A: Native contracts is an extension which allows to write contracts in Python code. So the advantages here are that native execution of code is faster than using the EVM. It's really easy to develop contracts because it integrates well with your development tools and testing tools. And those contracts are compatible with EVM based contracts. So contracts, for example, which you develop in solidity or certain language well use cases could also be restrictive environments where you do not want to allow the participants to create contracts, but just want to support certain features like feature chains. So obviously there's a limitation. This will not be compatible with the public chain.
00:08:12.420 - 00:08:47.600, Speaker A: You cannot deploy these contracts on the public chain because all the clients which participate need to have the same contracts deployed. It comes to be kind of part of the node. Think of it like add ons or plugins. That's how it looks like. Not too surprising just how Python code looks and how contracts look. Here we also support the ABI last time. Here you can see that you can also print the ABI and just copy and paste it to your javascript.
00:08:47.600 - 00:10:05.600, Speaker A: Something else is multi chains. We support that you can instantiate multiple chains in one client, or say rather in one process. So from if you have complicated setups where you want to bridge together multiple chains, that would not be deployment help, maybe just a bit complicated configuration, and you can use it for sharding, either for scalability or for privacy. And you can interact between those chains by using something called the atomic crosschain asset transfer protocol, which is nothing special to Ethereum, but can basically work with most blockchain systems. And next slide, we have some examples how that could look like for example, you could have a process or a node which connects to the public chain as well as to one private chain. Or you could have node which connects to multiple private chains. Or you could have for example a setup of the consortium chain, and additionally to the chain where they all meet.
00:10:05.600 - 00:10:53.490, Speaker A: You could have private chains between each of them in any combination, so they can hide their secret transactions. And the setups are basically unlimited. So come up with your idea how you need to chain chains and it's possibly possible. Okay, scalability and transaction privacy can be more important. I had a talk on Monday where I talked about the raiden network. So that's the next step that we want to do what we want to add to the system in order to really scale out asset transfers, as well as supporting a better transaction privacy. But this is work in.
00:10:53.490 - 00:11:41.170, Speaker A: Yeah, that said, well, many features are added to the stock clients. It's compatible on the EVM level, it supports the same languages, high level languages, it supports the same bytecode, the API is the same. You can also use the stock web3 js, and there's some nice additions through web3 js they now support also to have multiple connections, because if you run a multichain setup, you will get for example, multiple JSON RPC ports. And now in the latest version, I think web3 js supports that you have multiple connections within javascript. Okay. You can also reuse all the development and deployment frameworks. So basically most of the ecosystem of Ethereum can be used.
00:11:41.170 - 00:12:28.200, Speaker A: What compatibility is missing is at the wire protocol side. The consensus protocol is different. And as I told you, native contracts will not work. But you can have multi chains where you, as I've shown you before, you can connect to the public chain and have your specialized private chain all in the same process. Something that works. Yeah, you can download it from GitHub and it should work out of the box with the default configuration. We also have docker files for easy chain setups with multiple validators.
00:12:28.200 - 00:12:36.110, Speaker A: Like you would have maybe three or ten nodes in your docker. That's it.
00:12:52.120 - 00:13:00.010, Speaker B: Maybe it's hard for you as an author of hydrogen, but how would you compare yourself with what Eris Industries build?
00:13:00.700 - 00:13:01.208, Speaker A: Sorry?
00:13:01.294 - 00:13:04.570, Speaker B: How would you compare yourself with what Eris Industries build?
00:13:05.840 - 00:13:19.330, Speaker A: I think that's pretty similar. I don't know if they are still on Ethereum or if they build it on some different platform, but I think use cases are similar.
00:13:21.380 - 00:13:21.936, Speaker C: Great.
00:13:22.038 - 00:13:25.170, Speaker D: Next question. Costa's got it.
00:13:29.060 - 00:13:59.660, Speaker E: I have, I guess, a two part question. Is there a reason why you specifically chose the Python client rather than any other one for this? And the second question is, how do you guys feel about, for example, there's a whole bunch of changes in the core Ethereum and the way it works? Do you guys plan on continuing to integrate sort of like components of the Ethereum main chain into this client? Because you mentioned that it's an extension, so the idea is that over time you would support the core implementation.
00:14:01.120 - 00:14:34.330, Speaker A: Yeah. First question, why Python? That's because I'm one of the Python developers, and it's also a good choice because it's easy to extend it and to prototype. And for your other question, the question was if hydrochain would support new features which come to the other clients. Yes, because just swaps out the wire protocol and otherwise for EVM and how we evaluate blocks and the communication player. That's all the same.
00:14:38.860 - 00:15:17.728, Speaker F: So I have a question about how you imagine that this will be used in the case of a private consortium where you have maybe a financial institution and you have assets being used in this private network, do you think that would be set up over the Internet or in a private inaccessible network? And if it's over the Internet, does it have the same level of security from different kind of attackers that should not be able to interact on this network?
00:15:17.824 - 00:16:29.850, Speaker A: Yeah. So we have in the clients, we have strong encryption. Alex gave a presentation on the RPX protocol, so there is strong encryption in it. The question is, if you want to really early, also on the network layer, prevent that certain non registered nodes are connecting those clients. So that's something that could be added. It's currently not in it, but you could also solve this using standard networking tools to lock ports and only use whatever. But to extend on your question, the question is, shouldn't the banks run like really permissioned public chains, which preserve some of the permissionless potential that we can have as blockchains, like for example, have validators and have registered users, but basically allow them to do whatever they want to do because they probably will play by the rules because you can always reveal their identity in case if something goes wrong.
00:16:34.410 - 00:16:56.880, Speaker C: Okay, writing contracts in Python is not compatible with the Ethereum public blockchain. How much would it take to make it compatible? And you had a point about you could use the private and public blockchain, but I wasn't seeing how that might be able to help together.
00:17:00.770 - 00:17:40.180, Speaker A: So the Python code, you saw that it's simply loaded as a module directly in the client, so it's not compiled to EVM byte code. So therefore there's probably no way to have this feature in the other client implementations. Go could have go language native contracts and c plus could have c code, native language extension, but probably not a python one. And for the other question, public private, how that works?
00:17:40.790 - 00:17:50.710, Speaker C: No. Is there a way to get the public private thing here able to help when you're writing the contract in python?
00:17:52.170 - 00:17:58.950, Speaker A: So in the upper left setup, you could have native contracts for the private chain, but not for the public chain?
00:17:59.870 - 00:18:02.540, Speaker C: Yeah, that's right. Is there any way to.
00:18:04.270 - 00:18:04.666, Speaker A: Be able.
00:18:04.688 - 00:18:14.750, Speaker C: To use this configuration to help the contract that you wrote in the private chain also interact with the public blockchain?
00:18:15.330 - 00:18:42.870, Speaker A: Well, not directly. So this contract on the public chain could maybe help to lock some tokens which could then be unlocked on the public chain and the other way around for your use case, for example, what you can do is it's easy to bridge or to listen to both chains and mediate between them. Cool.
00:18:42.940 - 00:18:45.240, Speaker D: Okay, we've got time for one more quick question.
00:18:49.850 - 00:19:01.770, Speaker G: How does the atomic cross chain asset transfer work in hydrochain? Could you tell us a little bit about your implementation and kind of what's involved in leveraging that feature in your contracts?
00:19:02.450 - 00:19:16.750, Speaker A: So this is not actual an implementation in hydrochain, but it's a protocol, what you say. So you have to implement that yourself if you want to have that, how to do that?
00:19:16.900 - 00:19:22.640, Speaker G: Well, yeah, that was my question is, do you have an implementation or is it something that we implement on our own?
00:19:23.250 - 00:19:33.974, Speaker A: No, you have no implementation here. But it, I have a set of slides where I can show you how that works. Okay, great.
00:19:34.012 - 00:19:36.210, Speaker D: I think that's it. Thank you very much, Haiko.
