00:00:01.200 - 00:00:31.470, Speaker A: Good morning. Today we are doing EOF implemented call number 51. The agenda is issue number 1074. And so far we only have the standard, the standard tests, the standard agenda items. So probably spend a bit more time on test. There are some questions dribbling in on chat that we'll be sure to address. But first let's start with client updates, starting alphabetically by people calling in.
00:00:31.470 - 00:00:46.442, Speaker A: Alex, do you have any EVM one team, do you have anything on EVM one for updates? Any EVM when people can talk?
00:00:46.546 - 00:01:22.070, Speaker B: I think not much in it called validation is still in progress. Tests are, are being worked on right now by Andre and we've got also the maximum code size validation in review and I mean it's basically waiting, resolving the execution spec, test dependency in CI, but it's also implemented. I don't know if there's anything else being worked on right now.
00:01:23.050 - 00:01:27.270, Speaker A: Okay. Dragon revm.
00:01:28.810 - 00:01:58.120, Speaker C: Yeah, last week I was like fixing bugs for REVM, didn't pass test fixture too. So I will fix that and I found all of them and I need just to clean up the pr, submerge them in. And after that I hope that foundry is going to work properly with the custom UF solid compiler. So yeah, I am basically working on that.
00:01:59.140 - 00:02:26.700, Speaker A: Okay. Yeah, you posted a question on test. That's something we need to discuss and test whether we continue to build off Cancun or move to Prague. Yeah, so we'll discuss that in that section. Um, for Basu, um, the one to change from last, last week where we um, do the container sizes. Uh, currently working on that. I made the mistake of doing a large refactor as part of it and large refactor went poorly.
00:02:26.700 - 00:02:42.790, Speaker A: So I'm um, stepping back, doing a simple fix and I can do the refactor independent to get that fix and it's not terribly difficult fix. I know where to put the stuff in. Um, so that's the only um. Outstanding at you for Basu right now. Marius Geth.
00:02:45.050 - 00:03:32.880, Speaker D: Yes, not much happened for me. I'm passing all of the code validation tests except for one, I think, but I couldn't be bothered. So I'm not passing the state test. A bunch of things that I haven't implemented yet, a bunch of code that I haven't implemented yet. So I will be working on this. Otherwise I worked on these dos things a bit and I will be upstreaming them to ethereum tests. So we have them um, whenever we need it.
00:03:32.880 - 00:03:45.080, Speaker D: And um. Yeah, that's it. I just needed some time to work on something different. Uh, for a bit and but I will be coming back to to it this week.
00:03:45.500 - 00:03:49.640, Speaker A: Out of curiosity, what was the one test that you don't pass right now?
00:03:50.860 - 00:04:17.746, Speaker D: I don't remember. I think it is. Oh, it has something to do with, uh, Max stack height for. No, I think our jump Max deck height or something. I don't remember. I can look it up and I can send this in the chat.
00:04:17.938 - 00:05:23.690, Speaker A: Okay. Yeah, our jumps and stacks are true. There's just an off by one or a less than an equal, and it should be a less than or. It's always something silly like that has been my experience when I've been trying to struggle with just one do we have anyone from Nethermind on the call? Do we have anyone from Ethereum js? Are there any other mainline EvM clients? I have nothing asked about? Okay, next question would be for compiler updates. Do we have anyone from solidity on the call? No. Charles, do you have anything this week for Viper? No updates from Viperdev. Okay, the solidity POC any significant changes in the last week, or is it still just doing fine?
00:05:28.790 - 00:06:06.110, Speaker E: So maybe an update from Ipsilon. Many people were either off last week or off this week, so that's why the lack of response on some of these. I don't know if Radek made any more progress on the solidity branch, but we're looking at doing more benchmarks like gas and size benchmarks with popular contracts, and one of them we haven't completed it, but one of them is a P 256 verifier which uses significant gas like 330k, so hopefully that number will be less with the UF.
00:06:07.810 - 00:06:35.400, Speaker A: Cool. Any other compiler updates? Cool. Spec updates? We don't have any spec updates this week. I'm hopeful we may have had our last major spec update, although Marius wants to talk about updating Eof in the future. Is it okay if we do testing and then loop back to that question? Marius?
00:06:36.270 - 00:06:37.010, Speaker D: Sure.
00:06:37.510 - 00:06:52.090, Speaker A: Okay, so let's go to testing. Anything from the testing team they want to discuss or ask questions about before we go to the prog uf question?
00:06:53.550 - 00:07:38.520, Speaker F: Not, not that much. Major things. We've been reviewing the pr stuff and just trying to merge the tests. I think one question was related to one of the code size tests that we have, and there's actually an open pr for that that implements code size. So my question is, I think we should have two types of tests for the code size and validation when we try to do some oversized containers. I think that should belong into the EOF test fixture type and.
00:07:41.180 - 00:07:41.588, Speaker D: For the.
00:07:41.604 - 00:08:10.520, Speaker F: Creation of EOF containers and the validation that the containers are not oversized. We should use the status format. I placed a comment in the pr, but I think we should maybe async in the pr. We should just get this discussion just to know that we are in sync with the way that we are testing oversized containers.
00:08:11.180 - 00:08:12.748, Speaker B: Yeah, so I responded to.
00:08:12.884 - 00:08:15.276, Speaker F: Sorry no, no, please go ahead.
00:08:15.348 - 00:08:42.280, Speaker B: I responded to this question, this pr in particular, just outside very specific tests for an addition to the spec, which is the max unit code size eob validation time check, and I think we still need to fill the gaps in coverage and in general creation state tests. It's like a separate story, but agreed that we should test on both fronts.
00:08:43.900 - 00:09:58.070, Speaker F: All right, um. Cool, thanks. Um. Yeah, and there's another pr from the, from the testing side is this one. It's related to UF because we now have the ability to automatically calculate the max stack height in the code that we generate for tests, which means that we can, in theory, if the code for any previous tests, I mean pre cancun and all that stuff, if we have code that we use to test any other functionality like self struct, like recompiles, et cetera, we can now update this automatically to generate a container. In theory, if it doesn't call or use any of the deprecated opcodes, that's something else that we have to figure out. But for the time being, with this PR, the max stack height would not be a blocker to automatically convert something into the UF container.
00:09:58.070 - 00:10:12.800, Speaker F: So yeah, this pr is mainly test changes and that are unrelated to EF but I think it will be helpful for, for EOF.
00:10:13.660 - 00:10:25.560, Speaker A: Yep yeah this is good stuff, this is good stuff. This, this will make testing EOF V one and legacy opcodes make sure they operate the same a lot easier.
00:10:28.180 - 00:10:28.772, Speaker D: Cool.
00:10:28.876 - 00:10:29.396, Speaker G: It's.
00:10:29.508 - 00:10:56.812, Speaker F: I have to say it's not perfect though because there are some things that we simply cannot predict. For example, when you use call f into another record section that contains more outputs or modifies the amount of outputs that it has, that causes some issues with this. But as you can see, most of the maxtect height lines are removed from the EUF tests.
00:10:56.996 - 00:11:12.270, Speaker A: Right. But legacy is not going to be doing call f so we should be fine there. For what I see, its greatest value. So awesome. This looks great. Makes writing tests a lot easier.
00:11:12.930 - 00:11:36.260, Speaker F: Yeah and as you can see there were some instances where I think the value was incorrect and this thing caught the difference. So I think its beneficial that we dont have to calculate this manually and we just let this tool do its job and we only hard code this value if absolutely necessary.
00:11:37.160 - 00:11:45.340, Speaker A: Yeah, that fixed me. I mean, if the test is to get it wrong, of course you have to get it wrong in the code, but yeah, that makes it easier.
00:11:48.920 - 00:12:00.490, Speaker F: And overall, it's just a great addition to the testing framework. Yeah, it has other benefits also. But yeah, EF is going to be benefit the main beneficiary for this, I think.
00:12:02.830 - 00:12:06.982, Speaker A: Cool. Any other.
00:12:07.046 - 00:12:07.710, Speaker F: That's it for me.
00:12:07.750 - 00:13:07.000, Speaker A: That's it. Okay, so Dragon brought up an issue that's kind of related to another issue. There's a discussion of starting a separate Devnet before we go into the full prog Devnet series, march. That is just eof to kind of try and shake out things before we go into full devnet mode. And one of the questions is whether we build off of Cancun and whether we build off of Prague. And if we're going to build off of Prague, that leaks into reference tests on the east tests. Because do we build off of Cancun or do we build off of Prague? One issue I've seen is when we do Prague tests, all the state tests and all of the other tests are going to start introducing changes to things like the block hash stored, which will produce different state root hashes.
00:13:07.000 - 00:13:43.190, Speaker A: They're not easily discernible unless, you know, to expect them from a state test because you just get a different hash missing the ox 25, et cetera, et cetera, class that is storing the block hash. So that's one issue that I've seen between the fixtures that evm one creates and basically creates. And I'm not sure who's necessarily correct in that case. Barnabas. We were just talking about testnets. So you joined right at the right time.
00:13:44.650 - 00:13:45.790, Speaker H: How can I help?
00:13:46.890 - 00:14:11.400, Speaker A: We were having a discussion about whether we build off of Prague or Cancun. And I was just teeing up the issues around it. And one of the things that leaks in if we're going to build Prague instead of Cancun, eof that we should have reference tests require things to be integrated with Prague of. And I was doing a temperature check to see what other client teams felt about bringing in all the prog stuff into their EOF work.
00:14:12.540 - 00:14:24.080, Speaker H: Last week, if I remember correctly, we discussed that we would try to put it on right after Prague. So it would be prog time then prog eof time to trigger it.
00:14:25.740 - 00:14:50.090, Speaker C: Just to say, that's like. That's something that I said, but it depends, like on other teams, what's the best for them. For outside, it's like it would be best if UF is included after Prague. Basically you have Prague UF artwork, but I can make it work even if it is on top of the cancun. It depends. Just like what's easier for the people.
00:14:51.030 - 00:15:09.730, Speaker H: I think it's just when we want to test. Because if we want to test ASAP, then probably makes sense to have it top of Cancun and just stop all the merging and just get up and running. But if we can wait another week or two, then we can just probably have it on top of.
00:15:16.110 - 00:15:16.750, Speaker A: Go ahead.
00:15:16.830 - 00:15:35.270, Speaker F: From the reference test side, I think the only change, I mean, on the actual test code, the only change that we need to do is just one line, basically. But the problem, the blocker is the transition tool. So we need a transition tool that supports brack and also eof. So that's our blocker for testing.
00:15:40.050 - 00:15:53.210, Speaker H: Do we need to have the activation trigger with prog uf time? Can we not do just uf time and just have it activated independently of Prague?
00:15:56.910 - 00:16:28.560, Speaker A: At least the way base is set up, all forks have a parent and they inherit all things that are activated in the parent. So I have a PR set on the side that is a cancun Eof that activates cancun and adds the EOF stuff on top of it. So that was one option to go with the Cancun EOF as we can't have. It's not easy for basically just to turn on a random feature. I don't know what the other client team setup is for theirs.
00:16:29.780 - 00:16:54.020, Speaker C: It's similar setup in RevM. And yeah, Red has little bit different setup. But for vn it's a lot easier. And it was faster to have just one gate. Let's say we can basically have two hard forks. One for Cancun UF and one for Prague UF where the Cancun UF will be on top of the cancun a sec. One on top of the Prague.
00:16:54.020 - 00:17:30.948, Speaker C: I would like to have just one of those because it's not. It seems like I could basically add both of those. But we need. Yeah, we need just to decide what's easier. Yeah, I have a little bit more preference on Prague UF, but because Prag AIP seems mostly like it required just like 7702 and that was it. And that's like different transactions. So if we're not setting different transactions, we're not like having collision between UF and Samsung.
00:17:30.948 - 00:17:38.040, Speaker C: Zero two and pre compiles from Devnet zero. Senavity changes from definite zero. Seems like in okay state.
00:17:40.020 - 00:18:03.600, Speaker A: Yeah, I looked at the 7702 for PR that the other base rest of the basic team is working on for 7702, and it touched like one line in the eof and that was just the gas calculator to add a constant. So yeah, 7702 is pretty orthogonal to EOF. And because I pinged Marius last week, his opinion on it, and correct me if I'm wrong, but he could go either way and doesn't have strong preference. So.
00:18:07.060 - 00:18:25.560, Speaker H: Would it be reasonable to ask each client team to have then two activation possibilities, Cancun EOF and prog UF? And then we could test right away with Cancun UF and then whenever prog Uf rebase is done, then we can just deprecate the Cancun EOF.
00:18:27.580 - 00:18:28.476, Speaker A: I'm okay with that.
00:18:28.508 - 00:18:47.530, Speaker H: It's. I don't know how much time, how much extra time dev take, but, like, if it's very easy to do and then we could have like a devnet up and running by the end of the week, then it might be worth it. Assuming that the EOF implementation is actually done by all the different things.
00:18:49.790 - 00:18:58.670, Speaker A: Let's go to the test metric, the matrix. And I'm not sure, is this up to? This isn't up to date. This is the update.
00:18:59.450 - 00:19:01.578, Speaker B: I've just opened a pr with an update.
00:19:01.754 - 00:19:02.910, Speaker C: Yeah, I need.
00:19:04.890 - 00:19:20.350, Speaker A: The background colors have updates. So I don't think. I mean, we could get maybe Revm and Basu by the end of the week. Possibly. But if it's not the end of this week, the next target will be next week or the week after. Is that what I'm hearing from Barnabas?
00:19:21.810 - 00:19:47.210, Speaker H: I mean, I don't know how long the rubies plan to be for gas, for example, or for nethermind. So if. If it's just one or two weeks to replace, then it might not worth it to add the cancun UF to it and just Covid Prague uf from the get go. So do we have any word from Marius? Maybe. How is gath is doing?
00:19:49.510 - 00:20:25.150, Speaker D: It kind of depends on, like, we. It can go pretty fast. It can also take a long time. I started reviewing the first Prague Prague PR, and the problem with the way we did Prague is that we have a bunch of PRS building on top of each other. So we have 61 10 70.
00:20:29.170 - 00:20:33.150, Speaker A: 00 70 02 yeah.
00:20:33.970 - 00:21:28.080, Speaker D: And then the depth net, those are kind of three prs built on top of each other. So we. We need to go through them one by one and match them one by one. And there's some issues with 6110 because we need to unmarshal the deposits and that was actually something that I wanted to ask other client devs about how they are doing the unmarshling of the deposits and what happens if they fail. But probably with different context than discussing right now. So I will keep that to another call. Either way I guess we can probably do two or three weeks, that would be my guess.
00:21:29.620 - 00:21:36.460, Speaker H: And how long would it be if you would need to add another activation time like Cancun eofdemen?
00:21:39.950 - 00:21:59.730, Speaker D: The problem is that we don't have any prague Uf activation in yet, so it would take me maybe a day or two, but that code is just going to be thrown away.
00:22:01.390 - 00:22:03.810, Speaker H: Yeah. So it's not worth it, do you think?
00:22:04.950 - 00:22:09.850, Speaker D: I wouldn't. I would say it's not that. Yeah, not really worth it.
00:22:13.430 - 00:22:25.054, Speaker A: Okay, so should we work forward based on a prague of Devnet next week probably then, or the week after? Enjoy when we can.
00:22:25.102 - 00:22:32.650, Speaker H: It's probably more. Yeah, it sounds like the week after is a bit more reasonable. It depends on when the rebase is done.
00:22:33.230 - 00:22:51.050, Speaker A: Okay. Yeah, base is ready to go when we need it. So I think that we should be our target for when we launch a devnet. It'd be great to launch the Devnet with everyone but other clients joining late is pretty standard for Devnets.
00:22:52.310 - 00:23:03.478, Speaker H: We can do kurtosis tests right away. Like today even. I could add like one flag. Okay, maybe not today, but tomorrow like 06:00 p.m. already here.
00:23:03.534 - 00:23:05.050, Speaker A: Yeah, don't do it today.
00:23:05.670 - 00:23:22.980, Speaker H: Yeah, I could add the cancun EOF time as the activation epoch for our Genesis generator tool and then I can add that to the Ethereum package and then we can do local kritosis stats by tomorrow.
00:23:24.200 - 00:23:30.380, Speaker A: Basically we need to get there, get our Cancunio FPR merge. But I could do that.
00:23:30.880 - 00:23:40.900, Speaker D: Yeah, we still have no way of actually testing it, right. Of triggering uf stuff on.
00:23:42.760 - 00:23:52.068, Speaker A: We would need to hand create. Oh, kertosis. Can you send random transactions inside of kertosis? Does it expose the ports to clients?
00:23:52.264 - 00:24:01.360, Speaker H: Yeah. So what we would need to do is update TX files maybe to do EOF transactions.
00:24:03.540 - 00:24:12.280, Speaker D: But there's no way of doing Eof transactions, right. We would need. We would need an EOF contract in the Genesis.
00:24:13.500 - 00:24:35.960, Speaker A: No. 7698 should provide a way to introduce EOF transactions. You take a create transaction, you put your EF code in there and you put your aux data after your EOF container, not your aux data. Your input data. So that's 7698 is how you bring EOF into an existing system just through a regular old create transaction.
00:24:37.580 - 00:24:44.760, Speaker B: And you have the solidity PoC to help you with this because this is what solidity Poc uses to deploy.
00:24:47.830 - 00:24:49.290, Speaker D: I see. Okay.
00:24:51.030 - 00:24:57.086, Speaker B: We can deploy on uniswap. What else we tested? I don't remember. Ens.
00:24:57.118 - 00:25:05.010, Speaker A: I think uniswap ens, it might be entertaining to try the open zeppelin contracts.
00:25:08.190 - 00:25:14.930, Speaker C: I do hope that I will integrate it inside foundry. So it's like we'll have gas and everything around it.
00:25:17.910 - 00:25:21.730, Speaker H: Do you plan to have foundry integrated in soon?
00:25:22.910 - 00:25:48.430, Speaker C: Yeah. The problem was RVM had some bugs, so I just found the last one. I need to clean up those prs, merge those, and propagate the changes to foundry. We started testing it, have some integration with it and. Yeah, it is not that. Yeah, it is easy to do.
00:25:53.610 - 00:26:15.950, Speaker H: Last week I've been working on. Last couple of weeks I've been working on some optimism stuff to have optimism roll up on top of the Ethereum package. So we could potentially check if we could roll out a UF style contract deployment with optimism stack.
00:26:16.890 - 00:26:19.910, Speaker A: Yeah. Happy Oprah. Op base is not ready to go yet.
00:26:21.050 - 00:26:24.026, Speaker H: Yeah, the Oprah. That's what I meant. Yeah.
00:26:24.178 - 00:26:26.870, Speaker C: Yeah. That's amazing, to be honest.
00:26:28.410 - 00:26:35.160, Speaker A: Yeah. Someone from op ping me on Twitter. I should probably let them know that that's a possibility that might happen this next week.
00:26:35.980 - 00:26:50.720, Speaker H: Yeah, I mean, that assumes that the solidity code is changed to be compatible with EOf code. I'm not sure if anyone would be quick enough to do that because I have no idea what any of that means.
00:26:52.700 - 00:26:53.716, Speaker C: So what?
00:26:53.788 - 00:26:54.252, Speaker A: Go ahead.
00:26:54.316 - 00:27:05.170, Speaker C: Yep. It's in proof concept, but it's like working. That's how the stats for the Uniswap contract and Ens are basically made.
00:27:09.350 - 00:27:15.330, Speaker H: Right. So to activate the Oauth, do we need to have some contract deployed or. Nothing special.
00:27:16.270 - 00:27:18.690, Speaker A: Nothing special. Okay.
00:27:19.110 - 00:27:21.010, Speaker H: So what happens is that.
00:27:22.350 - 00:27:56.100, Speaker A: So what happens right now is when a contract create transaction sees efdev of any way, shape or form. At the beginning is the first byte rejects the transaction. So 7698, if it says EF zero zero, and it's a valid container with possibly some init code overhang, then it'll deploy an EOF contract. So that's how you bring EOF contracts into the system is through the create transaction or through the genesis file. So we don't need anything in the genesis file for us to do validation.
00:27:58.960 - 00:28:00.260, Speaker H: Okay, sounds good.
00:28:01.480 - 00:28:11.700, Speaker A: So at least we can turn it on and see if smoke comes out. So that's, that's good news. So yeah, keep us posted. Don't, don't, don't bash your head in. If it's not working too well, just let us know it fails.
00:28:12.400 - 00:28:20.140, Speaker H: Yeah, we have a new interrupt chat on Etherndy. I'm not sure if you guys are aware of that.
00:28:24.400 - 00:28:26.860, Speaker A: Is it in a testing group or is it a different group?
00:28:27.560 - 00:28:33.900, Speaker H: Yeah, it should be in the testing group. So we have a specific uof testing within the testing group.
00:28:34.920 - 00:28:44.300, Speaker A: Yeah. So let's keep those updates in the probably eof testing group would probably be the right place. Cool beans.
00:28:45.650 - 00:28:57.910, Speaker H: All right, let me know if you have a Bezu branch ready to go with the cancun activation time. Yeah, cancun eof time activation trigger.
00:28:58.290 - 00:29:04.630, Speaker A: Okay, I'll put that on my to do list. I have a. Yeah, I have checked in. I just published a pr.
00:29:07.530 - 00:29:17.590, Speaker H: What would be the trigger for nethermind, by the way? Would it be all the different vips or would it be the one big vip?
00:29:26.370 - 00:29:30.870, Speaker C: Do you have anybody from neithermind, that is?
00:29:32.170 - 00:29:32.950, Speaker A: Yeah.
00:29:35.890 - 00:29:47.380, Speaker I: We don't have a lot of updates. We are working on EIpde 7698 and you are trying to see to implement it and test it.
00:29:49.120 - 00:30:02.700, Speaker H: My question was what would trigger eof in the chains pack? Would it be all the different eips timestamp transition timestamp or would it be something else?
00:30:04.040 - 00:30:11.220, Speaker I: I guess, yeah, we'll go with the same timestamp for all eips, for only for all EOf Aips.
00:30:14.440 - 00:30:20.620, Speaker H: So we, so I would need to define all the different eips in the Genesis chain spec.
00:30:23.000 - 00:30:32.620, Speaker I: Oh, you mean like separate vip for each change or one small, one big one for the full eof? I don't get the question.
00:30:33.610 - 00:30:36.922, Speaker A: Does it exist right now for us?
00:30:36.986 - 00:30:44.470, Speaker I: We have just one field we have to set true for eof to be for like activated completely.
00:30:45.690 - 00:30:50.030, Speaker H: Yeah, but how do you do that? Yeah, what is the field name? That's my question.
00:30:54.370 - 00:30:58.070, Speaker A: Is it activating 7692 or is it a different field name?
00:30:59.260 - 00:31:01.708, Speaker I: Its name is activate.
00:31:01.884 - 00:31:02.596, Speaker A: Let me check.
00:31:02.668 - 00:31:37.130, Speaker I: I don't remember exactly the name, but I think it's release back. Is EOf enabled.
00:31:38.870 - 00:31:40.490, Speaker A: EOf enabled. Awesome.
00:31:41.870 - 00:31:46.414, Speaker H: Eof enabled timestamp or we are just.
00:31:46.462 - 00:31:48.610, Speaker I: Calling it is eof enabled. And.
00:31:51.680 - 00:31:54.100, Speaker A: If we're enabling a genesis, that should be fine.
00:31:54.640 - 00:31:56.736, Speaker H: I don't want to enable Genesis. I want.
00:31:56.808 - 00:31:58.820, Speaker A: Oh, that's not fine then.
00:31:59.160 - 00:32:19.070, Speaker H: Yeah, I do want to test the fork transition for sure. So enabling it in Genesis makes little testing. I want to be able to center inductions before and maybe in epoch two or three to test if you can transition nicely.
00:32:31.130 - 00:32:33.230, Speaker I: I don't think we added that one yet.
00:32:35.010 - 00:32:42.610, Speaker H: Okay, can you please add that then, a way for me to activate the specific time?
00:32:43.150 - 00:32:46.410, Speaker I: Yeah, what do you suggest I call it?
00:32:48.790 - 00:32:52.206, Speaker H: Isn't there a mega eip for Eof?
00:32:52.398 - 00:32:54.810, Speaker A: Yeah, 7692.
00:33:00.630 - 00:33:10.450, Speaker I: Okay. Then I will call it seven EIP 7692 transition. And whatever value you provide, it will be used.
00:33:10.910 - 00:33:15.930, Speaker H: Yeah. Okay. Yeah, let's do that.
00:33:19.670 - 00:33:20.094, Speaker A: Cool.
00:33:20.142 - 00:33:25.570, Speaker I: 7692 copy paste.
00:33:27.590 - 00:33:30.330, Speaker A: Tomorrow's all core devs execution, correct?
00:33:38.040 - 00:33:39.300, Speaker H: Yeah, I think so.
00:33:39.600 - 00:34:41.910, Speaker A: Okay, any other testing updates before we go to other items? Okay, so one thing I'm going to propose, not this week, but next week we start doing is we switch to every other week live calls and we are going to do a lot more async stuff like getting the devnets up and running and dealing with bugs. The reason I remember us going to the weekly calls is we had a lot of spec issues that we needed a lot of quick iteration on. We have no spec issues this week, so I think this is the right time to consider going back to the every other week cadence, which I think is a much more sustainable kids, I know that's what vertical trees does and that's what a lot of the other breakout rooms do, is every other week. So we would still meet next week, but after next week we would meet every other week on the weeks where Acde is not on. What are people's opinions on that?
00:34:46.290 - 00:34:47.590, Speaker C: Seems reasonable.
00:34:49.810 - 00:34:51.070, Speaker B: That makes sense.
00:34:53.940 - 00:35:16.200, Speaker A: Okay, so if there's no objection, we'll start going to every other week. Starting next week we'll meet and then in two weeks we'll have it off. So this would be the last off week call is the way we can look at it. Cool. Any other questions or comments or items that need to be discussed before we end the meeting?
00:35:19.750 - 00:35:25.730, Speaker D: Yes, I wanted to discuss quickly discuss upgradability.
00:35:26.470 - 00:35:29.166, Speaker A: Upgradability, yes, I forgot about that. That's why I always ask for this.
00:35:29.238 - 00:36:45.080, Speaker D: Okay, so one thing that I kind of noticed when thinking about our stack validation is if we add something to it, we will completely break it. And so if we ever decide to add a new opcode to EOF, any opcode, we will break the second code validation. Right. And so we would need to have a separate version for every hard hook. My question is, have people already thought about this and if so, how do they handle it when this, when, when designing their code? Because right now, my code for the stack validation, it's, I don't know, 150 lines for the code, for the code validation, 150 lines for the stack validations, 200 lines. And those are two different functions. But if I would have to version them, I would need to basically make a copy of it.
00:36:45.080 - 00:37:06.730, Speaker D: Everything else would be pretty horrible. So my question would be, have other people thought about how they would like to do this? And if so, if there are any better ideas than just copying 350 lines of code.
00:37:09.270 - 00:37:54.932, Speaker A: So I've thought about it a bit. In Baesu, in our code we have the notion of a max EOF version. And that goes along with my mental model of how I expect EOF versions to evolve. If you'd imagine EOF V one being a set of all possible contracts that are valid, any forward compatible change would take code that was in the invalid set and move it into the valid set. And anything that's in a valid set would not become invalid. So if there's something that is a valid d one contract, if we make a change, it makes it invalid. We now have EOFv major two, but if we have a set of valid contracts and we turn on opcodes, we now have EOFV eleven, and I might encode it internally as one, two, three.
00:37:54.932 - 00:38:34.242, Speaker A: Java's in their class file format, they just monotonically increase it. I think they're version 55 for their compatibility, even though they're only on Java 21 because they would increment it whenever there is some sort of a change. And like 55 could only go back to 51 for compatibility. There's kind of a matrix on there. But my thought is that we would take one set of validation rules for EOF one. For certain rules we would also say like, let's say we're adding back, we're adding in what's an opcode ext data copy. So we put in another thing.
00:38:34.242 - 00:39:25.130, Speaker A: It's like, well, if EOF version is greater than two, and this would be Eofminr version in that case, or greater than one or whatever value it is, version two is when we're bringing it in, when I would check that, I would check that it's there. And if the maximum EOF version is two, so when we do the validation function, we would pass in a parameter saying what our maximum EOF version is. So in basically we would still have one code block that would validate all the code and validate all the stack. But if we're validating a rule that was relaxed for v two, we would need to have that flag to set it. And by relaxed typically it would say include these opcodes and then necessarily do the opcode validation. I'm not anticipating any changes to stack validation apart from what the opcodes bring in with them. But in theory we might just say EOf version three yolo on stack, all stacks are valid.
00:39:25.130 - 00:39:28.070, Speaker A: So we could just say if EOf version is three passes on, that's.
00:39:36.210 - 00:39:46.432, Speaker G: Sorry about that, I lost my microphone. But that's my perception on it is that the future versions relaxations will be triggered by flags that we passed it as a function.
00:39:46.546 - 00:39:47.692, Speaker A: And I've already got that written into.
00:39:47.716 - 00:40:03.080, Speaker G: The EVM spec in Bayesu so that we got these things built in. That's my mental models. We don't have to copy code validation and copy stack validation for every major version going forward, otherwise that's going to be a rich source of bugs.
00:40:07.900 - 00:40:48.250, Speaker D: Yeah, makes sense. But there's only, it's only really clean I think for like very easy rules. Right. Like if we, if we, I don't know, if we relax the backward jump roll or whatever then it would be very hard to, to do that as a plug.
00:40:49.870 - 00:40:50.610, Speaker G: Right.
00:40:51.670 - 00:40:53.118, Speaker A: That does limit some of our forward.
00:40:53.174 - 00:40:59.530, Speaker G: Things we could add which I don't see large changes on the rules and stack validation going forward.
00:41:01.590 - 00:41:32.470, Speaker D: Yeah. Okay. But yeah that's, yeah, yeah it makes sense. Thanks. Now I know how I'm going to maybe do it in the future. I will, I don't think I will implement it now because it's not needed, but yeah, makes it easier to implement it in the future for sure. Yeah, that was it.
00:41:38.490 - 00:41:43.790, Speaker G: All right. Any other topics of discussion or comments or questions?
00:41:48.770 - 00:41:49.322, Speaker A: All right.
00:41:49.386 - 00:41:56.130, Speaker G: If not, see everyone back in seven days and see most of us tomorrow on Acdem. Thanks for calling in.
00:41:57.310 - 00:41:58.130, Speaker C: Bye.
00:41:58.870 - 00:42:00.130, Speaker D: Thank you. Bye.
00:42:00.470 - 00:42:00.942, Speaker F: Thank you.
00:42:00.966 - 00:42:01.070, Speaker D: Bye.
