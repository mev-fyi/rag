00:00:16.730 - 00:01:03.778, Speaker A: So I'm gonna do just a quick overview on how to apply design into contracts. So first, what I'm doing here. What's my job here? Of course, the designer is the guy that comes after Fabian done his job and just make it prettier, right. So I don't really see it that way. I think that the purpose of the interface, of course, is to translate the code into what the user sees. So in the same way, the purpose of the interface designer is to be some sort of translator between the developer and the end user. So I think it's important that the purpose of the designer is to be the guy that tries to connect the two words.
00:01:03.778 - 00:01:57.778, Speaker A: And in order to do that, you need to do something that designers don't like really to do, which is understanding the code and understanding what's going on under. I mean, of course, it's not the job of the designers to develop, but if he doesn't understand what he's designing, he will not be doing a very good job at designing anything. So here's an example. So the first time that Christian came up with this code, we are talking and we are exchanging ideas. This was the first layout of the purchase function. And you might notice that just looks like something we saw. But there is this one detail, which is the buyer was set at the contract when the contract was created, which made my job needed that.
00:01:57.778 - 00:02:51.842, Speaker A: The way that someone would interact with the contract was the seller would announce the price of blockchain. The buyer would answer him, look, I want to buy your stuff. And then the seller would get the address from the buyer, deploy the contract, and communicate the address of the contract back to the buyer. And then the buyer needs to send the money to a contract, which in some sense might make sense, and there are some advantages to it, but it creates a lot of problems. It makes the interface a lot more complicated and creates a lot of problems, like, what if the buyer never answers back? What if the buyer disappears? Then you have to add some way to refund. So if you need to refund anyway. So why do you need to create the seller in the beginning? So that's why now we decided that the seller doesn't define who the buyer is.
00:02:51.842 - 00:03:34.362, Speaker A: The buyer defines himself by actually giving the money. So if the buyer doesn't deposit the money, he's not the buyer, which makes sense and simplifies my job, because now the seller deploys the contract with already the price information. So the way he communicates a price is via the contract. And then all the buyer has to do is send money to the contract, which makes more, it's easier for both of them and simplifies what we need to do. So now let's take another look at the contract. And that's all the functions that the interface has to do. So you have to imagine that the interface needs to be able to abort, to confirm the purchase, to confirm the received.
00:03:34.362 - 00:04:21.354, Speaker A: So it's probably something that we need four buttons and we need to add somewhere. You can add the address of the contract so you can interact with it. But before we go there and try to design it on Photoshop, let's try to think about, let's try to simplify it. So if you remove it, you see that those are the functions and those are the modifiers of the functions. And if you try to rearrange them, you notice that we have like three states and we have two states and they can be in three conditions. And there's only one function that you can actually do, meaning that you have to remember that adapt can know who the other person is. So an adapt can ask for access, asking for the user.
00:04:21.354 - 00:05:17.902, Speaker A: Look, who are you? Give me the address of your if account so I can recognize you. Meaning that the app knows if she's talking to it is talking to the seller, the buyer or anyone else. Meaning that actually what happens is that if you, and since the states doesn't happen all the time, it means that there always only one single function you can do. So if there is no buyer, and if there is no buyer, then the seller can abort the purchase or anyone else can confirm the purchase. If there is a buyer already, then the seller can refund and the buyer can confirm receives, and everything else is just a state that is active. Meaning that actually we don't need to design the whole app, we can realize that the app is just a button. We don't need to do the whole app with a buying and selling.
00:05:17.902 - 00:06:24.902, Speaker A: Actually, our whole design process is that it's realizing that the app is a single button, which is kind of cool because Don Tap Scott was talking about how the next uber could actually be the car that owns itself and it's doing the transactions. And this is a very nice example of a button that holds the money itself, which I think is kind of cool and takes me to the second point, which is you shouldn't try to do too much when you're trying to design a dap. So of course this is a great app. We could think about all the ways you can build a marketplace, you can build Amazon.com, you can build an eBay, trustless eBay. You can add search functions, but you don't need to do it right now, actually, since it's a very decentralized tool set. If you just build a single button and allow other people to use your button, that might be a viable business model because you might charge a few cents for people to use your button.
00:06:24.902 - 00:07:26.426, Speaker A: And of course they can deploy their own contracts if you want, but that's your job to convince them why they should be using your contract that they have to pay. Which is interesting, because you can imagine a web where instead of you going to Amazon and Amazon builds the whole page, maybe Amazon has a single card that it's from another developer. And we think less about big portals and think about a bunch of components that can work together in the new web. Now a third point, which is a more design oriented thing, is just when we are talking about depth, we want to be able to distribute them on a bittorrent like network, on ipfs, on swarm. So the fonts you use should be open source that you can distribute them. Those are some great example of open source fonts. We use source sense pro for most of our apps, sometimes monstera, but those other are great.
00:07:26.426 - 00:08:10.166, Speaker A: I kept libre Barska view there because it's my favorite. Ampersand. I love ampersand. And my fourth point is that use grids that applies to everything that the designer makes. We use this little grid here, which is kind of weird if you say, if you take a look at it, but we use 32 pixel by 18 four. Why do I use a height of 18 four? For the simple reason that it allows me to have exagons on my grid, which is nice because it allows you to centralize circles, which is something that is always cool with some designs. And also we use 32, 32 pixels because it's the divisor of 300 and 2489.
00:08:10.166 - 00:09:10.710, Speaker A: Hundred and 61,024, which is, and a bunch of other sizes which are great for mobile, which are great for multiple screens. Finally, test, test, test, always test whatever you do. So normally when I first started, I always used whoever is in the office as the first. The best test is just grab someone who's not working your project, show something and ask him a dumb question like, okay, what is this that you are seeing? And never answer to him, just let him answer to you. But since I work from home now, which made that kind of complicated, I was forced to find other sites that would allow me to do that, which I found some great, like usability hub. I highly recommend it envision I highly recommend it. So for example, in our design process, instead of building a document saying what the interface should look like, we build an envision document that has all the screens linked.
00:09:10.710 - 00:10:02.022, Speaker A: And I can show the developers, I can show some users. So all they have to do to understand how interface works, they click, click around and they will be able to see how the app is going to feel like this is a great tool for exploring everyone. And the next thing I always use is usability hub, which is a great way to do quick design tests. So this was the first design of the Aleph one miner, which is a CPP tool for allowing a quick one button mining, which is a great tool. But the first design was very kind of nerdy and complicated. And I suggested a new design where part of it we removed a few buttons, like the cpu mining, which doesn't make sense. And we just have one button that's called start mining and withdraw rewards, because that's actually what people want.
00:10:02.022 - 00:10:41.094, Speaker A: And in the process of convincing that this design made sense, because I think it felt like it made sense, but sometimes you need some numbers. So I run it in a usability test, which is a way that you can have 20 people like clicking your design around from all over the Internet. And I just asked them, look, this is some app that uses your cpu and gives you money. So I want you to turn the app on and try to collect your winnings. And you can see that on the first app people were like clicking all around. They had no idea what it was and they couldn't get to the next point. And on the second version, everyone was mostly clicking just on those two buttons.
00:10:41.094 - 00:11:11.074, Speaker A: And we were able to switch. The overall rate of people having success on the first try, on the first click from 30% only to 70% only, which I think it's a great success and show how important it is to test it constantly. And sometimes you can test just logos. For example, this is the first logo for mist. And of course you can see that's a wave inside a diamond. So I think it's so obvious that I almost didn't test it, but I decided to test it anyway. And that's how the Internet described it.
00:11:11.074 - 00:11:34.746, Speaker A: It's just like a diamond with a shape with purple. And then maybe there are not enough details. So I asked people to write substantives. I made a second version with more details. And then everyone just told me, okay, so this is a wave mounting with water ice. I don't know, I'm confused. So I decided to.
00:11:34.746 - 00:12:08.630, Speaker A: Oh, maybe I just should add some smug to it. And then, okay, what is this now? And then? Oh, it's a messy, scary, confusing, code blue, sharp. And then I could see that this was not the right approach for the icon. So I decided maybe, since maybe you can go to iceberg, iceberg, there's this idea of the deep web, and maybe an iceberg is cool. So what is this? And everyone say, nothing. That's some app thing. So I kept trying.
00:12:08.630 - 00:12:48.660, Speaker A: I kept making other designs, and I think this one was better. And people start seeing that there's an iceberg there. It's like an iceberg with a magical mountain thing. And that was finally the latest iteration of the logo. I had multiple iterations between them, and they were like, oh, it's a magic diamond mountain with an iceberg Chrysler inside, which is more what I was going for in the beginning. And finally, the last point I want is keep the user in control of his data. That's something we don't do on the current web, that we can totally do on the decentralized web.
00:12:48.660 - 00:13:56.050, Speaker A: So just in miss, for example, we allow the user to, as I was telling in the beginning, the user can just tell the app who he is. So the user starts all apps anonymously, and then he can choose one account to review himself. And it's a great way that the user, maybe you don't need to have a login password information on your app. You don't need to keep all that information on the end app side. Maybe all you need to do is ask for the browser for it to show you some sort of proof of ownership of a public key, and your app will be simpler, and it will be a better experience for the user because he can keep his private data on his own browser. So I think those are the six things I wanted to tell about how to design for the new app. It's.
