00:00:02.720 - 00:00:29.205, Speaker A: All right, like to welcome everyone to EOF implementer call number 52. As a reminder, before we get too much further into this call, we're going back to the every other week schedule. So there will be no call next week. There will be a call in two weeks and I may be on a family vacation that week, so someone else will need to run it. I'll try and keep my notes available. I might be able to make it. I can't make promises.
00:00:29.205 - 00:01:06.195, Speaker A: So that's Wednesday morning. I won't be able to make it. Okay, so in two weeks I won't be available, but I think there's going to be enough people that it's still worth having it. There's a lot of progress being made right now. Agenda for today, client updates, compiler updates, spec updates, testing updates and other items. And there was a couple of late things that came into the agenda. We'll discuss EU in testing and finalize some of the EOF create stuff.
00:01:06.195 - 00:01:30.595, Speaker A: So client updates I'll start with be just keeping up with the state tests, making sure that we're up to date and when we see differences, fixing them. There hasn't been any notable change this week. Still trying to get most of the reference tests in EVM1.
00:01:34.215 - 00:02:07.265, Speaker B: We have merged the new rule to validate that container is below maximum minute code size. And another thing, we've merged validation of INIT container runtime container kinds. Except we still haven't merged the part that disallows unreferenced sub containers. So that is still in progress, but I think we'll be merged soon too. Yeah, that's all related to implementation.
00:02:09.005 - 00:02:14.689, Speaker A: Okay, nevermind. Eamon hi, we have some by the.
00:02:14.697 - 00:02:15.873, Speaker C: Way, can you hear me?
00:02:16.049 - 00:02:17.569, Speaker A: Yes, I can hear you. Perfect.
00:02:17.617 - 00:02:26.325, Speaker C: We have some failing tests regarding UFCREATE and X call of codes and we are trying to figure out what's going wrong and fix it.
00:02:28.385 - 00:02:40.025, Speaker A: Okay. If you need help, feel free to ping up in the chat. I could probably help you out if you haven't figured out, but I don't know nevermind code that well so it might not be too much help.
00:02:41.165 - 00:02:42.225, Speaker C: Sure, thanks.
00:02:42.525 - 00:02:47.665, Speaker A: Yeah, Marius?
00:02:51.485 - 00:03:27.697, Speaker D: Yeah, I've been going through the block tests. I still haven't figured out how to make the state tests work, but they're testing the same thing so it doesn't matter. I could just go through the block tests I thought. I think like 10 issues already. Right now I'm stuck on some gas differences and those are kind of difficult.
00:03:27.761 - 00:03:28.365, Speaker A: To.
00:03:30.785 - 00:03:54.335, Speaker D: Pass or to debug in my opinion. So if anyone else has A passing implementation and could trace some stuff for me that would be really helpful. I have no overview of how many tests I'm still missing, but shouldn't be that many anymore.
00:03:55.995 - 00:04:51.835, Speaker A: Okay, I know Besu and EV1 agree on gas costs. I wound up rewriting all of our gas charging logic special for EXD call rather than trying to make the gas logic work for EOF and current and ancient forks. There's a lot of interesting steps in there, especially the pre Constantinople and pre spurious Dragon stuff. So that's. That was our experience in bases. We just rewrote it special because it's to get rid of all the previous flags. Do we have anyone from Ethereum JS on the call? How about Ref or Aragon? Okay, any other.
00:04:51.835 - 00:05:00.505, Speaker A: Any other thing else we said before we move on to compiler updates. Cool.
00:05:01.045 - 00:05:18.995, Speaker E: From the yield side. So I just wanted to give an update. We just started implementing the ERF EIPs. We are just like halfway through and I'd imagine we'd be like we'd have a full implementation in a week or two weeks. What we are targeting.
00:05:19.615 - 00:05:23.431, Speaker A: Okay, what. I'm sorry, what? Client referral. I missed that part, Sorry.
00:05:23.543 - 00:05:25.023, Speaker E: Eats from the Eels team.
00:05:25.119 - 00:05:38.871, Speaker A: Eels. Eels. Okay, great. Yeah, Eels. Eels will be important for testing because that's basically the reference implementation. So yeah, again, if you got any questions, just feel free to pop them up in the chat. Sure.
00:05:39.023 - 00:05:39.875, Speaker E: Thank you.
00:05:42.375 - 00:06:10.305, Speaker A: I need to add Eels to my list. Okay. Any compiler updates? I don't see Viper here, I don't see Charles, and I don't see one from Solidity. We are going to be revisiting one of Solidity's requests in the spec updates though. Any compiler. Last call for compiler stuff. Great, great.
00:06:10.305 - 00:07:44.885, Speaker A: So for spec updates, three things on the agenda. Item one is to revisit the XD call return codes, one is to look into adjusting the stack overflow check in call f jump F and one that should be easier is to finalize no shared containers between Create and return contract. So the first one was the EXTU call return codes and this is kind of harkening back to a few weeks ago when we had the Solidity team and one of the issues was there's no good way to identify an EOA from a non EOA account and I think what we settled on was well, we don't need it for aa and I think a piece we were missing is one of the requirements from ERC721 and this is for the safe transfer from. For the safe transfer from. To work the contract needs to be able to identify if it's calling a smart contract or if it's calling an EOA even if it's a smart contract wallet. So yeah I think this is a non this is this is a use case that still persists past living in the future and the the point that was made in the linked form the linked ETH magician's comment is we can't create a spec compliant ERC721NFT and EOF as long as this is the case. So if it's a smart contract they have to do a callback to it otherwise they can accept it.
00:07:44.885 - 00:09:16.995, Speaker A: And the point of this is to make sure they don't send an NFC to smart contract they can't also send the smart contract back. There's a check where you have to have a supported supported call and has return a magic number for it to be valid. So anyone have any comments on this or content before I go on to any proposed solutions? Okay, so as I was going through with this I was thinking one of the ideas we batted around to deal with this was to change the EXT call return codes. This is something we talked about in IOTA and this is a variant of that that I have posted here is basically we would distinguish between successful calls to smart contracts and successful not calls to EOAs. And this would be we still need to be able to do EXT call to the EOAS to do balance transfers and we can't just segregate out pay and ext because there are a few use cases where a call needs to receive value to be successful. So we always have to be able to transfer value. So the thought was rather than one success code we would have multiple success codes and we would spread them out so you could do a more simple check.
00:09:16.995 - 00:10:17.195, Speaker A: If you only are concerned about a successful call you can still do a zero but if you just get concerned about success in general it would cost you about four more opcodes. Three or four more bytes is zero and you might be a not in there but it might cost you three more bytes to do a check to see if it's greater than zero. So it would hurt a little bit on the call overhead if you care about non calls. But this way would provide an opportunity and a mechanism for EXT call to figure out if it's calling contractor and eoa. So anybody's thoughts comments on this? Anything from Ypsilon, Alex, Peter, Andre?
00:10:18.455 - 00:10:41.295, Speaker B: Yeah, I think it's definitely worth to change now given that there's this new use case with specific status codes. I think maybe we'll have to think some more. I'm not sure yet what would be the best. Yeah, we discussed this already but. And there were several ideas I think.
00:10:43.435 - 00:10:46.855, Speaker A: Are there other ideas we should be pursuing rather than just the return code?
00:10:48.155 - 00:10:59.255, Speaker F: How about if we put a successful non call case into revert category? Would that be an option as in to return one.
00:11:04.125 - 00:11:05.493, Speaker B: Return one if it.
00:11:05.549 - 00:11:30.149, Speaker F: Reverted, if it reverted. If it, you know, had the problems that there's this bunch of cases where it returns one. And also for a successful non call. The rationale is that they're somewhat similar. I mean. Oh well, they are not similar because a value transfer might have happened.
00:11:30.197 - 00:11:30.429, Speaker A: So.
00:11:30.477 - 00:11:31.745, Speaker F: No, I guess not.
00:11:32.085 - 00:11:35.865, Speaker A: Right. And in that case the value transfer is what they're looking for.
00:11:36.205 - 00:11:36.941, Speaker F: Yeah.
00:11:37.093 - 00:11:42.985, Speaker A: Okay. Just do a value transfer. Did a value transfer and call right in the NFT.
00:11:43.525 - 00:11:52.265, Speaker G: Don't do value transfer in the NFTs. They. It's not about value transfer.
00:11:53.685 - 00:12:07.665, Speaker A: Right. But we still need to keep the case where exe calls can do value transfer and we need to be able to distinguish when those were successful because we don't have the pay op code.
00:12:15.325 - 00:12:37.335, Speaker F: And if we put the successful non call into the upper register, so to speak. So I don't know. 253. Wait, that doesn't. That doesn't help. Really.
00:12:42.035 - 00:12:49.255, Speaker A: Yeah. Because they're trying to create categories of where these broad marks are. So when you do a return test you can do a simple comparison.
00:12:50.805 - 00:12:51.625, Speaker F: Yeah.
00:12:53.085 - 00:13:23.555, Speaker A: And negative one uint 256 creates a much larger set of bytes for the comparison. If you want to see if you verted versus failed. Because the other case is we want to. If we're going to give this information, we need to expect that some code is going to differentiate between failures and reverts. Which is why I opted for a single byte of encoding rather than all 32 bytes of encoding because that's going to be harder to efficiently store in it.
00:13:32.375 - 00:13:47.265, Speaker F: How about pushing two items to the stack, one for success or failure in the other whether that was a contract or not?
00:13:48.005 - 00:13:54.181, Speaker G: There's no such instruction yet. That's why we kind of ended up going that direction.
00:13:54.333 - 00:13:59.621, Speaker A: But there was an optional. And then every call is going to wind up having to put a pop on if they don't care.
00:13:59.653 - 00:14:01.025, Speaker F: Yep. Yeah. Yeah.
00:14:02.325 - 00:14:10.705, Speaker A: Another option is we could put an opcode that we could ask has contract data because that's what they're doing with size as they're checking for it.
00:14:12.365 - 00:14:18.905, Speaker G: There was the other option on the calls to have like an input flag. Whether to allow no execution.
00:14:21.845 - 00:14:28.305, Speaker A: Input flag. Would it be another stack item or would it be like a bit pardon one of the stack items?
00:14:34.925 - 00:14:36.225, Speaker G: I mean, good question.
00:14:39.055 - 00:15:06.705, Speaker A: Because we have the address. We have the address, we have the value and we have the two inputs for call. We don't have the value in static or delegate because static and delegate might have the same issue. Because we can't just rely on the successful on receive return because an EOA is not going to send that.
00:15:16.085 - 00:15:32.715, Speaker G: The one issue with the input flag, we also discussed it like a year ago. If you have an input flag, then why don't we make the static call and delegate call also just a flag and have a single opcode? So it's kind of.
00:15:41.735 - 00:15:43.715, Speaker A: Yeah, that would be another useful flag.
00:15:44.295 - 00:15:57.355, Speaker G: Yeah, but if you introduce a new opcode, then wouldn't pay be or transfer be the actually useful one as opposed to have like two versions of the call?
00:16:00.095 - 00:16:49.405, Speaker A: How would you distinguish calling the on receive to an EOA from a contract? If we allow pay, that still doesn't solve ERC720's unique need to figure out am I transferring it to an EOA unless we make them, you know, keep sending satoshis across our ways or whatever they're called to the target or doing another trial call to see if it's going to respond to anything. Because I think this is like a legit non. A legit case where pay doesn't really solve the problem.
00:16:52.455 - 00:16:53.795, Speaker G: Yeah, I mean it doesn't.
00:17:05.255 - 00:17:30.275, Speaker A: One thing we might want to consider is bringing back ext code size with a change. It doesn't return the actual code size. It returns a 1 or a 0 if the code size exists or if it doesn't exist. And that would actually solve 721 concern because the actual encoded standard for if it has a smart contract is if the code size is greater than zero.
00:17:31.215 - 00:17:36.991, Speaker G: But wouldn't that be rather like is EOA or has code that's basically is.
00:17:37.063 - 00:17:53.925, Speaker A: EOA and has code is what it would be because code size is a very standard solidity check. They check the size for is code and they don't care about the size in most cases.
00:17:56.185 - 00:18:00.525, Speaker G: Well then you could, you could just call it, you know, is EOA or HESCODE instead.
00:18:01.945 - 00:18:54.645, Speaker A: Right. I mean, would that be a valid transfer case like what Randao replaced difficulty? Would that fall into that category because it's backwards compatible across the two of them? We're looking for a zero or a non zero value from a contract. So we could reuse the ext Code size and rename it is the OA. No, is is contract. So if it returns 1, then it is a contract 0, then it's not a contract address and that translates fine back to legacy. Because any length of code is going to be greater than zero. And we would encourage implementers to test zero and non zero rather than zero and one, even though we're specified to return one.
00:19:06.795 - 00:19:41.509, Speaker G: We didn't really have the mandate to solve the EOA question, you know, with the. We only had like three dots introspection and code introspection. But I wonder if. Because right now we kind of hide the fact whether something is in EOA or not, which a lot of people wanted to achieve for a long time. Yeah, I wonder, going back on this, what other issues would it open? I mean, definitely solved like this case.
00:19:41.557 - 00:19:42.145, Speaker A: But.
00:19:44.765 - 00:19:46.145, Speaker G: Yeah, I have no answers.
00:19:47.325 - 00:20:22.005, Speaker A: Right. So maybe we should think about this for a couple of weeks again and consider the two alternatives. Is contract and return code changes. Is contract is clearly the less disruptive change to existing implementations. But I think we're not too far along where we could do this level of a change if it's warranted. So I think that's when you think about the next two weeks and probably hope that Charles or Daniel from Solidity comes on the next call.
00:20:24.945 - 00:21:04.575, Speaker G: So the one, the one piece I'm kind of worried about with changing the return code is that how frequent is this requirement? I mean, obviously with NFTs it is, but how frequent is it across all the calls? Because in this case we're optimizing for NFTs and every single other call has to make more checks with the new version of the return codes. Because with the old version or the current version, it's just a single zero check.
00:21:05.875 - 00:21:13.335, Speaker A: Right. And we're imposing this requirement on everyone, effectively by increasing the successful return space.
00:21:28.295 - 00:21:46.725, Speaker G: Yeah, Radek, I think going to be back next week, so maybe we could. We could at least think about changing the Solidity, the compiler implementation to both cases so we can see what is the overhead on some of these contracts. Benchmarking.
00:21:47.145 - 00:22:08.233, Speaker A: That would be an excellent thing to look at. Yeah, absolutely. Because this contract is like zero. Overhead is existing overhead. I think we only need to see what changing return codes would do to it. Okay. All right, so we will document this.
00:22:08.233 - 00:22:26.455, Speaker A: Let Radic look at it and ask Solidity and Vyper to chime in on the two options. Does it simplify it in any way if we use bit flags? Bit flags on which field? Like an immediate to the call or is an extra Stack item.
00:22:28.155 - 00:22:29.735, Speaker H: To the return code.
00:22:31.835 - 00:23:09.845, Speaker A: So that's kind of what we wind up doing here. The high bit would be failure. So that's why I coded greater than 127. The high bit signifies failure, the low bit signifies non failure. I don't think bit twiddling is going to save us any any opcodes because we'll need to push 128, do an XOR and doing a zero so it's already one worse to do bit twiddling. So doing a check, doing an LT on 127 is probably an LT or GT on the barrier is probably more efficient than a bit field. But I don't know what other bits we'd want to encode.
00:23:09.845 - 00:24:19.465, Speaker A: I mean maybe we could encode the second bit's always going to be that the call was to a contractor non contract. We could do it 64 and have the next bit be the contractor non contract flag and Then the remaining six are the status codes and that still preserves the 127 feature. Something to think about because we could go encode more useful bits and all sorts of things on these. Okay, I'll add that into my write up about return code possibilities but I don't think we have a solution today and we need a remanded out to others to discuss Next item was to improve the stack on call F jump F and that is an issue by Paul. Paul is he's not on the call, is he? Oh Peter. He's not Peter. Peter, could you talk to this?
00:24:22.085 - 00:25:08.009, Speaker F: Yeah, so. So there's this I don't call it convention that the max state height Mac max stack height in the header includes the inputs of a code section and when. When you. How it goes when you calculate the how to best put it Andre, can you. Can you maybe sort of having hard time.
00:25:08.057 - 00:26:25.341, Speaker B: This is related to stack overflow checks at runtime. So this check happens only during call F and jump faster and it checks whether max stack height of the cold section is plus current stack is above stack limit. Oh yeah and like minor issue is that max stack height as we define it currently in the type section it includes sections inputs and then when we calculate this stack overflow condition it has to subtract this number of target inputs because otherwise it's counted twice they are already on stack and they are also counted in max stack height of the code function. So the check is actually if current stack plus max stack height minus inputs is above the limit. And so this is clumsy one reason and like it requires the extra access to the header to get these inputs of the target section. So the proposal was just. Yeah.
00:26:25.341 - 00:27:15.405, Speaker B: To redefine max stack height to not include the target inputs and yeah, this then this check is simplified and maybe we should then rename this field. It will be like not max stack high but that max the growth or max the increase. So that's Padel's proposal, I guess. And yeah, I think it will maybe change many tests because like all the tests that have inputs and colef and jump F and this renaming, I'm not sure what are they? What's the impact? It's just probably just renaming in the spec but also I don't know all the variables and implementations.
00:27:17.105 - 00:27:34.085, Speaker A: Okay, so everyone would need to rewrite some section of their code validation. It would impact just about every single piece of code that uses colf. And this is to get rid of an extra subtraction in a stack height check, right?
00:27:35.065 - 00:27:35.885, Speaker B: Yeah.
00:27:43.235 - 00:27:48.135, Speaker A: I see the aesthetics, but I still am concerned this might be in the too late department.
00:27:48.515 - 00:28:01.415, Speaker B: Yeah, it's. Yeah, I'm also thinking it might be too late. So it's not only about aesthetics, it might also affect Oracle future when like it requires extra access to the header maybe.
00:28:01.875 - 00:28:07.665, Speaker F: But it's like the, the two bytes that's encode this are just next to each other.
00:28:08.085 - 00:28:09.505, Speaker B: Yeah, that's. Yeah.
00:28:10.045 - 00:28:38.575, Speaker F: Actually it's more about managing after you have done the access. You just need to keep the extra variable around. Right. I mean is it likely that max stack height would be in a different chunk than the inputs? I mean it's this, it would be the.
00:28:38.615 - 00:29:24.725, Speaker A: The type data and a lot of execution would probably be lighted. We wouldn't see that because it's not strictly necessary because it's been validated. If you're doing a call left, it's been validated. You're passing in the correct amount of variables. Because in when I view through when, when I board game out what what this is going to look like in a vertical format, I don't see us ever bringing in any of the type section. I mean I'm sure there's optimizations you can do if you have the entire code with you, but from a witness execution it's been validated. So we just presume it's correct.
00:29:24.725 - 00:31:02.105, Speaker A: What do other clients think about this? Never mind. Gethsemane. No opinion. Strong opinion. Eamon said in chat feels too late because we're not losing the data, we're just having to do an extra subtraction. So I'm thinking we should pass on this unless there's a Strong reason we need it. Any comments on that? If there's no objection perhaps we should move on to the next item then on testing test Hargomax doc I need to be updated.
00:31:02.105 - 00:31:11.045, Speaker A: All of those can easily be updated. The test can be fixed and that's just a long day of running over failures and fixing all the numbers.
00:31:20.825 - 00:31:35.195, Speaker F: But this wouldn't be. Wouldn't need to be done urgently because I guess testing could just do the subtraction right and then that can be worked on in the future.
00:31:41.415 - 00:31:50.635, Speaker B: I would just change the test it shouldn't be difficult to fix the test it's only the tests that do call F and have inputs.
00:31:53.735 - 00:32:01.605, Speaker F: Yeah there shouldn't be many but just as a stop gap solution you can just, you know. Anyway.
00:32:06.625 - 00:32:46.455, Speaker A: I'm concerned this is a lot of work for a change to drop and minus from validation. Do we want to come back to this in two weeks and so we can talk about testing or come back if there's time available. Is there some testing issues we need to discuss?
00:32:50.355 - 00:32:52.417, Speaker F: Yeah, that sounds like a good idea.
00:32:52.571 - 00:32:54.865, Speaker B: Maybe present in here.
00:32:55.445 - 00:33:28.105, Speaker A: Ok, let's table it and get Paul's opinion. I think that's. That's the big thing that's missing Quick small one Finalize the change to disallow referencing the same container by both EOF create and return contract within the same container we had discussed this before so this is just the final call if there's any objections Even though there is a corner case where you could share revert it's just not terribly useful and it's easier to prevent it and it prevents problems.
00:33:31.085 - 00:33:32.589, Speaker F: No, it simplifies things.
00:33:32.677 - 00:34:14.988, Speaker A: I think it's okay so let's adopt this Unless there's an objection that has risen been out for a couple of weeks now the discussion for this. Okay, our next question or EVM1 implementation. Okay, here's the implementation Just a sub bullet so. Yep. So what we need to discuss I think going on to testing is EVM1 T8N state tests. Hugo, do you have anything you want to tee up with this or. No, sorry Mario.
00:34:14.988 - 00:34:18.988, Speaker A: Mario. Yeah.
00:34:19.036 - 00:36:31.585, Speaker H: So basically the EVM1 tool is currently appending the beacon root contract state changes into the storage even if the contract is not there which goes against the specific I think that should be easily solvable on the even one side But I think the other thing that we can consider is basically just add a status flag into the transition tools which would mean that when we call the transition tool either gets transition tool or even wants transition tool with this flag the execution that the transition tool has to do is it doesn't contain any block level operations such as the withdrawals such as the block hash inclusion into the history contract and so on and so forth. I think it's not that complicated to do on Geth's code base and this would simplify us having to work around when we fill the state test versus the blockchain tests. Right now what we do when we are filling the state test is that we simply do not include the history contract, we don't include the beacon root contract. And that means that we expect that the transition tool follows suit and does not execute this logic. But if we specifically set the status flag, we now have the security that the transition tool will not actually include this logic. So basically, yeah, that's the question. I think this Slack should not be that difficult to implement and it will help us when porting the EOF tests into prac because we now have four new pre deploy contracts that are to be executed at the end of the.
00:36:31.585 - 00:36:37.705, Speaker H: At the end of the block. So yeah, I think it will simplify a lot of stuff.
00:36:38.365 - 00:36:45.105, Speaker A: Okay, would this be like a command line flag or would it be data passed in the env or something?
00:36:46.525 - 00:36:48.865, Speaker H: I think a flag should suffice.
00:36:49.845 - 00:37:04.229, Speaker A: A command line flag. And so yeah, basically runs in server mode for performance reasons. Would test keep a separate server mode for one or the other setup or would it tear them down and build them back up each time?
00:37:04.357 - 00:37:18.955, Speaker H: That's a great question. I think for besus specific case we need to pass it somewhere in the environment. So maybe we can generalize this and just pass it in the environment for everyone. Mm.
00:37:25.295 - 00:37:25.879, Speaker A: Okay.
00:37:25.967 - 00:37:26.215, Speaker B: So.
00:37:26.255 - 00:37:40.687, Speaker A: So there's a flag. No block hash processing. If it's in, there's no block hash processing, no beacon rep processing, no withdrawals, deposits or consolidations to be considered in the transition tool. If it's present, we cannot need to consider all of them. That's what it.
00:37:40.751 - 00:37:41.595, Speaker H: Exactly.
00:37:41.975 - 00:37:42.795, Speaker A: Okay.
00:37:48.265 - 00:37:57.365, Speaker H: Everything that is not part of the transaction. So the ideally you only execute the transaction and return the state root modification and that's it.
00:37:58.185 - 00:37:59.045, Speaker A: Okay.
00:38:01.105 - 00:38:24.415, Speaker H: I think also you. You had. You made this suggestion some time ago. So I don't know if you. If you have any comment, but yeah, I think going into the environment the flag should be. Should be parsed and then just select the mode that you're going to execute and that's about it.
00:38:27.355 - 00:38:34.915, Speaker A: Okay. Any opinions from EVM1? Never mind. Or Gethsemane?
00:38:37.005 - 00:38:40.265, Speaker B: Yeah, I think should be pretty easy to implement for us.
00:38:41.845 - 00:38:42.309, Speaker A: Okay.
00:38:42.357 - 00:38:45.905, Speaker B: Can you create. Create an issue in VM1, Mario?
00:38:46.885 - 00:38:59.745, Speaker H: Yeah, yeah, definitely. I can also create the PR for geth, but if I need help, I'll just ping someone from the get the team.
00:39:01.495 - 00:39:05.675, Speaker A: Okay. Eamonn, Marius, what do you. What are your opinions on this?
00:39:12.935 - 00:39:14.115, Speaker B: So. Yes.
00:39:18.255 - 00:39:19.515, Speaker A: Eamon, go ahead.
00:39:20.575 - 00:39:24.675, Speaker C: I was saying it doesn't seem too complex to add, so we'll try to add it.
00:39:26.825 - 00:39:28.045, Speaker A: Okay. Marius?
00:39:30.585 - 00:39:31.409, Speaker F: Yep.
00:39:31.577 - 00:39:35.405, Speaker D: I prefer it in the test environment.
00:39:36.745 - 00:39:53.017, Speaker A: Okay. Yeah. So basically likes the environment too. So it sounds like we're all on board with it. I'm not thinking it'll be too terribly difficult because of stuff like E simulate. We always want to be able to execute transactions outside of the block context. So I'm.
00:39:53.017 - 00:40:04.725, Speaker A: I'm hopeful that the client teams won't have too much difficulty implementing this. Okay. Any other testing updates from Mario now that we got the most critical issue out of the way?
00:40:06.945 - 00:40:41.275, Speaker H: Not that many. I know there are a couple of PRs open. I was focusing on Devnet One EIPS yesterday and the day before that, but I will try to get to review the PRs today. Also, there was a modification that was suggested by Andre about having the INIT code flag. This change. I have a PR for that. Basically this change is whenever we call the EVM1UF parse tool.
00:40:41.275 - 00:41:24.715, Speaker H: Now we're passing also the INIT code flag. If the container in the test specifies that it is an INIT code container. And also when we generate the fixture, the EF test fixture, it will also contain this flag in the JSON in the generated JSON. So when you are consuming this test and if you see inside of any of the vectors that the file contains, you see the INIT code field set to true, you should treat this the bytecode of the container. You should treat it as an EOF INIT code container. Yeah. That's basically the only change that clients need to be aware of when they consume these tests.
00:41:28.495 - 00:41:41.105, Speaker A: Okay. And that kind opcode is going to be at the same level as the results, right? It's going to be code results kind. Is that the level it's at?
00:41:41.965 - 00:42:08.035, Speaker H: So it's right now we have like, we have the vectors field, which contains a serial an increasing number, so from 0 to n vectors and inside of each one there's a dictionary. And that dictionary will now contain the INIT code field equal to false most of the times. But sometimes it will contain equal to true. And then, you know, you have to treat this as an INIT code container.
00:42:08.335 - 00:42:12.327, Speaker A: Okay. So the name's going to be INIT code The dictionary name is going to be init code.
00:42:12.391 - 00:42:25.355, Speaker H: Okay, yeah, yeah, I will try to. Let me. I'll send the PR into the discord with the update to specify exactly what you guys need to take a look at.
00:42:26.135 - 00:43:52.415, Speaker A: Okay, cool. Anything else that is on the list? No one else. So I'll write up a summary on call return data and is contract. I think we need to wait for Paul to advocate for call left a little more articulately and that'll be discussed in two weeks. And I think those are the only two open items other than the PR for the. Other than the changes, the tan. Is there anything that we missed or do we need to discuss the remaining 12 minutes? All right, hearing none.
00:43:52.415 - 00:44:16.069, Speaker A: We can probably end the meeting then. We have our plans for the call in two weeks. Again, the call is going to be in two weeks. There will be no call next week on the 4th of, no, the 3rd of July. Our next call will be on the 10th of July. Again, we don't need to wait. Yeah, I don't think we're ready for devnets, Barnabas.
00:44:16.069 - 00:44:31.825, Speaker A: I think that's okay. Yeah, that's a good point. We were looking at launching Devnets, but it would be a single client devnet at this point and I don't think we'll get much good interrupt signal out of that. So. Yeah, so it's going to be at least two more weeks for devnets. We're going to push into July at least for that.
00:44:32.925 - 00:44:46.485, Speaker I: Yeah, I agree. Also, kurtosis is now EOF ready. So if you have your client that wants to support EOF with EOF time, it automatically going to be triggered.
00:44:46.985 - 00:44:56.273, Speaker A: Yep. I got a local kurtosis running. I started it up and it started up fine. I haven't thrown anything at it, but I'll work on getting that in the next couple of weeks.
00:44:56.449 - 00:45:03.965, Speaker I: Yeah, would be good to create some assertor tests also. And then we could do automated tests in kurtosis.
00:45:04.305 - 00:45:12.245, Speaker A: Okay, I'll need to research how to write a kurtosis test. So it's assertive test, Assertor test. Yes. Yep.
00:45:12.945 - 00:45:15.205, Speaker I: Feel free to reach out if you have any questions.
00:45:16.665 - 00:45:39.035, Speaker A: Okay. All right, last call. Thanks everyone for coming. I know it's summer and there's a lot of distractions, so don't forget to touch grass while it's green. And we'll see everyone in two weeks.
00:45:42.495 - 00:45:43.675, Speaker F: Thank you. Bye.
00:45:45.335 - 00:45:46.095, Speaker A: Thank you. Bye.
