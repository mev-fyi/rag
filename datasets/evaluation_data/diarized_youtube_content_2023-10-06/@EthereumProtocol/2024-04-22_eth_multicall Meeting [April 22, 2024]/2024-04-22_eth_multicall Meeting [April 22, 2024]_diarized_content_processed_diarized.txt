00:00:00.720 - 00:00:28.074, Speaker A: So I wondered, do we have any page with the error that we want to throw if the user gives us like skipped, reordered blocks that we want to tell him about? So is there something like specific that we, that we want to throw at him, or we just throw a generic error as we want.
00:00:32.614 - 00:00:34.314, Speaker B: Block numbers up, wrong order.
00:00:35.134 - 00:00:38.022, Speaker C: Yeah, I think we should have a standardized error code for it.
00:00:38.038 - 00:00:42.182, Speaker B: At least there's error code for it. Oh, there is. Okay.
00:00:42.358 - 00:01:02.124, Speaker A: And what do we do when the user sends to us a range that is out of the limitation that we give him? So imagine block number, say 3000, block number zero, and the block number 300. What do we throw him then?
00:01:05.624 - 00:01:13.244, Speaker B: I guess we don't have specific error for that case. We had to create error for that here.
00:01:20.164 - 00:02:05.484, Speaker A: Also, I looked a bit into the way that we create hash. So given that everything else would be same, hashes shall be equal between geth and net mind, at least from my understanding, because we cast stuff that I was afraid of, like in many places, Nethermind hash int 164 for example, and Geth has unint 256. And when we create hash, we actually cast down to UN 266, 264. So it shall be correct in that regards at least.
00:02:15.884 - 00:02:38.684, Speaker B: Yeah, just looking at the error cause, and I guess I think we need to also adjust a bit. They have block number in sequence, did not increase. I don't think we need that kind of error anymore. It just should be something about the block numbers when it consisted or something like that. And then there's the block number is too high. Error could be also one.
00:02:42.304 - 00:02:55.604, Speaker A: And I also wondered, Clary, maybe you can tell me if there are any like outstanding issues. Would you post them on Trellis so that I would be able to manage them properly?
00:02:56.904 - 00:03:13.404, Speaker B: Yeah, I can take a look on that. One of the issue was that many of the tests at the moment wrong, because they're using those phantom blocks, and the phantom blocks are Dexs. But then I don't have any client that is supporting non phantom blocks.
00:03:20.544 - 00:03:37.564, Speaker A: And in general, the main difference between supporting them and not supporting them is, well, sending to you the like, the extra empty blocks. And that's pretty much it here with the hashes also.
00:03:39.504 - 00:03:41.164, Speaker B: Sorry, I didn't get what you mean.
00:03:41.624 - 00:04:10.384, Speaker A: When we sent to you the like, say you sent to me, create a block number five from the latest and fill it saved with one transaction. I send back to you four empty blocks with nothing in them, with only hash basically, and everything else copied from the block before. And then I sent to you one process block, and that's what is expected yeah.
00:04:12.684 - 00:04:21.801, Speaker C: Is that what we decided last week that we're going to fill? I probably should have written down the art decisions.
00:04:21.987 - 00:04:24.549, Speaker B: No, it was that we are feeling them.
00:04:24.581 - 00:04:27.033, Speaker C: Yeah, we decided.
00:04:29.253 - 00:04:45.513, Speaker B: Yeah, we voted on that. We are doing the feeling. I just need to understand what was your question about? I think we agreed we voted last time on that if we are doing filling or not. And then the feeling option won.
00:04:47.013 - 00:04:58.564, Speaker A: So I think we'll provide to you updated version of nethermind client later today. So you'll be able to probably test it tomorrow. All right.
00:04:59.424 - 00:05:17.324, Speaker B: Yeah, I guess there can be an error that the block numbers are too small, that you try to generate blocks that are already existing on the chain. So I guess the error needs to be block numbers are out of range, covers both of the cases.
00:05:20.384 - 00:05:21.564, Speaker A: Could you come again?
00:05:23.384 - 00:05:40.204, Speaker B: If the latest block is hundred and then you say that generate from latest. And then you say that the next blog is ten and then ten already exist in the current chain so it cannot be generated. So we need our error in that kind of case as well.
00:05:41.344 - 00:06:04.512, Speaker C: Yes, I assume that would fall just into just one category of errors, which is invalid. Block numbers or something. And that can account for. You gave us a block number that was out of order. You gave us a block number that was two before your head block. You gave us a number that was too far. In the future, like all those, I would assume we could pack into one error code.
00:06:04.512 - 00:06:06.444, Speaker C: Or do you think we should have a different error code for each?
00:06:07.784 - 00:06:18.324, Speaker B: Yeah, I'm not sure. I think it could be grouped, but then it would be nice if the client would then add their own information about it. I could be more specific about it, but I guess the error code doesn't need to be that specific.
00:06:19.304 - 00:06:45.676, Speaker C: Yeah, exactly. So their code would be like block number wrong or something. And then the client would add messages. To answer your question, Oleg. Yes, I believe what you described is correct. If the latest block that you're building, if the block you're building off of is 100 and the user just passes in block 105, then you will return an array of five blocks. The first floor blocks will have no transactions in them, but they'll still have all the header information.
00:06:45.676 - 00:06:58.104, Speaker C: And then the fifth block would have all the header information plus some transactions. And for the transactions, I would do an empty array rather than missing.
00:06:59.804 - 00:07:07.184, Speaker B: Yeah, because there are valid blocks, there's no transactions. Also the base fee and the block base fee also go down because there's no transactions.
00:07:07.514 - 00:07:09.974, Speaker C: Yeah, they would calculate just like the whole block.
00:07:11.794 - 00:07:13.454, Speaker A: Yeah. All right, we'll do that.
00:07:13.794 - 00:07:39.434, Speaker B: Do we want different error for that? The block number is out of range because that is more client specific config. And it can, some clients can support higher more blocks to be generated than others. So some clients could allow you to generate thousand blocks. Do we want to have different error for that?
00:07:46.574 - 00:08:17.584, Speaker A: I have a question, actually. When we generate blocks that are nearly empty and are like inheriting from the parent, I'm just wondering what happens to guess that is inside of them. So the block, say, has a limit of the parent, but we don't utilize anything in it and the block will be built.
00:08:18.524 - 00:08:37.364, Speaker B: The block limit stays the same because that's something disordered. I would always take the parents block limit or gas limit. So also, if the user overrides in one block, then it then stays overridden. The next blocks.
00:08:40.904 - 00:08:43.512, Speaker A: Used will be zero, mainly. Almost.
00:08:43.568 - 00:08:58.890, Speaker B: Yeah, but it will be zero if they generate or there's no transactions yet. Did you remove the phantom blocks logic already or is there something to work?
00:08:59.082 - 00:09:25.924, Speaker A: It's more, it's not removal, it's just adding stuff to check that we are given, say, block number five, please add new blocks because in our implementation, there is no real difference between absence and presence of phantom blocks. So it's just adding like fill in extra blocks. Please now return results for every block that we've created in this request. Now.
00:09:26.904 - 00:09:33.284, Speaker B: But we had that special logic on how to calculate the block hash, for example. And I guess that's extra code.
00:09:35.584 - 00:09:37.764, Speaker C: That will go away now, the phantom block.
00:09:39.544 - 00:09:48.798, Speaker A: Yeah. But generally if you, for example, created blocks number one till ten. Oh, yeah, I get you.
00:09:48.846 - 00:09:49.550, Speaker C: Yeah.
00:09:49.742 - 00:10:04.754, Speaker A: That logic can be now script. Was there something like special that required us to remove phantom blocks? Just wondering if phantom blocks can be a client specific feature.
00:10:07.174 - 00:10:42.644, Speaker C: I think it's having a different per client. I worry is it's not the end of the world if, let's say, another mind sport phantom block. Well, there's a couple things. One, the behavior of what do you do when a block is missing in the user's input? Do you fill it with phantoms or do you fill it with real blocks? That would be a difference in output for the same input on two clients. So both clients return success and they give you different results. And so that's not great. I think the other thing is.
00:10:42.644 - 00:10:50.844, Speaker C: Yeah, I think that's really the main reason I would argue for keeping the clients the same in this regard.
00:10:51.824 - 00:10:52.184, Speaker A: Yeah.
00:10:52.224 - 00:10:52.844, Speaker B: All right.
00:10:53.224 - 00:11:14.034, Speaker D: As far as I could understand. Right, this is a lot of specification that would have to be done here for a potentially very rare use case and on the already how to specify JSON RPC method.
00:11:15.334 - 00:12:04.676, Speaker C: Yeah, I think Oleg was just saying, could we just have this a client specific behavior? So the spec would only support filling in blocks, like, all of them, but an individual client could go above and beyond and allow users to leave, have, like, gaps in their. In their blocks, and then instead of erroring, the client can give a response. I just worry that about that situation where. So I guess I would be okay with that ish. I generally like it when the clients agree. It makes it nicer to develop, and it makes it less likely that app developers have to, like, end up getting tightly coupled to one client. But as far as concrete things, I think it's just that one issue of different behaviors when you're filling blocks.
00:12:04.676 - 00:12:47.994, Speaker C: That being said, we could resolve that by saying if a user asks for blocks with a hole, like sparse blocks, we just return an error, and then I would feel less bad about Nethermind. Instead of returning an error, you give something, and it's just kind of undefined what you give. The other disadvantage there is later on and simulate v two or whatever. We do want to add support for end of blocks. It would be awkward if we respect it and it changed from what Nethermind or Aragon or some client did voluntarily. I still favor keeping things in sync. I think it wouldn't be the end of the world, though, if Nethermind went and did this, but I think we should.
00:12:47.994 - 00:12:54.514, Speaker C: If we're going to go that route, we should drop the backfilling in the non phantom case.
00:12:56.214 - 00:13:11.714, Speaker B: I'm not really a fan of adding that the client's behavior more differently, because sometimes difficult when you're developing or something, and then suddenly you notice that it doesn't work on some other client, and it would be nicer that it wouldn't work on the first case either. So thank you.
00:13:12.694 - 00:13:13.054, Speaker A: Yeah.
00:13:13.094 - 00:13:34.844, Speaker C: All right, we'll remove that like we do most of our development on Nethermind, and then we go back and test Geth later. And it would definitely be annoying if we did a bunch of work and then we found out later that, oh, geth's different. Like, in fact, that's kind of why we test on Nethermind first, is in the hopes that nethermine will do be better at copying Geth than Geth is a copying nethermind.
00:13:38.904 - 00:13:39.376, Speaker B: Yeah.
00:13:39.440 - 00:13:39.616, Speaker C: Yeah.
00:13:39.640 - 00:13:45.344, Speaker A: All right, so Sinai cannot make it today.
00:13:46.484 - 00:13:54.980, Speaker B: Did we have something else that we didn't finish discussing last time? I don't think so.
00:13:55.132 - 00:14:19.184, Speaker C: I think we made some decisions, and at the end of the call. I said, if anyone wants to contest any of these decisions, let's talk about it in telegram. And no one brought anything up this past week that I remember. So I guess we're finalizing those decisions from last week officially. Does anyone. We should probably. Did anyone write down what those decisions were or do we have to go back and watch the recording? Honestly don't remember.
00:14:19.644 - 00:14:35.984, Speaker B: I have them up and I didn't. I made decision that I don't modify the spec until this meeting because I would expect that things might be changing, that the people had realized that we need to do something differently because now people have been developing those things.
00:14:37.114 - 00:14:42.770, Speaker C: Okay, so we'll get the spec updated in this week with these decisions. Yeah.
00:14:42.802 - 00:14:50.574, Speaker B: It seems like no one had disagreed with them now for a week. So I guess they will be finalists.
00:14:52.074 - 00:14:52.934, Speaker A: Okay.
00:14:53.914 - 00:14:55.334, Speaker C: I didn't have anything else.
00:14:57.394 - 00:14:58.574, Speaker A: Yeah, perfect.
00:15:00.234 - 00:15:01.774, Speaker B: Okay, talk to you later.
00:15:02.114 - 00:15:02.934, Speaker D: Bye.
00:15:03.354 - 00:15:05.114, Speaker C: Thanks, everybody. Bye.
