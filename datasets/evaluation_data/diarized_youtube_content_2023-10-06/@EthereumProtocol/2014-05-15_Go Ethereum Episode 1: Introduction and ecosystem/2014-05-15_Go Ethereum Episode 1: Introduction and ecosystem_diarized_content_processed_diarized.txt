00:00:28.180 - 00:00:38.824, Speaker A: Hi, welcome to episode one of writing smart contracts with Mutant and the Go Ethereum client. I'm Stefan Chule, CEO for Ethereum, and I'm joined today by Jeffrey Wilkie. Jeffrey, you want to introduce yourself?
00:00:38.942 - 00:00:56.604, Speaker B: Hey, man. Yeah, so, my name is Jeff. I am the core developer on the go side. I joined Ethereum in December. Well, basically just started developing because I thought it was fun. I read the white paper, and now I'm a founder. That's me, Brian.
00:00:56.652 - 00:01:03.852, Speaker A: Thank you. So today we're going to learn about ether real. Can you tell us about what ethereal is?
00:01:04.006 - 00:01:33.608, Speaker B: Yeah, so ethereal is a client. It's written in QML, it's written on top of go. It serves as the main ue for the go client. It's still in its very early alpha alpha stage, and it has a very basic and limited contract editor. It has a basic debugger, and it can send and receive transactions very simply.
00:01:33.784 - 00:01:35.384, Speaker A: Okay, so it's an ethereum client.
00:01:35.432 - 00:01:36.588, Speaker B: Basically, yes.
00:01:36.674 - 00:01:47.276, Speaker A: So why do we have two Ethereum clients? I heard of Alice Zero, of course, which is the C implementation. What's the benefit of having two different implementation? Maybe three if you include Python.
00:01:47.468 - 00:02:27.800, Speaker B: Right. So just imagine kind of a complex problem. You have the white paper, which is a non technical white paper. It's just an idea. And the only thing, if you want to find problems in a white paper, if you want to find holes in it, you have to start developing. Just. I basically started my own deployment in December, and the C guy, Gavin, he did the same thing in January somewhere.
00:02:27.800 - 00:03:03.480, Speaker B: We started comparing our clients together and see know. So I had my interpretation, he had his interpretation, and through that we figured out what were the holes in the white paper and how we could fix it. That is one of the advantages of having two implementations. The other one is understanding the white paper, understanding the protocol, and if either one of the implementations has a bug, there is still one or two other clients out there that just function normally.
00:03:04.380 - 00:03:07.256, Speaker A: Right. Okay. Do they share the same blockchain then?
00:03:07.358 - 00:03:08.584, Speaker B: Yeah, absolutely. Okay.
00:03:08.622 - 00:03:17.708, Speaker A: So if I'm running whichever version of the c plus plus client, I can send you a transaction and you're going to receive it through the ethereal client then?
00:03:17.794 - 00:03:28.560, Speaker B: Yeah, sure. Yeah, it shouldn't be a problem. I'm not saying it's easy, but it's not very hard to have two clients communicating with each other.
00:03:28.630 - 00:03:29.152, Speaker A: Okay.
00:03:29.286 - 00:03:45.924, Speaker B: The only thing that you have to make absolutely sure is that they interpret the data that they receive exactly the same. So both of the clients have to do the exact same thing. Because if they do not, it doesn't work.
00:03:45.962 - 00:03:46.816, Speaker A: That will go out of sync.
00:03:46.848 - 00:03:47.872, Speaker B: Right, got you.
00:03:48.026 - 00:03:59.320, Speaker A: Okay, so on Aleph zero, I heard that we wrote contracts in something called ll, which is a listplight language. What do we use on the go client? Ethereal.
00:03:59.680 - 00:04:22.112, Speaker B: So I started developing out my own implementation of a language that I thought was best. We have serpent, which kind of resembles Python. To be very honest with you, I don't like python very much. We don't play well with each other.
00:04:22.246 - 00:04:23.250, Speaker A: Right, okay.
00:04:25.320 - 00:04:46.804, Speaker B: I like c, I like c plus plus, and I like go. And what they all have in common is curly braces, and I just miss curly braces, and I just needed them. So I worked on my own implementation, very rough, simple implementation that could be optimized.
00:04:46.932 - 00:05:04.976, Speaker A: Okay, so basically, if I understand this correctly, whether you're using ls zero or whether you're using ethereal, or whether you're using the Python implementation that Vitalik is working on of the Ethereum client, you'll be able to use potentially any of those smart contract languages on top of each, right?
00:05:05.078 - 00:05:20.656, Speaker B: Yeah, sure. So ll, serpent, and mutant, they all compile to a sampler type language, is a language which can be interpreted by the virtual machines that run within Ethereum.
00:05:20.768 - 00:05:32.168, Speaker A: Okay, so there's one virtual machine, and you have imagine compilers that compile down from mutant, down from serpent, and down from ll into what's called EVM code, right?
00:05:32.254 - 00:05:54.328, Speaker B: Yeah, it's an assemble like language. People familiar with assemble development know what I'm talking about. You can develop in it, but it's not very easy. While higher level languages such as serpent, mutant, and ll, it's just much more friendlier to look at and much easier to develop.
00:05:54.514 - 00:05:58.210, Speaker A: Okay, and what's this intermediary bytecode I heard about?
00:05:59.700 - 00:06:34.360, Speaker B: So it's exactly what it is. It's a bytecode. It is towards efficient. It tries to limit the amount of bytes that you need for each operation. For example, if you have an instruction, the first byte is an instruction sequence, and it tells you what to do. It tells the virtual machine what to do, for example, storing a certain data in a storage address or store it somewhere in a contract. Something along those lines.
00:06:34.440 - 00:06:49.072, Speaker A: So if I understand this correctly, I type my code in Newton using my favorite text editor, or the id that you've mentioned earlier straight into the serial client that converts down into evm code, correct?
00:06:49.206 - 00:06:49.648, Speaker B: Yes.
00:06:49.734 - 00:06:57.652, Speaker A: And then that goes into intermediary bytecode or not? Yes, it does. Okay, and that's what the virtual machine actually runs when exactly. Right.
00:06:57.786 - 00:07:16.900, Speaker B: So what it does is it takes the mutant code, it compiles it to an assembler type language and it takes the assembler type language into just translated into bytecode. And the bytecode is understandable by the virtual machine that is embedded in the python client, the C plus plus client and the go client.
00:07:17.060 - 00:07:40.224, Speaker A: Brilliant. Well, I think I understand it. Wonderful. So I'll explain a little bit about the type of audience we're expecting today. I think we're looking at developers really that have experience writing in C like languages. Go would be ideal, obviously, but I think somebody who knows Java, somebody who knows Javascript might feel a little bit at home here, right?
00:07:40.342 - 00:08:19.550, Speaker B: Yeah, absolutely. It's not a very difficult language to understand. It's telecast, so you have integers ranging from eight to 256 to 32 bytes. That's all you really need because the virtual machine uses 266 bits, storage addresses and integers. So it's television type in that regard. You only have integers and there's only thing you really need. But besides that, it's not very hard.
00:08:19.550 - 00:08:31.920, Speaker B: If you want to define a variable, you define what kind of type it is and just have an identifier for that type and you can reference it later, whatever you want. It's very easy. It's like javascript or go.
00:08:32.070 - 00:08:59.644, Speaker A: Okay, great. Well, let's get started then. On my machine I'm using OSX Mavericks. I have a terminal open and that's all I have. I have go installed. So for those who don't have go installed, there's a link that's flashing on the screen right now, pointing at the instructions onto how to install go on OSX. Jeffrey, correct me if I'm wrong, but pretty much it's the same process on all platforms, right? If you can run go, you can run all this stuff, right?
00:08:59.842 - 00:09:15.500, Speaker B: Yeah, it's slightly harder on Windows because we use Qt. I haven't done a lot of development in Windows, but as far as I know, it's not very friendly.
00:09:16.240 - 00:09:28.288, Speaker A: Got you. Okay, well, macOS X it is for today, and then we'll issue probably some links on how to install all this. I think they already exist. That's what you're showing us right now, right? Building QT for OSX?
00:09:28.384 - 00:09:49.720, Speaker B: Yeah, these are the build instructions for OSX on Linux. This is for building QT because that is one of the requirements that it has. Because it uses QML, you need QT. So these are the instructions that you have to do first before even grabbing the Ethereum client.
00:09:50.060 - 00:09:56.248, Speaker A: Got you. All right, so I don't have that stuff installed, do you want to do it together, or should I go build my own and come back?
00:09:56.414 - 00:10:08.832, Speaker B: Yeah, you go ahead and build it. Just try to. To follow along with your instructions. If it doesn't work, we figure it out. Because unfortunately, I have everything installed already, so it's kind of pointless to me.
00:10:08.966 - 00:10:14.940, Speaker A: Okay, well, we'll see you at the next episode then. And speak soon. Yeah, bye.
