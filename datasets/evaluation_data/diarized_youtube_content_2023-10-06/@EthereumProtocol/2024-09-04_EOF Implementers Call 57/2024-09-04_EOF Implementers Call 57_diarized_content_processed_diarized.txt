00:00:00.440 - 00:00:39.050, Speaker A: All right. Welcome to EOF implementers, call number 57 4 September 2024. As posted, I have the agenda. One change I'm going to propose that we do is we move spec updates after testing updates because that's probably going to consume all available time. I think there are some testing issues we need to discuss first, but I hope to have 20 minutes to half hour set aside to discuss just the as contract. I think that's about as much time as we're going to need first for client updates. We could probably zoom through client and compiler updates as there's probably no.
00:00:39.050 - 00:01:03.120, Speaker A: Is there anything from any of the client teams apart from we're implementing and fixing tests that needs to be discussed? Gary, got anything from Basu? Nope. Mostly just here to audit. Okay. And next would be geth. Geth I don't see on the call. Never mind. Anything.
00:01:04.940 - 00:01:10.080, Speaker B: We did merge the EOf test ClI support.
00:01:10.700 - 00:01:16.320, Speaker A: Cool. And let's see ref anything above and beyond typical?
00:01:17.660 - 00:01:40.290, Speaker C: No, everything's fine. Just run the latest test. Everything's passing. So that should be, I'd be curious to know before the clients have support for IAP 7702 and UF on top of it so that we at least have some idea when the UF testing or Devnet can be deployed.
00:01:40.910 - 00:01:43.102, Speaker A: Yep, we can do that later.
00:01:43.166 - 00:01:43.670, Speaker C: Sorry.
00:01:43.790 - 00:01:59.310, Speaker A: Yeah, I think that's on the move to prod for activation. We can discuss that there. So. Yeah, we'll definitely discuss that. Ethereum J's do we have anyone on the call from Ethereum J's? No. Evm one. Anything on the ordinary?
00:02:02.490 - 00:02:04.298, Speaker D: No, I don't think so.
00:02:04.474 - 00:02:40.852, Speaker A: Okay. I don't see anyone from solidity or Viper. Okay, so yeah, the quick summary is we're getting tests ready for devnet four, which is going to be after Devnet three, and update your implementation matrices. That's the basic ozone update. We tested the 14.1. They're starting to remove the big change there is. They're starting to remove the broken and old duplicated EOF tests out of the legacy Ethereum test repository.
00:02:40.852 - 00:03:03.330, Speaker A: And 14.1 gets rid of all the current broken tests. So you should pass everything that's in Ethereum test. That's eof right now. And that eof link, that epsilon link 158. Yeah. So the testing matrix looks like.
00:03:03.330 - 00:03:34.180, Speaker A: Yeah. So these two lines need to be checked if you implemented them. I'll get that pr in later today. So the next on the agenda, the first thing is we need to start looking at moving into product for activation. I guess this is a good time to discuss Devnet three and 7702. How do clients are implementers on these teams also aware of the 7702 implementations and how things are going?
00:03:41.170 - 00:03:56.830, Speaker C: I think on Samsung zero, two, Ethereum, G's, J's and ret is only passing. At least that was status last week. So I'm not sure if other clients are probably assuming here are implementing those.
00:03:57.490 - 00:04:02.430, Speaker A: Okay, have we launched Devnet three yet? I don't think that's happened yet, has it?
00:04:02.810 - 00:04:11.830, Speaker C: No, it should be next week, I think. But I didn't participate. Yeah, I did participate in Monday's interop call, so I'm not sure.
00:04:12.130 - 00:04:35.630, Speaker A: Okay. But the specs are locked in, I think. Yeah, yeah. Okay. So the next step I guess is to move the eest tests once we're satisfied we have a good eest spec. Okay. There are a few 7702 changes, but they're scheduled after Devnet three.
00:04:35.630 - 00:04:38.430, Speaker A: But I think it's time to start. Go ahead.
00:04:39.610 - 00:04:52.138, Speaker C: I think they're related to Lightclient's proposal to fit invalidation of transaction, but those are very small and they're going to be clued after Devnet tree.
00:04:52.314 - 00:05:00.230, Speaker A: Okay, and are they comfortable slip streaming those into the devnet where uof turns on, or are they going to move us to Devnet five?
00:05:01.880 - 00:05:23.416, Speaker C: Not sure. To be honest. It probably depends when the devnet four is going to be like created. If it's right after the Devnet tree, I would assume. I would basically do those changes after UF, after Devnet three, after Devnet four. But this depends on timeline. Either way there are small changes.
00:05:23.416 - 00:05:28.136, Speaker C: So would it matter if it excluded Orlando, devnet four or devnet far?
00:05:28.248 - 00:05:58.416, Speaker A: Yeah. Okay. But I think the big thing we need to do is we need to start wiring our implementations to activate. At least have a pr ready for not ready to merge it yet that is synced with your main or master branch. Oh yes, we can watch the, there's a peep and eth that's being recorded today. Maybe we should jump on that. Or we could watch it via Zoom or next week when it comes on YouTube.
00:05:58.416 - 00:06:52.968, Speaker A: But yeah, definitely. But we need to get our either through a PR off of master or main, something that activates our EOf stuff on Prague and that will help with tests a lot. The next thing I want to go through is I've got some implementations for, let me put this about a different tab. I went ahead and tested everyone's client against the testnets using your CLI tools. So execution specs has been ready to go. And some of the, one of the, one of the problems we have is that some clients aren't able to run all the state tests or the block tests because we have very inconsistently named fork names whether it's with Prague, with the of or not Prague or Cancun. And I think that's where some of these failures, definitely all of breath's eleven failures are coming from.
00:06:52.968 - 00:07:23.810, Speaker A: And I'm wondering if some of gether and nethermines failures are also related to that mixed date. The big thing I think that gets that gets ref is they don't activate the create transaction except for prog EOf and that's not what's generated in the tests. So if we can have one. I think Mario linked a pr that's going to flip this over to Prague. The big change is super.
00:07:23.850 - 00:08:37.410, Speaker E: It's super simple. So yeah, the EF fork name changes from either cancun or EIP 7692 or Brac with the same name to simply predez which means that we are going to enable tests that are parameterized for for example all the call opcodes, let's say call ext call. All of those are going to be enabled also for Brac which means that 7702 tests once they are merged they're going to be activated for this UF opcodes too. I can go over the 7702 tests also if we had time I can show a couple of examples of how when this PR lands into main and also the 7702 PR lands in domain we can have this cross EiP testing for EOF and 772. Let me send you a link because it's not in main yet. Give me a second or I can share my screen if that's easier.
00:08:37.710 - 00:08:44.410, Speaker A: Yeah, so let me stop sharing and. Do I need to give you permission?
00:08:44.950 - 00:08:45.930, Speaker E: Let me try.
00:08:50.630 - 00:08:51.810, Speaker A: Should be able to.
00:08:52.440 - 00:09:03.220, Speaker E: All right, let's see. Does this work?
00:09:03.640 - 00:09:05.060, Speaker A: Yep, I see it.
00:09:05.360 - 00:09:24.130, Speaker E: All right. So yeah, basically this is the main file that we use for 7702 testing. And one of the nice things when we rebase onto first of all the easy text size. Okay. Or. Yep. Okay.
00:09:24.130 - 00:10:14.870, Speaker E: Yeah. So one of the nice things is that once we have this thing in main and also the we have the activation as sprague set to set for Uf it means that we are also going to be able to parameterize a lot of these tests. Let me show you a couple of examples. Yeah. For example this one. What happens with this test for 7702 is that we have these markers that depend on the fork that they are running on. For example, if you have this market which with all create opcodes it means that if UF is activated in the same fork as 7702, it means that it's going to parameterize this particular test not only with all the create opcodes that we have now which is create at grade two is also going to parameterize with create e of grid.
00:10:14.870 - 00:11:29.600, Speaker E: You can see that we have some code already in place. It's not guaranteed to work at this moment because we haven't tested with any of the implementation because now implementation apart from BesU supports 7702 UF. But this is just one example and you can come into this pr I will share the link in a bit and you can take a look at all of the tests that we are going to automatically parameterize for UFD once evf and 7702 are in the same fork in main. But yeah, this is just one example but we have many others. So for example, tests that are calling into, I think this is a call into the same subcontract and we test with all the call up codes which is currently for devnet three. It's just a constraint for call, delegate call and whatnot. But once again, once we activate UF with 7072 in main is going to extend it to the x variant of the opcodes which means that's going to cross test with UF.
00:11:29.600 - 00:11:48.000, Speaker E: Yeah, that's basically gist. I think it would be better if you guys come into this file and check this test by yourselves to see if there's anything missing. But yeah, that's the basic idea.
00:11:50.140 - 00:11:55.720, Speaker A: So it's with all call opcodes, with all create opcodes. Those are the two marks we need to look at.
00:11:56.500 - 00:12:35.590, Speaker E: Exactly, exactly. If you come here and you see any tests that might need these markers and it has not applied them, I can just totally just come here and update the tests. But I think it's a good coverage to start with. Again, I haven't run this test in EF mode because there's no filler right now. But once we have the filler at first there's going to be some failures of course, because they're not tested. But we can clean this up and then we can make another release which will contain this cross eip test.
00:12:40.820 - 00:12:41.600, Speaker A: Cool.
00:12:44.180 - 00:13:01.300, Speaker E: Let me share, start sharing. I will share the link directly to the file so you can take a look. There you go. Please take a look. Let me know if you have questions or suggestions.
00:13:01.340 - 00:13:55.300, Speaker A: Also write this down real quick. All right, so let me go back to sharing. Cool, cool. The next issue on here is fuzzing and Mario's discussion. Ipsalon, do you have anything interesting about fuzzing that you've, anything you want to add or that we've done with fuzzing?
00:13:57.330 - 00:14:28.220, Speaker D: No, I don't think so. This, yeah, so I kind of stabilized the fuzzer itself. There are no new findings. I incorporated Java Fuzzer as a kind of site guidance tool and I didn't, I didn't include any other implementation because I don't think they pass all the tests right now. So doesn't see the point.
00:14:29.240 - 00:15:13.950, Speaker A: Yeah, especially because the fuzzing tends to use the tests as their C corpus. So there'll be a lot of adjacent failures and it's hard to get a good signal. But once your clients up to 100% on the of tests, let us know and we'll fuzz it and hopefully we won't find any more bugs and then we'll be in a good position. And this is for Eof layout. So cool. Mario also had converting UF format tests into state tests. Is there anything we want to discuss here other than what's in the list?
00:15:17.620 - 00:16:25.238, Speaker E: So yeah, I think that this is pretty self explanatory. The way that we are doing this is basically just converting, putting the EOF container into init container and putting that as the transaction data in a contact create transaction. The goal of this is to test the validation of the EF container when the client receives the transaction. This is another code path that I think we should cover. Basically with this enabled we are generating every single e of tests as status and the test count basically bumps threshold. Yesterday I checked we had 6900 tests around that and now with this enabled we have 12,000 tests. So yeah, it's quite a bump, but I think it's necessary because eventually the only code path that is going to.
00:16:25.254 - 00:16:25.810, Speaker A: Be.
00:16:27.870 - 00:16:39.470, Speaker E: Actually run in Mainnet, in my opinion, is just the great the transaction creation for validation. So I think it's important that we fill those tests with this.
00:16:47.810 - 00:17:08.440, Speaker D: Yeah, I'm slightly confused about the init mode. I think that should be like the easy part because the init mode is expected in this TX. No, in this, in this create transaction. Right?
00:17:09.300 - 00:18:09.540, Speaker E: Yeah. So basically when, when someone develops a UF test that, that contains an a container, the problem is during verification phase at the end of the status, because we don't exactly know what the expected deployed code is going to look like. That is basically the issue. But I think one alternative that we can do is point in the second bullet point. The B option is that these init containers, they need to specify also apart from the container contents itself they also should specify how does the deployed container look like. So if the test specifies something like this, we can actually verify the deployed code at the end of the state execution.
00:18:11.960 - 00:18:18.230, Speaker D: Okay, I got it slightly like the b option more, but.
00:18:20.530 - 00:18:42.890, Speaker E: Okay yeah, I think it's a little bit more work. So this deploy container is not going to end up in the v of test fixture, but it's going to be significant for the status. It's a little bit more work, but I think it's worth it because we have a one to one conversion in this case. Um, yeah.
00:18:44.790 - 00:19:28.130, Speaker D: There'S also not like this, a lot of you can do with this, with this runtime container. Right. It's, it only differs in the data section. So it will be one of the, it's kind of expected to be one of the already subcontainers that exist in the code and you can only manipulate the data section. So I think maybe it's also worth to just try to fuzzy match if the other parts are the same, but the data section kind of ignore for now and maybe specify it as expected data section, something like that. I would need to also take a look and practice how difficult it is.
00:19:32.590 - 00:19:37.104, Speaker E: So do you mean like appending data sections dynamically?
00:19:37.152 - 00:19:52.740, Speaker D: Because in the d option you have like init container as kind of the main thing of the test, but you also want to have additional, let's say field of expected random container that comes out of it, right?
00:19:54.360 - 00:19:55.304, Speaker A: Yep. Yep.
00:19:55.392 - 00:20:41.696, Speaker D: So you can, you can check it. Actually this was deployed in the status. So what I mean is that this random container, it will be one of the subcontainers of the init container. So you can kind of already, you have like some information already even without manually specifying this. And the only thing the init container can do to this output runtime container is that it can only manipulate the data section of it. So the rest is expected to be the same. But the data section might have different size and different content.
00:20:41.696 - 00:20:49.980, Speaker D: That's the only difference you can like, there's no way to modify it, some other parts of it.
00:20:51.080 - 00:21:11.570, Speaker E: Yeah, makes sense. So I think I, well, what we can do is like for automatic testing is to try to see if the first container is the one that is deployed. Right. If not, the test will fail, but then the tester will have to.
00:21:14.350 - 00:21:31.520, Speaker D: One of them. Yeah, that's true. It's like not the first one, it's like can be one of them, but maybe it's, it's like usually the first one. And in case if it's not or the data section is modified, then you would need to specify. Yeah. Expected.
00:21:31.640 - 00:21:39.580, Speaker E: Yeah, makes sense. All right, I will try to do that. Let's. Let's see how many tests fail with this assumption.
00:21:46.490 - 00:21:55.630, Speaker A: Okay. Any other open testing issues, any other experiences teams are having running the tests?
00:21:56.770 - 00:22:13.190, Speaker D: Yeah, you already mentioned this, but I wanted to say just this legacy, this new release of the legacy test, and I think we're done with it for now because we should pass all of them. It's 1401, right? Yeah.
00:22:16.210 - 00:22:26.470, Speaker F: And I think this is mostly the difference between the older version is just removed coverage. I don't think there's any added coverage or fixed.
00:22:29.330 - 00:22:32.050, Speaker D: Those. A group of tests that were fixed.
00:22:32.170 - 00:22:33.426, Speaker F: Okay. Okay. Sorry.
00:22:33.538 - 00:22:33.866, Speaker D: Okay.
00:22:33.898 - 00:22:36.066, Speaker F: Then it's a meaningful update.
00:22:36.218 - 00:23:00.380, Speaker D: It's. Yeah. I don't expect this is significant, actually. They were fixed, but I would just kind of. On this level of examples or something. And it was fixed only by this rule of top container, right? Yeah. So only this one.
00:23:00.380 - 00:23:07.134, Speaker D: And because we had fixes for them, I don't know, probably for half a year.
00:23:07.302 - 00:23:10.166, Speaker F: Yeah. Suddenly they weren't pushing.
00:23:10.318 - 00:23:28.130, Speaker D: I didn't messed up. So that's the difference. There's some difference, but I think there was like four or five group of tests and let's say all of them were converted to east except one group that was fixed in place.
00:23:29.670 - 00:23:30.530, Speaker F: Gotcha.
00:23:30.840 - 00:23:31.232, Speaker A: Okay.
00:23:31.256 - 00:23:49.140, Speaker F: Never. Nevertheless, don't forget to remove any exclusions if you have this. You probably had exclusions for some of the tests that were in passing, so be sure to wipe them out before updating. I guess that's it.
00:23:54.040 - 00:24:39.300, Speaker A: Okay. So I think that's all of the testing items. So I think we can move on to spec items. And the big open spec item is going to be the iscontract instruction. We did discuss this last week on ACD. I expressed my concerns that if we just add more stuff that the rest of the core devs will push back on it. And the plan that was proposed in ACD was we proceed on testnet four as is, and then we consider adding is contract on a follow on testnet if things go well.
00:24:39.300 - 00:25:35.940, Speaker A: So to that end, we have an EIP that specifies what we would propose would be added either in Prague or in the next major fork, depending upon when it gets slotted. But the intent is that this becomes the solution to the problems we're having with 721 contracts, 1155 contracts, and any other contract that depends on distinguishing an EOA from a smart contract account and behaves differently based on those two. And again in here, the motivation we're calling out the safe transfer on ERC 721 on ERC 1155 is our main motivation. So I like to open the floor. Anyone that has any comments about the flow of this, if this is going to be sufficient, if we need something different. So yeah, Ben, you've got your hand up.
00:25:37.120 - 00:27:05.400, Speaker B: Yeah. So is my concern with having a specific is contract rather than say enabling length, even if it returns junkie data, is say libraries where they have an is contract function, say that's doing size greater than zero and there's no detection as such to say whether you're compiling to EOF or compiling to legacy. So you don't necessarily know, you know, that it should switch what's being used. That makes sense, but maybe that's the serenity thing. But they could add a, I don't know, hash define or, you know, if def this is a eof compiled, do this. If it's a legacy, do this. It's not necessarily a bytecode issue, but certainly in terms of third party libraries, they need to know what target they're compiling to.
00:27:13.460 - 00:27:28.240, Speaker G: I think many, many libraries which would use assembly to that extent or, you know, depend on xcode size or xcode copy would have to be changed anyway. They just wouldn't compile.
00:27:32.470 - 00:28:00.660, Speaker B: Yes, but if you're say, I don't know, open Zeppelin and you have, here's our, I think they've removed it, but if they had an is contract function and you as a dev are bringing that in, how does it know whether to call is contract or what is called xcode length? If that makes sense?
00:28:02.880 - 00:28:17.760, Speaker A: So is this something that solidity could add a new is contract function and they'll be smart enough to figure out whether to decompose it to iscontract or the ext code size tests either that.
00:28:17.840 - 00:29:04.990, Speaker B: Or solidity to add a, you know, some kind of if defined or whatever, a conditional compilation that could, you could say, if I'm compiling to EOF version one, use this code. If I'm compiling to legacy, use this code because it's really in the compilation, isn't it? Whether what you're using, it's not necessarily anything on chain. If you are compiling to EOF, the bytecode is different. So it is at the compiler level that it would be probably most helpful.
00:29:05.970 - 00:30:01.330, Speaker G: For solidity, even the is contract. So on the address type there are a bunch of helpers like this, like balance code code hash. There was an issue to introduce is contract which would perform the Xcode hash or Xcode size comparison. There's an old outstanding issue for this, it was never implemented. And there was another one to expose the EVM version, which wasn't implemented because the problem it has is optimization. And the new pipeline solidity has would be much better at that. So the optimization issue, if they had implemented at the time, then it wouldn't remove the dead code path for any of that.
00:30:01.330 - 00:30:03.654, Speaker G: Therefore it wasn't done.
00:30:03.742 - 00:30:04.370, Speaker A: But.
00:30:06.070 - 00:30:29.470, Speaker G: These are long, outstanding issues in solidity, and this basically comes up every single time there's a big breaking change, even in the EVM. And I recall that open Zeppelin took at some point like a year to transition to a new version of solidity. I don't think there's really a way around that. Probably the same going to happen.
00:30:32.690 - 00:30:41.028, Speaker A: And this is something as subtle as push zero, right? Yeah.
00:30:41.044 - 00:30:52.200, Speaker G: I think open Zeppelin at least doesn't has that many low level optimizations, so it's not an issue for them, but something like Soledad definitely is affected by post zero.
00:30:53.420 - 00:30:55.680, Speaker A: Okay, and then what were you going to say?
00:30:58.940 - 00:31:54.800, Speaker B: Yeah, I mean, I've even seen in the Taika contracts they have a, you know, try and detect whether certain things are supported, and I think it happens on, on chain. I'm not sure how. Yeah, look at that. Yeah, but it is a problem that there's no way to conditionally compile to what you're, what the target is and produce the correct bite code. I think in Taiko it's the, they use, what's it called? Tea store in tea light condition.
00:31:58.960 - 00:32:03.540, Speaker A: Yeah. Transient storage. Such a simple change and so divisive.
00:32:05.080 - 00:32:22.530, Speaker B: Yeah, but there's no way to detect the event of the, what you're compiling for supports them. And it would be a lot easier if it was done at the compilation time rather than something on chain. You've got to configure.
00:32:23.190 - 00:32:29.050, Speaker A: If only there was a header format where we could signal that we need the new t store instruction before you load it in the blockchain.
00:32:33.030 - 00:32:35.890, Speaker B: I mean, the solution, sir, just needs to resurface.
00:32:36.710 - 00:33:00.670, Speaker A: Okay, so how do people feel about is contract? Besides those issues would, the main alternative would just be to open up ext code size and ext code hash. And those would address the issues of am I dealing with. Yeah, go ahead, dragon.
00:33:02.570 - 00:33:18.540, Speaker C: This contract does makes a lot of sense, to be honest. I in support for adding it. It solves the problem to check if the account is contract, not basically, that's the main purpose, so it makes sense to add it.
00:33:19.680 - 00:33:53.588, Speaker A: Okay. Yeah. So let's review the alternatives. The extra argument for the exe call, we would have to do that now or not do later, but it seems a little overwhelming. In addition to the extra status code, no opcodes return two values currently. So that would break a lot of assumptions. Exit code status also and register.
00:33:53.588 - 00:34:24.050, Speaker A: And so from here re enable exd code size is something we could easily do in the future. Reusing ext code size using the opcode was also considered but rejected. I mean, that would solve a lot of this compiler if all they're looking for is greater than zero. But if they're looking for anything like they're testing in the code size of another implementation, that might cause problems.
00:34:27.790 - 00:34:38.350, Speaker B: Yeah, I mean that would result the conditional compilation issue, but yeah, as you said, it would be returning junk if they wanted to actually use the value.
00:34:41.330 - 00:34:42.190, Speaker A: Peter.
00:34:43.250 - 00:35:06.080, Speaker F: So one last ACD, there was a mention from someone from the A team that this would be problematic. So I wanna, I want to reach out to this and these people and just try to get a like proper write up or just a description of the problem so that we can put in here. And this is why one of the sections is still at TBD.
00:35:08.020 - 00:35:08.740, Speaker A: Okay.
00:35:08.860 - 00:35:18.880, Speaker F: Once the dust settles and on the CIP and maybe it's even merged, then I will reach out and try to get all of them.
00:35:23.670 - 00:35:30.878, Speaker G: By the way, in the chat I linked the two solidity issues I referred to, if you want to put that into the text. Anna.
00:35:31.054 - 00:36:01.620, Speaker A: Okay, yeah. What was the other one?
00:36:14.690 - 00:36:32.030, Speaker G: Right, I think the. Yeah, I just remember what the issue with the EVM version was that even on the assembly parsing level, it would need like short circuiting to avoid the other path because it would have instructions not supported on the given EVM version.
00:36:46.380 - 00:37:13.382, Speaker A: Okay. Got those added to the notes and I got the formatting. Right. Good deal. Okay, so it doesn't sound like there's any action today on this contract. We should all review it, wait for it to get merged by the EOF editors, and then we can. I think the next big action is we need to have a review from the AA team.
00:37:13.382 - 00:37:53.090, Speaker A: I think Peter mentioned Peter was the one that mentioned he was going to reach out. Right? Did I get that right? Yep. Okay. So once, because I think, I think AA of all of them, because that was actually one of the, you know, arguments, was like, no, we should ignore it and just live with the account abstraction future where everything's going to be a contract and this is pointless. But yeah, so we need to get that from the AA team. Okay. So yeah, review this and in two weeks perhaps we'll have some action items we can have off of this.
00:37:53.090 - 00:38:27.910, Speaker A: We won't be in Devnet for in two weeks. But we might be a week out, so that is one thing we need to keep in mind. Probably we're going to be at least two weeks out, though. I don't think we're going to do a solid two weeks on Devnet three. I would be impressed and happy if that happened, but I don't think that's where we'll be. Any other things we need to discuss? Any other implementation concerns as we push towards Devnet four? I wish Geth would call in. I really think we need their representation here.
00:38:27.910 - 00:38:37.810, Speaker A: Okay. Any other things we should discuss before we end the call?
00:38:38.830 - 00:38:45.410, Speaker C: What about Aragon? They said they close to finishing uf. Yeah.
00:38:49.830 - 00:38:51.890, Speaker A: There's no one from Aragon on the call, are they?
00:38:55.280 - 00:38:56.420, Speaker C: I don't think so.
00:38:56.960 - 00:39:13.660, Speaker A: Because Aragon two is what we're talking about. Because Aragon three, which is not ready for production yet, is using EVM one under the covers. So Aragon three, I think is covered. It's Aragon two. And have they forked significantly from their Geth EVM code or are they still bringing a lot of that in?
00:39:14.720 - 00:39:40.110, Speaker D: I think it's more complicated. Oregon two can use EVM one, but it's experimental integration. Oregon three, it's go only right now, so it cannot. But I think they working on the implementation, but I don't know what the. What the status is.
00:39:43.330 - 00:39:44.288, Speaker A: Okay.
00:39:44.474 - 00:39:52.760, Speaker C: And Ben, what did you say about nethermine? What's the status on UF and Erp? 7702.
00:39:55.820 - 00:40:24.890, Speaker B: So we're sort of using the Prague test, but 7702 is in a different branch, so it's not in. So where? The reof's on our master, but 7792 is not merged yet. We'll see how it goes.
00:40:25.590 - 00:40:26.046, Speaker C: Okay.
00:40:26.078 - 00:40:28.650, Speaker A: And 702 will land in master first, right?
00:40:29.550 - 00:40:36.930, Speaker B: Yes, but I'm happy enough for the test to change to only target power.
00:40:37.580 - 00:40:38.480, Speaker A: Okay.
00:40:39.220 - 00:40:44.400, Speaker B: And then we'll deal with whatever fallout comes from that.
00:40:45.380 - 00:40:49.400, Speaker C: Are you running uf validation? Basically tests?
00:40:50.940 - 00:40:51.720, Speaker B: Yes.
00:40:52.220 - 00:41:15.040, Speaker C: Okay, cool. What else is there to be done? Regarding uf? You need to run other tests. We have a three types test, east Ethereum test and EVM one suite. So you're running just Ethereum test or are you running east tests?
00:41:18.500 - 00:41:22.400, Speaker B: I think maybe to see if there.
00:41:23.780 - 00:41:32.400, Speaker A: I looked at your code and it looks like you're actually pulling the current published releases. But you're not running the e s t from an unfilled python?
00:41:34.840 - 00:41:41.780, Speaker B: Yes, we're running the publishment. The textures.
00:41:43.640 - 00:41:44.420, Speaker A: Yeah.
00:41:48.800 - 00:41:57.740, Speaker C: If you need any help, just ping us and at least looking at the traces around that. Yeah. Okay, cool.
00:41:58.250 - 00:42:39.930, Speaker A: Yeah, and I guess on that we probably need to get a new set of fixtures published by the end of the week. I need to finish up the pr that's testing legacy opcodes. So right now the head of ESt is broken with ext call up codes are actually being called in legacy code which should not be allowed. So manning tests to make sure that ext. That all EOf codes are not called with legacy verifying that they break. And I need to finish that to make sure it breaks in a NIC code and a couple of other usage patterns that Mario wants. But once I get that in, I think we should probably get another set of fixtures out and publish and that'll I think, help speed some people up.
00:42:39.930 - 00:42:41.942, Speaker A: I think.
00:42:41.966 - 00:43:03.450, Speaker E: I already left some reviews for both yours and Peter's pr. Yeah, just let me know whenever you want the new release. Maybe we can wait for this to prsitive because I think the state test fixtures is going to take a little bit more. Maybe only these two prs and then we can release.
00:43:04.230 - 00:43:10.170, Speaker A: Yeah, once one of those gets merged we can release because that fixes a bug that I put in, unfortunately.
00:43:11.790 - 00:43:25.680, Speaker F: Yeah. So I have one more pr in the pipeline which is regarding uof create gas costs, but it's still. I got. I got stuck with something else on the way, so it will.
00:43:25.840 - 00:43:27.192, Speaker E: Which number is that?
00:43:27.376 - 00:43:29.740, Speaker F: Not yet. Not yet pushed.
00:43:31.840 - 00:43:32.496, Speaker E: But yeah, just.
00:43:32.528 - 00:43:37.420, Speaker F: Just heads up, but this will surely need to go after the release.
00:43:40.720 - 00:43:41.700, Speaker E: Sounds good.
00:43:46.810 - 00:43:52.230, Speaker A: All right, anyone else got any open issues? Any subject at all?
00:43:54.050 - 00:44:00.722, Speaker C: One more client. We may be missed. Ethereum J's. So I'm not sure. I mentioned the status of those.
00:44:00.786 - 00:44:31.150, Speaker A: Yeah, yeah, I mentioned them at the top. They do have a fuzzing interface so I was able to drop a few fuzzing things there. I don't know how to execute their fixtures from a command line because if I. If I can get how to execute their fixtures from command line, I can run it in my own scoreboard test that I posted from my markdown link I've got. I posted. I run scripts to run all of these. So.
00:44:33.370 - 00:44:39.320, Speaker B: Hopefully a number of the failures from our side have been fix a little bit.
00:44:39.740 - 00:45:16.590, Speaker A: Yeah, I think there's probably like maybe three more issues related to like jump f and some pricing. So it should be fair. They shouldn't. There's less fixes than failures. I would say we're getting to that part of the test where we're causing the same failure multiple ways, multiple times because that's where the bugs creep in. All right, give everyone. Ten minutes back.
00:45:16.590 - 00:45:21.150, Speaker A: Thank you for calling in. Thank you for participating in implementing. It's been a pleasure.
