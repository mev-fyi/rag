00:02:09.324 - 00:02:10.624, Speaker A: Over here, I guess.
00:02:10.924 - 00:02:18.164, Speaker B: Okay. Zoom should be live on my stream. Let's see if it shows up on YouTube.
00:02:19.224 - 00:02:39.444, Speaker A: Okay. Okay. I think I see it. I know I see it. So thank you, Tim. Okay. Yeah, I tried, Barnabas.
00:02:39.444 - 00:02:55.966, Speaker A: Okay. Sorry again for the technical difficulties. Here's the agenda. We'll go ahead and get started. We're a few minutes behind. I am apparently really bad at operating obs, so apologies. Let's see here.
00:02:55.966 - 00:03:21.266, Speaker A: This is consensus layer, call 133. And, yeah, the agenda is not too packed today, so we'll kind of see how things play out. And, yeah, I think we'll just go ahead and hop in. So, first up, Roberto had an update on confirmation role research he's been doing. Roberto, I think you wanted to share some content. Great.
00:03:21.410 - 00:03:43.968, Speaker B: Yeah, thank you. Yeah, yeah. So this is a work done by myself, Adicia, Francesco, Luca and Chini. We've been working on this for a while. Just give. It's something I think Khadija presented some time ago. But given that there's been some time, I thought of giving a brief overview of what the confirmation rule is.
00:03:43.968 - 00:04:29.244, Speaker B: And it's an algorithm that allows determining whether a block will always be part of the canonical chain. Even though it's, of course, if a block is penalized. We know that. But the idea is to be able to apply these to blocks that are not finalized yet another way it can determine that a block will never be reordered out under some assumption that we'll see later. So there are two properties. One is safety, which is basically what I just said. Essentially, when the confirmation rule says that the block is confirmed, then it means that this block will always be part of the canonical chain of any honest validator.
00:04:29.244 - 00:05:20.244, Speaker B: But there is also another property that is one that we kind of been busy working on that is actually not that easy to get, is monotonicity, meaning that if a validator sees that a block is confirmed, now, it will keep seeing that block as confirmed. So the two things are different. You know, it could be that you see a block that is confirmed and it will be safe. But then let's say in a few minutes, you check it again, and the algorithm says that it is actually not confirmed, even though it's actually safe. So. And kind of the two properties, they, like, fight with each other in a way. You know, trying to achieve both has been a bit of a challenge, but that's one of the things we've been working on.
00:05:20.244 - 00:06:09.014, Speaker B: So just very quickly, how it works, it's kind of. It's a bit more complicated than this. But overall, kind of the algorithm looks at two aspects of Gaspa, LMD and FFG. For LMD, we look at the ratio between the weight for a block and the maximum weight, and this must be larger than what you see on the right hand side. Half, yeah, whatever is written there, half of this one plus the weight of the proposal boost divided by maximum weight plus beta. This must be, must be verified for all the blocks in a chain until the finalized one. And then for the FFG component, we check again, high level.
00:06:09.014 - 00:07:16.974, Speaker B: We check that. We check that essentially the FFG that is supporting the checkpoint of a block minus what beta is again the, the maximum adversary weight, minus basically what can be slashed, plus one, minus beta, which is the weight of the honest multiplied by the ratio of the honest multiplied by the weight of the remaining slots. This must be larger than two thirds of the total weight of paper. And this, the paper we showed these last two together with other conditions to ensure that this block will never be filtered out by the for choice filtering rule. And so the two things together that we allow to determine that this block is safe. So as for there are some assumptions made in terms of safety, I think that pretty expected properties. We need to assume the network is good synchronous.
00:07:16.974 - 00:08:13.360, Speaker B: You know, we have finality for when we assume the network is not synchronous. Also, we assume that given us any sequence of slots, we know that no more than bit of the state controlled by these committees is byzantine. This pretty standard is pretty sort of probabilistic property. We assume again beta is less than one third. And also we assume that byzantine validators cannot delay for more than one epoch the inclusion of attestations that justify a checkpoint from the previous epoch. So basically, if by the end of the current epoch, enough attestations have been sent to justify the checkpoint from the current epoch, by the end of the next epoch, these attestations will be included in a block in one chain. In a way, you can think of this like there will be at least one honest proposal.
00:08:13.360 - 00:08:53.423, Speaker B: True, there are limitations on the block size, but another way is also to potentially think of a change where you allow to include more attestations. If those end up justifying a block. In terms of to actually achieve monotonicity, we need stronger assumptions. Beta must be less than one six. And also in a way we assume that there is a new checkpoint, that is, there is always a new checkpoint that is justified in future epochs. The actual assumption is more complicated at this point. You can think it in this way.
00:08:53.423 - 00:09:44.458, Speaker B: Lastly, another point that we've been working on that wasn't present in the forced work was it's been dealing with entering exits, rewards and penalties. So section five, the paper. So we, the paper represent the algorithms in increased order of complexity. We start with just considering LMD cost, then we move to considering FFG. And then we also initially considering only basically no changes to the validator set except for slashing. And then in the last section we show an algorithm that can actually deal with entry exits, rewards and penalties. Actually the structure of the algorithm is exactly the same as the one that doesn't deal with this problem.
00:09:44.458 - 00:10:35.392, Speaker B: The only thing that changes are the thresholds that I showed you before. So those thresholds in the more extended algorithm, they also have components that take into account reward ratio, penalty ratio and churn ratio. Currently there is. The spec PR of the confirmation rule has been updated as well to reflect the algorithm that we have in the paper. The algorithm there is the one that does not assume entering exit rewards and penalties just because there wasn't enough time. And again, as I said, it's just the only difference here. Some factors that must be multiplied in the former but the overall structure is the same.
00:10:35.392 - 00:10:44.804, Speaker B: So in our opinion that spec PR is ready for review and for comments. And this is all from me.
00:10:49.724 - 00:10:58.468, Speaker A: Great, thanks. Do you mind dropping a link to the slides or if there's somewhere people could follow up with your work that'd be really.
00:10:58.516 - 00:11:01.584, Speaker B: Yeah, yeah. Interrupt affiliates.
00:11:12.884 - 00:11:43.544, Speaker A: Great, thanks. Anyone have any questions? Okay, also a pr indication, specs repo. Great. Yeah, thanks, Roberto.
00:11:45.844 - 00:11:46.784, Speaker B: Thank you.
00:11:50.404 - 00:12:34.784, Speaker A: Okay, I wanted to queue that up first. Just go ahead and work around the time zones with Roberto. So next up we'll move to Electra. Again, there was a quick question about EIP 7547. This is the inclusion list EIP Andrew is asking essentially if the IP won't go into Electra, should we change the CFI status? I think that was. I don't know if Andrew's on the call, but either way that was basically the question. Generally, I think if we CFI something, there's no formal bearing on inclusion in this sense.
00:12:34.784 - 00:12:40.404, Speaker A: And so we don't really uncfi things. I don't know if anyone feels differently.
00:12:47.744 - 00:13:14.606, Speaker B: I guess. Yeah, usually what we do is we just uncfi it when we have a final scope for the fork and we just remove everything that's been CFI'd and just keep the stuff that's included. If it's simpler if like we really agree now that we're not gonna do this, we can all, we can remove it from the list now, but yeah, no strong opinion it'll get removed to.
00:13:14.630 - 00:13:24.634, Speaker A: Delay for the time being. Yeah, I mean, in some sense CFI is almost like immortal status. You could imagine if something's been CFI'd, it's always CFI.
00:13:25.974 - 00:13:30.714, Speaker B: Yeah. At least for this fork. Right. And then can discuss for the next one.
00:13:31.104 - 00:13:32.964, Speaker A: Yeah, yeah, I guess it can change.
00:13:35.944 - 00:13:36.804, Speaker B: Okay.
00:13:39.584 - 00:14:10.174, Speaker A: Okay, next up, wanted to get into Devnet zero and everything there. So the first thing to call out there was a spec release, v 150 alpha one. I think this is mainly bug fixes for the pector specs, also pure dos test vectors. So thank you everyone who got that together in particular. Shaoi. I can go grab a link to them in a second just so everyone has that otherwise. Yeah, I think.
00:14:10.174 - 00:14:27.474, Speaker A: Were there any questions or things to call out on the spec there? I think it was pretty straightforward. Just fixing some bugs from the Alphazero release. Yeah, sure.
00:14:29.414 - 00:14:29.814, Speaker C: Yeah.
00:14:29.854 - 00:15:13.144, Speaker A: So we have received at least two issues of the test vectors in the latest test vector release. So I think I can. I will share the link to the chat later if any clients have test it and just let me know if you encounter some issues. And I expected that we will have another hot fix of the test vector early next week. Yep. Great. Thank you.
00:15:13.144 - 00:15:54.720, Speaker A: Okay, next up, I did want to talk about just general progress and where everyone is. Let's see. Barnabas dropped this progress tracker in the chat. I'll go ahead and take a look here. Yeah. Do client teams want to give an update? How are we feeling about Devnet zero implementation progress? So for Lighthouse, I'd say we're making progress. We're mostly focused on the changes related to moving the attestation index because we were talking about that in discord a bit.
00:15:54.720 - 00:16:23.484, Speaker A: But it does end up being. It touches a lot of the code base. So that's the majority of our focus right now. We're actually staging our implementation differently than per EIP. We're implementing all the ips for different components of the code base as we go. So it doesn't quite map to the progress tracker, but solid progress. And we're grinding, I would say.
00:16:23.484 - 00:16:29.524, Speaker A: Great. Sounds good. Anyone else?
00:16:33.384 - 00:16:36.364, Speaker C: Oh yeah, go ahead.
00:16:36.984 - 00:17:22.414, Speaker D: All right, thanks. We have also made decent progress and we for 7549 we are working on few things, but mostly things seem done. As of now we are making few changes regarding with treating the partial withdrawal request in the new format. But yeah, we should be ready pretty soon. And for ethereum J's, I just want to add yes on that. On that end, as well, we are doing good for 7.6. We have incorporated 7685 and are sort of integrated into individual eips.
00:17:22.414 - 00:17:24.454, Speaker D: Yeah, thanks.
00:17:26.314 - 00:17:28.442, Speaker A: Great, Enrico.
00:17:28.538 - 00:18:11.796, Speaker C: So back to tackle. We are complete on 6110 and 7002 and we are close to be ready for the Max EB VIP and work in progress. For the attestation one, this is 7549. What is missing there mostly is the aggregation logic, but for now I guess we should be able to follow, um, a chain in theory. So yeah, still work in progress there and finalizing Maxib, the TLDR.
00:18:11.820 - 00:19:45.562, Speaker A: Is there an update for Prism? All of the eips are being worked on, but we're taking a similar approach to Lighthouse where we're sort of handling cross components. We're doing like all the block changes, all the state changes sort of separately. And the 7549 slowed us down a little bit because of how many things it touches, but we're making progress. So for grandini team, we progressed a lot on all the eips except that there is really huge work still need to be done on attestations, refactoring. So I did raise this question on Telegram, but it feels from the update from the other teams, it feels that other teams are progressing quite good and it doesn't feel that the teams will not be able to do this huge refactoring. So correct me if I understood that incorrectly. Yeah, it sounds pretty good so far.
00:19:45.562 - 00:19:48.054, Speaker A: I think. Dustin, you're going to give an MS update.
00:19:50.254 - 00:20:48.720, Speaker E: Yeah, so I was in, Jeff, I don't know. I'm going to echo in terms of say what White House was saying about like not implementing, I'm going EIP by eap but rather say sort of set of test vectors by set of test vectors or set of sort of support of code base. Code base by portion of, portion of a, of code base. That being said, viewing it by EIP, I think I would say as far as I can tell, we're okay on 6110 for, from this is the Cl side, obviously. Six thousand one hundred ten s, seven thousand two and seven thousand two hundred fifty one. I believe those should all be, I mean, at least okay enough for Devnet zero as usual. As.
00:20:48.720 - 00:21:36.498, Speaker E: And this is, I would agree that this is 7549 is a challenge and it's, I don't know, it's underway and I guess my approach here is to try to make sure that there's something it can, minimally they're kind of following the chain is my, I mean, criteria here. So there may or may not be able for some, for the 7549 related stuff. I'll just say this. For example, Nimitz has no intention of posting attestation slashings. Like, it's not, it's fixable. It's not worth fixing in time. That's one of the things affected.
00:21:36.498 - 00:21:40.744, Speaker E: It's one of the little bits of fallout from 7549. We didn't know.
00:21:41.044 - 00:21:43.224, Speaker A: You just mean for Demnozero, right?
00:21:46.204 - 00:22:08.896, Speaker E: Yeah, yeah, eventually. But it won't break consensus and other clients. But we've had a fire attack, but we're attempting to get this working. We have. It looks maybe okay, but I.
00:22:08.960 - 00:22:09.136, Speaker A: But.
00:22:09.160 - 00:22:24.124, Speaker E: But for a very limited view of. Okay, honestly, like, this is. Yeah, I don't know, it. Hopefully it will work well enough.
00:22:26.984 - 00:22:27.724, Speaker A: Great.
00:22:29.344 - 00:22:38.074, Speaker E: Nimitz does a lot of type level stuff in it construction and it's. Yeah. So. Yeah, the rest are there.
00:22:38.734 - 00:22:54.334, Speaker A: Yeah. Cool. Yeah, I'll take well enough. Great. I think that was every cl team. And yeah, it sounds like things are progressing well enough. Ideally we should be looking at Devnet zero, say in ten days.
00:22:54.334 - 00:23:34.434, Speaker A: So I know, again, it's like a very tight timeline, but, um, sounds like everyone is moving towards that. So I think we keep things as is. Uh, there was this question brought up of maybe changing Devnet zero scope. Um, it sounds like, again, this attestation refactor is like pretty involved for everyone, but also it sounds like at least one or two teams are pretty confident that part will be fine. So yeah, I guess this is now your chance. If we want to have this conversation we can, we can talk about this, but I think generally we should keep things as is for the time being. Does anyone feel incredibly strongly otherwise?
00:23:37.214 - 00:23:59.684, Speaker C: Going back for Tago will be a super pain and I would think that we will stick, we would stick into the attestation no matter what. So if the thing is to participating or not participating in Devnet zero, I would say if we go back, I don't know if tech will, will be able to participate at this point.
00:24:01.224 - 00:24:30.134, Speaker A: Right. And the thing is, we do just need one cl and one el to start a Devnet. So if it takes a day or two after, say, this ten day deadline for others to join, we can still make progress on the actual initial Devnet as other people round out their implementations. So I know it's a very tight timeline and yeah, it's, I'm sure, very stressful for everyone, but it sounds like we can make it. So I would lean towards keeping everything as is for now.
00:24:40.834 - 00:25:50.034, Speaker E: So I guess one, I'm a little less concerned with whether it's in Devnet zero. And I think that's sure. But the question of, I guess my concern is that this seems to have, have potentially snuck in a little bit as a, let me say it was framed during the ACD call as a more minor change that ended up being. And part of this I think is in terms of the logic of the change, there wasn't a huge amount in some web, at some level it's quote unquote, just moving a field around. It was not pages of if then statements. And so I guess I have some kind of process concern there of sort of. I think that there was a process failure in a way.
00:25:53.494 - 00:26:11.634, Speaker A: Yeah, I kind of get that. It definitely looks a lot simpler spec that than like actually an implementation. And it seems like, I don't know, how do we readjust our, I guess, fork scoping after we start the implementation, if we, if we want to. In the future.
00:26:18.134 - 00:26:59.524, Speaker E: Yeah, exactly. I think, I think that's a good way of putting it. And to say that I think every one of these, these eips, which was considered, which has been considered, people have looked at in their various ways, kind of the phrase it, in various ways, rois, the risk return, uh, the, the benefit, cost benefit, some kind of, relatively speaking, a ratio. Is it worth implementing this EIP? And this one was framed as kind of, well, why not? Isn't it kind of nice? Um, and maybe, but.
00:27:01.324 - 00:27:50.444, Speaker C: And to add to that, I think there's really some. Sorry, I was just adding to your comment about saying that the initial framing of that was also that it will be some very nice benefits in terms of networking. And there has been a little bit of misconception initially and then this turn out that it's just block space that benefits for it in the current form. And you're right that we probably underestimated the impact in the code basis because touching the testation that is simply the same for since phase zero has been underestimated, how painful would have been to change the format even just adding a field.
00:27:51.664 - 00:28:18.714, Speaker A: Yep. Yeah. I mean, I think that makes sense of what everyone's saying, you know, takeaways. I think in the future when we touch types, we should just be very mindful of this. Again, it seems like, I mean, there are benefits. It's not that it's useless eip. And if anything, I think it does lay the groundwork for future changes around networking that would unlock even more benefits.
00:28:18.714 - 00:28:39.044, Speaker A: So I think the Eap stays in. Yeah, definitely hear everyone that this is a big change implementation wise, but sounds like we'll make it work? Yeah. Dapline. Yeah.
00:28:39.124 - 00:29:26.264, Speaker F: Just to remind a bit, I think what happened here is the original EIP had a slightly different implementation. It only set the indexed to zero. So by not having the type change, the fix was supposed to be smaller. But then Mikhail proposed some really nice benefits that we should do and that I think this mutation through the process is, I think what we missed. And as you recognize, that's what increased the scope in terms of implementation. So, yeah, for next time, if any IP mutates, we should be mindful of the consequences, even if it's already considered for inclusion.
00:29:29.444 - 00:30:05.324, Speaker A: Right. And just to like, you know, I guess state the obvious, like this is the process, right? Like we have VIP's, you know, if they sound good enough to everyone, then we include them in some sense. And it is the point of like then downstream implementation of that to like sort of raise these issues. I think everyone's just feeling a little extra pain because of pretty tight timelines. So yeah, I hear everyone and yeah, these are all things we should be keeping in mind moving forward. And yeah, that being said, I do think that we'll make it happen. So I'm feeling pretty good about it.
00:30:05.324 - 00:31:07.424, Speaker A: Sean, something we're trying to move more towards in Lighthouse is more flexibility with individual EIP implementations. So the ability to enable disable single features and that would let us more easily pull things out of forks, move them to separate forks. If we could similarly move towards something like that at the spec level too, that would be even better because then it'd be easier to get vectors that are testing individual features and then different combinations of features. And yeah, it might help in snare like those. Yeah, and generally we have this like features notion in the consistent specs that gives you that. I think again, maybe just due to the timelines, it's like we didn't necessarily have these test vectors, these independent ones per eip. Just ready to go.
00:31:07.424 - 00:32:00.468, Speaker A: Terrence asked a question. Let me go look at this link. Right? Yeah, so Terrence was asking about an addition to 7549. This was making essentially the representation a little more flexible on chain. And yeah, that is out of scope for Devnet Zero. And yeah, the idea would probably be to include it in later devnets, but again, we are focusing on just Devnet zero for now and then we'll handle that down the road. Okay, well, thanks everyone for your comments.
00:32:00.468 - 00:32:13.184, Speaker A: I think that was some good reflection and yeah, definitely things we should all keep in mind moving forward. Is there anything else? Otherwise we can move on to another presentation on a new EIP.
00:32:18.484 - 00:32:38.594, Speaker D: Could we maybe get a timeline on like when is the first CL would be ready because we initially tried to do it like last week and now we push the time to like the 6 May. But is any CL team actually can see if they would be ready by next week Monday.
00:32:43.014 - 00:32:48.354, Speaker A: We wouldn't be ready by Monday now I think 1010 ish days we're targeting.
00:32:52.134 - 00:33:22.304, Speaker C: We might be have something for Monday but maybe probably high probability with being broken. So we were thinking more about targeting mid next week to have something more stable. But I even see the benefit if we have something kind of working to spin up some devnets by Monday or Tuesday and see where they break.
00:33:25.044 - 00:33:26.980, Speaker A: Yeah we'd be doing this stuff locally.
00:33:27.012 - 00:33:30.504, Speaker F: So the cost of that failing is extremely low.
00:33:32.564 - 00:33:42.544, Speaker D: Yeah I think Devnet zero could possibly wait to Kenya and then we would just do all local testing all next week still.
00:33:53.024 - 00:34:22.334, Speaker A: Okay great. Sounds like everyone will be very busy. Good luck with the rest of the implementation. So next up I think this is vasily. He wanted to give a short presentation over EIP 7684. Would you like to do that? Yeah, I'm going going to post two links into the call chat so be with me for now. Yeah.
00:34:22.334 - 00:35:26.064, Speaker A: So there is an EaP 7684 by Dublin. The GST is at this moment when there is deposit coming for invalidator on beacon chain to the that already exists. Then it doesn't matter what withdrawal credentials are in the deposit that is coming. What only matters what are withdrawal credentials are for the validator that already exists. So imagine there is for example a malicious note operator who is accepting a delegated stake. They provide deposit data to the client, client posts a deposit transaction and the malicious validated front runs this transaction with their own deposit with their own withdrawal credentials. And the staker who wanted to just delegate their header will be gifting them to their malicious not operator.
00:35:26.064 - 00:36:09.944, Speaker A: This is so called deposit front run vulnerability. It's a pretty subtle one. It was pointed out I think half a year before the beacon chain launched. It was actually found in the code of rocket pool and Lido back in the day. And both protocols had to, both protocol teams had to like fix it ASAP just before the launch of rocket pool. As far as I remember this is mostly mitigated in largest protocols and probably mitigated in the largest custodial services like exchanges and custodies. Though the second one is just probably true.
00:36:09.944 - 00:37:15.114, Speaker A: There is no way of checking, but these mitigations are pretty cumbersome or capital inefficient. There are basically two one is just in time checking the deposit like lido does with a special committee to check it. This was in the trust model and development costs, the operation and increased brittleness. There is an option of only allocating stake to the validator that are pre deposited. But this makes model capital efficient because if there is not enough stake coming then these preposterous validators are just sitting there doing nothing. And this makes the process of stake delegation like two step process which makes it more cumbersome and worse user experience. Most of the stake in existence actually just win it.
00:37:15.114 - 00:38:35.264, Speaker A: They don't like clients. The stakers don't check that the validator is not on chain, not operator, does not provide a mitigation that is entirely like a trust issue. I don't think it has been exploited in like in actual life. There is I think like five or six deposits that override with raw credentials, but they mostly look like honest mistakes, like zero x zero withdrawal credentials, something like that. But there is like 7684 proposes a pretty simple fix here. No band withdrawals are possible when a deposit comes with a withdrawal credential that is different from the validator that is actually resistant on bitcoin chain. This either can immediately be withdrawn back to the execution layer, maybe with some fee to prevent spam or something like that.
00:38:35.264 - 00:39:06.684, Speaker A: I think. I'm not sure. I'm pretty sure that it's pretty late to get anything to Petra at this point, but I'm pretty. So this would be a good change for Ethereum stake and mechanism. Got it, thanks. I've had time to look at the CIP in depth. I hear you on the concern.
00:39:06.684 - 00:40:32.014, Speaker A: Does anyone else have any thoughts or comments at the moment? Otherwise we might need a few minutes to digest. I guess one question is, you know, if we wanted to move ahead with this EIP, would you be pushing for Electra, the f star fork? Or you're more just wanting to raise awareness today? My intuition that is like a super small proposal that is entirely can fit, I don't know, but not much work. But I'm not a client developer and that's what I wanted to understand. What the feeling people have. Is it something that is so small that can fit into Petra last minute? Or if it's even desirable. Alright, what's the public sentiment on this? Or that is like just something that I'm presenting for now to raise awareness. Yeah, that applied.
00:40:32.894 - 00:41:23.974, Speaker F: Yeah. So regarding complexity. So unless someone finds a clever, more clever way to do it than what I found, there is an interesting quirk about withdraws and after EIP 61110, there is a recursive dependency on building blocks. The execution layer needs to be supplied from the consensus layer. What are the withdrawals that have to be processed? And then the block of the consensus cannot be dependent on these withdrawals. Otherwise we have a recursive dependency. So the solution of this EIP is to evict immediately any withdrawal that attempts to.
00:41:23.974 - 00:42:18.694, Speaker F: To have a different withdrawal credentials. But because of this recursive dependency, we cannot immediately withdraw a deposit. What that means is that we have to accumulate the withdrawals in the state and then process them afterwards. And after Eip six, one, 1110, the amount of deposits is not bounded anymore. And I think the maximum number at coolant gas parameters is about 1200, which means that either we can have an unbounded queue of pending withdrawable deposits on the state, or we have to remove the cap of withdrawals if we want to evict all these undesirable withdrawals at the budget. Sorry. Within the next block.
00:42:18.694 - 00:42:47.754, Speaker F: So that's something that we have to talk with the execution teams to see how much of an issue it is to have unbounded withdrawals or up to 1300. So it's not terribly complex, but definitely, I would not consider something trivial. I think it's good that we look at this solution and see if we can find something simpler, but I'm not sure if this fits for electrons.
00:42:51.814 - 00:43:11.294, Speaker A: Right. Yeah, thanks. I mean, I think we probably need a couple months just to digest, consider different solutions, and then get to the final EIP. So that process will need to play out. And then ultimately, I guess this is the place to come back. Once that's done, we can. We can see where things have stacked up.
00:43:18.794 - 00:43:49.114, Speaker F: And as a final comment, I think to. To motivate the solution, this does not. This affects every single LST or future LSD protocol. And especially for those that want to be maximally trustless, definitely all the solutions involved some sort of heavy trade off or centralized actor. So it's definitely an unequalizing force, agnostic to any specific LST.
00:43:57.294 - 00:44:42.328, Speaker A: Yeah. In general, like, this is attacks on development instead of, like, a straight blocker for implementing, like, trusted things. But it's a pretty significant task, actually, a lot of efforts going into, like, mitigating this. Okay, good to know. So, yeah, everyone just please take a look when you have some time and, yeah, we'll keep it on our radar. Okay, next, I wanted to leave some time for pure Dos. I don't know if anyone has any update there.
00:44:42.328 - 00:45:08.624, Speaker A: I know the client teams have been pretty busy with pectra. There has been some work on spec lately. Like I said, there are some test vectors even released in this alpha one consist release. So it's really exciting to see the progress there. I don't know if anyone else has anything they want to discuss right now with respect to pure DOS, either an implementation update or spec update, spec questions, anything like that.
00:45:14.044 - 00:45:35.234, Speaker D: I've been working on peer desk for last two weeks and basically we'll try a local lobster to loadstra all custody testnet and if that works then we'll try to integrate with any other peer that is out there.
00:45:40.494 - 00:45:42.062, Speaker A: Great, good to hear.
00:45:42.198 - 00:46:54.354, Speaker F: Yeah, Lighthouse I think as of yesterday we can we have completed sampling sampling lighthouse only testnet. So we can so as of now we can produce blocks with garbage extended data. We are not actually using CKCG library yet. I think we can cost 2d, we can serve cost two d, and we can do sampling some specifics of what we are going for. We are going for trailing DA at the moment we are not using yet the neo network charts formula, but we plan to do that this week and we implemented a feature that was suggested by the Codex team I think where we allow, so as a cost to the serving, we allow people to request the samples before we have them and then we put that request on hold and we will resolve this request once we get the cost to the samples from gossip. So will be cool to agree on the set of features with everyone, otherwise we'll have interrupt problems. That's it for me.
00:47:00.814 - 00:47:46.674, Speaker D: Yeah. So on Prism Sen, we've been making good progress on peer dust implementation. We are right now in the process of trying to get prism to prism node working. So we have integrated all the CKCG paradise methods, so it seems to be working for us. We started running into issues with getting the columns gossiped out, having a blog proposed with the extended columns being received by the other prism peers. But we are positive that by interrupt we will be able to communicate with other clients, at least as the current spec as it is.
00:47:50.814 - 00:47:52.274, Speaker A: Okay, that's great news.
00:47:57.634 - 00:48:16.294, Speaker C: Just an update from Teco. I don't have the details, but there is a branch in working progress and we could have something. Yeah, we could hack something maybe during the interrupt, but not sure.
00:48:20.834 - 00:48:33.754, Speaker A: Okay, sounds good. Yeah. Dapline I think I might have glossed over this was did you have a question around the spec or sort of what to initially target?
00:48:36.614 - 00:49:35.674, Speaker F: Yeah, so I think that the two questions, and I'm not sure if the spec is precise on this. So first one is if we're going to do trailing DA or since DA, I don't think we have agreed on either way yet. And then the second one is this feature of if someone requests your custody column that you are supposed to have but you don't yet have, instead of returning immediately resource unavailable, you hold this request for some time in the expectation that you will get a column, and if you do not after some time out, then the request gets canceled and that's okay. But if you get the custody within this window, then you resolve the request and what that allows is to have a zero lag dissemination mechanism without actually having to do many retries or having gossip amplification.
00:49:38.774 - 00:49:56.694, Speaker A: Right. The latest I heard on the first point with regards to the trailing for choice, I think Lighthouse was thinking that they would not do it, but then the latest I heard is that they would do it. So I'm not sure anyone else has enough implementation to have like a strong view on that right now.
00:49:57.114 - 00:50:50.124, Speaker F: Yeah, I can summarize. We had a chat internally about this and I think the, what we realize is that if you don't do trailing DA, then the timing gain pressure would be very high because you will be supposed to perform all the sampling within a very short time window between when you receive the block and when you have to attest. So those peers that do not have very, very fast Internet connections, they will suffer as builders and proposers will delay the block as much as possible to get enough votes at the expense of the slowest peers on the network. If we do trailing day, then at least you would have 12 seconds and then there is no much pressure. You only have like, the situation would not be worse than today. You just have to press the block soon enough.
00:50:52.944 - 00:51:02.952, Speaker A: Right? Yeah. I wonder if there's a middle ground. We've talked before about moving the attestation deadline to say like 8 seconds rather than four, which with respect to timing games maybe doesn't change much.
00:51:03.088 - 00:51:11.088, Speaker F: No, I think that doesn't fit against anything because then you would just publish the blog later, right?
00:51:11.216 - 00:51:11.924, Speaker A: Yeah.
00:51:17.704 - 00:51:18.080, Speaker B: Yeah.
00:51:18.112 - 00:52:12.028, Speaker A: So I can't speak for Pierre Das, but if by training the a it's only this, its own four choices, this implementation of filtering the branches where you don't have them and act like that, that would be a very simple change in for choice for prism, so it's easy to implement. Okay, that's good to hear. It seems like. Yeah, the consensus seems to be leaning towards trailing Soyuz. Yeah. For, I think for testnets, maybe it makes sense to not do this tailing workshise just for, just to try and see. Maybe the old way just doesn't work on a small testnet for some reason.
00:52:12.028 - 00:53:00.484, Speaker A: So then we can automatically roll out that. That would be one argument. The other argument that so far the first choice was always, always protected from these blocks that are not available. So far the current approaches is to include the block only when this data available is true. So this trailing for choice is, I would say, very different approach than we have now, right? Yeah, there's another comment from Nishant. We should just increase the custody counts and not use trailing. You get stronger VA guarantees from gossip.
00:53:00.484 - 00:53:22.504, Speaker A: So yeah, it sounds like we're actually kind of undecided on this. You do have a point that maybe just for like initial implementations, it's simpler to do non trailing like synchronous within the same slot, so there's some benefit there. Although it kind of sounds like we are undecided.
00:53:24.244 - 00:53:41.644, Speaker F: Yeah, I think in practice it doesn't matter. We definitely don't want to do that for mainnet eventually, but for an initial interop, people can just sample whenever they want and it should be fine because it's, it only impacts your local view of the for choice.
00:53:48.464 - 00:53:48.920, Speaker A: Right?
00:53:48.992 - 00:54:06.804, Speaker D: Yeah, yeah. For interop, I don't think we need to actually align so much on how we're going to sample because it just matters for your local view. So you could have some nodes doing trailing and some nodes not doing it, and technically the network should still function fine.
00:54:11.184 - 00:55:01.404, Speaker A: Right. So then I guess it sounds like do whatever is easiest for your implementation, at least to get started. And I guess we can come to some star consensus on this down the line. Okay, thanks everyone for that. Anything else anyone would like to bring up? I think otherwise, yeah, we can go ahead and close out the call here in a few minutes. So hand is still up. I don't know if that was from the last time.
00:55:01.404 - 00:55:49.394, Speaker A: I'll assume it was unless you say something. I guess just the conversation now does kind of bring to mind that we might eventually want to break out for pure dos, the biggest of these things. But that can happen after we get the first unnet running. Yeah, okay. Yeah, I mean, that sounds like it for the the day. I do have one final remark. We'll go ahead and cancel the next AC DC.
00:55:49.394 - 00:56:21.818, Speaker A: Many of us will be working at an interrupt, so it will not make sense to have the call. That means the next AC DC will be May 30 at the usual time, so I'll post again in the usual channels just to remind everyone. But just keep that in mind and I think that's it. Thanks, everyone. Thanks. Bye.
