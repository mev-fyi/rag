00:00:07.520 - 00:00:35.160, Speaker A: Oh, I'm muted. And I've been speaking for a while. All right, so welcome to breakout call number nine. I posted a link to the agenda in the chat. I suspect that the best thing we can do is to start with Julianne that wanted to have a brief presentation on issues arising with cloud auctions. It should be a short call. There are not many things to discuss, but it's.
00:00:35.160 - 00:00:39.720, Speaker A: I guess it's better if we start with Julianne. Can you take it from here?
00:00:41.300 - 00:00:48.692, Speaker B: Sure. Thanks. Let me try to share my screen. Is it visible for you guys? Nice.
00:00:48.756 - 00:00:49.400, Speaker A: Yeah.
00:00:50.300 - 00:02:16.678, Speaker B: Okay, so I just wanted to presents a hypothesis for an argument that shows there's a trusted advantage in slot oceans. It's fairly convincing for me, and I've presented some people within robust incentives group, but it's not like, I mean, obviously it's very far from a fully fledged, worked out argument, so please let me know if there's anything. So first of all, what is the nostalgia advantage? We want the Beacon proposal to be incentivized to use the in protocol commitments to commit to the block producer that maximizes the proposal utility. So either it should be the block producer that produces the highest value block, or maybe the proposal has some valuation for producing the block itself because it wants to influence the ordering of transactions. For example, whatever the proposed utility is, it should commit to the person that maximizes it. But the question is, will the proposal indeed use epbs, or will it use MavBoost? So a way that a proposal could bypass EPBS is, for example, commit to itself in the beacon proposer in slot auctions and say, I will produce a block. And then 6 seconds later when the execution payload has to be produced, it runs MavBoost to get other people to bid and thereby bypass the in protocol commitments and use trusted relays and other trusted sources so that it still outsource spot production without using epbs.
00:02:16.678 - 00:03:01.080, Speaker B: And here I present an argument in why in slot auctions a proposal may choose to do so. So consider a very simple model. There's a proposal that can choose to auction at two times, at p zero, or at two and six, or you could say early or late. And there are builders that try to maximize their chaos. Each builder has a distribution of block values it may realize, and at time t zero, the builder does not realize value, it only knows its distribution. And at time t is six, the builder knows its block value. What we see then is that if the proposal were to choose to auction off at t zero, and so they actually use epbs, the builder should bid according to their expected value of the block.
00:03:01.080 - 00:04:14.588, Speaker B: So obviously a builder wouldn't want to bid more than their expected value because then in expectation they would lose money. And depending on the auction mechanism, they should, if it's competitive, be close to the expected value. And if the proposer were to choose to auction off at time tier six, so at a later time, builders should bid according to their realized values. And the key insight here is that the second highest order statistic of the realized values, which is what a proposal may expect to receive at time t, is six, is, under reasonable circumstances, likely higher than the expected block value x on them. So if builders were security bid based on their expected value, this should be lower than if builders bid based on their realized value, because there could be some builder that has an exceptionally high value, for example, or just some value that's higher than their expected value. And this would mean that proposal would choose the late auction. So effectively, it would mean that in EPBsen, Beacon proposer commits to itself in slow touch and etbs, excuse me, a beacon proposer would commit to itself as the builder and then 6 seconds later run that boost and still get a higher price based on the realized book values instead of the expectations.
00:04:14.684 - 00:04:44.050, Speaker C: Can I slow you down for a second? Yeah, just the second highest order statistic of realized values is likely higher than the expectation. It sounds as if you're saying with slot options that this somewhat enables them to. Oh, maybe you haven't gotten to that part, but, yeah, I don't know, it sounds like you were kind of saying that the slot auctions, they get the option of taking the later auction and getting closer to the realized.
00:04:46.550 - 00:05:11.270, Speaker B: Yeah, yeah, yeah. So that's a good point. So in blot auctions, you commit to a specific execution payload hash, so the execution payload can't be changed anymore. And so you're kind of forced to auction off at the time that the protocol describes because the beacon block must be delivered, installs auctions, you commit to one builder, and the execution payload itself should still change later on.
00:05:12.810 - 00:05:30.348, Speaker C: So, yeah, okay. So, yeah, if we do block auctions, then it's definitely bid based on the realized value, but if we do slot auctions, it's based on the expected value. Yeah, okay.
00:05:30.484 - 00:06:04.050, Speaker B: Yeah, exactly. And so the argument here would be in slot auctions, the proposer kind of has the option to choose whether it would want to receive bids based on expected value or bids based on their realized what value. But if it wants to get bits based on the realized what value, it has to commit to itself in the beacon block as builder and then run that boost 6 seconds later. And the argument here is that likely the realized block values would lead to higher revenue for the beacon proposal, if that makes sense.
00:06:06.190 - 00:06:23.380, Speaker C: Yeah, that makes sense. And I suppose, yeah, it's just that I thought this was a argument in favor of slot auctions, so maybe that's why I'm confused or what you're saying in favor of block options.
00:06:24.280 - 00:06:31.296, Speaker B: So I think this should be. It's an argument in favor of blood watchings.
00:06:31.408 - 00:06:39.860, Speaker C: Okay, that makes sense. Okay. I thought you were present. I thought the presentation was done by slot auctions. I was confused.
00:06:40.520 - 00:07:21.946, Speaker B: No, yeah, yeah, I should have specified that, but it's an argument against false auctions. In various other research proposals, such as execution tickets. It's used as an argument in favor, but there are some specifics there that make it good. But yeah, that's outside of this discussion. So the takeaway is that if you choose to auction later, you should expect higher revenue as a proposal. But then there's a bit of a weird assumption underlying this, and the assumption is that a proposer can use MavBoost 6 seconds later to sell the execution payload construction rights. I think this is a fine assumption.
00:07:21.946 - 00:07:34.470, Speaker B: It's what's happening now. And if we were to change the current system to slot auctions and it turns out that it's more possible to do this, then I would expect mavoos to still exist. Yeah.
00:07:35.890 - 00:08:20.622, Speaker A: So I understood the issue. I have no solution to it. I think we need to think about it. But do you have any idea of like how this changes with timings? I mean, how accurate is it? Or do we have statistics as to how much do we expect the difference between the realized and the expected value to be at 6 seconds? Because a proposal that wants to do this will not have much more time. I mean, they won't have the time that they have today into submitting a block. So today to run Mapboost, we're already at the limits of latency that we can have, and to run this thing you're going to have, it's going to be much tighter, I guess. I'm not sure, I'm not sure.
00:08:20.622 - 00:08:44.080, Speaker A: It might be even worse because the proposal would just immediately announce that they're running mapboost. They will just quickly submit their block community themselves at zero. So that block was going to be assured to have proposer boost and then they can just run the mapboost auction at about 5 seconds and play the usual timing games.
00:08:47.020 - 00:09:11.610, Speaker B: Yeah, I think. Thanks. Yeah, so I think I wouldn't know about the magnitude of the difference. I think the difference is surely there. And I believe I'm nothing, uh, super show on these specifics, but I believe that bids are coming in mostly three and a half seconds before the deadline in mav boost these days. So you should have time during the stage, second interval. Uh, and Rico.
00:09:12.750 - 00:10:05.590, Speaker D: Yeah, just thinking about that. Even if, if you think about the, the average. But maybe, uh, just to catch the potential upside for, for the outlayers, where you got a very big Mev thing that happens. So just to be exposed to a very unlikely, but very, very big upside, you have this incentive to say, okay, I'm playing. It's just another way of playing the timings here. Just, I want to pick the very latest thing that happens independently by the mechanism. So the math boost way is the way to keep, to delay the choice as much as possible, essentially is.
00:10:05.590 - 00:10:06.054, Speaker D: Right.
00:10:06.142 - 00:10:40.180, Speaker B: Yeah, yeah, I see your argument. So let me get into it in this slide, because I think it's slightly different. So maybe I don't summarize well what you're saying, but it sounds to me like you're saying, if there is some possibility of larger value, I'd want to wait. And this sounds a lot like a risk transfer. So the proposers, uh, is basically either the builder could bid early, uh, and the proposal gets a fixed value, or it could wait and have a more volatile value that it gets some, uh, risk reward ratio, basically, I think so. Uh, yeah. So you can respond to that.
00:10:40.560 - 00:10:42.344, Speaker D: Yeah, yeah, I think you're, you're getting.
00:10:42.392 - 00:10:42.980, Speaker A: Right.
00:10:43.680 - 00:11:12.650, Speaker B: Okay, thanks. Um, so I think this is slightly different from. Yeah, let me just quickly finish this full. And then, uh, I think it's slightly different from a risk transfer because in this, I assume that the builders can also effectively resell their execution payload construction rights. So that's the second point on the slide with the question mark. This is an assumption I make here. If a builder would be able to effectively resell, then this result doesn't exist and proposers would probably sell early.
00:11:12.650 - 00:11:28.488, Speaker B: But then to ensure that builders could effectively resell, it means that you have to have a secondary market pop up. So I think the true results here is that whether sloth auctions have a trusted advantage or not really depends on the state of the secondary market, and it's quite fragile.
00:11:28.584 - 00:11:35.140, Speaker D: So, yeah, I got this. Yes, yes. Now I see what you're making.
00:11:37.840 - 00:13:01.260, Speaker A: So, part of a mitigation to this is, I think I got something wrong. So, a proposal that wants to participate in this way should not submit at zero, committing to get an auction later, because it might actually happen that he gets a good bid now. And so at the very least, he should evaluate whatever bids he gets, even if he doesn't request some bits, whatever bits there are on the p two p layer, for example. And the problem is that if you do this thing, then, then whomever, I mean, the secondary market is already, how to say this? If the proposal decides I'm not going to commit to any of these bids that are outside already, then he might actually end up losing money because he's doing this early, he's looking at bids and is still committing to himself for zero value. Not really sure. I mean, yeah, I'm just ranting off the top of my head, but there are two problems that I wonder how much the builders can actually trust the proposer in this situation. The proposer can always equivocate and include whatever block he wants.
00:13:01.260 - 00:13:36.290, Speaker A: And unbundling protection of mebboost would probably note, hold here. So I'm not really sure, because the proposal itself is the builder, and the builder boost is huge. So if the proposer commits to himself and gets a boost, he can probably reorganize, bundle the builder. So if there are bits outside. Yeah, I don't, yeah, that's the thing. Under the current EPBS proposal, I think it's easy for the proposer to screw a map boost builder.
00:13:37.350 - 00:13:38.086, Speaker B: Yeah.
00:13:38.238 - 00:13:46.478, Speaker C: And this is interesting. This is in the context of hosts, this is the context of slot auctions after they've committed to building themselves.
00:13:46.574 - 00:14:20.140, Speaker A: Or it's in either, in either context, if you run any sort of like map boost auction, because you can do a map boost auction also for block auctions as well. You commit to yourself and then you just put the hash that whomever gives you. But the thing is that the system is designed in a way that the protection for the builder is so high that if the builder gives away this protection by allowing the proposer to sign as a builder, I think the builder can be unbundled. So I'm not really sure how many builders will be willing to play this game.
00:14:21.000 - 00:14:25.112, Speaker C: Wait, okay, I think I'm missing something somewhat.
00:14:25.176 - 00:14:41.480, Speaker E: You have to trust the relayer here, right? Because when you run the mat boost auction at, say, the 8.9 2nd marketplace timing game, you have to go to the relayer, and then the relayer will be the one that's releasing the final block, basically.
00:14:43.460 - 00:15:03.260, Speaker A: Yeah. But it's like if you, I mean, if the relayer needs to make sure that no equipment block is going to come out, especially in slot auctions where we're not even punishing equivocations. So we're not even punishing equivocations on the payload. If the professor is smart, he cannot unbundle. Yeah, actually I don't know.
00:15:03.380 - 00:15:08.508, Speaker E: But it's not. But, but then it's not same slot of bundling.
00:15:08.564 - 00:15:08.780, Speaker C: Right.
00:15:08.820 - 00:15:10.948, Speaker E: This, I think this will be the same slot.
00:15:11.004 - 00:15:31.310, Speaker A: Right? It is same slot. You just, if you manage to get a hold of this payload and you submit quickly another payload that wins, for whatever reason it wins, you just unbundled the builder and the builder doesn't get any protection because this is key. That is, signing this payload is any way it's going to be the validator.
00:15:33.890 - 00:15:42.290, Speaker B: Maybe as a validator you could commit to a relay being like the relay being the builder in your beacon block and then the relay hosting the math boost auction.
00:15:42.370 - 00:15:59.164, Speaker A: Yeah, that's true. Yeah, that's true. The relay will be. But that actually this way. Yeah, that's true. So this is an honest, trusted advantage, but this is something that, not that the fact that there is an advantage, but it's something that we wanted to happen anyways.
00:15:59.212 - 00:15:59.444, Speaker C: Right.
00:15:59.492 - 00:16:35.950, Speaker A: We want to have a secondary market in which the builder resells these blocks. So this, I don't mind if the builder, which is in this case would be the relay. The relay is buying the rights to do a slot auction and then the relay resells the rights to the builder to build the block. This is fine because whomever is buying this auction is in the protocol and it's already staked. So what you're describing is that perhaps there is an advantage. It's a centralized enforce in that the relay will always win this and the validators would always sell to the bill, to the relay.
00:16:36.490 - 00:17:02.880, Speaker B: Yeah. Okay, that's interesting. Let me quickly get to the last slide. So this slide is my opinion, and it's so it shouldn't be taken as facts. Just curious what you guys think about it. So to me, looking at this argument, it looks like slot auctions is very fragile to what the secondary market looks like. So specifically to whether the proposer has more options in the secondary market than a sophisticated builder would have.
00:17:02.880 - 00:18:04.100, Speaker B: So basically, the question is if the auctioneer is sophisticated, would you be less willing to participate in the auction than if the auctioneer is unsophisticated? And so, for example, if the secondary market attracts fewer bidders, if the builder runs an auction, then proposers won't choose to use the EPBS option, but will use the nefboost option instead. And so potentially that's fine if you count like the VA thing, but yeah, and then also there's like a lottery aspect. So you could see as a revealed preference now that proposers, for example, don't participate in smoothing pools, that they're very, very risk seeking. And so if proposers are less risk reversed than builders, proposers would also want to wait later. And this is basically the point that Ngika was making. And so they would use mavboostochin. Potentially this is less bad because then it means that risk is just something that they like, so they are maximizing their reward by committing to themselves, which maybe isn't technically a trusted advantage, but something to be taking into account.
00:18:04.100 - 00:18:44.068, Speaker B: And so since it's so fragile, and since we're already in a regime of meth boost now, to me it feels like if all of this indeed holds and the assumptions are reasonable, then it could be that in sole options we get that either almost 100% or almost 0% of the time they're actually used. And this to me sounds quite bad. And if we're in a regime, it will be difficult to move out of it. So then my question will be, what do we need to know to decide on this? Because it's quite difficult to, um, predicts what the secondary market will look like. And it could also change of course over time, uh, once epbs goes live. Um, yeah. So that's it.
00:18:44.068 - 00:18:46.600, Speaker B: So curious to hear what you guys think about it.
00:18:47.180 - 00:19:21.320, Speaker E: I have a question, Julian. So, so would you say like this type of a problem will exist no matter what in any type of future auction market? Right, because you can always just have, like, instead of committing to a builder, I just commit to a relayer, and then basically that relayer will just release the best block at the time, once the auction ends or once the six second mark. Is it, is it a fair statement to say this type of problem will always exist, whether it's like a slot auction or like a future execution auction or execution ticket.
00:19:23.380 - 00:19:32.708, Speaker B: So for any slot auctions, let's say execution options are also tiny slots options for block auctions. I think it won't exist because you have to commit to, exactly, you have.
00:19:32.724 - 00:19:34.040, Speaker E: To commit to that. Yes.
00:19:34.480 - 00:19:58.060, Speaker B: Yeah. And I think for execute, like further ahead auctions, you're basically forcing the sale via like Mevurn or something. So you're basically saying the proposal must sell at this point, unless you're willing to pay a high premium for it. And I think this will have a big effect on the secondary market. So I'm not sure if it will always exist. And intuitively I would say, no, you wouldn't have this. If you sell, for example, two epochs in advance.
00:20:01.050 - 00:20:13.618, Speaker C: I just want to clarify that the secondary market is the like selling that takes place after the, after you've committed and said your bill, you've said you've chosen a builder, but it's really you, and then you're going to sell it again. Okay.
00:20:13.674 - 00:20:24.386, Speaker E: And then, yeah, basically, imagine you just commit to a relay instead of a builder. You just commit to a relayer and then the relay just basically get the best block and just propose it.
00:20:24.458 - 00:20:24.834, Speaker C: Right?
00:20:24.922 - 00:21:05.458, Speaker A: I don't, I don't think it is the relayer. So there are two components to this sort of attack, to this problem. If I just commit to a relayer and I sell, and my block includes a header or a bid, whatever it's called, with a value that the relay will pay on chain, and then the relay of results, that's fine. That's predicted by the protocol. And this is something that we can live with that's not off protocol. I think the problem that Julian is describing is that even if I commit to a key for every layer, I am getting my payment off protocol. The whole auction is being carried outside of the protocol.
00:21:05.458 - 00:21:30.440, Speaker A: And this sends builders, builders cannot compete against this relayer because the relay will pay for their actual value of the block instead of having to predict correctly what the value would be. So builders, honest builders, cannot compete against this. And this is the centralizing problem. This is a problem. This is a problem that, that really would always win. I think this is what Julian is pointing. I'm less than mistaken.
00:21:31.060 - 00:21:33.120, Speaker B: Oh, yeah. Absolutely. Yeah.
00:21:33.780 - 00:21:46.700, Speaker E: So say the payments are the protocol, right. Then if you, today, you run the honest client software, like, then some, basically some p, two p bid will probably win because they have a higher value, and then you just choose a higher value.
00:21:46.780 - 00:21:47.164, Speaker C: Right?
00:21:47.252 - 00:22:08.564, Speaker A: No, no. But the point is that we don't want to have a system in which being off protocol has a clear advantage, because then every validator would be off protocol. We want to have a system in which being off protocol is fine, you can go off protocol if you want, but if you have a clear advantage of going off protocol, that's a system that breaks us.
00:22:08.732 - 00:22:22.448, Speaker C: Then if you want to rely on altruism, don't make it expensive. Although it's not altruism, but. Yeah, that's correct. Okay, so just to walk through the logic. Yeah. If they commit to. If it's.
00:22:22.448 - 00:22:38.380, Speaker C: If it's a block auction and they're committing to a particular hash, then we forced the sale at the time and there's just, there's really nothing. I mean, you can get bids faster about using mev boost just because you have a point to point connection. But other than that, there's really nothing happening off chain.
00:22:39.860 - 00:22:43.580, Speaker A: Actually you get bit faster by using the protocol instead of mev boost.
00:22:43.700 - 00:22:45.780, Speaker C: That gossip sub faster than.
00:22:45.820 - 00:22:48.844, Speaker A: No gossip is going to lose anyway. Gossip doesn't exist.
00:22:48.972 - 00:22:54.996, Speaker C: So what do you mean about gossip? I just mean like getting the bids from the builders to the proposer.
00:22:55.188 - 00:23:02.692, Speaker A: Yeah, it's. You get it directly. That's what the protocol hopes to get, that the builder connects directly to the, to the proposal.
00:23:02.756 - 00:23:07.980, Speaker C: Oh. Or is it. Okay, so builders will HTTP endpoint in the proposals.
00:23:08.060 - 00:23:15.952, Speaker A: Exactly. And then you don't. And the relay has an actual disadvantageous. So even if you make a payment off protocol, you have a disadvantage.
00:23:16.096 - 00:23:33.288, Speaker C: So yeah, basically you set up your mev boost to point at all the builders you like, and then you're farming that out. Okay, cool. And then, so then you've got your bid. All right, and versus the slot auction, which enables this whole secondary market. And that's basically the crux. Yeah, I mean, that seems reasonable to.
00:23:33.304 - 00:24:09.400, Speaker A: Me that we thought that the secondary market was cool because people at rig wanted to have something like abs eventually. So if you have a system that eventually enables a secondary market, you can move this secondary market and shape it however you want off protocol if you want. And then we keep the in protocol option as it is with minor changes. But I think what this is showing is that it's trickier than what we thought. So what did Rick think about this, Julian, I assume that you show them this.
00:24:10.140 - 00:24:55.940, Speaker B: Yeah, I showed them this, I think so it's difficult for me, of course, to speak for them, but many of them thought it was a problem. I presented the arguments in favor and against those auctions, which is the notion document. So I was part of a larger presentation. I think this was the main problem. Yeah. And so I think a secondary market is fine as long as you force the sale early, the IMF burn as something that you would do in execution auctions. So if I could add to that, to me it feels like two big considerations in block or assault auctions are so slot auctions.
00:24:55.940 - 00:25:14.872, Speaker B: The thing I just presented block auctions has the three DA problem that POTUS pointed out and also the missing or potentially builders not revealing their blocks if they later find out that it's unprofitable to publish them. And so I think these are, to me it feels like this is the main trade off.
00:25:14.976 - 00:25:19.980, Speaker C: What was the first disadvantage of the block auctions? Three D A.
00:25:21.720 - 00:25:22.860, Speaker B: Yeah, it's there.
00:25:24.920 - 00:25:46.910, Speaker A: You can post a hash and the PTc would vote that the payload was available, and then you produce a payload that is invalid. So that payload is dropped by every node. But you can prove that you had that hash and that every node had that payload. So that data did exist.
00:25:48.930 - 00:25:49.290, Speaker C: Yeah.
00:25:49.330 - 00:25:50.242, Speaker A: You get this for free.
00:25:50.346 - 00:25:52.910, Speaker C: So is this a DA problem? A free da problem?
00:25:53.210 - 00:25:57.750, Speaker A: That's a DA problem that arises in block auctions. We do not know what to solve.
00:25:58.060 - 00:26:01.764, Speaker C: I see. Okay.
00:26:01.892 - 00:26:14.480, Speaker B: So I feel like the arguments in favor and against block and slow selections are somewhat well known. So I'm just curious how we could move forward on that. Yeah, like how to make a decision.
00:26:17.900 - 00:26:51.890, Speaker A: So I have an opinion on that matter. From the implementation side, these two things are very trivial. So we're still like far from having a devnet, at least a few weeks. So my suggestion would be to stay as we are, which is on block auctions. We have a major change that we need to anyways rebase, which is this change by Lucas about. I was going to talk about this later, but it doesn't matter, just to skip on block auctions. And whenever we make this decision, it's just that, it's just a few lines of change.
00:26:51.890 - 00:27:06.320, Speaker A: It's nothing is not a big change for us to move from block to slot options. At least this is not for prism. So I think it's better just to continue on the implementation side while these discussions are carried. Async.
00:27:09.060 - 00:27:22.360, Speaker B: Okay, sounds good. I'm trying to find people who are interested in looking into how often blockchain would be withheld in block blockchains. That's probably a research thing. And then I could update you async how that goes.
00:27:23.360 - 00:27:38.540, Speaker A: That's great. I'm still worried about this GA problem because I'm not sure how much of an issue it is. I can definitely see a market for a roll up that requires their validators to be live.
00:27:40.520 - 00:27:58.116, Speaker C: I mean, dumb. I don't know, this has probably been thought of before, but if presumably you can have an on chain egg get attestation by the entire PTC saying that the block was invalid, do you really need to include the block on the chain?
00:27:58.308 - 00:28:31.856, Speaker A: No, but no, the block is never included in the chain. So because this thing is invalid, you drop the thing, but the PTC. So in principle you could make the PTC evaluate the block and check that it was invalid. But we don't want to have this because this puts a high requirement on the PTC. This execution on the PTC, which is the big win of FPS, is that you delay the validation of the block. Now you're going to put the validation of the block in under 1 second, which is just tough.
00:28:31.968 - 00:28:32.740, Speaker C: I see.
00:28:34.280 - 00:28:55.924, Speaker A: So another one which was. Yeah, so there was something. Yeah, that comment, I don't know how to solve the. But also it's not really clear how much of a big problem it is. Like when I mentioned this, Francesco seems skeptical that this is an actual attack. To me it sounds like a really serious attack.
00:28:56.092 - 00:29:35.704, Speaker C: I guess it would depend on the, I mean, one of the things it would depend on is the relative price between like DA and execution. And like DA is pretty cheap. So like, you know, having to outbid like valid execution and pay, that could be, I mean, not that we necessarily want to rely on this, but it's just my thought is like if DA remains cheap, you want to go outside of the 444 mechanism and soon peer Das, which with prices on one Gui, at least at this point, just to have some DA. I don't know.
00:29:35.872 - 00:30:23.290, Speaker A: Yeah, but the thing is, what is that you're pricing, right? So today Ta is cheap, but that means that you can send a bunch of transactions with a couple of blocks with a couple of blobs cheap. But with this you can send a full payload that's several megabytes. So you can send a full payload and every single blob because the KgG commitments anyways are going to be there. And, and you get all of those for free. So you get several megabytes for free or for whatever the bid was. So as long as those megabytes are cheaper than the MEV payment on a block, it's rational for you to post that way if you only need it sporadically. Right.
00:30:23.290 - 00:30:24.990, Speaker A: You only need it for one slot.
00:30:35.060 - 00:30:41.636, Speaker C: Yeah. Is there ever like the good thing.
00:30:41.668 - 00:31:21.300, Speaker A: About this is that if this becomes a serious attack, the network can react quickly because it's someone, and we can even slash the proposed, the builder anyway. But the network will react quickly because you need to have a series of validators who would participate in this and you can blacklist them immediately. So if you see a builder proposing invalid blocks, validators wouldn't immediately check it, then vanilla validators can blacklist immediately the builder. So a roll up doing this seems like unfeasible, but. So it's an attack that is out. There.
00:31:26.170 - 00:31:39.150, Speaker D: Can be something in protocol here potentially where you see the PTC voting everything and then the block is not included. So you can afterward penalize this situation.
00:31:40.610 - 00:32:05.176, Speaker C: Yeah. Like, could we decouple the, like, if you, if you don't reveal, or like, if you reveal when you have a commitment on chain, you're like on the hook for that amount of money. Can we decouple the amount of money that you're on the hook for, including a block from either having an invalid block or not revealing?
00:32:05.368 - 00:32:56.062, Speaker A: Yeah. So that was the proposal of Lee from off chain labs. Just penalize after the fact for the DA, for the maximum amount of DA at the gas price that you could get, which is something we can do. But it definitely complicates the protocol because you need to go back and see what the builder was and then you need to get, you do have the builder's commitment, but also it becomes another attack. And you need to start studying what are the four choice implications of this? Because every time that a payload is reordered now, that builder would be, would be penalized. So you need to have to prevent this. Now you're going to have to be enforcing a PTC commitment being on chain.
00:32:56.062 - 00:33:44.210, Speaker A: So today, the PTC vote is never enforced on chain. It's only put on chain to reward the validators that are tested. But under this penalization, you're going to have to keep the BTC vote on chain and make it a matter of consensus more than just for choice. So I think it's like the complication of like penalizing for this. It's just too much, or at least it's a level up from what we have today. Anyways, I think it became clear that Julian made an exposition that there are these trade offs. We seem to have, like, serious attacks.
00:33:44.210 - 00:34:03.670, Speaker A: It seems to me that the slot auction attack that was presented today seems pretty bad, at least at the moment. I can't think of any way of solving this, like having shipping the whole thing so that people just anyways bypass it and seems unreasonable.
00:34:04.090 - 00:34:11.260, Speaker E: This requires like, client changes, right? So you have to modify your client entire, like, is there a client called for this?
00:34:11.600 - 00:34:41.570, Speaker A: Not really, because you're going to. So the client, the builder API is going to be completely covered by us. So keeping a map boost fork that uses the client is going to be a very minor change. Very minor fork. It's true that you're going to have to have a fork that automatically, that doesn't connect to anything and it just commits to yourself. But map boost is going to be essentially supported, right? Yeah, because we are going to. We are going to be requesting bids from builders directly.
00:34:41.570 - 00:34:43.230, Speaker A: So that's all that they need.
00:34:44.010 - 00:34:49.546, Speaker E: You basically just commit to yourself and then you basically don't shed any bit value from everybody else.
00:34:49.618 - 00:34:50.470, Speaker B: That's it.
00:34:55.810 - 00:35:34.840, Speaker A: Which is, anyways, that thing is going to be a flag, right? So I'm sure, I'm sure prism at least will include a flag that says build locally, meaning just commit to yourself. So the fork of prism, I think it's going to be easy to make. Well, we do have. Unless someone has more comments about this, we can move on, on the agenda we had. Mark wanted to discuss something and Terrence wanted to discuss something. So we can go with Mark.
00:35:35.660 - 00:35:59.390, Speaker C: Sure. I mean, I can post a link. I couldn't share my screen, although I have a lot of screens, so it might take a while. Maybe I'll just, I'll try sharing. How do I do this in Zoom? Maybe I'll post a link. I can't figure out how to do it. It might take too long.
00:35:59.390 - 00:36:42.460, Speaker C: Okay, so this is just the I posted in the chat. There's a thank you, a link to like just a simple engine API method. It's basically the exact same specification as getpayload bodies, except you return the whole payload. It's renamed as get payloads because you're not getting a body or getting the full payload. Maybe we could just make it to get payload bodies before Ingrid hold payload and say, that's the thing, it doesn't really matter, that's just semantics. But this is the, all these. I just wanted to have something written that was concrete, that was a proposal, so we can talk about it.
00:36:42.460 - 00:37:46.986, Speaker C: Not that this is the end all form of the method, but the reason we have this is like the consensus node often doesn't want to store the execution blocks because the execution layer will already do that, and then you're wasting disk space. So we created this payload bodies method, so that, because the execution, because consensus layer stores the headers. If you can just get the bodies, the transactions and stuff, combine those with the headers, you can get back your full block. And so you have that saving a space. But now we don't have headers. And so if you want to have the same saving of space where the consensus layer doesn't keep the full execution blocks around, you need some method to get those execution blocks from the El. Right now there is two reasons to do this compared to using something like ETh getblock by hash.
00:37:46.986 - 00:38:37.560, Speaker C: Number one, ETh get blocked by hash doesn't accept a range, and we're often getting range things I mean, the main reason to do this is that you're getting range requests from other nodes in the network. And number two, if we use getblocked by hash, we would actually have to have RLP in the consensus layers to decode the transactions and get them in the form that we need. Yeah, it's just not designed for consumption by the consensus layer. But yeah, like, basically if we don't have this, our options are usually get by hash and put RLP in the consensus layer, or have the consensus layer store all the payloads and duplicate the space because the execution layer is already doing that.
00:38:40.400 - 00:38:42.136, Speaker A: Can I ask a very naive question?
00:38:42.288 - 00:38:42.980, Speaker C: Sure.
00:38:44.840 - 00:38:59.020, Speaker A: I don't understand why we even need to. So I honestly don't know how the El syncs. So why do we need this range requests?
00:39:00.000 - 00:39:05.638, Speaker C: I believed it was for Cl syncing, actually, not eldest, but that's my point.
00:39:05.734 - 00:39:27.170, Speaker A: So for Cl syncing, you kind of need it now because you need a block and you need, I guess, the block hash. But for Cl syncing, all you need is the blinded envelope and the black because the blinded envelope has the right hash and you don't need to validate the payload for clsyncing.
00:39:27.950 - 00:39:32.088, Speaker E: How do you get a payload for clicking?
00:39:32.264 - 00:39:56.180, Speaker A: But that's the thing. So if the EL is syncing, the El knows that the hash, if the hash is valid or not because the EL is syncing independently on their own. So that's, it's my lack of knowledge as to how they are syncing. But my understanding is that if they can sync independently, the blocks, and I told them sync to this hash, this is my final x hash.
00:39:57.950 - 00:40:12.650, Speaker C: Yeah, I mean, I. Wait, so I'm looking at the p two p interface. So first of all, there's a couple things being said at once here, which is, number one, are you saying that the Cl doesn't need the payloads when syncing?
00:40:13.710 - 00:40:35.072, Speaker A: So the Cl, our syncing spec, says that we need to submit the payload to the engine to validate and we need to wait for a request from the engine. So therefore we do need the payload. But my naive question is, why do we need the payload?
00:40:35.216 - 00:40:35.576, Speaker C: Okay.
00:40:35.608 - 00:40:50.840, Speaker A: The El can sync on their own and we have the hash and we tell them, I've synced up to this point and this is the hash, is it valid or not? And the El tells me, yes, it's Validore for this height. So why can I not take it?
00:40:50.920 - 00:40:54.848, Speaker E: You still need to process the payload, though. You still need to process the payload, right?
00:40:55.024 - 00:41:02.380, Speaker A: The Cl does not need to process anything. The Cl needs to process the payload envelope. And we have the blinded envelope is everything that.
00:41:03.000 - 00:41:03.632, Speaker C: You're right.
00:41:03.696 - 00:41:12.540, Speaker A: That's right. That's right. The only thing from the payload today that we need to process is withdrawals. That is outside of the domain of the payload in ebbs and even electra.
00:41:13.250 - 00:41:42.494, Speaker C: So you're asking basically, like, why during syncing, do we need to keep sending new payload, new payload, new payload, new payload to the El when it can, based on the hash? And just think. I think the answer is we actually don't. And there is a minimum amount of validations that we need to do. And those can be found in, like, if we don't send you payload there, there are still a minimum amount of value.
00:41:42.542 - 00:41:44.118, Speaker A: Yeah, you're talking about the block hash.
00:41:44.174 - 00:41:54.190, Speaker C: But I even block hashes as. And, like, I don't know even that.
00:41:54.270 - 00:41:58.810, Speaker A: We don't need to do anymore because we don't even care what the content of the block is.
00:41:59.870 - 00:42:20.886, Speaker C: Okay. I mean. Yeah. The reason. The reason, though, that we have to do the. The block hash has to do with a specific kind of attack. Like, I know that at least for withdrawals, I can describe this attack.
00:42:20.886 - 00:42:24.810, Speaker C: So if you can force the.
00:42:25.230 - 00:42:50.160, Speaker A: Yeah, yeah, but. Because withdrawals is part of the block hash. But starting with Elektra. Well, I don't know about Electra, actually, because I think they probably still use it for priority. But definitely on epbs, if we move to ss, we don't care about what the content of the payload is. We don't need anything from the payload. Nothing.
00:42:50.160 - 00:42:53.360, Speaker A: We don't care if the hash is even wrong.
00:42:58.750 - 00:43:09.278, Speaker C: We do in terms of, like, the execution payload saying or the execution engine saying that the block is invalid, that it can no longer be the head. I mean, yeah, that's why.
00:43:09.334 - 00:43:18.570, Speaker A: That's why we only need the actual hash to send it to the L. And the l would reply, yes, I have this block is valid. Or the l replies, no, I have this block, and it's invalid. And that's it.
00:43:19.510 - 00:43:54.186, Speaker C: Okay. I mean, so let me try to blame this attack, if I can remember from memory. So, I think the idea is that you force. If there's a mechanism of forcing the El and the Cl into, or, like, the El into. Sorry. The Cl into optimistic sync. If you can do that and you have this situation where the Cl is not sending every payload to the El, then what you can do is release two blocks which are different and where the validations between the two don't match up.
00:43:54.186 - 00:44:30.992, Speaker C: So, like, it's wrong on one side, but it but that side doesn't validate it and it's wrong in another way on the other side. And that side doesn't validate it, basically. So, for example, with the withdrawals, like on the. I think, let's say on the CL is what validates that the withdrawals are correct. And so you release a Cl block with correct withdrawals but with the wrong block hash. And then on the El side, you release, like this crazy withdrawal, which isn't correct. And then you calculate the block hash correctly.
00:44:30.992 - 00:44:55.270, Speaker C: And that's the block hash you put in the Cl side, if that makes sense. So you put in, you basically have two blocks, but they have the same hash. And on the Cl, it's incorrect hash. But the Cl has the correct withdrawals and the El, you have an incorrect withdrawal, but the El doesn't verify the withdrawals. And then you have the correct hash.
00:44:55.930 - 00:45:00.510, Speaker A: Wait, but the El does verify. So when you send.
00:45:02.410 - 00:45:03.746, Speaker C: So the email can't verify.
00:45:03.858 - 00:45:15.020, Speaker A: Send the payload for validation. Now, when we send the payload for validation now, we will need to. We need to send all the requests. So this includes withdrawals.
00:45:16.040 - 00:45:22.140, Speaker C: Yeah, but the El doesn't verify the withdrawals because it can't.
00:45:22.760 - 00:45:28.420, Speaker A: No. El verifies that those withdrawals are the request that they are fulfilling. In that block.
00:45:32.000 - 00:45:37.488, Speaker C: The El can only get the withdrawals from the Cl, like from the payload on the Cl.
00:45:37.544 - 00:45:56.320, Speaker A: And that's fine. We can still send them without having the payload. We only need the withdrawal. So that's my point. That to the El, we can send a blinded envelope and the El can verify that the requests that I'm sending match up.
00:45:58.300 - 00:46:00.220, Speaker C: So I think, yeah, actually it doesn't matter.
00:46:00.260 - 00:46:07.760, Speaker A: The Yale only consumes the request from the envelope. Yeah, actually, I don't know. Let's think about this.
00:46:09.150 - 00:46:15.718, Speaker C: I mean, did what I said make sense, though, like, where you kind of have two blocks, but they're the same?
00:46:15.774 - 00:46:31.010, Speaker A: It does, but this is a problem that we have today because the withdrawals are within and it's part of the block hash. I think it disappears once we just have this SS object and the withdrawals are outside of the payload.
00:46:33.360 - 00:47:07.028, Speaker C: Yeah, I mean, it's a good question. I'm not sure I am fully across. Why? Like, all I know is that this verify and notify new payload function in the spec, which almost no one talked about this function, but it has a number of validations in it. And these are the minimum amount of validations that you must do if you do not send every payload to the. To the El.
00:47:07.204 - 00:47:07.508, Speaker A: Yeah.
00:47:07.524 - 00:47:07.700, Speaker C: Yeah.
00:47:07.740 - 00:47:14.364, Speaker A: So it's just the block hash validation. I understand. And Prism might be the, probably the only client that doesn't do it.
00:47:14.452 - 00:47:24.916, Speaker C: No, you're not. It's only nimbus and lighthouse that don't send everything to the. To, like, you don't have to do these validations if you send everything a new payload.
00:47:24.948 - 00:47:30.436, Speaker A: Yeah, I understand. We never wanted to implement this RNP thing so that we don't need to check the blockhatch.
00:47:30.548 - 00:48:05.870, Speaker C: Yeah, and that's fine. If you send every new payload request to the El and that's what prism does, then this is fine. And everyone except for Lighthouse and Nimbus send every new payload request. And so lighthouse and Nimbus are the ones that have to do these extra validations. But these attacks are somewhat complex and I. I don't understand them enough to say that it's fine to not send new payloads. But what you are proposing is to not send new payloads and just have the El sync on its own.
00:48:06.290 - 00:48:40.020, Speaker A: Yeah. So I'm proposing that optimistic scene needs to change, but. Okay. So to be practical in this meeting, I think what you're proposing for the engine API is perfect because it's a minimum change so that we keep the things the same way that we are now. Yeah, but. And yes, we should probably move along with that, but at the same time, I'm going to start a call with Misha and try to see if we can just get rid. If after accepting SS on the Pl, we can get rid of these things.
00:48:40.600 - 00:48:41.432, Speaker C: Yeah.
00:48:41.616 - 00:48:44.896, Speaker E: You still need a new engine API call even for that.
00:48:44.928 - 00:48:45.072, Speaker C: Right?
00:48:45.096 - 00:48:53.796, Speaker E: Because you need to pass in the payload hash to this El and then the EL will return valid. But then in this case, it's just a payload hash.
00:48:53.908 - 00:48:58.780, Speaker C: But we have the hash from the bids. Like that's. That is something we already have and we.
00:48:58.900 - 00:49:00.428, Speaker E: So you can just use that basically.
00:49:00.524 - 00:49:27.380, Speaker A: Yeah. Yeah. Right. So does anyone have a comment about this engine API methods? If people have. I've seen it. I mean, anyone disagrees with implementing it this way because we haven't made any changes on the engine API, this would be the first new method added to the engine API. Ethan also suggested the same thing.
00:49:27.380 - 00:49:44.402, Speaker A: All right, so that seems reasonable. Terrence wanted to discuss moving process withdrawals to the execution phase.
00:49:44.586 - 00:49:46.418, Speaker E: Yeah, I guess just briefly.
00:49:46.474 - 00:49:46.738, Speaker C: Right?
00:49:46.794 - 00:50:26.980, Speaker E: Because I feel this is something that people have brought up every two weeks. Basically, people ask that, why can't we not do withdraw on the execution phase? What does the withdrawal currently has to be the consensus phase. It's because the. It's because the withdrawal is originated from the beacon state and then it's redeemed on the consent on the execution phase. But we also could move withdraw to the execution phase if we want. But then, I mean I think currently it just feels safer, more nature to do it on a consensus phase and then just block on the execution if the, if there's an empty block basically. But we could also look into they are moving to execution phase.
00:50:26.980 - 00:50:29.400, Speaker E: So I'm not sure what's the best like step forward.
00:50:30.110 - 00:51:16.770, Speaker C: To me it doesn't feel safer, I guess. I mean I could be convinced to say it's just that I have to sit there and think about it. Whereas it's like it seems immediately obvious to do it on the, on the side of because like, you know, like the way that it was framed in the spec is the state transition has been split into two phases. And so like let's just do it on the phase that, that is processing the execution payload side. And it already to some extent needs to be done there. I mean not if we do caching. But you already are checking that the withdrawals route matches, which is the same exact check as what used to be in process withdrawals.
00:51:16.770 - 00:51:27.704, Speaker C: So yeah, in a sense to me it feels actually like it's more similar to what we have pre epbs because.
00:51:27.832 - 00:52:11.920, Speaker A: Oh no, no wait. So it is. Sure in the happy case it is exactly what we would have pre epbs. The problem here is that withdrawals affect the safety of the beacon chain and they affect the economics of the execution layer. So if you get a wrong withdrawals on the execution layer, you can get paid. But if you get wrong withdrawals on the beacon chain, you can get out like say slashed money. And there is an actual change, what is the difference of executing it? And I'm not against moving it to the execution side, but there's an honest difference, which is the following.
00:52:11.920 - 00:52:41.278, Speaker A: Let's suppose that I today withdraw with the current specification, I send a withdrawal and this block lands and I withdraw. So my withdrawal is going to be deducted right now on the, on the beacon chain. And now let's suppose that the next thousand blocks are missed. Not, not missed, but empty. There's no payload. There's a liveness problem on the chain. Now my validator is leaking but it cannot be leaked because I just already withdrew.
00:52:41.278 - 00:53:16.720, Speaker A: So the 16 withdrawals that were included in this block were already withdrawn on the beacon chain and they need to be fulfilled on the execution layer. If we go with the design where we only process on the execution layer, then my validator would be leaking for 100 blocks. And what I would withdraw would be different. Would be a different value. So the effective balance might have changed, and a lot of it has. It has an effective balance change. So these two withdrawals are effectively different, and we need to verify that they are set.
00:53:17.060 - 00:53:24.756, Speaker C: I guess I just don't follow, because, like, you send a withdrawal. Okay, so this.
00:53:24.788 - 00:53:25.660, Speaker B: Does this have to do with the.
00:53:25.700 - 00:53:31.212, Speaker C: Ordering of process withdrawal requests versus process withdrawals? Is that what this comes down to?
00:53:31.236 - 00:53:33.336, Speaker A: No, no, forget about the withdrawal request.
00:53:33.508 - 00:53:36.060, Speaker C: Okay, but I thought you said you send a withdrawal.
00:53:37.000 - 00:53:41.288, Speaker A: I send a withdrawal. Like, I withdraw my valve. I exit my.
00:53:41.344 - 00:53:42.800, Speaker C: Oh, okay. So, like, you.
00:53:42.960 - 00:53:45.660, Speaker A: Whatever. Whatever form you withdraw.
00:53:46.680 - 00:53:47.616, Speaker C: Okay.
00:53:47.808 - 00:54:02.242, Speaker A: Even if it's a partial withdrawal, it's fine. Suppose that my validator was to be partially withdrawn. Now, in this block. Yes, currently, I would partially withdraw, like, 0.1, Ethan. And that's it. That's.
00:54:02.242 - 00:54:16.750, Speaker A: That needs to be fulfilled in the next payload. But if we go with the payload one and there's a thousand blocks, I can actually leak during those thousand blocks. And then when the next payload comes in, I don't withdraw anything.
00:54:23.250 - 00:54:26.938, Speaker C: This implies the existence of a queue, sort of.
00:54:26.994 - 00:55:02.204, Speaker A: No, there's no queue. There's nothing. Chain continuous advancing. If there's a thousand blocks where bitcoin blocks are coming, but the. Yes, and the payload is not, I might even be slashed during those thousand blocks. So this validator that could have been exit, exited or withdrawn or whatever in this block on one scheme, will not be exited or whatever and withdrawn, and might even be slashed in the other scheme. So these are different outcomes from the beacon chain perspective.
00:55:02.204 - 00:55:21.500, Speaker A: And we need a for choice analysis of these outcomes. So I'm not comfortable changing this without getting that analysis. The current design is such that on the beacon chain is exactly as we have now. And the El side is different turn.
00:55:22.080 - 00:55:27.100, Speaker C: Like process withdrawals effectively doesn't run if there's no payload the last time.
00:55:28.400 - 00:55:41.380, Speaker A: Yeah, but the first one does, so it only affects one block. That I agree. It only affects the last block before the liveness problem. So there's 16 withdrawals that will be different.
00:55:45.610 - 00:56:00.298, Speaker C: Okay. I guess. Yeah. I'll have to think. But my thought is that this whole thing just shifted one block. And that I don't see how the attack is different, but I'll have to think about it more.
00:56:00.434 - 00:56:18.180, Speaker A: Well, because the withdrawals are something that is determined by the beacon state at the point where you process them. Yeah, if we're not freezing and the beacon state keeps advancing without payloads, then the withdrawals might be different after a thousand blocks that are missing.
00:56:18.340 - 00:56:25.732, Speaker C: Oh, I thought the withdrawals would freeze, effectively because process withdrawal doesn't run.
00:56:25.876 - 00:56:50.890, Speaker A: I thought it was frozen, but withdrawals don't. The thing is that the beacon state is different. So you're not processing a partial withdrawal of a validator that got slashed, for example. Process withdrawal is not doing anything, but the beacon state is changing. Therefore, the withdrawals that you expect when you call process, process withdrawal now or a thousand blocks from now, from now, it's going to be. They're going to be different.
00:56:52.870 - 00:57:05.188, Speaker C: Okay. And you're. You said it was 16. So, like, basically, if you're the guy who's getting a withdrawal in two blocks, and then this thing happens to, you're out of luck and you're in the same position, is what you're saying.
00:57:05.364 - 00:57:15.844, Speaker A: Yeah. So. So if. Yeah, that's correct. So the only thing that changes is for the guy that will be withdrawn now, and then suddenly it's not.
00:57:15.972 - 00:57:16.396, Speaker C: And that.
00:57:16.428 - 00:57:17.316, Speaker B: I don't, I don't think it's.
00:57:17.348 - 00:57:22.080, Speaker A: I don't. I agree that I don't think it's a dangerous thing, but we don't have that danger analysis.
00:57:22.420 - 00:57:35.250, Speaker C: I mean, yeah, we can think about it, but that seems like. So I don't see how. If one is preferable to another. Yeah. I don't know.
00:57:37.710 - 00:57:44.410, Speaker A: Exactly the same behavior as it is today on the beacon chain. The other one would be a change in the beacon chain.
00:57:47.430 - 00:58:24.150, Speaker C: I see. Okay. I see what you. I think I see what you're saying now in the sense that, like, I see. Because currently, the beacon chain cannot progress without the execution chain progressing at the same time. And you're just saying that, like, if we know that. Okay, yeah, I would be really.
00:58:24.650 - 00:58:27.058, Speaker A: I definitely prefer to move it to the execution.
00:58:27.074 - 00:58:29.150, Speaker C: I'm extremely surprised if it mattered, but.
00:58:30.530 - 00:58:47.360, Speaker A: We are on same page. And I also prefer moving into the execution. But I would want someone to actually think about this problem before we decide this. I want someone to assert, yes, this is safe. I thought about this. The changes are. They seem safe to me.
00:58:47.360 - 00:58:57.120, Speaker A: And it also seems like an easy change on the spec. So that's why I'm not that worried of doing it earlier or later.
00:58:59.540 - 00:59:00.320, Speaker C: Yeah.
00:59:09.260 - 00:59:25.706, Speaker A: So I'm not sure about what the status of. Of implementation is for us. It would be easy to change it now. We already implemented this, but it would be easy to change it now. So if people haven't even started doing this, we can change it, and it might be simpler for everyone.
00:59:25.898 - 00:59:49.500, Speaker C: Yeah. I haven't implemented process withdrawals yet because I got stuck on it when I thought when I didn't see that one line. But it would simply, it would definitely be simpler for me to implement just because it requires no changes to the process withdrawals function. So, I mean, that's, that's just easier. And there's like no changes to the function. But.
00:59:55.080 - 01:00:01.380, Speaker A: Yeah, it also, it also has an advantage that you don't need to have this extra field in the state.
01:00:01.880 - 01:00:02.718, Speaker C: Yeah.
01:00:02.904 - 01:00:16.430, Speaker A: And a cache is always ugly. So. So I do agree that it seems better. Why don't we run a poll in the, in discord? Because we're already over time. Why don't we run a poll on discord and decide what. What to do?
01:00:17.730 - 01:00:18.470, Speaker C: Sure.
01:00:21.170 - 01:00:25.430, Speaker A: All right, people, we are already over time. I don't know if people have more comments.
01:00:27.410 - 01:00:28.350, Speaker C: Thank you.
01:00:28.980 - 01:00:31.892, Speaker A: All right. Thank you, guys. I'll see you in a bit.
01:00:32.036 - 01:00:33.200, Speaker D: Thank you, guys.
01:00:33.740 - 01:00:34.020, Speaker C: Bye.
