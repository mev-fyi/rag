00:00:00.680 - 00:00:31.291, Speaker A: All right, I'd like to welcome everyone to EOF. Implementer call number 54 is 24 July 2024. Right now our agenda is mostly standard. We have client updates, compiler updates, couple open questions on spec updates. What should we do about detecting contracts, then probably longer talk on testing. Updates and fuzzing will be part of that. And then finally another item if we have time, is to talk about dev contacts.
00:00:31.291 - 00:00:56.088, Speaker A: They're due next week. Proposals that I want to give us an opportunity to collaborate. If we want to set some things up for it, or if we just want to individually submit to it, it's up to us. So the first topic is client updates. Peter, do you want to talk about EVM1 and Aragon 3 real quick?
00:00:56.210 - 00:01:10.455, Speaker B: As for EVM1, I think we are up to spec. There was one bug fix on the way by Pavo and that's it, I guess. Andre, can you correct me? I was out for part of the week, so I'm not sure.
00:01:10.955 - 00:01:13.855, Speaker C: Yeah, nothing else. All the spec is implemented.
00:01:14.155 - 00:01:20.335, Speaker A: Yep. Okay. Never mind. Updates.
00:01:21.495 - 00:01:25.875, Speaker D: Yeah, the spec is implemented, all tests passing.
00:01:27.815 - 00:01:35.675, Speaker A: Cool. Now the fun part happens. Cool. Dragon Rath.
00:01:37.495 - 00:02:02.025, Speaker E: We had one bug we didn't decrement non see, if the validation fails, that's fixed and I am making basically finishing the PR that takes into account if the bytecode takes into account container type. And with that we finish off the validation tests.
00:02:03.685 - 00:02:31.479, Speaker A: Okay, I'll go for besu we had one bug with ext code stuff in Legacy we needed. We were not applying it to older forks properly so we got that fixed and it's not a. Yeah, it's because of the rules. There's nothing you could do with it. It's more of a defense in depth fix. But that was something that Guido found in his fuzzing work. So that was.
00:02:31.479 - 00:03:22.749, Speaker A: That was a good find there. JavaScript eth JS, anyone from EJS, anyone from EELS, anyone from GETH I have a PR out to GETH. They had the same issue we had with the XD call ordering. I'll ping Marius again and try and get that merged into his code. They also still have that bug also in reverse jumpy based on the last time I checked their code. Were there any clients I missed? Okay, compilers. I'm not seeing any of our compiler people on the call.
00:03:22.749 - 00:04:29.417, Speaker A: I'm not seeing Daniel or Charles. Any compiler updates? Any updates on the Solidity Pocket? Okay, so moving on spec updates, we still have an open question about how we're going to solve the contract detection issue. This is something Solidity pointed out to us when we first did the poc. As far as checking to see if a contract exists before doing a call, that's something Solidity does as a user experience feature, but also more Importantly, it impacts EIP 721, where they have specific protocols in their safe transfer from mechanism. That depends on being able to detect if a contract is an EOA or not, and they detect that by the size of the code. So there were two options that we discussed. One was to reuse EXT code size and morph that into an IS contract opcode and the other one is extending call values from exec call.
00:04:29.417 - 00:04:32.645, Speaker A: And there may have been a third one that I forgot about.
00:04:34.865 - 00:04:39.165, Speaker B: Yeah, there was also passing the flags into the XT call.
00:04:40.345 - 00:04:45.217, Speaker A: Oh, passing flags into the call or doing a check flag on the. On the output.
00:04:45.401 - 00:04:46.165, Speaker B: Correct.
00:04:48.025 - 00:04:59.505, Speaker A: Okay. If we're going to fix this in 1.0, we probably need to address this sooner rather than later, especially if it's going to be a return code change.
00:05:00.605 - 00:05:09.905, Speaker D: Ben, doesn't EX code size work anyway? Because it's not zero byte. It's like two bytes.
00:05:10.925 - 00:05:14.745, Speaker A: It's two bytes. But we can't use the XD code site inside of EOF contracts.
00:05:15.455 - 00:05:17.915, Speaker D: Okay, but it would work out.
00:05:18.655 - 00:05:55.097, Speaker A: Yes. Yeah. Yes. So EOF Smart Contract Wallet could accept it. So is there any strong opinion as to what the best solution to this might be? Powell, I see your off mute. And he's back on mute.
00:05:55.201 - 00:05:56.365, Speaker F: Sorry, I don't have.
00:06:00.545 - 00:06:01.241, Speaker A: You're not having.
00:06:01.273 - 00:06:03.241, Speaker D: Good luck with changing.
00:06:03.313 - 00:06:04.217, Speaker A: Go ahead, Ben.
00:06:04.401 - 00:06:29.615, Speaker D: Changing exped size seems that's cool. The. The common pattern for legacy is EX code size and then is zero. But they'd obviously have to be writing something different for er, so probably.
00:06:37.725 - 00:06:39.745, Speaker A: Powell, is your mic working?
00:06:43.885 - 00:06:51.865, Speaker F: Yeah, I believe this, but I. I'm out of the context right now, so I don't have anything to say in this topic.
00:06:53.085 - 00:06:53.905, Speaker A: Okay.
00:06:55.845 - 00:07:09.495, Speaker C: To me it seems like this contract kind of occur is simplest to agree on, simplest to figure out the spec because the rest the other options are like too many options to choose from and none of them seem ideal.
00:07:19.275 - 00:07:51.125, Speaker A: Okay, looks like I didn't. I thought I'd submitted a PR possibly to 3540. So if we do a spec change, the question is which EIP should it be in? And I think it would be 3540 because that's where the other handling of EXD code is handled. Or do we create a new EIP at a cover is contract or do we put it in the call Op code. What are people's opinions on the best place for it?
00:07:53.715 - 00:08:10.735, Speaker B: Just. Just before we do that, are we or how much are we concerned about the response of another opcode being touched in a way. I mean does it count as a new opcode or not?
00:08:13.955 - 00:08:15.415, Speaker A: Yeah, it probably does.
00:08:15.915 - 00:08:21.535, Speaker B: I mean data copy doesn't so maybe it doesn't. It's a new name.
00:08:23.835 - 00:08:31.295, Speaker D: Is ex code sized slab. It's not just. It still runs, doesn't it?
00:08:34.115 - 00:08:38.415, Speaker B: As of now it is. It's not allowed in EOs.
00:08:39.795 - 00:08:42.375, Speaker D: Okay, maybe we need to test that.
00:08:43.435 - 00:08:47.957, Speaker B: Oh we should. I think we have somewhere I'm not.
00:08:47.981 - 00:08:50.341, Speaker D: Sure why this we do There is.
00:08:50.373 - 00:09:17.335, Speaker A: A band and permitted opcode test that goes through every single opcode. Yep. My red herring code isn't can't find it But I mean that's also another point is that we could introduce this in in a future fork and just add an opcode because adding opcodes is still fine instead of eof.
00:09:17.915 - 00:09:31.935, Speaker D: But I mean it could do exactly the same as it does in Legacy. I returning to for ERF and returning the length for Legacy and then normal code would still work.
00:09:37.525 - 00:09:41.301, Speaker G: Turning the length goes against. I mean it allows code introspection.
00:09:41.373 - 00:09:41.985, Speaker B: Right.
00:09:43.685 - 00:09:48.661, Speaker A: But it doesn't allow introspection of EOF code any of.
00:09:48.733 - 00:09:52.461, Speaker B: Yeah, it's just the size also yeah.
00:09:52.493 - 00:09:57.813, Speaker D: Any of Legacy code sounds interesting however.
00:09:57.949 - 00:09:58.745, Speaker A: It is.
00:10:01.245 - 00:10:20.385, Speaker D: But then nobody need to change the pattern. It would still work otherwise Solidity might need to go or. What are you doing here? You know you're checking code length. I need to convert this into an IS contract call.
00:10:21.845 - 00:10:31.717, Speaker C: Yeah, I think Solidity is aware and they said they are okay with using whatever method is contract would work too like changing this code anyway for ufo.
00:10:31.891 - 00:10:51.065, Speaker D: Yeah but I mean if. If users in Solidity are doing their own, you know they're using Open Zeppelin or whatever to do contract length greater than zero and then Solidity where I have to reinterpret it.
00:10:51.185 - 00:10:58.215, Speaker C: No query and contract length is not available at all in uf so these of course would not work.
00:11:03.715 - 00:11:09.455, Speaker G: Isn't the current suggestion we're talking about to re enable XCODE sites.
00:11:10.635 - 00:11:12.043, Speaker D: Yeah. And just return.
00:11:12.139 - 00:11:12.651, Speaker B: Yeah.
00:11:12.763 - 00:11:23.987, Speaker C: Okay. Yeah then I agree then that's the issue for Solidity users and in general I not sure it's a great approach to have different semantic like in Legacy.
00:11:24.051 - 00:11:28.063, Speaker D: In UFO and it'd be the same.
00:11:28.199 - 00:11:33.551, Speaker B: It'd be the same. Right, right. The target would be would.
00:11:33.663 - 00:11:34.315, Speaker A: Yeah.
00:11:34.975 - 00:11:44.191, Speaker B: UF versus Legacy would be different for the target but not for the source of the call. Right, right.
00:11:44.263 - 00:12:21.843, Speaker A: I like that's a subtle. I didn't hadn't thought of that. I really like the subtlety of that. Because we have the same opcode between Legacy and eof. Because what we're concerned about code introspection is introspecting into EOF code. And we could view and this also opens up using other legacy contracts as data contracts does you know, in a future version of eof we could unban ext codecopy and ext code hash, but I think we start with just ext code size and keep it the same behavior so that EOF comes across as two and is otherwise a distinguishable from a link to contract. That's not eof.
00:12:21.843 - 00:12:27.375, Speaker A: So what we don't have is an EOF detector which I don't think there's a valid use case for right now.
00:12:29.555 - 00:12:38.455, Speaker B: Right. We would have it with the hash ext but we don't need it I guess, do we?
00:12:39.995 - 00:13:01.905, Speaker G: In the previous call we talked about the delegate call restriction that I was proposing to lift and Axec proposed to keep the restriction but add a way to detect eof. Again, I still prefer just lifting the restriction, but that was one use case for adding EOF detection.
00:13:09.215 - 00:13:16.395, Speaker A: I mean we would need a lift code hash because the code hash is consistent and we wouldn't have to open up the door of copying other contract code.
00:13:19.895 - 00:13:43.525, Speaker B: That's true. I mean that still doesn't might not count as code introspection. You can just check the hash. On the other hand, lifting the restriction for delegate call seems like opening up a very easy path to working around code introspection in general. Because you can delegate call and they're called gas call copy, code copy or whatever.
00:13:48.105 - 00:14:13.855, Speaker A: Yeah, and you can just to do code copy of a legacy contract, you just call a jumper contract and have code copy there. So the ban of these three ex opcodes is very easy to circumvent. You just have another contract that takes one argument of the stack, executes it and returns it. It's super easy to circumvent with legacy in place.
00:14:18.835 - 00:14:25.535, Speaker G: Is that an argument for enabling these opcodes in EOS context?
00:14:28.405 - 00:15:09.593, Speaker A: Kind of is because it's not. I think what's different between this and this and the delegate call in self destruct is we're not modifying account state. And I think that was the big issue with self destruct is we were allowing non EOF code to change things on the account state. Ext copy, ext size and ext hash just provide data. They don't change the state of the account Like a pay op code or a create op code. And really self destruct was the only effective one to like remove code. And that's since been removed.
00:15:09.593 - 00:15:40.555, Speaker A: But as a category, I could see future account changes being proposed and I honestly think there are times where we might want just EOF to have access to those as well. So maybe we might need a band delegate call into eof, I don't know. Or we would need a check on the operation that we're working on an account that has EOF code. But that's. I think that's a bridge we can cross when we get there with the account changes. But just banning a value read opcode is trivial to circumvent.
00:15:47.905 - 00:16:00.125, Speaker G: Can you say that again about the delegate call thing? So currently there's a restriction in one direction but not in the other direction. You were, you were just making an argument for banning it in both directions, Right?
00:16:01.225 - 00:16:42.355, Speaker A: Right. So we, we're not there right now. But if there was a feature in EOS that allowed the EOF account to be manipulated in some way, like set a set of 7702 delegate or unset it, and it only had it in EOF, then Legacy would just delegate call in EOF to get at it and do that call. So you know, EOF only things in modify account kind of don't matter because you can with delegate call into an eof. And the thing is, we can't ban delegate calls in the EOF because that's going to remove a lot of utility for things like Uniswap. So I'm hypothesizing on features that don't exist yet. And it's kind of an argument for why those features should not exist.
00:16:42.355 - 00:17:19.070, Speaker A: If we allow account changes, it should be available to Legacy and eof. But if we're trying to keep things out of the world, get rid of these account changes like self destruct, then we can't let EOF call Legacy because that would bring those back into the EOF accounts. And that was self destruct. And the sweep operate. The basically the sweep operation of the balance of the ether is what remains in self destruct. That's something that we're trying to get rid of as a whole. And the getting rid of the deleting the storage in the code was a compromise to make Verkal work.
00:17:19.070 - 00:17:35.885, Speaker A: But there still has some side effects that we're still trying to keep from entering EOF if we can, that there are no features that manipulate accounts that are EOF only. And I don't think there Will be.
00:17:45.545 - 00:17:47.645, Speaker G: Is pay really legacy only?
00:17:48.905 - 00:17:49.885, Speaker A: Is what?
00:17:50.985 - 00:17:55.521, Speaker G: Hey, the, the new cell pay is.
00:17:55.553 - 00:17:56.425, Speaker A: Right now legacy only.
00:17:56.465 - 00:18:02.895, Speaker G: Yes, but I mean is it, isn't it. Are you not able to get the same behavior on eof?
00:18:03.515 - 00:18:26.319, Speaker A: Not right now. You can't do an unconditional sweep all balance at the end of the transaction. And that's. It's. Yeah, because self destruct interacts strangely with the call stack as well. So pay is not really self destruct is not really pay. There is a legitimate pay proposal that has different semantics.
00:18:26.319 - 00:18:32.755, Speaker A: I would call it the new self destruct. The 6780 self destruct. The 6780 self destruct is not in eof.
00:18:44.215 - 00:18:45.115, Speaker B: Got it.
00:18:53.545 - 00:19:01.245, Speaker A: So were there any arguments against removing the ban on EXE code operations? What's the strongest arguments we have against it?
00:19:02.265 - 00:19:05.845, Speaker B: I mean, you mean all three or just the two ones that we are.
00:19:06.545 - 00:19:10.285, Speaker A: Which. Yeah, there's, there's. There's two options. There's all three and there's just size.
00:19:10.825 - 00:19:13.165, Speaker B: And size and hash, right?
00:19:13.985 - 00:19:18.459, Speaker A: Oh yeah. Size, size, size and hash. Size, hash and code copy.
00:19:18.587 - 00:19:28.775, Speaker B: Right. And size is needed for the solidity case. The NF, NFT or what I think that was ERC721.
00:19:29.355 - 00:19:33.979, Speaker A: Yeah. Anyone that tries to distinguish between whether they're setting to an EOA or a.
00:19:33.987 - 00:20:01.745, Speaker B: Smart contract and then hash is needed for what franchise is the case making the case for which is the make it easier to X delegate call without like more predictable result, right? More or less, yes. But we have no case for copy and it's, it's the most severe one because it actually allows you to read the code.
00:20:02.645 - 00:20:03.269, Speaker A: Right.
00:20:03.397 - 00:20:12.335, Speaker B: And then I don't know, it is. I mean that's, that's the only one that's actually introspects code, right?
00:20:14.875 - 00:20:18.155, Speaker A: Correct. Because the hash is fixed metadata of the code.
00:20:18.275 - 00:20:18.975, Speaker B: Yeah.
00:20:19.635 - 00:20:36.755, Speaker G: I think I'd say that an argument against it is that if there is the chance to remove code introspection that is Code copy in the future through some kind of migration and legacy contracts, this would make it a lot harder.
00:20:40.935 - 00:21:24.365, Speaker D: So one I would be, I would be for at this stage just code length and have it do what it does at the moment, mainly because there's so much code in the wild that does that check for is contract. And rather than trying to get either change in user behavior or solidity to have to interpret what the user's trying to do and change the OP code that it puts out, it'd be easier just to support code. I put a link to Open zeppelins checks.
00:21:25.745 - 00:21:28.305, Speaker A: And Ben, what's your opinion on code hashtag?
00:21:34.995 - 00:21:53.895, Speaker D: I mean it's maybe not harmful. Nobody's. Nobody's doing anything interesting with Kash really in terms of be. You know, beyond checking whether it's an empty hash or something else. You're not doing weird maths on it or anything.
00:21:56.005 - 00:22:17.945, Speaker A: Because code hash would be useful. We could check empty hash. We could check EF00 and also if. Well, you can always escape out to another contract to do the code copy for you. But you could use the hash to prove that you have contract data in memory and extract data from that kind of as a proof. But that's kind of a roundabout thing.
00:22:18.525 - 00:22:31.255, Speaker D: Yeah, I mean I don't think it's sample. It's just reading a property of the account was not bike balance or whatever.
00:22:32.835 - 00:22:45.775, Speaker A: Okay. So I'm not hearing strong objections to code size. Kind of lukewarm on code hash. Anyone else got a stronger opinion on either way on that.
00:22:49.245 - 00:22:56.185, Speaker C: Size is going to work with legacy. So it will return real legacy size inside.
00:22:57.205 - 00:22:57.989, Speaker A: Yes.
00:22:58.157 - 00:22:59.865, Speaker B: Yeah. Just keep it simple.
00:23:03.645 - 00:23:08.701, Speaker D: Yeah. So the two opcodes would behave unchanged. Yeah.
00:23:08.733 - 00:23:18.445, Speaker B: Literally we just lift the restriction of the validation stage and I think the rest is just should work at least speaking for even one one liner.
00:23:19.105 - 00:23:21.673, Speaker A: It's a one liner for besu plus test code.
00:23:21.809 - 00:23:23.485, Speaker B: Test code. Yes.
00:23:24.585 - 00:23:38.885, Speaker D: I think if you reintroduce things like code copy X code copy and things then it. You know you're starting to. We're starting to box ourselves in in terms of the future but I don't see any harm with magic for hash.
00:23:49.755 - 00:24:17.685, Speaker A: So how about we start just. Just with hash and we can think longer about not hash. Just start with size and we can think longer with hash. We see what the reaction to this is. But we can always also bring back hash or another detect EOA in a future. Future fork. Okay, so let's.
00:24:17.685 - 00:25:35.315, Speaker A: Let's go on that for now. Here's my screen. So I think the conclusion there it. All right, next item on the list. It's probably a testing update in 30 minutes. It's probably time moving to testing. Mario, got any info on testing? Anything you want to lead with or should we just go into the other questions we have? Okay.
00:25:35.315 - 00:25:40.235, Speaker A: Powell, sounds like Mario's muted. Go ahead, Paul.
00:25:40.695 - 00:26:00.025, Speaker F: Yeah, I did some fuzzing recently and it's still in progress but I was able to integrate EVM1 and Revm into the fuzzer and we starting reporting some issues that has been found.
00:26:01.645 - 00:26:07.345, Speaker A: What fuzzing framework are you using and what do other clients need to do to participate?
00:26:08.485 - 00:26:53.245, Speaker F: Yeah, I'm using LibFuzzer, so it's like coverage based instrumentation for like native code mostly. So I was able to get coverage from Rust. I think there's a way to get it from Go as well. So I plan to start with these three implementations and for the rest we'll see. The basic thing is to just export C kind of function from your implementation. Even if that's without coverage, that's also useful and we can think how to enable coverage later on.
00:26:58.825 - 00:27:01.845, Speaker A: Okay pal, so mostly something like.
00:27:02.745 - 00:27:21.415, Speaker F: Yeah, something like static library. When you have single entry point I can call and that will validate EOF and I think it's enough to just report true or false for now. So that's the basic we can start with.
00:27:23.195 - 00:27:33.695, Speaker A: Okay. Ben and Eamonn is producing a static library something that. NET can do in Linux?
00:27:38.565 - 00:27:44.225, Speaker D: Yes, I think so. Although need to look into a bit more.
00:27:51.045 - 00:28:09.675, Speaker A: Okay, I think there's a way in Java through graalvm I found a post that someone did it. As long as we're not testing KZG or BLS and speed performance speed is not a concern, we should be fine there. Graalvm is not the fastest implementation out there.
00:28:13.255 - 00:28:45.575, Speaker F: Okay. They're also like even before that we can export all the test cases found so far into JSON and then you can just run run it from there. So I think so what I wanted to say. Nothing is really needed right now, but in the next one week or two I might ask some people from different teams about advice how to integrate that if that's possible and so on.
00:28:47.235 - 00:29:26.825, Speaker A: Okay. An unrelated approach I was thinking about for fuzzing is if teams expose T8N server or if we fuzzed it through the engine API. But the engine API's got a lot of overhead. Or if everyone had ETH simulate, which again has overhead that not everyone implements but a standard JSON API where if you implement one of The Standard JSON APIs we can fuzz you. That's one approach that would make it easier for everyone to come in. The problem with that approach is you can't use coverage to guide the fuzzer. You would need to have the mutations come through separate means.
00:29:26.825 - 00:29:39.705, Speaker A: Mario, you said your mic is working. Do you have any comments you want to add?
00:29:40.885 - 00:30:04.235, Speaker H: Hey, thanks. Sorry for the issues. Not. Not that many. I've been working mainly on other PRs. But yeah, I agree that we have to do something about fussing. We have been trying to implement some kind of Fussing in into east but nothing concrete yet.
00:30:04.235 - 00:30:37.385, Speaker H: I think, I think. I think the way to go right now as Marius suggested in Oracle devs is fast CBM for the short term but in the long term I would like to. For this to be also included in east. But yeah. However I don't have any solution right now about fossing yet. But we will start to explore it at least in the following couple of weeks to see how we can implement that in East. Yep.
00:30:43.285 - 00:30:58.541, Speaker A: Where's. What's the. Does anyone have the. I looked at Guido's fuzzer. It's. I want to look at Fuzzy VM before we go down Guidos too much Guido's got some good hits. Vice versa.
00:30:58.541 - 00:31:01.705, Speaker A: What's the GitHub link to fuzzy VM?
00:31:06.815 - 00:31:08.475, Speaker H: Give me a second, I will get it.
00:31:11.375 - 00:31:14.115, Speaker A: F, U, Z, Z, Y vm. That's what it is.
00:31:17.895 - 00:31:21.271, Speaker H: There it is. I shared in the. In the chat.
00:31:21.383 - 00:31:42.525, Speaker A: Yeah it's in Marius's repo because when you fuzzy eof you can mu. You can mutate an opcode but that might imply changes in the header otherwise they'll fail validation. So we would need to get some more changes to the mutation step. But this gives us something to work with.
00:31:43.825 - 00:32:18.035, Speaker H: So the advantage of east is that it right now it calculates automatically everything that you need for the header to work. So the max stack height and all that stuff. I think it could be really easy for us to just implement some type of fuzzing, but it's going to be a little bit. A little bit of wait until we finally got it working. The advantage of Fuzzy VM at the moment is that it already has the strategies and everything set up, so it's missing some pieces still in my opinion.
00:32:20.985 - 00:32:27.685, Speaker A: Is Fuzzy VM guided fuzzer or is it just strictly a random fuzzer based on the strategies? The mutation strategies.
00:32:29.505 - 00:32:33.725, Speaker H: I don't think is guided, but I think Mario should have a better answer.
00:32:35.385 - 00:33:01.995, Speaker A: Okay. Because. Yeah, because if we can get into east then we have a standard interface where everything not guided. Okay, that's actually good to know because that was my big panic when I was looking at these fuzzers is like Java's got some. It interacts with its tracing APIs and that's how it gets it guided in VM. But other. I don't know if other languages have live coverage of their stats.
00:33:01.995 - 00:33:23.105, Speaker A: So we need to do multiprocess which is another complication. But if it's not guided and it's just doing intelligent changes, I think moving something like this into east opens up that all, everyone that can fill tests can be fuzzed and even the ones that can't fill tests, we could still throw the fixtures at them as they're generated.
00:33:32.885 - 00:34:29.825, Speaker H: Let me, let me take a look a deeper look into FastVM this week and to see how what we can bring into the eastward east world from from it. I will have a better, better context and better opinion next UF call O the nice thing is that this is not only beneficial to uf. I think this is an important part of testing that needs to be into east for. Yeah. For basically every single EIP that we test for.
00:34:30.805 - 00:35:15.635, Speaker A: Yeah. And what I like about putting in the east is it's, it's a common setup. I got Fuzzy working once with Go EVM Lab and it was not a simple setup and I'm not even sure I had it set up right. And the documentation, if you understand the tools, the documentation is probably sufficient. But I don't understand the tools so that's probably the problem There is I don't fully understand those two tools. Geof gas usage of opcodes we need to get a long term strategy. One of the things I mentioned on Discord is and I'll probably go ahead and write up a demo of this this week if no one's got it on their plate.
00:35:15.635 - 00:35:43.649, Speaker A: But a mutation where we take legacy call and we call EOF three different times with the change, without the change and with the change so we can get warm, cold and non existent and that should give us a baseline to figure out what the gas cost of the opcode is and that way we can make more generic tests out of it. But I would want to mock it up and try it out first. Peter, I see you came off mute. Do you have anything to add to this or comments?
00:35:43.697 - 00:36:11.845, Speaker B: Yeah, I was thinking about this. I'm not sure if you share my reservations with this. I guess this would work. It's just. It sounds more like a long term strategy than short term as you said. I wonder what the short term strategy could be Just to get the for example EXT call tests in shape in East.
00:36:13.945 - 00:36:29.607, Speaker A: So the really short term strategy is to not test it in east to test it in the fixtures and just make sure we all agree. But that's going to provide really bad metrics when we get it wrong because we have no idea what we're getting wrong because there's no test explicitly saying you got this wrong.
00:36:29.711 - 00:36:55.385, Speaker B: Yeah, I mean there's the short term strategy which is used in MCP memory expansion Test at least which is just calculate the gas expected gas cost of a know a particular call by hand and just assert on that this is kind of dumb and maybe inelegant.
00:36:58.085 - 00:37:20.885, Speaker A: But the downside. Yeah, the downside if we don't calculate it independent of an implementation is we might all collectively get it wrong and we might change it to the wrong implementation to try and align with other implementations versus coding in the east. We have the correct answer independent of them. So that's. Yeah, we do need a long term solution.
00:37:22.265 - 00:37:25.725, Speaker B: I mean the advantage of recalculating by hand, right?
00:37:26.225 - 00:37:27.001, Speaker A: Yep.
00:37:27.153 - 00:37:40.075, Speaker B: Because that's like another point of reference when it is not calculated by any EVM implementation, it's just calculated by hand.
00:37:42.055 - 00:37:46.479, Speaker A: And gas costs aren't like, you know, hashes which you're not calculating that by hand.
00:37:46.527 - 00:38:18.445, Speaker B: Right, right. I mean the downside of the manual approach is, you know, we can get, we can get the manual calculation wrong but have the right answer. Right. Because you have a lump, have many instructions involved and you just compare the end result and you know, you might confuse a, I don't know, gas cost of a push with something that should cost the same and you know, have the right sum and, and, and, but the wrong pieces.
00:38:19.625 - 00:38:20.405, Speaker A: Yeah.
00:38:23.625 - 00:38:36.855, Speaker B: And it's ugly. And with the, with using the gas opcodes, my concerns are it's, I mean it also doesn't, I think it doesn't help with out of gas testing.
00:38:40.835 - 00:38:42.335, Speaker A: Right. Out of gas.
00:38:43.435 - 00:39:43.155, Speaker B: Yeah, except charging the right amount. You should also test if that amount is not supplied then you out of gas at the right moment and sort of the. It's called the McP test style. One seems to cover both. Maybe not ideally, but somewhat because in, in this, in this style you just calculate the gas and then you have one case where you supply that amount of gas and the other case when you just subtract one and the subtract one case should fail. And also I mean what if, I mean this may be hypothetical, but what if we want to test EVM implementations which do not support non EOF code at all, Then making a long term strategy using the GASOP code might be risky.
00:39:44.495 - 00:39:55.045, Speaker A: Right, right. That would involve an EST change though to run the three tests. Well figure out what the warm call is.
00:39:58.785 - 00:40:32.041, Speaker H: So I think MCPY is a manual calculation. So if you always provide this manual, I mean it doesn't have to be manual, you have to only provide the formula or the function to get the gas cost. What we can do is maybe just come up with a decorator for testing where you Supply which opcode is under test, the formula or the function that is used to calculate the gas. And then it automatically generates these test cases that. In the same fashion as MCP does right now.
00:40:32.193 - 00:41:02.365, Speaker B: Yeah, because we already have pre op codes tested like that, which is my shameful addition, which is return something else. Return data copy and also data copy. Just copy the same. Pun intended? Non intended. They copy the same approach. We already are at the spot where we could make like a mini framework for these kind of tests. But it's an investment.
00:41:03.225 - 00:41:53.633, Speaker H: Yeah, of course, I understand. Let me, let me revisit those tests just to get an idea how we can just make a decorator to make it super easy for anyone to just come with the formula and the opcode they want to test. And then it should automatically produce all the test cases. And the advantage of making this a decorator is that if in the future we think of a new test case that applies to every single of these patterns, we just have to modify the decorator and the decorator will automatically update every single test case where this is applied and we get. We will get new test cases for free. Yes, but yeah, I need to take a look just to see how we can design it.
00:41:53.769 - 00:42:37.095, Speaker B: Yeah, yeah. Just remember about the quirks in the ext call gas calculation which might or might not be able to be put into this kind of a decorator approach. Because then for ext call the. You have like this. How do you call it? The more gas you supply to a function, the more it changes the way it's distributed for the column. You need to supply this minimum retained gas and also the minimum Coly gas. And then this is crazy formulas to calculate the expected gas.
00:42:37.095 - 00:42:41.235, Speaker B: So I mean just. We need to be wary of this.
00:42:41.355 - 00:43:22.055, Speaker H: Yeah, of course. So it needs to be very configurable. So I mean the base case would be something like McPy. But then if you try to test something more complex that has different levels of gas, when you go out of gas and something like that, you need to be able to configure this also into the decorator. It sounds complex, but I would like to see if it's possible to implement it. I will reach out to you if. If I have questions about ext call.
00:43:22.475 - 00:43:29.835, Speaker B: Yeah, yeah, please do. I'm not sure about the long term start strategy though.
00:43:29.915 - 00:43:30.251, Speaker A: Do we.
00:43:30.283 - 00:43:46.825, Speaker B: Do we do this gas harness or. Or trace testing which also popped up. So if you have any thoughts on that, you can also let us know.
00:43:50.685 - 00:43:52.705, Speaker H: Yeah, okay, thanks.
00:43:54.965 - 00:44:35.515, Speaker A: Right. I think that's probably need a time box the fuzzing. If we want to get to our last subject, which is the subject of devcon talks, do we want to collaborate? Who's submitting? What spaces do we want to make sure is covered? I submitted one talk with a future of EOF talking about capabilities and some of the extravagant things that might be added that are enabled by the container. But I haven't submitted any other talks and I want to hear what other people are submitting to make sure that we have the coverage and people who are willing to go and willing to talk. So make sure we get enough coverage for this. Peter, you came up mute briefly.
00:44:37.685 - 00:44:40.825, Speaker B: Oh, nope, has gone on yet.
00:44:41.645 - 00:45:11.075, Speaker A: Okay, so who's planning to go to devcon and take that long flight? And even if you're not, what talks do you think we need to have coverage for? Should we have an EOF panel and if so, who should we invite and who should moderate?
00:45:18.735 - 00:45:48.005, Speaker B: I mean as. I don't know if it's premature, but we're sort of thinking about the way to structure the EOF related talks. But I'm not really involved in this so maybe someone else can can speak. I see there's Alex is not here.
00:45:48.985 - 00:45:57.165, Speaker A: Yeah. AAN raised his hand. Dragon had bad luck with the visa. Do you think you'll have better luck with the Thai visa?
00:45:58.475 - 00:46:37.505, Speaker E: Should be easier to be honest about talks related to Yev. I didn't thought about that a lot. Having like panels seems maybe it's the best option. Yeah, we should have few talks but having a panel additionally seems okay. Especially because the people don't know what UF is. They tie it to one thing like its performance and why we are doing 10% performance. So there is a lot of confusion related to eof.
00:46:37.505 - 00:46:47.545, Speaker E: We need to somehow make it clearer in some way or form.
00:46:49.935 - 00:46:58.155, Speaker A: Okay, so would this be like a history of the EVM and how we got to eof? Would that be like the guide for that panel?
00:47:00.495 - 00:47:31.155, Speaker E: Yeah, that could be nice. The frame that we want to get is basically here. Every change that you are making around DOF are basically the minimal set that we have. We cannot remove things from it. And we thought a lot what needs to be included and what needs to be added at this point of time.
00:47:32.735 - 00:47:33.515, Speaker A: Yeah.
00:47:40.295 - 00:47:42.035, Speaker E: Or some version of that.
00:47:42.975 - 00:47:52.315, Speaker A: Okay. Does anyone want to volunteer to be on a panel? I would volunteer.
00:47:56.215 - 00:47:57.315, Speaker E: I could do that.
00:47:57.775 - 00:48:17.001, Speaker A: Okay. I honestly think we should get Greg or Boris. If Greg's going. Greg's probably not going. It's Forest man is going. Happy to.
00:48:17.073 - 00:48:20.345, Speaker F: I think we need something and try.
00:48:20.385 - 00:48:21.977, Speaker A: To look for happy to work with.
00:48:22.001 - 00:48:34.105, Speaker F: You and try to add more people on the panel. But for that we may have to make an application for that. Would you be willing to make the application for the panel discussion or do you want us to take care of that?
00:48:34.605 - 00:49:13.209, Speaker A: I can take the panel application. I just want to know who I should list should be on the panel. Who getting feedback on that. I think we should have someone from EVM1 and the reason I feel that is because they've been one of the longer term developers longer than me is as far as getting stuff working on the evf. And they also have. I think the biggest thing we can get from someone from Team Epsilon is feedback on what happened during and how that informed where we got to. But I'll.
00:49:13.209 - 00:49:29.535, Speaker A: I'll ping the Ypsilon team separately on that. Are there any other. I guess one question. Do we want to have it be. Do we want to have a skeptic on the panel and if so who and how should we handle it or should it just be a. A history in a. In a pro EOF panel?
00:49:36.715 - 00:49:40.255, Speaker B: It's hard to plan at this point because that's.
00:49:40.915 - 00:49:45.975, Speaker A: Will it still be in come November? Honestly, I mean, yes.
00:49:46.675 - 00:49:47.667, Speaker B: Just more in.
00:49:47.731 - 00:49:51.455, Speaker A: Hopefully address the elephant in the room.
00:49:53.755 - 00:50:01.615, Speaker E: We can always ask. Can always ask Marius. He was mostly like voicing out his opinion about uf.
00:50:02.475 - 00:50:03.215, Speaker A: Right.
00:50:03.555 - 00:50:04.075, Speaker E: And that's.
00:50:04.115 - 00:50:06.055, Speaker A: Marius is probably good one to ask. Yeah.
00:50:06.435 - 00:50:13.575, Speaker E: And this is like three months and a lot of things can change in three months. Opinions can shift.
00:50:15.555 - 00:50:16.295, Speaker A: Right.
00:50:19.365 - 00:50:26.105, Speaker F: It can be also Martin's because I think he had some. Also some criticism recently.
00:50:29.565 - 00:50:53.065, Speaker A: Yeah. Marius or Martin. Okay. Because I do want to get, you know, the skeptical side on it, but I also don't want it to turn into a 40 minute debate about the legitimacy of EOF. So we'll need to make sure that whoever we get to moderate will keep that in mind. And that's the next question is who do we ask to moderate? I mean maybe I moderate. I don't know.
00:50:53.065 - 00:51:29.087, Speaker A: A journalist would be nice, but I don't know which one. Okay. Anything anyone wants to discuss before we end the meeting? Tim would be interesting. I will ask Tim. He might be too busy, but I think it's worth the ask. Anything else that anyone wants to talk about before we end the call? All right. If you have any other comments, the discord's always open.
00:51:29.087 - 00:51:36.015, Speaker A: Feel free to ask anything. Thank you everyone for the time spent working on AOF and coming on this call and we'll see everyone in the next meeting.
