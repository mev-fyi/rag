00:00:00.720 - 00:00:32.720, Speaker A: All right, so welcome to. I think this is the 7th breakout room for apbs. We have some sort of an agenda today and we have a topic that is a little bit complicated that I would like to discuss. But anyway, so before we get there, I posted a link to the agenda there. So let's go over the points that are noted there. Perhaps some people might show up as we go along. So the first point is the EIP status.
00:00:32.720 - 00:01:18.490, Speaker A: No changes here. I think the main pr to the consensus repo has emerged since the last breakout room implementing block only, the markdown for block auctions. And the only testing that, that EIP actually does is testing that the fork code is compatible with the previous forks. So it only tests the transition up to the transition into epbs, but it doesn't test anything on epbs. The PR that actually does all the testing on epbs is quite invasive and it's still open. I don't think it's even been reviewed. That's all about this EIP status, implementation status.
00:01:18.490 - 00:01:48.280, Speaker A: I think it hasn't changed. Perhaps I can report over prism. Prism has. We are somewhat advanced. We have most of the helpers for processing the blocks and the sync package over network and there's been quite a bit of advanced in the RPC endpoints to propose blocks. But we still need core processing and for choice, which is. Which are going to be hard.
00:01:48.280 - 00:01:57.772, Speaker A: Perhaps Gejinder can speak about too whether or not you guys have been working on something already or started implementing. Yep.
00:01:57.836 - 00:03:00.420, Speaker B: So on Loadstar also we have started and me and NC are working on it. We have sort of got the types done and some clarification regarding that in the channel. And right now I am looking at places where there is a blinded block and normal block execution, header execution, payload handling so that this can be taken care of in the new folk because all the blinded types are now sort of collapsed into the normal since the consensus is mostly blinded. If you, if you think like that. So one question that I had with regard to that is how would the block contents API, it's basically the produce block API will change. I think it will also collapse into, into just a single thing. I'm not sure whether.
00:03:01.920 - 00:03:09.100, Speaker A: I'm sorry, I'm not. So the question is how is the block production, uh, workflow?
00:03:10.080 - 00:03:35.682, Speaker B: Yes. So basically how is the block production API changing? Uh, right now we have for example block contents. Uh, so we have produced block v three API and it basically has uh, it comes with block contents or it comes with the blinded block. And uh, so, so that, that thing uh, how that is changing. And uh, one other thing that I wanted to.
00:03:35.746 - 00:03:41.150, Speaker A: Oh, so you're thinking more, more on the beacon API, not on the, on the engine API to produce a block. Right.
00:03:41.490 - 00:03:45.230, Speaker B: Yeah, on the beacon API, between beacon and validator.
00:03:45.610 - 00:03:46.390, Speaker A: Yeah.
00:03:48.130 - 00:04:14.866, Speaker B: And one more thing that I was curious about was are we sort of building this on the Petra? I know Eip says on Petra, but again, pectora is right now undergoing a lot of changes and what we have started is on the top of Deneb and I don't think that it would basically cause any issues if we sort of literally based to Pectora or are we already building on top of pectora?
00:04:15.018 - 00:05:14.614, Speaker A: Oh, so in prism we are building on top of pectra and the spectr is built also on top of pectoral on essentially not the tip of pectra. But there's been not that many changes from Pectra. So I need to probably rebase to the latest changes, but those are very minor. So on the spec PR, the pull request is on top of spectra. All right, so regarding your previous question, which is how the block production goes, it's true that we didn't include a pull request to the beacon API because those things are typically quite contentious. Everyone seems to have an opinion how an API should work and I'd rather be out of those discussions. But also the API which the workflow itself changes a lot if we go with block auctions or slot auctions.
00:05:14.614 - 00:05:18.010, Speaker A: So probably we can talk about this later in the call.
00:05:20.000 - 00:05:34.060, Speaker B: All right, understood. So what we'll do is I'll sort of rebase the branch on tip of Pectra. Basically I wanted to avoid that, but since Prism is already building on top of that. So I guess we should also move on top of spectra.
00:05:35.760 - 00:05:59.050, Speaker A: Yeah. So I think it's going to be easier for all of us if we work on top of Pectra. All clients are quite advanced in Pectra, already testing, so most of the typing system should be already in place for Pektra. So if we build on top of pector, it's going to be easier for us to keep it closer to our develop branch and test on Pektra. That's what I'm guessing. I'm not sure if everyone would agree.
00:06:03.470 - 00:06:35.630, Speaker B: Sounds good. So we will. So I'll be targeting the block flow, block processing flow and NC is looking towards PTC and consumption of the payload. And so basically, yeah, that is what is our focus going forward. But yes, I think if we can sort of have some sort of clarity on block production. That would be nice.
00:06:36.170 - 00:07:11.530, Speaker A: All right. Yeah. So let's, let's talk about this in like when we discussed the last point because, because it changes quite a bit. But perhaps let's clarify now how we are dealing with block production. So if we go with block auctions. So the validator will need to make a call to the beacon to get it a block to sign, just exactly as we do now. Right.
00:07:11.530 - 00:08:18.600, Speaker A: And this happens at the beginning of the slot. Now the beacon needs to produce two different objects. It needs to produce a signed execution payload header for the local block and it needs to produce a signed execution payload header from the builder and then compare them and see which one is better and return that block to the validator to sign. Now how would that go with block production? I think the most optimized way would be the validator makes one call, but it needs to call before to get the header because it needs to sign the header because the block root will depend for the final block would depend on the header that that is included in the block. So the easiest way to do this is to make two calls. The first call is give me a header to sign. Then the validator signs it and gives it back to the beacon.
00:08:18.600 - 00:08:38.100, Speaker A: And then the second call is give me a block to sign. And then the beacon responds with the right block either with the local header or with the builder's header, which is already signed. But then that block already contains the right route. So that that requires two round trips. Yeah, go ahead.
00:08:38.880 - 00:08:44.088, Speaker B: So the first round thing is for the local block production, right?
00:08:44.264 - 00:08:48.520, Speaker A: Correct. And then you get the header immediately.
00:08:48.640 - 00:08:49.456, Speaker B: And then you got it?
00:08:49.528 - 00:09:19.960, Speaker A: You sign it. Yes. So that's, that's one thing. So these two round trips on the beacon side are handled by a single call into the execution engine. So this is the beacon API, right. So what? We just called, we just talked. But the execution engine can deal with all of this with only one call, which doesn't change at all.
00:09:19.960 - 00:10:09.430, Speaker A: So the beacon in the same spot would ask, give me a block to the execution engine and the engine would reply with the payload. And then the beacon out of this payload would make the sign what? The execution payload header that would return back to the validator to sign. And then it will have to keep that payload in a cache because if we use that header, then the beacon later needs to broadcast the execution payload envelope. So with the same payload, the beacon needs to produce two objects, the header and the envelope. If it chooses to use local payload, then it needs to broadcast the envelope. And if it doesn't, then it drops the envelope. Okay, so there's only one call to the engine, but two calls between the validator and the beacon.
00:10:12.050 - 00:10:31.740, Speaker B: So basically that depends upon whether we are embedding the execution block hash or not. Because if we are not embedding execution block hash, then I mean what engine could or what builder, what the local could.
00:10:31.780 - 00:10:56.330, Speaker A: Basically, I think it's the same. So the workflow is the same with just a shift in time. So if the workflow from the beacon API. So now let's do slot options. So the workflow from the beacon API would be exactly the same. The validator would request, give me a header to sign. The header will not include any block hash at all.
00:10:56.330 - 00:11:27.896, Speaker A: And then it would call again, it would sign the header, give it back to the beacon, and then it would call again. Give me now a block to sign. Now. The beacon doesn't need, in this stage, when it gets the header, it doesn't need to call the engine at all. It doesn't really call the engine at all. It just, when it gets a request to get a header, it doesn't call to get a payload, it just produces the header with the data that the beacon already has. It doesn't need any information from the.
00:11:27.928 - 00:11:36.602, Speaker B: Engine to produce a header, but it would sort of need to figure out a bit value for it, for the header.
00:11:36.776 - 00:12:12.410, Speaker A: Right. So this is, this is really a problem. We either want to have a, we want to be either involved or not. So we either put an oracle on the engine so that the engine says, well, I more or less expect that this is going to be the value that I can give you a block for now. Or, or we sort of like have some heuristics in terms of gas price or whatever it is. I don't really know what the best is. If we, if we have an oracle in the engine, that's going to be a change in the, that's going to be a new endpoint in the engine.
00:12:12.410 - 00:12:25.370, Speaker A: It doesn't really make any sense to request a payload at this stage because we're going to have a better or a different payload later. So we would be requesting a full payload just to get a value.
00:12:25.950 - 00:12:50.970, Speaker B: But I think if we sort of keep the local engine simple then, and if we sort of get a value, that is sort of what? Collection of the fees, I mean, so depending upon that, can we allow the payload to add more value, it value to it later on than the value it sort of committed earlier?
00:12:51.470 - 00:13:05.116, Speaker A: Yeah. So we don't even need the payload at this stage. That's the thing. So we could in principle just request a payload now, get a value and then request a payload later and get a value.
00:13:05.268 - 00:13:42.950, Speaker B: For example, if we sign, or if any builder sign locally or external builder sign an execution payload header with a value, with a bid. So as long as they produce execution payload envelope with a biddenness or with a value greater than what they did, I think that should be acceptable. Because in that case things would be really simple because you can first make a call to get the value and in the second call you can get the payload which will obviously might have value greater than that.
00:13:42.990 - 00:14:05.010, Speaker A: No, but wait a second. So I don't understand. So you don't change the value of the bid, right, so that the payload envelope doesn't have a value only, the value is only on the header, which is committed with the block. So the block commits to a value with the header. And this is completely independent of what the payload would have.
00:14:06.710 - 00:14:11.430, Speaker B: Oh, that's nice. Then this problem is sort of resolved in that way.
00:14:11.590 - 00:14:56.680, Speaker A: Yeah. The payload doesn't really need to pay anything, so it's only on the header that the payment is done. The question is local building, how does it work? And if you don't want to change at all the engine API for slot auctions, then local building could work as follows. You could just request a payload as we do now, at the beginning of the slot it would give you a value and you already committed to that payload. So that's the easiest way of implementing a slot auction. You committed to that payload and the builder hasn't committed to anything. So you're comparing your local block right now versus a future block of the builder because they're bidding on what the value would be 6 seconds from now.
00:14:56.680 - 00:15:03.360, Speaker A: So I suspect that local building would always lose in this situation.
00:15:06.260 - 00:15:09.820, Speaker B: Right. So that is another way would be to put.
00:15:09.900 - 00:16:09.820, Speaker A: Another way would be to put an oracle. You could have an oracle that says I'm going to local build if I see the gas price being this much or that much or whatever it is. Or another way would be to ask the engine, give me a value. What do you think a payload would be worth 6 seconds from now? I don't like any of the latter ones, so I would keep it simple as it is today. And clients that always local build, because there are clients that will always want to local build and not use a builder. Those clients can always, those clients can always not call to get an envelope right at second zero to get a value. You can have a flag in your client that would own, because you only need to get a payload when you're about to broadcast, which is about 6 seconds into the slot.
00:16:09.820 - 00:16:14.780, Speaker A: Is that, is that all right?
00:16:15.880 - 00:16:39.574, Speaker B: So basically what you're saying is that. So in my get head up, for example, I don't want to call any of the builders and I only want to produce locally. So the first call I'll do nothing and I'll provide a, I'll basically provide a value with, I mean I can provide whatever the header can be zero.
00:16:39.622 - 00:16:56.370, Speaker A: For local building, the header is zero. It's, the value is zero. It doesn't really matter the value because it's a transfer from the builder to the proposer, which is both objects are the same, both entities are the same. So the local building header can always have a value of zero.
00:16:58.640 - 00:16:59.780, Speaker B: Oh, understood.
00:17:01.440 - 00:17:58.760, Speaker A: So the point is that you don't need to call getpayload for local building under slot auctions because you call to get a header and then the header only contains the parent hash, the parent block root, and this information and the slot, this kind of thing, this information that you already have at the beacon so you don't need input from the execution layer. I if you already know that you're going to locally build and then you can call getpayload later on. Now, I personally think that clients would not implement a delay here. I think for clients validators that want to produce locally built blocks anyways, they're not going to be delaying their execution. I think they're just going to commit now and broadcast immediately the block and the execution payload envelope together because they guarantee inclusion that way.
00:18:07.060 - 00:18:10.920, Speaker B: So block is now committed at 6 seconds.
00:18:11.500 - 00:18:35.950, Speaker A: The block is committed. The consensus block is committed at the beginning of the slot, attested at 3 seconds, and the broadcast of the payload is supposed to be at about 6 seconds. But it can be any time. So if I'm locally building, I already know that my block has a commitment to myself as a builder, so I can broadcast both of them together.
00:18:47.240 - 00:18:57.176, Speaker B: So basically when I'm locally building, then you are saying that both my consensus block and payload can be emitted at 3 seconds.
00:18:57.328 - 00:19:00.020, Speaker A: Yes, can be emitted at 0 second if you want.
00:19:01.720 - 00:19:12.750, Speaker B: Right, right. Unless, I mean, unless execution wants to. Unless the local block production wants to wait till 6 seconds to get a better payload.
00:19:12.920 - 00:19:53.932, Speaker A: Exactly. So you could implement either way. I suspect that clients would go with the easiest, which is for local building. Always commit to a payload immediately at the beginning of the slot. You get a value immediately there and you can compare if you wish, with other bids or not. But it's much simpler to keep it as it is now, the whole thing as it is now. If you want to update the block without changing the engine API, what you would need to do is call for a payload at the beginning of the slot.
00:19:53.932 - 00:20:18.770, Speaker A: You would get a value from the EL and immediately call for four choice update to the last four choice update that you did so that you trigger another execution for the same block. Or you need to change the engine so that it continues building on the same block that it already gave you. But I don't like those changes because I want to keep it a consensus. Consensus PR for the time being.
00:20:20.110 - 00:20:47.220, Speaker B: Right, right. But I mean these changes are sort of minimal. So I mean if I look at Ethereum J's, I think it should be easy to modify it to just make sure that the first call, it doesn't stop, stop building. And so we just to add another endpoint to get the value recall. I think that is something that should be pretty easy to add.
00:20:48.160 - 00:20:58.060, Speaker A: Sorry, I got disconnected and connected again. Internet here sucks. Could you repeat this? You were saying that on Ethereum Js it's simple to implement this.
00:20:58.810 - 00:21:11.670, Speaker B: I mean it should be simple to implement a get value oracle that does not stop payload building and might just give you what is the current value.
00:21:12.090 - 00:21:58.370, Speaker A: Perfect. Yeah, the oracle, yeah, that would be, yeah. So my guess is also that for els it should be easy to more or less estimate what the current value of a block would be. Yeah. All right, so let's move on to the next topic, which is relation with peer Das. So we're talking that we are basing this on Petra, but peer Das is already being discussed whether or not it's going to be in Petra or nothing. In any realistic scenario in which we have epbs, we will have peer Das before or at the same time.
00:21:58.370 - 00:22:53.520, Speaker A: That means that we need to be careful with how we're going to be merging this. Once PRDAs is merged in prism, we have the following problem, which is the fact that most of the code for data availability relies on the fact that the data availability, the blocks themselves come with the blocks, so they don't come exactly with the block, but they're always related to the block. They're labeled by the block root and they're expected to be. So all of the helpers that we write are written in terms of the beacon block that is supposed to be valid or not because of the data availability. But EPBS changes this because the data availability is a validity condition, not on the block but on the payload. So this is just a warning for clients that are implementing. But I only see loads during this call, which is a problem.
00:22:53.520 - 00:23:34.580, Speaker A: But anyways, this should be in the notes, which is if you're implementing GA eventually you need to be careful in your implementing PRdas. Then it would be good if you separate the GA requirements on PRDAs itself on your brdas branch to not assume that the data comes with a block. So if you could separate this now, which is early, then it's going to be easier to then rebase cbbs on top of prdas. Apparently I'm being told that in prison this is not easy to do. I'm not even looking at the PRdas code in prism, but it seems that it might be a problem to rebase cbbs on top of prdas.
00:23:37.010 - 00:23:54.950, Speaker B: Yeah, just to also provide you the load server perspective. It is quite similar in loads are also and very tightly coupled with the block. So that might need change when we are trying to rebase peers. Rebase ebbs on top of PDF.
00:23:56.610 - 00:24:41.400, Speaker A: Yeah, yeah. So that's going to be a problem that's going to bite us eventually. Yeah. So this was just a warning to keep this in mind if you're starting implementing and if you're also implementing PRdas to try to abstract away the block from the PRDAs branch. I'm trying to convince the person devs to do this. All right, so the next one, which is what I posted on discord and on Twitter and a bunch of braces, I think actually that is a killer for block auctions and I think we might want to switch to slot auctions now instead of rather than later. So let me describe again the attack, just for the record, it's going to be here.
00:24:41.400 - 00:25:34.746, Speaker A: The attack is as follows, is that I am a roll up operator. I win the bid to have a payload. So I commit my block hash in the become block I submit my payload which has all. And remember we are committing not only the block hash but we are committing the KCG commitments as well to the block. I well then I will submit a payload that is invalid later on, but early. So the PTC that doesn't check for validity nor GA, they would attest and give it a boost. So my payload would be included but it would be immediately rejected by the EL.
00:25:34.746 - 00:26:20.140, Speaker A: That's going to say this payload is invalid. So the outcome of this is that I am a roll up operator. I can collect this PTC votes so I can prove on chain that a block and the blobs for this particular block hash and this particular KCG commitments were available on l one to most validators. So I have the hashes, I have the KCG commitments, and I know I can prove that the data is available, or was available at least. Therefore I can base a roll up on this, paying only the bid and not paying the gas. That includes the data on l one. So neither the blob gas nor the data gas nor the cold data gas.
00:26:20.140 - 00:27:03.496, Speaker A: And I believe this is a brutal attack. We don't have a solution to this. As of this moment, the solution that was offered by Lee from Lee Bousfield from arbitrary we could in principle slash the builder for invalid blocks. This is actually not hard to do. You could always slash the builder for the length of the value that would be committing all of the block as data. That means the maximum. Consider the size of the data, the size of the block, and multiply with that as if it was called data with the current block, with the current gas fee.
00:27:03.496 - 00:27:55.792, Speaker A: And then consider the number of blobs and multiply that for the as if the blocks were available for the block data gas. So you could deduct this payment from the builder if the block is deemed invalid, but it comes with a bunch of trade offs, you need to keep those invalid blocks. This is not so bad, but we need to keep them because you need to prove that they are invalid. And then preemptively, when you're validating the bids, you need to know that the builder has enough money to pay in the occasion that his payload is invalid. So this makes complication and I think people anyways already favor slot auctions over block auctions, and slot auctions are much simpler to implement because we don't commit to anything. We don't need to commit to. We don't need to commit to the KCG commitments in the block and we don't need to commit to the block hash in the block.
00:27:55.792 - 00:28:53.770, Speaker A: So my proposal at this stage would be that I spent a couple of days, actually, I can have it today. Even the pr for the consensus repo only changing the markdown on the without the testing for slot auctions. So we move a slot auctions by default unless there's someone that can actually come up with a better design for block auctions. And we don't commit to the block hash nor the KCG commitments on the beacon block. We commit to the KCG commitments on the payload envelope. Well, I mean, we update the KCG commitments on the payload envelope. So I need to think whether or not these are deep changes or not, but they seem to be very simple to implement and I could have this pr by today or tomorrow in addition to, well, no, let's open the discussion with this only.
00:28:53.770 - 00:29:14.860, Speaker A: I don't know if people have opinion here. All right. I don't see.
00:29:16.520 - 00:29:18.240, Speaker C: Oh, hello. Hi.
00:29:18.320 - 00:29:20.216, Speaker A: Yeah, hello.
00:29:20.408 - 00:29:54.810, Speaker C: Just a beginner. I just learned about the PBS and epbs and execution tickets and some other kind of thing related to MEB proposal. So maybe it's kind of like a silly question. So if you don't mind, may I ask what is the difference between the beacon block and block? Like what is the difference between the beacon round beacon proposer and executing round execution block?
00:29:55.910 - 00:30:53.980, Speaker A: So if you're reading about abs some distance execution tickets, the meaning is different there than here. Here the meaning is we are separating the consensus block. So currently a beacon block comes inside with what is known as the execution payload. So the become block inside the body has an execution payload which itself contains the transactions that are sent to the execution layer. What we're doing is separating those out of the become block. So we will have two different blocks, one that is sent by the proposer that only contains the consensus information, and one that is broadcast by the builder that contains the execution information, namely the transactions. What we're discussing now is whether or not we want to have in a, we want to commit to the block hash of the execution in the beacon block or not.
00:30:53.980 - 00:31:02.700, Speaker A: And I'm hoping to get some feedback on whether it's a good strategy to move to slot auctions now rather than later.
00:31:06.880 - 00:31:14.660, Speaker B: Yeah, so my opinion is I like slot auctions and we should do it now only. I mean, there is no point doing it later.
00:31:17.840 - 00:31:42.778, Speaker A: Okay. I actually dislike slot auctions, but I think I dislike more the problem that I just found on block auctions. So I'll ask around. Since this meeting doesn't have enough people, I ask a little bit, but I suspect that most people would want any ways to move to slot auctions. So I'll work on the pr. If you're already implementing, it's not big change for me. I'll take the PR on prism.
00:31:42.778 - 00:32:28.974, Speaker A: It shouldn't be a big change to move to slot auctions. The changes are really minor because you're checking less things. So it's just changing a couple of types and removing the hash and the KCG commitments from the become block. All right, so we are only essentially two devs currently arguing this, so perhaps this is just premature. But anyways, it seems like reasonable to commit to having the hash not committed nor the KCG commitments. Another last topic I wanted to discuss is the issue of withdrawals, this. I'll keep it as it is today.
00:32:28.974 - 00:33:00.576, Speaker A: But it would be nice if someone spends time analyzing the dangers of processing the withdrawals in the payload as we do today. So today, without ebbs, the withdrawals are included in the payload. And we check that they correspond to what the beacon state wanted. But. But then we process them out of the payload on epbs. These changes on epbs. We process them out of the beacon state.
00:33:00.576 - 00:33:23.890, Speaker A: And then we request that the payload fulfills the same withdrawals. The problem with this is that this needs to commit the withdrawal route to the beacon state. And it's ugly. It's much simpler if we actually process them from the payload. We get a payload, we check what is the. We don't change anything. Maybe we don't check process.
00:33:23.890 - 00:33:49.502, Speaker A: We don't change process withdrawals. And we include the withdrawals on the payload. That's the easiest possible implementation. But it has some semantic changes as to what a withdrawal means. Because you may have many, many blocks that are full from consensus side but empty on the payload side. And I haven't done the analysis as to what changes. If there's any danger there.
00:33:49.502 - 00:34:46.234, Speaker A: It would be nice to have someone that actually takes it seriously, analyzes the situation and checks if leaking or validator leaking or these kind of things or slashings during this period without payloads could affect those withdrawals. And if there's any danger in moving withdrawals to the payload, I'll keep it as it is now. But I really am looking forward to remove the process withdrawals from the consensus block and put it back in the payload. That's all I had for today's meeting. We could close early unless someone wants to discuss a little bit more. All right, so let's call this adjourned. I'll post the notes shortly because I have them fresh now.
00:34:46.234 - 00:35:05.390, Speaker A: And Terence is not here. So I'm going to post the breakout room notes and I'll circle the question of whether or not to move to slot options immediately. All right. I'll see you guys in a couple of weeks. All right, bye bye. Thank you.
