00:00:16.650 - 00:01:13.780, Speaker A: So what I'm planning on talking about today is basically scalability, and particularly some of the more detail, the implications that this is going to have for how Ethereum developers are going to write their contracts. So we've already talked about scalability quite a lot this morning for about an hour. We've talked about Casper consensus problems, some of the issues that meeting Ethereum scale is necessarily going to entail. So just to sort of recap all of that very quickly, Ethereum right now, every single computer in the Ethereum network processes every transaction. Every single computer in the Ethereum network maintains the entire state. And that is very slow. On the Olympic test set, we achieved an impressive 20 transactions per second, which I believe is roughly what normal computers were able to do at some point in the 1980s.
00:01:13.780 - 00:01:46.442, Speaker A: Yeah, but unlike nearly all other systems in the real world, this also does not get more powerful the more nodes join the network. Surprisingly enough, in fact, it actually should get slightly less powerful with the universal logarithm of the size of the network. But the basic reason is, if you have ten times more nodes, guess what? Each and every node still processes, processes every transaction. You still are where you started. You just have even more inefficiency. So the basic vision for 2.0 is this concept of sharding.
00:01:46.442 - 00:02:34.110, Speaker A: So instead of having one global state that's seen by absolutely everyone, you split the state up into these sort of chunks that you can call shards. And each of these shards is going to contain its own state. So you can imagine each shard containing some portion of all of the accounts, and then you have some number of shards. You can imagine potentially having a few hundred, a few thousand of these, and the state is represented in a Merkel tree. As usual, Merkel roots of the state are represented in the shard roots. And then you build another Merkel tree out of the shard roots, and you get the global state root of the entire Ethereum system. So as you can see, yes, you can still have some concept of sort of a global truth, even in a scalable context.
00:02:34.110 - 00:03:22.270, Speaker A: So states split into shards, each account is only in one shard. And just the simplest case, accounts can only send transactions to or call accounts within the same shard. So this is one fairly simple way to do it. So basically, you just sort of split Ethereum up into a few thousand different islands. And if you want to do stuff that kind of interoperates between islands, well, you just have to figure out some sort of super protocol way to do it. But in theory, you can probably have a few thousand different applications and each application can kind of do its own thing. You could have a shard that has gnosis on it, you could have a shard that has like auger and potentially three other things on it.
00:03:22.270 - 00:03:53.654, Speaker A: You could have a shard that has five other things. So this is one place to start. So just to go into this in sort of much more detail, the way that this would work from a transaction standpoint is you have two levels. So in bitcoin, in Ethereum, you have a block header which is small. Then you have the set of transactions which is large. And in the block header the set of transactions is represented by a Merkel root. So here instead we're going to do a two level thing.
00:03:53.654 - 00:04:29.214, Speaker A: So we're going to create this object called a transaction group. And so the way you can think about this sort of from a big picture standpoint is theoretically even in bitcoin, or even for something like bitcoin, you don't need to have blocks. You could have just required transactions to just have proof of work on their own. And you could have just made every transaction, reference one previous transaction and just made a chain end of transactions. As it turns out, by introducing one level of indirection with blocks, you can make things somewhat more efficient and somewhat more scalable. Here we're introducing two levels of indirection. You have transactions.
00:04:29.214 - 00:05:19.220, Speaker A: Transactions get collated into transaction groups and then it's going to be the transaction groups that go into the main header chain. So transactions, what they groups, what do they have? They have a header and a body. The header contains two main components to it. The left side contains a shard id, then a prestate route, a post state route and a receipt route. So the prestate route basically says, hey look, before these transactions were applied, the state route of shard 43 was this. The post state says after applying all of these transactions, the state route of shard 43 is going to be this. And then you also say, because Ethereum has this concept of receipts, if you apply all these transactions, the root of the tree of receipts that they're going to omit is going to be this.
00:05:19.220 - 00:06:02.640, Speaker A: And each of these transactions has to have a shard id as well. So all these transactions are going to have Shard id 43. And so the whole thing has shard id 43. Over here you have the idea that in order for this header to be valid, it has to be validated by this sort of randomly selected global sample of validators. So we could imagine you'll have some 400 or 1000 whatever number of ideas of validators inside the entire system. And theoretically, these don't even need to be the same validators as the ones that actually maintain the top level consensus. So if you're concerned about sort of o event squared stuff slowing down Casper or slowing down whatever other consensus algorithm, that's fine.
00:06:02.640 - 00:06:36.970, Speaker A: You can stick to 400 validators for Casper and have 40,000 validators for the bottom level. Now, every transaction specifies an id. A transaction in Shard X means that it does stuff only in shard x. A transaction grouping in shard x contains zero or more transactions in Shardx and specifies the pre and post state route. Top level looks like this. So this is probably one of the more complicated blockchain diagrams you're going to see this week. Probably the major competitor here is going to be Jeff Coleman's universal hash time graph.
00:06:36.970 - 00:07:07.522, Speaker A: So basically you still have a blockchain at the, you know, you can call this the header chain, and it know a state route. It contains the hash of the previous block. It contains metadata, just like all the metadata we all know and love. But it contains two primary routes. One of them is a state route, and the state route basically represents the entire state. So here you have the shard routes. Each shard itself points to a tree, and then you have a transaction group route.
00:07:07.522 - 00:08:11.370, Speaker A: So instead of just being a Merkel tree of transactions, you have a Merkel tree of transaction groups. And then each transaction group, as usual, contains pre state, post state of the shard, not of the entire global thing, and a transaction route, and was a transaction tree and a receipt route for the receipt tree. So one way to think about this sort of intuitively is you can think of the top level as the top level, as a non scalable ethereum 1.0 style blockchain, except it has these funny state transition rules where instead of validating transactions, it validates transaction groups. And a transaction group is valid if basically the prestate route matches. And if the signatures are valid, and if those two things line up, then it takes the signatures as kind of proxy evidence that everything else was done correctly. And then if this transaction group gets in, then the post state route becomes the state route of that particular shard.
00:08:11.370 - 00:09:29.810, Speaker A: So, question getting back to how do we do cross shard transactions? So the problem is, if we allow just sort of random, arbitrary cross shard calling, then parallelization becomes impossible. You could potentially have contracts in 20 different shards, all access or modify accounts in 20 other different shards, and it could be done in some way that's completely not friendly to any kind of parallel analysis, it could be non commutative in a whole bunch of intractable ways. So solution is to make it asynchronous. But how? So the basic ingredient here is Merkel tree receipts. So if you look at just one particular receipt, you might notice that this receipt is part of a tree. And this Merkel tree has a root over here and this thing is itself part of a tree, or rather, and then this thing itself is part of a tree which has a Merkel root over here. So ultimately you could come up with a fairly compact branch and that branch would ultimately basically be a proof that the receipt actually was included at this particular time.
00:09:29.810 - 00:10:20.126, Speaker A: So this gives you proof of existence. It does not give you sort of proof of non double spending. But what we're going to do is we're going to add that in, but we're going to sort of cleverly add that in in the correct shard. So what I'm basically describing here is a fairly kind of simple sort of standard approach that lets you implement a sort of node JS style asynchronous programming language on top of this sort of Ethereum 2.0 infrastructure. And the key piece that you require is you need to have transactions have access to Merkel routes from previous blocks. So transactions here should be able to read the global previous state route, global previous transaction group route.
00:10:20.126 - 00:11:04.820, Speaker A: Now they don't need to be able to modify anything globally, they just needs to read a historical route. And that's fairly okay. It doesn't sort of prevent parallel analysis or parallel computation at all. Now what you have here is let's just go through a fairly sort of somewhat involved example. It's involved enough to capture all the nuances, but it's still sort of as simple as it can be within that context. So suppose that you are trying to register a domain name and this domain registrar is so devilishly evil that it only accepts GAFcoin as payment. So the domain registrar lives in shard 43 and Gafcoin lives in shard six six.
00:11:04.820 - 00:12:27.690, Speaker A: So the problem is that now this registrar charges a fee. Problem is, let's say the fee is 20 gaffcoin. Let's say I want to make a transaction which pays the 20 gaff coin, registers the domain and registers the domain. How does this sort of ensemble of the registrar and GaFcoin actually verify everything? So in general, the most kind of standard approach so far for contracts charging users sub currencies in order to actually make payments is a sort of two step receipt approach where the first step is you send a transaction to the currency and you kind of authorize the other contract as a withdraw and then you send another transaction to withdraw and then the contract sort of actually sort of debits out of your bank account. So this is something that we're going to be discussing probably in more detail over the next few days in things like the standard contract interfaces panel, but it's roughly the approach right now. So over here what we're going to do is we're going to call the function of the name registrar. And what we're going to say is we want to register a domain with some name.
00:12:27.690 - 00:13:03.714, Speaker A: We want to provide what fee we want to provide and we're going to provide the currency shard and the currency address. So basically where Gaapcoin lives. So what it's going to do is it's going to register a callback id and then it's going to create a log. And this log is basically going to contain all the information. So it's going to contain the destination shard, the destination address. So the log is going to say this log is addressed to Gavcoin, then it's going to say what method is being called here. So in this case, this contract wants to call the method withdraw.
00:13:03.714 - 00:13:45.454, Speaker A: It wants to withdraw 20 gaffcoin from my account. And the arguments are from me to the name registry and the value 20 gaffcoin. And it's going to say after this all happens, it's going to go to a callback method, which is the withdrawal callback and it's going to give it the callback id. Now, over here, I'm also going to, in the name registrar's own storage, basically provide some information saying, hey, look, there is this callback that's being happening and it's in progress right now. Step two on the gaffcoin side. So step one, I set this transaction on shard 43. It happened.
00:13:45.454 - 00:14:13.614, Speaker A: It created a log. Now, unfortunately, this isn't ethereum 1.0 anymore where all the messages happen automatically in asynchronous programming. This is also going to be a second transaction. You have to send it. So you send a transaction and what this transaction is is it's going to basically all that it contains is a log proof. It's just going to contain this Merkel proof of the log that was created in step one.
00:14:13.614 - 00:15:07.386, Speaker A: So what this contract is going to do is it's going to check the Merkel proof and it's going to verify that the Merkel proof is actually addressed to Gafcoin and it's also going to verify that this particular log has not yet been submitted. So in shard six six it now maintains a record of whether or not this particular callback id has been spent. So then it sets spent to true and it calls its own method. So in this particular case the method could be whatever it could be. Well in this case it's actually going to be processing the withdrawal. So it's going to be checking. Number one, have I authorized the registrar to withdraw my gaffcoin? Number two, do I have enough balance? And if both of those are true then it's going to debit my Gafcoin balance.
00:15:07.386 - 00:15:58.558, Speaker A: It's going to give the name register on my gafcoin and it's going to return success. Otherwise it returns fail, then step three and then if that succeeds, so it's going to call and it's going to create yet another receipt, this time in chart six six. And this receipt basically says okay, this computation happened and you have a response. Step three is basically almost the same thing as step two except in step two you were verifying that a log proof of the original call and you were verifying that hasn't yet been spent and you're also creating a receipt. Here. You're verifying the callback, you're verifying a Merkel proof of the callback. So you're in the name registrar, you're back in chart 43.
00:15:58.558 - 00:17:05.410, Speaker A: Now you're just verifying a proof that a log has been created, has been emitted by the GAfcoin contract and is directed at the name registrar. If that's true and if this particular log has not yet been spent then I'm going to say see that it's been spent and I'm going to call the method. So the method in this case is withdraw callback and the withdrawal callback basically says if the response is true then set the owner of this particular domain. Now over here, I probably should have also added that if the domain doesn't have an owner yet or something similar. So basically if the entire payment process, including initial transaction processing on the gaffcoin side and the callback, if everything works out fine then I'm going to register the domain name in shard 43. And there you go, you have an entire kind of pathway of asynchronous function execution. So in practice there are three main use cases for cross contract calling.
00:17:05.410 - 00:17:47.218, Speaker A: Number one is to get information. So getting information basically means I want to call the Bloomberg contract and I want to find out what the exchange rate is of USD to euro the second one is send an action without response. So one simple use case is, let's say I'm building a crowdfunding application, I'm building wayfund and a wayfund campaign, let's say fails. And so I have to refund all the money. So I'm just going to do a big huge multi send, give everyone their money back. That's just asynchronous sends does not even require a callback. The third one is send an action with a response, and gaffcoin is one example.
00:17:47.218 - 00:18:14.806, Speaker A: You have to send an action, tell Gafcoin to withdraw. Gafcoin does something and it might return success or it might return failure. So the second is actually not problematic at all. The first and third maybe. So once you get into asynchronous programming, as everyone who has done asynchronous programming will know, you run into race conditions. You have to think about mutual exclusion issues. And even without that Javascript callback towers look ugly and they are annoying.
00:18:14.806 - 00:19:05.942, Speaker A: And so you might want to think about promises, things like async map. So in general you want kind of programming paradigms that make this kind of stuff easier. Now skip the economics, because I don't have too much time, but that side is also interesting. The basic summary is that yes, you can do it, yes it's fine. And in fact, even though you need multiple transactions, you can actually make it censorship resistant, because basically because the log was created, you have common knowledge of the fact that theoretically a transaction completing the process can be made, and so you can punish validators for not making it within some number of blocks. So, more generality, here's one possible model. First, k bits of an address is a shard id, and k is set by the transaction.
00:19:05.942 - 00:20:00.846, Speaker A: So every transaction sets its own k you could set k equals zero means that your transaction can do everything globally. Setting k equals ten means your transaction only affects things that have a particular ten bit prefix and so forth. Attempting to synchronously call a contract outside of a shard. And the shard is kind of this sort of much more fuzzy concept where it's kind of defined by K. Basically, if your transaction sets k to 13, then if you try to do something, if one contract tries to call another contract where one of the first 13 bits is different, then that triggers an out of gas exception. And so the key points economically is that transaction groups on all, no matter what, the k is going to have the same gas limit. So if you want, you can make a transaction set the k to zero, and someone can collate all these transactions, put them together into a transaction group that has k equals zero.
00:20:00.846 - 00:20:32.902, Speaker A: But here's the thing. If you are someone creating a top level block, then you could get one transaction group at k equals zero. Or you can get 32 transaction groups at k equals five. Or you can get 65,536 transaction groups at k equals 16. So in equilibrium, the lower your k is, the more expensive it's going to be. And that's kind of a way of making this sort of balance and letting people sort of choose along the curve between synchrony and cost. So that's basically it.
00:20:32.902 - 00:20:36.690, Speaker A: Welcome to asynchronous Ethereum 2.0 contract programming.
