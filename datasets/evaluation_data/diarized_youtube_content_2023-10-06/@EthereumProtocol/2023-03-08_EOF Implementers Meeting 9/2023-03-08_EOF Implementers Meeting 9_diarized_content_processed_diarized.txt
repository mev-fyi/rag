00:00:02.010 - 00:00:05.280, Speaker A: You cool?
00:00:06.370 - 00:00:06.878, Speaker B: Okay.
00:00:06.964 - 00:00:07.310, Speaker A: Hello.
00:00:07.380 - 00:00:20.430, Speaker B: Good morning everybody. Welcome to the EOF implementers call number nine. Let's go ahead and get started with some client updates. Does anybody have anything to share since the last time we spoke?
00:00:23.800 - 00:00:48.130, Speaker C: Basically we was starting to test out a tan software, getting some feedback from the testing team. It runs against the execution client specs and just running around some of the undocumented corners that we're encountering and what's expected, like if the reward is negative, they don't want any block reward touched or stuff like that.
00:00:51.780 - 00:00:52.530, Speaker A: Cool.
00:00:57.000 - 00:01:02.550, Speaker B: Alex, anything to add from EVM one?
00:01:10.220 - 00:01:15.532, Speaker D: Yeah, very close to merge the big.
00:01:15.586 - 00:01:22.476, Speaker E: UFPR which basically implements everything matching what.
00:01:22.578 - 00:01:24.124, Speaker D: Are in the eips on the test.
00:01:24.162 - 00:01:27.870, Speaker E: Suite because previously these were like several different.
00:01:31.540 - 00:01:51.576, Speaker D: Also have. I believe Andre is on the call so he could expand on it. But I think we have a mostly finished implementation of the 2.0 stuff in regards to create. I can give some update later on on the call, but we did a.
00:01:51.598 - 00:01:54.904, Speaker E: Number of back and forth in terms.
00:01:54.942 - 00:01:57.160, Speaker D: Of the design, but I think we're.
00:02:00.380 - 00:02:04.236, Speaker E: Nearing down at one design which is.
00:02:04.258 - 00:02:07.660, Speaker D: A bit different to what we discussed at Weiss.
00:02:09.600 - 00:02:10.700, Speaker A: Okay, yeah, cool.
00:02:10.770 - 00:02:17.090, Speaker B: Let's talk about that some more in a minute. Merrick, anything from Nethermind's end?
00:02:18.420 - 00:02:21.760, Speaker F: I think Iman will cover that. So Iman.
00:02:23.700 - 00:02:24.690, Speaker B: Got it.
00:02:29.400 - 00:02:30.870, Speaker F: We can't hear you.
00:02:38.360 - 00:02:40.970, Speaker B: Audio doesn't seem to be coming through for me.
00:02:42.700 - 00:02:53.290, Speaker F: I know that I'm an adjusted to the latest changes of year, but I don't know details to be honest. So maybe we can go back when he fix.
00:02:54.780 - 00:02:56.712, Speaker A: Yeah, that sounds good.
00:02:56.766 - 00:03:18.180, Speaker B: Simon, feel free to interrupt us if you get your audio working. Another reason to have Mike Dow. Okay, it doesn't look like anyone from the compiler teams is here. I don't know, Alex, if you have anything to share on that front. If not, we can talk about specs.
00:03:22.200 - 00:03:28.756, Speaker D: Yeah, I don't have anything, but the solidity team had the offsite during last.
00:03:28.778 - 00:03:33.640, Speaker E: Week or this week, which probably is more about planning.
00:03:34.380 - 00:03:39.864, Speaker D: And I expect you to get more feedback from them starting next week once.
00:03:39.902 - 00:03:41.770, Speaker E: They finish with offsite and all that.
00:03:42.620 - 00:03:44.108, Speaker A: Okay, sounds good.
00:03:44.274 - 00:03:57.250, Speaker B: Also that made me think. I remember talking to somebody, Denver, who was saying that arbitram is planning to roll out an implementation of EOF. Has anybody here talked to the arbitram team at all?
00:03:59.780 - 00:04:03.090, Speaker C: Is that EOF or EVM plus that they're talking about?
00:04:05.220 - 00:04:15.990, Speaker B: I'm not sure. The person who let me know that this was happening worked on EOf a little bit on ref, so.
00:04:17.720 - 00:04:18.292, Speaker A: I think.
00:04:18.346 - 00:04:22.170, Speaker B: That it's EOF, not EvM plus.
00:04:23.020 - 00:04:24.760, Speaker D: What about EvM Max?
00:04:26.300 - 00:04:28.760, Speaker B: That is a separate.
00:04:34.220 - 00:04:45.788, Speaker E: You know, with the EVM plus. They may have read our minds adel wise. We were thinking about renaming UF to EVM next or EVM plus, but we.
00:04:45.794 - 00:04:47.276, Speaker D: Were too slow to make a decision.
00:04:47.308 - 00:04:48.880, Speaker E: And announce it on Twitter.
00:04:49.220 - 00:04:57.508, Speaker D: So I guess they picked up the EvM plus name instead. And Craig, what is EVM plus? It's nothing to do with EVM as.
00:04:57.514 - 00:05:00.820, Speaker E: Far as I know, it's wasm.
00:05:06.150 - 00:05:07.362, Speaker A: Hey, I'm in.
00:05:07.496 - 00:05:09.140, Speaker B: Is your mic working now?
00:05:09.910 - 00:05:11.970, Speaker G: I hope so. Can you hear me?
00:05:12.120 - 00:05:14.280, Speaker A: I hear you. Okay.
00:05:14.650 - 00:05:33.958, Speaker G: For nethermind, we implemented a draft for v one one and for jump f, just to be ready and currently trying to see how v two will be easily integrated into what we have right now. And we kind of have some opinions.
00:05:34.054 - 00:05:37.914, Speaker E: When it comes to what has been.
00:05:38.032 - 00:05:44.000, Speaker G: Discussed and what we try to implement. Hopefully we'll discuss them later this call.
00:05:46.210 - 00:05:57.250, Speaker B: Cool, thanks for the update. Anything else regarding clients or compilers before we jump into spec updates?
00:06:04.780 - 00:06:07.800, Speaker A: Okay, spec updates.
00:06:08.220 - 00:06:19.356, Speaker D: Actually, there's one thing. Hugo from our team is working on changing the Kawatir NPR, moving everything to.
00:06:19.378 - 00:06:23.644, Speaker E: Cancun because with that he can't refill.
00:06:23.692 - 00:06:31.440, Speaker D: Every single test to Cancun because they're currently set to Shanghai.
00:06:32.580 - 00:06:35.024, Speaker E: So the goal is that the test.
00:06:35.062 - 00:06:47.944, Speaker D: Feed, there's no changes to the semantics, it's just changing the EVM version from Shanghai to Cancun. And for that Hugo is changing the Goethe. He's finished with that and he started.
00:06:47.982 - 00:06:50.024, Speaker E: To refill the test and he will.
00:06:50.062 - 00:06:52.680, Speaker D: Push them to the testing suite.
00:06:53.580 - 00:06:54.650, Speaker A: Okay, great.
00:07:00.640 - 00:07:09.248, Speaker B: Let's move on to spec updates. Does anybody want to share how the spec has changed in the last couple.
00:07:09.254 - 00:07:10.690, Speaker A: Of weeks where we're at.
00:07:18.070 - 00:07:23.046, Speaker E: If nobody else jumps? I do have a large number of.
00:07:23.068 - 00:07:25.670, Speaker D: Updates regarding spec discussions.
00:07:26.650 - 00:07:27.590, Speaker A: Excellent.
00:07:29.610 - 00:07:31.560, Speaker D: Let me just try to open this.
00:07:33.130 - 00:07:36.230, Speaker E: So we internally.
00:07:38.970 - 00:08:20.210, Speaker D: I think, since the last dwef call two weeks ago. Since then we had two or three internal discussion calls in ipsilon just to align at least ourselves in what we would like to propose regarding the changes. And we took a look at the outstanding prs and the eips repo as well as made up our minds regarding the flags field which we discussed on the last call. And I think we also kind of made up our minds in regards to the 1.1 changes and the 2.0 changes. That's the summary.
00:08:20.210 - 00:08:24.140, Speaker D: Let me just open up, send you the things.
00:08:39.300 - 00:08:40.290, Speaker E: One sec.
00:08:42.100 - 00:09:00.260, Speaker A: Sure. Okay.
00:09:03.930 - 00:09:07.960, Speaker E: So this is the first pr.
00:09:09.690 - 00:09:13.302, Speaker D: It's about changing how the table size.
00:09:13.356 - 00:09:17.782, Speaker E: In RJMP works and we internally think.
00:09:17.836 - 00:09:30.702, Speaker D: That this is a good change and we would like to have it. We've made some clarifications to the pr. I think it would be good to get like a final decision on this call.
00:09:30.756 - 00:09:42.266, Speaker E: Is anybody against merging test change? I think Dano, and least Dano commented.
00:09:42.298 - 00:09:44.586, Speaker D: On it, so probably Dano is aware.
00:09:44.618 - 00:09:45.760, Speaker E: What this change is.
00:09:46.630 - 00:09:48.500, Speaker D: I'm not sure about everyone else.
00:09:52.100 - 00:09:52.556, Speaker A: Although.
00:09:52.588 - 00:09:54.908, Speaker D: We discussed something pasted link in the comments.
00:09:55.084 - 00:09:56.304, Speaker A: Yeah, thanks for that.
00:09:56.422 - 00:10:12.970, Speaker B: I thought we discussed something kind of like this. I don't know if it was specifically r jump v, but it feels a little weird to have the table size be plus one, the actual value encoded in the upper end.
00:10:16.930 - 00:10:57.050, Speaker C: So it depends if you look at it, is this table size or is a max index? If it, you know, r jump one, you could have an index of zero one r jump 20 one or two. That allows us to r jump 2550-1255 so it does look a little bit like plus one, but that's just old zero one based indexing. There's no clean way to allow what we need to do, which is to allow a 256 table with fall through for an out of range number for a 256 bidden without having this weirdness with it. But it's not too weird.
00:10:58.910 - 00:11:14.290, Speaker B: Do we have any other examples of using max index? Because for things like push, it's the max size. So this would be a deviation from that format.
00:11:24.580 - 00:11:28.608, Speaker E: So the reason we are leaning towards.
00:11:28.694 - 00:11:32.480, Speaker D: Having this is exactly as you say.
00:11:32.630 - 00:11:37.796, Speaker E: The initial design was guided by spec.
00:11:37.898 - 00:11:46.264, Speaker D: Simplification and really from the EVM implementer side. And the proposed change is done from.
00:11:46.302 - 00:11:51.608, Speaker E: The EVM user side. And it clearly seems to be a.
00:11:51.614 - 00:11:58.004, Speaker D: Really useful feature to be able to have 256 locations because then you can.
00:11:58.062 - 00:12:01.084, Speaker E: Have a very simple jump table, and.
00:12:01.122 - 00:12:04.012, Speaker D: Especially for having a jump table for.
00:12:04.146 - 00:12:06.540, Speaker E: Implementing EVM within the EVM.
00:12:07.680 - 00:12:23.990, Speaker D: And I think we feel like that the use case benefits overweight the spec clarity in terms of is there any other opcode following this scheme or not? So I think that's the reasoning from our side.
00:12:24.440 - 00:12:28.900, Speaker B: Okay, yeah, I think I agree with that reasoning.
00:12:31.940 - 00:12:53.610, Speaker C: The only other real option is to do weird things like our jump zero means 256, or do a two byte r jump or a two byte r jump fee. So our jump fee size of zero is really size 256. That's we start getting weird. We don't want super large jump view tables which two bytes would enable and encourage people to try and use.
00:12:57.640 - 00:13:04.920, Speaker A: Okay, cool. What else you got for us?
00:13:09.770 - 00:13:27.426, Speaker E: Yeah, the next one is this non behavior for create. And this is a more complex topic in the sense that it would be.
00:13:27.448 - 00:13:31.700, Speaker D: Nice to have pavel on the call. Okay, he's on the call now.
00:13:33.850 - 00:13:34.166, Speaker A: But.
00:13:34.188 - 00:13:53.370, Speaker D: Also with the UF 1.1 and 2.0 changes, this kind of becomes obsolete or on the fringes. So maybe I should explain what we think should be the case for 1.1 and then we can circle back to this because then there's more context.
00:13:57.020 - 00:13:58.330, Speaker A: Yeah, sounds good.
00:13:59.900 - 00:14:09.230, Speaker D: With the 1.1 I can share the document again, we discussed this, I think the first call after.
00:14:11.360 - 00:14:16.210, Speaker E: Adelweiss, and let me just share that link again.
00:14:19.650 - 00:14:19.978, Speaker A: There'S.
00:14:19.994 - 00:14:42.716, Speaker D: Just so many documents. Okay, so this was the rollout plan. So basically with the UF 1.1, which is the version we want to roll.
00:14:42.748 - 00:14:49.220, Speaker E: Out, that won't allow contract creation within UF.
00:14:50.360 - 00:15:38.672, Speaker D: So we are removing the create and create two instructions from UF code. And the only way we enable creating UF contracts is through creation transactions. Back when we shared this document, there were like a number of different options how to accomplish that. And we arrived at a singular option which we think is the best. And that option is that legacy EVM code in the create transaction is allowed to create Uf code. However, legacy eVM code cannot create Uf code through create and create two instructions. And I think currently there have been like multiple ways.
00:15:38.672 - 00:15:46.324, Speaker D: I don't remember what the 1.0 actually does. Do we ban UF creation from legacy or not? But I think at some point we.
00:15:46.362 - 00:15:47.670, Speaker E: Did want to ban it.
00:15:48.520 - 00:15:55.784, Speaker D: So the final proposal is that legacy eVM code cannot create Uf contracts with.
00:15:55.822 - 00:16:03.676, Speaker E: Create or create two Uf code cannot use, create or create two Uf code.
00:16:03.858 - 00:16:11.100, Speaker D: Cannot be used in a create transaction. I mean, it can, but it cannot return anything. So it's pretty much useless.
00:16:13.600 - 00:16:15.984, Speaker E: And that remains that.
00:16:16.022 - 00:16:24.028, Speaker D: The legacy EVM code in the create transaction is the one which creates EUF contracts.
00:16:24.124 - 00:16:27.052, Speaker E: And at that point it can inspect.
00:16:27.116 - 00:16:31.140, Speaker D: EUF contracts because it uses the same old return mechanism.
00:16:32.840 - 00:16:43.576, Speaker E: But you feel like that any other option is just way too complicated for not many benefits. And the only way to avoid any.
00:16:43.598 - 00:16:47.130, Speaker D: Of that intermediate complication is going straight to 2.0.
00:16:50.220 - 00:16:51.416, Speaker E: Yeah, I'm not sure if any of.
00:16:51.438 - 00:16:59.276, Speaker D: This made like complete sense to you listening, because I'm a bit tired and really bad at explaining today, but maybe I will.
00:16:59.378 - 00:17:04.830, Speaker E: Yeah. Can you tell me if this beta sets or should I try to write it down instead?
00:17:11.720 - 00:17:15.444, Speaker B: I'm only operating at about 45%, so.
00:17:15.642 - 00:17:17.652, Speaker A: That'S probably not on you.
00:17:17.706 - 00:17:19.270, Speaker B: If I'm struggling to follow.
00:17:22.200 - 00:17:41.790, Speaker C: So if we allow legacy code as a result of its create a nit code to create eof two, then that means forever. We would allow legacy to create eof code. So legacy can always introspect, would we still? And in that create, they could introspect into it, right?
00:17:44.560 - 00:17:47.520, Speaker D: Yeah, but only on a create transaction.
00:17:48.740 - 00:17:52.800, Speaker C: During the create transaction, before you send it off to the EVM to deploy.
00:17:53.860 - 00:18:03.616, Speaker D: Yes, it is only in the create transaction. The reason we want to bend existing legacy code using the create of code, because then you can just have proxies.
00:18:03.728 - 00:18:04.004, Speaker A: Right.
00:18:04.042 - 00:18:10.420, Speaker D: And definitely defeats any kind of banning of introspection. So the only one is the create.
00:18:10.490 - 00:18:15.768, Speaker E: Transaction, which feels like it's a smaller surface area that would just be a.
00:18:15.774 - 00:18:38.320, Speaker C: Transaction we would ban. So if we did change the chain of the future to say you can't do that, it would only affect transactions, it would not affect deployed code, would it? Or no, it might affect deployed code. No, because we have a contract that's going to do a create. I think we should include contracts doing create if it's reasonable.
00:18:40.100 - 00:18:50.436, Speaker E: No, that opens up the proxy case, then you can never get rid of it, right? Well, I mean get rid of.
00:18:50.458 - 00:19:06.840, Speaker C: So we have a legacy contract and it does a legacy create ban it from deploying uses create opcode, banning that sequence from creating EOF code. So EOF can only be created from contract create transaction.
00:19:11.680 - 00:19:25.120, Speaker H: Yeah, I mean, to be precise, you will have legacy EVM code as a init code in a create transaction and the result of that will be EOF contract.
00:19:25.620 - 00:19:26.080, Speaker C: Right.
00:19:26.150 - 00:20:13.520, Speaker H: So only the init code, the legacy will be used as init code so we don't have to design it for UF. We also thought that maybe it's only temporary solution until we have the proper creation for UF. But I don't know, I think it's debatable if we want to later remove also this workaround or not. I don't see it super harmful actually, because this init code will never end up. It's kind of like ephemeral in this way. It only handles the creation transaction and then it disappears.
00:20:18.580 - 00:20:42.280, Speaker C: Right. Maybe I'll write my notes in there, but I want to make sure that if we can get away with it, that there's no on chain contract. That depends on legacy code creating EOF code that way it's easier to say, well, we just don't accept these transactions anymore and get the full EOF isolated world for creation setup that we want so we can fully ban code introspection into EOF.
00:20:46.660 - 00:20:54.210, Speaker H: Yeah, exactly. We can decide to kind of also remove this thing as well.
00:20:54.820 - 00:21:02.660, Speaker C: Yeah, because if we're wrong we can always add it later, but pulling it out of a deployed contract is basically impossible.
00:21:14.000 - 00:21:49.110, Speaker D: Yeah, I was supposed to write this down for the call, but I didn't manage to. I would like to add however, that as we progress with the 2.0 there is a slight chance that maybe the 2.0 design will end up being simple enough that we could just go with it directly and we don't need the intermediate step. Or we can backport some of those or split up the 2.0 partially. But until that is figured out I think this is the option we are leaning towards.
00:21:49.110 - 00:22:02.712, Speaker D: The other major option we're looking at is that it's a create transaction with EOF in it code, but then you need to modify some of the semantics.
00:22:02.776 - 00:22:06.376, Speaker E: And it's just too hairy.
00:22:06.568 - 00:22:15.170, Speaker D: It doesn't seem to work the risk and overhead having those special semantics and then switching to 2.0.
00:22:15.620 - 00:22:19.068, Speaker E: Right. So in short, I think what we're.
00:22:19.084 - 00:22:23.040, Speaker D: Leaning towards is either we go with this option or we go 2.0 directly.
00:22:33.630 - 00:22:44.890, Speaker G: By 2.0 directly you mean that we don't do one one, we just do full uf I V one, V one one and v two combined.
00:22:48.350 - 00:22:49.100, Speaker D: Yeah.
00:22:49.970 - 00:22:50.720, Speaker G: Okay.
00:22:51.570 - 00:22:59.250, Speaker D: The 2.0 could be also staged. The design space is still open and.
00:22:59.320 - 00:23:02.418, Speaker E: I think we could actually go without.
00:23:02.504 - 00:23:04.690, Speaker D: A create transaction and only have this.
00:23:04.840 - 00:23:07.410, Speaker E: Deployer contract and all that.
00:23:07.480 - 00:23:12.390, Speaker D: And these could be staged that only some of them is introduced in Cancun.
00:23:18.810 - 00:23:20.214, Speaker E: No, go ahead.
00:23:20.412 - 00:24:00.482, Speaker G: I was going to say that from our point of view we would prefer to do them all at once, not separated like this since we found it pretty annoying and hairy as we said before, to introduce that special context for certain opcodes to behave like other opcodes as it is mentioned in the document and we didn't like it to be honest. And it felt like extra overhead and extra mental stuff to keep in mind while implementing this stuff and yeah, that's our stance on it.
00:24:00.536 - 00:24:03.880, Speaker E: We would prefer to do it all at once.
00:24:08.650 - 00:24:12.774, Speaker D: Yeah exactly. The pieces you referred to is the.
00:24:12.812 - 00:24:16.394, Speaker E: One we ended up really disliking and.
00:24:16.432 - 00:24:20.410, Speaker D: Having legacy in it code is in a create transaction.
00:24:21.630 - 00:24:22.874, Speaker E: It seems to be in the only.
00:24:22.912 - 00:24:25.674, Speaker D: Viable option unless we go to 2.0.
00:24:25.712 - 00:24:26.490, Speaker A: Directly.
00:24:30.750 - 00:24:37.900, Speaker I: What good reasons do we have not to just go to 2.0? Just do the whole thing at once.
00:24:40.770 - 00:24:42.846, Speaker E: It is just the sheer number of.
00:24:42.868 - 00:24:49.742, Speaker D: Changes and we don't know the size yet.
00:24:49.796 - 00:24:54.050, Speaker E: Right, because 2.0 isn't fully designed.
00:24:58.650 - 00:25:03.734, Speaker D: To that end. Ipsilon is having an off site at.
00:25:03.772 - 00:25:06.726, Speaker E: Eat Porto next week and we hope.
00:25:06.748 - 00:25:13.818, Speaker D: To get more clarity on the 2.0 discussion. So I think it will be the next implementer call will be like a.
00:25:13.824 - 00:25:21.600, Speaker E: Good time to see the complexity of 2.0 and whether we could just go directly to 2.0.
00:25:22.210 - 00:25:24.478, Speaker D: So yeah, I think that the next.
00:25:24.644 - 00:25:28.094, Speaker E: Implementer call should be a good time.
00:25:28.132 - 00:25:30.880, Speaker D: To decide the direction we're going.
00:25:37.000 - 00:25:55.530, Speaker H: Yeah, I'm not sure I'm not wrong about that, but 2.0 is mostly the create three instruction and similar transaction, so it's mostly like how to create EOF contracts. That's the only addition I'm aware of.
00:25:57.580 - 00:26:01.580, Speaker C: Were we also looking into reworking call and getting rid of some of the gas rules?
00:26:02.400 - 00:26:17.040, Speaker F: You will have this extra version forever in EVM when we know that we want to change it in future. It's like strange a bit that we already doing two versions.
00:26:24.010 - 00:26:31.450, Speaker D: Yeah, the 2.0 was more of a soft version bump, so you wouldn't need to actually bump the version.
00:26:34.990 - 00:27:15.430, Speaker H: Yeah, I kind of agree. This is like one point of view, but on the other hand we have most of the things done for 1.1 and we can continue implementation and testing of this part while we kind of also think that 2.0 is a bit more into design phase. So yeah, just to be able to do some stuff in, that's, I think that's my interpretation why it's going this way. It also depends how much time we actually have for the first shipment.
00:27:20.590 - 00:27:21.450, Speaker A: Alex?
00:27:23.870 - 00:27:30.926, Speaker D: Yeah, I would suggest maybe we move on with other spec discussions and then we circle back to the 2.0 at.
00:27:30.948 - 00:27:32.750, Speaker E: The end of the quality of time left.
00:27:32.900 - 00:27:34.240, Speaker A: Yeah, sounds good.
00:27:36.550 - 00:27:37.474, Speaker E: But yeah, I agree.
00:27:37.512 - 00:27:43.700, Speaker D: I mean, 2.0 and done, that's an exciting option. Okay, so.
00:27:45.590 - 00:27:54.886, Speaker E: With this in 2.0 with the create instruction, one result of that.
00:27:54.908 - 00:28:04.940, Speaker D: Is that we actually don't care about the nons, the account nons, so it becomes like irrelevant. And since we don't have the old.
00:28:05.310 - 00:28:18.430, Speaker E: Create instruction, which bumps the nons, we can fully ignore the nons. And now we can probably with this context we can talk about the PR.
00:28:18.500 - 00:28:21.040, Speaker D: Regarding the nons changes.
00:28:22.450 - 00:28:29.886, Speaker E: And maybe Pavel wants to discuss this because it's his pr and I don't.
00:28:29.918 - 00:28:39.240, Speaker D: Fully get what status we are in. There have been a number of changes, whether we bumped the nons, when do we bump the nons? Maybe pavel, if you want to explain the pr.
00:28:41.850 - 00:30:11.074, Speaker H: Yeah, so the spec, how it was, was kind of unclear how it's supposed to work, the nouns is bumped when you do a creation of a contract using create distractions. And this is kind of, yeah, you have to decide what kind of failure make it to stick, the nouns bumps to stick, or what kind of failure of the contract creation happens before the nouns bump. But this is always messy because the spec is kind of chain of different checks and different modifications. But anyway, the specification of the EOF wasn't clear when it's supposed to happen. Now, if you go to the create transaction, the nonsense is always bumped because this is kind of relevant how transactions work. And we decided that init code failure during create transaction doesn't make the transaction invalid, is kind of registered on the blockchain, which means even if the init code fails, the nouns is already bumped. And decision for the create instruction was to match this behavior as well.
00:30:11.074 - 00:31:02.420, Speaker H: In a sense that we bump the nouns for the sender of the create instruction, and then we check if the init code validation is good, and if it's not, the nouns remains increased. So that's the clarification. There's kind of the other way of doing this, and there was some back and forth between different implementations, but not going into historical aspects of that. Yeah, this is more or less the clarification. And I think on our side, we are happy with that. I mean, I would be happy with whatever decision, but we need to make one. So this is what the pull request does, and this kind of mostly affects the current test we already have.
00:31:02.420 - 00:31:50.660, Speaker H: If we quickly just disable or reject the create instruction in the u of code, this issue kind of go away and we don't have to care about it. So I think this is also, well, I don't know, this is always kind of alternative option, how to solve it. But I think personally I would just make the modification and we will make sure that EVM implementation, GEF implementation, and the generated test are in sync with that and whatever. We will remove some of the tests later. I think it's not something we will be really sorry about.
00:31:57.030 - 00:32:24.230, Speaker B: Anyone have an opinion? Okay. I don't feel super strongly. I'm not sure. Yeah, go ahead.
00:32:24.380 - 00:32:52.850, Speaker C: One thing that crossed my mind with create three, how do we deal with a situation of I don't care what it is, give me a new contract address. That's what you get out of create, which is you'll just do your notes in your current one. Do we require them always to come up with a new hash, a new salt for the hash, rely on them using stuff like the timestamp operation for the hash? Or is there a way to say just give me a different hash?
00:32:59.110 - 00:33:04.802, Speaker E: You could use Prev Rundell in place of the hash, right, right.
00:33:04.856 - 00:33:36.320, Speaker C: I mean you could always use different. You could use an operation that will give you random values. I mean, is that what we want to present as the best thing to get new? Because you also lose deterministic contracts. You don't have a deterministic address. This is especially problematic for things like developer tools who want to do the same contract three times in a row and get the same three results in a row without having to provide the same three knownces in a row. I mean the same, without providing three different hashes. But maybe we just change the process to them.
00:33:36.320 - 00:34:21.420, Speaker C: Going away from nonsenses I think has some side effects on developer tools. We're going to need to socialize and discuss and make sure they're okay with, I guess is what I'm saying. I mean, I like the idea of a fully deterministic address coming out, but I think we need to handle a situation where the people creating it don't care what the salt is and they don't want to rely on. What if they want to do multiples of the same? They don't care what it is, but they want it repeatable, which is kind of a paradox, if you know what I mean. But that's what you typically see in developer tools. Do we just say you got to learn how to code smarter or do we accommodate them somehow?
00:34:32.320 - 00:34:35.040, Speaker A: Have you thought about this at all? Pavel or Alex?
00:34:36.580 - 00:34:50.230, Speaker D: I mean, just response to Daniel. I'm trying to think about examples in foundry like how frequently people use even in testing or any of. Really? I'm not sure.
00:34:51.400 - 00:34:56.404, Speaker E: I think the majority of contracts, they.
00:34:56.442 - 00:35:06.776, Speaker D: Actually don't create anything programmatically because of code size limits. A lot of the DeFi projects where.
00:35:06.798 - 00:35:08.856, Speaker E: You need to deploy a pool, all.
00:35:08.878 - 00:35:12.648, Speaker D: Of that is happening with external transactions.
00:35:12.744 - 00:35:15.656, Speaker E: Uniswap is one exception.
00:35:15.688 - 00:35:17.100, Speaker D: With the factory contract.
00:35:18.000 - 00:35:22.430, Speaker C: I think Uniswap knows what they're doing. I'm more concerned about the college student.
00:35:24.240 - 00:35:26.672, Speaker E: Well, the college students are using huff, right?
00:35:26.726 - 00:35:30.210, Speaker D: So they do crazy stuff anyway.
00:35:31.620 - 00:36:15.250, Speaker C: Well maybe not college students like boot camp people. People who are like switching from writing database applications to writing smart contracts. The people who aren't as enfranchised in smart contract and EVM. So it might be surprising for them. Maybe we just need to establish patterns and communicate this better. I don't think we need to resolve it today, but I think it's something we need to keep in mind of people who want to create contracts and don't care what the address is. Maybe we do just socialize using pre brand Dow as the hash and just deal with the fact that in test environments you might get different results and that they'll have to figure out how to reduce their entropy, which is a problem they need to figure out anyway for a good repeatable system.
00:36:16.900 - 00:36:20.640, Speaker E: So I think there's a distinction between.
00:36:20.710 - 00:36:21.948, Speaker D: Two different use cases.
00:36:22.044 - 00:36:28.500, Speaker E: One where the programmer wants to do.
00:36:28.650 - 00:36:31.908, Speaker D: Some of that creation and maybe they don't know any better.
00:36:31.994 - 00:36:44.536, Speaker E: And the second is the testing infra of frameworks. And I would imagine that foundry has so many cheat codes for everything, I.
00:36:44.558 - 00:36:55.390, Speaker D: Would be surprised if there is no cheat code for finding the last created contract address. And maybe most of the testing actually works with that in mind.
00:36:56.080 - 00:37:03.410, Speaker C: Well, I mean, it's supposed to be returned as part of the receipt, and a good tool can grab the receipt and get the address from that.
00:37:05.780 - 00:37:09.280, Speaker D: But the cheat code stuff isn't working because of receipts.
00:37:09.700 - 00:37:13.280, Speaker E: It interacts directly with the VM.
00:37:16.580 - 00:37:30.910, Speaker C: Yeah, the create opcode is supposed to return the address too, so I guess we don't need to fix it today. But I think it's just something we need to keep in mind as we finish out the spec.
00:37:32.820 - 00:37:34.752, Speaker D: Yeah, I would say the short answer.
00:37:34.806 - 00:37:38.050, Speaker E: Is that we haven't looked into this.
00:37:39.300 - 00:37:41.440, Speaker D: And any help would be appreciated.
00:37:43.540 - 00:37:46.150, Speaker E: Looking more into the question you asked.
00:37:48.200 - 00:37:58.200, Speaker C: So where is the work in progress for these? Are these kept on notes? Ethereum, which I can't comment on because I'm not ef or are they prs in GitHub?
00:38:02.540 - 00:38:05.464, Speaker D: I would say the state of the art is the pr.
00:38:05.582 - 00:38:07.370, Speaker E: Let me just push the link.
00:38:37.910 - 00:38:40.420, Speaker B: Anything more on create three?
00:38:41.030 - 00:38:45.810, Speaker C: So we're going the implementation first route rather than the specification first route.
00:38:49.430 - 00:38:52.058, Speaker D: Well, we do have the specification from Adelbyson.
00:38:52.094 - 00:38:55.560, Speaker E: There's no significant change to that.
00:38:58.490 - 00:39:02.294, Speaker D: The reason we're implementing it to you to find any edge cases, and one.
00:39:02.332 - 00:39:06.282, Speaker E: Edge case we found was handling the.
00:39:06.336 - 00:39:13.420, Speaker D: Data size limits because you can push auxiliary data, which is appended. Um.
00:39:16.990 - 00:39:22.510, Speaker C: So am I going to have to dig through my telegram to find this link? Or is there someplace for keeping the note centralized?
00:39:26.150 - 00:39:32.370, Speaker D: Yeah, I think like 99% of the links are put into the EUF one checklist.
00:39:33.670 - 00:39:35.666, Speaker C: Okay, I'll work off that one.
00:39:35.848 - 00:39:43.526, Speaker D: That's like the master like link index, but it's a monster. It's just too big at this point.
00:39:43.548 - 00:39:51.666, Speaker E: And too many links. Maybe under the specifications section in it.
00:39:51.848 - 00:39:59.080, Speaker D: We can put like UF 1.1 and 2.0 as a subheading, and that could be a good way to find these.
00:40:17.830 - 00:40:20.450, Speaker B: Should we move on to other spec updates?
00:40:23.960 - 00:40:27.030, Speaker E: Yeah, I have one last piece from my side.
00:40:31.000 - 00:40:37.392, Speaker D: Okay. Yeah, actually with the create tree bit.
00:40:37.446 - 00:40:41.536, Speaker E: It had one question, but yeah, let's.
00:40:41.568 - 00:40:46.596, Speaker D: Move on and then we can circle back. So the last piece is regarding the.
00:40:46.618 - 00:40:51.124, Speaker E: Flags on the last implementers call, we.
00:40:51.162 - 00:41:03.336, Speaker D: Had a length to discussion whether we should have flex as a flex field in the type section or not, and I think we were torn. There seemed to have been some reasons that it may be useful, but a.
00:41:03.358 - 00:41:06.460, Speaker E: Lot of people argued that it isn't.
00:41:08.400 - 00:41:16.750, Speaker D: The two extra use cases beyond the non returning function which was discussed was the purity level.
00:41:18.740 - 00:41:20.496, Speaker E: Which I think is.
00:41:20.518 - 00:41:21.936, Speaker D: Still like a good idea, but I.
00:41:21.958 - 00:41:24.304, Speaker E: Don'T think we're going to have any.
00:41:24.342 - 00:41:37.124, Speaker D: Time to properly investigate it. And maybe making a decision based on this unconfirmed idea is probably bad. And so the only remaining reason was.
00:41:37.322 - 00:41:45.416, Speaker E: Whether we should mark init code with this flag or not. And there have been some reasons why.
00:41:45.438 - 00:41:56.008, Speaker D: This could be useful, but as we went down some of these creatory discussions, we realized that it wouldn't be sufficient.
00:41:56.104 - 00:42:13.644, Speaker E: To have the flag, it wouldn't be enough to fully determine, and the main reason for that is, can init code call other functions? And if it can call other functions.
00:42:13.692 - 00:42:16.192, Speaker D: Should those be marked in it code as well, or not.
00:42:16.246 - 00:42:20.404, Speaker E: And this discussion was quite long, but.
00:42:20.442 - 00:42:32.008, Speaker D: What we ended up concluding is that the init code as a flag doesn't seem to be a good enough solution. So our proposal is to not have.
00:42:32.014 - 00:42:36.724, Speaker E: The flex field, and we haven't agreed.
00:42:36.772 - 00:42:59.568, Speaker D: On what is the special value for the non returning function. But we would like to have a special value to mark a non returning function, and this value would go into the number of outputs. And the two options we discussed is zero ff. So all bit set or zero x 81, which means the top bit set and the lowest bit set.
00:42:59.734 - 00:43:05.792, Speaker E: And this option would signal that the top bit means that we are talking.
00:43:05.846 - 00:43:17.910, Speaker D: About flags and we choose the first flag. Yeah, that's our proposal. Choose either zero ff or zero x 81 and we won't have a special flex field.
00:43:33.030 - 00:43:34.366, Speaker A: Any objections?
00:43:34.478 - 00:43:36.180, Speaker B: Is that okay with everyone?
00:43:45.060 - 00:43:48.220, Speaker E: So that was written down, or was.
00:43:48.230 - 00:43:50.260, Speaker C: That a new approach to the flagging?
00:43:53.160 - 00:43:56.872, Speaker E: No, these were one of the options.
00:43:56.926 - 00:43:59.050, Speaker D: We discussed on the last call as well.
00:44:04.210 - 00:44:05.950, Speaker C: I'm okay with bid packing.
00:44:12.300 - 00:44:13.144, Speaker A: Sorry, go ahead.
00:44:13.182 - 00:44:13.880, Speaker C: Alex.
00:44:15.840 - 00:44:22.750, Speaker E: Yeah, this was the document we discussed last time. And out of this.
00:44:24.640 - 00:44:26.812, Speaker D: Yeah, it's the use special value zero.
00:44:26.866 - 00:44:32.210, Speaker E: Ff, or we use reserve bits as flags so that's the zero x 81?
00:44:35.620 - 00:44:35.984, Speaker A: Yeah.
00:44:36.022 - 00:44:52.856, Speaker D: I think out of the ipsylon team it was only me who was leaning towards having like a dedicated flex field with bit packing. Everybody else was leaning towards not having, you know that means from ipsilon we say we don't want to have the.
00:44:52.878 - 00:44:53.690, Speaker A: Flex field.
00:44:55.740 - 00:44:56.712, Speaker E: On this call.
00:44:56.766 - 00:44:57.992, Speaker D: I think we should make a final.
00:44:58.046 - 00:45:04.890, Speaker E: Decision on this call. Is anybody strongly in favor of having the flex field?
00:45:21.110 - 00:45:37.200, Speaker B: Doesn't seem like anyone feels super strongly about it. So should we just go with the non flags field bit packing just the zero xff?
00:45:50.990 - 00:46:01.514, Speaker D: Yeah, I mean, the question is zero fff or 81, which is the value we are going for? I'm not sure, Pavel, because Pavel or Andre, you guys had a strong opinion.
00:46:01.562 - 00:46:04.160, Speaker E: So maybe you want to watch it now.
00:46:08.270 - 00:46:47.430, Speaker H: Yeah, I don't have really very strong, my very slight preference is 81 because it's just easier to add some additional special flags. The only difference is either need special value or maybe there will be case to have a set of properties. So that's what it's better. But it's also harder to explain why this value has been chosen. So I will be accepting any decision. But if you want my preference, that's a bit into this direction.
00:46:54.670 - 00:46:55.980, Speaker A: Yeah, that's fair.
00:46:59.550 - 00:47:06.640, Speaker B: I do like zero x 81 for the forward compatibility, the ability to change it, add more things.
00:47:08.290 - 00:47:10.190, Speaker I: Don't you still have that ability?
00:47:10.530 - 00:47:11.934, Speaker E: The top bit set.
00:47:12.052 - 00:47:19.460, Speaker I: So in the future you can always say if the top bit set, then the rest of the bits mean something.
00:47:29.570 - 00:47:42.610, Speaker B: I don't know if that is the case for the zero xff because I think zero xff is just. This is a value because output is only one byte.
00:47:48.490 - 00:48:11.440, Speaker C: What zero x 81 implies to me is that we might use all the space from negative one to negative 127 if you're looking at an assigned int approach to it, whereas Oxff means we're just working from 255 down and taking up spaces as we go. So I think 81 would be a bit clearer in that we intend to have more special values in the future.
00:48:17.670 - 00:49:24.470, Speaker B: It's also not necessarily just about us like I could imagine if there is the ability to have more special values that maybe other implementers of the EVM try to add more functionality. So if we give them those tools, I generally see that as a win. Anyone strongly against going with zero x 81? Okay, I think that we should probably just go ahead with that format then. Is that okay with you, Alex?
00:49:28.950 - 00:49:31.074, Speaker D: Yeah, I mean, I'm the only one.
00:49:31.112 - 00:49:37.954, Speaker E: Who probably prefers having the special flag field, but I'm not as strong on.
00:49:37.992 - 00:49:43.560, Speaker D: That to champion it. So yeah, I'm fine with anyone.
00:49:47.750 - 00:49:54.722, Speaker A: All right, let's do that. I guess that's probably the end of.
00:49:54.776 - 00:50:03.080, Speaker B: The spec updates that you had. There's a couple of things we talked about circling back to. Do we want to take a moment to do that? We got six minutes.
00:50:05.630 - 00:50:07.420, Speaker D: Yeah, there's no more spec.
00:50:18.330 - 00:50:19.814, Speaker A: I know you said you wanted to.
00:50:19.852 - 00:50:28.060, Speaker B: Circle back and talk about Eos two. There was one other thing that we mentioned. I'm forgetting it now. Do you remember?
00:50:31.740 - 00:50:35.050, Speaker A: Just give me 1 second. Sure.
00:50:54.400 - 00:50:56.800, Speaker E: Sorry, it was becoming too noisy.
00:50:58.820 - 00:51:11.190, Speaker D: Yeah, I think what we were arguing whether we should go directly to 2.0 or not. And the 2.0, what it involves is.
00:51:11.560 - 00:51:14.100, Speaker E: The create upcodes.
00:51:18.840 - 00:51:19.556, Speaker D: Some kind of a.
00:51:19.578 - 00:51:42.974, Speaker E: Return opcode and a create transaction, or some kind of a create pre compile, so to say. And I'm personally leaning towards more of having the create precompile option because that.
00:51:43.012 - 00:51:49.266, Speaker D: Means we don't actually need a new transaction type, and that likely reduces the.
00:51:49.288 - 00:51:52.846, Speaker E: Surface area, which then increases the likelihood.
00:51:52.878 - 00:51:54.146, Speaker D: That we can roll this out at.
00:51:54.168 - 00:51:55.380, Speaker E: The very same time.
00:51:57.350 - 00:52:02.226, Speaker D: The risk with having new transaction types I see is that we're going beyond.
00:52:02.258 - 00:52:11.766, Speaker E: Just EVM changes into many more layers, which seems to be risky in terms.
00:52:11.788 - 00:52:12.870, Speaker D: Of complexity.
00:52:14.670 - 00:52:17.866, Speaker E: But maybe the example of.
00:52:17.888 - 00:52:25.034, Speaker D: 4844 with all its changes is like a counterexample that you can change every.
00:52:25.072 - 00:52:29.630, Speaker E: Single layer in the same protocol upgrade.
00:52:31.810 - 00:52:32.960, Speaker A: It is possible.
00:52:35.810 - 00:53:02.150, Speaker B: But I think it's a fair point of view, and I'm not really sure how things will shake out, given there's a lot of discussion about this ssdification of El data structures. One of those things is trying to figure out what the transaction format looks like going forward. And there's a couple of different camps.
00:53:02.730 - 00:53:03.480, Speaker A: But.
00:53:05.390 - 00:53:11.530, Speaker B: Yeah, trying to change those things all at once while adding new transaction types will be pretty challenging.
00:53:12.670 - 00:53:16.398, Speaker A: But it might also be useful, at.
00:53:16.404 - 00:53:32.450, Speaker B: Least as something that's part of the discussion. Trying to think if EOF did have a new transaction format, does that transaction format fit nicely within the world of the SSE transactions that's being proposed?
00:53:38.790 - 00:53:40.114, Speaker A: So I guess that is to say.
00:53:40.152 - 00:54:38.810, Speaker B: That this pre compile is likely the least resistance way of going forward. But thinking in terms of UF transactions or create transactions for the UF world is at least useful, because I'm sure more things will come up in the future where we want to add additional transaction types, and if the new transaction format doesn't support it very well, that is kind of a failing of that design. Any other thoughts? Anyone feel strongly that we should be trying to go down the transaction path versus the pre compile path. Or any other thoughts on eof two?
00:54:39.420 - 00:54:48.350, Speaker I: Who among us is deeply enough involved in the SSE discussions to liaison on that?
00:54:49.680 - 00:54:50.910, Speaker B: Probably me.
00:54:51.280 - 00:54:52.030, Speaker A: Okay.
00:54:54.320 - 00:54:57.472, Speaker C: I don't know if we're working.
00:54:57.526 - 00:55:02.210, Speaker I: On the new transaction types, then yes, let's get it done.
00:55:05.620 - 00:55:08.896, Speaker E: So for me, if we're going to.
00:55:08.918 - 00:55:28.280, Speaker C: Do by what's currently called pre compiles, it opens up a can of worms, because there's pre compiles that we could always used to do through EVM code. But now we got something we can't do through EVM code and we're punching system barriers. I mean, I'm fine with that, but it's new ground that we should make sure we do correctly.
00:55:30.780 - 00:55:31.720, Speaker A: Alex.
00:55:35.020 - 00:55:37.976, Speaker E: The pre compile I may have.
00:55:37.998 - 00:56:01.504, Speaker D: Been a tab bit misleading. Saving the pre compile option requires some changes to the transaction format, but not as severe as introducing like a special create transaction. I mean, all of this is written down in this UF two document, but I do understand the document is long and confusing.
00:56:01.552 - 00:56:04.900, Speaker E: So likely it may not be clear.
00:56:04.970 - 00:56:07.716, Speaker D: Enough what is being meant, but some.
00:56:07.738 - 00:56:10.820, Speaker E: Of that is under this heading.
00:56:12.380 - 00:56:20.420, Speaker D: In short, what this means that we would have another kind of create instruction.
00:56:20.500 - 00:56:27.512, Speaker E: Like create four or whatever, which gets.
00:56:27.566 - 00:56:34.456, Speaker D: The init code from a transaction context. And the change we would need to.
00:56:34.478 - 00:56:38.336, Speaker E: Do to the transaction format is the.
00:56:38.358 - 00:56:57.910, Speaker D: Way we have the blob data in the 4844 transactions. We could have another list of blobs, and these are in it codes. In it code blobs. And this new create instruction would take an index and index into.
00:56:59.880 - 00:57:00.436, Speaker A: Which of.
00:57:00.458 - 00:57:44.976, Speaker D: These init code blobs is being used from the current transaction context. So that would be the size of the changes. And this is against the option where we introduce like a special create transaction type. And the main reason I'm leaning towards is just the complexity of having a new transaction type, but also more for compatibility reasons, because it seems that now transaction types are proliferating. There's just a new transaction type every single year, and this doesn't seem to be a sustainable path. If we would end up with proposing.
00:57:45.008 - 00:57:48.116, Speaker E: This option, I would actually go strong.
00:57:48.218 - 00:57:55.832, Speaker D: In the SSD discussions to state that this new like 4844 transaction type is.
00:57:55.886 - 00:57:59.668, Speaker E: Only for in contract interaction.
00:57:59.764 - 00:58:01.972, Speaker D: It cannot be used for any kind of creation.
00:58:02.116 - 00:58:09.916, Speaker E: And it will have these like init code blobs as well. And in that paradigm we only have.
00:58:09.938 - 00:58:25.200, Speaker D: The legacy transaction types, which are as complex as they are today. But this new unified transaction type will only be used for interactions and it can have a number of different hidden payloads used for different meanings.
00:58:35.150 - 00:58:37.770, Speaker B: We're a couple of minutes over time now.
00:58:37.920 - 00:58:39.498, Speaker A: We should probably wrap this up.
00:58:39.584 - 00:58:41.370, Speaker B: Any last comments?
00:58:50.040 - 00:58:58.520, Speaker I: Just the one I made in chat. That anything we don't get out in Cancun, it could be years before it gets to the main chain.
00:59:04.820 - 00:59:05.570, Speaker A: Yeah.
00:59:08.680 - 00:59:16.068, Speaker E: Concluding comment, I think on the next implementer call we should dedicate it to.
00:59:16.074 - 00:59:23.690, Speaker D: The EOF 2.0 discussions and I think we will work hard from ipsilant to actually post a document before that.
00:59:26.140 - 00:59:30.136, Speaker E: But let me know if you have.
00:59:30.238 - 00:59:33.204, Speaker D: Any other strong opinion and we shouldn't.
00:59:33.252 - 00:59:38.120, Speaker E: Pursue this transaction direction I was explaining.
00:59:39.580 - 00:59:41.770, Speaker B: Okay, yeah, that sounds good.
00:59:43.380 - 00:59:44.608, Speaker A: Thanks a lot guys.
00:59:44.694 - 00:59:53.730, Speaker B: We'll have the implementers call number ten in two weeks. I'll post the agenda for it. Hope you guys have a good rest of your week.
00:59:57.310 - 00:59:58.058, Speaker A: Thank you.
00:59:58.144 - 01:00:00.502, Speaker E: Bye bye. Bye bye.
01:00:00.646 - 01:00:01.190, Speaker A: Thanks, bye.
