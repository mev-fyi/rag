00:00:00.640 - 00:00:50.095, Speaker A: Good morning. This is our good afternoon or good middle of the night, wherever you're at. This is UFM Planner call number 60 on 16th October. Posted the agenda in the chat and here's the agenda. We'll go over testing updates, client updates, compiler updates, which are actually spec updates for Osaka DevNet one that we're going to discuss and then some other items and then, yeah, we will. If anybody has any other agenda items they wish to add, please add them to the chat and we will get to them at the end. So first, because testing is probably the most important phase we're in, we're going to start with testing to make sure that we get enough time to cover it.
00:00:50.095 - 00:00:58.435, Speaker A: I don't see Mario, I only see Danceratops from the testing team. Is there anything from the testing team we need to be aware of?
00:01:01.015 - 00:01:23.621, Speaker B: Hi Dano. Hi everyone. Yeah, Mario's out of office this week. He'll be back next week. I don't think there's, I don't think there's much to be shared on our side. We've been pretty busy with petrol devnet 4. I mean I saw that you've got a PR open that's been approved.
00:01:23.621 - 00:01:26.665, Speaker B: Dano. I can merge that right now if you like.
00:01:27.125 - 00:01:27.985, Speaker C: Okay.
00:01:30.005 - 00:01:50.025, Speaker B: The stack validation in call F and then we saw the introduce. Introduce er for app tool pr, which I think is pretty, pretty much good to be merged. Just gave a little bit of feedback on that today. But apart from that, there's not really a lot for us to share this week.
00:01:51.965 - 00:02:27.235, Speaker A: Okay. Yeah, it's pretty busy going on with getting Devnet for you, trying to get that launched by the end of the week. So that's pre time occupying a couple of things that also went out there. There's new fixtures covering Osaka activation. I think that's the next top thing clients need to start activating on Osaka. We're not going to do like any EOF 7,692 flags. We're just going to fully commit to Osaka because what we have today we could ship.
00:02:27.235 - 00:03:18.125, Speaker A: Even though we're going to be refining it over the next few devnets, it's in the state where if the call to ship went out, we would ship what we have because it's, it's the improvement we need and we're just fine tuning things that are nice to have, not must haves at this point. That's, that's my perspective on it. So we're going to just start shipping in Osaka. DEVNET0 the goal that I heard on the testing call is they wanted to do that about two weeks, so about a week after DevNet 4 stabilizes. So we also need to rebase our existing EOF code onto the Osaka target, which shouldn't be too much, but I've been surprised before. See, I saw fixed socket fixtures aren't published. What else did I have on here?
00:03:18.705 - 00:03:19.525, Speaker C: Yeah.
00:03:22.145 - 00:03:34.485, Speaker A: Yeah. So a socket Devnet zero is going to be where we would have been at Prog 4 if we didn't decide to split Prog. Any other testing from anyone on the call?
00:03:41.745 - 00:03:42.565, Speaker C: Okay.
00:03:45.905 - 00:04:07.735, Speaker D: I was resolving merge conflict with EOF and our Master and it highlighted one I had a conflict with 7702 and I highlighted an area that we might need to put a bit more testing into, which is delegations and erf.
00:04:10.635 - 00:04:48.675, Speaker A: So that was something that Mario added just before the split happened. And I think the new fixtures that's why he also wanted to include the Prog branch is because I think there's some tests there that test EOF and 7702 with regard to their. To the delegation that goes on there. So I think there's test coverage. It's very fresh. So I'm sure we're going to need more test coverage there as we go over it. But that's the fixtures included both Prog and Osaka because I saw he put that in the Get Actions task that runs it.
00:04:48.675 - 00:05:18.625, Speaker A: So yeah, that's a good. That's a good discovery. Is that there's definitely some interaction there. Clients and compilers. Charles has already said he has nothing from Viper and I don't see anyone from Solidity on. So we'll just go over clients. Ben, do you have any other news from nethermind?
00:05:20.445 - 00:05:32.105, Speaker D: We're all up to date as of what is it 110 or 11 1? I haven't done the O move yet.
00:05:32.805 - 00:05:33.645, Speaker C: Okay.
00:05:33.805 - 00:05:37.545, Speaker A: And have you updated the. The radius matrix?
00:05:38.325 - 00:05:39.437, Speaker D: No, I haven't.
00:05:39.621 - 00:05:47.835, Speaker A: Okay, let's see. Dragon. Anything from Revan?
00:05:51.335 - 00:05:57.795, Speaker E: Not too much. I need to propagate OSAK hard fork basically make release.
00:06:02.415 - 00:06:04.435, Speaker A: Yeah, Small.
00:06:06.415 - 00:06:07.439, Speaker E: Small change.
00:06:07.607 - 00:06:08.159, Speaker A: Yep.
00:06:08.247 - 00:06:08.995, Speaker C: Okay.
00:06:11.905 - 00:06:28.405, Speaker A: Let'S see. Geth's not geth couldn't make call EVM1.
00:06:32.385 - 00:06:36.005, Speaker F: No updates from us. We still have to move. You have to Osaka.
00:06:40.915 - 00:07:35.365, Speaker A: Ethereum, js, nobody besu. We have Osaka published in Maine and maybe I should have mentioned this in the testing. The call left changes came as part of my work trying to get the fuzzing together. So I was doing a bunch of comparisons of stack traces of execution and there was a case there's there's a couple of rules in call left and jump after you need to check the available height and break in a couple of places. Basically wasn't doing that. And the tests we have were failing because you still blew up the stack in the next call. So those two tests that were just that, as airtops mentioned, per the type section, they'll bust the stack, but per the actual execution, they will not bust the stack.
00:07:35.365 - 00:08:53.425, Speaker A: And that's one of the things that we found checking traces. So that's why checking in all levels is important. One of the important things we get from differential fuzzing Are there any clients on the call that I missed? Okay, so that's the case. We'll move on to spec updates. Whoops, what did I do? So as far as we should have this discussion first, as far as spec updates go, since we're shipping numbered devnets now, we really need to target which specs are going to go in which devnet. And at the state we're at, I mean, realistically, Osaka is not going to ship until at least the third quarter, and that would be ambitious. To ship in the third quarter, things would have to go really well with Prague as well as Osaka.
00:08:53.425 - 00:09:56.715, Speaker A: So there's going to be multiple devnets, but I would like each devnet to be in a situation where if we needed to ship it, we could. So if there's, there's critical things that need to be fixed, we should get them in as soon as possible. And as far as changing the quality of life changes, I think those are fair game up until a certain point. And another thing that's going to start happening is people are going to want to have tools developed and stabilized. So at some point we're probably going to need to close the door on quality of life changes too, just to make sure that tooling will start showing up and we'll be correct and accurate. So knowing that, I would say that the door for quality life is open right now. So the spec changes we have discussing are a couple of ones that have been around for a while and a few things that we need to possibly fix and possibly not change.
00:09:56.715 - 00:10:26.175, Speaker A: The first one is EIP721 compatibility with the XT code. The next is the XT call return codes. There's a new thread starting on EOF Create hashing that we're still trying to get the final details and wrap our heads around. Yeah, and those are for the specs. There's some non spec things we'll get to after we go through specs. So first on ERC721 compatibility. Does anyone want to give their current opinion on what the current status is?
00:10:32.725 - 00:10:34.397, Speaker G: So it seems we.
00:10:34.461 - 00:10:35.145, Speaker A: Go ahead.
00:10:35.725 - 00:11:23.575, Speaker G: Yeah. Thank you. So we had discussed about has code and just enabling EXT code or a few subsets of it. My current thinking is that we should go the route of enabling the EXT code opcodes, possibly in some limited form, but maybe not. And basically my rationale is just to avoid adding complexity. And I brought this up recently in Discord, where if we're thinking that eventually legacy contracts will have to migrate, eventually these opcodes will come, so we might as well just add them now.
00:11:39.015 - 00:11:39.955, Speaker C: Okay.
00:11:40.335 - 00:11:41.075, Speaker A: Just.
00:11:54.745 - 00:11:55.605, Speaker C: Okay.
00:11:56.145 - 00:12:13.405, Speaker A: One thing that Marius did add is he's. He is opposed to it. He doesn't want to. Which is interesting for, for Marius to have this position on it. He's never been a strong advocate of eof, but he does believe that it would compromise the spec to add has code.
00:12:16.475 - 00:12:19.175, Speaker G: Do you know what he means by compromise this spec?
00:12:20.515 - 00:13:21.849, Speaker A: If we're going to commit to my interpretation of what he's talking about, you know, let him clear clarify his words if I'm not representing it. Well, but the code introspection should be as absolute as possible. So allowing we never have allowed any other codes to directly divine the types of the code. It's all been secondhand through things like code size. And if we're taking away code size, we should not add new ways to detect whether it's eoa. And I think the strongest part of his argument is he says that the 7702 delegation is going to significantly change the landscape of what accounts are and that EOA accounts are not going to become the norm, that delegated accounts and smart wallets are going to become the norm. And in some of the AA roadmaps that I've seen, there is a step where all EOA accounts will be migrated to an equivalent Smart Contract account that would behave exactly like the existing EOA accounts.
00:13:21.849 - 00:13:38.185, Speaker A: They would just be done through Smart Contract. And that would be one of the final steps of some of the E. Of the account abstraction roadmaps that I've seen published. So one of the things on the horizon is they do actually want to get rid of the notion of an EOA and have everything run through a Smart Contract account.
00:13:44.845 - 00:14:12.355, Speaker G: Well, yeah, unfortunately he's not here to discuss, but I don't see how that's. I mean, the whole point was just EIP, ERC721 just requires this. Right. And I, and I would love to see the point about Legacy migration being a part of the conversation. Do you guys think that's not relevant?
00:14:21.855 - 00:14:27.775, Speaker A: Anyone from client team want to raise a response to that? Or anyone from Epsilon?
00:14:34.435 - 00:15:24.945, Speaker D: I mean it's a indeterminate future thing that we shouldn't rely on or expect, but related to not having them. It's also a problem with not being able to delegate call to legacy accounts legacy code because you can't determine if it's legacy paid unless. Unless you do introspection through trying to delegate culture first, seeing whether it fails.
00:15:28.965 - 00:15:41.385, Speaker H: Yeah, and also I'm not sure that you can get ext code opcodes via legacy contracts because don't they return some magic if they're called on EOF contracts?
00:15:42.965 - 00:16:15.685, Speaker A: So if they target EOF contracts, it returns as if it is the bytes EF00. But for the purpose of 721, that's the answer it wants. It wants to know that it's not an EOA. So that actually works for 721. And for the case of proxy contracts, that's also what actually wants to know is it either is. I mean if it's EF00, it can't be faked. So it gets the answer if it gets that hash code, the yes, indeed, this is the eoa.
00:16:15.685 - 00:16:24.725, Speaker A: It's not. It's an EOF account and we can delegate to it. So the legacy opcodes jumping out to them will still allow to answer these two questions.
00:16:27.105 - 00:16:40.445, Speaker H: I mean, I think the sanest thing is actually to mirror the legacy behavior. So if you actually. Yeah, I'm not sure.
00:16:42.675 - 00:17:01.375, Speaker G: Yeah, yeah. To be clear, when we talk about enabling the ex decode opcodes, it would be with that behavior. So you wouldn't be able to actually look at the code of an EOF contract. You would get the same result that you get from a legacy one, which is opaque.
00:17:01.795 - 00:17:35.667, Speaker H: Yeah, that kind of makes sense. I think the only other alternative is for it to be solved at the application level. So for there to be a standard where like one thing that contracts can do that. Well, two things that contracts can do that EOAs can never do is revert and return data. And so if you have like a special method like iscontract for example, in this, in the standards, can you elaborate.
00:17:35.691 - 00:17:38.295, Speaker A: On that about revert and return data? I missed that.
00:17:40.835 - 00:18:20.655, Speaker H: One thing that EOAs can never do is revert and return data. So right now you like. I forget exactly how you do it in ERC721, but you ask for like the unreceived hook or Something. So if another thing was added to the spec, like is contract that all ERC721s like going forward have to implement. And like all ERCs, I mean, it's similar to the ERC165 solution that was discussed on previous calls.
00:18:21.355 - 00:18:57.315, Speaker A: Right. So what I just read the spec this morning again to make sure I had it straight. The safe send, it'll send the contract and then it'll try and do the call or it'll do the size check. If it's a size check and determines EOA and safe send, it's done sending because it knows it's an eoa. If it doesn't get the size check and says as contract it tries to do the callback, unless the callback returns the value, I accept it, it reverts. So you have to receive the nft. So you can't accidentally store the NFT in a contract that doesn't isn't aware that it's being sent an nft.
00:18:57.315 - 00:20:03.035, Speaker A: So that's the tricky part is that an EOA will never be able to return that positive confirmation. So the contract is either positively confirmed to be away or positively confirmed that it's received it. And the problem with everything except for the check with the EXT code size is you can make any contract simply through the calling interface impersonating the away and there's no way to distinguish it within just a call. So I was thinking through this as I could we just do like the 165 approaches to see if it's got a registered receiver. And if it doesn't, if it's not 165 registered and we assume it's an EOA, which actually defeats the whole thing because what if it doesn't implement 165 and it doesn't implement the receiver call and it impersonates an EOA and returns nothing on all calls, the default handler just returns nothing. I mean, that is, you know, you could argue that that contract has deliberately put itself in a bad place, but that's creating space where the contract could misbehave. So, yeah.
00:20:03.035 - 00:20:11.955, Speaker A: What is Ypsilon's opinion on some of this? I think that's a opinion. We haven't heard much from them yet.
00:20:17.665 - 00:20:38.485, Speaker F: I personally mostly agree with Mario's take, I think and that it should be solved probably on the standards level, not in the evm. So for me, ideally we don't introduce neither of these and has code is a bit better than XCODE size for me if we really need it.
00:20:45.195 - 00:21:49.115, Speaker G: I really, I really Hate to be on the other side of this, but I just, I just don't see the rationale for this. Like, I was looking back at the Vitalik's post where I think he introduced the idea of removing code introspection. And there's a very clear motivation there, which is we want to be able to, in future versions, do translations of ABM code to deprecate opcodes or change behavior without breaking backwards compatibility. So you need to remove, say, EXT code copy so that you don't inadvertently, like indirectly introduce breaking codes, breaking changes. That's a very clear motivation. And by making EOF contracts opaque so that you can never do EXT code copy, it seems to be already addressed now. The current status of VOF where you're not even able to invoke EXT code copy, I don't get where that comes from.
00:21:49.115 - 00:21:57.795, Speaker G: And it really causes issues at the application level and I don't see a good rationale or motivation.
00:22:00.415 - 00:22:55.165, Speaker A: So when these decisions were initially made, the whole perspective on what banning code introspection meant was that none of the code, anything that hits memory will never become code and nothing that's code will ever enter into memory. So it's the bidirectional thing. And that's kind of needed for zk, at least for the memory to code, because compiling a new thing on the fly in ZK is kind of difficult and it backs them into requiring arithmetizing traces, which is not the most efficient mechanism for really small contracts. Really small contracts could be directly compiled into zk and doing that on the fly is really expensive. To be consistent, we won't let memory go into code. We're like go into memory. They're two completely separate worlds that never exist and never enter into each other's considerations.
00:22:55.165 - 00:23:59.865, Speaker A: That's where the premise of banning EXE code. And then similarly, the reason why we banned EXT code from introspecting existing EOF code is the situation where you call into legacy, have legacy do the EXE code copy from the EOF and then come back and return it. So that's why the decision there was made to have all EOF code look like the bytes ef00 to legacy so that the EOF code then would not have to be preserved if you cross over into legacy so that in, in situations like that, the legacy code is. Yeah, the legacy code can't go into. You can't use legacy as an escape hatch to do this code introspection. Which kind of touches on a little discussion later on why we still need to ban exe delegate call because if you delegate call into legacy code, anything that's banned in EOF is then allowed in legacy code can then be done in eof. The first and strongest argument for that was self destruct because we didn't want to have self destruct in eof.
00:23:59.865 - 00:24:31.525, Speaker A: But we still have self destruct. We just have it within a transaction. So there's no self destruct for pre existing contracts, but contracts made within a transaction can still be done. We don't want to expose that to eof. So that's why the ban needs to still be in place because self destruct was not completely removed. There are still things that can be done in Legacy that we're also very committed to keeping out of eof. I think the self destruct stand is a bit stronger, very strong compared to the code introspection.
00:24:31.525 - 00:24:45.685, Speaker A: But yeah, it's the code introspectors. There's a lot of. From what I'm hearing today, we're not going to come to a decision today and I'm going to go ahead and time box it because we've been on it for about 10, 15 minutes without any, any new positions on it.
00:24:47.265 - 00:25:01.449, Speaker D: But I don't, I don't have any objections to banning delegate just on the code. Introspection is the equivalent of just checking an account balance.
00:25:01.497 - 00:25:02.245, Speaker A: Is not.
00:25:04.225 - 00:25:16.881, Speaker D: It'S not, it's not a particularly detailed introspection. You're just checking like code hash or if you get what I mean, right.
00:25:16.913 - 00:25:19.085, Speaker A: It could be an attribute stored with account information.
00:25:19.865 - 00:26:02.345, Speaker D: Well, I mean you, you're, you're either because we're already checking the code to see whether it's EOS when we're doing all sorts of things, you know, checking, checking the first bytes and for code hash. I mean that, that is just as, that's already on the account. That's just as much work as, you know, what's the ether balance of this account? They're, they're not like, they're not like deep introspections. You still don't, you still, you're still meeting all those conditions that you, you highlighted before, is what I'm saying.
00:26:02.965 - 00:26:03.825, Speaker C: Okay.
00:26:04.125 - 00:26:13.305, Speaker D: Because it's, you know, opaque. It's not a complex thing to do. We're already doing EOF checks on, on the actual code.
00:26:15.205 - 00:26:19.665, Speaker G: And the argument would apply to code ext code copy as well. Right?
00:26:20.925 - 00:26:24.985, Speaker D: Yeah. And you just go hey, here's your two bytes or whatever it is.
00:26:25.365 - 00:26:27.677, Speaker G: Right. So does.
00:26:27.741 - 00:26:48.931, Speaker D: Oh, although, although that has the downside of people might then if it works on. If codecopy works on legacy code, then people will be deploying massive data contracts in legacy code than using code copy in the ua. So that might not be good.
00:26:49.003 - 00:26:49.895, Speaker A: I don't know.
00:26:51.115 - 00:26:52.415, Speaker D: Or it might be good.
00:27:05.685 - 00:27:08.425, Speaker G: Just a quick answer. Oh, sorry, Charles, go ahead.
00:27:09.045 - 00:27:10.065, Speaker H: No, go ahead.
00:27:10.765 - 00:27:40.435, Speaker G: I was just. I just wanted to give Dana a quick answer that the rationale about ZK circuits. I think that's. That's great. Like I want to see the choice motivated by that kind of thing. And I'm not fully clear to me how all that fits, but it seems like it. My proposal doesn't really pose any issues to ZK circuits either, but I'll have to read more about it and think about it more.
00:28:03.305 - 00:28:08.449, Speaker A: Okay, so this is probably a good time to take a sidebar. Go ahead.
00:28:08.537 - 00:28:37.485, Speaker H: I want to point out that enabling has code. It doesn't necessarily preclude from like doing the full a thing like in the future, all accounts just return has code equals true. But I haven't been following the details of the AA roadmap, to be honest.
00:28:37.915 - 00:28:38.735, Speaker C: Okay.
00:28:42.515 - 00:28:48.415, Speaker A: Let'S see if I'm getting my headings correct here. Okay, looks like it.
00:28:51.235 - 00:28:52.055, Speaker C: Okay.
00:28:54.235 - 00:29:38.397, Speaker A: So this is not a decision we're probably going to be able to make before January anyway because we've got devcon coming up, we got Picture Osaka Net zero and imagine after that we're all going to be writing. We're all going to be writing our talks. And with dev0, I think it'd be a good time to demo some of these solutions that may or may not work by keeping it out, demonstrating either that they're feasible, if there's options, we should. Whoever wants to say that we don't need it because it's feasible, that would be a great time to show the feasibility of it or to show the difficulty of it. But also it's a great opportunity to. Yeah, if there's. It's a great playground to figure out if we really have what we need and to really show where the quality of life problems are good.
00:29:38.397 - 00:30:17.671, Speaker A: If we don't implement some of these, how they're going to negatively impact us. So. Yeah, so. So DevNet1, we're going to probably not close any of the spec items until January on this. So I don't think we're going to get anything on this list resolved today. Next on the list, DXT call return codes. So this was something while I was working with the Geth team fixing some of the final bugs that was brought up in one of their code reviews.
00:30:17.671 - 00:31:36.665, Speaker A: Is that the return codes seem to be somewhat inconsistent and that it might be a reflection of how GETH reflects some of the errors within their code. And they also, it might be, you know, that we're not getting some of the intent of the return codes. So one of the things that I think they brought up that might be worth noting is right now we have three levels of return zero success One, if there's a revert or some sort of other error in the call process and then two, if there's some other halts and those halts would be like out of gas static violation, some other EVM level exception where the spec says you must, you know, then halt the frame. There's really no good way to distinguish between a call was successful and reverted and the call failed in the process of making the call. Per the 70 is it 7069 or 7260 or 7560, which was the call 7069. 7069. So the one proposal I have that I'd like people to mull over is to expand the call codes to add one more category.
00:31:36.665 - 00:32:13.599, Speaker A: 0Success1 is reserved only for a revert operation called in the frame above it. At the frame above it terminated with revert opcode and returns run 1 and no other return for that number. 2 is reserved for if there's an error in the call sequence. That's where we do things like make sure there's enough money, make sure there's enough stack, make sure there's enough gas as far as gas reservations. And all the other errors are specified in 7069 in the 12 step process or however many steps there are right now to make a call. So those are like the light failures. So those would get their own category.
00:32:13.599 - 00:32:56.685, Speaker A: So we could say that there was an error in, you know, you didn't provide enough gas, you didn't provide enough money, you know, some there's not enough stacks or something in the in the call process has failed. And then three, we reserve it for all other errors where the call succeeded, went to the next one and failed for some other reasons. Static accessing stored memory in a static call is an example of that. Infranzio asks are there use cases where this information is useful? It's a good question. And ypsilon, what was the use case that was motivating this to split out return codes other than simple utility?
00:32:58.985 - 00:33:32.145, Speaker I: I think that the main motivation was this return code one, which is like contract wants to know if the revert was used on the other Side. So I think at least, I think we should confirm that again. But that like feedback from Solidity was that they are much more interested in this like programming error encoded in some other code. Right. In some other contract. So. So they were.
00:33:32.145 - 00:34:08.975, Speaker I: Yeah, they wanted to know if there was revert or there was something else. So. So mostly these two categories. But later in the process of implementing this and refining the spec, we noticed that. I don't remember exactly, but there was some issue with this, that this revert instruction invocation was combined with some other errors. I think the slight error somehow, and there was some reason for it. I think there was some information leak that maybe we didn't want to.
00:34:08.975 - 00:34:48.118, Speaker I: I don't recall exactly, but I think that was kind of the critical point when we kind of combined two sets. Yeah. So I like what you described this as these three different categories and I think initially we had like two categories combined and now we combined it in a different way. And. Yeah, so that's more or less the background. Although I think some of these bits should be confirmed again, I would assume. But I like what you.
00:34:48.118 - 00:34:52.954, Speaker I: What you described that I think splitting that in more categories kind of solves it.
00:34:58.534 - 00:34:59.354, Speaker C: Okay.
00:35:02.534 - 00:35:05.566, Speaker A: All right. Any other comments?
00:35:05.750 - 00:35:44.705, Speaker I: Yeah, so. So I think that's. That like this error code was revealing some GAS information and going into this like full no gas introspection path. I think that was the reason why we changed some of the errors for the slide errors which don't consume all gas. So we don't reveal this information. Yeah, I think we'll need to take a look on this part as well.
00:36:13.655 - 00:36:28.155, Speaker A: Let's not forget that there's always the legacy contract called to a GAS contract to get your current GAS level, since we pass everything in. So there's still ways to defeat the gas introspection.
00:36:32.305 - 00:36:45.913, Speaker H: Yeah, and also call stack introspection, which is.
00:36:45.929 - 00:36:49.125, Speaker A: Interestingly, we don't have a opcode to say what is your call stack?
00:36:49.985 - 00:37:11.785, Speaker H: Yeah, I think that was one of the issues brought up on a previous call. If I'm. I'm like dredging through my memory. But basically you can tell if you're at the begin at the end of the call stack, not like necessarily in the middle. It's not very detailed, but you can tell you're at the end based on some of the return codes, at least as it was drafted at one point.
00:37:12.605 - 00:37:27.295, Speaker A: With the 6364 rule. Is it possible to get to the end of the call stack at current gas levels? I'm not sure that it is because I was reading Some of the analysis.
00:37:27.455 - 00:37:36.035, Speaker J: Peter, I think it was like billions of of God's order of magnitude more or less as far as I recall.
00:37:37.575 - 00:37:38.343, Speaker C: Okay.
00:37:38.479 - 00:37:44.155, Speaker J: And I so not not main net numbers as.
00:37:56.545 - 00:38:10.125, Speaker G: Dano, do you know if the like the error condition that you want to break out into a new status code, is that exactly the same as the light failures that were apparently the reason to merge them or is it something different?
00:38:11.545 - 00:38:24.485, Speaker A: So it would be the light failures that we move into the new status code separating it from reverts. So right now everything that's a user revert or everything that's an error in the process of doing a call stack failure would go into type one.
00:38:27.225 - 00:38:36.845, Speaker G: What I'm seeing as the rationale in the AP is that it seems that differences whether the failure reserves gas or consumes all gas.
00:38:41.105 - 00:39:21.295, Speaker A: Yeah, that's not true in the implementation. I think there's errors that that was one. Yeah, I think there are ways where you can have that violated between 1 and 2 where all gas was consumed and all wasn't. I mean that's the other. I think that's the other option is to stick with that original rationale and change things as necessary to get back to that level.
00:39:25.355 - 00:39:26.175, Speaker C: Okay.
00:39:29.435 - 00:39:45.865, Speaker A: All right. I think we spent enough time on this. That gives us the info we need E with create hashing. Is that something we want to talk about or we want to continue talking about it on discord.
00:39:55.085 - 00:39:59.505, Speaker G: Just curious if there's any strong preference currently.
00:40:01.495 - 00:40:03.155, Speaker A: For UF create hashing.
00:40:04.135 - 00:40:08.755, Speaker G: Yes, for a solution or change or status quo.
00:40:09.255 - 00:40:35.965, Speaker A: What removes unnecessary hashing is I think what's preferable and I think what prompted this is having to double hash subcontainer to get the new address. So performance wise reduce the number of hash calls. And it's also ZK hates check caching. They can't say enough bad things about it. So the more hashes we remove, the happier they'll be.
00:40:45.025 - 00:41:11.085, Speaker I: Yeah, I think we want to remove the hashing. At least try a solution that is good enough. And yeah, I think we discussed this offline and there's some issues with the current design without hashing and I have some preference preferable solution but I don't think we need to talk about it today.
00:41:11.705 - 00:41:12.525, Speaker C: Okay.
00:41:13.505 - 00:41:16.765, Speaker I: I still like trying to wrap my head around this.
00:41:18.835 - 00:41:31.375, Speaker A: I think there's a solution. I think if we specify that we use the address of the contract in eof nested creates that I think that gives us all of the safety we need but I think we need to work it through completely.
00:41:33.635 - 00:42:23.551, Speaker I: Yeah, I think we kind of have different goals. So that's kind of my impression from the discussion we had today. Like my goal is to be able to kind of prove or like predict the address on like physical code that will be used to create it. And I think it also gives you collision free somehow addresses. So yeah, but it seems me that we need to kind of instead of just sub container index we need a path because that they can be nested and I'm not sure this is. This. This complexity will be accepted.
00:42:23.551 - 00:42:33.835, Speaker I: But yeah, I think we need a bit more time. Maybe we need to prepare it for the next call or something.
00:42:37.345 - 00:42:38.205, Speaker C: Okay.
00:42:40.385 - 00:43:48.175, Speaker A: So that's it for the spec top item for others tracing and the one thing I want to pitch is PC equals 0 is start of container. So when looking through this and while working through some of the fuzzing efforts I'm trying to get started up at the very least all of the we need to have PC that is zero relative to some fixed point in the container and not to every section's beginning because it's going to be more useful. It's going to be. It's going to provide better signal within Go EVM lab if we have the PC relative, you know, consistent across some zero point in the container. And my preference would be the zero point of the zero byte of the container of the EF header. And my reason for that preference is that's going to help us out when it comes to Verkal. Because of Verkal we need to mark which code has been visited in addition to taking in the entire header.
00:43:48.175 - 00:44:20.105, Speaker A: Probably we may not need to take the entire header in. That's something we can consider. But in cases where we would need to split it by section we would have call ups and jump Fs to signify that we're switching sections. So I think we'd have that info in the trace. But just as far as you know, getting all the clients. I think all the clients except forgeth we're using PC that is container relative rather than section relative. And I've got a patch out to get to move it to container relative PC instead of section relative PC.
00:44:20.105 - 00:44:45.345, Speaker A: So that's my big ask is can we, you know, if there is support for it being relative to spot the container if we could move it to the zero part of the container so a lot of the traces would start like PC equals 19 or PC equals 23 or whatever. So the entry point would never be PC equals 0. What are people's opinions on this? Am I asking for too much? Am I Crazy. Should I move Back to code section 0, index 0.
00:44:51.575 - 00:45:02.155, Speaker I: Did we like in the previous design did we have. Did the PC was reset to zero on every new section?
00:45:03.335 - 00:45:27.105, Speaker A: Yes. So my first, my initial pitch of the tracing spec was PC equals zero for each section. And it's possible to do that in the code because you can look at your offset in your section when you do the trace instruction. I think every single client could write that trace code. But the reason we went to container relative indexing was for optimization and speed.
00:45:31.685 - 00:45:34.585, Speaker F: Do you still want to include section number?
00:45:35.685 - 00:45:47.995, Speaker A: We still want to include section number. Yeah but I think that's going to be an optional field go. EVM lab doesn't have allowance for that. I could easily write code to add it but that's something we could easily add to check.
00:45:53.615 - 00:46:51.495, Speaker I: Yeah. So like from my perspective what we currently are doing is that we kind of start from PC0. But yeah, EVM considers like all code sections are like kind of single section because if you think about it they actually adjacent. So they are and the kind of boundaries are defined outside. There's nothing really in this code that defines like we're crossing different sections and if you just start interpreter based on the previous validation that doesn't matter. So like for us it's a bit easier to just have like global PC counter. It's more naturally to start with zero but I think remembering the offset somewhere, I think it's not a big deal.
00:46:51.495 - 00:47:25.181, Speaker I: So like internally it starts with like. It uses 0 as a as as the internal representation of the current position. But I like it's not even a number, I think it's a pointer. So yeah, so I think to compute the PC I need to subtract it anyway so I can subtract it for something that it's like. Yeah, so that's fine. So I think we can go. We can do both.
00:47:25.181 - 00:47:49.145, Speaker I: And my preferably would be to have like global counter. It means either starting with 0 and not resetting to 0 on every section and to implement the section ID I think I will just do it for tracing. Just I don't know look it up in the header if that's needed. But it's likely we will skip it if it's not needed.
00:47:52.205 - 00:47:57.285, Speaker A: Okay Dragon, what is Rhett's thoughts on this.
00:48:00.265 - 00:48:05.045, Speaker E: Implementation wise either way we can make it work.
00:48:08.945 - 00:48:11.685, Speaker C: Yeah, okay.
00:48:12.105 - 00:48:31.565, Speaker E: I don't have. It sounds it first. At first it sounds very strange to be honest. But yeah, maybe, maybe that's the way to go to start PC from start of the container. But I'm not sure, to be honest.
00:48:32.105 - 00:48:32.689, Speaker C: Okay.
00:48:32.777 - 00:48:35.165, Speaker A: Ben, what's Nethermines view on this?
00:48:37.225 - 00:48:47.779, Speaker D: Fine, it makes sense. Very cool. Yeah. Any objection is do some change. That's fine.
00:48:47.827 - 00:48:49.923, Speaker C: Okay. Okay.
00:48:50.099 - 00:49:07.095, Speaker A: And it seems strange at first, but I think one of the things that I noticed is when you look at the trace and you see your first entry is PC19, you're going to break open the code and you're going to go to the 19th byte of the file and you're actually going to have it. Whereas if it's PC0, you have to parse the entire container to figure out where the first byte is.
00:49:09.675 - 00:49:52.935, Speaker J: Peter, the counter argument could be that PC starting from like 19, like you said, allows it to represent something that's not possible. So smaller than 19 or whatever. Like more. More of a principle approach. But maybe it's an argument also. I mean, how do I put it? Starting from this? 0 being the start of the code section makes it impossible to represent impossible states of the machine. Maybe like that.
00:49:52.935 - 00:49:57.935, Speaker J: I cannot, I cannot word it.
00:50:05.165 - 00:50:34.045, Speaker D: I mean, you know what I mean? Like, yeah, yeah, you could never run zero, but I mean if you. If you think of normal solidity contracts, they. They have the. A big chunk of convert this method hash into a jump. So I mean, people should be used to the start of the code not being anything you look at.
00:50:36.585 - 00:50:57.655, Speaker A: But with PC zero, the flip side is you know that you switched. Well, you don't know when you switch into a new call if. But you know you switched into a new call. Apart from the depth increasing.
00:51:00.635 - 00:51:07.775, Speaker J: Then it's more consistent with legacy in a way, I guess.
00:51:08.275 - 00:51:09.123, Speaker C: Okay.
00:51:09.299 - 00:51:19.157, Speaker J: If any Turin is concerned, they would have easier life, but I'm not. This is not a strong argument, of course.
00:51:19.291 - 00:51:23.245, Speaker A: So right now EVM1 has PC0 at section zero.
00:51:24.465 - 00:51:25.245, Speaker J: Yes.
00:51:25.545 - 00:51:29.445, Speaker A: Yeah. Can you reset the PC across section calls?
00:51:32.905 - 00:51:35.645, Speaker J: No, Pavel. Okay, I think we don't.
00:51:36.065 - 00:51:38.605, Speaker A: Okay, how about ref.
00:51:40.905 - 00:51:42.445, Speaker E: Sorry, can I repeat that?
00:51:43.185 - 00:51:51.169, Speaker A: PC zero is at section zero, byte zero. Right. Current code.
00:51:51.257 - 00:52:04.565, Speaker E: Currently we don't even have support for tracing. Yeah, I need to check that. I think it's like zero. It's zero from the code section. I think that's the case.
00:52:04.905 - 00:52:09.045, Speaker A: So code section one. PC zero is by zero in code section one.
00:52:09.425 - 00:52:10.245, Speaker E: Yeah.
00:52:10.545 - 00:52:15.525, Speaker A: Okay, how about Nethermine? Do you know what your tracing is doing?
00:52:17.435 - 00:52:20.775, Speaker D: It'd be the same, the first byte of code.
00:52:22.635 - 00:52:27.855, Speaker A: How about section 1? What's the first byte of section 1? Is that going to be a zero or is that going to be offset?
00:52:28.195 - 00:52:29.891, Speaker D: It's going to be zero as well.
00:52:30.083 - 00:52:30.895, Speaker C: Okay.
00:52:34.075 - 00:52:39.735, Speaker D: But code, not machine code. So there's like a preamble, isn't there?
00:52:53.255 - 00:52:54.075, Speaker A: Okay.
00:52:57.495 - 00:53:03.495, Speaker D: So I. I think you're saying you'd want it to start at the start of the preamble.
00:53:03.615 - 00:54:03.615, Speaker A: The start of the preamble, and it would reset across section patterns. I think the big thing that I want is that it doesn't reset across section boundaries. And whether we 0 it's code section 0, or whether we 0 at the preamble is where the open question is. But as far as fuzz testing, we really will need to have continuous numbering, not resetting number. Okay, looks like we are at time. Is there anything anybody wants to check? Anything Benny wants to bring up on this call? I think there were still a few items that we didn't discuss, but we can discuss that in two weeks. Data copy and data size is a big one.
00:54:03.615 - 00:54:18.755, Speaker A: All right. Hearing none. And given that we're up against time, I'm going to thank everyone for their time. Thank you for calling in and implementing and participating. See everyone in two weeks.
