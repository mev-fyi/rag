00:00:00.410 - 00:00:15.680, Speaker A: You. Hey, good morning everyone. Welcome to EOF implementers call. I think number 22. I missed the last call, unfortunately. Sorry for not mentioning to anyone beforehand. Totally slipped my mind.
00:00:15.680 - 00:00:29.320, Speaker A: Yeah, and I also haven't made a PM issue for this call either, but I think the agenda will be mostly the same. So let's go ahead and get started with some client updates. Does anybody have some updates they would like to share?
00:00:31.690 - 00:01:12.020, Speaker B: Besu is in the same spot they were two weeks ago, still writing the tests for our create three implementation. None of it's merged yet because the specs changed a lot before, so we're keeping it on a separate EOF branch. Megaf. I had promised to write the ext code copy text. I didn't get to that. I was distracted by number one, back to school stuff in college, and number two, another performance issue that I was working on that consumed a lot of my time. I don't know if I can deliver that in the next two weeks because I also got to write an ETh Chicago talk for where I'm talking about.
00:01:12.020 - 00:01:13.700, Speaker B: Yeah.
00:01:14.890 - 00:01:25.480, Speaker A: Oh nice. Have fun in Chicago, and thanks for that update. Any other folks want to give an update from their client team?
00:01:31.000 - 00:01:42.470, Speaker C: I think we're still no update from our side focusing on other stuff. Honestly, I don't believe we have anything new.
00:01:44.220 - 00:01:52.410, Speaker A: Sounds good. Thanks for that update. And yeah, I guess that kind of leaves evm one. You guys have anything to share?
00:01:58.850 - 00:02:50.000, Speaker D: Yeah, related to UF we've merged one fix for stack overflow check in call f, which was standing pr and we merged it. And besides this, there were some prs merged not quite related to Af. There was trends and storage AP merged and in test, and we merged blockchain test support and also a small improvement in ta ten implementation to validate the deployed code, which is useful for UF to make sure that there's no invalid code in prestate and that's it.
00:02:56.980 - 00:02:59.372, Speaker A: Great. Thanks for that update.
00:02:59.436 - 00:03:00.050, Speaker D: Also.
00:03:01.780 - 00:03:12.660, Speaker A: Anyone else want to mention anything for client updates? Cool, any compiler updates?
00:03:19.340 - 00:03:23.530, Speaker E: No, but I wanted to discuss about the call to spec.
00:03:24.700 - 00:03:28.440, Speaker A: All right, great. Let's jump into spec. Questions and updates.
00:03:31.900 - 00:04:05.620, Speaker E: I kind of just posted on the Ethereum additions thread for call two, and I think in order for the call to spec or the EIP to be completed, it should really have a return data load as well, because otherwise it leads to a performance regression or at least a code size regression when you're calculating the output buffer.
00:04:20.000 - 00:04:24.510, Speaker B: An opcode in addition to it.
00:04:30.880 - 00:04:34.780, Speaker E: Let me pull it up. That'll make it easier.
00:04:47.240 - 00:04:47.990, Speaker A: It.
00:05:03.340 - 00:05:04.890, Speaker F: Any comments about.
00:05:10.400 - 00:05:11.150, Speaker A: It.
00:05:20.240 - 00:05:21.950, Speaker E: Is that for me or others?
00:05:22.880 - 00:05:33.650, Speaker F: Rather for others. But if nobody's speaking. So you mostly mean the case that in the current call you would just use output buffer and then.
00:05:35.860 - 00:05:56.570, Speaker E: Yeah, exactly. I mean, the client kind of does that already. It takes the return data buffer and then slices out whatever you need into the provided output buffer. But in order to replicate that semantics, you would not need to kind of do that in EVM code.
00:06:04.210 - 00:06:18.850, Speaker F: Okay, so previously you just use that and then output would go to memory as well. And then you can use m load to bring it to stack. Right. That's more or less the workflow.
00:06:20.310 - 00:07:30.890, Speaker E: Yeah. Previously we allocate a buffer, right. And then do the call with the length of the, and provide the length of the buffer to call. But in call two land, we need to do the call and then copy the min of the buffer size and return data size. Because return data copy, of course has this out of bounds. Interestingly, I was talking with axic about this, and having the out of bound semantics for return data copy is kind of a good thing because that reduces some ABI decoding validation checks that we need to do that the output data is at least of a certain size. Like right now we have to check that the output data is at least like some size, but with return data copy you just get that for free because you get a reversion on the out of bounds.
00:07:30.890 - 00:07:43.710, Speaker E: But it turns out that's like only half the problem. We still need to calculate the size of the output buffer to begin with.
00:07:51.170 - 00:07:55.200, Speaker F: But in the end you want this data to be in memory anyway, right?
00:07:55.570 - 00:07:56.320, Speaker E: Yeah.
00:08:01.390 - 00:08:34.740, Speaker F: Okay. I'm not sure I fully understand, but I will read the comment you sent, link to it on the instruction side, it doesn't seem to be problematic because I think maybe number of instructions, the other hand, think we can add this instruction separately as well.
00:08:39.930 - 00:09:06.990, Speaker E: Yeah. By the way, adding return data load now we would have like kind of symmetry too, um, which kind of makes some things a little bit easier instead of having, so right now we have what m load code copy call data copy, call data load, return data copy.
00:09:10.610 - 00:09:20.370, Speaker F: Yeah, two load instructions, one from memory, one from call data. There's no load instruction from return data, right?
00:09:20.520 - 00:10:05.550, Speaker E: Yeah. And then I think uf currently is like m load. Then we have m copy coming in cancun m load, m copy, call data copy, call data load. And then EOf has what data copy? Data load, return data copy but no return data load and also the return data copy. While we're on the topic, it's kind of interesting that return data copy has different out of bound semantics than everything else, and I'm wondering if it makes sense to fix that or make it more consistent. In Uf.
00:10:10.710 - 00:10:40.700, Speaker F: Last time we talked about it with solidity, they were in favor of making it consistent, which I guess means rather removing this requirement so behave as any other memory whatever. Yeah, I think it's rather question how difficult is to roll it out.
00:10:43.650 - 00:10:44.400, Speaker E: Yeah.
00:10:47.730 - 00:11:02.754, Speaker F: On the implementation side I think it's easy, more or less. I think for me it's rather question about additional point that confuses people or.
00:11:02.792 - 00:11:03.380, Speaker E: Like.
00:11:05.510 - 00:11:10.660, Speaker F: Yeah, it's kind of gotcha you can expect to step on, right?
00:11:12.550 - 00:11:38.346, Speaker E: Yeah, I mean I think that call data copy and code copy from out of bounds or I guess it'll be data copy is kind of like not generally something you want to do, but actually we use call data copy for memory zering and I think that solidity might do it too. Call data copy from past the end of call data. It's like a trick.
00:11:38.538 - 00:11:50.260, Speaker F: Yeah, I get it. It's kind of like the symptom of something misdesigned and nice feature, but okay.
00:12:04.220 - 00:12:22.030, Speaker E: Yeah. So maybe now that I think about it, we can leave the out of bound semantics as it is. It is confusing, but once you've learned it, you don't want to go back.
00:12:24.640 - 00:13:34.404, Speaker F: I mean, I think would be nice to have some, I don't know, general overview. I don't think we need to have specifically what exactly how EVM behaves, but rather what people think it's more desirable design for this. Not sure we can get it, but I'm not really sure which option is better from EVM. The reason why we added this restriction for return data. We were around the times when these issues with not checking the input data was causing some security issue in contracts that turned out to be problematic. So there was ideas so we can fix it in the new stuff, but apparently not everyone noticed that it actually is there. So there was also, I think some solidity issues at some point.
00:13:34.404 - 00:14:06.510, Speaker F: I might be wrong about it, but I think they somehow missed that this requirement is there, and that causes some, probably other issues. Not sure that they're fully exploited, but I'm not sure how to fix it. But at least if we had some ideal solution to this inconsistency, we can at least look at it and see if we can change the direction with the of.
00:14:08.240 - 00:15:15.670, Speaker E: Yeah, it's actually is not super simple, I think, because raising on an out of bounds thing kind of makes sense until you have data that's like not 32 byte aligned. So like call data often just has four bytes in it. So if you forced an out of bounds thing, then all of a sudden instead of just call data load to get the first four bytes of call data, now you need to start doing like call data copy and then loading that from memory. And I think if the ABI ever changes and contracts start returning less than 32 bytes of data, then the out of bound semantics might actually be problematic.
00:15:17.950 - 00:15:48.490, Speaker F: Okay, so seems like the only possible consideration is to remove the restriction from return data.
00:15:53.330 - 00:16:08.660, Speaker E: Yeah, let me think about this some more, but I think that adding return data load does make sense at this point.
00:16:10.550 - 00:16:39.500, Speaker F: Yeah, I mean, that's a bit new information. Previously I thought at least solidity was on the side, that it's not needed and just complicates some, at least on the consistency level. But if you say, and if Axic said that this useful and helps a bit, then I think we are good as we are.
00:16:42.510 - 00:17:22.350, Speaker E: Yeah, because Viper allocates all buffers statically, not based on return data size. So in other words, we do the memory allocation before the call. So then fitting the return data into that buffer gets more complicated. If we need to calculate this minimum of call of buffer size and return data size.
00:17:47.950 - 00:17:48.940, Speaker F: From others.
00:18:07.620 - 00:19:11.160, Speaker A: It seems like we can probably move on to the next topic. Unless there's anything else to say. Here's cool. Yeah, I guess. Still on the spec. Any other spec questions or comments? All right, I don't see the testing folks here, so I don't know if there will be anything to update on testing.
00:19:13.420 - 00:19:15.880, Speaker B: I think they've been preoccupied with Denkin.
00:19:17.360 - 00:19:20.030, Speaker A: Yeah, I hear that's kind of all the rage right now.
00:19:23.280 - 00:19:54.810, Speaker G: Yeah, from my side, the pull request updating the tests to Prague and this pr has been merged already. And there is another pr which changes the test in order to mark the non returning functions. This is also ready.
00:20:06.400 - 00:20:11.272, Speaker A: I just wanted to check, was this for ethereum tests or execution spec tests?
00:20:11.416 - 00:20:13.260, Speaker G: Yes, for ethereum tests.
00:20:13.920 - 00:20:15.070, Speaker A: Okay, thanks.
00:20:16.320 - 00:20:32.820, Speaker G: Yeah, and also I have been looking into execution spec tests in order to see what is the current status there, because maybe the next eips, I think maybe will be written using execution inspectors.
00:20:35.560 - 00:21:00.364, Speaker A: Right on. Thanks for that update. Yeah, that's mostly it for the call. I don't know if people have other things they want to talk about. We could touch on like fork meta if you wanted to. Otherwise probably call it an end.
00:21:00.562 - 00:21:02.460, Speaker B: What do you mean by fork meta?
00:21:02.880 - 00:21:08.460, Speaker A: Just the usual discussion of how are we going to put this in Prague.
00:21:10.640 - 00:21:38.040, Speaker B: Yeah, so a couple of weeks ago or a couple of meetings ago I mentioned idea. Do we want to do a all core devs presentation like Verkeltree did a couple of weeks ago and I think we got sign up from the Ipslon team but we agreed on a date but I don't know that anything progressed on that. Is the date still reasonable? Do we want to do the discussion or not? Some questions that might help broader acceptance of this amongst the people who don't call into this call and more comfort that this is suitable for Prague.
00:21:40.220 - 00:22:26.410, Speaker A: Yeah, I think a presentation would be good. I will say the conversations that I've been a part of it seems that the raging debate right now is will vertical just be like the next big thing? Are we going to ship 4844 and then it's going to be heads down on vertical for one year, one and a half years? Or will we have a fairly quick prague fork focused on eof and these types of things? And those conversations are starting to bubble up and I think if we present on all core devs it will accelerate it a bit. And also I don't know, just not have eof on its back foot. Rather being proactive of presenting it and showing that it's ready.
00:22:27.100 - 00:22:27.848, Speaker B: Right.
00:22:28.014 - 00:22:32.330, Speaker A: Yeah. Sooner than later. I think in September would kind of be good.
00:22:34.380 - 00:22:39.260, Speaker B: So you mean two calls 14th or 20 eigth?
00:22:39.760 - 00:22:42.700, Speaker A: I think yeah, if possible. The 20 eigth.
00:22:44.400 - 00:23:04.130, Speaker B: Okay. And who's got the assignment for writing the slides and leading the discussion? Happy to do it. Actually I can't do the 20th because I have a company off site that would be kind of awkward for me to do during. I'd love the excuse to duck out of the meetings but I don't think that would be good for my career. Or maybe it's the right thing to do. I'm not sure.
00:23:05.160 - 00:23:21.912, Speaker A: Understand. Yeah. We can figure this async if we need to. I mean it's also like not the end of the world if we do it in October. But I really don't know how the next few calls will unfold. I know that next call. Next Cl call, next El call.
00:23:21.912 - 00:23:44.930, Speaker A: It's going to be a bit about Prague or, sorry, Cancun timing and I'm not really sure how that's going to shake out right now there's a bit of talk of trying to do this fixed gas Eip in Cancun because of this whole press switch 1559 post. So in general there's some things to talk about.
00:23:45.860 - 00:23:48.610, Speaker B: Fixed gas. I must have missed that post.
00:23:50.100 - 00:24:15.130, Speaker A: Yeah, he just posted this thing yesterday, he made a cheeky pr to the flashbots relay. Basically, he's pointing out that builders kind of control with the gas limits, and there's not that many of them, and they're incentivized to just increase it, and there's not much validators can do to stop it. So he says the relay should just take the bundle it gets from the builder, change the gas limit to a million, and then send it to the validator to sign.
00:24:17.580 - 00:24:18.440, Speaker B: Hmm.
00:24:20.380 - 00:24:31.104, Speaker A: So there might be. I mean, this is pretty aggressive, almost an attack at least. Like some kind of meta attack, because.
00:24:31.142 - 00:24:37.948, Speaker B: Some people think that gas limit floating, they got rid of it as part of switching to the merge, which they didn't.
00:24:38.044 - 00:24:38.352, Speaker A: Just.
00:24:38.406 - 00:24:39.730, Speaker B: Nobody's doing it.
00:24:43.720 - 00:24:50.164, Speaker A: Yeah, I mean, it is a pretty weird thing that we still have it. And 4844, we don't have this.
00:24:50.202 - 00:24:50.692, Speaker B: Right.
00:24:50.826 - 00:25:22.450, Speaker A: It's fixed, and we should probably fix the other one. It just hasn't been that high on the priority list. But if people are going to make PRS to relays and start proposing that they attack the network in this way, then we need to respond anyway. So, yeah, basically what we're saying is there's some stuff to talk about the next call or two, but the Prague conversations are starting to bubble up externally, from the call at least. And I think if EOF is presented on a call sooner than later, it's better.
00:25:22.820 - 00:25:25.490, Speaker B: Okay. Yeah, that's my thought, too.
00:25:27.060 - 00:25:42.070, Speaker F: I think we need to start preparing for that. But, yeah, I would like to have light client and Dano on this as well. So maybe let's decide on the date later.
00:25:43.420 - 00:25:47.480, Speaker A: Maybe tentatively try and target that first meeting in October.
00:25:48.220 - 00:25:54.628, Speaker B: Okay. That would be October 5. No, wait. October twelveth.
00:25:54.804 - 00:25:56.010, Speaker A: Yeah. Twelve.
00:25:57.360 - 00:25:57.868, Speaker F: Yeah.
00:25:57.954 - 00:26:05.070, Speaker B: Let's target that. If I say dumb things on Twitter, I might be available on the 20 eigth. But that's not my plan.
00:26:07.200 - 00:26:08.748, Speaker A: Let us know if anything changes.
00:26:08.834 - 00:26:09.710, Speaker B: That happening.
00:26:14.800 - 00:26:16.450, Speaker A: Happens to the best of us.
00:26:17.860 - 00:26:23.190, Speaker C: One question is that, will we have the spec finalized by that time?
00:26:27.910 - 00:27:05.786, Speaker B: Well, finalizing the spec is the process, and I think at that time, I think I would be comfortable saying that we're closing the door to new features or there would be a last call for new features. I think we've already closed the door for large features. We're talking about pushing out jump. I'm not jumpy. Call Fi and Jump Fi out to a future release. So I think I'm comfortable saying that the only doors would be open with things that are required for functionality. Call Fi and Jump fi.
00:27:05.786 - 00:27:46.858, Speaker B: I think a couple of weeks ago, there was not sufficient consensus to put it in the first release. The preference to put in a follow on, maybe that's a discussion we need to have, but I think now is the time to start figuring out what's in, what's out, close the door. What's future release. What's this release? And I think involving ACD in the discussion because one of the big issues is size. Yeah, there's many stages of finalizers, the size that comes into it, but we need to figure out what's in and what's out because it happens all the time with hard fork stuff you think is in until literally two days before the first hard fork. And they say no subroutines for you. So it's always a process.
00:27:46.858 - 00:27:50.810, Speaker B: But I think we're getting to the point where it's no longer additive, it's only subtractive.
00:27:53.150 - 00:27:54.460, Speaker E: That wasn't my.
00:27:56.290 - 00:27:58.558, Speaker B: Go ahead, ask your question. I kind of missed it.
00:27:58.644 - 00:28:08.450, Speaker E: No, I mean, that wasn't my understanding of the conclusion a couple of weeks ago. I think there were just not enough Epsilon people on the call for, like, quorum.
00:28:09.190 - 00:28:09.940, Speaker B: Yes.
00:28:13.670 - 00:28:14.850, Speaker E: Jump fi.
00:28:27.390 - 00:28:28.858, Speaker B: Had some noise on my end.
00:28:29.024 - 00:28:32.490, Speaker E: Oh, yeah. No, I was saying that I think that we should solve jump fi.
00:28:36.780 - 00:29:01.476, Speaker B: Okay, so this is the discussions as the finalized. If it's not on the table, it's not like jump fiber. We discussed it before. I don't think there's room for anything new. And we can have the discussion about what's in and what's out. And I think some of this will be informed by the Alcor devs. So I think probably for the next meeting, we need to get a master list of what's possible and what's not, and then we can have real discussions about what's needed and what's not.
00:29:01.476 - 00:29:21.016, Speaker B: I think that's jump fi. Call fi exe data load. And now the call data load or return data load. I think those are the only bubble items. So we need to find whether they're in or out. But I think we can probably close the door. If it's not on the bubble, it's not in.
00:29:21.016 - 00:29:33.120, Speaker B: I think it's the current state of the spec. Who did we just lose that has to call in onto their iPhone?
00:29:43.960 - 00:29:45.060, Speaker A: They're shy.
00:29:46.840 - 00:29:52.440, Speaker B: I was just afraid. It's like someone loses their Internet connection having to call in on their phone. I've seen that happen before on these calls.
00:29:57.720 - 00:30:00.900, Speaker C: But I don't think it would say the phone brand.
00:30:05.720 - 00:30:06.900, Speaker E: Was a mistake.
00:30:08.380 - 00:30:11.130, Speaker B: They're calling in for the next meeting on this line, I guess.
00:30:13.660 - 00:30:14.264, Speaker E: They'Re probably.
00:30:14.302 - 00:30:27.390, Speaker A: Like oh man, someone dropped a zoom link on discord. I got to click on that. Okay. Yeah. Is there anything else that we wanted to chat about here?
00:30:30.800 - 00:31:01.800, Speaker C: One concern, if we are going to drop mega Oaf on the ACD, are you guys concerned about the size of the proposal? Because there is now a lot of features inside megaof, and if we drop all of that on ACD, there is a possibility that they would think the other divs would think it's too big to be included in a single fork.
00:31:05.100 - 00:31:49.460, Speaker A: I'm more concerned with saying the spec isn't final. I mean, we can say the spec is final, but we're open to reducing the scope a bit. I think it would be more of a nail in the coffin if we brought it and said yeah, we're still working a few things out. That would basically be the death of it. But I think if it's big and we say hey, we've worked it all out, this stuff makes sense. There's some features that are nice to haves, but they're not core pieces of EOf and we could reduce it, I think that would be the best framing. Paul?
00:31:55.350 - 00:32:46.900, Speaker F: Yeah, I didn't want to say in the topic, I wanted something new, which is the address space extension was mentioned recently again, and I think originally I thought it's unrelated to EVM itself, but I finally realized where it actually matters. So I think there's like pieces of instruction, semantic, that just chuncates the values to 160 bits. And yeah, apparently people depend on it and also compiler kind of enforce it, but that's like secondary thing. And I wonder if we also want to kind of try to track this in context of us.
00:32:54.790 - 00:33:37.930, Speaker B: Good call, totally forgot about that. But yeah, because Vitalik mentioned it on the last all cordes call and we would need to dig up the talks, the discussion on the cuts, but palace totally right. All the instructions cut and we could have EOf not cut it, and it's a one way door. It either cuts it or it doesn't cut it because you really can't go back. This would allow for address based expansion inside EOF. This might be a hook to push EOF as could be one of the net assets to get it to adoption. It could also be a risk if address based expansion never occurs.
00:33:37.930 - 00:34:02.470, Speaker B: And I think the biggest thing we need to specify in the absence of a specific address based expansion proposal is how would we deal with it? Does anything that has a high bit set in the first pass just fail to load anything but an empty account, does it revert? I think that's the big question that would need to be resolved in how we would do this, because no one's got a serious fixed address expansion proposal.
00:34:07.790 - 00:34:26.660, Speaker C: Yeah, I don't think we're going to keep pushing the can down the road or kicking the can down the road about address base expansion, because it's a problem that needs a fix, and if we don't address it now, it's going to be a bigger problem later.
00:34:36.750 - 00:34:57.060, Speaker B: This is also going to be a high touch fix for maybe not high touch, but a broad touch, because any of the opcodes that takes an address in, we would have to change our implementations to no longer trim those addresses. It could be a fairly simple fix, but there's a lot of operations that work off of addresses. They kind of sneak in and you forget about.
00:34:59.880 - 00:35:19.440, Speaker F: Yeah, I actually wonder how many instructions actually operates on addresses and how many we already change it in your. So we can start maybe with a list of instructions.
00:35:20.260 - 00:35:31.350, Speaker B: There is a reference test that covers this. It's not off the top of my head because I cached it later.
00:35:31.880 - 00:35:48.200, Speaker E: I think it's like all of the call instructions, ext instructions and balance and anything that returns an address, but that's a little different. So like address caller.
00:35:53.520 - 00:35:59.790, Speaker F: Okay. Yeah, that's kind of two groups. Yes. I can prepare something for next time if you want.
00:36:05.800 - 00:36:36.860, Speaker B: Because there's a lot of them. They test them in two places. Each one individual operation tends to have an address too big left filter and right filler too big left, too big right. But there was one master test that I can't find off the top of my head that had all of them in order because I had experimentally turned this on and seen what broke when I changed it. And there was one that literally tested every operation. It's a relatively recent one from Ori who wrote it. So there is tests to cover this that should help us with our scoping.
00:36:37.680 - 00:36:38.430, Speaker F: Okay.
00:36:57.710 - 00:37:23.380, Speaker A: All right. Is that all? Thanks a lot, guys. Bye. Yeah, we'll see you again here in two weeks and we'll try and target talking about EOF, October twelveth on all core devs. Have a good rest of the day.
00:37:24.470 - 00:37:25.620, Speaker B: Have a good day.
00:37:26.390 - 00:37:28.910, Speaker E: Thank you. Have a good day. Bye.
