00:00:16.410 - 00:00:54.894, Speaker A: Well, thank you very much. It's a pleasure to be here. Grant Passmore and my co founder Dennis Ignodovich is here in the audience. Thank you to Vitalik for the invitation. So we're going to talk to you today about our formal verification platform, Amandra, and in particular, something we're calling a Mandra contracts, which is the application of a mandra to Ethereum smart contracts, both to analyze smart contracts, reason about them, be able to prove properties of them, compute proofs and counterexamples, and then on top of that, to actually do risk management. So I'll tell you what I mean. But for those in investment banking, we mean compute greeks and so on.
00:00:54.894 - 00:01:05.426, Speaker A: So let me start with a video that gives you a background on what we're doing at aesthetic integration. See if the sound. I'll start it over. Here we go.
00:01:05.608 - 00:02:08.674, Speaker B: What's played in today's financial markets? The world economic complex tank of our competitive pressures and economic recession contribute to increasingly the effects of digital investors and ultimately general public. Regulators and industry have worked tireless to define what safe and fair markets are. What's been missing is a way to analyze and regulate all algorithms underline the solution is formal verification the science of the right algorithms. Other safety critical industries already rely on formal verification to make their algorithms safe. The monument by setting inspiration is the world's first formal verification solution for financial problems. Consider building a bridge, a design maybe catastrophic. To make it safe, engineers use powerful computer aided scientists which analyze science for safety.
00:02:08.674 - 00:03:03.810, Speaker B: Automatic powered by latest advancements in artificial intelligence, computer science and mathematics, a model brings unprecedented rig to the electronic financial markets. Analyzing safety and fairness of algorithms before enter financial algorithms are valuable, complex. They can be infinite number of causalities. They can be 101,000 or even 100,000. We must consider every possible case to answer the question, what could possibly work among allows designers to face reaches of safety before you? Let's build safer, more reliable and regulatory appliances that all user trust, saving everyone time aman by aesthetic iteration the blossoming of tourists.
00:03:04.970 - 00:03:54.594, Speaker A: All right, so that gave you a bit of an overview of what we're doing at aesthetic integration. The big idea is we're bringing the hard science of formal verification techniques that are relied upon already in safety critical industries like avionics and hardware design. Finally, to finance so that financial algorithms, things like dark pool matching logics, exchange matching logics, market making algorithms, smart order routers, the type of algorithm that is really at the heart of our global financial infrastructure, so that they can actually be analyzed rigorously and reasoned about. So a bit of our background. So Dennis formerly was the head of the central risk trading desk at Deutsche, roughly, I believe nine years at Deutsche. By the way. We were undergrad roommates in Texas.
00:03:54.594 - 00:04:54.220, Speaker A: And then as Dennis went to Wall Street, I went to academia, did my phd in formal verification, in particular, the real algebraic geometry for reasoning about autopilot algorithms, and being able to prove safety properties of autopilot algorithms in avionics, and now in self driving cars, and ended up as a postdoc at Cambridge while Dennis was working at Deutsche. And we realized we were working in many ways on some of the same problems. He had very complex trading algorithms that constantly everyone was know, if we commit a line of code, is this change all of a sudden going to cause us to violate a regulation? And it's very hard to get right. If you think of modern market microstructure, something like an exchange trading venue. In the US, for instance, it may have upwards of 2030, 40 different order types in each of those order types. Effectively, it's a way of packaging risk. It's a programming language, and as you introduce new order types, it's very difficult by hand to understand what can possibly go wrong.
00:04:54.220 - 00:05:55.494, Speaker A: So when it comes to smart contracts, really, we have the same issues. So if I come to you and say, look, I promise this piece of bytecode really implements fair escrow, please send me your assets. How do you know? Likewise, if I say I promise this implements a swap that we've agreed upon, how do you know? You can't ultimately trust the result or the design of a given smart contract without reasoning about it, without proving theorems about its possible behavior. So what we've done is we've taken our Amandra engine, which I'll tell you about, for reasoning about financial algorithms, and now we've adapted it in effectively two different ways. I'll tell you about one, that's reasoning about a high level language that can be compiled down to Ethereum bytecode, and the other that effectively is doing something called verified decompilation. That takes Ethereum bytecode decompiles it to IML, our high level functional language. That's actually a formalized subset of Ocaml.
00:05:55.494 - 00:06:45.494, Speaker A: If you know, Ocaml allows you to reason about it and push the proofs back down to be proofs about bytecode. So, okay, that's reasoning about individual contracts. But as I mentioned, fundamental importance as a bank who's a pioneer right now with, let's say, ethereum, as they're looking down the road three years from now, what happens when they have a portfolio of 100,000 smart contracts, right? You have to do risk management in the large, you have to compute greeks. And to do that, you have to reason about the code. So you must have effectively formal semantics that ultimately is mechanized for reasoning about your smart contracts. So let me tell you a bit about how a mandra is used currently. So our biggest focus has been something we call a Mandra venues.
00:06:45.494 - 00:07:34.030, Speaker A: And this is using a mandra to formally analyze the matching logics behind trading venues, things like stock exchanges and dark pools. So you may have heard about many glitches in the past few years. For instance, bats failed trading its own IPo, of course. Famous Nasdaq glitch with Facebook Night Capital, Goldman Sachs, Alphabet trading glitch. These happen all the time in finance. And fundamentally, what's been missing is a way to reason about the algorithms in advance of their deployment. So Imandra Vinyuz is now currently at use at top five global investment banks, effectively to take what is classically an imprecisely described algorithm, their collection of matching logic that is usually described, say, in some collection of pdfs.
00:07:34.030 - 00:08:35.300, Speaker A: There is classically no formal spec of how these things are supposed to work, but it's actually taking those ambiguous sort of imprecise specs, making them precise in a mantra, reasoning about fairness and safety properties, and then using a mantra to vet their high performance production systems to ensure that the production systems really correspond to the verified specifications. So there's also some exciting developments we have in the regulatory space. So, just to say, we came out of stealth mode with this in April, and the SEC brought us to Washington, DC, to the SEC headquarters to teach them about a mantra for two days. And some exciting developments will be announced soon on a mantra in the regulatory space. But fundamentally, regulators face the same issues. Someone comes to them and says, I'd like to add this new order type to my trading venue, ensure for me that this is allowed. And the SEC then has to process these things.
00:08:35.300 - 00:09:10.370, Speaker A: So does the FCA and other global regulators, and it's virtually impossible to do by hand without formal verification. So what is a mantra? I'm going to give you very low level demos of a mantra. This is a very technical audience, so I want you to see really in action. And I want to talk to you a bit about the automated reasoning and mathematical logic that's under the hood. But fundamentally, it's three things in one, it's a programming language, so it's a formalized subset of OCaml. If you're familiar with Ocaml in the ML family of languages, functional language. It's a mathematical logic.
00:09:10.370 - 00:10:13.806, Speaker A: So fundamentally, every data type definition or every program that you define, every function you define in a mandra is automatically transformed into an axiomatic representation that then a mantra's reasoning engine reasons about. So you write code and questions that you would like to ask Amandra about your code. And Amandra works to produce proofs or examples using many different types of decision procedures. And I'll talk to you more about that. So that's the big idea, what I just outlined. Effectively, you give a mandra your financial algorithm or your smart contract and ask a mandra a question, is there a potential glitch of this class? Or does this do some concrete form of unfair trading? For instance, is there some sequence of messages that could be sent to this trading venue that could allow someone to jump the queue? Right? And ultimately you get out. Either that the algorithm is verified with a mathematical proof that can be independently vetted, or you get a counterexample.
00:10:13.806 - 00:10:58.522, Speaker A: So that's the big idea, pushing these questions into what are called decitable fragments, so that this is automatic. So let me show you a very simple example. Here we have on the left, if you can read it, a summation function, just in a mantra. So this is just summing up the numbers from zero to n, the natural numbers, and it's a program. So on the right, we're just computing with it, right? We can compute sum of five, sum of 100. But you may remember this possibly apocryphal story of Gauss as a six year old, proving actually, that the sum of n, sum of zero up to n is equal to n times n plus one over two. So we can not only define programs, but we can write verification goals.
00:10:58.522 - 00:11:33.434, Speaker A: And what we've done here is we've asked Amandra to actually, pardon me, to actually verify this statement on the left. Verify, we named it Gauss. And we asked Amandra to prove for every possible input n. If n is greater than or equal to zero, then the sum of n is n times n plus one over two. So emodra then goes and does a proof by induction, et cetera. We can see a trace of that proof, great proof by induction, as you might do by hand, and ultimately has to do some symbolic rewriting. That proof can be exported, can be verified by an open source proof checker, so you don't have to trust it.
00:11:33.434 - 00:11:57.346, Speaker A: But now what happens more often, of course, is we have bugs in our code. So instead, here I've swapped a plus for a minus right. And I'm asking Amandra instead to prove that some of n is equal to something really that it's not equal to. And a mandra comes back and gives me a counterexample. So that's a super simple example. But let me show you something more complex. So I believe I don't have too much time.
00:11:57.346 - 00:12:39.006, Speaker A: But for instance, here's an example where I'm effectively defining algebraic data types, and I'm asking a module to compute some complex counterexamples for me. And again it comes back and always the counterexamples it gives me, those are valid IML, they're valid ocaml objects. They can be reflected into the language and computed with. So this same idea now can actually be scaled to reason about financial algorithms. So for instance, we can take the design of a dark pool, which I have on the left here, fairly complex matching logic. This is of a global investment bank, top five investment banks, dark pool, and now we can reason about it. So by the way, this is all based on publicly available information.
00:12:39.006 - 00:13:13.878, Speaker A: Don't worry. So now, for instance, I can ask Amadra, is the order ranking function transitive? Right? So that's something we really care about, a fairness property. So I can ask Amandra this question. It has a model of the matching logic on the right that's also a high performance simulator. And a Modra comes back and synthesizes for me a counterexample. So now I have concrete values of different orders, effectively that could exist in the book of this dark pool, where the ranking function violates transitivity. So that's the main idea, proofs and counterexamples.
00:13:13.878 - 00:13:57.894, Speaker A: So let me quickly cut to the chase for Ethereum. So what we've done here is we've taken a mantra and we've adapted it so that in IML, in this fragment of Ocaml, you can directly write smart contracts. So there's many things to talk to you about, how we actually do the compilation. So right now we actually compile effectively your customized smart contract code via serpent. We compile it first to serpent, and we have different encoding mechanisms for how we encode algebraic data types recursively. But now we have this smart contract, let's say for a crowdfunding example. And now we can ask Amandra to reason about it.
00:13:57.894 - 00:14:32.050, Speaker A: So for instance, we just had a mandra approve that in this smart contract, you effectively can't jump the queue in a certain sense. And then we ask another question, effectively, that we will always get our money back if we come in after a certain timeout. And Amandra computes for us a counterexample where that fails. So that's the big idea. I think I need to end here. But we have these different modes. Effectively, you can go IML directly to bytecode via serpent reason about your IML, or we can use our ethereum to IML verified decompiler.
00:14:32.050 - 00:14:38.262, Speaker A: So sign up, please, if you'd like to join the private alpha. And thank you very much.
00:14:38.316 - 00:14:39.574, Speaker C: Dennis, do you have five minutes?
00:14:39.612 - 00:14:40.520, Speaker B: If you like.
00:14:40.890 - 00:14:47.670, Speaker C: Five minutes, it's.
00:14:51.790 - 00:14:56.300, Speaker A: Okay. Well, that's okay. I mean, if there's any questions. Okay. Yes.
00:14:58.430 - 00:15:02.380, Speaker C: So are you saying we can write smart contracts in Ocaml now?
00:15:02.910 - 00:15:19.010, Speaker A: Exactly. In IML. So IML, it's not all of Ocamel, but it's polymorphic. Henley Milner fragment of Ocamel, for instance. It doesn't support exceptions. So that's a fundamental difference. But instead of exceptions, you use things like option types.
00:15:19.010 - 00:15:20.194, Speaker A: But yes.
00:15:20.312 - 00:15:21.650, Speaker C: That is pretty awesome.
00:15:21.800 - 00:15:42.890, Speaker A: Thank you. Pardon me. It's not. So effectively, we have a reasoning as a service API. We have an online web interface, and we have an open source proof checker, so you don't have to trust the proofs. The hard part is finding the proofs. The easy part is checking the proofs.
00:15:42.890 - 00:15:48.700, Speaker A: So currently it's not open source, though I'm sure we'll open source pieces of it over time.
00:15:50.910 - 00:15:55.930, Speaker C: I want to run your own source of religion.
00:15:57.970 - 00:16:38.470, Speaker A: You mean use a mantra to reason about a mantra? Yeah, it's a great question. So there's sort of architecture of a mantra. There's some bootstrapping in a mantra that is not written in a mantra that's written in, let's say, raw ocamel C. But then most of a mantra actually is written in a mantra after this bootstrapping. So we've actually done some self verifications. I mean, you always have these fundamental metamathematical results that if you want to prove, ultimately, consistency of your own system, you effectively need to add something like transfinite induction up to a larger ordinal. So actually, a mandra's logic is related to a logic called primitive recursive arithmetic of scholum, but it's typed.
00:16:38.470 - 00:17:22.554, Speaker A: But then we have transfinite induction up to an ordinal called epsilon zero. So basically that means we can synthesize and do termination proofs of functions that effectively recurse in some complex ways what you would have to do. Because we already have that strong ordinal in the logic. You'd have to add an induction principle up to a bigger ordinal, but you can. So, proof theorists have isolated effectively, the ordinal analysis of theories like this. So you could do it and actually try to prove soundness properties of a mandra as a whole. But one of our really driving philosophies has been we always just want our proofs to be independently checkable as well.
00:17:22.554 - 00:18:17.846, Speaker A: So when we produce a proof object, ultimately you can use a simple checker to check that proof object. Or if we produce a counterexample, it's an explicit value of a given type that you can run your system on. So in either case, you don't have to trust us. But we have a lot of ideas where we would love to talk to members of the community who are interested, a lot of ideas of effectively attaching this type of evidence directly to smart contracts, different ways that we can actually have an API where you can easily query what is known about this contract, what's been proved about it, what's been disproved. Also, there are times you need to prove Limas before a Mandra will actually prove your main theorem. Happens all of the time for, let's say, very deep properties. And there we imagine you could have sort of bounties where you want to give someone some number of credits if they prove this lima for you that you relied upon.
00:18:17.846 - 00:18:21.290, Speaker A: So there's lots of cool things I think we can do community wise.
00:18:25.570 - 00:18:44.878, Speaker C: They're either generated by fat fingers, flash crashes are either generated by fat fingers, or like, downward spirals, where algorithms are forced to sell because other algorithms are selling. And so you just get this very, very quick negative spiral down. Like, how would Imandra help in either of those two cases?
00:18:44.974 - 00:19:37.266, Speaker A: Oh, it's a great question. I mean, fundamentally, there's a number of answers. So, first of all, flash crashes happen a lot more often than we hear about in the press, right? These happened at a micro level, happen at a micro level. It is not uncommon. And a lot of work has been done effectively, having things like specialized risk gates, specialized circuit breakers, that are effectively trying to act as an arbiter to make sure that things don't get out of control. So, for instance, some of our clients, now, the first thing they actually do is they use a mantra to reason about their risk gate component before they go and reason, let's say they have an order router before they start to reason about best execution of their routing. They may use a modra first to prove that their risk gate component, which is just this last piece, that it effectively won't let something crazy out the door.
00:19:37.266 - 00:19:56.610, Speaker A: So you can effectively, incrementally verify these circuit breakers, these risk gates. Get those safe first, and then start to verify more pieces that are more algorithmically interesting. Did that answer your question? Okay, thank you very much. Thank you, Dennis.
