00:00:18.090 - 00:00:35.080, Speaker A: Thank you. So this is a short talk, so I'll go ahead and just jump into it. I was going to give a, you know, basic how prediction markets work. Introduction. I thought we put together this really nice video in the lead up to our crowd sale, so I'll just show you the video and we'll have time for some actual technical stuff.
00:00:43.550 - 00:01:32.278, Speaker B: Auger is a prediction market platform that rewards a user for correctly predicting future events. Prediction markets allow users to purchase and sell shares in the outcome of an event. The current market price of a share is an estimate of the probability of an event actually occurring. The prices of each share adds up to $1, so if you buy a share at even ods, it will cost you $0.50. If you end up being right, you'll receive a dollar for that share. These markets rely on a scientific principle known as the wisdom of the crowd, which states that if you ask enough people something, their average answer is usually far more accurate than any expert. This allows us to create one of the most powerful forecasting tools.
00:01:32.278 - 00:02:26.010, Speaker B: The problem with previous prediction markets is that they were centralized, allowing them to be easily shut down. Another problem is that with any prediction market, someone has to report what actually happened after the event occurred. In centralized markets, one person does this, which means there can be mistakes or outright manipulation. With Auger, we'll have thousands of users reporting on these outcomes using something called reputation. Using Auger, anyone, anywhere in the world can create a market asking a question about anything. Market makers provide some initial funding for the market, and in return receive some trading fees. Anybody can freely buy and sell shares in the outcome of that market, and the current share prices provide the best estimate of that event occurring.
00:02:26.010 - 00:02:41.200, Speaker B: Imagine being able to Google questions about things that haven't happened yet, and receiving accurate odds of their occurrence. That power, the power to glimpse into the future, is what we believe everyone should have access to.
00:02:45.910 - 00:03:33.962, Speaker A: Okay, so that's the sort of a high level overview of just what are we making? We're making a prediction market platform now. So we've learned a lot of sort of low level stuff about Ethereum and how you make decentralized applications over the past few days. And so you might be wondering, how the heck do you make something like that on Ethereum? Just using smart contracts. And I know this is a fairly technical audience, so rather than going through my usual sort of high level auger spiel, I thought I'd actually go through the details. Okay, so this is the auger interface. Now, the first thing I want you to notice is that all you have to do is go to a website. So you go to client Auger.
00:03:33.962 - 00:04:26.020, Speaker A: Net. And the way this works is we want this to be as much like just using a regular website as possible, even though it's decentralized on the back end. So you don't have to be running a local Ethereum node, although you can, and if you are, it will talk to it, but if you aren't, it talks to one of our hosted nodes. So all you have to do is go to client Auger. Net and you'll be presented with our interface. So there's three trending markets you can see here in the middle. So one thing we'll notice is that there's one market that says will the sun turn into a red giant and engulf the earth by the end of 2015? And it's at 18%.
00:04:26.020 - 00:05:14.994, Speaker A: So now that seems maybe a little high, right? Because the sun is probably not going to turn into a red giant and engulf the earth by the end of 2015. So we could probably make some money off that, because this says that the demand of the market price, there's an 18% chance of that happening. We need to create an account to do that. So you can use your existing Ethereum accounts, you can use this using a local node, in which case it'll just automatically connect to your account by talking to the node, by talking to Geth. Or you can create an account using our system. You'll notice in the top right hand corner we have sign in and register buttons. So again, looks very much like a regular website.
00:05:14.994 - 00:06:07.890, Speaker A: So after you click on register, I'm going to walk you through the steps of what happens after you click on that. So you click on register and type in your username and password. I've got the two inputs here, you'll see why they're like that. We made a tool called, which we call keythereum. We're fairly proud of that name, and it's basically just a key management, it's a standalone JavaScript key management tool for Ethereum, and what it does is it's JavaScript code that creates the same key store files that geth natively uses. So what happens is it generates a private key which is just a random 256 bit number. It also generates a random salt initialization vector.
00:06:07.890 - 00:07:20.410, Speaker A: It puts the password and the salt through. I think we're using 10,000 rounds of script to generate an encryption key. So this is a symmetric encryption key and it's used to encrypt the plain text private key. So this is your new account's private key. And we do the encryption using AES 128, which is just a strong symmetric cipher. One interesting thing here is that this is by design the exact same process that geth uses, right? And that means that this encrypted private key and the JSON file that can be exported from this can just be used natively in geth. So you actually can export this and just copy it into your keystore directory and you can use it, you'll even use the same password because Geth knows how to read the encryption parameters right out of this file.
00:07:20.410 - 00:08:27.950, Speaker A: Now what happens with this encrypted JSON file is we store it in ipfs. So this file is assigned a hash by IPFS according to the data in the file. And because we want to associate this data with a username which is just sort of an arbitrary string, rather than the IPFS hash, which is sort of a hard to remember 256 bit number, what we do is we have an Ethereum contract that is just, it maps the username that the user typed in onto the IPFS hash. And they're waving the five minute sign at me. So I need to move faster. And so one thing I want to comment about this is that because when you look up the hash, it is broadcast to the DHT and ipFs, this is not as secure as it could be. And I'm talking to Juan the IPFS guy about this.
00:08:27.950 - 00:09:22.480, Speaker A: And because of this we're going to also have an option of just storing it in local storage. Okay? And so the converse of this is when you log in, you supply username and password. Sort of the reverse of this magic happens. You have the decrypted private key which you can use to sign transactions in the browser using the Ethereum Js TX library. So we registered for an account and because right now we're on just the auger private chain while we test, we give all new accounts just 100 free ether because it's not real ether. So I got my 100 free ether and you can use the faucets to get cash and reputation. So you actually place bets in the prediction markets using cash.
00:09:22.480 - 00:09:57.306, Speaker A: And so now we're finally at the point where we can bet on this absurd event. And as the comment says, yahoo. So you can see we have like a price series and comments. Comments are still a little finicky right now. We want to bet on no, right? Because we think that, man, this is really underpriced given that we know this isn't going to happen. So I'm going to say we're going to buy 485 shares of. No, this will bring the probability up to 100%, because we know this isn't going to happen.
00:09:57.306 - 00:10:35.560, Speaker A: So this is all profit. And click buy. Now we have 485 shares pending. About 12 seconds later it clears, and now we have that many shares. So you can see the price now has moved up to 100%. Okay, so what just happened here? Well, so one, I click the buy button, but what happens after that? So your buy order gets serialized, bundled into a transaction, and on the Auger trading contract there's a buy shares method. Now the transaction actually gets signed in the browser, right? So I said that you don't need to have a local geth node running.
00:10:35.560 - 00:11:15.490, Speaker A: In fact, you can sign this just using Javascript in the browser, and then you submit the signed raw transaction to the Ethereum node that way. And in that case, the Ethereum Node does not ever need to see your private key. It gets the signed transaction, then we send it to geth. Geth broadcasts the transaction to the network, and then we just pull Geth to see when the transaction has been incorporated into a block. And this is what our architecture looks like. So we've got our very happy user. And this interface that I've been showing you is so it's the sort of pinkish purple blob where it says Auger client.
00:11:15.490 - 00:11:56.030, Speaker A: And because a lot of the nice tooling that has been talked about here basically didn't exist when we got started. We're mostly just working with our own stack. So we have our own middleware. And that's the way it talks to Ethereum, which here would be on the user's computer. In the example I just showed you, it's actually running on our remote server, and that talks to the decentralized network. So let me walk you through, if I have time, I have two minutes. Let me walk you through exactly what happens when you buy shares.
00:11:56.030 - 00:12:38.430, Speaker A: This is sort of a simplified version of our markets data contract. So all of our contracts are written in serpent, and all information about shares and bets that people have placed, they're stored as data on contracts. So the set of contracts is fixed, and the trades that you make and who has made them and the events that are incorporated in markets, these are just data on the contract. It's stored as basically a big dictionary. And we have a modify shares method. So this method gets called. So Alice buys two shares of outcome, one in market m.
00:12:38.430 - 00:13:08.694, Speaker A: So we invoke modify shares, and basically this is what happens. So this is that data structure up top. And we can see, okay, now she has two shares of one. Now, I've described this sort of somewhat complicated system, and Auger is really too big for one contract. Originally we had it all on one contract. There are some nice things about that, but basically it's way too big to upload. So we actually have it split into 26 contracts.
00:13:08.694 - 00:14:13.840, Speaker A: And so our contracts are, we have data contracts, which basically are, they have things like this market data structure, and then they have setter and getter methods, and these can be imported into the function contracts, which sort of make use of them. And the reason we have it set up like that is so that most of the functionality is in the functions and the function contracts. And because of that we can make changes without having to throw out all the data, which is even when we're testing is really nice. So I want to give you an example of how multiple contracts work together just very quickly. In the little walkthrough I just gave you saw me use what are called our faucets. So this gives you free cash and free reputation. So these are methods on the faucets contract, which is one of the function contracts, and it has to import the cache and the reporting contracts to do this.
00:14:13.840 - 00:15:02.190, Speaker A: Now, the syntax to do this in serpent, and I actually don't know the syntax in solidity, but the syntax in serpent actually requires you to, it's somewhat verbose, and it requires you to actually specify the address of cache. That's somewhat inconvenient because that will change if cache contract changes, and that if you have multiple dependencies, that can be a real pain. So what we did is we have a dependency resolution script that takes care of this for us. So we can use the sort of pythonic syntax import cache as cache, and it inserts the externs as needed, and we can just use it that way. Okay. And I also just wanted to say all our code is open source. I know this was just sort of a whirlwind tour.
00:15:02.190 - 00:15:10.700, Speaker A: It's all on our GitHub. So if you want to pitch in, please do. Yeah, that's it.
