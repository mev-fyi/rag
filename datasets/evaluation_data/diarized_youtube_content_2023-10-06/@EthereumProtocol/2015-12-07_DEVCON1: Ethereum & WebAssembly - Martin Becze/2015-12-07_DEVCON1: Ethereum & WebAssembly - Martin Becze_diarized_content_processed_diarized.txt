00:00:16.410 - 00:00:59.914, Speaker A: Anyways, today I'm going to talk about virtual machines. WaSM, short for webassembly, but I'm not going to just talk about webassembly and just give a little overview of virtual machines altogether, I think virtual machines are pretty cool. Okay, so for Ethereum, really, the virtual machine is pretty core to all of it. So what do we want from a virtual machine architect? Right? We want really good performance, and we want it to be close to the metal. We don't want a lot of abstraction between what our virtual machine is doing and what the real hardware is doing. Yet we also want it to be portable. We want it to run on many devices.
00:00:59.914 - 00:01:37.160, Speaker A: So we still need a layer between like X 86 native assembly and our virtual machine. We also would like it to be standardized. We don't need to recreate the wheel. Another really nice thing would be to have tool chain compatibility. It would be nice to use LLVM to compile stuff to run on the virtual machine. And lastly, it would be good to have a clean and fairly simple instruction set, or ISA. So, yeah, sorry, X 86.
00:01:37.160 - 00:02:50.382, Speaker A: So, to back up a little bit traditional, like normal hardware, you have the execution environment. A cpu has like an execution environment has many parts, but execution environment, and then it has a core where the ISA, the instructions, the actual opcodes get executed in the ISA is usually pretty simple. There's no instruction, for example, to load something from the hard drive. The way that is handled is you have physical addresses and they write to memory, and then your cpu just reads from memory, reads and write from memory. And the memory sections are allocated at boot time for the physical devices. So we sort of have an analogy to this in Ethereum. So traditional cpus, they keep it isolated.
00:02:50.382 - 00:03:36.850, Speaker A: The instruction set is modular. It doesn't make any assumption about the environment that it's operating in, right? It doesn't make assumption about what kind of devices you have plugged into your computer. There's no opcodes for a mouse or whatnot. So this is what Ethereum's Current ISA looks like. So this would be the intrinsic set. We have memory operations, system operations. So things that give us information about the state of the virtual machine, flow control, and we have plenty of integer operations.
00:03:36.850 - 00:04:59.050, Speaker A: And then going back to the analogy with the traditional cpu, these opcodes would be like external devices. So I want to draw like Shaw three and gas, call and pre compiled. Now, those are some interesting ones, and I'll talk to them about later. Block, hash and code size and all these things. These are properties of an external environment that need to go into the virtual machine, but through a modular interface, not necessarily having the opcode for them. So the rationale of putting the call lock code in with the external operations, it might not necessarily be clear, but our call lock code is not like syscall. Like if you've ever done Unix programming or something, you have a special syscall to interact with the OS.
00:04:59.050 - 00:05:39.770, Speaker A: Our call is a little bit different. We can think of ethereum. So gap has saying what it is. Ethereum is like a singleton virtual machine, which is really nice, but I think of it sort of like a singleton hypervisor. And each single contract is its own vm, or like its own vm in the sense that it has its own storage space, it has its own isolated environment that it works in. So going back to calls, calls aren't syscalls in traditional sense. When you're talking to the operating system, calls are more like a VM talking to another VM.
00:05:39.770 - 00:06:20.950, Speaker A: So that's why I think it can be external. Okay, gas. So gas is property of the virtual machine. And if you had pure hardware, the analog to gas would just be clock cycles. So that would be nice. I found out something really interesting, actually. Not all cpus have clock cycles in nuis, it's not too relevant here, but there's actually some cpus that are totally asynchronous.
00:06:20.950 - 00:07:06.630, Speaker A: So you can't seem that all hardware has clock cycles. And then lastly, yeah, pre compiled contracts. They're a necessary hack that we had to do, right, because for performance. But if you had a very performant virtual machine, and you didn't have to rewrite Shaw three and Shaw 256 and EC recover, you could just compile it and run it on the virtual machine. You wouldn't need this pre compiled contract. So the end result here is we have a stronger vm. We can also have a more consistent interface.
00:07:06.630 - 00:07:44.730, Speaker A: So what would alternative, possible virtual machine architecture look like? So, if you want to look at hardware, a really nice one today is RISC five. So there's multiple. RISC stands for reduced structure set. So there's multiple variations of risk. And RISC five is, I think, one of the newest ones that has a lot of momentum. It's an ISA. It has open source.
00:07:44.730 - 00:08:11.102, Speaker A: Open source. It's an open source ISA. So the specification is open. Anyone can use it. But the people developing it also include open source hardware implementations. So the hardware is the rocket core that implements the ISA. So it's just like little teeny core, and then the whole cpu.
00:08:11.102 - 00:08:57.560, Speaker A: There's one implementation called low risk. So there's multiple implementations too, but one's called low risk that uses the rocket core. So the good thing about this is it's really close to the metal, right? It is metal and it's standardized. It's great, has tool chain compatibility. You can compile an EC or C Plus plus program and you can matter of fact just run Linux on it. It has a very clean design. But the bad thing is if you wanted to actually burn one of these things to chip, it's very expensive, so you probably wouldn't, you'd probably just emulate it.
00:08:57.560 - 00:09:39.910, Speaker A: Development with it is fairly tricky. It wasn't necessarily designed, it was designed for hardware people, wasn't designed for software people. If you're not burning it to chip, you're emulating it, then you're going to have to have to modify it some. It wasn't really designed for that in mind. Environmental info information. So like loading external devices like the blockchain and stuff, there's no strict way or set path to do that. It's assuming you're loading stuff into memory and then reading addresses from memory or reading information from memory.
00:09:39.910 - 00:10:41.830, Speaker A: And that's really unnecessary because in Ethereum we're not plugging and pulling out devices all the time, so there's really no point to have that architecture. And lastly, it's not necessarily portable as once again it's designed for hardware. So another alternative might be webassembly. The basic idea behind Webassembly is it's assembly for the web. Basically JavaScript wasn't fast enough for certain applications, so people realized that okay, we need a little bit lower level abstract than something really high in JavaScript. So they came up with Webassembly. Actually first the history was first they came up with ASMJs from Mozilla, which was a subset of JavaScript that made it really easy for interpreters to see sections of code in, turn them into JIT, and then was really performant, but it's kind of ugly.
00:10:41.830 - 00:11:56.894, Speaker A: Another alternative from Google was portable Pnapple, which allowed you to run compile Destiny C code and run it in a safe virtual machine. So those were sort of the predecessor to Webassembly. The current version of Webassembly is a new ISA that is designed to be pretty fairly low level, portable and fast, and also safe for web browsers to run. It is the result of the collaboration between Google, Mozilla, Apple and Microsoft, which of course implement all the major browsers, replaces Naple and some js. Another interesting thing about it is, even though it is fairly low level, it does have some higher level abstracts to it. So the instructions are specify some ast abstract tree semantics. So for example, functions, modules, and it has variables instead of registries, but they're really interchangeable.
00:11:56.894 - 00:12:58.130, Speaker A: So it's registry based, but we say variables, and it's really easy to represent in actual expressions, which is kind of nice. Okay, three minutes, skip that. So you have some ast semantics, which we're going to skip the ISA, the instruction set. So instruction set is pretty, I mean, okay, so what? People have been designing instruction sets for like a pretty long time right now, and they really haven't changed for the past 50 years. So no big surprise in the instruction set, right? It's eight bit bytes, twos complement integer, a little ending. It comes in two variants, 32 byte and 64 byte bit variant. So why would webassembly possibly good for using on a blockchain? Well, it's built to be performance, it's built to be jIt.
00:12:58.130 - 00:13:48.630, Speaker A: It's built to be jitted. It came from Javascript, which is really hard and dynamic to JIT, and it's based to be like a complement to something that is really dynamic but really not so dynamic and easy to JIT. Opcode compression is built in. Compression is pretty important on the web when you're sending bytes across the wire. So that's even more important in the blockchain. It's portable, it should be easy to run on many different architects. It already has LlVM backend, meaning you can compile anything you want to, LLVM can compile to it and target it.
00:13:48.630 - 00:14:39.646, Speaker A: This specification has a pretty clear specification, and they're working on a formal specification written no camel, and it's built to be run in a hostile environment. So what would you need to change to modify webassembly to work in a blockchain ethereum like environment, it needs to be fully deterministic. So webassembly already does a pretty good job of isolating non deterministic behavior. So that would be pretty easy to do. All you have to do is disable threads and a few operations that uses approximations that may be hardware based. You have to add access to environmental information. So like getting the block hash and getting different environmental information from the blockchain, and you'd have to add it.
00:14:39.646 - 00:15:37.190, Speaker A: Metering, that's a pretty big one. So yeah, this is the environmental information you'd have to add. As I said earlier, webassembly has the idea of modules, which makes it really nice to add this environmental information in. Since you could implement it as a module, you could implement Ethereum module then that would have different functions to query the blockchain state and that module would hook into the action late of code. So there's a clean path of how to embed this instruction set into external environments. So also another big thing is you would need backwards compatibility. And it turns out transpiling EVM code to WASM is pretty straightforward.
00:15:37.190 - 00:16:18.180, Speaker A: I like to do it in two different stages and this is not complete project but what you do is you would first translate it to waSm and then you would translate it to waSm plus metering, some metering code that would run on a normal wasm machine. But if you modified wasm so that you had the metering built in natively, you wouldn't do the final step. So that's why it's nice to have it compiled like that. And here's some images of how transpiling looks. But my time is up. All right, but thank you mark. Thank you.
