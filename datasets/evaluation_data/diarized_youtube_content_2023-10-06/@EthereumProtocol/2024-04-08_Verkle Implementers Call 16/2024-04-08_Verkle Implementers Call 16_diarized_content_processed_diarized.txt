00:00:07.720 - 00:00:38.774, Speaker A: Okay, let's get started. Hey all, welcome to Verkle implementers call 16. This is issue 1005 in the pm repo. The agenda will be shared here in the chat momentarily, starting things off with client team updates. Anyone up to start things off? Agnes?
00:00:40.474 - 00:00:40.898, Speaker B: Yeah.
00:00:40.946 - 00:01:37.232, Speaker C: Hi Agnes from the members seat, one team. So the last two weeks we finished implementing EIP 6800 that basically or captures the entire world state into a unified vocal tree. We tested it entirely with get and for correctness and consistency, and everything works to like, seems to work fine. Then we updated the new spec change for point to hash, and we incorporated that as well. And still all the test data seems to be consistent with get. Apart from that, in our in memory nimit worker tree implementation, we have almost reached full statelessness. We are just left out with the tests for proof of absence.
00:01:37.232 - 00:02:31.334, Speaker C: Those conditions. Apart from that, we are pretty much, again, correct and consistent with all the test cases of go. And we also benchmarked them, like, not very solidly, but we were just wanting to estimate the speed and they look decent so far. Apart from that, the major hurdle for us in integration is our entire accounts layer is very, like, under the hood, integrated with our database, and it's very much dependent on the storage try separately, which is giving us a hard time to refactor the code if it's like, if we spend too much effort on it, I guess we would shift to a path based storage. Yeah, that's pretty much the update.
00:02:33.594 - 00:02:34.362, Speaker D: Nice.
00:02:34.538 - 00:02:45.254, Speaker B: Just a quick question. When you say you have the same, like, it's consistent with. Guess you're only talking about the root computation, or do you also get the same gas consumption?
00:02:46.714 - 00:02:54.494, Speaker C: No, no, I'm just talking about testing it with the test vectors, because we haven't fully finished the integration yet.
00:02:55.114 - 00:03:05.906, Speaker B: Yeah. Okay, cool. Thanks. It's already pretty cool. Thank you very much. Okay, well, I guess since I'm unmuted, I'll go next. Yeah, we've been working on tooling.
00:03:05.906 - 00:03:37.848, Speaker B: We helped other teams with the, the interrupt, the testnet interrupt. We found some problems, some of them. So, for example, guest did not use the map to field. There was an accident. It's entirely my fault. So we're going to relaunch the testnet at some point, but we're making sure that everybody agrees with the rest of the guest model. Until then, we have made a presentation at EFP or EPF.
00:03:37.848 - 00:04:32.444, Speaker B: I never remember what it's called, but the ethereum protocol fellowship epfs. Yeah, we got some stuff merged into guests, so we have one pr that got merged and another one that's awaiting merge, but hopefully we'll make it soon. Inacio has worked on the explorer. We'll have a presentation about that. Yeah, I started thinking again to guests to some block after Shanghai so that we can produce some metrics like average proof size consumption, things like this that would be quite useful for people who keep asking about them. And yeah, there was more work on the revamp of EIP 4762 but I'll talk about this later. And Ignacio just updated Vercal info because it was quite outdated.
00:04:32.444 - 00:04:37.044, Speaker B: I think that's pretty much it. Ignacio, do you have anything else to add?
00:04:40.004 - 00:04:41.344, Speaker E: No, not ready.
00:04:46.924 - 00:06:08.224, Speaker F: Okay, I can go for Ethereum J's. So on Ethereum J's, yeah, we basically tested out the test vectors game has been giving us and made sure that we pass and basically debug some of the issues that came through and on constraint. Fine. Then we basically synced and found some of the issues in Ethereum J's and resolved that. Right now I think we are on the last mile where we are trying to resolve mismatching gas issues on self destruct and I hope that is the last stage. And so basically we are hitting this issue on block 261 and I think post that maybe we'll be good to sync rest of the testnet. And so for transition, what we are planning right now is that we, me and Gabriel have this plan that we will basically code the transition in a way that even without having having the Merkle straight, we'll basically pop off things from the Merkel state and try to match the Merkel straight rules straight route.
00:06:08.224 - 00:06:34.664, Speaker F: So this is our plan to implement and test out a transition. And once the worker state is also implemented in Ethereum J's then which basically would be the next step. Then basically we would also pop things back, pop things in the vocal straight during transition and then make sure that we match everywhere. Thank you.
00:06:38.884 - 00:07:08.124, Speaker G: I can go next. In Netherland we are also working on like syncing the constant testnet. We synced a few blocks and found a few issues in the Netherland implementation. And there is I think some discussion around the gas cost of cell destructs that is there. In parallel to that, I'm also trying to work on the transition, some part of it is implemented. It'll take two three more days to finally start testing trans. That's it.
00:07:10.264 - 00:08:05.106, Speaker D: On business side we are working on some improvements regarding performance. So we are added the batching for generation of the tricky. We are also batching the ash of the commitment. We are working in order to improve the update commitment part. And so yes, we can see some better performance, but we still have some work to do. We also finished some refactoring, so the merge with the main branch and block accessory is implemented. We are just waiting for the new Testnet in order to test the gas cost implementation and I hope that we will soon look at the proof validation in the Bezu side.
00:08:05.106 - 00:08:08.934, Speaker D: So it will be soon, I hope.
00:08:17.854 - 00:08:34.902, Speaker A: Any more updates? If not, I think that was everybody. We can move on to the next agenda item. Testing updates. I don't think we actually have anyone from the testing team here today, but Guillaume mentioned you may give a quick update here.
00:08:34.918 - 00:08:35.554, Speaker E: Guillaume?
00:08:36.214 - 00:09:21.308, Speaker B: Yeah, so very quick. I'm just helping them. So the idea is that we have this process that there's a transition, right? And we were agreeing on the tooling. For example, there's no implementation of any of the vertical primitive or crypto primitives in python. So I added a tool to compute. You just pass the address and the slot number on the command line and it will compute the key value for you. So we've had some back and forth on that, and then it became apparent that we would still need to export the mapping from the key back to the pre match.
00:09:21.308 - 00:10:07.554, Speaker B: So address and or slot number. This is because it's easy for them to check that all the keys that are given are expected, but if there are some keys missing, they don't know how to flag what specific account was missing. So there's some effort for us to provide such a tool to output the mapping from the hash to the preimage. But once they have this, we should have all the tooling necessary to at least test a full transition. So, yeah, slow, slow progress. Not very impressive, at least not announcement worthy, but it's progressing.
00:10:11.214 - 00:10:18.594, Speaker A: Nice. Thank you for giving the update. Cool. Next up, the witness explorer demo from Ignacio.
00:10:21.934 - 00:10:46.894, Speaker E: Hey. Yes, so this is something I've been working mostly in the previous week. Last week, I'm sorry. So I will share my screen so we can make this more interesting. Give me a second. Okay. Is this working?
00:10:47.834 - 00:10:48.586, Speaker A: Yep.
00:10:48.730 - 00:12:18.334, Speaker E: Okay. Okay. So what is this witness explorer thing? One of the first things that I remember when I started working in Berkeley stuff was like this realization that the code for executing contracts will be part of the witness, and a big addition to the witness, like the witness size might depend on how much code is executed, and you are going to be charged whenever you execute a contract for all the cold chunks that are needed. So clearly this will add some new, like, let's say dimension into gas accounting for contract developers to understand how much adding the code impacts their gas for the transaction execution. So what I did is, okay, so first of all, I'm not like a web UI person, so I'm sorry for if it's not like a really nice UI, but what I did is something like a blockchain explorer, but to understand better what it's in the witness for transactions. Okay, so currently this is live, let's call it in gaussian. I deploy this like in my machine and you can access, everyone can access through this website, which is like a subdomain of my site.
00:12:18.334 - 00:13:33.374, Speaker E: We can later like move this somewhere else, but if you want to test it, you can use it here. Basically the landing page is, I'm showing two lists. One is like the top ten highest transactions as to like for people to really have a starting point and start looking at things if they want. And I have another list that I call the most inefficient code access transactions, which hopefully will make sense later. So if you click on any transaction or you look for a specific transaction here that you are interested, you will see web like a page like this one. So this first example is a transaction on Kaustinen that I did for deploying and like a, like an ERC contract, okay, that is was like kind of real contract. So the things that I show here is like well get a transaction hash, some like basic transaction information, like who is sending that and where and how much it and the block number.
00:13:33.374 - 00:15:11.428, Speaker E: Then I show the total gas, which shouldn't be surprising. And then I show like a de aggregation of this total gas into the execution gas, which should be understood as like the usual kind of gas that you already pay today for things, you know, like opcodes, instructions and things like that. And I de aggregate also what, how much gas comes from witness additions that aren't code related. And I will explain this a bit later, and how much gas comes from cold chunk accessing, okay? Which was like my original motivation for doing all this, since this is like a contract deployment, because code chungas has like zero value. I will show another transaction later with some more interesting case. But at least you start to see like the idea of, you know, if you want to see how verkle changes the gas expectation of your contract, then you can start like looking at these three numbers separately. Then in the execution section I show how many instructions were executed, how many bytes were executed, like considering that there are instructions with more than one byte, then I show how many bytes were charged.
00:15:11.428 - 00:15:52.710, Speaker E: So in this case it's zero because no code was executed. And then I show something called that I invented the name. It's execution efficiency. But let's look at this later in another transaction. Then in this witness charges section, I show every addition to the witness that charge a non zero amount of gas. Okay? And I exclude cold chunk additions. So basically, since this is a contract deployment, you will see the contract creation unit costs, which was this amount of has.
00:15:52.710 - 00:17:03.754, Speaker E: And then we did some s load and s store for this contract at this storage slot, this storage for the same storage slot. And then we did something else with another Torres slot. And then you get charged the contract creation completion cost. So at least like someone can look at these things and start to understand better or have a better intuition of where these witness gas costs are going. Okay, so basically all this is trying to detail these costs, and all this is trying to detail more this cost. Okay, and then I have another section, which is windows key values, which is similar to the stateless tab in the door explorer that I think I can show now because it's not available. But in the stateless tab in the door explorer, we have the witness key values that were added in the witness, but at the block level.
00:17:03.754 - 00:17:33.644, Speaker E: So I go, I went like a step further and said, okay, let's do this at the transaction level because maybe we want to understand how a transaction, which keys were added to the witness from a particular transaction. So for example, here you will see that, you know, this is probably the key of the contract that we created. And we can see that.
00:17:36.144 - 00:17:36.632, Speaker A: Now we.
00:17:36.648 - 00:18:43.724, Speaker E: Have the first, you know, this four less five values have the nodes, the cash of the contract and things like that. Other internal nodes, probably. So this is like a bit more maybe detail information per transaction of which things were added to the windows. So probably, maybe this will be helpful for debugging stuff. Yeah, so that's kind of the overall view of the UI. So to look at another example that is a bit more interesting, I deployed in Gaussian the, if you know about remix, it has a basic project that as an example is like a contract for voting and delegating votes and things like that. It doesn't really matter what it does, I just wanted to have like a bigger contract and like a longer execution of real code.
00:18:43.724 - 00:20:25.944, Speaker E: And basically I deployed this test contract that is part of the project. And I called this before all method, doesn't matter what it does, but basically it pushed something into the storage and instantiates like the valid contract with some parameter. Okay, so if you, if we look at this transaction execution, yeah, you can look at it with the extraction hash user. Like the basic information, as usual, we see that the total gas is this amount, and we see like a more interesting distribution of the cost in like the usual execution gas, non code witness gas, and cold chunk accessing gas, which in this case it isn't zero because it's actually executing code in the execution type. In this case we see that the amount of bytes that were really touched during the execution is this amount, but you were charged like a much bigger amount because remember that you are charged chunks of 32 bytes. So my point here with this execution efficiency is trying to get an intuition with a single number of how efficient is your transaction execution or your contract design. Because like in the worst case scenario you will be maybe like jumping all over around the contract, and that is will be pretty terrible because you will be charged with a lot of bytes that you are not using.
00:20:25.944 - 00:22:11.714, Speaker E: And for example, in the other extreme, if your transaction execution is like a tight loop in a single call, chunky, like you will be executing a lot of bytes, but you will be only charged a small amount because everything happens in one chunk, let's say. So this execution efficiency, maybe it's like not really the best name, but that's what I thought is basically the ratio of how many bytes you are actually using compared to the amount that you were charged. Okay, so ideally you want this number to be high, so you are not paying for a lot of code that you are not really using. How much of this really depend on? How much of this depends on the contract developer. It's not an easy question to answer because maybe some of it can be controlled by the contract developer, because you can think more of trying to shampoo all around if possible. But a part of this course is also related to compilers that maybe now have to understand better how to, you know, maybe with some hints or something, try to compile things in a way that like the execution of at least important methods don't really jump around that much. So in the witness charges we see a bit more interesting things.
00:22:11.714 - 00:23:28.814, Speaker E: So remember that in this method we have some storage changes and we kind of created a contract with some parameter. So basically, yeah, you can see some slow and stores, you can see a code copy which has a witness edition that is pretty relevant. I have the create opcode that also charges some other stuff. You can see here the contract creation completion and some extra laws and stores later. So the idea here is again all this stuff trying to shed more light into this cost and all this stuff trying to give more detail about this cost. So if you already see that in this case the cold chunk accessing is 4% of the total, then spending a lot of effort like caring about this stuff. Maybe this doesn't make sense and makes more sense to just like understand if this makes sense or you can have any control in improving this but maybe if this is like 25% of the total.
00:23:28.814 - 00:25:24.514, Speaker E: I know maybe you want to think about something regarding cold chunk accessing the Windows key values is like a lot of things. So something really important to clarify now is that in the current testnet we don't, we aren't really, we haven't implemented the tank field cost in the like in the gas accounting. So if we look at, let's see if we look at the ip you can see that the usual like the gas cost that we implemented in casting are these four ones. You have like the read cost, let's say the usual write cost of the branch and the chunks but there's like an extra cost that is like the chunk field cost that we should charge every time we write a value in the tree that has an empty, that was empty. So we are kind of adding state and this gas is like pretty significant. So you should have in mind that like I think it's okay to use this today to you know start to get a sense of some stuff. But don't, don't take like the current gas using contracts as like the final number because if any of these store or related operations that add state to the tree are fresh rights you should be charged with this cost which isn't negligible.
00:25:24.514 - 00:26:22.994, Speaker E: So please have that in mind. Probably not in the next testnet but maybe in the other we can think of trying to start charging that and whenever that's the case you will see here that cost appearing too. So yeah, I mean hopefully this will be useful for like maybe ask or developers trying to debug some particular difference in the gas between clients and hopefully for contract developers trying to you know come to calcinent deploy their thing, come here like run a transaction that calls the most you know use methods. I just paste the hash and start getting an intuition of like what is the cost and where, why that is the case and things like that. So yeah, that is my presentation.
00:26:28.974 - 00:26:38.844, Speaker A: Awesome. Thank you Ignacio. Super cool. Okay, next up gas model updates. Guillaume.
00:26:40.504 - 00:27:11.844, Speaker B: Yep. Let me share my screen. So I'm just sharing some ongoing discussion. It's by no means the latest version of the spec. It's to give a sense of how the spec could evolve. Ultimately all of this will be decided in the interop in a couple next month actually. But yeah, just want to give a heads up on what might happen.
00:27:11.844 - 00:28:27.054, Speaker B: So the first thing is that currently for those who know the spec, eap 4762, when you have a call to either any type of call, so delegate call, static call Poland and I forget the last one call code you get like you touch the version and you touch the size leaf key. So it appears that this is actually incorrect. We should. So the intuition here is that everything that touches an account touches the version, the potentially the balance and the nonce, and everything that has to do with the code touches the size and potentially the hash. So the modification is that instead of charging for the code size lift key, we would replace it with a non sleeve key. And then when you either do xcode size and xcode copy, you would touch the code size leaf key. And if you call Xcode hash, you would touch the code hash leafkey.
00:28:27.054 - 00:30:03.754, Speaker B: So yeah, that makes things a bit more expensive than they currently are on the testnet, but it feels more correct, at least from intuition point of view. Just a quick remark that geth does not currently touch the when calling a contract guest does not use the size, but it's using the hash. So here when you do a call, it would make sense to touch the, I mean if things were left as they are today, it would make sense to touch the hash and not the size, but in a stateless context, you want to know where the code ends so that you know what to look for in the tree and not go randomly in the tree looking for things that are not there. So it makes sense to replace it with the code size. And yeah, there's, there was also a discussion about making it like touching, making the touching of balance leaf key unconditional. This is because it matches the historical behavior, namely that when you load a contract, the, the account is packaged together as an RLP payload. So to be aligned to this behavior, you would also have to unconditionally touch the balance leaf key, unlike what is currently specified in which you just touch the balance if your call is value sending.
00:30:03.754 - 00:30:44.324, Speaker B: And in a way that makes sense because something that is not specified on this slide. But there's another reason to do this. It's because when you do a. Actually no, sorry, that's wrong. What I was going to say is wrong, so forget it. And yeah, the other reason to touch the balance, actually, I don't know why I wrote that, sorry. But anyway, so the other question that was asked was do we need to, do we really need to use version leaf key? So there was a question asked by Jejinder if I'm not mistaken.
00:30:44.324 - 00:31:42.094, Speaker B: So I would say in terms of, if you look at the gas accounting, it does make sense because you currently, when you do a cold account cost, it costs 2600 gas. And if you look at the cost of reading four entries, so namely the version, the balance, the nonce and the size, you get about the same, the same value. Of course, if you decide not to use the version, it would be 2500. So it would still be roughly the same value. But yeah, you could also see it another way. If you don't include the balance like was discussed in the previous slide, you would get 2500 and then half the time you would charge an extra 200. So on average it would be the same cost as 2600.
00:31:42.094 - 00:32:21.552, Speaker B: But yeah, the other reason to keep leaf key is for forward compatibility. So this is something that is still up in the air once again, I expect the resolution next month at the interop, but I just wanted to share this thinking. Yep. And the next slide is for. Is for another topic. Yeah, so that's pretty much the current state. I don't know if there are questions, but yeah, don't worry if something feels a bit too sudden, it's just a discussion.
00:32:21.552 - 00:32:25.004, Speaker B: And yeah, the point is to get the discussion started.
00:32:30.504 - 00:32:38.804, Speaker A: Cool. Thank you Guillaume. Next up, I think it's also you, EIP 29 35.
00:32:40.194 - 00:33:12.454, Speaker B: Oh yeah, yeah. So actually it comes from the conversation. It's a very short one. It comes from a conversation at Acde last week. Oh, sorry. Two weeks ago we were pushing to get EIP 29 35 included in Prague and at some point Vitalik said, yeah, we should increase the buffer size, the ring buffer size to 8192. So two to the power of 13.
00:33:12.454 - 00:33:29.974, Speaker B: I have no problem doing this. I just wanted to collect any feedback or people taking exception with this. But if not, I suggest we try to extend the buffer size to 8 kb.
00:33:34.614 - 00:33:39.954, Speaker A: Do we have any extra context on the reasoning for bumping it up? What was it?
00:33:40.494 - 00:33:49.710, Speaker B: No, I'm laughing because I saw Galzinder's comment. We should go all the way. So sorry, what was the question?
00:33:49.862 - 00:33:52.514, Speaker A: Just the context for Vitaliks.
00:33:53.934 - 00:34:36.054, Speaker B: So the context is that 256 blocks is very short and no one really cares about this short of an story. Because for example, if you have a ZK roll up that needs to access, that needs to make a proof, it will take quite some time. And by the time the proof is ready and they would need the block hash to compare or to use in their proof, or to verify their proof, the 256 blocks will already have elapsed. And so extending that value to. I think it's. I actually didn't compute, but it's. I think it's like a day or something.
00:34:36.054 - 00:35:07.384, Speaker B: At least it's more than 1 hour, because I think 256 gives you about 45 minutes, which is too short. So yeah, that's, that's the idea behind it. Not inflate the state all the way like gedgender suggests, but. But at least give you enough of a buffer that you can take your time to produce very slow, like, proofs that are very slow to generate.
00:35:10.564 - 00:35:13.344, Speaker A: Got it. Ignacio?
00:35:15.124 - 00:35:50.404, Speaker E: Yeah. I have a question that I think we have touched on some previous calls. So this proposal, having like a longer history of block hashes is going to affect the block hash instruction scope, or this like longer history will be only accessible through some, some kind of other system contract interface or something like that. Like thinking of like if this going to be a breaking change for block hash instruction.
00:35:51.414 - 00:36:38.642, Speaker B: Yeah, that's a very good point. I didn't think of that and that's. I think it would make sense exactly like you said to. I mean, I'm not a fan of having at least the update being done via the EVM bytecode, but we were talking when we discussed the deployment method to offer a get function that would, that would be able to, that would be EVM based. So you would just call that contract's get function and give a number that is larger than 256 while still retaining the standard behavior of block hash. And that would probably be the best approach to break as little things as possible. Yeah.
00:36:38.642 - 00:37:00.874, Speaker B: Ok. That's one item to add to the discussion. Yes. I also saw Karen's comment. Yeah, I'd be up for that in the next, in the next testnet, if everyone is okay with it.
00:37:06.014 - 00:37:12.614, Speaker A: Looks like thumbs up to that. Yep. Cool.
00:37:14.354 - 00:37:15.002, Speaker B: Okay.
00:37:15.098 - 00:37:21.734, Speaker A: I think next up, you also had a quick update on 7545, the proof verification precompile.
00:37:27.074 - 00:38:00.018, Speaker B: I had to unmute, of course. Yeah. So indeed there's been some back and forth about 7545. So initially we wanted to have it in Prague, then we decided maybe it's not necessary because optimism, who was initially interested in it, is no longer interested in it. And then I had the conversation with Polygon about this. They were interested in it. And so the API that I proposed would have been to call verification.
00:38:00.018 - 00:39:00.914, Speaker B: You would pass the route, you would pass proof, which is a byte payload that is opaque. So the precompiled self itself would decide if this is an MPT proof because we're at an MPT height, or if it's a vertical proof because we are at a vertical height or whatever kind of proof scheme we want to use in the future, and then have one key and one value and verify that this matches. So the key would have been a 64 byte value because we could potentially support or at least extend the key format in the future. So, yeah, prefix it with twelve zeros, then 20 bytes for the address, then the slot number, which is 32 bytes, and that would only be necessary to prove values. So storage, storage slots. Now, Jordy, that's not what he had in mind. I'm still having the conversation.
00:39:00.914 - 00:39:44.414, Speaker B: So I didn't get to the end of the conversation before, before we. Before this call. But given the fact that this is not really what Jordy had in mind, and it doesn't really look like a proven precompile, what he had in mind, the fact it's not really interesting for optimism, I think now is the time to do some deep soul searching. Can we find any bridge or l two or DAP? Which. For whom? That would be interesting right now that doesn't come to mind. So I suggest that we spend maybe the next week looking for this. For who? For a person that would be interested.
00:39:44.414 - 00:40:04.314, Speaker B: And if we cannot find anybody, or we cannot find anybody with a clear, very clear cut and strong, compelling use case, we just abandon this for electra or, sorry, the other one. Yep. So that's, that's pretty much it for this topic.
00:40:07.654 - 00:40:14.114, Speaker A: Awesome, thanks. Cool. Testnet relaunch, which I think is also you, Guillon.
00:40:16.974 - 00:40:53.958, Speaker B: Yeah. Okay, so I need to share my screen again. I don't know why stopped, but. Yeah, so the test relaunch. Okay, so something is missing in this slide because we just talked about using the updated version of 29 35 with the eight kilobyte buffer, so that would be one change. We would add the explorer from Ignacio to this testnet because it's proven very useful to debug. I mean, that was the purpose, but it serves that purpose.
00:40:53.958 - 00:41:23.704, Speaker B: So that's really, really good. We currently identified. I would say we, but it's. Gajinder identified an issue with self destruct at block 261. So before the relaunch, I would like to at least get to the bottom of this issue. I know Aave is planning to deploy their contracts on the testnet, so I would have to coordinate with them so that they relaunch. So they try doing this on the new Testnet instead of the current one.
00:41:23.704 - 00:42:04.068, Speaker B: And there was another point, there was another problem, and it's entirely my fault. I did not, I got mixed up with all the revision numbers and I did not rebase. So to the right, to the right revision. So Geth was using the old key format, so not map to field, but the compression. And that will be fixed in the new Testnet. So yeah, that's pretty much everything we want to change for the new relaunch. I just would like to know if someone has any other desire for the new Testnet.
00:42:04.068 - 00:42:18.874, Speaker B: But barring this, we should be good to go and we should do it this week because it's blocking Bisu and yeah, there's not that many changes, so it should be done fairly quickly.
00:42:27.534 - 00:42:37.354, Speaker A: Cool. Last up on the agenda, Ignacio had a few thoughts on the black, sorry, block hash corner case you wanted to share.
00:42:39.254 - 00:44:03.864, Speaker E: Yes. Um, so I think was on Thursday or last week, I was looking at some coding get and I realized that we weren't charging correctly the block hash gas. While fixing that, I realized that there might be a corner case that we might want to discuss or to do. And it's the following. So if you imagine a contract using the block hash opcode asking for the hash of the previous block, technically speaking, the way that we are thinking of 29, 35, we are adding this block hash to the witness at the kind of system level because we are kind of creating the history. So this block hash is already added to the witness. So any contract in that block that use the block hash asking for the hash of this previous block, technically speaking, shouldn't be charged any gas for doing that because that tricky is going to be added anyways because we are building the hash history.
00:44:03.864 - 00:45:17.644, Speaker E: So yeah, has some kind of discussion a bit around this, if we should like charge zero for this corner case of asking the block hash for the previous block or not. And there might be, you know, maybe different opinions because I know this is kind of coupling, like if we charge zero, we are kind of coupling the gas cost of block hash with 29 35. So maybe we don't want to do that and keep things simple and simply charge the gas as usual as any other older blockhash request. So yeah, I just wanted to surface this case and see if somebody else has strong opinions. I don't. But if we decide to do something special, we should add this clarification to 47 62 because it would be like something to clarify. Yeah, just like software in this topic.
00:45:20.224 - 00:45:28.644, Speaker B: Just to specify one thing, it wouldn't be zero, right? It would be 100. Like it would be the warm cost of loading the to contract hash?
00:45:29.984 - 00:46:04.084, Speaker E: Yeah, yeah. I mean, like, witness costs, is anybody like, in favor of not. Of doing this kind of cash optimization of not charging the witness addition for the previous block hash? It looks like the answer is no. So we want.
00:46:04.124 - 00:46:06.504, Speaker F: Sorry, can you repeat this?
00:46:07.084 - 00:46:57.148, Speaker E: Right, so to give like a TLDR of what I said is if a contract is executing the block hash instruction, asking for the hash of the previous block, technically speaking, that witness addition will be done anyway by the chain because we are building this blockhash history in 29, 35. So technically speaking, we could charge this contract zero of witness costs because this branch will be added anyways to the witness. So, like, contrast could assume that always the previous block hash will be in the witness. So you are getting this for free in quotes. Regarding witness costs, we are already not.
00:46:57.196 - 00:47:00.224, Speaker F: Charging witness cost for block hash.
00:47:02.404 - 00:47:06.824, Speaker E: Right, but that sounds like wrong, right?
00:47:08.924 - 00:47:32.384, Speaker F: Not essentially in the sense that, for example, if block hash, I think I also wrote this up in the print to the PR, which might be merged as well. So basically what I essentially wrote was that one could, the clients could just keep last 256 or maybe, you know, when we go to 8196, whatever.
00:47:32.424 - 00:47:32.808, Speaker B: Yeah.
00:47:32.896 - 00:48:24.064, Speaker F: So those in the memory and can serve from there. So basically, client architecture, if I see as a full client running, they can just keep on maintaining this in the memory as they do maybe currently right now. And I actually don't feel that, you know, there should be any extra excess cost for block hash, because this is something that we can make sure that we can keep low by maintaining it in the memory. Or if you don't maintain it in the memory, then still I don't feel that, you know, we should charge extra for block hash. That way, you know, the contracts which are already deployed, so will be backward compatible to that if they are assuming any sort of cost for this particular opcode.
00:48:27.644 - 00:48:39.404, Speaker E: Okay, so this is like a special case in which there are something that is increasing the witness size and isn't really charging for that. That's kind of an exception to the main rule, let's say.
00:48:42.344 - 00:49:10.744, Speaker F: Yeah, I think I mentioned this in the EIP PR as well, and sort of was sort of, you know, under the impression that, you know, we all are on the same page with regard to that. But yeah, we can, we others can also weigh in and on this particular issue, but I think that we don't need to. We shouldn't be charging extra for the block cache because it could just be served out of memory.
00:49:18.804 - 00:49:42.976, Speaker B: My question is, and that was my counter, do we really need this because who's going to be willing to use block hash for the last block that was produced? Like, is there really a use case for this? I. I don't see it. Typically, people generating proofs are way too late for. For the next. For the next. Well, to. To ask for the block hash for the previous.
00:49:42.976 - 00:50:15.984, Speaker B: Of the previous block. If. If there is a use case, I'm happy to change my mind, but currently I think it's a very corner case ish, very, very specific use case that no one really needs. And it might make things a bit weird for whoever doesn't know the AIP by heart and does not understand that. But at the same time, it's the. My counter. The counter to my counter is already included.
00:50:15.984 - 00:50:34.764, Speaker B: If this is not a problem that will really ever occur, then they will never notice that there's something a bit off. Yeah, I don't think it's really hard to do. I just wonder if it's really worth the complexity.
00:50:39.704 - 00:50:55.174, Speaker F: So just to mention that we don't charge for blockhacks block hash access, even if it's more. It's previous than the ancestor. So basically, any of the block hash access we don't charge.
00:50:59.074 - 00:51:04.174, Speaker B: Yes. Okay, maybe I misunderstood what you mean, but we at least charged the warm cost.
00:51:08.434 - 00:51:16.774, Speaker F: Which cost, I think we only charge whatever is the opcode cost for the block cash, and we don't really charge an excess, although we create the access.
00:51:17.714 - 00:51:31.294, Speaker B: I'll get back to you offline because I need to double check the code, but I'm pretty sure we do something called a check account, and so that will return our account check, and that would return a warm cost, but. Okay, I'll get back to you offline in like, ten minutes.
00:51:39.154 - 00:51:55.404, Speaker A: Cool. Okay, I guess before we wrap things up, there were a couple of questions from milos in the discord. I was wondering maybe we could quickly answer around how to get a vertical proof for a block from Testnet, if anyone more familiar with that.
00:52:00.104 - 00:52:19.134, Speaker B: Yeah, we. I mean, just sync. That's the easiest way. We could tweak the explorer, maybe Ignacio, to provide the proof, because presumably we look at those proofs so we could save them and provide them. What do you think?
00:52:21.794 - 00:52:46.274, Speaker E: Yeah, I was thinking maybe in the near future to also show some, like, block information so we can. Yeah, maybe allow downloading the. The witness bites and also show, like, the witness ties and other things that might be interesting. So, yeah, we could add it there.
00:52:47.094 - 00:53:15.764, Speaker B: It depends what his. What Miloski, who I think left is interested in checking because Dora, who unfortunately is currently down. Dora offers some insight into the witness itself. So if that's all you need, it's already present on Dora. Otherwise, yeah, we would need to explicitly provide some, some way to display or download the witness from any of the explorers.
00:53:18.584 - 00:53:38.294, Speaker H: Yeah, I was mostly just thinking about being able to process and analyze that data, maybe by myself or something. That is one use case. And another question that was also on discord is, is it possible to run a stateless client at the moment and how just instructions or something.
00:53:41.554 - 00:53:49.654, Speaker B: That would be question for Gajinder and or Tanish, but guess is not able to do that.
00:53:57.174 - 00:53:59.874, Speaker F: So what exactly do you want to know, Midas?
00:54:01.454 - 00:54:10.114, Speaker H: Is it just possible to run any of the clients in a stateless mode and the instructions on how to set it up and get it running?
00:54:11.774 - 00:54:12.150, Speaker B: Yes.
00:54:12.182 - 00:54:15.862, Speaker F: So reach out to me, I can maybe help you run Ethereum Js.
00:54:16.038 - 00:54:17.314, Speaker H: Okay, thanks.
00:54:20.054 - 00:54:28.344, Speaker B: And actually could you also export, because you will download them this way, would you be able to export the witnesses like the JSON payload?
00:54:32.724 - 00:55:05.364, Speaker F: Yes, we basically. So Ethereum G's has a spec script where basically it pulls off the JSOn payload and then plays it. So what you're saying can happen like that if you want to play some particular block or some particular set of blocks, and Ethereum js can also run in the manner that it can basically serially get the blocks and execute them like a normal client would.
00:55:19.124 - 00:55:28.664, Speaker A: All right, I think that was it for today. If nothing else, we can end there. Thank you very much everybody. Anything else? Oops, sorry. Anything else?
00:55:30.444 - 00:57:05.974, Speaker I: I have a question. I have a question that's currently because I'm new to this group and it's the first time, first time I come to the meeting. So now I'm exploring the further optimization solutions to make use of the reuse of the proof. That means that if the proof of a recent visit, or of a story slot, or the siblings, or the adjacent stores of the story slots, or there's recent updates to one of the either the start of other adjacent losses, then I think that the vertical proof to prove that recent event could be reused again to reduce that, to reduce the proof that time cost. And now I have this idea and I hope to do some research and to find if there's more space to reduce the gas cost for the vehicle proof. What do you think about that? But I think that because of the time of the meeting, I think that we can discuss it after the meeting and I would directly mention you.
00:57:07.614 - 00:57:19.550, Speaker A: Yeah, that sounds good. Thanks for the quick thoughts. Since we're running low on time if anyone has anything, any thoughts there. Otherwise, we can maybe take it offline or async and in the discord.
00:57:19.742 - 00:57:20.574, Speaker I: Okay.
00:57:20.734 - 00:57:48.330, Speaker B: I mean, all I want to say is, okay. We received your present, your document. We need some time to review it. The first outline seemed like it's something that cannot be possible. But if this is indeed correct, we're really happy to hear about it. But we'll get back to you when we have read the document and we can set up a call.
00:57:48.482 - 00:57:52.974, Speaker I: Okay, great. Thanks.
00:57:55.154 - 00:58:00.246, Speaker A: Yeah, of course. Thanks for joining. Thank you, everybody. We'll see you in two weeks.
00:58:00.390 - 00:58:02.118, Speaker I: All right, see you next time.
00:58:02.246 - 00:58:03.854, Speaker B: Thanks. Bye. See you. Bye.
