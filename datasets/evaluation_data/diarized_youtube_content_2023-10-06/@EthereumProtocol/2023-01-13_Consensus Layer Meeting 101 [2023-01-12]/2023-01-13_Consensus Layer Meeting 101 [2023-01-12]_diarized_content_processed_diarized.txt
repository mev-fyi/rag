00:00:00.570 - 00:00:53.130, Speaker A: Okay, let's transfer it over that. Welcome to consensus there. Call one. This is issue 70 two on the pm repo. A lot of minor capella discussion points, some status update name discussion for four four four. And then some light client endpoints for the Beacon API to discuss before we get into technical discussion as we approach interop in a couple of weeks. What's our Capella testnet status update? Harry or Barnabas?
00:00:53.630 - 00:01:49.114, Speaker B: Hey, yeah, so we had withdrawal Devnet two launched yesterday. There's a couple of bad blocks that need to be figured out, but I think they're mainly from Ethereum Js, but otherwise we seem to be doing good. We're testing withdrawals, et cetera, and everything looks okay so far. We're going to be launching a bigger, more public version of today's Devnet next week. And the idea is that general public can also start getting involved trying out withdrawal tooling and hopefully we have some documentation and some deposit guides, et cetera, up there in time. And another testing update is that we got the first withdrawal shadow fork working earlier today. So I was able to shadow Fork Sepolia into a mini withdrawal testnet.
00:01:49.114 - 00:02:13.506, Speaker B: Everything looks stable and good so far. Thank you for Adrian and Marius for some debug support there. I still have to try it with all the clients though. I just tried it in a small amount so that I could test the tooling. Tooling seems to be good, so now I'll try something bit bigger. So we should be good for a main net shadow fork in a couple of weeks. I think that's all the testnet updates.
00:02:13.538 - 00:03:06.390, Speaker C: We have so quickly. Going over the issues on Devnet two. Today I started sending some transactions, like handwritten transactions that should trigger stuff on Shanghai. And there were two bad blocks created by Ethereum Js. One contained a transaction that triggered the warm coinbase and the other block contained a transaction that had a huge amount of init data in it. Yeah, Ethereum Js should look into that. Another thing that I wanted to talk about is on the fork monitor.
00:03:06.390 - 00:03:48.550, Speaker C: On the fork monitor we have these bad blocks, right? Like some of the nodes collect bad blocks and we can display them on the fog monitor. What's really interesting to me is that there are four bad blocks seen by piso nodes that are not seen by any other nodes. And so it would be really interesting, really important for the BISO team to look into why they see those bad plots that no one else saw. And apparently.
00:03:50.330 - 00:03:51.270, Speaker A: I have no idea.
00:03:51.340 - 00:04:11.680, Speaker C: They are not part of the canonical chain. And so that's why we don't have a consensus issue there. So they might be reor but yeah, would be good to investigate from the Visa team and then the Ethereum JS team is already working on stuff.
00:04:14.530 - 00:05:05.204, Speaker A: Thank you. Thank you Mars. Any questions for Perry or Mars? Ok, great. Thank you. I know there's been some discussion about this both on the consensus layer call two weeks ago on all core devs last week and on the chat. Essentially the way that the commitments routes work across the consensus layer and the execution layer for both transactions. And now withdrawals do not allow for simple support of the consensus layer like client kind of inserting a block or block header into an execution layer without additional information, without downloading essentially the header to get that information.
00:05:05.204 - 00:05:43.070, Speaker A: So I'm not caught up on where people want to land on this compromise. Making the withdrawals commitment and SSD commitment on the execution layer is one thing. I do think that it would be quite hasty to change the transactions commitment given that tooling and or smart contracts might be relying on that and we don't have a good handle on what we would be breaking. But that's my take. Without having dug deep into the conversation, does anybody else want to provide information or where kind of the decision point seems to be standing at this point?
00:05:43.600 - 00:06:07.910, Speaker D: I can give an overview from prism side. Although we're consensus alliance, maybe we don't have much say in this, but I think our general consensus is just like if this delay withdraw, then our vote will be a no, just trust. We don't feel like it's right to keep adding future towards the end which delays withdraw and that's just our point of view.
00:06:11.500 - 00:06:54.280, Speaker A: Got you. Does anybody else want to weigh in? I mean obviously there can be to resolve this in a fork. In general, the work can either be changing the consensus structures to include the execution layer commitments, or to change the execution layer commitments to be that of the native consensus layer commitments or some combination of those. I did catch when that there was some eagerness to change the withdrawals commitment to SSZ. Does anybody else have a status update or read on that? Sorry, there's some hands up please. If your hands up, go.
00:06:55.930 - 00:06:56.390, Speaker D: Yeah.
00:06:56.460 - 00:07:44.390, Speaker E: So on behalf of Aragorn, I agree Danny that we shouldn't tackle transaction route in this release. But I think for withdrawals route we should switch to exactly the same route as NCL. So that probably entails switching to Guay and also to FSD commitment instead of RLP plus Merkel. So that makes sense to my mind. And in Aragon we've already started working on some CL code. We have light client Cl embedded into, so and we have some SSZ code. So for us it should be relatively easy code wise.
00:07:47.550 - 00:08:24.674, Speaker A: Got it. Mark. I think it is generally a bit too late for changing the coding because we are passing all hive tests now. We have working Devnet. Basically almost all pairs of clients are working fine and withdrawals are much anticipated feature by community. I don't think that technical dev that we will introduce is worth delaying withdrawals. And we have SSZ library developed by us, but the main risk for us is that it wasn't battle tested.
00:08:24.674 - 00:08:53.250, Speaker A: On the contrary, other libraries are used by CL clients. It was developed a few years ago and we just started touching it again, I think like moving to SSZ in 4844, give us time to verify this library correctly and check with existing tests and give us better confidence about the code. Got it. Thank you. And Matt?
00:08:54.630 - 00:09:40.478, Speaker F: Yeah, so from the, you know, we were weekly in favor in terms of kind of delaying, in terms of putting the SSE encoding in, we feel like we can have it ready for the interop. We again weekly in favor of being forward looking and reducing kind of the tech debt around this for the short term because we're not sure that we won't be making the changes again anyway in Cancun. So focusing on the withdrawal route to reduce that kind of need to support that weird piece of history between the two forks is kind of what we're looking at on our. Not again. To echo the other point, we're not thrilled that it's kind of the week before interop that we have an invalidation of all the prior testing and a.
00:09:40.484 - 00:09:41.310, Speaker G: Lot of this other stuff.
00:09:41.380 - 00:09:51.060, Speaker F: But we're not too concerned about what we see as a small delay. But we're only weekly in favor of adding the SSE encoding for the withdrawal route to match.
00:09:53.990 - 00:10:45.580, Speaker A: Got it. Do we have a specification that works here? Because it's not only guay, but it's also. I apologize, little India. So has anyone actually kind of gone through the specification work or worked through what this looks like in terms of the encoding? Micah, you sound very far away. I believe it was you speaking. Mikael, you have your hand up. It's just a copy of the Cl spec, right? Nothing special, correct? I mean, it's using the SSC encodings.
00:10:45.580 - 00:11:39.504, Speaker A: Mikhail? Yeah, I just want to pay attention to one detail. If we are considering switching el to Gray and we are not doing it etching high, but trying to do it later, then it might be more difficult to do because everyone will represent them, everyone will read those amounts as weight. And yeah, that's going to be a bigger change than of now. Well, there's two. I mean like everyone. One is to encode the withdrawals as GWE and the other is to encode just the representation of the withdrawals in the commitment as way. And I don't know if there's consensus on which to do.
00:11:39.504 - 00:12:09.784, Speaker A: There requires more changes than the consensus layer to send it in that way. Yeah. Having a different representation of withdrawal just for commitment purpose sounds like really dirty, but I don't know. Can't say that it's really bad or photos. Sure.
00:12:09.982 - 00:12:46.768, Speaker D: I just wanted to point out that this is not really an implementation issue. It may sound that it's easy and it's actually easy, but there are design decisions to make. You just mentioned this issue of having weight or weight at different layers. This involves also on the Cl side whether or not we are going to change the encoding, because we change from weight to weight to send it and endeavor to send it. And this has to be changed. So depending on which design decision you have, then you're going to have changes on both sides or only on the el side. And this has to be tested.
00:12:46.768 - 00:13:02.270, Speaker D: I believe that if we switch to thinking of this as a design problem, not as an implementation problem, this should be taken out of Shanghai because we're not at a stage where we're designing the port, we're implementing the port already.
00:13:05.120 - 00:13:23.720, Speaker A: Right. And I'm sympathetic to that. Given the different edge cases and things you can think through here, I'm not convinced that we have kind of an end to end sound design. Andrew, your hand's still up.
00:13:24.090 - 00:14:41.730, Speaker E: Yeah, I think, actually, I think that we should at least switch to Gui, because then, as Mikhail noted, the other way around, if we say okay, it's way in Shanghai, then switching the other way around is hackier. Because then there will be tools that will expect withdrawals to be in way and switching them to Gui is a nightmare. So at least if we don't do SSD, I would at least switch to GUI. It's a very simple change. Technically, the only complexity is synchronization across tests and Cl and DL and so on. So it's true that it requires changes both on Cl and El and to the engine API, but it's a trivial change and it ensures that in Shanghai on both sides Cl and DL, we have an encoding of withdrawals in GUi.
00:14:43.430 - 00:15:12.482, Speaker A: Mark, I'm okay with switching to Guay. For us, the main risk that we see is SSZ encoding. So Gwe makes sense is the indianness in the way the encodings work here a problem? Like would it need to be GwE in little indian to actually be keep?
00:15:12.536 - 00:15:49.774, Speaker E: I think in the engine API we should keep the encoding. What is required for what is the case for other fields like base fee? I think it's big and in JSoN, isn't it? In the engine API? I don't think we should change that. Yes, engine API is JSoN, so it's an ASCII string. And the only thing that would change is before sending withdrawals to the engine API, the CL would no longer have to multiply by that billion for the.
00:15:49.812 - 00:15:58.100, Speaker A: Amount, but on how things actually land in the block header, it would be.
00:15:59.910 - 00:16:15.110, Speaker E: In the block header. It's just a commitment. It would be RLP with the current spec. So it's big NDN on the El like nothing there would change, it's just the amount that would be larger.
00:16:19.150 - 00:17:32.688, Speaker A: I would push back a little bit against the fact that this is design work if we go with only withdrawals, because the withdrawals are already well defined on the CL site and we're just replicating that in the El. So either way this goes anyway. On the Nimbus'site, we do have a branch that implements the necessary changes. If anybody wants to look at the size of that diff. And on the CL side, it's really small. Micah, I'm going to say the same thing I always say, which is that I think we should be prioritizing the long term health of the ecosystem and clients over the short term gratification of users. Today I think that we should be thinking about do we want to deal with the tech debt of having this weird transitionary phase for the next five years versus just telling people to wait two months for withdrawals.
00:17:32.688 - 00:18:48.876, Speaker A: I really don't think we should be know rushing anything. Mikhail, I just wanted to say that probably we can try to do something about it during the interop, and if we're satisfied by the result, we can make, like by the result of designing phase and by the result of implementing and testing this particular piece, we can make the change to the spec after that once implementations already like having this like a stretched ball or interrupt just as an idea, right? Given the multiple design points here and given what seems to be a lack of consensus, I have a trouble synthesizing this into something reasonable to move forward from the call today. Unless I'm reading this incorrectly and everyone's on board with something and I am not parsing that. I think you're correct. There are many opinions and none of them align. Potez I think perhaps to advance we.
00:18:48.898 - 00:19:00.850, Speaker D: Can probably agree on something on whether or not we want to have SSF in the future or at some point and try to commit to that and then we can decide when this happens.
00:19:05.510 - 00:19:06.260, Speaker A: Right?
00:19:08.630 - 00:19:38.042, Speaker E: I would still advocate switching to way because if we don't do it now, then later it will be a much harder. Like right now it's a trivial change technically, but later because some tools will be with Shanghai with the release, some tools will be enshrined having wei instead of GUI and it will be a nightmare to switch. So I advocate doing that bit trill technically.
00:19:38.106 - 00:19:42.750, Speaker A: Now, does that only touch the engine API?
00:19:43.650 - 00:20:26.990, Speaker E: The engine API and the execution layer. So in the how I see it, there will be only two places. When we actually add withdrawals to the beneficiary we have to multiply it by ten to the 9th. And also in peer to peer when we serialize withdrawals, when we exchange blocks, I would also have withdrawal amounts in GUI. So maybe just a couple of trivial changes. So actually if we keep the amounts in GUI, then the peer to peer will be a no change and only one line of code. When we add the amount to the balance.
00:20:28.930 - 00:21:50.294, Speaker A: Is anyone willing to handle the specification proposal for the guay change so that it can be discussed starting next week and into the execution layer call on Thursday? Yeah, I can do that. Okay, if we can have that on Monday so that we can begin discussing it and talk about it on Thursday, I think that's a reasonable compromise given the status here. If anyone wants to do the full specification of switching everything to SSD so that we also have that up for discussion and in a end to end bound well designed way, I think that's also probably worthwhile if anybody wants to take that on at the moment. Is anyone against the g way change? I think it sounded like most people were in favor of that one at least. Right? But there's no spec. So I think yeah, assuming people are roughly in favor, if Alex can have a spec by next Thursday's call, we can agree to an actual spec and ideally debate. Know, if we have the spec next week that we come on the call.
00:21:50.294 - 00:22:09.040, Speaker A: Everybody's reviewed it on the same page and agreed to that. Yeah, definitely. If we can have it Monday or Tuesday, that would much help the conversation. I'm not following the chat very closely. Is there anything that people want to surface from there?
00:22:10.210 - 00:22:16.030, Speaker E: Just is it a separate spec or is this part of 4895 like the withdrawal CiP?
00:22:19.950 - 00:22:31.870, Speaker A: I think this will be a diff to 4895 and any other relevant components like the engine API, and to bundle a couple of prs for discussion.
00:22:32.710 - 00:22:45.842, Speaker E: Okay, so it's this spec change to gigaway and then a separate one to change withdrawals commitment, transactions commitment, and the receipt commitment to SSC.
00:22:45.906 - 00:23:12.160, Speaker A: Right? I do not believe that we're in a good spot to even discuss changing the transactions commitment given that we don't know what it would break. So I think this is more are we going to do? The extended spec would be changing the withdrawals commitment to SSC. This is going to have to touch in the engine API and as someone said, I believe the networking spec.
00:23:14.450 - 00:23:17.920, Speaker E: Okay, so both are with Alex then I guess.
00:23:23.080 - 00:24:07.690, Speaker A: Okay, cool. And Alex, I'm very happy to discuss and review as you're working on this. Great, okay, thank you. Any final comments on this? Thank you. Good discussion. There is an open PR 3176 on the consensus specs repo from Mikael. This is, I believe round two or three in a proposal on how to handle a gossip edge case for BLS execution changes around the epoch boundary.
00:24:07.690 - 00:25:19.460, Speaker A: It's a relatively minimal change, it's a Ux improvement for stakers and I wanted to get people's read on whether we're willing to get this in there. And Mikhail, if you want to give us a quick TlDR on it. Yeah, basically the idea is using Capella fork version before Capella and fall back to the normal logic after Capella fork. The Capella fork epoch is taken according to the system clock to the local system clock. So that prevents messages from being rejected if they're sent on the gossip subtopic that is not related to Capella. So it's a kind of like stop cap, right?
00:25:21.290 - 00:26:06.290, Speaker D: So prism already implements this. If you send us a change, we will put it in our pool before cabela hits. But we are struggling to see when we are going to broadcast these changes. There's a race against hackers, I guess, and people are pushing to try to broadcast these messages early and it's not really clear to me what is the right point to broadcast. I would have guessed that it's at the fork. But then this hits the problem that other nodes might not have their head state or their wall clock at the fork. So what I want is a commitment from clients that we will not broadcast before the fork, perhaps, or, I don't know, any scheme would work.
00:26:06.290 - 00:26:10.580, Speaker D: I just don't want to be penalized if we broadcast and we're too early.
00:26:11.990 - 00:26:25.366, Speaker A: Right? Do you assess this change as simple enough and meeting your what what Misha is proposing.
00:26:25.398 - 00:26:49.230, Speaker D: We already implemented it and it's fine for us. This was the most natural choice for us. What is still up to discussion, and I haven't heard from other clients, is whether or not we're going to be penalized or anyone is going to be penalizing peers if they receive these messages before capella hits. We are not penalizing those messages, we're just ignoring them before the court.
00:26:53.800 - 00:27:06.736, Speaker A: I don't know what we have in Lighthouse, but I can bring it back to the team and make sure that we don't penalize if these messages are sent early. I wonder if it's better to put.
00:27:06.778 - 00:27:12.296, Speaker D: This special behavior in the spec itself and then with certain time involved, just.
00:27:12.318 - 00:27:27.676, Speaker A: So that we're clear, because this PR, if I understand correctly, allows for the broadcast at any time before Capella, as long as the four versions are correct, right?
00:27:27.778 - 00:28:08.270, Speaker D: So the issue is more than on the PTP. This PR, as far as I understand it, is the way we validate them. When your local node, you send to your local node the changes to be included in the pool. So that's one thing that users would want to do to have these changes in their pool before the fork. And then there's this other component which is the PTP network. And I suspect that the easiest for all of us to do would be to just ignore any messages that come over the wire until the fork and then at the fork broadcast all of our pool and start taking messages. I think this is the easiest for implement to us.
00:28:08.270 - 00:28:12.110, Speaker D: I suspect that it would be the same for every client, but I don't know.
00:28:13.680 - 00:28:43.732, Speaker A: So on this PR, if system clock epoch below Capella fork epoch, it'd just be a simple ignore, right? Okay. I believe there's consensus to put something minimal into the gothic conditions to handle this appropriately. Hotels, do you want to make a PR that represents the logic that you already have? If we think that that logic is sufficient, that would require less changes.
00:28:43.786 - 00:28:52.920, Speaker D: I can take care of it. Most probably what I'll do is just either have it nishant reviewing it or having him writing it. But yeah, I can take care of it tomorrow.
00:28:53.260 - 00:29:47.356, Speaker A: Okay. And we're trying to get an additional release candidate out. I guess it's looking like mid to late tomorrow at this point, so we'll try to get that in there and I'll circulate that amongst teams. Mikhail? Yeah. There is also a suggestion by seaway which might also make sense to always use genesis work version for this message type to verify signature. So it will be just unconditional thing, which is probably less bug prone if it's also easy to implement. Of course, I'm less inclined to go that way.
00:29:47.356 - 00:30:10.610, Speaker A: If the network forked, and there are two representations of reality, this would not allow you to do key management in a different way across those forks. It's not a huge sticking point for me, but that's at least the logic. Essentially, you would forego replay protection on this message.
00:30:18.420 - 00:30:47.690, Speaker H: And also, I think it would be helpful when we are entering the future, folks, like when we are passing from capillar to yaki four four, then the old operations in the pool, they might have to be clear or something else. And then the user at the fork boundary, they might have to send another message.
00:30:48.860 - 00:30:54.536, Speaker A: They do work across one fork boundary, correct? Yeah.
00:30:54.558 - 00:31:04.540, Speaker H: I mean, if we use Genesis folk version, because right now they have to use the new folk version.
00:31:06.240 - 00:31:10.056, Speaker D: Yeah. No, they don't work across ports, Danny.
00:31:10.088 - 00:31:10.670, Speaker A: Now.
00:31:12.800 - 00:31:31.010, Speaker D: What Yushang Wei are suggesting is actually what we implemented. We're just going to wipe out the pool completely at the fork. It's not going to be a problem in future forks because there's not going to be many changes in future forks.
00:31:32.390 - 00:32:19.070, Speaker A: I see. Okay. I'm inclined to just change the networking spec at this point, rather than to change the consensus spec around the fork version of this message. Are there any strong opinion against that? Okay, sorry. The question will we run into the same issue where a message created to forks back might be useful?
00:32:25.040 - 00:32:37.970, Speaker D: But if you create the message to forks back, it depends on how you sign it. Right. You want to submit a BLS change signed now, but you want to submit it to forks in the future.
00:32:39.220 - 00:32:42.610, Speaker A: Yeah. I'm asking if that's a use case. Right?
00:32:43.060 - 00:33:13.030, Speaker D: No. So I think what we're suggesting is now only for the capella port. So it can only happen right now. Bella trips to capella. I mean, it will never happen again, this special behavior. So just to be clear, again, so if you sign a message with capella and you submit this message at the next the sharding fork, then it will be invalid.
00:33:16.570 - 00:33:19.430, Speaker H: Sorry. That's the new proposal.
00:33:21.530 - 00:33:37.710, Speaker D: So that is the current status, and we are proposing to maintain that status for the next forks. The only fork that is very important is because we're going to have hundreds of thousands of changes is people signing in Bellatrix and submitting at Capella.
00:33:42.840 - 00:33:52.330, Speaker H: But in the EIP four four, then you folk. Then you have to use EIp four folk version to send a message.
00:33:52.860 - 00:34:09.260, Speaker D: Correct. And this is the current status, so it's fine. The current status says if you're past the fork of capella, then you have to use the current fork, and if you're before capella, then you can use capella.
00:34:11.920 - 00:34:16.620, Speaker A: Yeah, but somebody was suggesting that we would simply sign with the genesis for congoes.
00:34:17.140 - 00:34:23.600, Speaker D: Oh yeah, this is a suggestion of Shao Wei. I'm not against that. I don't know if there's consensus.
00:34:26.020 - 00:34:45.240, Speaker A: Because if we do, then we don't have this problem and people can sign their messages now and store them in some place and then send them in whenever they want. I don't know if that's a use case. Right. And the main issue that we run into is replay protection in the event that there is some sort of chain.
00:34:50.780 - 00:35:08.770, Speaker H: Mean, just using Genesis pop version will reduce some UX problem. For example, if we want to sign a message offline, then we don't have to choose which epoch which fork version to use.
00:35:10.740 - 00:35:13.600, Speaker A: Right? And I find that compelling.
00:35:16.680 - 00:35:24.390, Speaker D: Yeah, I think it's a minor change to us to move from capella to generic version, so it's fine for us.
00:35:28.680 - 00:36:05.120, Speaker A: I'm sorry, I didn't get why shouldn't the default version be capella? Because it starts at Capella. We can always sign with the feature for. I don't understand what is the opposition to that, because that seems to me the better solution than I think it's because it gets rid of the edge case and it ensures offline signing. Ux can be simple and the tool that you installed two years ago would still work, rather than having to bring in extra information about the current network.
00:36:06.600 - 00:36:48.320, Speaker H: Also, I think it depends on how the CL tries to manage their preset and configs. Like if we are at Bellatrix, do they have top version or not? Because if it's in the execute the pipe bake, then when you are at Bellatrix we don't have any config accessible if we don't do some tricks. If we want to access the capillar operation, it's just a little bit more hard to manage. So using Genesis could be easier.
00:36:51.390 - 00:36:51.754, Speaker D: But.
00:36:51.792 - 00:37:56.680, Speaker A: The tools should anyway have some main net config baked in them, right? Yeah, they could, but also when you're talking about offline cold setup tools, you don't necessarily want to update them frequently, so you might have some sort of stale config that if it was just genesis, it would still work fine. So the genesis signed version will work till capella and post capella. Then it will be normal flow. That's what we are talking about. I missed that. Can you repeat yourself? I'm asking that the Genesis sign withdrawal will be valid till and on capella and post capella, for example, on charting, it needs to be signed fresh, right? No, the intention would be essentially by signing Genesis version. It works for all forks.
00:37:58.860 - 00:38:04.200, Speaker H: It is just like how we handle the deposit operations.
00:38:05.980 - 00:39:02.030, Speaker A: Right? There's a bit less of an issue on like. Again, the only thing that is an issue here is replay protection, but I don't know if replay protection is that valuable. The deposits get native kind of replay protection because they come from an execution layer that has transaction that has that. Can I add that it not just works like deposits. Deposits can be signed offline and then there can be these trustless validator schemes built around them where something that's signed will always be valid. And if a withdrawal is restricted to a single fork, then you cannot really pre sign withdrawals for validators anymore. And then you have to resign and you have to basically stay connected to whatever service you might be using.
00:39:02.030 - 00:39:43.156, Speaker A: If you're trying to agree on withdrawals, that will be reduced. The alternative is to just use the execution layer address from the start, if that's your scheme that you're using today. But I'm slightly in favor of using Genesis four version if no one's opposed. I think that it does simplify the UX quite a bit and is very minimal and gets rid of our networking. Would the other folks sign versions would become invalid. For example, Capilla signed or they would still be valid. They must be in that scheme.
00:39:43.156 - 00:40:26.440, Speaker A: They must be Genesis four version. Just to clarify the scope of this, we're talking about the BLS credentials change message, right? Yes. Not voluntary withdrawals, which then become a bit of an anomaly because they are not signed with Genesis. Right. But for the scope of this conversation, we're just talking about the BLS change. Yes. Shall we? Can you open a pr with the suggested change?
00:40:27.370 - 00:40:28.642, Speaker H: Yes, of course.
00:40:28.796 - 00:40:30.060, Speaker A: Thank you.
00:40:32.830 - 00:40:57.310, Speaker H: By the way, we might have a standard release tomorrow and we can try to make it included. How do you guys feel about making it ready interact.
00:41:00.770 - 00:41:43.740, Speaker A: At this point? I hope that we're only making extremely minor changes and that we get them in as soon as possible. So whether that be a release tomorrow or if we need to delay till Monday, that'd be my preference to get in whatever we plan on getting in. Okay. Mikhail, you have a number of engine API prs that you put into the agenda. A couple of them are now merged. Can you give us TLDR? Yeah, sure. So let's go over what has been merged into the spec already.
00:41:43.740 - 00:42:45.360, Speaker A: The first one is unification of failure mod when the structure version is not compatible with the actual structure content. So this pr is here. So basically before the merging of this pr, this back had a discrepancy on how to handle this kind of situation. For instance, for a new payload p two, if you pass withdrawals, say before Shanghai. So withdrawals aren't null before Shanghai in this case, or vice versa, withdrawals are filled. Withdrawals are null after Shanghai is enabled. In this case, the invalid payload status had to be returned, which is abusing invalid payload status in the first place.
00:42:45.360 - 00:44:17.494, Speaker A: The discrepancy here was with folk choice updated version two, where we had to return the error when payload attributes are failed with withdrawals when they don't mean to be failed with them. So this PR unifies this kind of stuff. And if the structure version doesn't match what is expected according to activated features, this PR particular uses timestamp to denote for calculation as this is applicable to El side and El uses timestamps. And in all cases, and I think it should be like a practice for future upgrades as well, the error should be returned as specified, the PR. So what does it mean actually? Currently new payload v two and folk choice updated with two. They support v one and v two versions of respective structures. And in the future we might deprecate new payload v one at all and use new payload v two, for example, to pass pressure high and postion high blocks into it and so forth.
00:44:17.494 - 00:44:58.360, Speaker A: So that's about it. So the change to Yale clients and to Cl, I guess, is about this switching from invalid to the error from invalid payload status in case of new payload. So take a look at this one. The next PR, what was it about? Let me check. Yeah, so a bunch of cleanups. It introduces some cleanups which are saying that the terminal preferred block conditions may not be verified anymore. So it's just like a recommendation, an option.
00:44:58.360 - 00:45:58.410, Speaker A: If clients want to, they may just remove this logic. And one of the things here is that invalid block hash status is deprecated and now invalid. Just invalid status should be used instead. And this is like a must. So el clients must switch from invalid block hash in new payload to invalid status. So that's like a substantial thing from these cleanups that people want to take care about. Okay, questions so far or comments on what has been merged? Okay, so the other thing that we have decided to try out to put into Shanghai scope are these payload bodies requests.
00:45:58.410 - 00:46:45.430, Speaker A: I have just stolen the PR by Yatesuk and rebased with Shanghai and did some refinements as well. So the spec is here and I was just going to ask Yale client developers about the status of this and how do they see can we do this as part of Shanghai or not? Can all Yelp clients provide this functionality and implement this as is specified? So basically it's two methods. Go ahead. It is about get payload bodies, right? And get payloads by range. Yeah, exactly. Two methods. Get payloads by hash.
00:46:45.430 - 00:47:01.680, Speaker A: We already implemented it, released it, so if CL clients want to experiment with, they can use it in gas too.
00:47:06.360 - 00:47:16.760, Speaker E: In Aragon, we have not implemented it yet, but it should be relatively easy to implement so we can to do it before Shanghai.
00:47:21.780 - 00:48:08.370, Speaker A: Same on Ethereum js we haven't implemented, but we can implement bazoo. Doesn't seem too challenging. It's the first time we're taking a look at it. Okay, so I suggest we merge it, but also experiment and test with it over the next handful of weeks. And if we're running into issues or we can't get conformance across the board, then we'll kind of move it into an experimental place and make it a more mandatory Shanghai update. Sound reasonable? Potez.
00:48:10.090 - 00:48:15.800, Speaker D: I'm sorry I raised earlier. I want to bring back something for Shao Wei. Can you call me in a bit?
00:48:16.810 - 00:48:52.170, Speaker A: Yep. So on get pillot bodies, we are merging this pr into dimension high spec, and if any issues, we are moving it to experimental. Am I understanding correct? That's my understanding. Okay, great. Thank you, Mikhail potas.
00:48:55.070 - 00:49:26.450, Speaker D: Thanks. So if we go with Xiao Wei's version, which is fine by me, like using Genesis version, I don't see anything wrong, but it would be good to specify when we're broadcasting the messages because we know that we're going to see hacked versions of people. We expect to see hacked versions of clients broadcasting as early as possible their changes. Perhaps we could agree on just ignoring anything that comes before the capella fork.
00:49:32.800 - 00:49:48.000, Speaker A: Right? So that would look like a conditional in the gossip spec. That said, if before simply ignore, I'm not opposed. I'm also not convinced. You don't know who's the person acting really fast, the hacker or the user.
00:49:48.580 - 00:50:04.020, Speaker D: Yeah, there's no easy way about this. I don't really know what's the right thing that I should implement. If we are going to accept messages early, then I think I should be implementing that. As soon as we subscribe, then we send those messages.
00:50:06.840 - 00:50:47.982, Speaker A: Right? I guess the only thing we can do here is have an even playing field, because we don't know if the hacker or the user is going to be racing first. So I guess your suggestion does at least make the playing field even. So, shall we? Let's consider also putting that conditional and ignore Mikhail. Yeah, just small question related to it. If you ignore, will you receive them again, the same message, I mean, yeah.
00:50:48.036 - 00:50:58.690, Speaker D: So it includes some sort of like perhaps a DOS, I'm not an expert on PTP but yes. So if you ignore you'll get them again and then you'll just put them in your pool.
00:50:59.350 - 00:51:06.550, Speaker A: Don't you have like a cache that if you see the same message you just drop the message even though it's.
00:51:07.210 - 00:51:14.070, Speaker D: We do have this, but only after we include it in the pool. So if we are ignoring that will never hit the cache.
00:51:23.400 - 00:52:20.370, Speaker A: Okay, we'll get something like this into the pr and circulate it for review. Okay. 4844, I was curious as we kind of lead into interop in a couple of weeks, just quick status updates in terms of passing tests. I know we have some issues with the tests that are going to roll out soon, but just where do clients stand in terms of limitation of the most updated specs? So for Lighthouse we're passing the latest spec test apart from the one test that I think is bugged. So we're there with the implementation, but we haven't really tested the latest spec in like a local testnet or interop at all. So working on that next, in the next week and a half.
00:52:21.860 - 00:52:27.836, Speaker D: For Prism, it's very similar to lighthouse that we are passing the current spat.
00:52:27.868 - 00:52:32.612, Speaker A: Test, but then there's a new one coming, so that shouldn't be that hard to pass.
00:52:32.746 - 00:52:44.948, Speaker D: And then we're working on some end to end tests. Basically it's pretty cool that we're using MoFi's blob utility that enables us to submit a blob and then sync a.
00:52:44.954 - 00:52:48.916, Speaker A: Beacon node and then download the blob from the sync beacon node.
00:52:48.948 - 00:52:55.720, Speaker D: So we're playing around with that. But yeah, I think we're fully ready for the interrupt and we're also very excited.
00:53:01.350 - 00:54:16.684, Speaker A: Load star is also collapsing the latest, except the one already saw the network and ASU has a number of pieces implemented, but we still haven't really started full integration of them all. I personally could use some help if we could maybe get doc or maybe update the EIP 4844 site that has a consolidated list of all the potential testing resources that are available that would help me orient the team and get that stuff delegated out. So if that already exists, just point me to it please. And if it doesn't can anyone own that specifically? Resources? I'm sorry proto, say again? I'll put together a list of the resources we have. Okay, thank you, thank you Proto. I think Nimbus is in a similar spot. We have tests passing and bits and pieces implemented.
00:54:16.684 - 00:54:51.580, Speaker A: They need to be put together. I'm guessing we have quite a bit of ux work as well to do in terms of yeah, there are all these little questions left to answer, which I hope we'll have time during the interrupt to decide like how long blobs are stored, how big they should be, whether they should be coupled or not, and things like this, like all the engineering stuff I think I feel is still a bit shaky.
00:54:58.760 - 00:55:18.972, Speaker E: We are implementing the sync logic and the block production flows are in a good shape. Yesterday we did our first block production in our interrupt local interrupts and yeah.
00:55:19.026 - 00:55:20.792, Speaker A: We are still progressing.
00:55:20.856 - 00:55:22.712, Speaker E: We have reference test enabled.
00:55:22.776 - 00:55:24.556, Speaker A: They have to double check if they're.
00:55:24.668 - 00:55:32.290, Speaker E: All enabled or not at the moment, but we are passing definitely some of those if not all.
00:55:39.740 - 00:55:56.220, Speaker A: Got it. And help me understand, would we call these implementations on the path to what we hope to be production? Or are these quick and dirty proof of concepts that are going to need extensive overhaul post interop?
00:55:59.360 - 00:56:19.316, Speaker E: For us, we always do directly in the master branch. So everything is production ready in terms of quality, definitely something to be left out in terms of optimization, cachings and you're there. But the general approach for us is.
00:56:19.338 - 00:56:20.630, Speaker A: Still always.
00:56:22.600 - 00:56:24.870, Speaker E: Be less quick and dirty as possible.
00:56:29.580 - 00:57:14.490, Speaker A: Ours is also like a production implementation, but it's still going to take us some time to fully productionize it. Like a month, two months, I don't know. Yeah. I don't mean whether it is production quality today, but that it's on that path and that we're not working on proof of concepts. Thank you. It's also on our main unstable brand and we really get selective as things move along and things come up. Okay, so am I correcting generally across the board? That's true.
00:57:14.490 - 00:57:53.470, Speaker A: I mean we have pieces that work, but I think there's a lot of user experience stuff left, like the database retention, like how do you do pruning correctly? Right, understood for a good user experience for the rest API, blah blah blah. Okay cool. Thank you for the updates. We will have call again next week and continue to chat about this as we approach interrupt. Xiaoui D star name.
00:57:58.800 - 00:59:06.210, Speaker H: Hey, so last time we had some discussion about what should we need for the next hard work in the Cl. So one popular candidate is the denet. If I pronounce it correctly. I saw some positive vibe about people want to use Lisnian and I just want to make sure that most people are happy with this choice and we can move on and rename five four four to this and break some links, but we will be happier after the big renaming. Yeah, and any suggestions feedback objections on it?
00:59:21.570 - 00:59:25.890, Speaker A: I think it's probably time. I have no opposition.
00:59:29.100 - 00:59:43.500, Speaker H: So it's Danab. Thank you. And so I think we can wait until after the interrupt and then start the big renaming.
00:59:45.840 - 01:00:05.750, Speaker A: Sounds good, sounds good. Okay, moving on, we have a couple of PRS, the beacon APIs open up by Zolt. Can you give us an update here and anything that we need to agree upon to get these things moving forward?
01:00:06.680 - 01:00:29.470, Speaker G: Yeah. Hey everyone, these two open prs I have are, they are basically extensions of the light client beacon API. And yeah, for some context, yeah.
01:00:32.480 - 01:00:32.796, Speaker E: I.
01:00:32.818 - 01:00:48.076, Speaker G: Have an almost finished version of the new light client protocol version for Go ethereum. So yeah, we don't have a working light client right now since the merge.
01:00:48.108 - 01:00:48.960, Speaker D: Unfortunately.
01:00:53.640 - 01:02:19.048, Speaker G: I have a very current use case for these things, but I think they are generally valuable if we have this idea that it should be possible to implement a light client through these rest APIs. And I think it's generally a nice thing because there could always be use cases that can make use of it and I would also need this right now and this would be very valuable. One of these endpoints is about the beacon state. Currently the light client API provides a lot of nice stuff and it's possible to light sync the consensus like we can sync up to the latest beacon header and that's nice. But if we want to prove something from the execution layer with that then we also need some merkel proofs, well at least to the execution block route maybe. Also other stuff from the beacon state can also be useful. So since I want a fully functional client which also can prove other blocks, I also use this historical state routes and whatever.
01:02:19.048 - 01:03:49.550, Speaker G: So the point is that right now I think it's still only lodestar that has a beacon state endpoint. And we discussed this a lot, both with Cayman from Lone Star and also with other people that that exact API would not really be practical to expect other CL clients to implement because they have different in memory representations of the big state. Not everyone has the last 64 states available. Instead, I specified a new API that I think it's close to being implemented in Lodestar that only defines. So it doesn't expect CL clients to keep all the beacon states. So it allows either requesting stuff from the current head, whatever it is, or it has this subscribe method, which is basically just a hint to the client that okay, I might be interested in these parts of the state in the near future. As you process this box, please remember it for a little while so I can request it later.
01:03:49.550 - 01:05:17.640, Speaker G: So yeah, there's the reasoning and explanation in that PR. So I don't want to go into very much detail and I believe it should be reasonably simple to implement and it's reasonably general purpose. There's a very nice compact format for defining the subset of the beacon state and the shape of this Merker multiproof that we want to request. So I think this could be like a nice general purpose beacon state API endpoint that I think any CL client should be able to implement. And yeah, there's also another that's even less complex pr about this instant updates PR, which is now we have finalized and optimistic updates in the light client API, and the optimistic update is basically the previous slot. So the slot before the head slot, because the sync committee signatures for each slot are included in the next peacon block body. So these light client signatures are always available with one slot of delay.
01:05:17.640 - 01:06:47.316, Speaker G: And that means that any light client can only have access to the head with a slot of delay. And these instant update endpoints would allow quicker access to the latest head because there are these partial aggregates available in the network and that's pretty easy to collect them and aggregate them on demand. And that would only be like, I don't know, 4 seconds of delay instead of twelve. Yeah, this is just a minor optimization and maybe less critical than the first one because having access to the beacon state, I believe that should be part of the beacon API at least once. We have endpoints for beacon light syncing and everything. I know that right now people are mostly concerned about the upcoming fork and everything, but these processes take time. So I just wanted to bring this up and yeah, it would be nice to get more feedback on these and move this thing forward.
01:06:47.316 - 01:06:49.190, Speaker G: So yeah, basically that's it.
01:06:51.960 - 01:07:06.634, Speaker A: Any questions? Result please.
01:07:06.832 - 01:07:44.230, Speaker E: Sorry, it's just if you could already get unblocked with the popular use case by just having access to execution payload header, that one will be part of the like there is a PR 3151 to extend the current likely and data format with the execution payload header as well, and it will also go into the rest stuff. But it's less generic than what you describe. But still, maybe that one already helps you a bit to get unblocked.
01:07:45.930 - 01:08:24.980, Speaker G: Well, I mean, I mean, so right now if we are talking about for current get lightline design, well that uses multiple fields. Right now I'm working with Lodestar mostly and Lostar is also working on these think. I think until others implement it.
01:08:27.110 - 01:08:27.474, Speaker A: The.
01:08:27.512 - 01:09:18.938, Speaker G: Getlite client will probably use lostar and more. Exactly get full nodes who are serving the get light clients. Those will probably use lost tunnels because, well, it provides full functionality. We already have the code and so I guess for now we will go with. But still I totally agree that for many simpler use cases, what you said, and this is what we talked about at the conference also like in Bogota. So this is useful, just having the execution payload headers and for some use cases this is all you need. And it's really nice to have this simple API.
01:09:18.938 - 01:09:25.494, Speaker G: But I believe this general purpose API is also not super complicated and I.
01:09:25.532 - 01:09:26.120, Speaker H: Think.
01:09:28.890 - 01:10:06.500, Speaker G: It feels like it's missing from the API. So we have everything else accessible through this and just not this. So like the Beacon state. And I think Cayman also said to me that they have some use case for accessing the beacon block bodies too. So maybe we could also implement the same thing for the beacon block bodies. I don't really need that right now, but I'm just saying that that's also a possibility. So this is why I'm proposing this.
01:10:11.560 - 01:11:24.664, Speaker A: Okay, beacon API maintainers of client teams, please take a look at these. Maybe we can get them unblocked and some discussions in person, if not asynchronously, between now and then. Any other questions or comments on this one? Okay, great. And then the Shanghai Capella Chappella community call. Tim? Yes, so next Friday at 1500 UTC, we're going to have a first community call for Chapella. Basically these are useful for developers, infrastructure providers, wallets and whatnot to come and ask questions about the upgrade. I realize that we're still a bit early in kind of the Chappella cycle, like we're not on testnets yet and whatnot.
01:11:24.664 - 01:12:24.826, Speaker A: But I think it's good to just have a first call where people can come with questions and we can answer that about how withdrawals work, what they should be mindful of as this is happening. A lot of people will be traveling during that time, but if you're not and you want to come on, people always appreciate it when client developers or researchers can answer questions directly. Otherwise Danny and me will be there to answer people's questions. If you're listening to this and want to join the call, the information is on GitHub and you can post your questions in advance there. Yeah, that's pretty much it. Thank you, Tim. Any questions for Tim? Any other discussion points for today's call? Ruben, I just want to ask what.
01:12:24.848 - 01:12:33.310, Speaker D: The conclusion for withdrawal protash regarding this SSD adoption on the yield side, I don't see we come up to any consensus.
01:12:35.810 - 01:13:38.470, Speaker A: Alex Stokes is going to work on a simple proposal that has GwE as the unit of account within withdrawals across the engine API, the EIP and the networking spec for discussion, and we will discuss it again on awkward devs next week. And then I believe we will also, although I not 100% sure who owns this one, will work on actually changing an additional proposal to change the commitment to SSE, although it seemed like there was much less consensus on that path. But again, both of these are things I think will come up in the call in one week time. But right now, we don't really have end to end reasonable designs for the things that people want to see. So that is the next step. Thank you. Okay.
01:13:38.470 - 01:13:54.340, Speaker A: Anything else for today? Okay, cool. Thank you. I appreciate it. Talk to you all very soon.
01:13:56.550 - 01:13:57.554, Speaker D: Bye bye, guys.
01:13:57.672 - 01:13:58.158, Speaker A: Bye.
01:13:58.254 - 01:13:59.154, Speaker D: Thank you.
01:13:59.352 - 01:14:12.460, Speaker A: Bye bye. Sa.
