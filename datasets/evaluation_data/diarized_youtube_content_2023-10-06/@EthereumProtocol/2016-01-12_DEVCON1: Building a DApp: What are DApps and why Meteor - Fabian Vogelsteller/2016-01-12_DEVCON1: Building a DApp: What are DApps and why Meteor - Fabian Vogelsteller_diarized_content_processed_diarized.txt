00:00:17.530 - 00:01:39.290, Speaker A: Hello, I'm Fabian, I'm the lead dev developer. I also created the current mist and the current wallet and um, I'm also worked partly on web3 js and other things I want to talk today about what are Dapps? Because I think a lot of people have this question in general because it's a new term we coined, and also why you should use meteor to build them. So adapt, like in its simplest case is just basically an application talking only to a blockchain. So the main source of information, basically the main back end is a blockchain because it's a trusted source of information. Obviously this can be a native dev also, but this will be most likely a JavaScript HTML five based web application because we have mist where you can run it, which automatically gives you the access to the blockchain. And it's also extremely easy to build interfaces in a JavaScript environment, in an HTML five based environment. So what basically makes a DAP? So the main three components, and the main component is obviously an interface built somehow, like in this case it's JavaScript HMF five CSS.
00:01:39.290 - 00:02:38.640, Speaker A: It has a local storage, so the data is kept locally, which could be local storage, could be the browser's index, DB, could be web SQL. And it comes from a place where you can verify that the DAP is exactly what it's supposed to be. So this could be swarm ipfs, any kind of content, addressable storage, and obviously it needs the access to the theorem blockchain, which is what we deliver the web3 object. So the web3 object is basically like the API for JavaScript applications to interact with a blockchain. And this will be the object you will have and missed available. And it's pretty simple to install, just MPM install web3 or meteor at Ethereum web3. So now a few people already probably had the question why meteor? So meteor actually is a full stack framework allowing cross client reactivity with all the server infrastructure and so on.
00:02:38.640 - 00:03:34.666, Speaker A: The reason why meteor like this is not the main reason. What? One reason is because I know it and because I wrote a book about it and we build all our interfaces using meteor. But the main reason actually it is ideal for Dapps because meteor is built to purely build single page applications. Single page application doesn't mean they have only one page, it just means that all the logic is contained in the javascript which will run in the browser. It also has a command line tool for loading a development server for package management and bundling. So currently if you would do this, you would have to learn a bunch of tools, you would have to learn crunt and gulp and browserfi and whatever. And it's a pretty step learning curve to get into and starting building web applications.
00:03:34.666 - 00:04:14.960, Speaker A: So meteor makes this easy and that's why we are recommending actually using meteor because it is so easy. You basically just write one line of code and you can already have something visible, you can change it and you already see something happening. Another major point is reactive templates. This basically means when your data sources changes, so anything you get from the blockchain, when this changes, your interface will update automatically. So this means your interface will always be consistent. You don't have any kinds of spaghetti code where you try to keep track of things or you have to write endless bindings to get things right. It's just always displays correct data.
00:04:14.960 - 00:05:01.370, Speaker A: And the major point is it has Minimongo which is an in memory database. It's basically exactly the same syntax as MongoDB, but it's basically just in your memory in the browser. And there are packages like a package I have, it's called persistent minimongo which auto persists. All of this either into local storage or into the index to be a web SQL in the browser. So you're basically just talking to this mongolike database, you're writing things stands automatically in your local storage, persistent. And when you reload your application, it's just back there. And one major tool as well is the meteor build client, which allows you to basically get purely the client part of your application.
00:05:01.370 - 00:05:50.700, Speaker A: So you get a JavaScript file, a CSS file, an index file which you can, and some static assets you had and you can just put them wherever, either on a server or later on swarm in mist. And we also provide some packages we use to build our own tools. You can use them in meteor, but some of them you can even use without meteor, for example the east tools which give you conversion with number formatting and so on, and some nice interface packages. So they need meteor because they use the reactivity of meteor. And we highly encourage using the identicon because the identicon is basically the user's way of recognizing his address and his account, basically his identities. He uses a mist. So we use this in missed and we use this in all our dapps we will build.
00:05:50.700 - 00:07:03.214, Speaker A: And if other daps use that too, it's easier for the user to recognize. So we saw this example before of the smart contract where somebody want to buy something, they all both put money on the smart contract, exactly twice the value of the product and then when the package was sent successfully and he is happy, he can initiate that, the money goes back, except what he paid for the package. So to have a nice interface, you can build this in mist. And I will not live code right now because that takes a little too long, but I will show you how it behaves. And, okay, so this is missed and I will start mining here on my private net to avoid any chances of no Internet. So this is basically exactly the button Alex was talking about. The nice thing about this is kind of like the Internet of things, but it's the Internet of components, you could say, because it's kind of like the button is the escrow.
00:07:03.214 - 00:07:46.494, Speaker A: So the button gets the money and the button pays the money out and all the rest around. And wherever this button is placed basically doesn't matter because the button is the Internet of thing thing. So we here, and this is basically a mispreview at its current state. And I selected that I want to be the buyer or some random person who has money on his account. In this case, it's here the buyer, and the buyer can basically, he sees the button, the contract, or like this component sees automatically who is there and what address he has. And he sees, okay, there's nobody I know. So probably somebody who want to buy the item.
00:07:46.494 - 00:08:20.534, Speaker A: So if I want to buy the item, I basically just click on it, I decrypt my password and send this magical comments to the CM blockchain. And I bought the item, basically. So now I would wait for the package from wherever he sends it. Once I like it, I would actually press confirm and the money would move to me back. My deposit and the price plus the two deposits of the seller. So the same thing would look different. The same button would look different if I would be the seller.
00:08:20.534 - 00:09:21.150, Speaker A: So if I'm now switching to be the seller, it would look actually different, because now the button recognizes that I am the seller of the button and I now have a different function I can do. I can refund the buyer if I think like whatever, he sent the package back and whatever, or if I'm somebody else, I will basically see that the item is already sold. So if we go ahead, just to actually make that clear. So here, if we look our accounts, we see there's the buyer who has thousand ether and the seller has thousand ether. Is this actually correct? It's actually a good question. Doesn't, um. Yeah, so we go back to the sales page and we basically confirm that we got the package.
00:09:21.150 - 00:10:09.060, Speaker A: And you also can see here in the confirmation window what actually is having under the hood. So I'm the buyer sending an action to the contract, to the button itself here. I'm sending no ether because I already sent ether. And I'm executing this function which is hex encoded the function name with some gas provided. Once it's done, all the money moves back to the people who, which should happen if my private network works. Okay, so now the item is actually sold for both parties and everything works. I paid and the seller got his money.
00:10:09.060 - 00:10:36.890, Speaker A: And the interesting thing about this is this is just the HTML here. And you see it's basically this simple thing down here. I'm not sure if you can see that. Right. So it's basically this simple thing here. It's the buy button and I pass in a contract. So obviously when we are building a real webshop, we're not having one contract per buy and per sale and per product.
00:10:36.890 - 00:11:23.930, Speaker A: We would write a contract which have multiple products which can be bought x amount of times at the same time. So this is just to show like a very simplistic approach here. So in this case we just give it the address and the button itself looks simply like a button which gets a specific text and a specific class and a subtext here. And the whole code itself that is self contained thing is this snippet here. And it basically just have the ABI of the contract we are interacting with. Is this readable? I hope so. So this is the ABI which tells basically web3 how to interact with this contract.
00:11:23.930 - 00:12:09.480, Speaker A: Then a function which will check the state, it will call all these contracts function like for example, who's the seller, who's the buyer, what's the value and what's the current state? And then we have this object which is the different state. So if I'm the seller and I'm state zero, then use this classes and this text. If I'm in state one, use this and so on, so on. And basically what happens if the template is initiated? We just check the state at the beginning reading from the ethereum blockchain. And then we're watching all the events which come from this contract. And if there's an event coming, something happened and we will check the state again. So this will update the state.
00:12:09.480 - 00:13:24.290, Speaker A: We'll update our reactive function here called template VAR buyer value and so on. And this will rerun all these template helper functions we have here, which is only one, the get state which gets the state from this one state object and returns the right text or the right class or whatever it does. So basically this function will rerun if any of these template bars here will change and the same when I click the button, I'm just checking if I'm the buyer or the seller or if there is a buyer or seller account and then it will call the right functions. And once you call in web3, web3 send transaction or whatever and you pass the right data, mist will pop up a window asked to confirm this transaction and there you go. This basically allows you to have the Internet of web components boxed. So what you also see here is using our little css framework we are building, which we will use for our Dapps, the daps we will build. If you want to use this framework, you will always look into similar like our design which makes you look good by default.
00:13:24.290 - 00:13:45.940, Speaker A: And it's rather simple. It's like simple HTML, you write very simple classes and then you immediately have like a good looking application. But this is still in the making so use with caution. So just check, the seller will see the same.
00:13:47.590 - 00:13:48.340, Speaker B: You.
00:14:03.490 - 00:14:06.160, Speaker A: Stop mining. Yeah.
00:14:09.090 - 00:14:21.410, Speaker B: Hello, can we turn this on? Okay, I think it's going to be testing, testing.
00:14:21.750 - 00:15:04.480, Speaker A: Okay yeah, that's basically it. So this is the dap you can try yourself. If you just go to this address and you have a local node running and you started on localhost with the RPC, started localhost 85 45, you basically be able to do things you would have to change. In this case you wouldn't be able to do anything except buying if I would deploy it with a right contract or you just clone the application yourself, look how it looks like. And if you want to start building dapps, our wiki page, I shifted it a little bit around or this page here actually gives you a good entry point on where to look like building meteor. Thank you.
