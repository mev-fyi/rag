00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:03.890 - 00:00:16.000, Speaker B: Hi all. Welcome to the EOF implementers call number 20. Let's just go ahead and get started with some client updates. Does anybody want to start us off?
00:00:20.320 - 00:00:57.950, Speaker A: Besu I'm working on implementing create three. I think that brings us up to parity. Have a community. It won't be until next week, but that'll us up to parity with EVM one. That includes the renumbering of the code sections with some of the things in flux. As far as changing the container ordering and opcode numbering, I don't know that there is a single unified spec most everyone's implementing. Like all the other clients, I think we're stuck in Denkun interrupt mode so they're not able to get too much time focused on this right now.
00:01:02.880 - 00:01:10.960, Speaker B: Is the mega EOF spec not what people are targeting? Is there like changes to it that haven't been reflected?
00:01:11.620 - 00:01:31.952, Speaker A: Not everyone's implemented all the changes. There's also some changes that just went in with stack height that are proposed and haven't gone in for final yet, so it's still a bit in flux. We haven't had a big interop hub around a version like we did back around December, January. Okay.
00:01:32.026 - 00:01:37.400, Speaker B: But there is a spec version that people can be implementing too, right?
00:01:37.470 - 00:01:39.448, Speaker A: Not everyone is up to date on. Okay.
00:01:39.534 - 00:01:41.690, Speaker B: Okay, that makes sense.
00:01:42.380 - 00:01:43.176, Speaker C: Great.
00:01:43.358 - 00:03:05.640, Speaker B: Other client updates cannot hear you if you're speaking. Andre still no. While Andre is working on his audio. Do you have any updates, iman? Okay, let's just jump to compiler updates and when Andre comes back he can say what's been going on with EvM one. Anything on the compiler front?
00:03:07.690 - 00:03:09.020, Speaker D: Nothing for me.
00:03:11.470 - 00:03:12.220, Speaker A: Cool.
00:03:13.790 - 00:03:25.040, Speaker B: That's probably it for compilers. Dano, I know that you've got a couple things you want to discuss on the spec. Do you want to go ahead and get started talking about extra data?
00:03:26.370 - 00:04:27.870, Speaker A: Sure. I was hoping to get more of the Ipsilan team and other people involved in the theoretical parts of it to get consensus around adding ext data load, which is something that has been requested to make it easier for the S store two community I think is what they're calling. I'm not sure what they want to refer to themselves as, but where they're using contracts to store immutable data do things like put vector art for nfts on chain cost efficiently. So I guess there's not much that can be discussed on that since there's really not much room to get consensus on and buy in from Epsilon. Are they out this week? Will they be back in two weeks? Or is everyone in Denkun burnout mode? No one's on from Epsilon, are they?
00:04:29.280 - 00:04:49.360, Speaker C: I'm from Epsilon but not working now. Currently on EOS. But Andre, if we'll become back here he will have some update. But this week we are mostly off and I think next week we will have better availability.
00:04:50.180 - 00:05:01.350, Speaker A: Okay. Trying to find where the agenda items I added were. Got so many things I'm juggling right now. It's also the other problem.
00:05:02.040 - 00:05:05.224, Speaker B: I paste the issue in chat 838.
00:05:05.262 - 00:05:59.144, Speaker A: Okay, so the first one was the exe code data and the data opcodes. I guess that's another question for Epsilon. Does anyone need help writing it? Is it coming along? So we need to get some final specs out. And then finally my last question was about the proposed stack range change that Viper was asking for, for its outlining to see if that would have been sufficient. So you got to get a progress statement status on that. Because from looking at the spec it feels like those might be last issues. And then I think we can look into starting to pack things up and ship it, or at least do a dress rehearsal for shipping it and make sure that's everything the community needs.
00:05:59.144 - 00:06:29.750, Speaker A: So that's my take on it. I don't know if other people think there's other things that are broken or need to be revised or need to be updated, what their opinions and thoughts on this are. Because if we get the stack range change, we may not need call fi and jump fi. Or maybe we do. That's why I need to hear from Viper.
00:06:34.810 - 00:07:50.990, Speaker D: From Viper's perspective. Well, I was looking at the thing that Andre proposed and it's. Yeah, I think that allowing forward recursion, this forward jump thing, but not the backward jump thing, feels a little awkward from a design perspective. But if it works, it works. I think the main issue is going to be with the RETF stack cleaning thing. So given all of the options so far, and given that I also haven't made that much progress with Pavel on being able to outline everything entirely just because of bandwidth reasons, call fi and jump fi are looking like probably the easiest way to move forward here, unless we do make some progress on this alternative implementation.
00:07:51.330 - 00:08:14.374, Speaker A: Okay. And I'm fine with that status. We don't need to push it to resolutions today. I'm just mostly trying to keep a running list of what the open issues are. And as that list approaches zero, once it's zero and we have answers on that, I think we could say that we're ready to propose a shipping version of it. So if more issues come up, don't hide them, bring them up.
00:08:14.572 - 00:08:56.360, Speaker D: I think we should still be tracking alternatives to create three, or where it can take potentially an external address in it code at an external address. And this isn't like a deal breaker or anything, but I think it would be nice if init codes were validated when they get on chain for the first time instead of. I think that's just more efficient overall. If they get validated, the first send instead of every time create is called.
00:09:00.660 - 00:09:24.080, Speaker A: Okay, so you say validate anit code first time they come on chain. That would be if it's in a subcontainer or just when it's in a transaction and you cache the results.
00:09:25.780 - 00:09:36.790, Speaker D: No, when it's in a subcontainer. I think that maybe we just need an init code kind, section kind.
00:09:39.560 - 00:10:06.296, Speaker A: So I kind of went with that with createf. And I think the problem we get into it is you get into the init code. To run the init code, you need to know specifically what the address is that you're developing to. So that would involve, I mean, maybe it's not a bad thing. Maybe the address is still going to be a function of the contract, of the factory contract and the section. That's the init code. That's going to be the thing to make it unique.
00:10:06.296 - 00:10:10.128, Speaker A: If you have different init codes to call that init code, why do you.
00:10:10.134 - 00:10:14.512, Speaker D: Need the address that it's deploying to in order to validate it?
00:10:14.646 - 00:10:17.970, Speaker A: Because not to validate it, but to execute it.
00:10:19.700 - 00:10:20.448, Speaker D: Yeah.
00:10:20.614 - 00:10:25.684, Speaker A: You can still call the address opcode inside of the knit code, and it's supposed to return the address that you're at.
00:10:25.882 - 00:10:27.030, Speaker D: Yeah, sure.
00:10:27.480 - 00:11:10.108, Speaker A: So we would need to have in that spec. So that's why for my create f spec, I would have to drop the return, the split returns, because you wouldn't know the key parts the address would come from. Whether you're returning from the container or returning from some external source, you still need to know where it's coming from. That's one of the issues that's still open. I'm all on it. And try and maybe iterate on my create f to see if we can get something there. But that was the issue I ran into, was how do we define what the hash is going to be for the derivative address and make sure that it's got the right kind of protections you would want to see from create two, or probably safer, possibly safer than create two.
00:11:10.108 - 00:11:54.800, Speaker A: I don't think we can prevent. We're getting ready to self destruct. So in one way we can but prevent multiple contracts being deployed, possibly from the same init code based on call parameters. Because the idea is that the original create two proposal, the idea was you would put some money at a remote address with a fixed hash and you would have certainty as to what it is. And I guess the argument there is you go read the init code and you make sure it's not polymorphic and make sure it's only going to result in one that just increases the level of knowledge. But those are the concerns that I would want to see resolved for this. Create copy is easy, you just point to the address and that would be part of the opcode.
00:11:54.800 - 00:12:11.830, Speaker A: But you would need to have the address resolved and solid before you start initializing. Running the first operation of the init code in case the first thing they do is ask for the address. So in those proposals, that's one thing we would need to work on.
00:12:12.600 - 00:12:19.560, Speaker D: Yeah. I'm wondering if you can do something which is just like validate the outside container if it has subcontainers.
00:12:20.540 - 00:12:25.530, Speaker A: That's the current proposal is you validate the outside container and then when you.
00:12:29.340 - 00:12:33.230, Speaker D: The first layer of the unit code. Yeah.
00:12:34.960 - 00:12:39.892, Speaker A: Just the first layer. Just the first subcontainers. But you don't validate sub subcontainers.
00:12:40.056 - 00:13:05.880, Speaker D: Right. Yeah, exactly. If you see anything which has like section kind in it code, which I'm not sure exists yet, but I think it would be useful to have that distinction between data and init sections, in it code sections. But if you see those, then you validate the outer layer of that thing. And I think that would just save a lot of gas at runtime.
00:13:08.460 - 00:13:08.776, Speaker A: Because.
00:13:08.798 - 00:13:14.680, Speaker D: Then you don't have to run the validation again every deploy.
00:13:16.000 - 00:13:28.050, Speaker A: Yeah. Let me think about it while I'm on the plane. I think there might be something in creative, I'll have to think about all the implications on it. Okay.
00:13:30.580 - 00:13:45.860, Speaker D: Yeah. And then this nice to have would be, be able to deploy from a knit code that's not in the current contract, but from an external contract. So an additional address parameter.
00:13:50.170 - 00:13:55.160, Speaker A: So you want both unit code and the contract and be able to reference an external contract for the unit code.
00:13:56.970 - 00:14:00.520, Speaker D: It's not a showstopper, but it's a nice to have.
00:14:02.170 - 00:14:04.150, Speaker A: Couldn't we do that with a factor pattern?
00:14:06.410 - 00:14:11.630, Speaker D: Um, that's why I said it's not a showstopper.
00:14:12.210 - 00:14:12.960, Speaker A: Okay.
00:14:14.450 - 00:14:19.760, Speaker D: Yeah. It requires special factory contracts and so on.
00:14:24.250 - 00:15:25.144, Speaker A: Right. I'll add that to the still open list. Call fi, create opcode where we copy external contracts by address, validate subcontainers inside of the of yes or no solutions to not having to double s containers or factories, along with exp data copy and stack range. Okay. All right, so I added that to the agenda. It's still open, unless. Unless we have, like, Powell or some of the other original authors of EOF.
00:15:25.272 - 00:15:27.648, Speaker B: We've got Axic Andre on here now.
00:15:27.814 - 00:16:08.190, Speaker A: Axe and Andre on here. Okay, should I start? I put my beginning of my list again, then go for it. So, one thing we discussed in the past few calls was a need for ext data copy and the data opcodes. This would make the job a lot easier for contract storage based solutions rather than having to go through an interface, ask for the data through the ERC method. I know that was initially deliberately dropped from the spec. How strongly does epsilon feel about adding it in?
00:16:17.600 - 00:16:28.610, Speaker E: I personally am slightly against just to increase the scope, but not super against, especially if someone else works on the spec.
00:16:30.500 - 00:16:37.024, Speaker A: Okay, Asic. Yes, sir.
00:16:37.082 - 00:16:48.360, Speaker C: I've been kind of out of the loop for various reasons. I imagine this instruction is similar to what we discussed in vice.
00:16:48.700 - 00:16:51.704, Speaker A: Yep, is exactly it. Yeah.
00:16:51.822 - 00:16:59.468, Speaker C: That somehow we get any code into an account and then give the instruction to deploy from that account.
00:16:59.554 - 00:17:14.050, Speaker A: Right. Oh, so this is a separate issue. I started back at the beginning. We're just talking about ext data copy. We also talked about the create copy issues as a separate one that Viper was concerned about. But I was starting at the ext data copy op.
00:17:17.240 - 00:17:24.040, Speaker C: I mean, yeah, I have no reasons against it. I think the only reason they left it out was just for the scope.
00:17:24.380 - 00:17:31.980, Speaker A: So the next point was, if you need help writing the spec. If I were to write it, it could go in. Is that what I heard from Andre?
00:17:36.430 - 00:17:37.180, Speaker E: Yeah.
00:17:38.430 - 00:17:52.400, Speaker A: Okay. The big blocker is writing up the spec. So I'll add that to my plate. Then that I'll do a first draft on the data opcode zip, unless someone else already has a draft that they're working on. Cool.
00:17:58.530 - 00:18:46.370, Speaker C: I do have, like, a soft pushback, just generally to the notion of increasing the scope, because we have been so far unlucky to get this into mainnet. And I guess initially we did start with, like, a really simplified spec, and then over time we extended it, but now we're getting into territory where it's going to be like, I don't know, 25 instructions. So I'm kind of worried that our chances are getting even lower with all of that. Long story short, maybe the best way if, I mean, I did miss, like, the first ten minutes, maybe. There was like a really strong reason that we want x data copy.
00:18:48.070 - 00:18:48.386, Speaker A: But.
00:18:48.408 - 00:18:58.520, Speaker C: I would probably put it into like a separate, optionally ip that specific instruction, or at least emphasize that we can launch without it.
00:18:58.890 - 00:19:10.182, Speaker A: Okay. Because we have to have the data copy ones that's given. So I could put ext in a separate file and that could be advanced separately because it's.
00:19:10.246 - 00:19:25.278, Speaker C: Yeah, I definitely like the notion you brought up months ago that if somebody wants x data copy, they can actually have maybe like five instructions in their contract to perform that.
00:19:25.364 - 00:19:25.614, Speaker A: Right.
00:19:25.652 - 00:19:31.440, Speaker C: With a call. Okay, did that notion change?
00:19:31.990 - 00:19:52.150, Speaker A: It's still there. There was concern about gas optimizations. Yes. And we don't have too many real world examples. So if we have two eips going forward, one with data opcode and one with ext data copy, then there's a possibility.
00:19:53.130 - 00:19:54.200, Speaker C: Is it me?
00:19:54.810 - 00:20:12.990, Speaker A: I'm willing to write these if time's the issue. Both of them or one of them just ex data copy and you have the other data opcodes. Either way, just let me know what would help. And Alex's Internet just went out.
00:20:20.690 - 00:20:23.920, Speaker E: I can work on data code spec this week.
00:20:24.290 - 00:20:24.894, Speaker A: Okay.
00:20:25.012 - 00:20:26.394, Speaker E: Except x data copy.
00:20:26.522 - 00:21:17.470, Speaker A: So I'll write a separate one on ext data copy and then we can advance them separately and see what the appetite of all core devs is. Okay. And then the rest of the open issues that I pasted into the agenda. Callify jump fi again, there's the meta concern about too many opcodes. Create opcode for external is the same open question about validating subcontainers instead of EOF containers. Currently the spec is no validation and you validate when you use the stuff pulling out of the container. Yeah, so I think those are still the open issues.
00:21:17.470 - 00:21:21.996, Speaker A: Yeah.
00:21:22.018 - 00:22:05.820, Speaker E: Validation I also will have to think about, because somehow we rejected this idea in the beginning in Austria. Yeah, so I have to remember the reason. Still didn't have time to remember, so I'm not sure. Maybe it can possible also about qualify jumpify I had one question or thought so far only jumpify makes sense to me because qualify, if you call a function with outputs, what would it do in case the condition is false?
00:22:06.480 - 00:22:16.050, Speaker D: That's a good question. I think that it should only be allowed for non returning, or rather returning zero things that don't modify the stack. Right.
00:22:18.100 - 00:22:21.650, Speaker E: Is it needed at all? Maybe we can do with jumpify only.
00:22:26.040 - 00:22:36.360, Speaker D: I think I have to double check because we wrote our code when jumpify was not on the table, and so I need to check if it violates the assumptions or something.
00:22:36.510 - 00:22:37.210, Speaker E: Okay.
00:22:38.860 - 00:22:47.370, Speaker A: Because I thought these were only needed for like outlining reverts, so you would jump into a terminal function anyway, so you wouldn't need a return.
00:22:49.760 - 00:22:59.740, Speaker D: Right. I'm not sure if you can use jump fi for that, or if you need qualify, probably you can use jumpify.
00:23:01.780 - 00:23:10.000, Speaker A: Yeah, because if the only exit from the function is a revert or a return, then there's no need to call a reTf.
00:23:18.200 - 00:23:55.280, Speaker D: Yeah, I think qualify is okay, bottle only if it doesn't change the stack, because in that way, under your rate, it's very different from our jumpy. It doesn't actually affect control flow, it's just conditionally jumping into this function. But like the next instruction is going to be the next instruction, right? There's no, yeah, it doesn't actually conditionally change the pc.
00:24:28.560 - 00:24:39.270, Speaker A: Anything else that Ipsalon wants to share or voice concerns about, or open discussion about.
00:25:00.520 - 00:25:23.580, Speaker C: At least not from my side. I just wanted to give a tiny bit of update in the sense that I think we have been mostly focusing on EVMX and work related to that. If you're not aware of what EVMX is, it's a very simple instruction set, just three, four instructions.
00:25:25.360 - 00:25:26.044, Speaker A: And it makes.
00:25:26.082 - 00:26:47.510, Speaker C: It possible to implement a lot of the pre compiled elliptic curve functions. And I think we're probably going to get to the point in a month that we get back to the US. Part of that, we're trying to implement this on the EVM directly, but instead of what we have done in the past few months is using the same primitives, but implementing all of that in C, just to validate the idea that those primitives which would go into being EVM instructions, those are actually enough to implement the actual precompiles. And I think we did prove that a second stage will be to actually move that over to EVM. And then the UF requirements are the discussions via the data wise that there would be probably some kind of like setup section or a different kind of memory, et cetera. In any case, I think there will be more connections of this work with the UF work at that point. And that's maybe the reason.
00:26:49.800 - 00:26:50.276, Speaker A: We had.
00:26:50.298 - 00:26:54.650, Speaker C: Less output on EUF, because we put the effort into EVMX in the past few months.
00:26:55.020 - 00:27:02.990, Speaker A: So would EVM Max be required in the first revision of EOF, or could it come in on a follow on revision? How tight is it?
00:27:04.320 - 00:27:11.980, Speaker C: No, it should not be. We don't want to make any more complications into EOF.
00:27:12.140 - 00:27:15.680, Speaker A: Okay, so it could target Osaka and EOF could target Prague.
00:27:16.900 - 00:27:17.650, Speaker C: Exactly.
00:27:18.100 - 00:27:34.900, Speaker A: All right. So that brings up a meta question. How do we want to proceed in advocating this to all core devs? Do we think it's ready enough to give a presentation like Verkel trees gave? Do we want to wait until after Denkoon to have that presentation.
00:27:38.140 - 00:27:39.972, Speaker C: For EOF or EVMX?
00:27:40.116 - 00:28:06.240, Speaker A: For EOF? So vertical trees, I mean, people are familiar with vertical trees. They gave a status update to all core devs. Do we want to give a similar one just for EOF or maybe for EOF and EVMX? Or maybe two separate ones to kind of advocate for our position and make sure that it's on the schedule? Or do we just want to go straight to putting it in so that when we start talking about Prague stuff, proposing it as the headliner.
00:28:08.180 - 00:28:43.630, Speaker C: No, I definitely like the idea that we should start advocating for it. Yeah, because we did hear it a number of times that stuff was proposed late. And why is it even considered? There's only so much space left in people's minds regarding what is important and it's in many cases a game of what do they hear about the. Yeah, we definitely should start giving updates about the UF just to have it a discussion point.
00:28:44.160 - 00:29:16.934, Speaker A: Okay, is this a presentation we want to give in three weeks or five weeks? I don't think we want to go into next week's all core devs. I don't think there's enough prep time for that, although I'm willing to be persuaded against it. I'm wondering if we should propose for three weeks, which would be beginning of September or middle of September. And I think more people be back at work in September. I think it'll be better then. And Alex just cut out again. So this is something I think we could actually mid September sounds good.
00:29:16.934 - 00:30:20.640, Speaker A: I think this is something we could coordinate on the Discord channels. Also issues of who gets the biggest present, who presents probably ipsalon, and what the content of the slides are. Because I think Prague's really starting to certainly once we get testnet dates picked out for Denkun, then we can really start shifting into being serious about focusing on what's on Prague. I think this is the right time to start bringing some of those discussions up and asics going to switch devices. So I think that's my meta questions and my issues I'd like to see advanced here. And we wait for ASIC to switch devices still listing. Okay.
00:30:25.490 - 00:30:38.546, Speaker B: That light feels like maybe closer to five weeks would give us a bit more time. It still feels we're pretty deep in the den cone triaging even like in.
00:30:38.568 - 00:30:44.580, Speaker D: Three weeks, I don't know, eip 663 going to be part of us.
00:30:54.110 - 00:30:59.050, Speaker E: Yeah, I think we plan to roll out together with you. It's not required.
00:31:01.070 - 00:31:04.154, Speaker A: Basic has it implemented? I think evm one has it implemented?
00:31:04.282 - 00:31:20.530, Speaker D: Yes, because I think that six six three probably needs some changes. I think for it to be really useful it needs swap Nm instruction.
00:31:21.910 - 00:31:22.900, Speaker E: Which one?
00:31:23.270 - 00:31:28.306, Speaker D: Swap nm. Swap the anth and m items in the stack.
00:31:28.498 - 00:31:30.150, Speaker A: Oh, swap nm.
00:31:31.450 - 00:32:53.010, Speaker D: Yeah. And there's, by the way, since my understanding now is that future Uf versions, the strategy is to try to transpile them. So ufv one, if we have ufv two, then we're going to try to transpile from v one to v two, then I actually don't feel as strongly about dupe n starting from one instead of 17. Eamon says, what is swap Nm useful for? It's very useful for stack scheduling. When you're scheduling items on the stack, you right now you need three item, three instructions to schedule things that are more than one item deep in the stack. And you can swap Nm allows you to do that in one instruction. And I mean, from the implementation you can kind of see that it costs the same amount from an implementation perspective.
00:32:54.710 - 00:33:37.582, Speaker A: So a little bit of a tangent as far as the transpolation. My thought was that the transpolation would only be necessary when we do a breaking change. Like let's say we get rid of the swap X and the Dupex series of operations and rely on swap and dupen. That would be an incompatible change that we could transpile into. But doing things like adding new operations that don't break things are what I would term forwards compatibles, where the full set of valid EOF programs is not reduced but only increased those I would consider forward compatible. It wouldn't require a version change, wouldn't require transpolation. We just treat it like we've done it before.
00:33:37.582 - 00:34:31.310, Speaker A: We just add the new operation, we update the code validation rules. What used to be invalid is now valid. So adding an operation like swap Nm or ext data copy wouldn't require a major version number change. That's my thought on the need for desire, the product management thing of making it the smallest necessary change, and then bringing in these other changes later like SwaPNM and ext data copy I think would be the more prudent one. I am persuaded by Alex. I do want to see ext data copy, but not to the point that it causes EOf as a whole to be rejected. And by floating the two separate proposals and proposing swap Nm later.
00:34:31.310 - 00:34:51.874, Speaker A: That gives us the option of either bringing it into Prague if people think it fits in, or bringing it in in Osaka when it's already in, and we're just growing it to increase to improve the user experience and the compiler experience and making it more accessible from my perspective.
00:34:51.922 - 00:34:56.940, Speaker D: By the way, swap NM is more important than all the other instructions in EIP. Six six three.
00:34:58.270 - 00:34:59.020, Speaker A: Okay.
00:35:02.110 - 00:35:50.730, Speaker D: Yeah, actually my concern with dupe end starting from 17 is if we start to remove other dupe instructions, then tooling will have to maintain. Like we'll have to be able to deal with multiple versions of UF, which is like not the end of the world, but also not really ideal. So I think it's better if it's kind of more future proof from the get go. But yeah, it's also, I mean, I think Daniel and Axic's concerns are now there's like duplicate instructions basically, which is weird.
00:35:51.550 - 00:36:12.740, Speaker A: So the mega EOF spec has dupen without the 17 shifting. So there is in essence a duplicate set of instructions. It's the immediate plus one and they swap. There's no 16 base shifting, the same as swap. There's no 16 base shifting according to the mega EOF spec.
00:36:13.450 - 00:36:38.220, Speaker D: Yeah. And I think that's something that I requested from Axic. Well, I'm here to say I don't feel that strongly about it anymore, but yeah. The issue of forwards compatibility is. Yeah, I don't know really what is the right call here. So maybe leaving it as is just fine.
00:36:39.870 - 00:37:45.140, Speaker A: I like the way it's coded right now, so in case we get rid of it in the future, the transpile burden if you're using the old dupe codes and the old swap, if you're using Dupex or swapx, those just get transpiled into a two byte instruction and the existing dupen and swap n stay the same. Mild preference total. Willing to lose on it. But that's what I like about the current setup. All it. Okay, any other questions? Should we give people 20 minutes back?
00:37:45.550 - 00:38:03.100, Speaker B: It's good with me. Any last comments? Okay, thanks a lot, guys. We'll talk again here in two weeks. Have a good rest of your day.
00:38:05.550 - 00:38:06.970, Speaker A: Thanks, bye.
00:38:07.710 - 00:38:10.070, Speaker C: Thank you. Bye.
