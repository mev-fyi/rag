00:00:00.800 - 00:00:44.604, Speaker A: Like to welcome everyone to EOf implement your call number 49. Nothing out of the ordinary on the agenda. If you have anything you'd like added, please add in comments. We're going to start with client updates, compiler updates, spec updates, two categories of spec changes and testing update and other items. Did we get clarity on the solidity return data changes last week? Before we go much further, someone could write what if we needed to do anything about that in the comments so it's there when we get there. But first for client updates. Ahmed, do you have anything for another mind?
00:00:47.464 - 00:00:49.124, Speaker B: Nothing from our side? No.
00:00:49.584 - 00:00:57.764, Speaker A: Okay, Andrew's next. Andrew is next on my list. Do you have anything for EVM one?
00:01:00.314 - 00:01:36.274, Speaker C: Yeah, we have merged creation transaction support and also the change to x calls to be address based expansion ready. So this aborting on high bit set of the address and also we merge return data copy out of bounds. Zero if I didn't change. Yeah. Init code mode validation still.
00:01:40.614 - 00:02:00.918, Speaker A: Cool. I'm next. Alphabetically. Base is just initially writing the tests. We're discovering some spec issues, things that are intuitively say one thing and spec says another as running them. And that's something that will come in the spec updates. So that's mostly another thing.
00:02:00.918 - 00:02:47.376, Speaker A: I'm starting to merge from the mega EOF branch into Baesu proper. It's kind of a tangent that would impact testing, but I'm not merging it directly into Prague. I'm creating a fork inside Baesu called prog Eof until we get clarity on exactly where it's landing. But for reference tests, when you say prog and reference test, it's getting used prog EOF. But when you use it elsewhere, like in a genesis file or the EVM tool doing traces, when you say prog, it means prog. Expect if you want EOf, you need to do prog EOf. That's something similar going on with the tests and that they have a Cancun EIP 7692 target that's coming in now.
00:02:47.376 - 00:03:02.204, Speaker A: So that's kind of lining up with that. Um, let's see. Marius, anything from Geth? Not really.
00:03:02.864 - 00:03:20.154, Speaker D: Still cracking on, I think. I have roughly 60 tests that are failing of the thousands and I'm going through every one of them and try to fix them.
00:03:21.414 - 00:03:22.314, Speaker A: Okay.
00:03:22.734 - 00:03:25.350, Speaker B: Yeah, but it seems like most of.
00:03:25.382 - 00:03:30.054, Speaker D: Them are duplicates, so should be maybe.
00:03:30.094 - 00:03:35.994, Speaker B: By the end of the week I have something that passes most.
00:03:38.674 - 00:04:13.616, Speaker A: Yeah. Since we can parametrically create tests, we can hit the same bug hundreds of times with two lines of code. So that's to be expected. It's one of the great things about the python tests. I don't see anyone from ret here, I don't see anyone from Ethereum, j's here, or Aragon. Correct me if I'm wrong, I guess EVM, kind of evM, one for Aragon, three. Any clients I missed, if not compiler updates.
00:04:13.616 - 00:04:18.176, Speaker A: Charles, do you have anything this week for Viper?
00:04:18.360 - 00:04:38.024, Speaker B: No, but I've been working a lot on stack scheduling, which is like, for existing EVM. And yeah, I have a lot of. I was wondering if there's like some kind of shuffle instruction that is more general than swap or exchange.
00:04:39.324 - 00:04:40.744, Speaker A: What do you mean by shuffle?
00:04:41.924 - 00:05:21.764, Speaker B: It's a generic instruction that takes like. I don't know, I just came up with it, really. But there's like some things that are like, not necessarily unsolvable, but there's some stack scheduling problems that are like np hard. And if you can just shuffle. So like, it's in, you take, you have like a one byte immediate that says how many items you want to shuffle and then a list of the items that you want to change. Sorry, how do you shuffle? Do you like shuffle the randomly or. No, no, no, no.
00:05:21.764 - 00:05:45.764, Speaker B: Basically you have a starting stack layout and you have a target stack layout. And right now, like, we generate like individual swap instructions. And in EOf we would like have more options, like more swap dupe exchange instructions. But like, what might be even better is just like a straight up shuffle thing where you like start layout and.
00:05:45.804 - 00:05:53.834, Speaker A: The target layout shuffle eight, and then you have eight bytes that would have the numbers one through eight in a new order. And that's what you would change it to.
00:05:53.994 - 00:05:54.734, Speaker B: Yeah.
00:05:55.154 - 00:05:56.014, Speaker A: Okay.
00:05:57.554 - 00:06:37.284, Speaker B: And then that has like kind of easy costing because it's just like the number of items that are shuffled, I think three times the number of items that are shuffled. I was also thinking about the EIP 663 instructions and wondering if there's any performance implications once we want to like compile to JIT, compile them, or ahead of time compile them to native code. But yeah, that's just things I'm thinking about and maybe somebody from Ipswan or anybody else has thoughts about that.
00:06:43.444 - 00:06:59.544, Speaker A: Ypsilant, any thoughts? If you're doing register mapping, I expect the dupes and swaps and exchanges to be fairly transparent. But if you're targeting a stack machine, it's the same issues.
00:07:00.884 - 00:07:59.244, Speaker B: Well, the thing is like, the kind of goal is to turn EVM code to native code through LLVM or something. Right. And the more things that are accessible from swaps the more kind of problems you have. Actually, I don't know if it's a concern in practice, but theoretically the compiler has to do more work, has to do like register coloring with more stack items. And I'm not sure if, I think maybe these are just optimized out so at runtime, but I'm not sure. So it definitely increases compilation overhead by an unknown amount, maybe negligible, but maybe not. And there may be a runtime cost.
00:07:59.244 - 00:08:01.964, Speaker B: So I think.
00:08:02.544 - 00:08:03.444, Speaker A: Go ahead.
00:08:03.784 - 00:08:34.744, Speaker B: Uh, yeah, I mean this is also part of a problem about the gas schedule, right? So like I think a lot of things should be revisited in EOF because the gas pricing is the way it is, because of, well, the way the EVM currently is. And like things like pop swap can be really like one gas or something. Like they shouldn't be really much more expensive.
00:08:36.124 - 00:09:06.624, Speaker A: So since Dupin and swapn take immediates, a compiler could statically figure out how much trouble it's in. So that is, I don't think we have a solution for it today, but that is one thing I want to point out why doing a stack based dupe and a swap in would have been a compiler disaster. I'm not a disaster, but it would be, you know, we couldn't do it in order and we'd have to do it at execution time or do escape analysis. So at least with an immediate, you know, in one pass how much trouble you're in.
00:09:09.044 - 00:10:00.374, Speaker B: Yeah, but like register coloring is like NP complete. So like for the people on the call who are not familiar with compiler theory, I guess normally you have all these theoretical virtual variables, which in our case are basically stack items and you have to allocate them to physical registers at runtime. And there's heuristics to do that. But yeah, to do it optimally is NP complete. The more register spilling you have like more register kind of traffic you have, the harder it is for LLVM or whatever compiler that you're doing because like the nature of the algorithm is just like kind of combinatorial.
00:10:01.554 - 00:10:16.294, Speaker A: Yeah, I think that's why people aren't fans of blocking JIT compilers, why they want AOT or mixed mode compilers for the JVM. But once we solve storage, we can actually worry about those performance issues.
00:10:20.074 - 00:10:20.362, Speaker E: And.
00:10:20.378 - 00:10:53.600, Speaker A: Then solidity is not on the call. All right, so if solidity is not here, that should be it for compilers spec updates. My first question, did we get a resolution last week? I thought we timed it out on the discussion with solidity and what they wanted with ext call return codes and detectability. Was there any action needed on our part, or was the conclusion that it's just bad and we'll just deal with it?
00:10:53.752 - 00:10:59.176, Speaker D: We made notes in the issue. I mean, you made notes.
00:10:59.360 - 00:11:08.524, Speaker A: Yeah, I made notes. But did we have a resolution? Were they okay with the status quo? What's an eof? Do they require changes?
00:11:09.024 - 00:11:16.844, Speaker D: Well, Kanye said that at least I got an impression that it's more nice to have them that they'll manage without.
00:11:20.184 - 00:11:53.294, Speaker A: Yeah. So I'm inclined to table this with no action unless lenity raises it again. They still have time, if they come back in a meeting or two to get us to change on it, but I'm inclined to, if they're okay with it, stick with it. So who just came off mute? If you have something to say, please contribute.
00:11:56.994 - 00:12:01.902, Speaker D: Me? No, I'm probably okay.
00:12:02.078 - 00:12:08.006, Speaker A: So we'll leave there, and if they want action, we invite them to come back and make a very specific request.
00:12:08.070 - 00:12:10.794, Speaker D: Yeah, yeah, yeah. Like a stronger one. That sounds good.
00:12:11.414 - 00:12:58.394, Speaker A: Okay, a couple of changes that we need to clarify. The first one has to do with init code mode, runtime mode. This is a discussion on discord right now. The specification, actually, I have it here. The specification of whether your init code or runtime code is driven by the contents of the instructions, which creates a corner case when your only exit is a revert statement. And it could be both and also have creation transactions run in runtime mode. So I think we decided no on both of these, and we're just doing a final pass on this.
00:12:58.394 - 00:13:27.104, Speaker A: Allow return stop. Oh, yeah, sorry, this is a different discussion, but we're not going to allow return stop in creation. You need to revert or return a contract. And that's been merged and closed on that proposal and also run the creation traction creation transaction runtime mode. And I think the issue there is just gets too weird with legacy.
00:13:29.884 - 00:13:37.584, Speaker D: Yeah. And it's like the storage and value transfer problems and also that it sort of replicates 7702 in a way.
00:13:38.244 - 00:14:08.904, Speaker A: Yeah. Okay. One item that was discussed on discord and merged pretty quickly because there wasn't much to sent, but I want to put it on the call to make sure everyone gets it. The. That's not the link. I had 124 EOF EoA, so ext delegate call. We wanted to make sure it couldn't call legacy code.
00:14:08.904 - 00:15:00.388, Speaker A: And the way Besu initially coded it and EVM one coded it was to only allow exe delegate call other EOF contracts. What was unclear in the spec and has now been explicitly specified is how to handle EOA contracts. Eoas that don't have contracts and empty accounts is a byte code of zero linked legacy account or legacy contract. Or is it no contract? One interpretation is only, you know, real contracts. But I think what we decided to revise it to was the more restrictive one, just for safety in that exdelegate call will only succeed if the target is an EOF contract. So if you delegate call out to an empty account or an EOA account, it will fail as though it's calling a legacy account. I need to update the tests for this.
00:15:00.388 - 00:15:14.674, Speaker A: This got finalized this morning. Tests currently have it wrong, but this should be easy to fix and I don't think those tests have been merged yet and basically currently has it wrong per this spec and it'll be easy to fix.
00:15:16.374 - 00:15:17.874, Speaker B: Is there any revert data?
00:15:20.094 - 00:15:23.070, Speaker A: No, it just fails without revert data.
00:15:23.262 - 00:15:26.958, Speaker D: It fails with this. Hold on.
00:15:27.006 - 00:15:27.230, Speaker A: Yeah.
00:15:27.262 - 00:15:37.392, Speaker D: The so called light failure, which is coincident, coincides with the revert status code, but there's no revert data. So a one status quo.
00:15:37.528 - 00:15:42.604, Speaker B: I think that could be clarified because it says the Kali frame reverts but revert can have revert data.
00:15:47.424 - 00:15:55.164, Speaker D: The status code is same as when the Calley frame reverts if it were to revert. Right.
00:15:57.544 - 00:16:10.576, Speaker E: I think this is specified slightly different in the IP. So it's kind of piggyback on the call that failure. It's the same as the cold failure somehow.
00:16:10.720 - 00:16:11.444, Speaker D: Yeah.
00:16:12.304 - 00:16:19.808, Speaker E: I'm sure this is like the best description, but it kind of matches what we have implemented.
00:16:19.936 - 00:16:26.324, Speaker B: Yeah, yeah, I believe I probably need to reread it. Pavel, do you mind sending me the link?
00:16:28.414 - 00:16:36.754, Speaker A: How far up is the EVM? Is the EIP commitment? I'm looking at the wrong discord.
00:16:41.454 - 00:16:52.594, Speaker D: What is the initial gas cost for delegate call? Is this the worm co host?
00:16:57.274 - 00:17:01.374, Speaker E: Yeah, I think it's 100 for the, for the worm one.
00:17:04.594 - 00:17:14.654, Speaker D: Yeah. And it's. And that is charged in this case, obviously.
00:17:17.394 - 00:17:24.033, Speaker E: Yeah. So you need to fetch the account. That's true, but it's kind of true for everything else.
00:17:25.733 - 00:17:26.109, Speaker D: Yeah.
00:17:26.141 - 00:17:35.593, Speaker E: So even if there is a code, you need to fetch it and yeah, the code can just exit in the first instruction, so.
00:17:40.973 - 00:17:44.873, Speaker A: But it's still going to be subject to address warming.
00:17:45.684 - 00:17:46.036, Speaker E: Yeah.
00:17:46.060 - 00:17:49.276, Speaker D: Yes, yes, yes, yes, yes. If it's cold then it's going to charge.
00:17:49.340 - 00:17:58.384, Speaker E: I think we need to treat it as like fetch account and I think the smallest consistent with all the gas costs.
00:18:01.604 - 00:18:19.244, Speaker A: Okay. Yeah, I think that's implicit currently in the, in the costing, so we don't need a special case for that. All right, so I think that's it for spec updates we're getting to the full size object.
00:18:20.464 - 00:20:00.374, Speaker D: Go ahead, can I quickly describe it? So right now we have, for container size for subcontainers we have a size limit, which is implied by the header format, which is sixty four k. And on the other hand we have no such thing for the top level container, whatever that means. We have the AIP 3860 max init code size of 48k, but that is not validated as part of the EOF validate. And as such there is no, you know, it's not part of the validation test and so forth. And the problem is that there's, as far as I can see it is that it leaves the EVM implementations assuming what the maximum top level container size might be, both in terms of how many bytes that container takes and also what, what is declared in the header. So we don't know if it's, you know, we should assume it's max init code size or 64k, same as subcontainer, whether it is the whatever number we can max out by just putting the biggest code sections and biggest containers into the header, make the header declare the container as big as possible or any other arbitrary value. And we had a subtool bug in EVM one where we overflow because like the offsets that we have been parsing from the header were overflowing because they were expected to not exceed sixty four k.
00:20:00.374 - 00:21:10.134, Speaker D: And the proposal is to have a validation role for the top level container to not exceed max init code size. I mean, just align with whatever is the init code size maximum. So then the EVM implementations can, don't, don't need to figure out what that is, it's just specked out by the validation. And if max init code size would go up, then it would go up together for, I don't know, for some future update. And then all the tests, you know, it's not, if the size is exceeded, then the test is just a failure. I mean, it tests that the validation fails, and if the size is lower than this limit, it's fine, there's no guesswork involved. What do you think?
00:21:12.674 - 00:21:37.474, Speaker A: I support it personally. When I wrote the tests, I deliberately went at those levels to try and tickle the bug. And at the time there was no size checking base who had it, I took it out, can put it back in. I'm totally okay with validating init code runtime code size at container validation time. Any other opinions? Just my opinion.
00:21:38.414 - 00:21:57.244, Speaker D: And just to make it complete, I think we should validate both the, the size of the byte string that's being ingested and also the declared size. So, you know, whenever the sizes which are parsed exceed the limit, then it should fail.
00:21:58.584 - 00:21:59.736, Speaker A: Yes, like, no.
00:21:59.760 - 00:22:13.624, Speaker D: It declares 200 sub containers, subcontainer sections, and then the 201 goes over the limit per declared size, and then it's a failure.
00:22:15.404 - 00:22:17.584, Speaker C: What do you mean? I'm not sure.
00:22:19.044 - 00:22:31.304, Speaker A: So like a truncated container for a return contract, if it's declaring that the minimum size is greater than 24k, then it fails container validation rather than runtime validation.
00:22:31.924 - 00:22:36.044, Speaker C: Okay. Yeah, I think I see. Makes sense.
00:22:37.064 - 00:23:24.964, Speaker E: Yeah, it's fine. Just wonder if it doesn't break solidity. But I need to check with someone, because what I noticed is that they organize tests in a way that they kind of inject additional codes to the test, and then if the test target is already close to the limit, just go subject. We had examples of these already with some, like big contracts that we try to. Yeah, but I maybe rather can comment on this, but I think I would agree to put it in unless there's like big reason not to.
00:23:26.424 - 00:23:34.264, Speaker D: I mean, we can have it twice the maximit code size. So that's also an option, at least as far.
00:23:35.084 - 00:24:03.504, Speaker E: I think it's just like usability issue that, like, if we strictly start to checking this at the front end of EvM, that's like country. I mean, you would need some other flag or maybe some, something to bypass it if that's needed. Yeah, but I think it makes sense to put the limit.
00:24:05.724 - 00:24:38.414, Speaker D: I mean, we can also put the limit for whatever can be really crammed into a container. Like calculate how many huge code sections you can have and just sum everything up and then just calculate that. And these are the limits. I mean, my main premise is that we have a limit, you know, cannot go arbitrarily large or up to some undefined amount, which makes overflows happen.
00:24:39.234 - 00:24:55.284, Speaker A: Right. Without size metering, we could go up to 64 megs, I think. So we need to do size metering somewhere. 64 max, from which 1024 full size code sections.
00:25:01.184 - 00:25:10.792, Speaker D: The containers are 256 limited, and then, so the containers can take up to 16 megabytes, I don't know, code size or code section.
00:25:10.848 - 00:25:23.116, Speaker A: And the containers. Oh, that's right. Because you can have containers of maximum size, yet we need to enforce it as part of validation before we get too deep into it. Yeah, definitely.
00:25:23.260 - 00:25:35.744, Speaker D: But yeah, like, I think maxed init code size is more practical or twice that amount is just something more tangible than trying to figure out what's the maximum we can declare.
00:25:38.664 - 00:25:44.924, Speaker A: So you want the test, the test double init code size, not maximum possible. Or you want the code to allow it?
00:25:46.464 - 00:25:49.464, Speaker D: Sorry, I understand when you say double.
00:25:49.504 - 00:25:57.512, Speaker A: The max init code sizes, you want test to test the double maximum init code size. Or do you want the internal parsing to be able to handle up to that much the, rather than the latter.
00:25:57.568 - 00:26:13.944, Speaker D: So the validation rule says that the declared and actual size of the total container cannot exceed two times maximum cosize. So it's just as a reference point, so to speak.
00:26:15.004 - 00:26:18.744, Speaker A: Any container greater than twice the net code size is invalid by rule.
00:26:19.244 - 00:26:28.184, Speaker D: Yes. And any container which contains a, you know, the declared sections which go over that limit is also invalid.
00:26:28.764 - 00:26:52.916, Speaker A: But if the top level container is limited. Oh, the declared size, okay, declared one. So pipe rule. And we let the, we let the storage system and other systems enforce the rule, right? I mean, we can't just supplant the init code size rule in runtime rule.
00:26:52.940 - 00:26:58.984, Speaker D: Right now we do, but for the creation transactions.
00:27:01.324 - 00:27:05.624, Speaker A: So it sizes checked and return contract.
00:27:08.844 - 00:27:23.104, Speaker D: Yeah, that's for the deployed code size, including the expanded data section. That's right, yep. But the inbox size is only checked in the creation transaction.
00:27:23.484 - 00:27:28.596, Speaker A: Create transaction is going to enforce the a 48k rule as well, right?
00:27:28.740 - 00:27:34.064, Speaker D: Yes, but you don't really, you know, that's not part of the validation. So then validation is kind of.
00:27:37.324 - 00:27:40.824, Speaker A: So validation only could handle up to 96k. Right.
00:27:44.364 - 00:27:48.344, Speaker D: So that would be the twice, twice the machine close size one. Right.
00:27:49.244 - 00:27:52.584, Speaker A: But there's no way to get containers of that size in.
00:27:53.564 - 00:28:10.344, Speaker D: Right. But I mean, the premise is that the validation is kind of decoupled. Right. Now you have tests for the validation only, right. So there's no common point of reference of how big the input to a validation routine can be.
00:28:11.804 - 00:28:12.492, Speaker A: Okay.
00:28:12.588 - 00:28:17.584, Speaker D: So the implementation is going to be prepared for sixty four k and the other one might be for something different.
00:28:18.144 - 00:28:45.764, Speaker A: Okay. I think we need specs written up for this then, before we can go deeper into it. All right, it sounds, I mean, because, I mean, if it's adopted, we would need specs anyway, so. But that sounds reasonable that for validation, any container over certain sizes, by rule invalid, don't even attempt to parse it. And we can change that value as blockchain tech improves. Yeah, I think that's actually fine.
00:28:45.924 - 00:28:48.412, Speaker D: I can write this down so that people can read it.
00:28:48.428 - 00:28:50.504, Speaker A: Andre.
00:28:52.284 - 00:29:01.104, Speaker C: You'Re thinking about validation of Genesis accounts maybe it makes sense. Apply the same size, right?
00:29:01.964 - 00:29:05.364, Speaker A: Genesis is also subject to the 24k limit, right?
00:29:05.524 - 00:29:05.884, Speaker D: Yeah.
00:29:05.924 - 00:29:17.844, Speaker C: Right. So it's this like validation limit should at least include in your code limit, right? So yeah, this argument doesn't apply.
00:29:22.264 - 00:29:28.324, Speaker A: Okay, so we'll discuss it next week with written up spec on that and then we can move to finalize it.
00:29:29.224 - 00:29:49.064, Speaker D: And there's a question from Mario. So the 64k limit, it is kind of implied by the header format, but it only applies to the subcontainers because we have two bytes for the subcontainer size.
00:29:50.724 - 00:30:24.924, Speaker A: And there's a couple of things playing into that. Charles's VLQ proposal would allow us to not have that limit, to have arbitrarily large code sections. But right now the init code and deploy code limits prevent that from being an issue. And I think a bigger issue that I didn't mention on the vertical call, but I need to raise it, is vertical limits code sizes, 64k right now, which is going to be the bigger limiting factor going forward than anything else in the world.
00:30:31.004 - 00:30:35.944, Speaker D: But that does not concern init code also which needs to be UI validated.
00:30:40.164 - 00:30:59.478, Speaker A: We could do a bit for VLQ in the header. There's more than just header size. There's also. We need opcodes that do VLQ too. Otherwise you're going to be limited to a jump range of 32. I mean, you're already limited to a jump range of 32k. You can't jump from the beginning to the end without having a little help in between.
00:30:59.478 - 00:31:03.114, Speaker A: So we would need VLQ opcodes as well.
00:31:07.534 - 00:31:08.714, Speaker B: Yeah, I agree.
00:31:10.534 - 00:31:15.074, Speaker A: But I think that's something we can revive, we can address in future additions to EOF.
00:31:15.534 - 00:31:23.854, Speaker B: Well, it's like, excuse me, some way of future proofing without making changes to the format right now.
00:31:27.114 - 00:32:13.164, Speaker A: Yeah. Okay, so another proposal at the bottom. This is talking about something we were talking about on chat yesterday today perspective. Right now, a subcontainer could be both a deploy container and a runtime container if it only contained revert invalid and didn't have a return contract or a stop or a return. By the current specification, EOF create and return contract could reference the same container. We need a. This does not seem like a good solution right now.
00:32:13.164 - 00:32:48.524, Speaker A: So we need to do probably one of two things. Yeah, I guess we need to figure out which one we want to do. One is we can require every subcontainer to have a stop or return or return contract. One of those three operations. If it doesn't have any of those the subcontainer would be invalid by rule and rejected. The other option is to disallow EOF create and return contract from referencing the same container and letting the use context drive, whether it's init code or deploy container. Any preference on which options people would prefer?
00:32:51.784 - 00:33:07.444, Speaker D: I got a question about the parentheses note at the bottom of the comment we're seeing. Option two would still allow containers that only have revert, but only if either we allow that subcontainers or it's a top container.
00:33:09.124 - 00:33:13.224, Speaker A: Um, I guess a top level container could have nothing but revert.
00:33:14.524 - 00:33:24.984, Speaker C: No, it can. Yeah, if it's only referenced by one u of grid or like several u of grids, but not return contact, it still can have a revert.
00:33:30.924 - 00:33:35.428, Speaker D: Oh, right, sorry, this was just like a weaker rule. Okay, gotcha.
00:33:35.596 - 00:33:41.144, Speaker C: Yeah, I'm more in favor of the second one, I think.
00:33:42.164 - 00:33:43.024, Speaker A: Okay.
00:33:43.484 - 00:33:51.036, Speaker B: Yeah, I mean, it's totally valid to have like signaling contracts which will never revert, but.
00:33:51.100 - 00:33:57.504, Speaker A: Okay, that was my question. Is there utility and contracts that only revert? And hearing that there is, so we should probably keep them.
00:33:57.884 - 00:34:03.804, Speaker B: Yeah, but I don't actually understand why is this a testing issue in the harness?
00:34:05.024 - 00:34:10.004, Speaker A: It will be. We need to test all corner cases and this is going to be one that we would need to test shortly.
00:34:13.504 - 00:34:25.724, Speaker C: Yeah, my handshot. So implementation will be a bit simpler. I'm still prototyping this, but I expect it to be simplified.
00:34:26.704 - 00:34:42.774, Speaker B: I mean, I don't think it's a very common use case, but I think that, I mean, Uf create and return contract, both referencing a valid revert. A reverting container seems valid. They're just sharing the revert code.
00:34:44.394 - 00:35:05.634, Speaker A: It makes the code more complicated and less deterministic, though, is the counterargument. Sure, we could save space, but now that I think of it, I do see value in reverting contract because you could have on one chain that will do stuff and on another chain it always reverts. So you could like lock up your solution on a different chain and always have it revert.
00:35:07.014 - 00:35:29.424, Speaker B: Yeah, I mean, there's like ercs that just revert, but yeah. I still don't understand why you can't have UF create and return contract reference a reverting contract or reverting container.
00:35:30.604 - 00:35:33.264, Speaker A: We can, it would be more code and more testing surface.
00:35:40.324 - 00:35:50.718, Speaker B: Sorry, what is the more code? Because like you have to. Oh, I see what you're saying. Because like normally you only allow one or the other, so, so you need.
00:35:50.766 - 00:36:15.914, Speaker E: To know which, which kind of it is by this us create or Internet contract. And for each kind you need to validate in different mode. So for this like revered container you would need to validate it kind of twice to make sure it kind of fits the both context that's diminished.
00:36:17.934 - 00:36:27.594, Speaker B: I don't think there's a dependency. Right. Like you don't need to know what kind of container it is before you validate it. You just like analyze it and figure out whether it's runtime or a niccode.
00:36:28.214 - 00:36:29.646, Speaker A: You would need to know how it's used.
00:36:29.750 - 00:36:29.942, Speaker E: Yeah.
00:36:29.958 - 00:36:36.358, Speaker D: But then the testing gets, gets hairy. That's very interesting, I think.
00:36:36.486 - 00:36:36.790, Speaker A: Yeah.
00:36:36.822 - 00:36:45.514, Speaker C: Even if you validate and figure out which kind it is, then you need to have three kinds. So initial runtime and this third one which allows both.
00:36:45.674 - 00:36:48.434, Speaker B: Yeah. Two bit flags. Right.
00:36:48.554 - 00:36:52.394, Speaker C: So yeah, this is mostly the complicated.
00:36:52.434 - 00:36:56.134, Speaker A: Yeah, I would want to validate by an enum rather than validate by a pair of flags.
00:37:05.954 - 00:37:13.134, Speaker B: I mean, it just doesn't really seem like a problem to me. But if whoever's in charge of like testing it says it's a problem, I believe you.
00:37:21.914 - 00:37:37.254, Speaker A: So second is preferred. Any arguments for the first? I think it was pretty compelling what was presented for why two is better. Okay, I think we should analyze this next week then.
00:37:37.794 - 00:37:56.374, Speaker E: Yeah, we have. Option two kind of penetrated a bit. Right. Because we kind of did this. And the option one is kind of, I think it might actually implement option one because kind of localized. But I think I would go with two as well.
00:38:00.754 - 00:38:05.954, Speaker A: I'm sorry, could you repeat that again? I. My son's trumpet practicing was like blaring out my ears.
00:38:07.414 - 00:38:35.374, Speaker E: Well, the option two is more or less in the direction we currently exploring from different, slightly different angles. So I kind of like it more. We don't have to put restriction on these additional instructions. The option one kind of puts restriction inside the instructions in the container. Right. For the obvious reason why. It's why.
00:38:35.374 - 00:38:41.214, Speaker E: Why you can't have unrevert other instructions.
00:38:54.494 - 00:39:28.914, Speaker A: Okay. I think this is another item we need coded up and then finalize next week. Any other spec issues before we go to testing? All right, let's go to testing updates. Mario, do you have any updates for us? Anything you want us to be aware of, any changes?
00:39:30.334 - 00:39:57.084, Speaker F: Yeah. So first of all, I would like to share some information that Dan, he had to run right now, but he wanted to share some information regarding EIP versioning. So I'm not the expert on this topic, so I will just try to relay the information that he gave me. Basically I think there was signaled a couple meetings ago that there was.
00:40:00.544 - 00:40:01.240, Speaker D: That.
00:40:01.392 - 00:41:02.696, Speaker F: You guys wanted to add versioning into the EUF eips. We are planning on actually using this versioning in our testing framework to be able to first of all see if there's anything, any tests that are out of date immediately when we fill the tests. So the first thing that we have to have is the EIP is actually having some version information. So for this, Dan gave me two things that we have to have. And the first one is the possibility of adding a changelog, uh, section into the EOf eips. And in this is within Ethereum eips. Um, so the first thing is, the first question is whether this could be allowed in an EIP, and if you guys are willing to add this generally changelog information into the EAp.
00:41:02.696 - 00:42:05.844, Speaker F: Um, the idea is that we inside of the test framework also code a, um, EIP version for each of the tests that we are writing. And then we, on runtime, when we try to fill it, we try to fill the tests, we fetch the information from the EIP repository and we compare it to our local version in the tests. And if there's a mismatch or there's an increase of a major or minor version in the EIP, that means that our tests are out of date and we should throw a warning somewhere. This is just to make sure that we are actually feeling what the specification says. So yeah, that's one thing. And on our side, on testing side work, we will all, we will add basically all of this tooling that we require to parse the eips. We will make sure that the warnings are there.
00:42:05.844 - 00:42:31.504, Speaker F: But yeah, the first two requirements is whether one, is this possible in the eips. And second, if you guys are okay with manually adding and increasing the version in this changelog in the eips for us to use. So I just wanted to bring up and start the discussion. If you guys have any input.
00:42:34.324 - 00:42:42.860, Speaker D: Question, the changelog would just need to start from some 0.1 or 1.0. We don't need to fill in the entire.
00:42:42.932 - 00:43:05.034, Speaker F: Yeah, absolutely, exactly. So at least, I mean we can have a starting point for the, for agap, which could be like version one, version zero, whatever, and we'll just match that to the current, implement the tests or update them if they are out of date. But yeah, the starting point can be anything. We'll just copy it over to the tests.
00:43:10.854 - 00:43:13.314, Speaker A: Does the version need to be in the preamble header?
00:43:15.334 - 00:44:29.530, Speaker F: That's up for discussion, I think. I don't think Dan or anyone else has specified anything where this thing should be placed, it's up to the EIP editors. If we have it in the preamble, it would definitely be much easier for us to parse it instead of going into the sections and trying to figure out which section is changelog. So yeah, definitely having the preamble will make everything, everyone's lives easier. Also the changelog, I think it was just like a stopgap solution, because we don't really need the changelog for testing site is just, we just need the version. If we want to see the changes, we just go to the GitHub history and that's it. We just compare.
00:44:29.530 - 00:45:10.324, Speaker F: So yeah, basically the chain log is just for us to have something to parse. But if the version is in the preamble, I would rather have that and just add a number. And for the EIP editors just to bump this number whenever they feel they have, there's some testing changes that need to be added or modified if they are unsure. I would suggest that if you are unsure, just bump it and we will take a look because it will warn us in the testing side that there was a bump in the version. We will take a look at the changes and we will figure out if there's anything to be added. If so, we will just update the tests.
00:45:12.994 - 00:45:53.094, Speaker A: Yeah, I think this is probably for the IP editors, but if we go to versioning, and versioning exists, that it should be enforced by tooling, that any change involves a change to the version field. It doesn't care which of the three steps it does, but it does requires at least a patch update and make it put the rules in there. But adding a changelog section I think is valuable. You just add another top level section. I don't think they care what top level sections are, as long as it has a subset. Those could be trimmed off as needed when we get to final and release. But okay, yeah, I think we should do it, but just my opinion.
00:46:11.614 - 00:47:08.974, Speaker F: Thank you. And also if you guys have any questions, I think reaching out to Dan is, he's available to respond any of your questions. He also made another suggestion which is just basically adding. So we have these EVM tools that we use to fill. We have the EVM one and we have the besuit flavors to add a flag into this tooling to also return the versions that are currently implemented. I think this is not absolutely necessary on our side because we will definitely just, when we are writing the test and filling them, we will run into errors if there's something out of date, but if there's a possibility that you guys add a flag just to return the versions that you have currently implemented. It will make our lives a little bit easier to make this comparison a little bit more automatic.
00:47:08.974 - 00:47:47.164, Speaker F: For example, if we are filling the fixtures and there's something failing in the CI and we have some way to compare what is currently implemented in the filler in the EVM tool with what we have on the test versioning, we will automatically know that the reason why the tests are failing is because there's something out of date with our EVM filling tool. Again, I don't think this is completely necessary, but I just want to throw out the idea just to get a feeling if this is possible or not.
00:47:48.064 - 00:47:51.964, Speaker A: So like a separate informational flag like EIP versions.
00:47:52.274 - 00:48:17.614, Speaker F: Exactly, exactly, exactly like that. The downside is that whenever you are pushing a pr to update the EIP implementation in your client, you will also have to make it a recurring thing to just make sure that you update this output information. So it's basically more work for the client.
00:48:18.104 - 00:48:49.704, Speaker A: I mean for dev versions it might be a little out of date because of the high frequency of changes, but when it comes to like release the IPS, it should be fairly easy to maintain those versions and make sure they're static and pay attention to the, because that's another check. If you put the version in the tested VIP version in the test fixtures, then our reference tests could catch those and we could say, hey, this is testing a newer version of it, should we update? And we could catch it a little easier on our side for the published versions.
00:48:50.804 - 00:49:11.064, Speaker F: Yeah, we already have some information of the EAP implemented, which is the commit hash. We already have it in the fixtures, but this will give more, more clarity because if you look at a hash, you don't really know which version it is, but if you look at a number, it figure out ok, I'm out of date or the tests are out of date or. Yeah.
00:49:18.944 - 00:49:26.368, Speaker A: Okay. Any other testing concerns, questions, details?
00:49:26.456 - 00:49:40.692, Speaker F: I have, I have another, another thing. So we, let me just share my screen if that's possible. I don't think it's possible. Do I need like special permission? You can share, I can just share the link.
00:49:40.868 - 00:49:41.864, Speaker A: Try sharing.
00:49:42.924 - 00:49:43.984, Speaker F: Let me see.
00:49:47.604 - 00:49:49.184, Speaker A: It's set for all participants.
00:49:54.844 - 00:49:56.344, Speaker D: I always miss it.
00:49:57.844 - 00:49:59.292, Speaker A: That's always the solution.
00:49:59.468 - 00:50:30.504, Speaker F: There you go. Okay. Okay, here it is. We made some modifications into the execution test framework. Let me just go into the file that we added. It's basically just a CI improvement. Let me see, where am I? Okay, the other branch right now in main we added a configs folder which now contains a feature information.
00:50:30.504 - 00:51:10.474, Speaker F: So previously we only had like the stable feature and the development feature. And both of these mean like stable is just the Kangkong fork which is currently the release fork. And we have the develop which is spread. And currently it signals that the tests are being filled for Devnet zero at this very moment. But now we also have the opportunity to add more, in this case UF. So we now have the EIP 7692 feature which is UF. And we specified some of the configuration that we are using for this to fill these fixtures.
00:51:10.474 - 00:51:52.298, Speaker F: So what does this mean is that we have defined a special fork for EOF only. And this fork is called when we are feeling only these fixtures on the background. This fork, basically it just passes brack to the EVM filling tool. There's no changes there. But for us it means that we only fill the tests that are marked for UF. So now in our test directory we have two different configurations. So if you go to the practice and to the EOF test we have a general modifier variable that is called EOff fork name.
00:51:52.298 - 00:52:58.624, Speaker F: And this one signals which fork is going to be used internally in our test framework for the feeling of the EOF tests, which is this in this case. What this gives us is that the ability that we can currently fill and make releases only for EOF. And I will show you how that looks like right here. So basically we can tack commits in our repository in two ways. So the first one is the usual one, we have the version and one point, whatever that means that we are going to release all the fixtures, so stable develop and also eof. But we also can do prereleases, which is tagging as EIP 7692 which is the name of the feature, in this case EOF, and add a version which is this version is specific to this feature. So when we do this, the CI will automatically in the background, let me see, we automatically in the background go in and actually compile.
00:52:58.624 - 00:53:40.792, Speaker F: At the moment we need a tool which is at this point evm one. But we could use any other tool as we need. But yeah, at the moment it's Evm one, it compiles that and it fills all the fixtures and packages them in a nice tar file that you guys can consume. So this is very quick, we just pushed that and the prerelease is already drafted for us. So we can speed up a little bit the cycle of releases that we have for EOF. Specifically this is already in main I tried to do it today before the meeting. But there's actually a new failure for EVM.
00:53:40.792 - 00:53:50.104, Speaker F: Evm one. So it was not possible. So that's downside. So since we don't have execution in our tests, so we need some filling.
00:53:50.144 - 00:53:50.724, Speaker A: Tool.
00:53:52.904 - 00:54:14.904, Speaker F: For the fixture fields. And in this case the only one that we are supporting is even one and sadly is failing at the moment because our tests probably are out of date. If this was not the case, we would be able to just fill all the fixtures with whichever EvM tool that we can use. I think this will make the release a little bit quicker.
00:54:16.804 - 00:54:26.732, Speaker A: Would it be possible to release. Would it be possible to release just the ones that fill and instead of having an error break it, just ship all the ones that did validate.
00:54:26.908 - 00:54:50.484, Speaker F: That's a great idea. Okay, definitely. I think we don't have flag for failing to not break on on a failure. But I think it should be fairly straightforward just to add that flag, pass it onto the feature. Yeah, I think should be definitely doable. Let me write it down.
00:54:51.384 - 00:55:03.054, Speaker E: Yeah, but then you need to make sure that you noted that there were some failures, some of the tests will be missing and you might just missed it.
00:55:03.214 - 00:55:09.594, Speaker A: But this would be only for dev mode, stuff like 7692 when it goes full production and it's done. Yeah. Yes.
00:55:12.134 - 00:55:29.194, Speaker E: I also noted some, some issues with the current main. And yeah, we're kind of working on fixing this in vm one. I'm not sure this is the same errors, but yeah, I think that should be done in a couple of days.
00:55:35.774 - 00:56:23.550, Speaker F: Yeah, definitely. I would rather not have like a single EVM tool be like the bottleneck for the rest of the implementation. So I will try to get Besu also working for this. It should be pretty straightforward and we can switch between implementations just to make sure. This is the downside of not having actual execution in our tests. But yeah, and yeah, one last thing is just basically at the end of the day, what you guys should do to, to consume the latest release for EOF is just coming to the into the releases and you will have to manually parse for the latest. So you will see here basically the latest one.
00:56:23.550 - 00:56:35.222, Speaker F: But below you will find the Eof at. I'm sorry, EIP 7692 at something. And you can fetch the latest fixtures like that. Yep.
00:56:35.278 - 00:56:36.074, Speaker A: Cool beans.
00:56:37.134 - 00:56:40.554, Speaker E: So we're about really good, I think.
00:56:43.134 - 00:57:01.274, Speaker A: Okay, so about two minutes over time. Anything that needs to be brought up that's worth extending the meeting. All right. If not, feel free to bring it up in next week's meeting. If there's nothing urgent. I'd like to thank everyone for showing up and everyone for participating. Another good call.
00:57:01.274 - 00:57:02.874, Speaker A: Thank you for your time.
00:57:03.614 - 00:57:04.754, Speaker D: Thank you very much.
00:57:05.414 - 00:57:05.814, Speaker A: Thank you.
