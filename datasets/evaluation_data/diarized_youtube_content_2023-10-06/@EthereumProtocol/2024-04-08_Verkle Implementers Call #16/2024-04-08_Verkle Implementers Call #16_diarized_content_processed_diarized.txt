00:00:07.800 - 00:00:31.145, Speaker A: Okay, let's get started. Hey all, welcome to virtual implementers call 16. This is issue 1005 in the PM repo. The agenda will be shared here in the chat momentarily starting things off with client team updates. Anyone up to start things off?
00:00:42.125 - 00:01:32.433, Speaker B: The members seat one team. So the last two weeks we finished implementing EIP 6800 that basically or captures the entire world state into a unified local tree. We tested it entirely with GET and for correctness and consistency and everything works to like. Seems to work fine. Then we updated the new spec change for point to hash and we incorporated that as well. And still all the test data seems to be consistent with get. Apart from that in our in memory NIMIT worker tree implementation, we have almost reached full statelessness.
00:01:32.433 - 00:02:31.345, Speaker B: We are just left out with the tests for proof of absence. Those conditions. Apart from that, we are pretty much again correct and consistent with all the test cases of go. And we also benchmarked them like not very solidly, but we were just wanting to estimate the speed and they look decent. So far apart from that, the major hurdle for us in integration is our entire accounts layer is very like under the hood integrated with our database and it's very much dependent on the storage try separately which is giving us a hard time to refactor the code if it's like if we spend too much effort on it, I guess we would shift to a path based storage. That's pretty much the update.
00:02:33.645 - 00:02:45.255, Speaker C: Nice. Just a quick question. When you say you have the same like, it's consistent with guess you're only talking about the roots computation or do you also get the same gas consumption?
00:02:46.755 - 00:02:54.535, Speaker B: No, no, I'm just talking about testing it with the test vectors because we haven't fully finished the integration yet.
00:02:55.115 - 00:03:17.059, Speaker C: Yeah, okay, cool, thanks. It's already pretty cool. Thank you very much. Okay, well I guess since I'm unmuted, I'll go next. Yeah, we've been, we've been working on tooling. We helped other teams with the Interop, the testnet interop. We found some problems, some of them.
00:03:17.059 - 00:03:47.151, Speaker C: So for example Guest did not use the map to field. That was an accident. It's entirely my fault. So we're going to relaunch the test net at some point, but we're making sure that everybody agrees with the rest of the Guest model. Until then we have made a presentation at EFP or epf. I never remember what it's called, but the Ethereum Protocol Fellowship, epfs. Yeah, we got some stuff merged into Guest.
00:03:47.151 - 00:04:34.791, Speaker C: So we have one PR that got merged and another one that's awaiting merge but hopefully we'll make it soon. Inacio has worked on the Explorer. We'll have a presentation about that. Yeah, I started thinking again to guests to some block after Shanghai so that we can produce some metrics like average proof size, gas consumption, things like this that would be quite useful for people who keep asking about them. And yeah, there was more work on the revamp of EIP4762 but I'll talk about this later. And Ignacio just updated Verkhol info because it was quite outdated. I think that's pretty much it.
00:04:34.791 - 00:04:37.075, Speaker C: Ignacio, do you have anything else to add?
00:04:40.065 - 00:04:41.365, Speaker D: No, not ready.
00:04:46.945 - 00:06:33.105, Speaker E: Okay, I can go for Ethereum js. So on Ethereum js, yeah we basically tested out the test vectors game has been giving us and made sure that we pass and basically debug some of the issues that came through. And on constraint fine five then we basically synced and found some of the issues in Ethereum JS and resolved that. Right now we, I think we are on the last mile where we are trying to resolve mismatching gas issues on self destruct and I hope that is the last stage. And so basically we are hitting this issue on block 261 and I think post that maybe will be good to sync rest of the Testnet and so for transition what we are planning right now is that me and Gabriel have this plan that we will basically code the transition in a way that even without having the Merkle state will basically pop off things from the Merkle state and try to match the Merkle straight route. So this is our plan to implement and test out a transition and once the vertical state is also implemented in Ethereum JS then which basically would be the next step. Then basically we would also pop things back, pop things in the vehicle straight during transition and then make sure that we match everywhere.
00:06:33.105 - 00:06:34.665, Speaker E: Thank you.
00:06:38.885 - 00:06:51.815, Speaker C: I can go next. Go next. In nethermind we are also working on like syncing the constant testnet. We synced a few blocks and found a few issues in the Netherland implementation and there is I think some discussion.
00:06:51.855 - 00:06:54.955, Speaker D: Around the gas cost of cell destruct that is there.
00:06:55.375 - 00:07:02.935, Speaker C: In parallel to that I'm also trying to work on the transition. Some part of it is implemented. It'll take two, three more days to.
00:07:02.975 - 00:07:06.075, Speaker D: Like finally start testing transition in.
00:07:07.255 - 00:07:08.155, Speaker A: That's it.
00:07:10.295 - 00:08:05.205, Speaker E: On Bezos side we are working on some improvements regarding performance. So we added the batching for generation of the tricky. We are also batching the hash of the commitment. We are Working in order to improve the update commitment part. And so, yes, we can see some better performance, but we still have some work to do. We also finished some refactoring, so the merge with the main branch and block accessory is implemented. We are just waiting for the new testnet in order to test the GAS cost implementation and I hope that we will soon look at the proof validation in the bezel side.
00:08:05.205 - 00:08:08.985, Speaker E: So it will be soon, I hope.
00:08:17.855 - 00:08:35.315, Speaker A: Any more updates? If not, I think that was everybody. We can move on to the next agendem testing updates. I don't think we actually have anyone from the testing team here today, but Guillaume mentioned you may give a quick update here.
00:08:36.175 - 00:08:57.925, Speaker C: Yeah, so very quick. I'm just helping them. So the idea is that we have this process that there's a transition. Right. And we were agreeing on the tooling. For example, there's no implementation of any of the vertical primitive or crypto primitives in Python. So I added a tool to compute.
00:08:57.925 - 00:09:59.807, Speaker C: You just pass the address and the slot number on the command line and it will compute the key value for you. So we've had some back and forth on that and then it became apparent that we would still need to export the mapping from the key back to the pre match. So address and or slot number. This is because it's easy for them to check that all the keys that are given are expected, but if there are some keys missing, they don't know how to flag what specific account was missing. So there's some effort for us to provide such a tool to output the mapping from the hash to the pre image. But once they have this, we should have all the tooling necessary to at least test the full transition. So yeah, slow, slow progress.
00:09:59.807 - 00:10:07.595, Speaker C: Not very impressive, at least not announcement worthy. But it's progressing.
00:10:11.255 - 00:10:18.635, Speaker A: Nice. Thank you for giving the update. Cool. Next up, the Witness Explorer demo from Ignacio.
00:10:21.975 - 00:10:41.395, Speaker D: Hey. Yes. So this is something I've been working mostly in the previous week. Last week. I'm sorry. So I will share my screen so we can make this more interesting. Give me a second.
00:10:41.395 - 00:10:46.955, Speaker D: Okay. Is this working?
00:10:47.855 - 00:10:48.623, Speaker A: Yep.
00:10:48.759 - 00:12:05.081, Speaker D: Okay. Okay. So what is this Witness Explorer thing? One of the first things that I remember when I started working in Verkle stuff was like this realization that the code for executing contracts will be part of the Witness and a big addition to the Witness, like the Witness size might depend on how much code is executed and you are going to be charged whenever you execute a contract for all the code chunks that are needed. So clearly this will add some new like, let's Say dimension into the GAS accounting for contract developers to understand how much adding the code impacts their gas for the transaction execution. So what I did is. Okay, so first of all I'm not like a web UI person, so I'm sorry for if it's not like a really nice ui, but what I did is something like a blockchain explorer but to understand better what it's in the witness for transactions. Okay, so currently this is live.
00:12:05.081 - 00:12:50.635, Speaker D: Let's call it in. Kaustin. I deploy this in my machine and you can access, everyone can access through this website which is like a subdomain of my site. We can later move this somewhere else, but if you want to test it, you can use it here. Basically the landing page is I'm showing two lists. One is the top 10 highest gas transactions as to like for people to really have a starting point and start looking at things if they want. And I have another list that I call the most inefficient code access transactions which hopefully will make sense later.
00:12:50.635 - 00:14:08.895, Speaker D: So if you click on any transaction or you look for a specific transaction here that you are interested, you will see web like a page like this one. So this first example is a transaction on Kaustin that I did for deploying an like a like an ERC contract. Okay, that is was like kind of real contract. So the things that I show here is like what the transaction hash some like basic transaction information like who is sending that and where and how much eth and the block number. Then I show the total gas, which shouldn't be surprising. And then I show like a de aggregation of this total gas into the execution gas which should be understood as like the usual kind of gas that you already pay today for things, you know, like opcodes instructions and things like that. And I de aggregate also what how much gas comes from witness additions that aren't code related.
00:14:08.895 - 00:15:15.425, Speaker D: And I will explain this a bit later. And how much gas comes from cold chunk accessing. Okay, which was like my original motivation for doing all this since this is like a contract deployment because code chunk has like serial value. I will show another transaction later with some more interesting case. But at least you start to see the idea of if you want to see how verkle changes the GAS expectation of your contract, then you can start like looking at these three numbers separately. Then in the execution section I show how many instructions were executed, how many bytes were executed, like considering that there are instructions with more than one byte, then I show how many bytes were charged. So in this case it's zero because no code was executed.
00:15:15.425 - 00:15:59.715, Speaker D: And then I show something called that I invented. The name is execution efficiency. But let's look at this later in another transaction. Then in this witness charge section I show every addition to the witness that charge a non zero amount of gas. Okay? And I exclude cold chunk additions. So basically since this is a contract deployment, you will see the contract creation init costs which was this amount of has. And then we did some slow and S store for this contract at this storage slot.
00:15:59.715 - 00:17:21.005, Speaker D: This store is for the same storage slot. Then we did something else with another Tor slot and then you get charged the contract creation completion cost. So at least like someone can look at these things and start to understand better or have a better intuition of where these witness gas costs are going. Okay, so basically all this is trying to detail this cost and all this is trying to detail more this cost. Ok, and then I have another section which is Windows key values which is similar to the stateless tab in the door explorer that I think I can show now because it's not available. But in the stateless tab in the door explorer we have the witness key values that were added in the witness but at the block level. So I go, I went like a step further and say okay, let's do this at the transaction level because maybe we want to understand how a transaction which keys were added to the witness from a particular transaction.
00:17:21.005 - 00:18:34.735, Speaker D: So for example here you will see that you know, this is probably the key of the contract that we created. And we can see that now we have the first, you know, this four last five values have the nons the hash of the contract and things like that. Other internal nodes probably. So this is like a bit more maybe detail information per transaction of the which things were added to the witness. So probably maybe this will be helpful for debugging stuff. Yeah, so that's kind of the overall view of the ui. So to look at another example that is a bit more interesting, I deployed in Kaustinen the if you know about Remix, it has a basic project that as an example is like a contract for voting and delegating boats and things like that.
00:18:34.735 - 00:19:16.759, Speaker D: That doesn't really matter what it does. I just wanted to have like a bigger contract and like a longer execution of real code. And basically I deploy this test contract that is part of the project and I called this before all method. It doesn't matter what it does, but basically it pushes something into the storage and instantiates like the ballot contract with some parameter. Okay, so if we look at this transaction Execution. Yeah, you can look at it with the transaction hash. You select the basic information.
00:19:16.759 - 00:21:05.165, Speaker D: As usual we see that the total gas is this amount and we see like a more interesting distribution of the cost in like the usual execution gas, non code witness gas and code chunk accessing gas, which in this case it isn't zero because it's actually executing code in the execution tag. In this case we see that the amount of bytes that that were really touched during the execution is this amount, but you were charged like a much bigger amount because remember that you are charged chunks of 32 bytes. So my point here with this execution efficiency is trying to get an intuition with a single number of how efficient is your transaction execution or your contract design. Because like in the worst case scenario you will be maybe like jumping all over around the contract and that is will be pretty terrible because you will be charged with a lot of bytes that you are not using. And for example, in the other extreme, if your transaction execution is like a tight loop in a single call chunk, like you will be executing a lot of bytes, but you will be only charged a small amount because everything happens in one chunk, let's say. So this execution efficiency, maybe it's like not really the best name, but that's what I thought. It's basically the ratio of how many bytes you are actually using compared to the amount that you are charged.
00:21:05.165 - 00:22:43.285, Speaker D: Okay, so ideally you want this number to be high so you are not paying for a lot of code that you are not really using. How much of this really depend on how much of this depends on the contract developer? It's not an easy question to answer because maybe some of it can be controlled by the contract developer because you can think more of trying to shampoo all around if possible. But a part of this cost is also related to compilers that maybe now have to understand better how to, you know, maybe with some hints or something, try to compile things in a way that like the execution of at least important methods don't really jump around that much. So in the witness charges we see a bit more interesting things. So remember that in this method we have like some storage changes and we kind of created a contract with some parameter. So basically yeah, you can see some slow and stores, you can see a code copy which has a witness addition that is pretty relevant. I have the create opcode that also transfers some other stuff.
00:22:43.285 - 00:24:01.565, Speaker D: You can see here the contract creation completion and some extra loads and stores later. So the idea here is again all this stuff trying to shed more light into this cost and all this stuff trying to give more detail about this cost. So if you already see that in this case the code chunk accessing is 4% of the total, then spending a lot of effort like caring about this stuff, maybe this doesn't make sense and makes more sense to just like understand if this makes sense or you can have any control in improving this. But maybe if this is like 25% of the total. I know maybe you want to think about something regarding cold chunk accessing and. Yeah, well the witness key values is like well a lot of things. So something really important to clarify now is that in the current testnet we don't, we aren't really, we haven't implemented the chunk field cost in the like in the gas accounting.
00:24:01.565 - 00:25:27.591, Speaker D: So if we look at, let's see, if we look at the eip you can see that the usual like the gas costs that we implemented in Gaussian are these four ones. You have like the read cost, let's say the usual write cost of branch and the chunks. But there's like an extra cost that is like the chunk fill cost that we should charge every time we write a value in the tree that has an empty that was empty. So we are kind of adding state and this gas is like pretty significant. So you should have in mind that like I think it's okay to use this today to you know, start to get a sense of some stuff. But don't, don't take like the current GAS using contracts as like the final number because if any of these s stor or related operations that add stake to the tree are fresh rights, you should be charged with this cost which isn't negligible. So please have that in mind.
00:25:27.591 - 00:26:22.975, Speaker D: Probably, you know, probably not in the next test net but maybe in the other we can think of trying to start charging that and whenever that's the case you will see here that cost appearing too. So yeah, I mean hopefully this will be useful for like maybe ask core developers trying to debug some particular difference in the gas between clients and hopefully for contract developers trying to come to Kaustonen deploy their thing, come here, run a transaction that calls the most used methods and just paste the hash and start getting an intuition of what is the cost and why that is the case and things like that. That is my presentation.
00:26:28.965 - 00:26:37.789, Speaker A: Awesome. Thank you Ignacio. Super cool. Okay, next up, gas model updates.
00:26:37.917 - 00:26:38.865, Speaker D: Guillaume?
00:26:40.525 - 00:27:41.535, Speaker C: Yep, Let me share my screen. So I'm just sharing some ongoing discussion. It's by no mean the latest version of the spec. It's to Give a sense of how the how the spec could evolve. Ultimately all of this will be decided in in the in the interop in a in a couple next month actually. But yeah, just want to to give a heads up on the on what will what might happen. So the first thing is that currently for those who know the spec ERP4762 when you have called to either any type of call, so delegate call, static call and I forget the last one call code you get like you touch the version and you touch the size leaf key.
00:27:41.535 - 00:28:57.395, Speaker C: So it appears that this is actually incorrect. We should so the intuition here is that everything that touches an account touches the version, potentially the balance and the nonce and everything that has to do with the code touches the size and potentially the hash. So the modification is that instead of charging for the code size leaf key, we would replace it with a noncelich key. And then when you either do xcode size and xcode copy, you would touch the code size leaf key and if you call xcode hash you would touch the code hash leave key. So yeah, that makes things a bit more expensive than they currently are in the testnet, but it feels more correct, at least from intuition point of view. Just a quick remark that Geth does not currently touch the when calling a contract, Geth does not use the size, but it's using the hash. So here, when you, when you do a call, it would make sense to touch the.
00:28:57.395 - 00:30:08.529, Speaker C: I mean, if things were left as they are today, it would make sense to touch the hash and not the size. But in a stateless context, you want to know where the code ends so that you know what to look for in the tree and not go randomly in the tree looking for things that are not there. So it makes sense to replace it with the code size. There was also a discussion about making the touching of balance leaf key unconditional. This is because it matches the historical behavior, namely that when you load a contract, the account is packaged together as an RLP payload. So to be aligned to this behavior you would also have to unconditionally touch the balance leaf key, unlike what is currently specified in which you just touch the balance if your call is value sending. And in a way that makes sense because something that is not specified on this slide.
00:30:08.529 - 00:30:38.279, Speaker C: But there's another reason to do this. It's because when you do a. Actually no, sorry, that's. That's wrong. What I was going to say is wrong, so forget it. And yeah, the other, the other reason to touch the balance actually, I Don't know why I wrote that, sorry. But anyway, so the other question that was asked was do we need to.
00:30:38.279 - 00:31:41.496, Speaker C: Do we really need to use version leaf key? So there was a question asked by Yejinder if I'm not mistaken. So I would say in terms of. If you look at the gas accounting it does make sense because you currently when you do a cold account cost, it costs 2600 gas and if you look at the cost of reading four entries, so namely the version, the balance, the nonce and the size, you get about the same value. Of course if you decide not to use the version it would be 2500 so it would still be roughly the same value. But yeah, you could also see it another way. If you don't include the balance like was discussed in the previous slide, you would get 2,500 and then half the time you would charge an extra 200. So on average it would be the same cost as 2600.
00:31:41.496 - 00:32:09.919, Speaker C: But yeah, the other reason to keep LeafKey is for forward compatibility. So this is something that is still up in the air once again. I expect the resolution next month at the interoperability but we. I just wanted to share this thinking. Yep. And the next slide is for another topic. Yeah, so that's pretty much the current state.
00:32:09.919 - 00:32:25.035, Speaker C: I don't know if there are questions but yeah, don't worry if something feels a bit too sudden, it's just a discussion and yeah, the point is to get the discussion started.
00:32:30.535 - 00:32:38.795, Speaker A: Cool, thank you Guillaume. Next up, I think it's also you EIP 2935.
00:32:40.215 - 00:33:12.495, Speaker C: Oh yeah, yeah. So actually it comes from the conversation. It's a very short one. It comes from a conversation at ACDE last week. Oh, sorry. Two weeks ago we were pushing to get EIP 2935 included in Prague and at some point Vitalik said yeah, we should increase the buffer size, the ring buffer size to 8192. So 2 to the power of 13.
00:33:12.495 - 00:33:29.955, Speaker C: I have no problem doing this. I just wanted to collect any feedback or people taking exception with this. But if not, I suggest we try to extend the buffer size to 8 kilobytes.
00:33:34.615 - 00:33:40.487, Speaker A: Do we have any extra context on the reasoning for bumping it up? What was Vitalik's reasoning?
00:33:40.631 - 00:33:49.757, Speaker C: No, I'm laughing because I saw Girder's comment. We should go all the way. So sorry, what was the question?
00:33:49.901 - 00:33:52.505, Speaker A: Just the context for Vitalik's.
00:33:54.005 - 00:34:50.638, Speaker C: So the context is that 256 blocks is very short and no one really cares about this short of any story because for Example, if you have a ZK rollup that needs to access, that needs to make a proof, it will take quite some time and by the time the proof is ready and they would, they would need the block hash to compare or to use in their proof or to verify their proof, the 256 blocks will already have elapsed. And so extending that value to. I think it's. I actually didn't compute, but it's. I think it's like a day or something. At least it's more than one hour because I think 100, 256 gives you about 45 minutes which is too short. So yeah, that's, that's the idea behind it.
00:34:50.638 - 00:35:07.394, Speaker C: Not inflate the state all the way like suggests, but at least give you enough of a buffer that you can take your time to produce very slow like proofs that are very slow to generate.
00:35:10.625 - 00:35:11.525, Speaker D: Got it.
00:35:12.345 - 00:35:13.325, Speaker A: Ignacio?
00:35:15.105 - 00:35:50.335, Speaker D: Yeah, I have a question that I think we have this touched on some previous calls. So this proposal of having like a longer history of block hashes is going to affect the block hash instruction scope or this like longer history will be only accessible through some kind of other system contract interface or something like that. Like thinking of like if this going to be a breaking change for block hash instruction.
00:35:51.395 - 00:36:31.675, Speaker C: Yeah, that's a very good point. I didn't think of that. And that's. I think it would make sense exactly like you said to. I mean I'm not a fan of having at least the update being done via the EVM bytecode, but we were talking when we discussed the deployment method to offer a get function that would, that would be able to. That would be easy and based. So you would just call that contract with that contract's get function and give a number that is larger than 256 while still retaining the standard behavior of block hash.
00:36:31.675 - 00:36:58.775, Speaker C: And that would probably be the best approach to break as little things as possible. Yeah. Okay. That's one item to add to the discussion. Yes, I also saw Karim's comments. Yeah, I'd be up for that in the next test. Not if everyone is.
00:36:58.775 - 00:37:00.885, Speaker C: Is it okay with it?
00:37:06.025 - 00:37:07.553, Speaker A: Looks like thumbs up to that.
00:37:07.649 - 00:37:12.645, Speaker C: Yep. Cool.
00:37:14.385 - 00:37:25.385, Speaker A: Okay, I think next up you also had a quick update on 7545. The proof verification precompiled.
00:37:27.075 - 00:37:52.163, Speaker C: I had to unmute, of course. Yeah. So indeed there's been some back and forth about 7545. So initially we wanted to have it in Prague. Then we decided maybe it's not necessary because optimism who was initially Interested in it, is no longer interested in it. And then I had a conversation with Polygon about this. They were interested in it.
00:37:52.163 - 00:39:00.945, Speaker C: And so the API that I proposed would have been to call verification, you would pass the root, you would pass a proof, which is a byte payload that is opaque. So the precompiled itself would decide if this is an MPT proof because we're at an MPT height, or if it's a verkel proof because we are at a vertical height, or whatever kind of proof scheme we want to use in the future. And then have one key and one value and verify that this matches the key would have been a 64 byte value because we could potentially support or at least extend the key format in the future. So, yeah, prefix it with 12 zeros, then 20 bytes for the address, then the slot number, which is 32 bytes, and that would only be necessary to prove values. So storage, storage slots. Now, Jordi, that's not what he had in mind. I'm still having the conversation.
00:39:00.945 - 00:39:58.265, Speaker C: So I didn't get to the end of the conversation before this call, but given the fact that this is not really what Jordy had in mind, and it doesn't really look like approving precompile what he had in mind. The fact it's not really interesting for optimism, I think now is the time to do some deep soul searching. Can we find any Bridge or L2 or DAP, which for whom? That would be interesting right now. That doesn't come to mind. So I suggest that we spend maybe the next week looking for this. For who? For a person that would be interested. And if we cannot find anybody, or we cannot find anybody with a clear, very clear cut and strong, compelling use case, we just abandon this for Electra or, sorry, the other one.
00:39:58.265 - 00:40:04.345, Speaker C: Prague. Yep. So that's pretty much it for this topic.
00:40:07.695 - 00:40:14.115, Speaker A: Awesome, thanks. Cool. Testnet relaunch, which I think is also you, Guillaume.
00:40:16.975 - 00:40:54.009, Speaker C: Yeah. Okay, so I need to share my screen again. I don't know why I stopped, but yeah, so the test every launch. Okay, so something is missing in this, in this slide because we just talked about using the updated version of 2935 with the 8 kilobyte buffer. So that would be one change. We would add the explorer from Ignacio to this testnet because it's proven very useful to debug. I mean, that was the purpose, but it serves that purpose.
00:40:54.009 - 00:41:31.081, Speaker C: So that's really good. We currently identified. I mean, say we, but it's. Gajinder identified an issue with self destruct at block two. Hundred sixty one so before the relaunch, I would like to at least least get to the bottom of this issue. I know AAVE is planning to deploy their contracts on the test net so I would have to coordinate with them so that they relaunch so they try doing this on the new test net instead of the current one. And there was another point, there was another problem and it's entirely my fault.
00:41:31.081 - 00:42:04.099, Speaker C: I did not. I got mixed up with all the revision numbers and I did not rebase so to the right. To the right revision. So Geth was using the old key format. So not map to field but the compression and that will be fixed in the new testnet. So yeah, that's pretty much everything we want to change for the new relaunch. I just would like to know if someone has any other desire for the new testnet.
00:42:04.099 - 00:42:18.845, Speaker C: But barring this, we should be good to go and we should do it this week because it's blocking bisu and yeah, there's not that many changes so it should be done fairly quickly.
00:42:27.505 - 00:42:28.361, Speaker D: Cool.
00:42:28.553 - 00:42:37.455, Speaker A: Last up on the agenda, Ignacio had a few thoughts on the black sorry block hash corner case he wanted to share.
00:42:39.275 - 00:43:37.995, Speaker D: Yes. So I think it was on Thursday or last week. I was looking at some coding get and I realized that we weren't charging correctly the block hash gas. While fixing that, I realized that there might be a corner case that we might might want to discuss what you do. And it's the following. So if you imagine a contract using the block hash opcode asking for the hash of the previous block, technically speaking, the way that we are thinking of 2935, we are adding this block hash to the witness at the kind of system level because we are kind of creating the history. So this block hash is already added to the witness.
00:43:37.995 - 00:44:46.155, Speaker D: So any contract in that block that use the block hash asking for the hash of this previous block, technically speaking shouldn't be charged any gas for doing that because that tricky is going to be added anyways because we are building the hash history. So yeah, have some kind of discussion a bit around this. If we should like charge zero for this corner case of asking the block hash for the previous block or not. And there might be. Yeah, I know, maybe different opinions because I know this is kind of coupling. Like if we charge zero, we are kind of coupling the gas cost of block/ with 2935. So maybe we don't want to do that and keep things simple and simply charge the gas as usual as any other older block hash request.
00:44:46.155 - 00:45:17.695, Speaker D: So yeah, I just like wanted to surface this case and see if somebody else has strong opinions. I don't. But if we decide to do something special, we should add this clarification to 4762 because it will be like something to clarify. Yeah, just like software in this topic.
00:45:20.275 - 00:45:28.695, Speaker C: Just to specify one thing, it wouldn't be zero, right. It would be 100. Like it would be the warm cost of loading the contract hash.
00:45:29.955 - 00:46:04.069, Speaker D: Yeah, yeah, I mean like witness costs. Is anybody like in favor of not of doing this kind of cache optimization of not charging the witness addition for the previous block hash? It looks like the answer is no. So we want.
00:46:04.117 - 00:46:06.505, Speaker E: Sorry, can you repeat this?
00:46:07.085 - 00:46:54.185, Speaker D: Right. So to give like a TLDR of what I said is if a contract is executing the block hash instruction asking for the hash of the previous block, technically speaking that witness addition will be done anyway by the chain because we are building this block hash history in 2935. So technically speaking we could charge this contract 0 of witness costs because this branch will be added anyways to the witness. So like contrast could assume that always the previous block hash will be in the witness. So you are getting this for free in quotes regarding witness costs.
00:46:55.525 - 00:47:00.275, Speaker E: We are already not charging witness costs for block hash.
00:47:02.415 - 00:47:06.835, Speaker D: Right, but that. That sounds like wrong, right?
00:47:08.935 - 00:48:12.555, Speaker E: Not essentially in the sense that for example, if block hash. I think I also wrote this up in the PR to the PR which might be merged as well. So basically what I essentially wrote was that one could the clients could just keep last 256 or maybe you know, when we go 28196, whatever. Yeah, so those in the memory and can serve from there. So basically client architecture, if I see as a full client running, they can just keep on maintaining this in the memory as they do maybe currently right now. And I actually don't feel that, you know, there should be any extra excess cost for block hash because this is something that we can make sure that we can keep low by maintaining it in the memory. Or if we don't maintain it in the memory, then still I don't feel that we should charge extra for block hash.
00:48:12.555 - 00:48:24.115, Speaker E: That way the contracts which are already deployed will be backward compatible to that if they are assuming any cost for this particular opcode.
00:48:27.675 - 00:48:39.495, Speaker D: Okay, so this is like a special case in which there are something that is increasing the witness size and isn't really charging for that. That's kind of an exception to the main rule, let's say.
00:48:42.355 - 00:49:10.745, Speaker E: Yeah, I think I mentioned this in the EIP PR as well and sort of was sort of, you know, under the impression that, you know, we all are on the same page with regard to that. But yeah, we can, we others can also weigh in and on this particular issue, but I think that we don't need to. We shouldn't be charging extra for the block hash because it just, it could just be served out of memory.
00:49:18.855 - 00:50:15.965, Speaker C: My question is, and that was my counter, do we really need this? Because who's going to be willing to use block hash for the last block that was produced? Like, is there really a use case for this? I don't see it. Typically people generating proofs are way too late for the next well to ask for the block hash of the previous block. If there is a use case, I'm happy to change my mind. But currently I think it's a very corner case, ish, very specific use case that no one really needs. And it might make things a bit weird for whoever doesn't know the AIP by heart and does not understand that. But at the same time, it's the. My counter, the counter to my counter is already included.
00:50:15.965 - 00:50:34.765, Speaker C: If this is not a problem that will really ever occur, then they will never notice that there's something a bit off. Yeah, I don't think it's really hard to do. I just wonder if it's really worth the complexity.
00:50:39.715 - 00:50:55.215, Speaker E: So just to mention that we don't charge for block X block hash access, even if it's more, it's previous than the ancestor. So basically any of the block hash access we don't charge.
00:50:59.075 - 00:51:04.215, Speaker C: Yes. Okay, maybe I misunderstand what you mean, but we at least charge the warm cost.
00:51:08.495 - 00:51:16.875, Speaker E: Which cost, I think we only charge whatever is the opcode cost for the block hash and we don't really charge an excess, although we trade the excess.
00:51:17.695 - 00:51:28.535, Speaker C: I'll get back to you offline because I need to double check the code, but I'm pretty sure we do something called a check account and so that will return our account check and that would return a warm cost.
00:51:28.575 - 00:51:28.727, Speaker D: But.
00:51:28.751 - 00:51:31.355, Speaker C: Okay, I'll get back to you offline in like 10 minutes.
00:51:39.175 - 00:51:55.395, Speaker A: Cool. Okay. I guess before we wrap things up, there were a couple of questions from Milos in the Discord. I was wondering maybe we could quickly answer around how to get a Verkal proof for a block from testnet. If anyone more familiar with that.
00:52:00.105 - 00:52:19.165, Speaker C: Yeah, we. I mean, just think that's the easiest, the easiest way we could tweak the Explorer, maybe Ignacio to provide the proof. Because presumably we look at those proofs so we could save them and provide them. What do you think?
00:52:21.835 - 00:52:46.295, Speaker D: Yeah, I was thinking maybe in the, in the near future to also show some like block information so we can. Yeah, maybe allow downloading the witness bytes and also show like the witness size and other things that might be interesting. So yeah, we could add it there.
00:52:47.085 - 00:53:15.705, Speaker C: It depends what Milos, who I think left is interested in checking because Dora, who unfortunately is currently down Dora, offers some insight into the witness itself. So if that's all you need, it's already present on Dora. Otherwise yeah, we would need to explicitly provide some way to display or download the witness from any of the explorers.
00:53:18.575 - 00:53:38.315, Speaker D: Yeah, I was mostly just thinking about being able to process and analyze that data maybe by myself or something. That is one use case. And another question that was also on Discord is is it possible to run a stateless client at the moment and how. Just instructions or something?
00:53:41.585 - 00:53:49.565, Speaker C: That would be question for Gajinder and. Or Tanish, but guess is not able to do that.
00:53:57.265 - 00:53:59.885, Speaker E: So what exactly do you want to know? Midas?
00:54:01.465 - 00:54:10.145, Speaker D: Is it just possible to run any of the clients in a stateless mode and the instructions of how to set it up and get it running?
00:54:11.805 - 00:54:12.181, Speaker C: Yes.
00:54:12.213 - 00:54:15.877, Speaker E: So reach out to me. I can maybe help you run Ethereum ds.
00:54:16.061 - 00:54:17.345, Speaker D: Okay, thanks.
00:54:20.085 - 00:54:28.345, Speaker C: And actually could you also export because you will download them this way. Would you be able to export the witnesses like the JSON payload?
00:54:32.765 - 00:55:05.395, Speaker E: Yes, we. We basically. So Ethereum JS has a test spec script where basically it pulls off the JSON payload and then plays it. So what you're saying can happen like that if you want to play some particular block or some particular set of blocks. And Ethereum JS can also run in the manner that it can basically serially get the blocks and execute them like a normal client would.
00:55:19.135 - 00:55:28.665, Speaker A: All right, I think that was it for today. If nothing else, we can end there. Thank you very much everybody. Anything else? Oh, sorry. Anything else?
00:55:30.165 - 00:56:44.481, Speaker F: And I have a question. I have a question that currently, because I'm new to this group and the first time, first time I come to the come to the meeting. So now I'm exploring the further optimized optimization solutions to make use of the reuse of the proof. That means that if the Virgo proof of a recent visit or of a story slot or the siblings or the adjacent stores of the story slots or there's a recent update into one of either the story itself or the adjacent slots, then I think that the ver proof to prove that recent event could be reused again to reduce that and to reduce the proof that and very fair time cost. And now I have this idea and I hope to do some research on it and to find if there's more. If it's a. More space to.
00:56:44.481 - 00:57:06.005, Speaker F: To reduce the gas cost and for the vehicle proof. What do you think about that? But I think that because of the time of the meeting, I think that we can discuss it after the meeting and I would directly mention you.
00:57:07.625 - 00:57:19.571, Speaker A: Yeah, that sounds good. Thanks for the quick thoughts. Since we're running low on time, if anyone has anything, any thoughts there, otherwise we can maybe take it offline or Async and in the discord.
00:57:19.763 - 00:57:20.579, Speaker F: Okay.
00:57:20.747 - 00:57:48.391, Speaker C: I mean, all I want to say is. Okay, we received your present, your document. We need some time to review it. The first outline seemed like it's something that cannot be possible. But if. If this is indeed correct, we're really happy to hear about it. But we'll get back to you when we have read the document and we can set up a call.
00:57:48.543 - 00:57:51.395, Speaker D: Okay, great.
00:57:52.175 - 00:57:52.915, Speaker F: Thanks.
00:57:55.135 - 00:58:00.315, Speaker A: Yeah, of course. Thanks for joining. Thank you everybody. We'll see you in two weeks.
00:58:02.215 - 00:58:03.365, Speaker C: Thanks, bye.
