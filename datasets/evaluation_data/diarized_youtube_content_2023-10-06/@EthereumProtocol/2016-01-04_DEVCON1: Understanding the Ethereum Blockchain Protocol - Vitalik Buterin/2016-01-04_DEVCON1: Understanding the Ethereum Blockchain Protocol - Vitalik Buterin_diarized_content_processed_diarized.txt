00:00:16.250 - 00:01:03.234, Speaker A: Hello, everyone. Welcome to the third day of the of the conference deep dive into Ethereum protocols. So we started off with the wonder pro presentation from Alex on the protocol, on top of which the other Ethereum protocols run. So I figured it makes sense to follow that up with a presentation on the Ethereum protocol. So the idea behind the Ethereum blockchain first came around back at the end of 2013, when people were getting really excited about bitcoin. People were getting starting to get excited about blockchain technology and applications beyond currency. And there is a public consensus that blockchains are useful for stuff and not just money.
00:01:03.234 - 00:02:22.122, Speaker A: So blockchains could be used for asset issuance, crowdfunding, domain registration, title registration, gambling prediction markets. IoT people are coming up with some new category of applications every week. The problem at the time is that most existing blockchain protocols were designed like this, single purpose tools that are specifically designed around one particular application. So in bitcoin's case, currency, in Namecoin's case, domain registration, in Primecoin's case, trying to do scientific computing, and in my opinion, not doing a very good job of it. So then we had second generation protocols that looks like this. So we had protocols that had somewhere around 55 different transaction types where one transaction type is something like create a binary option, another one is join a binary option, then one for settling a binary option, one for making a bet, one for settling a bet, one for doing some kind of two party dice game. And every time someone came up with a new kind of application that was deemed important enough to be worth including, the people who are creating these protocols would just add yet another transaction type.
00:02:22.122 - 00:03:24.830, Speaker A: So at the time we had protocols that had 55 transaction types. I even worked for one of them for a few weeks. After I worked for one of them for a few weeks, another two transaction types got added, good old contracts for difference. So even still, it's pretty obvious, I think, especially from the standpoint of our current generation, that this particular way of doing things is just fundamentally limited. So what's the solution? Basically something like a smartphone. So the idea is that instead of. So instead of having, you know, a protocol that's designed around one very small set of use cases, you just create a general purpose operating system and you let people build whatever they want as applications on top of it.
00:03:24.830 - 00:04:20.282, Speaker A: So if you do that, then things suddenly become better. Maybe when you're inventing the protocol, you might be thinking that, okay, people are going to use this for binary options, contracts, for difference making two party bets, doing domain registrations and whatever other 50 applications you are aware of at the time, then release the white paper and six weeks later you realize that people are inventing applications in a completely different direction. And guess what? Your protocol does not even have to change one single bit in order to handle them. So that's the power of generality. So what is the concept behind Ethereum? Well, it's a blockchain. Seen them for six years, pretty boring with a few tiny additions. So the first important one is this concept of a built in programming language.
00:04:20.282 - 00:05:18.900, Speaker A: So in Ethereum there is a built in Turing complete scripting language. It's essentially a hybrid between kind of standard virtual machine architectures, bitcoin script and a few other things. And the point is that people can write programs in this script, or more realistically in high level languages that compile down to the script. Then people take their compiled scripts, put them into transactions and send the transactions off to the blockchain. Transaction gets confirmed, an address gets generated, and you now have a special kind of account at that address called a contract. So two types of accounts, user accounts controlled by private keys, the same old elliptic curve digital signature algorithm we all know and love. Second kind of account, contracts controlled by code.
00:05:18.900 - 00:06:07.842, Speaker A: So these two types of accounts in Ethereum essentially have completely equal privileges. Anything that humans have the right to do, bots have the right to do. So anyone can create an application with any rules by defining it as a contract. So this is essentially the basic principle. So the whole world of Ethereum are creating a decentralized DNS system. So basically the idea here is you want to create a system where people can register addresses, and if they addresses could be somethingsomething eth, and if they own an address, they should be able to set the IP address associated with that domain address. So the way the system works is fairly simple.
00:06:07.842 - 00:07:10.562, Speaker A: So you see a sort of declaration at the top data domains, with basically a mapping between a domain name and a tuple containing an owner and an IP address. And you have two functions, one of them for registering a domain, which basically says if this domain doesn't have an owner yet, then send the owner to, or set the owner to whoever sends that particular transaction, and you have another function set IP address, which basically means if you own a domain, then you set the IP address to whatever you want to set it to. So very simple rule set. Of course, real life DNS systems have substantially more features to them, but sort of the fundamental core basically stays the same. And you could probably build a more complex DNS system on top of this just by turning the IP address into a hash and throwing everything else on ipfs if you really want to. But point is very simple logic. You can write it in ten lines of serpent code and publish it to the Ethereum blockchain.
00:07:10.562 - 00:08:02.150, Speaker A: And there you have a system that's basically like namecoin. So this is basically the meaning of anyone can create an application with any rules. Once this application gets created, then anyone can interact with the application by sending transactions that specify the contract's address as their destination address. So you send a transaction to a contract and that's how you talk to the application, that's how you call functions, that's how you do whatever it is that you want to do. So in bitcoin, the state is very simple. It's basically just a mapping of, well technically speaking, this sort of list of unspent transaction outputs. But what it basically means in practice is it's the list of balances, the list of sort of the amount of bitcoins that every particular person has.
00:08:02.150 - 00:08:26.430, Speaker A: And if you want to do a currency system, that's basically all you need. In Ethereum the state is kind of more complex. It's this sort of key value mapping going from addresses to account objects. And there's two types of account objects. One of them is the sort of simple accounts controlled by a private key. In that case all you have is a non center balance. The second kind is accounts that are controlled by code.
00:08:26.430 - 00:09:17.360, Speaker A: And in that case you have these extra two fields that get filled up. One of them is the code hash. So the hash of the code of that particular account. And the second is the storage tree root, which in a sort of fairly intricate way that I'll describe later, basically represents the entire sort of storage of that particular account. So for example, if I create a contract with this code and I register a domain, then the fact that one particular domain got registered to my and it got registered with me being the owner, and then I set the IP address to some particular value. That information all goes into the sort of persistent storage of this particular account. So basically mapping from addresses to blocks of this is the entire state of the Ethereum system at any particular time.
00:09:17.360 - 00:09:46.790, Speaker A: So code execution, every transaction specifies a two address that it's sending to. So this is fairly simple. It's the kind of logic that we all understand. If you send a message, then you generally specify who you're sending it to and you want to specify the contents. So what happens if you set a transaction to the two address? Well, two options. One of them is that the destination address is just a private key controlled account. In that case all you're doing is moving ether around.
00:09:46.790 - 00:10:36.466, Speaker A: So if you do that, then it's basically just being a cryptocurrency. What if you're sending to an account that has code, then what that's doing is it's basically activating the code and it's actually letting the code run for some number of steps. So code in Ethereum can do three things. Number one, you can just send ether to other contracts. Number two, you can read and write from the contract's own storage. So for example, if you go in here, then the way that I would call the register function is by sending a transaction with data formatted in a particular way. And what that function is going to do is, or rather what that transaction is going to do is it's going to start running the code that actually represents the register method and where it specifies self domains.
00:10:36.466 - 00:11:07.678, Speaker A: Address owner equals MSG sender. That's setting a variable. What that actually gets compiled to is setting a particular key in the contract zone storage. So then the third thing code can do is you can call or basically sort of create these sort of virtual transactions that go to other contracts. So theoretically I could create another contract that has some different set of rules. And that contract itself can actually interact with this contract. That contract itself can register domains.
00:11:07.678 - 00:11:47.150, Speaker A: It can set an IP address of domains. It could theoretically do just about anything that an account is controlled by an address can do. So every full node on the blockchain processes every transaction and stores the entire state. Just like bitcoin. It's bold because it's important. So this is sort of one of those points that's important to make because people often ask, well, if I publish transactions to Ethereum, so who's actually going to be enforcing the contracts and how many nodes are running them and so forth? For ethereum 1.0, the answer is very simple.
00:11:47.150 - 00:12:33.794, Speaker A: Every node in the network runs every transaction. And the process of running a transaction, if that transaction goes to a particular contract, it actually involves executing contract code and setting and sort of changing the state to whatever the state is after the contract gets executed. So from that standpoint you can actually think of it as being a rather fairly simple system. You can think of the state as being a database, and you can think of each of these contracts as being programs that are sitting on one computer, except the computer is massively globally distributed. It's actually a highly secure network backed by tens of thousands of computers around the world. So it's bold because it's important. So, gas.
00:12:33.794 - 00:13:42.082, Speaker A: This is one of those sort of key mechanisms underlying the security of Ethereum. So when you tell people that you have a Turing complete programming language and that you let untrusted parties send code that's executed in a Turing complete programming language by every single computer in an entire network, the first thing that they're going to ask is, well, what about the halting problem? So, there is this very widely known result in computer science, which basically says that it is mathematically impossible to create an algorithm which can tell whether or not any given program is just going to keep on running forever. So how does Ethereum prevent attackers from creating programs that just keep on running on everyone's computers forever? And the answer is this concept of gas. So what this basically means is that the Ethereum network charges a fee for every computational step that a contract execution takes. So the specific way that that's implemented is that every block in the Ethereum blockchain has a gas limit. So, basically a limit on computational steps. Right now, the gas limit is set to 314-1592 which is.
00:13:42.082 - 00:14:38.134, Speaker A: Which is a nice number that we picked, because we're totally not math geeks. Then, if you are a miner and you're creating a block, then chances are you're going to want to fill it with the transactions that give you the most profit. So, every transaction specifies a gas price, basically an amount of ether that it's willing to pay per unit of gas, and it specifies a maximum amount of gas that it's willing to take. So, a transaction might specify, I am paying 50 shannon, which is basically 50 billion of an ether per unit gas, and I'm going to consume up to 500,000 gas. Miners. See all these transactions coming in, they select the ones that have the highest gas price, and they include them in their block. So when a transaction specifies that it's willing to spend up to 200,000 gas, then there's two things that could happen.
00:14:38.134 - 00:15:26.550, Speaker A: One of them is that execution takes up less than 200,000 gas, in which case everything happens normally, it's okay. The transaction pays only for the computational steps that it uses. Second case, it goes over the limit. If that happens, then all the execution gets reverted. And the reason why that has to be done is because if execution could stop halfway through, then you might be able to sort of perform weird attacks on contracts where we try to set the execution to expire just at the time when one half of the changes gets made, but the other half doesn't get made, and we kind of prefer developers to be able to just not worry about that. All the execution gets reverted, but the transaction still has to pay for the gas anyway. So don't run out of gas.
00:15:26.550 - 00:16:09.794, Speaker A: Gas isn't just a sort of simple one computational step, one gas thing. There are some operations, for example, operations that increase the amount of storage that every node has to store, and those operations take up a very large amounts of gas. So the gas system is also this sort of fairly intricate set of incentives that are designed in order to encourage you using the resources of the ethereum system responsibly. So gas limit is sort of the counterpart to the block size limit in bitcoin. How is the gas limit set? Fairly simple voting mechanism. Right now. If you mine a block, then you can upvote or downvote the gas limit by a factor maximum a factor of one over 1024.
00:16:09.794 - 00:17:08.398, Speaker A: There is a default strategy that we currently sort of instruct all the clients to follow in the source code, which is you have a minimum of 314-1592 and if the usage starts bubling up and hitting close to the gas limit, then we target 150% of the long term exponential moving average of the gas usage. So basically sort of target it so that if it does get filled up, the gas limit is going to be sort of just a bit higher than what blocks normally contain. So there are alternative strategies that we're exploring. So one of them is just, for example, target a particular uncle raid. So what uncles are, I will explain a bit later. But the general concept is that the more the blockchain gets clogged up, then basically the more blocks and the slower blocks propagate, and so the more blocks kind of get lost and don't end up being in the main chain. And as it turns out, thanks to a feature of the Ethereum protocol, you can actually calculate how much this is happening.
00:17:08.398 - 00:17:45.066, Speaker A: And so you can kind of target a particular amount to which it's happening. And you can say, if we're seeing more than, let's say 20% waste from blocks being just falling off the network, then the gas limit should go down. So there are other strategies that we're considering. So transactions contain basically seven sets of values, number one, nonce. So what a nonce does is basically every transaction has to have a unique incrementing nonce. So the first transaction you send from an account has to have a nonce of zero. Second transaction you send has to have a nonce of one, third has to have a nonce of two, and so forth.
00:17:45.066 - 00:18:27.914, Speaker A: And the reason this is done is to prevent replay attacks. So if Alice sends ten ether to bob, you don't want Bob to take that transaction and reinsert it into the blockchain ten times to give himself another 100 ether. Non suspects that gas price the amount of ether per unit gas already covered that start gas, same thing. Two, the address of the account that you're sending the transaction to, or the contract you're calling value. The amount of ether that you're sending data is just a field of data. The transaction sender can fill the data field with whatever he wants as just an array of bytes, no limits on length. But the more data a transaction includes, there is actually a fee for that in gas.
00:18:27.914 - 00:19:07.414, Speaker A: So basically you have to pay an extra 68 gas for every byte of transaction data that you include. Vrs, there are values in an elliptic curve signature. So if you're familiar with cryptography, you've probably heard of, seen the r and the s. The v value is basically an extra flag needed to do public key recovery. So basically, instead of checking the signature against the public key, you actually derive the public key from the signature. So there is this concept called of receipts. So receipts are objects that kind of get hashed into the Ethereum blockchain, and every transaction has a corresponding receipt.
00:19:07.414 - 00:19:51.734, Speaker A: So these receipts have a few pieces of data. One of them is an intermediate state route, which once again, I'll describe the mechanism later, but it's a kind of hash that represents the entire state after the transaction gets executed. Number two, cumulative gas used. So the total amount of gas used in that particular block, including that transaction. So those first two things are kind of needed to do this sort of step by step accounting that actually makes it possible to kind of check the validity of individual transactions very easily. And the third thing is logs. So logs are this special feature in ethereum that it's kind of a different kind of storage.
00:19:51.734 - 00:20:48.374, Speaker A: So in general, when you set variables that gets set in account storage and that can be read or written by contracts, logs are basically append only. So if you have a transaction in one particular block and it creates some logs, those logs get hashed into that particular block, but they are not visible, they cannot be accessed by contracts, and they appear just in that block. They're not in any kind of persistent state. So nodes, if they want to, for example, they can just not store logs and they can prune them. So logs are also ten times cheaper in terms of gas consumption than storage. And the purpose of logs is to allow sort of efficient light client access to event records. So one example of where you want to use a log is if you go back to the DNS example, you might want to add a single line to create a log in the register method and in, let's say the set IP method.
00:20:48.374 - 00:21:49.070, Speaker A: And the reason why you want to do that is basically in order to allow light clients to very quickly scan through all the logs and sort of see all the instances at which the domains got registered, IP address got changed and so forth. So there's lots of applications that wants to be able to sort of have a history of things that happened, and logs are a convenient way of supporting that. So logs have a data field and they have up to four topics. And there is a protocol that uses bloom filters to make it very easy for white clients to kind of search through logs. So basically, if you create a log that has a particular topic, then you can very easily search through the entire blockchain and sort of identify all of the logs that match that particular topic. So, ethereum virtual machine. So once again, as I mentioned, it's this sort of combination of stack based architectures, traditional virtual machines.
00:21:49.070 - 00:22:27.178, Speaker A: So inside of the virtual machine you have the stack basically 32 byte fields, up to a maximum of 1024 of them. Memory. It's an infinitely expanding byte array, but the more you expand the byte array, the more gas you have to pay. So most of the limits in Ethereum, they aren't sort of static, they're economic. And that's just a standard thing you're going to see again and again. Storage, permanent contract storage, you can read and write to it environment variables. So for example, the virtual machine can access the block number, the time, the mining difficulty, previous block hash, and a whole bunch of other data.
00:22:27.178 - 00:23:15.066, Speaker A: So one possible use case of that is, let's say if you have some kind of financial derivative that can only be processed or called struck or whatever after some particular time, then you can say in the contract that you can check the current block timestamp against some particular limit that you set logs. So the virtual machine can create these logs. And there is an opcode by which the virtual machine can itself call other contracts. So this is basically the environment within which this contract code gets executed. Now you don't have to write in virtual machine bytecode yourself. There's high level languages, and one of these high level languages is called serpent. So this is one of them.
00:23:15.066 - 00:24:09.322, Speaker A: There's one called solidity, which is being used much more right now. There's one called ll, which is kind of much more low level. If you want to really go into low level code and be as efficient as possible. You might want to use Ll, although in my own opinion you should probably consider serpent as well, because serpent lets you go as low level as ll does, and it has high level features. As you know, basically you write code in these languages, then you have compilers and you compile the contracts into bytecode and you can publish the bytecode in a transaction going to the blockchain, the ABI. So when you send a transaction, let's say that I want to call the register method of that particular DNS contract that I keep on using. As an example, function calls get compiled into transaction data.
00:24:09.322 - 00:25:01.450, Speaker A: So in this case the function call gets. The way that it gets encoded is the first four bytes are function id, the next 32 bytes are the first argument. So this was the domain that I wanted to change the IP address of, and the second argument ends another 32 bytes, which is the IP address that you want to set it to. So every time you call a function of a contract in ethereum, it actually gets compiled into a transaction which is encoded in using this algorithm, which in simple cases looks like this, just four bytes, 32 bytes keep on going with 32 bytes. But there are some special cases involving sort of variable length lists and so forth. Everything in Ethereum relies on this one serialization algorithm called RLP, recursive length prefix encoding. So it's very simple.
00:25:01.450 - 00:25:25.730, Speaker A: So basically it's recursive length prefix encoding. So you take the thing. So in this case, if you take the word dog and you just hex encode it, you get six four, six f, six seven, and before it you prefix it with the length. So in this case the length is three. And so you can see a three here. Over here it's an empty string, and so you have a length of zero. Over here this is a list.
00:25:25.730 - 00:26:02.960, Speaker A: And so it still has a length of zero, but it has a different sort of start flag because it's meant to be a list and not a string. This is for people who are set theory geeks. This is a set theoretic representation of the number two. It gets compiled to this or encoded to this rather. If you have a string, then it gets serialized into this. So there are like five implementations of this. There's a much more detailed description on the wiki, but basically this algorithm is used for blocks, transactions, network protocol, literally sort of everything in ethereum land.
00:26:02.960 - 00:26:44.366, Speaker A: Ethereum also has a cool new mining this. So this is called eth hash. So the purpose of this is to be GPU friendly and ASIC hard. So it's to target gpus as much as possible and basically prevent the problem in bitcoin, where you have these specialized miners with extremely large mining farms taking up huge percentages of the network. So the algorithm uses memory hardness to accomplish this goal. So basically, instead of traditional proof of work algorithms like bitcoin, where the bottleneck is always how much computation you can do. Here, the bottleneck is memory access.
00:26:44.366 - 00:27:28.630, Speaker A: And the theory behind this is that memory is something which is highly optimized and which people spend billions of dollars optimizing in existing computers already. And so the opportunity to make further optimizations is theoretically smaller than it is for computation. So the way that it does this is by using this sort of clever multilevel Dag construction. So basically the idea is that you start off with a seed. Then from the seed you use this memory hard function, create a cache. Then from the cache you create a data set, and the data set can be created in parallel. So each individual piece of the data set actually gets created by hashing together 256 parents that come from the cache.
00:27:28.630 - 00:28:19.434, Speaker A: And if you want to just actually run the algorithm once, then what you need to do is you take the data that you're mining on, turn that into a seed, then you grab a random 64 nodes from the pieces of the data set and you get your result. So what's the point of this? The point of this is that mining with this algorithm actually is memory hard. Because if he wants to mine, and if he wants to mine at any reasonable speed at all, then you basically have to pre generate this entire 1gb data set, so that every time you pick a different nonce, you can just sort of sample from it. And that happens fairly quickly. If you just want to verify blocks, then you don't actually need the gigabyte, all you need is the cache. And the reason why is basically that when you get to this stage, you don't need to create this entire thing. You just figure out what 64 indices you want.
00:28:19.434 - 00:28:57.618, Speaker A: Then from each of those 64 indices, you're just computed from the cache. Now, this does require you to make 16,384 hash calculations, but as it turns out, that's actually not that bad if you're only doing it once. So, because verification only needs to happen once, this kind of low memory, slow verification process actually works. But if he wants to mine, then you need to do it with a lot of speed. And so he needs to have the gigabyte. So this is kind of the basic principle behind sort of why mining was designed in the particular way that it was in ethereum. So uncles.
00:28:57.618 - 00:29:23.278, Speaker A: So in general, bitcoin has a ten minute block time. Ethereum has a 17 2nd block time. Why is the block time not something even shorter, like 1 second? The problem with fast block times is basically stale rates due to network latency. So if the block time is extremely long, like ten minutes, you can think of network latency as being negligible by comparison. You can think of it as basically being instant. And so you basically don't have problems. Once you start pushing block times down.
00:29:23.278 - 00:29:47.458, Speaker A: Then your problem is that you have this risk that, let's say over here, you have one block, 2059. Then at some point someone creates another block, 2060. That block takes time to propagate through the network. And so someone else might actually make another block before hearing about this block. And so you have two blocks, both on top of the same block, 2059. And they're kind of both competing with each other. So this is called a fork.
00:29:47.458 - 00:30:49.690, Speaker A: And the problem is that one of the blocks has to eventually win, and the block that doesn't win just kind of gets discarded and the person who mined it doesn't get a reward. So this leads to centralization risks. So basically the issue is that the more powerful you are as a miner, the better you are at getting a high network connectivity. And if you created the last block, then you actually don't have this risk because you can just immediately start making the next block. So because the more these network connectivity issues become important, the more problematic these centralization issues become. And so you have this effect where large miners end up being more effective than smaller miners. So our solution is this mechanism of uncles, which is basically that if this happens, then sure one of these blocks is going to win, but whichever block loses, it can kind of get re included in the blockchain and it still receives most of the reward.
00:30:49.690 - 00:31:50.778, Speaker A: So the point of this is it basically cuts the centralization incentives by about 85%. And it kind of allows the Ethereum blockchain to continue to be relatively safe under somewhat harsher circumstances, both in terms of fast block time and in terms of high transaction load. Merkel trees. So how many people have seen the economist cover from Blythe master saying it's all about the blockchain? Well, my opinion is it's all about the Merkel tree. And particularly unlike Blythmaster's dogs, I like doges more. So the point of Merkel trees is that they're this construction that allows for compact, efficiently verifiable proofs that a particular transaction was included in a particular block. So the general principle is that this actually exists in bitcoin.
00:31:50.778 - 00:32:39.850, Speaker A: If, let's say every block has a few hundred transactions, then if you want to verify that one particular transaction was included in a block, then you don't have to download the entire block. All you need to do instead is you can kind of download just one sort of branch of this tree. And the tree is this kind of hash tree, where every single sort of node in the tree is actually the hash of the two nodes below it. And so what you need to do is just download this kind of branch, just download the specific part of the tree that's going down to your particular transaction. And you check the hashes that are just going up the branch. You don't check all the hashes, just the hashes that are relevant to your particular branch. And if all of those hashes check out fine, then you know that particular transaction actually is in that particular tree and still actually is in that particular block.
00:32:39.850 - 00:33:27.470, Speaker A: So the reason why this mechanism exists is basically for light clients. So what a light client basically is, is a client that accesses a blockchain without processing every single block, without downloading every single transaction. Why do you want this? Well, it's pretty obvious. The bitcoin blockchain right now is 30gb, and about a megabyte gets downloaded every ten minutes. It might be good enough for a high powered laptop, it's probably not good enough for this. And 30gb is probably too much for the devices that select it is going to be creating. So instead you use these sort of clever tree protocols in order to allow these devices to only verify the absolute minimum of information that they have to that's relevance to their particular transactions.
00:33:27.470 - 00:34:11.322, Speaker A: So in Ethereum, the merkel tree mechanism is actually quite a lot more intricate than it is in bitcoin. So the idea with Ethereum is that it's not just transactions that get stuck into merkel trees, it's also the state. So if you hear about this concept of a state root, what that basically is, is this root hash. And from this root hash you have another tree. And this tree contains hashes of hashes of hashes of hashes of data representing the state of basically every single account in Ethereum. So you have these account objects somewhere at the bottom of the tree. You have nons balance code hash and storage and storage is yet another tree.
00:34:11.322 - 00:35:06.638, Speaker A: So the point here is that if one of these white clients, whether it's my phone or a SWOC it device or whatever else, wants to know what the status of one particular contract is it doesn't have to process the entire blockchain, it doesn't have to trust anyone. All that it needs to do is just ask for a Merkel proof, ask for the sort of branch of the tree and verify just that one particular branch. So this is basically the sort of concept of the Ethereum white client. Zoltful foldy is actually going to be presenting quite a bit more about this, I believe, after launch today. So every block header actually contains three trees, transactions, state and receipts. So transactions are transactions, we know what those are. The state is the entire state of every account, balance, storage, all the sort of static information that you need to know.
00:35:06.638 - 00:36:00.202, Speaker A: And receipts are, they consist of this sort of extra auditing information and they have all the logs. So if your light client wants to know what particular logs are, let's say, associated with a particular topic, then the light client is going to ask for Merkel proofs of logs. So, future directions, we talked quite a bit about this on Monday, but the general categories are, number one, proof of stake. So where proof of stake is going to fit in is basically just at the top. So it's just a change to the consensus algorithm. So instead of users having to verify proof of work, they're going to verify validator signatures instead. And the way that you would join the validator set is as VlAD described, by submitting a security bond.
00:36:00.202 - 00:36:57.054, Speaker A: So that entire mechanism is going to either be part of a protocol or it's going to be sort of specified in one particular contract, not fully decided yet. And from a user perspective, all that's going to change is that instead of validating a proof of work nonsense, you're going to have a list of signatures that you validate instead. Scalable blockchain rent. So the idea with blockchain rent is basically that right now you can access storage key, your code can set storage keys, and those storage keys will remain there forever. But potentially this might present sort of serious long term risks because the amount of storage that the Ethereum blockchain stores could just keep on going up and up. And there's not enough incentive in some people's views to kind of delete storage. There is a bit of an incentive because if you delete storage, then you kind of get a refund, but even still, there's sort of no incentive not to kind of use storage as a bank.
00:36:57.054 - 00:37:26.138, Speaker A: So blockchain grant us the idea that every contract is going to have to pay some amount per month for every storage key that it has. So instead of storage being permanent. I could imagine it lasting one year, two years, five years. If this is going to happen, it's going to be as reasonable as possible. But that's the kind of basic principle virtual machine upgrades. So that's just not going to change any of the other semantics. It's going to swap out the virtual machine that the code runs in.
00:37:26.138 - 00:38:01.300, Speaker A: So in practice, for developers, it's going to mean very little, because theoretically you could still program in the same languages. We'll just have a different compiler that compiles to different bytecode. But if you want to do things faster, then you could potentially, ideally even program Ethereum code in things like C Plus plus and Java. Scalability talks about that on Monday. So the idea of kind of having not every node process every transaction, but right now, as far as the Ethereum protocol goes, all of this is basically it. Thank you.
