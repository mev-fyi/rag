00:00:00.440 - 00:00:35.005, Speaker A: Okay, I think it's good to start anyways. I have a very short agenda which is just informing of lack of progress. I took vacations so that delaying the ip but I am now full steam again at it. I am supposed to either one of these days pull up at least open the new PR for the consensus report. Everything is ready. My biggest problem is that I'm rebasing on top of the latest Electra and the changes on Electra are causing me trouble on. On.
00:00:35.005 - 00:01:15.763, Speaker A: On ebbs. So for example the consolidations went out of the beacon block body and are now in the payload and. Well anyways changes like this are. Are. Are like not easy to to keep track of on the way that the consensus repo works because we need to come up with a full new folder for and to make it executable. Some things are actually easier. For example because of the changes in Electra we don't need to change process attestations, we only need to change like get attested indices and that makes it.
00:01:15.763 - 00:01:46.485, Speaker A: I mean it's nicer because you don't touch process attestations but so you only touch get a testing indices to not return the PTC indices but at the same time you need to be keeping track that at any part in the repo like from phase zero we're not calling get a testing indices and something might break because of this. So I'm only like checking but it should be open soon and that's my only update.
00:01:49.135 - 00:02:13.849, Speaker B: Can you clarify like what. Like what you will be opening. So let me just say it. So correct me if I'm wrong. You have a consensus spec which consists of four choice validator P2P and then the main consensus beacon chain one and then there's also an engine API spec as well and that will probably be a separate. Go ahead.
00:02:14.047 - 00:02:49.849, Speaker A: Yeah, so I'll open. So I won't even open the pr. I'll open a PR in my own personal repo that it's only going to be. So I'll move out some files that we kept many files in the same consensus for reading purposes. Like if you look at the pool request number two, you're going to see that like the engine API and everything is there in that in the consensus repo of my clone. So that's not going to happen in this new pr. It's going to be something that actually is going to be eventually open in the main consensus repo but I'm only going to open it there.
00:02:49.849 - 00:03:37.457, Speaker A: So that's going to be beacon chain validator honest validator honest builder which is a new one and then P2P changes and portrays. So that's going to be very, very soon, like in the order of dates. Then the next one is the Engine API which I think doesn't have many changes. We might want to add new methods but that's fine if it's not completely ready by the time we open the eip. But I'll open an OOMPR in the respective repo for the Engine API. I'm not sure what to do with the Builder API. I think what has to happen is that the Engine API is going to be taking all of the builder API methods and that shouldn't take that long.
00:03:37.457 - 00:03:57.485, Speaker A: And then the one that is problematic because I'm not used to it is actually open the EIP PR which might from a guest already light clients already trained me and it seems to be easy enough but since I haven't done it before that might take slightly longer.
00:03:59.035 - 00:04:04.483, Speaker B: That's awesome. And there's also the execution spec which I don't believe there's any changes for the execution.
00:04:04.539 - 00:04:09.135, Speaker A: There's no changes at all so there's no need to touch the execution spec.
00:04:12.475 - 00:04:29.045, Speaker C: One thing Protus I noticed was that in your current epvsp in your own repo there is still mention of inclusion list. So is that going to stay because.
00:04:29.385 - 00:05:21.185, Speaker A: No, they're going to go no. So I'm going to open one without inclusion lists and yeah, so the pull request is going to be exactly what is in my repo without inclusion list but then with all the Electra additions. So yeah, so inclusion list is the biggest complication of that PR that is in my repo if we remove inclusion list, the PR becomes purely a consensus layer fork and it's a trivial fork. If ACD decides that they want to go ahead with like 7547 that's absolutely fine. This pull request is this EIP is completely compatible with that, but it's fine if it's an independent eip. So I think it's fine not to include inclusion list in this eip. Also because there's other methods for inclusion list and also because we might want to have.
00:05:21.185 - 00:05:27.585, Speaker A: I mean we keep the ability of self building so it is logically an independent eip.
00:05:28.965 - 00:06:22.185, Speaker C: Perfect. I think. Yeah, it would basically make this EIP very crisp if we sort of separate them out. Another thing that I noticed portals was that in the execution payload header, so instead of block hash of payload, can we keep the merkle Merkle root of the execution payload? I mean should we have that. Because I mean, if for example, execution payload is no longer part of Beacon block, then basically possible, it's no longer possible to sort of have a proof against the current attributes of execution payload against the beacon block. I'm not sure which apps use it or are there any use cases for it, but I mean, yeah, someone should.
00:06:22.225 - 00:06:23.481, Speaker A: Take notes for this.
00:06:23.633 - 00:06:25.405, Speaker B: Yeah, I'm taking notes. Go ahead.
00:06:26.585 - 00:06:54.515, Speaker C: It might also be a moot point if we sort of also get to stable containers. But in any case, yeah, we should sort of keep, keep track of this at any point whenever this goes in instead of just picking up the block hash from the execution payload. If we can sort of keep track of micro hash of the execution payload, that would be nice in the execution payload header.
00:06:56.775 - 00:07:25.745, Speaker A: So I don't see any reason not to. I. I'm not sure. This depends, I guess on the UX of this. If having the block hash itself makes it easier to pick up what actually was the execution block that was associated to this to this particular slot. And the EL keeps tracks of block hash. You can request only by block hash, not by hash reroute.
00:07:25.745 - 00:07:49.707, Speaker A: So I suspect that most proving is done on the EL side. So I suspect that the consumer of this would be people that communicate with an elite beacon node and with an EL node, not with a beacon node. So I'm not sure if it's more beneficial to have the HDR or the block hash. We should ask people that actually use the chain. Yeah.
00:07:49.731 - 00:08:08.955, Speaker C: Yeah. So again, I'm also sort of not fully aware what the use cases are, but yeah, I mean, they potentially could be someone on the bridges trying to prove that this transaction was included in this particular beacon block or not. I mean, that's what I can think of.
00:08:24.855 - 00:08:27.887, Speaker B: Yeah, I took a note on that. Go ahead. Sorry.
00:08:28.071 - 00:09:02.224, Speaker A: Yeah, there's. There's another observation regarding the Execution payload header. If you noticed, I removed it entirely. Like I've transformed it to not keep track of anything. Like that's what is there. It's just the minimum information that you need to actually be able to process the block. I heard Alex Stokes complain about this, that light clients might use it, but then I heard people that are actually working on light clients telling me that it's useless, that there's no use for it.
00:09:02.224 - 00:09:37.425, Speaker A: So I am keeping it like this, but it's good to keep note of that. There's no use currently on the execution payload header. So actually I don't even understand why we keep it now. We could just currently, it seems to me, for all the purposes that we have on the beacon chain, we can replace the execution payload header by the block hash of the execution payload and everything's going to work fine. So. Well anyway, so that's, that's one extra observation that if we can minimize it or not, because if it is a blocker then we need to go back to just keep the full payload header.
00:09:38.165 - 00:09:53.785, Speaker C: Or we can keep the markle root of the latest execution payload error inside instead of later execution payload. I mean that way basically whatever the attributes are, you would be able to link it to the. We can block.
00:09:54.265 - 00:10:20.919, Speaker A: So there are, there are few, there are a few things that we actually need to keep. So we need to know the parent. So we need to have something that identifies the. The previous block which you're suggesting is the HDR or it could be the block hash. It's fine like anything that identifies the parent block on the execution side but there's other things that we need to keep them. We need to keep the BLOB KCC commitments. We need to keep a bunch of things that are in that header.
00:10:20.919 - 00:10:32.955, Speaker A: So it's not only we cannot really just replace it by just a single route. Currently we can keep it by a single route, but on EPVs I don't think we can just replace it by a single route.
00:10:42.375 - 00:11:26.535, Speaker D: Yeah, I've had this discussion with Ethan regarding the Light client and obviously he's one of the main people working on it because he actually asked me whether I thought that there was anything that. And I wasn't. I didn't think so at this point either. The paygoad header as a whole, there were use cases around the merge about distinguishing basically essentially there were some checks for was the previous blocks payload header the default payload header or not because default meant that you were pre merge but we don't care about pre merge anymore. Not certainly in any PBS world. So it was, it was not that it was useless from birth, but it is useless now as far as I know.
00:11:29.435 - 00:12:02.477, Speaker A: Good, that's reassuring. Actually Ethan was the one that told me that. I'm sorry that I'm putting words on you Ethan. Yeah, I see that you're here but yeah, so Ethan was told is the one that told me that we could remove it so. So I'm happy to keep the PR as it is now. I promised this meeting was going to be very, very short so I'm hoping that the next one two weeks from now is going to be longer because we're going to have at least something out. So that's all from, from me I don't know if anyone has other items.
00:12:02.621 - 00:13:16.577, Speaker B: I have one topic on Beacon API, which I see there's a bunch of people that's working on Beacon API here, so I'm curious for your feedback. So currently we have this like weird asymmetry, right? Because of the full consensus block contains the payload, but you don't want to store the payload twice. So you have your consensus block with the payload on the consensus side, but on the execution side you still have to support RPC endpoint to get the execution. So typically how it works is that on the consensus client we blind the payload and then if user requests the beacon block, we will try to get it from the execution client and then unblind it and then return it, right? So it's kind of annoying to do that. So on the. So EPDs is nice in a way that like consensus and execution are like fully pipeline. So by default a consensus block is always a blind block, it always contains the header, right? So when you request a consensus block, you don't need to unblind it anymore, it just returns the consensus block as it is and now blah blah, blah.
00:13:16.577 - 00:14:13.123, Speaker B: And now the problem is that, okay, what happens if the user requests an execution payload from the. From the consistent client? Actually, let me share my screen screen and just look at the. Let's just look at the posters spec. It might be easier to go through this. Let's see. Okay, so you can see my screen, I presume. So basically in Portus Epps stack today there is this attitude payload envelope and you can ignore all the inclusion this stuff because that will be removed, right? So this envelope only includes the payload, the builder index, the beacon block route, the block KCG commandment, and whether this payload was withheld.
00:14:13.123 - 00:14:56.965, Speaker B: Okay. And this attitude payload, we know it can be retrieved by the execution layer client. So that's good. We don't need to worry about getting this. So we can all agree that we don't need to return this from consistent layer client, right? So I think the only thing that's really useful that people might want to know from the execution payload is whether this payload is withheld, right? Besides that, I don't think there's any reason that we need to have a separate endpoint to return execution payload envelope. We can just given a slot or a beacon block route, we just return whether the payload was withheld or not and that's it. Do you guys agree with me here?
00:14:58.085 - 00:15:08.865, Speaker E: So you're saying that we are the beacon node, we will no longer expose anything about the execution payload. And it will become something.
00:15:09.325 - 00:15:11.109, Speaker B: You will have the header. That's it.
00:15:11.197 - 00:15:14.093, Speaker E: Yeah, yeah, yeah. But in terms of how do you.
00:15:14.109 - 00:15:21.037, Speaker A: Get the state route? How do you get the state route? I mean, there's an actual state transition out of that envelope.
00:15:21.181 - 00:15:21.749, Speaker B: Oh, okay.
00:15:21.797 - 00:15:21.981, Speaker A: Yeah.
00:15:22.013 - 00:15:33.115, Speaker B: So you can return the state. Yeah, so I guess you need to return a state route. You're right. Yeah. So you need a state route. And then whether the payload was withheld, those two.
00:15:37.055 - 00:15:47.555, Speaker A: Well, in fact, if the state route is different, it means that the payload wasn't actually. I don't know. No, both of them would change the state. Yeah, yeah.
00:15:53.265 - 00:16:09.337, Speaker B: So my question is that I really don't want to have to design this in a way that I still have to get a payload from the execution layer client. That's the only thing I want to avoid. Like, I think that just annoying to do that.
00:16:09.521 - 00:16:30.755, Speaker A: But I don't understand. So I mean we are just, we have a new endpoint that just returns the execution payload envelope and it just gives you blinded. It gives you the exit instead of the payload. It gives you the block hash. Right? Yeah, you can do that. You can request from the EL the corresponding block.
00:16:31.335 - 00:16:45.305, Speaker B: Yeah, yeah, we can also do that as well. But the question now you have to define a new type. You have to define this new type that's called execution payload that only contains the block hash, not the payload itself. So there's this new type.
00:16:45.605 - 00:17:30.541, Speaker A: Oh, I see. And then what's the problem of keeping the current functionality? It wouldn't be easier for the consumers today. Not that I really care about any of this, but the consumer today, doesn't it request the full blocks from the beacon? Will they? I mean, suppose that they have some architecture where their EL is hidden from the guy that is making this request, but the CL is not. And, and then they tunnel the CL to the somehow so they request a full block currently from the cl. Wouldn't we be breaking that setup by having them expose their client to actually call directly DL? Yeah, that's why.
00:17:30.613 - 00:17:31.093, Speaker B: I don't know.
00:17:31.149 - 00:17:56.291, Speaker E: That's my, that's my point. I mean this is not, not, not a technical thing. But do we want to the beacon node to continue being kind of a proxy for getting all the information throughout the EL itself? And maybe we could have a dedicated API engine API that also force to get the block throughout the engine APIs.
00:17:56.403 - 00:18:20.749, Speaker A: Yeah, my instance here is that we shouldn't even worry about any of this. The EIP should be put out with the simplest possible design. And obviously the simplest possible design is to return the full payroll envelope, not define anything new. And I don't care about implementing this. I won't even implement this at all. So why. Yeah, I wouldn't worry about this until this is decided.
00:18:20.749 - 00:18:22.025, Speaker A: To get in or not.
00:18:23.045 - 00:18:52.551, Speaker B: Yeah, yeah, yeah. That was just a question. So. Yeah. So sounds like to me we can just keep things as it is and if anything we can decide later or just retrieve the payload from attitudinal layer client. Right. And let's see, another thing is that when you get a state, can we assume that we will always return the full state if the full state is available? For example, say today, if the slot is full, you will always return the full state.
00:18:52.551 - 00:19:03.459, Speaker B: I mean users shouldn't have the option to get either the full state or just the consensus state without the payload as process. Right. Because there are two versions of the state in the middle.
00:19:03.627 - 00:19:09.923, Speaker A: I don't understand. So what's the call? The call on the beacon. You're talking about the Beacon API to get the full state. The beacon state.
00:19:10.099 - 00:19:11.435, Speaker B: Yeah. It will always.
00:19:11.515 - 00:19:25.735, Speaker A: When you request the beacon state. Right. The state for head would be you're going to choose full or not according to what's your head. So that there's no question there. The question is if you request by slot.
00:19:26.315 - 00:19:27.055, Speaker B: Right.
00:19:28.685 - 00:19:38.197, Speaker A: Then again, I'm not really worried about any of this. But you could imagine that you have slots and the pair slot. Full slot. Not exactly.
00:19:38.261 - 00:19:42.733, Speaker B: Yeah. The question is do we need to worry about that? But it's probably too early to worry about that. You're right.
00:19:42.789 - 00:19:52.265, Speaker A: Whether you do need states, I'm sure that if there is a need to get a stage for a particular slot, then there's also a need to get both of them the full and the not full.
00:19:52.885 - 00:20:00.759, Speaker B: Why would people be interested at full if it's always going to. If it's full. Right, that's. That's my point.
00:20:00.927 - 00:20:05.391, Speaker E: It seems like to me that we should response is full when it's full and.
00:20:05.543 - 00:20:06.239, Speaker B: Exactly.
00:20:06.327 - 00:20:12.103, Speaker E: That's why we keep both in the fourth choice. But return what? What the best of it.
00:20:12.279 - 00:20:13.647, Speaker B: The best is the full one.
00:20:13.751 - 00:20:16.875, Speaker E: Yeah. If the full is full. Otherwise it's empty.
00:20:18.455 - 00:20:30.625, Speaker A: I don't see why would you have an endpoint that actually hides information. I mean, when you request the state, you might want to get that particular state. Right. Otherwise there's no way of accessing that state.
00:20:31.085 - 00:20:38.189, Speaker B: So you basically want to have a slot and also have a Boolean flag that basically say whether it's four or empty and then.
00:20:38.357 - 00:20:55.795, Speaker A: Or you just have two different Endpoints like pre payload and post payload. Because anyways, you have two states, so you will have two states. It doesn't matter if it's full or empty, because if the payload is withheld, you also will have a different state transition.
00:20:56.175 - 00:21:07.555, Speaker B: Right, right. So the question. Yeah, so the debate here is that like, is the empty useful whether we need to provide it. But sounds like, yeah, I don't think we're coming to an agreement in this meeting. And I don't think.
00:21:08.815 - 00:21:18.255, Speaker A: Yeah, but also, also I'm talking and I said two things that are actually wrong. When the payload is withheld, the state route is kind of irrelevant.
00:21:20.915 - 00:21:21.275, Speaker B: Right?
00:21:21.315 - 00:21:40.975, Speaker A: Yeah. So when the payload is withheld, the state route is kind of irrelevant and then you don't process the. I mean, when the payload is withheld, the builder is hoping that the block is going to be reorged anyways, so we don't really care about that state post withheld payload.
00:21:41.745 - 00:21:42.913, Speaker B: Yeah, exactly.
00:21:43.009 - 00:22:17.241, Speaker E: To me, this is an internal complexity that could be hidden to the API until we could have the bug endpoint like, which historically is today to dump everything. It's still debug. So we could have a debug into a point or this information could be dumped through our endpoint. That dumps the fourth choice tree and we could, we could, we could expose this information, this internal for choice information throughout that.
00:22:17.313 - 00:22:17.737, Speaker A: That.
00:22:17.841 - 00:22:23.085, Speaker E: That endpoint and hide this in this complexity through the APIs.
00:22:25.745 - 00:22:32.805, Speaker B: Okay, that's all my questions. I mean, yeah, but it's probably too early to really go over this in detail.
00:22:34.925 - 00:22:50.785, Speaker C: One small nit. If I can just point out, maybe we can use optional for the execution payload over there instead of having a payload held. If it's null, then obviously the payload was withheld and.
00:22:53.685 - 00:23:03.705, Speaker A: Oh, definitely. Do we have optional already in ssz? I don't want to make this EIP contingent to having something else being included in the specific.
00:23:05.315 - 00:23:06.855, Speaker D: I mean, it's not.
00:23:08.875 - 00:23:17.135, Speaker A: Right. So if it's there, then it's an easy change to add it and then I'm happy to add it, but I don't think we have optional in our library.
00:23:18.155 - 00:23:26.495, Speaker C: Yeah, it's there in the sense that Stable container ERP uses optional and. Yep.
00:23:27.075 - 00:23:42.395, Speaker A: And it's supposed to go to Electra. Yeah, but we don't have this yet, so then I won't be able to have a proof of concept. I'm happy to answer. So we should take note that it's better to have the optional for the withheld payload.
00:23:44.015 - 00:23:48.503, Speaker C: Yeah, because we can go with the union kind of a Thing, Right. Union.
00:23:48.559 - 00:24:12.171, Speaker A: None with a union type. No, but it's fine if it's optional, because if it's there for in the stable container, we can have it and then the builder that is actually withholding may just not send anything. In any case, the builder can always just build crap and just send crap in that execution payload because the payload is completely normal.
00:24:12.203 - 00:24:15.695, Speaker C: Yeah. Or just can send a default value. Nothing to build at all.
00:24:16.555 - 00:24:36.135, Speaker A: Yeah. So yeah, the way I was going to implement this in the proof of concept is that for the withheld, the builder was going to build a sort of like an empty block, like an empty object that satisfies the serialization. But yeah, I agree that optional is better. It's definitely better.
00:24:40.875 - 00:25:00.991, Speaker D: Right, I'll agree with that. But I also want to point out with a. With union, union is one of these things that technically exists sort of maybe in the SSE spec. It is not used. It has never been used. And I would actually very much like to keep it that way because right now we still have the opportunity to get rid of it with. To actually simply remove it.
00:25:00.991 - 00:25:26.075, Speaker D: Because we. Because we have never used it except for like three alpha releases in 1.3.0 or something like this. And because an OPT is better for generally speaking. So I'd let really specifically for this not to be a trojan horse for union, just personally. Anyway.
00:25:35.095 - 00:25:56.125, Speaker A: All right, hand on, Terrence. Seems to be done. If you guys have any questions. This is a good time. Otherwise we can close in less than half an hour, which is a very good thing. And in two weeks I hope that. So for the next meeting, I hope that the EIP is either out or at least every component is already public.
00:26:00.145 - 00:26:09.445, Speaker C: One thing I want to clarify is that if the payload is invalid, is the corresponding weekend block valid or that becomes invalid.
00:26:10.305 - 00:26:51.477, Speaker A: So. So when you. So the beacon block has a completely independent state transition function and it requires that the execution payload header is valid. So if the execution payload header, which is signed by the builder, is valid, then the beacon block will actually be synced and all of the changes will be committed to the beacon state. Whatever happens later is completely irrelevant. So if the payload comes in and it's invalid, then that payload will not be synced. So the state transition would just not be touched by that payload.
00:26:51.477 - 00:27:06.827, Speaker A: But the builder already has paid the value when we synced the execution payload header. So that block is going to appear as something that we're calling empty. So it's not skipped, but it's empty.
00:27:06.891 - 00:27:13.615, Speaker C: Got it, Got it. So basically it won't get Any withhold boost? Every single.
00:27:15.475 - 00:28:01.629, Speaker A: So yeah, so, so the, the, the builders boost are applied only to payloads that are valid or valid. With that on top of that, the PTC has achieved some consensus. So PTC only applies to give you this boost. So what you do is when you're syncing something, you check, okay, so I have this payload, I've checked it. And you only need to do this at attestation time. So when you're attesting, which is like about in the happy case, it should be around 10 seconds after you receive the payload. So only then you check, well, I received this payload, I don't care if I received it timely or not.
00:28:01.629 - 00:28:09.645, Speaker A: I just have this payload is valid and the PTC told me that it was timely. So in that case I say okay, so it has a boost.
00:28:09.805 - 00:28:14.925, Speaker E: So we are in the world where PTC votes only for timing and not doing the validation.
00:28:14.965 - 00:28:15.165, Speaker B: Yeah.
00:28:15.205 - 00:28:20.261, Speaker A: So I think this is the biggest gain of the CIP. So it's even better than EPVs itself.
00:28:20.453 - 00:28:41.695, Speaker E: Okay. Yeah. So it's perfectly exactly the same as withheld in terms of a user that looks at the chain and sees that the beacon block was having a block route, a payload payload hash that is not zero but never showed up.
00:28:43.715 - 00:29:08.661, Speaker A: No. So that's different. So if the, if the beacon block came with a commitment to a payload to a particular builder and you haven't seen that payload, so you haven't seen a withheld message, it doesn't matter if the PTC commitment PTC committee told you that message was withheld, you will just treat it as a no show.
00:29:08.853 - 00:29:22.097, Speaker E: So the difference was that you got the vote from the PTC in that case, but. So it's not withheld, but was not imported anyway.
00:29:22.281 - 00:29:46.695, Speaker A: Right. So this is important and this should be checked because I'm not really sure that I coded that correctly on the forgery spec. But the intention is exactly this, that you act, you give a boost or not according to the ptc, but after you validated the payload. So if you are going to give it a withhold boost, you must have validated a payload that was a withheld message.
00:29:47.235 - 00:30:00.715, Speaker E: So PTC just gives you timely, but the boost is actually on your side still after you do the full validation of the execution layer of the.
00:30:00.795 - 00:30:07.955, Speaker A: Exactly. Exactly. So the PTC just tells you you should apply a boost if this is valid. Yeah.
00:30:08.075 - 00:30:14.995, Speaker E: If the PTC show up with Hel, you don't care, the boost will not be there anyway.
00:30:15.335 - 00:30:20.275, Speaker A: No, no. Yes, because. So if the PTC votes for withheld I'm sorry.
00:30:20.975 - 00:30:25.635, Speaker C: Yeah. So if it's withheld, then the boost is applied to the parent.
00:30:27.095 - 00:30:46.295, Speaker A: The boost what? So if it's withheld then the boost will be applied to the parent. That's correct. The withhold boost would be applied to the parent block route. But then again you need to have a valid withheld message. So you do care that you actually have a valid payload.
00:30:50.075 - 00:30:50.435, Speaker B: Right.
00:30:50.475 - 00:31:01.015, Speaker E: So the PCT mess PCT messages gives you tells you to which block you want to apply the boost.
00:31:01.635 - 00:31:04.969, Speaker A: Correct. To which? Yeah. So to which station?
00:31:05.147 - 00:31:05.637, Speaker C: Yeah, yeah.
00:31:05.661 - 00:31:08.629, Speaker E: The pre, the parent one or the current one?
00:31:08.797 - 00:31:09.545, Speaker A: Yeah.
00:31:10.045 - 00:31:24.077, Speaker C: So one other question. If for example the proposer has seen the withheld message or the payload message but PTC has not seen, so you don't have the threshold for PTC boards.
00:31:24.261 - 00:31:25.013, Speaker A: Yeah.
00:31:25.189 - 00:31:27.261, Speaker C: Then how, then the proposal will treat.
00:31:27.293 - 00:32:21.125, Speaker A: It as not so a malicious proposer can actually exploit this situation. This is essentially a split view on the spt. So if you're a malicious proposer, you can actually exploit this by saying ah, this I cannot give a boost. And if, if, if I see that other validators also haven't seen this are in this situation, then other validators will not boost the payload. So if you're a malicious proposer and you hold a large malicious stake, then you can actually exploit this to reorder that pay that you've seen. So that lowers the threshold of malicious state that you need to have to reorder to reorder the payload. However, of course the honest validator, the honest proposer that has imported the payload even without a boost, that would be its head.
00:32:21.125 - 00:32:39.459, Speaker A: So even if the PTC hasn't achieved consensus, if you're the next proposer and you synced the payload and the payload was valid, that's your head. So you're not going to reor the payload. I don't know if I was clear, but I can repeat. Okay.
00:32:39.547 - 00:32:56.095, Speaker C: I mean, right, so basically you are saying that if, even if I have not seen, even if PTC has not told me that it has seen the payload, I will still import it in my fork choice and make it my head and propose on top of it.
00:32:56.485 - 00:33:14.221, Speaker A: Yeah. So what you would not do is give it a boost because the PTC dictates what gets a boost. But even without the boost that that thing extends your head. Right.
00:33:14.333 - 00:33:27.761, Speaker C: Okay, so so the PTC booster on BTC scene votes are only to give the boost for the head or for the parent if it's withheld, for example. But apart from that it will not.
00:33:27.833 - 00:34:16.025, Speaker A: Invalidate the tip, it will not invalidate it. That's correct. So if the PTC votes for withheld and you're a malicious proposer and you anyways build on top of that. Well, suppose that there's an equivocation, which is even easier. Suppose that the PTC votes for withheld, but actually the builder has sent, has sent two payloads and one of them is actually valid and the other one is the withheld one and you're a malicious proposer and you propose on top of the valid payload, then that's fine. Everyone else would try to withhold it because the PTC voted for withheld, but your block is still valid. They will sync your block and that's that I think is fine.
00:34:16.025 - 00:34:36.164, Speaker A: There's no gain on this kind of attack. I've gone through all of these cases and I think there's no attack in this scenario. I think there's no attack on equivocations on the builder side. That's why I believe that it's also easy to actually do slot auctions instead of block auctions for this pip.
00:34:39.264 - 00:34:56.835, Speaker C: Okay, one other question. I saw in process attestations that if, if the testing indices were in belong to ptc, they were not sort of being divided over there. So what is the thought process behind it?
00:34:57.495 - 00:35:01.835, Speaker A: I'm sorry, how is it, what was the question?
00:35:02.695 - 00:35:15.135, Speaker C: So basically I saw the process attestations if the testing indices belong to one that was in ptc, they are sort of not rewarded, I think.
00:35:15.595 - 00:35:16.075, Speaker A: Yeah.
00:35:16.155 - 00:35:18.695, Speaker C: So what is, what is the thought process behind it?
00:35:19.595 - 00:36:20.395, Speaker A: Oh, so again this is just for simplicity in principle, what we should, we could do is remove completely these adjusters from the committee. So when you get give me the Beacon committee to remove those from the PTC and then change everywhere in the spec that uses the committee. So for simplicity I went through with a design that is hacky. So perhaps we can change that which is the committee doesn't change, it's just that the last few members are PTC members. And so when you call to get the ptc, what you do is you call the committee, you get the committee and just take the last few members. So that, that's, that was the easiest way of getting the PTC committee without like having new helpers from the state deriving a new shuffling or whatever it is to get this members. So now the problem is that the PTC members are also committee members by definition.
00:36:20.395 - 00:37:06.005, Speaker A: Therefore they could in principle attest and not send PTC votes, but the PTC reward is only an attestation. So then that that gives you bad incentives in the sense that you can choose a test, not do anything for the ptc, not care, not even listen for payloads, and you're going to be rewarded. So the idea was, well, we're not going to include any attestation from the PTC member so they don't get the reward. They get a missed attestation by default unless they send the PTC vote. So when you process the PTC votes, then you reward them the attestation. Honest clients, like vanilla clients, should not allow PTC members to attest.
00:37:08.785 - 00:37:10.645, Speaker C: Understood. Thanks. Thanks a lot.
00:37:18.465 - 00:38:05.175, Speaker D: I have a question. We've started getting about questions about pre confs and that's a broadly different topic. I understand, but epbs obviously has potential attractions with this and what my question here is as we Nimbus start hearing from people about pre confs and what and I personally want to make sure that Nimbus doesn't access these sort of start, you know, aligning with anything that pushes against EPBs, because I want EPPs to happen. So what are the. The characteristics of pre comps that work with EPBs and don't to.
00:38:05.635 - 00:38:49.291, Speaker A: I posted, I posted something on ETH research. I don't know if you've seen it, Dustin, but it's not something which is of preconf itself. So the things that clash with EPBs are things that on protocol require the payload to be present at the time when you process the beacon block. That's by definition something that would break EPBs. So if you require the payload to be present, then that's, that's really, really bad and we cannot get away against that. So anything that would require the payload at the time that the beacon block is present is processed completely breaks epvs. Yeah.
00:38:49.291 - 00:39:50.465, Speaker A: So I'll find the link in a second. But with regards to your particular question, it depends on what you want from epbs. I think that the biggest selling point that we have for people that don't care about EPBs but care about other things, one of the biggest improvements that the CIP brings is this thing of like the validation time being much longer. So instead of having two seconds to validate everything, you now have like nine seconds to validate the payload or data availability for peer does, for example. So if you don't want to break that, then you don't want to overload the become block because the become block happens to be now the critical time become block has only like 1 to 2 seconds to be to be validated. And if your preconf is in protocol Namely a force inclusion list. Like many of these.
00:39:50.465 - 00:40:49.615, Speaker A: Many of these mechanisms rely on something like 7547 overloaded. They say we're going to have a market for inclusion lists and that's going to be the pre confer is going to force the proposal that is participating in putting transactions in the inclusion list. And then the problem is that for that you need a big block, a big consensus block because you need to validate the inclusion list with the consensus block. So anything like this which are in protocol precomps that overload the become block and it makes it larger and it makes it that now you need to actually execute on the beacon block as well then that that breaks. That's in contention with DPVs. So if you need to validate some something from the execution client at the time that you're validating the consensus block that is really a contentious. This is contentious with epbx but it's also contentious today like without epps.
00:40:49.615 - 00:41:33.609, Speaker A: It's also bad like if we send now an inclusion list that is like an entire block then you need to like validate two things with the pickle block. Okay so. So that's I think is the biggest thing. However I believe that the best designs. So I've been pushing for this but I haven't been vocal about this because I also don't want to legitimize precoms in protocol. Precoms are by nature of protocol design and I think it's fine if we keep them off protocol but I think EPBS makes them easier because you can enforce the pre conf. You can enforce the pre conf satisfaction on the builder instead of the proposal.
00:41:33.609 - 00:41:51.765, Speaker A: So if the builder is taped this should make the people that are working today on pre comps happier. So that's my take on precoms but it's that Justin Drake does not. Does not share this.
00:41:54.515 - 00:42:20.933, Speaker D: Interesting. All right, well I mean that they said they had actually spoken with you specifically and and that about. And basically said that they're reported that a claim of compatibility and it sounds like for. For these particular. For that for and because they were one of the people within not in protocol version. That was selling point.
00:42:20.989 - 00:42:34.385, Speaker A: I've only said this personally to one team which is the team. I think it's chainbound the pre map team that have a state version. Yeah. Anything that is restate is completely compatible with EPBs.
00:42:35.725 - 00:42:48.847, Speaker D: Okay. Okay. So they're the people who are kind of. Who kind of for first approached us and so. Okay, that's. That's all right. But so I haven't read the way.
00:42:48.871 - 00:43:02.315, Speaker A: They enforce them because if they require from the proposer to actually sign the payload, then that's also bad. But I think what they have, I think is compatible with the PBS in any form.
00:43:03.295 - 00:43:16.917, Speaker D: Right. Well, what they have is an oracle ultimately and they have other problems with their design. But I mean, like that, that's a sort of separate topic in a lot of ways. But, but I mean, I, I want. But as far as. All right, I. But.
00:43:16.917 - 00:43:22.305, Speaker D: But at least understanding that, that, that and will beat the post. All right. Yeah.
00:43:22.805 - 00:44:08.643, Speaker A: I actually think that unless they come up with different. The thing is that they are, they're forking MEP Boost. So if we remove Map Boost, if we remove Map Boost from clients, they're going to have to come up with a different way of getting the proposer to interact with their system. But I claim that we can do this all within the Beacon API or the Engine API within EPBS without any dramatic changes. So I don't think this is a big problem unless people want to have in protocol precons, which is what Justin wants. There's a bunch of people that actually want in protocol pre conf. And that I think is bad.
00:44:08.643 - 00:44:11.015, Speaker A: That I think is not compatible with anything.
00:44:15.235 - 00:44:35.817, Speaker D: Right. I mean, there's a sort of set of broader questions here which I've actually sort of deliberately been trying to kind of not get too much into, but about skepticism about precomps along the lines of MEV is sort of MEV Part two, et cetera, in terms of rest of the world wants it, is it good for L1, et cetera, et cetera. But these are all sort of questions that are not.
00:44:35.921 - 00:44:36.185, Speaker A: But.
00:44:36.225 - 00:45:06.323, Speaker D: But. Right. I'm not personally inclined to like love free comps in L1 in any intrinsic way, but I don't have strong views yet on it either way. I mainly want to, in this context, sort of ascertain about the compatibility. Put it this way, whatever. One, there's a big maybe, maybe to try to keep it on topic here and relevant. There's a broad design space for pre conf.
00:45:06.323 - 00:45:42.291, Speaker D: There are many people suggesting there's whole periodic tables of pre conf designs and all being systematically explored. All right, that's fine, that's great. But also, as a result is still very much researchy space that you say MEV command, et cetera. These are ways of either deferring the need to standardize or it's very clear standardization is a ways away. There's no EIP coming anytime soon. It's not Gonna there's nothing like that. So if we want anything in protocol it is anytime soon it is not going to be pre conf one way or the other.
00:45:42.291 - 00:46:16.525, Speaker D: Whatever Justin Drake wants. And so and Epps has is both a much more concrete near term and specifically L1 advantageous set of changes and that and so in terms of the prioritization that I'm looking at is sort of pre confs are out there. I'm willing to engage with them and look at them and I just want to make sure that it doesn't kind of undermine like something that can concretely help Ethereum much sooner.
00:46:16.825 - 00:46:50.837, Speaker A: So the fear might. But this is a personal fear. The fear is, I mean these are all VC backed companies that are competing among themselves like to come up with a particular design that wins the market. So what they want and they're all in cap their business is in capturing proposals. So if, if it so happens that one of them actually wins and there's a very large and this is going to happen fast because they're all competing among each other. So so they have an incentive to ship this immediately and they don't need to go through ACD not to go through anything. They can just ship it.
00:46:50.837 - 00:47:39.453, Speaker A: They are already testing on DevNet and there are some people that are actually shipping blocks on mainnet with preconce. So this will happen in the next few months. And if we see one such protocol that takes a large part of the validator set then this undermines EPBs in the sense that we would probably break it if we break their setup. If we ship clients that lose this map boost interaction, if they lose the support from clients to how to interact with these map boost then we're going to see a backlash. We're going to see the community say no, we don't want this. So that's my personal fear. But this is just more politics than actual protocol design.
00:47:39.453 - 00:47:42.025, Speaker A: So I don't really care about this for the time being.
00:47:45.375 - 00:48:28.945, Speaker D: Right. Although it, it does suggest. Do you, do you think from that perspective there's a relevant timeline difference in terms of Pectora or, or F Star and I mean Pector is kind of a long shot anyway but like there, there are some proposals and I, I know there have been discussions on the SSC side of saying there's something that are like well if we don't get in now F Star is going to be a really, really hard push to get in because of Verkle. Well on the El side for example, is there are, is this something that you're concerned where there's a decent chance that it could pector is soon enough, but that if it waits till F, then that's it. It's probably going to be too late because of this.
00:48:29.325 - 00:48:49.667, Speaker A: That's. That's my biggest fear. I'm not sure. I mean I would have. I would be in a very completely different situation if every client already had branches and they were working on a proof of concept. But as today, I think only Prism has a branch that is working on coding EPMs. So, so it's useless to be talking about forks without the clients implementing anything.
00:48:49.667 - 00:49:25.369, Speaker A: If we are in a situation where every CL client, this is only a CL fork. So if we have a situation, say a few months from now that every client has a proof of concept, then the talk is going to be different. But as of today, it looks to me like a race on time. But also I claim that for pre confers modulo this fact that you capture a market, the best design actually is easier and better with EPBs than without it. So. So I'm hoping that they recognize this. It's just that they are now building on top of a non epbs world.
00:49:25.369 - 00:49:51.125, Speaker A: And I understand them right, because. Well, they, they don't. They. They. They need to build for now and there's no EPBs now. So if they, if they were building on top of epps, I think their design would be more robust. I'm hoping that in a few weeks when we get clients with branches out, then the talk is going to be different.
00:49:53.425 - 00:50:10.295, Speaker D: Yeah, actually, and Prima was telling me that from their perspective, they actually agreed with you on this point that they thought a PBS world is better for them specifically. Which is not to say necessarily for all the pre confers, but they specifically would, I think.
00:50:10.455 - 00:50:37.265, Speaker A: Yeah, so their design would be some. The design that I posted on Neat Research is very much like theirs. And it becomes much easier because you only need to restate the builders. So it's much easier to capture builders that participate on that. So it's for them, their design is very much compatible with EPBs in that sense. And I think for them to change it if they are the winners is easy. So I don't know about others.
00:50:37.265 - 00:50:47.745, Speaker A: They're all centralized one way or another. That's the biggest problem. They all require a relay that precomps for everyone.
00:50:50.165 - 00:51:37.775, Speaker D: Yeah, yeah. I had this discussion with, with them a bit. There are concerns there, but I think it is context. The main thing is just trying to. Well, and this is kind of why I brought this question here sort of is Given that pre comps seem likely to happen, there's a big enough push for them, whatever anybody else thinks, same way MEV was pushed basically from the outside and so is this and that's fine. They both would happen and did happen will happen. But if what we might be able to do is try to redirect the ecosystem towards some pre comps away from others, that, that, that still might be and, and if that would kind of in a way, in a way that leaves space open for epps.
00:51:39.595 - 00:52:45.285, Speaker A: Yeah. So I, I'll be worried about like making protocol decisions that are based on affecting or not these companies. So so far I think it's fine if we just have a design that we know it's not openly incompatible with precoms and if there's some design that is actually winning by the time that we come up with an EIP and client implementations and that winning company is openly against EPBs or it's openly broken with EPBs, then we may have a talk and see if we can adapt or not. So far I haven't seen anything that is immediately accept this thing of like having full inclusion lists, like blocks, inclusion lists that are just of the size of the block that is definitely against EPBs, but I haven't seen any, any such thing being proposed at all. So there's, there's not even a push for inclusion lists currently on L1. So, so I don't, I don't see this being a problem for now.
00:52:47.345 - 00:52:47.913, Speaker D: Okay.
00:52:48.009 - 00:52:57.525, Speaker A: Yeah. Again I'm, I'm not the right person also for politics so perhaps someone else would be more qualified.
00:53:01.105 - 00:53:06.113, Speaker D: Right, right. It's not, it's not my, my primary strength for sure.
00:53:06.169 - 00:53:19.209, Speaker A: So yeah, I've tried actually. I've tried to do this. I've. I've pitched flashboards and I've talked to searchers and. But I am not good at this. All right.
00:53:19.257 - 00:53:21.765, Speaker D: But, but it, yeah, all right.
00:53:23.625 - 00:54:36.493, Speaker A: It's good if you have, if you talk to these people. If anyone in this call talks to the pre conference, it's good to have this, this in mind. Like how the things that would affect your PBS is how does the proposer get the list of transactions that need to be included in the block? Can, has this, does it have to be enforced at the proposal level or can it be enforced at the builder level? If it can be enforced only when the payload is revealed and the builder is the one that can be penalized instead of the proposer, then this is not only not incomparable with Epps, it's better for EPBs to be there for them. So if they insist in penalizing the proposer for something that is not the proposer's fault, like the builder not revealing the right. The right transaction set, then this is something that would be broken by EPBs. Because if you penalize the proposer and then suddenly the consensus block doesn't have the information that you needed to penalize it, then such a design would be broken if epbs ships and such a design would be against epps. So those are the questions that I would ask the pre conference.
00:54:36.493 - 00:54:43.385, Speaker A: So I think no design is incompatible with the pbs but all of the ones that I've seen would have to change with the pbs.
00:54:52.085 - 00:54:52.905, Speaker D: All right.
00:54:57.215 - 00:55:25.617, Speaker A: Also if you. If you do start implementing, I think the one that has been looking the most to fortress is Enrico. So it's a question for you. Keep in mind slot auctions and let's try to analyze the safety of it because it seems to me that it's easier and better. I think slot auctions are better than what this EPIP is and it's easier even so. So the question is a safety question. So if we can ship slot auctions just from the start, I think it would be.
00:55:25.617 - 00:55:49.339, Speaker A: Would get better adoption from builders. Oh wait, we are playing. What is it? Ah, speak up. I might. I can't even read this. There's someone that is saying something about. Oh, this is so spoke perhaps.
00:55:49.339 - 00:56:08.955, Speaker A: No. Who's pushing new inclusion is designed for L1 soon for what is. What who is this? I'm in the airport. So Canber. Yeah, so it is this thing of like we're planning to push a new IL design. Oh yeah. So.
00:56:08.955 - 00:56:30.973, Speaker A: Oh, this is the1. The 4 choice inclusion list. So it's just appeared in research. Yeah. Okay good. Yeah, that design is actually good and that one might actually. I haven't read it in detail, but that one might actually be compatible with EPBS without a problem because again, you can only you.
00:56:30.973 - 00:56:50.291, Speaker A: You're looking at. At testers and you can just. If I understood correctly, the testers are the one that enforced them and you can just. And force them in the next block. So that's that. I think it's in principle that thing is probably fine for ebbs. Yeah.
00:56:50.291 - 00:57:13.665, Speaker A: Yeah. You're not gonna get an enemy on. On me with that design, I think but I need to. I need to study it. I haven't. I haven't studied. All right.
00:57:13.665 - 00:57:30.505, Speaker A: We ended up taking the full hour anyways. All right guys, there are no more. No one has any comment. We can close this on the hour and I'll see you guys in two weeks. Hopefully the AP will be out or soon to be out.
00:57:32.395 - 00:57:33.375, Speaker B: Bye, guys.
00:57:33.675 - 00:57:34.011, Speaker A: Bye.
