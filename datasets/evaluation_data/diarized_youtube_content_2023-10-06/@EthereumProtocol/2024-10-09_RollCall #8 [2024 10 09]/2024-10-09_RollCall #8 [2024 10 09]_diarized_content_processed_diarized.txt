00:00:00.520 - 00:00:35.405, Speaker A: Hello and welcome everyone to roll call number eight. That's issue 1170 in the Ethereum PM's repo. I'll drop a link in the chat as usual. This will be recorded so for those who can't make it can check it out after the fact today. Let's get started with a presentation from. From Wilson. I'm sorry, I'm not going to attempt to butcher your your Last name on RIP 7755.
00:00:35.405 - 00:00:38.921, Speaker A: I'll hand it over to you.
00:00:38.953 - 00:00:43.485, Speaker B: Yeah, Wilson Cusack from the BASE team. Do you mind letting me share a screen?
00:00:44.825 - 00:00:45.925, Speaker A: Sure, one sec.
00:00:53.025 - 00:01:00.195, Speaker B: Might be Ethereum call faux pas to have your video on. But I like people to see me.
00:01:04.495 - 00:01:05.595, Speaker C: No, it's great.
00:01:05.975 - 00:01:16.599, Speaker B: Okay, cool. Here we go. So I'm going to share this screen. There we go. We got some other videos on. All right. So yeah, thanks for having me today, Carl.
00:01:16.599 - 00:02:05.425, Speaker B: Thanks for inviting me to speak on this. So RIP 7755, this is the title of the PR currently is contract standard for cross L2 calls and the sort of brief is contracts for facilitating the request fulfillment and fulfillment reward of cross L2 calls. The first thing I want to call out at the start is this is very much under construction. This is currently just a pull request on the RIP repo. This is not even in draft yet. For example, we could probably make some changes already contract standard for instead of calls maybe requests, the telec had a comment that calls is maybe overloaded and then it actually could just be generically cross chain as we'll get into. So we're going to take a few minutes just to kind of run through how this works.
00:02:05.425 - 00:02:47.265, Speaker B: Hopefully it won't take too much time. I'll have some topics for discussion and happy to answer any questions. The goals of this was a low level specification allowing arbitrary kinds of calls. We wanted something that was maximally on chain and so as much as possible sticking to Ethereum and the related chains and what is sort of intrinsically available on chain and then a sort of batteries included proof system with minimal trust assumptions. And so some of the context here is that I feel like a lot of people are working in this space and I kept on sort of hearing proof system agnostic, proof system agnostic. And then I didn't really. It was hard for me to understand what actually was the preferred proof system with minimal trust assumptions.
00:02:47.265 - 00:03:38.207, Speaker B: And then in talking with some people about this we realized that in the context of L2s or really any chain posting a state route to L1, we can actually deliver Something with pretty good trust assumptions as we'll see. So how it works, call requests and fulfillment. So the idea is you have some origin chain and a destination chain and you have a user who wants to make some call on the destination chain and to do so they call into this cross chain call originator contract. And in the PR you can see the specification for this. But basically this is the struct that specifies a cross chain call. So you have an array of calls that you want to make with two data value. You have an origination contract that you're calling into and that's on the origin chain, origin chain id, destination chain id a nonce just to distinguish this from any other call that otherwise has all the same parameters, a verifying contract.
00:03:38.207 - 00:04:14.783, Speaker B: So we'll talk about that in a minute. The contract that's going to be used on the destination chain as the source of truth that these calls were actually executed. L2 Oracle will also talk about this later. But this is where you expect to find state routes for this destination. L2 on L1 this is an address and in that, on that L2 Oracle the specific storage key at which you expect that route to be located. And then a reward asset, a reward amount. These are specifying whoever fills this request and can show that they fill that they're going to be paid this and then a finality delay seconds.
00:04:14.783 - 00:04:45.689, Speaker B: And this is a finality delay not on the fulfillment on destination chain but on a delay for the reward being paid out. And so this is in the case where you want to have some guards against the fact that some of these state routes might be pending. Realize there's a lot of context right up the gate. We'll get through this and hopefully it all makes sense. So you're doing this cross chain call originator and it's emitting some event. Somebody has this desire for this call to take place. And we can kind of draw a boundary of what's on chain and off chain here.
00:04:45.689 - 00:05:36.623, Speaker B: So off chain there is some filler that is indexing these events and decides that they want to fill this request and they call into this verifying contract on the destination chain. And the verifying contract does some basic checks to make sure that this is the right chain id, that this is the right verifying contract for this. And then basically it's just going to iterate through all the calls that were asked to be made. And if any of those calls revert, then this whole call is going to revert. But if all the calls succeed, then it's going to store this info and so it's going to say fill this for this call hash it was fulfilled at this timestamp and this was the fulfiller. And this is what we're going to prove state against later. So the general idea here is sort of we can get really nice trust assumptions using storage proofs.
00:05:36.623 - 00:06:20.565, Speaker B: In fact, as we'll go through the mechanics of you can prove state on other L2s using recursive proofs. The challenge is just we need a state on that destination chain that shows whether this call was made or not. This is our record that this call was made. And it has some analogies to the withdrawal flows for L2s, generally where you have some state record and then you're proving on L1 that this state record does exist on L2 showing that you made a withdrawal. So the filler, you know, calls here and then those calls are made out as I sort of described. Sorry, did the call just jumped? Am I, am I still on the call?
00:06:21.505 - 00:06:24.553, Speaker C: You still on the call, but screen sharing is off.
00:06:24.689 - 00:06:34.945, Speaker B: Okay, let me share again. Sorry, I think it just exited me and rejoined quickly. All right, can you share my screen again or you see my screen? Yes, this is okay. You could see it before, correct? I wasn't just talking.
00:06:35.065 - 00:06:36.449, Speaker C: Yes, no, we could see it.
00:06:36.617 - 00:06:59.961, Speaker B: Sorry. Okay, let's keep going. So then how reward payment works? So ideally, both of these destiny, this origin chain and this destination chain are right into some shared layer and we can call this Ethereum L1. And this is why I say it doesn't have to be L2s. Right. Technically this could work for any chain that is willing to post its state route to L1. So it could possibly work for all kinds of chains.
00:06:59.961 - 00:07:46.145, Speaker B: So if this destination chain is posting a State Route to L1 and the origin chain is posting a State Route to L1, ideally also there is some way to get the state route for this L1 on the L2. And so you have some block hash, Oracle or some trusted way of getting that L1 info. And with these ingredients you can construct a storage proof. And it's sort of going to be a nested storage proof. And so we first want to use the L1 state route to prove that there is some state route on this output. Oracle contract or state root Oracle contract on L1. So we want first a trusted state route for destination chain and we use our state route for L1 to get a trusted state route for destination chain.
00:07:46.145 - 00:08:31.151, Speaker B: And then once we have a trusted state roof for destination chain, we can go on to prove whatever State we want on the destination chain and in particular we want to prove something about that verifying contract. And so this is, you know these parameters that I described earlier. You are saying you know the L1 address of this L2 state root oracle and the storage key where you expect these to be. I'm just going to keep going and we can take all questions at the end. Sorry if anything's been confusing so far, I'm happy to hop back. But basically the filler is going to post this nested state proof into the cross chain call originator contract and they're going to be paid out that reward, assuming that state proof checks out. So some frequently asked questions.
00:08:31.151 - 00:09:11.756, Speaker B: How is this different from ERC7683? The ERC7683 is more about high level intents versus low level calls. We're trying to specify exactly the calls that we want to be made here rather than the outcomes we want. Also as written, ERC 7663 is currently focused on swaps. I know the team has some desire to try to change that. 7683 is proof system agnostic versus this is specified and importantly this system specifies sort of on chain origin contract specification. So you're assuming that users are making the request on chain that they want these calls to happen on destination chain. How is this different from op stack interop? And again, I'll just say I'm talking through these.
00:09:11.756 - 00:10:07.711, Speaker B: I don't consider myself an expert on any of these, so I'm happy to be correct. So interop allows faster settlement without compromising trust guarantees. So in the system I described you would have the filler sort of is like, you know, taking their own risk. If I see this request from origin chain and I immediately fill it on destination chain, I'm taking some risk that you know, origin chain is going to be reorged and that is that reward is never going to be paid out. The user can sort of specify their tolerance for risk on destination chain, you know, some fault proof or whatever there by calibrating that final finalization delay seconds. And so if they want to wait seven days they have a way to to express that. So interop allows you to sort of tightly couple chains such that if you know you can specify how far you want to trail behind head on a given chain and if that other chain reorgs, you are also going to reorg.
00:10:07.711 - 00:10:55.041, Speaker B: And so you could sort of have immediate fulfillment in both directions and trust that if one of them reorgs, it's going to reorg on both sides. One of the downsides of interop is it requires a dependency set and so each chain has to specify the chains in its dependency set. And all those chains sort of they're dependent on each other and that's a challenge. And I think that if we're headed into a world of thousands of L2s, is that really going to scale? So I think this is possibly a bit more scalable. There's a question of how do you solve race conditions where you possibly have many fillers that want to fill at the same time. One idea that we have is some sort of exclusivity period. And we can generalize for this by saying that on the destination chain before you fulfill the structure could also have some pre check address and a pre check call data to call.
00:10:55.041 - 00:11:50.007, Speaker B: And this would allow for arbitrary pre checks to be described. And one of those pre checks could be, you know, an hour or something where there's a specific filler that's allowed to fill this and then after that it would be open. Another idea is to try to leverage ERC 4337 because they have similar challenges that they're trying to make a global mempool and there's this eth send raw conditional RPC that's being used for a lot of the user op mempool. And possibly if you imagine that the fulfillment contract on destination chain is actually a Paymaster, then you could fit this into that system. Finally, what is the contract change proof system relationship? What's the many to many on each origin chain as it's currently described? On each origin chain you would need one contract per proof system. And so the proof system is described there. And so, you know, you could for all op stack contracts, they presumably would share the same proof system.
00:11:50.007 - 00:12:26.987, Speaker B: And you could, you know, describe those all together. You know, maybe arbitrary arbitrum could fit in there as well. If arbitrum needed a slightly different proof system, then you would need a different origin contract. But that brings up the question of, you know, should the proof system be abstracted? And I'll get to that in the discussion. So before discussion, how can you help Leave feedback on the PR? Check it out. Consider for L2 specifically consider how we can standardize the pieces needed for proofs. So for example, it would be great if we all had a unified way of exposing a trusted L1 block/H or a trusted L1 state route on L2.
00:12:26.987 - 00:13:19.049, Speaker B: This currently does not exist across all twos and is a challenge. We could consider standardizing where state routes live on L1. You know, describing like some reserve storage key that state routes are stored at or in particular a way of describing a consistent way of describing pending versus finalized state routes L1. So for discussion, you know, we've been discussing a lot of people, there's been some interest in this and some people are happy with it just as sort of a lower level way to specify the exact calls that you want to make and to specify desire to make calls on chain. And there's a, there's an ask of whether we should keep the storage proof system a bit separate and possibly not have it in this rip. There's discussion on ways to leverage ERC437 which I kind of alluded to. I don't want to take up too much time and then we can discuss any other questions you have.
00:13:19.049 - 00:13:40.255, Speaker B: I hope that made some sense. Yeah, go ahead Andres.
00:13:44.315 - 00:14:04.623, Speaker D: Several, several, several questions. But the immediate one is if your request just sits there and is never fulfilled or is not fulfilled for a long time, the state obviously changes. Right. On both the origin and the destination chain.
00:14:04.759 - 00:14:05.167, Speaker B: Yeah.
00:14:05.231 - 00:14:45.585, Speaker D: So at what point would, is there, is there a way you can fulfill a max duration for which this request is okay to be fulfilled? You know, especially if you're thinking about like your, your car, you know you want to do providing liquidity for certain, for certain transactions on the destination chain that's time sensitive and it doesn't go through then really doesn't make any sense to fulfill the call. So is there sort of like an expiration timer?
00:14:47.515 - 00:15:24.565, Speaker B: Yeah, it's a great call out. It's something that it's been called out on the, on the pr. It's a change that I haven't made, but I'm intending to make that. You can describe an expiration and something that is there currently, but I didn't go over is that you can also request a cancellation and so on the origin chain you can request to cancel and then there's sort of a waiting period, whatever your finalization delay was and then some guard additional waiting period for somebody to prove that they made the call. And if that period passes then you can sort of finish, finish your cancel request. But yeah, great, great question. Does that, does that answer it?
00:15:25.625 - 00:15:31.377, Speaker D: Yeah, yeah, absolutely. I let others go. Yeah, I don't want to argue.
00:15:31.441 - 00:15:35.245, Speaker B: Okay, let's see. I don't know if we have others, so you're welcome to ask more if you have them.
00:15:38.105 - 00:15:39.645, Speaker D: No, there's a question. And.
00:15:43.595 - 00:16:24.143, Speaker B: On state routes you're building the cross chain calls upon how do you make sure they're not perma stale. Because you're checking on L1, the state route of other L2s, but as soon as it's posted and L2 state route is almost already stale. So this, the storage proof is constructed against a specific state route. And so all you need is the specific state route that you were. That you used to construct your storage proof. The bigger risk is that there's some fault proof or something and that state route becomes invalid. And so that's sort of up to the user to decide their finalization delay that they want for that, if that makes sense.
00:16:24.143 - 00:17:01.685, Speaker B: Does that answer your question, Elias? Yeah. Eliza, I don't know if maybe you want to unmute and describe your question. You're checking on L1, you are proving, you're proving using the L1 state route that some other L2 state route exists on L1, and then you're proving using that other state route, something about that other chain. And this is all happening atomically in a single transaction.
00:17:13.345 - 00:17:13.681, Speaker C: Hey.
00:17:13.713 - 00:17:23.881, Speaker E: Sorry, I. I was getting to another room so that I could speak and then the. Everything broke. Sorry, my. No, I was. I was saying. So my understanding is you're.
00:17:23.881 - 00:17:28.401, Speaker E: You're checking another L2 state route on L1, right? You're constructing the storage proof.
00:17:28.433 - 00:17:29.005, Speaker B: But.
00:17:29.835 - 00:17:44.667, Speaker E: But that state route, as soon as it's posted on L1, my understanding is the L2 is going to construct new blocks on top of it as soon as it posts it on. So how do you make sure you're not perma behind on this state?
00:17:44.731 - 00:18:24.605, Speaker B: You don't care if you're behind, because all you care. In this case, we're trusting our verifying contract that that state exists. And the verifying contract is not going to allow that specific state to change at future blocks. So when you construct like an 1186 storage proof, you're specifying the specific block that you want that storage proof for. The specific state route that you want that storage proof for. So it would be a problem if like the call could happen and then somebody later could renege the call or something, but the call is sort of it happens and then it never happens again. You can't take back the fact that the call happened and so all the user call cares about is the fact that the call happened.
00:18:28.145 - 00:18:39.617, Speaker E: I still don't understand how like if maybe like at state route A, you have a balance on a roll up and then you want to do a cross chain call.
00:18:39.801 - 00:19:01.889, Speaker B: Yeah. So it would be a problem if we were proving specifically like prove that I have 20 die right. That could be easily manipulated. But we're not. We're proving a very specific thing on a contract. So you specify the verifying contract and let's go back to that code. This storage record, it's a very specific storage record that's being written.
00:19:01.889 - 00:19:24.285, Speaker B: It's a storage record that these calls that you wanted to happen happened. You can't take back the fact that the calls happened. If the user can be griefed here, it's their own fault. They specified I want some call to happen, the call happened, now they need to pay the reward. But it's not like prove that I have 20 die, it's prove that you made this call that I wanted to be made.
00:19:24.665 - 00:19:26.565, Speaker E: Okay, so you commit to an intent.
00:19:27.345 - 00:19:38.245, Speaker B: And this commitment is inside loaded words. I'm not sure I want to use that one. It's a very low level intent. If it's an intent, you're specifying to the value of the data that you want to be called.
00:19:38.865 - 00:19:44.725, Speaker E: And you put this into the state such that you can construct a state route of this. Sorry, state search proof.
00:19:45.045 - 00:20:11.065, Speaker B: Yeah, you specifically, you use a verifying contract as sort of this pass through contract to write a record that this, these calls were made and at what time they were made and who made those calls. This also allows for, you know, you can't doubly fulfill a call if it was just 20 die. Two people could prove that I have 20 die. But here, only one person can ever fulfill this request.
00:20:13.395 - 00:20:14.135, Speaker E: Why?
00:20:15.115 - 00:20:23.155, Speaker B: Because the verifying contract is specified in the request and the verifying contract enforces that the call can't be filled again. The call is already fulfilled here.
00:20:23.195 - 00:20:36.075, Speaker E: Okay. And so there's no expiration because you say that you're building this on top of the latest L2 state route.
00:20:36.235 - 00:20:50.815, Speaker B: And now expiration would be a good thing to add as we just discussed. So I think having an expiration on the struct, you could also check and fulfill whether this was expired. The user doesn't want this to happen anymore.
00:20:51.515 - 00:20:53.015, Speaker E: But you're saying it's not a problem.
00:20:53.755 - 00:21:13.125, Speaker B: Sorry, sorry. State route expiration. Yeah, state route expiration is not a problem because all I care is I trust this contract. If this contract says at any block height this call happened, I know, because I know this contract that it's never going to unhappen. You can't change the fact that these false happened.
00:21:17.585 - 00:21:30.725, Speaker E: In the case of a ZK rollup, you're saying as soon as you settle a state route, you can never go back on it. Okay. And you're also counting that L1 does not reorg.
00:21:31.305 - 00:21:42.465, Speaker B: Yeah. So again there's this verification seconds that can be the finality delay seconds where somebody can specify the, that they want to have passed and they can dial that that parameter for themselves.
00:21:49.205 - 00:21:55.185, Speaker D: Is that, is that in seconds or should that be in locks on the O1?
00:21:57.925 - 00:22:01.305, Speaker B: I think I prefer seconds. But open. Open to debate it.
00:22:01.845 - 00:22:46.760, Speaker D: No, I was, I was just thinking because you wanted to, you know, if you're, if you're, if you're specifying like, like an epoch. I mean let's, let's just stick for Ethereum, right? If you're, if you're, if you're specifying that, you know, because once, once, once the transaction, once the root is, is in a finalized epoch, it's done. Right. I mean you can't, that can never, that can never. That can never reorg. Right. So it's like you have a maximal delay for which you can have an L1 reorg.
00:22:46.760 - 00:22:52.973, Speaker D: You can have an L2 reorg in principle. But that's. Yeah. The L1 block.
00:22:53.062 - 00:23:06.945, Speaker B: This is really about the other L2. I'm trying to guard against the fact that the other L2 might have a reorg or fault proof. And so I'm using the L1 block as a proxy for how old that state route is for that other L2.
00:23:07.525 - 00:23:26.915, Speaker D: Oh, okay. Okay. So yeah okay. If you have, if you don't have, if you don't have, if you have, if you have fraud proofs. Yes. But then you need to like have like very long periods because, because your, your fraud proof periods are so long.
00:23:27.295 - 00:23:41.155, Speaker B: Possibly it's sort of a risk tolerance thing. I think it'll be priced accordingly. You know, we, I think this will probably be mostly handled by wallets and stuff. They'll abstract this for their users and pick a risk tolerance if that makes sense.
00:23:41.815 - 00:23:42.335, Speaker E: Yeah, yeah.
00:23:42.375 - 00:24:19.699, Speaker D: No it's like, it's like. Yeah. I'm just thinking this is really just a, just a, just a standard for, for basically the overall execution pattern. Not really for the under calls are actually that they're sensible. There needs to be another network that were the low level calls that are actually being made are verified. So it has to be in the calls that has to be approved that for example you have 20 die locked up on the, on the, on the origin chain that you want to move forward to the destination chain.
00:24:19.747 - 00:24:51.155, Speaker B: Yeah yeah. For example I can. There's somebody recently did an example where the case where they want to send some dai and in that case the call you're Describing that you want to be made is actually a call from the verifying contract to wherever you want the DAI to be sent to. And so the filler in that case has to pre transfer some DAI to the verifying contract and then transfer it on. That's one way to do it. If you look at the pr, there's some discussion on different ways of like where could assets be held?
00:24:52.775 - 00:25:06.135, Speaker D: Well, you need to. You need to lock them on the. On the. You need to lock it on the. On the. You need to lock it on the origin chain. And then once it's fulfilled on the destination chain.
00:25:06.135 - 00:25:13.685, Speaker D: Right. You need to burn it on the. On the origin chain. Right There.
00:25:13.725 - 00:25:21.261, Speaker B: There's a reward. Yeah, but they're. They're not necessarily tightly coupled. Like I. The reward. I could. I could pay my reward in any asset I.
00:25:21.261 - 00:25:22.773, Speaker B: I might be trying to make.
00:25:22.829 - 00:25:29.445, Speaker D: Oh yeah, yeah. The reward you can pay in. In. In any asset. Yeah, of course. But it's like. It's like that's, that's.
00:25:29.445 - 00:25:46.133, Speaker D: And it could be paid on any chain in principle, right? I mean, you could say I've. I'll pay the. I'll pay the reward in Seoul even if you wanted to, right? Yeah, I don't think so.
00:25:46.189 - 00:25:46.785, Speaker E: Because.
00:25:47.085 - 00:26:01.605, Speaker B: Yeah, the reward needs to be paid by this specific contract where the request was made. I do. I apologize. I only have a few minutes left. Another meeting I have to hop to. Thanks again for taking the time.
00:26:01.685 - 00:26:02.021, Speaker D: Sure.
00:26:02.093 - 00:26:06.385, Speaker B: If anybody has any. Any final question, I'm happy to answer it.
00:26:07.125 - 00:26:31.945, Speaker F: Yep. One quick question. Not a question actually, but more like a suggestion on the delay would be nice if you could specify some values. Like wallets have been historically not super good to make like opinionated choices in this situations. So like just some boundaries of like what you consider fast and slow would be nice just to give an indication to the wallets.
00:26:32.475 - 00:26:48.571, Speaker B: Yeah. And again, it would be cool if L2 is aligned on some of these like canonical ways of describing pending versus finalized state. Because then people could just specify a binary of like pending or finalized. But yeah, that's a good suggestion and.
00:26:48.603 - 00:26:49.895, Speaker F: Thanks for your presentation.
00:26:50.275 - 00:27:10.785, Speaker B: Yeah, thanks everybody. Really appreciate your time. Please check out the PR and comment. And please, if you have thoughts on some of these discussions, feel free to reach out to me. I'm just Pat Wilson Cusack on Telegram and on Twitter and so happy to chat and thanks Carl for inviting me and yeah, appreciate it.
00:27:11.605 - 00:27:12.205, Speaker C: Great.
00:27:12.325 - 00:27:14.865, Speaker A: Thanks for running us through your RFP.
00:27:18.645 - 00:27:19.385, Speaker B: Great.
00:27:20.805 - 00:27:28.885, Speaker A: Okay, next topic for discussion. Some 01 hectare updates. I'm going to hand up to an scar for those.
00:27:32.265 - 00:27:50.565, Speaker C: Good. Yeah. Hey everyone. Like last call, I created the presentation, although it's even shorter. It's just one slide but I always like having a visual reference. So let me just briefly air my screen. Can you see my screen?
00:27:53.395 - 00:27:54.259, Speaker A: Yeah. Looks good.
00:27:54.307 - 00:27:54.555, Speaker E: Yeah.
00:27:54.595 - 00:28:38.903, Speaker C: Awesome. Yeah. So basically the main update that I wanted to give is just specifically on the last roll call I mentioned that there was under consideration potentially splitting the upcoming pectoral hard fork on a one into two parts. And that has indeed now been decided. So basically there will be two, basically two parts of the pectoral, but because of naming consistency, the first one will be called Pector. The second one will actually basically get the next name in line which is called Fusak. And specifically basically in terms of like how the split falls out, you can, you can refer to the Meta EIP7600 if you want to see the full list of features for the for the pector fork.
00:28:38.903 - 00:29:52.665, Speaker C: But in particular the relevant for L2s as well of course are mostly the EVM changes that then you have to make a decision on whether to also bring those to your L2s. There are several also like for example BLS which is not mentioned here, but the Main 1 is ERP7702. So the set UA account code 1 that one will be part of the first basically of the pectoral side of the first fork. And there I just wanted to copy again the recommendations from last time because of course that now is locked in to happen relatively soon. So you should really basically have a strategy around this. Is this something you want to support at the time it launch? You're not going to support that for now and that depends a little bit of course also on the wallet situation and maybe reach out to some wallets, make sure you have a strategy. And in particular also given that the recommendation for 7702 is that wallets basically use it to have a 437 compatible smart account delegated to from an UA.
00:29:52.665 - 00:30:47.099, Speaker C: It would be important that your chain works well for 3.7. And then one more point on 7702 is just if you are say curious but want to play around with it a bit or something to basically just get a better feeling. One challenge point for that could be that there is planning to have a short lived 7702 specific testnet around Devcon also for hackers at Hackathon and everything to basically play around with. So that could be relevant for you. And then the other big topic on basically the first Half side. And that is related to the fact that as you can see further down, Peer DAS actually was decided to be pushed into the second half, into the Fusaka side of things. So there will be no kind of big blob throughput increase coming by peerdas yet in the first half.
00:30:47.099 - 00:31:34.625, Speaker C: But there is now the question of whether we might have some room just using the existing architecture, the existing before architecture, to basically give a little bit of extra blob throughput. And so in particular, basically right now we are like an average of 3 blocks per block and the question is to maybe push this to four or five or possibly six. So basically that would be still a good kind of increase. That is not certain though. Right now we are kind of on the L1 in the data collection and metrics collection side to basically get a better picture for how much kind of headroom we have for such an increase. And here again basically the call to action. We actually had Francis from the base team come on on an orchard, I think that might have been two weeks ago, if I'm not mistaken, 2ish, more or less two weeks ago.
00:31:34.625 - 00:32:38.761, Speaker C: Basically give some data from the base side that was very helpful I think for kind of informing the decision. And so if any other L2 also basically has some strong kind of opinions on this, I think public communication is always appreciated. Especially also if you have some kind of ideas of how your demand for blobs might change over the next, say six or 12 months, that will always be helpful to inform the decision. And of course again, if the presentation by Francis was very well kind of worked out, so if you basically are willing to put in that level of effort, then you're also always very welcome to join the ACD process directly. So yeah, those are the two main points on the PETRA side. And then just basically for your planning push to Fusaka, as I said already is Peerdes, but also the UF Ethereum object format changes and of course on Fusaka there's a bit more wiggle room yet. So none of those are completely confirmed and there might be additional features and everything, but basically UF will not be part of the first half.
00:32:38.761 - 00:33:13.395, Speaker C: So if you have plans to basically have support for that on your chain as well, just know that on a slightly less aggressive timeline now than say 7702. So that's kind of all really. The last few weeks of OS were very focused on kind of this two part split and then the kind of the progress towards Pectra. So there wasn't much else. Yeah, and I Hope that was helpful. Was happy. I don't know if there happens to be a question on this specifically any of this specifically I'd be happy to take to answer that.
00:33:13.395 - 00:33:48.835, Speaker C: So I see there is a question around timeline. Oh yeah, but that's Carl already answered. Exactly. So of course the exact timeline for Pector is still unsure. I think basically the idea is always we try to have a go live as soon as possible. Something like January is definitely conceivable. I would imagine that like if it's say early next year, I don't think it's, it's probably unrealistic to, to, to have the hard fork on L1 go live by the end of this year.
00:33:48.835 - 00:34:16.305, Speaker C: So if it's early next year I would assume it's probably not going to be January or February because we have these, the test nets that, that we usually fork before could of course also be a bit later. Like there's always some room for delay if testing doesn't go super smoothly or something. So I wouldn't necessarily count on say February yet. That's more like say I don't know my kind of optimistic, realistic kind of estimate but sometime first half of next year in some form.
00:34:37.535 - 00:34:49.315, Speaker A: Okay, thanks Anskar. And then I guess back to you again about the local breakout that we scheduled for two weeks time.
00:34:49.935 - 00:35:38.785, Speaker C: Yeah, sounds good. Yeah. So basically we decided to give a presentation to basically kind of update people in general on like our thinking around Brokho and also the broader kind of IP process and the future of the EVM, especially for EVM equivalent L2S. And so basically that's been kind of long time coming. Carl Jorf and I, we've been kind of collaborating on this topic for a long time. And so basically in two weeks at the same kind of roll call slot, it's going to be like a one hour breakout. We want to basically give a bit of an overview of our thinking.
00:35:38.785 - 00:36:31.451, Speaker C: And so basically first of course just describe kind of like how do we see the concentration. We have a lot of EVM equivalent L2s, they're all right now kind of equivalent to each other, but also equivalent to L1 of course with individual extensions on top. Then talk a little bit about the challenges. And in particular of course there's just some things that L1 does not need that would be helpful in the L2 context. So that is the L2 specific L2 native pricing, gas pricing things, more advanced features like transaction parallelization, more cryptographic primitives, native account abstraction and some solutions for state growth, especially for L2s that have ambitions to basically have higher throughput numbers and for that reason, higher state growth in general. All of these, of course, challenges that in principle can be tackled by L2s individually. Right.
00:36:31.451 - 00:37:26.877, Speaker C: So we can basically just have the common base of the L1 equivalent EVM and then just have L2s individually solve this. Our kind of question that we've been thinking about for like the last year has been like, is there something that we can do in a more collaborative way, basically using the fact that all these different L2s use the same kind of shared base. And so we want to basically just present what we think might be directions that could be helpful here. And we have some concrete steps towards that we want to talk about there. But of course, just to be clear, right, this is always kind of like fully opt in. We're basically just giving our take and at the end of the day, all L2s will always choose their own paths. But we are pretty excited actually that we have ideas here where we can basically have more EVM side innovations, again, especially in the L2 context.
00:37:26.877 - 00:37:38.015, Speaker C: So, yeah, I'm personally very excited about that two weeks from now. I think that's going to be a good breakout and I'd be very happy to see as many of you all as possible there.
00:37:39.915 - 00:37:53.695, Speaker D: Quick question. We had said that we would do the breakout for the L2 transaction fee API spec in two weeks, if you look in the chat.
00:37:56.685 - 00:38:01.805, Speaker C: Okay, I see. Yeah. Then we can, I mean, I can.
00:38:01.845 - 00:38:20.945, Speaker D: I should move it a week if you guys, if you guys want. But it's like. It would also be helpful if the breakout sessions were like advertised because the last one that we had on the, on the ultra transaction status, because it wasn't advertised except in the, in the telegram was. Was poorly attended. That was the problem.
00:38:23.165 - 00:38:50.875, Speaker C: Yeah, I mean, first of all, of course, yeah, of my apologies that, that's. That scheduling conflict is on me. Yeah. It would actually, it would be appreciated if we can find a way to maybe reschedule your breakout call there by a week in either directions one week earlier or later. Because I think for Carl and me, unfortunately, that week really works the best. Okay.
00:38:50.955 - 00:38:54.715, Speaker D: No, I can. I'm perfectly fine with that. That's not a problem.
00:38:54.875 - 00:39:00.815, Speaker C: Okay, that's much appreciated. Would we want to pick a time now then, just so people on the call are aware?
00:39:01.675 - 00:39:07.507, Speaker D: Yeah, why don't we do it? Do it. Do it exactly one week later.
00:39:07.691 - 00:39:11.135, Speaker C: One week later. That works well. Okay, so then we basically.
00:39:13.315 - 00:39:14.735, Speaker D: October 30th.
00:39:15.725 - 00:39:29.645, Speaker C: Sounds good. Yeah. And my apologies about like the. Your kind of earlier breakout kind of over this last cycle. Yeah, as we're saying, I kind of. I was. I was basically relatively offline for the month.
00:39:29.645 - 00:39:40.625, Speaker C: So that's why I mentioned before that we might not be able to spot it as like a official kind of roll call breakout. But yeah, we can reschedule that one too.
00:39:41.615 - 00:39:42.519, Speaker D: Right, right.
00:39:42.607 - 00:39:55.887, Speaker C: And let's try for the other one, let's try to basically make sure that people are aware and can you remind people as well like the upcoming one, the one in three weeks then which of the two would that be? Like what will be the topic that.
00:39:55.911 - 00:39:59.435, Speaker D: Will be the L2 transaction fee API spec.
00:40:01.855 - 00:40:08.075, Speaker C: Sounds good. And maybe just give like a two sentence kind of summary again of who that would be most relevant for.
00:40:09.485 - 00:41:20.699, Speaker D: That's going to be most relevant for the clients that have the status, the transaction status and their transaction receipt. So it's just basically aligning on the different statuses and the meaning and the numbering system such that wallets end users have a consistent experience as to. As to the at least the most common transaction status goal posts so to speak that all L2s will have in common. The PR the spec allows for additional statuses but the these suggested statuses are in the transaction spec. In the transaction status spec are for. Are for given or the most common set of transaction statuses. And sorry that was.
00:41:20.699 - 00:42:09.545, Speaker D: And for the API spec it's just a get imposed requests. So for the, for the supposed. What's the what's the expected transaction fee for transactions on estimation and then the other one is a get which is once the transaction has been submitted. What is the, what's the what are the different transaction fees are going to be? So it just breaks out the overall transaction fee into its standardized components which is priority fee, data fee and also execution fee.
00:42:09.925 - 00:42:46.955, Speaker C: Okay, sounds good. So that will be then three weeks from now. So let's make sure that everyone who basically that's relevant for which of course is all the L2s but there might be individual people in the L2s that work more on that side that they're aware. Yeah and then thank you for basically moving that. So then we can have the kind of the L2 EVM breakout as just announced in two weeks and yeah, I'm very much looking forward to that one as well.
00:42:47.925 - 00:42:48.665, Speaker B: Cool.
00:42:54.885 - 00:43:33.551, Speaker A: Great, thanks. Yeah, I think that brings us to open discussion. Any other topics people would like to chat about? Going once, going twice. Okay, that's it then. Thanks everyone for attending and yeah, I will see all of you at the breakout in two weeks. Thanks all.
00:43:33.743 - 00:43:34.635, Speaker D: Thank you.
00:43:35.695 - 00:43:36.287, Speaker C: Bye.
00:43:36.391 - 00:43:36.759, Speaker A: Cheers.
00:43:36.807 - 00:43:37.751, Speaker B: Bye. Thank you.
00:43:37.783 - 00:43:38.395, Speaker C: Bye.
00:43:38.735 - 00:43:39.143, Speaker B: Thanks.
00:43:39.199 - 00:43:39.335, Speaker C: Bye.
