00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:03.650 - 00:00:18.320, Speaker B: Hey, good morning everybody. Welcome to the EOF implementers, call number 18. Let's just go ahead and get started and hear what client teams have been up to the last few weeks. Does anybody want to start us off?
00:00:30.650 - 00:00:43.470, Speaker C: I'll go for base. Mostly we've been focusing on for the EVM stuff on the Cancun release, which involves some drill down on some of the specifics of self destruct and making sure that it tests consistently across platforms.
00:00:49.680 - 00:00:53.580, Speaker B: Great. Ivan.
00:00:56.100 - 00:01:02.608, Speaker D: From Nethermind side, we were just minor bug fixes because we were focused on.
00:01:02.774 - 00:01:07.830, Speaker A: Cancun eips like pre compilent like 4788 and other stuff.
00:01:12.110 - 00:01:20.650, Speaker B: Makes sense. Hear that there's an import in fork. Yeah. Anyone want to give an update for Epson?
00:01:28.230 - 00:01:56.940, Speaker E: In the vm one, we've implemented non returning functions that required a lot of changes in the unit tests because of data section kind change from three to four. So basically all the tests had to change. And besides this work, Pygval implemented t load to store codes and I think that's all we have.
00:01:58.510 - 00:01:59.260, Speaker B: Nice.
00:02:00.450 - 00:02:17.570, Speaker A: It's good to hear any other client team semistiler updates.
00:02:23.190 - 00:02:29.400, Speaker F: I don't have compiler updates, but maybe some stuff. I want to talk about the spec again this time.
00:02:30.250 - 00:02:42.486, Speaker B: Yeah, okay. I assume probably if not updates from you, then no compiler updates. So let's just jump into spec discussion. What's on your mind, Charles?
00:02:42.678 - 00:04:02.558, Speaker F: Yeah, so last time we touched on a few topics and I followed up in the discord. So I think for create three. So we were talking about x data copyright. And one use case is like factory contracts that are using init code stored in another contract to perform a create operation. And a couple of things I noticed were, one is that the init code is validated at init time, sorry, at create time, which I think first of all the process can be simplified and the cost can be brought down if the init code is validated. Instead, when the container is deployed, I think you can remove the especially if you have a new section kind which is init code instead of as arbitrary data. And then the other thing is, I think that there are different strategies for storing the knit code on chain, and I think it'll be more general purpose if create three has an address argument.
00:04:02.558 - 00:04:26.010, Speaker F: So you can take the knit code from the executing contract or from an arbitrary contract. Or if that's not feasible, then I would want to propose create five ha, which does have an address argument and allows you to deploy code from init code stored in another contract.
00:04:29.550 - 00:04:54.900, Speaker C: So my concern with validating init code at container creation is then we have to validate the subcontainers. And those subcontainers might have subcontainers and there's no limit unless we put one in and say you can only have like five layers of subcontainers, which seems somewhat arbitrary because you could have, I think potentially like 1000 subcontainers that you then have to validate, which would basically be possibly an attack vector if validation is slow enough.
00:04:56.470 - 00:04:59.620, Speaker F: But isn't it an attack vector at deploy time too?
00:05:01.450 - 00:05:23.310, Speaker C: You only validate one layer of container. So if they do that thousand container deep, they would have to do 1000 calls which would consume 1000 gas. So unless we also charge per subcontainer validation and increase the gas and limit it there, we would need to do something beyond simply allowing subcontainer validations. We'd have to charge more for each subcontainer and sub subcontainer.
00:05:24.530 - 00:05:30.590, Speaker F: I think that's kind of similar to the call limit, right, the call recursion limit.
00:05:33.010 - 00:05:48.470, Speaker C: So that was put in when the cost of call was not aligned with the efficiency of the evms. And also you could go, there was talk of removing it, but you could still with 15 million gas go absurdly deep.
00:05:52.740 - 00:06:00.640, Speaker B: I think there's like a fixed bound now with the 63 64th rule, I think it's like around 550 calls.
00:06:01.960 - 00:07:23.532, Speaker A: Pavel, I forgot to check the mic, can you hear me? Well, yeah, we hear you. Okay, so I think in one of the previous version we had this validation mean mostly we were validating the subcontainements when the master container was deployed. Whatever, it actually looks very beautiful. So when you later execute create extractions, you already know that the init code container is valid, so you don't have to revive that. And in terms of the US vectors, I mean all of that is bound by the outer container code size limit anyway, and validation is linear to the code size. So on the paper it doesn't really make so much difference. But yeah, that was something we concerned a bit, but I think it looks okay the first, yeah that's mostly that and I will let you down to respond to that.
00:07:23.532 - 00:08:27.920, Speaker A: But why this has been changed is that we realized we also want to manipulate the data section and the create time, right? So when you have a create instruction it takes like fixed init code. Well it takes the init code container, but the init code container contains to be deployed container and it also has ability to modify the data section. And if I understand correctly, currently we allow to append some data to it. And this data append means that we also need to update the header of that and specifically this container to be deployed. It's not valid when it's stored in its code container. So there's two levels of these containers. One of them is not valid when it's there.
00:08:27.920 - 00:09:17.008, Speaker A: It will be valid when it's kind of modified or something like that. If I understand correctly, it's like we will kind of modify it anyway and the validation happens before in practice for the current spec, it's not so big deal. If we kind of trust this update function, which is also under the consensus regime, will do the proper job. Right. But for the future proofing, kind of. It's a bit weird that you validate something and then later you modify and you kind of expect the modifying function to be produce something that is also valid. I think that was the main reason we kind of dropped that.
00:09:17.008 - 00:09:56.940, Speaker A: And also maybe to anticipating further questions, it's not possible to distinct between init containers and to be deployed containers. So you can use the same container in both contexts in some cases, if I remember correctly. So that was the main reason we dropped that. Maybe there was some additional information, but yeah, we considered maybe this way to make it work. That's mostly the background for the current decision.
00:09:58.320 - 00:10:04.480, Speaker F: Yeah. What do you mean you can't tell the difference between init containers and to be deployed containers?
00:10:10.500 - 00:10:44.510, Speaker A: I have to remember what the example was. But you can kind of use the same container. I mean when you validate to start with, what was the reason for that in it code context? When you execute init code, you can think about it. It's kind of two levels. Like the first one is like runtime, the next one will be the init code and the init code will contain runtime. Right. And this is the way to figure it out.
00:10:44.510 - 00:11:51.890, Speaker A: But init code container, you can have additional init code container because init code can also execute create instruction with subcontainer as a unit code. So in this level of when you go deeper in this different call instructions, you can have two levels of init code usage. This way. I'm not sure I can explain it really well, but when you validate mostly you can't tell if there's init codes. When you validate and you see a subcontainer, the validator cannot say if this container will be used as an init code or as a run type code because it can be both depending which instruction will use that. Because in the same code you can have additional create instructions and also return container instructions, right. So you can point the same one, you can even use this.
00:11:52.420 - 00:12:28.410, Speaker F: Yeah. What if you don't recursively validate the init code? What if you only validate that it's a top level init code and then leave a validation of any child containers for when that thing gets create called on it? Because I think that seems to solve first of all the recursion problem and then also this issue of needing to validate subcontainers all at once.
00:12:30.940 - 00:12:36.460, Speaker A: You mean when you, I'm not sure I fully get it because I'm really slow.
00:12:36.800 - 00:12:37.790, Speaker F: Oh no.
00:12:39.360 - 00:12:49.390, Speaker A: For example, when you validate the instruction and you spot create instruction, you can go to this container it points to and then validate it as well. This way.
00:12:50.080 - 00:12:50.396, Speaker C: Right.
00:12:50.418 - 00:13:14.410, Speaker F: So when create three is called, let's see from the spec it says the deck gas read in it container index, pop some stuff in the stack, blah blah, validate in it code EOF container and then execute the reference container in init code mode. Right. So what I'm saying is we can run that validate in it code EOF container one time when the parent contract is deployed and then not have to validate it in the future.
00:13:20.210 - 00:13:23.710, Speaker E: But what about nested containers?
00:13:24.850 - 00:13:25.600, Speaker F: Well.
00:13:29.510 - 00:14:16.360, Speaker E: We deployed a container, it has a container in it and that one has a container in it as well. So yeah, anyway, yeah. For me also this nested validation doesn't seem to be big problem. And the main reason we gave up this idea was this data appending to the data section and in case code contains data load and instruction which can access the appended data, it will be invalid if you validate it earlier than create two instruction.
00:14:20.700 - 00:14:30.940, Speaker F: Maybe I'm not following fast enough because there's two validations in create three, right? You validate the init code and then you validate the deployed code, right?
00:14:31.090 - 00:14:31.452, Speaker A: Right.
00:14:31.506 - 00:14:32.110, Speaker E: Yeah.
00:14:32.560 - 00:14:48.950, Speaker F: So I understand you still need to validate the deployed code which has maybe the data section or whatever, but can you move the init code validation to a single time, a one time step?
00:14:52.120 - 00:14:52.484, Speaker A: Yeah.
00:14:52.522 - 00:14:59.670, Speaker E: Then I guess what Pavel said, we can't really tell which one is in it code and which one is deployed code. Maybe that is the reason.
00:15:14.580 - 00:15:21.270, Speaker F: How, how could the init code in the container be deployed code?
00:15:24.300 - 00:15:52.050, Speaker E: So deployed code is referenced by return contract instruction, but the same code that has return contract can have earlier create three instruction which references also some subcontainer. So one container can have for example two subcontainers, one referenced to by return contract, another one referenced to by grade three, and then one of them is in it code, another one of them is deployed code.
00:15:56.510 - 00:15:59.180, Speaker F: Maybe I need to understand return contract better.
00:16:01.730 - 00:16:28.980, Speaker A: I think what Charles means that when you are about to deploy a container and you do a validation, then it's kind of implied that every sample container in this container will be in it, called containers in the end, because there's no other use for it. And then you can validate these. That's what I mean, more or less.
00:16:56.830 - 00:17:19.920, Speaker F: I'm pretty confused by the difference between a deployed code container and init code container. Maybe I can talk about that with you offline then.
00:17:22.850 - 00:17:51.334, Speaker A: Yeah, I think so. In the UF there's no distinction between these two. So they are not marked anyway. They role comes from which instruction reference them. Right. And there are kind of two instructions. One create instruction, one return container instruction.
00:17:51.334 - 00:18:28.680, Speaker A: And that's the main thing. And what else? And there are some cases like a bit more convoluted basic examples that the same container can be referenced by both instructions. And they more or less should be valid as well. Yeah, and up to until we. And. Yeah, and this return container instruction, it also modifies the container. And that's why it's really difficult.
00:18:28.680 - 00:19:16.980, Speaker A: The validation before this instruction doesn't really work because something that is invalid before modification can become valid after as more or less the case this way, rather the other way. But anyway, it doesn't make sense to validate before it's modified, because it will be different container on keeping the high level overview. And that's why we dropped the pre validation of all subcontainers that we had before. Maybe there are some cases when this can be work, but it will be kind of the specific case and we can figure out offline what are the cases for that.
00:19:18.090 - 00:19:19.640, Speaker F: Yeah. All right, thanks.
00:19:25.130 - 00:19:28.390, Speaker B: Did we want to go on to your second question, Charles?
00:19:28.730 - 00:19:33.130, Speaker F: Yeah. Which was about invoking a knit code in an external contract.
00:19:38.910 - 00:20:55.074, Speaker A: Well, I can say only this, that we also had considered that this kind of different addressing mode or like reference mode, that the reference to the container is like a pair of address and maybe some index of whatever the address has and so on. I think that was even the first draft of this pack, because I think that was influenced by some sketch or proposal by Vitalik with this different creation mode. And the creation mostly means you copy existing code and do some specific modification to it, which is restricted and so on. So it was doing kind of referencing some other code that is already deployed mostly. That was it. I think originally the idea was just copy whatever is deployed and then run a constructor on top of that to allow modify like storage and stuff. Yeah.
00:20:55.074 - 00:21:27.878, Speaker A: So there was number of iterations and I don't know, I think we pick something that is simpler above, more generic case. I think that's the main reason. Yeah, I think it can be revisited. I don't know. Don't have much more to say about this right now.
00:21:28.044 - 00:21:54.160, Speaker F: Yeah, I mean, the other option is that you could just call this external contract and hope that it calls create for you correctly u, which isn't necessarily the end of the world. But there's some like the salt is different and stuff like that.
00:21:55.570 - 00:22:14.680, Speaker A: Yeah, I mean, I agree with this. You can have the same systems work in both cases. It's probably like different way of thinking about the deployment and all of that. So. Yeah, I kind of agree.
00:22:19.330 - 00:23:07.480, Speaker F: Yeah. I mean it's the same as having a template contract which just loads the init code index from call data and then runs create on that or create three. Sorry, but that has like call overhead and. Yeah, we don't like transferring execution context. Maybe I'll think about that some more.
00:23:13.770 - 00:24:22.400, Speaker A: I mean, I think we are a bit more at a bit better position to discuss that. I think some months ago there were so many options to choose from. We just pick, if there's alternative designs, we just pick probably the simplest one by our assessment. Right. And I think it's worth it that there are some comments coming now about the design, because this means people are getting familiar what the current spec says. It should be easier to discuss the details right now than drop the draft with multiple alternatives. We can collect comments about it, but I don't have good understanding how contract developers might use that.
00:24:22.930 - 00:24:57.620, Speaker F: Yeah, I mean, there's different strategies for having these factory contracts. Right. And I think Viper pretty much exclusively has factory contracts call other use init code that's stored in other contracts on chain, whereas sility, I think, stores the init codes all in one contract. Right.
00:25:06.530 - 00:25:09.120, Speaker A: So yeah. Any other comments about it?
00:25:12.550 - 00:25:25.362, Speaker F: I think that it would be useful, but I think we all agree that you can also get the same result with a little bit of more work.
00:25:25.416 - 00:25:26.020, Speaker A: Right.
00:25:28.230 - 00:26:02.500, Speaker F: I do have another question which is about this EIP 20 315, and I'm wondering if there are some very good arguments for having code sections instead of one global code section, because subroutines, code section allows for some other optimizations to be done.
00:26:02.870 - 00:26:32.234, Speaker C: So subroutines is the biggest argument for code sections. They have a built in return stack. You can treat them without having to do stacking conventions. And if you don't want to use code sections, you want to use one giant code section, feel free to use it if your conventions work. But the biggest advantage I see of code sections is a NVM subroutine facility, which is something almost every other VM system out there has.
00:26:32.432 - 00:26:42.030, Speaker F: I think EIP 20 315 has a way to have subroutines, but without different code sections, explicit code sections.
00:26:43.330 - 00:26:46.340, Speaker C: Was that the one that was in Berlin and was backed out?
00:26:47.190 - 00:26:49.620, Speaker F: I'm not sure what its history was.
00:26:50.870 - 00:27:20.410, Speaker B: Yeah, it was originally scheduled for Berlin and kind of in the last month before it started going to test nuts, it was removed. And I think the original reason was the solidity team had run some analysis on it and it didn't show a lot of improvement for their test bank. So I don't know what the status of that is at this point. I don't know if anyone else knows.
00:27:22.930 - 00:28:22.080, Speaker A: Well, I think my understanding is on the functional level, the main difference, what Charles is pointing to is that in this subroutine EIP from some years ago, you specified kind of where the subroutine starts, but that wasn't restricting static jumps to cross these boundaries. Anyway, that's the functional difference in this. Although there were subroutines, you could jump between from the middle of one subroutine to the middle of some other subroutine or something like that. And that's explicitly restricted in EOS. Right. And I guess that's the main point here.
00:28:22.690 - 00:28:33.330, Speaker F: Yeah, exactly. And that's the functional difference. And then there's also slightly less overhead because you don't need code section headers for every subroutine.
00:28:38.660 - 00:29:53.400, Speaker A: Yeah, I think that's kind of the reason why this is done this way. We kind of want to restrict this and also that's why we have this metadata about subroutines. We know how stack behaves. Yeah. And this jump f, that kind of is middle ground a bit. So I can guess you can design control flow using only jump f or something like that. I don't think I have anything specific to propose at this point to change that, but there's one big item still on me and just didn't have time between these two meetings to touch it, finally, which is this stack height restriction, which I just want to make it a bit less annoying, and I will need to help with this, but this, I need to start this kind of discussion separately.
00:29:53.400 - 00:30:13.170, Speaker A: I don't know how much that will help and we'll come to any conclusion about it. I'm in the stack height, but maybe there will be some outcomes and maybe that will solve this problem about single subroutine space. I don't know.
00:30:15.700 - 00:30:35.560, Speaker F: Yeah, as we're discussing in discord, I think jump fi and callify will more or less do the trick, but I think that it would be more elegant if we can get rid of the stack height restriction.
00:30:40.310 - 00:31:18.202, Speaker A: Yeah, I'm not sure we can do like full eliminate that. I mean, that was also proposal to do, so I think there's still possibility to do that, but there are some voices on the other side that really wants this. But I think we can kind of forgot the english word for it, but make it less restrictive. So I guess it should work in some cases and not like on every case. But that's my hope for now. I can't really say anything about feasibility.
00:31:18.266 - 00:31:47.880, Speaker C: Of that one thing. Code sections is kind of related, but off the stack it allows for multiple entry points per contract. Just before we got to that section, I was coding up an idea I had that. What if we did create init code with code section a, create f instead of having a nested container? I'll get a draft out for that later this week. But there's still utility to the code sections beyond just subroutines. Multiple entry points I think is one rich vein of mind.
00:31:50.490 - 00:32:11.920, Speaker A: Oh yeah, I think that was also our original idea about using code section as the init code kind of entry points. And I can't remember why we dropped that, but yeah, definitely we can talk about it.
00:32:21.490 - 00:32:31.380, Speaker F: Yeah. So it sounds like we have some stuff to talk about offline and don't have any other spec issues to bring up at the moment.
00:32:32.150 - 00:32:46.070, Speaker C: You briefly mentioned jump fi and call fi. Yeah. What are people's thoughts on that? Is that a good bad negative positive.
00:32:51.500 - 00:32:58.970, Speaker F: From the compiler side it would solve some issues. I don't love it, but it works.
00:33:03.260 - 00:33:30.950, Speaker A: Yeah, from instruction set perspective it doesn't look really astonishing, but I think that this is kind of recurring proposal. I think we already touched that with solidity discussions as well. And yeah, I don't know.
00:33:33.080 - 00:33:36.790, Speaker C: Other than the opcode size bloat, is there any downside to it?
00:33:40.920 - 00:33:48.650, Speaker A: Not so much. In terms of implementation. It's just like obviously like the merge of two instructions, right. Or something like that.
00:33:54.820 - 00:34:04.230, Speaker C: But it would save like five bytes down to three, save two apiece, possibly, maybe more.
00:34:05.000 - 00:34:57.230, Speaker A: I need to think about is it purely the merge of some instructions or is some semantic difference or. I don't know. I need to make sure I fully understand it. But it's kind of question like how much do you want to do stuff like that. Right. Because probably there's like lot of patterns that appear like very frequently in client contracts and anything like this, the common pair of instructions, whatever, right? So you can always argue that we should merge these pair of instructions because they happen so often.
00:35:01.570 - 00:36:11.800, Speaker F: Right? I mean, one argument is like it's something that you were able to do before, which is like conditionally jump to some piece of code, which you can't do now because it's in another subroutine or, and because of the stackite validation rule. I think it would be weird if we started having conditional execution for all instructions, which I saw in some older arm specs, which is like conditionally execute mull or something, which I think looks pretty weird and adds probably a lot of complexity to client and also to code generators. And also it doesn't really have precedent in the current evm, but this call fi and jump fi do have an analogy in current evm, which.
00:36:13.790 - 00:36:14.266, Speaker A: Because we.
00:36:14.288 - 00:37:03.930, Speaker C: Have a jump and a jump if, sorry, because we already have, for anything that changes the pc other than straight advance, we have a conditional variant with jump and jump. If. So we bring that into our jump and our jump if, and if we consider call f and jump f to be the same as a jump instruction, then yeah, it would be consistent to say that they've always, anything that changes the p, the pc within a frame always has a conditional variance. So it would be consistent. My concern is, are we bloating the instruction table? Can we afford two more instructions? Maybe we can, maybe we can't.
00:37:05.790 - 00:37:25.582, Speaker F: Right. Well, it might be doable with just call fi. I'm not sure if jump fi. It would be nice. It saves two gas or something, but I don't think it's. Yeah, I have to think about it a little. But I mean, also.
00:37:25.582 - 00:37:35.250, Speaker F: Right, where do we stop? Do we add like call fv and jump fv because those also change the pc kind of conditionally.
00:37:37.190 - 00:38:05.094, Speaker C: Yeah, because I think I'm running through it. It would change six byte sequence into a three byte sequence. We would have you come in with your conditional on the stack. You would conditionally jump forward, pass the call. So you might have to invert it. So there might be another knot there. So it's seven or six down to four, down to four or three just from code space.
00:38:05.094 - 00:38:19.540, Speaker C: There's an argument for it in case of no decision on that. Something to think about.
00:38:23.810 - 00:38:39.960, Speaker F: I think that once we investigate the feasibility of the loosening and stack height validation rules, then we can see if it's still needed. Okay, that'll be another way.
00:38:58.740 - 00:39:10.870, Speaker B: Okay, sounds like a handful of things to continue discussing offline any other spec questions discussions that we wanted to have here?
00:39:11.560 - 00:39:19.136, Speaker C: Herpat posted something about Ext data pat.
00:39:19.178 - 00:39:28.616, Speaker B: Do you want to go? And then Zane, sorry, I see that.
00:39:28.718 - 00:40:33.180, Speaker D: Your voice is not my house is going back and forth from being very noisy, but I just wanted to highlight the comment that I had shared in the ether and D server. If other folks haven't seen it yet, I think there generally is a sentiment across application developers at least that are working with on chain art stuff that it's a nicer way to expose things if there is a standard way to read data in a data section from a post uf contract in a different execution context. And yeah, I don't think it's solvable in different ways via the create a kind of pseudo standard where the contract has a method that you can call into where it reads its data and returns it via call data. But it seems maybe just clunky and so I don't know, wanted to give that as an additional two cent on the topic as it's being discussed.
00:40:39.750 - 00:40:59.660, Speaker C: So I think I would say I'm weakly in favor of ExT data copy. Other solutions do exist, but I do acknowledge they're clunky and considering the needs of the data community, it's something I would support, but depending upon how the other people feel about the spec, I'm not going to compel its inclusion, but I would weakly support it.
00:41:03.760 - 00:41:12.270, Speaker G: Is ext data copy exist anywhere? Specked out. I was having a hard time tracking that down.
00:41:12.880 - 00:42:08.880, Speaker C: It doesn't exist. It's a logical hole in the data copy because we had code copy and there was ext code copy, but we didn't spec out an ext data copy that corresponded to an ext code copy. So it's functionality we'd kind of lose. But there's patterns where you could just say we'll make contract expose some methods, which means each exd code copy in addition to the cold storage which you're going the 292-9293 cold accountant penalty you're going to have the first time you access it. There would also be 100 byte call penalty plus EVM overhead to go into the call. So there is a way to do it without it. It just feels clunky and unnecessary if we could do it, but the other people writing a spec may have stronger reasons not to, and it may go against the code separation desire.
00:42:08.880 - 00:42:18.950, Speaker C: So that's why I'm merely just weakly in favor of it. I'm willing to hear what the other people, the engineers think about it.
00:42:29.340 - 00:42:42.750, Speaker G: How should we go about, I guess, putting forth a plan of action for exp data copy or proposal for that? What would you suggest would be the best way?
00:42:43.760 - 00:43:18.500, Speaker C: We don't even have a data copy eip written yet. That's in process because we're all trying to make sure we get the cancun devnets out when the data copy one comes up, propose the addition. I mean, it should be simple. It's just, you add an extra argument, that is a contract address to the stack. Costing is going to be the issue? Yeah, I think. Not sure who's got the action item to write the data copy spec. Okay.
00:43:18.570 - 00:43:22.196, Speaker G: And that's going to be before or after Cancun?
00:43:22.228 - 00:43:22.970, Speaker A: You said.
00:43:25.640 - 00:43:49.710, Speaker C: EOF is shipping after Cancun. That's probably another meta discussion we need to have. When do we want to try and get specs finalized? And I think while we're still in the process of working with the compilers and the end users, I don't think we should push too hard to free specs, but I think we should get a handle on what the issues are so we can start closing doors and get ready to batten down the hatches when it's ready to go.
00:43:56.430 - 00:44:30.920, Speaker G: Cool. And then I kind of had another just question that floated through the on chainers, which is just if we have a legacy contract that deploys other legacy contracts, do those legacy contracts need to be in the proper EOf format or not? What's the behavior in that? Does that make sense?
00:44:34.650 - 00:44:37.926, Speaker C: Can you restate it? I think I got it, but can you run it by me again one more time?
00:44:38.028 - 00:44:38.774, Speaker A: Sure.
00:44:38.972 - 00:45:00.990, Speaker G: You deploy a legacy contract that deploys other legacy contracts when the eof change happens, what will happen to this factory contract that deploys future now invalid legacy contracts?
00:45:02.610 - 00:46:27.734, Speaker C: So I don't think we want to get into the point where stuff that used to work suddenly breaks, especially factory contracts. My understanding is that legacy will continue to always work as a layer and eof will be a second layer, and what will be restricted is how you would deploy contracts into that new layer you probably need to nail down. Can legacy contracts deploy eof contracts? But I think we've pretty much shut the door on EOF contracts deploying legacy contracts, and that's a question of how do we bootstrap to EOF contracts? Do we require them to come in as eof from the create transaction? Can legacy factory contracts, factory create eofs? I think those are some of the corner cases when we really start getting some of this create stuff probably after we start up cancun testnets is, I think, when everyone will be able to fully focus on it. And I think just today Charles pointed out some issues that factory contracts would require three layers deep. So I think there needs to be some more work done on Korea as well. But I think if we broke legacy, deploying legacy going forward, I think we've done a disservice. And I think that brings to the point as well that we need to make sure that ext data copy behaves well when pointed to a legacy contract as well as the current contract.
00:46:27.734 - 00:47:05.746, Speaker C: So that's one other complication of an ext data copy is does it just become an ext code copy when pointed at a legacy contract? That's the easiest way to solve it. Which would also align with some of the sdor two specs of CNET there. I think that's what it's called, SDR two, where you have the EF header. And the way that would work in an EOF contract is the data segment would just start with that EF header, even though it would be nested deep into the EOF contract part. I mean, that's where some design can be made to try and extend it. But I think that's a reasonable. To set the first two bytes of the viewable data copy to those bytes.
00:47:05.746 - 00:47:14.090, Speaker C: To say treat this as data, I think is a reasonable place to start, whether it winds up in a legacy contract or in the data section of an EOF contract.
00:47:15.950 - 00:47:16.554, Speaker G: Yes.
00:47:16.672 - 00:47:17.098, Speaker A: Okay.
00:47:17.184 - 00:47:19.500, Speaker G: Yeah, all that makes sense.
00:47:24.150 - 00:47:29.560, Speaker D: That makes sense. There is one kind of follow up question I have on that topic where I think it's in.
00:47:32.890 - 00:47:34.760, Speaker B: 35, 40.
00:47:35.370 - 00:48:16.726, Speaker D: I don't know if I'misremembering. Sorry, I haven't had enough coffee this morning. I think it's in that EIp, one of the Eofv one EIp. There's kind of this mention of the sentiment you're describing. Legacy contracts will be able to continue to deploy legacy contracts, but to allow for some period before this behavior may be deprecated or something like that. And was curious if there's more concreteness as to what that might mean. I think our read of that has been we should update our on chain storage libraries to use the UF format once it's kind of finalized and available.
00:48:16.726 - 00:49:03.746, Speaker D: There's maybe a different interpretation that says like, oh, it's never going to be deprecated. So before the hard fork, make sure you deploy a generic factory deployer or something which seems probably suboptimal from my understanding of what the intentions of the UF work are. So just trying to understand what does that actually look like in practice? Is it like we can't backwards compatibly break factory contracts ever, but we can make them prohibitively expensive to use? Which is kind of my interpretation is like there's economic forcing functions to get people to upgrade or something like that. Or is it something else? Just trying to understand how cordex so.
00:49:03.768 - 00:49:38.720, Speaker C: For Ethereum mainnet, I don't think we'll ever reasonably have a path to fully deprecate legacies unless we happen to find an eof where they can be brought in. Not just brought in, but brought in with them. Gas equivalents, recompiling it to a new format that is not gas equivalent. It may be compatible, but I don't think that would be a viable path. The more interesting paths, I think, are to look at L2s. I see a world where there are L2s that start out EOf only and only allow Uf contracts. That's where I think the more interesting parts of this is.
00:49:38.720 - 00:49:43.700, Speaker C: Paul's got some comments. I'm sure he's got better opinions on this, so let's let him talk.
00:49:45.830 - 00:51:13.402, Speaker A: Actually I don't have much to add, but I agree with Daniel. We don't see any path to deprecate creating legacy contracts, except one thing which we can consider but later is to deprecate create transactions. So it won't be very easy to create legacy contracts using a transaction, but you can always have and maybe there exist like generic contract deployers that will do it for you. So we can just forbid create transactions at some point later in the future, but not to break the create. Yeah, so we can only kind of encourage people to migrate to EOF and current encouragement is hopefully the feature set is good enough so people will consider this. The second thing you mentioned and maybe that would be used, but I don't know really is to kind of make eof cheaper than the legacy, but that's not something we already try to do, but it's relatively easy to do later because you can't even see the gas from the UF site. So for example you can, I don't know, make every instruction cheaper than one for different arguments.
00:51:13.402 - 00:51:19.390, Speaker A: But yeah, we can use gas pricing as an encouragement for eos.
00:51:22.370 - 00:51:36.040, Speaker C: And there's lots of places we could add the gas charge and the charge to the accounts that wouldn't necessarily break the EVM flow, but I think those are at least a year down the line before we even discuss the possibility or need of them.
00:51:38.010 - 00:51:40.440, Speaker D: Yeah, that makes a lot of sense. Thank you.
00:51:46.060 - 00:52:00.110, Speaker B: Okay, we've got about five minutes left. I kind of want to time box the spec discussion so we can take a second to hear anything going on with testing. Is there any updates that people want to share with respect to that?
00:52:01.540 - 00:52:03.410, Speaker H: Hey, can you hear me?
00:52:04.740 - 00:52:05.920, Speaker B: We hear you.
00:52:06.070 - 00:52:57.516, Speaker H: Okay. Yeah, so I made a small progress on the python tests, so now let me share USDPR for you guys to take a look. So this is the EOF tests updated to the latest python specs. And we support now EVM one and we support Brad the fork. So it doesn't currently work because the create three logic is basically not working yet, but it now lists all the tests for eos and Python. It's not really working yet, but I wanted to share this because if you want to guys, take a look, you can get an idea of how the python tests are written and the amount of parameterization that can be done. There are some examples.
00:52:57.516 - 00:53:28.730, Speaker H: For example, we have lists of opcodes and with those we can parameterize tests and how to generate tests. For example, to generate a contract, to try to generate an EOF contract with all invalid outcodes and so on and so forth. So yeah, I just wanted to invite you guys to take a look into the python source code and just any feedback, just let me know if you want to share or if you need help running this code or anything, just let me know.
00:53:35.420 - 00:53:36.170, Speaker F: Awesome.
00:53:37.660 - 00:54:21.206, Speaker B: Any other testing stuff? Three minutes left. Any last comments? Cool. Thanks a lot, everybody. We'll pick back up again in two weeks. Yeah, in the meantime, we'll see you on the EVM channel.
00:54:21.308 - 00:54:21.990, Speaker A: Cheers.
00:54:24.050 - 00:54:24.960, Speaker G: Thank you.
00:54:25.650 - 00:54:26.762, Speaker C: Thanks. Bye.
00:54:26.826 - 00:54:27.680, Speaker A: Thank you.
00:54:28.290 - 00:54:28.894, Speaker H: Thank you.
00:54:28.932 - 00:54:29.740, Speaker B: Bye. Thanks.
