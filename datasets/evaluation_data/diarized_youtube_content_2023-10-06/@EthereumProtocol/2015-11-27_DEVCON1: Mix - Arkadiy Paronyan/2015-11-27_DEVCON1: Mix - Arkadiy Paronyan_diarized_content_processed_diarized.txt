00:00:20.410 - 00:00:57.200, Speaker A: Let's talk about Mix. My name is Arkadi Paranan and Nix is an Ide for developing distributed applications on Ethereum platform. It started about a year ago. We've been working on it in Yvesdev Berlin. I did some work on it a few months ago, but nowadays it's been mostly programmed by Lebro. Wouldn't be here today. So still for edit should go to Jan and of course Utah and Afsar for providing design.
00:00:57.200 - 00:01:53.330, Speaker A: This will be a live demonstration. Just a sec. Make it work. Okay, this is inconvenient. I can't really see what's going on. Hope you can see. So the idea behind mix is to provide environment for developing distributed applications and to support a full lifecycle for the application development, starting from smart contracts and then moving to user interface and then to testing, to deployment and to updating.
00:01:53.330 - 00:02:39.150, Speaker A: Okay, so mix is a desktop application. It doesn't require any network connection to work. And yeah, let's take a look at what features we have here. So the basic is this simple editor we have for contracts has all the features you would expect from code editors, such as syntax highlighting, autocompletion. Now, it also highlights errors in the code. So let's say I would make an error here. Yeah, it would show the error immediately.
00:02:39.150 - 00:03:20.800, Speaker A: I can navigate between errors, fix errors and other completion also works here. So the first step I did here is I entered this contract. Now this is a basic token contract. The very same idea was mentioned in the previous talk. And this is the simplest form of the token contract you can have. It only has the send function which transfers tokens from one account to another right here. Now, after I have done writing my contract, the next step would be to test it.
00:03:20.800 - 00:04:03.200, Speaker A: And for that I have this scenario, panel here. Now, scenario is basically a sequence of transactions executed in the same way they would execute on an actual blockchain. So this is in fact sandbox blockchain, very much like in the easer camp ide we've seen earlier. But there are some key differences here. So I can set up a number of transactions to test my contract. I can have multiple scenarios and to test various aspects. Now let's see what we can configure here.
00:04:03.200 - 00:05:20.918, Speaker A: So this particular test and blockchain has a genesis state which I can import from a JSON file, which I can generate from an actual blockchain. Or I can just list accounts here with some balances here. And I also have two transactions here. Each of them goes into a separate block. So the first transaction, what it does, it deploys my contracts on this sandboxed blockchain here, I have a UI to specify transaction parameters, and that includes, as you can see here, my contract has a constructor which accepts a single argument, and I can provide a value for this argument right here. Also it allows to set basic transaction parameters such as gas and gas price. So I have this, and the second transaction just sends some tokens from current account to another account.
00:05:20.918 - 00:06:21.560, Speaker A: So tap the send function here and it also accepts two parameters per recipient for the transfer and the number of tokens to transfer. Here it is. With a click of the button I can execute these transactions and get result. So this is my current state displayed here. It shows contract storage and configured accounts as well. Okay, so this is a simple contract, but I've seen people writing really complex contracts in solidity. And what if something goes wrong and we might want to debug things? And what mix supports is building debugger for solidity.
00:06:21.560 - 00:07:00.550, Speaker A: Let's take a look at that. So I have this debug transaction. Yeah, and I'm debugging this send function. Now I can step to the code and see how it gets executed. This operates on an expression level, so I can step not over the lines, but individual validity expressions. And as I go I can see how much gas, the function the transactions consumed so far. As you can see, it's slowly growing here.
00:07:00.550 - 00:07:44.048, Speaker A: And notice how steep it went from 300 to 5000 something. That's because storage rights are expensive in Ethereum. So I can step forward and backwards. So basically I can navigate to any point in time here during transaction execution and examine the state of the contract at this point of time. So it shows me here my local variable contract storage as well. This allows contract debugging. Basically you can figure out what's going wrong with your contract here.
00:07:44.048 - 00:08:56.710, Speaker A: And if it's not enough, you can go deeper to this EVM assembly level debugging. You can view which instructions are executed and step in and out of functions and over instructions, and also shows the place in the code which corresponds to current instruction, as you can see here. So that's also a great tool to study how solidity compiles into EDM here. Okay, let's get out of it. So I can have multiple of these so called scenarios here. And I can have one, for example, that test if the fonts are stamped correctly, another one which tests if this condition is checked correctly, for example. Okay, let's move on.
00:08:56.710 - 00:09:40.310, Speaker A: So after I'm done testing my solidity contract, I would probably want to create a user interface for my dev. So that actual users could interact with this simple stuff. Yeah, one more stuff. Where is it? As in regular ide, this has a notion of a project. So I can have a list of files here which essentially form my dev. And I also have this little web page which acts as an interface. Let's find that.
00:09:40.310 - 00:10:24.940, Speaker A: So this works basically in the same way it would work in mist or regular web browser. It communicates with the theorem network using web free API. In this case, the API is implemented by mix, so it works with this particular sandbox blockchain as well. Sorry. Here's the preview of this little web page. Yeah, it has web 0.0 design.
00:10:24.940 - 00:11:27.806, Speaker A: Let's test how my dap works through the user interface. I can pick an account, oopsie, that's weird. Pick an account to send to and enter the value. Okay, that's weird. My send button disappeared somewhere. Let me restart. Anyway, whatever I do in the user interface also ends up in this transaction list.
00:11:27.806 - 00:12:18.630, Speaker A: So I can, let me check if I can see it here. Yeah, so here's a call made from Javascript. This is a call to request a balance for this account here. If I change an account, it makes another call. And I can see these calls here, right. I can save them as a part of my testing scenario, and I can added parameters or I can even debug them the same way. Now there's nothing to debug here since it's just a single line.
00:12:18.630 - 00:13:22.300, Speaker A: That's weird. Okay, after I'm done testing my web interface, I can package and deploy my depth to a real network. This has this deployment wizards. I'm not going to demonstrate it now. This requires an actual network connection, but the idea is it packages your DAP and pushes it to swarm or ipfs or whatever. It's not supported yet, but for now it can only deploy to regular HTTP server. And it also registers a URL for the DAP in the registry contract, which is already on main ethereum network there.
00:13:22.300 - 00:14:15.270, Speaker A: So this allows pretty complex deployment scenarios. You can have multiple contracts depending on each other. You can set up a sequence on how these contracts are deployed and which transactions are called for deployment and so on. Another little cool feature I can demonstrate here is gas estimation for solidity. So I can basically see which statements and which expressions consume the most and the least amount of gas. And it also shows the estimations for functions. This is a lower bound estimate of how much gas this function can consume, which can be pretty useful.
00:14:15.270 - 00:15:51.180, Speaker A: Okay, so as you can see, the focus so far has been on solidity features. So we don't support web debugging yet and stuff like that. And if you would like to use web framework such as meter for example, this would be complicated here, but the goal is to support that as well. So yeah, you can use this tool for prototyping your DAP really quickly. I mean it should just work. Okay, what else do we have here? Specific it now there are a number of features we want to add to this program, including Javascript debugging and so on. You can use your regular browser for now to debug JavaScript things, and you can use chrome development tools for example.
00:15:51.180 - 00:16:53.166, Speaker A: Another thing we want to add is test driven development. So we want to use JavaScript to provide a way to write the unit test for your contract, both solidity contracts and JavaScript web interface in JavaScript itself. Yeah, we've been over this so far. Yeah, so that's basically it. So we really need feedback from developers now. And you can get binary releases, you can visit our GitHub page or gitter chat and let us know what you think of it. Yeah, that's basically it.
00:16:53.166 - 00:16:54.560, Speaker A: Thank you very much.
