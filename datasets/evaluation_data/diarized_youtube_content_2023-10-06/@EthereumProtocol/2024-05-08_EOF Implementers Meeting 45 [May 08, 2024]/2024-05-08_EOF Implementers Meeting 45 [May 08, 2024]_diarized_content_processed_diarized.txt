00:00:00.160 - 00:00:44.924, Speaker A: From Planaware, call number 45. We will not have a, you may or may not have a column meeting next week. We'll decide that online. A lot of us are going to be off site, but we'll make that call a bit later, probably next Monday. The agenda is client updates, compiler updates, spec updates, one on address based expansion and TX create testing and then other items. If there's any requests for things you want to talk about that are not on the agenda, that Pooja pasted into the meeting, please put them in the chat and we'll come to them as we come to that subject. First on client updates, let's start.
00:00:44.924 - 00:01:03.776, Speaker A: Let's see. Is Eric on the call? Nope. Ethereum J s. Do we have any from Ethereum J s? Nope. Geth? No one from geth. All right, Nethermind. I see amens from Nethermind.
00:01:03.776 - 00:01:06.524, Speaker A: I like how he puts his client in his name.
00:01:08.224 - 00:01:10.244, Speaker B: Yeah, we are here.
00:01:12.824 - 00:01:16.324, Speaker A: Can you give a client update? How's neithermind doing with Eof?
00:01:17.144 - 00:01:44.504, Speaker B: We are reviewing our implementation. We opened the PR, I think, on the EOF spec brands, so we can indicate which eIps we have already implemented and which ones we are still re reviewing. So yeah, that's mostly it. Where most of the team is focused on Devnet zero, and EOF was just reviewing our implementation and catching some bugs here and there.
00:01:46.964 - 00:01:52.944, Speaker A: Okay, have you had a chance to look at the code and stack validation code yet?
00:01:54.924 - 00:01:55.664, Speaker B: What?
00:01:56.884 - 00:02:33.864, Speaker A: So when I went from big EOF to mega EOF, the places that took the most time were the stack validation and the code validation sections. And there's one of the opcodes that had some significant changes wasn't the XT calls. But that's probably where you're gonna need to spend most of your time. That's also where we have most of the tests written for validation. So it should be pretty easy to figure out when you have all the features or not. So that's probably one of the more heavily tested sections and reference tests. Okay.
00:02:37.044 - 00:02:43.224, Speaker B: We'Ll try to run the tests again and see how it goes.
00:02:43.684 - 00:03:14.364, Speaker A: Okay. All right, and let's see. So, Basu, I haven't had a chance to update the implementation matrix, but the new column, the which column was it? 7698. We do have an implementation for that. I just need to publish it in. There's no test for that yet. We need to get tests written for it, but it's fairly easy to test.
00:03:14.364 - 00:03:22.564, Speaker A: And let's see, Aragon, Ethereum, EvM one. Any updates?
00:03:24.944 - 00:03:45.624, Speaker C: Yeah, we have also grey and transaction pr and progress. And another one with new validation check for init container kind that Charles specked out. These are two in progress, but I would say close to completion. Some tests are needed too. Yeah, yeah, that's it.
00:03:46.044 - 00:04:18.982, Speaker A: Okay, do we have anyone from Geth on the call? No, they spent a week, they got some good progress. But there's. I looked at their code and ran it against the tests. They need to get some of the call and the create code written, as well as finishing up some of their validation. So I think that accurately reflects their current state as all those in progress signs. Revm. No revm.
00:04:18.982 - 00:04:46.294, Speaker A: Okay, that would be reflected. And so that's all the client teams. Is anyone from solidity on the call? Nope. And Viper Charles already said in chat, no impulse updates from Viper. Okay, so that's compiler and client updates. Alex.
00:04:49.574 - 00:05:53.384, Speaker D: I have a note here. So we did update the readiness matrix and included a number of clients and prs from what has been discussed here. So we included Goetheoreum and marked all of them work in progress, as much as we could judge that those eips are being addressed in the pr, and the same applies to Nethermind. So we found this one pr, I think it was earlier this week. And yeah, we included all of these aips as work in progress as far as we could tell. And then also on Ethereum J's, I think our assessment was that there is some support and there's a pr as well, but it seems to be very likely outdated using probably early 2023 version of UF. Therefore we included it in the matrix with the marking stale.
00:05:53.384 - 00:06:16.192, Speaker D: And the same applies to Wiper, even though. Charles, you said there's no implementation for Wiper, but there seems to be a, maybe it's an external contributor, but there seems to be a prime for implementing the first four, I mean apart from function sections, but static relatively that there's no implementation.
00:06:16.248 - 00:06:17.844, Speaker E: I just said we don't have any updates.
00:06:19.024 - 00:06:44.664, Speaker D: Yeah, but it wasn't marked in the readiness matrix, so we added them. But since the PR was last touched in 2023, we marked it as still. So I think my conclusion here is that I would invite everyone to review this readiness matrix and maybe push updates if you disagree with some of these.
00:06:53.884 - 00:06:54.664, Speaker A: Pavel?
00:06:56.484 - 00:06:56.932, Speaker F: Yes.
00:06:56.988 - 00:07:54.974, Speaker G: Hi. So Radek from our team who's not on the call, he's also working on updating validity implementation. So he took over the implementation that was there last year. So I think the progress is pretty steady. But this code has been rebased on the recent solidity. Some of the tests were still working if you used previous EOS implementation in EVM, I think that now is a bigger feature that is rework all the other creation that we added. So mostly implementing EOF, create, return contract and stuff like that.
00:07:54.974 - 00:07:59.314, Speaker G: This seems to be a rather big feature on the solid site.
00:08:06.374 - 00:09:14.098, Speaker A: Yeah, that makes sense because you would need to. Their code makes assumptions about flat space and moving stuff around for the init code. It makes sense that take a bit of work to do. Any other people have information on clients or compilers before we move on? All right, so the next item is to talk about spec updates. The first item is one of mine. It's one that I realized is coming right close to the end before we do our offsite EIP 7069. And that was some changes I was proposing to.
00:09:14.098 - 00:10:09.158, Speaker A: Let's see. Okay, this is pull request number 86. Is that on here? Let's work with that. With spec updates, we'll do that as a third item, but the first one is 7069 exe calls. After we had our discussion a couple of weeks ago about not wanting to change semantics of existing opcodes unless it was absolutely necessary, I retooled it and there's a new balance op code. But what I think survives out of it that I think we should bring into mega EOF is the changes to the calls ext call, the XT delegate call and ext stat call. I don't think it's written right now to trim the calls.
00:10:09.158 - 00:10:26.994, Speaker A: And I think the one change we should consider is adding in that it would revert if it has any of the high bits set until such time as we decide what we're going to do with those. Any comments on that?
00:10:37.754 - 00:10:39.254, Speaker C: Sounds good to me.
00:10:39.594 - 00:11:23.294, Speaker A: Yeah, 7069 is yes, in general. Okay. My EIP number was something different, but yeah, 7069 is the ase changes to it. Okay, so I'll post a pr to get that ready into 7069 and post that later today. Write that down my to do list. The next spec change is to finalize removing Txcreate in a netcode transaction. Any comments? And this also needs to be accompanied with the new EIP.
00:11:23.294 - 00:11:38.218, Speaker A: What number was it? 7968. Yeah, so it needs to be company with 7968 to replace that. All in favor? All opposed?
00:11:38.386 - 00:11:46.174, Speaker H: 7698 is. I would say it's confirmed because we have decided already to remove the creator contract.
00:11:47.684 - 00:12:38.806, Speaker A: Okay, so we do have a way in to the system. So let's go ahead and finalize that one and define a niccode mode and require variation validation of contract EOFPR number 86 and this is going to trickle its way down into the validation eips. Baesu does have this implemented. The error code is weird because of the way that I implement it. I do top down. So I don't say that this is actually an init code. When you're calling return contract on it, I will say inside the runtime, I say you have an invalid return contract, but it can be done top down, single pass just requires a little bit of finessing.
00:12:38.806 - 00:12:59.334, Speaker A: And I have, when we get to testing, I do have a set of tests set up that will test for some of these scenarios for validation. Any comments before we finalize? Okay, go ahead.
00:12:59.454 - 00:13:08.264, Speaker H: This is still about removing TX create an init transactional, have we, because you said ATC or 76, both.
00:13:08.344 - 00:13:17.924, Speaker A: So the changes is 70, 69 and then 70 and then EOF PR number 76 and then EOF PR number 86. So there's three items.
00:13:18.344 - 00:13:33.844, Speaker H: Right. So the first item we are waiting for the pr to the EIT, which is basically exists, but needs to be split out of the other one.
00:13:34.174 - 00:13:36.198, Speaker A: Right, good.
00:13:36.366 - 00:13:53.114, Speaker H: And then the removal of TX create and unit code transaction. Do we have a final poll on whether we want this or not? I don't see how it's related to the next one.
00:13:55.214 - 00:14:14.494, Speaker A: So TX create an transaction. They could be done independently of the return contract validation. It's just a question of whether we're going to do the return contact validation code in code validation, or whether we're going to bring that validation code into the operation and do it at runtime.
00:14:15.794 - 00:14:18.294, Speaker H: Right. And currently we do it in runtime.
00:14:20.034 - 00:14:41.324, Speaker A: Right. That's the way Megaspec was initially test specified. And this change would be to bring it into code validation time, right? Yeah.
00:14:41.364 - 00:14:52.024, Speaker G: To my understanding we're going into direction to, to bring all of this to validation time. But maybe Andre can confirm because he's behind the implementation of this.
00:14:54.344 - 00:15:16.564, Speaker C: Yeah, we have the implementation of this already. It works. I think it's a bit tricky. It complicates our code at least, and I'm looking into how to simplify it maybe a bit. So I don't have objections to this. I think in general it's a good goal to have everything in validation.
00:15:18.144 - 00:15:19.080, Speaker A: Okay.
00:15:19.272 - 00:15:23.918, Speaker C: So yeah, at this point it seems like maybe it's worth it. Yeah.
00:15:24.086 - 00:16:16.050, Speaker A: Okay. So basically when EVM want to have it implemented, because I think there was at one point a concern about the feasibility, but if we have two impulse with it, I think that passes the feasibility question from basically our mechanism so we don't reject unused subsections right now. But what we do do is we track what type of calls have gone into each subject subcontainer, whether it's been an EOF create or a return contract. We record that as we recurse into and validate it and use that to determine what mode to accept return contract from or not. Runtime rejects it and init code rejects return and stop. So that's a flag that we put in validation to also reject those. And that comes top down.
00:16:16.050 - 00:16:52.414, Speaker A: So you can still do the validation top down and the errors are going to occur in the subcontainer. And there's another check that you have to do to make sure that you don't eof and return contract the same subcontainer. You just need to track more data as you go top down. So this can be done in the same level order of complexity as we have before. It's a bit trickier, you got to think about it a bit more. But it really removes a lot of runtime code from stop, return and return contract and EOF create. And yeah, it returns, it removes a lot of those.
00:16:52.414 - 00:17:07.640, Speaker A: Okay, so if there's no other comments, let's move on to the testing updates. Sorry.
00:17:07.672 - 00:17:21.404, Speaker H: So I think we're kind of supportive of the return contract validation, but what about the TX create and unit called transactions removal? Like do we want to. I guess maybe it's time to make a final call on this one.
00:17:23.224 - 00:17:45.064, Speaker A: Yeah, I think the final call is. Anyone think it should stay in for mega eoF? Okay. Anyone feel it should be? I personally support taking it out and it can return, but I want to hear other people's opinion. I don't want to be the only one speaking on it.
00:17:49.004 - 00:18:11.134, Speaker H: I guess we know that we are losing some features by taking it away, but we also are reducing the scope altogether and removing the new transaction type is also of high value if we want to consider you to be going into Prague. I guess this is a pragmatic decision.
00:18:15.354 - 00:18:19.290, Speaker A: Yeah, that's the way I see it. Go ahead.
00:18:19.362 - 00:18:47.754, Speaker E: How much features do you lose? Because like basically you have to do, you can't have like a really generic create thing where you can like call a contract and then that contract deploys from, from transaction data. Yeah, but that's like the only use case, right. And like that's like fairly straightforward to do in just two transactions.
00:18:49.514 - 00:19:00.614, Speaker H: Correct? Yeah, I think this is the only feature that really is at play here, which we currently know about. Right.
00:19:02.754 - 00:19:07.934, Speaker A: Smart contract wallets can't create contracts without this I think is the other side effect.
00:19:08.554 - 00:19:12.014, Speaker H: I think this is what Charles described.
00:19:12.994 - 00:19:13.402, Speaker A: Right.
00:19:13.458 - 00:19:27.774, Speaker E: But that's, you need to deploy a separate factory contract. So then the code is like on chain instead of in the transaction data, which, by the way, if we want to discuss EIP 7702, that's like the same thing.
00:19:31.874 - 00:20:15.304, Speaker A: Right? And it was. So there's pragmatic, it reduces testing surface. And the risk is we do use that, lose that feature. But I think it's important that Vitalik's mentioned. He wants us to consider things like copy contract, and now there's 7702. So pulling it out serves a pre pragmatic scoping issue, and it also preserves space to discuss alternatives and make sure that we're not this, we're not locking out of other design possibilities. And what I like about taking it out is if we do all the discussions and we come back full loop and decide the exact design as what we had was correct, we can always bring a right back as is because it can be done as a compatible forward change.
00:20:15.304 - 00:20:49.764, Speaker A: So this is not an irreversible decision, taking it out. There's a possibility, just a delay until a future release when more people are more comfortable that this is the correct decision, mostly people not on this call. So we give them the opportunity to discuss it in a venue of their choice. And there's also the possibility that alternative designs may replace this. So I think that's, that's why I think pulling it out is an important concession to critics of EOF, because it gives them the opportunity to let their alternatives develop and we can decide which one is the correct one.
00:20:50.264 - 00:21:09.254, Speaker E: I think there was another kind of objection that was raised by Alex, which is that it's not like something that we can completely back out of because we're locked into the other transaction. Sorry. The creation method, like forever, because the.
00:21:09.594 - 00:21:17.346, Speaker A: The Trent create contract. Yeah, we are. We do need to support that forever, at least for the, for the, for.
00:21:17.370 - 00:21:27.934, Speaker E: The forces forever enshrined in the, in the transaction semantics. When the call data starts with, like, ef.
00:21:28.834 - 00:21:33.734, Speaker A: Right. For the forks, it's active. And which means for all the historical people reading the chain, that is correct.
00:21:36.274 - 00:21:42.534, Speaker E: Which, like, I mean, I'm personally fine with, but it should be. Yeah, I don't want to, like, talk for Alex either.
00:21:42.874 - 00:21:44.574, Speaker A: All right, let's let Alex talk then.
00:21:47.674 - 00:23:08.464, Speaker D: Go ahead, Alex, just to add some flavor. So, like, I think two weeks ago, we had a meeting with Ipsilon in person meeting, and that's when we created the create contract version of the EIP. And I think that version with those specific workarounds, or like semantics for the call data at least is forward compatible. So at least, given the current TX create design that will be unchanged, the code generated by the compilers will be compatible with both options. And even though in the past I did say that I prefer the creator contract, I still think that's a much more elegant solution compared to what we have now. But given the sheer amount of complexity we command here, I do feel now that this version of create contract is probably a good enough concession just to get this over the finish line and still opens up the door to have something like TX create. I suppose we won't really have a creator contract even in those designs in the future if there isn't much appetite for it.
00:23:08.464 - 00:24:02.964, Speaker D: But I'm not that much concerned having this legacy create contract rule, because I do think it could be deprecated in the future. Even though we haven't seen transaction types being deprecated, they're kind of like self deprecated with new features, making the newer versions much more popular. So maybe it won't be used in the future. The only case where I could see that it could become enshrined if the non protocol account abstraction designs rely on it. I think that's the only risk with making this create contract non depreciable. Maybe this was a long blur, but that's all my opinions on the topic.
00:24:11.344 - 00:24:27.016, Speaker A: Yeah, thanks for that color. I think that really helps people out. And yeah, it is a concession. This is the engineering process. We are being able to get our peer designs in like we want to anymore. And I appreciate that from.
00:24:27.200 - 00:24:49.344, Speaker E: We'll add that personally from the compiler perspective, like the current weight that's being proposed, which is somebody else, separates the container from the call data. It's really nice for compilers, because once you're in the compiler, you have like a single code path and you don't have to do something special.
00:24:55.084 - 00:24:58.024, Speaker H: Okay, so I suppose this is yet and we can move on.
00:25:04.244 - 00:25:32.134, Speaker A: Unless there's an objection. That's a yes, and we'll move on. All right, any last call for spec updates before we go to testing? All right, testing. I see we got Dan Serratopaz. Am I pronouncing that right?
00:25:32.754 - 00:25:37.650, Speaker F: It's emphasis on the Dan. So I'm Dan from EF testing. You can say danceratops.
00:25:37.842 - 00:25:40.454, Speaker A: Serotops. Okay, yeah, like the Dan.
00:25:40.914 - 00:25:41.562, Speaker F: Exactly.
00:25:41.658 - 00:25:43.294, Speaker A: Yeah, the Z through me.
00:25:45.794 - 00:26:22.554, Speaker F: All right, so I'll do my best here. It's mainly been dimitri who's been working on eoF. So basically now when we're filling eof fixtures. We now call EOF password automatically on the generated fixture so that you actually get feedback on whether your test was implemented correctly or not. So this is during the fill process. So when you're actually writing tests, you then can tell if it actually is like you're getting the exception you expected or whether it's like a legitimate eof test. Okay.
00:26:22.554 - 00:27:07.494, Speaker F: It's currently hard coded to be EVM one's EOF password, but we'd like to make this configurable via command line switch to enable other tools as they become available. Then while we're on eofpass, Dimitri brought up the point of specking out these tools a bit more concretely while we're still in this stage, so that we could try and avoid a mismatch of options. So we have very clearly defined input and output. So we just wondered if you'd be open to that. And I'm not sure if Dimitri has been in discussion maybe with Pavlov about that. Sorry for the vagueness.
00:27:08.514 - 00:27:18.778, Speaker A: Okay, so this is, Alice was discussing the new execution spec tests repository, not the ethereum tests.
00:27:18.866 - 00:27:28.812, Speaker F: That's right, exactly. So now Mario, Mario, Spencer and I, we collaborate together with Dimitri on execution spec tests. Exactly, yeah.
00:27:28.988 - 00:27:29.612, Speaker A: Okay.
00:27:29.708 - 00:27:31.548, Speaker F: We're working together on that, yeah.
00:27:31.596 - 00:27:39.024, Speaker A: So all new tests should come into execution spec tests and we should not be creating any more retest set fillers, is that correct?
00:27:39.524 - 00:27:40.824, Speaker F: That's correct, yeah.
00:27:41.404 - 00:27:42.264, Speaker A: Okay.
00:27:44.564 - 00:27:52.184, Speaker F: I mean there may be some exceptions to that, but for any new stuff, we're basically putting all our focus on execution spec test now.
00:27:52.604 - 00:28:14.264, Speaker A: Okay, so I do have one open question related to just the flow and not necessarily eoF. Those tests still create the JSON fixtures. And are those fixtures going to migrate over to the Ethereum test repository at some point, or are clients going to need to run Ethereum, run the execution spec test themselves?
00:28:14.964 - 00:29:07.354, Speaker F: Okay, so as you know, execution spec tests is a relatively new repository compared to Ethereum tests. And the way we've been operating for state tests and blockchain tests is that we release a table on our GitHub page and then client teams can like, that's available for client teams to add to their CI CD. So going. But this is, as I say, it's relatively new and this is not fixed and it's not staying stone. So if you have any requests, we're open and open to discuss it. But currently that would be the plan that basically we would release these eof tests on execution spec tests on GitHub and this tarball would be available for integration in CI CD.
00:29:08.694 - 00:29:21.594, Speaker A: Okay, so clients need to start pulling the tarball in addition to using the test repository. Is the goal long term, to deprecate the test repository and get everything into that tarball.
00:29:22.094 - 00:29:56.074, Speaker F: Oh, now you're asking questions. So I think at some point we forget. So obviously we have a huge body and history of tests and ethereum tests, and at some point we may essentially freeze that and focus essentially on filling tests from the new repository. And the path forward here is not clearly defined. We'd love to port all the tests to the new form, but it's really a huge amount of work.
00:29:56.574 - 00:29:57.314, Speaker A: Right.
00:29:58.134 - 00:30:33.642, Speaker F: So I think as most clients have Ethereum tests as a sub module and then run the test directly, I think that's going to stay as is for the foreseeable future, probably ethereum tests will be no longer supported, as in tests will be not filled for forks post Vercal, because that adds some complications. And yeah, we're still trying to find the path forward, but I think at the moment you have to take your test from two sources.
00:30:33.798 - 00:30:35.178, Speaker A: Yeah. Okay.
00:30:35.346 - 00:30:37.842, Speaker F: That's how it is going forward. Yeah.
00:30:37.898 - 00:30:50.014, Speaker A: Because I did see that geth wrote a script that'll take the fillers and convert them into python. They're kind of ugly, but they're functional. So they could be, you know, put into unliked corner and still used.
00:30:51.634 - 00:31:05.304, Speaker F: Yeah, I mean, that's a different topic. Yeah, we have looked at that, but it's not ugly. It does work in some cases, but it's not a solution for porting all these tests, unfortunately.
00:31:05.964 - 00:31:06.784, Speaker A: Okay.
00:31:07.804 - 00:31:12.744, Speaker F: So yeah, I think that's a topic for another day, but yeah.
00:31:14.404 - 00:31:19.624, Speaker A: Okay. Ahmad had a question about versioning.
00:31:22.724 - 00:31:27.264, Speaker I: Yeah, it's not related to UIF, though. It's about AIP versioning.
00:31:29.144 - 00:31:30.072, Speaker A: Okay.
00:31:30.248 - 00:32:16.864, Speaker I: I'm not sure it's the right place to mention it, but I would love to gauge the room because like me and Dan, we were working on this proposal to actually add versioning to eips and we haven't had the chance to present it in ACD yet. We did present it in and AIP IP with Poja was there and the editors, but we were not able to suggest it to ACD yet. But yeah, I would love to hear from you guys if you think AIP versioning would make sense to you.
00:32:18.564 - 00:32:22.024, Speaker A: How would the client signal it? How would the test signal it?
00:32:25.824 - 00:33:36.414, Speaker I: So the idea is the authors of the EIP would, whenever they make a change, depending on the type of change, if it's breaking or non breaking, would add version increase using semantic versioning, etcetera. And like how to, how would clients and testing signal it? That's like not specified in the AIP, but will be like discussed and like spec somewhere right after the AIP has been enshrined. But the first step would be to have an AIP versioning scheme and then move to how would we signal client implementations around which version of the IP is implemented in the client, which version of the IP is implemented in test, etcetera, etcetera. Dan here shared a very useful link where he explains the background behind this.
00:33:48.814 - 00:33:53.794, Speaker A: So this would version it before it goes into final. Once it's final, versioning is irrelevant, I guess is another question.
00:33:54.854 - 00:34:59.274, Speaker I: Once it's final, I think version. Once it's final, I think the changes to an EIP become very minimal where only changes are, I don't know how to call it, I'm not that good at English, but it would be superficial, nothing with the implementation in itself. It would be like spelling fixes, grammar mistakes, et cetera, some extra explanation maximally, whereas before its final changes to the spec itself could be made. This is already how all eips are once they become final, once they land on in it. Basically you can just change the spec, unless it's something like we said, fixing a small split mistake or grammar mistake, etcetera. So the idea builds on top of that and continues on it.
00:34:59.894 - 00:35:02.566, Speaker A: Okay, that makes sense.
00:35:02.590 - 00:35:15.794, Speaker I: Of course, I would not want an answer right now, but I would love for you guys to read this document from Danielle and read the IP and let us know what you think. That would be really helpful.
00:35:16.294 - 00:35:49.412, Speaker A: All right, we'll put that on our to do list. Lots to contemplate there. But I think, yeah, I think I generally support it. Some mechanism. I think we just need to figure out how clients and tests can signal this. So when you see a test failure, you can say, oh, well, that's because I have the wrong version, rather than I have things horribly broken, which I think would solve a lot of problems. One example I'm having, it's real world right now, base who has implemented the 6110 deposit route changes, but the tests that are being filled from execution specs don't have those.
00:35:49.412 - 00:36:01.824, Speaker A: So all of the blockchain tests fail for reasons unrelated to what they're testing, because they're looking for something that doesn't exist. So the real world, I could totally see where this would provide value.
00:36:02.544 - 00:36:03.284, Speaker E: Right?
00:36:04.024 - 00:36:48.494, Speaker I: That's the main point and the reason I wanted to mention it in this call. Of course, I respect everyone's time here, and I wouldn't want to waste it, is because of the ever evolving spec changes in EOF. And because of that, in my personal opinion, EOF would benefit the most from having this kind of versioning. Whether it's from testing perspective, whether it's from client client implementation perspective, from EIP spec perspective, from all perspectives. I think this would be beneficial to EOF implementers, and that's why I mentioned that of course I wouldn't have otherwise if out of respect to everyone's time.
00:36:49.114 - 00:37:15.274, Speaker A: Right. And I think it's better than to use the versions instead of saying small, big, mega, mega final, mega post final. I yeah, we're, we're kind of adopting versioning already, so. Cool. So let's review this. One thing I do want to mention from testing, I do have. Let me see if I can find it.
00:37:15.274 - 00:38:27.914, Speaker A: I've been submitting a lot of execution specs to cover a lot of the areas, and you know, they're not always accepted on the first review. But what I do have is I've been collecting them to one big omnibus, at least on my mind. Of all of the possible execution specs, you can see all the commits I've been combining onto this one omnibus branch fork that I have, and I've been bringing in some of the swap in tests and others. So yeah, I will post my omnibus link here and post it on discord. This is not final execution spec test is the authoritative I do write mistakes in my test code, which is why I validate against EVm one lot. So it's great to have multiple clients. As far as testing coverage, are there any major gaps we should consider filling or any issues with testing the current code base? We need tests for the new 79, 68, whatever that number is.
00:38:27.914 - 00:38:34.434, Speaker A: Dan.
00:38:37.414 - 00:38:53.614, Speaker F: Sorry, just with regards to your last point, thanks for the branch, and I have seen your prs in the repo. I must admit I haven't looked at myself yet, and I just wanted to add, but I did notice them. I just wanted to ask in general, are you okay going forward, or do you need a bit more support there?
00:38:55.954 - 00:39:16.544, Speaker A: I think I understand it. Just be direct with the reviews. If you want something changed, just directly ask for it. I'm happy to do that. I think I'm understanding enough of the python and I get enough of the subtleties that it's not too confusing to me anymore. It was a bit of a learning curve at first, like all new libraries, but it seems reasonable.
00:39:18.084 - 00:39:21.984, Speaker F: Okay, good stuff. Thank you. Perhaps we can have a chat offline.
00:39:22.724 - 00:39:25.556, Speaker A: Yeah. Will you beat the offsite next week.
00:39:25.700 - 00:39:26.916, Speaker F: I will be. Yeah.
00:39:27.100 - 00:39:28.780, Speaker A: Okay, great. See you there.
00:39:28.972 - 00:39:31.104, Speaker F: Perfect. Yeah, sounds good.
00:39:36.434 - 00:39:38.314, Speaker A: Any other testing?
00:39:38.474 - 00:40:23.064, Speaker H: There's been an idea about testing. Two weeks ago we had that we could take. I don't know how to best describe it. Take the existing tests that don't really have anything in common with EOF, say, in execution spec tests, and there be able to add a flag which will say, hey, I want to run this test also with the code wrapped in an EOF container. And then so that we could sort of duplicate the existing non EOF tests to run or to be executed as EOF tests, just to ensure that we have this, like, massive coverage of all the existing code. Like we. And, like, solidify the claim that we are.
00:40:23.064 - 00:40:27.944, Speaker H: No, the parts of the EVM that don't change have not changed.
00:40:29.144 - 00:40:42.208, Speaker F: Yeah, this is a great idea. And I know we thought about doing it the other way around, but this is a great idea. We definitely have to have a look at that. Perhaps Mario's already thought about it. Surprised me.
00:40:42.256 - 00:40:44.152, Speaker H: Other way around would.
00:40:44.168 - 00:40:56.804, Speaker F: You mean taking eof code and then putting them in blockchain tests? So taking all the different EOF vectors and then wrapping it in a blockchain test.
00:40:58.624 - 00:41:05.480, Speaker A: I was thinking this meant take all the legacy vectors and if they drop into an EOF container, construct a container and test that.
00:41:05.512 - 00:41:08.168, Speaker H: Yeah, yeah, yeah. That's what I mean, what download said.
00:41:08.336 - 00:41:16.848, Speaker F: Yeah, no, I. Yeah, I understand. It's an excellent idea. I'm not. I'm not sure. I don't think it's being worked on. And I.
00:41:16.848 - 00:41:23.606, Speaker F: It's the first time you hear about it. Maybe Mario's heard about it before. I'm not sure, but we should definitely do this.
00:41:23.800 - 00:41:53.534, Speaker A: So, one thing that crosses my mind, we're going to need stack validation and code validation to make sure that they are going to be valid. That dovetails into what eels is going to need to prove eoF. This may need to be blocked until eels has a functional eof, or at least half functional eof container. And then we can use the eels code to build the containers from random streams. And if the stream is acceptable, put it in eoF. Yeah.
00:41:53.574 - 00:41:54.274, Speaker F: Okay.
00:41:54.854 - 00:41:59.206, Speaker A: And yes, we should add eels to the readiness, but I think.
00:41:59.390 - 00:42:04.354, Speaker F: I think we can do this without eels. Just like filling via EVM one.
00:42:06.974 - 00:42:10.514, Speaker A: And we're going to play whack a mole with validation rules because we'll need stack heights.
00:42:11.334 - 00:42:46.034, Speaker H: Oh, we need stock heights, right. Yeah. I didn't think about stack sites, but essentially it should be. It should be as easy as adding a decorator in python in my opinion, or something like that. Just, just indicate, you know, it's probably the majority of tests will have the EOf counterparts. It's just a minority of tests which will not have one. Like once that tested opcodes that are removed in the OS and such.
00:42:47.574 - 00:42:48.310, Speaker A: Okay.
00:42:48.422 - 00:43:06.794, Speaker C: Yeah, I'm not sure it's a minority. That's like a lot of tests. It only works for section of opcodes of legacy and EVM. Right. And those are arithmetic ones, the least interesting ones. So calls wouldn't be translated as easily, jumps wouldn't creates neither.
00:43:07.174 - 00:43:25.568, Speaker H: No, correct, correct. The majority. I said it because we were sort of keeping most of the eVm. But because tests can be contaminated with non EOfE stuff it might actually turn out to not be a majority. I don't know, it's hard to judge.
00:43:25.736 - 00:43:56.594, Speaker F: So that's. I mean at least for the tests and execution spec tests. It's a very good point about different opcodes. A lot of our tests are implemented using like a sort of mini language for EVM bytecode. So without UL or without solidity, for example. And we can analyze that stuff pretty easily and check that we only include Uf valid bytecode and we can check this stuff and then generate the tests accordingly.
00:43:56.894 - 00:43:58.874, Speaker A: Anything with jumps is going to be challenging.
00:44:00.774 - 00:44:10.498, Speaker H: Yeah. I mean, details to be worked on. I have not looked at the execution spec test to, to see all the feasibility and of this in practice.
00:44:10.666 - 00:44:24.574, Speaker F: I mean it's. Yeah, it'll be interesting to see how useful it'll be. It might be worth having a discussion first before we do. A lot of our bytecode is just very simple, very minimal. Perhaps we can have a look at it together.
00:44:28.094 - 00:44:40.634, Speaker A: Okay, we've only got twelve minutes left and four quick items to discuss. Maybe we should have this testing discussion on another date if there's no outstanding requests.
00:44:41.174 - 00:44:42.822, Speaker F: No, that's not it for me.
00:44:42.998 - 00:45:11.614, Speaker A: Five, if we had Charles's last request. Charles asked in chat should we ban dead subcontainers? That's something we could roll in with the init code, I think. Let's go ahead and merge 86 as it is and write a new band. I'm writing this down, subcontainers. So when we come up.
00:45:11.914 - 00:45:17.970, Speaker E: But you mentioned it earlier when you were doing the implementation that. Yeah, it just kind of makes sense though.
00:45:18.122 - 00:45:22.424, Speaker A: And we're doing the validation for it anyway, so we may as well ban truly dead data.
00:45:22.804 - 00:45:23.584, Speaker E: Yeah.
00:45:26.804 - 00:45:34.224, Speaker A: All right, so I'll write a pr for that. Other items review updates to the true cost of ext call with value. Let me share this.
00:45:37.164 - 00:45:43.664, Speaker H: Let's bubble here anymore. I think.
00:45:44.724 - 00:46:08.488, Speaker A: Yeah. Um. I know I need to rewrite the gas costing in the ext call sections for Basu. So one thing I noticed is the 23 that comes in here does have side effects on the 164th it gets retained. This is. Yeah, this is a different formula. G minus max.
00:46:08.488 - 00:46:16.264, Speaker A: There's. It subtly impacts. And I think this is just a Baesu issue only to be honest. So I wouldn't worry about it for the clients.
00:46:18.724 - 00:46:35.784, Speaker H: I think that the 6700 versus the nine. Can you scroll down to the bottom? Because I remember, oh, there's this table, this latter table. It's kind of simpler. And here the difference between the two stands out in the cell.
00:46:38.354 - 00:46:38.746, Speaker A: In the.
00:46:38.770 - 00:46:54.574, Speaker H: Top left corner which is the 6700 versus the 9000. Right. And I think what. I don't want to speak for him, but I think this is. This is the main point here.
00:47:06.294 - 00:47:39.854, Speaker A: Okay. As we get into implementation and gas testing I'm sure we'll see these. These issues. The difference is 23 is return versus 23 is not returned because we don't do the refund or do the retained section. Anyway. Any comments or hands on this? Is there any change required from this?
00:47:42.714 - 00:47:46.594, Speaker H: Can you scrub scroll back up? Because I think.
00:47:46.634 - 00:47:55.574, Speaker C: No. So the final conclusion of parallel was to keep spec as is. And here the declarification to eap which was merged today.
00:47:56.164 - 00:47:57.024, Speaker A: Okay.
00:47:57.364 - 00:47:58.224, Speaker H: Okay.
00:48:01.484 - 00:48:02.420, Speaker A: All right, cool.
00:48:02.452 - 00:48:05.664, Speaker H: So this is just informational, right in the agenda.
00:48:05.964 - 00:48:33.928, Speaker A: Yeah. And this will show up as we execute our tests and gather with gas differences. We'll see this and see we need to rewrite it. Return data, zero padding. And three weeks ago, I think there's still no consensus which way to go on this.
00:48:34.096 - 00:48:46.484, Speaker E: I thought was somebody was going to submit an alternate pull request with the new opcode instead of changing the behavior of the opcode.
00:48:49.484 - 00:49:00.024, Speaker A: That would have been evm one. If there. If I think decision was if there was going to be change it would be a new opcode. But I don't know that we're going to introduce it in mega because we're already high on the opcode budget.
00:49:02.044 - 00:49:06.064, Speaker E: Well, we would ban the old ones or, sorry, deprecated.
00:49:06.884 - 00:49:07.624, Speaker A: Right.
00:49:09.884 - 00:49:15.344, Speaker E: I'm very skeptical that there is an issue. Go ahead, Alex.
00:49:19.724 - 00:49:44.464, Speaker D: I think just wanted to relate that. But correct me if I'm wrong, Ipsilon. I think our consensus was that we were mostly leaning towards to have the new specific opcodes because that's more consistent with everything. If you make return data copy one exception, then why don't we make the others the exceptions as well yeah correct.
00:49:44.504 - 00:49:52.724, Speaker H: If we make the return that the copy change we were more in favor of having us as a return data copy two or whatever it's called.
00:49:55.464 - 00:50:01.844, Speaker A: Do we want that omega or do we want to hold off until a future release? To add that is the next question. And do we want to change return data load.
00:50:08.644 - 00:50:15.744, Speaker D: I would rate it in mega we are removing the creator contract and all that so you know maybe we're in better spot.
00:50:17.404 - 00:50:23.412, Speaker E: Why don't we. Why don't we just change the old opcodes like I don't actually see a.
00:50:23.428 - 00:50:39.364, Speaker A: Problem with it so what we just discussed in testing I think is one reason not to do it we can take old tests put it in the wrapper and expect it to behave in the same semantics. So I think that's one argument for not changing old opcodes is then we can't do that anymore.
00:50:40.624 - 00:51:24.444, Speaker E: But you can't do it with the old opcodes that are deprecated anyways like call and friends are like banned so you can't just wrap any code with and like if you think about it from like the opcode emission like now we have to like maintain two tables. Like one is. One is a table of opcodes for EOF and then. But they like. But it's like just to do the same thing that's just my perspective I'm fine with either way but I just. I think it's fine to be honest.
00:51:25.464 - 00:52:00.746, Speaker A: We have to maintain multiple tables anyway for like different forks. And what a lot of the code at least invasive and get that I've seen is in addition to adding it to the opcode table when we do the switches we also put defensive code in there checking for forks in some cases say well if I'm before this fork treat it as an invalid instruction. And so it is the sort of logic that we need to support doing something slightly different in a new version of EOF is already littered across client code already for the way that we do our fork upgrades adding opcodes.
00:52:00.770 - 00:52:18.374, Speaker E: I argue that it's super way cleaner just to change opcode semantics in the big breaking change because you just have a table of changed opcodes and then whenever you hit one of those you just look it up if it's in the change table and you do the new behavior.
00:52:22.294 - 00:52:23.194, Speaker A: Okay.
00:52:29.534 - 00:52:47.614, Speaker E: But yeah I'm fine with it either way I'm a little busy so if somebody else wants to submit the return data copy with the new opcode new allocated instruction go for it and then okay we can decide on which one.
00:52:50.754 - 00:53:11.234, Speaker A: Okay, I think we talked about tune already. Oh, and this last one increase min retained gas. Do we need to do this? Paul's not here. Alex.
00:53:16.094 - 00:53:35.194, Speaker D: I think Paul made some analysis and he. I think this was kind of connected to the other one, probably if. Yeah, I mean, whatever update he made to the AIP covers both of these, I would say, but I'm not 100% certain.
00:53:41.364 - 00:54:02.164, Speaker A: Okay, we'll keep these open unless there's changes, but if there's changes, we need to hear sooner rather than later, I think. Yes. EoFv zero in the last three minutes. Alex.
00:54:04.824 - 00:55:19.754, Speaker D: Yeah, so this is a proposal I think you made around December. The naming is kind of confusing and you can ignore it, but the whole point is to improve, have oracle tree store code, and hopefully by improving that it will also have a good positive effect on UFO. So the way worker trees currently store code is they do code chunking. They split the EVM code by every 31 bytes, and then they append a prefix byte, which is the first instruction offset, which is the offset of the first non data byte in that given 31 byte chunk. And this is needed in oracle trees because you may not have access to the entire code, you may only have certain chunks, and you still need to be able to tell whether a given byte is part of data or whether it's an actual instruction. And of course, the reason for this is jump test analysis. And so far, vertical trees are really just concerned with legacy bytecode.
00:55:19.754 - 00:56:05.164, Speaker D: As everyone is aware, there's some contention between a UF and oracle, which should go first. So this is the reason we looked into this. The goal of the proposal is to change basically this code chunking and remove, potentially remove code chunking. And instead of having it store the valid jamdest list in the workout tree. So this was, there were a number of, I think, three different options proposed back in December, but they weren't really optimal. The overhead they had were bigger than what the code chunking overhead is, which is, I think, 3.1 or 3.2%.
00:56:05.164 - 00:56:53.084, Speaker D: And then two weeks ago at this initial version of the proposal has been merged in the repository, in the epsilon UF repository. Let me just briefly link to it. And then two weeks ago we came up with a brand new version of this. Okay, so this is the merged version, and then the new version is this pr. So the new version overcame all these limitations and we have a encoding scheme for jump tests. So we turn this around. We actually don't store the valid jump test list, rather we store the invalid jump tests.
00:56:53.084 - 00:57:57.804, Speaker D: Only, and we employ a compression compression scheme to make sure that the data we store is the least amount we have to store. In the past week, Pavel has worked on analyzing the top thousand contracts according to Dune analytics, and that confirmed our hunches. So two weeks ago we only measured, I think, one of the Uniswap contracts in one of the arbitrum contracts. And the results were really encouraging because we got like 0.1% overhead and this hunch was kind of confirmed with the top 1000 contracts. And we have tuned the actual encoding values based on this analysis conducted this week, and the initial feedback from the workload team was positive. So TLDR, hopefully this scheme will be, maybe there needs to be some more refinement, but if it gets adopted by workload, then we're going to have a number of benefits.
00:57:57.804 - 00:59:07.742, Speaker D: So number one benefit is the legacy code overhead will be less. So instead of the 3% fixed 3% it could be 0% if there's no invalid jump test in the code or on the average case sub 1%. But for UF code in Oracle, the overhead will be zero because we don't need to store this. So that's the main positive outcome for UFO and the next positive outcomes for both cases is that by removing code chunking, there doesn't need to be special handling of code size in any of those cases. The worker tree currently, because of code chunking, has the code size and the code hash in a specific field. The code hash still is very useful because you wouldn't need to download all the code, but the code size was added as a necessity. This scheme basically simplifies a lot of these operations and paves the way for EOF and the last comment, which it's still debatable, what is the best option.
00:59:07.742 - 00:59:39.944, Speaker D: But this invalid jump desk table could be stored as a prefix to the code, and then we get to this UFv zero territory. But the other alternative is instead of prefixing it to the code, we dedicate worker leaves for this data, and we know what is the upper bound based on the code size limit. So we know how many leaves to dedicate and reserve. So that's the TLDR. I think the outcome would be very positive for us.
00:59:43.064 - 00:59:50.964, Speaker A: That's good to hear, and I'm interested. The vertical leaves has possibilities for code sections. We can store those in separate leaves too.
00:59:51.944 - 01:00:08.764, Speaker D: Yeah, exactly. So I just wanted to maybe do an intro and yeah, hopefully you can spend a bit more time, all of you, on the call, just to get a bit more familiar with this in the coming weeks.
01:00:10.144 - 01:00:10.928, Speaker A: Cool.
01:00:11.096 - 01:00:11.400, Speaker H: More.
01:00:11.432 - 01:00:35.084, Speaker A: More homework to read. We're out of time. What was it? There's something. Oh, one concern I have with Verkle. Are we really limited to contract size? Is that the current setup? Is there a limit to the size of contracts we could potentially ever do? I guess that's a vertical question.
01:00:37.704 - 01:00:50.804, Speaker D: They have discussions on changing the code size limit. Okay, so they're looking at 65k limit. I'm not sure based on what reasoning, but that's what we're looking at.
01:00:52.184 - 01:01:05.078, Speaker A: Yeah, that's. We're just changing. We're gonna have the problem. This is a discussion we should have with them next week. Okay. There's nothing else. We're over time.
01:01:05.078 - 01:01:25.558, Speaker A: I'd like to thank everyone for showing up and participating. This is great. Probably not going to have a meeting next week. Formally announced that on Monday. Once we figure out what our bearings are. But we'll definitely have a meeting in two weeks. Thanks, everyone for coming.
01:01:25.726 - 01:01:26.822, Speaker H: Thank you very much.
01:01:26.998 - 01:01:27.886, Speaker E: Thank you.
01:01:28.070 - 01:01:29.046, Speaker D: Thank you. Bye.
