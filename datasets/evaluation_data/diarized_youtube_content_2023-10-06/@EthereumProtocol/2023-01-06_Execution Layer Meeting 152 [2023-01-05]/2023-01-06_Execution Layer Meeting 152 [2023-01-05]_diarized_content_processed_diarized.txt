00:01:55.940 - 00:02:45.916, Speaker A: Hello. Good morning, everyone. Welcome to the first awkward dev execution now. So 152nd of these calls. Yeah, most of the stuff today is around Shanghai, so getting some updates on the status of withdrawal testing and devnets. There was spec change proposal for the limit and meter and itcode EIp. And I will go over and then following you up on EOF, seeing both where clients are at based on kind of the conversation from the last call, and also going over the different proposals that have come up since then, I can go over some testing stuff.
00:02:45.916 - 00:04:04.402, Speaker A: And finally there's EIP 4844, a proposal on the CL specs, and two new eips to discuss if we can get to those, I guess to kick it off, does anyone from either the testing or client teams want to give a quick update on where just withdrawal testing is at, where the different implementations are and what things look like in terms of devnets? Regarding the devnets, I could give an update, yes. So we currently have a devnet one running, and we started it just before Christmas. Currently we have all the different client combinations running on it, and some combinations work well, others are not really. I have the link posted in the chat here. So here we can see that we are on block 94,000, and most of the nodes are able to follow the header. Nice. And what's included in the implementation.
00:04:04.402 - 00:05:07.880, Speaker A: So I assume it's withdrawals and then these other small eips, but not EOF, is that correct? That is correct. Okay, sweet. Any other client team, anyone have thoughts on this or anything else they want to share? Okay. And Perry posted the spec versions we're targeting in the chat. So that's the CL spec 130 alpha two. And then on the El side, the withdrawal EIP we're using commit zero fa ADEC. All right, anything else just on withdrawals or devnets for Shanghai? We would like to begin a new one with UF included, but it is really up to the EL teams to be ready.
00:05:07.880 - 00:06:03.192, Speaker A: Got it? Yeah. Well, yeah, thank you, I guess. Before we get into eoF, I just wanted to quickly cover this change Powell had proposed for EIP 38 60. That changes one of the failures, and it seems like some get folks have approved this. Does anyone want to give a quick overview of what this is? Marius, I will pick on you because you're the first one who approved it, and I can't find power on the. God damn it. So basically we have different failure modes, either out of, out of gas or.
00:06:03.246 - 00:06:03.850, Speaker B: Just.
00:06:08.560 - 00:07:20.630, Speaker A: Or just return a zero. So either like, either we terminate the transaction context or we return a zero. Address. And if you look into the linked Ethereum magicians thread, you can see that these checks are like, they were like interwoven. So we had some out of gas checks before and then within a zero address return and then some other out of gas checks. And it just makes more sense to have them in one block and then have the other and the one that basically right now, the way it was specified, the init code size limit check would return address zero. But it also conceptually makes more sense to return error there because it means you're running up against the init code size limit, and that's clearly an error to me.
00:07:22.200 - 00:07:35.956, Speaker C: Yeah. It can also be seen semantically as if you can deploy any code size, but if you do it larger than cytes, it costs infinite amount of gas.
00:07:36.148 - 00:08:31.810, Speaker A: Right. Okay, I saw like yeah, get folks approved this pr oh, Aragon as well. Any client team disagree with this? Okay, so perfect. I guess we can go ahead and merge this in the next week or so and then update the test and the next devnet should also include this. Okay. Paol yes.
00:08:33.780 - 00:08:51.540, Speaker D: Sorry for being late. I wonder if there's any comments from the other side, I mean, contract developers, if they see that as a kind of issue to handle.
00:08:55.600 - 00:09:14.774, Speaker A: Does anyone on the call have an opinion about this contract slide? Do you want to block merging this until we figure that out, or is.
00:09:14.812 - 00:10:10.614, Speaker D: It better to just I'm also slightly in the favor of the proposed change. I think the client disagreed on, but I think the main reason it was the other way around was that most of the comments usually are on this generic level to return as user friendly errors as possible. That I think. What was the reason for the original design? Yeah, I'm not sure how much this applies here, but I wouldn't block it. But if there are some concerns, I don't know.
00:10:10.812 - 00:10:43.700, Speaker A: Yeah, I guess just because we want to move forward with withdrawals and it's all kind of intertwined, I would move forward with the change if no client teams has an objection. I think if we learn in the next few days or weeks that there is a big pushback by contract devs, we could always revert it back. It doesn't seem like a huge change, but yeah, I would try and go forward and merge it for now. Anyone disagree with that?
00:10:45.350 - 00:10:46.340, Speaker C: I agree.
00:10:47.510 - 00:11:25.838, Speaker A: Okay. And I'll try and give a shout for contract devs to look at it. So maybe we can wait until late Friday or Monday to merge it in. So it gives people at least a couple of days, but assume it's going in sweet okay, next thing is EOf. So I think there's like two things to unpack here. So first is the current status of the EOFV one implementation. So it makes sense to go over that, and then we can discuss kind of the different proposals that have come out since then.
00:11:25.838 - 00:11:47.030, Speaker A: So specifically, Vitalik had a proposal about banning code introspection on eth magicians. And then this morning, Alex just shared kind of a view of how that could all fit in in a broader EOF roadmap. But maybe just to start, do any of the client teams want to share kind of where they're at with their EOF implementations?
00:11:50.090 - 00:12:29.506, Speaker E: Maybe I can just give a really quick update. Also from what we did over the holidays, breakout rooms. So we did two breakout rooms over the holiday period, and there were two main spec outcomes from that, mostly from the first meeting. The first one was that we removed the jump f op code. It was something that we felt we just needed to spend more time, have solidity complete their implementation, and make sure that this was the perfect type of instruction that we were looking for. And so we removed it for now. So reduced the scope of EOF slightly by that.
00:12:29.506 - 00:13:12.682, Speaker E: And then we also made the data section mandatory. Previously it was optional, but making it mandatory made the parsing marginally simpler. So those are the two main spec changes. A handful of things were, other things were discussed, but those are the things that did make it into the spec. The Epsilon team spent a lot of time and I helped a bit with getting to the spec into a more finalized place. I think we've merged all of the outstanding PRs to the Eof eeps. There's still a handful of small things that, small errors in the spec, some conflicting things between the four or five eeps, but more or less like the aps are in a good place now with respect to the implementations and tests.
00:13:12.682 - 00:14:02.110, Speaker E: I think about a week and a half ago, a week ago, Martin started doing differential fuzzing across all of the clients, and that uncovered quite a few things. Initially, I think every client had at least like three, four bugs, and a lot of those things have been resolved. And if Martin wants to talk more about findings there, yeah, that would be great. But we also have two sets of reference tests. I don't think either of them have been officially released yet, but the Epsilon team has been working on a set of tests in ethereum tests, and Mario and I have been working on some tests in execution spec tests. Mario and I decided to not release them until we were able to integrate the Shanghai by time logic, but those tests are in this pr. I put a tar ball up before the meeting.
00:14:02.110 - 00:14:42.030, Speaker E: I think the reference tests are not as comprehensive as we ultimately will want them to be, but they're at a place that we can start getting an idea of where clients are. Unfortunately, I don't think that any clients other than the guest client has run all the tests. I ran the Epsilon tests a couple of days ago, passed all of them except for two or three, and obviously I filled the execution spec test, so we are passing all of those. So still need to get some clients to run those things. Yeah, I think that's mostly the update. I'm curious to hear what other client teams have to say about the progress of their implementations.
00:14:46.290 - 00:14:47.630, Speaker A: Maybe. Dano.
00:14:50.210 - 00:15:24.202, Speaker C: Basically we've started running reference tests. There was a spec change initially. You could go eof one to legacy willy nilly, so I need to update that. So you can only create Eof one out of Eof one. Those are most of the tests that are failing, trying to hold off on doing too many merges to reduce whatever prs that go into the actual mainline. So I'm stacking most of these into an EOF five breakout branch that I have. But yeah, we're basically in the checking all the boxes phases, making sure that it's all ready to go.
00:15:24.202 - 00:15:26.220, Speaker C: So we got major work all done.
00:15:27.550 - 00:15:54.704, Speaker A: Got it, thanks anyone from Nethermind or ergon. So we already have complete implementations for EOF tests are still not finalized. We're not sure which pr to pull and to run against.
00:15:54.822 - 00:15:56.896, Speaker D: We have ran against a couple of.
00:15:56.918 - 00:16:07.350, Speaker A: Them since that they're still not ready and does not cohere to the spec. So.
00:16:11.960 - 00:16:13.268, Speaker D: We would like the test to.
00:16:13.274 - 00:16:25.196, Speaker A: Be finalized before we start with the Devnet. Because if we start with the Devnet before running the tests and resolving the.
00:16:25.218 - 00:16:28.524, Speaker D: Issues, probably what will happen is that.
00:16:28.562 - 00:16:29.948, Speaker A: During the Devnet we will have a.
00:16:29.954 - 00:16:31.804, Speaker D: Lot of consensus issues and it will.
00:16:31.842 - 00:16:59.000, Speaker A: Take so much time to debug where these issues are. Yeah, basically that's the status, but for implementation wise we have done all of the implementations for all eeps and we are already passing the buzzer that light client was talking about. Got it. Thank you. Anyone from Aragon?
00:17:00.220 - 00:17:05.800, Speaker D: Yeah, for Aragon it's easy. We are going to piggyback on the guest implementation by light client.
00:17:06.460 - 00:17:14.910, Speaker A: Got it. Thanks Paol, I see you have your hand up. Is that related to.
00:17:15.920 - 00:18:21.280, Speaker D: Yes. So actually I wanted to give update about the tests a bit more specifically. So the test cases, I mean the state test, the execution test from Ethereum test. So the test cases are still divided into five groups coming from original eips, because that we kind of defined most of them previously, but the implementation actually has all of the EPS enabled. So the test case is kind of focused on specific aspect of UF, but you should expect all of other features also being enabled. And the current status is that this is like recent. We updated the first pack of that and this is already in the main branch of tests.
00:18:21.280 - 00:19:26.960, Speaker D: This is EIP 35 40. So this we consider ready, although EVM one and gas implementation I think doesn't agree on one of the tests. So this is one thing that we need to take a look on, but I think it's almost done this part. The second set of tests are ready but not merged, and two others are being in progress, and the final one is not started yet. So that's more or less the summary of the status. That's kind of trying to also answer one of the comments from 1 minute ago that I think as of today you can take a look on this first pack of tests that's already in the main branch.
00:19:30.770 - 00:19:43.920, Speaker A: Got it, thank you. Any other thoughts on the current status of just the implementations or the tests? I don't know if Martin, you wanted to give a quick update on the fuzzing work you did?
00:19:45.890 - 00:20:03.382, Speaker C: Well, not much. I'm trying to make the fuzzer a bit more advanced now, but essentially it's four different clients that are. Five different clients are being tested. Four.
00:20:03.436 - 00:20:04.040, Speaker A: Sorry.
00:20:05.130 - 00:20:06.760, Speaker C: And we have a pretty good.
00:20:09.230 - 00:20:09.642, Speaker A: It.
00:20:09.696 - 00:21:11.440, Speaker C: Turned out that the implementation of the container format and the validation is obviously fairly complex, judging by how many different types of implementation flaws were made. But also the validation turned out to be very easy to test and we defined this test format which just we can shove bytes as input and we can compare the outputs. So we get very good coverage of this. And I'm fairly confident that this type of testing will prove to be very efficient in the long term. What we have not tested is the actual semantics of running the code. So my fussing has done the validation of the code, but not the actual execution of the opcode. So that's for a later stage with status and stuff.
00:21:11.440 - 00:21:15.040, Speaker C: Yeah, that's about it for me.
00:21:15.730 - 00:22:41.450, Speaker A: Khaled, thank you. Okay, anything else on the current testing and implementations? Yeah, I would like to share the perspective on the execution test. So I've been working alongside like line with the other test suite for reference tests, and one thing that I really found is that it's not so easy to create an effective test case for EOF and the problem is that there are a lot of pitfalls. For example, if you want something to fail in a certain way in EOF, you have to be very specific and you have to make sure that the test doesn't fail somewhere else before reaching what you really want to test. So for that matter, I think that it will be really valuable that we standardize the errors somehow so we can verify that our tests are actual tests we are expecting them to test. Likeline has draft of the errors, but I don't know if you want to share that now or maybe sometime later. But I do really think that it would be really valuable to have that standardized over all the clients that are improving.
00:22:41.450 - 00:23:07.530, Speaker A: Thanks. Okay. And yet, like Klein just shared his notes in the test with all of the different error codes. There anything else to add on this?
00:23:11.440 - 00:23:22.770, Speaker C: I'd rather have the errors as readable strings so you can figure out what's going wrong rather than having to cross reference a table. That'd be one request, but standardizing the strings I think is fine.
00:23:25.670 - 00:24:09.834, Speaker A: Got it. Okay, two other things to talk about. So one is on the last call we said we might remove Eof if it wasn't quite ready today. And same thing for the next call. I think before we have that conversation, it's worth talking about the new EOF proposals that came out, just so we kind of have that in context when we make that decision. So I don't know, maybe it makes sense. Vitalik, you kind of posted this first one on eth magicians about code introspection, and then Alex, you just posted this morning kind of your plan based on that, but maybe.
00:24:09.834 - 00:24:12.490, Speaker A: Vitalik, if you want to go first, then we can do Alex.
00:24:13.630 - 00:24:15.870, Speaker F: Sure. Are you guys hearing me okay?
00:24:15.940 - 00:24:17.360, Speaker A: Yeah, it's pretty good.
00:24:17.730 - 00:25:25.620, Speaker F: Okay, great. So I think what I wanted to start with is just a bit of kind of philosophical backgrounds behind where some of the things I was saying they were coming from. Right. I think the difference between evolution and ongoing improvements of any kind to the EVM, at least as it's done so far, versus ongoing improvements to the rest of the Ethereum protocol, is that in the EVM it's much harder to remove things than it is to remove other features. Right? So like last year we managed to successfully remove a huge module, the entire proof of work consensus system, and that only led to very limited backwards compatibility issues for users and for applications. But on the other hand, with the EVM we have added a couple of opcodes. But when we have tried to actually change things or even remove things.
00:25:27.670 - 00:25:27.986, Speaker A: It.
00:25:28.008 - 00:27:15.542, Speaker F: Has happened a couple of times, but there have been very high costs. Right? So like for example, removing the self destruct top code is well on its way, but it's definitely something that altogether is probably taking five or ten times longer than a comparable change outside of the EVM would take. Or even the gas cost increases from two or three years ago ended up taking quite a bit of time. Right. And so the reason for that is basically kind of obvious, right? It's that you have applications that are written in EVM code, and if the EVM changes, then those applications can't change. Whereas if you're touching a part of the system that interacts with something on the outside, like for example, if we eventually get rid of RLP transaction formats, then that deals with something that's on the outside and that something can change. Right? And one of the things that I think would be, again, or one of my big worries with improvements to the EVM in particular, is basically that because it's much harder to deprecate and actually remove stuff, a philosophy of EVM developments that allows for basically a large amount of ongoing improvements and doesn't commit to something really close to ossification fairly soon would risk us basically creating a v two and then creating a v three and then creating a v four, but still requiring v one, v two and v three to still be part of the consensus code because we don't have good ways of removing them and because there are applications that are written that depend on them.
00:27:15.542 - 00:28:53.254, Speaker F: Right. And we kind of see this already with Callcode is probably a good example. We added delegate call, which is obviously better, but call code is still around. And the general path that I wanted to suggest as a way of getting around this issue and as a way of getting to the, basically letting us make some improvements to the EVM over time, but at the same time actually achieving the objective of making the EVM simpler and making the EVM cleaner and actually making the protocol more simple and more beautiful over time, instead of just having this kind of glob of ever increasing technical debt that we can't get rid of, is that if we're going to make a new EVM version, that new EVM version should be designed with the idea in mind that it's of being very forward compatible to all kinds of upgrades that we want to do in the future. Right? And the current EVM is totally not that in a whole bunch of ways, basically because the current EVM just has way too much introspection, right? So you have code reading upcodes and code reading opcodes let you read specific bytes of the code. You have the jump upcode, and the jump upcode can take as arguments a byte value that gets created by EVM execution. And so the jump destinations, like you can't actually rearrange them.
00:28:53.254 - 00:29:30.254, Speaker F: You have to keep the same byte in the exact same byte. You have things like contract creation and everything having to do with code being kind of closely referred to by its code hash. There's a whole bunch of EVM properties. Gas is also another one, right, where the fact that all of these EVM internals get exposed means that any attempts to change a whole bunch of things just inevitably becomes a very backwards incompatible.
00:29:30.302 - 00:29:30.514, Speaker A: Right?
00:29:30.552 - 00:30:40.370, Speaker F: And so the idea is that if we make a v two of the EVM, where that v two has the property that it has much less introspection, then what we gain the ability to do is we gain the ability to forcibly upgrade old contracts, right? So if we upgrade, let's say, evm v two, at some point in the future, v two to v three, then we could have a protocol rule that says, oh, when a contract that is still v two gets touched, then you can apply a transformation that converts v two code into v three code that has equivalent behavior. And because there isn't all of this crazy introspection, that it becomes actually possible to do that. Just to give a quick concrete example, let's say in v three, we decide having shot three or catch as an opcode was a mistake from day one. So let's get rid of catchack as an opcode, and let's move it over and make it a pre compile. Well, the problem with doing that is that you've replaced something which has one byte with something which has like ten to 20 bytes. And also you're going to need a memory slice for it somewhere. And so you're replacing a single byte with a byte sequence that's more complicated.
00:30:40.370 - 00:31:35.740, Speaker F: And so that ends up changing the code copy output, and that ends up changing the positions of all the code. And you could write out the transformation and do it, but only if all of this introspection doesn't exist, right? But if the introspection doesn't exist, then what you could do is actually write the transformation, potentially even formally prove that the transformed code has the exact same behavior under the new version that the pretransformed code has under the old version. And then after you would have a transition period where evm v two and evm v three are both available. And eventually actually let make sure that all v two contracts get poked and moved over into v three. And then once that happens, then it would be possible to eventually upgrade again and do a v four or something like that, right. And so what that would mean is that the number of EVM versions that clients at any point in time would have to actually support is kind of upper bounded at two. Right.
00:31:35.740 - 00:32:27.946, Speaker F: Once you go past three, then the third oldest version can just be fully deprecated. And one of the nice things about EOf as it is, is that it has features that go in that direction. So particularly getting rid of dynamic jumps. Getting rid of dynamic jumps is like a great move in that direction because it enables these code transformations, right? Like if you have to make a code transformation that replaces one byte with five bytes, then you can do that and you can translate all the coordinates. And you know that the reason why you can translate coordinates is because there no longer is a way to jump where you pass in the coordinate you're jumping to as an EVM generated variable. Right. And the inability to do that makes that kind of code transforming actually possible.
00:32:27.946 - 00:33:43.954, Speaker F: So my suggestion is basically, well, we could take the evolf route, but extend it a little bit, ban introspection and basically push it to the point where it goes all the way. It actually makes code much more transformable. So I guess the things that I would love to hear feedback on are one, just the general direction and the concept of moving toward this EVM approach, where basically we're committing that the first goal of upgrades is to upgrade to some kind of code which is much more locked down and not introspectable, with the specific goal of being upgradable more over time. And then actually saying, we are going to only need to have two versions supported by the actual EVM clients at any one time, unless they really care about verifying the channel all the way from history. And so that way we can keep upgrading and having things be sustainable. And the second thing is specific pathways for doing this. Right.
00:33:43.954 - 00:34:21.040, Speaker F: So my proposal basically would in practice involve delaying EOF and adding some significant stuff to EOF to make EOF itself be this. But another path might be to have the kind of current proposed Eof be a v two and then have a v three. And I think the v two would still be transformable into v three. You'd have to pay some costs, like doubling code size, but that would be fine. And then maybe there might be some other pathways as well. There we go.
00:34:47.490 - 00:34:48.560, Speaker B: Yeah, I do.
00:34:52.810 - 00:34:53.560, Speaker A: Yeah.
00:34:55.210 - 00:36:00.690, Speaker B: I'm not sure if I should actually go through the proposal in depth. Probably not because it's also quite lengthy. But I wanted to start. Yeah, I wanted to start with saying that we actually wanted to have a lot of these features generally which were mentioned going back basically last year. We did hope that some point to reduce the introspection options, which also means like getting rid of anything gas related. We wanted to also revise maybe memory handling at some point. And we kind of felt like that doing all of these in the same time is extremely ambitious.
00:36:00.690 - 00:37:01.960, Speaker B: And that was the reason we started to split up all of these changes into steps. One interesting point Vitalik mentioned regarding static jumps and code modification. That was actually one of the driving forces behind the relative jumps we have proposed in EOF. The inspiration there was optimism's code transformation where they were inserting code for external calls. They were replacing that with some kind of a guarded call. And basically that was the inspiration of how the jumps are designed in EOF, which basically allow code notification very easily. I think the main disagreement may be around the sheer size of these changes.
00:37:01.960 - 00:38:14.714, Speaker B: I think last year we never imagined that we would get to this point that EOF, all of these changes are considered at the same time because that many changes were never actually, at least it feels like this many changes were never applied in the same upgrade to the EVM and in the past, basically during December. I think the understanding is that we are probably at the limit of the number of changes we can safely make. It's not really just about testing time, but rather having confidence that we can cover all these changes. And I think the changes we have in the current version are less related to how opcodes operate and they're more related into just a general container format and validation. As a lot of this was already mentioned by Martin and others on this call regarding the updates. And so if we would consider splitting the kind of changes into two parts. The first part would be what we have currently under EOFV.
00:38:14.714 - 00:39:23.550, Speaker B: One which mostly considers the container format and validation, but doesn't actually change a large number of opcodes. It seems like we can with more confidence test these set of changes and then implement and test the second set of changes which revamp, I think a significant number of upcodes. In the document I shared. I took it actually further than just a canned code introspection because we had a number of features on the wish list which are kind of related. The reason code introspection is needed in contracts today is basically twofold. Most of the time they want to read data in the contract and the data can be just predefined data. But it can be also something called immutables in solidity.
00:39:23.550 - 00:40:19.890, Speaker B: Which in practice are data fields which are populated during the creation time. So during runtime they act as constant fields but they are still fields which are right ones during creation. And the other case where there is some kind of an introspection happening is creation itself. Because we don't really have a specific transaction format or specific separation of how code and constructor arguments are handled. The way this works today is it is just a practice by the solidity compiler. That it appends the constructor arguments at the end of the code. So basically the code has like three sections today during creation you have the Dnit code which is ran in the counter creation context.
00:40:19.890 - 00:40:49.978, Speaker B: Then there's like the runtime code concatenated after it. And finally it ends with any potential constructor arguments. And this was already on the wish list. Maybe we should revamp this. And I think this kind of ties into account code introspection. But this requires potentially new transaction format changes to the create upcodes. And if we do this kind of changes then I would propose that we actually go one step further.
00:40:49.978 - 00:41:42.110, Speaker B: And we also try to eliminate gas introspection. Which then boils down to redesigning how the coal opcodes operate. I gave some rough ideas regarding direction for all these changes in the document. But of course by no means these are few immature. Yeah, I just want to conclude that I think I see like three different paths we could go. One path obviously is just going with eofv one as it is without any changes. And then working on eofv two which may mean that there may be a few number of opcodes.
00:41:42.110 - 00:42:23.946, Speaker B: Which would have to be supported in v one and would be banned in v two. There is a second kind of path where we could decide that we disallow some opcodes like creation in v one. But we make a strong commitment that we want to make a decision on of how creation should work. And buy the next upgrade or soon after. And then we can choose two paths. We may end up thinking that the creation as it is is good enough. So we just enable the create opcodes SDR.
00:42:23.946 - 00:43:06.940, Speaker B: Or we could decide that we actually want to do this new version which was proposed in the document. And work on that instead. And the last path, what has been mentioned is practically delaying and delaying v one. And thinking about whether we could integrate the two changes into a single rollout. Or if not then it has to be two rollouts again. I personally don't think there's any potential way to roll all of these changes out at once, as I explained earlier. So that would mean that this would be delayed for two, three upgrades from today.
00:43:06.940 - 00:43:11.070, Speaker B: I think that's my long explainer of the document.
00:43:13.710 - 00:43:32.030, Speaker A: Thank you, I guess. Yeah. I'd be curious to hear people's thoughts about kind of this whole spilling of the roadmap, like, with just any reactions to Vitalik and Alex's proposals.
00:43:40.550 - 00:44:01.734, Speaker C: I think unless we have a solution to the current EVM and making it go away, which I do not see a path for that, we are always going to have to deal with at least this version of the EVM, even if we can make it. So we only have to deal with this version of the EVM, and then the latest, but not everything in between. We still have to deal with this version of the EVM, which is like the worst of all of the possible evms we could come up with.
00:44:01.772 - 00:44:01.974, Speaker F: Right.
00:44:02.012 - 00:44:28.580, Speaker C: Because it was the first one, didn't get it perfect on the first try. And as long as we have that problem, I feel like we have the general problem that we need to solve of multiple versions of the EVM. And if we've solved the general problem of multiple versions of the EVM in production, then it's not that big of a leap to just support all of the intermediate ones as well. I don't feel like we're gaining that much unless we can get rid of the current version, EPM, which, again, I don't see a path to that.
00:44:34.250 - 00:44:41.130, Speaker F: Inversions is a lot more than two, though, especially over time and especially over the 20 year long term.
00:44:42.430 - 00:45:41.680, Speaker C: Sure. So inversions is definitely worse than two versions, but I think that the difference between one and two is massive. The difference between two and three is very marginal, and the difference between three and 20 is a little bit more than marginal, but still nowhere near that first massive jump from one to two. And so the question then becomes, okay, so if we're not getting that big massive gain, we're only getting a series of intermediate kind of marginal gains, that maybe they do add up to some amount. Is it worth all the effort? There's a lot of effort that goes into this. Every single time we want to grid the EVM, we have to think about, okay, how do we transform everything? We have to actually solve that transformation problem for every EVM change, which is nontrivial, whereas if we just accept we have all these evms, then we don't have to deal with that problem. And so I'm just questioning, is it worth the effort? Which is pretty significant if we can't get that big gain from going from two to one, which I don't think we can get.
00:45:57.270 - 00:46:45.170, Speaker A: Yeah, I think it's very different. I think we should clearly already, the jump from having to support two to having to support three versions is like 50% jump in effort, right? So I would say I can see Axic's arguments on like, it is very hard to make such a big version jump at once. So I agree that is definitely a problem worth thinking about. But it's also really worth thinking about this continuous effort that's 50% more of having to support one extra version of the eBM if we implement your messages.
00:46:53.420 - 00:48:07.424, Speaker F: Vitalika yeah, I just wanted to kind of also again reiterate that this whole thing is a big decision and this whole thing involves irreversible decisions. And I think we should all remember that making the right decision for the 20 year or 40 year long term is much more important than not delaying things by six months or even one or two years. Right? This is definitely something that I think whichever decision is the right one really should be thought carefully about. And if we make an irreversible commitment of any kind, that commitment should, I think, have in mind the idea of what the actual path is going forward from there is going to be. I see, like I said in the messages, right decision for 20 to 40 years is ossification. I think if that's true, then what might even be an argument implying that the right decision today is to actually ossify and basically say the EVM is not going to change even starting tomorrow. Right.
00:48:07.424 - 00:48:15.910, Speaker F: But whatever the decision is, the long term should be, I think, really thought about as the primary issue. Right.
00:48:20.920 - 00:48:21.780, Speaker A: Andrew?
00:48:23.820 - 00:49:20.760, Speaker D: Yeah, I think I'm just afraid if we delay eof until it's perfect, then we lose the opportunity to get actual feedback because trying to make we can't get something theoretically possible perfect before actually putting it to test and to real use. To my mind, uf one is on one side it's big enough and on the other it delivers good improvements, especially to eliminates dynamic jumps. So yeah, if we try to make it perfect, then it will be like a never ending super project, especially without feedback from real contracts. I would deliver in steps.
00:49:21.420 - 00:49:24.040, Speaker A: Thanks Anzgar.
00:49:25.420 - 00:50:25.960, Speaker C: Yeah, so it seems to me that maybe one good path here would be, given that we are kind of shooting for a 4844 fork, I don't know, on the three, four months timeline after Shanghai, that maybe. It seems like enough people here have concerns about making a decision that locks us in for the next 20 years on such a rush timeline, like for Shanghai, we basically have to make that decision today that maybe the best course of action would be to pull it out of Shanghai, but kind of commit on kind of actively discussing this over the next few weeks and then basically making a decision on if we want to go ahead with v one as is, basically, then bundle it with four eight four. Make that decision basically quickly enough so we can bundle it. That would have to mean decision within the next three months or so. And if we within that timeline basically are not comfortable with moving ahead, then we can delay it further. But basically shooting for the four four eight for four bundle because otherwise it could slip and then easily, I think orbits off. Could easily slip.
00:50:25.960 - 00:50:26.670, Speaker C: Yes.
00:50:28.960 - 00:51:00.360, Speaker A: Yeah, I will emphasize that. I think if we don't want to delay withdrawal over this kind of like we decided, whether or not v one goes into Shanghai is a decision we basically have to make today. I think if we don't commit to that, then it won't, and then we can figure out what's the next step. If we don't do that. I guess I'd be curious to hear, just like from the other client teams, how you all feel about this. I'm not quite sure. Geth.
00:51:00.360 - 00:51:35.510, Speaker A: Marius, you had some comments in the chat, but might as well sort of stop following. But yeah. So I think the Geth team is kind of split on this. I can only speak to my personal opinion. I feel kind of rushed, I think, and I feel kind of pressured into making a decision on Eof now. And I don't think that's good. I have also not been following the process as closely as I maybe should have.
00:51:35.510 - 00:52:44.400, Speaker A: But from what I seen and heard, the spec was still changing or is still changing and the testing is not there where we would like to have it. And especially the fuzzing has found issues in multiple different clients. And usually we only find issues in like one or two, and then it's just the amount of issues and the severity of issues are kind of a concern to me. Generally. I think the splitting into EOF one and Eof v two is kind of a good idea, but I don't feel comfortable putting EOf v one into Shanghai right now. That's just my personal opinion, and I think some people within the GEF team might disagree. Does anyone in GEF want to take the opposing point of view?
00:52:46.370 - 00:53:34.430, Speaker E: I don't think I fully oppose that point of view. I think that the reality is that the timeline that we want for Shanghai is going to have to be extended a bit to support getting EOF testing into a place where people are comfortable making the upgrade. How long that is, I don't know. I don't think it's more than maybe one month's time. But that still brushes away the fact that we have these questions about code introspection and other small things that are irreversible, and people generally feel rushed. And I felt maybe one and a half months ago that by doing EOF in Shanghai we were pushing ourselves a bit as a development group. But it was something that was very much within our capacity.
00:53:34.430 - 00:54:08.540, Speaker E: And now I feel like we're kind of reaching what our capacity is to do. So if the timeline for Shanghai is not extended, then I don't think that, like, that we can responsibly ship this. It's a question of whether it's important enough to talk about extending the Shanghai deadline a few weeks, a month. But if we're trying to do mainnet testnet upgrades in the beginning of February, I don't think that we're going to be ready by then.
00:54:09.710 - 00:54:15.200, Speaker A: Got it. Thanks. Anyone from Nethermind or basically want to share?
00:54:18.530 - 00:54:52.246, Speaker C: So for me, the part where I thought it's probably going to slip is when we worked with solidity and discussed the needs of them being able to append their constructive parameters to the blobs. EOF was designed to be sealed, it's not designed to be extended at deploy time. So there would need to be design changes to support that. We could do a hack and say that it can be extended for nitcode only. Maybe we could enshrine that. But I think that's going to take more testing, and that discovery came fairly late in December. So this whole issue of introspection may or may not.
00:54:52.246 - 00:55:16.510, Speaker C: It did come up kind of late. I'm not sure if it's. What's the harm of making the entire initial deploy block the data block for it. I think there's ways around it that don't involve necessarily introspecting it and shutting down the copy. But as far as an actual practical usability, the whole inability to append constructor parameters, especially array types, I think is, for me, what warrants pushing it out to Cancun.
00:55:18.070 - 00:55:21.010, Speaker A: Got it. Thank you Andrew.
00:55:23.030 - 00:55:56.438, Speaker D: Yeah, I think that verifies my initial concern that we do need kind of a production ready solidity compiler into EOF, so that we actually are sure that it works fine with solidity. So I'm currently thinking might be a good idea to delay EOF to Cancun and make proper solidity compilation a requirement okay.
00:55:56.544 - 00:56:44.740, Speaker A: And then. Thank you. And then Eamonn from nethermine has also said rather not have EOF included now and would rather push it to Cancun from Lucas. So I think it's pretty clear that not including UF in Shanghai seems to be the consensus. Anyone strongly disagree with that? Okay. So I think it seems like because there's all these proposals that are kind of floating around, it's probably a bit early to make a decision about if and what we include in Cancun. I'd rather we at least wait like a call or two before deciding that.
00:56:44.740 - 00:57:27.150, Speaker A: And also just like, I think part of the kind of issue that arose with EOF is like, we made the decision to include it partially in Shanghai super early in the merge work, and then people were kind of caught off guard that this had been sort of included really early on. So I think it would be good to not make the same mistake here. Maybe on the next call we can decide to put it in Cancun, but I think it's good to have at least two more weeks for people to discuss all of this and whether or not they should be coupled with 4844 or a separate fork. I kind of saw you came off mute.
00:57:28.690 - 00:58:30.360, Speaker E: Yeah. I was just going to say that if we already had pretty good agreement to try and do EOF for Shanghai, I think it would be okay to just try know still have pretty good agreement that we're going to try and do it for Cancun and of like, we can make a call later on once we get closer and we realize what the situation is. But I would be curious if anyone feels strongly that they don't want to make a commitment that we're trying to do EOf for cancun because I don't want to get into the situation where we had with EOF. I don't think that we would have been able to realize these things about EOF without having all of the client teams implementing things and having as much momentum around EOF having solidity, like working on this implementation. And if we don't commit to it again in the future, then we're going to end up again a situation where we have just the Epsilon team working on it and then client teams look at it two months before they want to have it finalized and we realize these things and solidity starts working on too much for and we realize these things.
00:58:32.410 - 00:59:21.750, Speaker A: Right. Maris, I saw you had your hand up. Yes. I really don't like to do this because I think Uniswap has kind of been pushing this eap too hard. But with Uf out of Shanghai, I think we should consider 1153 to move to Shanghai. It's kind of a small change and it might be possible to be added to Shanghai. Okay, we can discuss that in like 510 minutes.
00:59:21.750 - 01:00:02.340, Speaker A: I just want to make sure we wrap up Eof property before. But sure, we can discuss anyways. Yeah, let's discuss that right after. I think. Just to come back on what Matt said, I think I agree that the momentum and the client focus has been really valuable and we should keep working on it as much as possible. I just would not want to commit it to the fork schedule right now. But I don't know if all the client teams feel strongly that we can go ahead.
01:00:02.340 - 01:00:05.540, Speaker A: Yeah, I don't know if there's any more thoughts on that.
01:00:09.480 - 01:00:16.576, Speaker E: I feel relatively strongly that we should make the commitment, but I don't know if others feel the opposite.
01:00:16.768 - 01:00:17.620, Speaker A: Andrew.
01:00:20.060 - 01:01:05.590, Speaker D: I think that we should. Well, my preference is still to split, not to try to reach a perfect state of EOF. We can try it, but I'm just afraid that too big a change in my opinion, it's better to move into smaller steps. But I would commit eof to Cancun. But with the requirement that we have a fully working solidity compiler into EOF and that solidity team is happy with it and everything works fine. And if that's not ready by Cancun, then well delay it even more.
01:01:08.920 - 01:01:10.020, Speaker A: Anskar?
01:01:12.520 - 01:01:47.596, Speaker C: Yeah. Just to say, basically, I do think it is important that we still kind of keep an open mind as to this whole kind of b one v two split and whether or not we would even want to do this. I don't know. I thought Aksey had good points on why it might be a good idea. But I think basically what we should commit on was just we should make sure that for Cancun, UF does not not get in because we are not ready. Again, we should at least if we end up not including it, it should be just because we decided that actually bundling everything into a combined b two is a sensible thing to do. There's enough time between now and Cancun.
01:01:47.596 - 01:01:53.110, Speaker C: I think that we should be able to fully explore and make that decision. So I think that's the commitment we should make.
01:01:56.990 - 01:02:00.300, Speaker A: Okay. And mudi, if you have your hand up as well.
01:02:01.390 - 01:02:27.700, Speaker D: Yeah, I just wanted to add that I think it would be good to do some real world gas testing for EOF just to actually measure the benefits before forcing out V one, just to make sure that there's an actual reason to use V one. And people won't just continue to use legacy code. And I'm actually working with Daniel from solidity to do that for v three. Hopefully we have some numbers there.
01:02:31.030 - 01:02:33.270, Speaker A: Got it. Alex?
01:02:36.570 - 01:02:54.880, Speaker B: Yeah, I mean, Daniel from solidity actually implemented all of the UFeips and ran benchmarks regarding gas. And even without having optimization steps, which means deduplicating and optimizing everything, even without that, it was using less.
01:03:02.850 - 01:04:12.960, Speaker A: Like, okay, just to not also spend the entire rest of the call on this. I think if here we want to remove EOF from Shanghai, I don't think waiting an extra two weeks to make a specific decision for Cancun will change anything or slow down the progressively. I think it's clear that client teams are working on this now and we should continue that. So I feel like we should kind of continue this conversation about Cancun and v one versus v two on the next call, but kind of leave it at that for today unless anyone feels there's anything else we didn't cover that's really important that we should go over now. Okay, so I'll do that. I'll do the change in the spec right after this call, the next thing. Okay, so, Marius, what you brought up, so if we do remove EOf from Shanghai, do we have the bandwidth to add anything else? And if so, what should we add? So after your comment, Marius, there were a couple of comments in the chat about we should probably just be removing stuff at this point.
01:04:12.960 - 01:04:36.760, Speaker A: Yeah. So I guess I'd be just curious to hear from client teams how they feel. Like, does any client team feel strongly that we should add things, or does everyone prefer only removing things at this point to keep the scope kind of in check? Dano.
01:04:37.820 - 01:04:56.960, Speaker C: So the reason for cutting it is so we don't delay things for withdrawals. And my concern is if we add anything that's something else that might delay withdrawals. Withdrawals is the driver of Shanghai. So whatever decision we make should be done with the point of getting withdrawals out as soon as possible. So based on that, adding things only adds risk.
01:05:02.510 - 01:05:10.350, Speaker A: Okay, so there's more basic support for cutting only? Some get support for cutting only. I don't know. Nether, mine, Aragon. Any strong opinions?
01:05:13.850 - 01:05:17.286, Speaker C: So this is about adding 1153 or.
01:05:17.468 - 01:05:22.060, Speaker A: Yeah, potentially 1153, but just generally adding things at all.
01:05:23.150 - 01:05:50.980, Speaker C: So if we want to add something, we should have a fairly minimal impact. 1153 might be in that minimal impact. If every team reviewed the code and the test, then it might be a minimal impact thing. But otherwise, probably we don't want to add it if it's not. It depends if every team can spend a bit of time reviewing it.
01:05:55.790 - 01:05:56.314, Speaker A: Got it.
01:05:56.352 - 01:06:02.880, Speaker D: And Aragon, no strong opinion on 1153. Fine. Either way.
01:06:07.570 - 01:06:08.270, Speaker F: So.
01:06:08.420 - 01:06:22.980, Speaker A: Okay. It seems like 1153 is like the only one that could be considered. Is this something that we need to make a decision about today? Or would people be more comfortable, like, thinking about this in the next two weeks and potentially making the decision then?
01:06:26.040 - 01:06:31.270, Speaker E: I feel like if we're targeting early February public testnets, we should make a decision now.
01:06:31.640 - 01:06:32.390, Speaker A: Okay.
01:06:35.820 - 01:06:56.000, Speaker C: Early February testnet is aggressive. Any new ads? I mean, taking up EOF is going to be enough risk, warranted risk. But I think adding something else that hasn't been part of previous test nets or structures, even something as good as 1153 is unnecessary risk, in my opinion, willing to be overridden, but I still think it's unnecessary risk.
01:06:56.500 - 01:07:22.692, Speaker A: Okay. And there's more comments from Nethermind in the chat as think. Okay, then let's just focus on removing EOf from Shanghai. Keeping the scope. Yeah, so we don't delay withdrawals. Okay. I think that's pretty much it for Shanghai.
01:07:22.692 - 01:07:54.088, Speaker A: Anything else on the fork that people wanted to discuss? Okay. If not, a couple other agenda items. Yap. Four, four four. I know there's been a couple community calls. I don't know if there's any updates that people wanted to discuss. Okay.
01:07:54.088 - 01:08:18.130, Speaker A: Nothing on four four four. There'll be another call next week where we can discuss this. There was a proposal by Ethan on the status team to add xre tri route in the execution payload. Heather, I don't know if Ethan is on the call right now.
01:08:18.980 - 01:08:20.592, Speaker D: Yes, I am.
01:08:20.726 - 01:08:21.890, Speaker A: Okay, awesome.
01:08:22.500 - 01:09:20.756, Speaker D: So the problem there is sort of related to Shanghai because it also affects withdrawals, but it's not strictly necessary to solve it with that work as well. So it is about light clients. They currently can follow a gossip topic to stay up to date with respect to the latest beacon block header from the consensus layer. And we would like to extend that to also include the El block header so that you can follow that passive stream. And then when you detect the block contains, for example, some locks that are relevant to your wallet, you can then request a proof. Hey, give me the token transfer that is related to that. I have prepared a little graphic here that I shared in the chat, this PDf file right now.
01:09:20.756 - 01:09:56.128, Speaker D: The issue is that to get that El block header, the CL block does not contain all the data. There are two fields in the El block header, namely the transactions route and the withdrawals route that are hexary try roots in the El block header. But in the CL execution payload, those hexery try roots, they are just missing because in the CL blocks. Thank you. Yes. For sharing. Yeah.
01:09:56.128 - 01:10:32.536, Speaker D: In the CL there is like the full transactions list and the full withdrawals list. The transactions, the individual transactions are still RLP. While on withdrawals, the actual withdrawals objects are actually also SSC. That also means that they are stored in little NDN integers and in gigaway. While in the EL withdrawals route it's named the same, but it's totally different. It's big NDN and in way. And it's a RLP encoding and then a Hexa retry route.
01:10:32.536 - 01:11:27.310, Speaker D: So it's not the same data that we have here. And when we want to do a proof for a transaction or a withdrawal, this then leads to a problem where the lie client, it only has the CL execution payload header from that gossip stream. But when it wants to request a transactions proof from a El, then the El cannot give it that. Yeah, and the other problem is that there is no way to validate that. The block hash within the execution payload header is correct right now as it's used. Not really a problem because we sort of trust the sync committee to only sign valid execution payload headers. But still, if you just have the headers want to validate them.
01:11:27.310 - 01:12:14.220, Speaker D: This feels like a bug to me. Yes. If it's possible to fix in Shanghai, sure. For the transactions, like this is the first approach. Can we sort of make it so that we use the same format everywhere? So for the transactions and the withdrawals that are currently stored on the CL as well, can we just use the same route on the El side? That would mean adding support for the SSC format to the El. I'm not sure how big of a problem that is. Right now there is this nice wall where everything on the El side is RLP and hexory and everything on the CL side is SSC.
01:12:14.220 - 01:13:38.020, Speaker D: But yeah, like if we can get it done to add this SSC library to the EL, then this would essentially eliminate everything, just single format for the same data. If we can do that, then we essentially need to find a way to get those additional hex roots from the CL servers to the CL lite clients. And the way that I have here is essentially that the CL could recompute them from the CL block because it knows all the transactions and withdrawals. But that would mean like adding all that legacy code for RLP hex retries and the Kesar hash to the CLS, which is kind of backwards in where we want to go. As far as I know, the SSC format is considered to be more modern. If there is a implementation that absolutely cannot do that, it could also request the EL block header via the engine API or the execution API. It's the same bus, but that would then compete with the bus that is also used for validator duties, so it may interfere with actual real critical operations.
01:13:38.020 - 01:14:44.216, Speaker D: I'm not sure how well that could be supported. The next slide basically avoids having to compute those on the CL by just extending the execution pillar that we get from the engine API to also include those hexery roots. SSC Hashree route of the transactions is just a simple binary tree. Yes, it is just a simple binary tree, and also as far as I know, those hexery tri routes, they are not exposed to the EVM. So there is nothing in the EVM unless someone re implements it has their own transaction proof system. But I think right now there is no way to extract a transactions route from a smart contract. But anyhow, this slide here basically extends the execution payload, the execution payload header.
01:14:44.216 - 01:15:57.220, Speaker D: It's an additional storage of 160 megabytes per year. Maybe not that big of a problem anymore with the 4444 history pruning, but avoids adding libraries to the CL. And this final slide says that we just ignore those two values at all instead of trying to get those transactions hex root and withdrawals Hexroot we just have those four minimal items, the parent hash state root block number and block hash. We give it to the EL, and the El then issues another network request to obtain the El block header based on then if it needs it. And then this sort of solves the problem of having this mismatch. But it also means that to operate on the transactions and withdrawals you need to request actively those additional fields from the server again so it adds load to the server. And it also means that you can no longer passively just follow the gossip to keep track of the latest El block header.
01:15:57.220 - 01:17:01.130, Speaker D: This is probably the quickest to do without too much changes, actually no changes at all, but it also just is the least flexible. And there is this EIP 4788 that will add the consensus layer state route to the yell block header. So it could in theory be possible to just base transactions and withdrawal proofs on that one, but they would need to be served by a Cl and no longer an El. So you have this situation where for some data you need to ask an El for a proof and for some other data. You need to ask a Cl for a proof. Because the EL doesn't know the entire beacon state, it cannot create such a proof for a transaction. There may also be split block storage where the transaction is simply no longer there on the CL.
01:17:01.130 - 01:17:38.390, Speaker D: And also this same issue reappears every time we add a new array. So transactions and withdrawals are the current two arrays that have this problem. But every time we add a new array, we have the same problem. Yeah, that's what I wanted to bring up. And I mean, the main question is, can we just transition those arrays to a SSC root in the El? Is that something where there is like a risk or a pushback or. Yeah.
01:17:43.080 - 01:18:00.910, Speaker C: I think the risk and pushback you're going to get from that is that external tooling might depend on that. So any tools to actually try to validate a block, for example, that aren't clients will all have to be fixed and changed. Deal with it. And that includes on chain contracts that do block validation will break.
01:18:04.240 - 01:18:41.470, Speaker D: Yes, I mean, that's true for the transactions, but the transactions, they could be sort of solved as a one off workaround by just adding it to the payload as well. But this is more about the new stuff, the withdrawals. Anything in the future that could be an array and the received route. Actually it is MPT, like it is a hex retry in both the CL and El. So that one is already consistent.
01:18:43.730 - 01:19:14.950, Speaker A: The receipts route would still be worth changing to a hash rate route. Any layer two that wants to access messages from a layer one reads these receipts. So making it easier to verify would be a big win. Also like messaging between different layer twos. Any EVM chain really, that emits an event. That event could be ingested by another EVM chain if the proof was just simple to verify.
01:19:21.270 - 01:19:45.980, Speaker D: Yeah, so there is this spectrum of only changing the new stuff, like only the withdrawals and the new arrays, or also the transactions route, because then we have all the fields covered where there is the inconsistency or even more than that, or also just nothing at all. So there is this entire scope, and I'm not sure which of the approaches we should follow on.
01:19:54.190 - 01:20:36.438, Speaker A: Just because we're almost at time and we have other things. Does it make sense to just move the conversation? To just move the conversation for this on the issue? Maris, we can go over you and then wrap up on this. Yeah, so I think we need some more time with the eldevs to discuss this offline. I don't think we can make a decision on it. Now and it's also not that important, I think, to make a decision on it now. We can change it next two weeks maybe. Okay.
01:20:36.438 - 01:20:39.338, Speaker A: Yeah. Michael? Yeah.
01:20:39.424 - 01:20:47.550, Speaker C: Doesn't that kind of go against the previous statement we made, which is we need to make decisions for what's in Shanghai today because by next week we're too late to make decisions for Shanghai.
01:20:48.210 - 01:20:56.670, Speaker A: Yeah, but that change doesn't really like, it only changes the block format. It doesn't change anything within the EVM.
01:20:59.970 - 01:21:05.220, Speaker C: Correct me. Clients have x. Not all execution clients have SSD capabilities yet, do they?
01:21:05.910 - 01:21:07.010, Speaker A: We don't.
01:21:08.810 - 01:21:33.180, Speaker C: That feels like potentially a significant delay, I don't know how much. So for net in mind. So we didn't have SSD implementation, but Alexa is working on something on EAp four eight four. So that might be reusable, but generally there isn't an SSD net implementation. General.
01:21:36.320 - 01:21:51.570, Speaker D: I feel like it is an important question and we shouldn't delay it. I mean, we can discuss it offline, but because it pertains to Shanghai and it is a design decision, it's quite urgent to my mind.
01:21:52.740 - 01:22:14.090, Speaker A: So how like. Yes, I think it makes sense for client teams to think about this offline. We can use the issue to discuss, we can put it on the agenda also for the CL call next week because it's also kind of relevant to them and at the very latest have a decision on the next all core devs for this. Does that make sense?
01:22:19.470 - 01:22:38.990, Speaker D: Yeah, but to my mind, because it is a design problem, I would prioritize it and try to fix it properly rather than be left with some technical debt. With the rose route.
01:22:42.760 - 01:22:43.316, Speaker A: Yeah.
01:22:43.418 - 01:22:46.796, Speaker B: One, a note for hesitant execution layered apps.
01:22:46.848 - 01:22:59.592, Speaker A: You don't really need to implement a generic SSD. If you only implement for these types, it's much easier. Got it. Okay.
01:22:59.646 - 01:23:23.970, Speaker D: Yeah. You need a withdrawal object and then you need those list of byte data. Basically that is the only support that you need. The transactions, they are still RLP. It's just the actual tree of transactions and the full withdrawals and their tree that would need the change.
01:23:25.620 - 01:24:18.310, Speaker A: And EIP code four already includes manual SSD manipulation anyway. Okay. So yeah, El teams can look at this pretty soon and then we'll make sure to add it on the agenda for next week's Cl call and hopefully have the decision before the next all core devs. But at the latest make a call then. Okay, we have 6 minutes left and like two eips that people wanted to briefly introduce. So let's try and take like three or 4 minutes on each of those and then we'll wrap up first. Jared, you had EIP 5843 you wanted to chat about.
01:24:18.310 - 01:24:40.908, Speaker A: Are you here, Jared? Okay, if not then Abdel, you had an EIP. EIP 5988, are you still here?
01:24:40.994 - 01:24:41.630, Speaker G: Yes.
01:24:42.160 - 01:24:44.380, Speaker A: Okay, so let's do 5988.
01:24:44.530 - 01:25:50.688, Speaker G: Yeah, we'll be short. So basically the idea of the EIP is to introduce a new precompile, which is Poseidon precompile. So poseidon is a decay friendly hash function. So basically it works with a set of permutations over a prime field and it makes it very well efficient in Zk context. And it will enable basically a bunch of interesting use cases, obviously for layer two and specifically Zk and validity roll ups, but not only what kind of use cases it can enable. So first you can use it as an efficient and cheap ways of doing some kind of data availability solution using Poseidon hash commitments. So obviously it's not as efficient as 4844 and the future data availability sampling solution.
01:25:50.688 - 01:27:06.200, Speaker G: But still it is an alternative solution for cheaper data availability using this new patch function. Also Zk rollups can use it as their main function for the state commitment of the state of their rollups. It can also be used for escape hatch. Basically each time we want to prove a storage proof like Merkel proof, it's very expensive on Ethereum because we don't have any Zk friendly hash function. So let's say for example you want to implement an escape hash system where if the system is frozen and you want to let the possibility to users to redraw their phones on the layer one, then you can use this system to implement an escape hatch system. This is what we plan to do for starnet and scroll is also planning to use it for their exit game mechanism. And also maybe in the long term we can use it for Ethereum itself, like having the ability to prove ethereum history inside ethereum.
01:27:06.200 - 01:28:02.680, Speaker G: So this would be particularly useful for storage proofs and light clients and also a lot of use cases. So this is for the potential use cases. There are also some interesting use cases on the DAP level, but mainly this is interesting for roll up operators. One important design concern is about how generic can it be. This is the main problem of the precompile, because with Poseyben you can use it with multiple parameters and many different actors are using different parameters. So we have multiple options. So either we can implement only a set of known instances and add new instances with hard forks, or we can try to make something generic.
01:28:02.680 - 01:28:48.200, Speaker G: Anyway, this is one thing to consider. Another important aspect is security, because those arithmetic hash functions are pretty new. So this is also something to consider. So Vitalik described a bit this thing in the KVG alternative article reward a month ago or something like that. In terms of implementation, we already have a c assembly implementation for X 86 architecture. We also started rest implementation. So there are already some implementation that exists, like for example the Fyikon one and others, but they are not generic enough to fit with all possible instances.
01:28:48.200 - 01:29:00.690, Speaker G: So yes, there is a generic aspect, the security aspect, and yeah, that's pretty much it. To be short, we have only 1 minute left, so I will stop there.
01:29:01.620 - 01:29:27.044, Speaker A: Thank you. Yeah, Denkrad, you've had your hand up. I think we can do your comment and then wrap up. Yeah, just a very short comment. So I would generally say, Sophia, it's a bit early to enshrine any arithmetic hash function in the EVM because of what you mentioned, security concerns and we just don't know enough about them yet. So I would generally feel it's premature at this point. Got it.
01:29:27.044 - 01:30:09.750, Speaker A: And then there's an east magicians thread linked to the EIP for people to discuss this further. Yeah. Anything else before we wrap up? Okay. And I guess if people want to check out Jared's EIP async, it has to do with EVM modular arithmetics, which was proposed a while back as EVM 384. So I just posted the link for that in the chat as well. Yeah, I guess that's it. Thanks everyone for coming on and see you all on this week's Cl call.
01:30:09.750 - 01:30:13.332, Speaker A: Thank you, bye.
01:30:13.476 - 01:30:18.040, Speaker D: Thank you, thank you. Bye bye.
01:30:20.300 - 01:30:26.420, Speaker A: Bye. Thank you. Bye. Have a great one. Bye.
