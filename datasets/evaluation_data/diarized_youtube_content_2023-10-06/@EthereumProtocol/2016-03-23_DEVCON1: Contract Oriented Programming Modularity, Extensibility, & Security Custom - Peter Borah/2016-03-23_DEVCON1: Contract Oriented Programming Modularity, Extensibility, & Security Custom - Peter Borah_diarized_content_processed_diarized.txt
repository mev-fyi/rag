00:00:19.220 - 00:00:41.488, Speaker A: Hello, thank you guys for coming. So my name is Peter Bora. As you said, I'm a smart contract developer with. I've been writing smart contracts since proof of concept five and I've been working with consensus doing that professionally since about January. My major projects have been the DAP store, which is what it sounds like. You'll hear more about that tomorrow. My colleague Tim is presenting on that.
00:00:41.488 - 00:01:20.076, Speaker A: And then a programming game called Dow wars, which is intended to teach people how to program smart contracts. So you create the AI for a creature that lives in an artificial world and you do it all with smart contracts. So I'm going to take this opportunity to announce there's an alpha available. If you go to GitHub.com consensusdawars, then you can see the creatures moving around and add your own. So what I'm going to talk about today is the idea that contracts are a new type of abstraction. As programmers we use a variety of important abstractions like objects, like classes, like functions.
00:01:20.076 - 00:01:59.144, Speaker A: And I would argue that the contract is equally important to these abstractions that we're used to. So it's similar to other abstractions, it's not that different from an object, but it has some important unique properties. So one of those unique properties is that it's permanent. Once you put a contract up on the blockchain, it's going to stay there unless you do something to take it down. Now you can force it to destroy itself, but it's not going to go away through neglect. By default, it's going to stay up there, and that's a big deal. If you think about an object in Amazon's database that represents some book, that object is going to go away if they pull the plug.
00:01:59.144 - 00:02:23.228, Speaker A: If Amazon goes out of business, their database is shut down. That object no longer exists. And that's not true with a contract. If ether, Amazon puts up a book, it's going to stay there unless they do something active to take it down. And that's a big difference. The second big difference is that contracts are public. So a contract is going to be publicly visible, all the data is going to be publicly visible, and all the functions are going to be callable by anyone.
00:02:23.228 - 00:02:55.576, Speaker A: And that's also a big deal. If you think about that book in Amazon's database, you are not getting access to that object. At best you might have some HTTP API where you can influence the structure of that object, but you're definitely not going to be able to access it directly. So a contract gives you a built in API more or less and is automatically public. And that's another big deal. So a lot of the other talks at this conference are going to go over why this stuff is important, what the effects of all of this is. So I'm not going to go into that too much, but just for a flavor.
00:02:55.576 - 00:03:49.112, Speaker A: At my last job I worked for Braintree payments and we were a credit card API company, and according to PayPal, we were an 800 million dollar company because that's what they bought us for. And all we did was translate calls from ecommerce sites to things that the banks would be able to understand. We were purely an intermediary helping ecommerce sites interact with banks, and that was apparently an 800 million dollar business. And we are far from the only people in that field with smart contracts. That sort of friction is not going to be there by default because of the fact that they're public and permanent. The interoperability possibilities are way higher than in the existing web, and this sort of thing will become unnecessary. So when you have a new abstraction that requires new practices, if you're developing in C plus plus, but you write it like C code, you're not taking advantage of the language.
00:03:49.112 - 00:04:20.408, Speaker A: If you're writing in Erlang and you make it all single threaded, you're not taking advantage of the language. You need to program in harmony with the abstractions your language gives you. So I want to start the conversation about how to program in harmony with this new abstraction. The contract and I have four principles. They're all pretty straightforward, all pretty simple, but I think they get us started down the path of figuring out how we can best program in harmony with the idea of a contract. So my first principle, I'm just going to go right into it. My first principle is you need to expose your data.
00:04:20.408 - 00:04:55.776, Speaker A: And that sounds really simple, but it's actually incredibly crucial, because one of the big benefits of contracts is the fact that they can interoperate, that contracts can talk to other contracts and get information from them, and that lets us do powerful things. But if we don't expose your data, you're going to have problems. So here's an example of what I consider to be a problematic contract. So it's a very, very simple crowdfunding contract, similar to other ones, except with less functionality. You can contribute to it if you're the owner, you can get the money out at the end, and it's reasonable. It does what it should do more or less. But I think this has a fatal flaw.
00:04:55.776 - 00:05:33.792, Speaker A: And that fatal flaw is lines two through six. All of these data structures that are what is being stored in this contract, they're all private. There's no way to access any of that information. The only two things another contract can do with this contract is send a contribution or claim the amount at the end, and you can't get access to any other information, can't have any other way to interact with it. Now of course, all the data is public in the sense that a blockchain explorer can look at it all. So it's not actually private, but it is inaccessible to other contracts. And I think that's a big problem.
00:05:33.792 - 00:06:08.724, Speaker A: So all we have to do to fix that is we add the solidity keyword public and it automatically gives us the nice access or functions other contracts can call our data. That's a tiny change, but it makes all the difference because now we can do things like this. So this is a token that uses as its basis that crowdfunding contract. So say it's an equity crowdfunding, and you get a percentage of the company based on the money you put in, and so you need a token to represent that. Or maybe you're buying some good and you have a good that represents a coupon. What this token does, it's a pretty simple token contract. Line 17.
00:06:08.724 - 00:06:58.184, Speaker A: There's a send function that does what tokens should do. When you send it to someone else, your balance goes down, theirs goes up. But the magic happens in this claim function, what it essentially says, if you've never claimed your reward before, then the real magic is line 13, set your balance to the amount you contributed to the crowdfund. And because the data on the crowdfunding contract is public, we can do that, and we get a token that represents the contributions to the crowdfunder that's tradable, that has all the good features we want tokens to have, and we've built it on top of this crowdfunding contract with one line of code. And that's really powerful, and it only works if the data is public. So that's my first principle, expose your data. My second principle is don't discriminate, and specifically don't discriminate between humans and contracts.
00:06:58.184 - 00:07:23.376, Speaker A: So one of the really cool features of Ethereum is that both accounts and contracts have an address and can be more or less treated as the same. There's one important exception. Contracts can't initiate a transaction. They can never be the fundamental origin of a transaction. They can only respond to humans who are interacting with them. So you could build this crowdfunder token using transaction origin everywhere. Now that's the solidity keyword.
00:07:23.376 - 00:07:58.110, Speaker A: But essentially looking at the origin of the transaction, if you do this, that means that only humans can interact with this token. Only humans can own the token. Only humans can send the token. And that's a big problem. What if the contributor to the crowdfund is this contract? This contract implements an incredibly simple venture capital fund, line 15. It just forwards messages from the manager of the fund. So basically, the manager can just use this as a proxy and send things wherever he wants, but it keeps track of contributions, and in real life, it would do a bunch of other things.
00:07:58.110 - 00:08:42.664, Speaker A: So this function, or this contract could easily invest in a Crowdfund, especially if it's an equity crowdfund, and they'd want to get access to their token, they'd want to be able to make the money off of it. But if we built it like we did here with transaction origin, that becomes impossible. So all we have to do to fix it is replace transaction origin with message sender, which represents the most recent message, the individual message, which can be from another contract. And just by making that change, we've suddenly made our crowdfunding token ownable by contracts, and not just humans. And that's another big deal. So that's my second principle. Don't discriminate between humans and contracts, and specifically use message sender.
00:08:42.664 - 00:09:04.048, Speaker A: I have yet to come across a case where transaction origin was the thing I meant. I'm sure there is one. I'm sure some of you have examples, but in almost all cases, use message origin. Principle number three, keep your contracts small. I don't really mean small in length, although that can be good too. I mean, keep your contracts focused, keep your contracts doing one thing. And this is just general good programming principles.
00:09:04.048 - 00:09:51.444, Speaker A: We know this from object oriented programming as well. But I think it's especially important in the context of contracts because of all this interoperability that we're talking about. So here's an example of what you might want to do if you are building a crowdfunding campaign like our first one, but you want the money instead of going to an individual owner at the end, you want it to be handled in a democratic way. So at the end, in addition to all of the. So it has the same basic things that the crowdfunding contract had, but it's got this extra data about proposals, and it's got these functions that you can make a proposal and you can vote yes on a proposal, and if it gets over 50% on line 46, then it's enacted, the money gets sent to that place. So this is a good idea as something we might want to build. But in my opinion, it conflates two things.
00:09:51.444 - 00:10:19.044, Speaker A: It conflates the crowdfunding and the managing of the money. So a better pattern is to build our democratic crowdfunder using the crowdfunder contract that we already have. So, line 13. This crowdfunder creates its own crowd. This democratic crowdfunder creates its own crowdfunder contract. And what that lets us do is build things that are a lot more generic, a lot more abstract, a lot more flexible. So now there's a lot of different ways we could manage the money that comes out of a crowdfund.
00:10:19.044 - 00:10:41.436, Speaker A: We can do it democratically. We can do it with just one person controlling the money. But maybe we want to control the money with a futarky. Maybe we want to whatever. However we want to manage this money, if we keep the crowdfunding element and the managing of the money separate, then we have a lot more flexibility. We can get things to interoperate. Yeah.
00:10:41.436 - 00:11:04.164, Speaker A: And so here's the rest of that contract. So I think those three principles should be fairly uncontroversial. They're all pretty straightforward. They're very important, though. If we follow those principles, then I think we get a lot of benefits that we don't get if we don't follow them. My fourth principle might be slightly more controversial. It's that I think you should separate your logic and your data, specifically if you want to update your contracts.
00:11:04.164 - 00:11:42.192, Speaker A: So this is less important if you're putting a contract up there and you want to leave it there forever. But if you're going to give yourself the ability to modify your contract, which in many cases you'll want to do, then I think it becomes important to separate your logic and your data. Now, the reason I said this might be controversial is because to a lot of people, this is one of the big benefits of Ethereum, that you can combine the data and the logic so closely together. And I even agree with that. Having it all in one language is an incredibly powerful tool. It makes life a lot easier than if you have to translate from SQL into an object relational database. But there are many tools in programming that are both powerful and dangerous.
00:11:42.192 - 00:12:04.968, Speaker A: Anyone who's tried to use Ruby's method, missing to do magic knows how. That is both incredibly powerful and incredibly dangerous. And I think this is the same sort of thing. Logic and data living in the same layer is very powerful, but it's also potentially dangerous. So let's look at an example. So this venture fund that I said earlier was reasonable code. I think it might actually have a flaw.
00:12:04.968 - 00:12:49.412, Speaker A: That flaw is that all the data is stored in the same place. So what happens right now? It takes contributions on line ten and it just adds you to the list of contributors, says how much you've contributed. What happens if you're the manager and you want to close contributions with this contract, you can't do it. So you're going to have to give yourself. It's just going to keep taking contributions forever. So we might add the ability to close the contract, but there is a wide variety of things that the manager might want to do someday. And the problem is that even if the manager stopped treating this like it meant something, even if he stopped actually spending the money that gets sent there, the data is going to keep changing.
00:12:49.412 - 00:13:16.790, Speaker A: And there's no way to stop the data from changing as people send money to this contract. So one alternative would be you deploy a new contract and you send the money over there, you move all the contributor list, but you're going to have to do that manually. You're going to have to download the contributors from the blockchain. You're going to have to put it in some program that uploads it back. It's going to be slow, it's going to be expensive, it's going to be error prone. And also then the data is in a new place now. So any contracts built on top of this suddenly break.
00:13:16.790 - 00:13:48.924, Speaker A: So I think that's potentially a problem. So a pattern that gets around this is you create a new contract that handles the data. So this is a fund data contract that all it does is it stores data about contributors. But instead of also being the place where contributors actually contribute, it listens to an owner. It has an owner and it listens to that owner, and it adds whatever contributors the owner says to. And it doesn't have any knowledge of the actual process for becoming a contributor. It only stores the data.
00:13:48.924 - 00:14:31.112, Speaker A: And then our venture fund can look like this. It's very similar, but like on the line 13, it adds things to the fund data rather than directly into that contract storage. And the reason that I think this is potentially a powerful tool is because of line 20. This gives us a replace function where we can send it in the address of a replacement contract. And on the fund data contract, it's got this transfer ownership that lets you give, the owner can give it to a new owner. So line 21, it tells the fund data, hey, you have a new owner now it suicides itself and sends the money that it contains to the new owner and now the replacement has control over that data. But the data hasn't actually moved.
00:14:31.112 - 00:15:10.548, Speaker A: It still lives in the original fund data contract. It's still all intact, but the functionality around it has changed. And that's a very powerful tool if you want to give yourself that flexibility. So in a recent project, the DAP store, I've taken this to a pretty extreme place. The thing about adapt store is that it's all about the data, right? If you think if Google emailed you one day and said hey, we lost all the data about your Android app, all your reviews are gone, all your screenshots are gone, please upload it again, that wouldn't same. So it's all about the data and that data has to stay there. It has to stay in the same location.
00:15:10.548 - 00:15:49.424, Speaker A: It has to be immutable as best as possible. We can add to it whatever, but it needs to stay there. But also we want to be able to update the DAP store. We want to be able to add new features, new information if everything goes on ipfs, and we need both a URL and an IPFS address, and we want to store those as two separate things. And right now we're only storing one thing, we need to add that somehow. And if contracts are immutable so we can't do that easily. So what I've done here is I've built a very generic key value store that just has a mapping between keys and values for a bunch of entries.
00:15:49.424 - 00:16:21.840, Speaker A: So it's essentially mimicking like a MongoDB style database. And all it does is it has an owner who can send it, tell it to add or remove information, and then it does that. And that's all. And what this lets us do is the same thing we did in the previous example. We can store information in here and whatever information we want, and then we can replace the contracts that have the control over this contract when we need to, when we need to update things. And that's a really powerful tool. So I don't think that everyone needs to go to this extreme.
00:16:21.840 - 00:16:59.052, Speaker A: Not every project will require this level of genericness. And there are all clearly trade offs that I'm making here in order to do this, but I just wanted to show it as an example of the power of this way of doing things. And if you separate your contract and your data, you get flexibility in a way that is going to be really hard to get otherwise. So quick note about trustlessness. So you'll notice that I've been talking about updatability and so to a lot of people, that kind of goes against the purpose of Ethereum. The whole reason that we are interested in this stuff is because we can trust the contracts. We can believe that they're going to stay the same.
00:16:59.052 - 00:17:35.160, Speaker A: They're going to do what they're supposed to do. They're trustless. And I agree that's a very powerful property of Ethereum and something we want to keep around. However, remember principle number two, we're not distinguishing between humans and contracts, and so trustlessness can always be brought back. The owner of that contract could very well be another contract, and that contract can implement whatever logic we want. So if we want to give control over the contract and the updating of the contract to a futarky, that's a thing we can do. If we want to give it to multi sig between Vitalik and the electronic Freedom foundation and Microsoft, that's another thing we can do.
00:17:35.160 - 00:18:23.844, Speaker A: Whatever logic we need about how to make sure that updates to our contracts are in the best interest of everyone involved, that they're fulfilling the principles of the Ethereum worldview, we can always add that in. And so giving yourself the flexibility to update something is not the same as taking away trustlessness forever. Because of the properties of contracts, trustlessness is always an option, and no matter how much you try to get rid of it, you can always bring it back. So those are my principles. Expose your data, don't discriminate between humans and contracts. Keep your contract small. And if you want to have flexibility for updating your contract, separate your logic and your data.
00:18:23.844 - 00:18:40.470, Speaker A: So that's my talk. I'm looking forward to continuing the conversation over the next months and years. Feel free to come see me and talk to me about any of this stuff. You can email me at peterbor@gmail.com and my slides are available@slides.com. And that's my talk. Thank you very much.
