00:00:20.810 - 00:01:18.262, Speaker A: We want to show you how easy it is to create d decentralized application on Ethereum. And we will actually create a whole app from scratch in 1 hour at least. I hope that will work. And I will start explaining the mechanics of the application. Then Alex will explain something about the design principles, and Fabian will show you how to use the to create the user interface. So as we try to create an application that allows you to sell things over the Internet and, yeah, how would you usually do that? So Bob has some money and wants to buy an item from Alice. And one way would be for Alice to first send the item, but that could go wrong.
00:01:18.262 - 00:02:02.446, Speaker A: And the other way would be for Bob to first send the money, but that could also go wrong. And yeah, what you usually do is you use an escrow. So both sent their stuff to the escrow, but that could also go wrong. So let's do the same thing on Ethereum, where we have a smart contract that does exactly what it is programmed to do and it can never fail. But of course it's a bit more complicated because it has to interface with the real world. So we cannot really send the item to the contract, but we will do something else. And the idea is originally by Oleg.
00:02:02.446 - 00:03:04.626, Speaker A: And so what we do is the seller puts a deposit of two times the item value, and then Bob puts the same deposit into the contract, and then Alice sends the item to Bob. Okay, so at this point, for both Alice and Bob, it's impossible to withdraw the money from the contract. The only option Bob has is to say, yes, I received the item, it's exactly what you promised. So Bob can pull out his deposit and send the three other coins to Alice. And by that he has paid Alice and all got their deposits back. And the other option is for Alice. So if Bob says, that's not the item I bought, or if something goes wrong, Alice can refund Bob.
00:03:04.626 - 00:03:24.040, Speaker A: So that's the only option for Alice, and then both get their deposit back. Okay, so that's the model. Now let's try to implement that. Did you switch that?
00:03:24.410 - 00:03:56.280, Speaker B: Yes, it should be. I'm going to do it, and I'm going to switch to the keyboard too. So display arrangement, mirror display. So now everything is mirrored. And now the keyboard is for keyboard. And let's go here.
00:03:57.290 - 00:03:58.040, Speaker A: Okay.
00:03:58.570 - 00:03:59.800, Speaker B: Yeah, it's here.
00:04:00.810 - 00:04:59.180, Speaker A: Okay, so this is the thing called browser solidity. You might have seen it. That's an offline and online Javascript application which includes the solidity browser, the solidity compiler. So it will show us any errors we do when we write the contract. Okay, let's start with a function called the function that has the name, same name as the contract, which will be the constructor, which will be called when the contract is created. What it does is it registers the person that created the contract as the seller. And MSG sender is a variable that contains the address that's called a function.
00:04:59.180 - 00:06:26.962, Speaker A: And we said Alice is required to put a deposit. We will determine the price of the item automatically by the half of the deposit. Okay, then what can Bob do? This can be called by Bob. So let's register the buyer as the sender of that message. Sorry. And we check that he also sent the deposit. Okay, what happens here is this throw keyword.
00:06:26.962 - 00:07:27.648, Speaker A: When that is executed, then an exception is created. And the effect of an exception is that the whole transaction is reverted. So if Bob does not send the correct value together with this function call, then this will not have any effect at all. And the money he sent will be automatically sent back to Bob. After Bob has confirmed the purchase, Alice will send the item and the next thing Bob can do is confirm that he received the item. We have to check that this function is only called by Bob because when Alice calls the function, then it's kind of missing the point.
00:07:27.814 - 00:07:28.530, Speaker C: So.
00:07:34.740 - 00:08:30.600, Speaker A: We'Ll do the same thing here. And we said that when Bob confirms the purchase, then Alice will get her deposit back. She will receive the price and Bob will get his deposit back. So we'll send once the value to Bob, sorry. And it might be that by some mistake, some more money is left in the contract. So we'll just send to Alice all we have left. You can use this balance for that.
00:08:30.600 - 00:10:23.120, Speaker A: Okay, what is missing now is that we, so at the current point, confirm received can be called before confirm purchase. This is bad. So we will turn this contract into kind of state machine, and the three states are created, confirmed and disabled. And we will add a variable of this type that holds the current state and confirm purchase can only be called in state created. And confirm received can only be called in state confirmed. And of course the states change accordingly. And then the other option we had was that Alice, we do not have to initialize state here in the constructor because it's automatically set to the first value of the enum, so it's automatically created.
00:10:23.120 - 00:10:48.040, Speaker A: And then Alice had this option to refund Bob. So this can only be called in state confirmed and only by the seller.
00:11:11.940 - 00:11:12.690, Speaker C: It.
00:11:13.060 - 00:12:06.370, Speaker A: Okay, how much time do you have? How much time do you have left? Okay, then we can still make this contract pretty, and use some more solidity features. So you notice that almost any, every function starts with if state equals something. If sender equal, does not equal something. So we have these guards, and their effect is always to revert the whole transaction because it was sent in an invalid way, it was called in an invalid way. And so the DD has this feature called modifiers, which is basically something like macros, some code that can be prepended or appended to the function code. And it's very convenient to implement these guards because it's also, you will see.
00:12:07.220 - 00:12:07.970, Speaker C: So.
00:12:11.460 - 00:13:03.250, Speaker A: We'Ll first start with a very general condition modifier. And if the condition is not met then it throws. And otherwise we have this underscore. And the meaning of the underscore is that at this point the body of the original function will be inserted. Oh yeah, we can use that in the constructor in a nice way because we divide by two here. And if the value Alice sent is not an even number, then it's kind of bad because we will lose one way. So we'll add a condition that MSG to value modulator two is zero.
00:13:03.250 - 00:14:26.194, Speaker A: And this will just prepend this. If the value is not zero, then throws to the constructor. And then we have a similar modifier instate which takes a state as argument. I would write it a bit shorter that we see more. So if the state is not s, then it throws, otherwise it continues the functionality. And we can also move that up. Here's so it looks much nicer now, I would say.
00:14:26.194 - 00:15:14.590, Speaker A: And here we also have instate confirmed. Oh yeah. So we said that only the buyer can call confirmed. So we'll add a modifier only buyer which checks that the sender is the buyer. No, does not reduce the size of contract. It will inline all the code.
00:15:17.600 - 00:15:18.350, Speaker C: So.
00:15:22.340 - 00:15:45.700, Speaker A: Modifiers are only a way to make it better visible what actually happens. So you can add these nice guards, you see. Oh, only the buyer can call that. You better see the logic and the stat. So confirm purchase can only be called. I know that assigns the buyer. Then we have this only confirmed.
00:15:58.240 - 00:15:58.990, Speaker C: It.
00:16:02.320 - 00:16:08.750, Speaker A: Notice all these arrows here when I type. So we do not have the modify only seller yet.
00:16:09.680 - 00:16:24.850, Speaker C: So just add it. No it.
00:16:41.800 - 00:17:06.590, Speaker A: Okay, and that's almost it. So this implements the whole logic of the contract. The only thing missing to make it nicer for Fabian later is events. So we need a way to notify the user interface if something changed inside of the contract. And I'm not sure if they will add all of them.
00:17:10.000 - 00:17:10.750, Speaker C: So.
00:17:25.140 - 00:18:09.580, Speaker A: What was the last thing received? So events are just. Yeah, they, they look like. They look kind of functions, but they don't have an implementation. And what they do is they store information on the blockchain in an index data structure, which makes it very easy to search for them. So you can just query the whole blockchain. Give me all blocks, give me all transactions where this event called refunded was executed. And you can also have watches on these events, which means that your user interface gets a callback from the node.
00:18:09.580 - 00:18:58.830, Speaker A: When a new block comes in that has this event, the audience is better. Is a very good spell checker. That's it. Can you work that? Perfect. Okay, thank you.
