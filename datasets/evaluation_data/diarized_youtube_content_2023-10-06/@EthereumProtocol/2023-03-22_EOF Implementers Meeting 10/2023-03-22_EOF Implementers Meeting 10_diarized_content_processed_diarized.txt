00:00:06.350 - 00:00:06.900, Speaker A: You.
00:00:08.870 - 00:00:25.060, Speaker B: Okay? Hey guys, welcome to the implementers call number ten. Yeah, just to get started today, let's go through some client updates, see what people have been up to since we last spoke. Does anybody want to get started?
00:00:29.400 - 00:00:35.150, Speaker C: I haven't done anything in the past two weeks. I've been distracted with another issue at Hadera, so that's a pretty easy one.
00:00:39.790 - 00:01:06.380, Speaker B: That is an easy one. Never mind, same for us. We haven't added a lot of stuff besides the address implementation for EIP six two six. Well, the jump f EIP and. Yeah, that's it. Great. Evm one.
00:01:12.450 - 00:01:24.850, Speaker A: Yeah, I can speak. We finally merged the EOF EIP, which implements everything according to the state of the Eips.
00:01:27.110 - 00:01:28.930, Speaker C: Eof or mega Eof?
00:01:29.830 - 00:02:05.920, Speaker A: No, the December version of EOF, so that pr is fully merged into EVM one. And I think we did implement single piece with the exception of the transaction format defined in mega UF in EVM one. And there's a handful of prs for that. I think there's four prs and those aren't merged, but they do seem to work. And yeah, outside of that, it was the spec work, which we did.
00:02:07.570 - 00:02:16.260, Speaker B: Awesome. Any updates on your go Ethereum branch that you've been maintaining or. Not so much.
00:02:19.830 - 00:02:46.506, Speaker A: I don't see Hugo on the call. I think Hugo updated the Goetheurium branch, changing everything to Cancun from Shanghai. And I think you did refill every single test using that. And there's a number of different prs open on the test repo with those refill tests. Yeah, I think that's it. Really?
00:02:46.688 - 00:02:57.598, Speaker B: Okay, cool. And the EVM one implementation is passing the field tests from that as well, so not exactly.
00:02:57.684 - 00:03:14.760, Speaker A: I think some bugs have been found. I'm not sure, maybe Raddock can talk about that. Yeah, Raddock is on the call. There may be some bugs in Ethereum and maybe some bugs in EVM one.
00:03:15.210 - 00:04:04.950, Speaker D: So today, actually, I recently run the state test on the EVM one and I found a couple of. Actually, there's six text, six tests failed, but they are related only to two different issues. One is that probably geth does not burn all the gas when the invalid UF construct is being deployed by the create instruction create opcode. And the second one is related to call f. And it looks that. Let me remind a minute. Okay, I don't remember now.
00:04:04.950 - 00:04:31.680, Speaker D: It's our chat described, but one is related to not burning all the gas, and the second one is related to. Okay, yeah, I remember with Colef for some reason, for a couple one test, the get implementation throws the stack overflow exception when it should not be from there and that's all.
00:04:32.530 - 00:04:55.420, Speaker B: Got it. Okay, thanks for those updates guys. Any other clients or things to mention for client updates? Okay, compiler updates, does anybody have anything to update? On the solidity front?
00:05:02.210 - 00:05:25.330, Speaker A: I think the only update is they haven't been doing anything extra since then. They do have the December version of UF implemented and now I think Daniel is waiting for a bit more confirmation on the direction before he will invest more time into implementing maybe new features.
00:05:29.130 - 00:05:45.100, Speaker B: Sweet. Let's move into spec updates. I know that you guys have prepared the Mega EOF endgame specification. Do you think you guys can take some time and share what's changed in the last few weeks?
00:05:48.980 - 00:06:53.796, Speaker A: Yeah, I can give a brief update. I think on the last call, or maybe the one before that we kind of agreed that we will make a PR to the EIP to describe the changes to the Eips to describe the changes, and we actually haven't done that. Instead we duplicated the unified spec and added all the changes to it. Initially we did that just for ourselves to have a record of all these changes, and now we could do a diff compared to the unified spec and extract it. But it seemed good enough for this conversation. And the background information is that we have spent almost the entire last week in in a personal meeting to discuss these features and to add it to this new document. And basically this specification includes all the changes we have been discussing, including this UF 1.1
00:06:53.796 - 00:08:11.220, Speaker A: and UF 2.0. So it is the final version we think we should be going towards, which includes non observability of code and gas, which implies these new create instructions. We do have two different create instructions. We have create three, which I believe we already kind of extensively discussed, and create four, which is this new version taking init code from the transaction, and this transaction, the change we have in the transactions. Similarly to 4844 blobs, we have a list of init codes, and these list of init codes can be accessed only through the create four instruction in a transaction context. And with this it is possible to actually not having the need to introduce a specific create transaction. And we also included in the appendix of this document a creator contract which would be using the create for instruction on this creator contract.
00:08:11.220 - 00:09:24.740, Speaker A: Basically anybody could deploy something like this, but we could also have a recommended version at a known address. Besides this, I think the only additions are the data opcodes for data load, data copy, data size, as well as the changes regarding the observability, which means the xcode changes there. We chose the version we kind of agreed to last time, which means if the target is EOF, then we treat it as if it was Ef zero zero, and then includes the delegate call change. There is one with the delegate call change. What was proposed is to disallow delegate calling. Which direction? I think Eof to legacy. Yeah, that was proposed, and in this version we chose to disable both directions due to unknown unknowns.
00:09:24.740 - 00:09:49.820, Speaker A: But there's already a comment on the document that maybe this is a bad idea because this would make it impossible to have upgradable contracts point to new EOF implementations. So this definitely is a point which needs to be discussed. Yeah, I think that's like the quicker summary.
00:09:54.090 - 00:10:22.980, Speaker B: Is it the case that if I delegate before this restriction was in where it was just a one way that if I delegate called EOF, that the EOF just can't ever delegate? I'm trying to wonder if you could have a legacy contract as like a front to an EOF contract and sort of use that to get around some of the EOF restrictions. But I guess that's sort of why you're looking into banning it both ways.
00:10:29.350 - 00:11:20.450, Speaker C: My concern, that was my comment on there. My concern is if we ban legacy from calling EOF delegate call is that anything that operates through a proxy, an upgradable proxy, will be locked out of EOF. They will have to continue to use legacy. And that puts a barrier in the idea of getting as many people to migrate to Eof as possible. So that's my concern with locking it from going into EOF, leaving EOF. It's demonstrated because you could leave EOF and do self destruct through a little nothing but a self destruct contract and get away with it. But I'm not seeing, since we're taking away features from EOF and not adding them, if there's an attack scenario, it's got to be pretty creative to go from a legacy proxy into EOF contract representing that proxy.
00:11:21.990 - 00:11:22.740, Speaker B: Right.
00:11:26.680 - 00:11:34.250, Speaker C: Because it's also a one way door and they can't come back out once the proxy goes in the EOF land to leave it. They'd have to do a regular call, not a delegate call.
00:11:41.680 - 00:12:08.950, Speaker B: Right? Yeah. I'm generally in favor of trying to avoid unknown unknowns, but it seems like in this case, because this is a pretty strong use case, being able to have your upgradable contract plan. Dof, maybe we should consider relaxing that restriction unless we find some more concrete evidence that it's not a safe thing to do.
00:12:16.380 - 00:12:27.290, Speaker A: Yeah, we had no clear case. We just aired on the side of caution. But yeah, this coming from Dano is definitely important.
00:12:29.580 - 00:13:20.430, Speaker B: Cool. Yeah, I mean, we should think more about this scenario, but I do think Dano's comments are pretty valid. Okay. Yeah, this is a lot of stuff. Awesome job assembling the specification with everything. Are there any outstanding questions still? I think on the agenda you said you wanted to talk about whether it was still an idea that these things should be rolled out separately, as in like an EOF one first and then EOf two, adding a bunch of the banning of it code introspection, or doing just all of the EOF features that you speced out in one go. Should we talk about that?
00:13:23.360 - 00:13:34.096, Speaker A: Yeah. So even before that bigger question, we do have like two or three smaller questions regarding the spec.
00:13:34.278 - 00:13:35.010, Speaker B: Okay.
00:13:37.060 - 00:14:34.470, Speaker A: We don't need to come to a decision on those, but I just wanted to highlight what these questions are. So one is obviously what was discussed is delegate call. So I think we're in a good track on that. Another question is regarding the test in it code list on the transaction, we need to decide on the limits and the cost of that. I have some ideas how to determine the limit based on whole data repricing eips and 4844, but yeah, we haven't done the work on that yet. So that's like one bigger piece missing, determining the limits and cost of the synat code list. Okay, what's another one? There was another one.
00:14:37.640 - 00:14:47.276, Speaker B: Is the init code expected to be validated as part of the transaction validity or is the initial only validated whenever it's invoked?
00:14:47.408 - 00:15:14.716, Speaker A: Okay, yeah, I think last time we decided that the create transaction, regarding the nons, we always include the transaction even if it has invalid uf code. And following that, we don't want to validate this right at the transaction level. We only want to validate it at the time it's used. Otherwise the cost would be also insane.
00:15:14.908 - 00:15:34.420, Speaker B: Yeah. So for the cost, would it probably just have to do with the data cost of the init code or is there. Okay, yeah, I think it's the question.
00:15:34.490 - 00:15:36.310, Speaker A: Slightly closer to call data.
00:15:36.840 - 00:15:45.450, Speaker B: Yeah, I mean, I guess the question is like where does it sit on the spectrum between call data and blob data? Probably much closer to call data.
00:15:45.980 - 00:16:00.072, Speaker A: Yeah, I think so. The only difference is that you cannot really copy it into memory. So it may be cheaper for that reason, but it's still accessible right in its entirety.
00:16:00.216 - 00:16:27.028, Speaker B: Yeah. And because it's accessible as part of block execution has to be propagated with the block. Whereas the blob data. The reason it can be cheaper is because it's only receiving, like, the hash of the data. I mean, I guess the nodes have to propagate it anyways. So there could be a debate on why the blob gas is going to be that much cheaper, but. Okay, fair point.
00:16:27.194 - 00:16:51.244, Speaker C: Aren't they designing? It seems like there's only one blob per block. I know that typically for a really large contract, there'd only be a few, tops, two contracts per block that they cost 6 million to deploy a 24k contract. But if we put in the blob, I'm concerned we'll break layers that they're trying to separate with this use case. So I'm in favor of call data treatment too.
00:16:51.442 - 00:16:55.852, Speaker B: Sorry, I'm just talking about the pricing of the blob.
00:16:55.916 - 00:16:56.300, Speaker C: Pricing.
00:16:56.380 - 00:17:07.680, Speaker B: It definitely has to be close to call data. It may not be called call data, but it has to be in the transaction. Whereas the blob only has, like, the blob transaction would just have the KCG commitments.
00:17:08.360 - 00:17:18.740, Speaker C: Okay, so if it's in transaction data, I think we charge the same payload rates as the input data. We just don't make it accessible via call data copy.
00:17:19.560 - 00:17:29.130, Speaker B: That seems like the safe route. And if there is an argument later on that we can reduce the cost of that because of X or Y, then we can make that happen.
00:17:32.560 - 00:18:22.040, Speaker A: Yeah. So this is one of the discussion points. And I think more importantly, the hashing. Basically the address generation of create three and three at four. That is a big question mark. We discussed this heavily at Adelweiss, but I think that needs to be revisited, because currently it takes the sender the salt and basically the init code, including the auxiliary data, which is the same as create two. But I think there were other ideas how to do hashing.
00:18:22.040 - 00:18:28.970, Speaker A: Yeah, I'm not sure we can reach to an agreement today on that.
00:18:31.180 - 00:18:32.170, Speaker B: Got it.
00:18:34.960 - 00:18:43.390, Speaker C: I mean, were people wanting to take out sender or something? What's the differences on those layouts? What are the hot issues?
00:18:46.020 - 00:19:03.780, Speaker A: I don't fully remember the discussions, but there is at least one implication. If you look at this creator contract idea, that means the sender would be the same if you use the creator contract.
00:19:06.840 - 00:19:12.280, Speaker C: Right. Which would break uniswap versus sushi swap assumptions.
00:19:15.520 - 00:20:07.364, Speaker A: Yeah, I mean, you could still have factories where the init code is already in the state where this is not problem. Because that's a sender. Was there one? Basically just the last question. The creator contract. But this kind of in conjunction with the hashing question. Yeah, I think the cost of danit codes in the transaction, that is something we can research async and come up with some price and agree on it. But this hashing probably requires more brainstorming and coordination.
00:20:07.364 - 00:20:09.400, Speaker A: Hashing at the creator contract.
00:20:13.740 - 00:20:28.790, Speaker B: Makes sense. Anything else on the spec? Small things to discuss before we talk about scope a little bit more.
00:20:36.720 - 00:20:40.930, Speaker A: I think. Nothing from my side but Andre or Radek. Do you guys have anything?
00:20:51.680 - 00:21:09.540, Speaker C: I had some questions about if they don't, about what we're doing with call and the 60, getting rid of gas. Is there a need to keep the 63 64th rule when sending all gas to the next call, or would we just be getting rid of stipends?
00:21:11.000 - 00:21:42.476, Speaker A: Yeah, I mean, I responded to this. I don't think there's a need to keep it. But if you keep it, the code, the implementation, it wouldn't be like a new path. I mean, not necessarily. And as we discussed in Adelweise, this 63 64 tool could be removed later without the breaking change to euf. And maybe for that reason, it's fine just to keep it, to reduce the scope, but I don't have a strong opinion.
00:21:42.668 - 00:21:43.410, Speaker B: Okay.
00:21:44.340 - 00:21:55.830, Speaker C: But we're not letting them specify the gas, which prevents the lockout. So we still have the feature that if they run out of gas, sending more gas will always fix that. It just changes the math on it.
00:21:56.600 - 00:21:57.350, Speaker A: Yeah.
00:21:59.720 - 00:22:12.990, Speaker C: Okay. That's the one feature I want out of. Getting rid of gas is to solve an out of gas problem. That setting more gas always fixes it. It might be an absurd amount of gas, but more gas will fix it.
00:22:35.190 - 00:23:11.790, Speaker B: Should we talk about scoping of Eof now? Cool. Okay. On the issue, you guys laid out this question, kind of trying to understand, does it still make sense to think about EOF in these two parts, or should we be pushing to have mega EOf go in as one complete unit? Curious to hear what your current thinking is on those two approaches.
00:23:20.420 - 00:23:25.248, Speaker A: You meant me. I mean, I do have an opinion, but I didn't want it to sway anyone.
00:23:25.334 - 00:23:35.990, Speaker B: So maybe if anyone not from Epsilon wants to share an opinion or we hear from them.
00:23:41.080 - 00:23:43.380, Speaker C: Mike. Oh, sorry. Go ahead, Adam.
00:23:44.440 - 00:23:46.730, Speaker B: No, just go ahead.
00:23:47.980 - 00:23:50.570, Speaker C: You actually raised your hand. I think you should go first.
00:23:51.020 - 00:24:13.020, Speaker B: Okay, thanks. Well, from nethermind, the sentiment is that we do want EOf to go in one unit without any intermediate steps or separated steps. Just one big Eof. Got it, Dano.
00:24:16.520 - 00:25:14.390, Speaker C: So for me, it's a scheduling thing. It's a question of when 48 44 is actually going to ship. If it's looking at a Q four mainet activation, I think we could conceivably get mega ready by then if we push hard. But I think another option we want to consider is if 48 44 is looking at a Q three main at activation, particularly early Q three, as in we start talking finalizing tests and closing out scope just as soon as the current hard fork, not Cancun. As soon as Shanghai ships, if they're going to start closing down scope, do we have an appetite for being the lead feature in Prague in a q? One of 24, I think is one thing we should consider. I am open to all these options and possibilities. I don't particularly have a favorite, but I think what's happening with 48 44, I think is going to determine our time frame more than anything.
00:25:15.560 - 00:26:13.064, Speaker B: Yeah, that's a fair point, and to be honest, we'll see how things play out with the scope of Cancun. But right now we're talking about doing a lot of changes to the block structure to make SSE. And I think if we end up doing those changes, changing the merck orders in the block and stuff, that's going to be a pretty large fork, including 44. So in my view, it's probably going to be difficult to push mega Elef and Matfork. But if Elef is going well, then I think it seems pretty reasonable that it could become the lead for prague. Because vertical trees, it's unclear where things are at with that. The last that I've heard from some people is that the numbers, the performance is still like two to three x too far away from where it needs to be.
00:26:13.064 - 00:26:59.610, Speaker B: So it's something that we could realistically be looking at doing early to bit next year as the leading thing, the leading part of work. But yeah, I guess generally I also like the idea of doing eof all in one go. My biggest fear is the test surface of that. It already felt whenever we were trying to close down the original EOf one for Shanghai that the testing scope was starting to reach the limits of what was feasible, and now we're adding 50% on top of that. It's probably just a function of how much time we can put into testing, but it's something that I do worry about a little bit.
00:27:05.430 - 00:28:08.680, Speaker C: So I wonder if we could still notionally have it split into Infinity War and Endgame, where we would not do create, we would not mess too much up with the call. We wouldn't do the big outside EVM changes, but we would focus on getting something that's December plus that adds all the features and turns everything off that would be needed in endgame and get testing and working on that and get solidity validating some of our assumptions. Because I think we would need to put in the problem there is how you introduce EOF into it, into the entire system. We wouldn't want to have the old legacy path. I like the idea of being able to get multiple steps to get at least testing written against it while we progress to the next future steps. I'm more gaming that in my mind. I'm not seeing how it necessarily works out well doing anything other than just doing it all in one go, because we can't test everything until it's complete.
00:28:08.680 - 00:28:21.820, Speaker C: You can test parts of it, but the infrastructure we're going to need to test it is going to change as we bring in the other parts later on. It's a question of how much testing infrastructure we want to put in place and tear down as we get the final in.
00:28:22.670 - 00:28:56.630, Speaker B: Yeah, I feel like generally it seems more efficient, even if it takes longer to get to testing, to just do all of the upfront development and then focus hard on testing, rather than having this back and forth where you implement some stuff, write some tests, implement some more stuff, write some tests. I think that ends up taking longer. I don't know if Mario has anything to add to that perspective or maybe a different perspective.
00:28:59.210 - 00:29:27.760, Speaker E: Well, I haven't been looking at Uf recently, but yes, so far my thoughts are that it's already quite complex to make an effective test case for EOF. So adding more stuff, I think it definitely is going to complicate testing a. I mean, I haven't seen the most recent changes to EOF, so I might be wrong, but yeah, from my past experience writing this on EF, it was complex already.
00:29:35.640 - 00:29:50.670, Speaker B: Okay. That's, I guess, kind of some of the perspective of the non Epsilon people. Do you guys want to share what you guys have been thinking since you guys super heads down on this last week or two?
00:29:56.190 - 00:31:06.080, Speaker A: Well, I can share my opinion. It sounds like a combined opinion of the team, but, yeah, I was personally leaning towards to introduce it at the same time. Otherwise, let me make it complicated. Um, but definitely concerned about the size of this, because even the December version was quite hefty. And unfortunately, this would go outside of the boundary of the EVM with the transaction change, which I think is the biggest worry for me. I think every single other change, just staying within the EVM, however big the changes are, I think it's more reasonable. But once we cross this boundary it becomes maybe not only just technically more challenging but coordination wise and getting it into the system.
00:31:06.080 - 00:31:59.840, Speaker A: Even just thinking about all these discussions on how many resources are allocated to any of these changes on the client. You know, so far, because we were within the EVM. The people working on EVM at each of the client teams were kind of separate. So there was little overlap in other changes. And once we get to changing transaction types maybe there's a bigger argument that this takes away resources from other proposals. Which maybe people think are more important than UF. If we do end up splitting however then I would still include the data opcodes in the first rollout because those are relatively simple.
00:31:59.840 - 00:32:55.760, Speaker A: And I would try to include most of the changes regarding observability like the x. Well yeah, I mean that's the hard part. But with including the data opcodes and removing the xcode and x and code opcodes. It is possible to create these immutables because you can read them with the data. And so the only change which would move to the second rollout is create three, create four and the transaction change. However, even if we split these into two rollouts I think we have to have the implementation of all of it ready and tested. And understanding the implications of these later changes.
00:32:55.760 - 00:33:24.228, Speaker A: And I think that's why it's good that we have this combined spec because we can understand how all of this operates together. And it seems it's easier to split after being sure that all of this is going to work together well yeah, so that's the answer and non answer what you're saying.
00:33:24.414 - 00:33:58.150, Speaker F: Sorry, I've never found the hand icon on this interface. What you're saying makes a lot of sense to me Alex. And I've said before, and I'll say it again anything that doesn't go in now there's no telling when there might be another mean. Our history is that it can take us years to get to a new release, a new upgrade. So I'd be very motivated to see that all go in soon.
00:34:06.140 - 00:35:18.844, Speaker C: So if we do the two step. I do like the idea that you do everything but to create opcodes so we have it fully functional within the system and the transaction changes because I could see that the full SSD transaction changes would slip out of Cancun just to get 4844 in it might be a major focus of Prague. So that would slip streap in very well because then we could activate create four. In fact we could probably even ship create three with it. There's a possibility we could do that deploying, because what we really lose by not shipping create is to have things like uniswap migrate over and the ones that depend on deploying contracts and maybe some dows that deploy worker contracts. And I think that's a huge use case that we need to be able to get to. But I think there's enough use case without those huge use cases that we could put it out there and show that these last pieces coming in, in the next release, because it requires integration with the transaction formats, but that it will be fully functional there and it can get people who are really interested in doing things like saving gas size and saving contract size.
00:35:18.844 - 00:35:58.830, Speaker C: I mean, getting rid of jump desk, some of the stats they brought up from the solidity team was you save 20% space just getting rid of jump desk alone, which increases, in effect, the amount of data you could put into a single mega contract. So if you could delegate into those contracts, you would have less need for the diamond pattern without having to increase the sizes. I still think, even without creed, I still think there's value to be shipped into halves, but at the same time, I would support either approach. I'm not opposed to going mega EOF, but I think, honestly, the scheduling that's going to come up in the next ACD, I think is really going to drive more of it than anything.
00:36:03.680 - 00:36:04.830, Speaker B: That makes sense.
00:36:05.280 - 00:36:05.788, Speaker A: I think.
00:36:05.794 - 00:37:51.070, Speaker B: I generally agree. So it seems like the takeaway for the most part here is to focus on mega EOF, try and see if it's possible to make this change happen all as one unit. And I guess in the back of our minds, keep an eye out for things that we might be able to push into, like a later release. If it comes to that point, if we're realizing maybe later on down the line that the scope is quite large, then we could cut off create four or create three and propose them for a future fork or something. Does that seem reasonable? Okay, guys, what else should we talk about? What other things do we need to consider to move uf forward? It seems like for the most part, the Epsilon team has been working really hard on the specification and it's getting into shape. And so the most likely thing seems, is that we just need to start making sure that we have implementations, and that's going to reveal places where things might be less specified or things that we might want to change, or are there other things that need to be done before we get there?
00:37:51.620 - 00:38:23.560, Speaker G: I would emphasize the need for test cases, right, because we depend on these test cases a lot to verify the implementations that we're working on and merging these implementations to our master branch. So before we have a working test cases, all these drafts that we are working on or whatever, they are just drafts, right? And they remain drafts in our eyes till we pass certain hive tests.
00:38:30.080 - 00:38:30.444, Speaker A: We.
00:38:30.482 - 00:38:38.270, Speaker G: Pass certain ethereum tests and stuff like that. So I think it's worth thinking about that.
00:38:38.640 - 00:39:31.280, Speaker B: Yeah, no, I agree. It's just that to generate those tests, we need to have a reference implementation built essentially. So that's kind of the place that we need to get to. I think that the implementations that people have been working on are mostly targeted on EOF 1.1. And you haven't really started working on UF mega EOF yet, but it seems like that's sort of the next step. I feel like we don't need to keep big eof in place. I think it's okay to ruin the current big UF or maybe make a copy of your old branch and leave it somewhere and start working on this future branch.
00:39:41.400 - 00:40:20.720, Speaker A: Yeah, I think the more annoying part is the testing in regards to what fork and had to choose any of this. I think what we're going towards is to implement all of these fork and coon in the tests. And if during the process it turns out that we need to reduce the scope, then we move like the create tests to a different fork. Yeah, I'm not sure if doing anything else seems to be an overkill.
00:40:21.780 - 00:40:48.992, Speaker B: No, I think that makes sense to me. Do you guys have an idea? Given the like, let's say this beck is sort of frozen modulo, maybe sorting out some of the gas prices for these things. What will it take to get this implemented in EVM one? So test can be filled? Is it two months? Is it one month more?
00:40:49.066 - 00:42:16.150, Speaker A: Andre can correct me because he's working on the create tree and return contract and data upcodes. I did an implementation of the delegate call and the xcode changes, and the xcode change took me 5 minutes. The delegate call took me another 5 minutes without creating unit tests. I think create three was a bit more work, but all of these are kind of implemented already, and I think these should not be too difficult to implement in any other client. The piece, which may be a bit more difficult, especially for EVM one, because it's really just concerned by the EVM and not anything else outside of that is create four. And likely testing for that may be a bit more complicated, but I think for everything outside of create four, we should be in a good position to start filling tests next week or the week after. So if any other team would be in a position to start implementing some of these and maybe collaborate on test cases, that may be a way forward.
00:42:16.150 - 00:42:34.110, Speaker A: And I think lastly on test we were looking into, I think Raddock is looking into it to use the execution spec test instead of just writing the regular test cases by hand.
00:42:37.810 - 00:43:22.970, Speaker B: Cool. Would you want to set target dates where you expect to have an initial set of test cases filled? Is that something that we could say that this time next month it doesn't have to be super comprehensive and test every edge case, but this time next month we have the specification quote unquote frozen so that we know what we're implementing and we have some tests filled that target that specification so that client teams can start updating their implementations to support these new features. Or would it be longer, like maybe the first week of May or something?
00:43:28.220 - 00:44:44.450, Speaker A: Yeah, I don't know the answer personally, but I really hope we should have some basic tests soon. I would say the priority now is to fix the current state test to pass with EVM one, and after that we can look into new test cases. But this reminded me one more question mark regarding the spec which came up today is the header with the embedded containers, and from a spec wise it makes sense to make them optional from implementation wise, I think Andre ran into a case where it would be so much simpler for the implementation to make them mandatory, but that comes with of course an overhead for non create contracts, which I personally don't think is a good way. But this goes back to the header discussions. In any case, it would be nice to have at least another client implementation go through the create tree and see what it translates into soon enough to help us with stabilizing the spec.
00:44:49.260 - 00:44:52.700, Speaker C: Do we have the header format? I didn't see that in the mega EOF.
00:44:54.080 - 00:44:58.780, Speaker A: Yeah, because we forgot to add it on the weekend and it was added this morning by Andre.
00:44:59.840 - 00:45:06.556, Speaker C: Cool. I mean, that's where I would start if I got freed up from my Hedera commitments.
00:45:06.668 - 00:45:09.148, Speaker A: I think we're going to be I'm.
00:45:09.164 - 00:45:13.990, Speaker C: Going to get more time to work on this definitely this week or I'm going to see to it.
00:45:33.070 - 00:46:02.620, Speaker B: Sure, there'll be more discussion as people dig more deeply into the Maggie UF spec, but seems like right now everybody is relatively satisfied. 10 minutes left. Any other things that we want to discuss? Seems like we have somewhat of a clear path forward for the next two weeks.
00:46:13.320 - 00:46:26.170, Speaker A: Yeah, a question who had the chance to read this mega EOf spec? I think Dano because you commented you likely read most of it, but did anybody else had a chance to read it yet.
00:46:30.700 - 00:46:34.490, Speaker B: Sort of glazed over most of it?
00:46:40.260 - 00:47:15.710, Speaker E: I haven't, but I have a question regarding the differences between this and the previous version, and this is regard because I have the atraft for the execution spec tests, but this is completely based on the previous UF version, so I have to pick up those tests and just upgrade them to the mega UF. So should I keep separate branches of the tests between the previous version and the mega UF, or how should we go about it?
00:47:27.020 - 00:47:27.576, Speaker B: I don't know.
00:47:27.598 - 00:47:56.640, Speaker H: I think it's question similar to how implementations should be organized, like whether they replace all the information completely or make a separate branch. I think this new spec is kind of an extension really, and it can be separate, so it's not difficult to have them separately and build the second one like the big one on top of the old one. So I don't know. I think it's up to you regarding tests.
00:47:58.680 - 00:48:00.390, Speaker A: Okay, great, thanks.
00:48:09.370 - 00:48:11.000, Speaker B: Any final comments guys?
00:48:21.800 - 00:48:22.550, Speaker A: Cool.
00:48:23.320 - 00:48:48.430, Speaker B: Okay, thanks a lot. Awesome work on the mega UF spec, everybody on the epsilon team. It's awesome to see all these things coming together. We'll have another call in two weeks, the same time. For people in North America and time zones that have already hit daylight savings. It'll be an hour earlier, but yeah, it'll be the same UTC time. Thanks a lot.
00:48:53.330 - 00:48:55.150, Speaker A: Thank you. Bye bye.
00:48:56.290 - 00:48:58.480, Speaker D: Thanks. Goodbye, have a nice day.
00:48:59.410 - 00:49:00.620, Speaker A: Bye, have a great one.
