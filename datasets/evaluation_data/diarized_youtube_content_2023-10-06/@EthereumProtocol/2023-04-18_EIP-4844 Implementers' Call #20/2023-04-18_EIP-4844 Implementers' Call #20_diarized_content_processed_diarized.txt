00:00:00.410 - 00:00:02.494, Speaker A: You okay?
00:00:02.692 - 00:00:13.520, Speaker B: Yeah, I guess. Let's get started and see if people join in. Okay, it's recording already, so I'll just trim the video.
00:00:15.570 - 00:00:16.320, Speaker A: Okay.
00:00:17.570 - 00:01:12.180, Speaker B: Welcome to our 20th 4844 call. I'll post the agenda in the chat right here. There were a couple small specs issues that I think people wanted to bring up in the context of launching the next devnet. So it probably makes sense to start just going over all of those and then once we've done that, we can talk about the different status of the implementations, as well as when and how we want to launch a definite. Okay, a couple of people just joined as we're getting started, so yeah, I added all the things in the agenda. So Brolo, just wanted to highlight there's been a small change by Mikhail in like an error code. It's literally just not even a one line change, one value change.
00:01:12.180 - 00:01:16.440, Speaker B: Anyone have thoughts, comments on that?
00:01:26.180 - 00:01:38.150, Speaker C: Okay, looks straightforward to me. Yeah, sorry, please go ahead. Yeah, it's just an alignment from my understanding that the error code has been.
00:01:44.520 - 00:01:48.936, Speaker D: Accidentally, accidentally joined the portal call. Because at the same time.
00:01:49.038 - 00:01:53.130, Speaker B: Sorry, glad you chose to come over here.
00:01:54.460 - 00:01:58.330, Speaker D: I saw piper there and was like, oh shit, portal is going to integrate for it before.
00:02:01.760 - 00:02:15.730, Speaker B: Yeah, good timing. We literally just got started. Okay, sorry, Mikhail, you were saying? So it's just the error code change and I think you're saying why.
00:02:17.620 - 00:02:18.880, Speaker A: It was changed.
00:02:19.460 - 00:02:22.224, Speaker C: Yeah, it was a discrepancy between the.
00:02:22.422 - 00:02:25.810, Speaker A: Spec for extension and.
00:02:27.720 - 00:02:37.190, Speaker C: The main spec. Yeah, because there was a change at some point in time we aligned the error codes with. I don't remember why, but still.
00:02:38.940 - 00:02:39.690, Speaker B: Okay.
00:02:41.740 - 00:02:42.490, Speaker A: Cool.
00:02:42.940 - 00:03:11.940, Speaker B: Yeah. Any other comments on that? Okay, next up then? Actually, Mikhail, this was your suggestion. So basically you mentioned merging gettale v three and get blobs and bundle v one. I guess I'd be curious to hear from folks if we want to do this in the context of the next Devnet, or.
00:03:15.670 - 00:03:16.674, Speaker A: If this is maybe something.
00:03:16.712 - 00:03:23.560, Speaker B: We want to do after that Devnet. And maybe Mikhail, you can just give a bit of background on why we'd want to do that.
00:03:24.490 - 00:03:25.142, Speaker A: Yeah, sure.
00:03:25.196 - 00:04:42.986, Speaker C: So a bit of a background. When this blob extension was introduced, the get blobs bundle was separate because it was easier to prototype and spec out in addition to get payload. So it makes sense for prototyping and all this kind of stuff. But since we're heading towards stacking out the engine API changes for Cancun, this question should be, this is just one of the outstanding questions that we need to resolve. And FLCL, unfortunately their name has raised this question in the discord recently and I thought that that's a perfect momentum to discuss it with their client developers, whether we want to keep them separate or we want to merge these two, because this is basically the same build process from which we are obtaining the payload and blobs. So this is one to one relation between the payload and blobs. And at the first glance it seems like there is no sense to keep them separate.
00:04:42.986 - 00:05:11.450, Speaker C: So the get payload basically can return both. But maybe developers has different opinion, have different opinion on that. And I was just going to bring this for discussion. We don't need to decide this for next couple of devnets probably, or three devnets, but we will have to decide it soon in order to spec it out and have it tested if we want to get them merged more extensively tested.
00:05:14.740 - 00:05:15.264, Speaker A: Got it.
00:05:15.302 - 00:05:19.840, Speaker B: Thanks. Does anyone have any thoughts on this from the client teams?
00:05:25.740 - 00:05:30.990, Speaker E: I don't see the use of having them separate, so I'm good with merging it.
00:05:33.520 - 00:05:34.316, Speaker A: Yeah.
00:05:34.498 - 00:05:58.830, Speaker B: Does anyone want to advocate for keeping them separate? Okay, I guess in that case then, yeah, let's open a pr to merge them. I wouldn't probably include that in the next Devnet unless people feel strongly that we should. So we don't have to rework that as well. But does that make sense to people?
00:05:59.600 - 00:06:03.864, Speaker F: Is it a significant reworking? I guess. Seems like it's fairly limited in scope.
00:06:03.912 - 00:06:04.510, Speaker A: But.
00:06:06.740 - 00:06:08.130, Speaker F: Not entirely sure.
00:06:10.340 - 00:06:22.176, Speaker B: I assume you're removing an API and passing some parameters that were previously passed in the removed API and the new one.
00:06:22.358 - 00:06:25.380, Speaker A: But maybe there's something I'm missing.
00:06:29.050 - 00:06:33.430, Speaker F: Does anyone feel strongly whether it should or should not go in the next Devnet?
00:06:39.050 - 00:06:47.000, Speaker G: Maybe not next Devnet, but could be done quite soon.
00:06:51.450 - 00:07:11.070, Speaker B: Yeah, I think my preference is probably to. My preference would probably be to just not include it in the next Devnet and have the pr open for it so that we can start doing like multi client testing as soon as possible.
00:07:11.220 - 00:07:11.920, Speaker A: But.
00:07:13.890 - 00:07:16.350, Speaker B: Yeah, weekly held opinion.
00:07:16.710 - 00:07:25.714, Speaker F: Yeah, I mean, I guess the hope was this would be a more longer lived devnet. The more changes like this minimizes that. Right. Minimizes the chance of that.
00:07:25.912 - 00:07:27.300, Speaker B: Oh, got it. Yeah.
00:07:30.710 - 00:07:42.700, Speaker E: They advocate that Devnet five be the longer living because most probably we'll have more clients joining in, maybe in the next Devnet, and it would be nice that can be the longer living.
00:07:44.350 - 00:07:48.700, Speaker B: Oh, so you're saying. Yeah, Devnet five, we might not have everybody but Devnet six? We likely will.
00:07:51.070 - 00:07:52.506, Speaker E: Yes, hopefully.
00:07:52.698 - 00:08:22.840, Speaker B: Okay, in that case, I think, yeah, that seems reasonable to me. Or potentially the clients that join will also have bugs which require us to recite the devnet. Obviously you always hope this isn't the case, but practice seems possible. So yeah, let's open the pr for this and not have it in scope as part of Devnet five. And then obviously anyone not on this call has issues with the change. They can leave those comments on the PR.
00:08:27.690 - 00:08:28.114, Speaker A: Yeah.
00:08:28.172 - 00:08:29.420, Speaker B: Anything else on this?
00:08:34.540 - 00:08:35.290, Speaker A: Okay.
00:08:36.460 - 00:09:02.990, Speaker B: Otherwise, Gajinder, you had three prs you wanted to highlight regarding Devnet five. We can maybe just go through each of them to make sure everyone's on the same page. The first one is a pr you've made to the execution APIs. Yes. I guess we could break up. Yeah, please.
00:09:03.440 - 00:10:14.920, Speaker E: Yeah, so actually the first pr is the result of the EIP update PR, which basically add proofs to the transaction wrapper. So basically for the serialized transaction, and since now the proofs are available to El so that they can just be passed to the Cl through get blops API call and which is basically the second API and the third API. So these two are sort of part of Devnet five specs. But it would be nice that this can be reviewed and merged because they have some renamings in the EIP for it for PR 6610. So it might lead to some renamings on the execution API for blobs bundle. And the third PR is about blob signing points, endpoints which basically extend the current endpoints to provide and publish.
00:10:23.170 - 00:10:24.590, Speaker B: I think we lost.
00:10:27.840 - 00:10:29.292, Speaker D: Yeah, I can't hear him either.
00:10:29.426 - 00:10:30.110, Speaker A: Okay.
00:10:33.460 - 00:10:38.800, Speaker F: Did I hear him right? These are all in scope for dead net five Mophie, is that your understanding?
00:10:41.160 - 00:10:43.300, Speaker H: Yeah, they're in scope.
00:10:45.000 - 00:10:49.764, Speaker F: What's the implementation status in gap? Is it to do?
00:10:49.962 - 00:10:54.810, Speaker H: Yeah, to do, but shouldn't be a large change.
00:10:58.300 - 00:11:09.352, Speaker B: I'm fl, I'm not sure what the actual name is. Okay. Yeah, okay.
00:11:09.406 - 00:11:38.390, Speaker G: I will place two names there next time. So the question was about blobs bundle. Van we may put now proofs according to the suggestion. Right. Just wanted to know why we have had these proofs previously there. Are they useful at all on sales side? This is the question.
00:11:40.200 - 00:12:02.030, Speaker E: So on the Cl side, once we get the bundle from execution layer, we just run a verify proof batch to verify everything is in order. That's where the proofs and commitments get used. And post that the signing and publishing flow happens.
00:12:05.470 - 00:12:10.538, Speaker G: I see. But how did it work before? I mean, we did not pass proof.
00:12:10.714 - 00:12:35.560, Speaker E: Right to you, so we can generate proof since commitments and blobs are there. But it sort of feels ugly to me doing this on the Cl side because not really is required. You don't require to generate commitments or proofs either. You can just push the bundle to the verification function and be done with it.
00:12:36.410 - 00:12:46.950, Speaker G: Okay, does it make it more secure that proof matches? I mean, if we send proofs, wasn't it less secure previously?
00:12:49.230 - 00:13:03.470, Speaker E: I don't think there are any changes in security guarantees because if the setup is same, then it doesn't really matter. You should get the same proof.
00:13:04.690 - 00:13:40.970, Speaker H: Okay, quick question. So I think we had something like this before Freedom blobs, where the proofs were generated on the SCl side. And I recall we got rid of it because of the additional time to compute the proofs and we wanted to minimize the time for block building on the El. So I guess my question here is, is it still a concern like computing those proofs on the El side? Would it necessarily lengthen the time to build the blocks?
00:13:43.150 - 00:14:12.530, Speaker E: So the proofs on the El side are coming through transaction wrapper layer? Because that's what the EIP for it for pr six 10 proposed proposes basically. Earlier there was an aggregate proof, but now the update on the EIP is that the proofs will come bundle in the serialized transaction, so there is no need to compute on El side as well.
00:14:12.680 - 00:14:19.650, Speaker H: Gotcha. That makes sense. Yeah, the main issue before was the aggregate proof computation. That was pretty expensive.
00:14:19.810 - 00:14:20.520, Speaker A: Cool.
00:14:22.970 - 00:14:35.260, Speaker G: So as execution layer side, we do not need to verify proofs. Always need it.
00:14:42.650 - 00:14:44.440, Speaker E: Sorry, I didn't get a question.
00:14:46.110 - 00:15:06.430, Speaker G: Do we still need to verify proofs on execution layer side at all? Or we can just send it to consensus layer after this update and we'll spend less time on transaction verification in memory pool.
00:15:09.760 - 00:15:28.070, Speaker E: I mean, if it's part of specs, then El could basically probably skip checking the proof. But since the transactions would be broadcasted, or at least the hashes would be broadcasted to other peers, I don't basically suggest that proof not be checked on El site.
00:15:32.190 - 00:15:33.260, Speaker G: Makes sense.
00:15:45.960 - 00:16:02.340, Speaker B: Okay, any other comments on this? I guess, is this something we'd want to add for v five? Does anyone disagree with that?
00:16:06.900 - 00:16:11.890, Speaker F: Are we still talking about the third of these three, or is this a different issue?
00:16:12.340 - 00:16:27.430, Speaker B: Oh, sorry. Yes, the third in the full list. I thought you meant the third of Gejinder's three prs. So adding the proofs to blobs bundle v one.
00:16:29.880 - 00:16:30.890, Speaker A: Got it.
00:16:32.220 - 00:16:33.770, Speaker B: And I guess I don't know.
00:16:37.180 - 00:16:37.496, Speaker A: If.
00:16:37.518 - 00:17:00.780, Speaker B: We are moving kind of merging get payload v three, would it, for the next Devnet? It seems like it's reasonable to just also include that in like Devnet six rather than Devnet five so that we're not actually changing blobs bundle v one in Devnet five. But I don't know if anyone feels differently.
00:17:02.100 - 00:17:15.060, Speaker H: This sort of seems like a requirement. If we're including decoupled blobs to Devnet five, then don't we also need to add the proofs to the blobs bundle endpoint?
00:17:23.440 - 00:17:43.350, Speaker B: Okay, yeah, we definitely should include the decoupled blobs and. Sorry, I didn't realize this was a must have. Basically two if we were to do that. So, yeah, then if this is required to decouple the blobs, then I think we should make this change.
00:17:47.750 - 00:17:52.550, Speaker H: At least that's my understanding. Maybe. Gaching, you have any thoughts?
00:17:56.490 - 00:18:03.900, Speaker E: Yeah, basically it saves the computation both on El side and Cl side. So I guess we can do this.
00:18:04.270 - 00:18:34.126, Speaker B: Okay, and if we are doing this, then is this still back to the previous issue? Should we also merge, get petal v three and the get blobs bundle at the same time? Are we going to waste time by separating those two changes or should we? I assume it's much easier to just add the proof, but yeah, I don't know. How do people feel about that on.
00:18:34.148 - 00:18:45.000, Speaker E: The Cs side, the change would not really be a big deal. I mean, it should be a couple of hours if everything else is at place. So I am okay if we can merge it even for Devnet five.
00:18:47.450 - 00:18:49.480, Speaker F: Kaisender, which one are you talking about?
00:18:51.450 - 00:18:54.890, Speaker B: I assume merging the execution PI.
00:18:56.670 - 00:19:02.730, Speaker E: Merging the puff bundle with the payload, get payload in, get payload tree.
00:19:05.870 - 00:19:13.120, Speaker B: Okay, so you're saying it's only a few hours of work to merge, get payload and get blobs bundled, is that correct?
00:19:14.210 - 00:19:16.318, Speaker E: Yeah. I mean, on the Cl side, yes.
00:19:16.484 - 00:19:16.958, Speaker B: Okay.
00:19:17.044 - 00:19:32.040, Speaker E: I don't know if there's anyone even on El side because El would be caching all that data anyway. So it can just return the full content in the get payload three.
00:19:37.050 - 00:19:37.800, Speaker A: Okay.
00:19:39.930 - 00:20:01.872, Speaker F: I don't think it's a big deal for the El side, but I'm wondering who's other El clients that have opinions strong or not so strong on this before we slate it for Devnet five, do we have like a. Usually Terrence is pretty clued in. I don't know if he's in the call. Looks like he might not be.
00:20:01.926 - 00:20:24.710, Speaker B: No, he's not. But he says that they have a local Devnet running with multiple prism nodes. They're ready to join a multi client Devnet. So I assume in terms of just like, if this is just a few hours of work, they're not delayed or they're not behind in any way.
00:20:29.020 - 00:20:32.680, Speaker F: Okay, so do we include it or not?
00:20:32.830 - 00:20:35.576, Speaker B: Yeah, I don't know enough about the.
00:20:35.598 - 00:20:38.120, Speaker F: Cl side just to have a strong opinion.
00:20:39.020 - 00:20:43.500, Speaker E: Yes, Cl is relatively easy as well. I don't see any challenges.
00:20:45.040 - 00:20:53.484, Speaker F: Okay, let's tentatively include it. I guess we can always, if it turns out to be too much, we will run it by Terrence and a few other folks, I guess, to confirm.
00:20:53.532 - 00:21:27.320, Speaker B: Yeah, and to be clear. So we're tentatively including both changes. So merging get payload v three and get blobs bundle v one. And I don't know that we have a pr for that quite yet. And then we would also include the proofs as part of the blobs bundles. Yeah, perfect. So we just need a spec for the get payload v three and get blobs bundle v one merge.
00:21:31.650 - 00:21:32.254, Speaker A: Okay.
00:21:32.372 - 00:21:53.530, Speaker B: Anything else on that? Okay, your next pr that you mentioned, Gizinder, is the update to four four four to decouple the blobs. I assume this simply reflects the functionality that was already merged on the Cl side, is that correct?
00:21:54.940 - 00:22:11.870, Speaker E: So basically it changes the network wrapper to have proofs instead of aggregate proof. And there are few renamings of KZG to commitments, nothing more than that.
00:22:13.860 - 00:22:30.390, Speaker B: Okay. Yeah. Any thoughts, comments on that? And I assume we should just merge this. And there's still some comments on the VR, but we merge this, it's effectively part of Devnet five already.
00:22:33.470 - 00:22:35.606, Speaker F: Yeah, I think this is already implemented.
00:22:35.638 - 00:22:37.222, Speaker A: I believe in gap.
00:22:37.286 - 00:22:40.320, Speaker F: Anyway, MoPi, correct me if I'm wrong.
00:22:41.570 - 00:22:42.800, Speaker H: Yeah, that's right.
00:22:47.960 - 00:23:04.956, Speaker B: Okay. And then last one of the prs you brought up is the blob signing endpoint. Let me post this in the chat as well here. Yeah, do you want to give some quick background on that one?
00:23:05.138 - 00:24:03.820, Speaker E: Yeah, so this is sort of internal communication between beacon node and validator how to sign the block and blobs. So basically what it really does is that it extends the current produce and publish API endpoints for dynamfork to include to sort of use block contents rather than the block. Block contents are basically block plus blobs sidecar. And so this is basically internal communication between we cannot and a validator how to sign it. And it's sort of optional in the sense that if there are no cross we cannot validator communications, which we generally don't test for in the Devnets. Then it is sort of an optional thing. But since we are going this way, it could be an optional requirement.
00:24:06.500 - 00:24:06.816, Speaker B: To.
00:24:06.838 - 00:24:09.570, Speaker E: Sort of push the implementation forward.
00:24:16.350 - 00:24:18.380, Speaker B: Anyone have thoughts on this?
00:24:31.980 - 00:24:35.252, Speaker F: I'm not sure I've had this one.
00:24:35.406 - 00:24:37.630, Speaker B: Yeah. Has anyone reviewed this? Basically.
00:24:40.000 - 00:24:42.590, Speaker E: So Lodestar has implemented it.
00:24:46.160 - 00:24:53.570, Speaker B: And I guess. Yeah, this doesn't change consensus or anything. So it's fine if Lodestar has it but not prism, correct?
00:24:55.300 - 00:25:01.764, Speaker E: Yeah. This is optional internal communication between beacon node and validator tech.
00:25:01.802 - 00:25:10.470, Speaker I: We already started implementing that one. It's not completed yet, but we are going to be compatible with this pr.
00:25:12.120 - 00:25:17.660, Speaker A: Got it. Okay.
00:25:17.730 - 00:25:28.770, Speaker B: So I'd say we can probably merge the pr in relatively soon. I see there's like a huge thread of comments, obviously kind of want those resolved, but.
00:25:31.860 - 00:25:33.648, Speaker A: Yeah, I guess this is.
00:25:33.654 - 00:25:35.536, Speaker B: Sort of orthogonal to Devnet five, so.
00:25:35.558 - 00:25:38.768, Speaker A: We don't really have to mention it.
00:25:38.934 - 00:25:40.000, Speaker B: The specs.
00:25:41.480 - 00:25:41.892, Speaker A: Yeah.
00:25:41.946 - 00:25:43.030, Speaker B: Does that make sense?
00:25:46.150 - 00:25:51.154, Speaker H: Yeah, it makes sense. I currently had it marked as optional in the Devnet spec.
00:25:51.352 - 00:25:54.098, Speaker B: Okay, cool.
00:25:54.264 - 00:25:54.786, Speaker A: Yeah.
00:25:54.888 - 00:25:58.440, Speaker B: Then let's just leave it there so people have the information.
00:26:00.570 - 00:26:00.934, Speaker A: Okay.
00:26:00.972 - 00:26:31.566, Speaker B: So I guess to recap. And I'll post your spec. Actually, Mophie, thank you. So for the devnet five, we have the Cl that obviously decouples the blobs of blobs, switches the transaction type, the El built on top of Shanghai. No, zero blob transactions. Change the transaction type as well, decouple the blobs. And then on the engine API, we're adding the proofs to blobs bundle v one.
00:26:31.566 - 00:26:47.960, Speaker B: And I guess the other thing we would make is we would merge blobs bundle v one and get paid on v three. So that's, I think, the only thing that's not quite in the spec as of right now. And then the beacon API, this optional pr we just mentioned.
00:26:50.010 - 00:26:50.854, Speaker A: Does this make.
00:26:50.892 - 00:26:54.280, Speaker B: Sense to people as a general spec for Devnet five?
00:27:06.990 - 00:27:10.362, Speaker A: Okay, sweet.
00:27:10.426 - 00:27:15.840, Speaker B: So let's move forward for that. Just really one bullet point to change on what it looks like.
00:27:17.090 - 00:27:17.694, Speaker A: And yeah.
00:27:17.732 - 00:27:46.810, Speaker B: Curious to hear from the different client teams where they are at. Terrence said they're ready to join a multi client devnet basically ASAP. Lighthouse said in the chat or in the comments, sorry, that they probably need another week or two. And yeah, Lodestar seems ready as well. It seems. I don't know if there's any other client themes or if anyone on those teams wants to expand.
00:27:48.350 - 00:28:12.146, Speaker I: Yeah, Nimbus, sorry. Yeah, Henry Nimbus here. I'd say probably in the lighthouse time up. So we have sync working. I'm wrapping up gossip and fetching missing blobs during gossip, et cetera. That's probably the last pr is going up today or tomorrow for that. And then there'll be some tying up loose ends and stuff.
00:28:12.146 - 00:28:14.420, Speaker I: So I'm guessing another week to two.
00:28:15.670 - 00:28:19.380, Speaker A: Got it on the stack of side.
00:28:21.350 - 00:28:55.630, Speaker I: More on the two weeks time frame. Hopefully we're still doing some work on the storage side plus working on the import flow yet and the API as mentioned before, we are doing implementing to be compatible with the PR but not completed yet, so still work in progress. Hopefully we'll join later after Devnet five launch.
00:29:00.510 - 00:29:01.500, Speaker A: Thank you.
00:29:02.850 - 00:29:04.560, Speaker B: Anyone from the El side?
00:29:07.890 - 00:29:20.210, Speaker G: Nevermind has a previous scope implemented and just needs like a week to align with these new pythons.
00:29:24.070 - 00:29:28.370, Speaker B: Roberto, how about Geth or Aragon?
00:29:29.210 - 00:29:36.360, Speaker F: Yeah, so Aragon and Geth I think are approximately in the same state, which is pretty up to date.
00:29:37.850 - 00:29:38.214, Speaker A: Yeah.
00:29:38.252 - 00:29:43.980, Speaker F: Other than those prs that we've discussed, a few prs that we've discussed today, which we should be able to fairly easily add.
00:29:46.110 - 00:29:46.860, Speaker B: Okay.
00:29:49.070 - 00:30:04.750, Speaker F: So it seems like please, I should caveat that with Aragon has not been extensively tested recently. I just completed a bunch of updates this weekend, have not run any tests, but at least got the upstream merged and some recent changes implemented.
00:30:06.210 - 00:30:06.574, Speaker A: Nice.
00:30:06.612 - 00:30:27.800, Speaker B: And there's a comment from Kijender that Ethereum JS should also be able to join. So it seems like we probably have like half the clients at least give or take. And obviously there's going to be a couple of days of just implementing the last changes that we agreed on today.
00:30:29.450 - 00:30:30.182, Speaker A: But yeah.
00:30:30.236 - 00:30:45.680, Speaker B: Is it realistic to try and stand up to Devnet before the CL call this Thursday? And that if we run into any issues doing that that we can't sort of Debug async, we can cover it there. That gives us like three days.
00:30:53.950 - 00:30:54.266, Speaker A: I.
00:30:54.288 - 00:31:05.040, Speaker H: Would say probably not. Maybe like next Monday or Tuesday would be a better date.
00:31:05.730 - 00:31:06.480, Speaker A: Okay.
00:31:08.450 - 00:31:24.610, Speaker B: What do you think is like the blocker? Is there anything specific you feel like we need to figure out this week or is it just implementing the stuff we just discussed?
00:31:27.450 - 00:31:35.960, Speaker H: It's implementing them and just the availability of devs here to do the interop in particular.
00:31:36.830 - 00:31:39.754, Speaker A: Okay, fair enough.
00:31:39.792 - 00:31:58.400, Speaker B: So I guess then in that case maybe, and I see a couple thumbs up on the screen. In that case, what I would maybe do is let's check in on this in a few days on the Cl call as well and aim for something early next week going live?
00:31:59.970 - 00:32:00.382, Speaker A: Yeah.
00:32:00.436 - 00:32:01.760, Speaker B: Does that make sense to people?
00:32:04.870 - 00:32:06.340, Speaker H: Yeah, sounds good.
00:32:07.750 - 00:32:08.162, Speaker A: Cool.
00:32:08.216 - 00:32:23.190, Speaker B: Okay. And I guess on a similar note, I would definitely keep four four four only call two weeks from now as well. And we can use that to sort of coordinate whether we want to shut down Devnet five, move to Devnet six and whatnot.
00:32:23.690 - 00:32:33.402, Speaker A: Yeah, Lucas. So I have a question about for it, for testing. So one thing is the deafnet, but.
00:32:33.456 - 00:32:34.970, Speaker E: I have a question.
00:32:35.040 - 00:32:44.400, Speaker A: What's the plan for hive tests? Are they being developed? Are they still being postponed? Or what's the plan here?
00:32:44.850 - 00:32:47.054, Speaker B: Yeah, we have Mario on the call.
00:32:47.092 - 00:33:01.586, Speaker I: Yeah, we're still working on that. We started with the reference test for the execution, their clients, and we have those almost ready, but yeah, for the NDN API and all that. We still have to work on it.
00:33:01.688 - 00:33:02.194, Speaker A: And.
00:33:02.312 - 00:33:10.630, Speaker I: Yeah, we have them. I mean, we have to start this week. So probably next week we'll have something to test the changes on Hive.
00:33:12.090 - 00:33:12.840, Speaker A: Cool.
00:33:22.800 - 00:33:27.920, Speaker B: Any other question on the Devnet schedule, testing or whatnot?
00:33:30.260 - 00:33:39.990, Speaker E: I have a query with regard to the CL site spec test. I think it's still using that transaction prefix as five.
00:33:43.320 - 00:33:59.130, Speaker D: We're working on a release right now. Should be out by tomorrow with three. I suggest using that for. That's also in relation to the head of the EIP. So I think we should use that. And the tests will be ready tomorrow as.
00:34:02.160 - 00:34:05.150, Speaker B: Yeah, we should definitely use type three.
00:34:12.120 - 00:34:12.628, Speaker A: Okay.
00:34:12.714 - 00:34:14.864, Speaker B: Anything else on the Devnet or testing?
00:34:14.912 - 00:34:15.510, Speaker A: You?
00:34:21.390 - 00:34:29.550, Speaker B: Okay, in that case, Danny, you mentioned you had a point around the mempool and new payload.
00:34:31.090 - 00:34:31.406, Speaker A: Yeah.
00:34:31.428 - 00:35:39.780, Speaker D: So this came up in Adelweiss. Essentially, Peter would like to have the quality of service such that upon a reorg, any type three transactions could be put back into the mempool so that users have the same experience they have with normal transactions today. And he and I spoke. And so to make that happen, you have to essentially break the barrier between the consensus layer and execution layer a bit more. And on new payload, give the blobs the execution layer so that they can have them around in the event of a reorg to rebuild the transactions, the full transactions. We had spoken, Peter and I, that maybe actually to not break that barrier, not change the engine API, what you can actually do is anything that's come through the mempool, you have the blobs, and so you can provide that quality of service to users to have them reinserted. But essentially, if you bypass the mempool, you don't have a guarantee to get back in because the condensed layer doesn't give them the execution layer, and that would not require the new payload change.
00:35:39.780 - 00:36:31.320, Speaker D: I thought that we were kind of in agreement on that. I took a look at Peter's slides from a talk in Tokyo the other day where it implied otherwise. I just wanted to surface this as a design point to the group that this does seem like an unknown point as to whether we agree that there should be a change here, whether the change would happen, whether Peter's assuming it will happen, that kind of. So I don't have discussion points beyond that. People can obviously weigh in their opinions here, but we probably need to have this conversation somewhere. Otherwise, I think the conversation, if we don't concertedly have it, is going to happen in four or six weeks and still be a debate. That's a breaking change.
00:36:36.710 - 00:36:47.318, Speaker C: Danny, could you please repeat the alternative where we are not passing blobs back to El, whether El stores them, or what happens?
00:36:47.484 - 00:37:50.454, Speaker D: Right. So, essentially, you might want a world in which El has all of the blobs in relation to transactions that made it on chain, such that when you do a reor, you can rebuild those transactions and put them in the mempool to do so. If on new payload CL inserted those transactions, then they would have them guaranteed, even the things that bypass the mempool, they'd have those blobs available, and then they could prune them after finality or something like that. The alternative is, instead of the guarantee being all blob transactions can be rebuilt on a reorg. If you just have it, all blob transactions that hit the mempool can be built. Then you don't need to change new payload, because El will have whatever it got from the mempool. It can choose to cache those blobs for x period of time or till finality, to be able to handle rebuilds on reorgs.
00:37:50.454 - 00:38:28.120, Speaker D: But that essentially means that anything that hit the mempool can have this quality of service. If you bypass the mempool, tough luck. You need to bypass the mempool again to reinsert. I do think that this strategy, not changing, new payload, not inserting, and only being able to have this quality of service to the mempool is very reasonable, especially when you think about full sharding designs, when it would be impossible for everything to hit the mempool. So it's not necessarily even a quality of service that can be. That's reasonable to consider. But does that make sense?
00:38:31.210 - 00:38:31.960, Speaker A: Yeah.
00:38:32.570 - 00:38:42.010, Speaker C: Thanks for sharing. I think it at least makes sense for me, this alternative.
00:38:47.230 - 00:39:14.030, Speaker B: I apologize. I was looking at Peter's slides and listening to you at the same time. So maybe this is just me having missed something, but it seems, as per Peter's slides, that he's saying that you can't reorg external blobs. And then it seemed like you were saying that this is fine. You basically can only reorg what's been in the mempool. So I guess maybe you can reorg anything.
00:39:14.120 - 00:39:28.890, Speaker D: It's a matter of what gets put back into the mempool. I believe at the last, maybe third or second to last slide, Peter mentions, essentially, that you insert. The Solution is to insert blobs via new payload.
00:39:29.630 - 00:39:39.114, Speaker B: Okay, got it. And so he's saying that. Okay, I guess I just read that differently than you. Okay, I see what you mean.
00:39:39.152 - 00:39:39.354, Speaker A: Sorry.
00:39:39.392 - 00:39:39.882, Speaker B: Anyway.
00:39:40.016 - 00:39:40.860, Speaker A: Got it.
00:39:41.650 - 00:39:44.350, Speaker D: Am I reading it? Are we reading it the same now?
00:39:44.500 - 00:39:47.630, Speaker B: Well, I'm going to go and listen to the talk to make sure.
00:39:47.700 - 00:39:48.560, Speaker D: Yeah, I have.
00:39:48.930 - 00:40:08.360, Speaker B: Yeah. But the way I read this is like, the blob transactions are not fully bundled in a block. Reorgs of sync block will be unable to resurrect blobs because clients must provide the blobs in the new payroll API calls. It reads like a sort of, like, maybe this has to happen. But I'm curious. Yeah. Okay.
00:40:09.930 - 00:40:24.700, Speaker D: That was one of the intended designs, the end of adelbytes. But I thought maybe we had landed on compromise, but now I think that we haven't, necessarily. So I just want to bubble it up as a discussion point to not accidentally leave this sitting for six more weeks.
00:40:25.230 - 00:40:25.980, Speaker A: Yes.
00:40:26.750 - 00:40:35.150, Speaker F: I think there are also some opinions that perhaps we should just never rebuild these on Reorg and just leave it up to the client. A few people.
00:40:35.220 - 00:41:02.760, Speaker D: Right. Not putting it in new payload leaves it a bit more unappinionated. The client can rebuild them, the ones that they saw, but this isn't a core requirement of the software. But once you put in a new payload, it's. Obviously, they still can only rebuild if they feel like it. But you've broken the abstraction a bit and kind of implied more heavily, like, this is why we're doing that.
00:41:07.450 - 00:41:18.140, Speaker B: So my recollection is, I don't think we ever made this decision. We basically never made the decision to change new payroll. Right?
00:41:20.050 - 00:41:20.894, Speaker D: Correct.
00:41:21.092 - 00:41:24.400, Speaker B: Yeah. And I don't know if.
00:41:26.690 - 00:41:27.182, Speaker A: We did.
00:41:27.236 - 00:41:28.922, Speaker D: Punt on it, and I'm just worried.
00:41:28.986 - 00:41:29.600, Speaker A: That.
00:41:31.570 - 00:41:34.560, Speaker D: We'Re accidentally continuing to punt on it.
00:41:35.510 - 00:41:36.018, Speaker A: Yeah.
00:41:36.104 - 00:41:41.122, Speaker B: It should be explicit. It's like we want an explicit commitment to do nothing if we are actually.
00:41:41.176 - 00:41:51.240, Speaker D: Doing nothing, especially given that there is somebody who has very strong opinions about this that is not on this call.
00:41:52.010 - 00:42:01.798, Speaker F: What is Peter's opinion? Is Peter's opinion that we do do the full rebuilding on every reorg and change the API to support it, or is he okay with the rebuild, if you can, kind of approach?
00:42:01.974 - 00:42:14.800, Speaker D: That's my read of the slides, I'm now speaking beyond what I have, but this seems like something we punted on and I don't want it to accidentally catch us off.
00:42:16.850 - 00:42:21.360, Speaker F: Mean, I think we should loop in Peter and see if he still feels strongly one way or another.
00:42:21.810 - 00:42:46.200, Speaker B: Yeah. So I think maybe the next step here is like, yeah, I can reach out to Peter and the get team, generally async, and we can potentially cover this on the Cl call, especially in the case where Peter's opinion is we should change this, which involves the Cl much. I've made it out of that.
00:42:46.890 - 00:43:01.230, Speaker D: Yeah, I mean, fortunately, Peter is working on a lot of this transaction. Pool machinery kind of heads down right now. I think it works fine. The fundamentals don't change too much if it's rebuild if you can, versus rebuild from new payload.
00:43:03.890 - 00:43:09.790, Speaker B: But, yeah, let's ping him and make sure we actually understand his request.
00:43:14.080 - 00:43:14.780, Speaker A: Cool.
00:43:14.930 - 00:43:16.830, Speaker B: Anything else on this.
00:43:19.440 - 00:43:41.400, Speaker C: One kind of idea what on that thing is? Probably Cl can do something about it, because Cl will keep blobs anyway, and handling rewoks when rewalks is happening. Cl may just leave some blobs.
00:43:43.740 - 00:43:44.056, Speaker A: How.
00:43:44.078 - 00:43:47.604, Speaker C: To say, just missed. And Cl can fill the gaps.
00:43:47.652 - 00:43:52.476, Speaker B: But I don't think whether it's a.
00:43:52.498 - 00:44:09.490, Speaker C: Good solution or not, but it's just an alternative. And it comes from the consideration that Cl will have all bundles stored anyway. So I don't know what are the edge cases of that as well, and what the complexity will be.
00:44:14.400 - 00:44:20.876, Speaker D: Are you suggesting that Cl upon reorgs should have an endpoint to just give them, or are you suggesting otherwise?
00:44:21.068 - 00:44:47.050, Speaker C: I'm suggesting that El returns transactions and some of those transactions will not have blobs, because El will assume that CL has blobs for them and Cl will know, put those blobs in place. In some cases, it might not be the case and transactions will be left without blobs. That's potential issue with this.
00:44:47.580 - 00:44:54.600, Speaker D: Yeah, I worry that puts a much more stateful assumption between the two layers.
00:44:55.980 - 00:45:09.490, Speaker C: Yeah, exactly. But CL actually is responsible for rewokes. Right. So it rewokes from one chain to the other. Yeah, definitely. There could be edge cases in that.
00:45:11.300 - 00:45:17.730, Speaker D: Yeah, I guess if you come online, you come online at the point of the reorg, you won't necessarily have it.
00:45:19.400 - 00:45:33.332, Speaker C: Yeah, probably. So it really makes sense to have this strategy with those that are bypassing mempool, not being included into reorgs.
00:45:33.476 - 00:45:33.928, Speaker A: So.
00:45:34.014 - 00:45:38.680, Speaker C: Yeah, sounds quite solid in terms of da.
00:45:40.940 - 00:45:56.848, Speaker D: Yeah. My opinion is that's the simplest. It keeps the abstraction there. It doesn't put like, doesn't make any sort of new assumptions that are hard to hold during full sharding you.
00:45:56.894 - 00:46:15.110, Speaker E: My opinion is that Cl is sort of anyway responsible for checking the data availability of the blocks. And if Cl is sending a payload to El through new payload, I think El should assume that Cl has made sure that the data is available.
00:46:17.240 - 00:46:25.880, Speaker D: Yeah, and that's the assumption. It's just a matter of like, do you want to hand them to the El as well? For El to have this minor utility on reords?
00:46:34.780 - 00:46:38.010, Speaker E: Cl can definitely provide them if El needs it.
00:46:44.460 - 00:47:06.680, Speaker D: Yeah, certainly. It's just a matter of, I think, worth. If it's worth the complexity or worth the load. Yeah, I think your plan is good, Tim. I think that gather some information to continue the combo.
00:47:06.840 - 00:47:07.308, Speaker A: Yeah.
00:47:07.394 - 00:47:20.610, Speaker B: And yeah, we should at least know what Peter meant by Thursday's call. Anything else anyone wanted to cover.
00:47:26.920 - 00:47:27.668, Speaker A: Okay.
00:47:27.834 - 00:47:47.270, Speaker B: Otherwise, yeah, let's definitely keep four, four, four specific call in two weeks and see if we still need them after that. But given all the stuff we have to do. Yeah, given all the stuff we have to do in the next two weeks, probably makes sense to just have a separate breakout for this.
00:47:47.960 - 00:47:50.876, Speaker A: I'm them, but yeah, I think we.
00:47:50.898 - 00:47:55.230, Speaker B: Can wrap up for today. Thanks everyone, and talk to you all soon.
00:47:55.840 - 00:47:59.484, Speaker A: Thank you. Thanks. See you guys.
00:47:59.522 - 00:48:00.010, Speaker H: Have a good one.
