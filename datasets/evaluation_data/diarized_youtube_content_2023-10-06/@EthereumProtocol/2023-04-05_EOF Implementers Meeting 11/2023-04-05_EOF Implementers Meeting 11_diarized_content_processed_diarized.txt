00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:02.850 - 00:00:23.200, Speaker B: Hey guys, welcome to the EOF implementers call number eleven. Thanks for being patient with me while I'm running a couple of minutes late this morning. Let's just go ahead and get started. It looks like everybody else was able to make it here on time. Could we start with some client updates, what people have been up to over the last two weeks?
00:00:26.970 - 00:01:00.830, Speaker C: I'll start with Besu. We got most of the easier opcodes implemented. It's when we're getting into the call in the create three that there are some architectural changes that might make things easier that I want to discuss on the call. We got the data op codes implemented as well. Just wondering like mentioned later on if we could change the ordering of the containers. I think it might make things better in general rather than having to rewrite them. But that's where we're at, is getting into the nitty gritty of the implementation details.
00:01:04.560 - 00:01:05.068, Speaker A: Nice.
00:01:05.154 - 00:01:08.190, Speaker B: Thanks for that update. Anyone else?
00:01:12.450 - 00:01:17.120, Speaker D: Actually, I just wanted to ask Daniel how much time it took.
00:01:18.850 - 00:01:19.526, Speaker A: To implement.
00:01:19.578 - 00:01:27.700, Speaker D: The rest and was it like straightforward or did you find anything in the specs which you would want to change?
00:01:29.190 - 00:02:11.460, Speaker C: So I'm not writing tests quite yet because I want to get a full integrated test of all pieces before I commit to testing it, in case I need to do things like create multiple sets of operations for two different version of the operation registry. That's where my concerns about call and create are going to come in. But data, I mean, the hardest part is just rewriting it. And it's not that it's hard, it's that it consumes cpu cycles unnecessarily. So apart from calling create, it's not terribly difficult. And I don't think create will be too difficult either. I just need to get in and find time to do it.
00:02:19.350 - 00:02:20.210, Speaker A: Paul?
00:02:23.130 - 00:02:26.550, Speaker E: Yeah, I wanted to give the EVM one update.
00:02:27.290 - 00:02:32.194, Speaker C: I think we can start with that.
00:02:32.252 - 00:03:41.722, Speaker E: Alex gave update on core dev last week and in terms of implementation, so we roughly have most of the mega UF features prototyped in EVM one. Yeah, we didn't discover any substantial issues. I think the create three and create four has to be reviewed and check how it's looking. But so far nothing really bad happened. This is like terms of implementation progress and we put some effort into firstly updating GEF implementation and to be agreed with EVM one on this version 1.0 of UF and this is done. And we also needed to put some time into testing infrastructure.
00:03:41.722 - 00:03:53.140, Speaker E: But this also has finished. So the last piece of needed to close this subject is to.
00:03:54.870 - 00:03:56.642, Speaker A: Get the.
00:03:56.696 - 00:04:35.040, Speaker E: Previous submitted test updated and means there are I think three or four prerequisites to Ethereum tests with updated tests, which is not megaspec, but at least they are better than we had for Shanghai so it doesn't conflict with the Shanghai efforts and think there's some usefulness in this. So I don't know exactly what the status is like why this is blocked, maybe just some review details to figure out, but this is more or less where we are.
00:04:35.670 - 00:04:39.490, Speaker B: You're asking why the pr two Ethereum test is blocked?
00:04:41.190 - 00:04:52.680, Speaker E: Yeah, I didn't check what exactly is the status? So if someone knows, can answer, but I guess they're also publicly available so you can check what is going on.
00:04:53.050 - 00:04:54.582, Speaker A: Yeah, makes sense.
00:04:54.636 - 00:05:06.780, Speaker B: We can also talk about it when we talk about testing some more. Thanks for that update. Somebody on Nethermind want to give an update of what you've been up to?
00:05:08.030 - 00:05:24.190, Speaker F: Yes, well we implemented most the straightforward stuff from the mega UF spec kind of only the create opcodes and the new transaction type remain to be added.
00:05:29.750 - 00:05:31.006, Speaker A: Thanks for that update.
00:05:31.118 - 00:05:34.530, Speaker B: Anybody that we didn't get to that wants to give an update?
00:05:41.110 - 00:05:42.420, Speaker A: Okay, cool.
00:05:42.730 - 00:06:00.266, Speaker B: Any solidity Viper compiler related updates? Yes Barnabas, not really a solidity related.
00:06:00.378 - 00:06:16.954, Speaker G: Question, but can we start testing UF? Like start a dedicated devnet for it with possibly all the UF changes that we would like to see in the next potential fork?
00:06:17.102 - 00:06:38.442, Speaker B: Would that be something you guys would be interested in? It seems like we might be a little bit early on the cycle right now. Somebody correct me, but it seems like most of the clients are still reaching conformance with the tests, which I feel like is usually the first step. Once they have that, then it makes sense to probably start looking at doing a test.
00:06:38.496 - 00:06:47.628, Speaker A: Net okay, yeah, let me know if it changes.
00:06:47.794 - 00:06:49.176, Speaker G: Yeah, I would like to start pushing.
00:06:49.208 - 00:07:12.820, Speaker B: For it, especially now that Shanghai is about to be cool. Yeah, let's do spec updates and then let's talk about testing. What situation is there? So it seems like the spec is solidified. Is there any updates that we want to talk about or anything that was found during the last two weeks or an implementation?
00:07:14.840 - 00:07:33.660, Speaker C: I have a few that I mentioned in the discord thread and a fourth one that I just thought of that should be less controversial. I'll just start with that one. Is push in not push in. Is pop in swap not pop in swap in dupe n. Is that considered part of what we're going to ship with the first version?
00:07:38.030 - 00:07:44.640, Speaker E: Yeah, I kind of wanted to, but I don't know if we did agree on this.
00:07:46.370 - 00:07:56.254, Speaker C: So I motion we add it, let's put it that way. Formally added as part of EOF. I know solidity has been pushing for.
00:07:56.452 - 00:08:19.190, Speaker E: Yeah, yeah. They really wanted this and like, I think what they like some time ago is that if EOF will not go into Shanghai and there will be more time to rework some features, they would really like to have this swap and dupen.
00:08:19.690 - 00:08:48.180, Speaker C: Yeah, and the overhead, this is one of the simpler ones to implement because we've got already written this stuff to do the multibyte operations. We've already got the opcode filtering and stuff like that. So this is from an implementation perspective, it's not that hard to add and it provides significant value to the solidity team. So I think it would be a good add. Testing is going to be the harder part because it's going to take more time than writing it, which is the case with just about everything, but.
00:08:55.240 - 00:08:57.940, Speaker A: Yes, Julie.
00:08:59.720 - 00:09:00.036, Speaker C: Yeah.
00:09:00.058 - 00:09:36.304, Speaker H: So while we're on the discussion of the spec itself. So I mentioned in the forums briefly, but I think it would just be easier if maybe we kind of talked about it a little bit here instead of doing it async. But yeah. So I'm working on both a parser that validates EOF containers and then also like EOF code gen for the huff compiler in the parser. Yeah, those are both rust crates. Work in progress. I think it's public, but it's a mess.
00:09:36.304 - 00:09:51.236, Speaker H: You don't want to see that right now. Yeah. So on the rust implementation thing, so I was speaking with the. I don't remember his name, but the guy that's working on revum about adding this EOF validation, and so he wants.
00:09:51.258 - 00:09:53.530, Speaker B: It to be really fast.
00:09:54.460 - 00:10:36.340, Speaker H: Some pretty weird optimizations there. And so I was looking to do it that way, but there's some complications around doing this efficiently in a single pass. If you could maybe link the existing rust EOF container, that'd be great. But in particular on the topic of the header. So right know the header is dynamically sized, but I think with it being statically sized and then moving the metadata about the size of the different code sections, like moving that to the type section, I think would make it, would make the header parsing a lot faster. Right. You could effectively just use a mask to validate the constant bytes and then the ones that maybe some other value.
00:10:36.410 - 00:10:37.030, Speaker A: Then.
00:10:39.080 - 00:10:57.550, Speaker H: We could extract that information basically really quickly and it would be a lot less jumping around. So if we want to check a specific code section, we'd need to go both to the header and the type section, whereas if we move that into the type section, then it's all in one place in the type section. Curious of anybody else's thoughts on this.
00:11:04.380 - 00:12:04.860, Speaker B: I know we talked a lot about this specific header format and I don't know if there was any kind of final conclusion that this was the way that made the most sense. I think it's the simplest in a lot of know what we have. I don't know if Alex or Paul you have thoughts because we kind of have made. I don't know. I think that this was one of the big rabbit holes that we went down whenever we first started pushing really hard for EOF in Shanghai. And that's where we ended up spending a lot of time, is thinking about how to do these code sections and type sections. And we ended up having a couple of small changes to it that substantially increased the complexity.
00:12:06.640 - 00:12:15.330, Speaker H: Also, if you guys have a link to any notes or anything that was taken around this, just so people don't have to repeat themselves, and I can kind of go through the history of it, that'd be.
00:12:18.580 - 00:13:29.124, Speaker E: I mean, I think Matt is right. We kind of discussed it longer previously and most of the conclusion was that, well, there were two options to choose from. One was to keep some generic level, some abstraction, which is what we currently have. So they are like sections, and in the header you just have information where the sections are. And this is like one deviation from the very specific one is like when you have the series of this section of the same time, you can encode it differently. And that's, I think what Andre also tried to explain on the, I think magicians, right where you asked. So we kind of prefer that a bit to the other option where it was like we just put all the sizes in specific place in the header and just read some bytes and you know, where the things are.
00:13:29.124 - 00:14:18.424, Speaker E: But there's no really option to extend it easily in the future if you want to add. So currently you can just add new section type and that will be some kind of somehow like backwards compatible. So you can add optional sections in the future and you don't need to know what the section is about. Yeah, but yeah, definitely this way to kind of compress this information more. I'm not sure about putting, adding this dependency. You mentioned that you would need to kind of read one section to know where the other sections are. Maybe it simplifies the parser, but yeah, I would need to look a bit.
00:14:18.424 - 00:15:27.628, Speaker E: What does it mean practically? And for example, where do we need to access type sections. Seems like we access it more than we previously imagined at runtime. EVM needs to also check types, I think in some places, yeah, maybe it simplifies the parse. I'm sure if the runtime will be simpler with this way, but definitely you should check how it will behave. But still kind of want to keep at least these offsets in the header only. It might be also related to worker trees later when every chunk of access is priced differently. So if you can just read the header and then have all the information list where to go next, that may be useful, but I mostly tried to explain why we decided this way.
00:15:27.628 - 00:15:51.780, Speaker E: Definitely we know it's not like ultimate in terms of, I don't know, the density of the information or yeah, we lose a bit, bytes, some bytes here and there to keep this ability to add some to extend it for the future without bumping the DOF version.
00:16:02.620 - 00:16:04.090, Speaker B: Does that kind of make sense?
00:16:06.540 - 00:16:36.756, Speaker H: Yeah, it makes sense. Thinking how maybe we could experiment and try out both. I could probably set some time aside to basically implement with the design that I've proposed in mind, and I don't know, maybe see how they compare. But if it has to do with other external things aside from just runtime and parsing, then yeah, I'm not aware of how that affects those, so I'd have to look into it more.
00:16:36.938 - 00:17:24.612, Speaker B: Right? Yeah, I do think it's useful to try and have this comparison and be able to take a look at okay, what is the complexity of this algorithm for parsing one versus the other? What is the runtime performance of each? That's very useful. And then to also think a little bit about how extensible are both of them. And I think the note that we sent has some discussion about what the goals are from the perspective of being extensible, and generally other goals that we had during the container header discussions. So if you take a look at that, that might catch you up a bit. But yeah, I think that's probably the best approach. And I took a stab at implementing some of those parsers. You can kind of see the go code there as well, just to get an idea.
00:17:24.612 - 00:18:08.590, Speaker B: But yeah, always useful to try and look at it from a different perspective. Okay, just to circle back really quickly, we talked on the chat about adding swap and dupin to mega elf. Just going to give people a space for a second in case anyone thinks that should not go in. I agree with Alex. It's probably the thing that would be first on the chopping block if we need to reduce scope. But it seems like a good thing to just go ahead and add right now. Okay, we will assume that it's added, Dana.
00:18:08.590 - 00:18:20.922, Speaker B: Okay, well, Dana, you had a few other things you wanted to talk about. Do you want to move on?
00:18:21.056 - 00:18:50.578, Speaker C: Sorry, I was muted. So a few things I want to talk about. Before we took the detour on the container format, the first of the three items I mentioned last night or this morning was reordering the containers for the data segment. As last with create three, we're adding new subcontainers for deployment in the container. And those got put on at the end. I would like to ask that those get put on before the data element. And the reason is for consistent hashing when we're adding the auxiliary data from the create three.
00:18:50.578 - 00:19:29.170, Speaker C: Otherwise we would need to rewrite the containers in some cases to put it in the tree to get it updated in this way, all we'd have to do is append the data and update a field to get it correctly. And it would reduce things like vertical trees would have more consistent accesses to the various deployments. If we keep the variable data at the end and the stuff that depends on it. And part of the problem is because the data copy operations, if you copy across a seam, you would either have to have logic to join the two pieces or rewrite it in memory to get consistent access to this. So that's one request.
00:19:35.000 - 00:19:36.550, Speaker B: Any thoughts on that, guys?
00:19:37.980 - 00:20:29.130, Speaker E: Yeah, I think it makes sense to have it in this order, especially if we're going to append data, which means it's much easier to do if it's the end section. This one thing kind of reminded me that we kind of decided in the previous discussion that we already have these three type of sections and we added fourth one right now that we made all of these mandatory in the header. So maybe there's also an option or make a decision to also make this one mandatory. In a sense, there will be indication about it in the header, but it can be of size zero, of the count zero, whatever.
00:20:31.660 - 00:20:35.080, Speaker C: So the data can be skipped if there's no data in the header.
00:20:35.900 - 00:20:50.216, Speaker E: No kind of the other way. Right. You now need to kind of indicate the data section, but you can put the size zero there and the same for the subcontainers. I mean, this is deviation to require.
00:20:50.248 - 00:20:52.780, Speaker C: Subcontainers, not just let them be absent.
00:20:53.680 - 00:21:42.392, Speaker E: Kind of feels like this is not consistent, at least. I'm not sure we need to talk about it right now, but maybe there's something to consider for the next time. I'm not sure how much bytes we already put there. But yeah, I think there will be like three additional bytes that kind of have to be there. Well, I think someone needs to check what the overhead is. But if we want to be more consistent what we presented before, I think that's the direction. Yeah, but I don't have any problem with the putting data.
00:21:42.392 - 00:21:47.550, Speaker E: It feels more natural for me as well to put data section as the last one.
00:21:55.390 - 00:21:56.140, Speaker A: Cool.
00:21:57.070 - 00:22:01.980, Speaker B: Okay, I will add that to the notes. What else you got?
00:22:03.550 - 00:23:33.350, Speaker C: So, while implementing call delegate call static call for the EOF, the proposal was to change it in place at the same opcode. So instead of taking six or seven opcodes, to take two or three opcodes, depending upon the context, and it's the same operation number, and that with the same opcode number having two different call stack items felt a little weird, and I wonder if we should reconsider that. And I know one proposal that went out was a call x operation where we would combine call, delegate call and static call in a single operation with one immediate byte that would have flags as to whether it's a delegate call, whether it's a static, and we'd have room for other flags with 43 37 coming on the scene. They have a new validation mode that requires rejecting, not evaluating environmental opcodes like block number and block hash. And so growth in calls like that where we could add a no end call and have a no end flag where those will be prohibited in the call as context. Moving to a call x type one where we have these eight flags that we could adopt does provide room for adding new features in call without having to create a new opcode. It still would create overhead on the frame and the stack operation, but that's one option.
00:23:33.350 - 00:24:14.390, Speaker C: And another option across my mind is if we could just get new opcodes for call two, delegate call two, static call two, that would be the two or three opcode version of it. These, I think are less, these are more annoyances. I don't think it's going to necessarily break things, but it introduces more. This is the rule, unless it's this situation type sort of thing that comes up in a lot of compilers where f one is call unless you're an Eof in which it's call with only three yards. It's my goal to try and reduce these. It's this, unless that type situations. If we were to give them their own op codes or move to a new combined opcode.
00:24:21.830 - 00:24:53.480, Speaker B: Any thoughts on that? Looks like Paul responded and said he wasn't convinced on the call X idea. I didn't quite understand the Call X idea. You were saying that there's a lot more cases that we might want to add flags for. Did you have an example?
00:24:53.930 - 00:25:16.720, Speaker C: So right now the two flags we would have in collex would be whether it's a delegate call or a static call. Another flag we might want to add would be no environmental calls because those static is basically blocking out certain opcodes from the call in the stack frame that will cause an exception. We could have another one to add that in. That would be something that account abstraction would like.
00:25:17.650 - 00:25:18.382, Speaker B: Oh, I see.
00:25:18.436 - 00:26:26.700, Speaker C: Call X would either be three opcodes and value just wouldn't be used in the case of delegate call or static call and require those to be zero. Or if those flags are set we would only accept two, which would not necessarily be a good thing to change the number of arguments popped off the stack based on the size of the mediate. But if you view it as a two byte opcode, it's not too awful. There's lots of things to discuss about it. It might not be the best solution, but the thing that bothers me is having one opcode number have two different stack operations based simply on the context of is this code run in EOF or is this code run in legacy? There's significantly different handling that goes on with them in regards to return data. And I guess it's just return data input return data value. What are the two I'm missing anyway?
00:26:30.590 - 00:26:37.900, Speaker B: Any thoughts on this guys? Should we table it? Should we discuss it at a later point?
00:26:45.280 - 00:26:45.644, Speaker A: Yeah.
00:26:45.682 - 00:27:02.880, Speaker C: Who you're calling the value. So actually it'd be three or three or four. Three or four. Because you need the address value might be optional. The args are passing in. The returns wouldn't come in the memory but we're chopping off. We're also chopping off gas.
00:27:02.880 - 00:27:12.790, Speaker C: So whether we get those three items or not in there just feels. I don't know, maybe we should table it and let people think about it as they implement it.
00:27:16.540 - 00:27:58.520, Speaker B: I guess one thought I have on it I am not so deep in EOf right now. So I don't know. I don't have as much context about how important it is to support these other opcodes. The only thing that I can say is that I think Call X isn't my favorite solution. I think if we were to go down that path I would probably prefer just to have separate opcodes, like have a call opcode that doesn't allow state access and come up with a name for it. We have plenty of ops available. Still, I don't think that we necessarily have to just put it in a compound op, but that's like a really minor thing and something that I could be convinced otherwise of fairly easily.
00:27:59.260 - 00:28:07.320, Speaker C: But how about a new run of call delegate call static call opcode allocations for the EOS use case where there's three fewer arguments.
00:28:10.000 - 00:28:15.740, Speaker B: That way you don't have the conflicting op meaning different things in different contexts.
00:28:16.080 - 00:28:24.240, Speaker C: Yes, f one always means legacy call semantics, and like say e one would mean gas free semantics.
00:28:28.970 - 00:28:36.662, Speaker B: I probably need to think about it a little bit more. My intuition is that it's not something that worries me a lot, but maybe.
00:28:36.716 - 00:29:17.480, Speaker C: I should be okay. Put it out there as we think about it going on, so I guess we can table this. My final point is a discussion on ext data copy. That's one feature that we are losing from moving from code copy to data copy is the ability to copy data, just the data section from another contract. There are people out there who are using contracts as data sources. I'm okay if it goes either way, but I think we either need to explicitly allow ext data copy or call out in the rational of whatever appropriate IP that this will make data contracts impossible and we're okay with that.
00:29:28.580 - 00:29:30.130, Speaker B: Any thoughts on this?
00:29:34.570 - 00:29:48.250, Speaker H: Maybe a question related to it? As the EOF versions change and these things, certain things become disabled and other ones not obviously, you can always just use legacy formats or previous versions.
00:29:52.290 - 00:29:55.310, Speaker C: Is the objective here to get basically.
00:29:55.380 - 00:30:20.040, Speaker H: All new contracts, move over to the most recent EOF version every time? Or is this kind of more of creating more specialized contracts that maybe a certain EOf number is used for a specific thing or something like that? Because I mean, data contracts would still exist, right? And they can still be read, just not from an EOF contract, right?
00:30:22.490 - 00:31:41.120, Speaker C: So they can still be read. But there's another piece that is important for this is that we're not allowing EOF to delegate call legacy contracts to prevent escape hatches like this? My vision, generally speaking, I've heard other people discuss this at an interrupt we were at, is that there would be at most one, maybe two EOf versions live at a same time. And if we propose a new backwards incompatible EOF version, then we would need to have some standard transpolation from, say, EOFV one to EOFV two, and all EOFV one contracts in the system, either as part of a single point migration or when we go to the next version, are interpreted or transpiled in the EOFV two and operate under EFV two. So if we do things like we change, like some of the stack orders, some of the stacks, or we totally redo how all the opcode mappings work, that there is a standard process we can do to say this EOF contract looks like this in EOFV two. So that's why we're going through this whole exercise of deprecating entire concepts like the concept of code visibility, that you can view the code within your concept. To make sure that we can maintain this transpileability going into the future, identifying things by code hash is going to be a necessary casualty. Those will just become identifiers if we ever need to use that sort of a situation.
00:31:41.120 - 00:32:17.580, Speaker C: So that's the vision, is that these versions show major compatibility things, and that we would be able to transpile from v one to v two and v two to v three. And so that in your chain you would have legacy code and you would have EOF code of whatever the appropriate fork version is. So I don't think the vision of having multiple versions of EOF is something that we're really wanting to see because of the maintenance burden that the clients have expressed concern about when they see some of this EOF. Some of the EOF proposals that are going around. Ryan, answer some questions.
00:32:19.310 - 00:32:21.360, Speaker H: Answers a few, brings up a few others.
00:32:22.370 - 00:32:26.142, Speaker B: In particular, there's already a couple of.
00:32:26.196 - 00:32:57.880, Speaker H: Contracts in the wild that kind of abuse mechanics that exist today that maybe won't exist or maybe will change in the future, right? If this is the case, and people are writing like low level elf code, which I imagine they will, I don't know, maybe transpolation won't be as difficult as it sounds. But I don't know, it seems like if there are things that are being taken advantage of that are specific to an EOF version, then changing that would cause some kind of undefined behavior in the contract, right?
00:32:59.290 - 00:33:41.618, Speaker C: That would be part of going to a new version is clarifying what those would translate into the new version and making sure that it can be done. That's why we're trying to keep EOF footprint as small as possible and the amount of undefined as small as possible. So that's one of the arguments for saying that there's no external data copy. But you're right, we could subvert this by not doing a delegate call, just doing a regular call to another contract, who then goes into its data, gets it, copies it into the return buffer, and brings it back. The question is, are we okay with those escape hatches? Because that would actually work with an EOF. If you have a data contract where you call the data, it gets it, and it serves it back to you. That's one way that we may not need ext data copy.
00:33:41.618 - 00:34:14.800, Speaker C: You just have a standard data copy header in it. So we may not even need this and it could still survive with their operations. So I think a lot of the bias is if we can live without it reasonably, we would want to consider that. That's why we're also doing things like we're breaking the gas rules now to where you can only ever send the maximum gas with your calls in the call. Delegate call static call. So if we need to, we could reintroduce that, but we can't remove it without breaking it. So that's why we're biased towards doing all our breaking changes now as well.
00:34:16.130 - 00:34:16.880, Speaker A: Right.
00:34:17.330 - 00:34:29.422, Speaker H: Well, I don't want to take up too much more time on this, but I would definitely argue if we're going with the escape hatch route, then I think delegate calls would be important because it would be easier for protocols to upgrade.
00:34:29.566 - 00:34:29.970, Speaker A: Right.
00:34:30.040 - 00:34:45.020, Speaker H: Since a lot of people sit behind upgradable proxies anyway, I imagine it'd probably be in a legacy format. And so if an EOF version changes and it would cause some undefined behavior and they would need to update, then they could do that through the upgradable proxy. But of course that only happens with delegate call.
00:34:45.630 - 00:35:11.970, Speaker C: Right. Delegate calling into EOF. I think we're allowing delegate calling out of EOF. We're not allowing, and that's because you can delegate call out into something that'll self destruct, and we're trying to keep self destruct completely out of EOf right now. So delegate calling out of EOF to a prior version is not something we're planning on supporting. Honestly, I don't see a reason why we would want to support it. Because of risks like that, of undoing the restrictions that might be added in a new version.
00:35:14.630 - 00:35:16.200, Speaker A: Right? Yeah, makes sense.
00:35:17.050 - 00:35:39.094, Speaker I: I believe with the current implementation of self destruct that it will only be allowed in the same transaction. That will do create two on the same address. So basically the old version of self destruct will disappear. And that argument then is invalidated.
00:35:39.222 - 00:35:39.900, Speaker A: Because.
00:35:43.010 - 00:35:54.862, Speaker I: If we're only disabling delegate call for that reason, then with the new implementation that will come in Cancun, most likely it's CFI for Cancun. Doesn't make sense.
00:35:54.996 - 00:36:39.022, Speaker C: When we made these decisions, we weren't sure what the new version of self destruct is, and I'm not even sure that version of self destruct will survive once we go to the contract analyses and see what contracts we're breaking, because there's a strong bias not to break existing contracts deployed and existing functionality. Maybe we'll do that with the sufficient notice. But when this decision was made to prohibit delegate call, that was the first example and there was not enough known about prior versions. But there's also some other features that we're getting out of it. Like, for example, the observability of code. We can't ext call into legacy code and bring it into the system without deliberate actions on the part of the code. And delegate call is ways that we could get around that.
00:36:39.022 - 00:36:43.040, Speaker C: So self destruct is not the only one, it's just the most flagrant one.
00:36:44.770 - 00:36:46.400, Speaker I: Yeah, that makes more sense.
00:36:49.010 - 00:37:45.060, Speaker E: So my kind of way of thinking is that we still design this EOf to be withholding on its own. So all of this interaction with legacy is just because we already have it, but it's not like we use it as a feature to bring some other features to UF. So I think UF should be able to exist in isolation. So you can imagine deploying new blockchain that we only seof and that should work and without much disruption. So if we think data contract is something really important as a feature, then I think there should be somehow supported. I'm not sure it is. I don't think that mostly to me, data contract seems as something that happened because of this gas model is not really great.
00:37:46.870 - 00:38:14.720, Speaker C: So after talking through it on this call, I don't think we need Exe call, because if you have a data contract, you can write a function that will read your own data and serve it up on request. So data contracts can opt in to serve the data, but the consequence is you can't go in and snoop random data of other random EOF contracts. And I think that's actually a good feature. You can opt in to serve your data through a call, but you can't just go search the blockchain for random stuff.
00:38:15.970 - 00:38:33.540, Speaker E: Yeah, what I mean is that if you would want to migrate such a system to a different blockchain when there is no legacy EVM. Right. So there's no way to extract this data if you need it, because there will be no legacy part of the system to assist you.
00:38:35.510 - 00:38:43.350, Speaker C: Right. I honestly see EOF only l two s as something that's got a very rich vein to mine on for a lot of features.
00:38:47.190 - 00:38:47.842, Speaker E: Okay.
00:38:47.976 - 00:38:48.274, Speaker A: Yeah.
00:38:48.312 - 00:39:00.920, Speaker E: But it's still kind of, I think, in the position that this can be added if it's proven to be needed or something like that.
00:39:02.490 - 00:39:03.240, Speaker C: Okay.
00:39:03.870 - 00:39:08.380, Speaker E: Servative option. Right now I think it's better.
00:39:09.150 - 00:39:19.120, Speaker C: Agree. We can always add if we need it later. So I'm comfortable with that. That we're not going to do it and if we really need it, but we don't think we need it and we think we have options to get out of it if we need it.
00:39:27.790 - 00:39:28.540, Speaker A: Cool.
00:39:29.230 - 00:39:32.650, Speaker B: Anything else spec related?
00:39:48.100 - 00:39:49.650, Speaker D: There's actually one thing.
00:39:50.180 - 00:39:50.930, Speaker A: Yeah.
00:39:51.700 - 00:40:20.440, Speaker D: I spent some time on writing water retrieve seven support with UF and I think we do have everything needed with one exception. Removing gas observability kind of breaks. Four, three, seven. Because that depends on being able to control gas.
00:40:23.380 - 00:40:24.130, Speaker A: Right.
00:40:26.120 - 00:40:38.890, Speaker C: When running as a giant bundle. Yes, it's one of the things that's baked in. How essential is it? Because the spec also says you're supposed to simulate your executions before you even try.
00:40:40.700 - 00:40:45.640, Speaker B: But you need to figure out how much to pay. And so to do this trustlessly.
00:40:47.580 - 00:40:47.896, Speaker A: You.
00:40:47.918 - 00:41:06.470, Speaker B: Have to get the gas used back or the gas left back. Otherwise the bundler just says, I use this much gas and there's no way of proving it on chain without a complicated game.
00:41:09.800 - 00:41:27.320, Speaker C: Well, it's just a side effect of the contract that you're not proving it on chain, you're just making impossible to execute if the bundler is behaving properly to dispatch the gas. And that would be in your smart contract wallet where you'd limit the gas and you would monitor your gas.
00:41:33.920 - 00:41:45.964, Speaker D: Basically. In the worst case, you would have to have enough funds prepaid to cover the total limit of the bundle.
00:41:46.092 - 00:41:46.576, Speaker A: Right.
00:41:46.678 - 00:41:55.388, Speaker D: In the worst case, I mean for each execution included in the bundle, don't.
00:41:55.404 - 00:41:56.870, Speaker B: You kind of already need that?
00:41:58.360 - 00:42:01.428, Speaker D: Well, you have the limit, so you only need to include up to the.
00:42:01.434 - 00:42:02.100, Speaker A: Limit.
00:42:04.040 - 00:42:10.010, Speaker B: Or user operation. Yeah, I guess I missing how that's different than what we were just saying.
00:42:13.260 - 00:42:29.592, Speaker D: Right now, it's limited by what is the limit for the given user operation. But if you cannot limit the gas anymore in UF, then what you need to prepay is the total limit of the complete bundle, which includes a number of other user operations.
00:42:29.736 - 00:42:32.510, Speaker B: The user needs to do this or the bundler does this.
00:42:36.500 - 00:42:43.204, Speaker D: I mean, the user needs to have enough funds, right? But Bundler would need to select such users which have enough funds to cover.
00:42:43.242 - 00:42:44.150, Speaker A: All of that.
00:42:46.680 - 00:42:50.820, Speaker D: Beyond what they specified for the user limit.
00:42:53.490 - 00:43:08.710, Speaker C: Would this be solved by a user operation being much better about estimating how much gas it's going to need if the bundler is always going to charge the maximum gas and never give it refunds. Because I mean, that's really what we lose with the gas is the bundler could always charge the user operation the maximum gas they'll allocated.
00:43:09.530 - 00:43:19.050, Speaker B: That's what I was thinking, which in that. But that goes against what Alex is saying, because if that's the case, then you only have to have your gas limit, not the bundle.
00:43:20.350 - 00:43:26.794, Speaker C: And the bundler would be responsible for ensuring they have enough gas too, based on the bundler would.
00:43:26.912 - 00:43:39.120, Speaker B: The bundler already has to have at least enough gas to pay for the gas limit of some gas limit of all the operations. But I think what Alex is saying is that, he's saying that each user also has to have that much.
00:43:40.550 - 00:43:59.430, Speaker D: Well, basically the sequence, the operations are included. The first one would need to have the total limit, right, because you may spend the total limit, but as you progress forwards.
00:44:02.170 - 00:44:05.930, Speaker B: How do you spend more than what you've put as your gas limit for your operation?
00:44:06.990 - 00:44:12.010, Speaker D: Because you cannot control the gas. Know as you do a creator.
00:44:15.550 - 00:44:15.926, Speaker A: It'S.
00:44:15.958 - 00:44:20.110, Speaker C: The EOA that's being charged for gas. So it's the EOA's job to recoup that gas.
00:44:22.530 - 00:44:23.600, Speaker A: I see.
00:44:28.690 - 00:44:43.170, Speaker C: So you just need to have in your wallet logic that'll refuse to pay if they're charging you more for gas than the user operation allowed for, which would cause the entire transaction, the entire bundle to fail at that point. Or maybe your subfundler, depending upon how good the bundle is written.
00:44:49.220 - 00:45:34.716, Speaker B: I think what happens there is that you end up in this complicated scenario where it makes it reasonably easy for the user to grief the relayer or the bundler, because right now if you just use the result of call, then this is like the de facto cost of the transaction. It doesn't matter what they simulated, the true cost is going to be paid. And so it's totally fair. But if you just rely on the simulation, it's not too hard to construct contracts where you do some crazy thing that makes, so that it simulates one way and executes a different way, and then the relayer ends up having to pay more than the user is allowing to be charged, even though the relayer tried to simulate it. I don't necessarily think this is the worst thing in the world, but it does change the dynamic between the two.
00:45:34.738 - 00:45:35.950, Speaker A: Parties a little bit.
00:45:40.960 - 00:46:01.910, Speaker B: I think we might be going on a tangent as well, and I do want to talk about testing some, but yeah, this is. I don't know, what else do you think about this, Alex? Is this something that we should try and look into and figure out how to support four three seven better in EOf. Is it possible? I mean, it seems like a fundamental disagreement between the two.
00:46:02.280 - 00:46:41.604, Speaker D: Well, yeah, it's not like an EOF disagreement. It's more like a disagreement with this goal of removing that's observability. And four three seven just happens to fully depend on it. I haven't really come up with any solution. The closest we have for that is the transaction packages we had. That's like really the closest option for having proper removing gas observability, but having these kind of features neatly. Yeah, I don't know what the solution is.
00:46:41.604 - 00:47:00.410, Speaker D: Basically what this will boil down to is what is more important, like 4327 style operations as they work today, or removing gas obsoletability, that is, I think the final question.
00:47:02.060 - 00:47:35.140, Speaker C: So you can still run your four three three wallet in legacy mode and have it call EOF contracts and have your user operation call the EOF. Because the first call in would be a legacy call into an EOF and you could limit your gas there. But to allow 4337 to stop the progress of EOF, I think would violate the premise of four three three F that it doesn't require protocol changes. If it's going to induce and limit the scope of future protocol changes, then it's actually causing protocol changes. So that kind of goes against the spirit of what 4337 is claiming as a protocol free support for user operations.
00:47:36.200 - 00:47:36.804, Speaker A: I don't know.
00:47:36.842 - 00:47:50.090, Speaker B: I think that's like a bit of a marketing term. They're definitely planning to constrain future operations and they definitely plan to eventually make a protocol change, whether or not that's in the marketing material right now.
00:47:51.100 - 00:48:31.188, Speaker C: And I think that's fine because if the user operations are top level and it's changing in the protocol, then we can enforce the gas at the protocol level. It's the call level observability that causes all these problems. Why we had to put warm stuff when we upped the price on SDor and s load. That locked a few contracts because people didn't send enough gas. If we can't require them to send all their gas, then we lose the functionality that when we change the schedule. Any solution to unstick a transaction is to send more gas because that'll constrain our design space for fixing gas schedule problems. But I think if they're going to come in with protocol changes, we'll still be able to support it because it's not being done at a call level.
00:48:31.188 - 00:48:32.660, Speaker C: These user operations.
00:48:36.660 - 00:48:37.376, Speaker A: I think we should.
00:48:37.398 - 00:48:42.068, Speaker B: Time box this and talk about testing. There any last quick things we want to mention?
00:48:42.234 - 00:48:43.556, Speaker C: This is definitely something that we need.
00:48:43.578 - 00:48:45.190, Speaker B: To continue keeping in mind.
00:48:52.290 - 00:48:55.886, Speaker D: Yeah, I think my closing thought on.
00:48:55.908 - 00:48:56.720, Speaker A: That is.
00:48:59.650 - 00:49:37.980, Speaker D: I think this will be like a really tricky discussion to be had. I could really imagine based on this fact, like UF would be pushed back further while people still want discuss observability restriction. So I think we definitely should have a proper discussion, maybe on the next call or the one after, and figure out the strategy and good answers and everything around this topic. And maybe the final agreement is going to be that we either don't support.
00:49:38.830 - 00:49:39.980, Speaker B: This or.
00:49:42.290 - 00:49:51.280, Speaker D: Push the risk to the bundlers, or we don't make the changes on the gas. But yeah, let's discuss this next time.
00:49:52.290 - 00:49:59.410, Speaker I: Sorry to take everyone's time here, but can someone remind me why we want to disallow gas observability?
00:50:02.470 - 00:50:04.386, Speaker B: Because if you can observe the.
00:50:04.568 - 00:50:06.882, Speaker A: Go ahead. Light. Okay. Yeah.
00:50:06.936 - 00:50:40.800, Speaker B: If you can observe the gas and then you change the schedule in a later fork, then it changes the behavior of the execution. And so you might have some execution that relies on some specific gas amount being used. And if you rely on that and it changes, then your contract might be broken in a future upgrade. And one goal of Uf two is to be able to just change contracts, to transpile contracts from one version to another. And being able to observe the gas makes it very difficult to do that.
00:50:42.050 - 00:50:42.702, Speaker A: Right.
00:50:42.836 - 00:50:43.470, Speaker D: Makes sense.
00:50:43.540 - 00:50:44.400, Speaker I: Thank you.
00:50:45.010 - 00:50:45.614, Speaker A: Yeah.
00:50:45.732 - 00:51:19.926, Speaker B: Okay, we got four minutes. It would be great if we could talk a little bit about testing. That was kind of where we left things about two weeks ago. I think the last thing that we talked about was we're just approaching the point where we really need to have the EOF test suite at some level of completeness so that client implementers can have something that they're targeting. Does anyone have an update on where those things are? I think Paul and Alex mentioned a little bit in the client update, but I would love a more thorough update.
00:51:20.038 - 00:51:21.260, Speaker A: How it's been going.
00:51:29.100 - 00:52:47.120, Speaker G: Yeah, as Alex mentioned, there are prs in the test repo. I think most of them are almost ready. These are still in draft because, well, there was, there was a pending change or request to retest it in order to check if, when we are checking valid or invalid EF code, we only get if the code is valid or invalid, but we don't get the reason. So we cannot check this specific reason why an EF test is failing. But yeah, I think for now we are not going to use this format. The prs as they are right now, I think are good to merge into the main branch, at least for the version one of UF.
00:52:50.230 - 00:52:56.180, Speaker B: Awesome. Is that something we can try and make sure it happens before the next call in two weeks?
00:52:58.630 - 00:53:01.400, Speaker A: Yeah, I think so. Okay, great.
00:53:04.490 - 00:53:08.230, Speaker B: Two minutes left. Any other comments on testing?
00:53:08.570 - 00:53:09.590, Speaker A: Simon?
00:53:10.250 - 00:53:30.058, Speaker F: Okay, about testing. Well, from our side in Nevermind. We are having a bit of problems regarding testing because we have some test cases that fail and we don't know why they fail yet. And I have a small question regarding get does get passes all the tests?
00:53:30.154 - 00:53:32.990, Speaker C: All the state tests of uf?
00:53:37.620 - 00:53:49.990, Speaker G: Yeah, currently the tests are filled using get and currently it is agreeing with EBM one as well. So both of them, can you link.
00:53:51.240 - 00:54:16.860, Speaker F: The main branch or the main pr for of get EOF implementation? Because we have one here and when we run the state test with the current merged UF tests, we see that some tests fail. We're not quite sure. We're still double checking, but it's weird.
00:54:18.560 - 00:54:40.080, Speaker B: So Hugo has been working on, Hugo's been working on diff against my branch and I was working on a diff against branch a while back as well. So I think Hugo's branch is kind of the latest. Not to the pr that's currently in draft against Geth. So if you could share that branch with them, Hugo.
00:54:44.900 - 00:54:45.650, Speaker C: Cool.
00:54:47.940 - 00:54:51.880, Speaker B: Okay, the top of the hour. Any final comments?
00:54:55.260 - 00:55:01.380, Speaker C: Can all the clients post where their main work branches? So we could do cross client testing possibly.
00:55:01.460 - 00:55:12.380, Speaker D: Or at least see how and the same testing. So just to know what is the latest branch of the testing?
00:55:14.640 - 00:55:30.470, Speaker B: Yeah, would someone from epsilon mind adding that to the mega EOF spec? Or make another meta hack MD to track these things? Or at least a place where you can share with client teams to update with their branches and that stuff?
00:55:40.570 - 00:55:40.934, Speaker A: Yeah.
00:55:40.972 - 00:55:51.320, Speaker D: Should we actually keep extending this UF one checklist or should we do like an uf two checklist with a new collection of things? What would be the best.
00:55:53.850 - 00:55:54.546, Speaker A: An EUF.
00:55:54.578 - 00:56:00.620, Speaker B: Two checklist for UFV two? Because I think that they're asking about the EFV one things.
00:56:01.410 - 00:56:04.640, Speaker F: Yeah, the v one stuff.
00:56:06.210 - 00:56:08.910, Speaker B: Oh, and a new checklist for mega elf.
00:56:12.610 - 00:56:17.140, Speaker D: Yeah, we can update the old one and then maybe start a new one.
00:56:17.510 - 00:56:43.930, Speaker B: Okay, that would be excellent. Okay, 1 minute over, I'm going to post an update with a couple of the things we talked about from the spec section of the call on the PM issue. I'll open an issue for the employers call number twelve and talk to you guys again in two weeks. In the meantime, feel free to chat on the EVN channel on the eth R D discord. Thanks a lot.
00:56:44.080 - 00:56:45.958, Speaker A: See you later. Thank you. Bye bye.
00:56:45.974 - 00:56:46.762, Speaker I: Thank you, everyone.
00:56:46.896 - 00:56:47.980, Speaker C: Thanks, everyone.
00:56:48.990 - 00:56:49.480, Speaker A: Thank you.
