00:00:00.320 - 00:00:30.482, Speaker A: I'd like to welcome everyone to UF. Implement a call number 62. It is the 27th of November. This is our first meeting since DEVCON. So the agenda is a little haphazard right now, but we'll go through it. But I think I first want to open the floor to see if anyone has any comments about anything that was discussed at devcon. They want to add anything to the agenda or want to discuss anything, make sure that we get through it.
00:00:30.482 - 00:00:46.706, Speaker A: I'll go ahead and open the floor if anybody wants to say anything. Everyone have a good time at devcon. Who went? It was.
00:00:46.778 - 00:00:52.390, Speaker B: It was very good. Unfortunately, I got something terrible on the way back on the playback.
00:00:56.850 - 00:01:27.610, Speaker A: Okay. So yeah, there were lots of good sessions, lots of good discussion. So I guess we'll start with the regular updates and the things I remember on the call and in the checklists. I'll go through. Let me get my notes started. So, testing update. Do we have anyone from the test team on the call? Not seeing anyone.
00:01:27.610 - 00:02:22.280, Speaker A: So guess one update. Maybe we should talk about it. Getting some work done on the fuzzer and one of the bugs I tripped on my side was I produced some state tests with invalid eos, which, lucky for me, proved that GOEVM Lab would detect the difference, because GETH and BASU handle that situation differently. When there's invalid eof, BASU will set the contract to have no code and Geth will happily have the code and run it if it parses. And the question is, how should we handle that? Or should we do the third option in which this date test as a whole is invalid if there's any invalid EOF entries. So what are people's opinions on that?
00:02:25.540 - 00:02:33.560, Speaker B: Is this with starting with invalid yields on the chain or deploying invalid deal?
00:02:33.940 - 00:03:02.238, Speaker A: So this would be running a state test or a block test? A block test, you would import the block and you probably. I don't know if you'd reject it. That's probably a good thing to question. So the state test would specify in one of the. In the allocation sections, one of the accounts would have EOF code. In this case, I didn't rerun the stack height checks, so the stack heights were invalid, but otherwise it parsed just fine. So the question is for state test.
00:03:02.238 - 00:03:29.940, Speaker A: I think it's fairly simple. You validate all the code. If any of the code's wrong, the test always failed, the test can never pass. And maybe we send a different signal and say test invalid. I think that's what was suggested on Discord. But block tests when you have to try and import a block, I mean, how are the blocks even created? I mean, that's an interesting question because if it's coming into a great transaction, the great transaction should. Should reject it.
00:03:31.290 - 00:03:45.510, Speaker B: For blockchain tests, it's the only an issue with the Genesis block because the data state. Right. I think. Right. You cannot just plant an account code in a block.
00:03:46.010 - 00:03:46.750, Speaker A: Right.
00:03:47.290 - 00:04:33.240, Speaker B: Extra protocol. So and I think unless we want to somehow test what happens to a, to any VM implementation that happens for any reason to run invalid eof, execute invalid eof unless we want to do that and define that and inspect this out. And I think those status should just abort. End block tester also should abort and we can follow through with specifying that you know, Genesis is invalid if it contains an invalid EOF code in an account. Yeah, but that's optional, I guess. But yeah, for good measure do we.
00:04:33.280 - 00:04:48.340, Speaker C: Validate code that's not. That's like a different version than eof? I don't understand. Like what does the other blocks past blocks matter or what other code matters in this case?
00:04:49.600 - 00:05:14.840, Speaker A: So it's the same code. Legacy bytecode has no validation. Any presentation of code that does not start with EF is accepted in all places and at all times. And it's just the execution time that the behavior changes. The EOF would be if it starts with EF00. And I guess also for. This is a question for 7702 EF01.
00:05:19.710 - 00:05:25.730, Speaker B: Yeah, good question. I don't know. I didn't see this talked about.
00:05:30.190 - 00:05:37.686, Speaker A: Okay, so you say something, Peter.
00:05:37.878 - 00:05:50.640, Speaker B: I was just going to reiterate that I think we should reject those tests and just say that executing invalid UF code is something that we just do not specify. It's invalid it's undefined behavior.
00:05:59.300 - 00:06:17.150, Speaker A: Okay, are there any corner cases we're missing? Because I think that will cover all of them. When it comes to imported blocks, the only way that EOF goes into the block memory is through a create transaction that has the implied validation. So I think we're going to be good there.
00:06:19.850 - 00:06:29.538, Speaker D: Another case is if block contains creation transaction with invalid EOF that should be rejected, right?
00:06:29.594 - 00:06:34.830, Speaker A: Right. The transaction will execute. It'll notate the invalid eof, the transaction should fail.
00:06:38.570 - 00:07:04.280, Speaker B: And actually I just recall now that in the spec we have a mention that EOF is only safe to be activated in chains where EIP 3541 is active and where there are. No, I guess not. I don't remember the phrasing exactly, but the gist is that there are no invalid TOFs or code standing with EF.
00:07:05.420 - 00:07:14.014, Speaker A: Okay. So I think I'll actually put this on the ACD discussion. Smart, because it impacts 7702 as well.
00:07:14.102 - 00:07:16.290, Speaker B: 7702 is interesting.
00:07:18.070 - 00:07:23.490, Speaker A: Okay, any other testing updates before we go to the next subject?
00:07:26.310 - 00:07:33.850, Speaker B: I don't know if there's been much stuff happening on the testing front. There's no one from testing to say this, right.
00:07:34.220 - 00:07:35.684, Speaker A: Yeah, no one's here.
00:07:35.852 - 00:08:35.450, Speaker B: So I've seen that there's been an initiative kicked off by the testing team to port the Ethereum tests and organize the porting of Ethereum tests to east, which impacts EOF by that it can. If we have those tests in east, then we have. We're in a better position to run them in EOF setting as well, because east has these flags that allow you to run a test in different EVM versions. So there's an issue, like a big tracking issue that I guess organizes it. There's some file and. Well, we can take a look at this. But until then, until that time, there's this opportunistic EOF wrap tool that will make.
00:08:35.450 - 00:08:55.490, Speaker B: That will wrap existing Ethereum tests into EOF when it can, and those tests will be included in the next release. So that will, for example, mean that all the opcodes will be executed and tested in some way in eof.
00:08:56.020 - 00:08:56.960, Speaker A: Okay.
00:08:58.580 - 00:09:08.680, Speaker B: But I don't know when the next release is planned for the. For the ufs. Of course. We can, I guess, ask for one if you want.
00:09:09.860 - 00:09:12.280, Speaker A: So this is the big UF tracker you're talking about?
00:09:13.060 - 00:09:49.100, Speaker B: Well, wait, wait, wait, wait. I have. No, no, that should be a recent issue, I would say if you go to east repo, I guess maybe that's not an issue. I've seen it somewhere. Sorry, issue 97972. Open issue.
00:09:56.520 - 00:09:57.152, Speaker A: Okay.
00:09:57.216 - 00:10:35.510, Speaker B: Yeah, yeah, yeah. So there's, I guess the plan of the testing team for the porting, and I think that someone had already started some contributions and that's all I know that I can report.
00:10:36.050 - 00:11:08.030, Speaker A: Okay. That's worth noting though. All right, any other testing updates? All right, any client updates or compiler updates? I don't think much has happened since it got pushed to Osaka. I think all of the main client engineers have been redispatched on getting Pector out quicker. Correct me if I'm wrong on that.
00:11:08.150 - 00:11:18.450, Speaker B: I mean, I know that solidity support is like an ongoing effort to merge it into main as an experimental flag.
00:11:20.550 - 00:11:20.926, Speaker A: Yeah.
00:11:20.958 - 00:11:22.190, Speaker C: So I don't know.
00:11:22.310 - 00:11:36.970, Speaker E: Yeah, I mean, Your solid support. We currently on like merging function supports for like colef, retaff jump and basically progressing. Radek is working on it and it's going well.
00:11:38.550 - 00:11:39.518, Speaker A: Okay.
00:11:39.694 - 00:11:41.250, Speaker B: Stable as she goes.
00:11:44.390 - 00:11:47.610, Speaker A: And my understanding is across many PRs right now, it's not just one.
00:11:51.190 - 00:11:56.770, Speaker B: Yeah, there's a bunch of. It's like you can see 1, 2, 3 PRs.
00:11:58.050 - 00:12:09.270, Speaker C: Now there are three PRs to be. To be merged. One is under in the review process and the other two are waiting until the first one will be merged. So they all depends on.
00:12:10.290 - 00:12:11.082, Speaker A: So.
00:12:11.266 - 00:12:28.320, Speaker C: So we just. We just merge them one by one. I think this prs. So this one which is now in the review and the additional two should be matched this week, maybe early next week.
00:12:30.860 - 00:12:41.680, Speaker E: Yeah, and I'll add that like important intermediate milestone is for us to be able to run all the semantic tests we have in the compiler and basically with those PRs, we kind of. Almost there.
00:12:49.430 - 00:12:50.890, Speaker A: Okay. It's all of these.
00:12:52.230 - 00:13:09.530, Speaker C: No, the three first PRs are okay. The fourth one is unrelated actually and the last one is just a big one PR which was splitted into many different PRs by one by one.
00:13:24.240 - 00:13:56.594, Speaker A: All right, that's actually good. Good compiler update. All right, what's next on the agenda? Spec updates. Got one from Kazdogan and Brangio would want to discuss generic contracts later. Should we start with. Did I pronounce that right? Kuzdogan? Is he on the call?
00:13:56.682 - 00:14:05.190, Speaker F: Yeah. Don't pronounce the G. Okay. Oh good. Is the next. Or is this big updates?
00:14:07.380 - 00:14:19.820, Speaker A: Spec updates. So this will be a proposed spec update, I guess. Spec updates or other. Yeah. Okay. So yeah, go ahead.
00:14:19.940 - 00:15:10.000, Speaker F: Assuming this is next. Next item. So yeah, I put a TLDR on the issue. So this. So first of all, I'm Khan from the sourceify team and my teammates Manuel and Marco are also here in Bangkok. We had a meeting and discussion with the Solidity team about the metadata hash that the SOLID compiler places right now. It's appended to the bytecode and I guess with the EOF there hasn't been a specific discussion or specific place for this and we believe there is benefits to have a separate metadata section in eof.
00:15:10.000 - 00:16:03.570, Speaker F: Basically this is part of the data that is unreachable by the code. One reason being any change in this field does in fact affect the rest of the bytecode because if the metadata hash length changes or like the. In general, this metadata hash is part of the CBOR AUX data which contains also the solid diversion. So any change in this data changes the offsets, the Data needs to be read. Not like this part won't be read, but the other data. So effectively any change in this metadata affects the main bytecode. So we believe it is a good practice to have a separate metadata section.
00:16:03.570 - 00:16:10.770, Speaker F: Did I miss anything? Camille or Marco? Manuel.
00:16:12.630 - 00:17:09.750, Speaker E: I think that's basically it about like making it easier for verifiers because like if removing metadata changes, the code kinda becomes much more complex. And there's one other thing that we could maybe work around it, but like say keeping zeros instead of metadata when the user request to remove it. But there are several downsides to that. One is of course the cost of having the bigger bytecode. But also like this size of this metadata CBR section kind of is dependent on several factors like on the code and like parameter parameters and stuff. So it's not that simple. And yeah, basically our solution if we don't have separate metadata section would be to just omit it and it would shift all those offsets in data load instructions when done, which kind of complicates stuff for verification.
00:17:10.730 - 00:17:41.700, Speaker F: Yeah, I forgot to say we are basically coming from a source code verification standpoint and right now the verification gets quite messy. We have a lot of workarounds to locate where this data is and having a dedicated section makes it really easy for verifiers and. Yeah, and I guess like Solity has this field right now, but I presume other languages might want to add other stuff to this field.
00:17:43.370 - 00:17:54.390, Speaker A: So this would just be like a field where we give you a length of data and at runtime the runtime wouldn't care what's there. Would that be a correct understanding?
00:17:55.530 - 00:17:56.514, Speaker F: Yeah, yeah, exactly.
00:17:56.562 - 00:18:02.470, Speaker E: Like we don't even need like any instructions to access it because it's only really read like offline by verifiers.
00:18:03.610 - 00:18:54.730, Speaker C: Yeah. And from the perspective of the compilers, this metadata section now as it's implemented now in the current Solidity UF support, it's added at the beginning of the data section of the UF container. And basically it means that for example, data which is available from the, from the, from the runtime. So for example, for example, for example some immutables variables, values which are stored there have to be or they have to be placed in the meta in the, in the data section after the, the metadata. Metadata part. Because, because of the, of the reason. Because they are, they are basically initialized.
00:18:54.730 - 00:19:25.510, Speaker C: The value are in is initialized of this immutables is initialized during construction contract creation before return contract call. So and, and the data is basically Appended to the end of the end of the. The data section. So, so that's why it's kinda, I think reasonable to have a, have a optional metadata section for this. But. Yeah, but.
00:19:26.930 - 00:19:27.258, Speaker A: Yeah.
00:19:27.274 - 00:19:33.710, Speaker C: So from the compiler, compiler perspective, I think it's. It makes a lot of sense to have it separated.
00:19:36.170 - 00:19:37.830, Speaker A: Okay. Frangio?
00:19:38.730 - 00:19:47.710, Speaker G: Yeah, I'm not sure I understood yet. What. So can you explain how the size of the metadata section can change?
00:19:51.130 - 00:20:46.040, Speaker F: The metadata section would for example in solidity case that would contain the CBOR data. The CBOR data is basically some mapping that is encoded in CBOR encoding that can contain multiple things. One, the Solidity compiler, version 08, 11, whatever. Then the metadata hash, which is either an IPFS hash or a swarm hash, by default IPFS hash that resolves to the metadata file which contains bunch of information about the compilation. There is also an experimental flag. So if this contract was compiled an experimental flag, this CBOR section contains experimental true as well. So any change here would cause a different metadata section.
00:20:46.040 - 00:21:07.990, Speaker F: The terminology is quite confusing, I can imagine. Any change in the contents of this section would change the length and in turn with the current setting, this would change the offsets of the data read operations and this would in turn change the code, which makes verification quite difficult.
00:21:11.610 - 00:21:35.830, Speaker G: Okay, I see. Yeah, yeah. Do you have some sort of circularity there in the sense that is it still possible to construct the metadata even if like with the current state of things?
00:21:40.130 - 00:22:01.870, Speaker F: I'm not sure if I get the question. So there is multiple metadata. One, this bytecode metadata. Now we are talking about the section to the metadata file which is the solidity contract metadata. It is a JSON file that contains ABI source files, compiler settings and so on. Does that help?
00:22:02.650 - 00:22:06.310, Speaker G: Yes. No, no, I think I answered myself.
00:22:06.810 - 00:22:07.670, Speaker F: Yeah.
00:22:10.250 - 00:22:26.000, Speaker E: I mean also like basic problem is not in constructing the metadata, but about like the compiler provides an option to omit it and that causes differences. So one, the metadata CBR can be different lengths and also it can be omitted like when the user requests that.
00:22:26.620 - 00:22:28.400, Speaker A: And it could be stripped, right?
00:22:29.420 - 00:22:31.668, Speaker F: Yeah, I can.
00:22:31.804 - 00:22:33.560, Speaker G: Stripping post compilation.
00:22:34.380 - 00:22:39.800, Speaker A: Yeah, stripped post compilation. And you reconstitute the contract and have zero impact on the code.
00:22:40.700 - 00:22:43.400, Speaker G: Shifting the indices, the data indices.
00:22:43.910 - 00:22:50.430, Speaker A: Well, if we had a separate section, you wouldn't shift the data indices, right?
00:22:50.470 - 00:22:56.410, Speaker G: No, but it's. Yeah, you can't strip it. I think you can only zero it out.
00:22:57.990 - 00:22:59.650, Speaker A: You strip it pre deploy.
00:23:05.830 - 00:23:16.510, Speaker E: I mean with the compiler it's basically more like not emitting the section at all and it changes the offsets into the Data section. So basically immutable locations.
00:23:19.250 - 00:23:45.660, Speaker C: Yeah, I think that that's the crucial problem here, that when you remove this metadata, you need to update also all the, all the data load and immediate arguments in the code. And I assume they this to be made much easier just removing this metadata section without changing basically the bytecode of the contract.
00:23:47.880 - 00:24:06.540, Speaker G: But this is a decision that happens at the beginning of compilation, right? Like before you begin to emit any code at all, you already know whether you'll have metadata or not. So yeah, I'm not sure I see the issue.
00:24:07.880 - 00:24:30.600, Speaker A: So one thing that bothers me is whether or not you're putting the metadata down or not is it too changes the output code, it's going to change the indexes for the data. So metadata present versus metadata not present does have an impact on the code and it shouldn't. If it had its own compiler, if it had its own container section, then it won't. Either the metadata is there or it's not. And the data section truly belongs to the data.
00:24:36.820 - 00:25:13.728, Speaker B: I also see like another downside of using the data section for this. It is that the guarantees that cannot impact the behavior of the code are smaller. I mean, I guess you can guarantee that no one reads, I mean the code doesn't read that part of the data section, but I guess it's harder. And with the metadata section you have 100% guarantee that will never change the behavior of the contract, which is I guess the point of source verification. As I understood the articles you posted.
00:25:13.824 - 00:25:25.424, Speaker E: I mean, I really say this like more like side benefit because like on legacy we don't have this guarantee at all. Someone could craft a code that depends on metadata, but having this in UF would be like really a good thing. So.
00:25:25.512 - 00:25:38.180, Speaker B: Yeah, yeah, yeah. So that's what I mean. It's not only the offsets problem, but also it's kind of cleaner. It's. It's invisible data to the evm.
00:25:42.920 - 00:26:03.910, Speaker A: Okay, quick temperature check. People like it, don't like it. Should we ask for an EIP be written up for this? Anyone have problems with it? Anyone like it or merely okay with it?
00:26:04.770 - 00:26:25.660, Speaker B: I think it's reasonable. Okay, maybe we should like, what's the best alternative that we can come up to this. And if the alternative sucks, then maybe that's a good indication that the idea is sound.
00:26:26.640 - 00:26:28.088, Speaker A: I think the alternative is what we're.
00:26:28.104 - 00:27:00.214, Speaker B: Doing right now, which is, sorry, like something else altogether. If any ideas. I don't know, I don't know. We cannot have a. I don't know. A sub container but that would require a reference to that, things like that, you know, maybe those are hacking and inelegant then. This is so good.
00:27:00.302 - 00:27:26.170, Speaker A: Another thing that was requested by, I can't remember who it was, is a place to put debug symbols for stuff like remix. And that sounds like something that's more appropriate for Sidecar than for putting directly in the contract. Although apparently it's put in the contract a lot always anyway because the revert reasons that Solidity uses, for example, are hard coded in some places on occasion.
00:27:30.190 - 00:27:34.982, Speaker B: By Sidecar we mean something like with the IPFS file, a separate file that.
00:27:35.006 - 00:27:44.010, Speaker A: Goes peer to the class file. But I don't know if that's. That would totally re. That would upend the whole development process because everyone's expecting one file.
00:27:50.080 - 00:27:55.544, Speaker B: We have the metadata output from Solidity in JSON which goes to the ipfs as I understood. So the dbx.
00:27:55.592 - 00:27:56.664, Speaker A: Yeah, we already got that.
00:27:56.752 - 00:28:03.220, Speaker B: Land there and just, you know, be transparent to what we are designing here.
00:28:04.080 - 00:28:04.820, Speaker A: Right.
00:28:05.600 - 00:28:10.794, Speaker B: This is just another piece of the metadata that we, that we are processing.
00:28:10.992 - 00:28:42.830, Speaker A: The problem with the Sidecar metadata, it doesn't go on chain and that's where sourcefy needs it to verify it, get some identity. But yeah, it's an interesting problem. Anyway, I think the best way to progress this was if we had an EIP proposing in addition. So that would be the next step to get something tangible to look at. And unless there's some better option coming up, I think this solves a lot of problems.
00:28:45.810 - 00:28:59.030, Speaker F: Cool, sounds good. What do you think the perception would be in ACT or as an outsider asking this?
00:29:01.730 - 00:29:31.680, Speaker A: So an outsider with support from the team I think would go well in ACD is an outsider proposing it would show that this is something the community wants, not something that we just thought of ourselves and thought gee, wouldn't that be neat? And it shows that customers want it and it shows customer value and I think that would resonate. And I think one of the things that's going to be helpful is since we've been moved to Osaka, we got room to change stuff. If this was for Petra, there's no way it would get in, but yeah, good, nice.
00:29:32.260 - 00:30:10.140, Speaker B: Yeah, yeah, I second that. It would be great if that would be an outset eip. I mean, of course the. This new section is optional, right? That's. I guess we are on the same page with this. So this EIP could also be an optional addition and the AIPs that we have right now would spec out in full the container format without that section all those containers would be correct and then there would be a new way.
00:30:10.840 - 00:30:38.350, Speaker A: I suppose that's the next question would be do we change the section numbers so they sort nicely? Do we just define a sort order that is not the natural order? So we would have this section come between like section four and five and it'll be section six and then it would just be ordered differently. I mean that's the next question. Do we want to have a nice pretty section numbering or do we just go with the next available section and we put it in the header where it's appropriate and we just deal with the out of order handling.
00:30:45.500 - 00:30:59.440, Speaker B: I mean the first guess would be to pick a new number like that would be five but put it before the data section because we have this appending mechanism as someone acutely pointed out. So it needs to.
00:31:00.540 - 00:31:05.560, Speaker A: Is the header always in order and the body is out of order? Would that be appropriate? Would that be fine?
00:31:06.060 - 00:31:27.454, Speaker B: I don't know. I guess the same order makes sense just to remain sane. And also we have, I guess some, I don't know, muscle memory with what the section numbers mean. So it's also maybe a good idea to not change the numbering.
00:31:27.502 - 00:31:36.774, Speaker A: Right now we have the issue with auxiliary data. Would we then move it in the middle and move this stuff around? I guess blocking and tackling stuff when we get to EIP we can look at.
00:31:36.902 - 00:31:38.090, Speaker B: Yeah, yeah, yeah.
00:31:38.990 - 00:32:03.322, Speaker C: I also wouldn't change current current numbers of current sections and just add the new one which is not the. In the exact order. But it doesn't matter because anytime we will be adding a new section and it looks that we will be adding soon, maybe not in Osaka, but later we will have to add just next number but not in proper orders. You can test this scenario and use the CIP already.
00:32:03.486 - 00:32:10.950, Speaker A: Okay. Because I think we need to keep the data at the end. But maybe that's the only exception. Everything's in order except for the data section.
00:32:15.610 - 00:32:17.110, Speaker C: Sounds reasonable.
00:32:18.010 - 00:32:23.030, Speaker D: So yeah, I actually like the idea of giving data section number like ff.
00:32:24.010 - 00:32:27.714, Speaker B: I was going to say that but I think this is, I don't know.
00:32:27.802 - 00:32:37.590, Speaker D: Not a bad idea. It seems if we are changing the format anyway this will change all the tests again. But like yeah, if the format is changed it's fine. And maybe.
00:32:39.770 - 00:32:44.470, Speaker B: The problem I have with this is that it requires the change to the existing JP's.
00:32:45.290 - 00:32:45.986, Speaker D: Right.
00:32:46.138 - 00:32:53.890, Speaker B: Which is kind of, I don't know, it paints the spec in maybe worse.
00:32:53.970 - 00:32:58.428, Speaker D: Of but it might make sense to change it regardless of metadata.
00:32:58.604 - 00:33:00.360, Speaker B: Yeah, I know. Yeah, I know.
00:33:01.940 - 00:33:13.160, Speaker D: On the other hand, I feel like the order will be broken anyway at some point in the future with this account obstruction sections, for example, which they want to put in front, I think.
00:33:14.980 - 00:33:46.890, Speaker A: Okay, let's think about that. We're not going to solve it today, but that's I think probably the biggest issue. And this will be one last big change for the 1.0 before we freeze it. Yeah, so that's something to consider. All right, what else was next? Frangio, I think. Frangio's Eddie.
00:33:47.370 - 00:33:49.442, Speaker G: No, probably UF Create.
00:33:49.626 - 00:33:52.430, Speaker A: Yeah, yeah, UF Create. Right. Let's go to UF Create.
00:33:54.410 - 00:34:53.800, Speaker B: Okay, so there's this issue that you're, I guess going to. And this is the proposal from Charles. I mean the, the background is that we would like not hashed init container but then this proposal not only gets rid of the container, the init container hash in the new address derivation formula, but also basically anything related to the container. So also no subcontainer index, no code address and it puts all the responsibility of getting that right on the user or the author of the contract, I guess, or on the compiler to provide some sensible defaults which would be included in the SALT and as such would make collisions between addresses impossible or limited.
00:34:55.020 - 00:34:57.280, Speaker A: It would be entirely under the control of the contract.
00:34:57.900 - 00:35:20.250, Speaker B: It would be entirely under the control of the contract. I mean that would be after the contract's design. You know, you could, you could hard code stuff into the contract if you like, but you could also have it delivered through call data for, I don't know, generic factory service, stuff like that.
00:35:21.030 - 00:36:04.380, Speaker A: I haven't had time to read and review this because I was asleep. My first instinct is we need some sort of a salt itself, like an EF00 somewhere in this. So this is the hash just for ef. But I think removing the hash of the contract should be fine because we got rid of self destruct. We don't have to worry about polymorphic addresses anymore. But I mean they could do games with reverse but that's, you know, there's nothing will be side effect. But the one concern is that people rely on this for what's the counterfactual contracts.
00:36:04.380 - 00:36:16.024, Speaker A: I think if we just notate that, that this is a bad scheme for counterfactuals, then that should be fine. Yeah.
00:36:16.152 - 00:36:17.220, Speaker G: Is it though?
00:36:17.600 - 00:36:26.700, Speaker B: It's like four counterfactuals are were punted to TX create because this is the only one where the code doesn't exist on chain.
00:36:27.350 - 00:36:27.998, Speaker A: Right.
00:36:28.134 - 00:36:38.250, Speaker B: So we would need to, I mean, probably re approach the design of TX create. But we are in a good position to that because we don't have it in the current spec.
00:36:39.030 - 00:37:01.860, Speaker A: So it's limited counterfactual. I mean I guess you could prove the execution, but there's ways to mess it up because you could create off of any of your sub container objects. You could have like five contracts you would deploy based on arbitrary tall data and that's how it would defeat counterfactual. But you would still be limited to five contracts. But it's not. You're right, it's not a true counterfactual. And so we have TX create.
00:37:06.400 - 00:37:38.990, Speaker B: Yeah, my personal opinion is that this has some pros, but I'm quite worried about that. That's a lot of responsibility for the, for the smart contract and that could lead to errors which will then cause people to have their contracts bricked and unable to do something that's important because they cannot create.
00:37:40.970 - 00:37:41.710, Speaker A: Right.
00:37:43.140 - 00:37:48.316, Speaker B: Which I don't know, maybe paranoid but.
00:37:48.468 - 00:37:54.444, Speaker A: Oh, don't forget delegate call. You can delegate call to another contract and have them create because it's going to be the sender address.
00:37:54.612 - 00:38:24.490, Speaker B: I mean that is, that is covered. I think this is where my understanding gets kind of blurry. But the sender address would be the contract that does the delegate call. So it's just moving the witness to another contract which you know, also you, you know what it does. Right. So we can design it in a way that it passes the right salt, for example.
00:38:25.950 - 00:38:34.670, Speaker A: Yeah.
00:38:42.280 - 00:39:50.890, Speaker E: So I'd like to add some perspective from the solidity side because like we discussed this today, I want actually to post an update in the thread but to be for the. The call. But overall you kind of also like concerned about like making this like too generic because it moves a lot of response to the user of the user of the contract. Like especially having to mix stuff into this salt. Like we probably wouldn't want to hide this thing under the syntax with some compatibility code added by the compiler. So we probably would end up with user being responsible for always calculating this salt manually on EOF and that that would create a bit of complexity and it also would probably be more costly. So yeah, from our perspective the proposal with still keeping the container index in there was a bit better because it still hides some of it.
00:39:50.890 - 00:40:18.170, Speaker E: Yeah, and like another concern from our perspective that for example, let's say someone wants to deploy the same contract twice. It might not be like obvious at all that they have to like. I mean it becomes like much more complex than that because now you basically use new multiple times and like you get different contacts deployed now we'd have to like to disambiguate it with salt.
00:40:19.550 - 00:40:33.220, Speaker D: This is already broken with current scheme. We discussed it a bit before, like. So now you have to provide different SALT if you create the same thing twice, otherwise it's a conflict.
00:40:36.040 - 00:40:48.100, Speaker E: Yeah, but I mean still it makes like. I mean this is basically these things to the user. So kinda, we kinda go with it with strength. But yeah, I mean it's still like more complexity.
00:40:55.810 - 00:41:04.990, Speaker G: Yeah, so. So we're concerned about this then that should also extend to auxdata is kind of what I'm hearing.
00:41:09.810 - 00:41:10.714, Speaker D: What do you mean?
00:41:10.802 - 00:41:29.740, Speaker G: House Ox data related the fact that the arguments are not included in the address computation. So if you want to do that you need to manually put them in the salt and that's already a risk of getting collisions.
00:41:32.320 - 00:41:47.350, Speaker D: On the other hand, it's a flexibility of hashing or not hashing the input arguments. And then in some cases maybe it's beneficial not to. That's what I got like from discussion today.
00:41:48.450 - 00:41:52.070, Speaker G: Yeah. So the flexibility can be good, but it also introduces some risk.
00:41:55.570 - 00:42:32.100, Speaker B: But what if. What if. Is it like a big problem for cross chain deployments which I don't really know a lot about. Know a lot of about. Sorry, but the more you include mandatorily in that hashing scheme, the less chance of having the same address on different chains you have. And auxdata seems like a first candidate to throw out because I don't know, I would expect different chains to come with different auxdata.
00:42:34.930 - 00:43:04.790, Speaker F: Does AUX data. What are we, what are we referring to with AUX data here? Because another issue related might be with the metadata section that there's. There's a. Like people commonly complain about the metadata hash and they leave it out because it affects CREATE two. Could it be. Could we also exclude the metadata field here? I'm not fully. Yeah, I don't fully know the spec here, but.
00:43:05.730 - 00:43:23.830, Speaker B: Oh, that's. That's a good question actually we should. We should remember to. To be wary that these two propositions interact with each other, I guess. So you would say that the metadata should be excluded from the address derivation, right?
00:43:25.330 - 00:43:29.714, Speaker F: Yes. Yes. That would solve a bunch of problems that current.
00:43:29.882 - 00:43:31.590, Speaker B: Okay. Okay. Oops.
00:43:33.210 - 00:43:46.430, Speaker E: I mean that's actually another argument for having separate section because currently being in data section can affect execution and having separate section wouldn't be able. So it would be like much bigger argument for excluding it.
00:43:47.130 - 00:43:56.930, Speaker B: Yeah, yeah. I mean this is a good argument for also not hashing. They need container as a whole. So for. For this proposal, particularly in any form.
00:43:59.710 - 00:44:11.650, Speaker E: Yeah, I mean it's probably fine, but still like it should be something that like uniquely indicates the container like the subcontainer ID and I guess this code address.
00:44:15.470 - 00:44:32.580, Speaker A: So I heard the word probably fine, but that kind of gives me the chills. Can we think of this from the perspective of how might someone exploit this if we just have the address in the hash and maybe that will direct us as to what we should do? I don't know. Maybe. Yeah.
00:44:40.840 - 00:45:45.800, Speaker G: Suppose there's a contract where to claim something you need to trigger a deployment. Maybe it's like a contract that disperses vesting wallets and so it does create, sorry EOF create of the wallet and then it transfers funds to it. But the contract implemented the SALT formula in a way that like it's not correctly binding the created contract to the intended recipient of the funds. And maybe this opens up some sort of vulnerability that it's just kind of one thing that I came up with. But the point here's vulnerability depend on the code. It would be that the developer accidentally introduced something. Right.
00:45:45.800 - 00:46:10.736, Speaker G: And we could say like in the current. In legacy because the arguments are automatically included in the address computation. They sort of carried over that mental model and forgot to make the necessary adjustments any of to get the same guarantees. Does this make sense?
00:46:10.848 - 00:46:44.420, Speaker B: Yeah, it makes sense and I think the it I would say that it would be. It would be on the compiler to provide the good defaults. So if someone doesn't nominate any salt, then the compiler should. Should the ordinal sort of like the non. Call it a non problem. So that when someone does the same thing a couple of times is one thing that's a bit worrisome to me. And also the code address which I think is not available to the vm.
00:46:47.160 - 00:46:49.136, Speaker G: I commented on that on the. On the issue.
00:46:49.208 - 00:46:58.590, Speaker B: Yeah, I've seen but you. I mean not the address, the code address. So if you delegate call that would be the code of the contract that is executing.
00:46:59.490 - 00:47:01.754, Speaker G: No, but what you.
00:47:01.922 - 00:47:02.506, Speaker B: Ah, okay.
00:47:02.538 - 00:47:04.538, Speaker G: There is a way to get the code address. Yeah.
00:47:04.634 - 00:47:13.910, Speaker B: With an immutable or so so you. Okay, so self is like your. Your name for the self would be code address. Yeah, yes, yes. Okay. Yeah, you're right.
00:47:15.250 - 00:47:16.970, Speaker G: Yeah, but okay, that's good.
00:47:17.090 - 00:47:19.510, Speaker B: Sure, I understand that first.
00:47:22.620 - 00:47:23.140, Speaker G: Go ahead.
00:47:23.180 - 00:47:48.140, Speaker E: I don't can provide like good default because like we discuss it like there's. I mean basically shifting to the user. So that's like the similar problem like with nonce. We don't have like Nonce so kind of like breaks unsolted creation in a way that we probably have to require a user to provide salt and probably here will to the user as well. So.
00:47:52.040 - 00:47:57.420, Speaker B: I mean buying that it's expensive. Can you not just have a counter of.
00:47:59.880 - 00:48:00.528, Speaker G: Like.
00:48:00.664 - 00:48:07.344, Speaker E: I mean but where do you store the counter? Probably like to store it. So it's kind of like depends the use case. But that's usually considered expensive, I guess.
00:48:07.472 - 00:48:14.060, Speaker B: I know. I mean that's a safe but expensive default. I guess.
00:48:18.640 - 00:48:34.200, Speaker E: It also doesn't seem like something that we would do automatically because like it needs to have this canvas somewhere in the layout. So we probably would prefer user to have it allocated explicitly. So that wouldn't be like just fire and forget. I would have to like change the.
00:48:34.240 - 00:49:05.450, Speaker G: Syntax in some way accommodate instead of a counter. What I would expect as a default would be to recover the legacy guarantees by getting a salt by hashing a user provided salt with the input and the hash of the init sub container or something like that. So there will be no counter there and you would just get back the create two guarantees.
00:49:07.790 - 00:49:18.690, Speaker E: I mean but cost. So I mean we discussed it today on the meeting. So kind of like Daniel was really skeptical whether this like viable. I'm not for myself, but it still does at some cost.
00:49:28.510 - 00:49:53.660, Speaker A: So we should probably let this do for a while and think about it and come back to the comment link in the issue and at our comments there. We're not going to get resolution today. We've only got four minutes left. Frangio, is that enough time to at least pitch what you're talking about so we can think about it in two weeks or do you want to just take the entire question about generic contracts out to the next meeting?
00:49:55.160 - 00:50:12.320, Speaker G: No, I'm. I'm happy to just talk about that next meeting. I don't have any concrete proposal. I just wanted to sort of get your thoughts on something. I don't know if you have any other topics. I feel that it maybe it's useful to do a little bit of a summary on this EOF create thing.
00:50:13.100 - 00:50:59.090, Speaker A: Okay. So yeah, it's kind of hard to follow all the. All the concerns about the UFC rate. One of the what started this discussion that's a quick summary was concerned about having to hash the container multiple times, trying to improve performance and hashing the container. My understanding is that's also kind of a ZK issue as well, that hashing the container is more expensive in a ZK context than it would be in a regular execution context. So the desire to Remove as many of these container hashings as possible. Would be very beneficial to ZK on creating creates and make creates not as expensive.
00:50:59.090 - 00:51:49.138, Speaker A: Oh, so the first. Yeah, so that's probably the second reason. But the first reason is it violates the contract, the non introspection. Because if you have to hash the container, what if the container has been restated into some different code format? By getting a hash over the container, we have to have the bytecode of the container, which is a way to address the non introspection. You don't get the specific code, but you get it in aggregate, which is kind of, oh, we didn't even get time to get into the ext create, ext code hash and ext code size discussion. We should probably start off the next meeting with that. But yeah, the concern is by including hashes of the of code, we have to keep certain, even if it's just a hash of the old original data, you have to keep it around.
00:51:49.138 - 00:52:48.816, Speaker A: And then there'd be concerns about how would you prove it if we restated into different formats, like if there's an EOF2 or if, if a ZK chain restates it into their ZKVM format, they would still have to keep some reference in that old code around. So by getting rid of the hash, we would get rid of the the introspection concerns. So that's where it starts in. We're trying to figure out ways to running into other issues such as polymorphic and counterfactual. Since we got rid of self destruct, the issue of polymorphic address is gone because people would use a Create2 factory, use some various techniques to have the Create2 factory create different contracts at the same address and then self destruct them in between and self destruct is gone. In the os, that's not an issue. But the issue of counterfactuals, it doesn't quite exist yet in EOF because it was really dependent upon like a create transaction or a create two or a TX CREATE counterfactual.
00:52:48.816 - 00:53:44.154, Speaker A: I mean, you can still have counterfactuals with the plain old create, but by taking the INIT code out, the INIT code hash, it makes more ways to make counterfactuals less factual. So that's kind of the summary and the thing we need to figure out is of taking out any reference to the existing code and the paths within the code. I mean, I would argue even referencing which code section, which sub container section id feels like it's still getting into code introspection because it matters what order your sub containers are in and it leaks one piece of data out of it. I don't know if that's necessarily a bad thing or not, but it prevents us from reordering the sub container sections. I don't know. That's kind of the kind of the summary of where we're going with this. So please leave your comments to this thread up ahead.
00:53:44.154 - 00:54:20.780, Speaker A: If you have security concerns, drop them in. We'll have another call again in two weeks. We need to discuss has code or account type or ext code create didn't get time to discuss that today, but I'll update my ideas into a potential PR change to the eip. Any other questions before we close the meeting? All right, seeing that, I'd like to thank everyone for calling in. I know for the Americans it's kind of a fun time to call in because of the holidays but everyone else have a good week and enjoy Black Friday shopping.
00:54:21.680 - 00:54:23.160, Speaker B: Thank you very much and happy holidays.
