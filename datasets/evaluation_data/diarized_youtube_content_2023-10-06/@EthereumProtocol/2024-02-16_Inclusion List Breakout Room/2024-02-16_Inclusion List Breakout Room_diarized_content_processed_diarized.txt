00:00:00.330 - 00:00:29.430, Speaker A: You. Yeah. Hey, sorry, trying to get unmuted. Hey, everyone, thanks for coming. Happy Friday. Yeah, so I guess can kind of just run through these points bullet by bullet, I guess. Purpose of this meeting is to kind of increase visibility about the current Il spec that we're playing with some of the latest design considerations.
00:00:29.430 - 00:01:10.146, Speaker A: We've been working a ton with POTUS and Terence, so a ton of this work is based on those discussions. And I think we're mostly coming to consensus among ourselves, which is great because we had different views originally and now I think we reconciled those. Yeah. So I guess running through this short presentation, I'll just kind of highlight the three specs, that three spec changes and kind of the high level theme for each of them, which I put in these quotes. And then the main design considerations that we're still thinking about. I have the chat open, making sure no one's chatting. And then.
00:01:10.146 - 00:01:38.346, Speaker A: Yeah, kind of. Hopefully this will only take maybe ten ish, 15 minutes maybe, and then the rest of the time we can just go back and forth, talk about what makes sense and kind of brainstorm from there. So if that sounds good, I'll just launch in. Definitely feel free to interrupt at any point. Yeah, we are making sure. That's funny. Okay.
00:01:38.346 - 00:02:20.970, Speaker A: Right. So I guess starting with the spec docs, I'll just kind of run through the specs in this order. Execution consensus engine. I will say these are definitely like not the end game version. It's just the point of this document was to kind of scope the whole problem and demonstrate that it's a relatively small change in the grand scheme of things. Obviously there is some complexity from the fact that there's execution consensus and engine overlay. Like all three of these are derived from the fact that the consensus stuff has to be verified by the execution engine.
00:02:20.970 - 00:03:14.860, Speaker A: So for that reason it's not purely simple because it's not contained to one of the clients. But I think across the board the changes aren't too complex. Hopefully. Yeah, I guess starting with the execution specs, I'll mainly just focus on this diagram because I think it's the most kind of intuitive way to think about it. And yeah, I guess the execution API's part that changes most significantly is block validation. So when a block is being validated by an execution layer client, we need to add an additional constraint and an additional check, which is that the inclusion list is satisfied by the block and the payload that it was accompanied with. So I have kind of two slots diagrammed here and the beacon block for each of.
00:03:14.860 - 00:04:03.638, Speaker A: Yeah, the inclusion list itself is separated into two parts. There's the summary and then the transactions. The whole point of this summary thing is to not allow for free DA for the inclusionless transactions. And so the summary just contains a commitment to an address. This just means, I guess, semantically there is an address, zero xb. There must be a transaction in either slot n or slot n plus one from this address. And one of the preconditions for accepting the beacon block into your view is that the summary that it contains is accompanied with a list of transactions that are signed from the same proposer that satisfy the inclusionless summary.
00:04:03.638 - 00:04:50.300, Speaker A: So here we have this Il transaction object, which is kind of completely separate from the beacon block, but it's still signed, not signed in the same message, but signed as a separate message. And it has this transaction from zero xb. So the testers for slot n and kind of the network as a whole will accept this block into their view because it has the two components that are needed to satisfy it. You can think of this very much the same as the 4844 blobs. The block won't be accepted until all of the blobs that are committed to in the block body are in the view of that validator. So that's kind of the high level design for this slot itself.
00:04:53.070 - 00:05:11.982, Speaker B: I have a question just quickly. The Il transaction, like the little bluish blob or block, that's the full transaction that is valid with respect to the chain in clear text. There's no hash of it or anything like that, right?
00:05:12.036 - 00:05:35.426, Speaker A: Yeah, that's the clear transaction itself. Okay. It has to be valid in the slot n prestate. So, like before the slot n execution payload is simulated and executed, this transaction has to be valid. Okay. Yeah. The nice thing here is that if it's valid in the prestate, it'll be invalid in the post state only if there's a nonce reuse.
00:05:35.426 - 00:06:04.366, Speaker A: So that's why this whole summary thing just needs to commit to the address. Yeah, right. Thanks, potas. It does also need to have enough gas to pay the base fee in slot n plus one, even if the base fee increases by the full 12.5%. So I guess one of the preconditioned checks for the transaction is that it pays at least that max fee per gas. And Terrence said transaction has to be valid for. Yeah, right.
00:06:04.366 - 00:06:51.870, Speaker A: They both said the exact same thing. So great mind, think like, cool. If there's no other questions, we'll kind of just progress to slot n and finish up this diagram. The block validation for slot n depends on the satisfaction of the previous slots. Inclusionless summary and here in this case we have the execution payload. The transactions has this same transaction that was specified with the slot n il transactions object, and now we can kind of confirm that not only is the full execution payload like all the transactions in it are valid and have signatures, blah blah blah, but also that the Il summary for the previous slot is satisfied. So yeah, that's kind of the general flow.
00:06:51.870 - 00:07:54.820, Speaker A: There's a lot of different iterations and configurations for how these objects get gossiped and stuff like that, but in general, that's kind of the idea. Tim pointed out that it's worth mentioning here, if you're building your own block for slot n, then it doesn't really make sense to put transactions in the Il because you could just put those transactions in the block itself. So the whole point of ils is to have some agency over your block conditioned on you outsourcing the block production to the builder. And we'll get to this. Actually, this kind of like transitions us nicely into the engine API. But yeah, I guess the idea here is that when I'm building a block, or when it's my turn to propose, if I don't want to build a block, I can still build the IL. And even though I don't know what is going to be in the payload of my block, I can still specify the transactions in the Il without worry about whatever comes next.
00:07:54.820 - 00:08:26.750, Speaker A: Cool. Yeah, if there's no questions, I will just keep rolling. We're already at 910, so I'll try and speed up quickly. That was kind of like the main hump to get over, I guess from the Cl side, the changes are mostly just around the data structure itself, so we kind of define these new types. Inclusionless summary entry gosh, this scrolling is really laggy. Sorry about that. The beacon block has this new summary.
00:08:26.750 - 00:09:06.614, Speaker A: The payload attributes are going to have this transaction thing, and we'll talk about that when we get to the engine spec. The P to P spec changes slightly. There's kind of a few ways to do this. You can gossip the Il transactions alongside. I'm just looking at Tony's thing. This depends a bit. If I want to push out, I can still okay, I'm going to circle back to that and maybe in discussion we can talk through it, right? And then in the validator spec itself, it's just the honest behavior is to construct this inclusion list based on the view of the mem pool.
00:09:06.614 - 00:10:01.386, Speaker A: So I guess TLDR the biggest changes in the consensus spec are probably around the p to P and the networking stuff, because it's kind of similar to 4844, where there's these side objects. Hopefully with the 4844 kind of experience and development we've gone through already, this is kind of old hat by this point. But again, part of the open questions and design discussions will be around this very thing. And lastly, I'll just talk through the engine API again, I'll focus on the, just respond to Stokes sidecars. What are we thinking? Yeah, I think I'll go through that once we talk about the design decisions. And then what is the estimated max transactions per inclusion list? Yeah, so we'll also talk about this in the design considerations. There's kind of two approaches here.
00:10:01.386 - 00:10:31.526, Speaker A: You could limit the inclusion list based on, well, obviously you have to limit it on gas. You could also limit it on number of transactions. I kind of am of the idea that just limiting it on gas makes a little bit more sense. I think the fact that you have to have a max number of transactions per inclusion list, you would just take the amount of gas and divide it by like 21,000. Because, I don't know, I think constraining it both on number of transactions and gas is a little weird. Like just doing the gas makes more sense. But yeah, cool.
00:10:31.526 - 00:11:27.742, Speaker A: Just jumping in here. The engine API has basically this new get inclusion list definition, this new interface. So kind of starting at t equals zero, starting at the beginning of the slot. This is the view from a proposer who is building a block and they receive the previous slot block over the PDP. The consensus client verifies it with the new payload state transition function happens and the fork choice is updated if the state transition is valid. And basically now the building process starts for the proposer. So the consensus client sends this work choice updated thing to the execution layer client.
00:11:27.742 - 00:12:43.380, Speaker A: This includes the payload attributes. If the payload attributes, there's some way that it triggers the execution client to start building. And yeah, in the get inclusion list v, one kind of asks the consensus client to request to the execution layer client to grab the current set of transactions that it views as belonging to the inclusion list, return it to the consensus layer client, and then kind of continue the block building as it goes. The get payload is what actually the request from the consensus client to the execution client to get the current best block. So that happens at t equals twelve. And from my impression, the general thing that happens here is that the consensus client is pulling the execution client because there's like blocks being built this whole time during this whole 12 seconds, obviously with the builder spec, which is the spec that defines how the proposer talks to the relay. There's like an extra op in here, but for simplicity, I left it out and basically once it's their turn to produce a block, they publish the payload to the.
00:12:43.380 - 00:12:46.450, Speaker A: Oh, yeah, Enrico, your hand is up.
00:12:46.600 - 00:13:16.300, Speaker C: Yeah, just a question. So you see that get inclusion list requires to have a payload id like to be binded to the folk choice updated that you previously called. So is the inclusion list kind of bounded to the block that is being built by the execution layer? It's just detached engine API that you can pull whatever you want.
00:13:16.670 - 00:13:48.630, Speaker A: Yeah, great question originally, and this is actually something Roman helped me think through. Originally I was thinking, oh, it can be pulled along with the payload, so it could be part of the get payload response. One interesting thing is that really, you don't need to pull for the inclusion list construction. You only need to call it once. Right. Like at the beginning of my slot, I should have a deterministic view of the transactions that I want to put in the inclusion list. And so that shouldn't change over the course of the slot because no new payloads are coming in.
00:13:48.630 - 00:14:14.670, Speaker A: Nothing has changed from the view of the inclusion list transactions. Obviously the payload you're building itself could change, but the inclusion list itself shouldn't because a candidate for belonging to the inclusion list is like, it could have been included in a previous slot, but it wasn't, versus any transactions that are coming in during the 12 seconds that you're building haven't had a chance to be included yet. So they kind of in no way qualify.
00:14:15.250 - 00:14:20.974, Speaker C: They are not supposed to change at the moment. You are actually calling that, right?
00:14:21.012 - 00:14:37.942, Speaker A: So you can call it once at the beginning of your slot and then you say, okay, now I'm going to probably have to send this on to the relay. Like in the reality of mav boost, you'd have to send it onto the relay, but you don't have to continue building it during the 12 seconds and keep updating the relay with your inclusion list.
00:14:38.076 - 00:14:57.980, Speaker C: And they are not bundled with the same get paled vic four, because we want to actually have them independently by the local building because we actually want to send over the network for the builder to get it. So that's why there is a separated engine.
00:14:58.830 - 00:15:16.674, Speaker A: Yeah, exactly. I think Roman kind of pushed back a little bit on this and was like, maybe we should consider putting it in get payload and just calling get payload, because get payload, I guess, gets called repeatedly. I think this is one of the design axes we have, but think that.
00:15:16.872 - 00:15:35.880, Speaker C: There are some cases where you maybe don't call it because this put it a strong connection between the get payload and the inclusion list that you get it. So my gut feeling at the moment is that it's good to have that detached. So there is also different timings that you can follow.
00:15:38.110 - 00:15:42.620, Speaker A: Yeah, my gut was separation of concerns. It just seems better to have a different.
00:15:45.630 - 00:15:55.920, Speaker C: If for some reason your local fails and you still have the chance to go through the builder, at least you have something to send to them.
00:15:56.530 - 00:15:57.920, Speaker A: Yeah, for sure.
00:15:58.690 - 00:17:07.894, Speaker D: Potas yeah, I definitely agree on detached because the timings are really different. You call for the NEl immediately and just send everything to map boost and it might take a longer time to construct actually the block and call get payload. But on top of this, default behavior gets a little tricky. If you are going to construct a local payload and you called in a detached way for an inclusion list, the local El either remembered what was the El that it sent you and doesn't include those transactions in the local payload or doesn't send you any El, and it puts those transactions in the local payload. So if you're constructing locally, I kind of disagree with Tim. I think what he has to do, the default El should be give you an El and construct the local payload without any of those transactions in it. It makes it like for every slot it makes it the same.
00:17:07.894 - 00:17:10.760, Speaker D: With or without map boost is the same kind of calling.
00:17:13.050 - 00:17:14.840, Speaker A: Can you say that last part again.
00:17:16.410 - 00:18:05.960, Speaker D: That you don't have different paths if you're calling with Mapboost or not? Because you choose your block, even if you're using Mapboost, you choose your block after you've received the bead and the local payload. So in order to keep this thing symmetric and not treat in a different way whether you're going to build locally or not, the easiest implementation is you request an inclusion list at the start of a slot. The EL gives you an inclusion list. You call later to get the payload, and the EL gives you a payload that did not include any of the transactions that were in the inclusion list that it just gave you. So that way you're guaranteed that those inclusion lists are going to be included in the next slot and your current payload does not coincide with those transactions. Otherwise we're waiting space.
00:18:06.330 - 00:18:15.020, Speaker C: But that's weird because these are sensor transaction and your local is not going to include it.
00:18:15.390 - 00:18:22.826, Speaker D: Yeah, but anyways, these transactions are forced to be included anyways. So you're guaranteeing inclusion for those transactions.
00:18:22.858 - 00:18:30.590, Speaker C: Which is the thing that matters, you accept a one slot delay to have this kind of guaranteed mempool on chain. Mempool.
00:18:34.470 - 00:19:13.070, Speaker A: Yeah, I think that's interesting. It is nice, the symmetry, I guess. I also don't see a super big problem with having an inclusion list that you satisfy yourself with your own block. Like, it's a little weird, but it's also a little weird to ensure that those transactions have to wait another slot when you are yourself wanting to include them. Also, you could just make the default behavior for, if you're building your own block to just sign an empty one. An empty inclusion list. You know what I mean? Like that.
00:19:13.140 - 00:19:37.490, Speaker D: No, because you don't make this choice until after. The thing is that you always have the option of choosing your local payload after you've received the headers. So this is not unless you're sure that you're going to choose only locally, and then it makes sense. So clients may have a flag that says, always give me an empty inclusion list because I will be billed locally.
00:19:38.870 - 00:20:10.960, Speaker C: But I get your point where if I still want to have the choice, if then afterwards I choose the local one. It's kind of a waste to have an overlap because you're at least consuming some on chain transaction that has been already included by yours so the next proposer won't use it. So it's kind of a waste of space, I think.
00:20:12.050 - 00:20:42.060, Speaker A: But I guess my point is, if you do end up, okay, let's go through the flow. I grabbed all my headers and I was like comparing them to my locally built block. Let's say I do decide to go with my locally built block, then the locally built one can have an empty inclusion list. Even if I was sent the inclusion list to the relay, you know what I mean? Like I haven't signed over the full header yet, so I can still just do the empty inclusion list. If I do choose to self build.
00:20:44.830 - 00:20:50.490, Speaker D: The other one over there paths to deal with, it's going to be much more complicated to build our own block.
00:20:53.650 - 00:20:56.560, Speaker A: Sorry. You were both kind of talking at the same time.
00:21:00.410 - 00:21:09.226, Speaker C: Yeah, well, I was just saying that at that time you already sent the inclusion list over the network, am I right?
00:21:09.408 - 00:21:11.370, Speaker A: Well, you just sent it to the relay.
00:21:13.150 - 00:21:18.780, Speaker C: Well, how the publishing works is a p to p channel.
00:21:21.010 - 00:21:38.094, Speaker D: You haven't sent it to the relay, Mike. The inclusion list summary goes with the block, and the relay doesn't have this block. You're just getting headers at this time. When you send the inclusion list somewhere in your block, you've already signed a block.
00:21:38.222 - 00:21:42.290, Speaker A: Well, you've sent the summary though. You've sent the summary to the relay.
00:21:43.190 - 00:21:47.300, Speaker D: But then you cannot send a different block because you signed it already.
00:21:48.010 - 00:21:55.506, Speaker A: No, but if you're calling get header when you're calling get header to the relay you're not signing anything, right. You're just asking for the current best block.
00:21:55.538 - 00:21:58.780, Speaker D: But then when you're calling get header you're not sending any inclusion list.
00:22:00.270 - 00:22:38.390, Speaker A: But you have to, right? Because I guess when you call get payload. Because when you call get header you have to sign over something. And if you're signing over a beacon block that has to have a summary in it itself then you would need to have already communicated the summary to the relay. You see what I'm saying? The header has to have the summary contained within it if your slot end block. Right.
00:22:39.320 - 00:22:41.756, Speaker B: So the beacon block commits to the Il summary.
00:22:41.808 - 00:22:42.216, Speaker A: Right.
00:22:42.318 - 00:22:46.824, Speaker B: In which case that'll be part of the blinded beacon block that the relay gets.
00:22:47.022 - 00:22:48.744, Speaker A: But the relay doesn't have to care.
00:22:48.782 - 00:22:50.680, Speaker B: About that il for that slot.
00:22:53.100 - 00:23:00.376, Speaker A: Well, the relay has to have the summary like as the proposer. If I want to use that relay I have to send them my summary so they can build me blocks.
00:23:00.488 - 00:23:02.220, Speaker B: But it's for the next slot.
00:23:03.680 - 00:23:11.810, Speaker D: Does not need at all the summary yet. It only needs it on the block. It will get it on gossip or n.
00:23:16.190 - 00:23:34.990, Speaker A: But yeah, I guess we're not seeing eye to eye here because the blinded beacon block has my own summary in it. Right. So when the relay constructs the full block that I'm going to sign, the blinded version of it has to have the summary.
00:23:35.330 - 00:24:30.382, Speaker D: Construction goes the other way around. You signed assigned beacon block and once you do that and you've included the summary then there's no way out of this. Once you sign this you don't have an option of building locally and having a different block with an empty list. I think what we're all saying is that if you are going to allow for building a local block without an inclusion list or building mefboost blocks with an inclusion list in different ways, then when you ask for header for bits then you choose. And you choose before you constructed your local beacon, your local beacon block, you need to choose before this and then decide what sort of a blinded block you're going to do. This is not the way that clients do this today. Today we build a full block, a full consensus block.
00:24:30.382 - 00:24:44.710, Speaker D: This is not going to change and we just plug in an execution payload. Now if you want to have these two different paths we're going to have to build two different. Become blocks, compute two different hashes, compute two different things, and then decide which one we're going to broadcast.
00:24:47.840 - 00:25:15.604, Speaker A: Yeah, I think it'll be helpful to run through the. To kind of go through the actual builder specs and make sure that all of this works. But, yeah, I think we're saying similar things and I think that working through that part of the design is important, but maybe we table the discussion for now, because there's kind of other design considerations that I think we all want to talk about, too. Sound good?
00:25:15.642 - 00:25:17.864, Speaker C: There's Roman with hands up.
00:25:17.902 - 00:25:19.560, Speaker A: Oh, yeah, Roman. Sorry. Roman.
00:25:20.220 - 00:26:46.580, Speaker E: Yeah. Can you go back to the diagram with engine calls? Yeah, so I want to actually push back a bit on get inclusion list being a separate method, because when CL client forwards fork choice updated to the engine client, to the execution client, the execution client should build an empty payload, and then the inclusion list can actually change based on the local payload that the execution client builds. So it makes sense for the execution client to return the payload with the updated IL, which is based on this payload. And how the IL would be communicated to the relay or to the builders is with the initial call, with the very first call of get payload to the local execution client. Because local execution client should return an empty payload with an optimistic IL. Meaning like everything that it considers censored.
00:26:49.330 - 00:27:15.318, Speaker A: Yeah. Interesting. So you're just advocating for a single get payload, like changing the get payload to return the IL. The first call has an empty block and then subsequent ones have the block and Il. And we know that there's no overlap between the Il transactions and the block transactions. So we don't have this kind of like wasted space. Exactly.
00:27:15.318 - 00:27:42.094, Speaker A: Yeah, I think that's pretty interesting. Yeah. I do feel like all of these questions kind of are best understood in context of the relay specs, too. So I think I left that part out of here kind of for simplicity. But to continue the discussion, I do think it'll make sense to walk through the builder specs. Cool. Yeah.
00:27:42.094 - 00:27:42.990, Speaker A: POTUS.
00:27:44.130 - 00:28:07.750, Speaker D: Roman, did you repeat? I didn't get this. So you're saying we should call get payload right at the start of the slot, we're going to get an empty block but an inclusion list, and then if we call later, we're going to get a different block with an inclusion list that might be different now and it's not going to have any collisions. Is that what you're proposing?
00:28:09.370 - 00:28:10.120, Speaker E: Yes.
00:28:10.490 - 00:28:30.926, Speaker D: So how is this different than just calling? The first call to get payload is just an inclusion list and the second call to get payload gives an inclusion list and a payload. No, I see what you mean. So this way we're just going to copy calling twice. Get payload. I think this doesn't break us at.
00:28:30.948 - 00:28:31.520, Speaker A: Least.
00:28:33.730 - 00:28:38.930, Speaker E: Because Il should always be based on the local payload.
00:28:39.430 - 00:29:28.740, Speaker D: Yeah, this might be, though a bigger change in that. I can't speak for any Cl, but I can speak for prism. And the way we typically would do this is you run some code that is consensus. You build a consensus block and you call at the same time get payload for your local El and the get headers for Mapboost. So you have one chunk that is consensus and different plugins that are the execution parts. If we're going to do this the way you're suggesting, since the summary and the El is part of the consensus part of the block, now we're going to have to keep two different consensus blocks. And this is what worries me, that this changes.
00:29:28.740 - 00:29:32.050, Speaker D: It's a little bit more invasive, but I think it's doable.
00:29:36.690 - 00:30:34.714, Speaker A: Cool. Yeah, clearly a little more ironing out. The relay interaction here is going to be super important. If no one objects, I'll just run through these key design considerations quickly, and then we can kind of open it up for general discussion. So, first, is this conditional versus unconditional enforcement? The original design, the no free lunch design, had this condition where the inclusionless transactions didn't need to be enforced if the subsequent block was full. But POTAs and Barnabay and others pointed out that this kind of exposes this sort of degenerate behavior where builders can avoid including transactions by topping up the block and filling it. And then there's also this secondary concern, which is that a transaction that gets included in an inclusion list doesn't have actual guarantees until it gets included on the chain.
00:30:34.714 - 00:32:36.070, Speaker A: So there might need to be multiple proposers that include a transaction in an inclusion list to get it on chain, which is kind of this sort of not very strong guarantee. So I think most of us are on board with the unconditional enforcement. The problem, or I guess the question that it opens up is, if you do this unconditional enforcement thing, should the aisle transactions extend the gas of the next block? If it's full, should they be a constraint even with the 30 million limit? You can also imagine this kind of like cumulative list that Tony has written about, which is you carry these transactions forward, but then you have these weird gas tracking mechanisms. So I guess that's kind of the first set of questions. We want to make sure we're all on the same page on second, is this top of block versus anywhere in block thing? I guess the high level question here is do inclusionless transactions from slot n get enforced at the top of the slot n plus one payload? I think in general, my view of this is that's bad because you're kind of selling the top of block, and this is like the most potential block space, the most potentially valuable block space, especially in the classic slot specific Mev case where let's say you know that there's an NFT mint starting at slot n plus one, you can bribe the slot n proposer to include your mint transactions in their inclusion list and you know that they'll be enforced at the top of the block, which means you get to mint the first nfts. For this reason, I think the anywhere in block enforcement is better, and I think we've all kind of started to, I mean, happy to receive pushback here, but generally I think anywhere in block seems a little kind of less gameable, less mevable, and also doesn't seem too much harder to enforce in terms of the state transition function. There's a lot of chats going on.
00:32:36.070 - 00:33:13.700, Speaker A: I can't keep up. So hopefully everyone's taking care of those. We can talk about those once we open up the floor again. And then the next thing is this gossip question, which is, do we put the inclusion list with the block or not? You could imagine extending the p to p object type to include both the beacon block and the inclusionless transactions. Or you could imagine gossiping the beacon block separately from the transaction. So this is kind of the exact same question that was originally asked about blobs, because blobs could either be gossiped with the block or separate. But that same question here.
00:33:13.700 - 00:33:49.440, Speaker A: And lastly, right, okay, this is what we were talking about earlier. How do we limit the inclusion list, the number of transactions or the gas? I think in general, I prefer just gas limiting and then saying the max number of transactions is the amount of gas divided by 21,000, the minimum gas transaction. Happy to receive pushback there. This feels kind of like the least important one. I feel like I'm forgetting one thing here. Summary. Oh, right.
00:33:49.440 - 00:34:55.990, Speaker A: The other thing I wanted to bring up is this whole where does the actual summary get included? So there's also a version of this where the slot n inclusionless summary gets included in the slot n plus one beacon block. I guess the state transition for slot n plus one now has two conditions. The first of which is there's a valid summary that's signed by the previous slots. Proposer included in your block and the transactions in your block satisfy the inclusionless summary signed by the previous guy. I think we generally are opposed to this in my mind, mostly because it opens up this weird behavior where the slot end proposer can commit to their inclusion list, like, very late into their slot. So in this version, right, the slot n proposer has to commit to the inclusion list by the time they publish the beacon block, which is, I guess, by the attestation deadline, t equals four. In the other version, I, as the slot n proposer, could be bribed to give the slot n plus one proposer a very late inclusion list that has a different set of transactions and different summary.
00:34:55.990 - 00:35:40.514, Speaker A: I think also, it just feels a little bit like kind of commingling, crossing of concerns. As far as, as the slot n plus one proposer, I depend on the slot n inclusion list getting signed in broadcast, and it just feels like slightly less. There's just like some code smell there that just feels weird. But, yeah, that's kind of the last thing I wanted to bring up. I think we're all kind of happy with this version, so it might not even be worth discussing, but I just wanted to bring it up as something that was a big point of design iteration as we were thinking through these things. Cool. That's all I think I wanted to say.
00:35:40.514 - 00:36:10.646, Speaker A: I'll go back to the agenda here, just so we kind of can remember what we covered. And, yeah, I think opening up the floor, we have 22 minutes left in the call. Happy to continue the discussion that's happening in the chat kind of over voice or. Yeah, do whatever, Stokes, if you have anything you want to say. Potez, Terrence Francesco. Yeah, happy to pass it off. Yeah, Terrence.
00:36:10.646 - 00:36:11.242, Speaker A: Yeah.
00:36:11.296 - 00:36:37.822, Speaker F: So one thing I will add is that we miss that. Is that for syncing? This is actually interesting because this is probably the first time we are looking at this, is because when you sink into the head of the chain saying equal blocks by range or block by root, you are not going to have this inclusion list from before, because inclusion, this only matters for the current slot.
00:36:37.886 - 00:36:38.066, Speaker A: Right.
00:36:38.088 - 00:36:59.866, Speaker F: This is something that you have to satisfy for the current slot. So you kind of have this, like, it's kind of similar to when you sync in today into EIP 44. You only need the blob for the last 18 days. But the similar condition is that you only need the inclusion this for the current slot. So there is definitely that ways to implement it.
00:36:59.888 - 00:37:00.074, Speaker A: Right.
00:37:00.112 - 00:37:19.106, Speaker F: You can say, today I only care about inclusion this. If today I received the block over gossip I don't care about inclusion this if I receive the block over RPC. You can also look at a slot time. I think there are ways to. Yeah, there's a trade off here and yeah, we need to implement that in.
00:37:19.128 - 00:37:19.860, Speaker A: The spec.
00:37:23.270 - 00:37:25.190, Speaker B: With the block forever.
00:37:28.490 - 00:38:02.782, Speaker A: Well, the interesting thing is the block won't be valid unless the Il is satisfied. Right. So as you go through these state transitions, you can verify each time in the past that the IL was satisfied. I think the point Terrence is making is that the current block validity in terms of the fork choice view depends on this Il object existing alongside it. So at that point, we still need to kind of check the availability of the IL, for lack of a better term. And correct me if I'm wrong, Terrence, but I think that's what he's getting at.
00:38:02.836 - 00:38:10.930, Speaker B: You could prune after you know that the block was valid, but you do need it the first time in the syncing use case, you would have to get it from your peer.
00:38:11.750 - 00:38:12.450, Speaker A: Yeah, exactly.
00:38:12.520 - 00:38:17.720, Speaker G: You don't really need it necessarily, though. You don't have to care.
00:38:21.530 - 00:38:22.038, Speaker D: Once the.
00:38:22.044 - 00:38:56.660, Speaker G: New block has been built on top of it, you really don't care about the fact of whether or not there was an IL already. It's been satisfied. So it's kind of irrelevant for you as you're syncing. The only one that you really care about at any given time is the one with the head, basically. So I think you always need to keep around the one for the head, but you don't really need, like in case, for example, if someone starts sinking and gets to the head, they need to have that one to know if the head is actually good or not, like if it's something that they should care about or not, but they wouldn't need, for example, the one at DeF, like minus one or something like that.
00:39:00.150 - 00:39:02.290, Speaker A: Yeah. Protest.
00:39:04.570 - 00:39:16.040, Speaker D: So, since I changed my own mind regarding the issue of markets that are opened by ielts, I'd rather expand a little bit on that, if you don't mind.
00:39:16.970 - 00:39:17.720, Speaker E: Please.
00:39:18.830 - 00:39:53.060, Speaker D: There are two designs that we considered. One is to not put any summary at all in the Peacom block and just have a sidecar that has the summary and the transactions that satisfy that summary as an inclusion list. That is gossip and the builder for the next block. Since these messages are signed, the only thing that builder for next block needs to do is to include one such signed message. So this is actually simpler to validate. Right. Because in the beacon block, you're not even going to have anything about the El.
00:39:53.060 - 00:40:45.378, Speaker D: So this allows for something that I think is strong, which is the ability for the validator, for the proposer to submit conflicting inclusion list. Actually conflicting inclusion list, like with transactions from different addresses and different nonsense and everything different, completely different. So it commits to zero information in the beacon block. What are the trade offs here and now? This is what I proposed and I'm against this now. I was convinced, but at least I wanted to have a discussion about this. So what are the trade offs here? It seems better the fact that you're not committing any information on the beacon block and you are allowing conflicting transactions because ielts are going to have a separate market. It's expected that there will be a market for ielts developed.
00:40:45.378 - 00:41:56.186, Speaker D: If we keep them limited by having not that much gas, that's fine, but it's expected that rational validators would develop some sort of off chain market for ielts. If I don't commit to any information, then this market will never be trusted. If I send you a transaction and you tell me yes, here's an IL that includes assigned Il that includes this transaction, then I can't trust you because I know that you can be gossiping another inclusion list with a completely different transaction and then I don't know of inclusion until the next block. On the other hand, if we go with this design where the proposer is committing to a summary with a particular address, then once I have a receipt from you that you are including your transaction in this block, then I know for certain that my transaction will be included in the next block. Because I am the one that holding that address, I can make sure that no other transaction satisfies that summary. So this seems like it's going to make trustless a market that should be trusted before. So this empowers proposers to actually have a secondary market for inclusion list.
00:41:56.186 - 00:42:17.650, Speaker D: On the other hand, the problem is, and this is what Mike emphasized, that if we go the other way around and we don't commit at all like this, then the proposer can actually send an inclusion assigned inclusion list after the fact and negotiate with the next proposer next builder. And that I think is even more dangerous.
00:42:22.170 - 00:42:37.580, Speaker G: Just for the sake of argument. I guess it doesn't really matter, but I don't quite understand this point about you can negotiate with the next builder because if you'd send it later then no one would have voted for your block. So the next builder could just reorg your block, what advantage are you getting from no?
00:42:39.070 - 00:42:55.250, Speaker D: So the thing is though, you can send several, but the thing is that I can negotiate with the next builder to. Oh, here's an inclusion list that is more beneficial to you. Just include this. Here's a different one. Include this one, since there wasn't any commitment.
00:43:03.630 - 00:43:56.300, Speaker A: Yeah, I guess only thing to add here is that the freeda problem isn't solved by having the proposer allowed to sign multiple different summaries. The three DA problem is the fact that multiple different versions of the transactions can satisfy the same signed summary. So Terrence was talking about how you could. Sorry, Francesco was talking about how you could make signing multiple inclusion lists slashable. The version we have here, where you commit to the inclusion list in your own block, kind of does make that happen through the protocol, because if you sign multiple summaries, that means you signed conflicting beacon blocks, and that's like the equivocation in itself. So, yeah, I like this version for simplicity, and it still solves the free da problem. Right.
00:43:56.300 - 00:44:29.110, Speaker A: So thanks for the historical context there, POTUS. It's great to kind of shed light on the decision we made. Any other questions? Anything the execution team want to call out? Roman or Matt.
00:44:32.330 - 00:44:39.370, Speaker G: What is currently the limit? Maybe I missed it. Now, the gas limit.
00:44:41.630 - 00:45:25.590, Speaker A: Right. I think we have it set to 2,048,000 gas in the spec. Or maybe we just. I'm trying to remember if we hard coded a number in there or not. Right? I mean, it's kind of the question of the hour. I will say I do think there is this version of the unconditional inclusion list that doesn't have a gas limit, which is. You kind of do this cumulative thing like you proposed, Tony, and you can kind of keep with you a set of transactions that have been included in an inclusion list but haven't been included in a block yet, because those blocks have been full.
00:45:25.590 - 00:46:21.722, Speaker A: So, for example, let's just take a three slot n, n plus one n plus two view of this. Let's say slot n plus one is full slot n. Set some transactions in this unconditional inclusion list, and by the time you get to n plus two, there's gas remaining in the block. Now, at n plus two, those transactions have to be included, even though they were only included in the slot and inclusion list. This has the nice benefit of not forcing us to choose a gas limit and you still get this unconditional property. The only slightly annoying thing here is that you have to track the gas for each of those transactions. Right? So in the case we just took, let's say that the transaction that was included in the slot n payload doesn't have enough gas to be included at n plus one or at n plus two rather because we only do the check for n plus one.
00:46:21.722 - 00:46:58.626, Speaker A: Then you have to do this pruning thing for the inclusionless transactions. So that's the only downside. I do like the fact that the default is you can just as the client include all of the transactions. You see in your view, this is obviously like slightly less data efficient because now your inclusion list is as big as the block itself. But it takes out this default question and it also still preserves this unconditional property at the expense of some complexity. Sorry. Hopefully that made sense.
00:46:58.626 - 00:47:09.390, Speaker A: It was a little rambling. Enrico. Oh, hand was up and then went down. I see a lot of chats coming.
00:47:09.460 - 00:47:48.830, Speaker C: I was expected to unmute but I would hand out. So my question was still around limits. So we're talking about gas limits here. If we see this as a similar sidecar to the beacon block, the Ilton suction, we don't have a direct limit on the size of the object itself. I'm thinking does it make sense to have an hard cap on the size together with the gas limits to have the constraint size on this sidecar?
00:47:52.190 - 00:47:59.260, Speaker A: Yeah, I guess it kind of does. Like setting a gas limit does also constrain size.
00:47:59.710 - 00:48:47.610, Speaker C: We currently have blocks with 15 30 million gas and you could still potentially have 1 blocks. Am I right here? So it means that you could construct a big transaction that pays relatively low gas. Yeah, it's just a big thing that relative to gas usage is bigger. But since this is now a sidecar of beacon block then we have these networking things that we have to care about. And I think like having a stricter limit on the size of the object could be wise.
00:48:49.630 - 00:49:12.340, Speaker A: Yeah, I guess this in my mind falls into the bucket of engineering considerations that are going to be super important, but that I don't feel equipped to answer. But yeah, I totally agree that considering the data hit or just the bandwidth implications of the size of the IL, it does feel very important.
00:49:16.010 - 00:49:49.470, Speaker D: My connection sucks. So Francesco. I'm sorry, not Francesco, Enrico. One of the concerns about censoring. There are two targets for censoring that are worrisome. There might be much more, but realistically today it's transactions like for particular contracts that are not that large and they are just within this gas limit that we're thinking now. And those are the transactions that are being regularly censored.
00:49:49.470 - 00:50:08.760, Speaker D: There's other censoring that is worrisome for roll ups which is censoring the batch poster. This could be very profitable and censoring the batch poster would be exactly the kind of transactions that you're thinking of, which are transactions that are trying to minimize the amount of gas that they pay and at the same time being as large as possible.
00:50:09.210 - 00:50:09.960, Speaker C: Yeah.
00:50:16.180 - 00:50:19.456, Speaker A: Right. It's also worth saying that links to.
00:50:19.478 - 00:50:55.564, Speaker C: The engineering of our consensus layer. So if we still think like this as a sidecar and we start thinking about being timing timeliness, the timeliness of this sidecar compared to the slot, several things. Start thinking, start opening when you have separated the things that needs to be gossiped and you have a point where you have to have everything together and you might.
00:50:55.602 - 00:51:12.610, Speaker A: For what it's worth, this is why I prefer to just gossip the inclusion list with the block itself. Obviously this trade off is that the block max size is bigger for that specific message, but.
00:51:17.480 - 00:51:21.220, Speaker C: Coupling this sidecar instead of having the coupled version.
00:51:21.880 - 00:51:42.430, Speaker A: Yeah, exactly. One also nice thing that POTUS pointed out before, which I hadn't thought about, is that you can gossip the inclusion list before. Oh, sorry, never mind. This is the previous version. Ignore. Right. Just agree with the sentiment that there would need to be a lot of testing for this.
00:51:42.430 - 00:52:01.116, Speaker A: A lot of messages going, can't follow all of them. But I think Alex said something like, do we feel like this is ready to present to ACD as this could be shipped now is the thing to discuss to wrap.
00:52:01.308 - 00:52:12.150, Speaker B: Yeah, I was just saying in terms of timeline, how do we feel about this? Do we feel like the current design is well specked enough to move forward?
00:52:17.640 - 00:52:18.576, Speaker A: Can you run a poll?
00:52:18.608 - 00:52:24.344, Speaker B: It seems like there are a bunch of implementation details, but the high level all seem pretty good.
00:52:24.382 - 00:52:24.970, Speaker E: Right?
00:52:26.780 - 00:52:35.790, Speaker A: That's my impression. And that was kind of hopefully the point. I'm sorry, discussion no go.
00:52:37.680 - 00:53:19.610, Speaker G: Yeah, I was just going to say, I think it's also the main things to figure out are these kind of networking questions like coupled decoupled, which calls exactly should NGN API make? But as far as a high level design, some parts of it have not changed for months. If not, I mean some parts even years. So I think at least there's definitely some kind of robust score to the whole thing. So yeah, I think if we can put our heads together and really dive into these remaining questions, it's pretty close to being presentable as a full thing.
00:53:25.840 - 00:53:26.860, Speaker A: Otis.
00:53:28.240 - 00:54:06.680, Speaker D: Yeah, so I run a poll, I'm personally opposed, but I run a poll within prism and I can now speak for prism. We believe strongly that this should not be included for Electra if we are going to spec this fork for 2024. I don't believe we can test this. I'm personally sure that this is going to leak into 2025 if we scope it for 2024. And on the other hand, if we scope the fork for 2025, then we're strongly in favor of including this. We would include even different things that are bigger.
00:54:13.650 - 00:54:19.200, Speaker G: What does mean concretely, what does 2025 versus 2024 mean?
00:54:19.970 - 00:54:56.060, Speaker D: There was an agreement three months or like an ACDC and ACDe that the current fork should be small enough as to not affect the next fork aiming to ship Berkele by 2025. This was sort of like what seemed to me like a broad consensus that we would want this fork to be small and small enough, meaning we would scope it for this year. It seems to me that it's impossible to scope this change for this year because we will not be testing these things in three, four months, five months, as people are saying.
00:54:58.510 - 00:55:01.660, Speaker B: Nice point in the chat. Were you about to say something?
00:55:01.970 - 00:55:03.518, Speaker A: Yeah, I guess I was going to.
00:55:03.524 - 00:55:11.410, Speaker H: Ask both is like how long? Say that we agreed that all the client teams put like one or two engineers on this tomorrow.
00:55:13.110 - 00:55:13.586, Speaker A: I guess.
00:55:13.608 - 00:55:32.840, Speaker H: Is your view that just like we have so many other things to do that we can't prioritize this? Or is it more that this is so early that it's going to need a year of prototyping and refinement before it's even worthwhile to have every kind team working on it?
00:55:35.450 - 00:55:55.310, Speaker D: I think we haven't shipped on the CL side. We haven't ever shipped more than a fork a year. We're starting already this without even scoping this fork. I hardly see this fork happening this year. If it has any non trivial change, like withdrawals itself was very trivial and it took over a year.
00:55:55.460 - 00:55:56.160, Speaker A: Yeah.
00:55:58.530 - 00:56:04.000, Speaker D: How long it takes for us to start testing on Devnet changes. And this is a nontrivial change.
00:56:05.250 - 00:56:17.142, Speaker H: Okay. But it's more about the client team's ability or speed of implementing it than it is about the readiness of the spec.
00:56:17.276 - 00:56:17.960, Speaker A: Right.
00:56:19.050 - 00:56:34.954, Speaker D: I believe this spec is completely specified as Francesco side. I completely agree with Francesco. I think the core features of this spec is specified and we only are worried about minor details which we're going to gather numbers when we're actually testing them.
00:56:35.152 - 00:56:37.434, Speaker A: Got it. Because.
00:56:37.472 - 00:56:53.234, Speaker H: Yeah, that was my comment in the chat is like, if we think this is important, but we're not sure whether or not it can make it in the next fork without delaying it, just spec it as the fork after and.
00:56:53.272 - 00:56:53.860, Speaker A: Then.
00:56:55.910 - 00:57:25.126, Speaker H: Worst case, it still ships later than expected, which is sort of what you're saying now. But then if this actually is simpler to implement or we are quicker than we'd expect, can you bring it into electra or potentially just have it? If it's too complicated to merge the actual code bases, but we feel like this is ready. It's like can you just have the fork activate one epoch or one epoch.
00:57:25.158 - 00:57:25.740, Speaker A: After.
00:57:27.710 - 00:57:37.614, Speaker H: 7092 or something? Epochs after. This way you can still ship the fork. Basically, you can still ship without just.
00:57:37.652 - 00:57:45.780, Speaker D: Repeat what I just said. I think it never happened that we ship two forks in a year, and also somehow it seems this.
00:57:48.310 - 00:57:49.054, Speaker H: You muted.
00:57:49.102 - 00:57:49.700, Speaker A: Yourself.
00:57:51.750 - 00:58:08.060, Speaker D: Or someone according to our belief that this fork was being scoped for a particular year. If we're going to change this year, then we would have chosen a different set of eips and we would have prioritized a different set of things.
00:58:18.630 - 00:58:48.762, Speaker A: Cool. I think we're not going to come to conclusion on this in this call. Obviously there's a lot of other CL teams that we would love to hear from too. We're at time we're 1 minute over, so I think it's good to wrap here. I'm happy to continue the discussion in kind of chats. I generally don't use telegram, so if there's a channel there or sorry, I don't use discord. If there's a channel there, I guess I can start.
00:58:48.762 - 00:59:08.990, Speaker A: But I'm also happy that we have the inclusionless chat on telegram that if you want to be added to definitely hit me up. I think everyone here has my contact. Cool. Yeah, thanks everyone. Happy Friday and we'll see you next week. Thanks Mike, thanks. Bye.
