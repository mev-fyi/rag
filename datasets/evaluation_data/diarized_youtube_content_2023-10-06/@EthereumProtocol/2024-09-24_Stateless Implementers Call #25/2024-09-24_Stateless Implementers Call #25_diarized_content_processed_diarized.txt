00:00:02.120 - 00:00:25.845, Speaker A: Welcome everybody to stateless implementers call 25. This is agenda 1159 in the PM repo. So we have a pretty light agenda today. Just shared it in the chat. Yeah, we can go ahead and get started with team updates if anyone would like to go first.
00:00:35.305 - 00:00:53.825, Speaker B: Yeah, I guess I'll go. Yeah. We've been working on some well, the test Net relaunch. We merged most of our PRs. There's one that's still outstanding but we're currently debating. So we should. We should merge it soon, otherwise benchmarking.
00:00:53.825 - 00:01:20.725, Speaker B: I've had a lot of hardware issues so no announce to do to make right now unfortunately. But yeah, it's chugging along so hopefully next week I can share some stuff and otherwise there was some updates into the test fields. I think we released the latest version Ignacio, is that correct?
00:01:22.235 - 00:02:19.005, Speaker C: Yes, we. We fixed some extra guest bugs and I also fixed some tests regarding the X of T witness checks that were enabled a while ago. So last Monday I shared with some people a new version of fixtures so they can run them. We already know that Geth and Nethermine already agree on the state route and use CAS for them, so that's pretty nice. But yeah, we like. It would be nice if our clients might use them to know if they are ready for the devnet. And I also wanted to say that if EL clients have a stateless mode, it will be also cool to run these fixtures in stateless mode.
00:02:19.005 - 00:03:28.585, Speaker C: Which basically means try using the witness as your pre state source of truth to actually run the fixture. Right. Because that's kind of the whole point of all this. Everything in the witness should be sufficient to run the fixture and to let you the test pass. So I think actually running the fixtures in stateless model is actually the ultimate tests for knowing if the witness is having the right data for running a block. So yeah, just wanted to mention that too. But apart from that, well, after having some extra confidence that more clients were passing this version of Fixtures, I have a bunch of other tests that I can enable that will be testing more like corner cases about running out of gas in very particular places of execution.
00:03:28.585 - 00:03:49.095, Speaker C: But for this I have to do a lot of manual work to find this gas, the right gas limits for the tests. And yeah, after I know that things are a bit stable, I can do that work because if we keep changing or fixing our bugs, I might have to do that work again. So yeah, that's kind of the next steps.
00:03:51.515 - 00:04:03.135, Speaker B: Right. And I forgot to add yeah we're working on revising out of Cancun it's taking a long time, but yeah, we're, we're focusing on that now.
00:04:09.005 - 00:04:16.345, Speaker D: I can go next. So for another mind, there is no major update. Just working with Ignacio over HIVE test.
00:04:16.845 - 00:04:18.533, Speaker B: And I'll also try to run the.
00:04:18.549 - 00:04:20.665, Speaker D: Hive test in state test mode this week.
00:04:21.325 - 00:04:22.265, Speaker A: That's it.
00:04:23.245 - 00:04:54.699, Speaker D: Okay. On business side, I was last week trying to work on the flat db. So I'm trying to have a flood DB based on stem key. For that I did some micro benchmarking. I wanted to see what will be the impact in the S load operation. And with my first micro benchmarking I found that really the performance was really bad. I had some discussion with Kevin Rhee in order to understand why it's really, really slow.
00:04:54.699 - 00:05:41.935, Speaker D: And we found that maybe we can have some optimization in the rust versus library and maybe also on the bezel side we can optimize by changing how we are calling the library. But we are also trying to integrate the Constantine library into Bezu. We want to compare the performance with this library and after that if we can see that results are better, maybe. I will continue to work on slide DB based on stem. But for the moment, regarding the performance we have, I think we need to optimize performance before continuing on this part on the gas cost. So I will let Luis talk about that. He is currently working on that.
00:05:43.195 - 00:06:22.355, Speaker E: Yeah, so I didn't make much progress on the gas costs. I switched over to the enabling, getting the test framework, the fixtures to run with Vesuvius on Vasu. And yeah, I'm making good progress. I'm getting some errors while I'm executing the tests, but so I'm kind of missing some setups to do and yeah, I'm making progress on that. I will look into finalizing the gas costs once I get this out of the way.
00:06:33.775 - 00:07:11.215, Speaker B: Just, just some remark because we had the conversation with Karim last week. So yeah, we have a hashing that is seven times slower than Ketchack. I still need to do some benchmarks, but yeah, I was like bogged down by some hardware issues. But it seems that using a flat DB that is using directly the hash keys, like the Pedersen hash keys seem to be acceptable in terms of performance. But yeah, I need the benchmarks to support that claim.
00:07:12.395 - 00:07:28.925, Speaker D: Yeah, it's clearly what I want to have. Also on Bizu having something close to seven times slower. But for the moment when I did some benchmark it was more 300 times slower. So clearly we need to look in the business side of the performance.
00:07:45.835 - 00:07:46.331, Speaker B: Cool.
00:07:46.403 - 00:08:09.735, Speaker A: Did we get everybody Any other updates? Sweet. If not, we can keep going. Cool agenda. Item number two. Guillaume has some thoughts on EIT 7702 in Verkal.
00:08:10.765 - 00:08:52.275, Speaker B: Yeah, so while you might be aware of the attempt to break picture into two forks, one is called picture and the other one is called temporarily called Pict B. That might be Osaka after all. We don't know yet. It's not really important at this point. But part of Petra is 7702. Yeah, let's not start, let's not start a fight over the naming. 7702 is going to be in Petra.
00:08:52.275 - 00:09:21.345, Speaker B: So we implemented or we made a proposal that it's actually still in review. Let me see if I still have the PR right here. Yeah, that's the one. Let me also share the link in the, in the chat. Is that it? Yeah. Right. Okay, here we go.
00:09:21.345 - 00:10:25.395, Speaker B: So long story short, we. Yeah, if you look at the EIP 7702, you have, you have a new type of transaction that contains what's called an authorization list which is just. Yeah like some kind of, some kind of information that you use to update some accounts. So there's an algorithm that is being described. You need to verify that whoever like the signature basically of that authorization. And then if you do this authorize, if this authorization is correct, you charge some gas and you will replace the code as 0XEF0100 and concatenated with the address. So you update the code basically.
00:10:25.395 - 00:11:08.615, Speaker B: And this is, this serves as a pointer to. This serves as a pointer to call. Like if you for example do an xcode hash or if you do a call or anything, you delegate. So you just, instead of calling, if you do an xcode hash on this account, for example, it will go and look into the address and basically do the like forward it to the account that it's pointed. Pointed to. So you will got. You will get the code hash not of the EOA you're calling into, but of that address.
00:11:08.615 - 00:11:44.995, Speaker B: So this is an update to the EIP that does exactly this. That just says if you called those functions, you also need to touch the code hash, leave key. You will remove the specific case for xcode hash. Because we now we. Well, I mean at least when it's, when it's. Yeah, when you need to, when you access an account you need to know what the code is. So actually this is incorrect.
00:11:44.995 - 00:12:08.715, Speaker B: There's already a problem I realized with the cip. You need to check the first chunk of the code. So yeah, that should not be the code hash, it should be the code. So, yeah, the long story short, I just want to bring your attention on this. Please have a look. There's a lot to criticize. There's already a need for some updates, actually, I just realized.
00:12:08.715 - 00:13:02.145, Speaker B: But the idea is that, yes, because we need to check that. There might be an indirection, there might be a delegation. We need to check the extra code, like the first code chunk, to see what type of account this is, and we need to forward it. I think there's something else. When you execute the code, when you do an xcode hash, when you do whatever you need to check, and then you need to find the delegated address, if that's delegation. And so if this is a 7702 account, if this is a special kind of account, instead of executing the code of the account, the target account, you need to replace it with the delegated account. So, yeah, there's definitely a lot of criticism to this eip.
00:13:02.145 - 00:13:41.475, Speaker B: But please have a look and tell me what you think. It also describes the transaction itself. So this, I think is a bit more correct than the other part of this eip. But yeah, the idea is that every time you make a call, you know that like, for the type of transaction that does update the account, you will need to read those values. You would need to read the leaf key, you need to read the code hash and you will need to read the offset, the first. Sorry, the first chunk, which is at code offset. Actually, this.
00:13:41.475 - 00:14:24.985, Speaker B: No, that's correct. Yeah. And then you will need to write that and also fill them if it does not exist and write the first code, the hash leaf key, if the address is not. If the code hash is not present. So if you're creating an account with this operation, you will need to write the code hash, but otherwise you have to update the basic data leaf key because the nonce needs to be incremented and you need to update the first code slot. Yeah, right. And there's definitely a controversial claim here that I'm waiting for feedback on.
00:14:24.985 - 00:14:59.885, Speaker B: There are some extra costs that are added to the 7702 EIP and I think. But I'm not sure that they need to be cleared. They need to become zero because this is covered by the whole witness access costs. Just wanted you guys to know that this EIP exists, please. Sorry, this PR against the EIP exists. Please have a look, give some feedback and yeah, hopefully we can merge this for Devnet 8. Yep, that's it.
00:15:03.065 - 00:15:10.085, Speaker A: Thanks again. Do you or Ignacio want to continue on with the topic of partial witness charging.
00:15:12.225 - 00:16:43.535, Speaker C: Yes, I can mention all this topic. So last week or the week before I was debugging test that I wrote regarding it is a test that basically does a jump to some other, like you are executing a contract, do a jump to some other place and you have to charge for this new extra cold chunk. And what I'm testing here is if you have to charge 200 gas for this new cold chunk, as usual, but you only have let's say 190 of gas available, I wanted to check really what El clients were doing in this case. And this ended up being like a test that I discovered that it was different from like Geth was doing something some somewhat weird. And the thing is that in Kenya, as far as I know, it was decided that if you don't have enough gas to do whatever witness touching you have to do, you actually don't have to include that in the witness. So to continue the example, if you do a jump and you have 190 of available gas to charge for that cold chunk where you are jumping.
00:16:46.035 - 00:16:46.347, Speaker A: You.
00:16:46.371 - 00:17:29.275, Speaker C: Don'T have to include that cold chunk in the witness. This is something that get was doing. So Geth was including this cold chunk in the witness, even if he didn't have enough cash to pay for it. So that's kind of a bug, let's say. Just wanted to be clear that that shouldn't happen. Another situation where this can happen is there are many places in the execution where we have to include in the witness more than one leap. So for example, if we try to do a write on an account that doesn't exist, we usually have to write the basic data and the code hash for the address.
00:17:29.275 - 00:18:42.373, Speaker C: So intentionally, I mean the intention is to add kind of two leaf values atomically in the witness. But maybe you only have gas to include the basic data part of it, but not the code hash. So in these cases GET was always including both leaves because it first added things to the witness and then it returned how much gas you needed and then it tried to charge the gas. So if you didn't have enough gas for it, you have already added that thing to the witness. So we start pretty. It was like quite simple logic, but it didn't allow to do this kind of partial witness charging or having like final granularity in how you charge for witness additions. So this is what this open PR that we have in Geth that Guillaume mentioned before, we are still thinking of how to like I did like a fix for this, but we are trying to See if like the best way to fix it.
00:18:42.373 - 00:19:26.739, Speaker C: But I just wanted to like explain the situation because just to be sure that everyone is aware of it. I know that our mind is already has already implemented this because I. I also feel some extra tests where I re enable this test that surface this situation and we are both agreeing on it. But yeah, forget it has been a bit tricky to solve this. So I don't know, maybe in our claims isn't the case. It kind of depends on how you design all the gas charging for the witness. But yeah, just to make sure that you.
00:19:26.739 - 00:20:03.185, Speaker C: You only add things to the TLDRs that you should only add things to the witness if you have the available gas for it. So yeah, if you want to know a bit more details of how other like use cases where this can happen, you can pick me if you want. But yeah, I guess this. These two examples that I gave my already explain a bit the situation. I don't know if anyone has any question but that's it.
00:20:10.335 - 00:20:11.715, Speaker A: Thank you Nasio.
00:20:15.695 - 00:20:16.191, Speaker C: Cool.
00:20:16.263 - 00:20:35.045, Speaker A: If no questions on that. The last agenda item we have is just circling back to the question of testnet and potentially getting it launched this week. I don't know if anyone has updates, thoughts, Guillaume, Ignacio or anyone else.
00:20:37.945 - 00:21:09.003, Speaker B: Yeah, I mean we're more or less ready. Like we're one PR away from launching. The question is really whether the DevOps ETH Planet Ops has time at the end of the week to launch a test net. I think Tenish is ready. So that's two clients that we can launch a testnet with. There's been some upgrade from Lighthouse, sorry, Tiku and Lodestar of course. So yeah, I think it's.
00:21:09.003 - 00:21:17.215, Speaker B: It's worth making an attempt this week. It's just a question of DevOps having some time to do it. I think I saw Parry in the call.
00:21:17.515 - 00:21:24.307, Speaker D: Yeah, I think later this week we should be able to try it out. I would still do it locally first though, so that you guys have like.
00:21:24.331 - 00:21:28.563, Speaker C: A testing environment in case there's bugs found. And then once it works locally, I.
00:21:28.579 - 00:21:30.915, Speaker D: Would switch to a public test net.
00:21:31.455 - 00:21:50.035, Speaker B: Yeah, that sounds good. So okay, I think we have, we have the go finally for Devnet 7. Yeah. Are there questions otherwise? I think we can have, you know, an early end to the call.
00:22:01.865 - 00:22:08.365, Speaker A: Seems like no questions. So should we end it there? Let's do it.
00:22:10.305 - 00:22:10.777, Speaker C: Cool.
00:22:10.841 - 00:22:13.873, Speaker A: All right, thanks everybody. See you in two weeks.
00:22:14.009 - 00:22:15.577, Speaker B: Yeah, take care. Bye.
