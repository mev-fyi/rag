00:00:03.650 - 00:00:54.390, Speaker A: Hey, good morning everybody. Thanks for joining us for the EOF implementers call number seven. This is the first call that we've had in a few weeks. We spent some time, a few of us in person at the interop event in Austria and did some work on EOF, had some discussions about how EOF fits into some of the future roadmap ideas. And so I think it's going to be a good time to talk about what happened at that event and then what people have been up to for the past two weeks or so since we've been back. So I guess to get started, let's just go over what the clients have been up to at the interrupt and since the interrupt. Dana, do you want to start with Basu?
00:00:56.170 - 00:01:26.590, Speaker B: Sure. So we had basically gotten up to implementing what's been called EOFP one and we were engaged in the reference, looking into starting moving some of the reference tests over. We validated some of the reference tests. None of them had filled properly because it's still a very fluid spec. So that's not surprising. So I did differential testing against, I think the other most complete implementation was geth and off of like clients fork and I did differential testing there, came up identical. So we were ready to ship v one.
00:01:26.590 - 00:02:00.666, Speaker B: But because of reasons we're going to discuss later on, I don't think it's ready to ship. In Shanghai, there's at least two issues that need to be resolved and some more existential issues that need to be resolved before we can comfortably go ahead with it. Unrelated to EOF, I've got our EVM tool implementing. I'm working on having it implement t 89 and B eleven r so it can become a full partner in the execution test. Clients execution spec test that's still underway. It's not complete. There's still rough corners and not even gethruns gets them right now because they're changing some of the end.
00:02:00.666 - 00:02:03.100, Speaker B: It's par for the course on there right now.
00:02:05.230 - 00:02:19.438, Speaker A: That's awesome. If you run into any specific problems while you're implementing those, feel free to tag me in testing the testing channel or something. Or if there's something wrong with Geth implementing those interfaces, I'm happy to update them.
00:02:19.604 - 00:02:37.830, Speaker B: Yeah, right now the issue is around breathe baseb and there is no current baseb in some of the tests that come out. And I just need to read in what the test is expecting the client to do it when that happens and then just making basically do that. And I think Geth is in the same boat there they fail the same test in the generation.
00:02:38.570 - 00:03:48.610, Speaker A: Interesting. Okay, cool. Thanks for that update. Do we have another mind here or Aragon? Does somebody want to give an update on EVM one? Nothing I can give an update for guest then an update is there's not too much of an update. We spent a fair bit of time talking about UF two spec in Austria, and since returning I haven't spent much time at all working on the EUF implementation. I think there's some outstanding small issues and some things that would need to be updated, but I've just been focused on a couple of different things and so that's been on the back burner. Still waiting for things to settle a little bit to figure out what we're exactly targeting so we can get back to the place where we're doing differential testing against a bunch of clients.
00:03:48.610 - 00:03:57.190, Speaker A: So yeah, that's pretty much where the geth client is. Any other updates on clients?
00:04:01.450 - 00:05:19.150, Speaker C: I think there's a bit of an update on EVM one and radic and Andre can speak more to that. But Andre has been working on the create tree implementation, which is basically this new Andre creation model for getting rid of code observability, and we have shared these documents. Create tree is one of the instructions, return contract is another one, and Andre has been working on implementing this in EVM one. And the intention was that implementing it going to give us some, we're going to find some problems with the design and I mean, so far it seems to be working. It did help us identify some edge cases, which we need to describe separately to that. Just as of yesterday, t eight n transition support has been merged into EVM one, which means it can be used to fill tests. And so once we have this create free stuff implemented, we will be able to fill tests with those.
00:05:19.150 - 00:05:28.610, Speaker C: And that should really accelerate the way we work and test any of these changes across the clients.
00:05:30.230 - 00:05:34.120, Speaker A: Are you guys looking at implementing blue and r at all?
00:05:43.010 - 00:05:44.926, Speaker C: It's the block builder, right?
00:05:45.108 - 00:06:05.560, Speaker A: Right. This one is required to be used with the execution spec tests. So I think ta n it's the only requirement if you want to be used with retest eth, but to be used on the Python spec test, it does require having b eleven r as well.
00:06:07.130 - 00:06:09.560, Speaker C: Yeah, I think so far we haven't discussed it.
00:06:11.530 - 00:06:30.560, Speaker B: So my concern with b eleven r is it's very tied into the ethereum chain format and things like the current existing Patricia tree. Would it be possible to have the python client use one client for t eight n and another client for b eleven r? Would that hybrid be discussed as an option?
00:06:34.610 - 00:06:58.006, Speaker A: Yeah, we could add the ability to the Python spec Python testing library to take two different binaries, but I wasn't sure what you meant by the B eleven r tool was tightly coupled with the Patricia try, because it should really just be computing the RLP of a block and computing the hash over that.
00:06:58.188 - 00:07:29.390, Speaker B: Yeah, maybe I'm thinking of t eight n so many numbers in these, but the thought that's crossing my mind is with this utility of this for layer two clients, they're doing novel things like switching their hash tree to the sparse merkel tree. Is there a way to make these tests useful for the layer twos that are pushing evm compatibility so we can run a test on them and say no, you're not, here's your errors, or yes, they passed the test. Here, have a cookie.
00:07:30.210 - 00:07:51.720, Speaker A: Yeah, that's a good question. We should think more about that for sure. I do think that a lot of the ways these things are structured, it's something that we can support with relative ease. But yeah, it's just getting to the point where we might be boiling the ocean to support everything. And right now we want to make sure that we are supporting l one.
00:07:52.970 - 00:07:55.718, Speaker B: Focus on main net and grow layer two off of it. Yes.
00:07:55.804 - 00:08:39.950, Speaker A: Yeah, we should think about how to better support layer two. Sorry. Anyways, we can talk more about this on testing. The last thing that I wanted to say on this is I think that supporting a b eleven r would be great. And I think that writing the test in the Python format is pretty nice because it's really simple to change all the tests where I think that with the retest eth format it's a little bit more difficult to go back and change tests as the spec changes and we could talk about that more in a few minutes. Are there any more updates on clients? Okay, any updates from compiler folks?
00:08:49.820 - 00:09:35.504, Speaker C: I think the update I have from Daniel, I mean, this is second hand update. Daniel said that they basically implemented everything of V one, with the exception of r jump v. They also worked on some of the optimization steps because the easy way to enable us support initially was just to disable the optimizer just to get everything else done, but they got as far as re enabling the optimizer and actually extending it. And yeah, the result is that both code size and gas usage wise, they're seeing a savings.
00:09:35.552 - 00:09:36.150, Speaker D: Actually.
00:09:38.220 - 00:09:49.160, Speaker C: I think they haven't done anything yet this year, with the exception of Daniel participating in wise and helping in the create discussions.
00:09:50.700 - 00:10:16.340, Speaker A: Got it. Okay. Yeah, great stack updates. I know there's a lot of stuff discussed in Italy. Do you, Alex and Pavel want to try and give an overview about the things that we discussed with respect to UF one and these ideas about eof two.
00:10:20.190 - 00:11:15.600, Speaker C: I shared a document just at the time of the call, so nobody had the opportunity to read it. But that gives summary and like an overview of what we could do going beyond EOFv one. But I think, Pavel, if you're on the call, you are in the best position to summarize the status of EOFV one back changes, because generally we wanted to lock in what we had in December as EOFV one and any further changes, major changes we would be doing under EOFV 1.1 and 2.0. And the reason being is that we don't want to influence testing and break testing with EOFV one. But I think there were some clarifications for V one and maybe Pavel can talk about those.
00:11:17.890 - 00:13:03.230, Speaker D: Hi. I think V one was mostly missing this one thing about the create, how we handle invalid in it code in case of create instruction. This is like ongoing for longer, but I try to get opinion from many people on the chat and I think we have a solution that satisfies most of the people. So we kind of went to the process of updating the implementation, checking tests and so on. And there's kind of like one edge case that remains there, which I think it's fine, but it requires some additional infrastructure, at least on the EVM one side, and we didn't tried it yet, how complicated it makes the implementation in the end. Maybe it will actually simplify it in many cases, but we didn't try it. Yeah, so I think it's a bit mess, but it's always with the create and call instructions that everything you change, it's like this series of 20 or more different checks you need to do and depending where do you put additional checks or how do you modify existing, that hugely affects the semantics, although there's mostly like edge cases that will not frequently happen on real network.
00:13:03.230 - 00:14:18.542, Speaker D: So this is the status and I think we will continue with that and maybe we'll try to evm one this time as a first implementation to fully conform with the test and spec, but also. Yeah, so this is it. And I'm not really prepared for the 1.1, but mostly what we wanted to do is to include some changes that we already agreed to be included, but we didn't just not disrupt the testing of existing spec. Think there's like around five different changes, including delegate core, restriction and some minor other things. I don't have the list right now. However, the thing we also discussed during this interop last month was the conclusion that we actually should really cripple the ability to create contracts from UF.
00:14:18.542 - 00:14:50.740, Speaker D: Mostly means we should disable create instructions. So it kind of makes all this struggle of the create semantic a bit wasted in the sense that we'll probably disable all of it, but maybe that will be useful later on at some point. So that's my comment about it.
00:14:53.580 - 00:15:07.420, Speaker A: So you're saying by disabling create, you're saying disabling create the original opcodes, not talking about the new ideas with create with the transactions.
00:15:10.180 - 00:16:22.470, Speaker D: Yeah, I didn't fully spec out this new create instruction, the new create semantics, if we need to handle all the edge cases the similar way, or maybe some of the edge cases will go away. I'm not sure about that. But yeah, by disabling we kind of ended up on this position that if we want to deploy EOs in two phases and we want this new fancy create semantics, then we need to kind of disable it for now and then introduce it later without need of modifying the more or less there will be only option to create EOF contracts starting from a transaction. So this is kind of like, I don't know, partly functional system, but I think it's like, in my opinion it's good enough to start with.
00:16:26.600 - 00:16:37.370, Speaker A: Yeah, makes sense. Any questions from anybody on these ideas? EOf one 1.1 b two.
00:16:42.940 - 00:16:47.004, Speaker B: So 1.1 is not affords compatible extension of one.
00:16:47.042 - 00:16:47.292, Speaker A: Right.
00:16:47.346 - 00:16:50.204, Speaker B: Because we're removing features only one would.
00:16:50.242 - 00:16:52.860, Speaker C: Ship one or 1.1 would ship.
00:16:55.280 - 00:17:13.670, Speaker A: I think the idea, yeah, 1.1 is what would be the target for shipping. But they're separated into two just because sort of one was already defined. We have a lot of tests around it and 1.1 would be just a change on top of that.
00:17:21.600 - 00:17:25.420, Speaker B: So Eof one is basically eof beta.
00:17:27.120 - 00:17:30.290, Speaker A: That's how I'm understanding that. Cool.
00:17:32.020 - 00:18:33.460, Speaker D: So 1.0 is what we currently have in the aps and that's what we would been like implementations we're targeting and what the testing are done for. And we didn't want to disturb this because we assumed this ongoing implementations effort and ongoing testing effort. But if you think it's not worth continuing, we can apply additional changes to that and kind of keep this milestone. I think from my perspective, like kind of buff options are fine. I was a bit happy about having some milestones and multiple teams could confirm they passed all the tests and this is what we had. But I'm open to selecting one of the routes.
00:18:35.480 - 00:19:13.010, Speaker B: Yeah, because I don't think we have a good infrastructure inside of basic yet. To ship both 10 and eleven without changing the major version number from like a true forwards compatible where we just add new opcodes and add new capabilities and increase the space that is valid contracts. I think that's easier to handle inside of Besu, but to have restrictions would require separate code bases right now. So I think 1.0 is valuable. You're right for testing, but as far as shipping, once 1.1 solidifies, I don't see BeSU continuing to support 1.0.
00:19:13.010 - 00:19:51.470, Speaker B: So it would just mean the contracts that were compiled with those forbidden features would suddenly become invalid in Hyperledger baseu, which I think is probably okay because all the contracts that don't use these forbidden features should just transparently come in. If you're not creating stuff, if you're not using ext copies or the ext code series of operations and doing gas introspection, it should just. Well no, it won't work because we're changing the gas on the gas introspection. So there's some things that might change, it might be uncompatible. You couldn't do cross contract calls, which is kind of a big feature if we go with the in place change of call, just dropping the gas field.
00:19:54.960 - 00:20:51.996, Speaker C: So I was kind of thinking that we don't necessarily want to have both of these implemented at the same time. It would be rather because as you say, there are many different ways to enable like 1.1 and the sanest way to enable it is with an actual version one. Right, but some clients may be able to do it with enabling a specialty IP feature or whatever, but I think this may be like unnecessary complications. And how I was looking at this is more in terms of discussions. I think at this point we need to spend time on the specification of what this 1.1 would be as opposed to jumping the gun and implementing it in every single client.
00:20:51.996 - 00:21:31.470, Speaker C: So I think we have a number of weeks during which teams can keep working on implementing v one completely and passing the test because I think the tests are mostly done. So it's really just a matter of implementing in the clients. And parallel to that, people who are more involved in the specification of 1.1 can work ahead and finalize that and then in a few weeks time we can just jump to implementing all of this in the clients. Maybe this is a bad idea, but that's how I felt about it.
00:21:33.520 - 00:21:39.436, Speaker B: I think that's fine. Does this still put us on schedule.
00:21:39.468 - 00:22:16.250, Speaker C: For shipping in Cancun? I think assuming we can nail down like this 1.1 spec early, I mean, I will put it after eat Denver because obviously that's going to put a hit into this. People are going to be busy with eat Denver, but my target would be that the 1.1 spec should be pretty clear by end of eat Denver. I think then we're like on a good track.
00:22:22.870 - 00:22:52.060, Speaker A: So the anticipation is still to try and have this UF 1.1 specification used to propose the change for Cancun rather than trying to propose the full UFV two. Or will we just kind of go into the conversation like here is this 1.1 spec, does it make sense to do this on its own? Should we consider doing V two all at once?
00:22:58.750 - 00:24:05.520, Speaker C: And I shouldn't be the only one giving feedback on this, but my feeling is that v two, given the sheer number of changes around creation, may put us into like a similar position as we were for Shanghai, that it may be just too big given the time frame. Yeah, that being said, I think we do have to be proactive regarding the transaction, like the requirements for the new transaction types because there's this ongoing discussion of the ssdification of transaction hashes and the proposed dip for that. I think this would have an effect on that. So I don't think EoFV two ss would roll out in Cancun, but I think we have to do as much as possible to prepare everything else to be compatible with the V two we want to have.
00:24:06.450 - 00:24:07.422, Speaker A: Yeah, that makes sense.
00:24:07.476 - 00:24:09.042, Speaker C: Yeah, I agree.
00:24:09.096 - 00:24:22.680, Speaker B: I think V two is too much to get into Cancun, but I think we'll know what the scope is going to be and what the feel for. So it could roll forward in Prague with the new features. So yeah, I like this plan.
00:24:24.010 - 00:25:20.314, Speaker A: Okay, cool. Yeah, let's just stay vigilant on these changes with the SSD transactions, try and make sure that what's happening there is amenable to future changes that we might need or want to make with EOFV two. And also we just need to keep in mind and keep an eye on this proposal in general in the context of Cancun. Because I think this is going to be a relatively large change for the El. And so I don't know if it's necessarily competing with EOF, but if we think about El teams having a finite amount of resources for completing changes in their clients for forks, then this is obviously taking a piece of that. So I think, yeah, it would pretty much be impossible to do the SSE 4844 and ELF in the same fork. So V 1.1
00:25:20.314 - 00:25:23.340, Speaker A: is certainly our best bet in that situation.
00:25:27.310 - 00:25:30.890, Speaker C: Um, I don't know if there's any.
00:25:31.040 - 00:25:59.940, Speaker A: Specific things that we want to discuss on the spec. I think the updates were really useful, but we spent a lot of time discussing things in Austria. Is there anything that you would like to mention on the call or should we just talk about testing? I know there's some outstanding prs as well that need to be reviewed.
00:26:11.640 - 00:26:21.670, Speaker C: If we have the time, I would propose to maybe go through this document I shared. Maybe spend like five minutes just on this 1.1.
00:26:24.600 - 00:26:25.396, Speaker A: Yeah, let's do it.
00:26:25.418 - 00:26:39.580, Speaker C: I think most of the people on this call have been heavily involved, but I do see a number of people who with those discussions in Austria, but I do see a number of people who haven't. So maybe it's better to be aligned on these ideas.
00:26:40.640 - 00:26:46.030, Speaker A: Yeah, let's do that. We've got about 30 minutes left, so should have time.
00:26:47.540 - 00:26:52.530, Speaker C: Could you by any chance screen share it if you have it set up?
00:26:53.780 - 00:26:55.250, Speaker A: Yeah, give me 1 second.
00:27:07.170 - 00:27:07.690, Speaker C: It.
00:27:07.780 - 00:27:08.420, Speaker A: Okay.
00:27:14.400 - 00:27:51.716, Speaker C: Yeah. So on the introduction, it's just a summary of basically what we discussed already, that we want to roll uf out in two steps. The first step is the 1.1 where UF contracts can only be created through transactions and not through create instructions. And then the v two enables the contract creation. And then I have three different sections here, what the individual versions mean. So under v one I meant that everything what we have today.
00:27:51.716 - 00:28:02.060, Speaker C: But I also included this delegate call restriction, which has been proposed, I think, a few weeks ago and is 54.
00:28:02.130 - 00:28:06.668, Speaker A: 50 emitted for a specific reason here.
00:28:06.834 - 00:28:57.448, Speaker C: Yeah, I wasn't sure what's the actual number, but yeah, all of that is included. Okay. And then 1.1 is the interesting one. And here we only list like the changes which are different to v one. So regarding creation, we just disallow the create and create two instructions in the EUF container. And that means that of course you cannot create any kind of accounts from an UF context, but we still want to keep the external transactions to create Uf accounts.
00:28:57.448 - 00:29:57.184, Speaker C: And here we discussed a number of ways how to actually accomplish this. And I think we ended up with like two options, which seem the most reasonable options. The first one, and it's important to. Maybe I should have actually listed creation and introspection in the other order. But what's important is we not only disable, create and create two, but also all the xcode instructions and the code instructions. And so EUF init code wouldn't be able to use code copy to get the runtime piece. And so to get around this problem and not introduce any more complexity, one option would be that this init code Uf in v 1.1
00:29:57.184 - 00:30:13.510, Speaker C: would have this special behavior where the call data actually has access to what the code copy would have had access to in the init code context. I'm not sure if that's clear, but itian, I can go deeper on that.
00:30:15.320 - 00:30:16.790, Speaker A: I think that makes sense.
00:30:19.890 - 00:31:19.438, Speaker C: So basically creation today, just in legacy creation today, in the init code, whole data is empty and code copy has all the code, including any of the constructor arguments. And because we disabled this code copy instruction, there's no way to get that. But the simple trick is that call data would have access to that. So that's like one option. And the other option is instead of having Uf as in it code, we would actually allow legacy bytecode to create Uf in a creation transaction. And that means there's no special handling required. But I think it kind of goes against the current specs where we decided that legacy and the UF, they cannot create each other.
00:31:19.438 - 00:31:28.660, Speaker C: And maybe for that single reason, this might be too big of an exception. And the special UF init code idea is the better direction to.
00:31:31.590 - 00:32:18.740, Speaker A: One. I don't know. I think one slightly strange thing about the special EOF context is we're changing what the meaning of call data is in the context of just this EOF creation contract. And it is a bit of a pretty large difference from how it operates whenever you're just doing a create transaction, non EOF. And because the create transactions, the init code is very ephemeral. I don't think it is as important in both cases. But to me that makes it seem like deploying EOF from legacy bytecode from a create transaction would also be reasonably okay.
00:32:22.560 - 00:33:18.444, Speaker C: Yeah, I would say for the first part you said the special EOF context, it is a deviation from what we have today, but it is actually in line with how V two would operate. Because in v two, and that is an extremely long document, this v two design space. But I would suggest whoever has the time, please give it a read. It has a lot of interesting pieces, but it is super long. The important part of that is we would have a create transaction where the code and data is separate. And that means that the code piece would have the init code and the data would be just call data. And this code field in the external transaction would be a new addition.
00:33:18.444 - 00:33:33.030, Speaker C: We don't have that today. But in that paradigm, the call data copy in v two would operate as it operates in this special case. So it's kind of forward compatible, but it is a deviation from today.
00:33:33.480 - 00:33:43.210, Speaker A: So the call data would copy the code that's associated with the transaction in the code list.
00:33:44.300 - 00:33:52.180, Speaker C: No, well, in today, the call data pop is the data field from the transaction.
00:33:52.260 - 00:33:56.220, Speaker A: Right, but not in a create transaction.
00:33:57.920 - 00:34:00.172, Speaker C: I mean, in the special context it is, right?
00:34:00.226 - 00:34:03.070, Speaker A: Okay, yeah, in the special context, yeah.
00:34:03.760 - 00:34:13.890, Speaker C: And in v two, this still happening like that. But in v two, you wouldn't send in it code in the data field. You would send in it code in a code field.
00:34:14.340 - 00:34:15.392, Speaker A: I see what you're saying.
00:34:15.446 - 00:34:24.208, Speaker C: Okay, so I think the special Eof is forward compatible, but. Yeah, it may be confusing, but doesn't.
00:34:24.224 - 00:34:31.800, Speaker A: That mean that the Eof code ends up getting into memory? And so then you do have introspection in this create transaction.
00:34:32.460 - 00:34:38.570, Speaker C: Yeah, and I don't think we can avoid introspection in the create transaction unless we go with v two.
00:34:38.940 - 00:34:40.330, Speaker A: Oh, I see. Yeah.
00:34:43.260 - 00:35:26.170, Speaker C: That'S the decision we made. It just doesn't seem to be possible to avoid this. If you want this intermediate stuff that makes sense. And then introspection, as mentioned, x code and code instructions are not allowed. And x code instructions have some special behavior. I think what is kind of clear, based on the itelwise discussions, that Xcode copy would just work, but it wouldn't copy anything. But regarding size and hash, we had two options, and we're still not clear which is the better option.
00:35:26.170 - 00:36:17.480, Speaker C: One option is they just keep operating as is today. They give you the actual size and actual hash. The caveat here is that we have to mention that accounts may get updated and then these values change. That being said, I don't think accounts can ever be updated, but technically they could. I mean, that's the goal of this bending introspection. Another idea we discussed is EOF accounts would just operate as if they have the EF zero zero as a code, and then code sizing code, hash return values based on EF zero zero. I think this is something we really have to decide during this month, which is a better direction.
00:36:17.480 - 00:36:43.360, Speaker C: And then the last piece is regarding gas introspection. That was also like a lengthy discussion, but I think we ended up with the most simplistic option, that we just disallow the gas opcode and the call instructions, get the gas argument removed, and we just pass all the gas.
00:36:45.460 - 00:36:45.872, Speaker A: Over.
00:36:45.926 - 00:37:52.708, Speaker C: To the collie and a piece of this discussion has been what happens with the stipend? And the opinion is that since we remove this option to change it, we can adjust what happens with the stipend without any changes to EUF. So in V 1.1 we likely would just leave everything as is. But in V two, we could get rid of the stipend and refine more things around gas. And then V two, we have linked to this long document, but there have been three different discussions we had afterwards which are not covered in the document. And there was like an interesting discussion regarding had to do contract creation in general. And one idea was that it would work based on code cloning.
00:37:52.708 - 00:38:40.592, Speaker C: And if you would have that, then you likely would need a way to insert code into the state without doing any kind of creation. You just take UF code and you validate it, that it's valid, and just place it at an account. Nothing else happens. Then you can clone that. I think there's an interesting discussion, and probably we have to look into this once we spend more time on the V two idea. Two important questions, however, because I think those really drive the discussions of the design. Whether we want to support data contracts and whether we want to support solidity immutables, or if we don't, then we kind of force people to use storage.
00:38:40.592 - 00:39:00.140, Speaker C: And the answer to these two so far have been that we don't want data contracts and we want to support immutables. And that is what drove the design described in this v two design space document. But if the answers to these are different, then we have a different design space. Yeah, I think that's the long summary.
00:39:02.160 - 00:39:29.670, Speaker A: That makes sense. That's awesome. Thanks a lot for going over all these ideas. Does anyone have any questions about this for Alex? There's a lot of good stuff in here.
00:39:36.320 - 00:39:37.070, Speaker C: Cool.
00:39:38.560 - 00:40:14.390, Speaker A: Any final spec related updates? Questions? Comments? Okay, testing. We talked a bit about testing in different contexts. Does anybody want to share some updates about what they've been up to, some concerns, some things that they would like to see?
00:40:21.720 - 00:40:24.150, Speaker B: We don't have the testing team on the call, do we?
00:40:25.640 - 00:40:41.500, Speaker A: We don't have anyone from the testing team on the call, but I know that the Epsilon team has spent quite a bit of time writing some that I saw that Ori also has written quite a few tests. I don't know if you guys have looked very closely into what he's been up to.
00:40:41.650 - 00:41:08.244, Speaker B: Oh my goodness. The assembly output that he's got of his UF containers is just awesome to look out. He's posted. So as I'd requested one of the calls, we need to have a separate set of tests just to judge contract validation. And coming up in the reference test there's a really nice suite of those. And if you look in the filler for it, it is a really nice breakdown of what they look like. And I'm like tempted to see if we could automate generation of assembly output like that.
00:41:08.244 - 00:41:20.730, Speaker B: It's truly a sight to behold. Let's see. Where did he post the most recent copy of that?
00:41:22.140 - 00:41:28.670, Speaker A: Was it in the testing channel? I think I have this link. Is this what you're referring to.
00:41:30.880 - 00:41:53.924, Speaker B: That one? Diff? Yes, I think so. Let me. So there is work coming in the reference tests to get these in a formalized test, which I think is a really good development. Am I able to share? But what I was mentioning is go.
00:41:53.962 - 00:41:56.656, Speaker C: Down to the filler load.
00:41:56.688 - 00:42:35.056, Speaker B: Diff. This is like the most awesome breakout of the, of I've ever seen. It's got the legacy, it's got the UF deployed code and it's very nicely lined up. Describes every line of what's going on. This is practically a tutorial. And how to build these mean it's a lot of work just to get a bunch of tests that say pass fail. But when you don't know what's going on, to be able to look into these and see well why is it failing? What is it supposed to look like in your code for future implementers? This is just like, this is stuff you could bring into a college classroom to teach stuff about it.
00:42:35.056 - 00:42:36.050, Speaker B: It's that awesome.
00:42:39.540 - 00:43:10.430, Speaker A: I'm curious what you guys think about this perspective. I think this is obviously super great in many ways, but one concern I have with the way that this is formatted and probably generated is that it's not very easy to update whenever the spec changes. I think we're sort of past the point maybe now of changing the header format much, but imagine we do change the header format. You have to manually go in and update every single one of these.
00:43:12.240 - 00:43:12.652, Speaker C: Right.
00:43:12.706 - 00:43:22.016, Speaker B: That's why I wanted to know if there is a way we could write software to automatically generate this from standard output. This would be an awesome thing to do, right?
00:43:22.198 - 00:44:02.860, Speaker A: Yeah. And so I don't want to try to impose too many restrictions on how people are doing testing because it's important to get it done. And at the end of the day if we handwrite these things and it's a little bit of extra work. It's a little bit of extra work. Whatever. I do think this is where the python execution spec tests shine. You're able to write functions that generate this type thing, and it's much easier to change the implementation of one function that spits out a whole bunch of bytecode than it is to manually update some bytecode that was either generated with another tool outside of this format or something that you're constructing sort of manually.
00:44:02.860 - 00:44:28.960, Speaker A: Yeah. Ipsilan. Do you guys have anything to share about what you've been up to with testing? I know you kind of said that you feel that testing is sort of coming to a completion, at least for v one.
00:44:33.490 - 00:45:16.720, Speaker C: So I'm not sure if Hugo has a working mic. Hugo has been solely focusing on writing tests you cannot unmute. And I think right now Hugo is still doing the end of like 47 50 test cases. I think that's the piece which going to be close to completion probably in the next week or two, but I don't think we have started to write comprehensive tests for 54 50. So that's definitely outstanding. Got it.
00:45:27.970 - 00:45:41.730, Speaker A: Anything that we should be thinking about and working on in the next few weeks? Obviously 54 50 tests. Sounds like that's the next thing that Hugo is going to get up to. Any other considerations?
00:45:45.690 - 00:45:49.960, Speaker C: There's actually one more. Yeah, go ahead. I can go after.
00:45:50.330 - 00:45:50.742, Speaker B: Yeah.
00:45:50.796 - 00:46:23.150, Speaker D: Just wonder how much other teams are going to do test day implementation right now. I think if you assume that you will not spend a lot of time on it, then we can drop some changes to the spec into this 1.1 direction. I think if you need more time to actually test what is currently spect out, then we can move it further.
00:46:27.210 - 00:46:52.000, Speaker A: Speaking from myself at GEF, I probably will not be working on updating ELf implementation for maybe a month. There's a lot of other things I need to work on, so I would be happy if things were dropped into the spec and I just started targeting what the 1.1 changes are.
00:47:12.290 - 00:47:29.300, Speaker C: I guess for that reason, the t eight n support in evm one seems to be a really good direction. Right, because we can work on this 1.1 without the need of co ethereum. Yeah, absolutely.
00:47:32.470 - 00:47:38.914, Speaker B: I think the only real barrier for 1.1 is going to be the changes to the call code for gas introspection.
00:47:38.962 - 00:47:41.254, Speaker C: I think all the other tests in.
00:47:41.292 - 00:47:58.010, Speaker B: There are just get rid of tests that use these or change the test to fail. So as far as just don't write tests for ext and code copy stuff except for the v eleven, I don't think there will be too much collision between these two versions.
00:48:04.220 - 00:48:05.050, Speaker A: All right.
00:48:07.020 - 00:49:40.730, Speaker C: So there's actually one more spec point which was brought up by Daniel from solidity. It's the solidity metadata, which currently is at the very end of contracts. And it is a seabore encoded metadata where the trailing two bytes are the length of the preceding content. And that's how tools like sourceify can dissect contracts and see what the solid metadata is and extract information out of that with the data section. The insight was that it just seems to be that in an ideal scenario we would have like multiple data sections or we would have custom sections or whatnot where something on the application layer could be designated as state. This is the metadata, because this metadata stuff does some kind of encoding like this length, which really should be delegated in an ideal case to the container format. So I think what Daniel brought up is whether we should consider having multiple data sections or having specific metadata section, or having custom sections in general.
00:49:47.680 - 00:49:53.490, Speaker B: So if we had a metadata section, it wouldn't be introspected at runtime, right? It would be considered the same as the code.
00:49:57.940 - 00:50:14.980, Speaker C: Yeah, I think if it's specific, it's a specific kind of section. And in the v two, what we said that only the data sections have the data copy opcodes, then any section outside of that won't be inspectable.
00:50:21.580 - 00:50:52.890, Speaker B: How would multiple data sections work with the proposed opcodes? Is another thing I think we need to consider. Or if we would just have one flat data space and require the contract to manage its own space based on that, I would prefer a separate metadata section and keeping one flat data space for simplicity. But simplicity is not always the best path forward.
00:51:02.270 - 00:52:02.062, Speaker C: Yeah, I think the concern was that at least with the UFV two proposal, we have this auxiliary data, which is basically the data you can send from init code to be appended to the data section. And in that model, solidity cannot really have the metadata at the very end anymore because you would need to insert it from within the constructor. So if we don't have a special section or anything, then what solidity will do? They will place the metadata at the beginning of the data section, which is fine, but they felt like that maybe separation is good. So it would be a separate unconstrained.
00:52:02.126 - 00:52:09.190, Speaker B: Field of fixed length and it would just be opaque to do runtime and not accessible at runtime.
00:52:17.810 - 00:53:09.806, Speaker C: Yeah, I guess that's one option. Another is, as you said, multiple data sections and it's still up to, I think the multiple data sections is nice in one way, but then it also complicates matters for the init code. Which data section is this? Auxiliary data being appended to? Obviously the last one, but maybe for this reason, like this will do with data sections. It's just too complicated. Yeah, I'm not sure. I think it's really just that it would be nice to discuss these as we are right now. I know that we are like finishing in two minutes, but in the next call I think it would be the discussion points I would propose is like this metadata just agreeing on something.
00:53:09.806 - 00:53:21.380, Speaker C: Which maybe we do what we do right now. And the V 1.1 questions, I think we want to get answers to that on the next call.
00:53:26.200 - 00:53:28.440, Speaker B: Next call is the week before Eth Denver.
00:53:38.820 - 00:53:46.530, Speaker A: Look and see. Yeah, I think we were going to do them every other week. So that would be the 22nd.
00:53:50.900 - 00:53:51.312, Speaker C: Okay.
00:53:51.366 - 00:54:00.730, Speaker A: I don't think I have it on the calendar yet, but it would be the 22nd. That would be. Yeah. One week before.
00:54:02.380 - 00:54:03.130, Speaker B: Yeah.
00:54:04.060 - 00:54:05.508, Speaker A: Oh, it is on the calendar.
00:54:05.684 - 00:54:07.000, Speaker B: It is on the calendar.
00:54:07.340 - 00:54:07.992, Speaker D: Yeah.
00:54:08.126 - 00:54:10.584, Speaker B: Let's discuss it then and have people think about it.
00:54:10.622 - 00:54:13.208, Speaker C: But it's before eigth Denver, so we.
00:54:13.214 - 00:54:28.050, Speaker B: Won'T have any specs to push around. So we can have an open discussion before we would expect to have any specs written, which I think would probably be open up the design space. Probably a good thing, right?
00:54:31.680 - 00:54:53.040, Speaker A: Okay, guys, we're at the top of the hour. Any last things to mention? Great, thanks a lot. It was good hearing the updates from Austria. We'll talk to you guys again in about two weeks.
00:54:54.490 - 00:54:58.898, Speaker C: You cool? Thanks. See ya. Thank you. Bye.
