00:00:16.730 - 00:00:58.686, Speaker A: So I'm Ryan, and I understand this is being live streamed. So if any of you watching at home have any questions or comments, feel free to tweet at ripdX, and I will get to those as soon as I can. So we've decided to be the ethereal namespace. Maybe someday we'll be the Ethereum namespace. That would be great. I'm a dev with Nexus, and in the process of working on the maker stablecoin and cryptocurrency leverage platform, we decided that we needed to make a smart contract package manager. We made that.
00:00:58.686 - 00:01:52.430, Speaker A: We called it Dapple. One of the design goals of Dapple was to provide a node package manager like experience so people could install and publish packages by their names under username namespaces. So to accomplish that goal, we came up with the system of smart contracts that we call the ethereal namespace. Essentially, it's a hierarchical permissionable name Reg. So this is the name reg interface as it stands, and it allows you to map addresses to names and names to addresses. And it's great for a lot of purposes. I use it myself, and usually I end up with something like this, where I'm just mapping strings to addresses.
00:01:52.430 - 00:02:51.570, Speaker A: But if you have data that looks kind of like this, that's somewhat hierarchical, it's not such a great fit. Now, you can naively store data like this in a name reg contract. You can do this and just have path strings mapped to addresses. But there's a drawback to that, which is, first of all, there's a conceptual gap between the user's mental model of how the thing should be working and how it's actually implemented. And usually with good design, you want to minimize the gap between how the user thinks the thing works and how it actually works, because the greater the gap, the greater the abstraction tends to leak. So that's one problem with it. Another problem with this approach is that it kind of becomes messy and difficult to try to set permissions on subpaths, right? Because now you have this big name Reg, and you have to parse each subpath and do all this stuff to deal with permissions on subpaths.
00:02:51.570 - 00:03:54.070, Speaker A: So something like this is a much better fit for hierarchical data. I don't think I have to argue that one too hard to this crowd. So this is what we basically tried to make. Now, my initial approach to it was to just chain together name reg contracts, and it technically works. But again, there are a couple of drawbacks. Number one is there's a non locality of information here if I am just interacting with this name reg contract here, I'm getting addresses, but there's no information within this name reg system to indicate which addresses are pointers to name reg contracts, which addresses are basically pointers to subtrees, and which addresses are just addresses. So that information has to either live within the application that is interacting with the name reg, or you have to do some sneaky things to try and define if this address is pointing to a namewreck.
00:03:54.070 - 00:05:05.782, Speaker A: The other problem, of course, is that there's no standardized way of setting up permissions on these namebread contracts, so you end up potentially with a lot of one offs, maybe some things that don't quite separate concerns well enough. So to resolve the first problem, all of our getters and setters on our ENS app interface return and accept a boolean called islink, and that explicitly defines whether the data stored at a particular path should be considered a pointer to another node in the tree. And the second problem of not having a standardized permission interface we just solved by making a standardized permission interface. We call it controller contract, and you can set those on any node in the tree. So this is roughly what our code looks like right now. This is just a UML diagram, and you can see there are two distinct structures. The one on the left is governed by the NS app interface on top, and that is what you'll be interacting with most of the time.
00:05:05.782 - 00:06:03.718, Speaker A: It lets you get and set values in DNS tree using paths, and the second structure you'll only use if you're setting permissions on a node. I'll dig into these in more detail over the next few slides. So this is the interface for the ENS app contract. And you see there's a get in a set function. You'll also notice that on every function we have a boolean ok return value. We found that was necessary because sometimes functions return nulls if there's a failure mode. There are certain failure modes that return null, and you need to be able to differentiate between real valid null values and a failure mode, right? So if the Boolean okay returns true or is true, then everything went through okay.
00:06:03.718 - 00:06:52.534, Speaker A: If it's false, then any null values gotten back are not valid and you should figure out what's going on and fail gracefully. So get takes a forward slash delimited path and returns a bytes 32 value. It returns our is link Boolean that we talked about earlier and returns the okay Boolean set, of course takes a path, a value, and is link returns the okay boolean. And those are what you'll be working with most of the time. Of course, claim node you'll only be working with if you're writing a controller contract. Controller contracts call this function. The ENS app sets the controller contract, making the call to be the controller for the node that it sets aside in the tree for that controller, and then it returns that node's id.
00:06:52.534 - 00:07:45.190, Speaker A: The controller contract can then build out the subtree as however it wants, and it can set the position, the path for that subtree in the EnS tree using the set function. It passes in the desired path, it passes in the id of the node as a value, and it sets the is linked function or boolean to true. And then we have the node get node set functions, which are just ways of saving on lookup costs. On nodes, you can look up values relative to nodes and set values relative to nodes. And then finally the git controller function, which simply takes a node id and returns the controller contract. And that was a bit of a data dump. So here's a kitten.
00:07:45.190 - 00:08:34.054, Speaker A: Take a breather. All right, we'll jump back into it in three and two. All right, and this is the ENS controller interface. And the only thing that interacts with the ENS controllers is the ENS app. So when you're writing an ENS controller, you need to make sure that's permission, that only the NS app can interact with those two functions. It takes a node, an address, that's the caller making the request to set or get the key and the value that should be stored as well as the link Boolean, and it should return false if the caller either doesn't have the right permissions or if the requester doesn't make any sense for the given path. So to make your life easier, we've implemented a couple of controllers for you guys to look at.
00:08:34.054 - 00:09:20.440, Speaker A: I'll go over these very quickly because I'm running out of time. This is the standard registry controller, and it's simply a first come, first serve zero fee controller. If you look above set and get the new registry function is what you'll be using to set to request nodes from the ENS app and get back an id that you can then set using the set path method that we talked about earlier in set and get, of course, set and get values and transfer above the ENS set. And ENS git allows people to transfer ownership of nodes between each other and ENS set and ENS git we of course talked about earlier. So all of this code is published@GitHub.com. Nexus development ens. I don't know if you can see it on the bottom there.
00:09:20.440 - 00:09:53.278, Speaker A: All right, cool. And we're looking for feedback. We're looking for pull requests. Obviously, with a system like this, the more people using it, the more valuable it is to everyone. If we have a common ENS app implementation, then it helps with discoverability, and we've been trying to figure out how to make that happen. So we'd love some feedback, get in contact with us. Some of the things we've been kicking around is maybe a token system for registering tlds, maybe an auction system.
00:09:53.278 - 00:10:10.420, Speaker A: So if you want to be part of that process, please talk to us, tweet at me, email us. We have a GitHub. We're fairly easy to stock, so you can get in contact with us somehow. If you have any questions or comments, again, tweet at me or find me during one of the breaks. Thank you very much.
