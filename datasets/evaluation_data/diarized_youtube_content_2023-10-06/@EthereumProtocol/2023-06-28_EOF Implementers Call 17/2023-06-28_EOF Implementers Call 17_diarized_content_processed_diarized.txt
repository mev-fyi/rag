00:00:00.330 - 00:00:14.400, Speaker A: Hey guys, welcome to the EOF implementers call number 17. It's been about a month since we've had chance to chat, so looking forward to hearing what you guys are up to. Maybe we can get started with some client updates from everyone.
00:00:16.450 - 00:01:01.038, Speaker B: Sure Basu, I'll go ahead and start. We still don't have create three written I've been focusing on other more foundational tasks that I think are going to be helpful for the EOF process. Besu can now run the execution client specs. It can also through the t eight n and b eleven r tool. And there's also a grall compiled version of BEsu that is able to run the retest f tests at the same speed as the other clients because with Java there's a lot of startup issues. GralVM compiled version also gets rid of that startup burden, so that increases the number of clients that can be used in reference test generation. I think evm one has also added some of that.
00:01:01.038 - 00:01:40.330, Speaker B: So I think this is some foundational steps to get us to start writing reference testing and start doing cross client validation tests. Create three is just, I just got to spend the day fine combing through the spec and making sure we all do that. I do all the steps right and applying all the other existing reference tests that sit in the there are some reference tests that are a little bit out of date that are in some of the prs. We've got everything renumbered as well inside of basic two. And this is all in, it's not in the mainline basic yet, it's in a branch, it's in the mega EOF branch on Hyperledger basic repo. So those are the updates for Basu.
00:01:42.610 - 00:01:49.040, Speaker A: Cool, thanks Dano. Who else?
00:01:50.770 - 00:01:58.980, Speaker C: Ayman from Nethermind side. We were focusing mostly on Cancun by the way. Can you hear me guys?
00:02:00.630 - 00:02:01.860, Speaker A: Loud and clear.
00:02:03.190 - 00:02:03.842, Speaker D: Good.
00:02:03.976 - 00:02:30.410, Speaker C: We were focusing more on Cancun eips and for EOF we just did some cleaning up and matching correctly the spec, fixing some bugs and we are planning on starting on implementing thn this week, by the end of this week. So hopefully after a week or so we will be also able to generate reference tests. Yeah, that's mostly it from our slide.
00:02:31.410 - 00:02:41.710, Speaker A: Awesome. Do you also need to implement b eleven r? Have you looked at that's.
00:02:44.790 - 00:02:46.100, Speaker C: We'll do it.
00:02:46.470 - 00:03:04.870, Speaker A: Okay cool. Yeah, I think for retest eth you only need to implement t eight in, but to use the execution spec test you need also the eleven r. Cool. Yeah Paul.
00:03:10.570 - 00:04:04.700, Speaker E: So in EvM one we mostly like what is worth noting is we did change the opcodes following the suggestion for Cancun and others. So all of that has been reworked and we are working on updating existing tests to respect this change opcodes. And Hugo is working on this. And I think there are two pull requests for ethereum tests that does this. And I think in terms of implementation, Andre is working on creates tree and all the different edge cases, so maybe he wants to do the update, but I think that's more or less overview of the changes.
00:04:11.620 - 00:04:15.860, Speaker A: Sweet. Did you want to mention anything about that, Andre?
00:04:16.520 - 00:04:46.590, Speaker F: Not much to add, actually. I think create three implementation is finished now in the vm one. One small final problem that I fixed was there was a charge for hashing of input data applied by mistake, because originally it was in the spec, but then we removed it from the spec, but this charge still remained and it also remained in the spec. So I removed it from there too. Now it's fixed yet.
00:04:47.280 - 00:05:06.180, Speaker A: Cool. Any other client related updates? Any compiler related updates?
00:05:08.920 - 00:06:26.110, Speaker D: Hey Charles from Viper. So I think I brought up a couple meetings, maybe two or three meetings ago about the code size issue from stack validation, and not, it's a little bit tricky to reason about, but because of the stack validation issues, because of the stack validation in the spec, you can't really share code as well as it used to anyway. So we're seeing kind of code size increases from 1% depending on different kinds of things you can try to do to repeat it. But I'm trying to. Well, I'm wondering if we can relax the stack validation rules. I. Yes, sure.
00:06:32.580 - 00:06:33.760, Speaker A: Yeah, Paul.
00:06:35.540 - 00:07:35.050, Speaker D: And then another thing I wanted to bring up, which I think would be useful is I think immediates pointing to code locations should have a variable link encoded, because a lot of the time a jump is going to be to someplace that's fairly close. So if we can save a fight or two on every jump, that would be really good. And I was talking about the stack validation thing with Greg for a little while last time, and I'm not convinced that you need the stack invariant rule in order to write a compiler for the UF code.
00:07:40.380 - 00:07:41.850, Speaker E: Yeah, thanks.
00:07:46.460 - 00:07:48.010, Speaker D: Okay, go ahead.
00:07:49.440 - 00:07:51.230, Speaker E: Yeah, maybe you finish first.
00:07:52.080 - 00:08:12.530, Speaker D: Yeah, I was also comparing the code sections versus EIP 20 315, and I think that maybe having code sections not necessary and kind of makes some optimizations more difficult.
00:08:17.180 - 00:08:17.544, Speaker B: Yeah.
00:08:17.582 - 00:08:55.224, Speaker E: So about this stack height. Yeah, I remember about the issue, and I kind of planned to at least start working on this. So what I mean by working is to just describe the problem and give some examples. That doesn't work, but they could work. I mean, I kind of have impression this is somehow fixable, and we discussed that with solidity some time ago. So it's kind of matter to finding time from my side to finally do it. But I don't have final solution and cannot promise we'll find one.
00:08:55.224 - 00:09:14.840, Speaker E: But it's a bit like algorithmic problem to solve how to specify it in the way that we'll still be able to work with this. If you have ideas how to exactly formulate the rule.
00:09:15.000 - 00:10:02.190, Speaker D: I think it's kind of like the difference between, because you can have recursion with calls, right? You can have like tail recursion. So a loop should in principle not be any different from tail recursion. So you should be able to basically do the opposite of tail recursion, which is when you see some instruction which can have multiple entry points which result in different stack heights, you just kind of outline that basic block. And then on the back end you would have to issue like a call instead of a jump, which gives you a return pc or something, which is not as good as a jump, but it's not that bad either.
00:10:07.270 - 00:10:29.500, Speaker E: Yeah, I'm not sure I can process it on the fly, but I will try to make it maybe before the next call, definitely to formulate the current status, like what the problem is and how people imagine changing the spec a bit to kind of accumulate for that.
00:10:31.150 - 00:10:59.970, Speaker D: Yeah, I can talk about it with you offline on discord or something, but I think ideally we can just drop the stack validation requirement entirely and maybe make those code sections a little bit more expensive if the back end is required to outline some piece of code so that it requires column instead of jump.
00:11:01.770 - 00:11:23.820, Speaker E: Okay, let's talk after then. And about like variatic encoding. I don't know. We kind of considered that long time ago, think that the simplicity has won, but I don't know, maybe others have comments about it.
00:11:25.150 - 00:11:50.000, Speaker D: I think variable length encoding is not that complicated. It's not as simple, obviously, as all location encodings being static, but it's easy to understand. Everybody gets it and I think you would see a pretty significant code size savings. So I think it's worth it.
00:12:07.870 - 00:12:13.340, Speaker A: Did you have a couple other things there, Charles, or was that most of your questions?
00:12:14.590 - 00:12:46.308, Speaker D: I think the last thing was about meeting code sections. I think that you could have just as good code generation or better if you had one global code section instead of multiple code sections, or one code section for 17%, so to speak, it.
00:12:46.494 - 00:12:48.190, Speaker A: Do you guys have thoughts on that?
00:12:59.370 - 00:13:08.070, Speaker B: If it works better with one global code section. Can't that just be a compiler preference as to how they go about it? Do we need to remove code sections?
00:13:09.930 - 00:14:12.586, Speaker D: Yes, because call app only works with code sections. You can't use call sub to. It's like call f versus call sub. And the difference is that call f goes to a different code section, whereas call sub would be with the global code section and it would jump to some instruction with the return pc on the call stack. And I'm distinguishing the call stack from the operating stack. I also want to address what Andrea is saying is that you can use jump f to not change the call stack, but what that doesn't include is that it doesn't work with our jump I so like if you have a conditional jump to some code section that you want to share, you can't do that. You have to branch around a call up or a jump f instruction.
00:14:12.586 - 00:14:37.780, Speaker D: So it's an overhead of several bytes and instructions. Basically, let's do an is zero and then jump around the call up or jump out instruction. It's not just an implementation problem, it's a spec problem. Because of the jump on issue that I just brought up.
00:14:46.810 - 00:14:52.490, Speaker B: Can you write these out with examples so we can reason more closely about it with concrete examples?
00:14:54.830 - 00:14:57.850, Speaker D: Sure. Do you want me to write them out in the chat.
00:14:59.950 - 00:15:01.030, Speaker B: In discord?
00:15:01.190 - 00:15:05.520, Speaker D: Yeah, I think they're also in the discord history, but I can write them out again.
00:15:07.650 - 00:15:09.280, Speaker A: Or just bump your post.
00:15:16.050 - 00:15:19.520, Speaker D: I'll do that after the call. I have to actually leave in about ten minutes.
00:15:20.470 - 00:15:46.680, Speaker A: Thanks. Okay, that was kind of compiler and spec related things. Any other? I guess we can just move on to spec related updates and questions. Anyone have anything on that topic? Hey Zane.
00:15:47.180 - 00:17:20.176, Speaker G: Hey, just quick question about the think. I guess I'll be a small representative for the on chainers or the consumers or the DAP builders. So we put together a small working group with Artblocks and nounstow and everyone chainers. And we're kind of going through, yeah, we've kind of gone through the spec and we're trying to figure out what should be the game plan for the EOF changes. And so we put together about a couple of proposals and Dano, I know you commented on it, and so what we wanted to do was to start testing this out. Part of the concern is that looking around at the other people that are consuming things, we noticed that token bound accounts, I think is also using xcode copy, and so that's gaining a lot of steam within sort of just the NFT ecosystem, and so they're using that as a sort of minimal proxy to create new sort of derivative contracts that are like smart contract accounts. So it just seems like it would be good to be able to put together a test harness or just to know whether or not x data copy.
00:17:20.208 - 00:17:22.516, Speaker B: Is going to be a thing or.
00:17:22.618 - 00:17:48.118, Speaker G: If we should sort of take on board Dano's suggestion and then how should we test it? So that's like quite a few little questions in there. So what should we do, or when will we know what's supported?
00:17:48.294 - 00:18:43.690, Speaker A: There we go. I guess I can make like a quick comment that if this is going to happen for Prague, that would be sometime mid next year most likely, and we would probably have a good idea that that's going to happen by this fall. The exact specifics, I think things are settling for the spec. So depending on what the likelihood of EOf going into prog is, you can sort of use that as a guide. If you have specific issues, I think it's a good time to raise them. Like if people are using X data copy or xcode copy, then this is a good time to have the discussion about what's the right way for people to achieve the same functionality.
00:18:44.590 - 00:19:04.450, Speaker G: Yeah, that makes sense. I linked it in the discord, what may be the sort of hidden, broader implication, and I can link it in the chat real quick if I can find it. But that's it. And so it's looking like next year sometime.
00:19:08.210 - 00:19:20.260, Speaker A: I would guess Prague would be sometime mid next year because Cancun we're targeting for this fall, you usually add six to eight months after the fork. That's kind of a rough estimate for when the next one might be.
00:19:20.950 - 00:19:31.000, Speaker G: Okay, so none of the xcode copy changes would land until mid next year, until Prague, we'll say.
00:19:31.690 - 00:19:32.440, Speaker A: Right.
00:19:35.770 - 00:20:21.380, Speaker D: I actually have a thing about expo copy, which is that I think it's kind of a common pattern. Viper uses it for these blueprint contracts. It's ERC 52 and it's used for these kind of factory contracts which can read the init code from like a data contract, basically. And I think that's generally quite a good way of splitting code out. So I guess the pattern could be changed, but it might also just have an copy kind of thing.
00:20:28.830 - 00:21:25.530, Speaker B: So one of the high level goals that we're trying to achieve with this right now, until we formally abandon it, is to get rid of the ability to introspect code within code. You could think of it as basically the NX bit that the iPhone is subject to. You can't take data that has been processed by code and then execute that code. So as far as ext code copy going into the code segment, that is something we've had explicit requests from very high level people to not have functional, because it's going to have strong impacts on ZK systems. It's going to have strong impacts on cross compile systems. It's long term the direction we want to go to ensure upgradability of EOf code. That's one thing that's putting it at ods with some of the requests.
00:21:25.530 - 00:21:58.390, Speaker B: However, as far as copying data and not code and using a standard like this, FE 71, that is something that I think is something that could be worked in, maybe not necessarily in first draft, but I think there is possibly room for, and I think is less contentious than copying the init code itself. So that's kind of the table stakes going on. I don't have any strong yes or no's on that yet, but that's what we're trying to navigate around, what we're trying to achieve.
00:21:59.610 - 00:22:19.078, Speaker D: Yeah. Can you maybe explain a little more around so I can understand better? Are we trying to ban code contracts, introspecting themselves, or what kind of code introspection.
00:22:19.094 - 00:23:09.902, Speaker B: Are we trying to ban code introspecting, introspecting code full stop itself or other people. So we don't want code basically doing just the time compilation. We would like that the code that's going to be executed to be fixed at the time that the contract is loaded into the blockchain system, either through a transaction or through another piece of code. For example, we have the subcontainer codes that are put in there to support things like pool creation and uniswap. And you can bring in code via the transaction, via create four. You can bring in the code there in a separate container. What we don't want to have to support is the code that can enter transient storage, frame memory storage, or planal contract storage, then becoming bytecode in the system.
00:23:09.902 - 00:23:42.214, Speaker B: So that's, I think, the barrier that we want to make sure it doesn't get crossed, so that when other systems change how the code is represented, they don't then have to put in a cross compiler. In their execution environments for these codes, they can compile the code, they can put the blocks at the transaction entry points, and they can do whatever work they need to do there, and not necessarily at the runtime of the EVM, of however they're executing EVM and what's representing the runtime of the EVM so.
00:23:42.252 - 00:23:54.170, Speaker D: If I'm understanding correctly, basically we don't want to be generating code at runtime and deploying contracts from there, or running code that is dynamically generated.
00:23:55.310 - 00:24:19.170, Speaker B: Correct data is fine. That's much more easier to manage and inconceptualize and to deploy contracts and append data at the end. That's actually kind of necessary for some modern uses of the EVM. But as far as generating code at runtime, we want to get the bytecode out of all processing streams that are run during execution time. That is not actually being executed.
00:24:22.400 - 00:24:27.870, Speaker D: Okay, I think I have to jump off right now.
00:24:31.760 - 00:25:06.010, Speaker G: So I have a follow up question about that, which would be, so just to recap, as a very sort of simple example, it would be like, I have some contract, it has some bytecode in it I call xcode copy. And I would potentially take the bytecode that's there and then execute that within a new contract. And that's the behavior that you want to ban, is that correct?
00:25:08.060 - 00:25:33.200, Speaker B: Basically, if you're taking the data loading into a memory stream, changing the memory or creating it, rather than a simple copy from another contract. So yeah, we don't want to have, like, if you want to create a contract that responds to two different calls and you have logic that basically compiles it within the EVM and creates the code within the EVM and then deploys it, that's the sort of changes we don't want to have to support. Basically jitting.
00:25:36.020 - 00:25:36.770, Speaker A: Okay.
00:25:39.890 - 00:25:58.200, Speaker B: But a common thing that we have to support is to take an existing contract and put in the data segment hard coded constants, like saying my pool trades this token and this token hard code. Those as data in the contract, steal that data and put that out there. That's something we have to support, and I think something that the current spec does support.
00:26:10.280 - 00:26:54.340, Speaker G: Okay, so it's just like general, like, hey, here's some data that's non code segment related. Yeah, can we copy that from somewhere? And then you can do something with it. But anything that would be sort of like an opcode or something that you need to execute, you just wouldn't support that. And it doesn't make sense to have just a general hey, don't do this because it's not supported type of thing. Don't hard code gas numbers into your smart contract. It's better left as not a convention, but a hard restriction.
00:26:55.560 - 00:27:21.390, Speaker B: Right. And that's the point of the call two series is that you can't limit gas, which is how a lot of these contracts got wedged is they'd specify a small number of gas, we'd increase the cost of storage and those contracts will be broken forever until we did EIP 29 29 and 29 30. We don't want to have to do that again. So if we change the gas schedule, the solution is, and should always be send more gas and things will start working again.
00:27:26.210 - 00:28:09.260, Speaker G: Right. But the contracts, I guess it's just because they were not following conventions. So the approach here is exactly a little bit more strict. And to say like hey look, we're just going to lock this down, so now you just can't do it. And I guess the thing that you probably would need to understand more of the use cases would be to see some of these minimal proxies. I think a lot of people use a pattern with EIP 1167 and they're using Xcode copy in that context, which it seems like maybe create three would do the right thing.
00:28:10.910 - 00:28:32.770, Speaker B: Yeah, you would have an encapsulated contract that you could then send, you wouldn't xcode copy it, you would do your encapsulated contract, you would put in what you're proxying to in it and then you would submit that and the contract would reference its data section to do its jump. And because it's encapsulated in the contract, it can never change. So you get the immutable proxy.
00:28:37.530 - 00:28:39.400, Speaker G: Cool, thanks.
00:28:47.580 - 00:29:07.150, Speaker A: Any other questions? Comments on the spec? Any testing related updates?
00:29:11.090 - 00:29:14.580, Speaker H: Yeah, I have been working on. Can you hear me?
00:29:15.930 - 00:29:17.080, Speaker A: Yeah, I hear you.
00:29:17.530 - 00:29:48.800, Speaker H: Yeah, I've been working on updating the test cases according to the mega spec according to this specification. And yeah, there is currently a work in progress pull request in the Ethereum test repo which contain these changes. The test has already been changed to the Prague hard fork and also.
00:29:50.610 - 00:29:50.974, Speaker G: It.
00:29:51.012 - 00:30:11.640, Speaker H: Is also using the new proposed opcode and I'm currently working on changing the tests to also support the containers sections. This is what I'm currently working on right now. So yeah, that's it for me.
00:30:12.330 - 00:30:33.900, Speaker A: Awesome, thanks. Any other testing comments, updates? Yeah alex.
00:30:36.480 - 00:31:08.730, Speaker I: Yeah, I had just commented earlier discussion regarding the code size stack verification, so solidity. Initially when Daniel was implementing it, he ran into some similar problems, but then he actually figured out a way to use the code sections which were efficient enough. And in the end, at least on the test feed the compiler has.
00:31:10.860 - 00:31:11.224, Speaker D: He.
00:31:11.262 - 00:32:01.716, Speaker I: Noticed savings in many cases and at the time at least there weren't outliers in sense of generating much larger code. We did discuss a number of other features which I think we agreed to have in the stack and I think lately they have been added, but they may not have been implemented fully. One of the important ones was the non returning functions where stack validation isn't. You don't need to validate the number of return items. This feature was at least the source of most of the problems in solidity because it has the error paths. They just ended like revert. And with this in place, all of that can be deduplicated.
00:32:01.716 - 00:32:36.980, Speaker I: So I'm not sure, you know, what are the cases in Viper, but it may be interesting to have a discussion together with solidity, just to figure out which are the real problems of bugs and which maybe require some better understanding. And then lastly, we did have a number of other feature discussions, including tail jumps. I don't remember what was the conclusion of those, but we can probably take up the comments from around January.
00:32:47.260 - 00:33:47.780, Speaker A: I think we lost Charles, but okay, yeah, they'll probably figure those things out as well at some point. Anything else people have on the agenda? They wanted to discuss it. Okay, I guess in that case, let's end it a little bit early. We'll have the next call again in two weeks. In the meantime, hopefully Charles will post his comments that he had on discord or bump them on discord, and we can just take a look at that offline. Thanks a lot everyone. See you again in a few weeks.
00:33:47.780 - 00:33:51.426, Speaker A: Thank you.
00:33:51.608 - 00:33:52.654, Speaker D: Thank you. Bye.
