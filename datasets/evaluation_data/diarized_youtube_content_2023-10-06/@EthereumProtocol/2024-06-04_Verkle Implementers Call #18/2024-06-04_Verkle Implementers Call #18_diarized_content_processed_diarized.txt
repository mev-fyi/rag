00:00:06.800 - 00:00:39.364, Speaker A: All right, let's get started. This is vertical implementers, call number 18. This is PM issue 1027 in the PM repo. Okay, let's start off with any client team updates. Would anyone like to start things off? Can I nominate you?
00:00:39.864 - 00:01:23.944, Speaker B: Sure you can, yeah. We've been busy in the past month. Was it months, a month and a half maybe? We have been. We're reworking the guest schedule, especially with the interrupt, but before and after that as well, there's been a revamping, especially at the interop of 29, 35. So the vertical, the vertical, everything that is that concerns vertical hasn't changed, but there's been a lot of nitpicks, so for whatever gets activated at Prague. So there's a new EIP. I hope Gabrielle is here to talk about it.
00:01:26.274 - 00:01:27.054, Speaker C: Cool.
00:01:29.114 - 00:02:10.334, Speaker B: And otherwise? Yeah. A lot of effort has been made into the testing. So Ignacio has worked on test vectors, I have worked on testing the conversion. So with the testing team we have some working prototypes where we need to merge all those branches. And there's a couple bugs that I was investigating. I hope someone from testing is going to show up because I have a couple questions. And otherwise, what am I forgetting? Oh, there's been a couple specs update that we're asked, for example, the state route, so I'll cover that briefly.
00:02:10.334 - 00:02:42.344, Speaker B: Afterwards. We want to add the state route to the, to the proof and I think. Oh, yeah, the conversion. So we finally managed to have some, all the data we needed to perform a conversion at a very, at a much more recent height. So it actually finished a couple minutes ago. So it took about 16 days worth of blocks to process. So that would add two point.
00:02:42.344 - 00:03:21.530, Speaker B: Yeah, 2.7 days to a full sync, like extra. That's actually much better than I feared so far, at least in terms of will sink. The bad news is that, yeah, it already took roughly two. Sorry, 16 days worth of blocks. So that means the transition will already take 16 days, assuming it's using ten k, like it transferred 10,000 leaves per block. So we could improve that by raising the number of leaves.
00:03:21.530 - 00:03:59.754, Speaker B: But it's not something I'm comfortable doing at this point. So that means that the more we delay verkle, as expected, the longer this conversion is going to last. So we'll have to see how that evolves over the course of the next year. But, yeah, that part is not as a bit more worrisome than I expected. It's not the end of the world, but it shows that the state is growing faster than my initial estimate. Yeah, pretty much all for me. Ignacio, do you have anything else to add?
00:04:03.574 - 00:04:54.424, Speaker D: No, just to repeat, I work I have. Well I can speak more about this in the testing section, but yeah, work on the testing vectors for 6847 62. Oh we also did an implementation of the epsilon proposal of called chunking and I tested with some test vectors that Powell gave me and everything seemed too much. So if anyone is interested in a go implementation of that, we have it already to experiment. Maybe in the near future. Just some extra bug fixing get for the replay that now is working as guillo mention, but nothing else for me.
00:05:06.244 - 00:05:54.804, Speaker E: I can talk for bezel. So we did some optimization in the bezel side during the interop so we can import block much faster. We had different issues that we fixed recently. We also implemented the proof verification using so we are using this library for verifying the different proof. I did some test in the current devnet. For the moment it's working fine. Gary, I don't know if you want to add some information but you want to start to work on the migration and also on the snap implementation for Verkel.
00:05:54.804 - 00:06:30.924, Speaker E: And we also started to work recently on the new gas cost modification. So I started today to look at this park as this part and started to modify bezel in order to match the new specification. And we also have one guys that will start to work on proof generation like that we will be able to generate new block but we just started to work on this part so no big news for the moment.
00:06:38.864 - 00:07:19.154, Speaker F: I think I'll go next on nethermine. So regarding sync updates from before interop, like we are now able to sync cost in using vocal sync but since costing is a small network we can like only we only were able to test the ranges phase. So after interop and still yet to test the healing but we like I streamlined like how healing works in nethermines. It's much faster now but still not tested on Costin. We found a bug in Nethermind and you still need to debug and fix that. Except for that we implemented the most recent gas cost changes, though it's not finalized. But whatever is finalized we implemented.
00:07:19.154 - 00:07:47.194, Speaker F: And except for that we also started working on using rust worker for some operations. So now proof verification and creation is comparatively much faster than before. We're also planning to switch to using the uncompressed version of bandwagon for serializing and decentralizing nodes and yeah, that's it.
00:07:53.014 - 00:08:28.554, Speaker G: All right, I can go with Ethereum J's. So aside from the progress that was made at the interruption. We have made some. We have an outstanding pr that implements all the gas changes from voice 762, including, you know, the basic leaf data and all those related changes. We haven't merged it in, we're just waiting on casting m seven for testing and then we're going to make that our merge that to our main branch. Aside from. Yeah, that's pretty much it on our side.
00:08:28.554 - 00:08:40.424, Speaker G: We've also begun a vertical try implementation that's not really relevant for syncing or Testnet, so I can leave that out. But we have begun some work on there.
00:08:57.544 - 00:08:58.096, Speaker B: Cool.
00:08:58.200 - 00:08:59.884, Speaker A: Any other client team updates?
00:09:02.784 - 00:09:49.364, Speaker B: So for ergonom I was able to update the gas cost in an outstanding pr, but of course we're not syncing yet, we're not busy in other things. I was able to regenerate the images files with a slightly different approach and I created a description of it in pack and the total size is now 28gb instead of 40. I'll just put a link to the short description on this chat and perhaps an element. That's it from everyone.
00:10:05.104 - 00:10:13.684, Speaker A: Cool. If no one else, we can move on. Next up we have testing updates. Anyone from the testing side?
00:10:15.884 - 00:11:00.274, Speaker H: Hello, I'm here, but I'm not the main person working on Berkel at the moment. That's Spencer, but he is out of the office. But yeah, during the interrupt, as far as I know, the testing filling process is finally working. For Berkel, there were a lot of things fixed between the transition tool and the testing filling process that we have. I think one of the main issues is that we weren't able to communicate correctly the data objects that we were passing between the filler and the transition tool. And that is now partially fixed. And we were able to fill some of the tests, not all of them, but some of the tests during the interrupt.
00:11:00.274 - 00:11:27.924, Speaker H: Also another thing that was accomplished was the hive instance, that is specifically Verkle is now working and we got it working during the interrupt. Also the rest of the tests I think we are in the process of converting and also making sure that they work. But I think there's no other important developments during last week.
00:11:28.344 - 00:12:21.022, Speaker B: Yeah, actually there was one. So yeah, there was a bug fix because a lot of tests were not passing. Like a lot of tests that got translated, that was due to some remnants of an old conversion problem. So a conversion PR that got merged and yeah, there were two variables that did the same thing, so they were not behaving exactly the same. So now I deleted that variable, but there are still like ten tests that are not passing and I was able to, well, I debugged one. So there seems to be an issue that pre images are not cached. And then the last, the other problem seems to have to do with the way the conversion is running.
00:12:21.022 - 00:12:31.874, Speaker B: So I still have to run in. Like I still have to debug this one. Just FYI. I thought I had a question, but actually I just found the problem. So, yeah, no more question on my side.
00:12:35.674 - 00:13:16.354, Speaker H: Yeah, another small update I think is that we're preparing like prereleases on the, on the execution spec tests repository. So how. So the way that this should work is that we only have a prototype for UF. So now we are going to be able to tag releases with only UF changes and only vertical changes. Vertical is still a work in progress and we can probably do it in a couple next weeks. But the approach is going to be that all the client teams that are working specifically on a branch that works on vertical should be able to go into the releases page and get the.
00:13:16.394 - 00:13:16.974, Speaker B: Last.
00:13:18.914 - 00:13:28.114, Speaker H: Vertical focused test release from the repository. But we will keep you updated. This is not finished yet.
00:13:32.854 - 00:13:42.834, Speaker D: I just wanted to add that the work that I'm doing for all the rest of the test vectors can be found in this branch that I will share.
00:13:59.754 - 00:14:14.762, Speaker A: Awesome. If nothing else on the testing side can move on. Next up, Guillaume, you had a pr that you put up for adding the state root of the parent block into the proof. Do you want just to flag that real quick?
00:14:14.938 - 00:14:27.374, Speaker B: Yeah, it's very quick. Let me just share my screen. Assuming the right screen. Yes, sorry, right window. Sorry.
00:14:28.794 - 00:14:29.106, Speaker C: Yeah.
00:14:29.130 - 00:14:42.586, Speaker B: Okay. I'm not sure I get a weird message. Whatever. Yeah. So it's a very simple change, right? I will in fact copy it. Right. Copy the link right here.
00:14:42.586 - 00:15:49.164, Speaker B: But it's coming from a request by Ethereum J's that they wanted to verify it. So they implemented, like Gabrielle said, they implemented verification as well, proof verification, I mean, not just block execution. And what happens is that they discovered that they need the state root of the parent block inside the proof. Otherwise they would need to also get the previous block, which is a bit silly, just for 32 bytes. So we just, like this, there's an update, there's a proposal update, an update proposal against the consensus spec repository that just adds this, just as this field, to the execution witness. Yeah. So feel free to comment, but I assume, or I expect it to be implemented for the relaunch of Devnet seven.
00:15:49.164 - 00:16:20.514, Speaker B: So that means there's a tiny bit of work expected from the, from the CL devs I don't think any of them are here today, but I can. Yeah, I can chase them. So it's only. Nevermind. Sorry, it's only load star. Oh, right, there's, there's a load star dev in the chat, but otherwise it's lighthouse and Taeku currently who support. Who support this testnet.
00:16:20.514 - 00:16:38.414, Speaker B: So I guess if Gajender, I mean, can give us some feedback and then I'll hone down. Matt, sorry Mac and I don't know, do we have any contact at Taeku? I guess I'll just ask Paul Harris.
00:16:43.054 - 00:17:22.553, Speaker I: I think it should be pretty easy to add, but game. I think we earlier talked about sort of having the witness as opaque bytes for the Cl. Maybe we should think about that so that basically CL client doesn't use it at all. So having CL client to basically write a type and sort of pass it while passing it around from CL to El or from El to CL, I think that is unnecessary. But I mean, it's not really that important, but maybe we can treat it as a pick bytes at some point.
00:17:24.413 - 00:17:46.014, Speaker B: There was a lot of echoes. I didn't quite understand what you said. Sorry. Could you, could you repeat a bit slower maybe? Okay. Must be gone. Chanish.
00:17:48.074 - 00:18:19.994, Speaker F: I think what Galinde was saying that we had a discussion that like, instead of using a JSON object for proof, we can just use some like bytes so that like Cl doesn't have to encode and decode while sending and receiving it from the El. And like, I think the final conclusion for that discussion was that like right now it's easier for debugging to like print, just print the JSON. But eventually we are planning to like move to opaque bytes. I'm not sure if that's what we concluded last time, but yeah, that's what I remember.
00:18:20.774 - 00:18:54.714, Speaker B: So the proof. The proof part could be moved to opaque. This is what we talked about. Indeed, in Kenya, the proof part should be opaque. Currently it's quite useful to debug, so I don't want to do this if I can prevent it. But yeah, like the stamps and everything like this, I mean, we could make them opaque as well, but it's so useful to debug at the moment that I would say the cryptographic part. I don't really care anymore.
00:18:54.714 - 00:19:15.754, Speaker B: We have libraries that work. I mean, not everybody implemented proof, so it might be worth just keeping it this way a tad longer. But currently, currently I think it's a good idea to leave everything in the clear, even if the proofs are larger, because it's really, really useful to debug.
00:19:33.354 - 00:19:36.894, Speaker A: Cool. Anything else on that topic? Ion?
00:19:37.634 - 00:19:55.404, Speaker B: No. Yeah, I think that's a good. That's good feedback. We need to think about this, but yeah, currently, let's just build one testnet with this format and see if we find any problems. Don't expect any, but yeah, it will be. It will be quite useful.
00:19:57.744 - 00:20:11.524, Speaker A: Sounds good. Next up, there is a potential issue caused by the removal of empty accounts from state. The interaction of that with EIP 7702. Gas. Guillaume, did you want to.
00:20:13.064 - 00:20:28.844, Speaker B: Right. So no presentation for that, but yeah. So the idea is that until now. So there was this EIP. I forgot the number. I think it's 6710 or something like that. Or 7410 something.
00:20:28.844 - 00:21:09.324, Speaker B: It's about deletion. So it's about collisions. If you find yourself creating a contract at the place where an account exists already, and this account already has storage, then you need to delete the storage. This is what the IP said. If I remember correctly, the problem comes with Verkle. Because to check if an account and EOA has storage, you simply need to check the state route. But that state root disappears with verkle.
00:21:09.324 - 00:22:39.840, Speaker B: So there are several. So until now, this is not a problem because we don't really have any way that a new account that would be empty could have storage. Right? But now, because of 7702, you could actually create a contract, or you could create an EOA that has zero nonce sum balance that you could transfer during the execution of that 7702 transaction. So because you delete this, because you transfer the content of the balance, then the account effectively becomes empty and so it should be deleted. Now the question is, how do you delete a vertical contract? There's a reason why we deactivated self destruct. I mean, there's many reasons, but one of them is because deleting an account in a vertical context is an account with storage in a vertical context is impossible. And now with 7702, there's a new corner case in which an account could be marked for deletion because of EIP 158, but at the same time cannot completely be deleted.
00:22:39.840 - 00:23:58.916, Speaker B: Because if it has storage, then we don't know where that storage is. There's no storage route. There's no indication, really. I mean, even if there was an indication that an account has storage, you still have to find that storage. So I had a couple conversations with people from the guest team and we came to the conclusion that either you completely disable storage in 7702, or I think those two things are independent and both should be done in any way we should just get rid of EIP 158, at least make it more like the self destruct in 6780, namely that if a contract, if an account gets created during a transaction and then automatically gets deleted or becomes empty, then 158 should still apply, but if it's already present in the state, then it should not be deleted. So exactly like self destruct, it's basically matching EIP 158, the behavior of EIP 158 to self destruct. And.
00:23:58.916 - 00:24:14.544, Speaker B: Yeah, so this is basically what we, the guest teams think is the best idea, the best approach. I wanted to know if there were questions, pushback, counter proposals.
00:24:20.024 - 00:25:19.144, Speaker F: I have, I had one question regarding the second part where like, I think it's the behavior right now as well, that like if there is something, the account is created in one transaction and if it's empty by the end of the transaction, then we delete the account. But I remember we had a discussion during interrupt, like related to storage, that if we set a storage value and then we like set it to zero again, and we used to delete it in the current testnet, but we decided that if someone is paying the cost to fill the storage value, the chunk fill cost, so we should not delete it because then the user will have to pay the cost again. So wouldn't the same discussion also apply to accounts? Like if in a transaction someone creates account, that means they are paying the fill cost for the account. And if you delete it at the end of the transaction and the new transaction, someone pays with that same account again and they have to pay the cost again.
00:25:20.244 - 00:25:20.628, Speaker C: So.
00:25:20.676 - 00:25:23.264, Speaker F: Yeah, just question around that.
00:25:24.084 - 00:26:13.554, Speaker B: Right, that's a good point. Well, you are not increasing the state, the size of the state. So yeah, you should not ideally pay the fill cost, but there's no way we know beforehand that it's going to be deleted at the same time. Yeah, it's if the contract is deleted or the account is deleted and then someone recreates it doing the same thing, it makes sense they should pay the fill cost, right? So my guess is I'm trying to remember, what did we say again? Sorry to ask you to repeat, but what did we say back then? That if you pay the fill cost, then the thing should be created after all.
00:26:14.254 - 00:26:28.574, Speaker F: Yes. So for storage we, I don't know why, but we didn't discuss this for accounts, but for storage, what we decided is like if someone paid the cost once, then just add it to the state, don't delete it even if it's zero at the end of the transaction, right?
00:26:28.614 - 00:26:40.364, Speaker B: That's fair. Which would correspond, actually, to a complete deletion of. Sorry. A complete deactivation of 158. Yeah. Daniel, you want to say something?
00:26:41.664 - 00:27:07.184, Speaker C: If they pay it and having them store it, that's got echoes of the broken meter attack, of the Shanghai attacks. And I don't think it's a bad thing to charge them for the account creation if the account never gets persisted because they clear it out. I don't think we want to encourage such transient account uses and to create code to support special cases I think would unnecessarily make the code more complex. So I don't think we should encourage this pattern.
00:27:08.684 - 00:27:22.264, Speaker B: But if I understand you correctly, that means that we would not be creating this account. And then. Oh, yes, someone would keep paying. Is that what you say? Like, if people start. Right? Yeah. Okay.
00:27:22.724 - 00:27:37.744, Speaker C: Keep paying is fine. Because if. If we let them persist useless accounts, that's gonna. That has echoes of the broken meter attack. It may not be an issue, but it's enough, directionally, that it concerns me.
00:27:38.524 - 00:27:48.076, Speaker B: Fair enough. Yeah, that's a good point, actually. So we would just go back on what we said at the interrupt, but that's. That's fine. If ten ish or anybody else is.
00:27:48.100 - 00:28:20.224, Speaker F: Okay, I think I'm okay with deleting the accounts, but I think we have other reasons to keep the storage. And, like, so we can, like, create both of those separately. Like, we can still not delete the storage. Like, if someone clears the storage at the end of the transaction, but we can delete the accounts. I think the argument was, I don't remember correctly what. Something related to when you do a re entrancing check, you set something and then you reset it. And if you do that every time, the check basically gets expensive.
00:28:22.364 - 00:29:06.044, Speaker B: I mean, if I remember correctly, the argument was that that would be unfair because you are not creating the account or the storage slot in that case. But then someone would come and pay the exact same cost when it was actually accessed, which, yes, it's not super fair, but like Dano said, it would. It would potentially be a make a future attack cheaper, kind of. I mean, at least it reminds us of the pattern. So I would. Yeah, I mean, I'm thinking it's a good idea to change. To change that.
00:29:06.044 - 00:29:19.374, Speaker B: Yeah. Just. I mean, we can also take this offline. I think that's. That's. There are both. I mean, there are good arguments on both sides.
00:29:19.374 - 00:29:22.654, Speaker B: I'm not sure I got your counter tennis. Really?
00:29:23.554 - 00:29:27.426, Speaker F: What I was saying is that we can take it offline. I think that would be better.
00:29:27.570 - 00:29:33.374, Speaker B: Proper decision. Okay, cool. Yeah, let's, let's take it out offline then.
00:29:42.914 - 00:29:45.242, Speaker A: Well, did somebody raise their hand or.
00:29:45.258 - 00:29:45.814, Speaker H: No.
00:29:48.354 - 00:30:05.474, Speaker A: All right, next up we had. Sorry, 1 second. Oh, yes. So there was a discussion during interop, or one of the discussions was around system contracts, whether they should be warm, and I think Guillaume wanted to possibly revisit this conversation here briefly.
00:30:05.974 - 00:31:02.984, Speaker B: Yeah. So I. When looking at how to implement this, I realized that, yeah, we would have to basically re initialize the access event list every time with every single account, and that makes a bit of a hard dependency between several modules in guests. So now I'm more or less of the opinion that we should not warm anything because it makes for simpler code. Basically, it can still be done, but it's going to be a bit ugly on guest slides. So that's definitely not an argument to impose a protocol change just because it's easier for guest. But I was wondering what would be the arguments against or for keeping it warm so that, yeah, maybe other clients have exactly the same issues.
00:31:02.984 - 00:31:16.524, Speaker B: Maybe there's a very good reason to keep it warm. I don't frankly see one. So I would like to change my mind, but I'm happy to stick back to the old behavior if there's a good reason for it.
00:31:19.304 - 00:31:39.464, Speaker C: For precompiles, you don't have to fetch the account, you know, looking at the account number, if it's a pre compile, and don't have to consult the tree, so you're not imposing any expense on querying it. That was the initial logic behind keeping precompiles warm. And the logic behind me keeping Coinbase warm was that you've already loaded the coinbase tree data into data just to begin the block.
00:31:41.204 - 00:32:02.464, Speaker B: So it's actually not quite true, right, that we, that we don't have to touch the state. Because if you, for example, you do a block hash, you do need to touch the state. You need to find out what the, what the block hash of the precompile is. If you check the balance, you have to do that too. It's not stored in the pre compile, at least. Yeah.
00:32:04.324 - 00:32:17.184, Speaker C: Right. When this was done, we didn't have the block hash, and all pre compiles were strictly calls. There was no balance stored in any block hash. It was relevant. So if you. I think that was loophole. If you check the balance of a precompile, but nobody can do anything with those balances.
00:32:19.244 - 00:32:32.372, Speaker B: No, I agree. No, I mean, now someone can do one thing, which is to have them needed in the witness, and so you need to add to the witness and therefore you need to pay the cost for it.
00:32:32.548 - 00:33:09.784, Speaker C: Right. The beacon chain and the block hash contracts are not packed into the first sets of contracts. So our client detects those free contracts just by counting the number zeros and seeing if it's less than a number. Once we get enough zeros, we don't have a list we consult, except for like Coinbase, which you have to put in at the beginning of the block. So for us, detecting a precompiler is just examining the number and seeing if it's one of the first. At this point, 32. I don't know how many smart contracts there are going to be, but one of the first, it was nine up until Cancun.
00:33:11.544 - 00:33:22.204, Speaker B: Yeah, yeah. I mean, yeah, indeed. That doesn't really. Yeah, that's, that's easy to check. But what do you do if you are asked for the block hash and the balance then?
00:33:22.744 - 00:33:28.164, Speaker C: So those are traditional pre compiled contracts, goes through different segment of code.
00:33:30.584 - 00:33:30.920, Speaker A: So.
00:33:30.952 - 00:34:15.414, Speaker C: And those are arguably system contracts because they keep state. You know, if you want to get talking about definitions of kinds of contracts, pre compiled just runs code. So if we were to change this, I would want to see if my proposal would be to keep all those prepile contracts in the first hex thousand blocks that don't keep state, keep those warm. But the other system contracts like beacon chain and blockhash, those are not party exemptions and those must be warned. So that's where we would put the distinction. And any contract that would keep state would not go in one of those special reserved addresses. It would have to be pre deployed like block cash and beacon chain.
00:34:17.474 - 00:34:36.536, Speaker B: So. Yeah, but, so your argument if, because I don't know, maybe it's my connection, but you dropped off a bit. You're, you're saying that. Okay, what is the argument exactly to keep the system contracts warm for the transaction from the system contracts, the pre.
00:34:36.560 - 00:35:10.214, Speaker C: Compiled contracts, I'm only wanting to keep the precompiled contracts that are below 1000 hex. Those don't access state. Those are just the swap in the code. There's already logic in there that we have to put in to see if it's like the EC recovery address. We already have to have logic in to special case and switch that because we're never accessing the account state to run those, those I would propose we keep as the pre warmed, the contracts, they're not in that reserved space like the beacon hash and the block hash. Those can be subject to the existing warming rules.
00:35:11.914 - 00:35:16.794, Speaker B: Okay. Warming rules being. Yeah. Okay. Pay to cold cost and then they're considered warm. Okay.
00:35:16.834 - 00:35:17.098, Speaker A: Yeah.
00:35:17.146 - 00:35:17.734, Speaker C: Right.
00:35:18.354 - 00:35:30.074, Speaker B: Okay. Now that makes sense. Yeah. Because otherwise, I mean, if we start treating every single. That was my argument. If we start treating every single system contract as a pre compile, might as well make them pre compile.
00:35:31.574 - 00:35:31.886, Speaker F: Yeah.
00:35:31.910 - 00:35:37.874, Speaker B: Okay. That makes sense. I thought I had a question, but I can't quite remember it now.
00:35:39.934 - 00:35:43.074, Speaker C: Right now, block hash and beacon root are not warmed.
00:35:43.814 - 00:35:56.368, Speaker B: Right. Right. So we would keep it this way. Right. The question was with the coinbase as well. The argument would be that it's currently being warmed or I think it's already.
00:35:56.416 - 00:35:59.404, Speaker C: Being loaded in a state by virtue of a block being processed.
00:36:00.304 - 00:36:03.808, Speaker B: But it's done. That's done at the end of the block.
00:36:03.976 - 00:36:06.312, Speaker C: Oh, it's the beginning of the block, is it?
00:36:06.368 - 00:36:08.496, Speaker B: Okay, well, the loading of it's done.
00:36:08.520 - 00:36:17.804, Speaker C: At the beginning of the block now. Because even if it's done at the end of the block, sometime during the block, the system is going to be responsible for loading and paying for the cost of the coinbase.
00:36:20.044 - 00:36:36.140, Speaker B: Okay. Yeah. Okay. I'll have to check the code in guess. But maybe, I mean, it's probably, it's probably true and. Okay, so that's what we would do then. We would warm the contract.
00:36:36.140 - 00:36:38.384, Speaker B: We would warm the system contract. Yeah, tenish.
00:36:39.524 - 00:36:58.304, Speaker F: But then, like, we have the same problem with Coinbase as with system contracts. Like we'll have to like add it to the access list every time for every transaction. So the argument that we have for system contract, not warming them up. The same argument kind of goes for Coinbase as well.
00:36:59.244 - 00:37:10.864, Speaker B: No, that's not quite true. I mean, it's. Yes, it's. It is indeed similar. But you don't have at least in. Yes, you don't have dependencies on other modules. Like the, like the.
00:37:10.864 - 00:37:35.684, Speaker B: The state. It's, you know what that coinbase is and it's just the address. You don't need to find out which of those storage slots need to be accessed and things like this. So it's less complex, let's say. So while I agree that, yeah, there's a lot of similarities, it's not completely the same. And complexity wise, I don't think it's as bad.
00:37:37.404 - 00:38:02.224, Speaker F: Okay, that makes sense. But again, like, from an outside perspective, like people who don't know code, like, from that perspective, it is because system contracts also gets executed before block processing. So technically the logic we have for Coinbase is like, it's already loaded in state. So technically system contracts are also loaded in state. So I'll say that let's keep same similar behavior for both Coinbase and system contracts.
00:38:02.984 - 00:38:07.512, Speaker B: Yeah, right. But if we want to, if we.
00:38:07.528 - 00:38:23.924, Speaker C: Want to not warm Coinbase, I'm fine with that. It's just we're going to get pushback because this was a request from some downstream users. So there's going to be some people trying to defend that decision because it really impacted their cost. So that's. I can go either way on this, but that's just what I'm worried about.
00:38:28.004 - 00:38:45.024, Speaker F: I'm not very like, specific that it should be like this, just that, like, I feel that they both kind of lie in the same category. But if there is, there is like reasonable, like, like if we want to basically warm the coinbase, I think it should not be that big of a problem.
00:38:47.604 - 00:38:52.224, Speaker C: I think it shares the same fate as warming block hash. So I think we put in the same bucket.
00:38:57.304 - 00:39:12.484, Speaker B: Okay, so, okay, so from what I understand, we agree to continue warming the block hash precompile as well, at least the one that got accessed during block initialization.
00:39:18.584 - 00:39:25.568, Speaker F: I understood that you're not warming system contracts. I'm not sure what's like.
00:39:25.656 - 00:39:26.256, Speaker C: Yeah.
00:39:26.400 - 00:39:32.084, Speaker F: Are we, are we like warming all the system contracts or are we not warming the system contracts?
00:39:32.704 - 00:39:37.404, Speaker B: Yeah, I mean, we can't warm it. All right. That's the, that's where the complexity comes from.
00:39:38.464 - 00:39:52.064, Speaker F: We have no, but like, either we warm all the system contracts or we don't warm any at all. Like, I don't like this where we just warm the block hash contract and we don't like warm, let's say, beacon block or any other system contact that we are using.
00:39:53.124 - 00:40:11.584, Speaker B: Yeah, no, I agree. Yeah. We definitely need to be consistent. I agree. Yeah. I'm just struggling to get reading on what you guys really are saying. Like, am I getting some pushback for not wanting to warm the system contracts or not? That's the part I'm not clear about.
00:40:13.784 - 00:40:25.624, Speaker F: I think the conclusion was that we are warming pre compiles. Coinbase was a dicey thing, but I think we agreed to warm and then we decided to not warm system contracts. That's what I understood.
00:40:25.784 - 00:40:30.044, Speaker B: That's also what I understood, but I was, it wasn't very clear. Gijinder.
00:40:32.584 - 00:40:33.392, Speaker C: Yep.
00:40:33.568 - 00:41:06.264, Speaker I: If you can hear it. So I think what we should do is that whatever state gets wrong gets accessed in system contracts. It should be kept as warm because anyway, we will be adding it to access witness. And most of our logic for having warm or not warm cost depends upon whether they are in the witness or not. So whatever gets added to witness gets, gets warmed up. If we just follow this simple process, I think we should be good.
00:41:09.384 - 00:41:29.520, Speaker F: But right now we, like have access witness per transaction and not per block. So I think the initial argument was that, like, if we keep system contracts warm, then we'll have to basically replicate that for every transaction. And that was the complexity part, as far as I understand. Because, like, for each transaction we have.
00:41:29.592 - 00:41:36.604, Speaker B: Yeah, sorry.
00:41:36.644 - 00:41:40.064, Speaker I: I think our access witness is sort of global.
00:41:42.884 - 00:41:56.304, Speaker F: We, we keep a global one when we create the execution witness. But while charging for gas, we don't have a global. We charge per transaction. Like if something gets accessed in both the transaction, they like, pay the access for separately.
00:41:58.304 - 00:42:11.804, Speaker I: I think that shouldn't be the case, because if, for example, we have something bombed in the state. But I'll check in Ethereum J's. But I think it is sort of global. And I'll recheck.
00:42:13.104 - 00:43:12.944, Speaker B: No, it's not global. At least that's not how it's packed. And the reason for this is because we don't want to have some. To promote some games where you just warm stuff, you know, let people like, pretty much create new MeV games where you just wait for someone to touch one location to be able to execute your transaction behind and create a lot of complexities this way. So this is why you have a prayer per transaction witness. The witness is global, yes, but the charging is done as if you started from a fresh witness every time. Okay, I think I heard the arguments I was looking for.
00:43:12.944 - 00:43:28.054, Speaker B: I'm going to mull it over. So thank you for your input, and we can take that offline or discuss it again in two weeks. I think it needs a bit more thinking. Yeah, cool. Thanks.
00:43:31.194 - 00:43:40.482, Speaker A: Cool. Okay, last up is Guillaume, actually, your pr for the gas cost updates. And there are some open questions on that pr that you wanted to discuss.
00:43:40.538 - 00:43:48.324, Speaker B: Guillaume, I'm trying to think. Was it the gas cost update?
00:43:48.784 - 00:44:00.984, Speaker A: Sorry, am I getting something wrong? I just dropped a link in the chat. Not sure if that's the pr that you mentioned. You wanted to go over here. If you have some open questions around that, maybe I'm getting something confused.
00:44:01.144 - 00:44:06.484, Speaker B: Yeah, absolutely. But wait, did we not have a 29 35 thing to do before?
00:44:07.744 - 00:44:19.124, Speaker A: No. So I chatted. Gabrielle, correct me if I'm wrong, but I don't think there's anything there to, to discuss on this call. Unless or anyone else correct me if I'm wrong on the 29 35 topic.
00:44:20.184 - 00:44:26.804, Speaker G: Yeah, I personally don't see anything additional. I'd like to discuss if maybe others have things to discuss.
00:44:33.784 - 00:45:08.722, Speaker B: Okay. Yeah, I mean, we can. I guess we can schedule this for next time then. Yeah, I mean, I had. So in that case, we've got this update to the 4762, which is basically everything that has been discussed during the. During the interrupt. There's been some questions left, so we should resolve them, but it might be a bit tedious for everybody who's not involved in this.
00:45:08.722 - 00:45:50.144, Speaker B: In this conversation. So given how little time is left in that call, I suggest we schedule maybe a breakout with the people who are really interested in it so that we can resolve all those questions. What I would like to know is if there are still some open questions about this whole EIP update. Did people want to give more pushback? Yeah. Otherwise, I don't know. We try to have a meeting maybe tomorrow with everybody involved. So I know that would be gender and Ignacio and presumably one person from each team.
00:45:50.144 - 00:46:14.524, Speaker B: I'm trying to look out, of course. And, yeah, I assume Besu will want to say a word as well. And. Yeah, that's. That's basically the question. I mean, I can go over, but it's going to get very, very tedious for most people. So if everybody wants to drop off except the interested parties, we can start right now.
00:46:14.524 - 00:46:34.516, Speaker B: But otherwise, yeah, we could also call it and have an offline. Well, offline, a later online meeting, maybe tomorrow. Did.
00:46:34.540 - 00:46:37.424, Speaker A: Mario, you have a quick question or you want to drop that in the chat?
00:46:38.084 - 00:46:42.904, Speaker H: Yeah, it's really quick, but it's completely unrelated from anything else. So is that okay?
00:46:43.444 - 00:46:44.164, Speaker B: Sure.
00:46:44.324 - 00:47:26.754, Speaker H: Yeah, of course. So this question is regarding the stride that we use to configure the tests. So it's got my attention that it seems like it's necessary for us to fill the tests with different values for the stride during the vertical conversion because there are some issues that have appeared with some configuration of the stride and some issues that have not appeared with a different configuration of the stride. So my question is whether the client teams support this stride being available either by being configurable in the genesis or somewhere else. Yeah, because we plan to fill the test with at least multiple configurations for the stride.
00:47:27.454 - 00:47:27.926, Speaker B: Yep.
00:47:27.990 - 00:47:29.394, Speaker H: Basically that's the question.
00:47:31.974 - 00:47:33.394, Speaker B: I mean, guess does.
00:47:35.614 - 00:47:38.554, Speaker H: How does geth configure that right now.
00:47:38.974 - 00:48:09.924, Speaker B: There'S a. I'm not sure. I think you can get it in the config, but yeah, I can. I can send you the config option if it exists in after this call. But for sure you can use the option like the command line, option override, dot overlay, stride. Maybe I should write it, but, yeah, you can specify it like this.
00:48:14.864 - 00:48:43.144, Speaker H: The idea is that we can generate the tests with a given value for the stripe, and then we can run them either when you. When you guys consume it, consume the tests as blockchain tests. And another. Another run would be on the. On the full instance of the client. So this should be configurable in those two parts. So blockchain tests consumer, consumer, and also just the full, full instantiated client.
00:48:43.144 - 00:48:47.312, Speaker H: We should be also to configure. Configure it there.
00:48:47.408 - 00:48:50.884, Speaker F: So, yeah, what do you mean by stripe?
00:48:52.144 - 00:48:55.964, Speaker H: The amount of leaves that are converted during the vertical conversion.
00:48:56.464 - 00:48:57.324, Speaker F: Okay.
00:49:09.444 - 00:49:17.764, Speaker H: So, yeah, that was all the question. I will try to dig a little bit more into this to see how we can proceed with this thing.
00:49:17.924 - 00:49:18.664, Speaker B: Thanks.
00:49:20.004 - 00:49:26.744, Speaker A: Cool. Thanks, Mario. Guillem, are you okay with if we do a separate call up to you and anyone else?
00:49:27.044 - 00:49:30.704, Speaker B: 02:00 p.m. uTC works for me. 04:00 p.m. yeah, that works for me.
00:49:33.384 - 00:49:43.484, Speaker A: We can, yeah, finalize the time, async, I guess, and, yeah, get that figured out. Okay, cool. Anything else in the last couple minutes before we break?
00:49:43.904 - 00:49:44.644, Speaker B: Once.
00:49:48.864 - 00:50:35.084, Speaker G: There were discussions about pre image distribution when we were at the interrupt, there's been, you know, different ideas thrown around. I don't see this as being resolved right now. There was also a proposal for me that we could consider also adding these, you know, just the pre image that have been converted on each block, inside of each block, so that at least people can sync and verify blocks, even if they can't propose blocks. I think that would be worth discussing. I'm not sure if you want to discuss this in this call or do a separate breakout call for it, but it seems to me, like, in the general Virgo fork topic, this is the main pain point at the moment, so it would be nice to make some progress on that.
00:50:36.384 - 00:50:46.004, Speaker A: Yeah, agreed. Maybe we can reshare your proposal in discord, see if we can get any comments on it async, and then schedule it for the next vik, if that's not too far away.
00:50:46.384 - 00:50:48.084, Speaker G: Yeah, that sounds good to me.
00:50:49.664 - 00:51:31.084, Speaker B: Yeah. So just to answer the point that, yes, it's urgent, but at the same time, there's been a few discussions during the interrupt that, you know, wanted to maybe use EIP four four, like, whatever comes out of the EIP 40 four's effort to do pre image distribution. So I would like. I mean, okay. The reason why it dropped off, dropped out of my mind was because of that, but, yeah, sure. It's a very interesting topic, and what you had is also a very interesting idea. I don't think it solved the problem entirely, because you still need to distribute free images to some people.
00:51:31.084 - 00:51:38.404, Speaker B: But, yeah, I think it should be discussed, so I'm happy to schedule it or have a breakout session next week.
00:51:40.344 - 00:51:44.044, Speaker G: Yeah, whatever people feel is most useful. I'm done.
00:51:47.784 - 00:52:12.874, Speaker A: Well, yeah, we'll get that figured out. Whether to separate call or on the next vic, the link in the chat here, and then I'll also share it in discord. I don't know if this is. This is just my kind of quick summary of your idea, Gabrielle. I don't know if you have a better document somewhere, but. Okay. Anything else, or should we end it there?
00:52:16.474 - 00:52:22.454, Speaker G: Yeah, that's the best document. I don't have anything better than what you've written, so. Yeah, thanks.
00:52:22.874 - 00:52:29.694, Speaker A: Okay, cool. Thanks, Gabriel. All right, well, then let's end it there. Thanks, guys. Thanks, everyone, for joining. Talk to you guys soon.
00:52:30.474 - 00:52:31.186, Speaker B: Thank you. Bye.
