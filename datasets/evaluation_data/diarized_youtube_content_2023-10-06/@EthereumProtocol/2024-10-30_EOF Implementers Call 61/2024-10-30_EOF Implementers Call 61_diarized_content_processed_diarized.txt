00:00:00.560 - 00:00:37.959, Speaker A: Good morning and welcome to UF implementers call number 61 on 30th of October 10th looks to be a little lighter. I think there's a conflicting call going on right now because Daylight savings time is really messing with everyone right now. America will be back with the rest of the world next week, so hopefully it won't be a problem next week going forward. Today's agenda, huh? That's last week's call. No, that's an old post of it. There we go. So we have Testing Update, Client Update, Compiler Update, Spec Update and others.
00:00:37.959 - 00:00:54.335, Speaker A: If you have anything else that's not on the agenda, please post it in the meeting chat. One thing before we get to the end, before we go through it, should we cancel the 13th call that is the week of DEVCON. Cancel it and just pick up after DEFCON.
00:00:57.355 - 00:01:01.379, Speaker B: That would be two weeks after DEFCON. Like we are not disturbing our schedule.
00:01:01.427 - 00:01:19.903, Speaker A: Okay, perfect. Right. Okay. So there's any objections to that, let me know. But I'll come back to the other meeting that we'll skip the meeting on the 13th. So let's start with Testing Update. Mario, you got anything? Just thumbs up.
00:01:19.959 - 00:01:41.435, Speaker C: Not, not really that much important. Ah, sorry. Thumbs up for was for the canceling of the call, but from testing I've been reviewing PRs for the execution specs. I'm a little bit behind still because I was out one week, but I'm getting back to it and I will probably pick it up today also to review and merge what it's possible to do.
00:01:42.455 - 00:02:23.005, Speaker A: Okay. Yep. As far as trying to get Osaka DevNet Zero out the door, the creation of Prog DevNet 4, I think it slowed everyone down. I've got, as I mentioned on the chat, I've got everyone's local stuff running against all the ESD tests in Osaka. The question is how many are based against what's going into Prague 3 and Prog Devnet 4. Let's see. I guess we'll do that in Client updates, but that's the issue.
00:02:23.005 - 00:02:27.345, Speaker A: There is to make sure that we're going against the correct prog backing. Osaka.
00:02:28.645 - 00:02:55.489, Speaker C: Yeah, yeah. From what I can tell, EVM1 is not in DevNet 4 state yet. But I think I, if I remember correctly, I filled with Bessu and I'm not, but, but still, I'm not sure I, I need to double check if that's DE for up to date because 4 is pretty new. So I, I, I'm, I'm, I'm sure there are going to be some discrepancies yeah, they were.
00:02:55.577 - 00:03:10.015, Speaker A: There were three last I checked. I don't know if they've done the 7742 changes. I think those are mostly orthogonal. I mean it's going to be critical for like a live network. But I think most of them are orthogonal to anything that the EVM can see.
00:03:11.955 - 00:03:13.055, Speaker C: Yes, definitely.
00:03:14.435 - 00:03:35.015, Speaker A: Except. Well, if you do get more than six blobs and you transition to seventh blob, there might be a test. We might want to see if seven blobs can get there, but that's. Yeah, we'll figure it out. So I guess we should move on to client updates. Ben, anything from nethermind?
00:03:37.435 - 00:03:44.055, Speaker D: No, all good as far as I'm aware, other than the tracing.
00:03:44.875 - 00:03:45.695, Speaker A: Okay.
00:03:46.235 - 00:03:49.935, Speaker D: The pricing tracing.
00:03:52.165 - 00:04:01.065, Speaker A: Okay. So your features EVM EOF is backed off of the current prog that nethermind is shipping.
00:04:03.365 - 00:04:08.505, Speaker D: It's not in Prague at the moment. Sorry. Yes, it's rebased on it at the moment.
00:04:09.245 - 00:04:15.185, Speaker A: Okay, so it's off of main. Great Dragon. How about ref and Rev?
00:04:17.325 - 00:04:40.035, Speaker E: There's one bug found by you basically for external delegate call. When it's pointing to the precompile, we would call precompile and that shouldn't happen. How to do that? I think Red added Osaka hard fork, so we should be ready to go.
00:04:40.735 - 00:04:47.341, Speaker A: Okay. I think like two or three clients got hit by the EXT delegate call on a pre compiler.
00:04:47.403 - 00:04:50.485, Speaker E: So yeah, that was really great find.
00:04:51.385 - 00:04:58.685, Speaker A: Yeah, someone from. I think it was a Powell that wrote that below or did. Was that a port over from Powell?
00:05:00.985 - 00:05:07.765, Speaker B: I did the one that. No, that mine was related to data load.
00:05:08.745 - 00:05:09.385, Speaker A: Okay.
00:05:09.505 - 00:05:30.685, Speaker B: If I recall correctly, I mean at least this was the test you pointed to. So it was just loading unaligned data from data storage. Like some pieces are from data storage, some were outside. But maybe I misunderstood.
00:05:31.425 - 00:05:51.245, Speaker A: Ok. Yeah, I think it was EXE code copy. But there's also another one where you do exe delegate called any of the precompiles and they're all supposed to fail because none of them are eof. That. That change went in a few weeks ago, that test. Okay, so nothing is that. So that's it for ref.
00:05:51.245 - 00:05:56.485, Speaker A: Yep. Okay, Powell, how about EVM1?
00:05:58.065 - 00:06:38.031, Speaker B: So we. We are in the. In the face of transitioning to Osaka. I mean to moving QF to Osaka. I think the change itself, it's not complicated, but this affects a lot of testing around it and yeah, so this is the issue that Mario mentioned. I think we can get it. We need to update some tooling as well to be able to handle some JSON that is related to Proc and maybe Osaka as well.
00:06:38.031 - 00:07:30.097, Speaker B: So that's what's like. It's ongoing work and we still don't have all the PROC eaps in. So I think when we test EOF in isolation, that's kind of okay. But as soon as we get to testing some interaction with other EAPs, I think we might be in trouble. So yeah, I think it would be good that other clients can also fill the tests if that's needed. And finally going back to test a bit, I migrated all of the execution tests from the old repo to executionstack test. I think there's one more request that is the review, but it should be the last one.
00:07:30.097 - 00:08:06.835, Speaker B: And so we can consider that there is no more any execution tests in Ethereum tests repo that are targeting eof. Actually there's actually no more execution tests that targets PRAC and anything above. So I think that's kind of a milestone in terms of clarity what the tests are. There are still plenty of validation tests, but they behave a bit statically. So I think they're easy to easier to manage if we need to.
00:08:10.415 - 00:08:14.431, Speaker A: Okay. And just for the notes, that was all of Ethereum tests that was migrated.
00:08:14.463 - 00:08:27.285, Speaker B: Over or all execution tests which are status. That's something that the actual execute code not only validate. That's what I mean by execution test. Yeah, state test is probably a better term.
00:08:32.745 - 00:08:34.205, Speaker A: Ben, you raised your hand.
00:08:35.145 - 00:08:45.365, Speaker D: Yeah, I'm testing out a question related to the readiness matrix. I'm not sure entirely what half of it is.
00:08:47.835 - 00:08:48.683, Speaker A: Okay.
00:08:48.859 - 00:08:52.535, Speaker D: I'm worried we're missing. Missing something. So we. We have the.
00:08:55.195 - 00:08:55.975, Speaker B: Yeah.
00:08:57.835 - 00:09:06.735, Speaker D: The further down the bottom half, the exported ones.
00:09:09.435 - 00:09:28.185, Speaker A: Yeah. So yeah, if you can download these and put them in basically your test directory, you need to extend your Ethereum tests again to accept a new source.
00:09:29.805 - 00:10:09.631, Speaker B: Yeah. So the archive that is called AVM1. No tests. I think the last one from the release, it's just a package JSON test that we generate from EVM1 that are originally internal test of EVM1 but we have tool that can just export them to JSON. So that's what is it. If you never actually use that. They should be similar to execution spectest archive.
00:10:09.631 - 00:10:50.515, Speaker B: But there might be some differences in terms of directory structure. I don't remember exactly. And there also might be some like false positives because not everything works very precisely. But if you want to test use this as a confirmation that everything works in this matrix. There are different versions, so just use the last one and you can skip the previous versions. They're still in the matches because some clients reported that they passed these. So we keep it there.
00:10:50.515 - 00:11:09.125, Speaker B: But I think it's enough to just use the version 0:13 and if you have some like failures but they've. They look suspicious to you, you can just report what's. What's wrong.
00:11:18.385 - 00:11:52.435, Speaker A: Yeah, no one's updated the matrix on this. I've run locally, I've run BE on one, get nethermind and Rev off of raw eest and right now they're all running clean. So I don't expect any surprises here. I haven't run aragon or Ethereum JS locally or EELs. I don't have scripts set up to run those easily. Yeah. Okay, I'll take the field for Basu.
00:11:52.435 - 00:12:37.645, Speaker A: And we are. We have Osaka in place and we're based off of whatever main is. So wherever Basu is on the prod 34 process, it's there and this is off the main line. Okay. Any other. I don't see any other clients on the call. Our compiler teams.
00:12:37.645 - 00:13:19.915, Speaker A: Okay. Any other updates on clients and testing that we should over. Over before we go to the next section? Okay, so I probably should have put return codes in the same category as hash code ext dev call because we went through that pretty well in the last meeting. And possibly the EOF create hashing. Do we have any updates on that? From EVM1? From an EVM1 from Epsilon.
00:13:22.935 - 00:13:57.017, Speaker B: Just a tiny bit. I think the main issue with this idea is that. Yeah, yeah, you can. You can create another INIT code context out of previous INIT code context. In other words, during INIT code execution you can invoke another create. Right. So it creates this nested.
00:13:57.017 - 00:14:48.305, Speaker B: Nested INIT code context. And I think in this scenario it's pretty unclear what is the address of the code. So we want to put the address of the code where the container is in this function that computes the final address of the created account. And it works for the basic you have create. But if you net these, it's good. It's getting messy because originally I thought I would put. I don't know actually the number of options what exactly put there, but none of them seems good.
00:14:48.305 - 00:15:59.385, Speaker B: We can the address of this current where the unit code is even if it's nested but. Or this can be the address of the. Of this INIT code, like the upper INIT code context because this contract will be created finally and the code will be deployed, but the deployed code will have some sub containers Possibly and there will be different sub containers that you actually referred to when you computed the address. So that's kind of like fake, fake derivation that you computed something that points you to some sub container, but it's actually not the subcontainer that was used. It's something that will deploy it later. And finally, if you consider create transaction. So this, this one, this is the hacky one that, that we introduced as a way to deploy contracts.
00:15:59.385 - 00:16:45.925, Speaker B: So when you start executing this transaction, you immediately create this init code context. And if you, if you have UF create in this context, it would point you to the. I don't know, to the sender of the transaction. But it has no code. So this address has no code. But the nested create address will be somehow related to this something fakey code that never existed. It seems to me it's kind of pretty difficult to define what to do with this field in this function.
00:16:45.925 - 00:17:35.515, Speaker B: So I guess, yeah, you can, you can put a flag. Maybe you should put like you can in this context you maybe you want to omit your address or like put null address there like O address this number of options. And I don't see this super. I guess it's not always possible to point you to the physical address where someone can look it up the sub container. So maybe it's to actually indicate that by omitting the code address somehow. So that's more or less the status when I stopped. So I think we need to handle this case somehow.
00:17:35.515 - 00:18:32.985, Speaker B: And yeah, I considered number of options but nothing is really settled. So something from omitting the address in some way, maybe actually hashing the sub container in this context when we cannot actually prove where it come from. But this means the cost of computing the address will be different into these two scenarios. And that seems also not great. So I don't know. But I think that's the main issue with this, with this idea that in this context we need to behave differently that we would do for like regular EOF created are coming from deployed contracts.
00:18:35.045 - 00:18:39.105, Speaker A: Okay Rangio, you have your hand raised.
00:18:41.045 - 00:19:06.915, Speaker F: Yeah, I just wanted to make sure I understand the issue is with regard to nested creates, right? Is that, is it that if you use the address of the code and the index of the subcontainer that could refer either to the code once deployed or the init code. Is that the ambiguity?
00:19:08.615 - 00:19:28.415, Speaker A: Well, an EOF could also. An EOF could have a nested EOF could have a nested EOH. They could use chain creates like you create a. You deploy uniswap and you also deploy the factory for the swap contracts. So the EOF could have any create can have New York create within it.
00:19:28.995 - 00:19:34.695, Speaker F: But that would change the address of the code in the nested levels, wouldn't it?
00:19:36.675 - 00:19:53.255, Speaker A: The physical address would be where the contract is at, where the root validated. If we do anything other than the topmost code, we're going to have to hash the inner codes, I think is the concern. And we're trying to get away from that.
00:19:53.955 - 00:19:56.055, Speaker F: Sorry, you have what? The inner what?
00:19:56.795 - 00:20:28.165, Speaker A: So we're trying to get some unique information about the address of the parents. So the rootmost container would have an address that we could use. And if we use the rootmost address and some path to the sub containers, then we don't have to hash the sub containers because you have some predictable address to create from it. However, if we don't use the root most container, the concern is we would have to hash each sub container to get a verifiable derivation of the address.
00:20:33.265 - 00:20:35.845, Speaker F: Yeah, there's a lot that I'm not understanding there.
00:20:36.755 - 00:20:37.371, Speaker A: Yeah.
00:20:37.483 - 00:20:41.139, Speaker F: So are you gonna be. I'm gonna ask her. Yeah, sorry, are you gonna be a devcon?
00:20:41.187 - 00:20:45.295, Speaker A: Is this something we should do like a. A corner on for EOF issues or.
00:20:46.155 - 00:20:48.015, Speaker F: Yeah, that would be great. I'll be there.
00:20:48.315 - 00:20:49.135, Speaker A: Okay.
00:20:51.155 - 00:21:29.145, Speaker F: And regarding the. The avoiding hashes, which I understand is a mainly about ZK roll ups 1 and 2 avoid catch is it. Is there an assumption that you need to hash the init container on every EOF create or what if it's cached like the. When the rootmost container is deployed, you can cache the hashes of all of the sub containers. Doesn't that, you know, reduce the overhead by just doing it once?
00:21:29.915 - 00:21:43.147, Speaker A: It could. And that's. Yeah, that's an implementation detail. The ZK systems could bring their hashes in. We still have to hash it when the opcode is called, when they bring in their salts. But we would want something that is ready just to add the salts.
00:21:43.291 - 00:21:43.667, Speaker F: Yeah.
00:21:43.731 - 00:22:00.425, Speaker A: So they'd have the pre images ready to go. You add the salt and then you run the hash one last time. And that's assuming the ZK systems don't just rip out Kachak and use some different, some different hashing algorithm, but everything is the same except for the hashing algorithm.
00:22:03.005 - 00:22:18.985, Speaker F: Okay. Because I tried to make the argument in the issue that I see some value in keeping the current scheme, but. Yeah, if it's a matter of cost, I understand that.
00:22:19.845 - 00:22:20.625, Speaker A: Yeah.
00:22:21.295 - 00:23:11.657, Speaker B: I mean like my main motivation was that it's somehow kind of awkward that you hash in it. You hash the sub container to get the address but the sub container cannot ever change. So you're kind of repeating hashing of like static data and every time you use that. So this seems like something is kind of misaligned in the design here that we. Yeah, we hashing something that we know that there will be the same hash every time but there's actually like not obvious place how to work around it like where to store the hash of it. I mean I think it would be different if we kind of address sub containers by hashes. Right.
00:23:11.657 - 00:23:34.065, Speaker B: That would be kind of more natural way that you address it's and then then. But that's also like has some issues and so that's. Yeah that's where it comes from in my mind. But I. I don't think it's like super super required. But I think we wanted to explore this. If we can make something that replaces hashing.
00:23:34.065 - 00:23:46.195, Speaker B: But it's also like difficult to describe all this like edge cases that we. We are finding.
00:23:47.215 - 00:23:49.715, Speaker F: If you can write down the edge case.
00:23:50.615 - 00:23:52.355, Speaker B: I don't know if it's the same one.
00:23:53.055 - 00:23:54.711, Speaker F: It's the same one that is written.
00:23:54.863 - 00:24:26.225, Speaker B: Yeah, I think it is but I think we can simplify. And I found a bit more new. Something new as well. So yeah, I will rewrite that and then I will like notify you that I think it requires a bit different description that is more readable because I think these were my just like quick notes for myself. And maybe there's a way to improve that description in a way that it's more clear what's going on.
00:24:27.325 - 00:24:39.115, Speaker F: Yeah, because I'd like to think about it. I feel like it can be solved. I mean and the only thing we need is just unambiguity. Right? Well, in the lack of clashes. I mean in the.
00:24:39.535 - 00:25:20.925, Speaker B: Yes. But I also thought that some way a proof that the address will come exactly from this code is something useful as well. Maybe it's the same. The same property. But yeah, even so one of the issues we have currently is that you can kind of fake with this nested creates so you can refer to the index of the sub container and later there will be index. There will be sub container with this index at the given address but it will react to different sub container because it was deployed later. And this.
00:25:20.925 - 00:26:36.779, Speaker B: Yeah, so I think this is something we also want to avoid. So you cannot fake it because that's seems like new security area that you need to think when you create a contract that can any external actor can actually collision? So the collision definitely we want to avoid. So nobody can claim the address by tricking your contract to do something that will actually deploy something dependent different and then you will not be able to deploy what you plan to do. Right. That's obviously something we want to avoid, but maybe that's not very important right now. But I remember that this like Create two scheme was kind of created with this in mind that you can, yeah, you can, yeah, you can predict what the address will be and you can also put some guarantees how the address, like what code would be used to create it. It's not like perfect because you can work around some things there, but at least that was something that I kind of keep in mind.
00:26:36.779 - 00:26:38.455, Speaker B: Maybe it's not relevant anymore.
00:26:41.275 - 00:27:01.855, Speaker A: Polyamorphic addresses and contracts were kind of a pain in the neck when it came to analysis. So the value of making sure that the actual code bytes go into forming the addresses, I see is very valuable. So. And I view that as a version of Create2's intent when they're able to do polymorphic code. So.
00:27:08.355 - 00:27:23.925, Speaker F: As a side note, what had also come up in the issue was regarding including or not the call data. What's the prevailing opinion there?
00:27:31.425 - 00:27:33.205, Speaker A: Including call data in the hash.
00:27:34.225 - 00:27:37.845, Speaker F: Yeah, I don't remember right now. I say called call data or INIT data.
00:27:38.905 - 00:27:43.339, Speaker B: I mean. Yeah, the INIT data that goes to the create instruction.
00:27:43.417 - 00:27:44.591, Speaker F: Yeah, the input.
00:27:44.743 - 00:27:46.155, Speaker B: Yeah, the input.
00:27:46.455 - 00:27:55.915, Speaker F: I mean, I don't, I don't think it, it should be included or weekly. I weekly feel that way. But it seems like some of you were considering that.
00:27:56.855 - 00:28:15.767, Speaker B: I think we did briefly and I can tell if, if that's good or not. I mean, I, I know what, what this can be used for. Right. It's. It's to also prove that you will use like specific arguments for this creation. Right. So that's.
00:28:15.951 - 00:28:22.275, Speaker A: Yeah, but it's, but that's easily defeated. Yeah, you can defeat violate in a.
00:28:24.455 - 00:29:14.805, Speaker B: Yeah, yeah, it doesn't, it doesn't like seal all the, all the possibilities, but maybe it's actually useful for someone who actually has something. So. Yeah, so it doesn't give you like full guarantees, but you can. By inspecting the code and combining this, I think you can improve situation. But maybe it's not written. But what I found is that users can do that by hashing the INIT code and combining this with the salt. So you can kind of create a scheme that you will be able to prove the INIT arguments as well.
00:29:14.805 - 00:29:20.825, Speaker B: You just need to kind of Code it yourself. Right. So you can.
00:29:20.865 - 00:29:21.401, Speaker F: Yeah.
00:29:21.553 - 00:29:58.379, Speaker B: Before invoking UF code, you can hash what you will pass to it and then combine it like sor. I don't know what is the best combination of hashes? Maybe it's just the salt. So there's a way to do that and you can always. You can't really. Yeah, but you can't really hash subcontainer because it's not readable. So yeah, I was thinking a bit about it, but I definitely don't have like very lot of experience with actually yeah. Working smart contracts on this level.
00:29:58.379 - 00:30:01.875, Speaker B: So definitely we welcome some feedback on this.
00:30:01.955 - 00:30:16.975, Speaker F: Yeah, my intuition is that what we have now is satisfies all requirements. Maybe it needs just a little bit more work than CAR evm, legacy evm. But it's sufficient to prove the inputs.
00:30:19.125 - 00:30:19.945, Speaker B: Okay.
00:30:23.125 - 00:31:03.515, Speaker A: All right. Put a time box on this since we're not at a resolution. So let's go ahead and move on to the next thing on the potential change list is modifying max stack map max stack height. I think the idea here was to change max stack height and a call F jump F section to not include the number of inputs to just be the additional stack required beyond inputs. Am I reading that right?
00:31:04.055 - 00:31:39.695, Speaker B: Yes, yes. Because what the runtime actually needs is subtraction of these two values. So it actually needs maxstack height as defined today minus the number of inputs to check if the calling a function will cause a stack overflow. Right. So what the runtime does, it actually reads these two values and subtracts them and then proceeds. So like to optimize the runtime a bit. And also.
00:31:39.695 - 00:32:26.643, Speaker B: Yeah, you can just define this like what is exactly the numbers in the header on in this type section in a way that you just need to read one value of instead of two. That's the main thing. But it also, I think it also removes some redundancy in the actual bits in the type header. Because if you think about it, the max stack height cannot be lower than number of inputs. Right. So you kind of keep these two values in two different places. I mean the number of inputs, it's from like.
00:32:26.643 - 00:32:53.767, Speaker B: I don't know if that's proper thing, but from like information theory it just puts these values in actually two slots because max stack height cannot ever go below this value. So yeah, so like if you consider what the ranges are of the possible values in the header, there's also like kind of redundancy. So you can argue that that's like better encoding as well. And that's.
00:32:53.791 - 00:33:02.535, Speaker A: It From a fuzzy perspective, that means that those two values aren't related. They can change independently. Which is I guess proves the information theory point.
00:33:03.795 - 00:33:18.775, Speaker B: Yeah, yeah, yeah, I bet. Yes as well. So. But I wouldn't put it so. So like. Yeah, so it's kind of minor thing but I think it's like the change is relatively simple. I'm not sure about.
00:33:18.775 - 00:33:36.935, Speaker B: Yeah. How much testing effort that needs to like. Yeah. Change this in the test. That might be difficult. If you have some like static test or like example tests, you will need to go in every such place and like change these numbers.
00:33:38.235 - 00:33:49.019, Speaker A: I think every place we specify max stack height, we would have to change it. It would break half the tests. But it might be worth the effort. You know, I think it's worth.
00:33:49.107 - 00:34:10.705, Speaker B: If we have time, I would do it. If we would ship like tof. Like next month, that's fine not to do it. But if we have find time slot that we can improve that. I think it's worth to do it. It's minor improvement, but yeah, it's kind of quality of life, I think.
00:34:16.285 - 00:34:17.705, Speaker A: Will we rename this field?
00:34:23.055 - 00:34:31.599, Speaker B: I think the. The issue. I remember someone proposed a name for it.
00:34:31.727 - 00:34:32.435, Speaker G: Max.
00:34:35.455 - 00:34:39.875, Speaker B: Yeah. Something. So there was. There was a name for it.
00:34:40.335 - 00:34:49.640, Speaker G: Yeah. I think we look at the time, we liked it because if we change.
00:34:49.672 - 00:34:52.804, Speaker A: The name it makes it easier to go to the code and update it. Mario.
00:34:54.304 - 00:34:54.656, Speaker B: Yeah.
00:34:54.680 - 00:35:24.005, Speaker C: So when you say that it's going to take a lot of rewriting and testing. Do you mean in the unit tests of the clients or do you mean in East? Both. Okay. Because I think in east there are a lot of instances where we automatically calculate this value. So in those cases I think it's going to be pretty easy just to take the input, just subtract and then just go ahead and change it. I don't know how easy it's going to be in the unit test for the clients.
00:35:26.625 - 00:35:32.005, Speaker A: Yeah. It's just an afternoon running tests until they stop breaking. I've done it before.
00:35:34.025 - 00:35:47.803, Speaker B: Yeah. It's not like the end of the world. I think it's just. It's. It's like slightly painful piece of this work that you need to. Yeah. But it's like kind of mechanical.
00:35:47.803 - 00:36:09.949, Speaker B: But it's not like you can add. You can always find some issues. Even like today. I think not today but like in the recent weeks we. Hugo came and like found some issues in one examples that were kind of had. Incorrect. Incorrect like binary representation and yeah, it's.
00:36:09.949 - 00:36:38.865, Speaker B: Sometimes it remains unnoticed until you actually look at it for Example because you either don't execute these or like the error is somewhere else and then like before you reach this point and then it's kind of has another error later. There's always something like that happens. But I think we've been through this already, so more or less know how much work it is.
00:36:42.925 - 00:36:45.665, Speaker A: But if we had to like Q3, this is worth doing.
00:36:53.965 - 00:37:37.225, Speaker B: Yeah. How. How I was thinking about it is that at least for my side, the first step is to get EOF in Osaka and update, test and update tooling and make sure everything works according to the current spec. And then I would pack all of these proposed changes into single shipment. So. Right, let's say like definite zero is without it, definite one is with. Yeah, the basket of changes and.
00:37:37.225 - 00:37:44.225, Speaker B: And then we ship at once because they are minor changes I think. Okay.
00:37:46.285 - 00:37:54.205, Speaker A: All right. And I think the next one falls in this bucket. Align uf, create stack to align with arc. Basically reordering stack arguments.
00:37:56.865 - 00:38:08.845, Speaker B: Yes, the same story. I think that's even easier because probably not so many tests. It's not like every test has. Has this instruction. Right. So it's.
00:38:11.985 - 00:38:18.535, Speaker G: I think it's easier to update in the clients as well. Sounds like it just swap two lines for even one, for example.
00:38:19.115 - 00:39:03.185, Speaker A: Yeah, well, each client is different because like I know geths got littered all over their code assumptions about certain stack heights when it comes to their calls and their creates. So if we could align those, it would be great for them as far as the depth. But as far as the XT call versus call, we're already breaking some of those stack height variations, so we'll see. But as far as tooling, to have them, you know, just look at the docs and have them in the same order would be huge. Any other comments on it?
00:39:06.285 - 00:39:21.775, Speaker F: I would say beyond tooling, it's also useful for developers who are maybe manually debugging, you know, to just reuse their existing knowledge and not having to like swap the elements in their their mind.
00:39:32.035 - 00:39:44.515, Speaker G: Also, this was brought up by someone on ifmag. A bit different context, but just that the order of the arguments is weird as the same.
00:39:46.295 - 00:40:48.815, Speaker A: Okay. I think the last change is even easier than all of these. Rename return contract to return code. Okay. Any other. So I think that was the last of the Quality of Life list that Quick one posted. Yeah.
00:40:50.915 - 00:41:15.595, Speaker F: So you mentioned ext code at the very beginning. I don't want to bring it up just to mention that I created an issue in this in the EOF repo. I just invite people to read it for when we discuss this. And the other one was EXT data copy. I imagine this is also for later, but I just want to get a feel for what the appetite is for that one.
00:41:21.735 - 00:41:50.025, Speaker A: Yeah, those have been mentioned before and I think those were mostly cut due to complexity arguments. So adding it is I think open discussion. Yeah, I'll mention one of the strongest arguments is why can't we just use S2? So that's going to be where the. A lot of the arguments can come from. But I think that's already mentioned in the bug report. If not, I'll add it.
00:41:52.935 - 00:42:26.955, Speaker B: So my imagined solution for this X data was that you can write a contract that just returns the data. And I planned. Yeah, but I forgot. I plan to actually write it and see how many instructions is. So I'll definitely try to do this as an example how you can get more or less the same behavior. But maybe, yeah, that's not enough. I don't know.
00:42:27.855 - 00:42:55.125, Speaker A: So the thought that crossed my mind the other night is what if we, using Nick's gadget created a standard set of all the opcodes of contracts that just do the opcode and return. They pull the values off of the args, they do the opcode and they return and we just figure out, you know, a standard set of addresses to put them at using Nick's public signature gadget. So I don't know.
00:42:56.225 - 00:43:26.585, Speaker B: So yeah, so the only differences which kind of starts to bother me is that the data will come to different memory. It will be in the return data buffer, not the memory. So if you need it in memory later you will need to copy it. So it's another copy. Yeah, I kind of feeling that's return data as a separate memory is kind of was the bad idea. But.
00:43:28.365 - 00:43:59.066, Speaker F: So I'm not sure I understand why is S store 2 seen as an alternative? Because in me, in my mind, so the point of EX data copy would be I have an address for a contract and I know that it has a certain piece of data that I want and so I want to use this to fetch it. So where does S Store 2 fit?
00:43:59.122 - 00:44:31.249, Speaker A: One of the things S Store 2 fits in right now without EXE data, nobody can copy the data of a contract without the contract allowing it to be ready. And that even goes for legacy codes too. So if a contract from its internal data wants return its data, it has to opt in and create an interface to send it. So by not having EXT data copy, we allow contracts to have a privacy provision. Now easily defeatable. You go outside the EVM go to your block explorer, read the data in there, you can get it. But within the EVM you can't go into other contracts.
00:44:31.249 - 00:45:18.761, Speaker A: So there is a bit of a data privacy argument and encapsulation argument there. And contracts that want to allow people to access their data can use the SS Store 2 interfaces to allow that, to allow their contract to be done. So the choice about ownership of data now belongs to the contract. But again, that's modulo leaving the EVM using a block explorer, reading the data and coming back to it, which is also presuming that these blockchains are fully public and fully, fully auditable on the outside. Ethereum's not Ethereum. Main Net is not going to be a situation where we're never going to make the blockchain fully public. So that's, you know, that's not something that we're too concerned about for mainnet use, you know, keeping the full privacy.
00:45:18.761 - 00:45:22.965, Speaker A: But that, that is one feature that I see right now that not having it keeps.
00:45:24.025 - 00:45:49.505, Speaker F: So, so SS Store 2. It. It's. We're just talking about like the interface. So it's like the read function, right? Oh, okay. Because for me, SSR2 is more about even writing too. It's just kind of a pattern to use legacy contracts as data contracts.
00:45:49.505 - 00:46:07.185, Speaker F: But anyway, the point is, can we. Yeah. So, okay, now the question for me would be, is that equivalent? Probably, yeah.
00:46:10.125 - 00:46:35.075, Speaker A: I mean, so yeah, it's not equivalent because when we require them to opt into sharing their data, then there's no equivalent to, you know, it's the default secret. And there is, you know, it's not even. There's. There's not even opt in secrecy when we have EXT data copy. But secrecy is probably a bad word because again, you use the Bakken score and just read it publicly.
00:46:36.215 - 00:46:43.395, Speaker F: Yeah, sorry, I meant is it equivalently good for the use cases that I've seen? That's what I wanted to think about.
00:46:49.865 - 00:47:05.577, Speaker G: Something to think ahead about. This is the behavior when xdata copy is the target is a legacy contract or a 7702 account. And also will it be allowed in legacy contracts?
00:47:05.761 - 00:47:06.485, Speaker B: Just.
00:47:12.515 - 00:47:16.215, Speaker G: So I guess a proposition would need to come with those questions answered.
00:47:32.075 - 00:47:35.535, Speaker A: Fault necessarily a good solution because that's. Yeah.
00:47:38.365 - 00:47:44.825, Speaker G: And also, do we have X data load for good measure?
00:47:56.565 - 00:48:00.317, Speaker A: Do we have EXT code load right now, though? We don't. It all goes to memory. Right?
00:48:00.461 - 00:48:02.865, Speaker G: Ext code load? No.
00:48:03.245 - 00:48:04.065, Speaker A: Okay.
00:48:06.045 - 00:48:08.065, Speaker G: That would be one argument for not having.
00:48:09.685 - 00:48:26.065, Speaker A: It's already expensive. Why make it cheaper? Okay. Anything else we should put on the wish list to think about over devcon.
00:48:32.055 - 00:49:38.661, Speaker F: Well, the one, the other one that's been on my mind is the delegate call to legacy thing I've kind of already made. So it's kind of tied to the EXT code discussion. Right. I think if we get EXT code hash so that a contract can predict whether the delegate call will fail, that's pretty good. That said to me it would still be just a little bit more ideal to get delegate like unrestricted delegate call. I understand the problem of self destruct and I agree the one, the thing that I wonder is, would it. What about something where if you trigger self destruct in the context of any of contract, it doesn't do anything or rather it behaves like the nerfed self destruct that we have in with those exceptions.
00:49:38.661 - 00:49:56.475, Speaker F: I don't know if you've already considered this. I understand that it adds some complexities like a different kind of static call context that the clients would need to handle. So it's not ideal, but it would be something that I, you know, might be interesting to consider.
00:50:00.415 - 00:50:08.475, Speaker A: Okay, but I think the first one where safety detecting a legacy is kind of a needed feature.
00:50:10.335 - 00:51:03.265, Speaker G: I mean we usually when they discuss it, we boil down to saying that this is rather easily workaroundable by having. Because the problems with the legacy with the update of the proxy target to legacy. Right. That it would be solvable on the smart contract layer that the proxy before, you know, it would revert if it could detect that it's not able to delegate call the new target and revert in that if detected. So there could be this fuse mechanism. So this, I mean this is different from the EXT code size and yeah, EXT code size case that this actually is workaroundable. Right.
00:51:05.295 - 00:51:05.607, Speaker A: Right.
00:51:05.631 - 00:51:14.595, Speaker F: So you're saying that there is a way to detect the future, the potential for failure without the need for EXT code. Right?
00:51:16.695 - 00:51:23.275, Speaker G: Yes. I mean it would be just like a trial delegate call to the new target.
00:51:24.535 - 00:51:26.991, Speaker F: Yeah, that's right. That seems to generally work.
00:51:27.103 - 00:51:37.615, Speaker G: So I mean the issue is like, I mean it is there, but it is of. I say it's less severe because it can be worked around on the, on the different layer.
00:51:43.675 - 00:51:44.455, Speaker F: Yes.
00:51:44.915 - 00:51:45.427, Speaker G: Okay.
00:51:45.491 - 00:51:45.747, Speaker A: Okay.
00:51:45.771 - 00:51:46.415, Speaker G: Okay.
00:51:59.005 - 00:52:32.875, Speaker A: So we got about three minutes left. I'm gonna, Once I get the. They say they're gonna have discussion corners. So I think we should probably try and set up a time to do a discussion. I'll coordinate on the discord at least to get people together and have a general open community you know, time to gather just for EOF, without an agenda, just to talk about EOs. So I'll try and get that corner set up at some point when I see the schedules. If anyone has any strong opinions as to what day and time it should be, please post those in the Discord or send them to me.
00:52:32.875 - 00:52:57.295, Speaker A: Yeah, so I'll it's getting time to do coordination for devcons. Maybe the next meeting's going to be a devcon meetup, so that's probably what we should aim for. Cool. Like to thank everyone for calling in. Any last comments before we close? All right, hope everyone has safe travels to devcon.
