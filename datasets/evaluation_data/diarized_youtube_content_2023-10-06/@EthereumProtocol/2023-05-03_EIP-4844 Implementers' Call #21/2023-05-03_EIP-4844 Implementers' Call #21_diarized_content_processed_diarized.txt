00:00:00.570 - 00:00:26.978, Speaker A: It. Sweet. Welcome to 4844, implementers, call number 21. Yeah, like I was saying, there's a bunch of spec stuff on the agenda today. And then after that we can chat a bit about Devnet five Quizu. I hope I'm getting their name right. You shared a little tool on the agenda.
00:00:26.978 - 00:01:26.400, Speaker A: That was pretty cool as well. And then if we have time at the end, I might want to talk about the readydest checklist a bit, especially in the context of all the conversations we saw in the discord about some stuff around libraries and just other tests we want to do to make sure that we're actually moving this to prod with all of the bases covered, I guess, to start, though. So on the last call, we discuss merging, get payloads v three and get blobs bundle v one. I don't know if we ever got a pr for this. The execution APIs. Is anyone aware of one? Okay, so it seems like. No, I guess I'm curious in terms of just the client implementations.
00:01:26.400 - 00:01:41.840, Speaker A: Okay, nice. Okay, we got it. It looks like it's merged. The one that both people. Yeah, okay, sweet. I missed that one. Thanks for sharing.
00:01:41.840 - 00:02:12.972, Speaker A: I. Okay, great. So we've merged those. We have the pr. Anything else on this? And I believe we had this as part of the Devnet five spec, if I'm not mistaken. Yeah. Okay, next up, then.
00:02:12.972 - 00:02:58.424, Speaker A: So on the last acde, last week, we discussed EIP 6475, which introduces the optionals SSD type. And then we agreed to move that EIP forward and make a couple of small changes to it to make it work with 4844 a bit better. And Ethan listed those in east magicians. I don't think Ethan is here today. I believe it's a holiday where he is. So he listed all of these changes. There's been a pr as well that was open against 4844.
00:02:58.424 - 00:03:38.740, Speaker A: This is actually quite an old pr, but that would need to be merged now, I guess. So assuming the changes that are listed there in Ethan's eat magician's comments get done to the EIP. So the sort of three bullet points he lists, and we go ahead with this pr 6495 on EIP 4844. Is there anything else that we'd have to do to kind of align 4844 with the optionals EIP?
00:03:46.050 - 00:03:50.814, Speaker B: I think that's the only optional. There's only one optional field in the blob transaction, so I think that's it.
00:03:50.932 - 00:03:51.600, Speaker A: Yeah.
00:03:55.010 - 00:04:06.660, Speaker B: I mean, there's other things we need to do, like around the hashtag root domain string. That's the other EIP, but I think you listed in the agenda already. So I assume we'll talk about that next.
00:04:07.110 - 00:04:19.960, Speaker A: Yes, that was the next thing. But I just want to make sure on the optionals we're good. All right. Do you want to make the case for getting rid of optional in four? Four, four.
00:04:21.850 - 00:04:57.010, Speaker C: Yeah, I mean, we talked about it a bit, and I think we talked about it specifically in Austria. And it's just one of these things that we add a new transaction type. We try to retain all of the previous behavior of the transactions. But in this case, this is such a specialized transaction. I don't know if having the ability to create transactions from the blob transaction is important. And I don't know if it's something that's making things harder. I wonder if it's even necessary.
00:05:02.640 - 00:05:06.388, Speaker A: Just to be clear. So you said create transactions from the blob transaction.
00:05:06.584 - 00:05:07.788, Speaker C: Create contracts.
00:05:07.884 - 00:05:09.410, Speaker A: Okay, got it. Yeah.
00:05:10.580 - 00:05:32.280, Speaker C: I don't think that it necessarily needs to have the create behavior. I mean, one might say that the create behavior that we have is not really ideal. I would probably make the argument that it would be nicer to have a transaction that is a create transaction, not the two address was nil or none, and therefore it is going to create a contract.
00:05:44.930 - 00:05:48.880, Speaker A: I'm curious if anyone else has opinions about that.
00:05:55.530 - 00:05:57.670, Speaker C: Sorry, go ahead. Alexey.
00:05:59.210 - 00:06:07.770, Speaker D: Yeah, just wanted to ask about difficulty, how it makes more difficult in what measure.
00:06:09.470 - 00:07:05.790, Speaker C: I mean, we're spending time trying to figure out how to serialize and merklize the optional value. I think that this is supported by libraries. I'm not really sure the exact state of the SSD libraries, but it's a one of these things that we're trying to specify and b, just additional code path that we have to support in the actual 4844 transaction. And it's just like another thing that we need to think of, and for a lot of reasons, and I'm forgetting all of them right now, I mean, if we think about what maybe the future for EOF is, we're going to have more specialized create transaction types. We already have create opcodes for creating transactions. There's a lot of ways of doing these things. It just seems like this is a good time to try and show a little bit of restraint and not have everything be fully compatible with previous transaction types.
00:07:05.790 - 00:07:50.250, Speaker C: I think the one argument I've heard against this is Eton's idea of having a normalized transaction. So if we end up having this normalized transaction type, then we kind of need to define optionals anyways. And basically the idea of the normalized transaction is that you have one format that represents all of the different transactions that are possible in the protocol. So if that's the route that we end up going down. Maybe it doesn't really make sense to drop it from 4844. But I think ultimately this is a very specialized transaction. And I marginally prefer dropping optional.
00:07:53.710 - 00:08:12.370, Speaker E: I more or less agree with light client in the sense that when we will actually implement normalized transactions, which is normal transactions is SSD format, basically we can enable at that time. I don't think four at four transaction as of now needs an optional tube.
00:08:15.030 - 00:08:23.062, Speaker B: But couldn't the current blob transaction become that normalized one? Right. If you just drop the one blob requirement and can represent everything.
00:08:23.116 - 00:08:23.720, Speaker A: Right.
00:08:29.130 - 00:09:01.170, Speaker C: I think the problem is with the mempools. We're building this very specialized transaction type around the idea of blobs. And the idea that blobs are going to know more challenging to propagate and share with. Like on a theoretical point, yes, that's probably the case. But I think based on what Peter has said in the past, and what it seems like the discussions have been that if we do want to have a normalized transaction. We are going to create some other transaction type. With a more clear discriminator that this is not a blob transaction.
00:09:11.720 - 00:09:26.328, Speaker A: I guess. Roberto. And know from base and optimism's perspective, are you fine with that? You're sort of the users of this, right?
00:09:26.494 - 00:09:49.664, Speaker B: I don't have a strong opinion. I like simplicity. So kind of narrowing it down is preferential in that respect. But it's hard to predict all use cases of this. So there's natural reluctance to start constraining things. But yeah. Not somewhat ambivalent about this, I guess, right? Yeah.
00:09:49.702 - 00:10:09.370, Speaker C: I mean, fortunately you do have the ability to still create contracts via the opcodes. Really, the only functionality you miss out on is if for some reason you have some piece of your design or architecture. That relies on creating contracts from eoas that you own the private key of. And I'm guessing that's just probably not the case for anyone.
00:10:14.630 - 00:10:35.334, Speaker B: Yeah, it seems like we go back and forth on this a bit about whether it should be more specialized versus general. I just like a decision to be made, I guess. Do you think there's anyone that's not on this call that might have a strong opinion about this?
00:10:35.372 - 00:10:46.490, Speaker A: Tim? So I think Matt and Ethan are the two people with the strongest opinions as far as I can tell.
00:10:46.640 - 00:10:51.840, Speaker C: Yeah, probably it would be good to get Eton to say what his thoughts are.
00:10:59.430 - 00:11:18.820, Speaker A: Okay, so I guess, yeah, I guess maybe let's chat about this async on the discord and see what he thinks.
00:11:22.280 - 00:11:28.984, Speaker B: Yeah, I think we have a little. We're going to have to do another Devnet, so I think we have a little bit of time to figure this out.
00:11:29.022 - 00:12:20.250, Speaker A: Yeah, I just want to make sure that we don't sort of circle around this over and over again. I feel like if we can get his thoughts in the next day or two, then by the ACDC call this week, we can just all have agreed and potentially just remove the optional from 4844. And I guess if we did that, then it's not clear that we even need the EIP as part of Cancun generally, because it's the only use of SSD, I believe. But anyways, we can have that discussion on core devs as well.
00:12:21.740 - 00:12:32.750, Speaker B: Yeah, I mean, I think if Eton agrees that if we do do a normalized transaction type, it would be a distinct one from the existing bloblin, then perhaps we're all aligned that we should get rid of it.
00:12:34.340 - 00:12:44.210, Speaker A: And I think it's not clear to me that there's consensus within the client teams that a generalized transaction is a good idea. Transaction type is a good idea.
00:12:45.860 - 00:12:55.190, Speaker B: Yeah, no, definitely not consensus around that. But if we were to pursue it, and it would be a different transaction anyway, then we may as well constrain the blob transaction now, I guess, right?
00:12:55.560 - 00:13:48.100, Speaker A: Yeah. Okay, so let's assume that unless Ethan has like a strong objection, we move forward with removing the optional field from the 4844 type transaction. And obviously we're not going to change that on Devnet five. But as we get that ironed out, that would be what we would do on the net. Six. Okay. And I guess, relatedly, like the, the next thing I had on the agenda, which we covered on the SDE last week, is the EIP 6493.
00:13:48.100 - 00:14:07.950, Speaker A: So the signature scheme for SSZ. And there's comments in the chat about that already. Yeah, I'm curious, what are people's opinions about that and how we should move forward with it?
00:14:11.920 - 00:14:18.860, Speaker C: I was wondering, why add for cash to the transaction domain?
00:14:21.520 - 00:14:36.230, Speaker B: I think Etan left a comment. That's how it's done in a consensus layer. I'm not familiar with that, though. But he asked the same question in the chat, so he was asking what the motivation was, but I don't have the answer. Hopefully someone here does.
00:14:36.600 - 00:15:07.490, Speaker C: Yeah, I don't know exactly what the forecache looks like for the Cl but in this case, it looks like the forecache only protects the forecache in this proposal that Eton has, whatever the zip is, it only protects it against a world where a competing chain has the same genesis and introduces the exact same transaction type in a fork later than canonical main net. Other than that, I think it's kind of a moot point.
00:15:16.280 - 00:15:32.650, Speaker E: Well, I sort of agree in the sense that basically this transaction is not really fork dependent. So it's not that there needs to be an expiry of the transaction when a new fork will come on.
00:15:33.420 - 00:15:42.750, Speaker C: Yeah. Okay. I guess that's why it's on the Cl, right?
00:15:44.080 - 00:15:44.876, Speaker E: Yes.
00:15:45.058 - 00:15:50.850, Speaker B: Sorry, I didn't follow. I'm trying to get in the notes. What was the reason? It's in the Cl.
00:15:53.940 - 00:16:10.500, Speaker E: So, in the Cl, basically, when a new folk comes on, some messages become old and basically new messages are required, so you sort of expire them. And this is the mechanism to expire those messages.
00:16:25.280 - 00:17:41.610, Speaker C: Yeah, I don't think that we have that problem on the El, and if that was something that people wanted, then it's something that would need to be thought about a little bit more, because we go from a world where your transactions don't expire on fork boundaries to a world where they do. I'm sure there's some unintended side effects there. Also, enshrining the CRC 32 checksum into the protocol is probably not something that we want to do, because right now the proposal just says use the EIP 21 24 for cache specification, which was designed for Dev P to P and then enshrine that into the protocol. So I don't think that we really want to add more cryptographic functions into the protocol, so we might consider a different option. Otherwise, maybe just set to be compatible with the co set for cash to some static value, and then one day in the future maybe we change it or utilize something different. But I don't really see the point of it for the transactions right now.
00:17:42.780 - 00:18:16.560, Speaker E: Yeah, it's similar to how BLS change execution changes. Messages are sort of formatted with just a fixed folk. Nothing really changes. So those messages can live forever. So yeah, as of now, it doesn't make any sense to bring domain work domain into the year land to sort of expire the messages.
00:18:21.890 - 00:18:30.482, Speaker B: I link to the ETh magicians question that Etan raised. Maybe we could continue the discussion there. I mean, it sounds like we should get rid of it though.
00:18:30.616 - 00:18:32.100, Speaker C: Yeah, sounds good.
00:18:40.610 - 00:19:08.260, Speaker A: Okay, so aside from basically the fork version, the genesis hash. Yeah, aside from continuing that conversation on ETH magician, is there anything else we want to figure out with the signature scheme on this call?
00:19:09.450 - 00:20:15.450, Speaker C: I guess maybe just more of a broader question, but does it make sense to really bring the same signature scheme that validators use into the EL? Because right now we kind of have these two worlds. El, you sign your messages with ECSA over the signature hash, and in the CL you have a very specific mechanism that has the domain and the forecast and all these things. Does it make more sense to try and define some sort of signature scheme that's more aligned with the El? Because I can imagine a world where we don't really ever add any more transaction types, and we have three transaction types that are implemented in this very specific way. And then we have this one special 44 transaction type that looks more like a consensus signature and that just doesn't really seem like something that's really ideal from the perspective of execution layered developers to have a totally different format. They have to learn and for all of the hardware providers to support this stranger signature scheme.
00:20:21.440 - 00:20:26.690, Speaker B: Isn't the idea to swap over all at once once we're ready to ssd everything?
00:20:27.060 - 00:20:45.700, Speaker C: No, we can't ever swap over the signature hashes because we kind of have the assumption that we're not going to force all of the hardware wallets to upgrade and all the users who have hardware wallets to upgrade their hardware wallets.
00:20:51.640 - 00:20:54.760, Speaker B: People do update those though, so it's not impossible.
00:20:55.340 - 00:21:09.420, Speaker C: Yeah, but we've debated this a fair bit in the past, and I don't think that people are going to be supportive of a change that makes it impossible for someone who has a hardware wallet from 2017 to sign a message without updating their hardware wallet.
00:21:10.960 - 00:21:25.340, Speaker A: Yeah, and I think in the past we've even had more extremes version of this argument, which is like you've already signed the transaction and you threw your hardware, right, you're just waiting to broadcast the signed transaction.
00:21:25.500 - 00:21:45.880, Speaker C: I think maybe it's possible to have some pre compile or some specialized operation that takes an old signature hash and instantiate a transaction based on that and then switch all of the transaction signature hashes over to some SSD thing. But I think the most likely situation is that we just never are able to fully move away from the rop signature hash.
00:22:12.840 - 00:22:30.250, Speaker B: Yeah, I guess. I don't know. I think one of the problems that I guess this proposal is solving is the chance for collisions across chains. I guess there's probably a simpler way of achieving that objective. Is that kind of what you're thinking?
00:22:31.600 - 00:23:15.208, Speaker C: I think that you already actually, I don't know. I kind of forget the exact reason Itano was explaining this, and I didn't quite understand 100%, but I think that there are simpler things that we could do. So a silly example I thought of earlier was, imagine that you just compute the hash tree root of the transaction, sign that, and then to get a transaction, let's see, you compute the hash to your root, and then you change the upper byte to the transaction type id. So now you have, like, domain. You're signing hash to that transaction. That's kind of what the domain is doing. There's a lot of this machinery that's happening if we drop for cash.
00:23:15.208 - 00:23:29.070, Speaker C: Really, the only thing that all of this machinery is doing now, besides making it look like a Cl signature, is that it's adding the transaction type information to the signature. And so there are simpler ways of doing that.
00:23:31.360 - 00:23:46.800, Speaker B: Yeah, so I think the case he was explaining was that there might be another change that introduces an RLP transaction of the same type and introduces potential for collisions that way, which is obviously quite remote.
00:23:47.140 - 00:23:52.980, Speaker C: Yeah, I mean, if we're introducing rop transactions of the same type, then we've made a mistake.
00:23:53.480 - 00:24:00.730, Speaker B: Yeah, I think he's saying another EVM compatible chain or something might do that. Right beyond our control.
00:24:01.100 - 00:24:10.360, Speaker C: For sure. There is this issue, I guess, which I guess is that's what the genesis route is avoiding.
00:24:10.780 - 00:24:11.530, Speaker B: Yeah.
00:24:25.960 - 00:24:52.404, Speaker A: Okay. So I guess. Yeah. It's not clear to me what the next step is here. Or I guess, how valuable it is to keep. Yeah, I guess. Yeah.
00:24:52.404 - 00:24:57.030, Speaker A: It probably makes sense to keep discussing it on each magicians, but.
00:25:00.920 - 00:25:01.556, Speaker B: I'm a.
00:25:01.578 - 00:25:04.550, Speaker A: Bit weary of like. Yeah, sorry, go ahead.
00:25:05.960 - 00:25:26.248, Speaker B: I almost hate to say it, but, I mean, maybe we adopted SSE too prematurely. I hate to even back up further, but if we're kind of half adopting it, does that even make sense? We just have stuck with RLP until we kind of figure out this broader story. I don't know, I'm starting to have concerns.
00:25:26.424 - 00:25:30.640, Speaker A: Right, so we refactor all of Ford for four to use RLP.
00:25:36.740 - 00:25:38.610, Speaker B: All right, just ignore that.
00:25:39.220 - 00:25:45.090, Speaker A: Yeah, please, Andrew, go ahead.
00:25:47.140 - 00:26:01.130, Speaker F: Well, now we include chain id into the transaction, so maybe if we want to achieve this, to solve this more limited problem of avoiding flash between.
00:26:03.440 - 00:26:03.804, Speaker A: The.
00:26:03.842 - 00:26:22.104, Speaker F: Same transaction id but different format on different chains, maybe we can serialize prefix transaction serialization with the chain id instead of like, Genesis hash.
00:26:22.152 - 00:26:27.250, Speaker C: Or doesn't the transaction serialization already have the chain id?
00:26:27.780 - 00:27:40.920, Speaker F: Yeah, but I think Ethan's point was because you can have SSD serialization and RLP serialization and whatnot serialization, and even they all include chain id. But then because they are in different format, there is no guarantee that the same binary civilization would be different. Or a single binary representation can still be reinterpreted on different chains with different chains ids that use different formats. But if we kind of include, so we have this transaction type prefix, and then maybe we somehow add chain id to the prefix in some similar format like big indian zero stripped or whatnot, then we can exclude chain id from the main serialization and solve the problem of clash between different chains.
00:27:44.390 - 00:27:51.190, Speaker B: But then wouldn't we have to ensure that it's serialized at the exact same point as the RLP encoding? Or is that what you're proposing?
00:27:52.170 - 00:29:10.670, Speaker F: Yeah, I'm proposing to, I think how type transactions work for the existing, say, 1559 transactions. We serialize them into RLP and then we prefix the transaction type bytes to the RLP serialization. Right? So I'm thinking what if we have this transaction type prefix and then we have another prefix with the chain id outside of the SSD serialization, and then we have the following will be SSD serialization or RLP serialization and whatnot. And we can promote that among EVM compatible blockchains as a way to avoid clashes. And we also can make sure that that special prefix for chain id doesn't coincide with any valid RLP serialization, things like that. I'm just thinking of a way to solve the more limited problem of avoiding lashes between different chains.
00:29:25.100 - 00:29:32.380, Speaker D: How it is different from a case when chain id is the first field in SSZ?
00:29:34.160 - 00:29:42.690, Speaker F: I don't know how SSZ is serialized. Is it like when you have the first field, will it be the first?
00:29:43.700 - 00:29:45.410, Speaker C: If it's fixed size?
00:29:47.780 - 00:30:12.760, Speaker F: Okay, so I guess if it does not, and for RLP, that will be like, yeah, okay, maybe. But then can we reinterpret the same thing in RLP as RLP?
00:30:15.580 - 00:30:18.030, Speaker G: You'd have to put the endiness of it.
00:30:19.440 - 00:30:50.550, Speaker E: My view is we can, because right now the signature is composed after doing a hash of the serialized transaction. So basically, if there is an RLP that is same as the current transaction and the signature matches, that means that we have a solution to finding a pre image problem. It feels like that to me, the hardness of the problem. It's very hard.
00:30:58.960 - 00:31:03.010, Speaker F: And sorry, we had hash of what?
00:31:05.780 - 00:31:24.470, Speaker E: So to compute the signature, we hash the serialized transaction which is prefixed with the transaction type, to find an RLP transaction that matches with this as well as the signature also works out.
00:31:27.020 - 00:31:27.336, Speaker A: It.
00:31:27.358 - 00:31:32.810, Speaker E: Feels to me, that is the same problem as finding a premage of a hash function.
00:31:35.260 - 00:32:04.772, Speaker F: Well, I think it's a weaker problem because theoretically, you know how SSD works and how RLP work. So you can potentially, a potential attack is that you can find identical SSD and RLP serializations. Well, it's mostly theoretical, I guess.
00:32:04.906 - 00:32:11.056, Speaker E: But would the signatures be mean both in RLP and SSE domain?
00:32:11.248 - 00:32:17.610, Speaker B: I thought Eton actually had a demonstration of it. My recollection could be wrong. But anyway.
00:32:22.050 - 00:32:24.910, Speaker E: Yeah, we need ethan to complete these conversations.
00:32:25.730 - 00:32:36.930, Speaker B: Yeah, unfortunately he's out to take that, but yeah, unfortunately it's not as difficult to do as finding a hash collision, for example. But I can try and look that up and add it to the notes.
00:32:42.710 - 00:32:48.920, Speaker E: I mean, I think Txpype should take care of that. But yeah, I want to see what Itan has come up.
00:33:10.680 - 00:33:20.350, Speaker A: Yeah, I'm not quite sure where this puts us. I.
00:33:40.580 - 00:34:08.180, Speaker C: I think this is an example of a different thing that we're talking about here, though. This is an example of getting two hash tree roots being the same value, just due to the fact that the first example doesn't have a power of two items. And we're talking about RLP versus SSE. So maybe there was a different example, but this was the one that I was remembering.
00:34:08.340 - 00:34:11.210, Speaker B: Yeah, I might have them confused as well.
00:34:21.190 - 00:34:51.260, Speaker C: I don't know. I don't mean to throw a wrench in things, but I feel like we're putting 1ft in the door of SSZ and we're not going the full way in some cases. And so I'm just trying to think what is the best way to ship four four, where we ship it quickly, we do the things we want to do, and we don't do things that need to change in the future. And I think transaction signing is, I don't know, maybe one of these things.
00:34:56.430 - 00:35:13.700, Speaker B: It seems like this is a big enough change that we're always going to have some problem like this, though. So either we don't do it and wait how to do it all at once, or we do kind of possibly make some compromises today so that it lays the groundwork for the future.
00:35:16.150 - 00:35:55.120, Speaker A: And I think realistically though, when we say we waited, we do it all at once. This is like we delay. Doing it all at once will not be the top of our priority list for the next few years at least. Right? So it's like, what's the cost of waiting, say, three years for this to happen all at once, or having something that's kind of in between in the meantime and potentially also having to deal with it again in like three years.
00:35:57.960 - 00:36:20.030, Speaker B: Yeah, but I guess it seems the main goal that Eton was trying to solve was to try to get us to 6404, where we eventually have a fully mercalized transaction route in the block header and you can access pieces of transactions. So maybe we should strive kind of a minimum change that achieves that.
00:36:23.700 - 00:37:03.870, Speaker C: This is kind of like in a weird space, though, that's separate from that, because this is more like signature hashes and it's not really seen by the protocol other than whenever you verify the sender of the transaction. So we can kind of do whatever we want here. I guess maybe we're spending too much time thinking about what the right thing to do is, but ultimately we could just simply RLP serialize the 4844 elements and Kcheck hash them with the type prefix and sign that message. And that would be most parallel with what we already have, not affect our ability to do any six four, four related things in the future.
00:37:09.200 - 00:37:13.280, Speaker B: It, how is that much different than what's currently implemented?
00:37:14.420 - 00:37:53.870, Speaker C: I think it is pretty much what's currently implemented in terms of SiG hashes. But we're right now talking about changing the way that we do the SiG hashes to be much more similar to the CL, which we're not really trying to be Cl compatible, as far as I'm aware. And it doesn't really affect our ability to do 6404. So we're kind of trying to figure out a new way of doing execution layer transaction signatures, which is fine. But I guess the question is, should we just do it exactly like the Cl? Does it just for compatibility for that reason, or should we think of a better way that fits better within the design scope of the El.
00:37:58.330 - 00:38:19.690, Speaker B: Right. So I guess I was asking if we don't want to pursue, if we decide to keep it simple, what we have implemented now in Devnet five, where it does a hash of the serialized forum with the type bit using ketchack, where does that break? I guess. Is that not an adequate solution?
00:38:20.770 - 00:39:01.770, Speaker C: I think it's an adequate solution. I think the only thing that's a little bit weird is that it's not really the way that we hash SSZ values. So it's kind of unique in that sense. And so if we are going to make this an SSD object and then we calculate the RLP values of these things, this sort of breaks the assumptions that you might have around an SSD object. I don't think it really breaks anywhere because you don't create proofs against signature hash. It's really something that's not seen by users in any meaningful way. So I think it's okay in this case.
00:39:01.770 - 00:39:23.860, Speaker C: But the most correct thing to do would be to calculate the hash tree root of the SSD object in some way, and then compute a signature over that in some mechanism. And I think that's what this EIP is really going for. The problem is that it just directly takes what the Cl does and applies it to the El transactions. And there are things that we don't care about, like the forecast, as we're finding out.
00:39:40.710 - 00:39:50.790, Speaker F: Is there a difference on l two site whether to create blob transactions with SSD or with RLP?
00:39:52.490 - 00:39:54.358, Speaker C: I didn't catch the first part.
00:39:54.524 - 00:40:05.610, Speaker F: So for l two, is there a preference of RLP versus SSZ for blob transactions?
00:40:06.590 - 00:40:41.160, Speaker B: I think the only thing I've seen raised in the chat is what Mophie mentioned, which is the one nice property gives you, is you can get at the blob version hash without having to know the entire transaction schema. But that's a consensus layer advantage, not an El advantage. Yeah. So if we're not, for example, taking advantage of the full mercurialization, seems like the SSE isn't buying us a whole lot in the.
00:40:54.930 - 00:41:00.900, Speaker A: So we're. Yeah, we're almost through the entire call.
00:41:04.390 - 00:41:10.040, Speaker B: Does Matt drop another proposal, a simpler proposal? Discuss that.
00:41:13.850 - 00:41:36.400, Speaker C: I think right now I'm marginally in favor of, I guess, what we have. Like I would have to look to double check, but I think that if we're computing some RLP list of all of the elements, prepending the transaction type, and then Kcheck hashing that to create the signature, that's probably the best and simplest thing that we have at the moment.
00:41:47.280 - 00:41:58.576, Speaker A: It, I guess, yeah. And how big is it to write that spec basically, or I guess a pr to four?
00:41:58.678 - 00:42:09.990, Speaker C: Four. Do we actually change the signature hash at some point to something else, or was it something we were just talking about doing?
00:42:14.670 - 00:42:37.490, Speaker B: Originally the signature hash was hash tree root, and then it was changed to just catch out of the serialization to sort of be more compatible with the way that Yale is already doing it. But I don't think it was ever RLP based. Mophie. I don't remember that reading from the chat. Mophie says it was RLP based.
00:42:42.210 - 00:42:47.070, Speaker C: But right now it's on Devnet is not RLP based. You guys are computing the hash tree route.
00:42:47.970 - 00:42:54.590, Speaker B: No, it's computing the ketchek hash of the SSD serialization, not the hash tree route.
00:42:55.190 - 00:43:28.560, Speaker C: I see. Yeah, I would be against doing the kcheck of SSZ serialization just because this is something that is not done anywhere else and it just seems weird. That is one of these examples where I feel like we're stiffing partially into SSD but not the full correct way. So I would rather do kind of what Eton is proposing with a full SSZ signing mechanism with the hash reroute, or falling back to doing what kind of already exists, which is the.
00:43:37.990 - 00:43:39.060, Speaker A: Andrew? Okay.
00:43:40.310 - 00:44:24.610, Speaker F: Oh yeah, I just wanted to say that. Yeah, I agree with the light line. So we either should revert back to RLP or go the whole way and think about SSD like a proper path to ssding everything and invest more time and just making sure that things like 6493 is actually a good way forward. But this kind of the current approach, which is half measured, doesn't seem to be a good approach.
00:44:27.270 - 00:44:59.280, Speaker D: Yeah, it would be probably good and helpful if final scope of SSD transition existed and we could at least understand which part we can deliver with rate four without a lot of remake after that. What is the final game like that?
00:45:11.020 - 00:45:12.970, Speaker A: Justin, you also have your hand up.
00:45:13.340 - 00:45:45.330, Speaker G: Yeah, just real quick. I think I agree with everybody, but I do want to point out that the intent behind the SSE adoption eips, as they're written right now, is for incremental adoption. So I think it would help us to say that we want to abandon that approach and pursue a big bang, knowing and accepting that the trade off is significant delay in adopting SSD. So I think that's one thing to keep in mind, is that these half measures are by design.
00:45:50.050 - 00:46:10.222, Speaker F: Yeah, but what are the goals of adopting SSD? What are we trying to achieve? It's like bringing an SSZ library into El is not worth the of what are we trying to achieve?
00:46:10.286 - 00:46:28.654, Speaker G: Yeah, honestly, I agree with that. I'm just kind of bringing up the other end of the argument from my understanding, which is limited, is that what we gain is a generalized upgrade and adoption of what we broadly think is a superior serialization format. That's all. I don't have a stronger argument than that.
00:46:28.852 - 00:46:40.462, Speaker B: Yeah, I agree with that as the goal. But I guess what it seems we're starting to realize is, are these half measures really even getting us there, right?
00:46:40.516 - 00:47:46.470, Speaker C: I mean, look, again, we're talking about mostly right now if the signature signing scheme, which I don't think really matters all that much at the end of the day when we start talking about six four four and how are we going, what is the actual transaction hash? What is the value that's going into the transaction commitment tree, whether it's Merkel, Patricia or SSD. That's where that comes more into play, I think. But specifically, something that SSD helps with is being able to, in a smart contract, in some sort of fraud proof, be able to create proofs to specific pieces of the transaction without having to put the entire transaction object on chain. That is, I think like the major thing that I heard from l two s that they wanted to be able to prove a certain piece of the transaction. And right now it's not possible because you have to compute, to get the commitment against the header in some way. You have to compute the kcheck value yourself, which means you have to have the entire pre image of the transaction. With SSD you can just use the hash tree root prove like one specific leaf of that transaction.
00:48:01.680 - 00:48:21.030, Speaker E: So basically the transaction signature can still be computed like Gigakov SSD serialize, but the final transaction identifier could be the SSD hash tree root of the signed transaction type.
00:48:23.400 - 00:48:55.930, Speaker B: Yeah, and that's what 64 four is all about. It's about getting that fully mercalized SSE transaction route in the header to allow for those kinds of proofs. So I think that is definitely a valuable goal, especially for l two developers. I guess I'm not sure which way best gets us incrementally towards that, or if this is helping at all. I guess.
00:49:01.490 - 00:49:10.494, Speaker E: Maybe we need to see some use cases. I think that would sort of bring and conclusive and total discussion what we need.
00:49:10.692 - 00:49:41.500, Speaker B: Oh, I think for that particular case, there's use cases in fraud proofs, for example, being able to single out a specific part of the transaction. So I think there's known value for having SSE with a mercalized root available for proving over parts of it. But how do we, I guess the path there, right. Are these decisions we're making now hindering or helping our path there? I think that's what I'm a little fuzzy about.
00:49:44.510 - 00:50:06.020, Speaker C: I would like if anyone has a strong argument for adopting this as a Zbay signature scheme, to try and flush that out, because if there's not a strong argument, and we're just doing it just to do it, then to me that doesn't make a lot of sense, and it might be better to stick with the formats that we have.
00:50:18.330 - 00:50:33.678, Speaker D: As was said, it can be a good tool for l two s to some partial calculations parts of transaction of be transferred.
00:50:33.874 - 00:50:42.750, Speaker C: But the signature hash isn't available in the consensus mechanism. Like it's totally opaque.
00:50:53.440 - 00:51:07.570, Speaker D: So this partially calculates the truth is not used in contract like that. It is needed just in communication with consensus layer by airtooth. Right.
00:51:09.140 - 00:51:32.810, Speaker C: I'm not sure if I'm following. I'm talking about the message hash that the user ends up signing to create the signature. And I don't think that that value is propagated anywhere. It's reconstructed every time by the consensus nodes or the execution layer nodes to validate the sender of the message. But it's not something that's communicated to the cl or l two s.
00:51:46.390 - 00:52:31.054, Speaker A: Okay, so we just have 5 minutes left. Does it make sense to pause this conversation here? Obviously keep chatting on the eth magicians in discord and aim to align on the overall SSD approach for Devnet six. Obviously, we shouldn't change Devnet five overnight with this, but it does seem like a significant enough thing that if we make this our focus in the next couple of weeks, we could hopefully get to a spec we're happy with and have the next Devnet implement that. Does that make sense to people?
00:52:31.252 - 00:52:56.470, Speaker B: Yeah, I think this as well as, I guess the blob transaction, rebroadcasting on reorgs are sort of the two main open issues that I'm aware of anyway. But yeah, I guess we should probably move on, given a limited amount of time left. Try and have that on the discord for now. I'll try to lay out a few of the points and options that were discussed.
00:52:57.530 - 00:53:23.360, Speaker A: Awesome. Yeah, that would be amazing. Thank you. Yeah. Okay. I think those were all the spec discussions that we had. So there was the pr, I guess Ethan had a small pr to 4844 that just changes the limits on.
00:53:26.050 - 00:53:28.640, Speaker B: Yeah, I think it's just. He's just fixing up.
00:53:29.090 - 00:53:50.600, Speaker A: Yeah, exactly. I guess then in terms of devnets, it might be worth just getting you a quick update on Devnet five, where different teams are at. Obviously, for Devnet six, we can discuss that once we have the SSZ figured out.
00:53:52.570 - 00:54:38.390, Speaker C: One last spec thing. The same argument that we sort of made against doing the kcheck of some z serialized value for the signature hash is the same argument for doing it for the transaction hash that goes into the merkel. Patricia, try right now. So I am again, very against doing this half in, half out, where we kind of introduce SSD, but we don't use the correct way of hashing SSD object, which is the hash tree root, and we're just plopping that into the transaction try. So I would rather again, go the full length or only go not do the Soz.
00:54:49.330 - 00:55:59.460, Speaker A: Okay, I guess quickly, any very quick updates on Devnet five? Nothing changed since Thursday, I would say. Okay, so as we wrap up, we're just highlighting there's this tool that was shared in the agenda, so if people want to check that out, I don't think the author is on the call. And then last thing. So, Roberto, you just mentioned SSD, the reorg stuff are like the two biggest open issues. Obviously Peter's had a bunch of comments about the state of the crypto libraries on the discord as well. I'm wondering, do people think there would be value in trying to have a more thorough checklist to track all these issues? Oh, sorry, I just saw your message. Okay, we can get back to that right after.
00:55:59.460 - 00:56:35.100, Speaker A: But yeah, the people think there's value in sort of revamping the readiness checklist we had this much earlier on. Last time I updated it was right before Austria. Or do we feel like there's sufficiently little issues left to deal with that? Obviously the actual edge cases get tracked in the tests and then there's a handful of other implementation issues, but it's not worth maintaining a whole other, whole other tracker for that.
00:56:36.050 - 00:56:40.110, Speaker B: I don't think a specific tracker for 4844 would hurt.
00:56:40.690 - 00:56:41.486, Speaker A: Okay.
00:56:41.668 - 00:57:03.400, Speaker B: I think last time we were here, Danny had to remind us that this was an open issue around the blobs, for example, which has become top of mind. Perhaps we've been tracking that. We'd be more on top of it. I guess it doesn't need to be super detailed, but yeah, just sort of a list of remaining things to resolve to make sure we're making progress, I think would help.
00:57:04.570 - 00:57:13.510, Speaker A: Okay, I'll take a stab at updating the one that's there and kind of bringing it up to date this week.
00:57:13.660 - 00:57:25.530, Speaker B: Right. But like the crypto library issue, I've been following discussion around that. I believe Kev is working on that, at least in the go library. But I don't know, someone on the CKZG side is thinking about those concerns.
00:57:28.670 - 00:57:43.330, Speaker A: Okay. Yeah. Okay. So perfect. I'll update it, I'll share it once I have something. And obviously anyone's free to open a pr against it to tweak it as well. But I'm happy to own kind of the bigger update since January.
00:57:43.330 - 00:57:52.920, Speaker A: Okay. And yeah, I guess hopefully got your name right. Do you want to take a minute to talk about your tool?
00:57:53.930 - 00:59:15.098, Speaker H: Yes, sure. So we are experimenting the EIP 44 for net, especially from smart contract side, to see how to use it and also test it in smart contract. So one thing I found maybe missing is how to support this new op code in a developer friendly, I mean especially from smart contract developer friendly way. So I searched basically the implementations course and I'm not sure there's any other tool that help to support this new op code and also definitely will take time for the cities to support that. And if someone has more information of what they plan to support this new op code, I'm glad to learn. So just start a quick small solution library that is able to deploy a customized assembly code to a smart contract and be able to call the data hash and then be able to return to the parent the caller smart contract and so that we are able to retrieve the corresponding data hashes and then use the data hashes as storing the for example like for example in the robot contract to experiment all these ideas of VIP. .4
00:59:15.098 - 00:59:36.600, Speaker H: so this is basically what we have done and all the code is in the repo and we have done the experiment test on the devnet. Therefore in the GMIs notes and happy to learn if there's any feedback or perhaps there's also other tools to solve the problem.
00:59:43.910 - 00:59:50.600, Speaker A: There's a question in the chat, can this be combined? Oh, sorry.
00:59:52.010 - 01:00:54.598, Speaker H: Can be date code call combined with point evaluation codes. I'm not sure that the date code call is, I think is that the date hash obicote? I'm not quite sure. Combined with. No, they are separate things. So data hash opical is a new opical x 49 that is added in the list of the Ethereum EVM opical to retrieve data hash corresponding to a block index. And the point evaluation precompile is a separate precompile that is added to support the polynomial evaluation of corresponding data block. Given a list of data like KZG version hash and energy commitment, and also proofs.
01:00:54.598 - 01:01:32.418, Speaker H: So basically in terms of for example ROA, especially in optimistic contact. So I believe the data hash is used to batch upload the data and well, if someone found that the transaction, the execution result on layer two is wrong, then they will call point evaluation precompile to upload a blob and then say hey, there's some issue of executing this blob on layer two and want to challenge. So this is basically two different steps used in roll up setup.
01:01:32.594 - 01:01:45.740, Speaker D: Yeah, thank you. It was interesting how these pieces of code can be useful in grateful for actually it was not clear.
01:01:46.110 - 01:02:00.718, Speaker A: Thanks. Okay, cool. Anything else? Anything else? As we wrap up, we have a.
01:02:00.724 - 01:02:07.780, Speaker I: Couple of small updates from testing vectors I wanted to share. Is that fine?
01:02:08.310 - 01:02:10.882, Speaker A: Yeah, go ahead. Yeah.
01:02:10.936 - 01:02:43.146, Speaker I: So I shared two links on the mini chat. The first one is the execution spectrum. So there was a new release by Spencer helped us out to tab yesterday. Basically, it contains the cancun vectors. And you can use this on the execution client that supports 48. And we also have the hive test suite. It contains, right now, five test vectors for all the execution clients who want to run this.
01:02:43.146 - 01:02:54.850, Speaker I: If you need some help to run a specific docker image of your execution client, please let me know. I can help you out to run any of these vectors.
01:02:56.710 - 01:02:59.858, Speaker C: Yeah, that's all cool.
01:02:59.944 - 01:03:15.140, Speaker A: Thank you. Anything else? Okay, well, thanks, everyone. Yeah. Talk to you all soon.
01:03:15.990 - 01:03:17.060, Speaker C: Thanks, Tim.
01:03:17.750 - 01:03:20.320, Speaker A: Thank you. See you guys.
