00:00:18.970 - 00:01:02.526, Speaker A: Actually, I'm very fortunate to be able to follow Juan talking about this beautiful collection of hashes, this beautiful forest of hashes, because that's exactly what I'm talking about. It's the same thing, except I'm going to talk about it not from a perspective of content, but from a perspective of time. So compared to a lot of what you've seen today, this is actually a very simple presentation. I just want to, in the next 15 minutes, hopefully get you to think about a new cryptographic way of thinking about time. So I think most people, when they think of time, they think of probably what their local clock says right now. They think of a number. Some of you, as developers, will think more abstractly, as something like UTC, or maybe you'll even think of something even more abstract than that.
00:01:02.526 - 00:01:56.240, Speaker A: But in either case, you're probably thinking of some kind of ordered numbered property. And when you get into the cryptographic basics of how a lot of these blockchain systems work, you don't have that sort of a numbered property anymore. You only have one relation that you can enforce. And basically that relation is that if something happened before you created a certain hash, then you know the order in which the hash and the content were created. The way that this is commonly used is in proof of existence. Like Vitalik mentioned earlier, we're probably all familiar with the example of if I take a document and I hash it, and I put that hash inside of the bitcoin blockchain or the Ethereum blockchain, then at a later time, I can argue that this document already existed at a certain point in time because it was included in this particular block header. And I can give a very efficient merkel proof that this was the case.
00:01:56.240 - 00:02:35.520, Speaker A: This is an image I just randomly pulled off the Internet about structure of block. And we can see the same shape that's been up here three or four times today of all our wonderful content being hashed up into a root and a series of blocks. But a lot of people may not realize that we're creating a little bit of a fragmented approach to time when we do this, because every individual blockchain has its own idea of sequence. And it's not just blockchains, actually. This is an image of a traditional linked timestamping provider called guard time. You'll notice it's the exact same structure. We've got a bunch of individual content being merkeled up into a route and created into something over time.
00:02:35.520 - 00:03:29.850, Speaker A: And this is really unfortunate, because if the only measure of time we have is the relative ordering of two things, that one thing happened before the other thing, then if we're creating lots of different fragmented versions of time, we're losing something, and it's unnecessary because we can very cheaply keep all of this information. And this is the idea I call universal hash time. So just to mention a few sources of time that are out there right now. Of course, we have the Ethereum network, bitcoin, all the blockchain networks have some kind of chain of headers that's keeping track of time and ticking along. Traditional linked timestamping providers include guard time, the open source true timestamp, Alstru, a couple of other companies. And the answer to this is really very simple. This basic structure where you have some kind of packet of data that is somehow identified.
00:03:29.850 - 00:04:11.642, Speaker A: It's signed, but this is an abstract signature. It could be just the existence of some proof of work or compliance with some sort of pre agreed format, and that it has a link to the previous tick, the previous packet, and then on the other side, it has the root of some authenticated data structure. It could be a merkel tree, but it really could be any authenticated data structure. Of course, in Ethereum we're familiar with a Patricia tree. There's any wide variety of things that you could use. As long as we have these systems, there's a very clean and simple way that we can bring all of their concepts of time into alignment. And that is we just put the hash of every series of ticks in every other series of ticks.
00:04:11.642 - 00:05:25.090, Speaker A: Simple, right? So this is the idea I call Universal hash time. And basically this Pattern here, wherever we see it, we're going to come up with a term for that that allows us to recognize it. We're just going to call them tick chains. Obviously, block headers are what we think of in the blockchain world with Ethereum and things like this, but it's the exact same format in traditional links, timestamping and any other format, anything that constitutes a Tick chain, we're just going to try and put hashes of all that into every other system. So in terms of the structure here that we're familiar with, this is shared both across blocks with block headers and also traditional Link timestamping. We have a bunch of hashes that we're going to try and include, and we're going to hash them up into, for example, a MErkel tree or anything else, and we're going to put that root hash inside of the packet, and then we're going to have a sequence of packets and each Packet is going to contain the hash of the previous. And this pattern that we use in proof of existence, it's the same pattern that is called electronic certification in the linked timestamping providers.
00:05:25.090 - 00:06:07.138, Speaker A: It's just one same thing over and over again. And I'm just going to skip ahead here. And what it allows us to do is produce these very compact receipts. So if the Data is in Blue here, and we want to be able to prove that the Data was hashed into this particular tick here, we only need to store the red parts. So this is how we form our MErkel proof. For example, if this is a Merkel tree or whatever our system is, we have some kind of Receipt. Now, in the context of Universal hash time, we're going to say, unlike in blockchains, we're not going to try and store this, we're not going to try and replicate it, we're not going to try and make it available.
00:06:07.138 - 00:06:46.350, Speaker A: If you've got some content that you care about the stamp of, you're going to be the one who holds onto this receipt. So, for example, if one hash chain is being stamped into Another Hash chain, whoever cares about the Hashing, they can hold onto the receipts. We don't have to store and replicate this data. And that means going back to the earlier scalability conversations we were having, that all of this is going to scale extremely, extremely well. So in terms of scaling, we don't have to have every party keeping a copy of everything. We don't have every party validating everything. We basically just have to sneak these hashes in every once in a while and then ourselves, keep track of the fact that we did this.
00:06:46.350 - 00:07:34.462, Speaker A: As long as we have this property, we're going to later be able to come back and give time, like guarantees that can be cryptographically verified. And importantly, those timelike guarantees can be cryptographically verified inside of blockchains. Normally, if I want to prove inside of a blockchain that something happened at a certain point in time, I have very limited options for that. I need some kind of centralized provider to timestamp or something like this. And what we're going to see is that this has a lot of applications in the blockchain world. The first question that comes to mind is the economics of this. If you're going to be moving between chains and stamping between chains and trying to do this reliably, how can you pay for it? Especially if the chains maybe are moving in different cycles and have different cryptocurrencies, there's a very easy answer to this.
00:07:34.462 - 00:08:52.294, Speaker A: For those of you who are familiar with the concept of payment channels, state channels is the generalized idea of payment channels. And it's the same basic concept that you'll have heard two or three times today. If you can produce a game theoretic smart contract judge that's capable of judging between two participants and accepting their proof, accepting their evidence, and on the basis of that evidence, deciding what's going to happen, then you normally won't have to submit that evidence. As long as you're confident that someone has signed something and you could submit it to a smart contract and get something back out, then you'll probably never have to do this, because you can kind of just agree that the transfer has already taken place, enforced only if necessary by the blockchain, the same technique that swarm was referring to earlier. This is fantastic, because if we can write smart contracts that allow us to pay out only in the event that our hashes were included into other chains, and this can be paid for by anybody, it can be the person whose data is being hashed into the chain, but it can also be someone who wants to fund this as a public good. For example, maybe I want to fund as a public good the idea of having all Ethereum hashes included in the merkle tree of bitcoin and vice versa. Then I can just write those terms into a smart contract, and I can design that smart contract in the form of a state channel.
00:08:52.294 - 00:09:58.966, Speaker A: And what's going to happen is that because the ability to appeal to the blockchain is present in most cases, I'll be able to pay out that entire smart contract instantly, in real time, very small amounts, no transaction fees. And even though I'm incentivizing this as a public good, so it's all a trustless system. It's all very easy to support, very easy to kind of follow the same IPFs model of throw the expectation out there and let the network respond if it thinks that what you're doing is valuable. So the result that we have, if we can do all of this, if we can efficiently hash most of our different conceptions of cryptographic time, most of our different tick chains into each other's ideas, is that we're going to get a very helpful property. So let me just explain what's happening in this diagram here. This along one side is kind of a normal series of ticks. This could be, for example, the headers of the Ethereum network, or it could be the ticks in your centralized link timestamping provider like guardtime or whatever your reference point is, universal.
00:09:58.966 - 00:10:34.214, Speaker A: Hash time is entirely relativistic. It has no concept of an absolute state of things. It just tries to be very greedy and collect all of the possible relative information about what's available. So, for example, inside of these various Merkel trees on this particular hash chain, we have all kinds of different data that's been submitted, and some of that data is the ticks of other chains that I've colored in yellow and green over here. So, for example, if this is Ethereum, let's say this could be guard time up here. This could be bitcoin out here. We have some additional data that someone's doing a traditional proof of existence on.
00:10:34.214 - 00:11:43.580, Speaker A: Here. Hopefully, we have ipfs up and running so that we've got the vast majority of data on a system like this addressed by hash. And so something like a major news event or anything that happens in real time is being included into this structure. Out of this, we start to get some very important timing information, because if you have a normal policy of data, all data everywhere, being stamped into a tick chain, then what you end up coming away with is the assumption that the earliest produceable receipt is in fact the time that content was created. Now, obviously, this isn't true historically. If we only start building the system now, then the earliest available hash of the napoleonic wars will not be the time that the napoleonic wars happened, but in general, this will be true going forward. So if you can think of a detailed description of a current event that has enough features in it that someone would not have been able to guess in advance that that news article would be written in that exact way, then the earliest example, the earliest time receipt that you can get, the earliest stamp receipt that you can get of a news article covering that event is a reasonable cryptographic proxy for the time that this actually happened.
00:11:43.580 - 00:12:15.160, Speaker A: So you start with the earliest event of something. For example, it could be this data here, and the earliest receipt that's available. You can just produce this in a normal challenge response format by just throwing out a reward to the network. Now, you can ask, what happened before the earliest available receipt of this. And this turns out to be incredibly useful in a cryptographic context. So a simple example would be, we've talked about proof of stake, and the problem with long range attacks. One of the problems with long range attacks is that you have no conception of time.
00:12:15.160 - 00:12:59.298, Speaker A: If you're online on the network, you know what's happening live, and you know that, for example, this person over here was not part of the consensus at this time. But then the owners of that stake moved their coins and then only later sold their keys. And after those keys were available very cheaply at very little economic cost, then the attacker acquired them and then produced. This is a time difference. And what this allows you to do is you still have the subjectivity of any proof of stake system, but if you have something like universal hash time set up, you can take the trust out of the subjectivity. So let's say that you've been offline for a period of eight months, and you want to figure out what the correct consensus set is. Now, you could find someone that you trust.
00:12:59.298 - 00:13:24.560, Speaker A: You could try and accumulate trust through a series of social networks or trusted websites. But what you could do instead is you could say, I know something that happened four months ago. So let me Google for something that's stored on ipfs that happened four months ago. That's an article that described this. Okay, I found this. Let's find the earliest stamp receipt I can find for an article describing this event that happened four months ago. Okay, it's this one here.
00:13:24.560 - 00:14:29.538, Speaker A: Now, if I come across a chain in proof of stake that's claiming that it initiated four months before that, I can issue a challenge to those validators on that chain, and I can ask, if what you did when you signed these blocks and from this consensus was before this event four months ago, then why don't you have a hash of this consensus somewhere upstream, somewhere in the past hash cone of this receipt that I've produced? Because any possible news article that describes an event could only have been created after the event, which marks kind of a barrier in one direction at time. So if something happened before that, it becomes unreasonable, even on your own personal basis, before you check anything in the network. To think that somebody would have produced this consensus and would not have hashed it somehow into the past of this particular event. That's one example. There are numerous other examples of how this becomes cryptographically useful. I'm running out of time, and I'm going to stick within that. So you can come up and ask me questions about this later, but I'll just give one other one very quick.
00:14:29.538 - 00:15:36.722, Speaker A: Let's say you're producing some live news footage, and you want to produce a bound on the idea that this news footage was faked, and say that if it was faked, at least it was faked in real time. What you can do is you can take a little monitor, just a little display, put it right on top of the camera, have this hooked up to some tick chain that's producing content relatively often, say Ethereum, it's coming every 15 seconds or so, and then every few seconds on the live broadcast, as the news photographer or whoever is present in the scene looks over to the camera. They just read a few of these digits off, just enough that it's statistically unlikely that they could have pre recorded this. So this is a recent hash. Say something from here. You read off the hash into the data, and then the video hopefully, is being stored into something like ipfs being hashed right back in, which means we now have this specific window in between this tick and this tick that we know that the video was actually created or in some sense rendered or modified. And this gives us a very narrow window and allows us to, in some sense, prove that the video was created or faked in real time, which is probably harder.
00:15:36.722 - 00:15:38.740, Speaker A: So that's universal hash time. Thank you.
