00:00:17.210 - 00:00:45.226, Speaker A: All right, shall we begin? Let's do it. So, my name is Juan, one of the people behind ipfs. And today I'm going to talk to you about data and data structures. So the talk is structured this way. I'll give you a brief introduction to ipfs, actually, how many people here know already what ipfs is? Wow, awesome. That's a great distribution. So that'll go really quick.
00:00:45.226 - 00:01:41.262, Speaker A: We'll cover the iPLD data model, and then we'll talk about use cases and examples of IPFs and data structures and so on. All right, so IPfs, another name for it is the distributed web, or the permanent web, or the Merkel web, in honor of Ralph Merkel. And in a sense, it's this kind of evolution of how the Internet and the web were structured. And I think everyone here, both coming from blockchain history to through Ethereum and a whole bunch of other interesting technologies that are happening right now, sort of see what's going on, or what has been going on for the last three years as this total reinvention of how to do distributed computing and distributed networks in general. And so this is, of course, layers on top of the old Internet and so on. But what's really happening is that we're taking the web applications of the Web 1.0 or Web 2.0
00:01:41.262 - 00:02:33.040, Speaker A: world, and we are separating them from their physical location in servers and so on, and distributing them across different hosts. So IPFS is a protocol to upgrade the web because the web has some problems. I won't go over these. I think most of you are familiar with them. It's inefficient, doesn't work offline links break central points of failure and so on. And the gist is to try and create what would the web look like if you took a Merkel tree or a Merkel chain and put it underneath the web itself. So what would happen if you gained immutability for distributing content on the web? You can think of data structures like Git and the amazing power of distributed computing that you get out of that, or distributed version control.
00:02:33.040 - 00:03:25.066, Speaker A: You can think about Ethereum and the amazing powers of contracts and running programs in a distributed sense. And of course, before Ethereum, bitcoin and so on, all of these are Merkel trees. And what ipfs really is is this massive Merkel forest. That's kind of like the intuitive description of ipfs. It's saying, let's write one transport protocol to layer underneath the web and other protocols as well, and build this distributed data structure transport that is all Merkel addressed. Cool. So imagine being able to link across different Ethereum chains, and being able to link across bitcoin and Ethereum, and being able to link to git repos and be able to link to BitTorrent torrent, or being able to link directly into a specific commit inside GitHub.
00:03:25.066 - 00:04:25.966, Speaker A: So you could create a contract and say whoever patches this commit or something successfully gets some money or something. And in the IPFS world, which is a world on its own, there's a whole bunch of different protocols. And we have this view of the world that looks a little bit like this, with a whole bunch of different sections for these protocols, kind of of on top on the lower level network. And this of course all sits on top of IP, although it doesn't need to, on top of transports, on top of different ways of doing routing. We want to layer what we're calling iPLD, which is the Merkel Dag or the Merkel web, as this common data structure that we can all use for expressing our data structures. It's kind of the same idea as the semantic web, but instead of just having an object definition, imagine if the object definition linked between objects with hashes. That's the heart of ipfs.
00:04:25.966 - 00:05:41.210, Speaker A: That's like the core. What happens when instead of having a URL that points from one object to another using a location, what happens when you point using hashes? And this idea is old, it's been around for a while, but this talk will be mostly about what we're sort of loosely describing as the Internet of data or Internet of data structures to write on top of iPLd. And so you've probably seen something like this, where the IPFS model is, you take the original HTP world of mapping a DNS name to an IP address which looks kind of like this, where you're resolving through the network to a specific host, and you instead say, hey, let's just take the hash of the content itself and use that to address the files. And it looks instead of that, you get something like this where anybody in the network that has the file can serve it to you, right? This is all super intro ipfs stuff. And in a sense, what's really going on underneath the hood is that hash is a pointer to a directory. You can retrieve the directory because you can ask the network for the directory. People can return the directory to you, you can check the content, make sure it matches the hash, so that way you don't have to trust anyone.
00:05:41.210 - 00:06:39.142, Speaker A: And within that you look for foo. And what that means is that inside that object foo is a link that is pointing to another hash and you use that to resolve for the next step and so on down, right. This is taking the idea of a file system with inodes, but replace an inode with a hash and of course this is Merkel linking and you get full path traversals down this kind of graph. So if you imagine a blockchain layered like that, you would have a massive path going like parent, parent, parent, parent, parent and so on down, right. But imagine you would be able to index directly into a specific block and be able to go down into the transactions and so on. And so the ipfs link sphere, I guess is that you first have content addressed links where they start with ipfs, then you have a hash and then the rest of the stuff. And by the way, those are shortened hashes.
00:06:39.142 - 00:07:19.850, Speaker A: I haven't yet found a way to compress information magically. That's supposed to be a shot 256, but it's shortened. So it sits here. And yeah, of course we have the schema identifier if you want to use it. But we recommend that you don't use the scheme identifier because the way we look at the world, the regular w three C based scheme identifier broke compatibility with Unix. We're making everything so you can layer it directly on top of any posex machine, so you can mount it directly, so you can mount ipfs and you can fetch data and write data to the network with standard ol style applications. You don't have to teach them to speak over some other protocol.
00:07:19.850 - 00:08:02.840, Speaker A: And on top of the merkle linking, which is sort of like a Uri. And I say Uri with quotes because we do prefer people not to use the schema identifier. We'll have everything working and resolving with just straight up paths. On top of that we layer what we're calling also Mazieris links. This is for David Mazieris who author of Cademlia, author of Stellar, author of SFS Way before that. And he came up with a great idea in SFS. I won't go through the whole thing, but the basic notion here is that the way you achieve mutability in ipfs is that you use the hashes of public keys and you use those to resolve for pointers that have been signed with a private key.
00:08:02.840 - 00:08:37.490, Speaker A: It's explained better somewhere in the web. But there's more interesting stuff here. But it's a very subtle idea that gives you a way to achieve naming. And this is naming that is not human readable, but it's a way to achieve naming that's cryptographically addressed or cryptographically mediated instead of through some central authority, right? And on top of that mutable link, then you can layer names. And so here's the old style DNS world. We work exactly with DNS. So you can add a text record into your domain, and now you can resolve through ipns or directly to ipfs.
00:08:37.490 - 00:09:17.102, Speaker A: And of course you could have Ethereum names the same way, right? And so you can imagine resolving Ethereum names directly into ipfs content the exact same way. What's amazingly interesting about these kinds of names is that you no longer have to have any machine running yourself. You can create the content and add it to the network. You can create the names and the key names and sign contents and distribute it to the network. And then you can register some name and point it to the hash of your public key. And now you can just disappear, just add content to the network and walk away. And if the network will continue serving your stuff, and that's an asterisk there, everything will continue working.
00:09:17.102 - 00:09:44.114, Speaker A: And that's something that's very different. You don't have to maintain your own infrastructure. So this is often non obvious. So I'll kind of go through the IPFS content and replication model. This is kind of like what most people don't expect to hear. They're like, what? But it makes sense to go through. So there are three important points that bear mentioning here, other than a whole bunch of others that you probably can assume.
00:09:44.114 - 00:10:28.830, Speaker A: But number one is that we want ipfs to be able to go as fast as the underlying network. So we need to allow users to dial between efficiency and privacy. So as you know, systems like Tor and IGP and so on that are focused around privacy have to do a whole bunch of work routing packets and moving them around, and you spend a bunch of bandwidth hiding the traces of people's accesses in the network. And this is how you achieve privacy. But that's not fast. So you're trading off the speed of transfer there to gain some privacy. But the users of ipfs are varied.
00:10:28.830 - 00:11:15.038, Speaker A: Some people really want that use case and layer ipfs directly over Tor or I twop, and some users don't care at all about that. They're using ipfs inside data centers or they're using it in some other way and they really want it to be as efficient as possible, right? Like do you really need to route through tor to go from your computer, your laptop to your mobile phone in the same room? Maybe not. Or maybe you do, it depends on what kind of home you have. Another point here is that ipfs only downloads explicitly requested data. You do not download other people's stuff. And this is an important piece from a legality perspective, right? So there's been a whole bunch of problems around peer to peer systems where they download other data as part of the peer to peer algorithm and they end up downloading stuff. That's illegal.
00:11:15.038 - 00:12:09.874, Speaker A: This prevents the adoption of these systems in companies because companies just cannot afford to do that. So in ipfs, those are policies that are expressed and that can be added on top, right? So if you want to organize a cluster that moves around and shares data and so on, you can do that. But that's a policy that is layered above ipfs. So there's a strong commitment there of being able to say, look, you can use ipfs and not have to worry about what other people are adding to the network. And yeah, so IPFS is able to follow what the user programs. And so these policies, we haven't done as much work here, we'll be doing some interesting stuff there to be able to express how you might trust other keys and trust the content from other keys and being able to give people capabilities to add stuff to your node. So yeah, on this, only downloads explicitly requested data.
00:12:09.874 - 00:12:44.978, Speaker A: So this is a huge surprise for most people because they're like, wait, what? You have this distributed file system, it's supposed to be peer to peer. And if I add content, how do I back it up? Right? What if I disappear from the network? It falls off. And the idea here is that when you add content to the network, you're explicitly publishing something. So the rest of the network has an option. Either they spend energy maintaining this online or they don't. And if they do, it's because they care about this thing. So if they don't care about what you have to say, because what you say is not that interesting, then you can just pay them to care.
00:12:44.978 - 00:13:49.574, Speaker A: And this is where something like Falcon comes in. And so HTTP maps to IPFs and AWSs SS, three maps to falcoin or swarm or really AWS and Windows Azure and so on, right? So how you maintain stuff in the network is a separate part different from how you move stuff in the network. So IPFS is strictly about how you address and move content in the. So these protocols around incentivized, organized distributed storage, those layer on top of ipfs. And so an interesting thought is a lot of people say, well, how could you ever hope to compete with something as big as Amazon and Google and Microsoft and so on, which have these massive infrastructures. And then I just kind of point this out, right? So this is the hash rate of the bitcoin network and like, the massive spike. And this is what happens when you get an economic model coupled with a very easy to enter market.
00:13:49.574 - 00:14:37.122, Speaker A: And so somewhere along this graph, way before the knee, the hash rate of bitcoin surpassed the equivalent of the world's most powerful supercomputer. And then the world's 500 supercomputers put together before the knee of the curve. So that gives you a sense of just how insanely powerful the hash rate of that network is. Sadly, all that is going to waste. So hopefully we'll get proof of stake working correctly so we don't have to waste this. But when you think about this model and you apply it to doing something useful like storing content, you can get an enormous amount of storage wired up into the network. So you'll see, mark my words, in the next year and two years, you will see enormous distributed systems with storage popping up into the network.
00:14:37.122 - 00:15:37.240, Speaker A: And they're already getting started, but they'll come. And so you'll have something that looks like this, which are the bitcoin mines, but for storage. All right, so now that I've kind of made a claim about the future, let's have a dose of web reality today to cleanse our minds, right? So the web here, and these are strictly kind of like Web 1.0, Web 2.0 companies, or web states in general that I've put up there. These applications kind of run your life, right? So everything that you do nowadays revolves in some way around these applications, right? So your personal communications, your work, how you learn, how you get stuff, how you buy food, everything is now mediated not only through the Internet, but through specifically web applications. And this means that all of your capabilities are tied to specific organizations maintaining specific infrastructures online.
00:15:37.240 - 00:16:52.720, Speaker A: It's kind of scary, right, because those could disappear at any moment in time, or those could just stop wanting to serve you or blah, blah, blah, blah, right? But these, I like pointing these out, especially in this crowd, because this is kind of the competition, right? So if we want to push this very different model of computation, very different model of storage, and actually upgrade how the web works, we have to work equally well, at least and ideally better than these systems. In fact, not only do we have to work equally well, ideally better, we have to have much higher performance, or none of these people will adopt this stuff, right? And so this is what I mean by a dose of reality. And that when you think about the data on the web today, you have these massive infrastructure providers that have huge high performance databases. And sort of the model is that people have these business logic services and they have to maintain them. And this is where perhaps these systems can come in and change the model, where people don't actually have to maintain infrastructure themselves. It becomes a lot cheaper if they don't have to do that. But this is the competition, right? This is a diagram from Amazon itself.
00:16:52.720 - 00:17:59.320, Speaker A: Think about how many machines here are involved in just one application. This is kind of like if you're a legit application, this is what you do. You have like a DNS resolution machine connected to a CDN, connected to a bunch of static content buckets, connected to a whole bunch of web servers that auto scale, connected to routers which hit your application servers and then going all the way to the databases. It's madness, right? And this is all for optimizing really fast accesses on the network. When a user hits your web page, they have to get the stuff within a second or it's game over, right? They'll leave and they'll go somewhere else. And so this is like a beast lying in the center of the backbone to just be able to manage that. And we have this enormous explosion of databases, right? And so the constraints are around being able to do billions of transactions per second, handling billions of users, millions or hundreds of millions of simultaneous users for the big ones, sub 100 millisecond latencies, like from the backbone to the user, or ideally just from the user to the application.
00:17:59.320 - 00:18:43.874, Speaker A: And we're talking about terabytes, petabytes and exabyte scales. So terabyte scales if you're a small company, exabyte scales if you're basically Facebook and so on. And of course, so when I hear blockchain technology, how is it going to deal with this? Right, but here's the magic. Right? But here's the magic, right? So the thing is that it's not about matching the capabilities today. It's about proving that those capabilities can be achieved, but complementing them with a whole bunch of capabilities that weren't there before. So stuff like the idea behind a blockchain is being able to do multiparty computation that is verifiable and trustless. You don't get that at all today in Web 2.0.
00:18:43.874 - 00:19:34.322, Speaker A: Being able to do trustless ledgers, like being able to account that things are actually happening, timestamping, being able to run contracts that are verifiable, that you just write the source code out there, put it up there, and it just runs on its own and you don't have to maintain it and nobody has to do it. Being able to write decentralized and distributed applications, things where you write them, once you sign them, drop them into the network and disappear, and the people can carry them on, you could disappear as an organization and company, and people could continue to use those applications. These are real capabilities that you give people that you cannot take away. And that's extremely interesting. That's where there's a completely unfair advantage compared to the web 2.0. Right? And so we're talking about building, taking data and code and execution in a completely different verifiable model. And of course, being able to do secure and encryption in a way that the Web 2.0
00:19:34.322 - 00:19:56.570, Speaker A: people can't, because a lot of web 2.0 relies on advertising and so on, which means that they can't really do end to end encryption. So that's a huge advantage. Right? Because we don't have to deal with that. We can just do end to end encryption for users. We don't need users data at all. And this is a strong reason to be able to move in this direction.
00:19:56.570 - 00:20:08.826, Speaker A: Cool. Let me check timing, because timing. All right, 5 minutes. Sweet. So that was like the interlude. So Web 3.0 is kind of about having these databases talking to each other with data behind the scenes.
00:20:08.826 - 00:20:36.178, Speaker A: And with web 3.0 is about taking the logic and the data itself and putting those into the network and allowing those to communicate and making the actual hardware secondary. All right, that was the interlude. Okay, I'll have to rush through this stuff. 5 minutes, but we'll see. All right, so iPld, this is the heart of IPFs. It's a common format for hash chain or distributed data structures based on merkel trees.
00:20:36.178 - 00:20:57.626, Speaker A: And so what I showed before with these files, these aren't actually files. So when you add something to ipfs, it kind of looks like this. You add all this stuff. But these aren't files. These are actually nodes in a graph. And these nodes in a graph, it's stored in a format that we are calling iPLd. That is basically something like JSON.
00:20:57.626 - 00:21:27.910, Speaker A: It's not exactly JSON because it's serialized to be fast. But the whole point is you have a very flexible data model, so you can take entire APIs of today and just dump them straight into ipfs. You can take some data API that you have and just straight up import all of that into ipfs and mercurialize the whole thing. That is not perfect. And you have to work hard to make it really a good distributed application. But that's kind of like step one. And so we see as a new thin waste of the Internet, the Internet of data structures.
00:21:27.910 - 00:21:57.534, Speaker A: And it gives you Merkle links that are secure and immutable. It gives you Merkel paths, meaning you can resolve through the graph. They're sort of universal and they're kind of UrIs or URLs. As we said before, though, it's not location based, right? I mentioned here URL, because most people are familiar with that term, but it's not actually location based. And in terms of serialization, you can do anything you want. You can use JSON, protoboth, XML, RLP, or whatever it is that you use. You can use a serialization format.
00:21:57.534 - 00:23:29.280, Speaker A: Underneath the hood, though, there is a canonical way of describing which serialization thing to use, so that everyone has the same thing. And so if you had something like this in JSON, where you outlined the followers of a user this way, this is kind of like mush, right? What does at Vaniver Bush mean? It's some user somewhere, but you don't know what context that comes from, right? You have to know that this would be Twitter or something else just from the endpoint that you're accessing this from. But what if these actually linked to content, addressed things, the resources were actually based on hashes? Then you don't have to know anything about where you're accessing at all, because the content itself tells you what it's about, right? And with iPLD, you can do yaml, you can do whatever format you want and so on. So the whole point here is to build something as easy to use as JSON, but when you merklize it and you turn these normal graphs, you should be able to have the exact same architecture of your data, but where before you would just have some strings that you then would have to look up in a database. Here you have hash links, and so you can resolve through the hash link. So here in the second layer, you're going through the hash and then followers, meaning that you're accessing into the JSON object. So you're like touching a JSON object and then accessing through it to get another piece of the data.
00:23:29.280 - 00:24:02.460, Speaker A: And you can do whatever, right? So you can take somebody's followers, go followers to get, pull that array out, and then go like slash zero to pull out the first entry. And now you get something. And this is resolving through Merkel links. The idea there is you would pull one object out and then you would look into it, pull out another link and resolve it through the network and everything is integrity checked. So you can just dump all of this content into the network and anybody can serve it to you. And you don't have to worry about that, you have to worry about it in terms of privacy. But that's a whole different question.
00:24:02.460 - 00:24:25.466, Speaker A: And anyway, so you can model things, you can pretty much model anything you want. You get to be able to annotate links with other data. Here's what a directory would look like. You could do like version data structures. This is for example a git commit and so on. And so these will be completely native in ipfs. You'll be able to write all these data structures and have them write on this transport, right, like the forest thing that I described earlier.
00:24:25.466 - 00:25:20.062, Speaker A: And so this is really how we start doing Web 3.0, where we take all these data structures and these APIs and model our applications around content that we are just putting into the network and addressing through content addressing and key addressing. And so in a sense, when you think about modeling your application and you think about the data model, do I have users, do they follow each other? What are all these relationships? You can take those direct objects and put them straight into ipfs. Like you don't have to go to a database at all, you can just add them straight to ipfs. And what you gain is that when an application pulls those in, if there's nothing that has changed, nothing has to be updated. So you beat the speed of light. Because if I'm using an application here and I request some set of objects and I pull them down through the network and I have them locally and I have to fetch them again, normal HTP would say, oh, go and talk to the network and see if it has changed.
00:25:20.062 - 00:26:02.490, Speaker A: But with ipfs we can be like, well, no, I have the hash, I have the content, it's here already. We don't have to go to the network. And of course you can do this with all kinds of legal records and so on. Legal records is a great example of why people want to use blockchains, kind of like in the real world, it's to do careful timestamping of legal documents, right? So you can do all this. And so in reality we're building not exactly the web, but it's really more like a strong mesh that is secured. You can think of it as a secure web where the links can't break because they're constant at rest. So you don't have to maintain infrastructure and worry that your link now is slightly different and so everything will fall apart.
00:26:02.490 - 00:26:55.514, Speaker A: You just create content, you link it securely and you just release it into the network. And so I mentioned that iPld thing is a spec in progress. Some of the interesting stuff that we're doing is we are coming up with a right way of doing traversals through the graph. So being able to express, descending down a path in the graph, things like being able to address one level deep or everything underneath it, or being able to look into something, but then something more interesting. So this last expression would be able to, in a huge graph that represents a movie, being able to walk down the first path and retrieving the first set of blocks in. So that with that you are able to just pull out the first few things that have the data and then start showing the user the beginning of a movie. Right? So being able to express these things this way is extremely useful for replication protocols.
00:26:55.514 - 00:27:19.430, Speaker A: It's extremely useful to be able to point stuff out in contracts and so on. So this is kind of an interesting thing. Another one here is where you're able to embed one expression inside another expression. So if you like this kind of language and stuff, come talk to me, because getting those languages right is important. Cool. So last section, use cases and examples. So this might be the most interesting to you.
00:27:19.430 - 00:28:02.694, Speaker A: So ipfs, a lot of people are like, okay, well, what is ipfs for? What do you use it with? What is this thing? And they want me to tell you the specific set of users that are only going to use it for one thing. And the thing about ipfs is that it's a transfer protocol meant to help the web, right? And so what is the web used for? Everything. And then people just say like, oh, you haven't thought about this enough. I'm like, no, I'm serious. You can use this for everything. Let me list out the reasons. Right? You can use it to do peer to peer content delivery, right? So think about a CDN, but like a distributed CDN, distributed content distribution network, you could do like a decentralized link, things where no authority determines the link.
00:28:02.694 - 00:28:41.890, Speaker A: You just add content and the content is now part of the network. What we talked about before, you can take applications, entire applications, and define them within ipfs, then give people a reference to that application as a link. They download it, they run the code, and they just do everything on their side. So it's not only the distribution of the application, it's also the definition of the application. An example here is people have written video players that go over ipfs, people have taken entire legal codes. People have made like imager style clones. People are able to do stuff and be able to share them with ipfs because these are data intensive kinds of applications.
00:28:41.890 - 00:29:16.106, Speaker A: This is the only one in this set that is not an actual IPFs application. This is a Minecraft. But people are taking Minecraft and making it so that there's links between worlds. So you're walking through a Minecraft world, and then you find a link and you walk to somewhere else, and all of that is served over ipfs. People are storing documents, blogs and so on. You can do containers and vms definition and distribution of these. You can think of these as like Merkel containers, where the entire application and the graph is defined as a proper Merkel graph, which should have been the case from the beginning.
00:29:16.106 - 00:29:55.734, Speaker A: But anyway, you can do whole package managers and distributed them this way. So we're already working on doing this to several of these package managers where we're taking all of the code or all of the actual compiled binaries and adding them to ipfs. Usually, first of all, you get a huge space savings because tons of stuff is duplicated. But then you also get to distribute them faster, because if machines in the same data center have it, then things move faster. Key addressing, archiving, backup, everything. People are like archiving all the stuff, a whole bunch of the data. Here you can archive with ipfs, and there's efforts on this now when it comes to Ethereum, and this is like the last slide, I promise, when it comes to Ethereum.
00:29:55.734 - 00:30:48.358, Speaker A: And by the way, the logos fit really nicely together. Just wanted to point that out so you can use it for off chain data, right? So the very first thing that you can think of is like anything that just shouldn't be on the blockchain because it's too big, put it in ipfs, take a link and then serve that link with your own node. But that means that anybody else can serve it as well, and it means that you can disappear and the content doesn't disappear, right? So big stuff, you can use them again to define and distribute these distributed dapps, right? So these decentralized distributed applications, you can write them, put them on ipfs, put all the assets there. People are really doing this and so on. So yeah, the code and the assets and everything, but also the user's data, this is an example of one of them. This is ours, this is our web UI for an ipfs node. All of the code for this is an ipfs.
00:30:48.358 - 00:31:19.750, Speaker A: You pull it out, you run it and it's completely distributed. This is a very cool experience when you do this and you're like, whoa, not touching a web server ever. My browser does it. Here's swarm chan, an example of a four chan style board done with ipfs and Ethereum. So you actually pay ether to be able to post. So you could do trunk based storage, as swarm was pointing out. And you can do now the two interesting things here and sort of, I'll land this talk this way.
00:31:19.750 - 00:32:01.534, Speaker A: The most interesting things where ipfs could be useful for Ethereum and are worth investigating carefully is representing the entire merkable Patricia tree state as ipfs nodes. So that you're able to directly index into the state tree and pull things out and use a bunch of ipfs nodes that may not speak Ethereum yet, but they speak ipfs. You can then start addressing Ethereum state with them and use them to move around Ethereum state, which is really cool. And you can do that to the blockchain itself. You can take the entire definition of the blockchain and just import it into ipfs and then distribute all the content this way. And so this is a blog post from Chris that talks a little bit about this. Very cool.
00:32:01.534 - 00:32:09.330, Speaker A: So you check it out. All right, so that's ipfs and data structure. Thank you. Thank you. Thanks, Juan.
