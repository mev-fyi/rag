00:00:13.690 - 00:01:27.010, Speaker A: So Whisper, there's been a fair amount of misconception as to what Whisper is, what it does, how it works and what it is in. So a lot of this talk is going to be dedicated to explaining the goals of Whisper spread. A little bit of background. Whisper started as a project, at least conceptually, about 20 months ago, so April 2013, it was devised basically as an application for doing, implementing an exchange, a decentralized exchange. So around about the time bitcoin became really famous in the price 2013, January, February, it's like oh yeah, bitcoin, I remember that from slash in 2010 or whatever it was. Yeah, that seems to be worth a bit more now. And I thought, well why don't, I wouldn't a decentralized exchange be great? We got this decentralized currency, but we got these centralized, this centralized infrastructure.
00:01:27.010 - 00:02:46.290, Speaker A: So I looked into doing a decentralized exchange and just for this as a sort of interesting thought project, wondered what a back end might be like. When I considered how it might be implemented immediately, of course I thought about what abstraction this was underneath the application, what was really going on, and is there a pattern there that could be reused elsewhere? And that really provided the basis to Whisper at the time I wanted to do it as a pure JavaScript thing. So the idea being that you would go to a GitHub site or something, download a web page which had a JavaScript portion in it. The Javascript portion would connect to a peer to peer network, something that we similar to what we now know that Alex described in the last talk. And on that it would set up what I'm going to describe to you now, and it would use WebRTC in order to connect all the nodes together. So basically you'd end up with a web experience, but the content wouldn't be actually stored anywhere singular. It would be washing around the peer network, all hosted by browsers.
00:02:46.290 - 00:04:07.226, Speaker A: So that's the background coming to Ethereum. So fast forward twelve months, and what we're beginning to see is like, yeah, we got this blockchain, we got Turing complete consensus, everything's synchronized, everything's in lockstep, and actually with a twelve second block time you can do reasonably decent communications with it. You could do a reasonably highish frequency exchange, for instance. The issue is that if you move state in lockstep, which is what a blockchain does, blockchain provides you with a decentralized service to move state in lockstep across the entire network. It's really expensive to the point where a single transaction that would be done in microseconds on a modded machine, probably nanoseconds costs, well, we don't know exactly how much, but probably no less than half a cent, and probably up to really expensive. So we don't want to use the blockchain as the answer to everything. Blockchain is an excellent answer to some problems, but it's definitely not the answer to all problems, certainly not at the moment, and probably not for the foreseeable future.
00:04:07.226 - 00:05:12.974, Speaker A: We need alternative ways of doing communication. So when we think about massively multi user, I should say MMA, anyway, massively multi user applications, and when I say massively multi user applications, I'm talking about the sorts of things that we see implemented on the web these days. So email, Twitter, but also going into things like Facebook, obviously going into things like mmorpcs, so rpgs, where you've got games based on the notion of having lots and lots of people all interacting with each other. So the sorts of comms patterns that we see are static content publication. So where you've got a single piece of information that you want, that people need to know about, maybe some more than others, but nonetheless it's static. It stays there for a very long period of time, if not forever. Another communications pattern is the notion of a connection.
00:05:12.974 - 00:06:23.490, Speaker A: So the notion of two people or two applications or two endpoints, wanting to communicate either unidirectionally or usually bi directionally, this is the sorts of things that you rely on when you use a voiceover IP application, when you use video on the Internet. And then finally the other sort of pattern that we see is this notion of transient datagrams. So these are the things that might sit behind an email instant messaging thing, where typing messages on a chat irc sort of. Twitter's a good example of this. So Twitter is kind of different to the rest, because Twitter is a publication thing, but it's a publication thing where the things that you publish are very small and the things that you publish also have an identity that you can then look up and filter efficiently. So if we just go to the datagram patterns, we see some sub patterns within the datagram pattern. So I've called them wholly directed, going to filterable global, so wholly directed.
00:06:23.490 - 00:07:05.138, Speaker A: I'm talking about where you have one or a small subset of recipients, and the notion is that nobody else is going to see this. So although most of us know that when you send an email, the server is not going to be encrypted, the server is on the way. So the SMTP servers are probably going to be able to read your email unless you've taken explicit steps to encrypt it. But nonetheless, when people send email, they generally expect it to be private between sender and recipient. Instant messaging, roughly the same, partially directed. So this is where we've got the notion of multiple recipients or a distribution list. So usenet subscription services.
00:07:05.138 - 00:07:43.354, Speaker A: And again, the idea is that there is some privacy within this group. So it's a bit like email. Again, use net, anyone can join it, but there is a notion, for instance, on forums of a password protected forum or an invitation only group, for instance, in Skype. And then finally what I've called filterable global. So this is where you've got information is actually plain. Anyone can join it. There's nothing special about sort of being able to read it, no restrictions on it, but there's so much of it, and you're only interested in a relatively small subset of that, it needs to be filterable.
00:07:43.354 - 00:08:51.586, Speaker A: So Twitter's a good example here. We use hashtags because so many Twitter feeds, we use hashtags in order to collate from each of them. Registry is kind of another example. Okay, so for static content, when we do massively multi user applications in Ethereum or the Ethereum framework, we have some piece of technology called DHT, call it swarm, whatever. And Daniel's going to mention some of his thoughts on this after this talk for real time communications. So, connection oriented between one or between a particular pairwise set of identities. One of the things that we'll probably build into the p to p framework pretty soon is an ability to sort of say, right, I'm interested in this particular node, set me up, make sure it's one of my peers, and I'm then going to actually institute a connection.
00:08:51.586 - 00:10:07.230, Speaker A: This of course is encrypted, because everything on PTP is encrypted, but other than that, it's a raw connection. You're just sort of pumping data in and data comes back out. But for the other, this is what the rest of the use cases, that's what this talk is going to be about. So the other sort of thing that to some degree whisper is designed to solve, or at least mitigate, is privacy, and in particular routing privacy, although there's been a lot of focus on everything should be encrypted HTTPs all the way. But the problem is, of course, that a lot of the time, the metadata gives away enough information that your privacy is severely hampered. Furthermore, if there is an attacker of some sort that is reasonably well resourced by knowing which endpoints are communicating. They can target endpoints, and there are other attack vectors once endpoints are known, and metadata provides this initial information that can be used for such attacks.
00:10:07.230 - 00:11:09.650, Speaker A: So really we really want to work. If we're truly serious about guaranteeing our privacy, we really need to work towards routing privacy, what's also generally referred to as this sort of dark, dark connection, dark Internet, dark whatever, darkness. It's not a good marketing term. I mean, I prefer routing privacy, but. Well, okay, so what is whisper? So Whisper is an OD combination because it handles a selection of use cases and it's not specific to any one sort of primitive communication, primitive that we've already got. And so it's difficult to really wrap your head around in the first sense. I originally called it a messaging system because it can do messaging, but actually that's a relatively small corner case of the full thing that it does.
00:11:09.650 - 00:11:56.240, Speaker A: So to really understand it, you've got to accept that it's a hybrid, it's a hybrid communication system. Part of it is messaging for sure. So it includes things like authentication and encryption in order to provide certain guarantees that you'd expect from a messaging system. But it also provides other services more reminiscent of a DHT that kind of make it muddy the waters a bit. So a couple of slides, I'm going to treat it from both of these directions so that you can sort of see how it differs from each one. It's dark, so there's routing privacy. This is done by probabilistic message forwarding, which I'll go into a bit later.
00:11:56.240 - 00:12:34.378, Speaker A: And one of the other sort of key things is that it's oriented via key ease, not destinations or origins. So this is something to bear in mind as you're thinking about what this is doing. So origin and destination really just, it's dropped completely. It was never a thing. And this is why it really doesn't fit in with the traditional notion of a messaging system. They're not first class concepts in Whisper. Subject key, however, is a first class concept.
00:12:34.378 - 00:13:20.010, Speaker A: And I'll explain a bit more what I mean about that later. So is it a DHT, is it a distributed hash table? Kind of. If you treat it as a DHT, what we can say is it's a multi key DHT, which is to say each entry in the hash table doesn't just have one key, it has many keys. Okay, so it's like a composite key. It can have arbitrary numbers of keys. It's also multivalue, which is to say there's not a one to one mapping not a one to many mapping between the domain and the range. So it can have many keys that are the same, that each reference different values.
00:13:20.010 - 00:14:11.222, Speaker A: And when I say many keys, what I actually of course mean is many composite keys, many of the same sets of keys. And finally, it's transient, the entries are transient, so they stick around for a bit and then they sort of go away. They have an expiry date, basically. So. Okay, it's kind of a DHT, is it? How about, does it fit any better with a datagram transport later? A messaging system? Well, yeah, it's got the notion of broadcast, multicast and unicast. They're not really first class entities in the protocol, but nonetheless they're very well supported. And each one through being a broadcast or a unicast or a multicast, it's necessarily secure and authenticated, and it's also asynchronous.
00:14:11.222 - 00:15:17.122, Speaker A: So treated as a datagram transport layer, you can fire off a datagram, you can go away, you can go offline, and there's a fairly large probability that it will be delivered, assuming that your time to live is sufficiently large such that the other node comes online before your message dies. It's got some features that make it not impervious, but resistant at least to a denial of service attack or a spam attack. So methods bear these measures. One of them is a proof of work attached to a particular message or communication record. Another is what I've called good behavior incentivization, which basically means that peers should try to forward messages which are most valuable to their peers. And this is incentivized. I'll go into it a bit later, but it's basically incentivized by saying, right, well, every minute I'm going to kick off the peer that is noticeably least useful to me.
00:15:17.122 - 00:15:51.206, Speaker A: So if you're all basically the same sort of usefulness, then I'll probably keep you all. But if one of you is noticeably underperforming, we can do statistical modeling to get that. Then I'm going to kick you off and replace you with either a peer chose at a random from a registry, or one of my peers. Peers, or one of maybe your peers. I'll find another peer and I'll replace you. Next important sort of tenet of this is that we don't deal with endpoints. Endpoints are dealt with at the P to P layer.
00:15:51.206 - 00:16:06.210, Speaker A: So what P to P gives us is a mesh network. So we were chatting about this earlier. This sort of comes into this whole how do you do a lookup to. We don't deal with endpoints. We don't care about ports and ips. That's abstracted far, long time ago. What we deal with is identities.
00:16:06.210 - 00:17:12.822, Speaker A: So when we say if we ever use the notion of recipient or origin, which we don't really as a first class citizen, but when we do, what we're talking about is an identity. We're not talking about anything that maps onto anything physical, because as soon as we get physical, we run into problems with routing privacy. Another aspect of whisper is it's configurable. So when we take this notion of privacy, if we maximize privacy, at least at the moment, I don't know, maybe there's going to be some super awesome improvements in computer science and they're just going to solve this completely. But at the moment when we maximize privacy, we sacrifice efficiency. If you've ever used any privacy preserving tools, Tor, freenet, whatever it is, you'll notice that these aren't as fast as the services that they seek to replace. So there's necessarily, at least at the moment, a trade off.
00:17:12.822 - 00:17:46.334, Speaker A: What whisper provides the user is to make that trade off configurable. So sliderbar on the one end private, completely private. Nobody knows what it is that you're doing, but it's slow. And on the other end, maybe a sufficiently well resourced attacker might be able to have a guess at what you're doing, but it's much faster. The next tenor is that it's topic based. This is when I was talking about subject key before. So you don't watch out for messages that are addressed to you specifically.
00:17:46.334 - 00:18:23.498, Speaker A: That would again compromise routing privacy. Instead, what you watch out for is the sorts of entries in this DHT or messages that are floating, washing around the network that look like it's the sort of thing you're interested in. Now, how do you say? Well, it's the sort of thing I'm interested in. Well, there's an API, I'll get into that later. But basically each entry has a bunch of keys. As I mentioned before, these keys are derived from topics, so they're actually just a hash of the topics. And topics are just arbitrary pieces of data that describe something to do with the message.
00:18:23.498 - 00:19:01.434, Speaker A: Now, maybe it's only something that you know and that your intended recipient knows. Yeah, so maybe, for instance, if you want to communicate with an intended recipient, what you do is you hash your public key and hash their together with their public key. And this gives you a topic. And this topic is sort of a unique identifier that's unknown to anyone outside unless they can guess that these two particular people do want to indeed engage in the conversation. So if they know that you two want to engage in the conversation, they'd be able to guess this. But otherwise it would just be a random hash, a random topic. Other examples of topics are things like application name hashed with particular parts of application.
00:19:01.434 - 00:19:47.154, Speaker A: For instance, application name IRC, particular parts of application, particular chat room, ethereum, Dev. Taken together, those are two topics. You could even hash them into one single topic and then you can then look out for these sorts of messages. Or put it another way, they get indexed into a global DHT and you can look out for any values that have that index. It's secure. This is important. This is something that I shouldn't have to say, right? Protocols should be secure by default, but unfortunately many, many are not because they weren't designed with that in mind at the beginning.
00:19:47.154 - 00:20:21.650, Speaker A: I don't know, maybe they didn't evolve especially fast. And now I have to point out that yes, it's secure. So when we get to the difference between unicast and broadcast, so this notion of I want to send a particular identity, this information, versus I want to send everybody this information or everybody who's interested anyway, it's the difference between encrypting it or not encrypting it. That's how it should be in email. It's the difference between selecting two or not putting two in. Well, I wouldn't really make sense for email, but you get the point. It should be this.
00:20:21.650 - 00:21:02.240, Speaker A: It's not in present technologies too often, and it should be. So it's this by default. It doesn't have any other way of differentiating between unicast and broadcast. If it's broadcast, it's plain, if it's unicast, it's encrypted. And of course it's encrypted with the public key of the intended recipient. If it's a multicast, we have kind of still working this out, but the basic idea is to pre distribute on an individual session key for each of the individual intended recipients. They then remember that session key, and when this message comes up, they can decrypt it with the session key.
00:21:02.240 - 00:21:31.642, Speaker A: And if they want to send to everybody else, they of course encrypt with the session key and mail it out. It's authenticated as well. It's like this is another really important thing that should have been in there in the first place. It should be there by default, but all too often it's not. Well, in Whisperer it is the difference between it being anonymous versus it having an origin is the difference between it containing a signature. That's how a signature is the only way. Sensible way of giving it an origin.
00:21:31.776 - 00:21:37.286, Speaker B: Well, no, because there's the plausible deniability.
00:21:37.478 - 00:22:09.190, Speaker A: I'm getting to that. I'm getting to that with the exception. So the signature will be signature of something not necessarily the centers for you. Okay, so what isn't it? It's not point to point, right? We're not dealing with a point to point connection here. That is a use case for some things, but it's not what Whisper is designed for. That's what some other subprotocol can do. It's not high bandwidth.
00:22:09.190 - 00:22:39.360, Speaker A: High bandwidth is important for some things. It's less important for the sorts of use cases we have for whisper. For Twitter. It doesn't matter whether your tweet gets distributed to the person who wants to read it. Well, once they find out about it in a microsecond or 5 seconds, it doesn't matter. You're not powering out through with 5000 tweets a minute. Well, I guess some people do, but they're probably sad, lonely people you don't want.
00:22:39.360 - 00:23:28.122, Speaker A: It's not low latency. Again, it's not a big problem for the sorts of use cases we're dealing with. It's not application level. This is not designed for one particular application. It is an abstract communications layer for doing a particular pattern of communication that we see a lot, but that hasn't been thought of particularly, at least in these terms. Most of the mmas, Massimili multiuse applications that use the sorts of things that this could address actually use it via a server's actual table, like using SQL or whatever. They actually store particular entries in the thing and then everything goes through a server level piece of software which is backed by a database.
00:23:28.122 - 00:23:59.290, Speaker A: So this is kind of getting to the point of a fast real time distributed database, but it's a fast real time distributed database for some particular use cases. Nonetheless, it's not an application level thing. So it's not an alternative to email. So that's how it differs from some things like bitmessage for instance, and it's not connection oriented. So there isn't this notion of having an ongoing connection. You can do that. So you can have a session key and you can set up a session.
00:23:59.290 - 00:24:30.450, Speaker A: It can be placed over this, but it's a fit only for one or two quite specific uses. Okay, so let's get on to routing two routes to routing. I was tempted to say two routes to quite a shoehorn. That one isn't. So we can either do it passively or actively. If we do it passively, we give away much less of our privacy. So passively.
00:24:30.450 - 00:25:12.810, Speaker A: Alex was mentioning some of this in the last talk. So this is where we have this peer set. These peers are just throwing messages at us, throwing entries in the DHT at us, and most of the entries we're probably not going to be interested in. So some peers will probably be closer to the sources of messages that we are interested in than others. There will probably be a difference in the distribution of the likelihood of getting a message that's interested in a difference in that distribution for each peer. So this is where we say, right, well, if you're a peer that tends to give me messages that I'm just not interested in, or maybe messages that are old. So that's another way of not being interested in a message, maybe you've already received it from another peer.
00:25:12.810 - 00:25:41.142, Speaker A: If that's the case, I'm going to kick you off. I'm not interested in you from what you've got to say. I'm going to move to this other peer and give them a chance. That's a passive way of doing it. And eventually over a sufficient enough time, and we need to do modeling, of course, to work out what this time period will be. Over a sufficient period of time, you'll eventually arrive at a peer set that more or less probabilistically delivers you messages that you're interested in the other way of doing it. So that's kind of like evolution.
00:25:41.142 - 00:26:24.386, Speaker A: The other way of doing it is active. This is kind of like learning. So you got evolution to evolve particular sort of traits, particular ways of thinking about things, and then you've got sort of learning to actually learn skills. So it's kind of like talent that you're born with stuff that you learn. So active is where you actually tell your peers, I'm not going to kick you off or anything, what I'm going to do is ask you to deliver this sort of stuff, these sorts of messages, this portion of the DHT stuff that roughly matches this pattern. Now, if you do that, you're going to be giving away a bit of what you're after to that peer. So what we do is we don't ask for explicit entries because that's too specific and we don't need to ask for explicit entries.
00:26:24.386 - 00:26:44.238, Speaker A: What we do is we say, right, here's a mask. Yeah, I'm going to go into this slide. When I say a mask, who knows what I'm talking about? Like a bit mask. A few people. So the notion is that you've got a topic. A topic is a. Actually, I think it's 32 bytes, 32 bit.
00:26:44.238 - 00:27:07.670, Speaker A: So it's got. It's like 010011. There you go. 32 of these zeros and ones. I'm interested in a particular topic. Yeah, because it turns out to be the topic of someone that, I don't know, tweets, interesting messages, or a particular hashtag. It represents a particular hashtag that I'm interested on the Twitter dap.
00:27:07.670 - 00:27:36.670, Speaker A: Now, I could say to my peers, hey, this is what I'm after. This particular set of series of zeros and ones, this particular topic. Now, if I do that, they know I'm interested in whatever that hashtag is. And that hashtag, I don't know, might be smiley kittens, and I might be really, like, I don't want anyone to know I'm into smiley kittens. So what we then do is we form a mask. Now, a mask is just another one of these things. It's another 32 bit series.
00:27:36.670 - 00:28:14.074, Speaker A: It's mostly zeros. So it's like zero, zero, and then maybe a one, and then lots of zeros, and maybe another one and zero, and then all the rest zeros. And what this does is it says, ignore these bits. So these now get set to zero, right? We multiply them, but we ignore. But what we do is we don't multiply the ones that are above a one. Okay? So now all these are zeros, bitwise multiply, except for these, and we provide both of these. So what we're doing is we're hiding most of the information because they're all set to zero.
00:28:14.074 - 00:29:07.274, Speaker A: So it's like getting a combination lock, and then when you've locked the thing, you're only leaving maybe one or two of the numbers there. The rest you're just resetting back to zero. And with only one of the two numbers left, they can match it against all the various other combinations, and maybe there'll be a few messages that match, and one of them will probably be the one that you're after, and that will get forwarded to you, and it won't give away that you necessarily have to smile the kittens, because there might be another one that's like fierce looking dogs, and that's a bit of a different message, but it still has a one in this position and a zero in this. Yeah, a zero in that position. The rest of the bits will be different, but then your peer will never know which one of the two it is. So that's masks. That's a way of telling your peers what you're after without giving away actually what you're after, or increasing the probability that you'll get what you're after without giving away what you're actually after.
00:29:07.274 - 00:29:54.780, Speaker A: And that's a way of rooting, of getting things to be rooted to you. What they risk if they don't do this is disconnection, as I said before. Now, how do they determine which messages should come to you? So I went over the interesting topics. So you mentioned which topics you're interested in. They tend to root those parts of the DHTs to you. The other two, and things that should influence whether you get forwarded a particular entry in DHT is the time to live. We prefer to forward messages that have a shorter time to live because they've obviously got less time to be distributed across the network before they die and everyone drops them.
00:29:54.780 - 00:30:24.210, Speaker A: The other thing is to make sure it's the highest proof of work. This is an antispam measure. So this is if someone's pumping loads and loads and loads of messages onto the network, trying to bog it down. Well, they won't, unless they're very well resourced. They won't have the compute power to place a decent proof of work for each of these. Whereas the user that only has maybe one or two messages a minute can afford to spend a couple of seconds doing a half decent proof of work. And that's what allows them to rise above the crowd.
00:30:24.210 - 00:31:11.602, Speaker A: Now, the masking and filtering, as I mentioned before, you're able to stack the ods. The idea is, of course, that here I mentioned that only two bits were set to the one, and thus it's reduced from, you basically split the amount of total messages that will come to you from all of them to a quarter of all of them. If there were only one bit set, it'd be half of all of them. We can configure that number. The more bits we set, the more we narrow the search down, the more the peer knows. This number can be customized per peer or per application. It might be that some peers you trust more, you give them more information.
00:31:11.602 - 00:31:59.134, Speaker A: Some applications maybe that are more sensitive, maybe it's like the Wikileaks application or something, and you really want to have greater privacy for that application, and so you give away nothing or less. This forms what I call a topic vortex in the network. So if you view the network as a mesh, you get your point is like a point of hey, I'm after this topic. Your peers know that you're after something like that topic. The idea is that they take that and they consolidate it with all of their peers and the topics that their peers are after. And all of the other peers, they then tell hey, this is the sort of stuff that my peers are after. So I'm after this by proxy.
00:31:59.134 - 00:32:52.882, Speaker A: And this is so you get sort of this notion of a transient mapping of topic filtering. It becomes reduced the further out from the center of the topic you go, and of course it may be that the several nodes end up collecting in the middle in this topic vortex because they're all interested in the same stuff and all using the same applications. You end up with topic vertices forming, yeah, okay, so how do you use it? It's stupendously easy to use. It has three functions. The first one doesn't really do much, it just creates an identity. Right? So new identity, that's how you use it. There's not much to it, it's what it does.
00:32:52.882 - 00:33:25.040, Speaker A: It makes an identity. It gives you the public key for it. You never allowed secret keys, of course, that would be too insecure. But it remembers that you created this identity and it sets the public key aside and the sort of implementation part. And whenever you want to author a particular message or hash table entry, you author it with this key and it will sign it for you. Next one is post. Post, as you might imagine that posts a message onto the DHT, onto the system.
00:33:25.040 - 00:33:55.990, Speaker A: You can optionally specify a from and a two have to. If you don't want to, just specify a from. If you want, that will make it a broadcast message, just specify a two, that will make it anonymous. You could specify neither, and then it would be sort of this weird anonymous broadcast. It's probably really useful for things like, things like Wikileaks. So anyone can come pop a message on, nobody knows where it's from, it's not directed to anyone in particular, but everybody can read it. And maybe you've got a topic.
00:33:55.990 - 00:34:38.338, Speaker A: Too tired. Okay, so you got your set of topics, okay, and this is a set, not an array. So the series is, the order isn't important, it's just a set. This is actually just arbitrary data. In our web3 JavaScript thing, arbitrary data is prefixed with Ox or it's a number. And what it does is it takes the hash and then to get a 32 bit thing, it just chucks off the last 224 bits and you're left with 32 bits. The reason it's 32 bits and not the full 256 is firstly, we don't really need 256 bits, there aren't that many topics.
00:34:38.338 - 00:35:05.210, Speaker A: Second, a collision is unimportant. And thirdly, we've got data to save, we've got space to be saved. Then you got your payload. Payload is again just unformatted data. So again in the JavaScript API it's zero x, but we have a bunch of stuff that allows you to convert from ASCII and stuff. And I guess eventually there'll be ways of converting arbitrary binary data into this thing, but we don't have yet. The last two are the time to live, integer number of seconds.
00:35:05.210 - 00:35:28.658, Speaker A: It could be days, it could be just 5 seconds. It depends on whether it's important for you that your message actually gets to its recipient. If it's very important, you have a higher time to live. And it depends whether you want the message to stick around or not. So if it's something that you want, like a job posting or something, you probably want it to stick around for a day or two before you go online again and refresh it it. So that's way of time to reuse.
00:35:28.674 - 00:35:29.954, Speaker C: The maximum for the ttL.
00:35:30.002 - 00:35:34.886, Speaker A: I'd say two or three days, but I haven't mentioned shouldn't it be an.
00:35:34.908 - 00:35:39.720, Speaker B: Expiry time, because you don't know later when that message.
00:35:40.510 - 00:36:05.826, Speaker A: So a very good point, but expiry time is calculated as time of calling post plus TTL, and that's actually put in the message itself. So when the message gets distributed on the wispy network using the Y protocol, it does indeed include an x. No. So this is the user API rather than the sort of internal timestamp when.
00:36:05.848 - 00:36:10.754, Speaker B: The user sends it. I guess if it's a future time.
00:36:10.792 - 00:36:12.050, Speaker A: That is just invalid.
00:36:15.590 - 00:36:17.060, Speaker B: Synchronized time.
00:36:19.030 - 00:36:54.114, Speaker A: Well, if a node that has a, what would it be? A clock that's further ahead of yours sends you a message that they think is valid, and you say well it's further ahead, you'll just say right, mark down this node. I mean, if it's only a couple of seconds ahead, then it's like, well maybe their clock is a bit skewed, you probably won't mark them down much. If it's two days ahead, then it's like this node is really trying to pull one over on the network. Disconnect. This guy's bad. So I think actually I've written a proposal for the clock sku adjustment anyway, so it should really be built into the p to p network. Level.
00:36:54.114 - 00:37:38.474, Speaker A: And then nodes can, peers can sort of negotiate if one of them has a vastly skew clock because it plays absolute merry devil when someone's mining with a computer that hasn't been corrected for summertime God, it's an hour ahead, and then suddenly none of the blocks work really bad. And then finally priority. So priority is basically how much of a proof of work do you want to do? So it defaults to a small proof of work of like 100 or 200 milliseconds. So you barely see it in user level applications, but it still provides a decent amount of spam protection. But it's the sort of thing which ultimately, as the network grows, you probably want to raise because there'll be lots of people who are trying to send lots of messages for TTL.
00:37:38.522 - 00:37:43.570, Speaker C: If you use number of blocks, does that get rid of some problems or is it problematic?
00:37:44.630 - 00:38:34.082, Speaker A: The whisper protocol is entirely independent, so the idea is that it can be used alone. The final piece of the API puzzle is watch. What watch allows you to do is to surprise, surprise, watch for things that people have posted. So when someone posts something on the Whisper network, you get the notification that it's happened. Now actually, you'll get a notification at some point after it's happened. And how long it takes for that notification is how efficient things are being routed, and therefore to some degree, what security level, whether you put it up at private, in which case it'll take a long time before you notify because it'll be filtering through loads and loads of random other stuff, or efficient, in which case you'll be telling your nodes what you're after. It appears what you're after.
00:38:34.082 - 00:39:00.646, Speaker A: You'll be steering really fast and this stuff will come relatively quickly. Again, you've got the filter. So the filter is the topics. Now, this is a subset of the topics that must have been posted with. So it might be posted with like, I don't know, IRC application. Topic one, topic two might be chat room, chat room name. Topic three might be original origin.
00:39:00.646 - 00:39:56.186, Speaker A: So original name of poster. And it might be that you're in the chat room, you're not filtering on the original name of the poster because you don't care, because you want to go and receive everyone's posts, but you are interested in the other two. So you put the other two in here, and when you're posting, you put all three that way. When you say, actually, I am only interested in Alistair's posts because Alistair says really interesting things, then you'll filter on all three and you'll only be notified when those guys come. Optionally, you can also specify one of the public keys that you created with the new identity earlier. Now what that does is it says, even though I can never tell who actually signed something, assuming that they weren't using topics to tell me, I know from this filter that the messages that come through will have been encrypted or will have been sent to me. So being encrypted to me and being sent to me are the same thing.
00:39:56.186 - 00:40:37.174, Speaker A: In this, it doesn't make a distinction. So what you do is you say, right, I'm expecting if these are the topics, that this will be the key that unlocks the data, and it obviously unlocks it before it gives it to you. So then you say, right, when something comes in or watch or change, here's a function. M is the message, in, here is the decrypted message. So m now has things like data expiry, time to live, how much work was proved, all the rest of it topics. You can also say, right, well, what messages are there for this particular watch for this particular filter, tell me all the messages that have arrived. And this can.
00:40:37.174 - 00:40:50.620, Speaker A: Well, in future versions this may have a way of specifying time, date, times from and to. So I'm only interested in messages that came through from this point in time to this point in time. And finally, you can uninstall your watch.
00:40:52.270 - 00:40:56.890, Speaker C: To get a J notification. Do you get the hash topics back or the original topics?
00:40:57.050 - 00:41:03.520, Speaker A: You get the original topics. So the topics of the message, they're sent in plain, they're sent in plain text because they're needed for the reason.
00:41:04.290 - 00:41:09.166, Speaker B: And the security filter will just add random filters. Sorry, the security bar will add random.
00:41:09.198 - 00:41:10.660, Speaker C: Filters to your filter list.
00:41:11.350 - 00:41:11.970, Speaker A: Say again?
00:41:12.040 - 00:41:13.906, Speaker B: You said it was like a slider bar for how much?
00:41:14.008 - 00:41:33.450, Speaker A: Yeah. So what it will do is this number of ones that you include in the mask will be fewer. So at the maximum privacy, this will all be zeros. You won't tell your peers that you're interested in anything, you'll just take everything and then it's up to you to try to steer your peer set to the peers that tend to give you stuff that's useful.
00:41:34.590 - 00:41:38.202, Speaker D: When are you watching? Do you also set a minimum proof of work?
00:41:38.256 - 00:41:55.962, Speaker A: There is theft. That's possible, yeah. So it's not in the API yet, but that's a reasonable thing to do as well. Actually, my immediate idea would be primary.
00:41:56.026 - 00:42:06.920, Speaker B: Use of this tool with my public.
00:42:10.650 - 00:42:46.370, Speaker A: Yeah, well, the thing is that you have to know that the messages that come through are indeed encrypted with your public key. Now, you can't, two on its own doesn't filter anything. All mentioning two does is decrypt it with your public key. With this public key right here. What it doesn't do is check first that it's sent to you because it can't check because it's never mentioned. It's completely opaque as to whether something is sent to you or not, and that's why you use the filter. So if you wanted to do that.
00:42:46.440 - 00:42:47.380, Speaker E: Wait a minute.
00:42:52.790 - 00:42:54.100, Speaker B: No, it's a different.
00:42:55.190 - 00:43:18.346, Speaker A: That's it. So this isn't what's sent on the wire. So this is an API, right? What this isn't is the wire protocol. The wire protocol doesn't include from and to what it's using it for is just the encryption. Exactly. Encryption and signing. Is it possible to send to a subset of people? You send to everybody.
00:43:18.346 - 00:43:46.950, Speaker A: So multicasting. Indeed. So for multicasting, you would first set up a subset of identities that you're interested in, that you wanted to have read things as a group or receive things as a group. You'd tell them all a session key, and then you would only encrypt not to each of them individually, but when you want to send a message, you encrypt with the session key. But it's still always the topics that, the things that provide the routing. No one ever knows who it's encrypted to unless they happen to know that through the topics.
00:43:48.410 - 00:44:04.826, Speaker C: What can you see from the outside is basically the topics whole network. But some of these topics tend to be aggregated to certain parts of the national graph, and this changes over time. But you can't tell literally what the.
00:44:04.848 - 00:44:19.806, Speaker A: Topics is because the mask, as peers advertise that they're interested in particular topics. You can't tell what those topics specifically are? Well, not unless this mask is all ones. But assuming it's only a few dotted ones, can't you derive a hell of.
00:44:19.828 - 00:44:43.238, Speaker C: A lot of information about what just monitoring over time as know? You can know that something is common on Twitter at the moment and then map that because there's a certain pulse of topics in this area, and then like two months later it's another. And then statistically sort of really pin down the individual's topics and interests or not.
00:44:43.324 - 00:45:08.510, Speaker A: It's a possibility. It's something that we definitely need to look into for modeling. And this is something I'll bring up a bit later. But the idea is ultimately you can ramp down the peer steering and you can ramp down the masking and in that case, sure it will take a while before you receive stuff that you're interested in, but it will never be anything other than plausible deny. It's always plausible.
00:45:09.650 - 00:45:37.958, Speaker B: One more thing that if you're really interested in proceed. Then one thing that you could do is you somehow agree with your recipient in advance in a large range of topics. And then you send to a square root of that range and they ask a search in a different random square root and then one of those messages will be there. So an external observer has no chance of.
00:45:38.044 - 00:46:35.414, Speaker A: So following from that there is actually a protocol that I came up with that allows this to happen. So the basic idea is someone posts a broadcast, they say right, I'm interested in search and such, I've got a chair for sale, right? Someone who might want to buy the chair says right, I'm interested in buying this chair, I will send it to this recipient. But what they do is they put it on, so they put the topic in. So now someone might know that there was a message being received but they can't read it in that message. So it's now encrypted. You put a subject in, you put another topic in, that's just a random hash. And now both of the individuals, both of the daps, if you like, know this random hash and that's then used as the next topic and that's just a random hash.
00:46:35.414 - 00:46:45.470, Speaker A: No one can track what that topic means, what it means at all. And so obviously that can then be probabilistically changed as the session continues.
00:46:48.690 - 00:47:08.578, Speaker E: So what's the overhead that I'm creating with full anonymity? I don't have a feeling for that fresh discovery of some method that I'm interested in. How much time?
00:47:08.664 - 00:47:49.966, Speaker A: The honest answer is I don't know. It's something that needs to be modeled and it's something that hopefully some of our modelers can look into at some point. I would hope with a combination of proof of work, a modest amount of filtering, and peer peer steering, it's reasonable for the sorts of applications we're going to have on 1.0 and then for 2.0 we can sort of do some proper research and work out ways that this can be optimized further with the same API. But the API is the most important thing for 1.0 to get people used to thinking in this paradigm and placing their applications in this paradigm.
00:47:50.078 - 00:48:51.000, Speaker F: Alex, has there been thoughts on routing? You might have covered this preventing hack of storms and also preventing denial service attack. Obviously somebody can always do a higher proof of work. But then what if somebody just happens to have, I don't know, all he needs is really more proof of work than what is out there right now, not necessarily than everyone else, because it's only going to be more than who's currently using it. So this person could just use up everybody's bandwidth and then everybody else. It becomes expensive for anyone else to use and now it's hard to use.
00:48:51.610 - 00:49:20.462, Speaker A: Yeah. So if they can afford to put more proof of work in than all the other messages combined on the network, then it's going to grind to a hole. The question then is, well, how much proof of work is that? And would anyone really be interested in setting up a supercomputer or a massive collection of nodes to do a denial of service attack on the network in that? What would they gain by doing it? And that's a separate question, as is the question of whether it's actually affordable for anyone to do it.
00:49:20.516 - 00:49:21.646, Speaker B: We want to do this for high.
00:49:21.668 - 00:49:22.670, Speaker C: Frequency concentration.
00:49:25.890 - 00:49:37.960, Speaker A: It'S true. But the question is how much is there to be profited from it? And is this profit sort of in the same order of magnitude as the cost that it would take? And that's something that does need to be modeled. I don't have the answer.
00:49:38.810 - 00:49:48.650, Speaker F: If the topic is truncated, how are the. So every message is broadcast to every node?
00:49:52.430 - 00:50:13.134, Speaker A: No. So the messages wash around the network. You're aiming for every message to be broadcast to every node, but that will never happen. Yeah, at least not within a small period of time. So it's not that every node will have all information. Ultimately they're not building up to that. You're just sort of exchanging messages.
00:50:13.134 - 00:50:18.820, Speaker A: The messages are washing around and eventually you'll get something that you.
00:50:19.590 - 00:50:25.780, Speaker F: How do we prevent a message washing around that it is like just washing around?
00:50:28.150 - 00:50:42.140, Speaker A: Well, if a peer won't forward a message to the same message to another peer twice, so it won't go in a circle, it might die out early, but that generally means that it wasn't given enough priority or its time to live was too small.
00:50:44.350 - 00:50:46.106, Speaker F: So if I want to send you.
00:50:46.128 - 00:50:58.320, Speaker D: A message, but I don't want to reveal the content to anybody, I want the message to be private, then I have to agree with you on a topic. But then that means that I have to have sent you a message already.
00:51:02.790 - 00:51:13.570, Speaker B: You know each other's public keys. You can agree on a secret without any secret communication. That's the difficult key agreement.
00:51:17.370 - 00:51:22.246, Speaker C: It's fair to assume that if I'm not connected to the right peers, that there's a good chance I'll miss a.
00:51:22.268 - 00:51:24.600, Speaker B: Bunch of messages that I care about.
00:51:27.790 - 00:52:07.080, Speaker A: Possibly, especially if you're not broadcasting in sufficiently precise terms what you're interested. But in general, again, it needs to be modeled as to precisely what that limit is. It may be that for the foreseeable future, it's not a massive problem because people have very decent, very high bandwidth and you're connected to a sufficient number of peers and the peer network can be spread across properly, well balanced that actually it doesn't, and it's just something that needs to be implemented in model.
00:52:08.170 - 00:52:26.940, Speaker E: Is there any physical or biological process that this whisper is most closely related to? I mean, there's some kind of combination between whispering and active listening, but anything else, it feels like a forward backward diffusion. I don't know.
00:52:27.470 - 00:52:53.778, Speaker A: It's an interesting question, and probably not one I'm going to be able to address in a tractable time right now. Yeah. Is Whisper just a working name for the project? It was not a working name, but it might become a working name given the amount. I know. It's a shame. I really like.
00:52:53.944 - 00:52:57.480, Speaker D: Yeah, that's one question.
00:52:58.330 - 00:52:59.270, Speaker F: Regular.
00:53:03.850 - 00:53:29.146, Speaker A: Regular expression of filter is something that we love. A regular expression, yeah. Like, I want to listen on. Oh, I see. Well, the thing is, filters are just a binary. Okay. The topics that they're filtering are not, but the underlying, because a hash is taken, the underlying thing is binary because you want it to be cryptographically secure.
00:53:29.146 - 00:53:46.610, Speaker A: So what you don't want is by putting ones in particular places actually to be clustered around things of roughly similar topics. So you hash it so that the things that is clusters, the clusters are just completely arbitrary. It might be smiley cats, it might be fist dogs.
00:53:48.470 - 00:53:59.094, Speaker C: If you restart your deck and you watch for the same topic, and if you receive a message with a TTL that hasn't been expired yet, will you see it again next time you start your dash, or will you need to.
00:53:59.132 - 00:54:01.058, Speaker B: Store it somewhere yourself?
00:54:01.164 - 00:54:52.010, Speaker A: You won't be notified of its arrival, but you will get it back when you ask the messages, assuming that it hasn't been thrown out because it's not believed to be interesting to any dapps. But this is something that will probably be handled in a level underlying where you say, right, well, this Dap was interested in these sorts of messages. I'll probably not chuck them out yet, at least not until the DAP runs again and gets to register its interest again. There's a possibility a later sort of proof of concept or a later version where we can actually allow clients to say these messages. I know that the TTL, I know they're supposed to expire in an hour, but I'm actually really interested in keeping these forever. And they tick a sort of archive flag and every now and again they have to sort of reassert that they want to be archived and then they get back in messages forever.
00:54:56.590 - 00:54:58.620, Speaker F: Maybe you said it.
00:55:01.950 - 00:55:06.446, Speaker B: So the topics in the filter are they basically.
00:55:06.548 - 00:55:10.000, Speaker C: Are those. Do they all have to match?
00:55:11.890 - 00:55:35.814, Speaker A: Oh, sorry. Yes, they all have to match, but they don't have to be a complete set of topics for the entry. They only have to be a subset of the topics for the entry. So it might be that you provide two and the entry actually has three topics or four or five or whatever, but it includes this have to be a superset of.
00:55:35.932 - 00:55:40.306, Speaker B: Isn't the tag a better term? Because at least topics are in tag.
00:55:40.498 - 00:55:49.450, Speaker A: Yeah, tags, subject key. I had to land on one. Alex.
00:55:52.050 - 00:55:54.430, Speaker F: From a single hash or a double hash.
00:55:56.690 - 00:56:06.020, Speaker A: A single hash question. Absolutely. If there's a good reason.
00:56:08.150 - 00:56:16.130, Speaker F: It'S sort of not a good reason, but at the beginning when there's not a lot of topics.
00:56:20.970 - 00:56:25.240, Speaker A: Okay, then, well, think about it. Get back to me.
00:56:27.530 - 00:56:30.490, Speaker F: Image attack on 32 bits of a hash.
00:56:32.590 - 00:56:33.734, Speaker A: Free image.
00:56:33.862 - 00:56:46.110, Speaker F: Yeah. Where you just create a whole bunch of. Just. Yeah, but if it's like a topic.
00:56:51.250 - 00:56:54.320, Speaker A: Yeah, it's a good point. Yeah, you probably could. Yeah, that probably needs to be.
00:56:56.710 - 00:56:57.122, Speaker C: Yeah.
00:56:57.176 - 00:57:15.640, Speaker A: No, that said if you got a rainbow, you'd be able to do it with an actual hash. It wouldn't get you anywhere because you could do it anyway. You could just search on the first 32 bits of an actual hash for the rain table anyway. Yeah.
00:57:16.650 - 00:57:22.470, Speaker E: Is this suitable for kind of chat?
00:57:23.150 - 00:57:43.200, Speaker A: Yeah, that's one of the things. So something like Skype, Twitter, email, that's something. Well, I don't know, but with email I get latent disrupted like a day. I mean, it's true again.
00:57:45.650 - 00:57:51.250, Speaker E: Exactly. All I know is that I want to talk to Kevin privately.
00:57:55.190 - 00:58:24.026, Speaker A: This is a top level thing. So what this doesn't do is say it doesn't give you a direct line for me. Okay, so I'll just get to the end and then. Example. Oh no, I've only got a few slides. Okay, so this is just a quick example. So we make an identity.
00:58:24.026 - 00:58:41.874, Speaker A: There you go. New identity. What we're going to do is we're going to post a message to everybody. Broadcast message. We're going to say, hey, I'm online. What's your name? So what we do is we say the topics are just the application name. And this is a string, right? This is somewhere there.
00:58:41.874 - 00:59:18.606, Speaker A: It's like the hello world application. The payload is my name, so Gav or whatever. And then the next thing is, what is your name? Right? So it's just like the application is saying, right, well, here's, this is like a DAC level protocol. So the first field is going to be so we can make the payload, I should say, out of a series of 256 bit chunks of data. And all it does is append them. So my name. And then what is your name? Right? And the idea is that on the opposite side, the app will.
00:59:18.606 - 00:59:50.950, Speaker A: Then the dap will go, oh, this is Gab. He's after somebody, he's after some friends. Okay? So we'll reply to. And then we got like 100 seconds of the time to live and just give it a default priority of a second's worth of proof of work. Okay? And then what we do is we set up a reply watch, right? So this is watching out for these messages, right? The reply watch has a simple filter. Oh, hold on. Right, jump to the next slide.
00:59:50.950 - 01:00:19.214, Speaker A: We set up a broadcast watch, and this is a simple filter. We're looking out for anyone who's broadcasting with the topic of this application. So the hello world application. So everyone running this code will be running it with the same application name. So they'll all be seeing those posts that have happened. And what we say is, when something has arrived with this filter, we'll check to see if it does. So if m from is my identity, well, we're not interested if it is, because we're just going to reply to ourselves.
01:00:19.214 - 01:00:43.434, Speaker A: That doesn't make any sense. We'd have to have very few friends for that to be interesting. And if it's not us, then let's do something. So what we do, we've got a new message. So we know that from this topic, it's someone asking for our name. So firstly, we grab their name, right? That's what this string does. It just takes their name from the data.
01:00:43.434 - 01:01:22.710, Speaker A: We say, oh, look, we've found a broadcast from this guy. We're going to tell them that our name now. So what we do is we sign, we make a post, we say it's from us. That's our key, right? We put it to them. So the data, the bit that goes in the actual DHT, will now be both encrypted and signed. Signed, then encrypted so no one can tell it's actually from us the topics are going to be the application name again and then also who it's from. So this is the way of routing it back to them.
01:01:22.710 - 01:01:38.854, Speaker A: Right. This is a super simple way because we're just putting as one of the topics their id. Right. Their public key so they can look out for their public key as a topic. The payload is going to be our name. There we are. And then we're replying.
01:01:38.854 - 01:01:52.510, Speaker A: So we know that they're probably, well, we don't actually know they're online. But anyway, time for the 2 seconds. It's a transient thing. We don't care if they don't apply, if they're not online, saving it for a long time and then a bit of a priority.
01:01:53.490 - 01:01:55.166, Speaker C: So how do we know in from?
01:01:55.268 - 01:01:56.626, Speaker B: You said it wasn't not part of.
01:01:56.648 - 01:02:16.760, Speaker A: The visitors broadcast from is part of it. It's not quite part of it. It's in the signature. So it's retrievable from the signature. So if you say it's from an identity, it will sign the payload. Okay, so that's the broadcast post and the watch for it. And what we can do is set up a reply watch.
01:02:16.760 - 01:02:27.834, Speaker A: The reply watch says. Right, well, let's assume they got this and they've replied. They were looking out for it and they've replied. So we saw what that code was. Now we're looking at a reply, which we're watching out for the reply. The reply is. Right.
01:02:27.834 - 01:03:04.918, Speaker A: Well, again, our app name, just to make sure that it is actually this application and my identity. If you remember, before we set one of the topics to the sender's identity. So now we're looking out for our own identity in the topics. And what we're saying is here, this two, we're saying if it matches this filter. So if it's on this application, the topics include my identity. Then we are asserting that it was actually sent to us and thus we're saying to my identity. And this is the only thing that prompts the underlying implementation to actually decrypt with our private key.
01:03:04.918 - 01:04:22.560, Speaker A: If we didn't put this two in, the data of the message would just be a load of gibberish because it would be undecrypted data. And then finally we say, right when it arrives, we'll just tell the user, hey, I've got a friend. So things that I haven't really covered in detail, mainly because they're probably not quite sort of finished or worked out, the multicasting that's vaguely, there's a plan, there's a strategy might need tweaking, but Daniel has some ideas on adding to the signatures specifically for plausible deniability, which I don't know, maybe get into if you want. And then finally, as I mentioned before, security, privacy and scalability. We need to do modeling to work out how scalable the network is, how long it's going to take for a message to generally go network. Well, formedness will be a play a large part in making sure that we have a decent upper bound on those times, but basically how good actually is it when it goes into the real world? Okay, any questions?
01:04:23.430 - 01:04:29.938, Speaker C: What's my incentive in choosing a smaller time to live? Does it cost more proof of work for longer?
01:04:30.104 - 01:05:19.140, Speaker A: No, incentive is that peers will buy convention, forward them because there's a greater chance of another peer liking the fact that you gave them that message. So the other peer that you forward to might increase your recipe. And that's what you're as a peer, as someone who wants to keep their current peer set, you're trying to get your peers to keep you, not disconnecting, so you're incentivized to provide them with useful information. The filter needs to be a subset of the topics of the message. So in the example we could actually only use one watch call to get both types of messages. That is correct. Yes, you're right, yes.
01:05:19.140 - 01:05:51.600, Speaker A: Actually get the second topic from the message we receive in the callback. It is. But the problem is with having a single watch call, you have to specify the two in the watch call so the underlying layer can decrypt the message for you. And one of them was plain, the other was encrypted. But you're right in that there was an issue with that example. The one that only had one, the one app name topic in would try to give the application encrypted information, so you would put another topic in. That said, the initiation, the broadcasting, just so you could differentiate between the two.
01:05:51.970 - 01:06:22.680, Speaker C: I have a question regarding proof of work in this protocol, because for blockchain I kind of see the value of proof of work. So we get consensus with mine blocks and stuff. And I'm not sure if I understood correctly why we have proof of work in whisper. Is it just for avoiding spamming and stuff? We don't need to do calculations just in order to keep volume down?
01:06:23.610 - 01:06:36.730, Speaker A: Pretty much, yeah. It's a basic strategy against that. It's still precisely what proof of work is used. Again, is something to be tweaked, determined.
01:06:38.510 - 01:06:44.846, Speaker B: Why is it important to be able to choose the bits in the mask why not just tell? How many of the front bits do I get?
01:06:44.868 - 01:06:52.526, Speaker A: Yeah, you could do. It's reasonable. If I have a public address on.
01:06:52.548 - 01:06:59.700, Speaker B: The blockchain and I decided to use that as my whisper address, would that leak any information about who I was?
01:07:00.630 - 01:07:22.730, Speaker A: Yes, I'd leak all the information. It would link those two. Now you might want to do that. It might be that you've got an address on the blockchain and you want to prove to somebody off chain that you are indeed associated with this address and that you're rich or you have a high reputation or that you did do that transaction with them. But likewise it may be that you want a new identity and both are supported.
01:07:24.750 - 01:07:38.160, Speaker B: If someone doesn't give you any information in their filter, can you kind of encourage them to give you information by making a whole bunch of messages and just sending them to them? And then they'll be like, oh, I'm getting too many messages. Let me just give you a little.
01:07:39.010 - 01:08:03.286, Speaker A: Very good point. Now this is mentioned in the wiki, I didn't mention it here. One of the things that will need to be done to avoid this kind of attack. So this is the attack. I got a half decent name for it as well. But this is the attack whereby, oh, it's like a black hole attack or an everything but attack. So you know what they're interested or you think you know what they're interested in, right, because they gave you some sort of a thing.
01:08:03.286 - 01:08:19.146, Speaker A: So what you do is you send everything but what you think they're interested in and then you're basically pushing them for them to tell you more and more about what they want in order for you to actually send the thing that they are after you're sending them.
01:08:19.168 - 01:08:21.100, Speaker B: Then definitely not what you're looking for.
01:08:22.670 - 01:08:23.254, Speaker A: Say again?
01:08:23.312 - 01:08:24.426, Speaker B: You can just make up the messages.
01:08:24.458 - 01:09:04.380, Speaker A: Oh yeah, that's it. You can just make random messages. So how do you get around this? Well, you can reasonably assume that the information that you have from the other peers, okay, if you assume all your peers are bad, then you're pretty fucked anyway. So you assume that the other peers are giving you roughly decent information and then you do a statistical analysis on the traffic that comes from the other peers, how much of it is actually useful, how much of it isn't, and check to see if that matches what that peer is giving you. So if they're doing a really sort of heavily conscious, heavily sort of tainted everything but attack, you'll be able to detect it and throw it up.
01:09:04.750 - 01:09:06.118, Speaker B: If they know your peers, then you're.
01:09:06.134 - 01:09:10.694, Speaker A: More vulnerable if they know your peer well, certainly if they've compromised your peers, you're very vulnerable.
01:09:10.742 - 01:09:16.846, Speaker B: But if they were to just send those messages to your peers, they might send them to you and it might look like those messages are going through.
01:09:16.868 - 01:09:17.440, Speaker F: The.
01:09:20.850 - 01:09:29.570, Speaker A: This is slightly reduced by constant peer steering. So you just keep getting random peers.
01:09:32.950 - 01:09:36.610, Speaker B: But when you use the API, where do you set your masks?
01:09:39.030 - 01:10:01.360, Speaker A: Where do you set your mask? The masks are done actually as an underlying level. So the DaP never actually sets the masks. It's something that the user specifies in the interface of the client, like the browser or whatever, how much information you're willing to. Then there's obviously the idea of a big slider bar. But then you could also drill down and say, right, for this app, I want more for this, less, whatever.
01:10:03.330 - 01:10:06.910, Speaker C: You could call it Zoro instead of whisper. But this isn't.
01:10:09.730 - 01:10:12.160, Speaker A: Have, we should have a competition, shouldn't we?
01:10:13.650 - 01:11:00.746, Speaker D: Alex was asking about how you manage. The message won't go in a circle. And Judah was asking for some kind of biological counterpart. And it's very similar to the way like spore mode communicates using diffusion. But normally when you use animals that use diffusion, I also have some kind of feedback to say, okay, this place where the diffusion coming, there is food. Is there a way, if I am connected to a pier and then I find a message that I want from this pier, is there a way for me to tell that peer, you gave me a message I want, please bring me more from wherever your source so we can find this connection automatically.
01:11:00.858 - 01:11:20.886, Speaker A: You could do, yeah. The issue with that is of course that you're giving the peer, effectively you're telling that particular peer, you're giving them all the ones you're saying, right, that message, that topic set there, that's great. Give me more like that. Is telling them this is the topic you're after. So if you want to do that, you just give them this information in the first place.
01:11:20.988 - 01:11:27.830, Speaker D: You can just tell me that peer, that he's a good peer and he's good sources.
01:11:28.830 - 01:11:35.290, Speaker B: You don't reply after one message like you respond after 1000 messages in the past thousand messages.
01:11:36.910 - 01:11:45.518, Speaker A: So you could do that as a peer rating. So it could just be, hey, what's my rating with you on this protocol? And you say, right, your rating is currently 10,000 because you're super awesome.
01:11:45.684 - 01:11:57.198, Speaker D: But that's not really a rating of the protocol. It's just saying that there is a connection. If there is a big network, then the best way to find a connection between those peers is to.
01:11:57.284 - 01:12:05.460, Speaker A: We're not dealing with endpoints. Yeah, okay. True. Anything else? Cool, thank you.
