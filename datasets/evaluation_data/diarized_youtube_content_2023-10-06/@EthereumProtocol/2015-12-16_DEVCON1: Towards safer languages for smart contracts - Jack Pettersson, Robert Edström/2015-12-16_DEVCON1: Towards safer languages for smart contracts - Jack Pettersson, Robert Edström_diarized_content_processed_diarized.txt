00:00:16.730 - 00:01:23.266, Speaker A: Hello everyone, my name is Robert, this is Jack, and we're currently working on our master's thesis in computer science, and we're working on a new programming language for the EVM. So we're here to talk about how smart contracts can be a perfect fit for a dependently typed functional language and why we want to do this. We will also have a small example of how an expressive type system can help in contract development. So when you deploy a smart contract to production, you want to be really sure that it behaves precisely as you intellitue. So the more the compilator can catch for you, the better. So we also want to give developers high level abstraction of standard behavior and common patterns, stuff like high level cryptography and boilerplate for errors and cleanup. And I hope that after hearing Greg this morning, you can appreciate that a language that allows for compositionality of combinators and functions can be really powerful.
00:01:23.266 - 00:01:39.260, Speaker A: LlL is functional, but it's way too low level for a lot of purposes. So without further ado, Jack will now present two types of errors that programmers usually make when they start developing smart contracts, and how we can catch them at compile time.
00:01:40.370 - 00:02:19.790, Speaker B: Right? So we look at a simple example, game of rock, paper, scissors that's played for money. Joining costs ten ether and the price is 20 because there is two players. And I hope you know the rules, but it doesn't really matter if you don't. And here is a small example of how the function that lets players join the game could. Look, it's very straightforward. The game can only be joined if it isn't full. The player has to pay the fee.
00:02:19.790 - 00:02:56.920, Speaker B: And if both of those are okay, we just save the move and the address of the player. And yeah, the move is just represented zero, one, or two for simplicity. So for a regular programmer, this would seem quite reasonable, but there are actually a few bugs here. So what happens if a third player attempts to join the game? He would lose all his ether and there's no way to retrieve it. So let's fix this. This is better. But there is one problem left.
00:02:56.920 - 00:03:48.920, Speaker B: Since the blockchain is transparent, the first player will reveal his move to the second player. We'll not solve this now, but keep it in mind for later. So just a quick recap. There's two classes of error that we're focusing on that's very common for developers that's getting into smart contract development. What we are trying to do is to use an expressive type system to help identify and solve this. And to do this, we are including both ether flow and cryptography directly in the type system. So if we want to encode ether flow in the type system, what can we do? Well, we can start with including the transaction value in the type signature like this.
00:03:48.920 - 00:04:42.246, Speaker B: And as you can see, we have also put a precondition on the value saying that this function requires at least ten ethers to be executed. Otherwise the transaction is considered invalid for our purposes and all ethers automatically returned to the sender. And this is certainly neat, but it doesn't solve our problems. But as you can see, we actually already know the function's result, success and the transaction value. This is actually enough information for us to specify how the function should handle it during all execution paths. So we just take the return value and do a conditional check on it. That's the question mark and colon there.
00:04:42.246 - 00:05:51.498, Speaker B: As you probably recognize from imperative language languages, if the player was able to join the game, we should save ten ether and return the rest. And if the player wasn't able to join the game, then we should send back everything and don't save anything. Now this type signature actually causes the problematic implementation from before to be a type error that's catched at compile time. This is quite amazing because it allows us to eliminate a large class of bugs without doing any testing or formal verification whatsoever. This technique can actually also be used by contract developers to specify the behaviors of their contracts, but that requires a little more work on the part of the developer. So we won't go into this, but we still have the problem that the move is disclosed when it shouldn't be. The way to solve this is to use cryptographic commitments.
00:05:51.498 - 00:06:54.610, Speaker B: They basically allow you to commit to a value and then reveal it at a later time. But developers shouldn't implement their own crypto each and every time. It's tedious and very error prone. So the way we solve this is by annotating the types of secret values, as you can see there with commit. This indicates to the compiler that this value should be treated as a commitment, and the compiler will automatically generate a function for the sender to reveal it at a later time. When it has been revealed, it can be accessed in code by using the standard library open function, which takes any commitment and returns the value. If it hadn't been revealed previous to calling open, then open will fail, return all ether to the sender and abort execution.
00:06:54.610 - 00:07:17.320, Speaker B: So our final type correct implementation would look like this. Note that we are forced to explicitly save all ether that we want to keep, because otherwise it wouldn't compile and now Robert will talk about how we intend to implement this.
00:07:18.090 - 00:08:10.518, Speaker A: Thank you. So some of you might have noticed that the syntax we have used is very similar to Haskell. And when we first started looking at this, we had the idea of making Haskell on the blockchain, basically. But the more we looked at these problems and how they could be solved, we realized that dependent types would be really cool to do this. Also, Haskell is Lacey evaluated, which becomes prohibitively expensive in real life on the EVM as it is now. And then we found Idris. Idris is very similar to Haskell, but it has some key differences, first of which it is dependently typed and it has side effects, is modeled with algebraic effects.
00:08:10.518 - 00:09:01.900, Speaker A: So these two things combined is what allows us to have the neat expressiveness in the type signatures that we saw before. And Idris is also strictly evaluated from the get go, so we don't need to make any changes there. And as a nice bonus, we don't have to venture down into the murky depths of the GHC API, if you're familiar with that. So I hope we have shown how dependent types and algebraic effects can be used together to define the flow of ether throughout the execution of a contract. And we'll see how. We have seen how high level type annotations can ensure that secret information stays secret until it's supposed to be revealed. And we have a language where compositionality can be achieved in a natural way.
00:09:01.900 - 00:09:40.740, Speaker A: So, where are we currently with this? Well, we still have a long way to go before it's actually usable in practice. To create working smart contract bytecode. We have created models for how we want stuff to look for the developer and made sure that all the properties we want to enforce can be enforced using Idris's type system. And we have just recently started looking at how we can create a code generator that will go from Idris to ll in a similar way. The Pentacit today. And that's it for us. Thank you.
