00:00:10.880 - 00:00:35.490, Speaker A: Okay, let's get started. I don't think we'll get more people, but yeah. So welcome to breakout room number eight. Here are the agendas. EIP implementation, free da with block auction. I suppose we chat about that two weeks ago, which I wasn't there, but we can briefly touch base on that. And Julian has two documents to share and discuss.
00:00:35.490 - 00:01:09.542, Speaker A: And I also have one about block proposal for epbs. So in terms of EIP, I don't think there's much to touch base there. The EIP is out. Anyone's welcome to review the consensus. SPAC is out. It's worth mentioning that Etan has been leaving some reviews on the Eipdeh and Etan is also adding like client testing and like client documentation to the EIP. So if you see the Discord channel, Etan has an update on that.
00:01:09.542 - 00:01:59.130, Speaker A: So that is if you're interested in more like client type of stuff. But yeah, so that's the EIP. In terms of the implementation status, I can speak for Prism team. So we're working on implementation. I'm currently working on the RPC endpoints, that is for the proposer to submit blocks, to sign the header and to sign the execution payload. POTUS is working on more like a core state transition function and for choice that is. Yeah, so that's on the prism team side, I think like we could have a, I can't speak on Prism team that we think we could have a local devnet by Defcon and by then if any clients want to join us and join us we can do a multi client devnet.
00:01:59.130 - 00:02:06.450, Speaker A: But yeah, besides Kristen, I wonder if other consensus layer team wants to share their update.
00:02:10.310 - 00:02:47.940, Speaker B: Yeah, sure. Tech is progressing. I leave, I say what I've been working on now and then leave some updates from, from Stefan which is working on those things. So me is currently what I did is updating the valid, I'm working on a valid client side. Currently I'm done with the rescheduling of these events. That changes because there's a lot anatomy changes. So we've done that and I'm working on implementing the new duties for the PTC.
00:02:47.940 - 00:02:55.070, Speaker B: So so far so good. And yeah, I leave Stefan updates from his side.
00:02:57.330 - 00:02:57.730, Speaker C: Yeah.
00:02:57.770 - 00:02:58.066, Speaker A: Okay.
00:02:58.098 - 00:03:40.650, Speaker C: So from my side, the last week I worked on the beacon chain state transition changes. That is done. And now I'm working on the p two p, specifically the gossip topics, all of the validations, the three new pools and the RPC endpoints as well. And what's left, I guess after that is poke choice, which is the most complicated part, I guess. And yeah, of course the validator side and proposing and yeah.
00:03:43.190 - 00:04:05.570, Speaker A: That'S awesome. Yeah. If you have any feedback on the p two p gossip rules, because I think that for us it's slightly weak in a way that we didn't really think it thoroughly before putting out there. There are definitely things that could be reordered such that it's better. Feel free to erase that. Yeah, I'm definitely curious for feedback for the p two p rules.
00:04:06.300 - 00:04:11.476, Speaker C: Yeah, yeah, I have a couple of notes which I will share on Discord.
00:04:11.588 - 00:04:13.200, Speaker A: Yeah, thank you so much.
00:04:16.580 - 00:04:34.460, Speaker D: I can go for lots and yeah, so I've been working on straight transition and block processing architecture as such. But yeah, we'll share maybe a better update in the next breakout call.
00:04:36.440 - 00:04:44.780, Speaker A: Thank you. Any other clients wants to share an update?
00:04:48.880 - 00:05:05.190, Speaker E: Sure. So nimbus has been just going through the EPF program and there's been progress on that. We're still kind of at the stage of, I'll be honest, kind of data types and beacon chain helpers, but progress.
00:05:05.850 - 00:05:38.276, Speaker A: Nice. Awesome. Cool. Yeah, I guess that's all the client teams we have. And the next items is icloud is put free DA with block auction. So like for those, they're not like following closely, I guess the recap, which this was also brought up two weeks ago, is that with block auction, this doesn't happen in slot auction, this only happens in block auction. So in block auction, there's this.
00:05:38.276 - 00:06:45.976, Speaker A: I guess I can put a phenomenon in a way that a proposer or a builder could commit a block hash at the consensus phase, but at the execution phase, the execution block that is revealed could be invalid. And that invalid block could, for example, contain full blobs, could contain two megabytes of code data. It could be, for example, a very expensive block by the code data usage. But that block is invalid. But that block is also voted on time by the PTC committee member. So what can an attacker do with this block, if I ask, right, the attacker could, for example, build like a robot, like cheating rob that uses data availability as such. But to some people, this is not true.
00:06:45.976 - 00:07:36.194, Speaker A: Da, right. Because honest node will not serve this blog. It's only you have to modify the client to save a valid blog, and then you have to serve the blog basically as a dishonest client. So in a way, some people agree that we cannot argue this as three DA because this doesn't really provide likeness to the rob that tried to cheat. So now the open question is that, is this enough threat to kill a block auction, for example. I mean, there are many, many reasons why slot auction is better than block auction, which like we have been considering doing slot auction for a while. If you look at this notion, dot by retin pool pull out.
00:07:36.194 - 00:07:59.410, Speaker A: Right there is essentially. Let's see this. Where is. Yeah, there is this page that compares slot auction versus my block auction. And then slot auction, you just like cut the barrier in old avenue and then. So I do think that we will like move to slot auction at some point. But then the question is when.
00:07:59.410 - 00:08:25.960, Speaker A: It is pretty trivial to change, to change the slot auction, instead of committing to a block hash, you just commit to the builder. So when we want to change it, I don't suspect is that it is that much work for both client side and then the spec side of. But the question is when do we put the trigger and. Yeah, does anyone have any, like, inputs want to add on to this?
00:08:31.100 - 00:08:37.040, Speaker B: So the free, the real will be only just 32 bytes of the block hash, correct?
00:08:37.460 - 00:08:44.420, Speaker A: Yes. And then you rely a node that serve, you invalidate data such that assuming.
00:08:44.460 - 00:08:51.270, Speaker B: That this is not the case, the only true, um, three d a is 32 bytes per block.
00:08:51.650 - 00:08:55.858, Speaker A: Right. Which is nothing a little useless, people will say.
00:08:55.994 - 00:09:25.764, Speaker B: Exactly. Um, generally I would say that if slot auction is anyway better and spec change is not that big, why not doing soon instead of. That's my. So what are the character arguments for not doing that? Is there any more complex outside the protocol? More complexity outside there? Yeah, probably I have to go through.
00:09:25.892 - 00:10:02.264, Speaker A: No worries. Yeah. So definitely curious to hear feedback from Julia and Thomas. But like, the biggest counter argument that I have understood so far is that emits local blood building at a disadvantage. And polis didn't really like that at all. So, for example, today, when you request a slot or a block at second zero, you get this local value, and then you compare this local value with the builder's value, and then you can essentially add some boost to it. You have a censorship or a local flag.
00:10:02.264 - 00:10:26.930, Speaker A: But then if today there is a six second lag between your local value and the actual value that, for example, gets Manpool, it may be harder to value it at that from your locals perspective. So that's probably the only counter argument that I have heard besides for choice, which I choose. You can touch base on that later. Yeah, yeah.
00:10:27.010 - 00:10:35.990, Speaker B: I'm connecting back to the discussion. That previous breakout session has been widely discussing that. Yeah, I understand.
00:10:37.330 - 00:11:38.536, Speaker D: Yeah, I mean, my. I sort of agree with Enrico that if, for example, the complexity does not increase multifault, then it makes sense to have more flexibility and go with slot options. And even if, for example, it might put local block building at a disadvantage, but it could happen that even local engines might sort of get this feature and of predicting what value they can pack by the time it's time to omit the payload. So in that way, I mean, I don't actually see that it hinders any capability even for local engines. It's just matter of people building that module. And if we have this open source community. So maybe this problem isn't hard enough.
00:11:38.536 - 00:12:23.450, Speaker D: And for example, if there is open source builder code that is available out there, then it could also be easier, easy to import it as a module inside local engine. So in that way I don't see that in long term local engines would be at any disadvantage. But if, for example, we have rarity of builders out there and you get very competitive bids, it basically makes sense to go with some feature that can improve the flexibility and that can improve the economic value of the block.
00:12:28.110 - 00:12:34.090, Speaker A: Yeah, that, that makes sense to me. Any more feedback on this topic.
00:12:36.990 - 00:12:37.278, Speaker E: We.
00:12:37.294 - 00:13:29.510, Speaker F: Have to add on to the arguments against I think so why not? The bluff disadvantage is it's difficult to compare the value of your block to the value of the block 6 seconds from now. But potentially this problem also exists in block options, because we're just changing the structure of the option and when time agree happens. And secondly, this only is relevant for proposers that have a preference for their local value that has some relative value compared to the public value. So local value boost and prism would maybe suffer from this, but it's been shown that these values up until now don't contribute super much to this sensor resistance of the network, whereas parameters like Minbit or netboost, they don't suffer from this problem and they currently have a bigger adoption. But this could change, of course.
00:13:33.090 - 00:13:34.430, Speaker A: Yeah, that makes sense.
00:13:40.060 - 00:13:40.436, Speaker B: Cool.
00:13:40.468 - 00:14:03.120, Speaker A: Okay, so my meeting notes later I will put like slot auction is basically preferred at this point and supported by two client teams. And let's see how we go from there. But I suspect we'll move to slot auction fairly quickly. Now let's see. Okay, so the next topic, Julian, you want to take you over?
00:14:04.660 - 00:14:29.300, Speaker F: Yeah, thanks. And so I'd like to discuss two posts that I recently made. One is about the equal education in slot auctions. So I'll go through that one first and then talk about the second one. So in slot auctions, since the d ten proposal doesn't commit to a specific execution payload, the builder could release one execution payload and release another one later. And thereby confusing the tenderness committee.
00:14:31.130 - 00:14:31.870, Speaker A: Or.
00:14:32.210 - 00:15:24.460, Speaker F: Other the next proposal. And this could be bad. So in this post I present two proposals for fort choice that ensure that builders have the same builder reveal safety and proposers have the same unconditional payment guarantees in sole selections as compared to the current in global option epds. And also I put the daisy ASM that if a builder equivocates, then no payload should become canonical. And then these two proposals satisfy this. And one of them was get rid of the problem with lot options. I was passing reporters about this and he's questioning whether the second digitization is truly necessary, because potentially there's just not that much to gain as a builder from equivocating even with the current purchase locations.
00:15:24.460 - 00:15:50.894, Speaker F: So next steps for this are to explore whether this is truly in the digital ADSM and see if there's FFG safety concern. Yeah, so that's it for the notebooks. And then the second post is about the p two p market and EPDsen. Basically, I was wondering, what's the value of this?
00:15:50.942 - 00:15:52.090, Speaker A: Through the protocol?
00:15:52.910 - 00:16:44.882, Speaker F: Terence and POTUS have done great work on this and they've highlighted a few potential advantages. So it would allow for anyone to set the floor price for the auction. It can be used for met burn in future postfill upgrades if necessary, and it lowers the entry barriers for very long field builders who may only bid very inefficiently, so don't want to keep up a safe RPC node. I explore what the value of this is through the protocols and see if there are any other advantages in disadvantages. I would say that the TLDR is the p two p market is definitely very nice to have, and it could be very valuable for some composers to express their preferences. For example, allowing them to set the dynamic reserve price throughout the auction, which would span society. And also, it seems like it's fairly implementable, so it doesn't serve too many downsides.
00:16:44.882 - 00:16:49.830, Speaker F: Yeah, so that's it. If there are any questions, I'd love to hear it. And otherwise you can always reach out to me as well.
00:16:51.530 - 00:17:24.130, Speaker A: Thank you, Julian. Any questions for Julian? Nice. Okay. No question. Good. Okay, so the next one, the agenda is that blah, blah, blah. I've been working on this documentation, basically trying to figure out how the end to end blog proposal works under epbs.
00:17:24.130 - 00:18:06.064, Speaker A: Because currently blog proposal is very simple. You have a validator as a signer, and then you have a beacon node that provides the blog. So the validator get a block from the beacon node, signs it, and then send it back to the beacon node. It is a very simple process. But then in the epbs that it is a commit and review approach. Meaning that blog proposer for a local blog you will have also to sign the header itself. There is this extra round trip of signing basically.
00:18:06.064 - 00:18:49.696, Speaker A: So the question is that how do we optimize it in a way that in the happy path say that if you're using the builder it doesn't delay the blog proposal timeline. So definitely open to feedback on this. I'm still working on this documentation, but here are just a few ideas you can think of. Like the first idea is that as a proposer you can just call the prepared block endpoint first. And then when the prepare block endpoint is code that the beacon node is preparing everything in parallel. That is the consensus data that is getting all the execution. Compare that and then essentially, just basically have the block prepare.
00:18:49.696 - 00:19:26.110, Speaker A: Then this prepare block endpoint will essentially return like a local true, like Boolean. And then if the local true boolean is returned then as a proposer you know to whether go get header or get block. If it's get block, that's just a builder case. You get a block, you sign the block and you're done. But then if it's a local block boolean is true, then as a proposal you will call the get header first, then you assign the get header, return the get header and then, and then, and then call the get block and then again.
00:19:26.190 - 00:19:26.406, Speaker E: Right.
00:19:26.438 - 00:20:43.812, Speaker A: And the reason that is that you need to call the get header first because the header of the block is, has uh, is basically related to the state root, right. And then because of that there is this dependency that like we cannot do, we don't know the state rule of the block unless the header is sign and then we, and then we also cannot have, I guess like for me, I don't want the proposal to do it and sell proposer shouldn't do the hash two routing. So this is kind of the first proposal, sorry, the first idea, the second idea that I had is that just have the proposal called the get block as today. But the get block will either return a full block or a head or a header. If it's a header or if it's a full block, then it's the same business as usual today. But if it's a header, then the proposal will sign the header, submit a header, and then once it submits a header then the return the block, and then the proposal will sign the block and submit a block. I guess my takeaway is that because we want to give these options of a local block building.
00:20:43.812 - 00:21:42.920, Speaker A: There is no nice way of doing things. Basically the API gets pretty ugly and I'm also not an APIs. First of all, I'm probably doing things way more complicated than issue here. But it's worth noting that since that we are moving to slot auction with high confidence that this issue does not exist in, for example in the slot auction because of proposal. Just need to sign once and which is nice. But yeah, I wonder if anyone have any feedback on this or if anyone run into the similar issues when they design validator client signing today. Okay, I take no feedback.
00:21:42.920 - 00:21:45.120, Speaker A: Yeah, go ahead dusty.
00:21:45.540 - 00:22:59.190, Speaker E: Yeah, yeah. So I think a general, maybe use something I would look at here as a, well, sorry, throat carrying over the idea that the idea two seems to have to bake into more layers of the stack, let's say uh, policy questions like, like user preferences. And also some people are running obviously staking pools which require some set of, you know, choices. Presumably we'll continue to do so. Any of these policies or preferences end up needing to be baked into more of the protocol in an idea two style way. Idea one has, I mean this is just looking at, you're specific to kind of maybe somewhat straw man proposals, but at least comparing those idea one, the proposer has sort of more directly controls a lot of this policy and to me that's an advantage because it reduces coordinating costs across the layers which have proven problematic or high.
00:23:04.790 - 00:23:22.370, Speaker A: I see, that makes sense. Yeah. So the, so, yeah, so stands out. Yeah, we won't give proposal more control, but giving proposal more control. We need to have the endpoint for that. And then the endpoint is basically just get header and then. Yeah.
00:23:24.480 - 00:23:46.712, Speaker E: Yes, sure. But I think that sort of pays off. Sort of. I think having in certain ways it's a simpler endpoint too. So that's sort of the, it's a semantically simpler endpoint, simpler to test, decomposes more readily. My tendency is to. Right, and as well.
00:23:46.712 - 00:24:46.484, Speaker E: Yeah, sorry. My tendency is to look at that as probably a more overall straightforward system between those two particular options, even to the extent of the, should local header be used. I mean that's an example of the kind of policy question that in theory the proposer itself could choose, but the fact that it goes through that cycle of the proposer can in theory, I mean there's another variant of idea one, which is idea one, but the proposer just ignores the local header flag and does whatever it wants. I mean again, better or worse. The point is that, that flexibility is there. And as so indicated in chat, I think that one of the, maybe a concrete guideline is does it support proposed block v three? I'm not. I have, look, I have my issues with that API, my quibbles with it.
00:24:46.484 - 00:25:36.450, Speaker E: But broadly speaking I think it speaks to a set of two things. First, it's a higher level API. It's something that validator clients are expecting to call and they should be ideally as insulated from a lot of this as possible. As many of these changes should occur in the beacon node and below for Epps in general stages. Hopefully the beacon API should be able to be at least somewhat conceptual on this point. Secondly, that we have seen the discussion and that has been sort of litigated. What do people want out of these APIs? What kind of choices do people want in terms of picking blocks and that API? I don't want to just get in too much into that because that will need its own discussions at some point.
00:25:36.450 - 00:25:54.912, Speaker E: It makes a lot of assumptions effectively that the choice is either local or builder. API specifically needs judgment, sorry, needs adjustment. But, but I think at least the discussion around it points to has a lot of specific evidence of what do people want and what people want. I think id two is not flexible enough to accommodate.
00:25:55.056 - 00:26:21.430, Speaker A: I see that makes sense. Thank you. Any other feedback? Cool. So that is all I have on the agenda items. Are there anything else people want to cover?
00:26:29.290 - 00:27:46.822, Speaker E: So I have a general question, I guess because it's been coming that let's say on well, this is related to the testing. It appears like what is the, this is a question, what is the overall priority of having this be testable or I understand there's a chicken and egg thing to some extent of saying like I know POTUS is on record saying he doesn't, you know, wants to spend to bound to the amount of time he spends on the sort of fully ready test for the EF test suite. Unless it's clear this can go in at some point and at the same time what that means is I know Ethan discovered in the last, you know, has been discovering but discovered more in the last few days. Yeah. You've seen this, right? I know you and he have interacted on Gibbon and all that discord I guess as well. So, but my question is going, so starting, starting from that, is this a priority or what is the plan around maybe frame it in a more open ended positive way. What is the plan around testability as this develops or changes going from block to slot auctions or any of the other changes that are being discussed of epbs as a whole.
00:27:46.822 - 00:28:03.630, Speaker E: Is there a roadmap, even a very, very informal roadmap towards, um, Devnet? I know POTUS has talked about I wanting something by Defcon. That's great. I would love for that. But like so far it doesn't look super likely.
00:28:04.730 - 00:28:21.380, Speaker A: Yeah. So um, I guess one question to use, when you mentioned testing, are you implied the testing for the python spec or you implied testing for like a client code, like unit test, Devnet end to end. What type of testing is this?
00:28:23.120 - 00:29:13.740, Speaker E: Well, I would say both. They have different purposes, obviously one is, but. So for the EF consensus spec tests, those are a good kind of, let's say model checking in a way. And they are not obviously realistic tests in the sense of running different clients and network traffic and anything else. Yeah, but they, but they show some of these assumptions and about, like when do you do Randa or whatever? You saw that. So that, that's one. And, and in fact, I think POTUS himself has discovered many things working through the fork choice and he's talked about them in previous meeting or, and you're working in the discord channel working through some of the fork choice tests, discovering that or discovering why he added the merge stuff to the spec, which is like.
00:29:13.740 - 00:29:37.280, Speaker E: And it. So it just discovers these edge cases which otherwise are easy to maybe not see or ignore. That's. .1 I think. My note, Ethan and I are different people despite both working on Nimbus. And so I would say he's working on the consensus spec and he's a little more focused on that at the moment.
00:29:37.280 - 00:30:25.290, Speaker E: And that's what he happens to be doing these days. I personally am more so. I acknowledge his concerns and they are real. My personal, I think the more likely schedule blocker or schedule hindrance is going to be having the devnets and local test nets and infrastructure for that. I think one really concrete thing is, is this something eth ops is at all ready? I think that they've been very helpful and kind of just be able to set up infrastructure that allows it for this kind of testing to become practical and easy. They do the hard work to set that up.
00:30:27.070 - 00:30:55.278, Speaker A: Right. So yes, I definitely agree with you. So the reason I asked that is that I think like, for the spec testing, I think like just personal opinion. I think POTUS may agree with me that it's just like, I think we should put less emphasis like POTUS, for example. So currently EIP 7732. So the feature is merged into the main develop branch, but there's no testing around it. Right.
00:30:55.278 - 00:31:22.802, Speaker A: We haven't written any new tests for the Python spec. And then, and then that's, and that is also by design because I guess like, I mean we don't know how to do it. We can learn how to do it, but that will take time. But we rather do what we're good at. That is writing client code. That, that is having a death net, that is having an end to end test. We should spend time on writing this python spare test.
00:31:22.802 - 00:32:11.828, Speaker A: But the question is that like we probably don't want to do it unless we are confident that this EIP will get in post Petra. But then to gain confidence we have to have a Devnet beforehand. And that is where our thinking is to spend less time on the python spread testing, but more time on just writing client code, having a Devnet. So I guess between polters and I, this is basically our full time thing right now without doing anything else. So basically having a Devnet is a priority. I mean, I mean, say if today it fails, it doesn't get in, we form some breaking bug and that is great, but then we don't know what this breaking bug is unless we have a Devnet, unless clients start implementing it. So that's just my take.
00:32:11.828 - 00:32:14.000, Speaker A: I wonder if anyone have any takes.
00:32:17.180 - 00:32:34.840, Speaker E: I mean, I agree broadly with that. I'll say in terms of overall, I think the Devnet practically speaking, is more immediately important, let's say more short term important than the spec tests. So. Yeah, sure.
00:32:35.620 - 00:33:08.470, Speaker B: Yeah. And if I remember correctly, one of the objectives to actually having something really working in practice is also to test if we have good performance when we have less time for aggregations of slot anatomy changes. So we really want to run those stuff in practice. It's not something that is tested by just running python test checks on the specs. You really want clients to run and deal with networking and slowness in general.
00:33:08.930 - 00:34:05.586, Speaker E: Yeah. And that also speaks to Devnet specifically. I mean, one of the strengths and weaknesses of kurtosis is that, well, they can assert torque and can certainly add and other technique can add sort of known issues largely. They're kind of discovered after the fact, sort of what are the ways in which this spec or protocol can fail? Can weird message ordering or kind of, it's a, it's a kind of fuzz testing and. But you have to kind of know how to fuss and. Yeah, and so there's a, that means that you kind of have to learn how to that first by running, I mean Devnet in a more, I think natural way is probably the most productive direction. And then otherwise kurtosis and similar techniques often are.
00:34:05.586 - 00:34:27.011, Speaker E: They're testing kind of very happy path setups. The network works perfectly. There's no wait and see. Everyone starts on time. Nobody has to ever sync. I mean, it's so. And Devnet's really hit, I think are a good way to hit a lot of these sort of test.
00:34:27.011 - 00:34:32.439, Speaker E: What are the first things that people are going to run into in terms of testing it. So. Yeah, yeah.
00:34:36.379 - 00:35:00.444, Speaker A: Yeah. I guess also speak for prison. Like, I think, like we are, knock on wood. We're fairly confident to have something before DeF Con. I think like four choices by, by far the hardest part. But other than that, it's also a very interesting part as well that, like, it's actually so. I'm personally pretty excited to see in progress.
00:35:00.444 - 00:35:15.852, Speaker A: I think at the minimum we could just have like a solar validator. We don't even need actual builder, just solo validator, signs its own header included, broadcast a block, then Brock has a payload after for a local devnet. I think that's fairly doable, but.
00:35:15.876 - 00:35:16.480, Speaker B: Yeah.
00:35:18.820 - 00:36:00.752, Speaker E: Well, and this is the kind of thing that POTUS has discussed in the past as what are these sort of minimal intermediate steps which are not the system that will be built out overall, but which show structurally how epBs, the protocol, can still work broadly with the existing players and assumptions and so. Exactly. If you can show, and especially for people who want to see that it can still work. Apropos the discussion earlier about slot options and local building and things like this, that EPBS does nothing by its adoption exclude currently relevant use cases. So I think it's. It's still a useful exercise, even if it's not sort of.
00:36:00.776 - 00:36:01.288, Speaker A: Yeah.
00:36:01.424 - 00:36:04.620, Speaker E: Yes. As will be seen by the world eventually.
00:36:05.240 - 00:36:06.420, Speaker A: Yeah, for sure.
00:36:10.560 - 00:37:03.110, Speaker B: So it is fair to say that transition to slot auction will be after the first round of implementation, because if we are, especially you guys in prison, if you are in rush to implement something for Defcon, maybe switching to slack auction may be slowing down even more. We want to really test something that is really not relevant from the way you got the block. Maybe it's just testing the overall structure of things. Maybe it's less important to change slot action quickly. What's your feeling? What are you feeling?
00:37:05.530 - 00:37:32.992, Speaker A: Probably just like two to three days of work. I mean, I will if one of change, we should just do it now. But then I guess, like the reason that I haven't done. I wasn't at the last meeting, which is there wasn't that many like signals to thumbs up. But things like today we got more thumbs up. I guess eventually we'll reach over the threshold and someone will do it. But yeah, I will make the meeting note saying that like tech who name boss and the lo star both supported.
00:37:32.992 - 00:37:35.060, Speaker A: And yeah, we'll go from there.
00:37:37.040 - 00:37:37.900, Speaker E: Okay.
00:37:42.480 - 00:37:44.180, Speaker A: Sounds good. Anyone else?
00:37:49.480 - 00:38:37.870, Speaker E: So one final thing maybe, is that I think it would be useful to have a slightly codified version. I know POTUS has mentioned this a couple of times, and I have, I know offhand what some of the steps he has in mind are like a scaffolding steps, basically. I mean, I guess practically. I'm really, I'm looking at this as the person implementing this for NimbuS currently. You know, right now, it doesn't really matter. There's, they're implementing some, their computational algorithms, more or less, and that. But there will be a common point at which we start getting to, you know, how can we kind of keep having minimal viable, minimum viable kind of constructions, I don't say products here, but to test evps constructions.
00:38:37.870 - 00:39:18.220, Speaker E: And I know POTUS has, again, he's suggested some in the past. I know what they are, and I can, I can, you know, relay those and help implement those. But I think having that scaffolding be, I don't know, some suggested, not the only possible, but be written, or having some examples, minimal examples of what an EPBS setup might look like. That does not depend on having a full, I don't know, eth, panda ops, multi client, etcetera infrastructure might look like.
00:39:19.640 - 00:39:21.640, Speaker A: Is this just more like a testing setup?
00:39:21.680 - 00:40:42.528, Speaker E: You're thinking about roughly or even more development and testing? I mean, this is, I'm thinking back to a little bit, you know, how the engine API or so we had these sort of staged development of where long before the interop achieved, how basically, and the purpose that the consensus sort of have now, which is kind of everyone comes to the table with like, maybe they have bugs, but everyone passes the consensus spec tests. And so we're kind of the scope of issues here. I guess what I'm suggesting, I mean, it doesn't have to, I don't know if it can be as codified that we don't have a bunch of convenient unit tests for everyone to run, that that's not, it's not that uniform yet, or maybe, nor will it ever be, but something where maybe some possible scenarios that are known to be simpler or known to be achievable in the scope of one client, maybe starting with kind of what you're describing, the kind of local block building only. But because one. I'll provide a concrete example of the kind of thing I'm thinking about. It is possible to start with. One of the major refactorings is going to be the slot timings.
00:40:42.528 - 00:41:09.040, Speaker E: And when things happen within a slot, that's fine. That's how this works. But that needs testing. And that needs. Ideally, that we can start testing that in an isolated way on its own. And that means testing with locally built blocks using the existing engine API and things like this. And that's kind of what I'm getting as having an example.
00:41:09.040 - 00:41:35.270, Speaker E: I don't know. I guess we use the word milestones in Kenya a little bit in previous meetings to kind of. To kind of. Kind of scaffolded milestones. And so far, I mean, they clearly exist in different people's minds. I have some in mind. I know POTUS definitely has a bunch of specifics he's been able to just rattle off offhand, like, I know they exist, but, like, having those written down.
00:41:35.750 - 00:41:44.478, Speaker A: Right, right. So I guess before, even for every harbor, we had this m zero, m one, m two. Like those milestones, we basically do the same thing here.
00:41:44.534 - 00:41:47.142, Speaker E: Yeah. Yeah, that. Yeah, exactly. Exactly. That's.
00:41:47.166 - 00:41:47.302, Speaker A: Sorry.
00:41:47.326 - 00:41:49.094, Speaker E: I was not very good at expressing this, but.
00:41:49.142 - 00:41:49.678, Speaker A: No worries.
00:41:49.774 - 00:41:53.686, Speaker E: Yeah, I was good. I was just getting. Yeah, for sure. Awesome.
00:41:53.718 - 00:41:58.090, Speaker A: Yeah, no, that makes sense. Definitely. Yeah. I will add notes to that as well.
00:42:02.680 - 00:42:06.220, Speaker E: Anything else from me? No.
00:42:07.680 - 00:42:11.820, Speaker A: Okay. Well, thank you, guys. Happy Friday, you guys. Around the Internet.
00:42:14.360 - 00:42:15.216, Speaker B: Bye, guys.
00:42:15.328 - 00:42:15.752, Speaker A: Bye.
00:42:15.816 - 00:42:16.368, Speaker E: Bye.
00:42:16.504 - 00:42:16.976, Speaker A: Thank you.
00:42:17.008 - 00:42:17.120, Speaker E: Bye.
