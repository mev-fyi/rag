00:00:06.120 - 00:00:44.682, Speaker A: Okay. I guess we could probably get started. I had a few things on the agenda for today. Basically some spec discussions, then following up on wallet best practices. And I don't know if there's been another proxy pattern, but, yeah, see how things go. And Sandeep is here. So I guess, yeah, let's maybe kick this off with the revocability conversation.
00:00:44.682 - 00:01:34.010, Speaker A: So, Sandeep, I believe you're the one who posted on. On Eran's behalf on eth magicians around optional revocability. Do you want to take maybe a minute to, like, walk through your views and. Yeah. Concerns there. Yeah. So with the revocability question, we have been considering the sort of security handling and concerns, and that it's the same as a private key or a seed phrase, but, yeah, like, I disagree there, because once you delete the wallet from the browser, the seed phrase or the private key is supposed to be gone and no more with the wallet provider.
00:01:34.010 - 00:02:13.202, Speaker A: But with the signatures, it's a different deal. Like, once you make a 770 transaction, the authorizations live on the chain. And so let's say if I don't trust the wallet anymore and I want to move to a different wallet, then I should have an option to do something similar to, you know, sign out of all accounts or sign out of all devices. There has to be, like, a mechanism for that. And, yeah, otherwise there's always a lingering question about, you know, is it safe? There was a authorization that. That was there, and it wasn't really revoked. So what.
00:02:13.202 - 00:02:58.938, Speaker A: What happens there? Secondly, second point is that, you know, like, with. Sorry, just a minute. Yeah, so the people who are opposed to revocability, I don't think they're opposed to, um, revocability as such, but the constraints that it poses on the wallet providers. Um, and. And I think the nuns solution. The nuns revocability is definitely, um, like, too constraining for the wallet providers to create the. Create a proper ux.
00:02:58.938 - 00:03:38.704, Speaker A: So I think we should investigate, like, more solutions. Um, certainly Max Nance is one such option. The nuns manager is one such options, and, you know, like, I think we can come together with more solutions on top of this, which have revocability baked in and also allow the wallet providers enough sort of breathing room to create the yolks that they want. So I think that's the two points I want to put forward. Okay. And, yeah, I guess so. There's some.
00:03:38.704 - 00:04:24.532, Speaker A: Yeah, some. Some comments in the chat around. Like, if the wallet sent out the private key, it would also be unsafe forever. Even if you deleted the signature. And then, yeah, maybe some comments from you are about like, if the views in your hardware wallet, then the, the private key basically should not leave the hardware wallet. So there's like a difference in trust assumptions there where like, if you use a hardware wallet today, have the private key on there, and then use, you know, something like metamask or rabbi or whatever to, like, interact online, there's no way that, like, metamask can leak your ledger private key. And this is like a change in trust assumptions.
00:04:24.532 - 00:05:26.154, Speaker A: Whereas under 7702, if metamask signs something, effectively makes every wallet like a hot wallet, I guess. Is that like, maybe? Yeah. Is that like how you would describe the trust model? Like, any 7702, every 7702 wallet should be thought of as a hot wallet, basically. Richard. Yeah, I mean, my take is basically just the moment you sign a 7702 signature, that basically is like handing out, like extracting your private key from one wallet and inputting into another wallet. In this case, you're just inputting it into a smart contract in a way, which is definitely new. But in terms of like, how the trust assumptions to your old wallet are basically the same, at least that's my understanding.
00:05:26.154 - 00:06:19.992, Speaker A: Right. Then I guess the risk that a user is you think you're just signing something, just like how you sign a random sign in message on your ledger, but then you're actually doing something that's closer to exporting your private key, and that's not super obvious to the user. Well, to be clear, of course, the idea was always that this would already be a failure by the wallet. Like, you should never make it look like signing a signature. It should look like exporting your private key or something close to it. At least it should definitely go closer to exporting the private key than to signing a signature. And so the question is more to what extent do we trust that wallets will follow those best practices and recommendations around how to, how to expose this? Got it, Richard? Yeah, basically.
00:06:19.992 - 00:06:53.230, Speaker A: Also what Anska said for me, the question was also when we had the record session in Berlin, actually there, we had people from ledger there and we talked with them, and it was already a big benefit that there's a very distinct way that wallets can enforce it. You trust the wallet already to a big part. If you don't trust your wallet, you kind of lost in any case, and the wallets should enforce that. You set a nonce. Right? Like not setting the nonce. I mean, we went in the best practices, we try to outline it. In what cases do you not set the nonce there.
00:06:53.230 - 00:08:53.980, Speaker A: I think especially in the short term, that's more like a, like a very advanced case that normal wallets most likely will not enable at all. Why should ledger enable this? There's no good reason for this, but this I think in general, for me, the question which I also post in general, like where should we enforce it on, on the wallet level, which we have trust assumptions towards the wallet in any case already, and where should we enforce it on the protocol level and where is it just that we provide a means to enforce it? It would be interesting to understand a little bit better this shift because this is for me in general, I think everybody agrees we want to provide or we are fine with providing a way for revocation. It's not a discussion anymore. Thanks. And yeah, I guess, yeah, I guess one also question around like unrevocable transactions is, you know, if you do, like you always say, if you change your wallet, you know, you realize your old wallet was a bad wallet. Um, yeah, effectively the, if it's not a revocable signature, then you sort of have to assume they see that it's as bad as if the private key had been compromised in that wallet. Um, yeah, and I guess standeep, like what, what would you feel comfortable with in terms of like, yeah, design? Yeah, definitely revocability should be there and then like some way somewhere to have, where the work provider also have the design, the UX that they want.
00:08:53.980 - 00:10:00.184, Speaker A: So, you know, it's not um, not like living nuns where you just make a new transaction, it invalidates all the authorizations. So definitely not as restrictive as that. But yeah, there should be enough breathing room for the work providers as well. But yeah, revocability should be mandatory. I think another point is that if we allow the work providers the option to have revocable or non revocable signatures or authorization, then I don't know, maybe we allow the users, we let the users also, we sort of leak that information to the user as well, where they have, where the user has to know if they are signing a non revocable or revocable authorization. And that's not exactly user friendly for me. And secondly, what's stopping the wallet providers from just having a non revocable authorization in their Ux? And the user later on realizes, oh, it was non revocable and now I can't do anything.
00:10:00.184 - 00:11:05.524, Speaker A: Thanks, Ozgar. Yeah, I just wanted to say that I think if I remember correctly on like last call, there's definitely some openness even by people who are skeptical towards the mandatory revocability to at least explore that direction further, because if it was to be done in a seamless way where it wouldn't come with a lot of trade offs, I think people would definitely be open to that. I just think so far the only proposals that we have had in the direction have just not been good enough. I think Max non specifically, for example, the general feeling was that then requires some sort of in EVM mechanism to bump your nonce by more than one at a time, which just is a kind of like then a kind of worm on its own. You can't really get that to have a kind of nice minimum in protocol footprint. So that just seemed to be non starter. Nonce manager is like basically way too heavy as an overhead, because now you have to load an entire separate account every time you use this, which would massively increase the cost.
00:11:05.524 - 00:11:56.340, Speaker A: So that's a non starter. There are ideas like for example, Vitalik had this idea put potentially saying just actually store the delegated address associated with your own account before worker. That's a little bit hard to do. So we could do some sort of trick where we basically store it, just add your address plus one basically, and then put it into the code field, which is a bit hacky. And the question is how would that affect the vertical transition? But ideas like that could potentially be done where you basically then get revocability because you basically have to manually set that address and then manually change it again. I think in that setting we would probably have to rework 7702 a bit more fundamentally because then you basically just want us basically some sort of set transaction or something, and then a revoked transaction or something. So that would definitely look like you wouldn't just basically you would have to make some more fundamental changes.
00:11:56.340 - 00:14:17.740, Speaker A: My feeling is, given the pector timeline, that if there are people who are still uncomfortable with the current optional revocability, that it would be basically on them to keep pushing for and for helping finding a solution that actually is good enough, that would have a full revocability and do so reasonably soon. I think if say within the next month or so we don't have a fully specced out alternative proposal with full revocability that is good enough and is broadly accepted, then my feeling is we will just, this will not happen. So just for people who kind of still very much want this, I think basically the onus is on them to find such a solution. The comments so I guess yeah, one question I had was on the account abstraction or wallet side, if we ship with default revocability using the nonce in Pectra and potentially find an optional approach that's maybe more complicated that people like, but that will take longer and have that in the forecaster. How bad is it? Or like how much of a reduction in value is it? Yeah, how much of a reduction in value is it to shift the v one with mandatory revocability and then potentially soften that in the future? So I draw on the call kind of late, so apologize if I like, apologies if I miss something, but. So when you say mandatory revocability, are you talking about like going back to 374 like it was before, where it's like which Ongar is saying is useless right now? I guess so. So, so you're asking like how much of like a usability hit will it be if like every single UA transaction revokes everything? Yes.
00:14:17.740 - 00:15:59.904, Speaker A: Oh yeah. So the point I've been making, and you know, you know, you know, you know, and really it's not just me, you know, I'm pretty sure it's like every AA builder in this call, right? You know that like most of the most valuable AA use cases requires longstanding authorizations, right? So like if every single EOA transaction will invalidate everything, then this will vastly reduce the usability and usefulness of this EIP. Yeah, got it, thanks. So personally I want to maybe just say that, personally I think that's the changes that I think it was Matt that proposed in the latest PR updates, which is to make nonce optional. That might be the best approach for now. I think personally, in the world with optional nonce, would we still be doing same nonce or less than equal to nonce revocability? My feeling is basically that, basically Maxman's mechanisms, so that the literature would be that your counter currently has to have a nonce smaller or equal to the one that you signed over. That can still be useful in a pattern where you basically say sign over the nonce, the count nonce plus five or something.
00:15:59.904 - 00:16:58.392, Speaker A: But the problem is, what if your wallet made you sign count nons plus 1000? Then basically now you de facto don't have revocability anymore. So now you would have to have a mechanism in protocol to bump your nonce by 1000. But then basically you have to solve all these other questions of like, but how can you basically say some sort of maximum bounce level at once? But then if you, if you do this again, then basically now you, the question also becomes now the signature should only be valid if it is at most this amount above the current nonce, which means like, it's basically this is this entire kind of flavor of max nonce signing. Just. I have not seen a proposal there that seems sensible. Okay, so you would say same nonce in that case. Yeah, which that's, that's why I specifically think that basically mandatory revocability using nonce at all to me is just nonce data, because I think you can't really do Microsofts, you would have to do same nonce.
00:16:58.392 - 00:18:12.870, Speaker A: And if you do same nonce, then you have to make it optional. Because if you make it mandatory, I think the DAP is relatively useless for the main use cases we were trying to aim for. Nonsense is a non starter, basically. Sorry, I missed the question. Could you repeat that, Anna? I was essentially asking whether, you know, regardless of whether we were shipping mandatory, you know, mandatory nonce based revocability, whether the nonce based revocability would be same nonce, like require that the account nonce is the exact same as what signed over or like Max nonce. So like, you know, it can't be above this nonce. Oh yeah, please, Anna.
00:18:12.870 - 00:19:07.914, Speaker A: Oh, I was just going to summarize what Ansgar said, but yeah, Ansgar was saying that the max nonce mechanism was too complicated, had too many gotchas, basically in terms of how we would establish best practices around it. So he was saying that same nonce is the better option, but that it's important to have it be optional in that case, or else the EIP is essentially useless. Sandeep? Sorry. Yeah, so yeah, agreed. The same one says then a non starter. And the best solution we have for revocability is to have maximums with in protocol mechanism to bump the means. It's encore.
00:19:07.914 - 00:19:53.676, Speaker A: Yeah, I was just going to comment on a few issues that I see with having the same non revocability even in options scenario, is that, as direct mentioned, one of the major use cases of account abstraction is session like behavior. Right, where you sign a transaction once and. Or you sign an approval once and you expect it to be available for a long time. If this assumption is correct, then most accounts would be signing the authorization with the nuns and chain id set to null in most cases. And in this case, once it's signed, then it just becomes, then this particular signature becomes non revocable. Right. So if for whatever reason in future, a bug is found in the implementation to which the authorization is signed, then it still becomes non revocable.
00:19:53.676 - 00:20:45.796, Speaker A: With the Max nuns approach, you still kind of get the option to revoke it. Even if you feel that, even if the earlier approval was given with the intent of being long standing. So I feel that, you know, for in the worst case scenario, where most of these sessions being signed are actually long standing, the max launch might be, might have better security guarantees. Yep. Thanks, Amand. Yeah, I just wanted to bring attention towards like the hardware wallet kind of conversation because like, we were discussing revocability and revocability. And let's assume that hardware wallet is account a and you have smart contract wallet account B.
00:20:45.796 - 00:22:17.974, Speaker A: And in account b you have account a as the authority that can control account b. Now would it, wouldn't it be the same if, for example, account a had all its funds in account b already, and then account b had a had a bug and you then, as if it is, was account a who delegated to account to a smart contract that is similar to account b, and that smart contract had a bug. So it's kind of like when you do this authorization, you are saying, this is my smart contract wallet. This is the implementation for my smart contract wallet. So the same trust assumption that you are putting into a smart contract wallet should be here. And if this bug exists, then like it, it will exist also for all the smart contract wallets that will implement the same implement that will have the same implementation. And this is like, I think given that we already have this trust assumption for smart contract wallet, I'm not sure why we're trying to impose a higher level of security for eoas that are trying to implement like, follow this.
00:22:17.974 - 00:23:02.214, Speaker A: Yeah. So when I'm interacting with a smart contract wallet, then definitely there is trust placed on that and I'm doing authorization. So definitely a lot of trust is placed on that. But as a user, I should be able to decide the lifetime of that trust. And like, once I decide, okay, I want to move away from the wallet to another wallet, then I should have like a final call to be able to revoke all the previous authorizations. And without revocability, that is not possible. But we have a proxy for this.
00:23:02.214 - 00:24:28.534, Speaker A: Like if you have a proxy that can do, like if you sign a proxy, then you can actually assign which wallet you want as your implementation or assign none. So no wallet is your implementation and you basically revoke the whole authorization if you have a proper proxy. The problem is if you don't sign a proxy or a proxy that is audited and wallets should not let you do that in the first place. But if you're signing an audited proxy, an approved proxy, then this problem disappears. Okay, but if I move to a different smart wallet, then wouldn't the previous authorization still be sort of valid and can still be used. No, like if you, if you change the implementation target in your proxy contract, in your proxy storage where it is storing the target, whether it's outside storage or in the, in your EOA storage, then that the previous smart account implementation will not be valid anymore. Only the proxy is the thing that is permanent for you, which can also be revocable by setting the target to nothing, to the zero address or something like that.
00:24:28.534 - 00:25:44.198, Speaker A: Okay, so if I'm signing over the proxy address, then it has the implementation address in the code. So I'm effectively signing over that as well is, sorry, no, when you, when you sign up proxy address, you're just signing the delegation, and then in the call data of the actual transaction you specify the target. Okay, I see. Yeah, David. Yeah, I also wanted to add my thoughts regarding the in protocol level revocability. I think for smart contract wallet in general, the 4337 itself was developed on top of the protocol layer. So it was mostly like the account obligation to have a non repliable and a revocable approach.
00:25:44.198 - 00:27:19.030, Speaker A: But I think for EOA it's quite different, because right now protocols can make a choice to make it fully revocable at the smart contract at the protocol level or not. So I think like we should somehow view this in a different way, because for the smart contract wallet right now, like, it wasn't able to have like an in protocol revocation mechanism. And other than that, I actually agree that protocol level revocation is needed. But the nonce is not a good approach because there are a lot of times where the AA wallets use case relies on the user for a relatively long period of time, that if we assume that a single EOA transaction revoke it, it will be like practically useless. So it might be quite dumb. But I was thinking whether if we just add a new transaction type to just revoke all the existing access control that we granted to the implementation, what would be the approach? Or if that would be visible or things like that? Any responses otherwise? M. Lordell sorry, it's Nick.
00:27:19.030 - 00:28:16.316, Speaker A: It's just my GitHub handle. No, I just also wanted to say that I think echo the sentiment that protocol revocability is super important. I think there's a very specific case where it can actually cause issues if you rely purely on some on chain revocation method is things like token callbacks, where something that has code behaves differently than anyway, and some implementations. And you can actually, you know, you know, you can think of scenarios where these, these 7702 authorizations can be used as sort of DOS transactions if you have, depending on how it's implemented, but you can cause certain token transfers to fail just by including these. And if so, I do think it's super important to have protocol level revocability. I also brought something up in the chat. I don't know, someone said we should maybe discuss it more explicitly so I can bring it up now.
00:28:16.316 - 00:28:56.430, Speaker A: But it was at least my understanding with 7702 is that it was meant not necessarily as sort of this end goal thing. So my personal stance is I like this. I actually like the nun system for revocations. I liked it also for 3074. It does sort of restrict your design space for wallets, but at least in my view, it's not super obvious. This assumption that we're making, that accounts will work as hybrid eoas and 7702 based smart accounts. I know that this is if you have assumption, yes, obviously this way with the nonce is sort of really bad and really breaks a lot of things and makes it kind of useless.
00:28:56.430 - 00:30:04.704, Speaker A: But I would like to challenge that assumption because it isn't obvious to me, and I think it's an okay compromise, given that this is sort of like a temporary solution to say that for this to work for eoas, then you really should use your eoa as a sort of smart account always. That's just my opinion. Derek. Yeah, you know, I, I kind of reply to that on, uh, on the chat as well, you know. But I think, I think, I think there are like, there are a few reasons why. I think it's probably more reasonable to assume that people will be using their accounts as hybrid accounts rather than using it as pure smart accounts. And the reasons so what? First of all, I think there will be a lot of users who only use 7702 for things like batching, for example.
00:30:04.704 - 00:31:03.442, Speaker A: It's not actually a given that all users would be using a fully featured smart account. And this is especially important because right now there are a lot of applications that are not very compatible with smart accounts. If a user only uses their UA's as smart accounts today, they will find that their account will stop working on a lot, on a lot of applications. Because the reality is there's a lot of applications that don't work very well against smartwalls right now. So for pure usability reasons, I expect a lot of users, if not most users, to be using their wallets still primarily as UA's, but then turn the UA's into smart accounts for specific applications that explicitly support smart accounts. And then there are also reasons. For example, um, like if you're, if you're going to use your UA as a 437 accounts, then this will only really work on networks that actually support 437.
00:31:03.442 - 00:31:18.890, Speaker A: Right. So keep in mind that like 437 is a ERC, right. Right. You know, so it's not implementing into the protocol. So not all networks will support 437 by default. Right. So if you turn your UA into a four, three, seven accounts, it will really only work on the networks that support 437.
00:31:18.890 - 00:32:18.870, Speaker A: And on the other networks you, it will still be used as a UA. Right. So I think like given all these reasons, I think it's more reasonable, it's way more likely to, uh, you know, just like it's more, some more reasonable for us to assume that, uh, accounts will be used as both UA's and smart accounts rather than just like only smart accounts. Yeah, yeah. I just add, like, if we're designing with the assumption that people will only use this as a smart account, then why wouldn't we be laser focused on just shipping like a migration style EIP, which we're not, I think for good reasons. And yeah, I agree that users want to use this as a hybrid. So I guess, yeah, we spent about half an hour on this.
00:32:18.870 - 00:33:33.256, Speaker A: It doesn't seem like there's a like silver bullet solution. It does feel like there'd be value, like Ankara was saying in the chat, to like explore the design space a bit more. Is there someone you know that wants to take this on in like the next week or two? Because it does feel like, yeah, we need something that client teams are comfortable shipping that, you know, is, provides functionality to or provides enough flexibility for smart wallets, but that, yeah, we don't feel compromising security too much. And so, yeah, I don't know if anyone has the bandwidth that's on in the next week or two, but it does feel like a pretty critical thing to get this shipped. Wait, team, sorry. So are you. Just to be clear, I was suggesting that we just like, by default we just go with the latest PR updates, which is to make the nons optional, I guess.
00:33:33.256 - 00:34:44.133, Speaker A: Based on Sudeep's comments, like, my concern is that the current state, like we can move forward with the current state and implement that. But I think there might be some pushback from l one client teams that, yeah, this is like not enough on the revocability front and we should ideally have alternatives to that. Yeah, so I think. And I think like, yeah, basically, yeah, Sudeep, I don't know if like on the Aragon side, you have some bandwidth to spend on that. Yeah, I can take a shot at it. Yeah, I think if, yeah, like, and I think, yeah, like figuring out what's like the right balance between flexibility for like contract developers security and like preventing users shooting themselves in the foot and then like complexity in terms of just protocol level changes. Yeah, I think if you can like try to think through this a bit and look through the other proposal, that'd be really helpful.
00:34:44.133 - 00:35:26.008, Speaker A: The other thing, I know there was a comment in the chat around storage management. Is there anyone, sorry, I lost the agenda. Is there anyone who had an update on that, that we discussed it a lot last week. Okay, so no update on the s store issue, I think. Yeah. You all had a comment saying that solidity was starting to address to work on. Yeah.
00:35:26.008 - 00:36:00.372, Speaker A: Storage namespace, I guess. Nothing else on that front. And then styling over the address versus code. There was a comment on that, on the agenda. Nick, do you want to give a bit of context here? I didn't put that on the agenda. I put it on the agenda. I think it was your comment around signing on the, on the forum, you mean? Oh yeah, sorry, sorry.
00:36:00.372 - 00:37:09.144, Speaker A: You put it on each magician's. Yeah, yeah, sure. I can give a little bit more context. I just argued for signing code because you, it gives you some of the, I mean, it is a little bit bigger. Right, which is the downside of using code versus an address, but it gives you this ability to sign additional context or add additional context into what the EOA is signing. And like the main use case that I had for this is you can basically, you can encode the configuration of the, of the account directly into, yeah, into the code similar to what the commit would do. So you, yeah, I give a short example on the Ethereum magicians, but it basically, it makes the proxy sort of simpler where you can make the initial set of storage and configuration be sort of permissionless, where you don't have to set the, you know, have the owner sign two messages, but have the owner instead sign the code plus sign and have the code appended with some hash which represents the initialization.
00:37:09.144 - 00:38:33.684, Speaker A: And then have the initialization be done by anyone because the initialization is checked, that it matches the parameters for the initialization is checked against the hash that's appended to code. It was just an argument for code. I don't feel super strongly either way. It's just, it was a nice thing and you can, one nice feature is you can kind of use Nick's method to generate these sort of disposable accounts with 7702 that use some code because you can add this extra context in there for configuration, but it's not something I feel super strongly about. Any comments or reactions? One more thing I also wanted to mention. This was something that was possible with 3074 because of this commit that was included in the bytes and sort of was lost when we went to signing address over instead of code. Any.
00:38:33.684 - 00:39:16.606, Speaker A: But if not, yeah, I guess people can. Oh yeah, please. I mean, I can answer if nobody else is answering. I think like the proxy contract supposed to. Basically, even if you have an authorization to a proxy contract implementation somewhere, the idea is that this proxy contract implementation should have like, if it's not initialized by this account, then it should revert any call that comes into it, basically. And this should be like the standard proxy contract implementation that wallets will whitelist. That's the idea.
00:39:16.606 - 00:40:11.764, Speaker A: And when you sign this authorization, then you also need to sign a transaction that basically initializes this proxy contract on the chain that you want to enable this on. Unless you want to use some cross chain thing, then this is different. But I think you need to push a 7702 transaction to initialize that proxy to choose the target implementation that you want. This is, I think, the main idea that says being pushed right now. Yeah, that was my point was then we need two signatures. Right. You need the 7702 authorization signature and you need the signature for the sort of configuration for the upgrade of the account.
00:40:11.764 - 00:41:15.310, Speaker A: Yeah. So the assumption is that the wallet will have a built in feature to sign both of these at the same time, but you will not need two signature to like press sign twice. I understand, this is, but my point was more that you still do need two signatures and this kind of breaks. Like I said, I don't feel super strongly about it, but it is sort of a difference with 3074 where you don't. And if you were to sort of randomly generated addresses or accounts for doing things, then you always have to have these two signatures instead of just one. Again, it's not like a really strong use case, it's just something I wanted to bring up that it is a little bit different from 3074 and. Yeah, but just this is, this is only for authorization and not for, just to be clear, this is only for, sorry, the initialization and not for every transaction.
00:41:15.310 - 00:41:49.934, Speaker A: No, I totally understand. I understand. You just lose the ability to make a permissionless initialization. Yeah, that's true. Yeah, elim. Yeah. So I just wanted to kind of talk about the reasoning for the proxy, because I think one thing that stands out to me is that the proxy doesn't actually solve security issues.
00:41:49.934 - 00:43:16.576, Speaker A: Yes, wallet providers don't have to sign over any other implementations, but then this just delegates the actual security work to whoever is in charge of setting the implementations or whoever is in charge of implementing the upgrade patterns to different implementations. So what this basically just boils down to is a verifiable way to track which implementation is currently being delegated to in the Ethereum state. So I think there isn't actually any need for a proxy. We just could just choose a magic slot in the account and then verified implementations will promise to check the slot to see if their implementation has been set. Maybe they can all record their template addresses into that slot, or maybe some magic value they can just verify to see if this slot has been set to their magic value before the implementation runs. Yeah, that's kind of what I wanted to say. All right.
00:43:16.576 - 00:44:55.534, Speaker A: So I guess, yeah, again, it's not clear to me what the like, or that we have like a finalized, like, design here. Anyone have thoughts or strong opinions about, like, what the next step should be? Okay, I guess, yeah. Ansgar has a question around picture timeline. Like, I think we are pretty far along. Like, I would have loved if we would have had this conversation in March rather than June. So, like, I guess one concern I see is like, if this takes two months to get finalized and it requires like significant changes, we're sort of too far along in the development process that the default path is we just bump this to the vexfork. So I think unless there's people actively working on this, and one challenge is the amount that can be done by just like, client teams alone is kind of limited because of the, like, needed context to, like, to understand, like the best design for smart accounts and wallet providers and all of that.
00:44:55.534 - 00:46:32.256, Speaker A: But, yeah, like, we should get to a final spec in like weeks or, you know, if we're lucky, it's like, oh, you know, it takes us, it takes us a lot of time, but then the end state design is actually super simple and like, maybe we can implement it later, but like, it. Yeah, so I guess, yeah. Derek, to your point, like, you know, clearly the Aragon team has some issues with like, the optional non certification. So I would feel better if we had like an alternative or something that was, you know, that was, yeah. That we could consider or that we thought was just straight up better. And we'll probably discuss this on tomorrow's call so we can get a sense of like, how, you know, how many people like aren't happy with the optional nodes, but it's like I would not rely on that exclusively as the design. Tim, can't we like, because like I see that there is mostly the objection is coming from the ergonom team for the null nons.
00:46:32.256 - 00:47:14.684, Speaker A: Like if, if they, if, if the people who are arguing for the null nonce can't find a solution in a certain period of time, then we include it as is. If everyone else is in agreement of on, on including it how it is right now. Sure. Like look, if everyone else agrees, it would probably be included as is. Um, but I think the fact that like at least one team is like uncomfortable, um, means it's, it's probably worthwhile to spend time re. Yeah, yes, as is, I mean, optional amounts. Um, yeah, it like, yeah, I would try to spend time to see what the alternatives are.
00:47:14.684 - 00:48:19.946, Speaker A: Um, and I think, yeah, and the thing, like, yeah, I would not want us to like get through like testing and whatnot and end up like removing this later on because we find some weird issue with this revocation scheme that like we didn't like. Yeah. And then, okay, and then Justin, on the basic side has uh, handling storage as being the handling storage as being the more complicated thing. Um, yeah, I don't know. Justin, you want to share any more from Bezu's perspective on that? Yeah, I was only bringing that up because it's a potential angle that we could parallelize on and maybe accelerate things. So if the revocation con, uh, conversations could happen in parallel with the storage conversations, I think there's two different audiences. Wallet folks may be more interested in the former and EVM folks may be more interested in the latter.
00:48:19.946 - 00:49:25.464, Speaker A: So at the end of the day, if we could sort out the storage stuff first, I think circling back to whatever we decide on revocation is actually fairly trivial for us as an execution client. So for the storage part, I think one thing, like, there are two challenges. There are the challenge of compatibility with the EIP that we included about empty accounts and how we to deal with empty accounts, the one with retroactive effect. And the second part is storage conflict. And for storage conflict, we don't see it as a problem. Liteclient doesn't see it as a problem. Asgard doesn't see it as a problem because, as much of a problem because the assumption is that you're going to sign over one client implementation or one implementation, but also with the solidity updates that is being discussed, maybe this also can be mitigated.
00:49:25.464 - 00:51:05.194, Speaker A: So that's one thing, we can probably discuss some other mechanisms, but. Yeah, and for the other thing, what I was thinking about is if the nonce of the account, that is, we are using the EOA, like if the eoa nonce is zero and it's empty and there is an authorization on it, then what we can do is we can do maybe increase the nouns by one, just so we can, we can utilize the storage and the account wouldn't be empty. And then in this case it wouldn't, like, just in the case that it is zero and we put something in storage, then we increase the loss with one. That's one of the suggestions that I have to resolve that issue, I guess. Do you think it's worth looking like, what do you think is the best way to like resolve this? Should we spend more time looking at the spec or should we actually get it like implemented in clients and, you know, prototype there and see what's, what's a better. Actually, one thing that I wanted to discuss in this call is that maybe we should merge the PR just so we can get the clients to see the final state of the IP. Because not everyone is looking at the final state in the AIP from the PR.
00:51:05.194 - 00:51:58.500, Speaker A: Some people are getting confused and probably merging the PR would make this a lot easier for client teams and a lot of people that are looking into this too, to find the resource that they need to look at. And then we can discuss changes. Like we can always push another PR with any changes that the community is trying to, we end up deciding on. Yeah, any objections with that? Like, I agree that it's been pending for like several weeks now. And yeah, it'd be nice to have a single current view. Okay. No objection.
00:51:58.500 - 00:53:03.554, Speaker A: So, okay, let's get that merged. Julian, do you have your hand up? Yeah, I'm in favor of having the current print merged in, but also like, you know, we started talking about client implementations. We've been, the OTM team has been focused on making an implementation on ref over the past like two, two ish weeks, given the moving target of this new PR. So we've been focused on building there. We're having to like continue experimenting and, you know, working alongside folks to like implement different ideas and test things out. And we'll also be working on some potential revoke revocability implementations that might be useful in terms of discovery, or we just end up actually making a hard choice that we're absolutely down for optional revocability. So we're happy to share our findings over the next week or so.
00:53:03.554 - 00:54:06.616, Speaker A: Week or two. Thanks. I don't know. Yeah, we just have five minutes. We didn't really have time to go into the best practice talk, but I don't know. Richard, do you want to give a quick overview or at least highlight where people's feedback or attention would be valuable outside of this call? I mean, in general, I would just ask for feedback in general because currently there is not much. I think this will have to be updated with every do also rounds and nonce considerations because currently they are, like, I put it at the top of the section, some open discussions around, like, should we allow null, nonce, what are recommendations for wallets to go for? Because it's related to the discussions that we had, what should wallets enforce and where does the protocol enforce? And considering that the wallets have to make some considerations here.
00:54:06.616 - 00:55:24.698, Speaker A: And as Anska said, it's like a feature where users need to be aware you are handing over control over your account to a smart account, which is similar to extracting your private key. The idea is we want to provide some concrete guidance here. Currently it's separated into some security considerations which are around what needs to be considered if you have multiple 7702 authorizations, considering that also 7702 signatures or authorizations are public, and also some guidelines when it polymorphic accounts can be accounts, the address that you think can be polymorphic. We want to extend this also to some contract guidelines. I think lightclient provided a nice example with proxy, and also you kick started quite nicely the whole discussion around the storage pattern, which are kind of best practices that we should document because this is what wallets should check for. And then in general, there's a short summary like what should you sign and what should you allow? Currently, I think in the code address one, there was a whole discussion like, how do you actually enforce that? You know, what address you're assigning? I think there were fun discussions and serial magicians around the keyword whitelisting. I'm not sure if I want to go there again, but this is something where we have to find a good formulation for.
00:55:24.698 - 00:56:11.524, Speaker A: So there, it would be very helpful, very nice to have some proposals. And then again, nonce and chain id we just have to align on. Okay, what do we actually want to allow here? And maybe give some examples where what makes sense in general, there's some text written. It's not everywhere complete, but yeah, it would be nice to have something because it also helps, like if we can give this other implementers as a reference, maybe it helps us have a common understanding on how 7702 is being used. And what are the possibilities here? I can drop the link for the chat also if that was not done already. Thank you. Okay, anything else before.
00:56:11.524 - 00:57:01.694, Speaker A: Yeah, before we wrap up, we only have two minutes. Do we want to schedule another of these calls? Okay, if there's no strong interest, happy to move this async. And, you know, once we've gone on all core devs and discussed this more and see like sort of the next step, we can. We can decide if we want another call. But yeah, anything else before we wrap up? Are my hopes and dreams of signing code dead? I'm just kidding, I guess. Yeah, we will find out. Sweet.
00:57:01.694 - 00:57:16.734, Speaker A: Well, thanks everyone. Then I'll share the recording as soon as I get it from Zoom and yeah, talk to you all soon. All right, thank you. Thanks everyone. Thank you. Thank you, Tim.
