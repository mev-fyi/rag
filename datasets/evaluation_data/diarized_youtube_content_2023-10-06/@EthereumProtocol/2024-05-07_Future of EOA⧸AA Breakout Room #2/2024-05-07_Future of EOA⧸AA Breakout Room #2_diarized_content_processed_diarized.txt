00:00:03.400 - 00:00:33.252, Speaker A: Awesome. Hi everyone. Welcome to the future of Eoa and Aa breakout. Call number two. We've got a pretty big agenda and we made this call 90 minutes instead of the usual 60 minutes for breakouts. It takes a lot to get everybody here from the community and I want to be respectful of that organization. I also think it's prudent for me to not moderate this call since I'm been pretty involved in discussions and my take is obviously not biased in the debate.
00:00:33.252 - 00:01:02.320, Speaker A: So I have found a few people to help us moderate this discussion. I think there are people that you have seen in the AA community over the last few years. So with that said, I would like to turn over this moderation to Niko and Eric. Thanks. Thanks. Like client so indeed we will be moderating today. We have a lot of things to go through, so I think we can get started.
00:01:02.320 - 00:02:09.684, Speaker A: Eric, what do you think? I hope 90 minutes will be enough to come up for everything, but we'll do our best. All right, let's go. So we have the updated agenda. We will go for the first point, which is account migration in the protocol AA roadmap. So if everyone can prepare their take and give something in the chat, if you have prepared your messages that you wanted to pass, we asked people to prepare and if not, we can go straight to the account migration point. I think maybe if I can add some context, since I wrote this agenda and I had some things in mind as I was writing it, and then people can, we can have a bit of discussion about it, if that's okay with you. Yeah, sure.
00:02:09.684 - 00:03:22.920, Speaker A: Yeah. I think one reason that, I mean, there's a lot of reasons to have this call to talk about 3074 and the proposals. But the reason I want to talk about this AA roadmap before we talked about the proposals is I don't think that there is full alignment on what or when this full native account abstraction roadmap looks like for layer one. And I wanted to hear from people working on native accounts abstraction, people building smart accounts and like what the expectations there are just to try and move into the next discussion about. Like what is there to do today with more clarity about where are we all moving towards? I can share my perspective from being a client developer on layer one that it's not clear to me what or when the native accounts abstraction roadmap will occur based on where things are today. It doesn't feel like it is on the forefront of client developers minds how to ship native account abstraction. So that is usually a good indication that we are at least one or two years away from possibly scheduling such a feature into a fork.
00:03:22.920 - 00:03:54.486, Speaker A: So if that is kind of the lower bound for how soon we can have these types of features, it to me feels very prudent to ship something in the Petra fork that improves the situation for eoas. That's what I have to say. I'm curious what others think about this. There's a. All right, thanks, Richard, I see you have raised your hand. You can take the mic. Sure.
00:03:54.486 - 00:04:26.560, Speaker A: Thanks. I mean, just to take up the microphone from Matt, right? Like I think for me we all have been working, especially the smart account teams have been working on wanting to have more native supports for smart accounts for a long time. And it's always this. I wouldn't say battle, it's maybe a strong word. But if there are discussions around this with some of the node teams or the client team, so I like it. They are very defensive outlets for good reasons. Not going to judge this, but obviously now for us it's always about, okay, we want to have native account abstraction.
00:04:26.560 - 00:05:31.706, Speaker A: We've seen this in other ecosystems work to some extent. We see that 4327 set a very nice starting point where we can iterate on. And these were signs for a lot of the smart accounts that we go towards. Native account obstruction in my opinion. I would have loved to see this even faster, but I think we all agree since it's been a while and now the question is, okay, why? I agree with you that the science, because the client teams are still very defensive. If you hear comments like the guest team being very conservative about not wanting to implement 7560 might have changed, but because of complexity, these are obviously signs that them a little bit like okay, how can we go there? Even so, I would really want to have some like one of smart account based teams would love to have some commitments that we like, some clarity do we want to stick on, we want to make smart accounts first class citizens and that this should be our go to solution. Or do we rather want to go the route of empowering erase, which from the X perspective is a valid road, right.
00:05:31.706 - 00:06:42.778, Speaker A: I'm not going to change on this one, but it's very different one at least right now compared to what we started with 437. Personally for me, I would still see that having in my mind, and I think you have can give this more realistic numbers actually. But I would have seen that in the next one year, one to two years, we get rip 7560. So the basically native account abstraction on rollups to a state that we have enough insights that actually after a pack drives after the worker fork, we can really start tackling this on Mainnet and with this transitioning over the wider ecosystem, or enabling the wider ethereum based ecosystem of having native account abstraction support and then starting actually after this to migrate accounts over towards smart accounts. Because then if we have native smart accounts are first class citizens, then the migration should also not be that painful anymore. This was my understanding for the like, basically what would be coming after worker, the mercant fork. But yeah, this is again being slightly challenged with 3074 timeline wise.
00:06:42.778 - 00:07:14.184, Speaker A: That's I think also where some of the contratism comes from. Oh yeah, sorry. Yeah, sorry. Let's end. But I'm not meaning that after pectora we see anything native for counter structure it was after the worker we have pectoral and worker and then I would have seen native account inspection. Right, that makes sense. I think ans Gaur wanted to give some comments.
00:07:14.184 - 00:08:14.084, Speaker A: Yeah, I just wanted to briefly comment specifically on the other kind of the situation, specifically regarding the triangle abstraction and the difference between layer one, layer one, and L2. Basically I think some of the problem that 437 ran into is that on the L2 side there's a lot of interest in also short term already in training some version of a card abstraction. And so that's how IP 7560 came into being. But Ip 7560 is the very first large Ip. And so we are for the first time actually figuring out how code L2s move beyond pure EVM equivalent. So this is adding features that layer one does not yet have, the layer one EVM. And in particular one problem that so far we are still kind of looking into how to do this is basically that L2s mostly just use largely unmodified layer one clients.
00:08:14.084 - 00:09:07.906, Speaker A: Well, in practice they mostly use get, which means that even before we want to ship this to mainnet, we would basically need to have some sort of support for this native account abstraction in get. That doesn't of course have to be done by the get team itself. There could be some like the L2 teams, but L2 teams are very hesitant to basically make large modifications on their own that they have to basically maintain. The guest team has been very hesitant to basically implement and maintain large features that are not relevant for layer one. So we are a little bit of an impasse there right now. But we have to solve this anyway because there are multiple directions in which L2s might want to move beyond layer one. So there are a lot of thoughts there, but this will take some time to sort out right now, native account abstraction on L2s is somewhat blocked by basically this having to be figured out first and then on the layer one side.
00:09:07.906 - 00:09:52.642, Speaker A: I will say that part of the reason for why, because otherwise we could just wait for layer one to start moving in the direction. But it does seem like on layer one side we are much more conservative with these bigger changes. So I think the realistic time until we are very confident that we have a good solution, there might still be a bit longer there, for example. Now one good step in that direction is there's been this recent EIP to basically take the IP 760, but remove the entrained solidity interface by instead using UF, which is a good direction. But it will still take some time. So I don't think even after work, I think it's very optimistic. I would say there's probably at least three, four, five years before Mainnet moves to native account abstraction.
00:09:52.642 - 00:10:53.472, Speaker A: And we are still in the process of figuring out how can L2 do this faster. Thanks. Very interesting point. I guess we will need to talk about it more during the roll call and dedicated L2 calls. Anyone else with a take right now? All right, I guess we can jump into the agenda then, if that sounds good for you guys. So should we directly go to EIP 3074? As I think a lot of questions will revolve around this. And we have some news, some new proposal from Vitalik.
00:10:53.472 - 00:11:25.194, Speaker A: So I guess a lot of people would want to talk about this. So maybe we can directly go to this and. Or maybe. Matt, do you want to give us insight on the different previous points? Yeah, I was just. I mean, I'm trying to make a platform for people who disagree with some of the decisions that were made with all core devs. Because, you know, we've sort of accepted 3074 to go into the next fork. And like, what does that mean? That just means that the core devs are putting these into the Devnet working on right now.
00:11:25.194 - 00:11:48.730, Speaker A: Like, we have the opportunity to change 3074 some. We have the opportunity to potentially send a different proposal through and accept it and remove 3074. Like, these aren't necessarily set in stone. It's just moving a step of confidence higher that this is the direction that we're trying to go. And the feedback was, a lot of people felt that that was not the right decision. It didn't work with what they were believed. Account distraction was supposed to look like on Ethereum.
00:11:48.730 - 00:12:36.344, Speaker A: And I wanted to give people the opportunity to discuss how, how ethereum should be changing over the next, you know, one year to improve the situation currently with eoas, but also support the account abstraction roadmap. And like, there's some points here like, you know, is account migration the thing that we should be prioritizing over something like 3074? Like that was a discussion that we had in February and it seemed like 3074 one. But I understand that there are people who weren't part of that discussion back in February, so I wanted to maybe give them a chance to talk about that. And then the smart contract originated transactions we sort of just talked about. It seems that we're several years away, minimum, from having that on l one. So maybe we can skip over that and then. Yeah, maybe dive into 3074.
00:12:36.344 - 00:13:34.046, Speaker A: All right, so I think we've had many, many different takes on what was wrong with 3074 in the AA group. So, like, if someone that was supporting one of those takes want to speak now, I think it's. It's a good time. Obviously we can. Nothing is set in stone, so we can be chill and it's the moment to speak. Guys, maybe we can chat briefly about some of the comments going on in the nav bar. But my biggest question right now is around inclusion of 3074 and L1 today, especially given that it comes at the cost of some features that better support roll ups like session resistance fee inclusion lists, and is generally incongruent with the overall roll up centric roadmap.
00:13:34.046 - 00:14:40.696, Speaker A: I think there's a great opportunity for us to define what is an Ethereum score charter right now and how to best support that versus what are enrollment score charters. And even as an rip, I think this would have been less controversial. But even then, I think it fits a little bit less cleanly in what has been the well defined long term aa roadmap. So I still struggle to see how this fits into the long term system in a way that promotes the right incentives for users on using the right systems and how to grow these things in the long term. I can quickly talk about inclusion list. I don't think that inclusion of 3074 has anything to do with excluding inclusion lists from Prague. Basically, we worked on inclusion lists quite a bit and kind of found several issues with inclusion lists that weren't great and it felt like we were just patching up bugs that we found and the spec was never really finished.
00:14:40.696 - 00:16:09.274, Speaker A: It kept evolving. And yes, one of the arguments for not including inclusion list is that it doesn't play well with 3074. But that wasn't the only argument to not include inclusion lists. I don't think that it's either inclusion lists or 3074. Inclusionists were not included because they were not done as a feature on their own. But doesn't this kind of shut the door on adding them in future hard forks, too? At least any kind of account abstraction where one, one account can spend the funds of another account or can modify anything of another account is something that doesn't play well with the, with inclusion lists. Yeah, but, and so, like, we can, yeah, we can, we can make, we, we can find a way to make inclusion lists work with all of the features, or we can just say, yeah, we're not going to ship any feature that is looking like account obstruction.
00:16:09.274 - 00:16:55.172, Speaker A: Yeah, but then it becomes a question of sequencing and priorities. And what is the core focus of L1 Ethereum? Like, on what invariant should it best support its customers? And from my perspective, its customers are increasingly roll ups more than end users. And that's why I'm flagging this as something that I see as congruent. I just don't see 3074 or something similar to 3074 being a big detractor from L1 moving in the direction that we're talking about. Like if we were saying, okay, 3074 is going to be this two year project. It's going to take all of the, the teams the same level of work that it's taken to merge the vertical, then that would be a big question about what is our direction. But we're talking about an EIP that takes 2 hours for a client to implement.
00:16:55.172 - 00:17:25.712, Speaker A: It feels like a big win for the users on Ethereum today, and it seems like something that we can just do without significantly detracting from the direction that we're moving. I think. Yes, sorry. Yeah, go ahead. You were muted. Yeah, I generally agree that. I think on the note side, this is not like there's implementation of Ford.
00:17:25.712 - 00:18:30.806, Speaker A: It's probably not the biggest blocker. I think also when I was primarily voicing my skepticism here was less about actually the node teams and more on the level of the accounts, wallets and the depths. Why there are definitely synergies where 3074 will in general break some of the statement with depths, most likely when it comes to that we should not just assume certain execution flows as we have them right now, which is a big item that we need to work on. I think also in some other fronts that we create some duality, again, between two standards, which might or might not be, to be honest, create a delay or not. I don't know, might also speed up things. Who knows? This is where my personal skepticism came from when it came to. Ok, should we now go for a second option or should we try to stick to 4327 for the time being? I get all the reasons, and my point that I wanted to make is we should not only think, what does it mean? An overhead towards the node teams, it also means towards steps, wallets, alignment on the wallet side.
00:18:30.806 - 00:18:44.780, Speaker A: And there are different reasons. It's not as black and white as I think. We have had a lot of discussions, but this is where my personal skepticism came from. I'm still would not be. I mean, they're different views on this. Yeah, I don't know. For me, I just.
00:18:44.780 - 00:19:50.544, Speaker A: I don't see it as a separate track. I feel like it's something that we can put into 4237 and help supercharge the adoption of 4237 because there are still a lot of eoas out there and integrating, like allowing eoas to use 4237, increasing the base functionality of the account that Dapps can expect, I think it will proliferate the adoption of a lot of these standards much faster than if we're just waiting for everyone to migrate or upgrade to smart contract wallets. All right, I see some hands raised hands. Gar and Rafi, you can take the mic and then we can move forward. Yeah. Just briefly on the point of basically 437 compatibility with 3074. I do think that a lot of the concerns here, or concerns around 3074 do come from this question of will we end up with two competing tech stacks.
00:19:50.544 - 00:20:42.518, Speaker A: And the thing is that, yes, 3074 can be made fully compatible. And if all the invokers that end up being used are invokers that actually allow for 437 style decentralized mempool flow, then I think a lot of people's concerns would be eased. The question is, it's not clear that we can basically ensure this from the outset. It's not clear that we can put guardrails in advance to make sure that the invokers that end up most heavily used do these things. There have been somebody's like, for example, we could even initially launch 3074 on Mainnet with a whitelist in protocol whitelist of invokers. We basically pick some safe invokers initially and we say we might remove that whitelist or expand it in future folks. But basically this general question remains.
00:20:42.518 - 00:21:28.094, Speaker A: How can we in advance make sure that only invokers that follow patterns we think actually are good forward compatible for account abstraction are adopted? And, yeah, it's not a bit. Thanks, Rafi. You were the next one. Then we can. Yeah, I was about to ask almost the same exact question. So, like, I think instead of, like, discussing, like, first, instead of discussing the censorship and the others, we do need to understand the actual motivation here. Because if you're just throwing the 3074 without the actual plan to then migrate to 4337, then we are just basically creating two divergent stacks that are competing as.
00:21:28.094 - 00:22:19.644, Speaker A: So, yeah, okay. All right. Yeah, go ahead. Yeah, so, I'm sorry, I just thought that I heard something. So the biggest question here is, actually, I think instead of thinking how 3074 can basically bring, can bring how dapps are going to be more willing to support account abstraction features, I think first, instead, the discussion should be made around the motivation and also the situation that how 3074 will be migrating to 4337 in the future, at least in the foreseeable future. All right, Ahmad, last one. And then we move to the alternatives.
00:22:19.644 - 00:23:31.222, Speaker A: Right. So first of all, I would want to point out that I'm a, like, I was one of the supporters of 3074. And the fact is, account abstraction is the end game here. And we want account abstraction to be like, smart accounts, to be the de facto account for everyone on the blockchain. But the road to that seems to take a very long time. And for us to just wait until that distorted in years to come does not look like the UX. And we're like, the users of the blockchain of L1 are always saying that they feel that the core devs and the developers of the blockchain are not putting the user as the first class citizen and not thinking about the user experience that the user has to put up with to transact on whether it's Ethereum, l one or l two s.
00:23:31.222 - 00:25:05.096, Speaker A: And with that in mind, I don't think just hindering EOAS is the correct approach to resolving, like, forced migrating users into account smart accounts. Because if we just say, okay, let's not allow eoas to feel a little bit better to the users, just so smart accounts can flourish, well, then why did, didn't smart accounts already flourish by now? They had all of these years of advantage, supposedly in the UX department, but adoption is still stagnant, as we can see. The other thing is restricting the invoker contract to a predefined list. Like, since when do protocol researchers and cordives decide on, like, like, why are we trying to block innovation in this area? Like, the same, the same thing that applies to the invokers applies to smart accounts. To interface with a smart account, you need to have an inter like to work with the smart account and publish your transactions through a smart account. You need to have a lot currently, you need to have a lot of infrastructure built. You need to have a UI built to support the smart account, et cetera, et cetera.
00:25:05.096 - 00:25:54.784, Speaker A: If you're not following a standard smart account, you will have a really, really hard time getting your transactions in. So it's normal that a certain invoker implementation would have a certain interface. Let's say every wallet needs to support a certain invoker. They can develop the invoker that supports their UI, etcetera. And this is the same thing that already smart contracts already have. So, like, this is not different than smart accounts, it's exactly the same. And saying that invoker contracts and the wallets blocking, like having some kind of control over which Invoker contracts they would allow or disallow, does not make any sense, because that's exactly the same for smart accounts as well.
00:25:54.784 - 00:26:53.824, Speaker A: My opinion. All right, we will let you have respond, then we really need to move forward, else the call is going to be very long. So you have your response? Yeah, so I'll keep it short so we can move on. Just wanted to make a comment that we also think, me and the count instruction team, we also see that, we also see EOA improvements as important, and I think we should have something. The difference here is that with invokers, I mean, we want to allow any form of innovation, but we also want to be able to decentralize and to have censorship resistance, if not now, then at least in the future. And this requires separating, validation and execution. That's a key part of anything that would use a permissionless member pool, because otherwise denial of service attacks become too powerful.
00:26:53.824 - 00:27:57.884, Speaker A: So with invokers, the way 3074 does them, it is much harder because this separation does not exist. So yes, it allows you to innovate, it allows you to innovate on EOA improvements, but unless you do them in a very specific way, such as implementing the invoker as a 437 account, then you will not be able, we will not be able to have censorship resistance later because it's not something that you can fix later. Whereas if it's a transaction type, and I don't mind which one, for example, the one that Vitalik just proposed, seems like a good alternative. If you have the functionality of 3074, but implemented as a transaction type with a separation between validation execution, then you can have all of the same innovation at 3074, but also be able to have a permissionless mempool. And I think that's the key point I would make about that. Perfect, perfect. Thanks.
00:27:57.884 - 00:28:42.294, Speaker A: That makes a great transition. So we have a new proposal. It's 7702. Very new. So maybe, Vitalik, if you want to give us a quick explanation here. Um, yeah, um, so I just, uh, pasted the link into the chat in case anyone wants to follow along. So the idea of uh, 433 of 7702 is basically to have something that, uh, you can think of it as having the form factor of 5806, but the user and dev experience, that's very similar to 3074.
00:28:42.294 - 00:29:47.874, Speaker A: And the basic idea is that what we do is we create a new transaction type where that transaction type allows a user to provide a contract code and then sign over that contract code, and then that signature gets included into the transaction. You could even have multiple encoded into a transaction. And then for the scope of that transaction, the user's code gets replaced with that piece of contract code. And the way that this would work in order to mirror 3074 use cases is basically that you would have a transaction and then the sender of that transaction, or the origin could possibly be some account other than the user, and the user would just sign over their code. And then for the scope of that transaction, the user's ELA code will be replaced with contracts code. And then instead of having calls, or instead of doing an auth to authenticate the yeah. Account, and then an auth call to call on the yeah.
00:29:47.874 - 00:31:15.554, Speaker A: Accounts behalf, you would basically just literally do call like two calls into the user's wallet that would verify, like perform some other form of verification and immediately after that just fall into the wallet and then do whatever execution that they wanted to do. So basically. Yeah, there. So this approach is nice because it's both like very clear how existing but 3074 use cases can be translated to it. And at the same time, it has this really nice property of forward compatibility with the smart contract wallet ecosystem because essentially the code that a user would sign over would just need to be a smart contract wallet code and it would even work as is if a user signs over their existing 4337 wallets. And so it basically accomplishes the same functionality as 3074 in the sense of allowing a wallet to temporarily turn into a smart contract for the scope of one transaction. And at the same time it would also enable all of the standard use cases, including batching, including more complicated forms of batching, including sponsorship, including privileged de escalation.
00:31:15.554 - 00:32:21.254, Speaker A: And potentially, yeah, you could even just have it like, or have the transaction just be an ERC 4337 bundle that directly calls into an entry point. And so it's like, it's very compatible with the, with the existing 43074 ecosystem, and at the same time, it's very forward compatible with both the 4337 ecosystem but also, like, theoretically pretty much any kind of pathway towards smart contract wallets. Right. So there is nothing like 4337 opinionated about this proposal in the sense that the only opinion that it has is the idea that you have some kind of smart contract wallet that you're activating for one transaction. Right. And so if some smart contract wallet proposal that looks very different from 4337 ends up winning, then this would also be forward compatible with that as well. So that's the right, so that's the core idea, basically.
00:32:21.254 - 00:33:33.168, Speaker A: Yeah. Becoming the, a smart contract wallet for one transaction and doing that as a, as a transaction type, I guess. Right. And I mean, the basic goal of this, I think, is that, like, there have been multiple efforts at coming up with, like, things that provide some of the use cases of through 3074, but without the properties of 3074 that, like, people have the most issue with. But this one, I think, like, goes much further in terms of providing pretty much like, I believe basically all of the 3074 use cases because there's just like such a nice way to translate existing auth and off call workflows. Let's see, going through some questions, can 7702 be used together with 4337 and bundle user ops for multiple accounts? The answer is yes. So you can have multiple contract codes for multiple accounts to get authorized.
00:33:33.168 - 00:34:59.764, Speaker A: And so you could basically, literally have a single transaction that just is a 4337 bundle where the code is all exactly the same as it is today, except if you want to make it work with some eoas, you would just do it inside this new transaction type and you would put the signed contract codes in and it would basically just work as is. Then there's questions around, like, should you sign over a nonce? Should you sign over a chain id? Like, how reusable do we want this? And I mean, I personally am agnostic to this, and I think we can probably borrow a lot of the discussion that we've had around 3074 and 5806. And like, pretty strongly the, or a lot of the reasoning should be pretty similar. Why? Right. Signing the code versus signing the code address is one of those interesting points, I think. Yeah, I mean, I'm, this is one of those things that, like, I personally think doesn't really matter much in either direction, basically, because if you sign a code address, then, or like, you can sign any code by just publishing it first. And then if you don't have code addresses that with, I think it's EIP 1167 or ERC 1167 proxy is like a proxy that wraps around an existing piece of code is only a few extra bytes.
00:34:59.764 - 00:35:37.174, Speaker A: Sorry. In 7702, how is the code getting on chain? If you sign over the code, do you have to propagate it every time? Yes, you do. So in the code proposal, you do have to propagate the code every time. And the argument for why this is not incredibly inefficient and fatal is basically because we expect users in practice, to just use proxies for this. And proxies actually can be extremely small. Like, they're the, like the one I mentioned is only 44 bytes. Makes sense.
00:35:37.174 - 00:36:27.844, Speaker A: We have a. Yes, Daniel, you can. Yeah. Just, just one question. How do you prevent that the users are signing some malicious contract with this type of transactions? Because wouldn't you end up that wallets have to have sort of a whitelist again, but in this case, just for contract code? Yes, good question. So I think the set of concerns around, like, that people raised with 3074 of, like, complaining about having to trust invokers, like, a lot, this does not solve a lot of the concerns. And, like, the need to trust code does remain.
00:36:27.844 - 00:37:18.014, Speaker A: But that's something that exists in any smart contract, while the ecosystem. Right, like, that also exists in, or, like, a version of it exists in 4337, because, like, ultimately, a user has to trust whatever wallet implementation they use. And so I think the recommended way to interface with this would basically be that your wallet would have a canonical smart contract implementation that follows some particular API, and that's pretty much the only thing that you would trust. Yeah, but then in the end, I mean, this would be the same concerns as before, the 74. No, I mean, there would not be any improvement. It would just be instead of the invokers you trust. Smart contract that the wallet allows.
00:37:18.014 - 00:37:44.176, Speaker A: Right. I mean, maybe the one thing you can say is that it's more plausible that a user would be able to have only one and be done with it, but. Okay. All right, next question. Derek. So I do have, like, a lot of questions. I guess I'll just ask three questions right now.
00:37:44.176 - 00:38:20.770, Speaker A: So, one is, it's not clear to me from the EIP, and I really only had, like, you know, maybe five minutes to read it before the call. So it's not clear to me from the EIP, like, how. How does storage work? Right. Because, like. Because, like, most of the most important use cases of AA depends on storage. So I would like to learn more about how storage works in this case. The second question is, it's not super clear to me why Vitaliku decided that it's better to sign over the codes of the contract instead of just signing the address of an existing contract.
00:38:20.770 - 00:38:43.092, Speaker A: So that's the second question. And then the third question is, it's also not clear to me why just how does this proposal handle exploration, you know, so, like, like, what is, like the lifetime of the authorization? Yeah. So. So, so those would be my three questions. Thank you. Um, yeah, so I think on the first one I had one, there's basically two approaches. What? Right.
00:38:43.092 - 00:40:14.564, Speaker A: One is to just allow storage and the other is to, um, either, like, for storage to be temporary or even just disallow s storing completely in the way that 5806 does. And the trade off is basically that if you allow adding storage, then there's, well, I think in 5806 it might have been actually a bigger risk because the implication in 5806 would be that users would be more often in the habit of constantly newly signing, signing over pieces of code, whereas here, like, a realistic user might have one. But there's the risk that if you sign the wrong thing that your storage gets screwed up. And then if you want to actually deploy a contract safely, then you'd have to sign over some other piece of code that clears over all your storage or something like that. And then the other option is you just disallow a store. And if you disallow s store, then realistically, yeah, like, you'd have to rely on storage that's stored somewhere else, or you'd possibly have to just make do without storage and rely exclusively on, like, vertical level nonsense for replay protection. So those are the two paths that I see for the, like, signing over contract code instead of signing over address this thing.
00:40:14.564 - 00:40:44.130, Speaker A: I mean, I think, as I've said before, like, I'm personally not too opinionated. I'm okay with either approach. And, like, I actually don't think that the two approaches are that different from each other in terms of their consequences. And what was, sorry, what was the third question again? Exploration. Yeah. Oh, exploration, yes. So I think, I mean, the most natural exploration strategy is basically to stick the nonce into the thing that gets signed.
00:40:44.130 - 00:41:25.514, Speaker A: Right? Or at least make it an option. So that's like, if we want the ability to expire, that's probably the easiest way to do it. Yeah. Then I saw another question, like, would it increase gas usage because AOA users would provide code in every transaction. And. Right. I think the answer there is basically that either if you use an ERC 1167 proxy as your code, then your code is just 44 bytes, and 44 bytes is like very trivial call data cost wise, or if we do it by providing code addresses that have code, that probably solves usage in a different way.
00:41:25.514 - 00:42:20.100, Speaker A: All right, Eric, next. Thank you. So I wanted to ask about the practicality of implementing this in Pectra. I think given the, from what I understand, given the similarity to 3074, I kind of get the sense from people that it should be possible. But at least from my end, this is kind of a core question because of the importance of including those capabilities before we go into the verkle tree, basically pause in things that could improve user experience. Sure. I think it makes sense for core dev to reply to that question that would have to be discussed on the call.
00:42:20.100 - 00:43:13.334, Speaker A: I don't think a single core dev could give a yes or no to it. All right, the next question. Ahmad. Yeah, so my question is that, so I have kind of a couple. One question is like, if you have to sign contract code or address with every transaction, how would you be able. So like, 3074 allows you to a contract, and this auth is valid on, you can, you can, you can put certain permissions on this auth that it would execute in at any time. So does 70, how would 7702 do the same thing? That's one thing.
00:43:13.334 - 00:44:50.306, Speaker A: And the second question is, from the core development perspective, um, like, one of the motivations behind 7702 is that we don't want to introduce two new opcodes into the evm, the auth and Auth call, but instead we're introducing a new transaction type that could possibly be deprecated. Um, so from a core development perspective, uh, is a transact a new transaction type really less of a big deal than just adding the two opcodes? Um, the third and last would be, how would 7702 be different than that proposal that lite client created where he said that we can modify 3074 to make the frame of execution is the EOA itself, and point to the invoker contract. That way, the invoker contract can kind of act like a smart account. Inside the execution frame will be the EOA address, but it will act exactly like a smart contract account for the opcode versus opcode versus transaction type. Maybe a code if can answer, or, I mean, someone with the knowledge about this. I was asking Vitalik about this because I recorded. Yeah, I mean, I think my case for why.
00:44:50.306 - 00:45:48.824, Speaker A: Yeah, transaction types are like lighter than or more like less of a technical debt problem, I guess, than opcodes. Is that like, in principle, if you remove a transaction type eventually, then, or the only infrastructure that would have to change in response to that is off chain infrastructure. Whereas if you remove an opcode eventually, then that would require on chain infrastructure, including smart contracts that people were counting on to be at the same place and have the same functionality forever to change how they work. And so, like, the second is just strictly harder than the first. And like, we've seen how challenging it is, even with self destruct, which is an opcode that barely anyone uses at all, and this is an opcode that's. Or transaction type that's likely to become part of very mainstream user workflows. So that would be my, probably my case for why.
00:45:48.824 - 00:47:02.566, Speaker A: For why transaction type makes more sense in this case. And then, I mean, I guess there's also the philosophical points that, like, opcodes feel like something that should focus more on computational things. And like, basically there is value in this, like, very high level user authorization stuff being something that's a, like, being something that's at the transaction type level because it's more legible to the protocol and might be more forward compatible with various things. Right. And around the question of how would 7702 support use cases like an Auth that has other use cases than the immediate transaction, like where you oauth a contract and this contract would be then pulled under certain permissions at any time. In principle, you should be able to do it. Right.
00:47:02.566 - 00:47:52.344, Speaker A: Because basically, yeah, you would just send out that auth and that auth would just be a piece of contract code, and then you'd be able to call into it from whatever, from some other contract in like, basically a very parallel way to house an implementation. Subaru that uses 3074 would be able to call the auth op code. Right. Because like, what you basically do, I guess you're basically guessing. You replace the, you replace the auth with a call into the contract, that you could replace the auth call with another call into the contract. So maybe you could replace both with one. So in principle, they, like any use case should be able to just like, be translated, at the very least, much resolving it naively.
00:47:52.344 - 00:48:17.240, Speaker A: Yeah, I think so. But it does feel a little bit more restrictive than how auth and auth co operate. I'm not entirely sure. All right. I mean, one other. Yeah, one other way. Just, I think to finish that thought.
00:48:17.240 - 00:49:30.104, Speaker A: One other way to address that type of question might be to explore how the 4337 ecosystem has approached that particular use case because there's some chance that it has and you know, you'd be able to convert the four three seven approach into working with, with the CIP as well. So like that, the question is because like the smart contract code is only valid for the duration of the transaction. So what 4337 has is that they have the smart contract code always live on in, whereas. Right, so, yeah. Right, so in this case, yeah, the solution would be that like it could be reusable, right? Like basically, yeah. I think this all has to do with like do you sign over the nonce or do you not sign over the nonce? And actually even if you do sign over the nonce, if like, if you sign over the nonce but you don't outfit the nonce, then it's still something that becomes reusable. Yeah, Derek, go ahead.
00:49:30.104 - 00:50:35.966, Speaker A: Oh yeah. So personally after thinking about the proposal more, I definitely think that it's a more elegant and more clean way to do to kind of bring the benefits of AA to EOA. And I also like how it's more forward compatible with the overall a roadmap. But I think like from a practical standpoint of adopting 7702 in Petra, I think it does have a few more dependencies comparing to 3700. Right now, 3700 is already implemented by the client teams. If we want to ship 7702 within roughly the same timeframe as the original time 4374, then I think there are two main dependencies. So one is that I'd like to hear from the core devs whether they think that implementing this new transaction type is doable within the time frame of seven, within time frame of Petra.
00:50:35.966 - 00:53:01.094, Speaker A: And secondly, since this proposal will require, I think if we want to use the 77702 with the 437 mempool, which I think is how most people want to use it, then it will also require an update in the specs of 437 itself as well as the updates of all the bundle infrastructure. I think I would like to also hear from the AE team whether they are roughly on board with this proposal and whether they think that they're, the bundlers can also implement support for this proposal within a reasonable time frame. Yeah, great question. I think like client gave a reply in the chat, which is yes, for the first part and for the second part I would invite AA teams to discuss it. So what do you, what specifically, what part do you want to discuss? Oh, so, so the, so the question is basically just because it's like to use throughout, so like three or seven for comparing to this new proposal has the advantage that it can basically leverage the 437 man pool in a way that doesn't require any modification to fall through seven through a multi tenant invoker accounts. So I like this new proposal, but it does require updates to 437 itself as well as obviously updates to bundlers. So I guess my question is just have you guys had the time to review this proposal and are you guys roughly aligns with this proposal? And would you get behind this proposal and update 437 if this proposal was adopted? I think it's, I mean, in general the proposal looks good, but since it was written like an hour before, an hour before this call, I think we'll need to think about it a bit, see how it fits in the 4337, how it fits in the framework in a way that doesn't create new attack vectors.
00:53:01.094 - 00:53:38.804, Speaker A: But yeah, if it's. So if this proposal does not introduce any problems, I mean, if we have a good way of integrating it, then I don't see, then I don't see why we wouldn't. But that's, but again, we can't commit to it before spending some time thinking about it because it's very new. Thank you. Because to me, like, you know, if both the client, the core devs team, and the 437 team can get behind this proposal, then I really think that this is the, you know, you know that this is like the best way forward. Yeah, I tend to agree. It's, I tend to agree.
00:53:38.804 - 00:54:42.664, Speaker A: I think it could be a, it could be a good way forward. But I think we just, we just need, probably need at least a few days to think about this proposal because it's so new and see if it's, I mean, if we can't see any new problems it creates, which on the face of it, I don't see, then, yeah, then it would be, yeah. But you know, I also do want to say that, like, I think it's important, I think it's important for us to commit to get this into pack charges because like, I think like, you know, things like zero seven four itself has already been delayed for years. I think we really should then just keep kicking the can down the roads. So it's like if we want to replace 374 with this proposal, then I think we really should have a strong commitment from both the core devs and 437 team to ship this within the petrol time frame. We haven't had time to even discuss it. So I'm only speaking for myself here.
00:54:42.664 - 00:55:26.584, Speaker A: I think we'll need to I think the team will need to discuss it, and we finally need to discuss it on the mafia group. But yeah, I think we should do it and the sooner the better so it can be included in Petra. Perfect. Thanks for the reply. Elim, you had your hands up. Yeah, hello. So I think remember from one of the previous all core devs, I think Vitalik mentioned that like a reasoning for not including any IP such as I think 5003 or 7377 was that it breaks an invariant that eoas don't have a contract or don't have code.
00:55:26.584 - 00:56:53.530, Speaker A: So I guess if that still holds, then does 7702 kind of also touch on breaking this invariant? And if so, then what's the reasoning for having this kind of temporary code solution rather than just outright including something like 5003 or 7377 that permanently migrates the account? Yeah, in terms of my previous comments on the breaking the coded variant, just one thing to be clear is I am in favor of breaking that variance. I'm just in favor of us being super explicit about it so that applications such as I know nfts that depend on non transferability and things like that are aware that the changes are going to happen well ahead of time and people don't make new applications that depend on it then get hit by a surprise later. One other interesting, really nice thing about 772 that I didn't mention yet is that like five actually 5003 is like literally just one line of code on top, right? Basically, yeah. Like you could imagine a flag being added where if the flag is set at the end of the transaction, you just don't revert the code back to zero. Right. And if we do that, then 5003 basically, yeah, exists immediately. And from a code complexity perspective it feels like the delta between doing that and doing that is like fairly small.
00:56:53.530 - 00:58:18.964, Speaker A: I think the only reason why it didn't want to just included into the EIP by default is just because I didn't want to introduce this as something that changes ten different potentially controversial things all at once. But if we decide that we want 5003 to happen fast, then we do have a very easy way to do that, either in Petra or in a future four. I guess like kind of maybe I just wasn't that clear. Or maybe I just didn't understand quite like what is the reasoning for not just doing that endgame like in game migration? Oh, so for like not just like adding the, adding the flag to set the code permanently in the initial version? I personally am not against it. I just, procedurally I just wanted to present this as an alternative way of satisfying 3070 four's use cases without also simultaneously doing the discussion of let's do 5003 in Petra. But if people decide that they want them simultaneously, they're. I have zero opposition to that personally.
00:58:18.964 - 00:59:41.258, Speaker A: Thanks. Like client, maybe you have something to add because we had some points on the agenda that were related to some of the things we just said, but maybe you want to take them in the 3074 context. Sorry, go ahead, Ben. Disregarding permanently writing code to the EOA, wouldn't that mean you can essentially brick your wallet, which would be a bad, very bad outcome, by writing the wrong code? There's no walking back from it. I mean, yes, it does, and that's the reason why things like 5003 have any controversy at all. Right? I mean, it's the same problem with smart contract wallets too. So if we're moving to a world where everyone's going to have a smart contract wallet, then we're going to have the possibility of them setting the proxy of their smart contract wall to the zero address and never getting their funds back out.
00:59:41.258 - 01:00:42.774, Speaker A: So it's something that we need to design for. Yeah, I mean, in terms of 3074, I think we're sort of up in the air at this point. Like, I'm happy to discuss some of these things, but given that there seems to be pretty good support for 7702, we're still working on 3074. It's going to go into this initial Devnet for Pectra, but I am personally open to removing it and swapping something different in 702 seems like a good alternative. I want to spend some more time looking at it. Maybe iterating a little bit on the design, but in general, I'm happy with it. We need to wait to see if it's acceptable by the four three seven team because if it doesn't support the decentralized permissionless relaying use case, then I think that it doesn't really give us what we're looking for in this upgrade.
01:00:42.774 - 01:02:02.414, Speaker A: Does anyone have any 3074 specific things that they were hoping to discuss? Yoshiyari. Hi. Am I audible? Yes. This is a little skeptical point of view regarding EIP 7702 is that it could be a threat to ERC 4337 account exception because UOA have options to update their code. Why would they ship to a smart account later on? Am I making sense? No, I think it makes sense. So the thing that I would say is basically that if 7702 gets introduced, then you as a user would absolutely be able to just keep on using EIP 7702 transaction types, either forever or until the transaction. If the transaction type gets removed ten years in the future, then you would actually have to upgrade.
01:02:02.414 - 01:03:23.874, Speaker A: But the main reason you would have to actually finalize the upgrading eventually would basically be if you want to switch keys, that if you want your original EOA key to no longer have full powers over the accounts anymore. So I think the case for it being a bridge is basically that if you like, any user who is in that halfway house state of being, a frequent 702 user would actually be part of the 4337 ecosystem. But they would share networks with the 4337 ecosystem, and once the ability to permanently set code is introduced, then they would have the ability to just switch over to being a full member of that ecosystem anytime, and they would not have to. So I think in practice it's not a competitor to the 4337 world. I think it ends up serving as a bridge. Alexander, you want to say something? Nope. All right.
01:03:23.874 - 01:04:57.224, Speaker A: I guess one thing on the agenda under the 3074 category, but that's also relevant to this discussion on 7702, is there has been a lot of debate about like what should, how flexible should this signature be? And we've discussed it a bit in passing in this call, but I maybe can just ask if people want to make arguments for against the signature having certain fields that limit its flexibility. For instance, the chain id or the nonce that exists in the signature right now as it's written, 7702 does not have the trainity or nonce. It's a question of should we add those things to it? I have personally felt that they're not necessary because the contract should enforce that functionality. But I'm open to feedback from others. Yes, first hand raised was n Scar, I think. Yeah, so I will say, because I'm also otherwise I would have also argued on this call for removing those restrictions from 3074. I think given that all of these proposals come with a requirement for manual wallet whitelisting anyway, basically all of these restrictions can be enforced to an equivalent level through that process.
01:04:57.224 - 01:05:40.494, Speaker A: So you can have the exact same restrictions around revocability, around expiry, around chain id binding, just basically by only wallets, only ever whitelisting invokers or in this case code that actually brings those restrictions. But the nice thing is now it's up to that ERC layer. And so if at some point some pattern emerges that requires those not to be present, we can just upgrade to them. And so I would always argue that we should do this. The security model is already that we trust that the wallet does not do anything stupid with the whitelisting. So there really is no downside to this other that maybe it would set the wrong standard in the ecosystem. But for me, basically the added flexibility always outweighs those concerns.
01:05:40.494 - 01:06:58.834, Speaker A: Ahmed yeah, I actually agree with ASWa on this front. The protocol does not need to restrict and to enforce these restrictions. Usually we as pointed previously in one of the previous calls by light client, we usually let this type of restrictions happen on the smart contract kind of side of things and we don't have enforcement on the protocol side of things. And because this is a new transaction type like wallets will not have, will not. As soon as picture lands, wallets are going to become vulnerable to this attack. No, they have to like support and whitelist or do the work needed to support this transaction type. And as such the risk of oh, suddenly after the fork all the users are vulnerable to some kind of scam does not really apply in this case because again, like support from the wallet side of things need to be added because of the new transaction.
01:06:58.834 - 01:07:47.974, Speaker A: Fair point, Richard. I'm also more on the side of not enforcing nonce and China id why I do see many points made about security. There's for me also the distinction do we need to make them required or can they be optional? Can we leave it up to Dapps users, the wallets, to give this option? Because if you also make it optional, we see that there's a landscape of more and more networks coming in. And if we say we make them optional, actually you there are certain use cases where having replayability across chains is super powerful. There are two sides of the same coin. Replayability can be bad and good. Generally.
01:07:47.974 - 01:08:24.498, Speaker A: Just excluding it will limit our design space, which I think currently we are in the need for better ux. We need to have a bigger design space, not a smaller one. The only point where that comes to my mind why we should enforce them is because apparently it's easier to get this through with certain stakeholders in the serum ecosystem. I'm not sure if this is the best reason. Yep, jor, you can go ahead. Yes. Okay.
01:08:24.498 - 01:09:16.770, Speaker A: I'm trying to think about what Richard said because my first inclination was just like with 3074. These are required to avoid long lived signatures and network malleability. Whether they can be optional, I'm not sure. So I not think about it. Try not to speculate right now. And earlier it was how is it fit with the 437? Again, we've seen it only for 1 hour when we did it really look deep, but it looks like it's promising. It might allow EOA to become first class citizen in a transaction and in 4327 transaction and looking forward like a counter structured transaction.
01:09:16.770 - 01:10:21.940, Speaker A: So it looks promising. But again, we didn't really look the code how it would will change anything. Either the entry point, maybe the entry point doesn't change at all, or the bundles need to check. Sure, we might want to plan out another breakout room given the fact that 7702 is so young, but we will discuss this later. Ben, you can go ahead. If the things like chain id and so forth aren't included in the signature, then that would lean more towards it being contract code than a contract address in the sign because then you could include the chain id in that optionally, if that makes sense. Whereas if it was just a contract address, you wouldn't be able to include that.
01:10:21.940 - 01:10:44.592, Speaker A: You'd have to include it in the data, which would be a different signature. Yep, good point. Rick, you want to go? So. Yeah, I just want to jump in quickly. So, I mean, first of all, I feel like one thing we could always do is make it so chanity zero is the omni chain. If you wanted to like disable. Um, so you're done talking? Okay, sorry.
01:10:44.592 - 01:11:28.208, Speaker A: Um, yeah, so if you want to disable like the ability to, to work on just a specific chain. But for me personally, like, when I'm signing my ledger, if it's on a network that I don't really care about, um, then when it pops up saying you're signing this for arbitrum, I'm far more willing to click a button. Like recently I've noticed a lot more things, uh, are signing weird type messages that don't specify the chain id. It's kind of scary because you don't know. Are you like authorizing like Dai on whatever network. So tying it down to one network definitely like reduces the threat profile of what I'm worried about. So it could be a wallet limitation currently, but that's kind of my, my quick reasons for wanting chanity kind of embedded in it.
01:11:28.208 - 01:11:52.864, Speaker A: Again with the option to disable that by setting the chany to zero. Yep. Interesting point. I do agree. I do tend to sign things much faster when it's on a L2 network. Who's next? We have a lot of hands raised. David, maybe? Yeah.
01:11:52.864 - 01:13:43.378, Speaker A: This is not directly tied with the chain id and the nonce within the signature, but I see one of the things that the community discussed regarding 3074 is like the original key still being used. So like, there isn't that validation execution, but rather execution abstraction. And I also see, correct me if I'm wrong on the 7702, that the account is still bound to the original key. And I wanted to discuss with the community like what if we could the current architecture uses the EC recover from the protocol, but will there be a chance where we could add another parameter where we add the input or the address of the validator contract, which is similar to having basically to support custom signature scimitar with 7702, so we delegate the validation to another parameter which a custom smart contract will handle rather than like being bound to like the default protocol. Although I understand the point. I just wanted to bring this up and see like what the community thinks about this. Yeah, I think that, I mean it depends on this philosophical question of whether you're looking at the 7702 workflow as being this kind of like temporary thing that the equivalent of a Linux live USB install where you can just plug the USB stick in your laptop and then it loads up Ubuntu without ever installing it.
01:13:43.378 - 01:15:10.324, Speaker A: And that just gives a nice way for users to quickly try the functionality versus if you're looking at swapping the code for the scope of one transaction as being a workflow that sticks around the long term even after users switch the smart contract wallets. And I think when writing this, my thinking was much more the first and then basically because I think the seconds could be covered by smart contracts themselves having the functionality to authorize new pieces of code for temporary scopes. But I mean definitely open to thinking about it the other way. Derek, you have your hand raised. Yeah. So personally, like I don't, I don't have like a very strong opinion on chain ids, but I do want to say that like about nonce, I think like whether it's with 7702 or 3074, I think it's like if our goal is to bring the benefits of account abstraction to users, then I think it's very, very important that we avoid including nones in the signature. The reason is because our company zero deaf, we have been working very closely with many, many of the early adopters of account rejection.
01:15:10.324 - 01:15:48.734, Speaker A: All the most popular use cases of AA, besides maybe like guest sponsoring, depends on long standing, long lived authorizations. So for example, two of the most powerful use cases of AA. One is attaching alternative signing methods to your smart accounts, such as pass keys. So imagine attaching a passkey to your EOA through either through 7.4 or seven seven two. So in that case, because you want to keep using that signer, the fact that every single transaction from your UA will invalidate that signer, will make that use case basically impossible. And then another use case is session keys.
01:15:48.734 - 01:16:36.954, Speaker A: The idea of essentially delegating transactions for other devs to execute, that's also a really, really powerful and popular use case. Again, that wouldn't be possible if the authorizations can just be invalidated all the time. So I think it's very, very important that we avoid the pitfall of including nonsense to the signature, which will essentially make some of the most popular a use cases we have seen impossible. Yeah, so that's my take. Thanks for the contribution. Parta, you want to add something? Yeah, sorry, this may sound a bit naive, I just, I'm trying to understand a bit more. On 7007 7702, would.
01:16:36.954 - 01:17:39.916, Speaker A: I mean, for the execution context, the account in this case would function as a smart account. Right. So does it mean you would need support for 1271 or a variant 6492? Or would it, would dabs continue to support or treat these requests emanating from the UA as a regular UA based transaction? Did that make sense? That does, and that's an interesting point. There's basically two ways to handle that, right? One is basically that you just say, well, for 1271 it keeps on being. Anyway, the other way to do it is you basically do, do a 6492 extension that basically says if the user provides an authorized piece of code, then like that gets treated as a 1271 signature exactly the same way. In a way that's very parallel to what happens in 6492. So I guess either of those makes sense.
01:17:39.916 - 01:18:42.468, Speaker A: I mean, the second obviously takes more work because it's in ERC, but the second is more powerful because off jade signatures are often precisely one of the things that you care about, like creating lower security, higher accessibility, deeper of what you use for thanks drawer. If you want to, go ahead. Yes, Derek mentioned that the, the reasons why I don't like the nonce in the signature, because it limits the signature. And we have exactly the same issue as with 3074. I'm all for it, as long as you keep some mechanism to allow the user to revoke a signature that was already published on chain. Otherwise you sign for life for a specific implementation, which I don't think is a good idea. Yep, good point.
01:18:42.468 - 01:19:20.188, Speaker A: You have. Yeah. So regarding the nonce, I mean, first of all, I do think that being able to revoke and fix your past mistakes, so to speak, is important, but it's, but it doesn't have to limit any use case. So I would propose, instead of including nonce include a max nonce. Just, you know, you can. So you can include a max nonce. This is valid for the next maybe 1 billion nonces or whatever, which gives you like, infinite gives you a like.
01:19:20.188 - 01:20:47.536, Speaker A: Since you are not going to have a million transactions, it gives you infinite approval, but also have a way to bump the norms by a 32 bit value. The rationale for that is that if you realize that you need to revoke your past signatures now, you can bump the nonce by, let's say, 1,000,001 and be sure that your past authorizations are no longer valid. And on the other hand, it doesn't put the nonce, the nonce, the ripple protection at risk, because the 32 bit value where the nonce is 64 still gives you more than enough room not to ever overlap. So I think that using a max nonce and a way to bump the nonce would give us both things infinite, like both infinite authorization and being able to revoke. Would that make sense? Yeah, it's a fascinating idea. I think one weakness that's worth pointing out is that it does weaken the mempool's ability to safely queue up multiple transactions for a user, because right now, if a user queues up 50 transactions, you know, all 50 would have to be included. But with non spomping, you lose that guarantee.
01:20:47.536 - 01:21:17.234, Speaker A: But then at the same time, like, we realistically lose that guarantee for account abstraction anyway. And you can argue that once you have badging, there is not actually as much of a point in having that guarantee anymore. So, like, I personally don't see that as fatal. Just want to flag that that regression does exist. I think it doesn't. This doesn't create a regression because this is already possible today. I mean, we can have, currently the mempool allows you to have a, if I recall correctly, 63.
01:21:17.234 - 01:22:11.312, Speaker A: I mean, the default configuration geth is a 63 pending transactions, but the current transaction actually can, it can invalidate the other transactions by draining the, by draining the account, sending it elsewhere. Well, right. No, but what you can do, what you can do though is that you can do a check that checks if the user's balance is greater or equal to the sum of the values of all the transactions, and then you can forward conditional on that. Yeah, you can do that. So it does. So bumping, what I would do is since bumping the nonce is an extreme case, it's not something that you do all the time, you're going to do it if you think you need to invalidate all your past authorizations. So I would say that this should cost a lot of gas, which means that it cannot be used for denial of service.
01:22:11.312 - 01:23:03.354, Speaker A: I think it's fine if you pay like, if you pay some really high amount of gas for this one time invalidation of past authorizations. Yeah, that's a good idea. Conrad, you want to go? Yascha kind of just wanted to weigh in on the nonce debate. I think my two cent here, obviously there are some good points on both sides. I would probably err on the side of not enforcing nonstop chain id checks on the protocol unless we actually have to. I think from the points made before, I think it would be a nice to have, but it would be something that could be equally solved. Kind of using an ERC or kind of like just in general kind of application level like, standards are just like implementations.
01:23:03.354 - 01:24:47.294, Speaker A: And I think, like, one argument there that I don't think has mentioned, has been mentioned before is if we assume that wallets will to some extent whitelist these kind of like either invokers on 3074 or kind of like smart accounts, then wallets might as well kind of check that there's some way of revoking kind of like. Yeah, outstanding signatures. So I think that's another argument for being able to rely on application level standards or just the implementations to have revocability or cross chain preventing cross chain replayability if that's required in certain use cases. Just on the nonce invalidating transactions, that door has already been opened by being able to run code in your account because it could move all the eth out. So the first transaction could invalidate the rest by not having any more gas. All right, I think we have covered a lot of the topics that were planned for today. Even though we spent a lot of time on the new alternatives, I think it could probably be good to plan another breakout considering the fact that 7702 is so young and many teams will need to to look at it.
01:24:47.294 - 01:25:38.712, Speaker A: So let me know what you think, guys, but I think we are signing up for another round. Great. Thanks so much, Nico, for helping moderate this discussion. I think we'll discuss this further on all core devs also, which is Thursday. At the same time as this call, I can add 7702 to the agenda. If anybody wants to come and hear what the client teams have to say, or maybe like, share your perspective, you're welcome to, but otherwise we'll see everybody in the Aamafia telegram. Yeah, absolutely.
01:25:38.712 - 01:26:04.704, Speaker A: And last point, I think exactly as Enzgar said, it's quite good to see all this energy around the AA roadmap. So let's continue with this energy moving forward. Thank you, everyone. See you soon. Bye bye, everyone. Bye.
