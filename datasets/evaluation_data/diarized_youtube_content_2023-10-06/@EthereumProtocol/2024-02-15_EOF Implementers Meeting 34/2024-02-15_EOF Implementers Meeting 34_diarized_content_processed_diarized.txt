00:00:01.290 - 00:00:20.080, Speaker A: All right, looks like Alex is out right now. We got some people here, so I think that's good enough to start the meeting. I guess our standard first item of discussion is client updates. Dragon, you're the first client member. That's not me. So how about you lead with your.
00:00:22.130 - 00:00:40.490, Speaker B: Just last week I just started looking at how to implement inside RevM and it will not be that bad. So yeah, I'm still at the beginning figuring out how to basically integrate all of this inside EVM.
00:00:44.270 - 00:00:48.250, Speaker A: Okay, any EVM one updates?
00:00:50.190 - 00:01:21.880, Speaker C: We still have several prs open with different pieces, mostly finished. We are mostly working on tests now, so grade three and grade four already, I think grade three needs some minor fixes. It seems so grade four is ready and relaxed stack validation and I think x code logic in legacy is ready and we're also working on new calls at the moment. Yeah, that's it.
00:01:22.490 - 00:01:43.238, Speaker A: Okay. For Besu we got create three working. There is one bug that I think I found in EVM, one I think they're going to fix. But apart from that one difference, their create three tests and bases create three tests. Agree. So we got progress there. I pushed that out to our mega Eof.
00:01:43.238 - 00:02:21.020, Speaker A: I spent some time trying to get retest f. I wasted all day Thursday trying to get it to work on Apple silicon and then failed. Similarly on a more recent Intel Mac. But I have a decade old Mac Pro sitting on my desk and retest compiles fine there I discovered yesterday. So I'll be able to help get some of the reference tests written for the client there. What we don't have implemented yet is create for and exchange. I don't know that the exchange specification has settled completely yet, but probably it's time to start implementing it anyway.
00:02:21.020 - 00:02:28.650, Speaker A: We don't have solidity on the call. So Charles, any updates from Viper?
00:02:30.110 - 00:02:47.950, Speaker D: No updates on my end. I updated this EIP 663 spec a little bit and I'm not sure if there's anything outstanding on my end and I don't know if there's any progress or more thoughts on VLQ.
00:02:51.730 - 00:03:07.606, Speaker A: I don't know that any of the clients have got any progress on VLQ. We've all been heads down on reference tests and initial implementation. As far as 663, you updated exchange. Do you consider that in a state that we can just go ahead and implement it?
00:03:07.788 - 00:03:09.414, Speaker D: Yeah, I would say so.
00:03:09.612 - 00:03:17.740, Speaker E: Okay, I think it's ready. Just need to be the pr that Charles opened needs to be merged, I think.
00:03:19.790 - 00:03:22.960, Speaker A: Off of Charles Pr. Okay. Right to that spec. Cool.
00:03:24.370 - 00:03:26.750, Speaker E: Should also be in sync with the megaspec.
00:03:27.650 - 00:03:53.000, Speaker A: Right, cool. So I guess we'll go into spec updates. I wasn't expecting to have to lead the call today. I was thinking that ASIC might have been here. What's the status of moving the mega spec over to eips? I guess is the first question while I look that up.
00:03:53.450 - 00:04:54.010, Speaker E: Okay, so I can handle this. So we have a bunch of prs open with updates. We have an update to the first EIP which is 35 40, which I think there's one pending discussion item which I would like to handle when we are in the spec discussion part and the others are kind of bit waiting on different stuff. Like for example the create free and four eap is waiting I think at this point for the editors to approve it. There are some bunch of smaller updates that are trying to get the status out of stagnant and I think they're also waiting on the editors. And what else? I think that's it. We're blocked a bit, but there's a lot of new updates ready lined up to be merged.
00:04:56.590 - 00:04:59.530, Speaker A: So we're waiting on action from the EIP editors.
00:05:01.710 - 00:05:06.160, Speaker E: Someone confirmed this because I'm not sure how the process goes on these.
00:05:08.290 - 00:05:15.360, Speaker A: Yeah, their process is. Yeah, I have no comment on that.
00:05:15.730 - 00:05:24.820, Speaker F: Can you please help me with the EIP number or the CR number? Once again? I may be able to pull it up in the next EIP editing office hour.
00:05:29.830 - 00:05:30.306, Speaker E: I think.
00:05:30.328 - 00:05:30.466, Speaker A: What?
00:05:30.488 - 00:05:45.434, Speaker E: Catch that? I mean there's a list of prs in the chat. The last one actually I think is axic, who's the author? Yeah, that's the one. But I think the others to look.
00:05:45.472 - 00:05:47.690, Speaker A: For ones that ASIC authors.
00:05:48.430 - 00:05:58.942, Speaker E: There's one, the swapping one, but the others I think are. Browser is giving hard time.
00:05:59.076 - 00:06:37.850, Speaker C: Yeah, for grade three I think we've got some review from editors and addressed the comments and now waiting for another round. And I opened like three small ones to change the status. So like 35 40 is currently in stagnate and I cherry picked a couple of small updates from a bigger peer, bigger update and moved it to review back to review. This is still not reviewed by editors and also data instructions and jump f. Also I tried to move them to review but they are now also require editors approval.
00:06:41.390 - 00:06:46.300, Speaker F: I will try to pull all of them in the next vip editing office hour and hopefully it will be more.
00:06:47.950 - 00:06:48.940, Speaker E: Thank you.
00:06:49.570 - 00:07:00.100, Speaker A: Okay, so that sounds like one action item is we need to get a master list of what we need editors to act on. And that's next Wednesday or is that today, in a few hours.
00:07:01.270 - 00:07:03.250, Speaker F: It's Tuesday. Next Tuesday.
00:07:03.750 - 00:07:12.230, Speaker A: Next Tuesday. Okay. So we'll need to get a master list of things that we need editors to act on for them by Tuesday.
00:07:18.080 - 00:07:24.670, Speaker E: Okay. I can make this list. And who do I send it to?
00:07:28.660 - 00:07:34.290, Speaker F: Yes, there is a meeting agenda. I will just post the link over here. You can just add it over there.
00:07:35.860 - 00:07:48.210, Speaker A: Okay, so that meeting today, EIPIP meeting, or wait office hours, except from EIPIP, right?
00:07:50.970 - 00:08:01.260, Speaker F: No, in EIPIP, we only talk about proposals which are into final status. But this office hour is for the proposal which are in process of getting to fund.
00:08:02.350 - 00:08:05.260, Speaker A: Okay. So we could just dump our wish list into that pr.
00:08:06.430 - 00:08:07.820, Speaker F: That's perfect. Yes.
00:08:08.370 - 00:08:09.120, Speaker A: Okay.
00:08:12.290 - 00:08:48.600, Speaker G: Do you think it makes sense to reflect the EIP process in this readiness matrix? What I mean is that I think Peltren and Andre has put a lot of stuff already that is being updated. And to my understanding, many of these are kind of ready for review, except it's not merged. But I think other people might be interested in reviewing them in meantime anyway. But I think it's a bit difficult to track what's going on. Well.
00:08:51.210 - 00:08:54.090, Speaker E: In the implementation matrix, you do have a row for eips.
00:08:55.150 - 00:09:08.414, Speaker G: Yeah, sure. But it's only like single unicode character there. Right. So if there is a pull request that kind of updated, but it's not merged yet. There's no link, so I can't see it.
00:09:08.532 - 00:09:16.382, Speaker E: Yeah, there's a list of PRS links below, but I should update it, and I will. When I do that, I think list.
00:09:16.436 - 00:09:34.520, Speaker G: Would be enough, I guess. I don't think it's really picky about where it goes well, but yeah, having a current in progress list of requests would be nice too. Other people have orientation, like where these are.
00:09:35.550 - 00:09:42.140, Speaker E: I'll update the list. It's a week old, so it's not terribly old, but it's old.
00:09:47.690 - 00:10:02.570, Speaker A: Okay, so were there any of these eips that had requests for discussion? I think we had the VLQ request from Charles. Anything from EVM? One that needs discussion in terms of spec.
00:10:02.640 - 00:10:03.260, Speaker E: Right.
00:10:04.430 - 00:10:06.380, Speaker A: Anything we need to talk about on this call?
00:10:06.750 - 00:11:15.140, Speaker E: Yeah, there's this notion of making the header format more liberal, because in the previous EAP 35 40, we had this, that the header of the sections was the section kind, and then either a single two bytes length or a list, which is the number of items, and then a bunch of sizes of sections. And now I think we had a discussion before about this, but the question is whether we want to make it more liberal, because this is the format that applies to all the EOF versions, starting from version one and then moving on. But if in the future we would like to have another header format, we would need to violate this general format liberal in sense that it's not necessarily just a list of sizes. Could be a list of offsets possibly, or something else completely.
00:11:20.320 - 00:11:20.588, Speaker A: Yeah.
00:11:20.594 - 00:11:52.070, Speaker C: And to clarify, this is just like a non functional change. This is just how we formulate it in AP 35 40 doesn't affect the exact container format. For now, there's a paragraph that describes how general UF format for any possible future version looks like in general terms. And there's one possible formulation or another one. And basically that's what we need to decide. I don't think it's like very important decision, to be honest.
00:11:52.600 - 00:12:00.570, Speaker E: Okay, that's fair enough. We can just keep the previous strict format and not worry about this. This is fine.
00:12:02.800 - 00:12:10.990, Speaker C: I'm in favor of keeping what we had in AP before. I think it's fine, but yeah, I'm open to changing it too.
00:12:12.400 - 00:12:22.930, Speaker E: I'm fine with keeping as it. I thought we decided to make it more general, but it's fine, we can roll back.
00:12:25.000 - 00:12:34.420, Speaker A: So what changes would be involved in making it more general? Would the current specification of the header format be compatible with liberalized format?
00:12:37.620 - 00:12:40.532, Speaker E: Second, what would be compatible with what?
00:12:40.666 - 00:12:50.532, Speaker A: So if we made it more liberal like you're proposing and doing some of those things, would the current header format have to change to accommodate these changes?
00:12:50.666 - 00:12:52.390, Speaker E: No, absolutely not.
00:12:54.120 - 00:13:05.550, Speaker A: So we could do a forward compatible change and we could open it up a bit after we ship V 10 and say here's how you would extend it, but with the current specified version is set.
00:13:07.760 - 00:13:42.250, Speaker G: Yeah. To my understanding is that we just rename some specific use different terms in the specification in the way that, for example, the number doesn't mean size, it's like any number in the array of numbers. And then it can be interpreted differently in the future. That comes to my mind, but I also don't think it's super important. I mean, if you can do it, I don't see why you can't specify it later.
00:13:43.980 - 00:13:56.844, Speaker A: Right, go ahead. So I guess what I'm saying is the bytes that go over the wire can be the same if we change the spec or if we don't. Right. They'll be the same, right?
00:13:56.962 - 00:13:57.630, Speaker E: Yeah.
00:13:58.160 - 00:13:58.910, Speaker A: Okay.
00:14:01.360 - 00:14:08.990, Speaker E: I think we're more in terms of not worrying and just rolling back and making it as it used to be. So it's fine.
00:14:09.520 - 00:14:28.550, Speaker A: Yeah. So I guess the subtext is if we're going to launch a testnet like we got the request from EF DevOps in March. Now is the wrong time to fundamentally change things like the header format because I would have to rewrite all my tests again for about the fifth time that tests all the header format code.
00:14:29.800 - 00:14:32.792, Speaker E: The V one header format would not change for sure.
00:14:32.846 - 00:14:33.450, Speaker A: Okay.
00:14:35.660 - 00:15:20.180, Speaker B: I have one question regarding the header. Did you guys thought about adding the size of the header? What I'm asking is basically when the workload comes, will we have maybe different format where we want to know how much the data we need to read? Basically how much chunks of the workload data we want to read. So maybe it can be usable or useful both for the header data and for the terminal like body size. We can get that from the header, but from the header maybe it could be usable.
00:15:25.810 - 00:16:02.874, Speaker A: So there is no header. Is this long code? Is this long bytes in there? It can be derived from two chunks which might be the same chunk. For a low count of code sections. The first chunk will get you into the two header, which includes the length of the code sections, the three. And from that you can extrapolate to figure out where the subcontainers, what are subcontainers that kind of wrecks it, because then you have to check. You'd start with the first chunk. You bounce to where code section three might start, and then you bounce to where code section four might start.
00:16:02.874 - 00:16:35.030, Speaker A: And so there, from up to three bounces, you could get the full header from just three sections and then you can load the code willy nilly as you need it and you know where the data starts. So while there is nothing in the header, and that would be nice, it's at most three chunks to get all that necessary information. And if you're calling a fairly large contract, the three chunks is going to be typical. Just for method dispatch, there's going to be like five or six chunks to your typical method dispatch.
00:16:36.810 - 00:16:43.260, Speaker B: Okay. Either way, even with the current format, it's easy to extract the data.
00:16:43.950 - 00:16:46.650, Speaker A: Yeah, it can be calculated with minimal hassle.
00:16:48.110 - 00:17:09.010, Speaker B: Then if all values are hard coded, basically we know the order, how the kind code, kind container, kind data comes. Why do we have kind type if it is all hard coded?
00:17:09.990 - 00:17:59.490, Speaker A: So that would be for future extensibility. For one thing, the subcontainer kind is optional right now. So we do need to know when we're going after code section lengths to go into either subcontainer or data link. So we need to know that. And for future extensibility, we're saving the space by requiring the kinds so that we could add extra fields in there, the ordering will be specified. But if we have, let's say we have another section that has a solidity dispatch table, we could add that to the header. Or if other roll ups want to add that sort of information, marking them with the header kind allows for that kind of extensibility.
00:18:00.390 - 00:18:03.570, Speaker B: Yeah, but you get the same thing with versions.
00:18:04.790 - 00:18:06.142, Speaker A: With what versions?
00:18:06.206 - 00:18:14.374, Speaker B: With version, yeah, version one, you bump the version, you have different format, or maybe extend the format or format with.
00:18:14.412 - 00:18:48.302, Speaker A: Remote field, but versions don't allow you to have optionals in infinite combinations because containers might be optional. This mythical dispatch table might be optional. So we could go to version two, but the field might be optional in version two. And we're also. Yeah, we're trying not to bump the version field if necessary. My goal with the version field is it only signals incompatible changes. Incompatible changes like say we're adding a new op code, or we're doing something to the code that previously would have not passed validation.
00:18:48.302 - 00:19:19.210, Speaker A: Would now pass validation. That's my definition of a forward compatible change is there's some code that would have been rejected that is no longer rejected, then those, I would say would not require a version bump. It's when we do things like take codes away, stuff that was valid and make it invalid where we would have to increase the version number. I don't know what the rest of everyone else working on the project is thinking, but that's my vision for what the version number represents is we've done something incompatible.
00:19:20.750 - 00:19:23.102, Speaker B: Sounds good to me, to be honest. Thank you.
00:19:23.156 - 00:19:38.980, Speaker G: Yeah, this kind of allows to have some future compatible changes without changing the version, which is like adding optional section in the future is one of the options that we have.
00:19:41.910 - 00:19:50.066, Speaker B: It's like we increase it by a few bytes, that's nothing. And we get. Understand. Thank you for explanation.
00:19:50.178 - 00:20:36.500, Speaker G: Yeah, that has been discussed and some people proposed to truly fit it in what we currently need and don't really make it anyway generic and I don't know how to put it, but yeah, definitely we could just put every value we need in just order. And knowing where things are, it's kind of like design trade off. I don't think it's super important and I don't have very strong preference which one is better. Probably we'll never know until like five years into the future. But yeah, that's mostly what the design was for.
00:20:39.570 - 00:20:51.570, Speaker A: Okay, I need to drop off. I have another meeting I need to call into in about two minutes. So I guess I'll need. We'll need to assign someone else to be co host to maintain the recording.
00:20:54.730 - 00:20:58.200, Speaker F: Recording will be continued. I'm online, so it will go.
00:20:58.970 - 00:21:12.170, Speaker A: All right, cool. So, yeah, I don't know if there's any other requirements we need to go through if you want to move on to that. Charles's VLQ request. But like I said, I'll be dropping off here in about a minute.
00:21:20.750 - 00:21:26.000, Speaker C: Peltor, did you have some other questions about calls? I think.
00:21:30.210 - 00:21:40.580, Speaker E: I think they were a bit specific to EVM one and the pr that we have open. So not for this call, I think. And I think I need to go after Isaac for this.
00:21:41.750 - 00:21:42.500, Speaker C: Okay.
00:22:08.250 - 00:22:15.850, Speaker F: Do we have any further update or any further discussion point? If so, people can continue and it will continue recording.
00:22:22.040 - 00:22:24.230, Speaker C: Charles, do you have anything to.
00:22:27.960 - 00:22:28.324, Speaker A: Mean?
00:22:28.362 - 00:23:10.710, Speaker D: I don't really have any new information. I think I was out last week, but the VLQ thing, I just want to make a case for it again, which is, I think it makes the format more forward compatible and it also results in some code savings. I think the only question really is, I mean, there's a couple of details, but we can address those if want to move forward with that. I think the only question is the scope, which is. Dano indicated to me that it changes a lot of tests, which is really annoying. So that could be a blocker for it, if time is of the essence here.
00:23:15.050 - 00:23:54.910, Speaker C: Yeah, I think we agreed to proceed without this change for now. And we added some rationale, I think, to p 35 40. Just saying that we decided that it's out of scope, but. Yeah, open to getting back to it later at some point. Now we're working on tests with the format agreed on. Speaking of tests, actually, I have an update about tests. We worked on new validation tests.
00:23:54.910 - 00:24:48.740, Speaker C: I managed to export the cases that we have in unit tests in EVM one, and now there's a lot of test vectors. I've made a pr and tests. So these are tests in a special new format which it existed before, but I'm not sure if any clients so far used it, not sure if Bessu looked at it. So in general. Yeah, it's just. Yeah, let me share the screen, maybe.
00:24:50.250 - 00:24:54.310, Speaker B: Yeah, this can be useful. Thanks for sharing.
00:24:57.550 - 00:25:50.330, Speaker C: Yeah, this is just the format that has the bytecode and expected, whether it's valid or not. And inverted cases have exact error message expected. I'm not sure how much this is useful because I expect so. The different limitations will not agree on specific error in some cases. So I would start maybe just trying to agree on the outcome and then see how many errors are different. Because at least in parsing, I'm sure parsing can be implemented in different ways, and then you interpret similar situation like the same situation in different meaning, then error is different. I expect such cases to come up, but we can try.
00:25:50.330 - 00:27:04.366, Speaker C: So this is like what EVM one generates and there are a bunch of these tests. I don't think it covers every possible error and every possible validation case, but at least stack validation I think is pretty well covered. Except I am still to add cases for r jump v there. But yeah, so I encourage to try this otherwise we have from the old PR solo. So I'm not sure exactly what's the status. Hugo is not present today, but there is also this PR which updates test on master to the new creation spec, but it mostly deletes, I think, some cases, some tests, because they are not possible with the new spec. But still this is kind of the most up to date version of test on master.
00:27:04.366 - 00:27:47.936, Speaker C: This should be merged soon, I hope, and separately. Third test PR is the one for creation, which we also generated from EDM one unit tests. And these are like a separate thing. And this should cover, these are normal state tests and they should cover grade three, at least three, grade three and grade four actually. So yeah, this is also possible to try. When you get to grade three, you can create four. Yeah, that's all I have about the.
00:27:47.958 - 00:27:48.640, Speaker A: Tests.
00:27:57.620 - 00:29:45.448, Speaker G: Going back to this variation length encoding a bit, so maybe have an option to make slightly progress here. So I think I'd still mentally try to split these two things like UF container and the instructions. I'm kind of skeptical about the instructions actually, because decoding the number at runtime, it's a bit more complicated than just running two bytes and just swapping whatever. Secondly, it seems it's not really good fit for this jump table, but anyway, what I did try to do it, but I'm not sure I will be able to do it myself entirely. Is this actually quick way to inspect all of the deployed code on mains, for example, at least if you have a running node, we use that to find the EOF prefix previously. This runs really quickly, I think to just check all the code I believe shouldn't take more than minutes. So I have written a script that can just collect some statistics about the jump offset that are currently used in existing contracts.
00:29:45.448 - 00:31:25.740, Speaker G: So maybe we'll start collecting some data, collect ideas what actually data we want to have and how to store it for later processing. I think I will just make an issue in our repo about it with what I currently have, which is like a prototype for now. I don't have a running node actually that I can use it for but maybe, actually I thought I could get it running maybe in day or two unless someone else have it. And what else? Yeah, there's only one kind of missing information that I'm not sure how to get and if it's easily available you can scout existing codes but you don't have information how frequently the codes are used so the statistics are not really represent the usage on the network if you know what I mean. But maybe it will be good enough at the starting point. Yeah, that's all from my side for now.
00:31:56.650 - 00:31:58.040, Speaker A: Did we wrap up.
00:32:00.960 - 00:32:02.510, Speaker E: Or is there anything else?
00:32:13.250 - 00:32:16.206, Speaker C: I'm good, I think we can wrap up, yeah.
00:32:16.308 - 00:32:22.160, Speaker E: Okay then. Thank you all. Bye guys.
00:32:22.770 - 00:32:23.680, Speaker D: Thanks everybody.
00:32:24.330 - 00:32:25.826, Speaker C: Thank you very much. Bye.
