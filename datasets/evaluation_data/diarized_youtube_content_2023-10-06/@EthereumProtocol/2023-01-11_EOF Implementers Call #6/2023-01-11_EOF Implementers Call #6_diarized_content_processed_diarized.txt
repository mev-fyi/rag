00:00:00.810 - 00:00:40.940, Speaker A: Hi everybody. Hi everybody. Welcome to the EOF implementers call number six, formerly known as the EOF breakout room. We decided last week to start doing this on alternating weeks of all core devs for at least the next couple months to try and get a hold on eof and figure out what the game plan know, trying to get a cancun inclusion is. So, yeah, let's start with some client updates. Does anybody want to share what they've been up to since all core devs last week, or maybe like a little bit before that?
00:00:44.030 - 00:01:02.830, Speaker B: Basu has been doing mostly cleanup and taking time to do some optimizations. Now that we got it correct, we can see if we can do it faster. So one of them has to do with the pc abbreviation, another one has to do with counting dead code. So nothing too exciting or groundbreaking.
00:01:04.230 - 00:01:07.460, Speaker A: Cool. Never mind.
00:01:14.860 - 00:01:22.270, Speaker C: Same. We've been just doing some refactors, cleaning code, and doing some minor optimizations here and there.
00:01:25.750 - 00:02:09.416, Speaker A: Great. Aragon, is anybody here? Yes. Not okay on the geth side, also pretty similar. Spent some time trying to clean things up. Haven't really done much performance work on the pr. Still mostly have been trying since the cleanup to improve errors and logging. And so that kind of also came out through this proposal for this reference test format, which we'll talk a bit about in this testing section.
00:02:09.416 - 00:02:28.640, Speaker A: But, yeah, I think, yeah, that's mostly it. Not a ton of new things on the GAts implementation. Daniel, do you want to give some updates from solidity?
00:02:30.280 - 00:02:31.830, Speaker D: Yeah. Can you hear me?
00:02:32.200 - 00:02:33.252, Speaker A: I hear you.
00:02:33.386 - 00:03:10.770, Speaker D: Okay. Yeah, nothing substantial has happened since the new year for us as well, I think. I mean, we did have the PPR draft of an implementation in the end of last year, reported the last issues we found, but, yeah, that's basically it for us, actually. Uniswap tried to Moody from Uniswap tried to run testing through them, but I haven't heard from him back now for a few days. He wanted to pass through Ethereum js and had some issues with that, but yeah, may have more data soon.
00:03:12.580 - 00:04:07.244, Speaker A: Got it. Let's see any other compiler updates from anyone. Okay, spec updates. Are there any things from Ipsilan that you guys wanted to bring up and talk about? There's a couple of things that Dano listed that we can chat about, but is there any things that you guys have on your mind? Okay, so I guess the first one here is you're interested in removing this pc verbiage, right. Do you want to talk about that quickly?
00:04:07.442 - 00:04:48.520, Speaker B: Yeah. So back before we got rid of the pc operation, it made sense to anchor where the pc equals zero is inside of the execution, and that's the beginning of the code section. Now that we don't have a pc or a direct jump, there is no way to introspect or interact with the absolute position of the pc inside of the spec. So I would like it removed. And execution starts at the beginning of a code section without setting the pc. Because one of the optimizations I did in BESU was I didn't split out the code sections, I just set an entry point of where the index is from the beginning of the container. And it all works because the code never overruns because we already do those checks.
00:04:48.520 - 00:05:06.080, Speaker B: So it helped me from having to, in the degenerate case of 1024 different containers, I don't have to slice up the array 1000 times, I just use the same array passing it around. So it's helping on a lot of garbage collection in Java, which is a bigger issue than in a lot of the other languages.
00:05:07.300 - 00:05:45.420, Speaker E: Alex has a hand up. Yeah, so AIP 4200 still have, or also refers to pc and how the pc is modified. But the intent there, and I think the same applies to the other EIP as well. The intent isn't about what the pc opcode is returning, it's rather the internal pc representation, right, what the interpreter thinks at what position it is currently executing.
00:05:46.720 - 00:05:51.230, Speaker B: Right? But if it's all relative, it doesn't matter what the zero point is, does it?
00:05:53.600 - 00:06:04.640, Speaker E: I mean, in the EIF 4200, if you want to eradicate PC as a term entirely, then I think we need to come up not as a term.
00:06:04.800 - 00:06:06.900, Speaker B: Just the PC equals zero designation.
00:06:08.760 - 00:06:14.070, Speaker E: I mean, that's only for stating that execution starts from the beginning, right?
00:06:19.020 - 00:06:36.540, Speaker B: Or we could keep it, but either way, when we need to expose it, just look up the entry point index and do some math. But if we're removing pc observability, it doesn't matter if it's pc equals one or pc equals 42 when your code section starts.
00:06:38.240 - 00:06:51.216, Speaker E: Yeah, that's an interesting point. In the future, if he relaxes, if.
00:06:51.238 - 00:06:53.570, Speaker A: We relax, this pc equals zero.
00:06:54.740 - 00:06:57.110, Speaker E: Yeah, I understand the point.
00:06:59.560 - 00:07:27.980, Speaker A: I guess it just only matters if PC ever becomes something that can be introspected again, because right now the way that I understand it is that you have implemented the EOF spec. It's just that there is this guiding principle of PC equals zero. To state that execution should start from the first byte of the code section. But the fact that your pc is an absolute value across the container, you still get the same outcome.
00:07:30.000 - 00:07:30.716, Speaker F: I think.
00:07:30.818 - 00:07:46.930, Speaker E: Where you could have issues if some other opcodes are described that they do something based on the pc and if they don't do it in a relative manner, and that's where it would start mattering again.
00:07:47.540 - 00:08:00.120, Speaker B: Yeah, that's where it would start mattering again. So we could bring it back in if we need to do absolute positioning. But absolute positioning becomes problematic for certain code transformations anyway. So I think it would be hard to bring it back, but not impossible.
00:08:05.660 - 00:08:16.330, Speaker A: Okay. I personally don't have a problem either way, so if you guys are okay with removing it, I think that's okay.
00:08:20.780 - 00:08:23.264, Speaker E: You it? Yeah.
00:08:23.462 - 00:08:46.970, Speaker F: I also don't have problem with this suggestion. I am not like particularly, I don't know, I kind of thought about this back as a kind of explanation how it's supposed to work, but I wasn't ever connected to this explicit value zero.
00:08:49.100 - 00:08:50.840, Speaker A: Yeah. Alex.
00:08:52.940 - 00:09:21.570, Speaker E: I would suggest if we remove the PC equals zero wording, then somewhere we should explain this explicitly that it is implementation defined and every single instruction has to be described as being relative. If they change the PC, it has to be relative. Maybe this is under security considerations, I'm not sure, maybe that's the best section for you, but I think it has to be made clear.
00:09:21.940 - 00:09:42.456, Speaker B: So the trace specification, the standard tracing, may impact that. I'm looking at this now and hearing the discussion on it. That's the next point that I brought up is how do we in standard output, it has a pc value, so we would have to do some math to get to pc zero. Maybe we should just leave it in there and I should just not worry about it.
00:09:42.478 - 00:09:43.048, Speaker A: Then.
00:09:43.214 - 00:09:46.200, Speaker B: We need to have some agreement on what the pc is for. The tracing.
00:09:50.310 - 00:10:27.320, Speaker A: Yeah. Does anyone have a strong feeling that pc should be absolute for tracing or should it be relative to the code section? My intuition is that relative to the code section is preferable. It seems much clearer what's going on when reading the execution. I don't think that would cause your optimizations to be thrown out the window because you could still calculate it in some branch that if tracing is on, then calculate this.
00:10:27.950 - 00:10:31.834, Speaker B: So if we keep it relative to the code section, we'll need to put the code section in the trace as.
00:10:31.872 - 00:10:35.194, Speaker A: Well as optional line.
00:10:35.312 - 00:10:39.440, Speaker B: That's what we need to do either all the time or when code section does not equal zero.
00:10:45.010 - 00:11:07.000, Speaker A: Yeah, the code section non zero definitely needs to be there. If we put code section zero in, that could be something to denote that this is an EOF trace. That might be valuable. That might be valuable, true, because otherwise you don't really know what semantics. I mean, do you really ever know what semantics the trace is going on because there's not fork information?
00:11:10.410 - 00:11:25.470, Speaker B: You know what block it's coming from. So you could define it from that. But it also be useful when you call between contracts to know you're calling between an EOF and a legacy contract if you see the section up here and disappear.
00:11:25.970 - 00:11:26.720, Speaker A: Right.
00:11:28.450 - 00:11:29.840, Speaker B: So section always.
00:11:32.530 - 00:11:35.006, Speaker A: I think that section always is a good idea.
00:11:35.188 - 00:11:37.038, Speaker B: But only for EOF code.
00:11:37.204 - 00:11:38.660, Speaker A: Only for EOF code.
00:11:41.750 - 00:11:55.990, Speaker B: Okay, those are my two questions. So no change on the spec I'm fine with, but the tracing spec needs to have some clarity somewhere. I don't know how to do that.
00:11:56.140 - 00:12:13.850, Speaker A: To add it. Oh, it's stagnant. So fortunately Martin and Marius can change. Yeah, yeah. Okay. That's something that we should work on. I have a couple other things I just stuck on here.
00:12:13.850 - 00:12:43.830, Speaker A: I know that a big spec question that we have outstanding is figuring out how to support in echoed arguments. I don't know if there is any other thinking about how we should deal with this, how we should resolve this problem. Maybe this is something and we don't have to go into a super long debate here, but I do have another section I want to talk about. What is our plan going into this interop? What is our plan for the interop? And maybe that's something we want to answer during the interop. Alex?
00:12:47.460 - 00:13:30.190, Speaker E: Yeah, so that would be probably the update from ipsilon. We started to work on how to do creation. We started a document last week to bounce off some ideas internally and we want to share it as soon as possible. But there hasn't been too much work on it last week. But my hope is that we're actually going to share it early next week and that could be a discussion point, especially for the interop. But there have been some interesting ideas how to actually support immutables and.
00:13:31.920 - 00:13:32.296, Speaker A: Yeah.
00:13:32.338 - 00:13:36.290, Speaker E: It seems like a solvable issue with the extra time we have now.
00:13:37.700 - 00:13:58.600, Speaker A: Okay, great. Let's talk a little bit more about that when we talk about the NRL plans. Then the last spec update. I had a bit of a question here. We have some more time now. Does it make sense to work on some unified EEP at this point or do you think we should just continue forward with the multi EEP approach?
00:14:01.340 - 00:14:11.000, Speaker B: It's a whole lot easier to read a unified EEP. Do we go the meta EEP approach and have it copy it, or do we deprecate the other eeps if we go to a single EEP?
00:14:12.780 - 00:14:24.480, Speaker A: I would think deprecate the other eeps and just say this EEP is the. I mean, you don't have to say this is the EEP text, but we know that this EEP is the combination of all these other eeps into a single format.
00:14:24.820 - 00:14:28.880, Speaker B: And in the event of typos, the unified EEP prevails.
00:14:29.940 - 00:14:48.640, Speaker A: Yeah. Do the authors have any feelings on this? Is that something that you're interested in working towards, or. Probably not.
00:14:49.970 - 00:15:16.490, Speaker E: Do you mean that we're going to have a brand new unified EP with copying that entire spec text? Or are we seeing that for now, we're going to just rely on the unified spec, and once everything is 100% clear, then we're going to copy back stuff into the eips. Or like a third option. What is the suggestion?
00:15:17.070 - 00:15:32.030, Speaker A: I'm suggesting that a new ep is written or has most of the pieces copied from the existing eeps so that there's one eep that's the source of truth for the big EOf implementation.
00:15:42.270 - 00:16:42.560, Speaker E: I think my only concern is one of the reasons the unified heap is nice, because it doesn't need to be concerned by all those other required sections by, you know, the motivation can be quite big. The rationale and security and backwards compatibility stuff, all those likely will double the text. But also the current eips have like the python code, which we discussed, that maybe they're obsolete at this point, so they could be. Even the current ones could be cut back. Personally, I think the least amount of work for now, at least for this month during the interop, is just using the unified spec and not caring about any of the battery ips and all that.
00:16:43.090 - 00:16:43.840, Speaker A: Okay.
00:16:44.450 - 00:16:50.830, Speaker E: But I'm not sure if every implementer is happy with working off the unified spec as opposed to the aiPs.
00:16:54.210 - 00:17:35.642, Speaker A: Yeah, I was getting the feeling that people preferred working off the eips. And to be fair, the eips are more concise. I've realized that there are some small things that are overlooked in the unified spec. The contract creation aspects, I think are under specified. And of course we can specify these things in the unified spec in a good way. It's just that it's not quite as clear as the eIps. And everybody tends to just fall back to the Eips and look and say, okay, well, what does the EIP have to say about this? And so in that case, then we're kind of losing the advantage of the unified spec rather than.
00:17:35.642 - 00:18:39.150, Speaker A: Because I think that the behavior should be, if the unified spec is not clear, then we should update it to be clear, rather than falling back to the eeps and then at some point in the future try and port all of the changes in the unified spec to the appropriate eeps. I don't think it's the flow we followed yet. Anyways, we don't have to make a decision on this. I just think that as things continue to change, it is better to have all the changes in a single place. And it's just something that has been difficult over the last two months for implementers trying to make sure and testers to make sure that everybody is agreeing on the exact same things. So something that we can consider. Okay, testing updates Ipsilan guys, do you have anything to share?
00:18:42.180 - 00:20:11.550, Speaker F: I have some stuff, so maybe quickly, about the spec updates, I didn't say before there were two changes from my side. One was just to rename the data stack to operand stack. That was a prequest to some of the Aps and that has been merged, and there's follow up that is listed in the agenda issue for this call that that kind of changes some of the runtime checks to asserts because the conditions are already guaranteed by the stack validation. There's a prerequest for that. It hasn't been merged yet on the testing side. So we were focusing on the comparing mostly the GEF implementation with EVM, one implementation using state tests. And as of today I think there's only one issue remaining and the rest, the implementations agree on the rest of that.
00:20:11.550 - 00:21:17.888, Speaker F: So the issue is in the create as usual. So I think what the test expects and what GEF implementation is doing in case init code is invalid, the color nons bump remains, so the creation fails, but the nons is increased by one. I think that has been discussed somewhere before, but I think intuitively the check should be before that, and the nouns should not be updated. But somehow the test explicitly expects this. So maybe there was some decision made I'm not really aware of, but I think I'm still in the position that should be the other way. So that's the difference between two implementations. Yeah.
00:21:17.888 - 00:21:39.930, Speaker F: So if that is resolved, I think we kind of in a good position right now. And yeah, I think more tests are coming this week or next week for other test cases, but like two big chunks of the existing tests are pretty good right now.
00:21:43.180 - 00:22:38.576, Speaker A: Okay, awesome. That's good. That's good news. Any comments on that stuff? Okay, there's been some talk about having a reference format for EOF tests. A lot of the tests that we've been writing are really focused on just the parsing and the validation of EOf bytecode. And so there is an idea of what if we had a way to just run the parsing and validation without having to generate blocks and import them into the chain and then check storage elements and these types of things. So there's been some proposals, there's basically two proposals.
00:22:38.576 - 00:23:59.330, Speaker A: I think that Dimitri started writing one in the Ethereum test repo, and then I made some suggestions for a slightly different format and I wrote a hack MD with that I'll post. So this is about as bare bones as you can have for a filled test fixture. It really just has the code and then the results for each forks that we would expect results for. The maybe big question here is there was this idea of maybe standardizing the errors that we have from the parsing and validation code. This kind of puts some, maybe unnecessary constraints on implementations, because certain checks need to be done in certain ways to be in conformance, and maybe that is overbearing for implementers. But I do think that having the ability as a tester to say I'm writing a test and this is the error that I'm writing this test to cover, is useful because generally this binary output of pass fail, we don't know if the right thing is getting tested in the clients. And so maybe we're hitting another section and we're not having full coverage over what we want.
00:23:59.330 - 00:24:06.770, Speaker A: And so that was sort of the idea behind this. I don't know if any other people have strong feelings about this.
00:24:10.980 - 00:24:54.496, Speaker B: So I like enumerating the expected exception in there. I would prefer to see a text string instead of the number so I don't have to look up a table so I can tell it from the test directly. But what Besu does, there's a couple of other tests scripts inside of the reference test that specify the exception. We don't map the exceptions right now, we just verify that an exception occurred and we use that as a flag that it's a failure. But we could easily do the mapping and make sure we get the same fails. I do like the idea of trying to say what should fail and trying to make the test fail in only one way. Because there was several years ago one of the ALtBN tests had two ways to fail and basically was only getting one of them correct and wasn't checking the other way.
00:24:54.496 - 00:25:19.210, Speaker B: And that was the only test case that checked for AltBn pairing or something. And because none of us are crypto masters and know what this checks are, we didn't know that the check was invalid. So enumerating in the test how we expect it to fail, I think is valuable to those who aren't like say phds in cryptography. It can tell you what all the failure cases of a BN curve are, so I see value in enumerating them, even if they're not directly used.
00:25:25.940 - 00:26:07.936, Speaker A: Yeah, I guess I can update it to use strings. My initial hesitation was that each language has its kind of own way that they like writing what errors are, and each code base kind of has the same thing. And I felt it was kind of maybe overbearing to say your text needs to look like this. But the way that I ended up implementing it is it's actually outside the main code base for geth. It's really just a table of these go error types to integer, and so really I can just update that to some standardized text output. That's totally fine. Okay, yeah, I can go ahead and do that.
00:26:07.936 - 00:26:13.250, Speaker A: I'll probably just use what is in the name field right now for the specification and we can go from there.
00:26:15.780 - 00:26:16.930, Speaker B: Sounds great.
00:26:18.500 - 00:26:19.360, Speaker A: Alex.
00:26:22.900 - 00:27:24.576, Speaker E: This is a tiny bit off topic, but for a long while I was kind of interested if we could introduce error codes, why execution stopped, because that could help comparing different implementations and could help in establishing better coverage, or at least understanding the coverage of the test. But one big downside is if you do that, then a lot of these different conditions, something can abort, has to be way more precisely described than it is today. And one good example is like these discussions around the IP 38 60, the init code. And of course then that would be more prone to consensus bugs. I wonder if this step is like a step towards that's so it depends.
00:27:24.608 - 00:28:02.964, Speaker B: On which way we're driving the standardization. If it's a name used in testing that's advisory, I say we just go ahead and do it and clients can use it or not. The tricky part comes in if we need to fail in a specific way, and a failure to fail with the right failure becomes a failure. That's where the spec allows for multiple failure paths. That's where it gets tricky, because if five things fail, I don't want to have to say that we need to check them in a certain order. I just care that one of the five is returned. If we just put it in the test and say we expect it to fail this way, I have no problem with that.
00:28:02.964 - 00:28:06.900, Speaker B: It's moving it up the stack into the spec, and things start getting tricky.
00:28:09.160 - 00:28:44.480, Speaker A: Right? I do think this is just going to be a good learning experience for understanding if that is a path that we can go towards is having more clarity why things are failing in the EVM. It may turn out that it's pretty straightforward for us to do this error propagation and agree on certain errors. And so maybe that is like a signal that we should look more into doing this at the EVM level. It could also go the other way too, where we realize that this is hard and maybe the binary pass fail is preferred.
00:28:46.500 - 00:28:56.260, Speaker B: So one thing that I think should be pushed up as part of the spec is the revert bytes. If you revert at the base of the thing that could be brought in right now, it's totally optional.
00:29:01.000 - 00:29:01.940, Speaker A: Mario.
00:29:03.320 - 00:29:48.630, Speaker G: Yeah, so I've seen at least a couple of test cases that I've written. I've seen cases where it's totally possible to have two different errors from the ones that you listed. So maybe if we have that scenario, or it's impossible to just narrow down to a single error because writing test case is just not possible. And it depends on the client where the check in the order of the checks they are doing. So maybe we can have an either error for very special test scenarios. So if you have one test scenario that simply cannot be narrowed down, you can have either this error or this error. And that's okay, I think.
00:29:48.630 - 00:30:00.392, Speaker G: But yeah, it opens the door for less ideal test cases or less. Yeah, it's not ideal either.
00:30:00.446 - 00:30:20.620, Speaker A: I think I know what you guys think. So should I extend the filled test format to include an array of exceptions where we just interpret that array of exceptions as like, the output of this test must be one of the exceptions listed?
00:30:22.960 - 00:30:59.790, Speaker G: Yeah, I mean, that, that could be one suggestion, but I'm not sure if we are just lowering the coverage of these test cases by doing that. I know it's not ideal, but I've seen at least one test case where it's impossible to determine the exact error because you would need to know the implementation to see what check goes in first? I could give an example, but I don't quite remember now. I just know that there is at least one test case where it's impossible to know. Which exact error are you going to get?
00:31:00.960 - 00:31:47.310, Speaker A: Yeah, well, right now there is this kind of confusing error unexpected into file, and this is something that probably needs to change, but it kind of overlaps with other errors. Like you might have a magic that's invalid because you only have the EF byte. And some might say that that's an invalid magic depending on how you check it. Others might say that I was trying to read something and I ran out of things to read, and so it was an unexpected end of file. That's a case where maybe the errors there are just bad there, but that would be a case where you could have two different outputs. Ahmed.
00:31:48.690 - 00:32:11.862, Speaker H: Yeah, but in this particular case, I think that if you have EF without the, then you shouldn't be running the EOF checks in the first place, because this is not EOF code and should be just treated like normal code and fail like the normal code fails when it gets an ah.
00:32:11.916 - 00:32:18.010, Speaker A: Yeah, okay, I think you're right. Okay, so say you have EFO and you don't have a version.
00:32:21.300 - 00:32:23.744, Speaker H: Yeah, this example makes more sense.
00:32:23.942 - 00:32:26.000, Speaker A: Yeah. Dana.
00:32:27.300 - 00:32:57.020, Speaker B: So there's another way we might have multiple errors. Let's say there's five ways that a code section can fail, and we have a test case that has five code sections in each code section failing in a unique way. Do we then mandate that you have to evaluate the errors in byte order, in linear order? I think it's going to be possible to say that with one particular EF, there's only one error, you from it. I don't think we want to get to that level of specification.
00:32:59.440 - 00:33:00.380, Speaker A: Mario?
00:33:00.960 - 00:33:24.790, Speaker G: Yeah, I would argue that that's not a good test case, because, yeah, you want to only test one section, one particular at a time. But it was more like, for example, I thought of an example. I wanted to make a test case where you overflow the stack. So we have stack overflow error in the list, but to do that, we would have to list too many.
00:33:27.560 - 00:33:27.924, Speaker A: Too.
00:33:27.962 - 00:33:43.610, Speaker G: Large max stack height, for example. So which one of the two errors would you list? Because if you want to overflow the stack, you have to have a high max stack height. So those kind of things, those very specific things.
00:33:48.800 - 00:33:49.660, Speaker A: Ahmed.
00:33:52.650 - 00:35:08.842, Speaker H: Yeah, so I just want to note here something that probably, with this expected error exception that we will face, is that, for example, in nethermind, we check that the EOF code. So basically, any code that starts with EF, that it has a minimum of like 20 bytes or 19 bytes or whatever, the minimum valid EOf code could be, right? And this is the first thing that we do to validate the code, because it does not make sense to go through parsing the code if we know that it is smaller than any valid code out there. And this probably is not the same way it is implemented in other clients, for example. So, for example, other clients would go through things, and they might have an error that is different than this one. So we would say, oh, this is not EOf valid code. Because its size is smaller than the minimum EOF valid code. But the other client failed because, for example, the version is two instead of one, and two is not, for example, valid version for EOF.
00:35:08.842 - 00:35:22.340, Speaker H: So I see what you're trying to do with these expected exceptions, but I think that they introduce a lot of conflicts. So not sure if they're a good idea to go through with.
00:35:27.740 - 00:35:28.760, Speaker A: Ivan.
00:35:31.200 - 00:36:21.950, Speaker C: In my opinion, if we are going to do this, we need to be extremely sure that each test case is isolated and doesn't touch any other test case. So if we have truncated code or very small code, we should make sure that at least the prefix or what is included in that test case is correct. And the only invalid thing in that test case, the example I said in that test case is the code being incomplete. So if we have multiple stuff happening in the same test case, that leads to some confusion. Also, we can restrict the order of checks. We can make it explicit, do this, then do this, then do this, or something like this in the eips themselves. But I would prefer not doing that.
00:36:23.840 - 00:37:25.552, Speaker A: Yeah, that makes sense. So, I mean, one way that we can use this is we can kind of use this as a tool to help us understand if the tests we're writing are testing like the things that we expect and the thing that we really care about when we look at, okay, are clients passing these tests. We look at the binary output, is there an exception? And did the client throw an exception? That way we don't get stuck on this whole, our clients doing things in the right order. But as a test writer, still saying, I am expecting this test to fail this way, having that in the filled test, maybe as a client runs those tests and the test says it should fail because of stack overflow, but instead it fails because there were not enough code sections or something. This can be a signal to implementers that maybe there is something to look for more deeply. It could be a signal for test writers that maybe the test that they wrote is not testing exactly what they think this is. I don't think going to be like a perfect system.
00:37:25.552 - 00:38:02.850, Speaker A: It's not going to be something where one side, either the client or the test filler format proposal is going to be perfect in a vacuum. It's something that's going to have to go back and forth a little bit. But if people are okay with this, then I think that we should just move forward with having these enumerated errors, see how it goes, but not get too hung up. If the error that test is requesting is different than what the client is throwing. Does that seem like an okay way to move forward? Alex.
00:38:05.030 - 00:38:35.210, Speaker E: Yeah, I would be in favor of giving this trick to a try, but quickly able to iterate and roll back if you get confirmation. That complicates testing too much. Yeah, I think in an ideal case it would be nice to actually have all of the error conditions for the EVM properly specified and test the order of. Yeah, I mean that's, that's a really long term goal.
00:38:37.230 - 00:38:48.720, Speaker A: I think it's an interesting goal though. And I think, yeah, we should keep thinking about it and use this sort of experiment as a way of understanding how feasible is it?
00:38:49.410 - 00:38:53.358, Speaker B: Eamon also, there is this one thing.
00:38:53.444 - 00:39:30.890, Speaker C: Like there are three aspects in the code that we should test. There is the parsing of the header and the EOf code itself. There's the execution of EOF code, and there's the deployment of EOF code, the parsing itself. We can do stuff in different order and we can have different errors, but the result should be the same. A valid UF header. A valid UF code is a valid Uf code no matter what the implementation says. But for deployments and for execution, we should be strict about the error messages.
00:39:30.890 - 00:39:45.700, Speaker C: For the parsing we can be loose a bit, but for execution and deployment we should be strict. There's no other cases. They are consensus stuff. They are not just parsing stuff.
00:39:46.550 - 00:40:09.190, Speaker A: Right. But the error output is still binary, even in consensus. So if the output is not to deploy the contract and spend this amount of gas, these are pretty binary things versus having error codes. This provides a lot more granularity into understanding the failure.
00:40:09.690 - 00:40:10.680, Speaker C: Oh yeah.
00:40:16.410 - 00:40:56.630, Speaker A: It I think we should talk about the interopsum. We can keep talking about this testing format more in the EVM channel there are these filled tests. If people want to start looking at implementing this, implementing some sort of test runner in your clients, it should be really similar to how the UF parse tool that you guys mostly have already implemented would look. Oh, I guess one other thing I wrote on here. Are people okay with this fork format of Shanghai plus EOf going forward? Is the plus EOF something that all clients support and can implement, or should we change it to cancun?
00:41:03.540 - 00:41:23.130, Speaker B: When I asked what I should put it in for the other basic devs that were involved in EOF, they said put it in Cancun. So I put mine in Cancun, but I can alias the test to Shanghai plus EOF and have that go to Cancun because right now in the basic code, that's the only thing in Cancun, so I'm flexible. But that's where we're at.
00:41:24.140 - 00:41:26.010, Speaker H: We're also fine either way.
00:41:30.150 - 00:41:40.820, Speaker A: Okay, let's just put it in Cancun. I can rebuild the tests and they will be forked by Cancun. So let's do that.
00:41:43.770 - 00:42:03.820, Speaker H: Just one thing. Are we sure that the ethereum test names reflect the actual scenario? So when the test name says valid, does that mean actually it's valid and should pass? Or are these test names actually reflective of the result?
00:42:08.220 - 00:42:10.570, Speaker A: Paul? Alex, do you know?
00:42:12.380 - 00:43:11.180, Speaker F: Yeah, I think they should, unless there's some. So the tests, how they are written, you also put some expectations section that are not visible to the final file, but it's in the source file of the test. I think it rather don't happen that the test case kind of. So I think the tests are not like 100% blind. So you put some code and then just execute and whatever the EVM returns, it's your test. So there are some expectations that are checked against if there's something that you think is wrong that might be a mistake in the test or something like that, but they usually should reflect what are actually testing.
00:43:11.760 - 00:43:19.996, Speaker H: Can you point me to the place where this expectation is laid out or mentioned?
00:43:20.098 - 00:43:23.890, Speaker F: Yes, I'll find some example in a second.
00:43:24.660 - 00:43:25.650, Speaker H: Thank you.
00:43:37.480 - 00:43:40.500, Speaker A: Okay, any last things on testing?
00:43:45.400 - 00:43:51.850, Speaker F: Yeah, I kind of missed the decision on the Cancun, so this is easier for some people.
00:43:54.380 - 00:44:04.780, Speaker A: I think it's not a huge difference either way. And some people have already started using Cancun so we might as well just fill the test.
00:44:04.930 - 00:44:06.012, Speaker F: Okay, it's fine.
00:44:06.146 - 00:44:09.630, Speaker B: I think it's good marketing to say we intend to ship in Cancun as well.
00:44:18.260 - 00:44:33.130, Speaker A: The EOF director of marketing has made the decision. Okay, let's talk about this interop. Some of us will be in person in a week and a half.
00:44:33.980 - 00:44:36.200, Speaker E: Can I bring up something for that?
00:44:36.350 - 00:44:37.144, Speaker A: Yeah, go for it.
00:44:37.182 - 00:45:26.760, Speaker E: Speaking of Cancun, there have been some proposals for Cancun and related to AuF which have been proposed for Cancun because they were proposed late. Good example is the unlimited swap dupe, which would be quite beneficial for solidity and likely Viper and other languages too. Now given that this we hope to ship in Cancun, should we consider like this unlimited swap dupe in any shape or form or we shouldn't. I mean it was proposed for Cancun already, but given we moved like quite a big chunk from Shanghai, wonder how the effects.
00:45:46.850 - 00:46:15.590, Speaker A: I guess, you know, from my point of view I'm a bit apprehensive about it because it does feel that we're starting to reach the edge of what we can comfortably do in a single fork. We have a lot more time now, and maybe that affords us a greater ability and range of changes, but yeah, not really sure. Paul.
00:46:17.550 - 00:47:09.930, Speaker F: Yeah, press strong button. Yeah. How I think about it is the current spec and the current test suite is like EOF 1.0 and there are some additions that I think we can consider later, mostly for testing. So think once everyone is kind of on the same level about testing and we're kind of confident, I think there are three or four additions that can be added to current EOf that are backward. They're kind of compatible with the current spec. So examples are this like swap dupe unlimited version, this jump f instruction that we removed.
00:47:09.930 - 00:48:37.400, Speaker F: There is this no return, the notion of no returning function that has some affect the stack validation and can enable some optimizations on the compiler side. The fourth one, that's what someone suggested I think yesterday or two days ago about the delegate call issue. So we can also add this one in. I'm not sure this should be commitment to ship it, but if we have some basic revert ability to revert implementations to the stable 1.0 version without so much issues, and we can always kind of revert to snapshot of tests and so on. So if we have time, I would go this way and also work on the EOF 2.0 whatever spec with some additional changes so we can decide on the way what milestone we want to test right now if it's a good candidate for shipping altogether, I'm not sure, but at least at this point I would do it this way.
00:48:42.360 - 00:48:47.352, Speaker B: Andrew Daniel yeah, I think during the.
00:48:47.406 - 00:49:34.760, Speaker I: Last ACD call it was mentioned that there are some hacks with EOF required in solidity. So to my mind that the priority we need to address is it due to constructive arguments or something else? I don't remember exactly, but yeah, I would prioritize solidity implementation and alter EOF so that there are no hacks or like minor, only minor hacks in solidity, any kind of extra features. I agree that it's already big enough so that it's on the edge, what we can comfortably deliver. So I would rather fix bugs rather than add new features.
00:49:36.540 - 00:50:33.016, Speaker D: Daniel yeah, I mean I can speak about the issues in solidity. Contract creation is maybe the most annoying one. There's also another thing I want to hear some opinions about whether it's feasible to still address, which I'm not entirely sure about, that's why I didn't bring it up earlier. But which would be relaxing the stack validation because currently it prevents code deduplication in cases where I think it doesn't have to. If we make this algorithm more complicated, but still in linear lunar runtime in the number of opcodes, I haven't thought it through, but I may be able to suggest a change there which would allow for more codeuplication for us to do, for example to jump to rewards from positions with different stack heights. That's the issue. But yeah, not sure how the general idea is there.
00:50:33.016 - 00:50:43.020, Speaker D: That's something that is really a change and can't be added later, whereas we really like the swapped up stuff. But I agree that it can be added later with less effort.
00:50:44.000 - 00:50:58.400, Speaker A: Yeah, we definitely want to understand what is important useful for you guys because we want to be able to do the things that we can't do later now, obviously. So any more information on that is helpful. Daniel.
00:50:59.620 - 00:51:52.400, Speaker B: So we need to tread carefully on the stack validation because that is critical to some transpolation issues. If we can enforce the swap dupe. But like the case that you outlined where you're jumping to something terminal and only the top x components matter, but there's mappings, like color mapping, register swaps that can be done that we would lose if we get rid of stack validation. But if we're taking what would be invalid and moving it to something that would be valid, that's like a soft port fix and that is something that can be added later is if we take something that was valid and then making it invalid, that's where we have to bump major versions. So adding things like swap dupe to infinite swap dupe, those can be software added into 1.1 and don't have to be done on the first thing because it's increasing the scope of what's valid rather than moving stuff from valid to invalid.
00:51:53.540 - 00:52:59.350, Speaker A: Yeah. Okay. I want to switch gears and talk a bit about this time that we're going to have in person in a couple, in a week and a half or so. What are clients teams plans for interop in general? I've been talking to Tim a bit and it seems like it would be really ideal if we had this separate track where we just sat together and we just really worked through some of these that like do we have enough things to work on? Are people going to be able to work on EOF? Do you have other responsibilities you're going to need to be working on? With respect to 44 four in Shanghai, I'm not sure. What are people's? I am personally able to work only on EOf that week, but I don't know what others people's responsibility load is. Is anybody actively working on EOF right now for a client team that won't be there or won't be able to work on?
00:53:01.020 - 00:53:12.420, Speaker H: Okay, I will be there, but I will be also working on making sure timestamp working works correctly.
00:53:12.580 - 00:53:13.290, Speaker A: Okay.
00:53:14.380 - 00:53:22.300, Speaker H: And probably that's mostly it devnet stuff, but that's mostly okay.
00:53:22.450 - 00:53:52.000, Speaker A: Sounds good. Okay. Yeah. Tim was also talking about this. Daniel, I think it would be great to have you at some point. I think we should spend some time and figure out what we want to do with EOf that week to know when the best days for you to come would be. I don't know if there are certain days, yeah, we can talk about offline, but if there are certain days that work better for you, obviously let us know.
00:53:53.250 - 00:53:56.580, Speaker D: Tuesday probably would be best if anything.
00:53:57.110 - 00:54:46.850, Speaker A: Okay, that sounds good. I talked to Tim also a little bit and he wants to do a session where we talk about eof two or mainly about these ideas that Vitalik is having. Yeah, so that will definitely be something. We probably want to do it later in the week so we can spend some time together and flush some ideas out beforehand. We can continue talking about this like async. I think the biggest thing I want to talk about before we go from this call is what types of things do people want to have ready when we show up there? We already sort of have pretty good interoperability of clients. Are there any things that we can prepare in the next week and a half that would put us in a good place for getting a lot of work done at the workshop?
00:54:47.830 - 00:55:13.510, Speaker H: So can we say that the Ethereum tests are finalized for babyof? Because if they are, then clients should be working on making sure they pass all the tests so we can have some type of a divnet. I believe this is one of the best ways we can go with that week.
00:55:14.920 - 00:55:34.760, Speaker A: I just feel like we're pretty early in a cycle now that we've reset on devnets because we have outstanding spec problems that we need to resolve mainly this constructor problem. And so until we solve that, it seems like building devnets is not as much signal.
00:55:38.900 - 00:56:07.240, Speaker F: Yeah, as of tests, I think they're not final yet. So there's still like tests being in preparation mostly to add new test cases which hasn't landed yet. And as I mentioned, I think there's one issue with the tests and one of the implementations that we have to also correct. So yeah, still there are some moving parts.
00:56:10.240 - 00:56:14.940, Speaker A: Are some of these tests merged now to east test master?
00:56:15.300 - 00:56:28.070, Speaker F: Yeah. You mean about the main branch? So yeah, not everything landed there. And this one issue that we have to check.
00:56:28.840 - 00:57:18.390, Speaker A: Okay, so if I can make a proposal for a game plan until we arrive there, maybe first we come up with a list of the tests that are released and make sure that clients are passing those tests. That would be a good place to start from just knowing that we are all implementing the same things. And then maybe I would make the request that we would also implement the reference test tool. That could be like a good place to expand upon in person, figuring out how to deal with these error codes if we're going to deal with them. Maybe trying to do some fuzzing based on that. I think that if we came with those two things, that could be a pretty good place to start. Does anybody disagree or have other things they would like to add to that list?
00:57:25.510 - 00:57:42.706, Speaker B: Those sound reasonable. We also need to have discussions on things like the delegate call, basically circumventing suppressions. We didn't have time for that on this call, but I think that's also on the critical must fix for EOFB one, where we can only delegate call.
00:57:42.728 - 00:58:18.700, Speaker A: To other EFS eos. Yeah. So I guess, yeah, I'll write a document and I'll share with everybody about some milestones we want to have before we get there. But I think maybe one other thing I would also add is just to spend some time and think about what are the things that need to be solved for EF one, and then we can just kind of start out the week and sit down and talk about those things and really hammer through any kind of spec issues that still exist. We're 1 minute over. Any final comments on the interop, anything we discussed?
00:58:24.300 - 00:58:33.930, Speaker H: I would just say that I would push for the delegate call thing for AOf one instead of pushing it to AOf two.
00:58:35.500 - 00:58:56.370, Speaker A: Okay, sounds good. Yeah, let's keep discussing it. Thanks a lot everybody for taking the time to join this breakout. And I will send some more information about these milestones that we talked about and we'll see a lot of you people here in a week and a half. Thanks.
00:58:58.260 - 00:59:00.000, Speaker E: Thank you. Bye.
