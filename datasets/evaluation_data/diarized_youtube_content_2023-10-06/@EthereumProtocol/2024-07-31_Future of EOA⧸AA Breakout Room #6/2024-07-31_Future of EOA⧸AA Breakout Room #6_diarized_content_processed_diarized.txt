00:00:01.760 - 00:01:06.955, Speaker A: All right, I guess we can start. So this is the breakout number six to discuss 7702 and we are going to discuss the latest proposal, the latest change request and we will try to, to move forward if we can at the end of this call. And then there is ACD on Friday. So it would be nice if we can have some type of decisions for Friday. I think I've seen a blog post recently, an ACMD about proposed changes. Maybe we can start here or maybe like lion first you can give us a quick update on the status and the latest version of 7702.
00:01:16.215 - 00:01:18.515, Speaker B: I don't really even know where to start at this point.
00:01:20.105 - 00:01:23.081, Speaker C: All right, we can.
00:01:23.273 - 00:02:59.825, Speaker D: I feel like the current situation is basically that like we've been in this state where there's been a couple of proposed changes and the list of proposed changes like sometimes keeps increasing and like, sometimes we keep like having some ongoing discussion on them. And I think there's a strong desire to get this to the point where we can actually, yeah, like have finality here on the spec or if, if not finality on the spec, something very close to that so that know at least the scope creep of the whole thing doesn't just keep increasing. Right. So I know that at least about a week ago when like I suggested the idea to have this breakout, there were at least a couple of different ideas around. You know, like the. Yeah, the current, the current design which has, you know, this, the new account type and then some proposals for things that we can, that we can replace it with. And I'm trying to remember what the specific ones are like.
00:02:59.825 - 00:03:45.355, Speaker D: Okay, so one of them is this concept of a code reset opcode. Another one was the basically adjusting the behavior of storage opcodes so that they use hashes to go into deterministic storage slots that are different for every proxy. And then I think like one or two other ideas. So I guess one way to start is to just directly get into some of those. I mean, or we could talk about like underlying philosophy, but I feel I could disagree like talking about either one of them just gets into the other one. Anyway.
00:03:47.175 - 00:04:54.879, Speaker C: That makes sense. I mean, maybe I can set a little bit of context also for. So we, we wrote this document that about code reset and, and I can maybe share with, with everyone here a little bit of context on how that that came up. I want to be mindful, like I feel like I'm kind of like coming in at like the last mile here where everyone is already super fatigued about reh. This, this EIP and making some, some suggested changes. And so I do, I do really appreciate you guys spending the time to entertain it because I know everyone, the common goal here for everyone is to get something included in Petra and, and that's I think the North Star that we need to, to keep everyone aligned on. But yeah, there was a, there was a, a workshop that was hosted by the Wallet Connect folks and, and, and Derek put together during Brussels where we, the 7702 proposals and then the latest changes that Light client had merged and the topic of ephemeral versus non ephemeral related to the code that's being added to 7,702 accounts was sort of brought up.
00:04:54.879 - 00:05:30.125, Speaker C: And the impetus for this initial discussion was the idea is there a way to maintain the optionality of an account to be either persistent or ephemeral in the, in the creation. And then throughout that workshop sort of came together a few different ideas around how to, to be able to enable that. So maybe I can quickly share the screen and share the link to this, to this document here. You know how to copy the link?
00:05:32.755 - 00:05:34.295, Speaker A: Yeah, you can paste the link?
00:05:41.435 - 00:05:42.043, Speaker E: Yeah.
00:05:42.139 - 00:06:55.873, Speaker C: Okay, so there's this document that we put together that really just aimed to be a summary of the discussions that were had. It suggests three changes to the 702 proposal. One of it is around 3607. So basically to disable the EOA key from being able to continue operations, the introduction of this code reset opcode that allows for deleting the code at an address without impacting the storage and then having optional CAL data that can be passed as with the, with the transaction to be able to initialize the account. The idea being that if you want to have ephemerality, you can implement it by deploying the account code, calling the constructor, and then at the end of the constructor having this code reset opcode be called such that the account returns into EOA functionality. So that was the impetus and sort of the summary of the workshop. We had discussed a few of the different concerns with this.
00:06:55.873 - 00:07:40.975, Speaker C: One of them being, as Vitalika mentioned, the storage slot issues. And then we sort of discussed two mitigations, one of them being at the solidity pragma level and then the other one being updating the storage nodes. I don't think that it makes sense to discuss these mitigations specifically because they feel very tangential and it also solves an issue that exists already with smart contract upgrades. So I think it would be wrong to focus this workshop on the storage stuff. Perhaps it makes more sense to focus a little bit more on the suggested changes. So that's the context from our perspective. But yeah, feel free to ask any questions or jump back in.
00:07:43.395 - 00:07:48.825, Speaker A: Okay, so Ansgar, maybe you want to and go.
00:07:50.645 - 00:08:47.451, Speaker E: Sure, I can give my opinion. So I will say this is definitely. It looks like an interesting direction to go, an interesting feature in general code reset, but I think I'm opposed to adding it to 7702 just because it basically just changes the character of 7702 quite significantly. It basically turns it from a temporary kind of upgrade of NEO A into smart account into a permanent one. Because by default you can just basically use code that does not have code reset. And that way basically it's now all of a sudden a permanent upgrade, which is specifically something that we considered out of scope for 7, 7 or 2. And then even with this kind of this code reset, basically it's a completely new type of pattern that we haven't really reasoned through before, which just significantly changes the character of the ip, the scope of the ip.
00:08:47.451 - 00:09:00.255, Speaker E: It's something where I definitely think I can see a world where some feature like that eventually would make sense and would be a nice feature to have. But to me there really is no good reason to combining it with the existing erp.
00:09:04.235 - 00:09:16.015, Speaker C: Could you help me understand what's the profile of the current ERP that you think is being changed here by those suggestion? So what's the intent behind the current EIP that this would sort of violate?
00:09:17.395 - 00:10:04.265, Speaker E: So the intent behind the county is that in any situation the ultimate authority over the EOA or the IS it always lies with the EOA key itself. And that basically the code is just a supplemental delegation that can always be ultimately revoked by the authority of the original ua. And in this situation now you can basically like you would now instead move the authority of moving the authority back to the UA into the code. So the code would have to itself decide to call code reset. Unless and until it does that, the UA key itself is powerless. And that specifically, I think, in my understanding, was not what what the EAP was trying to achieve.
00:10:04.565 - 00:10:46.155, Speaker C: That makes sense. Yeah, I agree with you. If that's the intended outcome of the ip, then this is a deviation from that objective. I think from the conversation that we've had with a lot of the smart contract wallet teams, they would prefer to have this ability to switch completely to a smart contract account because then this allows you to unlock a lot of functionality of a smart contract account. But if purely the goal of this EIP is to add programmability to EOAs. Then it creates this new type of account which is kind of like not an eoa, not a smart contract account. It's this third type of account that right now, as far as I understand, no one is really building towards.
00:10:46.155 - 00:10:52.435, Speaker C: So yeah, I wonder who are sort of the stakeholders here that want this program.
00:10:57.385 - 00:11:50.835, Speaker F: Yeah, I think it's probably, I can chime in here. So anybody who has, I think Wallet will be building towards this because the entire idea, the way we see that. Right, the entire idea with 3074 moving on to 7702 is that until now a lot of the things that we as an ecosystem wanted to push for came not aligned with EOA wallets. And so EOA wallets didn't participate and so the adoption was pretty small. So when you introduce something like a way to do interaction between Dapps and wallets that will allow batching 99%. Well, not 99, but like a lot of the wallets that are actually using those features are not part of the game, they do not participate. This gets less adopted.
00:11:50.835 - 00:12:54.629, Speaker F: So as soon as we have those capabilities like 7702, we will be building towards supporting a smarter, better UX with applications where both smart contracts and EOs can support the basic feature set. So that is I think at least the way I see this, this is probably the biggest goal that we're trying to achieve right now is to allow those better UX experience to be widely adopted. And then over time I think that there's a way to introduce additional features that will maybe like ask your said, like over time we introduce more and more capabilities that kind of push towards more and more smart contract capabilities taking over. But, but yeah, I think this like using this account that is an EOA but has the ability to run code is definitely going to be going to be adopted and I can say that because we'll definitely be building with this.
00:12:54.677 - 00:12:55.345, Speaker A: All right.
00:12:55.765 - 00:13:38.465, Speaker F: The one thing that I just wanted to add is, or maybe raise as a question is regarding the ability to add code reset just as a way to basically not save the code for future operations, which is, I think I've been saying this a few times but having a one transaction ability is still useful. So regardless of stopping EOA transactions, if we can have the ability to code reset at the end of the transaction, I think that may be a smaller addition that is still valuable. I understand if like not everybody sees the value in a single transaction delegation, but in terms of actual risk on the people Using this, I think it actually makes a big difference.
00:13:39.515 - 00:13:47.855, Speaker D: I guess that approach is interesting because that just like fits right into basically the way that self destruct already works. Right?
00:13:48.875 - 00:13:49.775, Speaker F: Exactly.
00:13:54.955 - 00:14:04.655, Speaker A: Derek, you had your hand raised first. I think you're muted.
00:14:06.305 - 00:14:46.697, Speaker G: Thank you, Derek from Wallet Connect. So I agree with ARIC and everyone in this room that I think the core premises that 7702-3074 bring to the table is we can batch transactions, we can sponsor transactions. End users can pay for gas in ERC20. End users don't need to learn what gas is anymore because they learn about an ERC20IS, which is especially important now that we have this explosion of L2 chains. Mike. So I don't represent a wallet other than a test wallet, but I've talked to a bunch of wallets about this. I talked to aric, I talked to Rainbow, I talked to Trust.
00:14:46.697 - 00:15:28.679, Speaker G: Trust is a special case because they have an ERC437 wallet and there's only really trust. Timeless and OkX were noteworthy 437 wallets. Who, who adopted that? I'd say maybe Coinbase, Smart Wallet. The point I want to make is I'm concerned about the adoption of 7702. I think if there's this ephemeral case with self destruct, I think it allows for an easier migration path for wallets because there's less state to manage because you deploy and then you undeploy. And. And I'm also a fan of the modification because it allows us for.
00:15:28.679 - 00:15:49.435, Speaker G: Which I know is not the intent of 7702, but it allows for a more permanent migration, but it allows for it on the, like a layer above the protocol. So we don't need to wait for another protocol change. But your main concern is adoption of 7702 in its current form.
00:15:53.845 - 00:15:55.265, Speaker A: All right, Ahmed?
00:15:56.085 - 00:16:30.580, Speaker H: Yeah. So, like, looking at how we reach 7702 is looking back at where. How we reached here because it feels like we're backpedaling a little bit. Like we had 3070, whatever, like the opcodes. And we thought, okay, these are not compatible with 4337. And these are not compatible with existing infrastructure that we want to be compatible with. And this is why we were like, okay, let's do 7702.
00:16:30.580 - 00:17:24.959, Speaker H: And when we first introduced 7702 without the designation delegation, it had some problems and a lot of people were raising issues about these problems. When we came with the designation delegation, all of these problems were fixed but now we are faced again with oh, but wallets don't like that. But we were fixed like by doing this we were fixing other issues that other providers and other wallets have been complaining about. So what I'm trying to say here is that there isn't a spec that will please everybody. That's 100% like a fact. There is always a spec that is going to be the most, like the best for most. But that will not work the way everyone wants.
00:17:24.959 - 00:18:30.255, Speaker H: Now if we want ephemeral delegation designation I think we can figure this out. But code reset is not. I don't think code reset is the way to go because with code reset I feel like it provides this ability inside the EVM and not from the transaction itself. And I think that if we want to introduce something like this, it should be from the designation itself. So you designate only once with the nonce and then once this transaction is executed the designation is reset. But I believe that last time we talked about this Ansgar said that there is a DOS vector to this approach and I want to touch back on that. Like we go back and try to solve this issue and this is I think the correct approach to ephemeral designation or delegation.
00:18:42.965 - 00:18:57.865, Speaker A: Okay, do we have more, more strong opinions on this or should we, should we jump to the next point?
00:19:00.945 - 00:19:01.425, Speaker D: David?
00:19:01.465 - 00:19:02.045, Speaker A: Yes.
00:19:05.025 - 00:19:26.379, Speaker B: Yeah, I'm David from Trust Wallet and I wanted to share some views from a wallet perspective on why we think that code reset may be quite useful in a lot of wallets. Like some of the other UX things that have been mentioned like batch sponsorship and things like that will be able.
00:19:26.427 - 00:19:28.281, Speaker A: To be done through 7702.
00:19:28.410 - 00:20:41.945, Speaker B: But one other major thing that 7702 somehow delegated to further protocol update was regarding validation and in quite a lot of UX related hurdles that wallets and a lot of protocols I think needs to handle right now is regarding the validation and users key management and I think this code reset and blocking the wallets, the EOAS from making protocol level transaction actually enables a custom validation skim that could be implemented through smart contracts. So yeah, one thing I wanted to add on top was that besides some execution related functionalities that Devin710 enables, I think the other thing that we are interested in and want to see coming through is regarding the validation. Like we want to unlock some validation related features and make those things customizable so that for chain abstraction related protocols as well and some for wallets we can I think somehow potentially reduce the risks related to wallet Key management.
00:20:47.975 - 00:20:50.555, Speaker A: Okay, Ankit, go ahead.
00:20:52.935 - 00:21:40.821, Speaker I: Yeah, I just want to highlight what David basically said and I sort of agree that there is no perfect solution. Everyone is trying to make the EVM ecosystem better in their own way. And so there are a lot of different opinions but just putting out there the stuff of how wallets think about. Basically with the current 7702 spec, we are creating this new type of account which has smart contract code but the EOA has root access so the EOA can move assets away from the, from the smart contract code and that has. That basically breaks validation that basically. So you get. What do you get from this is you get batching, you get pay masters, but you don't get the security of smart contract wallets.
00:21:40.821 - 00:23:23.131, Speaker I: And that is I think like the root cause of all this discussion is where like do you still want the EOA private key to be able to have the root access of your account or are you willing to delegate that job to the smart contract code? Because if you delegate that job to the smart contract code then you have access to a lot of user experience social recovery resource logs, all of which make the overall experience much, much better in terms of wallet for wallets and other application builders. And so that is one thing that I want to highlight over here. One of the concerns that we have heard when we talk to some of the people about why the why making the private key a root access is important is because, so that it is very clear to the user that the private key, the private key can still basically withdraw funds. So for all the chains where the user has not migrated to the smart contract wallet or for some edge case tokens where permit or E recover based permits are still valid, if the user loses their private key then their assets can be withdrawn. For those tail end chains and for those tail end tokens, I think at the end of the day this is a point about educating the user and some someone or the other has to educate the user about what is the seriousness of the private key even after they have migrated to a smart contract wallet. And we cannot expect a retail user to basically click a button and understand all the nuances of. Okay, now my private key is still the root user.
00:23:23.131 - 00:24:14.931, Speaker I: I need to keep it more, more secure. We have been talking to wallets. Half of the wallets one week ago did not know what, what is the current spec of the 7702. So even the wallets who are working in this domain do not know what is, what are the nuances. We cannot expect this from a user the perfect place to educate the user is when the user is clicking the button, show them like a big red button saying, keep your private key secure. And so even in that scenario, if you, if you basically educate the user that way, what you get is even if the private key leaks, which happens if the private key is root user, all the user's assets are at risk. But if the user has migrated to this more secure version, then only the assets which lie in the permit type scenario are at risk.
00:24:14.931 - 00:24:45.295, Speaker I: And we ran some numbers. Almost 99.85% of transactions that happen in the last year do not have those permit type issues. And 99.9% of L1TVL does not have, does not have a permit. So the amount of assets that we are caring about for making sure that assets are at risk or are not at risk is very minimal.
00:24:45.875 - 00:25:02.895, Speaker B: That's not true. We exchange dm, we exchange DMS about this. ENS is a token that's at risk. That's billions of dollars. Like, it's not true that it's minimal amount of risk. Many of these tokens that have permit two do not support 1271.
00:25:04.115 - 00:25:12.935, Speaker I: Yeah, I just sent a link. I just sent. You can argue if it is minuscule or not, but almost 99.9% of assets are not at risk.
00:25:13.635 - 00:25:14.775, Speaker B: That's not true.
00:25:15.235 - 00:25:31.363, Speaker I: Yeah. Of the L1 FDV, I have, I have sent a link to the, to the analysis as well. ENS is at risk. But are you willing to hold back changes for one token? One or two tokens?
00:25:31.499 - 00:25:34.655, Speaker B: Yeah. For billions of dollars of value? Absolutely. Yes.
00:25:36.115 - 00:25:36.827, Speaker A: All right.
00:25:36.971 - 00:25:45.591, Speaker C: Is this an ENS chain or like, I don't know, I don't understand. Like, there's two, there's two tokens that are significant that have, like, permits.
00:25:45.663 - 00:26:18.205, Speaker B: I don't trust what you're saying because I literally picked one random token and it was at risk. So until someone else does some analysis to tell me that ENS is literally the only token at risk, you were trying to tell me weeks ago that there weren't very many funds at risk. I pick a random token and it is clearly at risk. So I don't really trust the fact that you guys are saying that there's not that many, that much funds at risk. It doesn't seem true, and it doesn't really matter because ENS is at risk, and that's a billion dollars. That's enough for me.
00:26:18.325 - 00:26:53.541, Speaker I: I don't agree that ENS or I would reframe that question. So let me reframe this again. You have two scenarios. One where private key is the root user and it has access to all the assets. The second where the private key is not the root user and only a subset of assets are at risk. We are proposing the second scenario where a subset of assets ENS and a few more others are at risk. What you are proposing is if the user loses their key, then all the assets are at risk.
00:26:53.541 - 00:26:54.905, Speaker I: Is that correct or not?
00:26:58.135 - 00:26:59.675, Speaker B: I. I don't know what you're saying.
00:27:06.335 - 00:27:38.525, Speaker I: Let me, let me share my screen. Maybe that's clearer. So there are two proposals. One for making. Maybe. Maybe let's take it step by step so that you and others in the call might, might understand. One proposal is to make the EOA private key the root user, which is the current 7702 spec.
00:27:38.525 - 00:27:59.745, Speaker I: The second is to not make the EOA private key the root user, which is all the transactions go through the smart contract code. Those are the two proposals, right, Matt?
00:28:02.285 - 00:28:04.637, Speaker B: Sure, those are the proposals.
00:28:04.821 - 00:28:29.595, Speaker I: So with one proposal, if the user leaks their private key, they all their assets are at risk, ENS and all the others. With the second proposal, if the user leaks their private key, then only a subset of assets which have E recover and not one to seven one supported those assets are at risk, right?
00:28:31.255 - 00:29:15.063, Speaker B: I mean this is. There are so many things wrong with this comparison that you're trying to draw here. Like it doesn't matter that if you go with this code reset mechanism that the UAS have migrated, that only then a subset of of assets are at risk and you're trying to like draw this comparison that it's better than in the world that we have previously. The problem is that when people migrate, migrate fully to a smart contract wallet, they expect that the smart contract wallet is going to secure their funds. And that's not possible because of these tokens that don't support 1271. It's still possible to steal the tokens. So yes, if you migrate to a smart contract wallet from an eoa, then some of your funds will be quote unquote protected.
00:29:15.063 - 00:29:59.607, Speaker B: That's not really a fair comparison because really a true smart contract wallet does not have this problem where funds can be stolen out from under them. So it's difficult to communicate to users, to educate them that even though they have upgraded to a smart contract wallet, their friends have a gnosis safe that they deployed to the smart contract wallet. They don't have to worry about these private key problems. It's hard to communicate that because they came from an eoa, the private key still has to Be secured in a very special way. Yeah, this is the issue. It's not about reducing the scope of funds that are at risk. And then the analysis that you're trying to do where you're trying to say like the number of transactions, the amount of volume of transactions is very small, that's at risk.
00:29:59.607 - 00:30:21.045, Speaker B: That's like completely the wrong metric to be accounting for. You should be accounting for the value. It doesn't matter if the value is being transacted. It matters if the value is at risk, if the value can be stolen, if the private key is leaked. So who cares? Like if you're sending USDC back and forth between two wallets 10,000 times? Like, what matters is that ENS $1 billion is possible to be stolen from.
00:30:22.945 - 00:30:43.255, Speaker I: The value is only. So yeah, I agree. It's an education issue. You can only. The value will only be stolen if the private key gets leaked. And the best person, and we cannot expect the retail user to understand all the nuances about different type of security considerations when they are clicking a migrate button the best.
00:30:43.335 - 00:30:59.275, Speaker B: So let's not make it harder for them. Let's keep it simple. EOS completely control the account or you deploy a smart contract wallet. That's simple. That's the world that we live in today. There's no reason to overcomplicate the situation.
00:31:06.615 - 00:31:18.319, Speaker C: To me, it came back to like, what was mentioned at the start. Like, if the intent of this EIP is just to add programmability to eos, then like, all these discussions are like somewhat moot. I think what's like, been a struggle for.
00:31:18.367 - 00:31:40.785, Speaker B: But that's what the point is. So why do we continue to have this conversation? Like we've been talking about this for three weeks asynchronously and people keep saying the point of 7702 is not to migrate EOS. But we again are here on this call trying to migrate EOA smart contract wallets. So when are we just going to say, all right, we're not migrating EOS to smart contract wallets and move on to the next problem?
00:31:44.365 - 00:32:22.715, Speaker C: I appreciate your patience with me, Matt. Like, I know that you've been on this for like, much longer than I have. And so that's, you know, my apologies for coming in again at the last moment here and rehashing these questions. So please, please bear with me. So understood on all those points. I think our intent here was to share some additional features that aren't going to be covered by 7702 and that some of the concerns that we Raised so far weren't as notable as what was initially perceived to be. But I'm happy to yield the floor for other folks to contribute their opinion here.
00:32:25.185 - 00:32:27.885, Speaker A: Joab, I think you were the first.
00:32:31.065 - 00:33:10.261, Speaker J: Yes. So I don't want to argue any specific feature. And I also have my concern about any form of UI migration which can never be done in a fully safe way. And not only because of Fair Permit. But the reason I do like this change is from the, from the protocol perspective, because one concern I had about the current version of 7702 is that we are adding a third account type. One that is, that is both an EOA and a contract. And it has some security considerations that the EAP should at least mention.
00:33:10.261 - 00:33:40.005, Speaker J: But it's easy. But it's much easier to reason about, to reason about the EAP about the security of this if we are not adding a third account type. So what the change does is basically alternating the account easily between being an EOA and being a contract. But the account is always either this or that. It is never both at the same time. And that's the. So that's the main reason I would consider, I would consider this change.
00:33:40.005 - 00:34:31.931, Speaker J: The alternative is to try. The alternative is to have a thorough analysis of what are the implications of this third account type and then to at least document them in the security considerations. One of them is the DOS vector we discussed, which can be mitigated by at least three different ways. One of them is this change which makes the DOS impossible. There were two others, one that Matt proposed limiting the limiting depending transactions for these F4 accounts that have code to one penny transaction instead of F63. And yet another one is what ASGA proposed, making the code available only when the transaction declares it. So this also mitigates the loss then.
00:34:31.931 - 00:34:42.385, Speaker J: So we need to decide on one of these and write it in the security considerations, all to accept the. The proposed change and then it's no longer a consideration.
00:34:47.125 - 00:34:55.453, Speaker A: Okay, fair point. Derek, Pedro, I don't know which one of you was first. Derek, go ahead.
00:34:55.589 - 00:34:56.461, Speaker D: Sure, sure. Yeah, yeah.
00:34:56.493 - 00:34:56.709, Speaker E: So.
00:34:56.757 - 00:37:50.765, Speaker D: So I think, I think I just want to maybe show two points, right? You know, so, so, so one is that like I think, I think everyone is aligned that if we were to migrate the EOA permanently, then the risks of leaking the UA key gets lower because I guess the attack surveys gets lower. But I think it's also true that it just can be done perfectly with things like permits and other protocols that check signatures, but also just the fact that the account will still be EOA on other chains, right? So my point is that there is just not a UA migration proposal that is really able to address all these issues, right? So that's like the first point, but also the second point that I feel like I haven't seen people mention. It's just that the very reason why we wound up with this current form of 7702 is actually precisely. I mean, it's not really precisely, but I think a very big part of the reasoning has been that people actually want to keep their EOAs, right? I think basically I feel like there will be more adoption for smart accounts if there was a way for people to try out these smart account features. Whether it's batching, sponsoring guests, session keys, there's a way for people to try out all these features without having to permanently give up their uas, right? So if the cost of trying out these smart account features is for them to in a way almost like permanently migrating their ua, that's actually like a. Of course, like I understand that queries that will allow the users to then revert from the smart account back to the ua, but that still depends on the smart account being actually correctly implemented, right? But like with the current 7702, the fact that you can experience all the benefits of smart accounting, like a very low friction and very low commitment way, in my opinion, actually not a bug, but a feature, right? Just like the fact that you can kind of have the best of both worlds. And I think maybe the third point I want to make is just that I think we can probably all agree that even if one proposal is say a little better, like marginally better than the other, at this point I think we can all agree that the most important thing is to ship this in pacture, right? So if the alternative is like we ship proposal one in picture or we ship a slightly better proposal, that's like another 12 months away, I think most people, most so called stakeholders in the space will prefer the first option.
00:37:50.765 - 00:38:03.595, Speaker D: So I also want to say that, you know, I think wire is very important for us to consider all the points of views. I think at some point we just have to really commit to a solution to make sure that we can shift this impact.
00:38:06.575 - 00:38:10.115, Speaker A: Pedro, then Derek again, other Derek.
00:38:11.855 - 00:38:12.479, Speaker G: So.
00:38:12.607 - 00:38:59.995, Speaker F: Thanks Derek for sharing that. I think that you put it really nicely what we all want to achieve. But from my take, I think I share a little bit what Yoav said is the current solution puts the accounts in this very ambiguous state where it's both anyway and a smart account. And I know we were talking about education, but I think it's much harder to educate the user around how it's both at the same time, depending on the certain circumstances. Rather than having like just clear black and white separation, like we already have the ability to revert back to a new way. But when you're a smart account and E away, I think it should be just very clear as water that you're either one or the other. Right.
00:39:00.575 - 00:39:14.325, Speaker B: There's a separation between these two. It's still an eoa. Like it's an externally owned account, it's owned by the private key. We're allowing them to delegate some control to some other keys, but the root control is still the eoa.
00:39:15.225 - 00:39:24.529, Speaker F: But that's exactly what the proposal is trying to do where. When it's delegating, then it's actually removing the access from the private key.
00:39:24.657 - 00:39:25.641, Speaker B: So it doesn't.
00:39:25.713 - 00:39:26.105, Speaker E: You have.
00:39:26.145 - 00:39:40.795, Speaker B: That's the problem. Well, you're talking about exactly what you're saying, which that's control of the EOA or that's the control of the control of the account. The EOE key could still spend the assets. Like, this is why. This is exactly why we cannot do this proposal.
00:39:42.135 - 00:39:53.087, Speaker F: But the permits. It's a much smaller scope than just saying, then we're just going to let the UA be EOA completely like the.
00:39:53.111 - 00:39:55.279, Speaker B: Permits we already have. EOA is completely smaller.
00:39:55.367 - 00:40:03.087, Speaker J: So, Matt, when. When I said it's. When I said account is both, I didn't mean from the user perspective, but from the protocol perspective.
00:40:03.231 - 00:40:03.915, Speaker G: Yeah.
00:40:04.335 - 00:40:09.515, Speaker J: Do you agree with me that it's a failed account type and nothing like what we had before?
00:40:09.855 - 00:40:16.735, Speaker B: Yeah, I agree with what you're saying there, but I think Pedro is saying it's from the user's perspective, which I don't really.
00:40:16.775 - 00:41:04.445, Speaker F: Well, it is from the user's perspective, because if the user has the ability to import its seed phrase to a different wallet and it has some delegated smart contract, then the wallet is not going to act as the same smart contract in a different wallet. What it imports, the user will kind of lose this aspect of. It's an actual smart contract that is being managed rather than the private key. Like, the private key should be secondary in this migration and what's happening in this, if you don't want to call it migration, if you want to just call it like Upgrade, like the 7702 delegation is essentially saying, oh, you have some features, but you're still in eoa. Like, don't we just continue as an EOA plus the delegation.
00:41:06.625 - 00:41:27.325, Speaker B: Right. And that has been the goal that we've been trying to achieve since 3074, like four years ago. So I'm not really sure why all of a sudden we're up in arms that that is the solution that we ended up on. Like, we are just trying to give the EOAS execution abstraction, nothing more. If you need more than that, then you should migrate to a smart contract wallet.
00:41:29.875 - 00:41:49.375, Speaker F: All right, well, but there's obviously disadvantages with that. Like, you can't just like migrate. Like, people have assets, they have. It's not like they started their accounts from scratch. And when you migrate to a smart account, you're starting from scratch. Like, so it. In theory it sounds like it's a feasible solution, but in practice it's not.
00:41:51.475 - 00:42:24.435, Speaker B: And that's why we've ended up on 7702, because we went down the conversation, we looked at 7377 and said, you know, client teams, do you want to allow EOs to migrate to smart contract wallets? This seems like something everybody wants. Wallet said, this is what we want. And we looked at it and we realized that there were problems and it wasn't very clear how to make it work nicely. And so we decided not to do that. And until we are able to do it in a nice way, like, I don't think that we can do it at the protocol level. And so the best thing that we can do right now is to let EOs have some extra functionality that brings them closer to parity with smart contract wallets.
00:42:26.245 - 00:42:38.785, Speaker F: But it does seem that, like the only blocker for this proposal is the idea that permits exist today in assets, and because they exist, we should not go full migration.
00:42:39.085 - 00:43:16.355, Speaker B: I mean, I think that there's probably other problems with people using private keys to control the authority of some operation. We just need to look more deeply into what those other things are. But permit is enough of a reason to me not to do it because billions of dollars of assets would be at risk of being spent out from underneath a thought to be smart contract wallet upgrade. And that to me is just, that's a complete non starter. So I, like, I don't really understand why we keep having this conversation when people are just like glossing over the fact that that private key will spend money out from under the smart contract wallet account that was upgraded to.
00:43:21.225 - 00:43:27.285, Speaker F: Then we just ended up halfway. Then I. All right, well, that's my take.
00:43:28.425 - 00:43:40.245, Speaker A: We'll have to disagree on this one. Derek from Wallet Connect, I think, and then Vitalik or Vitalik directly, if direct.
00:43:40.545 - 00:44:05.379, Speaker G: So I was muted. I don't learn. Okay, two points. First on the billions of dollars at risk. Like I might not be technical enough here, but it sounds like I still have to lose my private key for those funds to be at risk. So I think Derek from Zero Dev touched on that. Ultimately the risk still goes down with this proposal.
00:44:05.379 - 00:44:08.379, Speaker G: It doesn't go up, but maybe I missed it.
00:44:08.387 - 00:44:19.009, Speaker B: But we're not trying to fix the risk with eos. We've accepted that eos are the root control of the account. We're not attempting to de risk it with this proposal totally.
00:44:19.177 - 00:44:24.085, Speaker G: But it sounds like we're making something worse. And to me it sounds like nothing's getting worse.
00:44:24.385 - 00:44:32.045, Speaker B: How are we making this worse? We're making it so that EOAs can do execution abstraction. This is like what they've been demanding for years.
00:44:32.505 - 00:45:10.515, Speaker G: The way I understand you arguing is that we are actually creating more risk. But to me it doesn't sound like we are introducing any new attack vectors. You're still not supposed to lose your seed phrase private key. But the other point and that other people brought this up earlier that I want to respond to and Derek touched on this. So the, the intention I think is the same of keeping like making it simple, keeping it simple, stupid for wallets and I guess end users. So everyone has the same intention. So I'll argue that with this ephemeral setting and this is actually easier because.
00:45:10.515 - 00:46:19.245, Speaker G: And the EOA is just an eoa, then with the, with the self destruct, I carry out a transaction on and on chain A, and then temporarily you have the smart account and these features and then I'm back to where I was before and I don't need to worry about the state or things being different from different on different networks basically. So I think I haven't fully thought this through, but just by design that's more state and it just seems more complex to handle, not just for end users, but also for wallets who need to implement this. And then also one wallet might start implementing this and another one doesn't. The end user now wants to migrate from wallet A to wallet B. So my assumption is that it's just harder. And the main intention out of this ephemeral feature was to keep it simple, stupid for wallets. So the intention is the same, but I think we disagree on what's actually simpler for wallets.
00:46:24.065 - 00:46:24.497, Speaker A: Right.
00:46:24.561 - 00:46:41.931, Speaker D: Okay, maybe just so one bigger picture question here is that it feels to me like the chance that we will get consensus on what we think about full migration in time for picture is basically zero.
00:46:42.043 - 00:46:42.627, Speaker E: Right.
00:46:42.771 - 00:47:57.183, Speaker D: And so the other way to one other question to ask is if we do status quo 7702 like what is in the current tip then like that is still compatible with us offering full migration later, right? Yep. Yes. Okay. Right. And so I think like if we, if there's these questions that we can't get consentus around, then I think the thing that we should be optimizing for is not trying to like rush to get consentus on these questions in two weeks, but basically ask the question of like what is the kick the can down the road solution? And for full account migration it feels like to me that the kick the can down the road solution is basically to not enable full migration now. But anything that's. But then like that conversation I think realistically will continue to be open for as long as even some people care about it.
00:47:57.183 - 00:49:12.945, Speaker D: And who knows, like maybe in a few years major applications will figure out how to move away from their dependence on permit to and that whole risk will decrease by a factor of 100 and things might change. But like it does feel like trying to like rush toward everyone being on the same page in the within the next couple of weeks is the wrong approach there. So I guess one other way to frame these questions right, is basically not does 7702 in its current form solve all the problems, but does 7702 in its current form like lock out possible futures that we might want to have? Like are there fit axes that we care about on which it like actually moves us backwards and makes solving the rest of the problems in a future EIP that gets included post spectrum more difficult.
00:49:17.425 - 00:49:37.725, Speaker A: Yep, that sounds like a reasonable approach. So with that said, maybe like client, you have something to add to Vitalik's proposal. Well, proposal to discuss this way.
00:49:39.395 - 00:50:05.575, Speaker B: No, I think it makes sense. I'm not against EOA migration in theory, I'm just against it in 7702 and against it without solving the problems that are being raised from it. So I think it is a good way to frame it that we should think about what are we locking ourselves out of from the future if we do 7702 in the mostly specified current way. And my take is that there's not really much that we're locking out.
00:50:07.855 - 00:50:21.275, Speaker A: Right, Sounds fair. Vitalik, do you still have your hand raised or no agus then I think you were the next one.
00:50:22.295 - 00:51:40.967, Speaker G: Yeah, I just wanted to share a small different perspective because for UA migration we are discussing that there are many dabs and, and tokens and whatnot that won't behave correctly if EOA is migrate. But the problem is that this is a bit of a chicken and an egg program. As long as tokens and DApps don't have the incentive to actually support smart contract wallets and possible UAs migrating to smart contract wallets, as long as they don't need to, they will probably not do it. So the Stillman argument for enable migration is that as soon as we do it, then dapps and contracts need to take explicit action to handle this scenario, otherwise they may be vulnerable to attacks or this problem of the EUA leaking out. So in general I am neutral to either way. But I think it's worth considering the idea of enable migration just as an incentive for everyone in the in the ecosystem to properly have to account for smart contract wallets. Because now every single wallet can become one at any point in time.
00:51:40.967 - 00:51:52.115, Speaker G: So you cannot just say okay, we are not going to support smart contract wallets because EOAs are always there now, EOs can always switch and yeah, you cannot account for that.
00:51:55.855 - 00:51:57.675, Speaker A: Okay, Enket, you can go.
00:52:02.735 - 00:53:04.057, Speaker C: Yeah, I was just going to add. So I think it's not, it's a good idea to separate out the migration concern from this. I still don't get the pushback on migration and for me it seems like a feature that's quite necessary, but I don't think that it's worthwhile to fight this anymore. I do think that the thing to consider is just the side effects of delaying this to different aip. So I think that's the only thing that we're sort of creating path dependency on is there's going to be other ecosystems are going to move faster towards supporting cross chain stuff, scalability, all these different things. And I know that those are features that a lot of smart contract wallet people have been trying to develop for. And so I already know that there's going to be a lot of disappointment from the people I've been developing on this stack for a while to see that, that there's going to be longer timelines to be able to get something like a migration or support for smart contract accounts more natively supported.
00:53:04.057 - 00:53:09.605, Speaker C: So that's just my take on like what is the cost of this?
00:53:27.235 - 00:53:36.215, Speaker A: Anyone wanted to add something? Derek, were you just unmuted? Oh, okay.
00:53:45.475 - 00:53:47.175, Speaker E: All right. Do you want it? Do you want to go?
00:53:48.845 - 00:53:53.425, Speaker G: No, please. I understood Derek, but I think Nicole said Greg.
00:53:55.365 - 00:54:01.865, Speaker A: No, I was saying Derek right before, but it wasn't you? All good, Greg, you can go ahead.
00:54:02.325 - 00:54:35.741, Speaker E: Yeah, I mean, I was going to say something akin to what Vitalik had jumped in on before, but I think the fundamental thing we need to remember here is it took us how long to get 3074 approve, which prompted this whole discussion on getting, which prompted 7702 even becoming into light. And we don't have enough time to actually get anything reasonably heavy implemented for Petra, as Petra is already underwater in.
00:54:35.773 - 00:54:38.117, Speaker G: Terms of like how much shit's getting put in.
00:54:38.301 - 00:54:45.861, Speaker E: I think we just need to be pragmatic and say what are like the best features we can get away with.
00:54:45.933 - 00:54:48.725, Speaker G: Today to give you like a little.
00:54:48.765 - 00:55:34.445, Speaker E: Bit more breathing room and teams more breathing room so that we can slot an advancement in and upgrade that for the next one, for the next hard fork. Because like everybody's already kind of said and we've already hinted at now it's, we're, we're not going to get everything and the more we try to like make this fancy, we're just going to run into further problems. So I mean like, from my point of view, I would say get as slim and lean as we can to pull this off so that at least the EOAs can like get a little bit ahead of the curve and then just like really spend the next like year, six months, eight months to like figure out what is like the best situation we can get for us moving forward.
00:55:39.555 - 00:56:30.495, Speaker A: Yep, there seems to be an agreement around this idea of getting something in something that doesn't block the future, but something that is, yeah, lean and small enough to not run into troubles. I guess we can keep discussing it. Right now we still have 30 minutes on the goal, so we can probably use them to try to start this move and to assess what we can retain in 7702 and what needs to be left out, let's say. So if anyone has an actual take, Eric, maybe.
00:56:31.765 - 00:57:24.715, Speaker F: Yeah, so actually just something small. If we're talking about a bit of more of the pragmatic usage of 7,702, I think something I would love is to see maybe there are some modifications that can be done that would make it cheaper because like the usage of storage, I'm not sure exactly what it would mean because we had so many permutations that I'm not exactly sure what would be the cost of actually using this in a real world situation where you're like on a dap on Uniswap and you now are being asked to deploy the contract and Do a batch transaction. Like, what would the cost be? If there's a way to make the cost cheaper overall with different tricks that can be built into this, I think that's worth looking into. Like, that's just an area. Just making the experience cheaper for users.
00:57:27.735 - 00:57:28.143, Speaker D: Right.
00:57:28.199 - 00:57:36.435, Speaker A: Some more optimization. Greg, do you still have your hand up or is this from the previous intervention?
00:57:37.295 - 00:57:39.023, Speaker E: Sorry, that's from the previous one.
00:57:39.079 - 00:57:40.335, Speaker G: But I mean, like, I will make.
00:57:40.375 - 00:58:21.085, Speaker E: Like one note in regards to, like, features and functionalities. It's like, where 7702 sits is not like where I would dream for things to go, but it gets a job done. And ultimately if, like, we can get away with some of the things that 3074 was going to get us, I think that's good enough as well. Right. Like, to frankly, if we want to under overhaul the like account model, which I think needs to be reconsidered, you know, in general, to get us like a much more rich account system, we're going to need more than like, I don't know when Vitalik proposed it, but like two months, a month ago. Like, we're gonna need more than a month and we're gonna need more than two months. It's gonna take us like a very long time.
00:58:21.085 - 00:58:28.405, Speaker E: So. Yeah. Anyway, I'm done. Keep it simple, keep it clean, and we can work from there.
00:58:30.265 - 00:58:46.405, Speaker A: Okay, so question to the 7702 authors, to you. What would be the key things to get into try. If we were to get something in.
00:58:47.985 - 00:59:04.725, Speaker B: Can we just back up very quickly and say that we're not going to open the conversation about EOA migration again for 7702? Because we kind of mentioned something along those lines, but it wasn't super clear that that was the decision. Can we have a decision point on that?
00:59:07.995 - 00:59:21.775, Speaker A: I think we can. I can't promise though, because obviously some people might try to reopen it again. But for this call, I guess I can vouch for the duration of this call.
00:59:23.595 - 00:59:43.355, Speaker B: Okay. I mean, let's say not just the duration of this call, but for 7702. We're not going to reopen this because it's becoming detrimental to actually shipping 7702. So, yeah, from here on, like, that's not something that we're going to consider accepting for 77 2. And I recommend pushing that as a separate proposal.
00:59:44.255 - 01:00:08.995, Speaker J: I, I agree, I agree with that. I just want to. But I want to make sure that we're being consistent about it. So like, so in the future, if we discuss any form of account migration, we should be equally rigorous about it. And also if it doesn't solve, for example, the permit problem, we should not consider other forms of EOA migration.
01:00:09.975 - 01:00:10.835, Speaker B: Agreed.
01:00:11.855 - 01:00:43.533, Speaker E: Actually disagree. I mean that's out of the scope for this call, but I disagree with this. Like the point that was that three months ago we said there's not enough time before pector for us to rigorously think about the implications. Like we might even decide that the permit concerns are not enough of concern to block migration. It's more that we just need proper time. So if we find us before the next start folk, we again will have only as little time as we have now and we will have made no progress. I would agree, but if we just actually take proper time for that, that would not have to be a block in the future.
01:00:43.629 - 01:00:56.175, Speaker B: But I mean that's the same. Saying the same thing. I think if we do the research and we realize that it's not a problem for some reason, then that's equivalent to coming up with a quote unquote solution like we have to neutralize this problem.
01:00:59.515 - 01:01:26.035, Speaker J: Yeah. And in addition, just since. So since we are not using this form of mitigation, I think we should have, in the security consideration we should have, we should mention what mitigation should be used for the DOS issue, whether it's limiting it to one transaction or to. Or at least highlighting the problem so that clients are aware. Aware of it.
01:01:37.935 - 01:01:42.295, Speaker A: Ansgar, do you. Yeah, yeah, yeah, go ahead.
01:01:42.335 - 01:02:31.505, Speaker E: Yeah. The question, right, that you asked was from the author's point of view, what are the open questions or the questions where we still kind of want to get feedback on or something. And to me, there are three ones that I'm primarily still unsure about. And so those are, number one is the kind of the exact ephemeral nature of the delegation. So basically, as I proposed in the past, one alternative would be that instead of having the code by default active after delegation, and only if you specifically send an ERA transaction that basically overrides that, and then you can still do that in practice. If thinking about it a bit more, it feels like the only way where that would be different. So basically if instead you turn it off by default and you only turn it back on when you send user ops, the only way that would be different is in passive situations.
01:02:31.505 - 01:04:00.183, Speaker E: So if someone interacts with your account while you're away, you did your delegation operations and everything, and then someone wants to interact with your account, should they basically by default interact with the code or with the code less version of Your ua, to me it feels like it seems safer if by default they would interact with the code less version of the ua just because there might be existing token standards or something that basically check that the recipient is in UA or something and then they might fail if that's no longer the case. So I have some bias towards going to only having the implementation active when you explicitly flag it as such in the transaction. But I'm open either way, so that's kind of point one. Topic one is this kind of ephemeral nature. Topic two, I would want to briefly check with people how they think about code accesses. So the ERP right now states that actually if you inquire about the code of the account with xcode copy or things like that, that it actually returns the code of the delegation target, which to me seems very dangerous because it can give people the false understanding that that's a persistent contract that lives at the address and then you make assumptions about it never changing because for example you could analyze it and you don't find a self destruct or whatever people did there and then you basically believe it's safe and then it gets swapped out under you. So my feeling is you should never be able to access the actual code of the delegation target.
01:04:00.183 - 01:05:04.331, Speaker E: So the that's another proposed change. And then the third one, that's a very new one like you off a few days ago, convinced me that actually it might be worth one more time reopening the discussion around INIT code. And that is specifically because in the past INIT code was not really considered because basically the initial versions of 7702 all had were rerunning every single transaction. You wanted to use the smart account. But now that we basically have this persistent delegate delegation target setting, it actually seems reasonable ish to potentially have an INIT code step at the beginning of the transaction where basically you just set up call data that gets set and runs in your account. And the nice thing there is that basically it would more closely mirror the way smart accounts are initialized today, where basically you deploy them and immediately call into them atomically to actually set them up. Otherwise you have this annoying thing where basically you deploy and then you have to be robust against people calling in before you can actually initialize.
01:05:04.331 - 01:05:15.735, Speaker E: You also have to double sign with the same UA key multiple times. It's a bit ugly. So I'm at least curious about inner code. So to me those are the three open questions. Ephemeral behavior Code reads and inner code.
01:05:20.595 - 01:05:24.235, Speaker A: Yes, Ahmad, I think you were first.
01:05:25.615 - 01:05:58.785, Speaker H: Oh yeah. So my opinion about these three points. The first one, I'm not a bit. I don't see this as a problem. I don't think that we need to go ephemeral route. I think it should be an option for the user if they want to go the ephemeral route. But like we mentioned before, Ansgar mentioned that this could lead to a DOS vector if we add a flag where you can make it ephemeral.
01:05:58.785 - 01:06:44.833, Speaker H: I'm not entirely sure if that can be mitigated or not. And for the second point, I think I agree with Ansgar on it. And I think that we can make xcode copy and, sorry, xcode size and xcode hash return an empty account. So like the same thing that they would return for an eoa. And for the last point, if I remember correctly, it was about INIT code. I know that initializing the smart contract would be ugly in the current form, but I think that adding INIT code will just complicate the implementation. And I see that there is no need for it.
01:06:44.833 - 01:06:54.565, Speaker H: But that's just my personal opinion. It is not backed by any scientific or engineering logic. Thank you.
01:06:56.145 - 01:06:59.641, Speaker A: You're welcome. Jor, you can go.
01:06:59.753 - 01:07:41.739, Speaker G: Regarding INIT code, if we don't add INIT code. Yes, I know it's complex. Need to think about gas. Then at the minimum we must add a very strong security consideration to the eap. And that you cannot rely on any existing contract code because any contract like SAFE or others requires setup state setup of storage. And if you rely on such a setup, you cannot bind it to the transaction and you are vulnerable to a front run that someone will use. You create a 7702 signature and someone replaces the setup with something else and.
01:07:41.867 - 01:07:43.535, Speaker F: Grab your account or whatever.
01:07:43.875 - 01:08:01.507, Speaker G: And so you must have a setup that recheck a signature, another signature. So it's a terrible UX because you need to sign twice or you are vulnerable to front run. So we do need to think about how to fit in code data or INIT code.
01:08:01.531 - 01:08:02.707, Speaker F: It's not init code because it's not.
01:08:02.731 - 01:08:07.325, Speaker G: Really constructor, but it is a call data that I had to call at the beginning.
01:08:18.265 - 01:08:25.165, Speaker A: Ensgard, do you want to precise something on what you meant with ephemeral?
01:08:28.145 - 01:09:04.515, Speaker E: Yeah, I think physically, because I realized that was conclusion. The question is just if you send a 7702 transaction that sets your delegation target to something other than zero or other than clearing it. And then of course the next time you send a user up or something, yes, you will Use that code. But what if in between someone sends a transaction that calls into your account? What should happen? In the early version of 7722, the thing would have been that if someone calls into your account, it still behaves like a normal ua. So no code execution. In the current version, there would be code execution. I have some concerns around that because there are some token standards that basically look at.
01:09:04.515 - 01:09:16.935, Speaker E: Okay, that might have some incompatibility there. But yeah, I just basically wanted to ask the question, should a PF like a smart account or like an UA when someone calls into your account other than yourself?
01:09:23.475 - 01:09:25.135, Speaker A: Yep, Ahmed, you can go.
01:09:26.795 - 01:10:20.463, Speaker H: I mean, I was like, this is what I was answering actually. And like what I think is that there is possibility of that happening. Like, for example, let me say I delegate and then I want to make multiple transactions. And like the idea of set code is, was that you can delegate in a. In a transaction and then execute with the Paymaster or the bundler at a later transaction. If we make CIT code only valid with CIT code transactions, if we make the nonce. Like.
01:10:20.463 - 01:10:23.415, Speaker H: Like what prevents someone to code transaction and including it.
01:10:23.495 - 01:10:25.795, Speaker B: We lost you for about 30 seconds.
01:10:27.335 - 01:10:28.599, Speaker A: You're back. Oh, good.
01:10:28.687 - 01:10:32.155, Speaker H: Sorry, sorry. Okay, sorry. My connection here is.
01:10:36.655 - 01:10:37.875, Speaker B: Lost you again.
01:10:40.095 - 01:10:42.795, Speaker A: The statement about the connection was true.
01:10:52.665 - 01:11:08.125, Speaker H: A little bit bad, but I'll try my best. Pumoral thing that Anzac. That you have to increase the nonce and someone like includes that in their 7702 type transaction then that.
01:11:15.875 - 01:11:17.347, Speaker A: Right, Ahmad, you're.
01:11:17.451 - 01:11:27.575, Speaker H: You're playing again your account. Like. Like I'm. I'm not getting how. No, no, no, I'm. I'm saying I'm not seeing how the ephemeral thing m.
01:11:40.245 - 01:12:21.235, Speaker A: All right, Ahmad, you're cutting again. Maybe if you can try to get a better situation with the connection, let us know. Or you can probably reply to nsgaard directly in the chat. Maybe can work too. All right. Ansgar, did we address the three points that you raised earlier?
01:12:24.855 - 01:12:59.805, Speaker E: I'd be curious because the only person talking about INIT code was draw whether. And I think Drawer was basically saying you would also prefer having INIT code. It was more saying if we don't, then indeed we have to be very explicit about the security implications, which I'm not worried about the security implications. As long as we make it clear that, you know, all smart account implementations have to be robust against someone calling into it for the first time that's not actually the owner. That's not a problem. But it does add a bunch of overhead. So I'm curious whether people are at all open to the idea of reopening the INIT code discussion.
01:13:02.505 - 01:13:03.765, Speaker A: Yep, you have.
01:13:05.745 - 01:13:22.609, Speaker J: Yes, so. So as I said before, I do think, I do think it's needed, but if we, if we don't do it just to be more accurate, it means we can't. It's not making existing accounts more robust.
01:13:22.697 - 01:13:23.025, Speaker H: It's.
01:13:23.065 - 01:14:00.829, Speaker J: It will be maintaining. Maintaining two versions of each account implementation. Because for normal SMART contract, you don't want to sign twice. It doesn't make sense to. If you are initializing it in the same transaction, you don't want to sign to sign a configuration twice. But for 7702, you must not have a setup function that doesn't explicitly check the signature. So we will need to be explicit about the security considerations and say that any existing account that has any existing Smart account should not be used with this.
01:14:00.829 - 01:14:12.505, Speaker J: There should be a special version for each account. So I would prefer having INIT code, but if we don't, then at least we should make it very explicit.
01:14:17.175 - 01:14:19.075, Speaker B: I'm fine to make it explicit.
01:14:21.335 - 01:14:25.155, Speaker J: And you're not. And you're not fine with the INIT code. I understand.
01:14:26.175 - 01:14:33.155, Speaker B: I mean, I don't really understand the proposal because you're saying INIT code, but drawer was saying it's actually call data.
01:14:33.855 - 01:14:48.455, Speaker J: Yeah, it's equivalent. I would prefer call data because. I would prefer call data because it just removes some overhead that is not really needed. But INIT code is more consistent with how contracts work.
01:14:49.275 - 01:14:53.255, Speaker B: But I mean, how does the call data get to the contract then? Like, what is the flow?
01:14:54.315 - 01:15:23.965, Speaker J: So the flow is that during, while setting the code, you also. While setting the code, you atomically make a call. So you specify call data and GAS limit for this call and you have a call frame that calls into the code as soon as it is set in the same transaction. And if it reverts, then you do not set the code. You don't need to reveal the entire transaction, but you do not set the code. This, this allows you to automatically run.
01:15:24.005 - 01:15:30.305, Speaker B: The setup for the account, but as a relayer. How do I know how much GAS was used in that to charge the user?
01:15:33.365 - 01:15:37.105, Speaker J: For example, you could use 4337 and then.
01:15:37.845 - 01:15:46.421, Speaker B: But the stuff is frame is outside of like this is a separate call stack. Like you're saying that during authorization it's.
01:15:46.453 - 01:15:52.405, Speaker J: Considered a part of a part of validation. From a 457 perspective, it would be.
01:15:52.505 - 01:16:27.595, Speaker B: A part of the 4337 call stack. Goes through the entire 437 stack. So you can process the transactions for the 437 contract, make the contract initialization, see how much gas was used, charge the user, make the call into the wallet. Charge the user. What you're proposing with 7702 is during the validation of the transaction, as you're setting the code, before you set the code, make a call in and then when that returns, determine if in the kind of validation phase of the transaction if you should set the code for the transaction. That's what you're proposing?
01:16:28.335 - 01:17:11.099, Speaker J: Not exactly, no. It can't run during validation because validation is called by entry point and this one is top level. So it happens before entry point. What I'm saying is that it's considered to be a part of the validation from cost perspective and from the rules perspective it has to obey the same rules because otherwise it can be a dose on the mempool but it's not measured. So it's not measurable by entry point on chain. But that doesn't matter because in 1437 we also have the pre. We also have the pre validation cost.
01:17:11.099 - 01:17:44.105, Speaker J: For example, the 21k that is split among users among accounts in the bundle. So it can be accounted for in both the user. The user knows how much gas it's going to cost and the bundler knows it. You can't know it off chain, but both parties know about it. So you can just add it to the pre verification. The user adds this cost to the pre verification gas and bundlers will only accept it if it really does pay the proper amount.
01:17:45.085 - 01:17:50.785, Speaker B: It just seems like a lot of hoops to jump through when all they need to do is verify a signature from.
01:17:55.285 - 01:18:01.625, Speaker J: There's the trade off of having to maintain having to maintain a separate implementation for the account.
01:18:02.285 - 01:18:14.265, Speaker B: I honestly don't care. Like they can solve this problem very easily. We've put a lot of work in to make it easy for their wallets to continue working. I think having two setup functions for their wallet is like a very reasonable ask for them.
01:18:16.775 - 01:18:22.195, Speaker J: Yeah, since. Okay, I don't have a holes in this race. I'm not a wallet developer, so whatever.
01:18:23.175 - 01:18:26.315, Speaker D: Whatever wallet devs are there wallet developers in the call?
01:18:30.775 - 01:18:43.135, Speaker A: I guess we had Wallet Connect, they left. We have no EVO from Embayer. Maybe you can jump in if you want.
01:18:45.235 - 01:18:50.895, Speaker E: Yeah, I don't really have anything to say. Maintaining two separate flows is absolutely fine for us.
01:18:51.515 - 01:18:54.603, Speaker G: In the name of keeping things simple, not.
01:18:54.699 - 01:18:57.907, Speaker J: Not flows, contracts, implementations of your account.
01:18:57.971 - 01:19:02.595, Speaker E: Yeah, yeah, yeah, yeah, yeah. Yeah, okay, that's fine.
01:19:02.755 - 01:19:10.895, Speaker A: Well, that's at least one opinion drawer. You can, you can take the mic.
01:19:10.975 - 01:19:44.325, Speaker G: As I said, I understand the complexity that adding such initialization call data adds, but the alternative is to add a security consideration to avoid calling any existing contract. For example, you cannot initialize safe. You are not allowed to use any safe based code unless you are using different safe implementation which has a different setup method, which means a different path. It doesn't share the same safe master proxy which allows any setup to run.
01:19:45.545 - 01:19:47.525, Speaker B: Yeah, we can add the security consideration.
01:19:47.865 - 01:20:03.539, Speaker G: Issue into the EA because otherwise someone will say okay, I will create a safe safe. No, you create unsafe. It is impossible to create a safe based on the master copy existing of safe that we'll be able to use. 7702.
01:20:03.707 - 01:20:08.615, Speaker B: I mean yes, we can add this. No problems, add security consideration.
01:20:14.835 - 01:20:18.939, Speaker G: And then find a. I don't know Martin, to address that.
01:20:18.987 - 01:20:19.575, Speaker E: But.
01:20:21.875 - 01:20:23.735, Speaker G: To make sure that we are safe from that.
01:20:29.085 - 01:20:29.493, Speaker D: Right.
01:20:29.549 - 01:21:09.965, Speaker A: We could directly circle back with the safe people on this specific point. We have like eight minutes left, so maybe we can, we can keep discussing this quickly and then have a wrap up over the last five minutes. So this leaves us a few minutes. So anyone, Anyone with a last remark? People want to discuss storage, then yes, we can use those minutes to discuss storage.
01:21:11.905 - 01:21:17.497, Speaker G: Yep. So basically I have put up here regarding that in which basically we sort.
01:21:17.521 - 01:21:20.307, Speaker I: Of map the keys of particular delegation.
01:21:20.371 - 01:21:28.699, Speaker G: To a hashed hash chunk version so that it is also also compliant with the vertical optimization.
01:21:28.787 - 01:21:31.043, Speaker I: So basically chunk of keys get mapped.
01:21:31.099 - 01:21:33.379, Speaker G: To a chunk of keys and if.
01:21:33.387 - 01:21:36.947, Speaker I: You for example, change the delegation then they will map to a different area.
01:21:37.091 - 01:21:45.191, Speaker G: So this basically will solve the problem of conflicts between the storage if there is a delegation change.
01:21:45.263 - 01:21:50.823, Speaker I: And I think it is worthwhile to have it because otherwise we could have.
01:21:50.999 - 01:21:53.759, Speaker G: Some all sort of issues ranging from.
01:21:53.927 - 01:21:59.995, Speaker I: Just a broken UX to maybe even compromising the accounts as well.
01:22:13.425 - 01:22:54.485, Speaker B: Yeah man, I guess jump in. I've responded to this asynchronously a couple times and I don't see a reason to do this for 7702 because it doesn't solve the overall problem that we have and it might possibly restrict the design space of things that we might be able to do in the future to solve this problem for both EOAs and 7702 or sorry, both EOs and smart contract wallets. So I think that one, this is not necessarily a protocol problem, this is more an application layer problem and two, we haven't spent enough time Trying to think about the possible solutions that support both 7702 and the existing smart contract wallets.
01:22:59.385 - 01:23:05.421, Speaker G: I mean, yes, you already mentioned that, but I don't think we should compromise a feature with.
01:23:05.493 - 01:23:06.269, Speaker I: When we simply.
01:23:06.317 - 01:23:21.625, Speaker G: We can sort of address it. And that is basically my problem with the response. And maybe everyone else thinks the same way. That is fine. But I would like to hear what other opinions are out there.
01:23:37.815 - 01:23:45.155, Speaker H: I mean I think that since we have a white list of designations.
01:23:46.135 - 01:23:46.915, Speaker E: Oh.
01:23:56.345 - 01:24:04.805, Speaker A: Okay. All right, no worries. So if anyone wants to jump in.
01:24:05.345 - 01:24:17.085, Speaker D: On tajinders, maybe since we have four minutes left, it might be worth to start a wrap up now and basically yeah. Talk about next steps.
01:24:19.595 - 01:24:45.335, Speaker B: Yeah, I feel like it doesn't seem there's much support for this storage change. We can discuss more offline but in general most people appear to think we should solve this for both 7702 accounts and for smart contract wallets. So we should look more into that as a solution. And personally I think we should look at this as a separate proposal for 7702 because it is both dealing with 7702 and with smart contract wallets.
01:24:50.475 - 01:25:32.795, Speaker D: All right, so in terms of where. Yeah, like, like basically what we learned over the last one and a half hours, does it, does it feel like we have consensus on the idea that like the, the bar for changing things in 7702 at this point is basically. Yeah, find like if we find something about the status quo that's either last minute or insecure or that like actually moves us backwards in a way that's going to be difficult to get out from and if we want more features there's opportunities to do that in separate EIPs.
01:25:38.065 - 01:25:42.685, Speaker A: Yep. This is basically the points we're at now.
01:25:43.585 - 01:25:44.405, Speaker E: Yeah.
01:25:46.025 - 01:26:09.777, Speaker D: And I guess it also feels like in general there's no like no consensus on the idea of exact status quo, but also like low a lot of enthusiasm for reopening boxes and making changes that are like not kind of very contained tweaks.
01:26:09.881 - 01:26:10.725, Speaker E: Does that.
01:26:15.105 - 01:26:19.965, Speaker A: Yep. I think that sums up pretty well the situation.
01:26:21.465 - 01:26:22.361, Speaker E: Okay.
01:26:22.553 - 01:26:43.455, Speaker D: I mean that feels like we're, you know, like we're not quite rubber stamping 7702 at its current form and, but and putting a hash of it on IPFS and setting its Update address to 0. But it's, you know, it's still pretty close, which I guess sounds like progress.
01:26:45.315 - 01:26:51.299, Speaker A: I guess it is. Eric, you want to add something very.
01:26:51.347 - 01:27:19.875, Speaker F: Small, but I think a lot of the anxiety right now is that everybody Feels like the next iteration will be in two years after Verkals and everything. I do wonder if there's some way to add a small amount of space in future forks to maybe do some small iterations once we have something good. Because I think everybody feels like we do it now and then. Nobody touches the OAS for two years at least.
01:27:24.185 - 01:27:49.165, Speaker A: I don't think we can commit on next forks like this. Maybe, I don't know, like client. Can you give us some ideas of the next forks if there is some room? I don't know if you have a vision on this, maybe you just don't.
01:27:49.585 - 01:28:13.005, Speaker B: I don't have a crystal ball unfortunately. But if things are important, things are important and we will try to make them happen. So I think we just have to try and do the best thing we can do today. And seems like we're coming closer to that thing. And keep in mind that that's going to be the process for the future is doing the most important things.
01:28:14.595 - 01:28:26.535, Speaker H: One last point that Ansgar pointed out that I'm not sure if anyone has time to discuss is the code reads. Can we touch on that or is it too late now?
01:28:32.355 - 01:28:41.425, Speaker A: I can stay for a few minutes. No worries. So yes, you can go on this if you want to.
01:28:42.045 - 01:29:30.555, Speaker H: So in EOF we usually try to avoid any code reads. So anything like exit code copy, exit code hash, exit code size and so basically code introspection. And here it does not make any sense to allow code introspection into the EOA's delegated account. My personal opinion would be to just have these specific opcodes return the normal thing that they would usually return for an eoa. And we can simply add that to the aip. I want to listen from Light client and other client implementers on this.
01:29:34.385 - 01:30:05.605, Speaker J: One argument against this is that there are already contracts that they make an effort deliberately to not to communicate with anything related to account abstraction, but to only serve EOAs and without trying to discourage this behavior. So making it easy to identify that the contract you're interacting with is still an eoa. It goes against this direction. So I understand why it's easier for clients.
01:30:05.765 - 01:30:06.325, Speaker E: Yeah.
01:30:06.445 - 01:30:19.549, Speaker H: Okay. So we can keep this enabled for non eof, but in EOF this is disabled for everything. So we can disable it also for 7700. Okay.
01:30:19.597 - 01:30:22.105, Speaker J: Yeah, for EOF it should be the same.
01:30:23.325 - 01:30:35.555, Speaker H: Okay, okay, this makes sense to me. This makes sense. Okay, I understand the reasoning. Ansgar, do you agree with this approach?
01:30:36.175 - 01:31:00.405, Speaker E: Well, I'm just. I just think in a way the Chain in the can't spec, the chain is actively lying. So basically you're asking, hey, what is, what is the code in this account, in this contract? Because you didn't even know that's an account. And then basically the chain is telling you, here's this code. And you look through the code and it looks all immutable. And you're like, okay, I'm trusting this. It has no indication whatsoever that it would have different behavior.
01:31:00.405 - 01:31:40.449, Speaker E: And then boom, next time you actually interact with it, it has different code in the same place. And that is invariant. That I think is like, I feel like A, I would be very hesitant to ever break it, and B, I would. To me, it feels like almost insane to break it without at least a clear analysis. Like, who right now uses these kind of patterns? What potential security implications could this have? This is like a Pandora's box that I really don't understand why the can spec is opening. And so I kind of, I wrote in chat the four options that I see, and out of all the four, all the other three I would be okay with. Literally the only one that I think is the one that we should really not do is the one the Khan spec does, which is actually just.
01:31:40.449 - 01:31:41.205, Speaker E: Yeah.
01:31:42.835 - 01:32:29.515, Speaker J: How is it different from proxies? I mean, assuming that. Assuming I'm not aware of any contract that does this, but if someone does, they would have to get the code and statically analyze it on chain to see that there is no delegate call. Because if there's a delegate call, if it's a proxy, then they have no way of knowing whether it's mutable or immutable, whether it could have different implementation. So I doubt anyone uses this pattern. But I do know of many contracts that use the other pattern of trying to only communicate, only transact with eos due to proxies. Do you see anyone, anyone using this method?
01:32:31.255 - 01:33:07.777, Speaker E: Again, I just, it seems just very. It's very unpleasant that we have to kind of now make these assumptions. You might be right. I feel like I remember from three, four years ago when maybe in the context of 3074 or something that we did look at that. And I feel like I remember seeing a pattern like that that specifically traced and looked at, basically followed through recursively, delegation, targets and everything or something like that or some taint analysis. I'm not sure, maybe this was not actually unchained though. All I'm saying is conceptually, like again, it probably, probably it's not actually breaking anything, but conceptually it just really seems like wrong thing.
01:33:07.777 - 01:33:13.625, Speaker E: To do. But I don't know, maybe this is just me being all caught up on this and maybe we can just move on.
01:33:13.665 - 01:33:39.225, Speaker J: No, you are right that it would be wise to get an analysis for this to see how it's actually being used. I mean, we know how it's being used against account obstruction, but we don't know whether it also has positive uses. So it will do this kind of analysis of a static analysis on delegate call. So we should probably spend some time looking into this.
01:33:45.725 - 01:33:49.345, Speaker A: All right, sounds good.
01:33:50.085 - 01:33:50.825, Speaker E: Sure.
01:33:52.405 - 01:34:25.701, Speaker G: Yeah. One more observation regarding initialization code. It's not having two different code. It means forking the entire tree of. Think of a modular accounts that now try to get some traction. You cannot use any of them in the context of 7702. You only allowed to use monolithic accounts that require setup that uses a signature, the root contract that you are trying to use.
01:34:25.701 - 01:34:39.701, Speaker G: I'm trying to think whether you ever going you will be able to change something else. And I don't see a way. Because if there is a way to get away and modify storage without a signature, then it could be called you.
01:34:39.733 - 01:35:00.397, Speaker B: Absolutely can modify it. It's just this first setup time. You have to set a master controller for the account. And the only way you can authorize that is with the signature. Otherwise like you said, you can be front run. So once you have set that, then it's just behaving like a smart contract wallet and you can have them set whatever.
01:35:00.581 - 01:35:07.425, Speaker G: Yeah, but if that code has a method that can do check whatever, but.
01:35:09.005 - 01:35:25.601, Speaker J: Can do it means that basically. Yeah, it means that we need to apply this recursive recursively also for modules in the case of modular accounts. So yes, it applies not only to the core account, but to any model. Basically creates a separate ecosystem.
01:35:25.753 - 01:35:35.641, Speaker G: No, no, it's not. I think that the models are unaffected. What is affected is the core model is the core contract. You are unable to use the core contract and do.
01:35:35.753 - 01:35:39.409, Speaker J: Yeah, so that's just an account that's just like any other account.
01:35:39.577 - 01:35:39.905, Speaker D: Yeah.
01:35:39.945 - 01:35:51.371, Speaker G: The core contract is not allowed ever to have set up without an extra signature because if it has that method, it could have been called as a first transaction.
01:35:51.483 - 01:35:59.615, Speaker J: Yeah, that's what we said. Every account, whether it's modular or not, will have to maintain two implementations. That's. Yeah, I think that's pretty much a given.
01:36:04.555 - 01:36:05.415, Speaker F: Okay.
01:36:06.995 - 01:36:11.829, Speaker A: Yep. Frank, you.
01:36:11.957 - 01:36:52.515, Speaker B: Yes. So quickly going back to the code copy thing because I don't know if this was mentioned, but there's a recently proposed change to EOF to add just a little bit of code introspection back where the code size and potentially the code # that is sorry xcode size and xcode hash opcodes would be re enabled in eof. So I think the decision about what to do with respect to sort of whether to pass through the delegation can be ignored because of that. Like I think it's still a discussion to be had and make a decision consciously.
01:36:58.615 - 01:36:59.421, Speaker D: Yep.
01:36:59.583 - 01:37:51.025, Speaker A: Per point. I guess we could. We could stay a bit more but we're already over the limit of the call. We can take those discussions offline. I guess I will be writing a resume because we discussed a lot of things and yeah I guess we. We agree with at least some things around 7702. We can try to keep it as small as possible to have something in Petra and remove anything that would block improvement in the future for era migrations and future improvements.
01:37:51.025 - 01:38:31.495, Speaker A: So this is for now the status quo. And yeah, thanks for being here today and let's discuss more offline and I'll be writing a resume pretty quick, pretty quickly. Probably tomorrow it will be available drawer. Did you have something or was it is your hand raised from the last intervention? Nope. All good. Then I guess that's it. Thanks for coming today.
01:38:31.495 - 01:38:32.311, Speaker A: See you soon.
01:38:32.423 - 01:38:33.515, Speaker B: Thanks Nico.
01:38:34.215 - 01:38:34.951, Speaker E: Thank you.
01:38:35.063 - 01:38:35.503, Speaker J: Bye.
01:38:35.599 - 01:38:35.895, Speaker H: Thank you.
