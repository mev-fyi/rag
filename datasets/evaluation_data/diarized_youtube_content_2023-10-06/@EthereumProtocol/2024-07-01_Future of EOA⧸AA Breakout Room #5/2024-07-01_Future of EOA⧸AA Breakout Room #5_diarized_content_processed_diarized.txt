00:00:02.160 - 00:00:41.655, Speaker A: All right, let's get started. So thanks for joining. Today we will be discussing the Last update to 7702. So it's basically add delegation designation. You probably have already checked the files. So, yeah, without further introduction, I can give you the mic if you have some comments around this one. I've seen some comments on East Magicians from Kevin.
00:00:41.655 - 00:01:10.611, Speaker A: So Kevin, if it's you, I think it's you, maybe you want to start and then we can take it from there. And Scar also, if you're available to discuss, would be very nice, I think. I don't know if Matt will be joining, but we'll see. All right, I see the thumbs up. Okay, let's go. Kevin, if you. If you want to take the mic, I give you the floor.
00:01:10.763 - 00:01:27.977, Speaker B: Yeah. So my proposal was not really oh, for information. That's. That's a Ledger proposal. It's just not mine. But yeah, my proposal is not really about the latest version of the eap. The proposal has been made when we were still discussing the previous one.
00:01:27.977 - 00:03:04.055, Speaker B: But it's basically serving the same purpose, I guess, of trying to find revocability in a better way, I guess, than just having the nouns and creating this max nouns or nouns option, which is impractical for in terms of UX and everything. But yeah, the new version and Badger's proposal is basically going into the same direction, I guess, by trying to enforce having a single implementation at a time and not trying to basically trying to store it somewhere. Our proposal was to store it in a very specific storage slot, mimicking what the proxies are doing most of the time with the some already known ERCs. And I guess the proposal is just moving that directly into the contract code or the code of the address and into the account state. So yeah, it's not really any different, I guess, except that migration later on might be more difficult or more difficult to handle because we will already have code. So it's not like Drawer said, it's not temporary anymore. It's really permanent now.
00:03:04.055 - 00:03:28.385, Speaker B: Yeah. I'm curious to know if anybody is against going into something that is more permanent. I think that was one of the first thing that was actually causing issues trying to go into something that is more permanent when we wanted to have a bit more space, I guess.
00:03:30.405 - 00:03:30.741, Speaker A: To.
00:03:30.773 - 00:03:51.465, Speaker B: Try to do that. And it's not really. I don't really have any question, I guess specifically on the spec. It's more like I confirmed that this is the kind of direction that Ledger could be able to handle way more than this multiple Authorization at the time thingy, that was really difficult, I guess.
00:03:54.165 - 00:04:10.135, Speaker A: All right, thanks for your comments. Maybe I see Sam Wilson. Maybe if he's around, he wants to answer or oh, I see Matt joined or Ansgar. Any one of you just raise the hand, take the mic.
00:04:20.195 - 00:05:11.163, Speaker C: Yeah, sure. Hey. Unfortunately I wasn't really super, super involved over the last two weeks around 7:72, I had a look at this proposed change. Though I think directionally it's kind of the right direction to explore in basically storing the delegation target. I think conceptually it is somewhat cleaner just because it is more reassuring for users because at any given moment in time you only have this one dedication target. So it is obvious you can always revoke by basically overriding it. So I think in principle I like it.
00:05:11.163 - 00:06:42.833, Speaker C: The one thing that I was wondering, so when that idea first came out like couple of weeks ago, just as a rough idea, I was picturing more something that basically that was not in itself immediately like lasting beyond the scope of the transaction, right? So basically the old version of 7702, you set the delegation target only for the scope of the transaction, right? And then at the end of the transaction that's cleared with this new version, you store it and then it is valid and active from then on out, right? Until you change it. And then I am very uncertain whether that is the right approach and I'd actually be curious to have some feedback from people here. So the one alternative I've been thinking about, and it also has its own downsides, but the alternative I've been thinking about is basically do the same thing, store it in the code field, the delegation target, but it is still only active during the scope of the transaction where it was set. And then afterwards it's still sitting there, but it is only sitting there as basically the only currently valid delegation option. It doesn't mean it is active. So outside of the scope of the transaction, if you check the account code, you would be told that there is no code and if you call into it, indeed nothing happens. And then basically there would be two different options how you could actually activate the delegation target.
00:06:42.833 - 00:07:49.761, Speaker C: So one would always be as part of whenever you're in a seven, seven or two transaction, if you actually change the delegation target, right, with basically nonsense signature and everything, then doing that new transaction, doing that transaction, it would be active. But then also you could instead basically, I don't know, add another field to the 7702 transaction or something where you basically just listen, just give a list of addresses completely without any Authentication So there's no signatures, no nothing, no nonsense. And for this list of addresses that the transaction center specifies, basically you just within the scope of the transaction, you activate the delegation target if set again. So basically it would basically make this delegation not permanently active, but only active manually to be activated by the transaction, by every individual transaction center. I personally think I like this a bit more. Although of course it comes with its own downsides and I'd be curious how people think about this kind of. So yeah, so with.
00:07:49.793 - 00:07:58.765, Speaker D: With that approach, doesn't that mean the transaction originator gets to decide whether your account has code in it or not and not the actual owner of the account?
00:07:59.555 - 00:08:02.695, Speaker C: This was already true in 7702 before this change.
00:08:03.955 - 00:08:05.015, Speaker D: Yeah, I suppose.
00:08:05.875 - 00:08:48.175, Speaker C: So basically it would recreate this behavior of non revocable 7702 signatures that basically would have been floating around forever and anyone could have ever just decided to pick it up and use it for that transaction to temporarily give you code. The only difference now is that you can prevent anyone from doing this in the future by just basically unsetting or overwriting with a different one the field in your transaction. So it's not basically the change would only be in behavior that now for user, it's not unpredictable whether that can happen. But you can always just look, do I have the delegation target set currently? And if so that can happen to me and if I don't want this I can always just unset it. But yeah.
00:08:54.125 - 00:09:05.865, Speaker A: Yeah, interesting. Maybe Matt, you want to say something about it? This was your call. Yep, go ahead.
00:09:06.365 - 00:09:13.945, Speaker E: Sorry, I'm. I'm running late this morning. I didn't see what the first. I kind of only came in as Unskar was talking there.
00:09:15.485 - 00:09:48.725, Speaker A: No worries, you didn't miss much. So the first question. Well comment came from Kevin from Ledger. He explained that they didn't really like the permanent approach that was made during this update. And Ansgar explained another alternative to this. So maybe Anskar, if you can re explain quickly for Matt.
00:09:50.385 - 00:10:28.165, Speaker C: Yeah, sure. And this is just basically a question. A question that I was having for people here is I'm a bit uncertain. This proposed change by Matt has this new property that once you set the delegation target it is active even beyond the scope of the transaction where it was set. So basically you set it and then it is in the account and then from that moment onwards basically your account just has that code basically for all intents and purposes until you change the delegation target with another 772 transaction. And this might be Fine. It might be that we decide that this is actually behavior we want.
00:10:28.165 - 00:10:58.209, Speaker C: I was thinking about whether there's any value in the alternative where the delegation still ends at the end of the transaction where it was initially set. You still store the information though. So basically from that moment on, basically it is in the account code just as a. If it is ever. If delegation is ever activated for this account, this is the only allowed delegation target. Basically, you can change it. You can change it with another 7702 signature that basically comes with a nonce and is physically revocable in that sense and everything.
00:10:58.209 - 00:11:32.575, Speaker C: But as long as it's not changed, as long as it's sitting in the account, it is not active by default within normal transactions. But any 7702 sender can basically add just in an extra field or so just the. Just the address itself doesn't have to have any signature or anything attached to it. And if they do so basically, if they specify, hey, please add this account to the list of accounts that are active within the scope of my transaction, you basically activate delegation again temporarily. And I'm just wondering, do people think there would be any value in that other alternative approach?
00:11:33.395 - 00:12:35.589, Speaker E: Yeah, I mean, let me. I guess I can just say something quickly about the proposal. To me, what we're doing is we're sort of leaning into what actually happens when you make a permanent delegation under 3074, under 7702, something without revocation. And yes, the way that these things are manifesting in the new 7702 proposal is very different because before you had to bring the authorization on chain every single time that you wanted something to happen. But if the. There wasn't revocation, which again is like an important thing to have some of the use cases that we want, like, you know, social recovery or delegating to more hot wallets, then you have kind of given this permanent delegation. And it's really just an implementation detail whether the user needs to send that authorization on chain that can't be revoked, or if something is stored in the account that says at some point in the past this was authorized, and it will continue to be authorized into the future until the user revokes it.
00:12:35.589 - 00:13:10.705, Speaker E: The nice thing about the new 7702 proposal is that it finally addresses in what I think is a much nicer way how to deal with the revocation story. And what I mean by that is that now the authorization is only valid one time for the specific nonce. The nonce is required. And that's okay. Because you are setting the authorization account. So you consume an authorization, it's no longer valid. The account is delegated to a smart contract wallet for the, you know, in perpetuity until they change it.
00:13:10.705 - 00:13:59.459, Speaker E: And this is really achieving the things that we were hoping to achieve with 77 2, which is creating an experience that is like using a smart contract wallet. And I think that like what you're proposing, anskara and what 7702 sort of used to do, 3074 used to do, always had this difference between what smart contract wallets are today and what they were under 7 cents, where you sort of have these like kind of ephemeral authorizations. And we had a way of them being irrevocable by just signing something without a nonce. And then we had some optional revocation. But now that we can write it into the account, this feels like the best thing to do. And now it's kind of like I deploy a smart contract wallet to my account, but I haven't given up on the ability to originate transactions from my eoa. This sort of gives us like the best of both worlds in that sense.
00:13:59.459 - 00:14:12.215, Speaker E: And it sort of lets people slowly try and migrate. Not just people, lets people and developers slowly try and migrate to smart accounts. That's the summary, I guess.
00:14:16.995 - 00:14:21.135, Speaker A: Thanks, Eric. You have your hand raised.
00:14:21.435 - 00:15:19.961, Speaker F: Yeah, so just, I think actually connecting to what Matt said just in his last sentence, I think in order to actually let people try it out and slowly get into this process, you don't do that by giving them permanent and only permanent delegation scheme. Because like it isn't permanent, it's permanent. So I'll, I'll put it differently, it delegates for as long as the account, as long as you don't do another action. Right. So basically from that point forward, let's say you have $1 million in your account. From that point, those million dollars are dependent on the safety of the contract. If there's a new hack found two years from now, if you didn't do something there, change something, that money is gone, versus in a different situation where you do have the option.
00:15:19.961 - 00:15:35.565, Speaker F: I'm not against the option of permanent approval. I think it's useful. But it's useful in a process where in some situations people will prefer to initially have one off delegations.
00:15:35.725 - 00:16:02.955, Speaker E: And it's, you can still emulate this behavior. All you have to do is have a revocation piece of logic at the very beginning. So you set the flag for the first time that this code has been called. They can never be Called again. Yes, it still exists in your account, but now none of the rest of the logic is going to execute. And if you want to update and use a new piece of code in that account, you would have to sign a new delegation.
00:16:04.295 - 00:16:08.835, Speaker F: Right, but that's like. So that's good as long as that code is not broken.
00:16:09.175 - 00:16:16.087, Speaker E: I mean if we can't write a revocation flag that's not broken, then we need to revisit what are we doing here.
00:16:16.271 - 00:16:30.075, Speaker F: No, but like, you know, there's a lot of different ways that things get broken. So like what I think makes sense in that like again in the approach towards and I'm just thinking about this from just to explain the angle.
00:16:31.815 - 00:16:32.271, Speaker C: Like.
00:16:32.343 - 00:17:19.967, Speaker F: Our clients, we make the decision to opt end users into this situation. So if you're suddenly with the decision, do I opt 100,000 users into this experience? Your risk management is very harsh. You really have to think about anything you enable. And it's much easier to enable something for the duration of a transaction than enabling something until otherwise. And by the way, this I think a good similarity to think about is bridging. So there's a lot of people that are willing to use a bridge to go between chains, but they will not stay on synthetic assets that have permanent bridge risk associate to them. And I think this is similar but instead of bridge risk with smart contract risk.
00:17:19.967 - 00:17:55.475, Speaker F: So as a user you can decide and here we're kind of taking that decision away unless if you do another transaction. And I actually think that like there should be a pretty simple solution where we say you can decide when you do 7702. Do you want this to be a one time thing and not have smart contract risk regarding how simple it is or you want to opt in for a slicker experience over time where you delegate until otherwise dead. It should be quite similar. And I don't see these side, I don't see the downsides to having this plan.
00:17:55.935 - 00:18:41.655, Speaker E: I mean I agree with you, I see what you're saying. But ultimately we haven't come up with a mechanism that gives us the best of having permanent delegations, which is very important and aligns us more with what smart contract wallets look like today and will look like in the future. And having this temporary execution and like ultimately this temporary delegation mechanism is something that does not bring us closer to smart contract wallets. So I just don't really see much of a reason to have it. Like yes, we might get some users and we might have some organizations who feel that the risk profile that is better. But I don't think that this like moves us closer to the end goal that we're trying to get, which is getting everyone to smart contract wallets one day.
00:18:42.065 - 00:19:29.905, Speaker F: So I actually think it is the most important thing in getting us closer to that. And I'll explain right now there's separate processes between like EOA wallets and smart contract wallets as to how do you interact with users in a dap and just having the ability with a low amount of risk for an EOA account to support the, you know, the. I don't remember all of the years, the EIPs and ERCs that are happening right now for, for batching for gasless. So the fact that both ecosystems will be able to play in this playground and do this together and push the DAPP ecosystem in the same direction without having to do a big risk change.
00:19:30.245 - 00:19:31.877, Speaker E: I mean, you're preaching to the choir here.
00:19:31.941 - 00:19:33.077, Speaker F: It's very meaningful.
00:19:33.261 - 00:19:53.395, Speaker E: I have been saying this for like three, four years. I agree. But I don't think that the risk profile is that different between delegating to a smart contract wallet, especially something like safe, which has tens of billions, hundreds of billions of assets locked. Like are. You're basically saying that you don't trust a safe.
00:19:53.775 - 00:20:30.697, Speaker F: So with. So for example, for me it would be very different and this is even on the personal level between SAFE and SAFE plus model. Like any module that you have on safe, because most of them have not been widely used, have not had traction, there's very little modularity built on SAFE that has any of the same kind of lindy effects as SAFE itself has. Right. But then I'm also thinking about other smart contracts that don't have that. So you know, it's like this risk difference is actually very big. And I think like this is kind of like, I think the main point, it is very big.
00:20:30.697 - 00:21:23.875, Speaker F: So having this for a single transaction puts you in so much less risk than anything else For a person that is concerned about that risk. I'm sure not everybody is. So doing this, having this option is actually going to be a huge driver in adoption and in collaboration in making those things happen. I think it's a huge unlock. That's why I'm actually like, I'm very vocal about it because I think it's huge for the ecosystem to be able to do this. And as far, I think the solution that you already brought just misses one flag of saying at the end, I'm not sure what's the best approach. Either delete the code or just have One bit that says, I know I have the address here, but actually it's not delegated anymore or something like that, you know, like you guys have a lot of options for solving this, but I think it's going to be very important.
00:21:23.875 - 00:21:44.625, Speaker F: And with that change, this new suggestion is actually gives you kind of both the first step, which is temporary delegation, and the second step, which is long term delegation. And then the third step is going to be possibly a forever delegation. But that's like you actually get three steps instead of two and the difference is very big.
00:21:49.405 - 00:21:57.905, Speaker A: Interesting. I see a lot of chat going on. Ansgar, you want to take the mic for a minute?
00:21:58.205 - 00:22:45.779, Speaker C: Yeah. I just wanted to briefly point out one point because in principle I actually like the idea of adding actually directly in the protocol, adding a one time use flag of sorts that basically says, hey, do the thing, but at the end of the transaction just don't write it at all to the, to the code. Right. You basically just, it's just ephemeral like that. The one problem that I think is actually hard to solve with this is the problem of extracting and front running that signature. So if you send it via the public mempool, anyone can just basically see that just extract that sent their own 7702 transaction that basically uses your signature and then because it doesn't actually commit to what transaction it would have to be used within. Right.
00:22:45.779 - 00:23:39.405, Speaker C: That's kind of one of those fundamental 7002 properties. And so then by the time that that actual transaction is run, it's no longer valid and can't be used anymore. Right. And I assume in most use cases that wouldn't actually necessarily be a vulnerability because just because it's active doing that other transaction, it's not like you can do anything with it, but you can basically just grief the user because they can't actually make use of it. So I'm. I am wondering if there's good ways to basically mitigate this, because otherwise I don't really see how basically in protocol like this, in protocol one time use could work. And of course with mat proposed idea of basically just leaving it up to the contract logic, at least that would have the upside that it could be conditional.
00:23:39.405 - 00:23:57.905, Speaker C: So basically you could see that you don't actually consume it within an authorized context. So I don't know. I'm just wondering whether there's any good way to make the in protocol one time use work in an unfoldable way. I'm not sure.
00:24:06.495 - 00:24:52.725, Speaker E: Ultimately we just need to buckle down and implement smart contract wallets or have a way of integrating with existing smart contract wallets in ways that are safe or that people consider not to be risky. Because really the whole argument is hinging on the fact that there's a different risk profile between using this permanent delegation and using some temporary delegation. But in theory we could implement a piece of code that is provably secure that we could permanently delegate to. Of course doing this is hard and one might say that SAFE has already done this. But if we have this piece of code that doesn't have risk, then there is no point in having the temporary delegation. The only point of having a temporary delegation is to develop some flows which are not easily replicatable within the smart contract wallet ecosystem.
00:24:59.555 - 00:25:06.215, Speaker A: Interesting take. Maybe we can have some words from SAFE or.
00:25:10.395 - 00:26:08.965, Speaker G: I mean I think in general for us when we are biased, right? Like first of all because we are a smart contract wallet. And I think as we all realize by now that this new version is going a little bit more in the direction of the full migration pass, which I think for existing smart contract wallets is quite nice to have. I still understand some of the reasons also from ARIC around having it as a one time use only. It's still interesting. For me the biggest question would be considering the time, considering the state that we are in, what is the most realistic version to push into a hard fork. I think we will never get to this version where all of us really say awesome, that is exactly what we wanted, all of us, right? Like so this is. And then whatever we add and whatever trade off we make, we have to think okay, what is the complexity here? We want to ship it in definite two by now.
00:26:08.965 - 00:27:12.885, Speaker G: I think definite one is not even on the list anymore right now. So for me personally and also for safe, I think this is the biggest question, right? Like okay, do we like as also like client said in the shed, right? Like is it enough that we can implement most of these one time usage in the contract and we have to then trust it and then we in the beginning potentially have to have stronger white list, white listing or similar to make sure that only contracts where we know that this revocation works is in there. Or do we want to go back completely to the initial version where we like before this proposal, right? Like because we said okay, this one is the one that was accept indefinite one. But there the challenge was I think that actually there were a lot more questions around this revocability than we have right now. I think from a security standpoint the new proposal is I think has a Way wider adopt like support. And I would. Yeah.
00:27:12.885 - 00:27:36.511, Speaker G: So since we, you know, we care about security and revocation is important, there seems a good way to go from us. But ultimately I think both of them are fine for us. Both versions. Yes. And I agree with what Anska is writing in the chat. Like, so we really have to keep the time in the back of our head. Right.
00:27:36.511 - 00:27:53.485, Speaker G: Like, it's not that we can take another month to really iterate over the specs. We basically should within the next week align on the specs so that we can in the next all core dev meetings say, okay, this is a spec that we want to align on and what we want to finalize.
00:27:54.745 - 00:28:19.215, Speaker A: Absolutely. Good point. Indeed. It has been a discussion topic for the last month or so and hard fork is coming, the devnets are already ongoing. So yeah, this is going to be very important to solve in the next days or so. Ahmad, I think you raised your hand first.
00:28:22.475 - 00:28:23.295, Speaker F: Yep.
00:28:23.875 - 00:29:39.731, Speaker H: So I have one. One suggestion here is that to preserve the old 772 behavior, we can simply add a flag boolean. It's one bit false or true. If this authorization is temporary, meaning it will be reverted at the end of or delegation. Sorry, it's going to be like reverted at the end of the transaction or not. The nice thing about this is that once it consumes the nonce, it's as if we had used the older 7702 implementation, which is currently the EIP, the current EIP before light clients PR. But we gain the implementation simplicity and from the client perspective, from the core dev team perspective, the Light client's PR is way better in the implementation perspective, whereas this would preserve the same kind of behavior.
00:29:39.731 - 00:30:28.891, Speaker H: You have the temporary only for one transaction kind of authorization, it's still there. You have the non temporary and then even the non temporary you can still revoke it by pushing another transaction to change the designation. So like this satisfies all like concerns. Whoever wants to designate once and for all can do it. Whoever wants to do it for a single transaction can do it. Whoever wants the option to even change his designation at a later time can also do it. So we have a path forward for all three with the better implementation of the eip.
00:30:28.891 - 00:30:43.255, Speaker H: Also, as I see, this designation approach is from the corp dev and execution client perspective as a way better approach than what the EIP currently is.
00:30:45.205 - 00:30:55.105, Speaker A: Right. That sounds ideal indeed. But there seems to be a debate around a DOS issue. And Scar, can you extend on this?
00:30:59.885 - 00:31:48.341, Speaker C: Sure, yeah. I mean to summarize again, so basically the problem I see is just that if you send such a one time use signature basically as part of, I don't know, a user op or so in the 437 mempool and then some bundler wants to pick it up or something while it is in the public mempool anyone could basically just pick it up without your user up. So Basically just send a 7, 7 or 2 transaction that uses signature and then within that transaction doesn't actually make use of your account being there just basically consumes this in sharp and that way basically not actually hurting you but just griefing you so that then by the time the banda tries to add it or so it's no longer valid. That's my concern. That's not why I had my hand raised.
00:31:48.413 - 00:31:54.465, Speaker A: But yeah, sure, go ahead for or yeah, maybe you want to reply to this?
00:31:55.485 - 00:32:02.385, Speaker H: No, I just want a better understanding. Like it would just invalidate the transaction. That's it.
00:32:02.805 - 00:32:29.165, Speaker C: Well, it would basically just invalid like so by the time, I don't know, the bandlasser tries to include it, it basically it would be like hey, you know that signature denounce is no longer valid because it was already used. So it would just with it like it would just be a no op in that sense. Like it would. It would just not activate and that user would be skipped in the bundle. So basically the user could not actually make use of the one time account.
00:32:31.905 - 00:32:34.233, Speaker A: And you had another point or.
00:32:34.329 - 00:32:49.155, Speaker H: Yeah, right. I mean so if someone uses the authorization for one time. Yeah, then yeah, that would invalidate that transaction. I got you. Okay, thank you. Thank you. I will think about it.
00:32:49.155 - 00:32:49.975, Speaker H: Thank you.
00:32:53.035 - 00:33:15.659, Speaker C: Good. Yeah, but otherwise I agree. I think otherwise it would be really desirable. So maybe we can find a way. The other point I just wanted to make is. Yes. In terms of timing, as I was saying in chat, I do think there really is temperature to some extent at the same time just for context setting like the upcoming pectoral fork, it is very unusual and that's important to be aware of.
00:33:15.659 - 00:34:04.805, Speaker C: In terms of just its size it's very unprecedented. We usually have small 3, 4, 5, 6 ERP forks. I think this one has, I don't know, well above 10, 10 to 20, I don't know, EAPs and several really, really big ones. So I think realistically, of course things can always go perfectly and actually we are rolling it out in a couple of months and then really basically the 7702 spec should be final very soon otherwise it wouldn't make it. But realistically most likely it'll have several months of delay so there's still a little bit of room to figure out details of 7702. What could happen though is that it ends up being split into two with the ERPs that are basically already done and also implemented being shipped out relatively soon. And so they are really then and then the rest basically in a follow up for a couple months later.
00:34:04.805 - 00:34:58.249, Speaker C: And if that were to happen then basically we have to just basically decide do we want to really rush to finalization of the AP and then try to make it into that first part if it exists or take the extra few months to make sure that this has the best shape possible. I would personally do the second but you know up for us this will like over the next few or devs. I think this will shape up a bit more clearly. In the meantime I do think there's a few decisions we have to make very soon. People already mentioned the devnets. I think we should ideally on this call decide what recommendation to give for codefs in terms of what to ship on the next upcoming devnets. So like so basically should do we want this proposed change by MAT to be the one that is the next one implemented? Yes or no.
00:34:58.249 - 00:35:36.199, Speaker C: And if so I think there's still some details to be figured out. I think some people had concerns like I think the cost of the 7702 Signature should be increased to account for this permanent storage change. And then also I personally for example wonder whether we actually want to make the existence of that delegation transparent or not. So basically whether reading the code should actually show you that there's some UF code in there. I think UF has restrictions anyway where you can't actually see the specific UF code, so you wouldn't be able to see the delegation target. You just see that there is UF code in there. So I think basically we.
00:35:36.199 - 00:35:45.355, Speaker C: Yeah, so I think for now we should focus on maybe on that decision like what should be the spec that we want people to use for the upcoming devnets.
00:35:49.785 - 00:35:55.577, Speaker A: Yep, good points. Ahmed, you have something to raise about this?
00:35:55.761 - 00:36:40.775, Speaker H: Yeah. So I have what two points. I'll first address one of Asgard's concerns about introspection. So code introspection is very, very like UF tries as much as it can to disable code introspection and like remove the ability to know if this account is what or gas introspection for that matter. And that's one of the goals for EOF to remove this for various reasons. Right. But so yeah, that one thing is I would Try to avoid introspection of the codes or of what is the account that is there.
00:36:40.775 - 00:37:58.695, Speaker H: I would try to follow whatever EOF is doing and apply it here in this case as well. So that's one thing. The second thing is that I wanted to ask, like, if we have the knowledge that a one time designation or a temporary designation will be consumed by a certain account, for example the sender's account, then we can attach to the authorization the account that can consume it. And if that address does not align with the address that sent the initial transaction, then we do not count that as a valid authorization and thus we do not increase the nonce. Of course, if this does not work, I'm not sure if this will will work well with paymasters because like you do not necessarily know who your paymaster is when you're submitting a transaction. But I'm not entirely sure if this is like a requirement that we need to allow anyone to consume the temporary authorization or not.
00:38:08.685 - 00:38:35.865, Speaker A: All right, my client, maybe you have something to add on the discussions that are going on in the chat. I think it's not very clear if everyone wants to go for the devnet with Matt's proposal or not. From what I read, I see people seem to be okay with it.
00:38:38.285 - 00:39:08.973, Speaker E: The problem with this format in general is that we have a lot of people with a lot of different things that they would like to do with this proposal. And we end up needing to agree on one specific thing and it's hard to do that. And so instead we say we can do both things. We can do temporary and we can do permanent. And then the EIP and implementation grows and grows. So I just, I don't support the temporary delegation. I don't think that it's needed.
00:39:08.973 - 00:39:21.105, Speaker E: I think that you can emulate the exact same thing with the permanent delegation that is in the proposal. And it's a lot simpler to implement this than it is to add flags or to interpret the delegations differently.
00:39:25.375 - 00:39:32.075, Speaker A: I see. Good points. You have your hand raised.
00:39:33.295 - 00:40:24.445, Speaker I: Yeah. So first, I also agree that I don't think temporary delegation is really needed since it can be emulated. But if we want it, and we still want to mitigate, I mean, still need to mitigate the issue that Hans Go raised. Maybe it could be related to a revert you could have. I mean, if you associate it with a revert, then instead of a particular sender, then it would become possible to use it with 4337 because just if you have a contract that otherwise fails validation and causes a Revert, then you get a different behavior. So I'm just thinking whether we could, I mean if we do need to do temporary delegation, whether we could use. Whether we could associate it with reverts.
00:40:37.065 - 00:40:45.033, Speaker A: Anything to reply to this mat or Engard. Yeah, go ahead.
00:40:45.209 - 00:41:21.597, Speaker C: Yeah, I'm just wondering because I was also briefly thinking about this. So basically, how would you handle the following cases? I mean a 7702 transaction that has a one time enter in it, but then within a transaction that account is just never called. So there's no revert or no passing or B. I mean of course many smart accounts basically also just have code paths that don't revert that are very trivial. Like you just send something, some eth to it and it just accepts the ethnicity, you know, doesn't revert. So. So you can basically, it's a bit more expensive to grief then.
00:41:21.597 - 00:41:36.745, Speaker C: But you can still basically just have it be used in a way that doesn't revert or see, you know, like some sort of multiflow where within the same transaction it is called into multiple times and reverts sometimes and doesn't revert at other times. Like it seems tricky to get.
00:41:37.885 - 00:41:55.655, Speaker I: I think you are right. Since it can be included in a transaction that actually doesn't call the contract, so it has no opportunity to revert, then your ID solution will not work. So I go back to the original, what I said originally, that maybe we don't need the temporary delegation.
00:41:56.995 - 00:42:15.435, Speaker C: Yeah, you could try to make it work. Right. But just basically saying that the nonsense just only increased the first time in the transaction that the account is actually used or something. I'm not sure it's a good idea but like maybe worth exploring, I think. Yeah.
00:42:15.475 - 00:42:48.805, Speaker I: So I see Sam wrote about a self destruct which could also be a case. You could say that if you could use self destruct or something similar during validation of such a transaction. Say that during this transaction you say this is now becoming invalid, I'm now invalidating and otherwise it doesn't get invalidated. Maybe it could be made safe, but I think we need to think more about it. It's hard to like to think about all the, all the cases here.
00:42:52.625 - 00:42:58.265, Speaker A: So then we would go back to Matt's proposal, right? For the time being?
00:42:58.425 - 00:42:59.585, Speaker I: Yeah, I think so.
00:42:59.745 - 00:43:05.285, Speaker A: All right. Okay, sounds good. Kevin, you have your hand raised.
00:43:05.675 - 00:43:06.099, Speaker G: Yeah.
00:43:06.147 - 00:43:49.765, Speaker B: Just wanted to mention that basically the thing that we're mentioning here, being able to remove the delegation into the same transaction or directly from the implementation itself is part of why Ledger proposed to use the storage slots instead of directly changing the account code that way. It's. It's basically as easy as just having a simple method in your. In your contract capable of removing that storage slot value from whatever implementation you add and going back to zero. And that could be inside of the same. Inside of the same transaction.
00:43:53.985 - 00:44:00.203, Speaker A: Yeah. Matt is bringing the point that the protocol should not touch the user storage.
00:44:00.379 - 00:44:12.175, Speaker B: Oh, so we're back at not doing S store. Right. I think that was kind of. We kind of changed opinion on that. But maybe I misunderstood.
00:44:13.875 - 00:44:36.615, Speaker E: I don't know if I understand the proposal, but I don't think that we should have a protocol mechanism that reads from the storage of a user account and then allows the user to like, you know, modify that storage to change like the behavior of that account. That is sort of conflating the like protocol, the kernel space of the protocol and then the user space that applications have the access.
00:44:38.355 - 00:45:47.565, Speaker A: Okay. Right. All right, so let's get a last round of for or against the new proposal and see if we can move forward for Devnet2 and say that we think it's a good thing to go forward with it. I think so far from the client's team and from the researcher, people seem to agree around this new update. So maybe I will let the floor for a few more minutes and then we will try to make a decision around this. If anyone has more points to bring now it's the time. Evo, you have something.
00:45:47.565 - 00:45:52.801, Speaker A: Nope, we're just. Just muted.
00:45:52.993 - 00:46:12.181, Speaker G: Yeah. Because I feel like we talked about a couple options now and you mentioned this. I. I do think there's one that most people align on at least feeling wise, but I'm not sure if we all are really on the same line. And that's why I think it might be helpful to just one time go through it. So. Right.
00:46:12.181 - 00:46:43.075, Speaker G: Like we do not allow temporary revocation. As far as understood, it is persisted with inside the code storage using EOF format. So it's a EF bytecode starting so that it's in this and it is dependent on the nonce and can only be used like once and then it's persistent. Right. Like that is a very simplified. I just want to make sure if this is really the version just to avoid that people misunderstood. Angska Happy, if you want to add this or have a different question.
00:46:43.375 - 00:46:45.155, Speaker C: Yeah, I think right now.
00:46:45.775 - 00:46:47.035, Speaker J: Sorry, go ahead.
00:46:47.495 - 00:47:31.485, Speaker C: No, I just want to say. Yeah, so I think indeed physically right now we seem to mostly all align that Matt's proposal is a sensible next step to take basically in terms for the spec, I still would want to explore my idea a bit more to basically make it so that it doesn't. It's still stored persistently, but it's not active by default in future transactions. You have to manually basically activate it in future transactions. But given that that's conceptually more an extension of Matt's idea, because it would still use this persistence mechanism, I think it would not. Basically we wouldn't have to decide on it now. It's more like we would go with Mat's update to the spec and then at some point, potentially later add that extension, which we might or might not want to.
00:47:31.485 - 00:48:04.995, Speaker C: So in terms of future defnets and whatnot, that would still be useful to basically change to MATS version. So my question here would be more, do we have people on the call that basically strongly oppose that direction in general, like basically either MATS or my variant of it, and would just really strongly prefer the old version of 7702? Because if we, otherwise, if we have broad agreement to make that step, then we could already basically, over the next few days, work towards figuring out the details of Matt's proposal and then merging it so that, you know, at least we move in that direction.
00:48:06.655 - 00:48:09.335, Speaker A: Absolutely. Ivo, you want to add something?
00:48:09.415 - 00:48:46.561, Speaker J: Yes. I'm actually opposing temporary delegations. And the reason for this is that I think the UX in practice of temporary delegations doesn't really make sense because there's very little account abstraction features that you can actually experience in a proper way using temporary delegations. Like one simple example would be batching. In the majority of cases, batching would be valuable with ERC20 approvals. And in this case you only need to batch two calls. So in this case you would have like one signature for the user op and one signature for the delegation.
00:48:46.561 - 00:49:28.685, Speaker J: So it cancels, it cancels the benefit from batching and then it also cancels the benefit from sponsorships. Right. Because you need to do the delegation before you actually benefit from the sponsorship. So I think there's very little account obstruction use cases where temporary delegation would make sense and I think emulating it on chain in some sort of a minimal way where you can, for example, emulate it for, let's say, a week or a day or whatever makes a lot more sense. And this emulation code can be argued that can be absolutely safe enough to be as safe as the current security model.
00:49:44.275 - 00:49:56.215, Speaker A: All right, so compared to like the current proposal that we were discussing, you, you meant the. So you strongly oppose temporary revocation, right?
00:49:59.155 - 00:50:12.455, Speaker J: Temporary authorizations. So I Oppose the ability to like, set an authorization in a way that it would get automatically revoked in one. In one interaction. In 17702 interaction.
00:50:16.635 - 00:50:28.267, Speaker A: Right. Now that. Sam, could you expand on the mutating account codes? What did you mean? Did you mean by like, if you.
00:50:28.291 - 00:50:39.811, Speaker D: Can change your delegate call target, like with another 7702 transaction and that target is starting stored in the account's code field, then doesn't that mean you can mutate your account's code field?
00:50:39.923 - 00:50:48.655, Speaker A: Oh, okay. Yeah. Ans. Gaur, go ahead.
00:50:49.355 - 00:51:11.487, Speaker C: Yeah, on that point, I also. I was thinking about this as well. That does seem to be concerned. But of course the thing is that with the original 7702, that also is already the case. Right? So basically that within different transactions you have different code. And I think the idea was also ready to make it introspectable so that you actually see as if that code was permanent. And then all of a sudden at the end of the transaction, that's no longer the case.
00:51:11.487 - 00:51:51.535, Speaker C: And then you have a different code in the next transaction and so on. So that is already a concern. Part of the reason why I was proposing my extension of this that basically would not by default be active beyond the scope of the transaction is that I think it is somewhat problematic that now basically you can over multiple times, basically over the course of a week, you can check and recheck and recheck and recheck and you always see the same code and then it later on changes. So it becomes conceptually, I guess, even a bit more of a. It looks permanent and then it vanishes or it gets changed. But I feel like basically this is a problem that's in general in some ways inherent to 7702. Right.
00:51:51.535 - 00:52:00.035, Speaker C: Because either you make it immediately permanent or you basically will have this problem in some variant. I think it's basically unavoidable.
00:52:04.345 - 00:52:10.525, Speaker A: Evo, do you still have your hand raised or is this from the previous points?
00:52:12.745 - 00:52:14.161, Speaker J: No, that's the previous point.
00:52:14.233 - 00:52:19.785, Speaker A: Okay, okay. Yep. Richard, go ahead.
00:52:19.945 - 00:53:35.183, Speaker G: Also with introspection, right? Like why I get the point that this changes the behavior of how you interact with a blockchain or like how on chain contracts behave. Because offshane you could just check that it is really this special case that starts with ef. I think with proxies we are already in a state where you have to differentiate or separate what is the bytecode and what is the behavior. So I know that it changes in invariant, but I don't think it's the worst development that people start Separating these tools more clearly. So I would have another point if there's no question towards the mutability of code also brought up by Sen. I found the idea interesting because it would allow potentially to make it easier to emulate this one time transaction part or this limited time transaction part is to allow somehow, for example, Sam mentioned self destruct to reset like the authorization. Why I find this interesting is because if you just revert, that basically means that if you set your code to an address set after a certain point of time reverts, you would have to create a new authorization to activate your account again to make it usable again.
00:53:35.183 - 00:54:06.015, Speaker G: Because if it just by default reverts at the first opcode after a certain point of time, that means you cannot receive either ether, you could not reserve receive any token that does a callback into your account. So rather having a way that after a certain time it would just self destruct really itself would be interesting. But I'm not sure if this is basically going a little bit against the idea of this we want to deprecate self destruct. That's a bit the question. But here again we have mutating code already, so.
00:54:08.835 - 00:54:20.045, Speaker D: So I think the really interesting thing with self destruct is you could do it as the absolute first thing in your contract and then guarantee that your code will only be temporary.
00:54:21.545 - 00:54:22.325, Speaker C: Yeah.
00:54:27.745 - 00:54:35.681, Speaker A: Yeah, interesting. But then it reopens the self destruct defecation pandora box again.
00:54:35.873 - 00:55:08.665, Speaker G: But yeah, but it would be towards these two account types which we can check, right? Like we can very clearly differentiate these accounts that are allowed to do self destruct because there are kind of mutable accounts in any case basically and for them self destruct is just resetting their state to the original state where there's other accounts. But again, I know that it adds existing complexity and maybe this should rather be an extension that is more optional that we can evaluate, but it would make it easier to emulate a couple of these temporary use cases.
00:55:10.285 - 00:55:13.665, Speaker D: Are we still planning on removing self destruct even in the same transaction?
00:55:16.555 - 00:55:17.735, Speaker E: I don't think so.
00:55:18.115 - 00:55:20.535, Speaker D: Yeah, so that would be fine for this.
00:55:21.075 - 00:55:30.135, Speaker C: I think Vitalika still wants to remove self destruct even within the same transaction. From my understanding, not sure if this will ever happen, but I think the intention is still there.
00:55:30.635 - 00:55:32.055, Speaker E: We can make it harder.
00:55:36.155 - 00:56:44.745, Speaker A: Yeah, to be discussed I guess. Probably good to to bring that point to the next ACD or so we are soon reaching the end of this call. I think we can go back maybe to nsgar question about DEVNET 2 and do we want to have this new proposal from Light Client in the in the next defnet. I think so far people are pretty aligned on this in. In the call. So I think, I think we could move forward with this and obviously it's a, it's a devnet, so we will take it from there and see how it goes for the final version. But I think it wouldn't hurt to go forward with this in order to be able to explore more in the, in the next stages.
00:56:44.745 - 00:57:01.785, Speaker A: So if that sounds good for you guys, I think we can, we can wrap this up. Maybe. Matt, you have some final thoughts that you want to share?
00:57:03.605 - 00:57:40.575, Speaker E: No final thoughts. Thanks everybody for the feedback on the PR and in this call. I think we'll let things sit for another couple days, probably early next week, try to merge. There are some things I need to update in the EAP like the title and some of the more like accessory paragraphs in the eap, so keep an eye out for those updates. But yeah, unless someone comes with a different idea, then I would expect this to be merged before the all core devs call next week and we can discuss having it for Devnet 2 with all the client teams.
00:57:44.635 - 00:57:50.815, Speaker A: All right, sounds great. Thanks everyone for joining and see you in the next calls.
00:57:54.905 - 00:57:55.805, Speaker H: Thank you.
00:57:57.145 - 00:57:58.165, Speaker C: Thanks everyone.
00:58:02.025 - 00:58:02.665, Speaker J: Thanks everyone.
