00:00:00.800 - 00:00:28.097, Speaker A: All right, I think today will be a short one and so let's begin. So on our side we finally cracked the needle. The issue with. Sorry for that. I'm probably also sick. We cracked the needle with the contract destruction issue and through that found even more serious. Sorry for that, even more serious one.
00:00:28.097 - 00:00:51.085, Speaker A: And now it is fixed and being fixed so we'll finally be able to update it properly and we'll be having more correct view on the block data set. So that's it with us for now, hoping for a release soon. And yeah, that's it.
00:00:53.345 - 00:00:55.845, Speaker B: I'm not sure I caught that exact same.
00:00:56.485 - 00:00:57.665, Speaker A: So yeah, we had.
00:00:58.405 - 00:01:02.325, Speaker B: Did you find the timestamp issue or was this was some other issue?
00:01:02.445 - 00:01:55.505, Speaker A: No, no, no. That was a bit more severe issue. So the point of the issue was we have a contract, it has a destruction call. The destruction call is called and upon destruction call we need to in the code of contract transfer funds from the contract to the caller, for example. And the issue was that we had no, I didn't like no information for the user of esimulate that transfer actually happened. So basically the lock, this additional log that we created did not appear on such particular case and it appeared to be quite a deep rabbit hole that we digged with Lukash quite deeply and now we are finally finishing. So yeah, it's not related to time or blocks really from that side of things.
00:01:55.505 - 00:02:01.545, Speaker A: It is more related to how like EVM event was passed down.
00:02:03.765 - 00:02:38.805, Speaker B: Okay, gotcha. Thanks. Yeah, as for me, not a lot to report. Killari opened PR against GETH to add documentation for a simulate v1. I was reviewing that and we got that merged yesterday. So that's done. Something else was as you guys saw, seems like REST implemented Esimulate and we were trying to add them to our Hive testing setup.
00:02:38.805 - 00:03:08.979, Speaker B: So yeah, I wrote a patch to Hive so that they are included in the tests. And it seems like. I mean Killer would be the best person to comment on this, but seems like they're not too far apart from our results. Just the. The structure is somewhat different. Maybe it's a bit older, but it seems like we agree on a lot of things, so that's good news.
00:03:09.107 - 00:03:10.695, Speaker A: Do you agree on hashes?
00:03:11.955 - 00:03:18.115, Speaker B: No, I'm pretty sure that's. That's going to be the last thing.
00:03:18.275 - 00:03:21.175, Speaker A: That would be actually a miracle. That would be cool.
00:03:21.675 - 00:03:22.883, Speaker B: That would be a miracle.
00:03:22.939 - 00:04:06.175, Speaker A: Truly. Like Danish from the get go. That would be perfect. All right, is there any place like where we can take a look at the current diff state? Maybe we can we could ask Hilary when he'll get not sick and show it on the next stream or something like that, so that people are looking into what would see. All right, so any other news? There was some discussion on removed field on the chat, so could you. Could anybody, like, remind us what was this all about?
00:04:07.915 - 00:05:11.635, Speaker C: So the issue is that the logs provided by the ETHGET logs endpoint have a field on them called removed. This only makes sense in the context of a subscription, where when you have a reorg, it basically sends you loglines saying this is the logline that was removed due to the reorg, and then it's followed by log lines that are added in their place. That field doesn't really make any sense in the context of ETH call or ETH simulate because you can't reorg in those cases. And so the field doesn't really make sense. But the counterargument is that it's nice when you use the same structure for multiple things, even if they're not totally the same, if they're close enough. The question is, do we want the structure of the log to match the ETH logs call including the fields that don't make sense for ETH simulate, or would you rather have ETH simulate have its own structure that is slightly different?
00:05:13.575 - 00:05:18.355, Speaker A: Would it then mean that we would have escaped simulate logs?
00:05:20.775 - 00:05:35.527, Speaker C: Yes, we already do. These are the events. Events. Maybe they're called another mine. Don't know. And we already do have those, right? Like they're part of the response. Yeah.
00:05:35.527 - 00:06:17.095, Speaker C: And so the question is just do we include the removed field in those or not? It would always be set to false if we did include it. Yeah, then it's just an API structure question. My personal preference is to not include it since one structure is a superset of the other. In most languages that's pretty easy to deal with where you just have the base structure and then the other one adds fields. It doesn't bother me too much, but I can appreciate the argument for having them be exactly the same. Also, I think guest may currently include the remote field and so I think. Is that true, Sina?
00:06:19.155 - 00:06:50.475, Speaker B: I believe so, yeah. Because we use the same struct, the same object type as these get logs. So I think also like. So my slight preference is towards having the same structure and even in the in the E simulate specs to directly reference the log type that is defined for ETHGET logs. I think we should try for consistency here.
00:06:53.135 - 00:07:23.805, Speaker C: The other option would be to specify that field as an optional return field, meaning the client can decide whether to return it or not. And if it is returned, it will always be false. So we can just specify it as it's either false or missing. And they both mean the same thing. So that way people who are implementing the other side of the API, so library authors and whatnot know that, hey, sometimes you might get this value, and if so, you need to deal with that. Dealing with that may just be mean ignoring it, which is totally fine. Or if you've got.
00:07:23.805 - 00:07:45.775, Speaker C: But also sometimes you won't always get the field. So some other client may say, not send it. You need to be prepared for that. And so this is basically saying, acknowledging, the clients may give different results because internal implementation details and the Ethereum clients may give different results. The libraries and whatnot that are interacting with those will just need to be aware of it.
00:07:46.275 - 00:07:52.935, Speaker A: And in terms of like using it, when would be that situation that would set it to true.
00:07:53.805 - 00:08:21.559, Speaker C: So it's never set to true. For ETH simulate, this is only in ETH get logs. Because the way eth get logs works, I think it's eth get logs, it's basically a subscription. So you tell the Ethereum client, hey, anytime there's a new block, send me the logs that match this filter. If there's logs that match the filter in the block. And it will do so every time that happens. It's particularly meaningful if you're on a websocket connection or some persistently open connection, though you can also pull, pull.
00:08:21.559 - 00:08:43.275, Speaker C: And so what happens is the Ethereum client sends you a log that says foo, right? And then the block, the generated foo gets reorged out and it's replaced with another block. The Ethereum client will say, hey, foo was removed, so removed equals true. And then here's a log that showed up bar in the next block.
00:08:43.695 - 00:08:56.919, Speaker A: And isn't there a case that we can somehow have this in V2, in theory at least. So that simulation of how the block was removed, or something like that, I.
00:08:56.927 - 00:09:29.385, Speaker C: Mean, in theory you could, we could add a bit of complexity, hypothetically. What you'd want to do is you make it so when the user is giving you their ETH simulate call and they describe the series of blocks they want, they could say, you know, include this block and then remove that block and then proceed with these blocks. It's a little bit of a weird case. It would be kind of useful for people being able to easily test their applications and make sure their applications work in a reorg scenario. But it's a pretty limited value and it Adds a lot of complexity.
00:09:30.525 - 00:09:34.865, Speaker A: Is it potentially needed on L Tools or something like that?
00:09:36.805 - 00:09:57.765, Speaker C: The ability to simulate reorgs, you mean? Yeah, I mean it's useful just even for regular apps. Like it's a kind of. It's one of these things that's like kind of useful. You can imagine people doing something with it. I'm just not convinced that it's useful enough to warrant the extra complexity. In Ethereum clients implementing Ethereum simulate V2MM.
00:10:01.665 - 00:10:28.065, Speaker A: We have three options. We keep it in and set it always to false. We make it optional. So for example Wrath and nethermind cannot have them or something like that. Or we can include them in some future for example release and make it dependent on like actual, actual logic. Yeah. Or am I missing something?
00:10:32.375 - 00:10:33.715, Speaker C: I think that's correct.
00:10:37.855 - 00:10:39.975, Speaker A: Okay, let's think with it.
00:10:40.095 - 00:10:44.755, Speaker C: For now I just type it. Type those three options into chat.
00:10:45.535 - 00:10:46.915, Speaker A: Yay. Thank you.
00:10:47.495 - 00:10:48.955, Speaker C: My order.
00:10:51.975 - 00:10:53.435, Speaker A: Hello, Caleb.
00:10:56.175 - 00:11:51.441, Speaker B: I'm leaning towards having it as optional fields. I think having an extra field in the object is usually not a problem for clients to deserialize. Like if you have a unused field in your JSON object in JavaScript, Go or languages that I know of when you're deserializing that JSON string, then it causes no problem. They just ignore that extra fields. So I tend to say like it doesn't cause any issue and I would refer, I would defer it to actually to the Eskit logs spec. I'm not sure if this is. I'm not behind my laptop right now to check this, but I'm going to do it as soon as I'm at the keyboard to check how ethget logs defines the log structure.
00:11:51.441 - 00:11:58.045, Speaker B: Like is remove field included in there or not? And I would just go with that.
00:11:58.985 - 00:12:24.475, Speaker A: Yeah, let's make it optional for now. We would vote also for it. All right, so with this I think I thank you so much everybody and oh yay, you are here. Well, no problem at all. So probably if we are all out of topics, let's see each other next week.
