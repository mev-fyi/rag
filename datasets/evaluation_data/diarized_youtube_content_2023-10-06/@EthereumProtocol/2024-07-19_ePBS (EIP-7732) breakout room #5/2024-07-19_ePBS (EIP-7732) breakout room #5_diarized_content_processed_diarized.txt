00:00:01.680 - 00:00:58.600, Speaker A: All right, so welcome to the fifth meeting. This is the fifth breakout session of EIP 772. We have a very small agenda and I'm very sick, so apologies for my tone. The first point in the agenda is something that Quintus raised, which is the fact that builders can gather the IP addresses of proposers that request bits from them and can we do something about this? Do we want to do something about this? What situation? This is definitely something that a proposer that connects to them would be trusting them with this information. This is a trust assumption that ebbs does not solve in the current performance. Does anyone have any opinion on this topic?
00:01:02.380 - 00:01:11.480, Speaker B: I'm not a networking expert, but how hard it is for the proposal to change its ip after it proposes a block? Because it doesn't propose a block very often. Right?
00:01:14.340 - 00:01:15.236, Speaker A: I don't know.
00:01:15.268 - 00:01:16.720, Speaker B: Not a networking expert.
00:01:22.590 - 00:01:34.478, Speaker A: I've been told before that builders, anyways, can do this today and they already have them mapped. But I'm not sure if that information.
00:01:34.574 - 00:01:37.694, Speaker B: But that is relayer today. It's not builder.
00:01:37.742 - 00:01:37.950, Speaker A: Right?
00:01:37.990 - 00:01:39.054, Speaker B: This is relayer today?
00:01:39.142 - 00:02:39.980, Speaker A: Well, yeah, so I've been told that this was builders, but I presume that this is with the help of the relay, or probably already integrated builders. I'm not sure if this information is even true, but I don't even have an idea on how to mitigate this. So it is a problem that is out there. I don't know how grave of a problem is also. So it's a problem that is there, and unless anyone has anything to say about this, we can move on. I'll contact Anton, who's been studying this problem for the beacon chain for a long time, and he's realized that you can find the IP addresses just without being a builder, without being anything, just connecting a node into the network. So this may be a problem today.
00:02:40.140 - 00:02:57.516, Speaker C: I remember a study kind of proving that was very, very, very easy to grab. High chance of picking the right IP address for a given validator was or beaker node, I don't recall.
00:02:57.588 - 00:03:26.956, Speaker A: Yeah. And Tom was doing this by spamming the network quickly. And, I mean, if we haven't mitigated that, then. It's not that I want to minimize this problem, but if anyone can do it anyways, you don't need to be a builder to get this number, then there's not much that we as a group can do. But. But this is a problem for core devs in general. All right, so let's move on and let's have a short meeting.
00:03:26.956 - 00:04:08.810, Speaker A: So I have only two issues to to mention, I already fixed them in the, in the EIP. If anyone is looking at the consensus PR, the status of that PR is as follows. The consensus layer PR, it's mergeable. It might actually be merged as cis because there's no commitment to implement it. If we merge it, it's just an extra fork, just like there are other prs. Like the whisk is an extra fork there in the consensus repo. Now we caught two bad bugs out of trying to make it executable.
00:04:08.810 - 00:04:46.342, Speaker A: I am passing all tests that are relevant except for choice test. Now that's going to be a separate pr to make it executable at the current fork. The fork choice tests are very nasty because, well, the changes to portraits are very large. So it's not really clear to me which tests should pass and which tests should fail. So that's taking me a long time. I still have 34 tests to pass start. I started with 700 something tests failing and now I am down to 34 tests passing failing.
00:04:46.342 - 00:05:51.200, Speaker A: I hope to have that PR open in about a week. But I said that two weeks ago. The two bugs that we found out of trying to make it executable is one was the issue of the state route in the block hash. So currently you find out what your parent block route should be by looking at the state and hashing the last block header that you have in the state. The problem is that the block header has the commitment to the state root, and that state route for the previous state is not put there as part of state transition. It makes sense because you're making a state transition, and only after state transition, you actually copy the hash. So the way we do this today is that when we process the slot, at that moment, you insert the right state root, the hash through root of the state in the block header.
00:05:51.200 - 00:06:40.240, Speaker A: But this breaks in epbs, because in epbs there's a second state transition that happens within the same slot. So when you import the payload, the execution payload, then you need to check whether or not that payload was referring to the right block, and therefore you need already the hashgrid route of the current block, which is already committed in the state. You've already performed state transition, but the hash three root was not performed, was not updated. So the only thing that I did is I added that check. When you process the payload, just check that if the root is empty on the block hash, then you just update it. You compute the hash now for the state and you just update. And so far nothing has broken out of that change.
00:06:40.240 - 00:07:16.158, Speaker A: I kept the change of course in process slots because you might need to process a slot when the payload hasn't been revealed. So you might need to update the hash three root for the state, both either in the payload or when processing a slot when the payload was not revealed. Uh, the other consensus, but the other bug that, that I found was in for choice. That one I'll probably defer for you to look at the comments. Uh, it was in the filter in the tree. It was just completely broken. It was bad python.
00:07:16.158 - 00:07:56.514, Speaker A: Uh, I was, uh. So the idea is that when you have a node, what are the children's of this node? Uh, within four choice. And the children are every block that was based off of, off of this route. But you have to consider them with or without a payload. And in this change I was considering as children, well, essentially I was considering no children for the justified checkpoint. So therefore all tests were failing. And then I figured out that fortress was completely broken because I was having an empty tree, which is only the justified checkpoint was the.
00:07:56.514 - 00:08:22.090, Speaker A: I think this is fixed, but this is harder to check if it's fixed because since I don't have fortress test, most of the fortress tests are broken currently. It's hard to know if this was fixed. It requires a review. It is a hard thing to review, so I'm hoping that some of you would actually read it. All right, so that's all my update and there's nothing else in the agenda. So if anyone wants to say something now.
00:08:27.210 - 00:08:57.310, Speaker D: Hello? Hello, hello, I'm on my mobile. I'm sorry, my reception also bad. If possible, could we talk shortly about the IP thing I wrote you in the meantime, but you didn't, probably didn't see it. You know, we're trying to spin the EPF project with builder rating. Is this IP thing going to affect it? I'm trying to comprehend this.
00:08:59.010 - 00:09:09.630, Speaker A: I don't see how. I don't see how you can. I don't see how you can detect in your node that the builder is collecting your IP information.
00:09:15.170 - 00:09:24.100, Speaker D: The current rating system is about bad responses, right? Bad.
00:09:25.800 - 00:10:16.280, Speaker A: So there's not currently. Right. But the proposal for the proposal for rating, it's mostly focused about censorship. Like if you see that the builder is consistently putting out blocks that don't include transactions that you see on your maple, then you might want to downscore that builder. If you late, then you might want to downscore the builder. So you can check for conditions that you check locally and you have different weights and allow your user, your operator, to downscore for whatever reasons you believe they're valid. But I don't see how this IP issue would play a role there because you cannot see from your node that the builder is actually collecting IP addresses.
00:10:17.220 - 00:10:25.012, Speaker D: And you don't actually need to share that information with the builder in order to get your information about the builder as a node.
00:10:25.036 - 00:10:47.230, Speaker A: That's correct, that's correct. The nodes will only downgrade or upgrade a builder based on their own view of the chain, which is local. It's local and you don't even need to be a validator to do this. You don't even need to be a proposed proposer. You just run a node and you have information of your local node.
00:10:48.010 - 00:10:48.562, Speaker D: Okay.
00:10:48.626 - 00:10:52.190, Speaker A: Have a scoring system that is separate from your actual validating node.
00:10:53.850 - 00:10:59.030, Speaker D: Okay, that's a thank you very much for the clarification right.
00:11:02.290 - 00:11:11.480, Speaker A: There. Any more comments? This looks like this time is going to be an actually short note.
00:11:12.660 - 00:11:49.010, Speaker B: I guess we can get like an implementation update, right. So from my end that like I'm working with EPF fellows on like implementing the actual SPAC itself, which is the pr that open on the consensus back. So I think besides like while he's fixing all the tests, definitely welcome reviews on the python code. But meanwhile we're also looking into adding the python code into the prism client. So that's where we are at today. I believe Enrico and maybe Kjenda were looking at the same thing as well from their perspective. But yeah, definitely welcome feedback.
00:11:49.990 - 00:12:17.040, Speaker D: You're right. I know there are, I have fellows that have this in their project. This was a of a different approach, something that Portuguese proposed on a different discussion. But yeah, I think there are fellows doing exactly what you're saying and that's the implementation in the actual client. I thought they should be here, but they're not on this meeting. I mean.
00:12:21.340 - 00:12:26.030, Speaker A: Anything in the chat to say that they're doing this in Nimbus, that's great too, right?
00:12:29.210 - 00:12:29.950, Speaker D: Nice.
00:12:31.050 - 00:12:58.286, Speaker C: And a place from Teco. Yeah, we spoke the last breakout that I was planning to start working. The bad news is that I haven't started. The good news is that I completed finally what I was doing before, which is the SSD stable container finally implemented. So I next week and plan to switch, and switch contexts again finally and start putting my ad on it. The other.
00:12:58.358 - 00:12:58.902, Speaker A: That's really great.
00:12:58.926 - 00:13:15.490, Speaker C: The real bad news is that I'm gonna go on vacation for three weeks after the next week, which will add a little bit of posing on the work, but I will start, let's say.
00:13:16.030 - 00:14:26.510, Speaker A: That'S already good news. All right, so what I was thinking, if you guys are starting, just little piece of advice would be to implement just the minimum, which is not even deal with the option itself. If we can prove for me a proof of concept that would be good enough, is if we can prove that we can handle the 12 seconds block, the twelve second slots. So that means you get your local block from your local yale, but you break it into a bid, a payload and a consensus block, and you just locally produce blocks as if they were from epbs. I think this is the really minimal viable proof of concept that doesn't even implement the auction because the auction part is easy to do than later without the P two P part, but the actual just requesting a la MEF boost, that's also easy to add. But for that we need to agree on what the builder API would be and that surely is going to be a nightmare. So I think the easiest thing to do is just to focus on locally produced blocks, but broken into different pieces, which already would guarantee that we can actually handle 12 seconds.
00:14:28.570 - 00:15:15.270, Speaker B: I think the second easy thing to do, this is the second easy thing to do is just essentially you can build kind of like a local builder or, or like an altruistic builder. You basically just kind of request the payload from Geth or your El client every slot and submit a bid. But then you also have to be a validator as well. You have to stake and then you basically try to win every slot to set the baseline and then you see the block is included, then you just review the payload at the second half. I don't think that's that hard to do either. And I think that may be a fun project for the EPF or I could take on that as well.
00:15:16.370 - 00:15:32.350, Speaker A: Yeah, that's definitely. Yeah, it should be a flag. Also on validators, just submit a bid every, every block, which, yeah, we'll have to deal with the spamming.
00:15:33.820 - 00:15:34.732, Speaker C: Right, right.
00:15:34.796 - 00:15:37.600, Speaker B: And that's good for testing the PTP path. Yeah, go ahead.
00:15:38.180 - 00:15:50.960, Speaker A: No, no, I was just going to close the meeting if there's no comments. All right, let's go work. See you guys, and thank you very much.
00:15:53.060 - 00:15:54.004, Speaker D: Bye bye.
00:15:54.172 - 00:15:54.652, Speaker A: Bye bye.
00:15:54.676 - 00:15:55.156, Speaker B: Take care.
00:15:55.228 - 00:15:55.380, Speaker A: Bye.
