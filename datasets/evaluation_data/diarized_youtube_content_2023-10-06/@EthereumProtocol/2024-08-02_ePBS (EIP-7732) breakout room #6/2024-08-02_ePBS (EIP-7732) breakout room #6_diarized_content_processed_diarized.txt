00:00:00.680 - 00:00:35.765, Speaker A: Anyways, this call should be like just five minutes. There's actually no updates that we have to give. There hasn't been any changes in the spec at all, which is good because that means that we can actually start coding. We are increasing the speed of implementation in Prism, the eip. I don't remember if I was passing already every test, but I think I was already two weeks ago. It's passing all existing tests. On the consensus side, Eaton left some feedback.
00:00:35.765 - 00:01:14.355, Speaker A: I think it's the only one that left feedback so far on the CL spec. And I'm going to start pressuring Xiao Wei to merge the one without tests because that's not invasive to have it in the repo. It's over 3,000 lines, the full PR so far. And this didn't add any new tests. What else? Implementation. There's this. The only issue we found on implementation so far that I'm aware of is what was discussed yesterday night that I got an explanation from Misha and from Adrian.
00:01:14.355 - 00:01:59.989, Speaker A: The issue is that when we pass to the engine the new payload, we need to pass it together with the parent become block route because that's the route that they use for the block route op code. And currently we have that route because we have the block that included the payload and then we just request from the block the parent route. But on epbs we don't have a block. We only have the execution payload. The execution payload envelope. So there's two ways out of this. We could add both the block route and the pay and the parent block route to the envelope.
00:01:59.989 - 00:02:29.085, Speaker A: Or we could just request from for choice, which is what I did in prison, ask for choice. Hey, I have this route. Can you give me what is the parent route to that route? I assume that this is a very cheap check for every client, so that's why I went with that because that doesn't require. Require any spec changes. But if this is not immediately cheap for everyone, that I'm happy to change that. That's all for me. I don't have anything.
00:02:29.085 - 00:02:44.489, Speaker A: So I'm open to any comments and Rico's updates from Teku and so forth. Yeah, you just mentioned.
00:02:44.577 - 00:02:44.945, Speaker B: Go ahead.
00:02:44.985 - 00:02:45.537, Speaker C: Sorry.
00:02:45.681 - 00:03:04.725, Speaker D: No, I just. Just mentioned that we. Yeah, we are actually organizing to really start working on it, which is good. We have. Since I'm going off, I put on the. On the. On the desk Stefan as well.
00:03:04.725 - 00:03:29.985, Speaker D: And so we can start working together in any way. There will be everyone. Everyone will be off next week. So next week will be. Anyway, nothing to work on. And maybe the week after there will be actual work starting on T.
00:03:39.055 - 00:03:39.415, Speaker A: So.
00:03:39.455 - 00:03:42.767, Speaker C: If your comments to Burnaby POTUS here.
00:03:42.871 - 00:03:44.103, Speaker A: So little background.
00:03:44.159 - 00:03:44.423, Speaker B: Right.
00:03:44.479 - 00:04:28.699, Speaker C: Because to basically to self build that you also need to come up with a value of your local mempool and then you compare their value with the builder's bid and then you choose the highest bid. And this is easy with block auction today basically because it's just. Because it's. Because it's just in time. Right. And then you basically commit to the contents of the block at that very second. But I think your point is that because in slot auction that by looking at the local mempool get would not have like a very good estimate on what the value will be six seconds later because no one uses local Manpool for example.
00:04:28.699 - 00:04:38.465, Speaker C: And it is also harder for local mempool or local guest to come up with that estimate versus some other sophisticated builder. Is that your point?
00:04:39.845 - 00:04:55.741, Speaker A: Well, yeah. So the last one is exactly my point. The previous one is not really right. If no one uses the mempool then you know that the current value is going to be the value that you're going to get success from for now. Yeah, but yeah, so that, that's. Yeah, that. That's right.
00:04:55.741 - 00:05:11.955, Speaker A: Mar posted my comment on Discord, which is something I do dislike about slot options. It makes the difference between producing a block today and comparing your block against the builder much worse than on block options.
00:05:14.895 - 00:05:45.121, Speaker B: I don't know if I totally agree with it. I need to type the answer to just convince myself. But I actually think for instance, like you don't know how much the block will be in six seconds. That's true. But you have this optionality that you don't have in block option. That's the first thing. And the second thing is you might find a good estimator based on the value of your local block at 0 second versus the best bid you're getting from the slot auction at the same time.
00:05:45.121 - 00:05:57.505, Speaker B: So for instance, if that's already 100x then probably you can tell yourself your local block won't be competitive six seconds from now. Yeah, but I want to type it up just so that it's clear.
00:05:59.125 - 00:06:06.225, Speaker A: I didn't understand the first point. What is the new optionality that you have versus block option?
00:06:06.885 - 00:06:23.511, Speaker B: So you can commit to yourself, right in a slot auction and then you deliver the block in six seconds. That's not something you can do in a block auction. Like in the block auction you have to. If you commit to yourself, you have to also commit to the. To the block content.
00:06:23.703 - 00:06:24.055, Speaker A: Yeah.
00:06:24.095 - 00:06:52.815, Speaker B: So so yes, there is the same. Yeah, yeah, exactly, exactly. So you have like this deterministic value, like there's no, no randomness, but at the same time. Yeah, it's. Yeah, I'm just saying like the benchmark of saying, oh, this is much worse. It's a benchmark that seems to be based on the best possible outcome in a, in a random world. But you don't have a random world when you have block options.
00:06:52.815 - 00:06:56.871, Speaker B: And so is it fair to compare against this benchmark? I guess would be.
00:06:56.903 - 00:07:24.205, Speaker A: The argument is pretty simple. The builder is much more equipped who's bidding is much more equipped to knowing what their value would be six seconds from now than a home staker that is running vanilla software. They can actually do this analysis and a home staker will not be able to do this. Definitely not on vanilla software because we will not implement such analysis.
00:07:25.025 - 00:07:55.597, Speaker B: Yeah, but so the builder does this analysis and this is mediated through the bids that they send you in the slot auctions. And so. But just by reading the builder bids, you can kind of tell what's their own forecast. For instance, if the builder bids are 1 if. And your local block is telling you, or currently my value is 0.1 if I think you can tell yourself, like, if your decision function is, oh, I want a local build, when it's like a bit better, then maybe you can. Oh, I see what you're saying.
00:07:55.597 - 00:08:00.845, Speaker B: I guess. So you're saying like you don't have a deterministic decision. My local, you can't.
00:08:00.925 - 00:08:54.005, Speaker A: So what you do today, for example, would be a strategy today would be if my bid is 20% less than the, than the builder or with a cap, whatever it is. But if my bid is up to 20% less than a builder, never rather take my bid because I trust it not to censor. That's a possible strategy that validators can do today, or they can do the opposite. But we have a flag that does exactly this. And this number gets much worse because now if you get a bid that is now 20% less than the builder, six seconds from now might actually be 60% less than builder. And you do not know this. So to protect you from that, if you were betting bidding for 20% less than a builder on slot options, you're going to go to 60% less than a builder or whatever it is, because this number is going to tend to increase.
00:08:55.585 - 00:09:09.525, Speaker B: Well, but the builder pays you the forecast. Right. So if they expect to give you one if they will pay you one if now and your value in the local block can only increase over time.
00:09:10.105 - 00:09:40.857, Speaker A: So that's, that's correct. But the thing is, let's suppose that, that I am willing to, to get my block if it's worth up to 20% less than the builders on block option. This means that if I see a bid for 1 ETH and I have my own block is 0.8 E, then I will locally build and that's it. It's an easy check. Nothing else. Now let's suppose that we go to a slot auction and now I see the exact same situation.
00:09:40.857 - 00:10:06.614, Speaker A: The, the. The builder tells me that they are bidding 1 ETH, right? Their current block is not valued 1 E. Their current block is probably value less than 1 E, but they are forecasting that it's going to be 1 E 6 seconds from now. Their current block is, let's say 0.8 currently. Now. Now my block is 0.8
00:10:06.614 - 00:10:25.355, Speaker A: times 0.8 currently. So if we were in a block auction, I would accept my block. But if since I am in a slot auction and 0.8 times 0.8 is less than 0.8, which is the 20, the 80% of the current bid from the slot auction, then I would not self build.
00:10:26.575 - 00:10:30.435, Speaker B: I, I don't understand why it's 0.8 times 0.8.
00:10:31.095 - 00:10:51.509, Speaker A: Well, because the, the. If we were making a comp comparison, I, I have today a block which is right now the beginning of the slot. I have a block that is 80% of the builder's block of the builder's block right now. So both blocks are. The builder's block is 0.88 and my block is 0.8 of that.
00:10:51.608 - 00:10:52.000, Speaker B: Right.
00:10:52.099 - 00:11:16.830, Speaker A: So it's 20% less. If we were doing a slot, a block auction right now, I would take my block because it's 20% less than the builders. But now we're doing a slot auction and the builder is not bidding 0.8, which is its current value. The builder is building one ETH because he expects to get that 0.2 extra in the next six seconds. And my node is telling me you don't have 0.8.
00:11:16.830 - 00:11:26.135, Speaker A: My node is telling me you currently have 0.8 of that. So then I reject my current block and I give it to the builder.
00:11:27.835 - 00:12:03.558, Speaker B: Yeah, yeah. But the. So when you commit to the builder's bid of 1e, you secure 1e regardless of what the value of the block is after six seconds, you compare that to the value of your block which, okay, let's say at t equals 0 is 0.8 times 0.8. That value can only increase over the next 6 seconds. Right? Because you just add more transactions. So that estimation that you get at T equals zero should be like, let's say if your model of the world is you're always like 20% away from the builder, that should hold as well.
00:12:03.558 - 00:12:05.465, Speaker B: At T equals 6. Inexpensive.
00:12:05.505 - 00:12:41.199, Speaker A: Yeah, but that's my point. That's exactly my point, that now it's true I have a minimum estimation as to what is what I'm losing or a maximum that I'm. The minimum estimation is how much that I'm going to get, therefore a maximum estimation of how much I'm losing. But these numbers that we just talked about means that I am now getting my block is not making 80% of the builder's block. I'm not guaranteed of that. And I have no way of knowing how much my block is going to increase up to the six seconds. And I am not a sophisticated player, which I.
00:12:41.199 - 00:12:44.835, Speaker A: And I have any meanings to computing this.
00:12:46.015 - 00:13:04.115, Speaker B: Right? I mean you could say you could still have a local decision rule that says if my current value of the local block is 20% off from the builder's forecasted value, then I'll use my local block. And maybe if you want to embed the information.
00:13:04.935 - 00:13:39.035, Speaker A: But that means in the example which is talked now, that means that I would only choose my block if my current block right now is the same as the builder's block right now the builder's block was to 80% of an E. And if I put. Yeah, yeah. So the builder's bit 1 eth. But the builder's block at that moment was 0.8. So with your rule which is 20% from now, I would only accept my block if my block is already beating the builders, which is what makes it much worse.
00:13:40.055 - 00:14:00.955, Speaker B: Okay, okay. I need to write it down just so that I'm clear. I think you can find a decision rule that's not perfect because there is randomness. So it's never going to be always like perfect forecast. But I think you can find something that's reasonable and not stupid. But I'll write it down just to convince myself first.
00:14:04.585 - 00:14:24.885, Speaker C: Is it fair to say whatever value you determine at second zero becomes up only? So the second six will always be higher than second zero. But what about transaction can be canceled? I don't think those exist. Or something does. For example, account abstraction made this property harder.
00:14:27.955 - 00:15:08.627, Speaker B: I guess the builder could cancel their. Yeah, the builder like let's say if they are actively extracting the sex dex arbitrage and this the price Moves between t equals 0 and t equals 6 bear block value could change negatively. You as a local builder who's just accumulating transaction fees like it can only go up, Right. Because you, let's say at t equals 0 second, you have some set of transactions. If you find a different set that gives you a worst thing, you can always just take the set that you already have at t equals 0 seconds.
00:15:08.771 - 00:15:26.225, Speaker A: So I'm not exactly sure. So is there anyone from the EL here? Because I agree with you that in principle this only increases. But I'm not sure how the EL decides what's the value that they give you. I suspect that they do this statically by computing the sum of the tips.
00:15:31.765 - 00:15:33.621, Speaker C: I think they also do it honestly too.
00:15:33.653 - 00:15:33.869, Speaker A: Right.
00:15:33.917 - 00:15:36.585, Speaker C: They will allow people to cancel transactions.
00:15:40.205 - 00:15:43.945, Speaker B: Yeah, I guess, yeah. The replace by fee type of thing.
00:15:45.995 - 00:16:07.575, Speaker A: Yeah. So the problem is that what Terrence is, I guess is alluding to is that with a counter abstraction you. This computing might be much, much more complicated. I suspect that the EL would only just give you the sum of the fees that they compute statically when they build their block. I'm not sure about this.
00:16:10.805 - 00:16:19.865, Speaker B: I mean, isn't the local block building algorithm just. Yeah. Decreasing order of priority fee and then just fill until.
00:16:20.925 - 00:16:30.065, Speaker A: Yeah, I think. I think so. I think that's at least what gets is. And I agree with you that if it's this, then it has to increase. It cannot decrease.
00:16:30.605 - 00:16:37.893, Speaker B: Yeah. Unless you allow for cancellations within the duration of t equals 0 to t equal to 6.
00:16:38.029 - 00:16:38.845, Speaker A: No, not really.
00:16:38.885 - 00:16:39.085, Speaker B: Right.
00:16:39.125 - 00:16:45.773, Speaker A: Because you cancel by a transaction with a higher fee. So by definition, if you include that cancellation, then you get a higher. A higher fee.
00:16:45.909 - 00:16:53.549, Speaker B: Not necessarily. Because you could use a lot less gas. So you could cancel a transaction that uses like 500k gas with the transaction that you.
00:16:53.597 - 00:17:09.675, Speaker A: Yeah, yeah, but that's my point. I think that the number that the EL reports to you is not the actual money that you make. It's the statically computed from fees. But I'm not really sure. So I think the number that YEL would give you can only increase because they only statically compute it.
00:17:11.455 - 00:17:18.315, Speaker B: I feel like they should report to you the numbers of a blog that's just greedily constructed and then simulated otherwise.
00:17:19.255 - 00:17:24.715, Speaker A: Oh, do you think they do simulate? Do we have anyone from an EF here to confirm one or the other one?
00:17:25.095 - 00:17:27.039, Speaker B: I mean, it will be totally gameable if not.
00:17:27.087 - 00:17:30.855, Speaker E: So I can speak on behalf of Ethereum. Js So what is the question?
00:17:31.595 - 00:17:48.495, Speaker A: The question is if when you tell us we call get payload and the engine gives us a payload. And the value that you're getting out of that payload is the value simulated from the block or is the value statically computed from fees in the transactions that are included?
00:17:49.675 - 00:18:09.999, Speaker E: Yes. So for now it is in Ethereum js, it is basically the fees that are statically computed. But I think this would depend on upon implementation to implementation how they would want to value it. But yeah, as of now it is fees.
00:18:10.167 - 00:18:18.315, Speaker A: Yeah, and I suspect that actually geth is also fees. I suspect that the engine never simulates it, but I'm not sure.
00:18:19.825 - 00:18:23.645, Speaker E: But do we want to simulate the benefit to the free recipient?
00:18:24.225 - 00:18:25.045, Speaker A: Yes.
00:18:25.785 - 00:18:30.885, Speaker E: No, no, I don't. I don't think any of us would be doing that as of now.
00:18:31.425 - 00:19:08.495, Speaker A: Yeah, I suspect that this is, I think the mining algorithm is you just order all structures that are valid. And you know, because currently before account abstraction, the miner doesn't need to execute the previous transactions to know that the next transactions are still valid. So they just, they know that they can order, they know that they can include them because they have a cap on the gas and they know that they could simulate them if they want. And I think they only report the sum of the fees like what you're telling Ethereum JS does. So I think this number can only go up.
00:19:09.035 - 00:19:11.615, Speaker E: So what would you want to simulate?
00:19:14.415 - 00:19:35.835, Speaker A: Well, the thing is that this number is not what you are actually going to get. You might get more than this if there are transactions that ex. That consume much more gas. Well, you're, I'm sorry, you might get less than this because what you're getting is the fee times the maximum gas that you put. The gas limit that you put.
00:19:36.455 - 00:19:55.385, Speaker E: No, but. No, no. So this is so as transactions are executed, so this whatever is credited to the coinbase, that is the value that is returned. So it should be exact as such in terms of the fees that are credited to the coinbase.
00:19:55.965 - 00:20:13.835, Speaker A: But then I don't understand. So the, so this is then simulated, you're actually executing the transactions and this, this, this is in disagreement with what you said before. So you're actually executing the transactions and exactly computing how much gas this transaction actually compute consumed.
00:20:14.215 - 00:20:27.423, Speaker E: Yeah. If we have to build a block, it has to have a post state and we have to execute the transactions to get that posted. There is no other way around it. Including that need to be given to coinbase.
00:20:27.599 - 00:20:34.055, Speaker A: Okay, so the value that you report in the block is that is how much coinbase got or is it just.
00:20:34.515 - 00:20:43.815, Speaker E: Is how many, how much Fees the coinbase got much value the coinbase got. But how much transaction fees the coinbase got.
00:20:44.595 - 00:20:46.775, Speaker A: Okay, that's fine, that's good enough.
00:20:47.195 - 00:21:01.155, Speaker D: Yeah, but I don't think there is a world where what you get is different by what you have seen in the engine. API call, to be honest would be very weird.
00:21:02.655 - 00:21:23.315, Speaker E: But if for example clients are giving you what they are crediting to Coinbase, it can't be different because then the EL consensus will break. Right. Because the post date is calculated on the base upon whatever is the final state. That includes whatever is paid to the coinbase as transaction fees.
00:21:28.825 - 00:21:38.005, Speaker A: Okay, so. So then it is whatever is included is Coinbase getting out of fees? That's. That's good enough. That's that that number can actually decrease.
00:21:43.345 - 00:21:51.765, Speaker E: Unless clients implement some other way of evaluating the value. But I don't think as of now anyone is doing any other strategy.
00:21:55.865 - 00:22:18.195, Speaker B: I wrote in the chat a question. It does sound. So when you're doing like this local evaluation between your locally built block and what you're getting from the builders, it sounds like if you're just naively doing gas limit times the priority fee, for instance. Yeah, I could kind of game that. I could always.
00:22:18.275 - 00:22:42.615, Speaker A: But that, that actually is what happens. Right. With block transactions. This is what led to the problem the other day where arbitrary was, was. Was complaining that literally this was, this was happening like some roll ups were elevating the tip, but the execution of those transactions was smaller. So Geth was including them in the wrong order.
00:22:46.555 - 00:23:02.295, Speaker B: Right. I guess I have in mind a scenario where I can just always force the nodes who are doing this local evaluation to pick the local block because I trick them into thinking the local block is very profitable.
00:23:03.795 - 00:23:26.533, Speaker A: Yeah, I think that's true. Well, no, I'm sorry, this. This can trick the node into putting the wrong transaction. But what, but what Gajinder is saying is that you cannot trick the local block because the reported value of the block would be the right one because the node into putting into including the wrong transaction.
00:23:26.709 - 00:23:34.185, Speaker B: I see. So the reported value will be the right one, then you will be simulated and you would get the correct coinbase fees.
00:23:36.235 - 00:23:43.855, Speaker E: Yeah. So basically you say that you're sending a local transaction which exceeds gas limit. Is that what you're saying?
00:23:44.995 - 00:23:57.255, Speaker A: No, that the transaction has a higher tip, but the maximum gas limit that it has is very high. But the actual consumption is much less. For example.
00:23:58.515 - 00:24:10.545, Speaker E: Yeah. So it doesn't matter. So whatever. So the transaction will be executed and on the basis of that the coinbase will be Credited. So, yeah, it should reflect the real thing.
00:24:15.645 - 00:24:15.933, Speaker A: Yeah.
00:24:15.949 - 00:24:28.325, Speaker B: I was just wondering if this happens before you do the local evaluation between the builder's bid and your local block. And I'm getting from this value. This does happen. I think it should happen.
00:24:33.865 - 00:25:03.785, Speaker A: All right, so we are diverting from EPBs. I don't know if there's any other. Any other comments. We can probably close early. There were some requests from Bernabeu to spec out slot options. I made the claim that over the last PR on the consensus repo, it shouldn't be more than five lines change. So I'm not sure if we want to do that or not or if there's any value on doing that.
00:25:03.785 - 00:25:17.145, Speaker A: If you guys want it, I can just add a new PR with that. But it's just a pipeliner. Probably it's going to fail tests. I'm not going to fix the test, but the specification should be very simple.
00:25:19.765 - 00:25:44.225, Speaker B: Yeah, I think this would be valuable. I don't mean to airdrop work on more people. I was saying it more to say, oh, if there is like a branch somewhere that we can start from, I can find. Yeah, I'm happy to think about it, though. I'm not like, super proficient in speaking, but yeah, I think it would be nice to just have this on the side so that we can point to it when people ask about these differences.
00:25:47.245 - 00:25:51.145, Speaker A: I'll probably open it in the afternoon. It should be very simple.
00:25:52.355 - 00:25:54.215, Speaker B: Okay, that's amazing. Thank you.
00:25:59.635 - 00:26:06.335, Speaker A: Does anyone have a question or a feeling or implementation? You can probably close this early.
00:26:08.515 - 00:26:12.491, Speaker E: I just have an update on Dorsa that we have started working on this.
00:26:12.683 - 00:27:07.395, Speaker A: Ah, nice. There's a question on the chat. I didn't understand the question. I see you are muted yourself, Abhishek, but I. We cannot hear you. Or at least I can't hear you. Think Abhishek might be trying to speak, but we cannot hear you.
00:27:07.395 - 00:27:31.205, Speaker A: All right, any other comments? All right, guys, I'll see you in two weeks. Hopefully we're going to be much more advanced, at least on our side. See you guys.
00:27:32.865 - 00:27:33.201, Speaker B: Bye.
