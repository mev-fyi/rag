00:00:01.680 - 00:00:35.945, Speaker A: Like welcome everyone to EOF Implementers call number 50. We got a regular meeting scheduled, got client updates, compiler updates, spec updates, testing updates and other items. If anyone else wants anything added to the agenda that's not on the agenda, please mention it in chat so I can see it so we can get to it at the appropriate time. First we'll start with client updates. Ahmed, can you have any update for nethermind?
00:00:39.605 - 00:00:43.165, Speaker B: Yes. Not sure if Ayman is here, maybe.
00:00:43.245 - 00:01:18.591, Speaker A: Not, but he's currently we started again working on refining our implementation and mostly the EIP related to the creation and if that's done, I think we will be mostly aligned with what we. What the. What the spec is and possibly Even join a DevNet once that is done. Yes. Okay, cool. I'm going to go ahead. Devnet's a good thing.
00:01:18.591 - 00:02:34.455, Speaker A: Let's talk about that app and other items. Let's see. Bob, are you with the client team or are you just listening? If you're the client team, speak up. Otherwise I will move on to I guess basis alphabetically a first name that would be Basu. I just merged the last we had issues with being equivalent with the gas costing because I basically needed to rewrite our gas costing for ext call so I merged that and Now Besu and EVM1 create identical traces when you filter them out to their gas costs and most of the other critical items for the trace I'm about to merge it into Main into. Into Ethereum Main it's going to activate on a fork name prag EOF for mainnet not for mainnet for like Genesis files but for reference tests it still activates on the progname so that's what we're going to go forward unless we until we hit at least DevNet2 in Pectora. Let's see next on the list would be Dragon Ref updates.
00:02:34.455 - 00:02:36.375, Speaker A: Yeah.
00:02:38.635 - 00:03:25.795, Speaker C: I run the test suit that we had and I didn't have Prague updated there so I had some few test failing that I fixed. I still have tests related to UF Create that need to fix. That's mostly on the red side. We are adding support inside the Foundry because if the REVM is supporting uf it can be easily included with the new solid compiler. So after the problems with UF Create are just inside revm it's probably going to be just. Yeah, it's going to pass inside Foundry and can be used.
00:03:28.695 - 00:03:29.151, Speaker A: Cool.
00:03:29.223 - 00:03:29.887, Speaker C: That's mostly it.
00:03:29.911 - 00:03:35.475, Speaker A: Yeah, cool. EVM1.
00:03:37.655 - 00:04:05.365, Speaker B: Not many updates from EVM one side I think there was to merge this tweak that we disallowed truncated data in top level containers, but that mostly affects testing and I don't see anything else here. We have still the INIT code, mode validation, change in review in progress and that's it I think. Unless Pablo can want to add something.
00:04:07.465 - 00:04:10.417, Speaker D: No, I. I can't remember anything else.
00:04:10.601 - 00:04:45.775, Speaker A: Yep. Cool. Do we have anyone from GU on the call? Anyone from Aragon, Ethereum, js? Okay, Any other clients I didn't name? Cool. Next item is compiler updates. Charles, anything from Viper?
00:04:47.915 - 00:04:52.375, Speaker E: No, sorry, been really busy with the big release.
00:04:52.845 - 00:05:15.741, Speaker A: Okay, that's fine. Do we have anyone from Solidity on the call? Okay, the Solidity proof of concept got a few updates this last week. So this is from Peters writing this or. No, it's not, Peter.
00:05:15.773 - 00:05:16.345, Speaker B: It.
00:05:19.555 - 00:06:12.663, Speaker A: Yeah, the big, the big difference is timing wise has also been added to some. Some of the information. Other than that, it's pretty much the same information as last week. Just got a better organization and answering more questions as they come up. Go ahead. Oh, Victor, are you muted? Okay, so that's, that's. Any other compiler updates before we go into spec updates? All right, so for spec updates we got three items, two clarifications, a discussion on INIT code, and also one that I forgot to put on the agenda that came up during testing I mentioned in chat.
00:06:12.663 - 00:06:39.585, Speaker A: Has to do with the address during EOF create. It's probably just gonna be a spec clarification. It's something you don't think about until you start getting devious tests written against your code. So the first proposed change is requiring max INIT code during validation. Peter, you want to lead the charge on that?
00:06:39.705 - 00:07:02.405, Speaker B: Yeah, we have. I have pitched this on the previous call and I think it's. We got some agreement that this is okay, but I just wanted to make sure that nobody has any objections before we merge this. So I think Pavel was on board and you don as well. I think I've.
00:07:02.745 - 00:07:03.809, Speaker A: Yeah, I don't know.
00:07:03.857 - 00:07:37.679, Speaker B: That was a different. Different one, but I don't know. Maybe you're okay with this then? Also, Solidity said we had. We had thoughts whether this limit would not impact Solidity testing, but it. We confirmed that it would not. And I think also this popped up in the recent discord discussion with Marius from that and I think this PR link was mentioned there and he was like, okay with this? I think. No, I haven't heard any objections.
00:07:37.679 - 00:07:48.355, Speaker B: If there are any, please let to know now. Otherwise, can we assume that this is a goal?
00:07:48.815 - 00:08:43.855, Speaker A: Yeah, I mean we'll have to Hammer out the exact corner cases as we find them. But in general, one thing I would like is if we tracks max and net code is the size rather than a new constant or a doubling of max and net code. Because that's what's going to matter for the system for testing. I think we just need to have a flag where we take it off. Because as was mentioned on, on, on the discord, I think there's going to be valuable need for testing things like validation with absurdly large containers to ensure that we're really linear. For example a container with a thousand full code sections that contain nothing but call offs to each other. And that would be like 64 gigs, not 64 gigs 64 megs when you make sure that you know, validates within the appropriate gas schedule time so that that can be worked on later.
00:08:46.395 - 00:08:50.359, Speaker B: What do you mean linear in size or in some other aspects?
00:08:50.517 - 00:09:12.295, Speaker A: So we get, we get the gas that is charged when you create a contract. And we want to make sure that the time, you know, it grows per byte. So we want to make sure that the gas per second it would take to validate it doesn't slow the system down. So I guess we could say we want the time per byte to grow linearly rather than exponentially or parabolically.
00:09:14.795 - 00:09:19.575, Speaker B: But that would be just like one of test, not newest integration.
00:09:20.035 - 00:09:22.603, Speaker A: Exactly, exactly. That would be a one off test.
00:09:22.659 - 00:09:26.775, Speaker B: Yeah, well that can be accomplished with just tweaking the implementation I guess.
00:09:27.195 - 00:09:34.043, Speaker A: Yeah. So that's, that's the only thing that would implement this max code size. But like, like you mentioned it's one off and doesn't need to be repeated regularly.
00:09:34.139 - 00:09:34.975, Speaker B: Got John.
00:09:38.075 - 00:09:53.275, Speaker A: Oh, Bar has an update for clients from Marius passing 231, 232 validation tests. Have looked at state tests haven't. Can't make the call today. Okay, so we got updates. That's good numbers from gu. Mario, you raised your hand.
00:09:54.695 - 00:10:00.815, Speaker F: Yeah. So this extra large UF test do we want. I don't think we want this in state test.
00:10:00.855 - 00:10:01.055, Speaker E: Right.
00:10:01.095 - 00:10:12.405, Speaker F: Because in state test it would mess a lot of. A lot of things. So do we want this on a Neo F test fixture? Is that the idea?
00:10:13.545 - 00:10:44.441, Speaker A: So yeah, I think that would be the right place to put it. We will. I mean we. That would like make the test size really large. I almost wonder if we need to have a separate, separate torture test that is not distributed as part of normal tests where we keep the torture tests. We just torture the implementations maybe once or twice per fork to make sure these extreme. I mean this is an extreme measure because we could keep all the 48k tests to make sure everyone's in time with just 48k things.
00:10:44.441 - 00:10:57.045, Speaker A: But when we're going beyond the scope of the limitations, I don't know that we. Yeah, I mean, we want to make sure we dismiss 4 megabyte test, but a 64 megabyte test. But do we want to put that in the test cases?
00:11:01.225 - 00:11:07.565, Speaker F: Another option could be that we can request the client teams to add this as a unit test.
00:11:07.945 - 00:11:08.329, Speaker A: Right.
00:11:08.377 - 00:11:09.521, Speaker F: Initials.
00:11:09.593 - 00:11:09.825, Speaker A: That.
00:11:09.865 - 00:11:16.345, Speaker F: That's an option because we can keep it out of the fixtures. It will mess with the format, but they still get.
00:11:16.425 - 00:11:16.737, Speaker G: Get.
00:11:16.801 - 00:11:19.485, Speaker F: Get some kind of feedback from. From this test.
00:11:20.785 - 00:11:21.605, Speaker A: Yeah.
00:11:23.945 - 00:11:24.281, Speaker E: Yeah.
00:11:24.313 - 00:11:34.387, Speaker F: I mean, we can design it. Design the test and then just distribute it to the. To the teams and make sure that they are adding it to some unit test somewhere in their code.
00:11:34.571 - 00:11:52.027, Speaker A: Okay. Yeah, we can design, test and have the Python spit out the test. That. Yeah, that. We can do that. Okay. So, yeah, so we just need to get this spec up.
00:11:52.027 - 00:11:57.785, Speaker A: Where does this go? 35. 40. Yeah.
00:11:58.805 - 00:12:07.458, Speaker B: Yes, yes. Like the general code validation goes. Sorry, the general container validation goes into 3540. So.
00:12:07.580 - 00:12:08.067, Speaker A: No.
00:12:08.189 - 00:12:08.677, Speaker B: Yeah.
00:12:08.799 - 00:12:09.286, Speaker A: Okay.
00:12:09.408 - 00:12:40.885, Speaker B: This has two sections. One has for general EOF and the other is for general EOF V1. So it's. It's like an editorial decision whether. Where do we actually put it? I think UFC 1 is better, but it's just a matter of days, I guess. Doesn't impact a lot.
00:12:42.385 - 00:12:45.925, Speaker A: There's no specs in 7692.
00:12:47.875 - 00:13:05.739, Speaker B: I don't know. Can you go back to where you. Maybe this mention which you were following was just a coincidence? I don't know. I think it would go to 3540. This one. Yes. Because it has container validation rules here.
00:13:05.739 - 00:13:06.895, Speaker B: Oh, just.
00:13:07.195 - 00:13:07.819, Speaker G: Just.
00:13:07.947 - 00:13:22.585, Speaker B: There you go. AOF version one validation rules. So these are sort of separate from code validation rules, which are different to eip. And I would see that particular rule being added here.
00:13:23.405 - 00:13:42.685, Speaker A: Okay, cool. All right, so get that spec updated. Next is there's a minor update on our jumps and successors for bin creation targets. Oh, yeah, this is. This is here.
00:13:42.985 - 00:13:44.765, Speaker B: This is my specific thing.
00:13:49.505 - 00:13:58.765, Speaker A: Yeah. So this one we're adding R jump. V. No, R jump is okay. And I think everyone's tests had that already.
00:14:06.795 - 00:14:12.211, Speaker C: Yeah, I think this was just clarification that Mario's stumbled on. Yeah.
00:14:12.283 - 00:14:19.347, Speaker A: Yep. Yep, That's a good one. And the next one. Right, right.
00:14:19.371 - 00:14:20.975, Speaker B: This is. This is not contentious.
00:14:21.715 - 00:14:50.985, Speaker A: Right. So basically, if you're in the middle of doing an EOF Create, either from a Create transaction or an EOF Create operation. If you call out to a legacy contract and they call out to the address of the contract that is in process of being created, it will come back as an empty account. And I think that's just, you know, there's. We can't. It's not EOF until it's been validated, so we can't say it's eof. And just like Legacy, there's no code that exists.
00:14:50.985 - 00:15:21.035, Speaker A: So we'll just do the existing code behavior for legacy that if you try and introspect the code mid creation, you get nothing. And that for most implementations should be a no op, but it's worth encoding and enshrining in a spec and.
00:15:22.455 - 00:16:01.915, Speaker B: Okay, so the last one is there's a lot of editorial change here, but the second bullet. Actually there was a rule proposed on the EOF call that we, well, disallow sub containers referenced by both return contract and EOF Create. Yeah, the diff is bigger because I'm also removing the definitions here, but that's like separate but last. Or the last line here. I think this was suggested by Andre, but he's not here today, I think.
00:16:03.655 - 00:16:26.033, Speaker A: Yeah, and I don't think we have test for the 298 line and I'll write that up. So I'm fairly certain BESU allows unreferenced containers and that it passes. The test to me indicates we don't have a test, so we need to. I wasn't sure if this had made the spec yet, but now that it's in there, I'll definitely add it.
00:16:26.089 - 00:16:53.065, Speaker B: Well, this, this PR doesn't add this line. It just changed the wording. This, this PR adds the last line to 99. And this is what I don't know, we potentially need to discuss. Yeah, if you, if you actually go follow the link which is in the PR discussion, in the description.
00:16:53.765 - 00:16:54.101, Speaker A: Yeah.
00:16:54.133 - 00:16:57.545, Speaker B: Here. This is the broader context.
00:17:04.485 - 00:17:07.475, Speaker A: So would we ban revert invalid onlys.
00:17:07.645 - 00:17:15.155, Speaker B: Or not really like, option one is banning revert invalids.
00:17:16.775 - 00:17:23.271, Speaker A: Okay. Option two would allow those and you would still have to. Okay. We just didn't force it.
00:17:23.343 - 00:17:33.475, Speaker B: Yeah, you cannot. Yeah, you can. You can't have such a container, but you cannot reference it in both EOF create and return contract.
00:17:35.405 - 00:17:36.265, Speaker A: Okay.
00:17:38.085 - 00:17:42.745, Speaker B: Which I think has practical benefits.
00:17:45.285 - 00:18:13.395, Speaker A: I'm sure some genius will figure out a way to make a DEX out of it or something. So we should probably leave it. Okay. Anyone have commentary on this or should we go ahead and add it all Right. Maybe.
00:18:14.135 - 00:18:37.205, Speaker C: Maybe I have like question for clarification. This adds additional validation basically validation on if the container contains only stop, return, return contract or it doesn't or it does contain only return contract. But I'm not exactly sure what we want to check.
00:18:38.785 - 00:19:27.435, Speaker A: So the way I implemented it in base zoo, when I recurse in the sub containers, I put in a flag in a sub container for how I was referenced from the parent container, whether I was referenced via EOF create or return contract. And based on that I have validation rules for stop, return and return contract. If I was referenced by EOF create and I see a stop or return, I raise the validation error. Similarly, if I was referenced by return contract and I see a return contract in the container referenced by the parent by that reference, then I do a validation error. So that's, that's the impact of this is if you do a return contract or an UF create on a container that has one of these band operations for that type, then it's a validation error and I detect it while I'm in the sub container.
00:19:28.055 - 00:19:34.755, Speaker C: Okay, that makes sense. Okay, I still need to add that. But yeah, it makes sense to add those.
00:19:35.335 - 00:20:21.555, Speaker A: Yeah. So we just need to add validation tests for that. Yeah. All right. Any other questions or concerns about this? Okay. Our Spark updates are getting much shorter and they're going along the lines of this is what we've been doing, let's validate it. So I think that's really good indication that we're actually closing in on zeroing and I'm finally being complete with multiple implementations.
00:20:21.555 - 00:20:29.175, Speaker A: This is good testing updates. I don't know who wants to take the testing updates.
00:20:32.155 - 00:20:33.535, Speaker F: I guess I can start.
00:20:33.995 - 00:20:34.855, Speaker G: I've.
00:20:35.275 - 00:21:18.765, Speaker F: I think Most of the PRs are already merged. There are some couple of outstanding ones, but please check if there are review comments that need to be sorted out. I think mostly most of the comments are regarding duplicated tests. So we have this legacy containers PI which I created like more than a year ago and I think it's like very convoluted. It's not worth to have this. So if you guys find a test case that it's duplicated in this file, please just take the opportunity to remove it in your pr. So yeah, if you see this comment, just please, please go ahead and just go into this file and remove the duplicated test cases.
00:21:18.765 - 00:21:53.285, Speaker F: But yeah, I think there's not much to it, but only that there's PRs progress in PRs merged and just implemented. We made two releases I think UFO for EOF if you guys find any issues with the fixtures that are being produced, please just reach out. We can, we can fix them otherwise. Yes, yeah, yeah. For, for versioning, I think Dan is the one. Let me see if he's. He's here.
00:21:53.625 - 00:21:56.525, Speaker A: I see him. Is he close to his beep button?
00:21:57.705 - 00:22:45.995, Speaker G: Hello, everyone. Yeah, it's done here. Yeah. So in the R and D discord, I've had a bit of interaction with Piotr and Pavel about maybe trying out EIP versioning with. With eos. And so basically, I mean, a TLDR is. Basically I've been working on an EIP to introduce versioning for EIPs that we're looking at right now and the proposal is still in draft status, but we could potentially like test, like take EOF as a pilot project for this and start versioning the EOF EIPs.
00:22:45.995 - 00:23:23.305, Speaker G: And basically this could help us with the testing pipeline in order to make sure that the test version and the client versions are using the same version of the spec. So if you're interested, I've been basically prototyping a very minimal version of it in the test framework. I don't. Obviously we don't have it on the specs, as in on the Ethereum AIPS side yet, and we don't have it on the binary side yet, but I'm happy to start ramping this up if there's interest.
00:23:25.935 - 00:23:35.835, Speaker A: So I'm reading through this. Is the versioning now handled by tooling, and we have to put major minor or patch in one of the commits and the tooling figures it out.
00:23:36.615 - 00:25:03.221, Speaker G: So that would be the end goal. Yes, but I think we're quite a long way away from that. I mean, if you have a look at the Eth Magicians thread, there's still quite a lot of discussion about whether we want to apply a semantic version at all. And I think before any development work gets done on tooling, this should go to all core devs and be discussed in a broader scope before tooling for the IP's repository gets. Gets implemented. But there's maybe a soft version what we could go for. As I've understood from discussions with the EIP editors, if we moved this 7577 to review status, then we could introduce a changelog section in the eips that want to use versioning and as long as we add 7,577 to the requires preamble of the IP that wants to use it, so exactly, we could start adding a section as Dano is showing here, and Assuming it's ordered, which I'm sure it would be, we could make some tooling to pass the first version list in the change log and use that as suspect version from the client side.
00:25:03.221 - 00:25:26.305, Speaker G: What it needs is basically any binary that touches testing. So anything that gives us a result, like the transition tool or the EOF pass tool, should get a new flag minus, minus EOF minus versions that would give us a JSON with a lookup of EIPs and their respective version that are implemented in that binary.
00:25:27.405 - 00:25:30.705, Speaker A: Do we have a prototype of what that JSON file should be?
00:25:32.045 - 00:25:52.825, Speaker G: There is a. Let me just see if I've got the link in there. There is a. This Discord discussion, and I think I did add a version at the top. I can add it somewhere else if it's a bit lost in discord here. I think you'd have to scroll up to find the JSON version.
00:25:53.365 - 00:25:53.901, Speaker A: That's.
00:25:53.973 - 00:27:15.955, Speaker G: That's the post from today. So something like this. So, I mean, this is, this is one of the big questions about the proposal is whether that's an acceptable amount of work for client teams to maintain in their implementations. But basically every binary that implements an EIP would have, in order for this to be useful, would have to provide the testing framework with this output so that we could then compare the client implementation version with the testing version and with the version that we would pass from the change login, Ethereum eips the tooling. So the tooling on the, on the, on the Ethereum EIP side. I mean, I would hope that essentially the change log section could be written automatically from tooling based on the commit message and the PR title, for example. Okay, but I think we're, we're a long way off getting the tooling into the IPs, but we're quite close to having a soft version where we could add a change log and then start using it within the test framework.
00:27:22.655 - 00:27:29.085, Speaker A: Okay. See what I can draft up this week.
00:27:32.625 - 00:27:46.565, Speaker G: I should let you know that I'm going to be away out of office for basically the next two months. So I'm very happy to make a push today and tomorrow and Friday.
00:27:47.065 - 00:27:51.325, Speaker A: No, not today. Tomorrow, Friday. No. We can come back to this in two months.
00:27:52.425 - 00:28:03.805, Speaker G: Okay. I mean, failing that, Mario said he'd be happy to pick up the work on the test framework side. And although I'll be away, I'll be following progress on 7577.
00:28:05.825 - 00:28:06.645, Speaker A: Okay.
00:28:10.385 - 00:28:19.405, Speaker G: I would, I would still try to get things ready on our side before I leave in the to a state that Mario could take over.
00:28:23.445 - 00:28:26.065, Speaker A: Cool, that sounds good.
00:28:29.765 - 00:28:30.945, Speaker G: All right, thanks.
00:28:34.885 - 00:28:39.745, Speaker A: Any other test updates or anyone else have any commentary on testing status.
00:28:42.285 - 00:29:03.965, Speaker H: Regarding the versioning? You can do fix or feed or feed with an explanation mark in order to bump specific versions if it's just a fix or a feature or a breaking change which requires major update. So this definitely could be automated by a commit.
00:29:04.705 - 00:29:07.529, Speaker G: Okay, yeah, that's. That's the basic idea.
00:29:07.577 - 00:30:06.615, Speaker A: Yeah. Cool. Anyone else? One last topic on the agenda. There was a late ad that I put in there. So the last item that I put on, as I mentioned in chat, is the question of devnets. From what I recall from our all core devs last week, which is by the way, anyone not listening to all core devs, EOF is currently slated for Prague. That was less than a week ago, but it's coming in Prague, but it's not targeted for the next test net 1 devnet 1 and it may or may not be in devnet 2 depending upon client readiness.
00:30:06.615 - 00:30:46.555, Speaker A: But what we could do before we join the formal devnets is we could work together to set up our own internal devnet. But the question, one of the questions there is how do we activate eof? Do we activate EOF requiring devnet one features? Do we set up the test. Net requiring Cancun in plus EOF which might require some more configuration on some clients? Or do we just be patient, wait for DevNet 2 or DevNet 3 and just rely on most of our client testing to make sure that we're still compatible? So any thoughts, Barnabas?
00:30:47.935 - 00:31:15.685, Speaker H: I would actually recommend to have an EOF specific fork activation and an EOF specific like fork epoch where all the EA clients can just fork completely outside of the scope of Prague at this point. So I would just build it on Cancun. I don't know if that's resemble for all the client teams, but it would be the easiest to test by far without touching any other code base.
00:31:17.305 - 00:31:20.965, Speaker A: Okay, so Cancun EIP7692.
00:31:22.905 - 00:31:44.415, Speaker C: From Red side it's a little bit easier to extend Prague and just have another fork proc pull cof that's easier solution because we don't have like features. We have like level where the fork is enabled. We cannot basically disable previous fork.
00:31:47.835 - 00:32:14.145, Speaker H: Could you not trigger EOF at a different activation is on like an EOF time where you say on this epoch time you want to trigger eof. And if we have prog set. Not prog yeah, pro set to a date that is well in advance then proc Will not be triggered but EOF would be.
00:32:15.205 - 00:32:33.315, Speaker C: It could be done a little bit hackily but it's like if the prag indent format get activated it means and even UF is get activated. We can add like code features that going to say disable that like build. But yeah, it can be done.
00:32:38.135 - 00:33:13.047, Speaker A: How does nethermind approach forking? Did we lost another mine? No, we haven't. Ahmed. He must be away from his pause button. I know for beu we also have a similar issue with it that Reth has. All of our forks are very combined together. It's every, all, everything or nothing. So in each fork so it builds off of a previous fork.
00:33:13.047 - 00:33:40.385, Speaker A: So I have written in basic code to support both, but I basically had to write two different forks. A Cancun EOF 7269 and a Prog EOF fork. So that's the work it would take on Basu is we just basically would need to make two separate forks succeeding Cancun or succeeding Prog. And if we want to activate Prague it gets kind of. Kind of weird. But I was able to figure it out. We don't have.
00:33:40.385 - 00:33:55.185, Speaker A: We don't support the feature get proposed years ago which is fork plus a bunch of VIPs because we don't activate EIPs individually per se. I wish we had geth on so geth could speak to their forking per process.
00:33:56.125 - 00:34:15.005, Speaker H: Nevermind does activation per EIP high. Ok, so I'm not sure if they would do that for EOF as well. But previously that's what they done. And all of their Joneses file has to include EIP specific activation time.
00:34:16.105 - 00:34:16.965, Speaker A: Okay.
00:34:20.545 - 00:34:31.645, Speaker H: Gu does it based on just a single whatever like prog time. But I don't know if they did that for EV yet.
00:34:33.874 - 00:35:05.895, Speaker A: I could try and pick apart Marius's fork, but I don't know how easy it would be to swap between the two. I mean it got easier this last week when 3074 got removed. So that did simplify a bit. So there's no opcode level changes coming in right now before eof. All of the changes all around the transaction processing and the withdrawals and stuff like that. So it did get a little easier. I was able to factor it out.
00:35:08.075 - 00:35:12.027, Speaker C: Only changes to precompiles blsd.
00:35:12.091 - 00:35:22.575, Speaker A: Oh right, we added precompiles. That's the change. That's the big change. It's one line to one test that I always forget until the last moment. So yeah, that makes sense.
00:35:24.275 - 00:35:54.745, Speaker C: In general from how I see it, they're not big overlap between EOF and DevNet zero. So in that having that in mind just extended DevNet one to just having EOF basically doing proc plus EOF seems reasonable to me. If people want to do it like more clearly, like separately, like having can compose uf, I'd be fine with that. But we prefer more like proact plus eof.
00:35:57.085 - 00:36:21.475, Speaker A: Okay. And one advantage I see about prog plus EOF is it requires prog to be implemented before we can add on eof. So all the other features for prog need to be put in place before we can activate eof, which would help address the issue that EOF is stealing resources from the rest of Prague. If we have to get the rest of Prague done first, we can't steal resources. So.
00:36:23.775 - 00:36:24.795, Speaker C: That'S true.
00:36:30.215 - 00:36:47.795, Speaker A: So it doesn't sound like we're going to come to consensus on this call. So I'd encourage all the teams to think about it, talk about it maybe on the Discord chat group because devnet1 is going to take at least a month and devnet2 is at least two months out. Is that a correct guess? Barnabas?
00:36:50.135 - 00:37:04.795, Speaker H: We are just waiting for the consensus back to be merged. So that might be tomorrow and then a week after that we can probably launch that one. So I would expect maybe end of the month for them too. Possibly.
00:37:05.735 - 00:37:09.555, Speaker A: Oh end of June before July. Wow. Moves quick.
00:37:10.375 - 00:37:14.405, Speaker H: Depends many changes there will be and how stable it is.
00:37:14.705 - 00:37:17.737, Speaker A: Yeah, and it depends if EOF makes Devnet 2 or not.
00:37:17.841 - 00:37:48.183, Speaker H: So okay, so it really depends like how do you guys want to trigger it? Because if we can, if we could trigger EOF all EOF features without touching any prog code because prog code at this point is pretty much untested. So like it would be very good if you could just test EOF on its own without any other headache and but it feels like that's not reasonable from Rest and Resume.
00:37:48.239 - 00:37:57.871, Speaker A: So yeah, I think we need, we need to hear from Marius before we try and move towards a consensus direction or someone else on the Geth team for their implementation.
00:37:58.063 - 00:38:06.885, Speaker H: Yeah, I guess Marius what their what his preference was for for eof. You can proceed from that.
00:38:07.185 - 00:38:08.385, Speaker C: Okay, we can do that.
00:38:08.465 - 00:38:17.485, Speaker A: All asking okay so we'll move this async Any other topics people want to discuss relating to eof.
00:38:22.305 - 00:39:04.755, Speaker E: I posted in the chat but I think that we should visit the GAS schedule because according to the Solidity POC article there's like a somewhat large mismatch now I think because jump dust analysis is already like you don't need to do it anymore. I think basically the. And also, excuse me, stack checks at runtime, I think a lot of the small opcodes, dupe, swap, add or whatever should come down by one or two gas.
00:39:06.775 - 00:39:29.215, Speaker A: Okay. So for large scale gas changes, I know we're going to have a lot of large scale gas changes in vertical. So I'm hesitant to do anything before then since we're going to be blowing up the world in Verkle anyway. At least for the storage operations. Paul has his hand up.
00:39:32.235 - 00:40:14.541, Speaker D: Yeah, I have some comments about it. So first of all, this JAM DIS analysis that showed up in Solidity benchmarks, I think this is not really accurate to regular client. So most of the issue is that we don't have any caching for this or any maintenance in EVM1 as the testing tool. So it just like performs the JAM Desk analysis first time it sees the code and that's repeated over and over in the loop. If you benchmark this somehow. So that's why it kind of screwed the results. So we in the end disabled this as well for legacy.
00:40:14.541 - 00:41:12.845, Speaker D: So I think it's like more comparable. I know they're the full client implementation, they need to carefully handle this separately and I think this number doesn't reflect the full client in this way. Yeah, but definitely you don't have to do it for uf, but it's hard to tell how much performance you get from this. Like for Aragon, I currently try to rework code for that. And the jam, this analysis is like almost zero percent of overall execution time because it's just cached by. Yeah, that's like for like 5, 5, 5,000 recently used accounts and it's kind of, it's kind of close to zero. So yeah, so mostly we just disabled that to have more comparable results.
00:41:12.845 - 00:41:46.815, Speaker D: Secondly, I think the GAS drops with eof, the solidity compared to eof but also the execution time drops more or less comparable amount. So I think this actually means the GAS is actually accurate before and after. That's that second comment and anything else maybe that's, that's. That was all I wanted to say.
00:41:49.555 - 00:42:05.865, Speaker E: Yeah, I don't know. I mean like part of the draw of EOF is like we don't have to do a lot of the analysis at runtime like pop and knob jump test.
00:42:06.965 - 00:42:36.315, Speaker D: Oh yeah, that's one more thing. Yeah. In EVM1 we don't actually disable stack checks yet and I think it's unlikely that we'll disable these for EOF release. It's like it's, it's change that gives you like maybe 5, maybe 10%. But we didn't.
00:42:36.775 - 00:42:37.279, Speaker A: We.
00:42:37.367 - 00:43:17.605, Speaker D: I think we will limit the number of refactoring we do to EVM, I think partly because EOF was in EVM1 for like two years. And yeah, I think at this point it doesn't really make sense to kind of write it again. Probably some sometime later, definitely. But I think it's a bit too risky to do it right now. So. Yeah, I also think we can revisit like many gas schedules, but I kind of see it that this is probably something to do later than in the same time we shipped eof.
00:43:30.305 - 00:43:41.805, Speaker E: I think in a theoretical future where there's like native compilation, the calculus is all different.
00:43:43.875 - 00:44:20.121, Speaker A: So gas is not just a direct measure of time spent computing. It's also, I mean, we get to the multidimensional gas, sometimes it's used to pay for storage long term. It's also going to be used in vertical to pay for data that you add to the witness, not necessarily computation time. So that's, you know, one argument against using strict computation time against it as a guide. But again, bringing up ferql, we're blowing up the gas schedule there. If we do that, that would be a better place to do it than in Prague. Okay.
00:44:20.233 - 00:44:23.125, Speaker E: Yeah, I just thought it should be kind of revisited.
00:44:29.585 - 00:44:41.515, Speaker A: Okay. Any other comments? All right, I'll give everyone 11 minutes back. Thank you for calling in today. We're getting some great progress done.
00:44:43.935 - 00:44:47.235, Speaker C: Congrats on including UF side pr.
00:44:48.535 - 00:44:49.355, Speaker A: Yep.
00:44:52.255 - 00:44:53.035, Speaker C: Bye.
