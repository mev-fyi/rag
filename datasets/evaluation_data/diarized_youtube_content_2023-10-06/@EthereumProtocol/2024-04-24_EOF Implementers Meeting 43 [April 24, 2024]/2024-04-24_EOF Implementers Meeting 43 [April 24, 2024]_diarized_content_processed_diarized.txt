00:00:01.440 - 00:00:27.874, Speaker A: So this is UF implementers call number 43 24 April 2024. So our agenda is client updates, compiler updates, spec updates, test updates, and a list of other items. So client updates. Bayesu has been contributing to some of the tests using Baesu as a basis to validate the tests. Some bugs and Baesu were found in the process. Fix those as we get them. That's why we write tests.
00:00:27.874 - 00:00:33.004, Speaker A: Next up, Marius, you want to talk about Geth?
00:00:36.264 - 00:01:48.404, Speaker B: Sure, yeah, so we, I'm passing all the EF validation tests and I have still a lot of EF stack tests failing. But I think over the last week I fixed around maybe 20 or $30 that we had in the implementation. And yeah, so far it's kind of progressing okay ish, I would say. Yeah, just, just cracking on with the validation stuff. And it's been sometimes kind of hard to understand what the tests do. So the tests in the test report have, except for the name, they don't really have any explanations to them. And so sometimes it was like, I don't know, most of the time it's just spent reading the raw bytecode and trying to understand what the test tries to do.
00:01:48.404 - 00:03:39.994, Speaker B: So if we want to port them, or if we're porting them, it would be really nice. We could have like a, like a good description for each test case, what it tries to achieve, so that it's, it's easier to see what the bug is in your implementation if you don't, if you fail it. Otherwise, I think the test coverage, at least for the validation, is kind of okay. There were some, one thing that I found was I could often, I would make a lot of tests pass with some buggy implementation. And there was, maybe there was one test that would fail and I would like realize it and then fix the implementation, and then all of the other tests would be passed as well. And then there was one time where I fixed something in a wrong way, but it passed every test. So, um, the, the case was if, um, if a subsection, if a subsection is truncated, but also the, so we have this rule that the data size has to match the data length if you want to deploy.
00:03:39.994 - 00:04:22.650, Speaker B: But what I implemented is that it matches the data length of the contract that deploys it. So the outer container basically. And that passed the test, but it, but it's kind of wrong. So I realized at some point it's just wrong and fix it anyway. There are, there are some, but it's also very hard to make it to create a test that tests this exact thing anyway.
00:04:22.722 - 00:04:25.854, Speaker A: Could you share what you did have that briefly past?
00:04:27.474 - 00:04:33.690, Speaker B: Yes, I'll share it in the chat because it's, I have to dig it up again and it's hard to.
00:04:33.802 - 00:04:34.694, Speaker C: Hard to.
00:04:35.274 - 00:04:35.906, Speaker B: Reasonable.
00:04:35.970 - 00:04:59.598, Speaker A: Yep, that's, that's understandable. But if you get tests that you think that are interesting, please share them. We can always add them to the corpus. I think those are valuable, even if, even if it's stuff that you fixed. Okay. Marius went on mute. Dips along.
00:04:59.598 - 00:05:12.678, Speaker A: Anything from Evm? One going once, going twice. Doesn't look like it.
00:05:12.726 - 00:05:29.404, Speaker D: Yeah, we have merged, you have create NTX create by now. And we have one pending fix for the rule about unreachable code sections. And otherwise we are up to the current spec.
00:05:34.064 - 00:05:49.814, Speaker A: No nethermind, no ethereum, j's, no Aragon. So I think next is compilers. Daniel Charles, who wants to go first?
00:05:52.274 - 00:06:25.284, Speaker E: Yeah, I mean I can start. Yeah, I mean I'm basically here because Ipsalon told me it would be good since you have this schedule for considered for inclusion now to join these calls again, we still, implementation wise, have the implementation of the Shanghai version of VOF, and now wondering what the guarantees are of the mega UF specification actually happening, which would mean that we can allocate time to update the implementation to that version. And that's basically a date from us summarized.
00:06:27.744 - 00:06:31.804, Speaker A: Okay Charles, anything from Viper?
00:06:32.504 - 00:06:34.924, Speaker C: No, same status.
00:06:36.544 - 00:06:43.604, Speaker A: So what level of guarantees do the two of you need before you can start implementing? What changes need to be set in stone that won't change?
00:06:57.904 - 00:06:59.004, Speaker C: Who's asking?
00:07:00.604 - 00:07:22.664, Speaker A: Um, I'm asking for one. I'd like to know what's, what should be, um, implement what should be considered absolutely frozen and what could be discussed to be changed, if anything, what, what can we do to unblock compiler progress and if that's putting a lockdown on the spec, maybe we need to do that. And what that lockdown looks like.
00:07:27.944 - 00:08:35.714, Speaker C: I think that implementing EOF from the compiler's point of view is actually kind of complicated. Like maybe more complicated than the EVM implementation because it just like works very differently because you have to like basically completely redo how functions are compiled so it's not. So I mean, if somebody needs the compiler to implement it, then like what we would need to be guaranteed is basically like the container format and some of the basic call f, basically the subroutine and call and jump instructions. But if nobody needs it, we're just going to kind of put off productionizing it until the day before the fork or some reasonable time to allow for testing.
00:08:36.614 - 00:09:34.524, Speaker E: I mean I would have quite a different perspective there. I mean we have implemented the part of the Shanghai version of the O app and that's sitting there, not merged, but I mean in a state that can be revived for us it would be some effort to accommodate the contract creation changes. That's not entirely trivial, but also, I mean that's significant effort. But I mean what we really want is a prognosis of the likelihood of actually there being consensus of actually doing UF at some specific point in time, which then we would be very happy to provide an implementation for whichever version. Then what we really need in the specification is the DAPN and swap opcodes. That's what helps us the most. The other stuff, iterations on those, I mean not much of that is optional and it's well specified as it is, but I mean, minor changes around that we can accommodate because the code doesn't change that much depending on how the container format actually looks and stuff like that.
00:09:34.524 - 00:09:50.124, Speaker E: But yeah, the most important thing for us is to actually know that we can assume that in some particular hard work there will be EOF. And we are happy to, way before that, spend effort in providing an implementation.
00:09:50.904 - 00:10:22.304, Speaker A: Okay, that's good to hear. One of the reasons that I do want to unblock the compilers is there's been questions raised about what's going to be the net size differences, what's going to be the actual operational gas differences, if any. Is it going to be like double 20%, 1%? Is it going to be noise? Those are questions that really are not answered well without an actual implementation of compilers. So that's my interest in trying to unblock and get things progressing.
00:10:23.884 - 00:10:36.544, Speaker E: We have good data from the previous version of EOF that increased our metrics in both gas cost and code size. I don't think that the changes in creation and the code intersection changes will have much of an effect on any of that.
00:10:38.204 - 00:10:47.864, Speaker A: Okay, do you have benchmarks for those? Go ahead. Yes, benchmarks handy that I could reference, or should I try and recreate some myself?
00:10:49.244 - 00:11:06.566, Speaker E: I mean we did provide some data back then. I can look that up. We can revive the branch and do it again, but that's relative to the version of uh, at that point in time. So it's not actually the current specification, but and more probably it's not the.
00:11:06.630 - 00:11:08.114, Speaker F: Vertical version of it.
00:11:10.414 - 00:11:12.126, Speaker C: But that would.
00:11:12.150 - 00:11:13.094, Speaker G: Be a starting point.
00:11:13.214 - 00:11:15.154, Speaker A: I'd be happy with that to begin with.
00:11:18.174 - 00:12:05.274, Speaker C: Yeah, I mean we also have some data from the Shanghai version and it's like the, we actually had code size regressions because code sharing isn't, and Viper has, I think, always had very good code size. And the issue here is that code sharing is not as good after EOF, and because of the code sharing restrictions, which is that shared code basically needs to be put in subroutines, you end up with more code size versus gas trade offs than like in EIP 2315 world where you have the global code section.
00:12:05.934 - 00:12:16.430, Speaker A: Right, but isn't that why we introduced the changes in the stack height validations where it's a range instead of a fixed value which allows you to then outline for various ranges?
00:12:16.622 - 00:12:30.504, Speaker C: Yes, it's better, but there's still a gas versus code side trade off because the lower gas is to jump within a section. So if you want to outline it, then you need a call f instead of jumping.
00:12:31.204 - 00:12:41.264, Speaker E: Okay, I can just say that even with the previous stack validation version, we had code size improvements with that, they will be even better.
00:12:44.324 - 00:13:40.284, Speaker A: Okay, cool. So yeah, that's just an open question. And is there anything I can do to help unblock you on these? Let me know anything else for compilers before we move on to spec? Okay, I'm looking at the agenda. I see spec items and other items. There's some other items which are in spec items. The first spec item we need to finalize on was changing. Discuss the version without the regular state change, number 78, pulling TX create out, possibly from this revision, adding init code validation, discussing return data, zero padding, and some issues with ext cost and mid retained gas.
00:13:40.284 - 00:14:02.404, Speaker A: And I thought I put in a request for. I must not have put it in the right place to discuss EIP 7676, which was allowing address based expansion. Do we want to talk about testing or do we want to talk about spec first? There's a lot of things for spec that could consume the rest of the hour. Should we start with testing?
00:14:05.304 - 00:14:06.084, Speaker B: Yes.
00:14:07.064 - 00:14:17.422, Speaker A: Yeah. So, testing Demetri and Hugo and Mario, you're from the testing team, right? The three of you, or is Hugo Epsilon? I can't remember.
00:14:17.518 - 00:14:19.166, Speaker H: Yeah, Dimitri and myself.
00:14:19.350 - 00:14:26.994, Speaker A: Okay, how's the testing on EOF? Do you have any updates, any requests, any blockers?
00:14:28.654 - 00:14:32.194, Speaker I: Check up the group chat. I just posted a link to the pierre.
00:14:33.614 - 00:15:03.764, Speaker A: Okay, let me get my browser window ready so we can share this. Let's share screen. All right, so this is Kyle EvM. So is it this one or am I on the right? Is this the correct one you posted, or is there another one I should be showing?
00:15:04.184 - 00:15:21.924, Speaker I: Yeah, this one. So this is basically the same logic as retested was using. When you fill in py script, it will generate fixtures and it will check against exceptions error codes provided by evil one EOf parse tool.
00:15:23.984 - 00:15:40.044, Speaker A: Okay, so is this parsing the validation test or all the tests? UF parse. This is just doing the Uf parse.
00:15:40.084 - 00:15:42.064, Speaker I: Test on the UF parse.
00:15:44.324 - 00:15:57.304, Speaker A: Okay, cool. So this is something clients would need to implement EVM one's interfaces, or is this just relying on EVM one?
00:15:59.884 - 00:16:18.874, Speaker I: It currently works with EVM one and in the future we integrate other parsers as well. Okay. Yeah, so since it's a python, whenever you develop the test you might need another exception and you just add that exception in Python in amps as you go.
00:16:21.974 - 00:16:22.874, Speaker A: Okay.
00:16:24.614 - 00:16:37.364, Speaker I: If you need any help, this how this all works, just ping me and we can work through it. So I can teach how to use the PI script now compared to the JSON test we used to have.
00:16:38.184 - 00:16:53.324, Speaker A: Yeah, yeah, I've got it. I think I'm starting to understand PI scripts for these. Got a couple of, I've got tests for the data load operations and some tests I submitted for 7676 and draft that I need to update some of the do some reviewer comments on.
00:16:54.464 - 00:17:38.234, Speaker I: In this pull request there is an example test script file where you can see how the test is designed and to generate it, you use the same field command as with any other python. But yeah, it will require to have ERF parse executable installed in the path of the system to verify the exception. And other than that, Python script allows quite a flexible way of designing your code. You can like it creates quite sophisticated scripts, but not necessarily like you don't have to. It's better when the test is readable and small and simple, but it allows us to do many, many things.
00:17:39.574 - 00:17:43.718, Speaker A: Cool. Ypsilant, you have your hand up.
00:17:43.886 - 00:18:34.378, Speaker F: Yeah, this EOF parse, it's a tool that we did like for this older version when we were fuzzing EOF validation. I think that was running by Martin Svenda and I don't even, I couldn't actually find what the spec was exactly. I think we communicated mostly on discord and stuff, and I think many other projects actually implemented the similar tool. I know she has some issues with the user experience of that, because it really follows very specific kind of way of accepting inputs. I guess we can change that because the old fuzzer, I think it's not operational right now, or maybe we should kind of make it operational again. I think there's some discussion here.
00:18:34.546 - 00:18:46.374, Speaker B: Yeah, I think we should definitely make it operational again at one point. And I think the original way is to accept stuff from standard end, right?
00:18:47.844 - 00:18:58.516, Speaker F: Yeah, it follows exactly this. I just couldn't find where the fuzzer actually was. It was part of GoevM lab or something else. I don't remember.
00:18:58.580 - 00:19:10.500, Speaker A: Actually, Martin had written it. He would know. Okay, so that's comforting to hear. It's using the interface that we probably already have squirreled away somewhere.
00:19:10.692 - 00:19:27.584, Speaker F: Yeah, this kind of the same one. And that's why it's a bit like graph in some cases, because sometimes it doesn't report anything because just wait for the input. So. But I think if Dimitri made it work somehow, I think it's a good starting point for now.
00:19:28.124 - 00:20:09.774, Speaker B: Okay, so I wrote like, I extended our version of this tool to have, just like you can also pass in hacks or you can pass in a file name or a name to a folder, and it will run all of the tests in the folder. So the Geth EVM tool, or it's called EOf dump now supports like four different ways of running tests, basically. Yeah. I don't know if any other clients would want to implement this same thing for convenience.
00:20:10.314 - 00:20:51.634, Speaker F: Yeah, we can implement the same just like I think we need. It would be nice to have some graph specification. What exactly is expected? I can obviously copy your code, I mean, your kind of convention, but do you think it's enough to just like, I just wonder like if, how we can evoke this later, like if we want to change something, how to communicate the change. And so, for example, we can change something in the command line interface, but then maybe the execution spec test will be surprised about this.
00:20:53.614 - 00:20:57.114, Speaker B: I think it would be best to write down some spec for it.
00:20:58.094 - 00:21:09.254, Speaker A: Okay. I think one thing we're going to want is definitely a batch mode because even gets going to hit the startup penalty because it's a really quick function, so it'll be much more efficient to do it in batch.
00:21:12.874 - 00:21:17.034, Speaker B: I think that's kind of what the standard end stuff was.
00:21:17.114 - 00:21:20.374, Speaker A: Yep. Yep. That solves that quite easily.
00:21:22.674 - 00:21:51.734, Speaker B: One thing that I've, I've kind of noticed is in our Shanghai version, we actually verified the errors. Now because it's broken, we only verify that there is an error. Is there some spec for the error numbers?
00:21:53.664 - 00:22:37.630, Speaker A: No, there is no spec for the error numbers. What matters is that it passes or fails. And that's where it gets kind of tricky, where like if you submit a test with two separate errors, you're saying which error you have to test for first, which provides some restriction on the implementations. So that's one of my concerns with specifying a specific error. But the error could be informative in saying I'm trying to trip this problem and could help us write better tests so that only that error trips. Because I remember it was the BM 128 Bayesu had a bug where there was one test case that tripped two errors and there was one case that only tripped one of those errors. And the second error was hidden by that.
00:22:37.630 - 00:22:45.834, Speaker A: So there was no test case that tripped, only the grouping error. So that's why we want test cases that fail one way invariably.
00:22:49.314 - 00:23:22.714, Speaker B: Yeah, and I kind of have the feeling that some of the errors that I'm, or some of the tests that I'm passing is because there are two errors being thrown, one of them is the correct one. And yes, and apparently at some point there were error code specified. Okay, but maybe not anymore as we do testing.
00:23:24.614 - 00:23:28.234, Speaker A: We could probably build these error codes organically through testing.
00:23:32.054 - 00:23:57.974, Speaker H: So we have a list of exceptions for EF. Maybe we can make that the canonical list, at least for testing. I can share the link to the file and we can grow it as needed. So if you see that file that I sent just in the chat at the bottom, we have UF exceptions and maybe we can use this as the guideline.
00:24:02.774 - 00:24:13.674, Speaker A: Okay. And would we need to emit those exceptions or have some sort of mapping from our output to say this is the exception? How's that being handled in test?
00:24:14.054 - 00:24:47.162, Speaker H: So the exception is being written into the UF test fixture format in a string, so it has no number. What you would expect is if you scroll a little bit down to the bottom. There you go. So you have the class EOF exceptions. What you will see is you have exception and the name of the exception. So we have default exception right now because some exceptions are not mapped yet. But ideally we shouldn't have something like default exception.
00:24:47.162 - 00:25:20.114, Speaker H: We should have a specific exception for every single test. And yeah, ideally no test should fail with two different exceptions. If it's almost always possible to make the, to design the test so that it only hits one exception. There are very rare cases, but where it's impossible. Maybe if we find one of those, then we can decide what to do. But I think we should try to design every single test case so it is only possible to hit one exception.
00:25:22.494 - 00:25:40.226, Speaker A: Okay. There's no flag for fork version yet because it's all in one fork. So we can, we can skate around that for a little bit. Okay. Any other testing? Oh, go ahead.
00:25:40.330 - 00:26:07.394, Speaker H: Oh yeah, we can version the exceptions also if you guys want, we can. So we have this folder where we are storing everything that is related to version number one. Maybe we can just create the exceptions there. And if there's version, when there's a version two, we can just create another list of exceptions if necessary. But yeah.
00:26:11.014 - 00:26:11.990, Speaker A: Okay.
00:26:12.182 - 00:26:28.104, Speaker H: Also, to respond to Mars, it doesn't have to be a string. We can just easily change this to integrator errors. The names are only for only just to easily identify which exception it is.
00:26:34.764 - 00:26:46.624, Speaker A: Okay, one question I have. Are there any places where there are holes in tests where you might appreciate help from the client teams implementing some of these tests or informing what tests need to be done?
00:26:52.604 - 00:27:18.304, Speaker H: I don't have a concrete answer to that because I haven't looked at the spec changes. To be honest. I don't know if Dimitri has any info, but I think we will be able to maybe find more coverage issues the more we implement stuff. Because right now, yes, it's very early to tell.
00:27:18.684 - 00:27:22.184, Speaker A: Okay. If Solon's going to hand raise.
00:27:23.084 - 00:28:02.474, Speaker F: Yeah, yeah, I sent one pull request, kind of like testing how to write tests to execution spec tests, and I just think needs some guidance. What are the next steps? I think the current status is. So I picked like swap and Dupan as an example. I think the current issue for the pull request is just doesn't, it doesn't pass all of the python linter requirements. Not sure I should fix these or like. Yeah, it would be nice if you can take a look and give me some feedback. It doesn't have to be right now.
00:28:02.474 - 00:28:18.294, Speaker F: And if that process kind of improves, I'm happy to contribute more tests. I'm not sure that's expected. Maybe you want to have it fully under your control, but definitely we can put some resources into this.
00:28:19.754 - 00:28:39.454, Speaker H: Yeah, I can take a look. So yeah, I can see your pr. So back to question for Dano. Do you need a review on five two, which is the tests for EIP 7676? If so, I can try to do both. Both of them today.
00:28:39.994 - 00:28:53.374, Speaker A: Dimitri put a review on it. I mean, if you want to give a second review. I was going to. His changes sounded reasonable, so I'll go ahead and implement those both basically readability recommendations, but I was able to get it past the linter.
00:28:58.294 - 00:28:59.234, Speaker H: Sounds good.
00:29:01.454 - 00:30:01.584, Speaker A: Okay, any other tests, questions, comments before we move on from the test subject? All right, let's go through some of these spec issues. I'll go through them in order. Unless there's an objection. Discuss version without a regular state change. I think this is one we had discussed last week. And this is the changes, I think it is where we would take out the creator contract and replace it with the creation transaction semantics where we just combine the call data is the EOF container and the call data is that in here. This is just getting rid of the create legacy create.
00:30:01.584 - 00:30:19.118, Speaker A: So the first one is getting rid of the ise portion. Any concerns? Can we go ahead and move to finalize that? Okay, hearing no objection. And it's been up for a week version.
00:30:19.206 - 00:30:20.914, Speaker G: And can you share the IP?
00:30:21.694 - 00:30:50.424, Speaker D: Yeah, we published an AIP like with the same spec, basically that is in this pr. This is pr to mega spec and separately there is an IP now. And yeah, this is the same idea of putting both container and call data. It's call data into data transaction. Yeah.
00:30:52.204 - 00:30:57.584, Speaker A: Okay. And this, this coalesces all of the changes we discussed in it.
00:30:58.364 - 00:32:03.874, Speaker D: It's, yeah, it would be good to review, but basically, yeah, I think it's what we discussed mostly. We also discussed within the team another option of putting the constructor arguments into a data section instead. But yeah, given that in this version the tooling wouldn't need to change and can be used as is to deploy EF. And another concern that we had is forward compatibility with possible future special transaction type that will have like separate field for cold data. And then constructor arguments definitely go into cold data in those init code executions. And then, so what we have now should also be similar, like some take constructor arguments from call data, not from data section. So those are two arguments in favor of doing this concatenation into transaction data.
00:32:04.174 - 00:32:06.494, Speaker G: Well, there's one more that in this.
00:32:06.534 - 00:32:07.274, Speaker F: Version.
00:32:09.694 - 00:32:41.564, Speaker G: The init code and non init code has the same semantics in the version where it will be concatenated and considered part of data, then the compilers would need to know that they are in it code compilation context and then behave slightly differently, aka get the constructor arguments from data as opposed to from cold data. So I think these were like the strongest arguments in favor of the version we proposed in the new EIP.
00:32:47.064 - 00:34:09.464, Speaker A: Okay, just a second, I need to go deal with the plumber real quick. Any other questions or concerns? I'll have my headphones on it. Sorry about that. I'm back. So what was the opinion of the epsilon team? Is this okay to move forward or do we need to take more consideration of the alternatives?
00:34:14.983 - 00:35:05.453, Speaker F: I think that the big alternative is just to introduce, because what it kind of decouples the new transaction type from all of this. So like the big alternative to actually have the new transaction type and then you can nicely split these two buffers like init code container goes one way and the call data goes into other place. And yeah, I think that we can. It's mostly, I think the main decision point is do we skip to, do we skip this new transaction type in the first deployment IoF or not? And if we do, this is the solution to how to deploy the contracts without me transacting that.
00:35:06.074 - 00:36:03.758, Speaker A: Okay, so from a practicality perspective, I think skipping the transaction type is a requirement, will help get EOF over the line. It's really big and we need to look at things to cut and make things work within the existing system. So that's just my opinion on it. We can always come back later and add the extra transaction type. And I think this solution, as far as working with a new transaction type, isn't too much overhead to support. And it might be good enough that we might not need the transaction type until we support things like TX create where we need to allow smart contract wallets to create arbitrary contracts. But until we, until we settle on a account abstraction format that's going to be brought into the protocol, I think we actually need to wait until it's decided to see what that looks like before we get to committed to a specific solution with a new transaction type.
00:36:03.758 - 00:36:13.874, Speaker A: I mean it's, I kind of want to go forward with this as is, but if Ipsalon still has concerns, we should probably discuss it for another while, make sure that we're okay with it.
00:36:16.214 - 00:37:01.564, Speaker F: No, I don't think so. I mean, like, my opinion is kind of also slightly into kind of like delaying this new transaction type together with TX create. It's kind of a pack that goes together and they mostly depend on each other. And having this new transaction types enables kind of also nicer solution to this. And I think we can kind of swap these solutions later as well, in the sense that duplicate this kind of hacky hacking concatenation with the kind of nicer form. I'm not sure that the others from the team agree, but I think that was more or less sentiment on our side.
00:37:03.264 - 00:37:25.630, Speaker A: Okay, so since this is a new EIP, doesn't even have a number, I don't think we can finalize it, but let's put it on the schedule again for next week for bring up your concerns and let's try and get a decision on this next week. We definitely need a decision before our meeting in the middle of May.
00:37:25.742 - 00:37:31.238, Speaker E: So just to quickly confirm on that, the version with the concatenation is also.
00:37:31.286 - 00:37:39.206, Speaker A: Easier for us okay, all right.
00:37:39.390 - 00:37:45.904, Speaker F: But does it enable the decision about the TX create and new transaction type? I mean.
00:37:48.204 - 00:37:50.012, Speaker A: So what allows us, you.
00:37:50.028 - 00:37:58.784, Speaker F: Can do at least like pull request to the spec with the updates like this, do you think it makes sense to take.
00:37:59.884 - 00:38:05.064, Speaker A: Yeah, so is the mega spec the canonical spec now or is it the eips?
00:38:11.704 - 00:38:14.424, Speaker F: Sorry, we kind of, kind of were.
00:38:14.464 - 00:38:24.444, Speaker A: Talking, is the mega spec the canonical spec or is it the eips at this point? At what point do we switch over to the Eips being a greater source of truth than the mega spec?
00:38:27.824 - 00:38:39.784, Speaker D: I think mega spec is still the main spec for now, but we haven't merged this change, this particular change yet. So this is going to be updated I guess, soon.
00:38:40.164 - 00:39:15.564, Speaker A: Okay, so I guess we could merge it in the mega spec if people are okay with that being canonical, but that also opened up other questions. Does this open up TX removing TX create from the current mega spec and the txcreate init code transaction? Is that something we can move forward with with these changes? Is that or something we should work on? Marius prefers megaspec, so let's work with Megaspec being canonical and eips are artifacts we create to implement the changes. That's what you would prefer, Marius?
00:39:18.144 - 00:39:18.924, Speaker B: Yes.
00:39:19.464 - 00:40:21.334, Speaker A: Okay, so we'll go with the Megaspec being canonical and pulling out eips as we finalize stuff. So I guess we can go ahead and merge. Because we discussed 78 last week, there are concerns that are noted, but I think for expediency we should probably move forward with that. That also unlocks UF version without TX create and an itco transaction. Again, the concerns with how we would do smart contract wallets are noted, and those are probably best solved when we get the aa solution that we're going to protocol put in the protocol. Okay, the next on the list was init code mode and require validation of return contract. And this I think will solve some of the test case problems that Marius might have run into with truncated init codes.
00:40:21.334 - 00:41:19.654, Speaker A: This would require us to make sure that we have return or stops in non init code mode, and we have return contract in init code mode for each section, which shouldn't be too difficult to change from what we have. The biggest value add here is when we have EOF create a return contract create point to a subcontainer. That's when we can do the size checks. I don't think that's coded in here. So return contract can have truncated data. EOF create cannot. So that might be one thing we might want to add to 86.
00:41:20.794 - 00:42:15.920, Speaker C: Yeah. By the way, one thing, this should all be up to date with the latest reviews. One thing that I didn't say in the spec, but it's kind of a maybe implementation detail that people worry about, is that I think one concern is that it forces a dependency between code and what is this? Container validation. But there actually isn't, like you can decouple the validation you just have. While you're doing container validation, you do the. Basically, while you're doing each of code and container validation, you create lists of, you know, init code containers. I mean, you, you assign flags to every single container, and then at the end, when you've done all of it, then you just check that those two match.
00:42:15.920 - 00:42:17.324, Speaker C: And that should be very cheap.
00:42:20.384 - 00:42:27.204, Speaker A: Yeah, that was, that was my assessment of it too. It can still be done linearly in order. It's just a question of how you store the data.
00:42:28.024 - 00:42:33.614, Speaker C: Yeah, I mean, it can be out of order, actually. There's no, there's no strip dependencies between the two.
00:42:33.654 - 00:43:05.046, Speaker A: Right, right. There's lots of flexibility. Okay, so that was stuff we were asked to review. Any concerns, comments, or should we go ahead and move forward with this change with the caveat on the data truncation validation? Okay, we discussed it last week. No objections were raised. So I think we should move forward with it. Go ahead and get that one merged.
00:43:05.046 - 00:43:37.474, Speaker A: Let me get the fixes. Return data zero padding. And this is the return data load return data copy operations within EOF. This is a request from the compiler teams. This is pretty common in conferences to say that these will bounce check is the only opcode that will bounce check. Any comments on this, or should we move forward and write tests to verify it? This is one that will absolutely need tests to verify the behavior is like a early feature of it.
00:43:40.854 - 00:43:58.204, Speaker C: One drawback that Pyotr found or brought up is that it's like the only opcode which changes behavior in EOF. The others are all like new opcodes, and then we deprecate the old opcodes.
00:44:00.664 - 00:44:18.004, Speaker A: EIP 7676 also proposes a change to balance for a dress based extension rather than trimming it will fail. So there's another one that's gaining it as well. There are two that will just change behaviors in the way they handle exceptions.
00:44:20.064 - 00:44:20.400, Speaker F: Yeah.
00:44:20.432 - 00:44:36.094, Speaker G: Based on that notion, our conclusion yesterday was that when the semantics are changed in this manner, we should probably prefer to have a brand new instruction, a brand new opcode for it.
00:44:40.394 - 00:44:41.254, Speaker A: Okay.
00:44:42.274 - 00:44:56.590, Speaker C: Analogous thing I noticed is in. I don't remember when this was Paris maybe is difficulty got changed to pre, some hash. Right.
00:44:56.702 - 00:44:57.838, Speaker A: Pre brand out.
00:44:58.006 - 00:45:14.314, Speaker C: Yeah, yeah, yeah. And that's like a hash instead of a number. And it has some, like, it's like still a single stack item, but it has like some different characteristics. Like it'll take the full 32 bytes instead of, you know, just a few bytes.
00:45:14.994 - 00:45:40.534, Speaker F: In this case, it doesn't really affect EVM. So EVM just gets this like 32 bytes of data under the same kind of like field in the transaction it gets in at least like from my perspective. So it just, yeah, it just, this instruction just asks it to take this 32 bytes from somewhere.
00:45:41.564 - 00:45:42.348, Speaker A: Okay.
00:45:42.476 - 00:45:44.104, Speaker G: So it didn't add any.
00:45:45.644 - 00:46:03.028, Speaker F: The semantic is mostly take this 30 to bite whatever it means and put it on the stack. So, so I think it's slightly, I mean, yeah, you can argue that it's like depending on level when you, when you put the boundary on in the m or stuff, but, uh. Yeah, I don't know.
00:46:03.076 - 00:46:08.712, Speaker C: Yeah, yeah, it's not the same. It was just the kind of like the closest analogy I could find.
00:46:08.888 - 00:46:14.764, Speaker F: Yeah, yeah. And I think this one as a kind of example, but I think it's slightly different.
00:46:15.544 - 00:46:37.084, Speaker A: But for, with the difficulty, I think the thing that pushed that over the edge is there were contracts depending upon the behavior, that there was random data coming in, not really random data, but unpredictable data that is being used to see prngs for lotto contracts. So because it crossed layers, I think that's what pushed it over the edge of changing the behavior to be report on a different one.
00:46:38.144 - 00:46:53.884, Speaker F: Yes. Also, otherwise you would get like no value for this opcode after the merge. Right. So that's also, I think it's even worse that. So it kind of fixes some issue with the transition to proof of stake.
00:46:54.624 - 00:46:55.484, Speaker A: Okay.
00:46:57.504 - 00:47:24.304, Speaker G: There was one, there was one more argument for the balance. It's a slight argument using a new opcode for it, together with the call 2.0 balances, the only other opcode in EOF, which does external account handling. And if it also gets a new opcode, then it can be grouped with the call up codes.
00:47:25.794 - 00:47:27.306, Speaker A: You would be, it would be easy.
00:47:27.330 - 00:47:42.334, Speaker G: To check if, if a contract is handling external accounts or not with a simple range as opposed to, you know, looking at random opulence. But this, this isn't like a strong argument.
00:47:43.314 - 00:48:13.174, Speaker A: Right. So that is a good objection to 90. I don't think we can go ahead and, go ahead and close with that. I think that's a valid argument. So if we really need this behavior, we would need to have new opcodes and it will make the compiler's logic simpler because they can just reuse their existing return data copy and return data load checks. Return data loads new in EOF, do we want to have that zero padded or do we want to have it match return data copies behavior?
00:48:18.494 - 00:48:20.714, Speaker D: Currently it is zero padded already.
00:48:22.254 - 00:48:25.566, Speaker A: Okay, so it'll be different between the two of them, but it's a new.
00:48:25.590 - 00:48:27.314, Speaker C: Algorithm, not zero padded already.
00:48:27.614 - 00:48:29.070, Speaker A: It's not zero padded.
00:48:29.262 - 00:48:58.354, Speaker C: Yeah it does. Right now it does the same thing as return data copy, which is like the argument is by analogy, by the way. I mean, personally I don't, I think it's like fine actually to like change opcodes. Like when you're emitting EUF, it's not like you will accidentally issue the wrong because like the semantics of all the instructions are different. So you like just need to make sure that the code gen is different for everything.
00:48:59.014 - 00:49:13.314, Speaker E: I mean we already established a year ago that no compiler lies on the weird behavior of return katakobi anyways, so changing it in that regard has zero effect. So I also think that changing its behavior in place without a new opcode is saner choice.
00:49:16.994 - 00:49:20.694, Speaker G: I mean, compilers may not rely on it, but other contracts may.
00:49:22.594 - 00:49:25.934, Speaker E: Yeah, other contracts need to be aware of UF anyways.
00:49:26.794 - 00:49:34.494, Speaker C: Yeah, like UF is like all the opcodes are new and it's just like some of them happen to have the same meaning as before.
00:49:39.814 - 00:49:56.514, Speaker A: But when it comes to return data copywrit, I do kind of hear Ypsilon's argument because it's just a subtle spec change. It's not like we're changing the full nature of it, which I think is easier to see that you're getting, right, and just a little subtle change like that, I can see tripping things up.
00:49:57.694 - 00:50:50.224, Speaker F: Yeah, that's more or less because like from the implementation point of view it doesn't make any difference or you can implement it, whatever, it's the same stuff. And I think we'll make effort to test this properly. I think what we mean is that for anyone outside of kind of core development and stuff, it's at least if you have any kind of disassembly or tooling that just reads byte opcodes and try to analyze it, it will be kind of obvious that this is something new here with the new number and it's not the old one. So yeah, that's mostly, I think the argument, but I think we don't have issue implementing otherwise. But I understand like we want these both changes, right? You're just discussing how to exactly roll it out.
00:50:52.364 - 00:50:58.464, Speaker C: Yeah, I mean, if it is a new opcode, like, what do we call it? Like return data copy.
00:51:00.794 - 00:51:09.054, Speaker A: Return data copy. To return data copy zero, because it's zero pads.
00:51:11.394 - 00:51:14.734, Speaker F: What is the only issue that is the name or.
00:51:16.874 - 00:51:23.490, Speaker C: Yeah, I mean, I just don't understand. Yeah, like, okay, like if you put, throw it into a disassembler, you're just.
00:51:23.522 - 00:51:27.054, Speaker F: Going to call it the same. That's going to assign the same mnemonic to.
00:51:29.104 - 00:51:31.124, Speaker C: Isn't that just as confusing?
00:51:33.144 - 00:51:54.774, Speaker E: Nobody expects the behavior of a return at a copy anyway. So I think changing it either way doesn't have an effect. It's just a cleaner semantics that is better for optimization. That's the entire effect of it. So I don't think it's worthwhile to consider doing it separately or at the same opcode and just doing it the same opcode. Keeping the name is the same simplest and obvious choice to do that.
00:51:57.754 - 00:52:35.984, Speaker A: So I don't think there's consensus on moving forward or canceling 90. So I think we should table it and discuss it next week so we can discuss the last two items on the list. And these relate to the cost of ext call. There was a chart put up by team Ipsalon earlier today in the chat that showed there was a discrepancy between ext call and call having to do with 2300 being added or subtracted or removed. So was there a call for a change here on this?
00:52:39.364 - 00:52:40.744, Speaker G: I just made one.
00:52:42.844 - 00:53:11.228, Speaker F: If we want. If we want exactly the same behavior as legacy costs for this case, I think we need to change this back by changing the constant we use. And yeah, I can propose to change and maybe it will be a bit more obvious what's actually being changed exactly as a diff. Well, I think we want it to be exactly the same. Right. It doesn't really. Numbers are kind of arbitrary.
00:53:11.228 - 00:53:16.904, Speaker F: So let's use the number we actually used in the legacy.
00:53:17.384 - 00:53:25.524, Speaker A: Okay. So the proposal will be to make these two numbers the same, but these sections can be different. And that's okay.
00:53:27.464 - 00:53:29.920, Speaker F: Yeah. The other sections are different by design.
00:53:30.072 - 00:53:34.792, Speaker A: And this one's different by accident. Let's fix the accident.
00:53:34.848 - 00:53:35.248, Speaker F: Yes.
00:53:35.336 - 00:53:49.484, Speaker A: Okay. So let's move to finalize that next week. There will be a pr, I think number 95. We'll have it. And I think the other related issue, increase the calls min retained gas.
00:53:50.784 - 00:54:29.034, Speaker F: Yeah, this is kind of more arbitrary because I just noticed, like, the retained gas is like 5000, right. So it's kind of on the edge of. Sometimes you are able to update the storage with this. Sometimes, you know, depending on like the condition of the storage, if it was accessed or not. And it kind of feels weird, but it's, I think, not critical issue. But maybe people have some opinions about it, like what should be enabled with this or not, but we can keep it for later. It's kind of invitation to discussion, actually.
00:54:29.814 - 00:55:02.624, Speaker A: Okay. So no call for action on that. And this is a change from the 164th retention to like a newer number, 20,000. Yeah, let's discuss it over, over discord. I don't think there's an action to move on next week. My concern is that's kind of a large gas number for people that like to bring their gas estimate to be as close to in line with possible with what's actually going to be executed. This will cause some ergonomic issues, but we can discuss it later.
00:55:02.624 - 00:55:52.044, Speaker A: Yeah, and I do like that it's being talked against something like, we need to be able to perform this action. So that's why we need this number. So that if we have to change schedules in the future and we come back and have to redefine this number, because the gas schedule change, whoever's changing it will have some benchmark to say, this is the space we were trying to preserve. Um, okay. We could define it as like maximum s door times 1.5. Okay. Um, so to summarize, adopt 78, 76.
00:55:52.044 - 00:56:11.364, Speaker A: Um, and 86, table 90. And discuss 94, 95. Next week, again, I'd like to thank everyone to call in who called in. I'd like to thank especially solidity for calling in. It's been a while since we've seen you. It's great to see you again. Yeah.
00:56:11.364 - 00:56:19.144, Speaker A: And we'll speak again next week. If you have issues or need help with testing, just bring it up in the EVM channel. Lots of people will help there.
00:56:23.104 - 00:56:24.444, Speaker B: All right, see ya.
00:56:24.784 - 00:56:28.464, Speaker A: Great. See you. Thank you. Regarding next week, I think that's the first.
00:56:28.504 - 00:56:33.404, Speaker B: Why is the day off in the most of the european countries? So maybe it's good to move it.
00:56:34.944 - 00:56:45.964, Speaker A: Okay. There's a european holiday, we'll discuss moving it in discord then. There'll be at least 48 hours notice if we move it. Okay, so probably Tuesday.
00:56:47.084 - 00:56:48.748, Speaker F: There's no water off Tuesday. Fine to me.
00:56:48.796 - 00:57:01.264, Speaker A: Yeah. All right. We'll discuss moving it after ACD tomorrow. All right, thanks, everyone.
00:57:02.084 - 00:57:02.580, Speaker C: Thanks.
00:57:02.652 - 00:57:03.944, Speaker B: Yeah, thanks.
00:57:04.284 - 00:57:04.964, Speaker A: Thank you. Bye.
