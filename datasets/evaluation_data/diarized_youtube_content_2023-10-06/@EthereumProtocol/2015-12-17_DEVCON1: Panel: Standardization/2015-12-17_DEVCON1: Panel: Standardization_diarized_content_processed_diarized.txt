00:00:18.090 - 00:01:15.250, Speaker A: This is the standardization panel. We have a bunch of brilliant minds up here, Gavin Wood, Nikolai Fabian Vitalik and Christian. So the point of this panel is to talk about the current standards, potential issues that we might see might happen. How can we as a community resolve some of these issues, and how can we go forward to maybe implement perhaps a process or something like that? So I think to start off with, I think it would be great to, there are certain standards that have already been defined that people are using and want to use, such as the token standards, registry standards and so forth in your area, which are the ones that you currently feel the most passionate about. And what are your thoughts on that particular standard and going forward, whoever wants to start? Christian?
00:01:16.090 - 00:02:22.140, Speaker B: Yeah, so I think for me it's probably tokens. So in the transactive grid energy trading program project right now, we have our own custom way of tokenizing energy credits, renewable energy credits, and we want to move towards a standard token solution so that it can be integrated with markets such as Etherex, et cetera. And so this is, for that reason very important. I'm also using registries in various daps, but I think there, it's often more straightforward and there might be less need for interoperability if you have a very targeted system. So I think for me, tokens, definitely.
00:02:25.070 - 00:03:01.640, Speaker C: Tokens and registries, I think probably are the two biggest categories. And with registries there are different types of them. So there are some registries that are specifically kind of targeted to particular types of metadata. And then there's other things which are basically name registries. And they have a lot of different requirements, though in some cases kind of partially or entirely the same interface. Aside from those two, the third category would be different kinds of financial contracts, exchanges, even like purchase offers. I want to buy X units of a for Y units of b.
00:03:01.640 - 00:03:03.894, Speaker C: Yeah.
00:03:04.012 - 00:03:33.840, Speaker D: So for me it would be like proxy contracts, contracts where actually would hold your ether and send it along, but maybe do something with it, maybe like send out shares to other proxies or some kind of voting system based on whatever you pass through. This would be interesting, me, and also tokens as well, because we need to integrate it in the wallet or we did already, and we want to obviously support as many tokens as possible.
00:03:34.610 - 00:03:37.410, Speaker A: Can you elaborate more on the proxy contracts?
00:03:38.390 - 00:04:00.342, Speaker D: The current wallet, for example, is a proxy contract, but ideally you should be, for example, with the wallet you have a multisig on Ether. Ideally you can have a multisig on everything, like even a multisig on sending your custom tokens or whatever so you basically can use these proxies for whatever you want to do with any other contract in the network.
00:04:00.486 - 00:04:01.180, Speaker A: Okay.
00:04:02.270 - 00:04:19.760, Speaker E: Yeah. So I work on maker, and obviously we're most interested in the token standard also. And I guess my role on this panel is pretty much just going to be. I think it's too early and nothing seems like a satisfying solution yet, although I don't have anything better. Sorry.
00:04:23.830 - 00:05:44.406, Speaker F: So I think identity in some sense is something worth considering deeply in how we can try and make all of the different pieces of infrastructure fit well together while dealing with actual individuals. So things that are going to fold into this, like reputation, potentially stuff to do with the outside world, my email address, my website and so on. This is in some sense already addressed with the notion of this 160 bit address scheme that we have. But I think it's worth considering a bit deeper and how this might feed back into things like avatars that go across the various applications within the Ethereum and sort of web3 at large ecosystem. I'd also note that the other thing, we tend to think about standards as something that they tend to be kind of opt in, and we need standards in order to have interoperability, right? Different applications implement the same standard so that they can operate with each other. But actually one of the great things about Ethereum is that this is a fundamentally programmatic infrastructure. So we have the notion of objects existing within the system, and these kind of already enforce standards because they have an API.
00:05:44.406 - 00:06:06.820, Speaker F: And if you want to interact with this object that sits at the center of some system that you do want to operate with, then you just use the API. And the API is a standard, it's already there. And there's no real prejudice because assuming that it's been implemented in some reasonably fair way, and you can check because there's a code there, then we can already kind of pre agree to the standard.
00:06:08.710 - 00:07:01.918, Speaker A: If someone makes a token that doesn't conform to the normal standards, then maybe Etherx, a decentralized exchange, wouldn't then be able to use those tokens. But considering that the code is open source, you can just clone Etherx and make an exchange for your standard as well. So it's great in that manner. The topic of identity, I want to come back to that. I think it's an important one, because as far as I know, we haven't specified anything yet in how it should work and how the ideal version of it should work. Christian, you yesterday explained more about uport work. What's the sort of the idea or design goal of that is it sort of the idea that you keep your identity in the browser and then you move it between certain Dapps.
00:07:01.918 - 00:07:15.270, Speaker A: What about sort of examples where you have a phone client or you have a web browser client or something like metamask or something? What do you think is the most ideal way to swap identities through different interfaces?
00:07:15.690 - 00:08:35.134, Speaker B: Yeah, so this is, of course, a big question. And the notion of using the same identity on multiple devices, that ultimately comes down to key management, which might be one of the greatest challenges of this whole endeavor. How to have key management with a good ux identity is, of course, very important. I'm glad you brought it up. An interesting thing there is, when I think about identity, I describe the kind of general outline in my talk, and the key management issue is very important. So I think we have to have a system of identity where even if you lose your private key, you don't lose your identity. So then we come into the fact that in the current system, contracts always interact with keys.
00:08:35.134 - 00:09:33.620, Speaker B: So you have access control in the form of if message sender equals this address, then do this, otherwise do something else. And that works in the context of identity because you can have a lookup that goes from key to identity. But it's an interesting thing to think about if we should think about an access control system that works on the level of identities rather than keys. So in my mind, an identity is kind of a cryptographic identifier. So maybe a 32 byte hash or something. And then the contract could say, okay, I'm getting this message, I'm going to look up. If it's, maybe it's just a key, then do this.
00:09:33.620 - 00:10:04.190, Speaker B: If I do a lookup and see, oh, this is actually an identity, then I can have access control on the level of that identity. And so then you can keep using these contracts even if you rotate your keys for your identity. So that's something to think about. And that, of course, if we want to go down a path like that, it requires standardization in how we construct these contracts.
00:10:04.930 - 00:10:30.680, Speaker A: Yeah, it does paint a potential issue that if a lot of the current apps are going to use the normal account system and not more, say, identity system, that you won't be able to upgrade all the previous applications to optionally slot into a more flexible identity system. That's one of the things we need to figure out. Any other comments on that issue?
00:10:31.130 - 00:11:31.180, Speaker C: In general, I think that 20 byte addresses are a pretty wonderful identity standard themselves, just because the sort of really important property that they have is how they're good at completely separating the concept of identity to the concept of how you do access control for the identity, and even through potentially with things like registries, how you provide metadata or assertions about that identity. In general, I do think that access control is a problem, and figuring out how to switch keys around is a problem. But all of those things, it's important to kind of neat, cleanly separate all of those problems so that all of those problems can kind of be sort of hidden behind, at least from the point of view of applications, hidden behind one single account. And then people can basically use whatever solutions they want because in theory, people have the incentive to protect their own security and they'll go with what's most comfortable for them.
00:11:32.190 - 00:11:48.640, Speaker A: I think that's where proxy contracts can become useful in that regard, where essentially you navigate your interaction with the rest of the ecosystem through like a personal proxy contract. That's your sort of forwarder to the rest, right?
00:11:49.010 - 00:11:49.760, Speaker E: Yeah.
00:11:50.930 - 00:12:23.690, Speaker B: This could be tied into any type of identity system, potentially, so that the proxy contract then would become the canonical, I mean, the address of the proxy contracts becomes the canonical identifier for you, and then you do all your interactions through that. But you can have multisig access through that and do key rotation for access to the proxy contract, et cetera. So that might be a good solution.
00:12:25.310 - 00:12:51.300, Speaker C: If the EVM can practically be expressive enough, especially in terms of cryptography, I think you can go very far with proxy contracts. Like one really far out thing is, if you look at something like the estonian digital id standard, then someone with an estonian digital id is theoretically able to create digital signatures with that. And you could even have a proxy contract that verifies those.
00:12:53.350 - 00:13:28.320, Speaker E: I agree that proxy contracts work very well. Like the address scheme is super general. It pretty much solves a problem like you described. But another approach you could do is basically the two keys are the same identity if they both say that about each other. So you have one contract where everyone just comes and I guess wires up their cluster of keys, and also a contract, if you can force it to do a particular call, it's the same thing. And then your cluster has one canonical address, which you used when you check the sender, you look up the canonical address and then see if that's authorized. Then people can make up whatever.
00:13:28.320 - 00:13:38.020, Speaker E: They can even merge identities if you want to. I have two identities, but then I want to combine the reputation or something, then I can link them together. And now they're one.
00:13:39.670 - 00:14:26.900, Speaker A: Yeah, that's right. So I think we've heard a lot about tokens through the past few days. It's definitely one of the more pertinent things to think about. And I think as a community we've come to very close to defining a pretty good, decent standard that's not ambiguous and people can understand. I think the next big one would most likely be registries that a lot of people are going to want to use and going to think about. I know there has been talk about questioning where should metadata live? Should it be in the contracts themselves or should it be in registries? Gavin, I think you have opinions on that you want to share.
00:14:27.590 - 00:16:01.594, Speaker F: Sure. Yeah. So this is a question concerning whether given a contract that does some particular thing, let's assume it's some sort of token contract that's recording the balances of various identities. Should the contract itself contain information regarding itself or should that information be placed elsewhere on the system, potentially in some other contract whose reson, so to speak, is purely to retain information concerning, for example, token contracts? These are the two sort of options. It's my opinion that because we have this system, so normally I would place the information in with the contract that it actually refers to. This is mainly because in the real world we have siloed servers that actually have system admins that can actually corrupt data and the two sort of systems can become disjoint. But within Ethereum, of course, we don't have these problems and we can actually have nice isolation of use cases without having to have the sort of real world problems that isolation brings, such as the fact it's stored on a different computer, potentially with a different ISP.
00:16:01.594 - 00:16:26.866, Speaker F: Potentially it's going to go down at different times and all the rest of it. So in this instance I would actually prefer to have a nice fair contract that actually it's resonator is simply to store metadata about other contracts and then allow the coin contracts and all the rest of the other, all the token contracts, et cetera, to do their thing, which is to say maintain the balances of their users.
00:16:27.058 - 00:16:30.922, Speaker E: Can you explain more what types of metadata you're talking about? Because that could mean so much.
00:16:30.976 - 00:16:53.620, Speaker F: Sure. So specifically data concerning the contract itself rather than containing the data that the contract cares about. So in this case the data will be things like what's the name of the contract? Maybe there's typically in real programming we consider them like static members, stuff that doesn't actually change with the state, it's just to do with the actual object itself.
00:16:55.510 - 00:16:58.754, Speaker A: Yeah. In your opinions on that about the.
00:16:58.792 - 00:18:10.280, Speaker D: Idea is basically like names and the token symbol or how much decimal places one token has, and I think it's definitely a valid approach. But I could also imagine that lots of people may want to have tokens which are not listed in any kind of registry. And as well as I see this as growing from simple things, from what we can do right now, what we can add for example to the wallet right now in an easy way, and what ideally we want to have at some point in the future. At some point in the future, we probably have many depths which allow you to look at these registries, to modify these registries to have all kind of storage functionality, and then it's very useful to have these registries and maybe even exit all through this. But in the current state, I see it more like a lean approach, like putting the things where they are right now, easy accessible and easy to understand. Because it's also from the other developers who use these contracts who want to understand them. They have to know that they have to look in this and this and this place, or maybe there's two different coin registries, or three or so.
00:18:10.280 - 00:19:04.666, Speaker D: If they just right now have it in the place where they're actually expecting it to be, it's easier. And I think we will grow in that direction so it will mature over time. And this also brings me to the point of the current standards. So I don't think we can make up a standard right now which fits everything for the next five years or so, it will probably be many iterations. And I think one major point is to make sure that we have some kind of upgradability strategy. So what happens if standards change? Maybe we can use proxies in front of others, or some kind of proxies where you can change the API of your token in a way without changing the actual contract, without the real update of the contract. You can still be sure it's still the same contract just now.
00:19:04.666 - 00:19:52.282, Speaker D: It has a different interface with things like this. We can actually be rather flexible even if we have to make changes in the future. And one other thing towards the tokens. For example, the guys from Knossos have that issue that they want to not only have one contract per token, but they have a token contract which holds multiple tokens. And that's actually something worth thinking of, how we have token per contract or multiple tokens per contract, and how we bring this into one standard, how we make this readable. For example, this would require not only having a coin registry which has like token name and address, but token name, address and identifier of the token used inside. I really would love to really bring the community in, come up with what use cases they have, and try to find a common standard.
00:19:52.282 - 00:19:54.140, Speaker D: And I think that's more rather a process.
00:19:57.470 - 00:21:23.890, Speaker C: Regarding standards, it's also important to just keep in mind that modularity fundamentally is about upgradability. So if you knew that the way things are is exactly the way things are going to be forever, you might as well just write the whole thing in spaghetti code, because it's faster. When you have questions of the form, should x be lumped into object a, or should x be lumped into object b? One of the things to think about is what category of those objects do you expect to be upgraded more frequently? What category do you expect to be created or destroyed more frequently? So with tokens, for example, we're going to see, keep on seeing new tokens being issued over time. You have a question of, do the existing tokens that get issued, who is going to be upgrading them? Is anyone supposed to have ultimate authority over them? How are they going to be upgraded? Is it just going to be through just creating new proxy contracts for each new standard might actually be a pretty decent approach. Another question then you have the question of when is the registry going to be upgraded? So, for example, right now we know that tokens have names, we know that tokens might have decimal places. Well, guess what? Ether has six subdenominations. And eventually people are going to decide that they want logos.
00:21:23.890 - 00:21:40.250, Speaker C: And maybe the fad in 2017 is going to be logos that are in the form of mp4 videos. It's sort of importance to figure out exactly whatever standard we take, how that's going to handle those kind of situations.
00:21:41.090 - 00:22:40.174, Speaker B: So I think one thing that touches both registries and tokens is name registries. And I think this is a quite challenging problem, because whenever you have a system that registers human meaningful strings, there's going to be questions about economics, because these things have value, they have different value for different people. You have things like name squatting, which is a huge problem in namecoin for. So this is something that we should be thinking very carefully about. And I think you, Gavin, have thought about auctions in the context of registries, et cetera. And so just putting it out there.
00:22:40.292 - 00:23:21.882, Speaker A: In registries, they serve essentially two purposes, which is providing additional information, additional metadata. But also if there are scenarios where you want something like a namespace for certain things to exist, like if we eventually want a system where like one name which has the namespace in bitcoin wallets, then you want that interoperability to exist in all the bitcoin wallets. So then there needs to be like a community decision to gravitate towards a certain namespace for certain things. And that's probably a more difficult thing than just the fact of registering metadata. Anyone have opinions on that?
00:23:22.016 - 00:23:55.954, Speaker E: Yeah, well, I kind of want to go on a sidetrack. I think before we even start talking about more like application level standards, we should resolve things like what is the correct way to deal with VM errors? Because in the current standard it's like half return value VM check, and then the other half don't have that. So I'm assuming there's an exception being thrown there. And this actually is, I think, in all the standard or all the proposed standards right now. So something like that. And then maybe some standard design patterns for upgradability, like they were saying, once we get those done, I think it'll be much simpler. I think the standards will just emerge naturally.
00:23:55.954 - 00:24:04.780, Speaker E: Like a couple of people will make some great wallets with decent standards. Everyone will want to be compatible with that wallet, and there's your standard, and it won't change until someone makes a better thing.
00:24:05.630 - 00:24:54.234, Speaker D: I really agree with this. I really think it will evolve naturally, like Twitter took on or other things took on. If somebody does something which a lot of people like the way it's done, they will adopt it and it will really become the standard then with time. But I really would like for now, because we are very early in this game, to have more community approach, bringing in ideas. I mean, this can be a lengthy process and this can be like discussions sometimes take time and maybe they lead somewhere in a stuck path, but it's about bringing ideas together because so many things we can't think of even yet where this is going and what all will be necessary. So everything we come up probably will maybe be very simplistic compared to what we need at some point.
00:24:54.432 - 00:25:32.680, Speaker A: Yeah, I think one of the things I want to point, I want to make on that is the way the current standards work is whoever edited the wiki the last time. And I think it would be great. I think if we can move towards just, it doesn't have to be very complicated. We don't have to put up mailing lists and get a committee on things and whatever. But I think it would be great if there's sort of a stamp of approval from various people that this feels like the best approach at the moment. But we could make a discussion on Reddit and get a lot of people involved to see what they.
00:25:36.330 - 00:25:57.550, Speaker D: Having. Actually, I think a good idea would be actually using gist, because in gist you can comment on the gist and then it moves to a wiki. But right now, kind of like, it's a little bit like a Wikipedia edit war kind of thing. Not that much, but definitely having places where we can bring together examples and have these talks.
00:25:59.330 - 00:26:34.538, Speaker A: Okay. I think the last topic before, I think we end up ten parts. I think there are probably people who have some questions. So I think one last thing I want to touch upon is do we feel that there should be more like formal process for defining standards and maybe into the future? Not at the moment. I think at the moment it's still sort of nebulous and growing organically. But bitcoin has the improval process, the bups. Right.
00:26:34.538 - 00:26:41.760, Speaker A: Is there something that currently exists in the Ethereum community, or is this something we need to consider more?
00:26:42.290 - 00:26:47.120, Speaker F: Yeah, so there's quite recently, I think it was a couple of weeks ago, Martin set out the.
00:26:49.010 - 00:26:57.460, Speaker A: Great. And there's a wiki for it as well, information about. Okay, well, that's great then.
00:26:59.430 - 00:27:22.490, Speaker D: Right now this is read about the Ethereum protocol updates, but one can think of for all kind of things. But right now, I think it's like you say, it's very early stage, it's very much exploration phase. So it's a lot of things like trying things out and see what catches on. Really, it's about who. I mean, we can make up a standard if nobody follows it. That's just a standard written, right?
00:27:22.640 - 00:27:35.840, Speaker E: Yeah, I definitely think the Ethereum Foundation's role should be facilitating discussions and all this, and not defining standards and definitely not creating apps. Then you have to follow those standards because it's the official one.
00:27:36.850 - 00:27:50.126, Speaker A: Okay, there's about five minutes left. I think we open up some questions over there. 15 minutes left. Okay, well, Piper, so there's talk about leaving proxy contracts.
00:27:50.158 - 00:28:11.610, Speaker G: One of the problems with that is the message sensation. Proxy contracts and message center are very likely, because now all of a sudden, everything's coming from some other address.
00:28:13.900 - 00:28:26.156, Speaker E: Basically, the fundamental issue here is that the call code operator maintains all the same state except for the sender. So it sort of just barely doesn't satisfy the role that intuitively it's supposed to.
00:28:26.258 - 00:28:52.436, Speaker D: Yeah, this is also something we have with the wallet. The wallet currently actually uses stub contracts, so it's cheaper to deploy. It cost 120,000 gas versus 1.2 million gas. So we have one code base and we have the subcontracts. They use call code. And the problem is inside the actual wallet message sender is actually the calling contract and not the one who actually initiated it or the one before.
00:28:52.436 - 00:29:01.464, Speaker D: And this basically makes Callcode not neutral and really a bit destroys this library functionality. So I really would love to see change here.
00:29:01.662 - 00:29:15.870, Speaker G: So one of the other things that's currently not possible, if I understand correctly, is accessing further down the stack of message sender. Is that an option for future EVM upgrades, being able to actually trace your way all the way back to transaction origin?
00:29:16.880 - 00:29:39.132, Speaker F: Yeah, it's something that we're looking at. The argument against it is essentially isolation. There's a notion that the current executing frame on the stack shouldn't really be possibly prejudiced by previous stack frames because it breaks the notion of encapsulation.
00:29:39.276 - 00:29:41.516, Speaker G: Shouldn't transaction origin be excluded?
00:29:41.628 - 00:29:46.650, Speaker F: In principle, yes, but there is a slight difference in that a transaction is different to a message.
00:29:50.860 - 00:29:51.930, Speaker C: Other questions?
00:30:05.300 - 00:30:50.172, Speaker H: So one of the arguments for the registry against keeping metadata inside contracts is really how does the contract will register itself? Because either we have to register when the contract is launched, meaning that if you have a register that exists after the contract has launched, the contract can't register itself. Or the contract must have some sort of way to pass on arbitrary messages, which might add some complexity that something like a token contract might not necessarily have, which then has the problem of who has the right to pass arbitrary messages.
00:30:50.236 - 00:30:50.850, Speaker A: So.
00:30:53.380 - 00:31:00.640, Speaker H: How would the token register itself, and who would be the owner of the token if the token has no owners?
00:31:01.240 - 00:32:02.628, Speaker C: There's two major categories of solution, of ways of solving this. I think one of them basically is to say that currencies or tokens have to build in submechanism. It doesn't have to be standardized in order to allow some particular administrator to keep on updating registry data if they have to. Or alternatively you could just say that the token just calls the method once and it's in it code and then never does it again. The other approach is this proxy contract route, which basically means that you start off by just having the token follow whatever the API was at the time. And then if a new standard comes along, or if you want to update the registry information, then the way you would do that is by creating a new token, which is really just a proxy pointing back to the first token and then all that. That new token is, is basically the same thing as the original one, except it has a different interface and maybe different registry data to it.
00:32:02.628 - 00:32:07.160, Speaker C: So that's one potential way of making things more modular.
00:32:07.900 - 00:32:41.040, Speaker E: Yeah, I was going to say if you don't know ahead of, basically there's two categories. There's like immutable contracts, which basically you know exactly what they're supposed to do ahead of time. You write the code and there's no backdoors or anything. But then if you have even one use case where you might need to do a proxy call, then your contract becomes, it could do anything. And so then it needs a governance model, basically. So the answer to that is if your contract is doing arbitrary behaviors, then yes, you need a governance thing, and that's a separate problem altogether.
00:32:42.280 - 00:33:10.744, Speaker F: Yeah. The only thing I'd add, if the notion that actually we're going to say all tokens could in principle become proxy, have proxy sort of facades in front of them, and this can be added for all possible, all eventual improvements to registries, then we've got like this order n squared issue where you're forcing all tokens to support all registries, so you're going to end up with like n squared facades.
00:33:10.792 - 00:33:11.390, Speaker B: Right.
00:33:11.920 - 00:33:53.400, Speaker F: Whereas if we go for the route of saying, right, well, actually tokens, maybe it's the case that they elect to a registrar, some third party address and say, actually we're not going to execute arbitrary transactions in the future, but this guy can actually update metadata on our behalf, which massively reduces the attack surface. And it could in principle be like a multi sig sort of contract, multiparty sort of stakeholder thing, where multiple people actually have to agree that, yes, this isn't just some dodgy troll trying to change your name to something silly, it's actually a reasonable metadata upgrade.
00:33:54.700 - 00:33:56.170, Speaker C: Thank you. Any more questions?
00:34:05.280 - 00:34:22.880, Speaker A: So how much do standardization conversations today, or how much should they be influenced by scalability conversations tomorrow? So with respect to sharding, if we take some approaches to standardization that may not make sense in a sharded future, I'm just wondering. Thoughts?
00:34:24.180 - 00:34:38.040, Speaker D: That's actually a good question. So if we have the registry and we have the token, and we take the basic metadata of the token out of the contract to a registry and they are in a different chart, it would get more complicated.
00:34:39.900 - 00:35:12.710, Speaker F: Yeah, I guess today exactly how the sharding is going to work, exactly how sort of scalability in 2.0 is going to work is still very much a question of research. We've yet to do any real modeling on the ideas that we have, and then of course there's still feasibility and implementation all the rest of it. So I think it's still a relatively long way off, and we probably should be focusing on real use cases today rather than presuming potential architecture decisions that we're going to take in maybe one, two years time.
00:35:13.800 - 00:36:08.550, Speaker B: I feel like it's kind of a case of premature optimization. We have this idea that, oh, maybe in the future there'll be a different chart. So I make certain decisions now. That's probably not a good approach. I think with any future upgrades, I guess what they should just, we can probably rely on future upgrade not directly breaking what works now. And so if we create stuff that works now and make sure that works, I think that's good.
00:36:10.040 - 00:36:25.064, Speaker D: There's always the possibility to basically copy a contract and copy its storage. I mean it would be maybe a manual process, but it will work. So you can always basically change it, move it over. You just have to point the interface and send to the new wallet. So in the worst case, kind of.
00:36:25.102 - 00:36:29.276, Speaker C: Well, it depends on whether or not the contract contains ether or any other assets you don't control.
00:36:29.378 - 00:36:30.124, Speaker D: Right?
00:36:30.322 - 00:36:37.852, Speaker B: Yeah, but yeah, using pointers to contract in a modular fashion is good.
00:36:37.906 - 00:36:48.460, Speaker C: Incidentally though, this last particular argument is actually a very good reason why you might. Very good argument in favor of different Dapps basically creating their own subtokens.
00:36:50.000 - 00:36:58.130, Speaker A: Cool. I think, I think that's it for this panel. So I want to thank all the people. Thank you very much.
