00:00:16.650 - 00:01:23.846, Speaker A: Hi, my name is Petria Nyuk. I work at IMAP and I'm going to present you our approach to nano payments in Ethereum and how we believe they can be implemented by nano payments. We understand payments that are two orders of magnitude smaller than typical micropayments. It's not a formal definition, but we believe that typical micropayment is a payment under $10. We came across this problem when we tried to implement parts of our project, the Golem project, which is a distributed supercomputer. In fact, it's a distributed peer to peer network, where each node can participate both as a computer and as a task sender, and each node taking part in this computation should be able to receive payment eventually. And this results in nanopayment because tasks can be split into pretty small, pretty substantial amount.
00:01:23.846 - 00:02:23.958, Speaker A: For example, single task can be split into up to 10,000 tasks where a cost of one task is below one dollars. We try to achieve payments as small as subtest, but we believe that we can approach even one 10th of a cent to make it attractive to users. We believe that cost of renting one cpu core shouldn't exceed five cents on average per hour. To make it even more attractive, we believe that from the user perspective, the setting should be that the transaction fees are below the 5% of the total task value. Framework should not require any central authority or any trusted authority. Everything should work inside the peer to peer network, golem network, and in fact also an Ethereum network. Users computing nodes shouldn't be required to stay online at any specific times, for example, due to changes in time zones.
00:02:23.958 - 00:03:12.074, Speaker A: They should be able nevertheless to get their payments at some point, even if they're offline. And ideally you would like to skip any payments from users so that they don't have to pay upfront any funds to start a computation. We believe also that nanopayments can be used in other scenarios, for example, paying for articles or for streaming content, paying direct to artists or for likes on social media. Also, you can donate something on forums and blogs for people to write something that you find useful. But there are many more ideas why we believe Ethereum is the solution. Well, traditional payment systems are simply too costly and they require additionally some trusted central authorities. We don't want to trust them.
00:03:12.074 - 00:04:26.894, Speaker A: Well, people wouldn't have to trust them because there are some central and external authorities that work outside of the network. Additionally, we have bitcoin, which up to some point can solve our problem. But first of all, it requires additional payments for just transactions. Additionally, there are some penalty fees for many transactions in one block and you have to pay additionally for large blocks. Possibly we could overcome these problems in bitcoin network, but we also believe that additional logic would be implemented in a contract attached to Gom, which makes bitcoin a bad choice and ethereum the right one. So how do typical payment scenarios look like? Well, we thought about them a bit, we investigated all of them, and it seems that external servers would be the best solution because they would solve the problem simply. But they require the external servers and additional authority, something which is of the network, both Golem and Ethereum, and it is not feasible in our scenario.
00:04:26.894 - 00:05:01.366, Speaker A: Batching up to some point solves the problem, but it's not scalable. Well, direct transfer costs approximately 21,000 gas right now. Exactly, and batching is two up to three times cheaper, but that's it. You cannot get any better with it. Batching boils down to initiating all transactions just with one message. In Ethereum, it's just a loop that sends value to all users. A very promising option is micropayment channels.
00:05:01.366 - 00:06:15.398, Speaker A: Unfortunately, this requires the setting when two parties cooperate together for a longer period of time, and this is not the case in Golem, unfortunately. And the last one, probabilistic payments, described by Vitalik on his blog, seems very promising. Unfortunately, it requires users to send large amount of value before starting the calculation, and those deposits we believe may not be acceptable by senders who simply would like to pay the predefined amount of money and be sure that that's enough to make the whole payment. So how it looks in Ethereum? Well, with the gas price and iterate costs at the level presented on the slide, it looks like this direct transfer costs 21,000 gas, whereas batching costs 11,000. It's an improvement, but it's not enough for nano payments. Micropayment channel would work, provided that we could establish a connection between two parties, which we unfortunately cannot do. When we take golem into mind, probabilistic payments would work.
00:06:15.398 - 00:07:17.650, Speaker A: Unfortunately, there is no fixed cost per user. Expected cost could be calculated, but we're not going to do it here. Our minor improvement over batching is sub accounts. Sub accounts is a simple smart contract which establishes a mapping between addresses and values, and sender transfers values, sending a vector of data pairs of addresses and values, and they accumulate in those accounts stored in the contract. From time to time, end users can cash out, and we believe that on average it should cost 8000 gas per user, which gives five k for contract modification, two k gas for sending message to the contract, and we believe that users should be able to boil down to 1000 gas for cashing out. This still is not a perfect solution. It doesn't scale.
00:07:17.650 - 00:08:11.260, Speaker A: And that's why we came up with lottery contract, which supposedly solves all the problems. And in principle it looked like this task. A person who broadcasted the task into a golem network sends off chain the description of the lottery to all receivers, and additionally sends some data to the smart contract so that all receivers can verify that they are treated fairly. And contracts should be able to verify that some user has won. The second step is drawing a random number. I'll talk about the randomness source later on. We believe that provided that we can do it, it's just a matter of running the contract so that it pays the required amount to the winner, and so that everyone can verify that indeed that person won.
00:08:11.260 - 00:09:13.470, Speaker A: In ideal world, we would be able to draw a random number easily and in a very verifiable way. And in that setting, the algorithm would be pretty straightforward. Task sender would send altery description to everyone in the column network, so that everyone would be able to verify that it is fair. And after that, anyone could call a reward winner into the contract, which would simply send the funds to the winning node. Unfortunately, we don't know how to do it because there is no source of trusted source of randomness. But if we could draw a random number from some external source that can be checked later on, then sender would call start lottery with lottery id. Lottery ID maps uniquely to the description of the lottery and the id of the task that was sent to the golem network.
00:09:13.470 - 00:10:08.174, Speaker A: And after the random number is generated, someone, maybe sender, or the winner, calls reward winner. And just as before, funds are transferred to the winning node. Unfortunately, this is still invisible and we have to come up with something else. So we use, as suggested by Vitalik hashes from future blocks, an additional method, determined winner can be called by anyone, and that method stores predefined hash of the predefined block future block, and after that everything goes as before. Someone calls reward winner and the funds are transferred to that winning node. The point is that reward winner can be called by anyone. Determined winner is required to be called within some amount of time, and there is an incentive for everyone to do it.
00:10:08.174 - 00:10:47.958, Speaker A: First of the paying node task sender pays some small additional deposit, and this deposit is returned. If the sender calls the term winner. Elion. If that node fails to call it, anyone can call the term winner and the deposit is transferred to that node. So there is an incentive to do it well. What's important here is that winner certificate is pretty similar to what we had in sub accounts case. It's a list of pairs, nodes, addresses and values that correspond to each node.
00:10:47.958 - 00:11:38.886, Speaker A: And each value is proportional to the time. Well compute resources node spent for the task or even subtask. And this is linear in number of nodes. We believe that it should be better and everyone knows what this structure is. Mercotree can be used to simply send logarithmic amount of data. With regard to the number of participants. The only change in the algorithm is that the winner certificate right now consists of triplets address a partial sum up to the point where this node is in a vector and its value so that it can be determined in a tree.
00:11:38.886 - 00:12:14.450, Speaker A: So when the path is set, the lottery id is changed to the hash of the root of the tree concatenated with lottery id. We believe that we can do even better. We can keep the cost of the whole lottery constant. But this setting requires some optimistic assumptions. And that proof, the one that is sent in fifth step, is sent only when necessary. Necessary. Meaning that someone was cheated.
00:12:14.450 - 00:12:59.542, Speaker A: Someone was cheating. So a winning node sends a lottery winner message without any proof, and stores a huge deposit which would be paid to other node if that sending node is a cheater. After that, anyone participating in the network can send approve. And if the cheater is revealed, then the node sending the proof gets the deposit and the winner gets the value, gets the price. We believe that 24 hours is just enough to make it fair. The algorithm is pretty similar to the first implementation that is not optimistic, but uses certificates. Right here we add three additional points.
00:12:59.542 - 00:13:53.266, Speaker A: In fact, two lottery winner and lottery payout. Lottery winner is used to indicate that a node believes is a winner. Lottery payout can be called after 24 hours if no one vetoes and reward winner is a veto, which results in revealing cheater and sending a deposit to the revealing node, and sending price to the winning node. So one very important problem that we have to deal with is how to generate random value. Well, generating random values by future blocks is not a perfect method, because it's prone to miners fraud. And at the point of this presentation, only 25 and 56 blocks can be. Well, hashes of blocks are available to the contract.
00:13:53.266 - 00:15:12.078, Speaker A: So within 25 2056 blocks, a block hash has to be stored in a contract, because later on it cannot be verified. If that doesn't happen, then the next batch of 25 226 blocks is used and another hash is used. It's fair, but it changes the winner, so it's an incentive to everyone to get that hash from the first 256 blocks. Well, so far we don't know any better solution, but we are aware of approaches that can in future replace our approach. Rundown contracts and alarm clock, when stable and well developed, may be a better approach to this problem and may solve it easily. We don't know right now there are not very reliable and well more expensive than our approach, simply so we know that they exist, we know that they can be used, but we have to wait until they get a bit more mature. So the cost comparison between presented methods is like this.
00:15:12.078 - 00:16:07.538, Speaker A: Batching and sub accounts grows linearly with the number of users. Lottery check, as you can see, grows logarithmically. Lottery winner is a constant cost, and for less than 256 users, lottery check is cheaper than lottery winner, which makes it a preferable method in our setting. As you can see, for 100 users, cost is six to seven times higher than for lottery batching and subcounts, and for 1000 users it's two orders of magnitude more expensive, which makes it unusable in our setting. What may be interesting for a user who takes part in a probabilistic setting is how long. Well, a user would have to wait for the first pay payment. And it seems that the probability of not getting a payment during first n number of lotteries drops to zero pretty quickly, which means that it goes rises to one pretty quickly.
00:16:07.538 - 00:16:50.300, Speaker A: Probability of getting a payment rises quickly to one. What's even more interesting is what's the chance of getting some predefined amount of expected income after a number of lotteries? Well, using a simplified approach with binomial cumulative distribution, we can show that this grows to one with the number of lotteries the way it's presented on this graph, and it's pretty convincing. That should work, and it should be convincing to users to take part in lotteries. Thank you very much. If you have any question, please don't hesitate to contact us.
