00:00:17.290 - 00:00:46.940, Speaker A: Hello. So Gustav and I wanted to talk to you a bit. So, my name is Jota. We were heading supporting the security audits prior to launch. And Gustav and I wanted to talk to you a bit about what we have done from the FDEV side in order to secure the network and make everything stable. So Brushnei has said security is a process. So that's what we kept in mind when we thought about security.
00:00:46.940 - 00:02:24.058, Speaker A: It starts with the different implementations that were supported by the Ethereum foundation, particularly the Python client, the C and the go client, in order to ensure a healthy network together with the yellow paper that is a bit unreadable, as some people say, but nonetheless served very well as a process. And Gustav will talk a bit more about that in order to ensure that the implementations are actually comply with a formal specification. Then of course a big set of comprehensive tests that we implemented. And also Gustav will talk a bit more about that cross client tests, particular tests for the VM as a critical core component of the protocol transactions and block tests, and Christopher and Dimitri, who are around, they did a great job in achieving a very big coverage. And then finally, the thing that Gustav and I mainly worked on, the audits that we did prior to launch. So where we worked together with blockchain researchers, academic researchers, different professional security firms, for which we used a big chunk of the budget from the raise, from the sale and the bounty program. Let me say a few words about the bounty program, since we have one of the bounty hunter hunters here.
00:02:24.058 - 00:03:08.390, Speaker A: Martino did a great job. So that was an effort and is still ongoing, where we engaged the community to find and find issues, scrutinize the network. So, yeah, as I said, it's still ongoing, and it's important that we continue the work that started prior to launch, even now, especially since we are still in the frontier phase. So that's a bit of an overview, what we did. So, as I said, it started basically with the different implementations last year. Then that was the moment when Gustav and I joined the team in December, setting up the audit strategy and then the different companies. So Citil leased authority.
00:03:08.390 - 00:03:58.234, Speaker A: They also did a very great job analyzing the economics of the network. Deja vu, who helped us with the Go C and Python audits. And finally, as I said, the researchers. So Sergio Lena, Andrew Miller and Ita Yal, they helped us with a lot of theoretic analyses. So before I hand over to Gustav, I want to talk about one thing that's particularly important for me, which is diversity, but not the sort of diversity you might think when you look around, but the diversity of the network. So when we started, we hope for a very diverse network because it's when you think of when we find a bug, we want to ensure that the network can continue operating safely. So this is how it should be.
00:03:58.234 - 00:04:46.840, Speaker A: But unfortunately the audit schedule has kind of more led to a picture like this where go is dominating. So we launched the Go implementation first because we were done with the or officially kind of because we had finished the audit already, but in between we also finished the c plus plus audit. And it's essential to keep in mind that a critical factor for the mining is the implementation of the block two mine function, which depends on the implementation. So please get c plus plus miner up and running. And if it's just because you want to earn some money when go is down and the difficulty goes down.
00:04:52.110 - 00:05:44.140, Speaker B: All right. Yeah. So what is blockchain security? There's a great quote in the jello paper from Gavin about how there's far more invalid states than valid states in a blockchain, and blockchain security is a very broad scope. And earlier this week we had Vlad Semfir talking about security in terms of mining power and proof of stake. And earlier today we had Alex Leverton talking about the peer to peer protocol. So what I'll focus on here is just a few examples of the things we found in the core consensus protocol. So we're not going to go too much into networking or mining, but look at the core virtual machine and the protocol around that.
00:05:44.140 - 00:06:36.730, Speaker B: So I'll show a few examples, but before that I just wanted to show this relation between the jello paper and the clients. So we started with kind of three main clients, CPP, Golang and Python. And they are based on the jello paper. So they are considering the Jello paper to be the formal specification and they have implemented the virtual machine and the protocol based on that. And the Jello paper is also what the other tests are derived from. So if you go to GitHub, we have this repository for protocol test cases. We have a few thousand tests there to cover blocks, transactions and the virtual machine, and these clients execute these test cases.
00:06:36.730 - 00:07:52.130, Speaker B: And the tests were actually started when the proof of concept was started last year. So during the development until the launch, all these clients have executed these test cases, and they've also been used by other clients like JavaScript and Haskell client to ensure that they're compliant with the protocol. And there's also feedback from the clients. So we will see one example where we found a bug in the formal spec based on the clients, where the clients were actually correct, but the spec was wrong. And there's also a relation between a c plus plus client and the test, in that a c plus plus client is used to generate the test cases. So we're just going to go for a few examples to see what we found during the audit and in the bounty program. And some really rough categories could be said to be the consensus protocol in terms of both logic implementation details like overflows.
00:07:52.130 - 00:09:29.698, Speaker B: We'll see one example of a denial of service attack and a few issues that we found after the launch. So here's the first issue in the bounty program creating ether out of was I think at this time jift and I were talking about how to reward bounty program issues, and we were kind of thinking that this is a pretty critical thing because it kind of affects the limited supply property of Ethereum. What happened was that the former specification doesn't limit the block number, it's actually unlimited. So the data type that was used in go was a big integer for this. And there was an interesting bug here that was found by Jonasnick in the about program back in February. And what happened was that the Go implementation is using a golambigint for the block number, and there's a instruction in the virtual machine to get the block number on the stack. And what happened was that you could actually put a block number that was bigger than 32 bytes there in your block header, and that would actually be valid when you deserialized the block header from the RLP, the RLP encoding that Vitalik mentioned in his previous talk.
00:09:29.698 - 00:10:47.776, Speaker B: So you could set the block number to more than 32 bytes, and then when you grab that number on the stack, it will actually be casted in a way that you could push a negative integer on the stack. This was an example of how we kind of used the wrong data type in the sense that the film virtual machine is not defined to be begins or integers, it's defined to just be 256 bit values. But in languages like go, you kind of have to use a big integer to model that. So the arrow is actually what we can see the go for looking at here, which is the commented out to make sure that what we push back on the stack is an unsight integer. And the thing we see at the bottom there is actually the contract bytecode that would trigger this issue. And the result was that you could actually create unlimited amounts of ether. Another short example is just a very simple integer overflow that I found back in March.
00:10:47.776 - 00:12:30.830, Speaker B: This one was found by the security auditors, Deshau security, and it was related to the sign extend operator in the jello paper, which is used to extend an integer, binary integer without changing the value or the sign. And so what the go client used to do back in March is that it popped one of the arguments from the stack and would then cast that to an onsite integer of 64 bits, even though stack items are 256 bits. So that was something you could easily overflow as an attacker, and that would then cause a consensus issue with C plus plus clients or the python client. So we had a lot of these issues where we were just casting big integers to unsigned 64 bit integers for convenience, basically to make implementation of instructions easier. Another kind of class of issues that we had is the off by one error, where one example is the gas limit. Yeah, Vitalik mentioned this in the previous talk here, that the protocol has a gas limit in each block, and the jello paper specifies how much this can grow. So the miners basically vote and they can change the gas limit to go up or down, but only within a certain interval.
00:12:30.830 - 00:13:16.110, Speaker B: And this is the diff from GitHub for the fix to this issue. So what happened was that we were not considering the case when the gas limp was going down, only when it was going up. It's a bit of an embarrassing issue to find when you're just completely off by one, but there's a lot of examples like that. And we actually had the same thing in the c plus plus client. So here you see the code for the fixed error. And the important part there is just that we changed the less than or equal and greater than or equal to less than. Sorry, we changed less than to less than or equal, and vice versa.
00:13:16.110 - 00:14:17.490, Speaker B: You can't see the full diff here because C plus plus doesn't have a code standard for line length, so they have very long lines. So moving on to another type of issue, we also had some non consensus issues during the audits, and this one was found by Martin in the bounty program. And it was an issue that had nothing to do with the consensus protocol. The clients were correct in the logic, but they had a very unperformant part related to the jump test instruction. And you could trigger this by making this contract where there is a single function that calls itself. So you could pass it like 1000, it would just call itself 1000 times. And each time it calls itself, it makes an external function call to make sure that you get a new execution environment.
00:14:17.490 - 00:15:19.906, Speaker B: And if you compile this and then post compilation manually insert jump test instructions in the place right there. Then you would have this very slow thing where both Golang and C were using a data type to store basically jump tests during the execution of contract. Right. And one good thing to note is that the, the cost is really cheap for a jump test, so you just pay a single gas for one jump test. And so what happened is that they were both using a set data type to store all the jump tests. And when you had a new execution environment in the virtual machine, like when you do an external function call, that data type was basically recreated. So in a single transaction execution of the same contract, it would have to be recreated.
00:15:19.906 - 00:16:12.694, Speaker B: So what was changed here was basically to use a map instead, and also to cache it between executions within a single contract. A short example of how to not do your encrypted was found in the C client where we have a spec from NSA actually. So I couldn't find this in the ECDSA spec itself, but it's present in the implementation guide from NSA where I've carried out the first steps just to focus on the last step, which is that there's a point about you have to check whether the derived public key is at point of infinity or not. And yeah, I think that was the wrong logo. So that's a real logger. Anyway, moving on. We're pretty short on time, so the fix for this was really quick.
00:16:12.694 - 00:16:58.450, Speaker B: In C Plus plus, where we just added a single check, there was already a field to track this, so you could just add check on that. But the point of this issue is that it was really hard to find. Even though the fix is really simple, it was hard to find because it's something that's missing from the code. Right. So a short example about the formal spec. We found a case where the formal spec was using the floor function to round signed integer division, and that was a case where the clients were actually rounding towards zero when you do sign division, but the formal spec was rounding to the floor. So that's the example I mentioned before where the clients kind of influenced back the specification.
00:16:58.450 - 00:17:52.166, Speaker B: Another example also in the formal spec around the same instruction sign division, is this edge case when you divide minus two, raised to two five, five divided by minus one. So this is kind of realization you have sometimes when you're working with this. And the problem is basically that the della paper didn't specify this, so you could do different overflow semantics and still be technically correct. So we had to add a case to just, you can see on the right hand side, it's the stack items we pop. So we add basically a special case for that. So my time is almost up here. So I'm just going to show a really quick thing, which is that when we launched, there was a note about that.
00:17:52.166 - 00:18:46.642, Speaker B: It's not really safe. Yeah, so post launch we found a few issues and I'll just show one really quick thing here, which was also found in the boundary program. This was found after launch in the Python client, where the Python client was not following the spec for suicide. So if you suicided a contract to yourself, you need to make sure that you set the balance to zero. Well, you need to make sure that's the case in any suicide. But if you suicide it to yourself, then in python you would actually still have that balance afterwards. Just one example we had post launch, and I'll just skip through a few other examples here and just go directly to some of takeaways.
00:18:46.642 - 00:19:27.350, Speaker B: So don't make your own blockchain. And if you do, it's a really good idea to have a formal specification and multiple clients. We've seen issues where we had a bug in single client, in two out of three clients. We've seen a bug in all clients. And we've also seen bugs where the formal spec was wrong, but all the clients were actually correct. And some of the things you have to really think about is the data types you use and the conversions off by one arrows. And also be really careful with cryptography because there's a lot of cryptography details that are not specified in the form spec.
00:19:27.350 - 00:20:20.574, Speaker B: They are simply referenced from the literature. And future wise we want to add more audits, perhaps on an annual basis. It would be great if we could include more clients in audits and also include these clients in the scope of the boundary program. The current boundary program reward is between half a bitcoin to ten bitcoins. And if you compare this to Google's bounty program, they offer a bit more in case you find kind of zero day exploits. So I hope that in like two or three years we can increase the bounty awards to match companies like Google or Facebook. Yeah, I'll skip this one and just go then.
00:20:20.574 - 00:20:20.700, Speaker B: Thanks.
