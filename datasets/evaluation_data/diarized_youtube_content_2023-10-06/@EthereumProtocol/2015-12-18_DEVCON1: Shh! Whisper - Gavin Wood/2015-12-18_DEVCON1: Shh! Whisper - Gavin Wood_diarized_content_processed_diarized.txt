00:00:20.730 - 00:01:06.610, Speaker A: So this is a quick talk and hopefully a demo at the end on Whisper. Hands up if you've heard of Whisper. So the first question to answer is why have whisper at all when we've got the blockchain? The blockchain allows people to communicate. We can just bake contracts, we can send transactions to contracts. They can be like messages. The main obvious answer is that it's really expensive. If you use the blockchain to communicate with each other, then you're paying essentially to have everybody else know about and archive all of those communications.
00:01:06.610 - 00:02:13.400, Speaker A: Minor answers also include hey, it's open. And maybe we don't want everybody else to know about what we're saying, but of course that can be achieved with encryption. So in essence there are aspects of decentralized application building where we don't need consensus, we don't want consensus, and what we actually want to do is simply do peer to peer communication. So within the, the framework of doing massively multi user applications, which when I say massively multi user applications, basically what I'm talking about are web apps, but also these days decentralized applications too, we see three main paradigms for communication. The first is static publication. So where we publish generally quite a lot of data and it doesn't change. It's the assets of a web page, it's the text of a story.
00:02:13.400 - 00:03:01.142, Speaker A: It sort of goes up there, it's maybe a movie, it goes up there, it stays the same. This is stuff that we already have pretty decent p to P tools for Bittorrent, ipfs and potentially even like FTP. We also see obvious sort of peer to peer communication strategies where it's point to point, right? So it's where I want to connect to one particular other identity and I want to feed them information. So when we think of this, we think of things like Skype, voiceover IP, real time communications. That's generally where we're headed in that direction when it's point to point. The final one is much more interesting than these two. The final one is transient datagrams is what I've called them.
00:03:01.142 - 00:03:38.526, Speaker A: But this is the kind of communication where we want to generally tell a group of people something for some limited period of time. So this is something that we don't really have a proper abstraction for yet. But you see it every day. You see it when you use an exchange. When you use an exchange, you want to communicate to a bunch of people, generally the people, the other people on the exchange, or the people at least on the exchange, that want to change a particular currency, you want to tell them a particular message and you want that message to run out after a particular period of time. So transient messages between groups of people. We also see them in things like Twitter.
00:03:38.526 - 00:04:20.030, Speaker A: Right. When I use a hashtag, I'm actually trying to reference a group of people who might be interested in something that I'm saying I don't want to reference everybody. So it's not like publication exactly, but a group of people and for a particular period. We can see some of the patterns within these massively multi user applications in terms of direction. So when we send email, it tends to come from a particular identity. It tends to go to a particular identity. When we use things like mailing lists or Usenet, we're going to a multitude of identities, but it's still coming from one.
00:04:20.030 - 00:04:45.160, Speaker A: And when we use kind of. There is also a kind of notion of global stuff where it's not really coming from anybody. Maybe it's an anonymous publication, but it's going to a whole bunch of people. Static content. Yeah, we already have answers for that. Real time communication in some sense. We have an answer for that within the Ethereum framework using the dev p to p stuff, maybe a raw connection over that.
00:04:45.160 - 00:05:42.170, Speaker A: But for the final paradigm, that's basically what WiSP is designed to address. So in terms of privacy, I think it's also important to remember that, and we probably know this much more than when I first authored this talk, but it's very important to remember that the metadata of the communications can often be almost as important to keep secret as the content of the communications themselves. Right. So we have a notion that metadata collection actually gives very useful information on what's going on. So if we want privacy, it's important to make sure that the routing itself is kept private as well as the content. So what actually is whisper? So it's a bit of an OD thing because it's not a messaging system. So we don't deal as being a pure point to point system for messaging, but it's also not a DHT either.
00:05:42.170 - 00:06:14.366, Speaker A: It's kind of a hybrid between the two. It has a couple of additional attributes. It has probabilistic message forwarding, which means the routing itself is kept private. It's kept private because actually there's no easy way of doing any analysis on it since it's probabilistic. It's also oddly oriented around subject key. So I'll show you later. But basically messages, normally when we consider messages, they have a very particular two endpoints.
00:06:14.366 - 00:06:51.786, Speaker A: They have the endpoint that they start and the endpoint that they eventually arrive at, but within whisper, that's actually played down. It's not a major part of the system. Rather, the messages have a couple of attributes that are very important. One of them are topics, right? So there's a notion that messages have associated topics, and it's these topics that are used to route the messages through the system. I'll come on to that in a second. So is it a DHT? Well, if we think of it in terms of a DHT, then it's multi key, which is to say, messages may have more than one key. These are the topics that I alluded to earlier.
00:06:51.786 - 00:07:28.598, Speaker A: It's multivalue, which is to say topics or messages that have the same keys. Actually, there can be different values associated to them, and it's transient, so they don't stick around forever. They have an explicit expiry date. And if we think of it in terms of a datagram transport layer, which we can do, then it's also got some interesting attributes. It is inherently multicast, which is kind of interesting. It allows for actually reasonably efficient dealing with things like hashtags on Twitter. And it's asynchronous.
00:07:28.598 - 00:08:18.250, Speaker A: So the messages, the two points from which the messages go between, don't actually have to be online at the same time. It's also got a nice little sort of inbuilt antidos system. It's not next generation, but basically we've got some good behavior incentivization in there. One of the important sort of tenets that whispers designed around is always considering identity and never considering endpoint. We consider endpoint to be basically an implementation detail to do with the hardware that it's actually running on. And as such, it fits a layer below this particular protocol. In terms of whisper, we never deal with the endpoints.
00:08:18.250 - 00:09:10.620, Speaker A: This is nice because it ties into the privacy thing. If you never deal with endpoints, then in principle, messages can never be tied to any particular physical location. Rather, they're tied to cryptographic identities. And that's quite an interesting attribute to have. Furthermore, the implementation is configurable in terms of what trade off the user, or perhaps even the application wants from efficiency and privacy. So on the one hand, if we want a lot of efficiency, we're going to have to give up some privacy because we're necessarily going to be closer to the metal in terms of routing the packets. Similarly, if we don't want a vast amount of privacy, then we'll be able to trade that off and get substantially faster transmission times.
00:09:10.620 - 00:10:52.010, Speaker A: It's topic based, which means when we want to communicate within whisper, we do so by naming, by associating topics which are small cryptographic identifiers with messages. In order to eventually rein in these messages which we may be interested in, we use the same mechanism. We use these small cryptographic identifiers in terms of the encryption it uses. The difference between a unicast message within whisper and a broadcast message within whisper is essentially the difference in which key it's encrypted with. Right? So we're not doing anything in terms of the sort of hardware close to the metal routing with this, what we're doing is saying, right, if it's unicast, I'm going to encrypt it with your identity, which means doesn't matter who receives it, we want everybody to receive it. In principle, the only person who can actually decrypt it is the recipient with broadcast, rather than encrypting it with a particular identity, we encrypt it with the topics, which means anybody who knows what those topics are are able, in principle, to decrypt the message. However, one of the nice things that's tied into this is the notion of router deniability, which is which, if I am merely storing a message or passing it on, and I was never interested in these topics, I will not be able to decrypt the message because I'm only dealing with what is essentially a partial topic, a small portion of this topic, which is sufficient for routing but not sufficient for actually decryption of the message itself.
00:10:52.010 - 00:11:26.228, Speaker A: Messages are authenticated as well. The difference between there being an origin, so it coming from a particular identity and it being anonymous is simply the difference between it containing a signature and not containing a signature. And this kind of ties into PGP with email. When you can sign a message, you can encrypt a message, or you can encrypt and sign a message. Same kind of idea, except it's actually built into the protocol now. It's important to also get across what Whisper isn't. So there's a bunch of stuff which it's definitely not suited for.
00:11:26.228 - 00:12:01.250, Speaker A: It's not suited for high bandwidth, point to point transmissions. So don't think that you're going to do Skype over Whisper. It's not going to happen. It's not particularly suited to low latency conversations, although it can be traded off to some degree. This isn't an application level protocol, so you're not going to use whisper directly in order to, say, take part in a chat room applications are going to be built on this, and it's not connection oriented. This is entirely about datagram messaging. There are two routes in whisper to routing itself.
00:12:01.250 - 00:12:37.096, Speaker A: One is passive, which is essentially a case of gathering nodes that tend to pass you the right messages. You throw out nodes that don't, and we call this peer steering. This is something that's on the roadmap to being implemented in the Dev P to P protocol. And the second one is active routing. This is essentially where we form what I've called topic vortices, or where I advertise that I'm interested in these particular topics. Well, technically partial topics. And my peers pass on messages to me, and they select messages.
00:12:37.096 - 00:13:18.996, Speaker A: They also pass on to their peers the messages that I'm interested in, although, because obviously it's an exponential trade off, it does so at a relatively lower accuracy level. So in terms of forwarding messages, we have this notion of serving one's friends well. We want them to stay our peers in general. We don't want them to go away, and so we want to behave well. We want to actually give them stuff they're interested in. There are three basic ways of determining this within the whisper protocol. One is interesting topics.
00:13:18.996 - 00:14:05.220, Speaker A: So the topics that we've already told them, hey, we're interested in this stuff, you should give us message, you should pass on messages that are actually conform to this. Another is the lowest time to live. So we want to prioritize messages that are actually urgent. And the third is the highest proof of work. So each message actually has an associated proof of work, which basically similar sort of thing to the blockchain. It associates particular amount of computation to this particular message. The way that we tell our peers about messages that we are interested in, topics that we're interested in is using this sort of masking filtering approach.
00:14:05.220 - 00:15:04.508, Speaker A: You actually use bloom filters, and we pass the bloom filters to our peers, and then they can actually test to see whether particular messages match these bloom filters. And if they do, they can send onto us. They can combine bloom filters and send onto their peers so that their peers tend to give them messages that we may then be interested in. This kind of filtering can be customized, potentially per peer or even per application, so that applications that may have very sensitive topics, we tend not to advertise to our peers, applications that are not sensitive at all, but actually do need to have much more real time characteristics. For example, maybe an exchange application. They would sort of be much more aggressive in telling the peers what it is that they're interested in. Yeah, I'll go into that a little later.
00:15:04.508 - 00:15:30.412, Speaker A: So the API has three functions. It's super simple, right? New identity, which creates a new whisper identity post. And actually that's changed. It was watch. It's now filter. Post just sets a message off onto the network and the filter is able to set up filters and check to see which messages have already arrived. There's an example of new identity.
00:15:30.412 - 00:15:49.416, Speaker A: It's pretty simple. You get a key back. There's an example of post. This is a bit more interesting. We can optionally send a from and a two. It's a bit od to have an optional from, right? Because normally as part of an API, we don't get the automatic ability to anonymize our messages. This one does.
00:15:49.416 - 00:16:28.550, Speaker A: It's also got a two. We can actually do a broadcast right from within here. That actually means comparatively little because we have topics to identify the sorts of things that this message is going to contain, which then allows the potential recipients to actually identify this from all of the various other unicast message, sorry, broadcast messages. We have the payload. That's simply a bunch of data. That's the actual body of the message and a couple of other things. Priority, which is the amount of work we're going to put in and therefore that's going to alter how likely it is other nodes to pass on this message sooner and a time to live, which essentially is the expiry date for the message.
00:16:28.550 - 00:17:01.308, Speaker A: Watch. And again, this is filter, but you'll see that later. Optionally has a two. Now this is very interesting. We're not automatically able to filter on the recipient of the message. We have to know in advance who the recipient is. Now if we know that we actually are going to want to filter on the recipient of the message and the original sender knows this, they will place that in the topics itself so that we can actually filter for these particular kinds of messages.
00:17:01.308 - 00:17:24.204, Speaker A: But intrinsically, the way that we receive messages are through the topics. They're not through the from the two. The from the two are essentially just the keys that we are signing with or encrypting with. There's a quick example. In this example, we're creating an identity. We're posting a message. The message is going to be from our identity.
00:17:24.204 - 00:18:09.776, Speaker A: So we are actually being honest about it. We're saying who we are. And the topic in this case is just an application name and the payload is just a message sort of saying, hi, what's your name? We're also going to have this watch here, which is watching for these kinds of messages. So it's actually watching for this kind of broadcast message identified via the fact it's actually this application. And when we find this, what we're going to do is just log to the console. Hey, we found someone who's asking us what our name is on the other side. We'd watch this broadcast and potentially we could reply to it.
00:18:09.776 - 00:18:32.964, Speaker A: So we would check to make sure that it's not us who is actually asking for people's names. Assuming it's not, then we're going to simply form a new message back to them. We're going to sign it from ourselves. We're actually going to use a two in this case. We're actually going to say who we want the message to arrive at. It's not a broadcast, and we're going to identify it with our topics. We're also going to identify ourselves as being as one of the topics.
00:18:32.964 - 00:19:40.048, Speaker A: We're going to put our identity in there in terms of where the protocol is going. One of the couple of things that we're going to sort of move into soon. Plausible deniability of the authoring, which is essentially a case of having the ability to have future people looking at messages not be able to determine that it was actually us who sent the message. But of course, at the time, there will be cryptographic certainty that it was us and modeling on precisely how scalable this approach is and what the trade off is going to be precisely between efficiency and privacy. So how much time? You'll have ten more minutes, right? Yeah. Okay, let's see if I can give a quick demo. How do I get rid of that escape? Okay, what happened there? Is there some reason that my.
00:19:40.048 - 00:20:04.100, Speaker A: There we go. Okay, very good. Okay, so this is Alice Zero. It's actually running a whisper node. Here is a console. So I'm first going to set up a filter. So this is going to filter messages that are incoming.
00:20:04.100 - 00:20:31.630, Speaker A: You probably can't see that. Maybe you can. It's pretty sharp. Basically I've got a topic set. The topic set is Devcon, and that's the only thing that's in there. So it's just filtering on the entire whisper system for all messages that have a topic of Devcon. And when it finds it's going to print something out to the console, it's going to print out the found message and then the payload, and then whoever it's from.
00:20:31.630 - 00:20:58.136, Speaker A: Okay, so that's created that filter. And the next thing I'm going to do, and this could be done on anyone's computer, but it's going to be done on mine because I've only got one here. And this is going to post the message. So the message it's posting is a message whose topics are Devcon. So the first thing can find it. And the payload is going to be world. There we are.
00:20:58.136 - 00:21:21.120, Speaker A: And there's a time to live, which is a minute. Yeah. And what we see is that found message, found message world. And it's actually from the null address. The null address just means that it was not actually signed by anybody, so we don't actually know who it's from. Okay, pretty simple. Next thing, let's create an identity.
00:21:21.120 - 00:21:43.700, Speaker A: There's an identity. That's our key. So this is actually just an ACDSA public key that it's returned. The actual private key is managed internally in alice zero. And what I'm going to do is just send that exact same message. But I'm sending it. Actually, you know what? I'm going to change the payload so we can tell the difference.
00:21:43.700 - 00:22:00.744, Speaker A: This is going to be. Hello. The important thing is that I'm sending it from that identity. There it is. From id, found message. There's our new payload. And yes, we know now that it's coming from that particular identity.
00:22:00.744 - 00:22:16.284, Speaker A: Right. Okay. We know that because it's actually been signed. So it's not just some insecure sort of thing attached to it. It's a proper signature. Now then we're going to have another identity. This is my identity.
00:22:16.284 - 00:22:44.170, Speaker A: So it's Gav. Gav is equaling a new identity. There's my identity ox, 1282 sf. And I'm going to set up a new filter. This one's just going to filter for messages with the topic Devcon gav. Right now we have to tell it actually up front that it needs to decrypt with my key. This is to avoid having any additional metadata in the message body itself.
00:22:44.170 - 00:23:18.592, Speaker A: So we're saying all messages of topic devcongav are actually going to be sent to me. Now. We're going to set up a watch for that and say that it's just actually going to print a message, found message to Gav with a payload and then it's also going to tell us who it's from. So I do that. And of course nothing comes back because no messages have been sent yet. But hey ho, here is a post. So we're going to post using the Devcongaf topic and the payload.
00:23:18.592 - 00:23:46.510, Speaker A: There is. Let's change the payload. Make it something interesting. Hello, Gav. Where's the from our original identity OXCB four d blah blah blah. But this one it's to. There we are.
00:23:46.510 - 00:24:05.660, Speaker A: Let's use double quotes instead. And there we go. Found message to Gav. Hello Gav, where's the beer? And it's sent from that particular identity. Cool. Yeah, so it's super simple. As you can see, payload can be whatever you want it to, you know.
00:24:05.660 - 00:24:48.640, Speaker A: In principle, byte data send images around, whatever it will be. Probably it's going to be mostly ASCII with a few hashes, and the hashes would then lead on to some other systems publication, ipfs or whatever the topics. There can be an arbitrary number of topics. The topics can be anded or owed together so that we can say, right, it's got to contain one of these two topics in the first place, one of these five topics in the second place, and the third place must be this topic. That all works fine. And yeah, obviously the time to live. I haven't bothered doing anything with the proof of work priority stuff, but the principle is there and it works in practice.
00:24:48.640 - 00:25:16.816, Speaker A: This is proof PoC three. This is in the CPP code base. I understand it is being currently implemented in the go code base. I think goes up to PoC two at the moment. And there's substantial interest in the other code bases for putting all this stuff in. Yeah. If you want to contribute and help develop this, then get in touch and otherwise.
00:25:16.816 - 00:25:18.190, Speaker A: Thank you. Any questions?
00:25:33.720 - 00:25:59.048, Speaker B: So two days ago we discussed that one paradigm of building scalable Dapps is creating sophisticated state channels, and I'm wondering whether Whisper is the right protocol to distribute transactions that happen on those state channels. Is Whisper suitable for that?
00:25:59.134 - 00:26:43.060, Speaker A: Yeah, this is actually something that I would like to take forward, I think with blocks and obviously the stuff that Zolt was talking about before, the various bits of data regarding the blockchain. This is all static data and fits well into the ipfs swarm sort of paradigm. Transactions definitely are much more ephemeral. Data that float around generally have broadcast semantics, potentially exist within different networks for maybe private subnetworks. So yeah, Whisper would work particularly well and it would be really cool if we can make the transaction publication stuff actually be just an application that sits on top of Whisper. Yeah, definitely. Cool.
00:26:43.060 - 00:26:52.440, Speaker A: Thanks guys. Fantastic. It's.
