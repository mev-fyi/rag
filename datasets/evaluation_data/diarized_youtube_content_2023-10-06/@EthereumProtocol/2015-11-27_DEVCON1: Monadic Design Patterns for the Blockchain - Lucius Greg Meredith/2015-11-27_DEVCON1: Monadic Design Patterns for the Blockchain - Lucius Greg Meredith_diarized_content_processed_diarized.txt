00:00:18.490 - 00:01:15.902, Speaker A: So first of all, thanks to Vitalik and Vlad for asking me to come, and it's great to be here. I'm glad to be able to deliver a few impressions. I think in 25 minutes, that's all I can do is deliver a few impressions. Vlad and I've been working a lot on Casper, and kind of the technologies and tools and ideas that I'm bringing to the formal verification of Casper are also embodied in some of the ideas that I'll be presenting here. So kind of just want to touch on an overall narrative. And really, if you walk away with nothing else, I want to leave you with this one big picture idea. But in the details, there's enough space for God and the devil, right? So there's always lots and lots of space in the details and maybe talk about some next steps.
00:01:15.902 - 00:01:42.998, Speaker A: So that's kind of what we're going to do. And the narrative is actually a fairly simple one. It's fairly straightforward. Consensus is a necessary component of the blockchain. So you heard Vlad talk rather eloquently about consensus and some of the problems there. It turns mean. I think many of the people here know that blockchain, currently as embodied, doesn't scale very well.
00:01:42.998 - 00:02:42.510, Speaker A: And Casper's variation of the proof of stake is an important step along the way towards scaling. I wouldn't say that it's the solution to scaling, but it's one component of a scaling. So we want to look at proof of stake, and in particular the casper variant of proof of stake, and really bash on it from the point of view of formal verification. We'd like to know for sure, once and for all, whether Casper enjoys certain properties. And so one of the tools that we're using to go about this is something called the applied PI calculus, and I'll show kind of where we are in the state of that later in the talk. But this gives us access to automated support for proof of correctness. So the tools that we're employing right now include Proverif, but much more the spatial logic model checker, which was developed by Luis Carrey.
00:02:42.510 - 00:03:41.358, Speaker A: And that turns out to be good fun. And if you want to look at the code, it's up on GitHub, and I'll give you a link a bit later. But it turns out that if you have a spec in the applied Py calculus, well, I have a bunch of libraries that up on GitHub called special K, and they are an implementation, an executable distributed virtual machine of the applied PI calculus. So if you have a spec, you can turn it straight into an implementation. So if you have a spec that you can reason about the correctness properties, then you can actually run Casper. And so this has big implications for the correctness of an implementation. What you get is correct by construction, and that's a different approach to design than I think happens in a lot of the software industry.
00:03:41.358 - 00:04:13.738, Speaker A: But in particular in this space, I'm, I'm not sure that the blockchain as originally conceived was, was done in a correct by construction style. I think it was quite the opposite, actually. But if you take on correct by construction, this helps with scaling. There are a lot of different aspects to scaling. Right. It's not just about volume and performance, it's also about when you have reliability. Reliability is what engenders adoption.
00:04:13.738 - 00:05:25.766, Speaker A: Right. So you think about, you're someone who manages a large financial firm and there's this great new technology that promises wonderful things, but am I going to swap it out for the thing that works? Well, I might be more inclined to do that, take on some of that risk if I knew that it had certain reliability properties that were formally and automatically verified. It also helps with maintenance and evolution, because as we know, this space is changing very fast. And so it's kind of important to be able to adapt the code to the needs of the space. So it turns out that in addition to some of these benefits, special K, already of its own, provides a broad range of transactional semantics. And we get these because of the monetic decomposition of the elements that are used to make these kinds of transactions. And I'll go through those.
00:05:25.766 - 00:06:21.030, Speaker A: But there's basically a handful of programming paradigms that are used successfully today in building distributed systems. And it turns out that you can organize all of those under a single rubric, under essentially a single API. Additionally, the compositional nature of the PI calculus. So I'm just giving you some sense of all the benefits of this kind of approach makes it possible to write down in a single page a metered, distributed concurrent vm. So just for fun, I'll show you that spec right at the end. That's some nice feedback, that's some really nice high frequencies. Okay, so the big picture is that compositionality is the key to scaling any system.
00:06:21.030 - 00:07:16.280, Speaker A: So if you forget everything else in this talk, if you remember that one idea, I'm hoping to plant that seed in your mind and go home and think about that. So what the hell is compositionality? Is it even a word? Right? If spell check is going to underline it in red, I guarantee you. So let me kind of unpack this idea in computing. I think we're all familiar with the idea that scaling refers to lots and lots of copies of things that are potentially not reliable individually. So lots of chips, lots of boxes, lots of databases, lots of servers, lots of data centers, right? So that's the traditional high volume, high performance notion of scaling. Compositionality turns this upside down. And what it says is that scaling is about making the large reflect the small.
00:07:16.280 - 00:08:30.138, Speaker A: And every child understands this idea. They hold up the leaf, they look at the leaf, and they say, hey, there's a tree inside this leaf, right? And that is, in fact, how nature scales. And we see it again and again and again. And it's kind of funny. Why is it that we forget we knew this at one point, and then we forget it? And why is it that we forget this? Well, it turns out that it's actually a fairly new thing for culture to remember this. So I'm just giving you a few examples from pop culture of this idea, and you'll notice that all of them, I mean, even Mandelbrot sets, are very new on the cultural landscape, right? And just to give you another sense of how interesting and different this way of thinking is, so here's a bunch of people who had computationally very effective ideas, right? So maybe you recognize Paul de Rock, maybe you recognize Erwin Schrodinger. But quantum mechanics, as formulated in those days, was not compositional.
00:08:30.138 - 00:09:12.586, Speaker A: And it's only been in the last five years that we've had a compositional formulation or presentation of quantum mechanics via Samson Abramsky and Bob Kuka. A similar thing has happened in the physics of the large gravitation and cosmology. And because we don't have good compositional accounts, physics fails to scale. We don't have a nice way to marry those two ideas. So if you're feeling like, hey, I'm not quite sure what compositionality is, I'm not sure. Well, these guys didn't either, so it's kind of okay. But what I can say is that the notion of composition has nice formalizations.
00:09:12.586 - 00:10:08.282, Speaker A: So, since about the 1950s, there's been an appropriately parametric notion of composition that was formulated first in category theory, and it was given this weird, crazy name of a monad. If you pair monads with their dual mathematical widget, the comonad, you can think of them. So composition is kind of like nesting, right? It's like the russian dolls you nest. It's like the tree inside the leaf and the leaf inside that tree and the tree inside the leaf, right? So it's about nesting what monads and comonads give you. Monads give you a way to zoom out, and comonads give you a way to zoom in on this nesting phenomena or this composing phenomena. Unless you think I'm talking about abstract airy fairy stuff. Again, all I can do in 25 minutes is give you a few impressions.
00:10:08.282 - 00:10:44.282, Speaker A: Right? So here are effective APIs expressed in the language scala. You can find similar expressions in the language Haskell. Just out of curiosity, how many people code in functional languages here? Awesome. How many people use monads in their daily practice? Yeah, quite a few, less. Okay. But the point is that they are an effective notion and they're a great way to structure code. Even if you're not thinking about scaling blockchains, they're a great way to structure container code.
00:10:44.282 - 00:11:35.260, Speaker A: They're a great way to structure, control flow. But it turns out that we can do better than that. So in particular, special KVDB looks at a duality between continuation, which is the rest of your program. So let's say your program walks up to the blockchain and says, I'm looking for something, and what if that something isn't there yet? What do you do with that program that is waiting for data and can't go further, right? So in special K, what happens is the rest of that program is packaged up as a piece of data and stored at the place where it was looking for something. So that's the continuation. And then data is dual to that. And in fact, you can have a notion of data integrity that goes all the way back to the law of excluded middle, right a or not a.
00:11:35.260 - 00:12:13.282, Speaker A: That has to do with this duality between continuation and data. So at this location that you're looking for this address on the blockchain, or in the case of special K, it's a more sophisticated kind of key. But at this location you will either have a continuation or some data. And if a program is looking for data and it's not there, the continuation will be stored there. If a program is depositing data, if there is a continuation there, that continuation will be woken up and handed the data. Okay, that's the basic setup right? Now. You can ask some questions about that setup.
00:12:13.282 - 00:12:50.350, Speaker A: You can say, well, after the data and the program, the continuation meet each other, what happens? And there are only a handful of possibilities. One is the data disappears and the continuation disappears. So they meet each other in this abstract space, this address, and they go poof. All right. Another possibility is that the continuation remains and the data goes poof. Another possibility is that the continuation goes poof and the data remains. And the last possibility, of course, is that they both persist.
00:12:50.350 - 00:13:45.198, Speaker A: Right? What does that have to do with traditional approaches to distributed applications? Well, if the data persists and the continuation evaporates, that's just traditional database operations. Think about a read, right? My program wants the data, I read it, but I don't get rid of it out of the database just from the read operation. Right? That's traditional database operations. If I publish and the publishing data is ephemeral, but the continuation persists, that's ordinary publish and subscribe. That's ordinary publish and subscribe. And if both of them persist, it's publish and subscribe with a history, with a backlog of what you published. And finally, this is quite interesting.
00:13:45.198 - 00:14:47.922, Speaker A: If they both disappear, then you get item level locking in a distributed transactional semantics. So one API, which I showed you, nothing up my sleeves, one API, the monatic API, covers all of those distributed programming paradigms. Now, how does this apply to the blockchain? Well, how we provide that, is that the continuation monad, is the monad underlying being able to bring those patterns together. Right. So we talked about this duality between continuation and data. Well, it's the structuring of the continuations in the way we store them that uses the continuation monad to provide that unification of all those programming paradigms. So we looked at that API.
00:14:47.922 - 00:15:31.334, Speaker A: It turns out that if you just tilt that API on its side a little bit, what you end up getting is the applied PI calculus. And that's exactly how special k is organized. So if you look at special k, if you go to GitHub right now and you look at special k, what you'll find is a little DSL that provides an implementation of the applied PI calculus. But here's a little preview of applying that API to Casper. So I spent last night and refactored this. I had good fun. So let's see if I can, can you see that? That's all going to.
00:15:31.334 - 00:16:25.190, Speaker A: Again, I only have time to give you a flavor. So here are the files in the spec, and let's take a look briefly at just some of them. So in Casper, the consensus protocol is organized around nodes, which we think of as validators. And what a validator wants to do is essentially receive blocks and then make bets on whether or not a block should be published to the blockchain. And here's basically just an applied PI calculus spec of the betting, and the convergence around betting spec for the validator. And you can see how tiny it is. It's teeny tiny.
00:16:25.190 - 00:17:32.486, Speaker A: Wow, we're already at 2 minutes. Okay, come see me afterwards and I'll show you probing this spec for properties. Okay, so I'll cut to the chase, but I would like to just come see me afterwards and I'll give you a lot more of the flavor of the spec and how we can probe it automatically with the spatial logic model checker. But I would like to conclude by just taking you through a little bit. Taking these same kind of specs and using the compositional structure, we can walk this structure, we can essentially build up a new semantics from the existing semantics in a nice, clean, careful way. So I took essentially a variant of the applied PI calculus, and I added to it metering. And this metering basically uses three elements.
00:17:32.486 - 00:18:20.890, Speaker A: So there's a resource and a channel for the exchange of the resource, and there's a channel for the next step. That next step is again an encoding of a continuation. And what we see here is essentially just a tiny little harness for running a metered vm. We run inside that harness the translation of our little tiny API for contracts. But this API and this contract language is a little different. And the reason it's different is because contracts can be executed in parallel. Contracts have other interesting properties in that contracts themselves can be reified and exchanged.
00:18:20.890 - 00:19:18.430, Speaker A: The important point here, again, I'm happy to go through all the details with you offline, but the important point here is the size of this spec. And not only the size of this spec, but the correctness properties of this virtual machine can be stated and proved in about a half a page. Right? So even more interestingly, you can take this kind of virtual machine and bootstrap, so you can build this virtual machine on top of this virtual machine. Now it would be interesting to look at doing that with the existing VM. That would be an interesting question. Could we build the Ethereum blockchain on top of the existing VM? Does it bootstrap? And that brings us back to the point I was trying to make at the very beginning. Do we have this self loop? Because that's your first and best test that you can scale.
00:19:18.430 - 00:19:34.000, Speaker A: So the big picture that I want to leave you with is that compositionality. This kind of finding the small and the large, the large and the small is the key to scaling any system. So thank you.
