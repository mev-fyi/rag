00:02:43.470 - 00:03:38.640, Speaker A: We are live. So this is our 28 or 28 four call now morphed into the full dencoon testing calls. So there were a couple of things people wanted to bring up today. So one, what we discussed on our cordes last week, so all the proposed changes to 4788. And then the second big thing that came up was the issue around 868 interop and the encoding of the transaction type there. And I see Alex is not on the call, so I don't know if we might want to wait for him to do the 4788 stuff. So instead I guess we should probably start with the E 68 issue and then can do 4788 after.
00:03:38.640 - 00:03:59.640, Speaker A: Okay, so Alex can't make the call. Okay, let's just keep going with E 68 and we can do 4788 after then. I know Andrew, you're the one who posted this on the agenda. So yeah, you want to give some context on.
00:04:04.010 - 00:05:03.340, Speaker B: I think it was not me who discovered this problem, but I think it was ethereum JS guys. And basically the problem is that how e 68 is implemented in most clients. I think in all El clients except for Ethereum JS is not in line with the spec and the difference is minor. It's how announcement types or different transaction types are encoded. And because the majority of the clients already implemented in one particular way, the same way geth implements it, I just suggest to update the spec so we will minimize the necessary changes. It's probably the easiest thing to do.
00:05:05.790 - 00:05:55.194, Speaker C: Yeah, it is a bit weird though. The reason why I wouldn't say it's necessarily the best idea to update the spec to what it is now is that current encoding is kind of weird. I mean, it's basically an accident, because in the go library for RLP, if you put an array of bytes, it's going to encode it as a byte array, kind of expected. But then when you put any other kind of array then it puts it as a list, which is also expected. But it's kind of weird to have this, to have the TX types as a byte array because it's just not. I don't know what if there's ever going to be like, I mean, it's all hypothetical anyway. I don't really know, it's maybe not.
00:05:55.232 - 00:06:05.038, Speaker B: The most elegant, but I think if we do that, update the spec, then we just minimize the amount of busy work.
00:06:05.204 - 00:07:01.842, Speaker C: Yeah, that's true, that's true. The idea was kind of to like, I was kind of curious why in the first place it was decided to put these things in separate lists, actually. And in the discussion, nobody really knows. Does anyone remember? To be honest, I have a bit different thing to say, that we cannot really change ETH 68 and implement it properly because this is already in production, already running. So we have to accept ET 868 as is, and we can only fix it in ET 69, for example. Yeah, there's no plan right now to change the E 68 anymore. It is what it is now.
00:07:01.842 - 00:07:12.040, Speaker C: My question is more like, why was it already decided that? Should we maybe make another change for E 69? First of all, is anyone in favor of it?
00:07:13.770 - 00:07:25.500, Speaker B: No, because I think it's just unnecessary. We don't have a problem. The problem is that the problem can be easily addressed by changing the spec.
00:07:27.070 - 00:07:52.580, Speaker C: Yeah, I know. It looks pretty bad, though. I mean, would it be okay for you guys if we basically leave it, but then I will make a note, and then when we make the E 69 for another reason, we will include this change as well. Like just improve this message somehow to look better. Would you guys agree with that, or do you think that it should never, ever be changed again?
00:07:53.270 - 00:07:55.060, Speaker B: No, that's fair.
00:07:55.590 - 00:08:37.120, Speaker C: Okay. Yeah, I can be okay with that as well. Change this back now, but then leave it for next time to clean it up. I made a quick inquiry how we got to this point, and we haven't found it at the beginning, so we actually, I think, wanted to implement it correctly. But then the guys who were implementing, because it wasn't me, actually were confused by the hive tests, which didn't work with the proper schema. So it kind of like propagated from GAF and that's not great. Yeah, that's true.
00:08:37.120 - 00:09:37.886, Speaker C: Like I said, I think even if somehow, I mean, the hive tests are not based on Geth in the regular way, it actually implements a protocol by itself, but it also implements it incorrectly because, like I said, this mistake is really too easy to make and go because of this by the way thing. But my question was another one, which is like, if anyone maybe remembers why it was decided that in E 68, these announcements should contain these, like, three separate lists for the types, sizes, and hashes. It seems kind of counterintuitive. Maybe it would be better to somehow have it so that, I don't know, we have, for example, triples in a list or something. But then you would have encoded triple separately, right? I don't know. I don't think it would make any difference, to be honest. I just found it curious that somehow it was decided to have these, like three separate lists for the separate items.
00:09:37.886 - 00:10:12.398, Speaker C: It's kind of an OD encoding, I feel. But at the same time, if you guys. Nobody seems to have any issue with it. It was more like a question. I remember the discussion, but I don't remember the exact thing. You're right, because I remember that I also wasn't sure that this was the best idea to go with release, but it wasn't too bad. That seems to be how everyone feels about it, which I find kind of funny, to be honest.
00:10:12.398 - 00:10:42.600, Speaker C: Everyone I asked was, you know, it's not the best, but it's also not the worst. Ask Marius. Maybe he. Yeah, I think he's on vacation. But anyway, I mean, we can just leave it now. So I will basically make a note in this issue in the dev PW repo that it's like for the next time, and I will change this back to have the byte array. It's weird, but we can accept it and move on, and then there will be the least amount of changes.
00:10:49.040 - 00:11:04.196, Speaker A: Sorry, I was looking for your unmutement. And when you say leave it now, it's basically we do the change to the current E 68 spec as basically proposed, and then also move this change. Also have this change as part of E 69, correct?
00:11:04.378 - 00:11:18.276, Speaker C: Yeah, we will change something in E 69, but it's not that important what it's going to be right now. Maybe we will go to the triples after all in the next version. Let's discuss it another time and let's just ship cancun.
00:11:18.388 - 00:11:23.480, Speaker A: Okay. Are you able to make that spec change, Felix?
00:11:25.500 - 00:11:26.056, Speaker C: Yeah.
00:11:26.158 - 00:12:07.130, Speaker A: Okay, awesome. We'll wait for your pr there. Thank you. Anything else on the E 68 issue? This is going to be included, not Duncan. Did I understand it correctly? This is one after Duncan. So E 69 would be after Denkun, but we will make a fix so that all the clients basically have the same implementation for Cancun as part of the E 68 spec. Does that make sense? So that should come to eight already.
00:12:07.130 - 00:12:39.810, Speaker A: Do we want to have that? I guess ideally we want to have everything in Devnote eight. Okay. That's what we've been saying in four weeks now, but we just keep adding stuff to it. So that's why I'm just curious, what do we want? Because right now Devnet seven is quite old and irrelevant. So it would be very good if we could launch this week. Definitely even. Yeah.
00:12:39.810 - 00:12:52.050, Speaker A: And then the question is, though, this in a way is more like a bug or like a disagreement in implementations. Like, some clients are going to have to change it regardless to communicate with other clients, right?
00:12:53.340 - 00:13:21.808, Speaker B: It mostly will be a no change, because I think all the El clients except for Ethereum js already implement kind of the gas flavor. In fact, there will be no difference between Devnet seven and Devnet eight. But formally we can count as a difference as a change to the spec, which brings the spec in line with the reality, actually.
00:13:21.894 - 00:13:25.490, Speaker A: Right. So Ethereum js would have to make a change, basically. That's the only one.
00:13:26.260 - 00:13:26.816, Speaker B: Yes.
00:13:26.918 - 00:13:46.010, Speaker A: Okay. Yes, I think we should do that then. So let's mark it explicitly as included as part of. Net eight. But in practice, the implementations won't have to do anything except ethereum js. Yeah, just chiming in, we already have this change. Okay, nice.
00:13:46.010 - 00:14:28.106, Speaker A: Yeah. Okay, sweet. Does that make sense to you, Barnabas as well? Yep. Okay. Anything else on this? Okay, so next up. Yeah, the last big thing and change to the spec is what we agreed to with regards to 4788 on awkward devs last week. So basically to move from using pre compile for the EIP to using just a normal smart contract.
00:14:28.106 - 00:14:50.180, Speaker A: And then the two biggest questions were which contract? How do we deploy the contract? Do we assume it's deployed prior to the fork, or do we have deployment mechanism as part of the fork? And then what actual contract should we be using? Lakhline, you said you and Martin may have an update on one of those?
00:14:52.490 - 00:15:43.202, Speaker D: Yeah. Okay. Yeah, there's a pr to the 4788 spec. I'm not sure if people have had a chance to look at that. That was kind of the proposal based on what I understood we discussed from all core devs and on those two questions about how to get the code there and what code to use. The answer that I used in the PR was we would deploy the contract before the fork once we agree on the bytecode, and then set in clients that address as the address to make the system call to and the bytecode. I wrote an assembly implementation with some help from Martin and Joaquin, and that's the proposed bytecode for 4788.
00:15:43.202 - 00:16:07.440, Speaker D: It's got a get and set functionality where you can get the root based on timestamp, and then if you are calling as a system address, you can set the timestamp. So I guess the main question is, how are we going to get the code there and how are we going to update the roots? Those are the two things that seem to be debated right now.
00:16:09.650 - 00:17:21.640, Speaker A: Well, if I could just add so there. One more thing I think is being debated is whether to have ABI encoding on the user facing loading part. So there's the ABI encoding, yes or no, what deployment methods you use? And then I think it was primarily Danny who raised the question, should we even have a path in the contract for the updating instead of because previous EP version just did the update directly onto the storage of the contract? And yeah, I've already commented this on his comments. If we have the path in the contract, then it's still up to the client. A client implementer can still choose to do the update directly. If they want to do that optimization, that's fair game. They can do it.
00:17:21.640 - 00:18:02.960, Speaker A: If you want to have a more simple client, you can just invoke a system call and let the evm do what the evm does. Yeah, so that's kind of the argument for doing it as a system call instead of mandating it as a direct update. That's all I had to add. Anyone else? Yeah, have thoughts on that?
00:18:05.090 - 00:18:22.130, Speaker B: Yeah, I think regarding the ABI, if I remember correctly, for gnosis chain and for aurora in general, we do use ABI, so it would be nice to also use ABI for consistency for this contract.
00:18:23.590 - 00:19:48.096, Speaker A: So what are we talking about here is the user facing part. So when you want to get the beacon route, the original e just said that you send 256 bit integral to the pre compile. None of the current pre compilers have API for requesting data, thus they are a bit clumsy and it's kind of hard to interact with most of them until the solidity compiler gets native support for them. If they would have, or if this new one does support AI encoding, then nothing needs to be added in whatever compiler you want to use, you can just cast it to an API interface and then they get beacon route. So I'm not talking about the system call here, I'm talking about the user. So for consistent, if we want to be consistent with previous pre compilers, then we would say no ABI because we don't do that for pre compiled. But if we want to be more like acknowledging the de facto standard of data exchange between contracts in Ethereum, then we might want to go with API.
00:19:48.096 - 00:19:50.100, Speaker A: That's kind of my impression.
00:19:55.980 - 00:20:49.210, Speaker D: Yeah, I guess my take is it feels like we're starting to blur the lines between the application layer and the core. Yeah. Right now the way that we do ABI encoding is very ubiquitous, but I know there are other compilers that want to do things differently and it just doesn't feel right to enshrine this behavior into a system contract. And also this is not going to be a commonly used system contract. I think mostly liquid staking tokens want to use this. So there's not going to be a huge rush of people doing the ugly raw call interpret a 32 bytes. So I don't think there's a lot of advantage of just making it work nicely with solidity from day one.
00:21:02.190 - 00:21:18.960, Speaker A: Yeah, so me and Lightslient have had this discussion a bit. I'm curious to hear what other people. How other people feel about it. Yeah, I would currently be in favor of using the API, but I can also understand clients comment about.
00:21:23.350 - 00:21:49.770, Speaker E: There'S also. What's going on is there's a read mode and a write mode going on in the same address. All the other smart contracts, smart contracts, all the other system contracts generally had one mode going and we even split up the. I was able to get the BLS to split up into separate modes. So if there's multiple modes, either we need two contracts or we need some standard way to split between the modes. And that standard way is Adi.
00:21:57.310 - 00:22:02.190, Speaker D: I mean, I really don't think we should be. You're muffled, Martin.
00:22:04.290 - 00:22:12.370, Speaker A: Sorry, I was just going to say that in this particular case we are splitting on the sender.
00:22:16.470 - 00:22:32.470, Speaker E: True, but that's still two modes. So you're splitting on the sender or you're splitting on the input data. There's modes. It's the same as changing. The owner of a contract also splits on sender. You either revert or you actually change the sender.
00:22:40.510 - 00:22:44.790, Speaker A: What do you think? I don't really understand what you're saying, donna.
00:22:44.950 - 00:22:52.830, Speaker E: I prefer the ABI method because we're going to the direction that smart contracts are behaving like, so we should just embrace it and do the ABI.
00:22:53.650 - 00:23:10.580, Speaker C: Yeah. I'm also curious, what's the argument against using the. This is more for the non Avi camp like in your mind, what's the thing that makes you not want it the most?
00:23:15.520 - 00:23:42.390, Speaker D: I think it's enshrining behavior that shouldn't be enshrined. There are other compilers who want to have different ways of calling functions, and I don't think that forever in perpetuity we should say that the way that solidity chose a long time ago is the way to do it. This is a system contract and we shouldn't be choosing standards like that.
00:23:44.280 - 00:23:51.160, Speaker E: Yeah, but Viper uses the ABI. Is it that fee and some of the others don't?
00:23:51.580 - 00:23:53.470, Speaker D: I know Phi doesn't want to.
00:23:54.720 - 00:23:57.660, Speaker C: Do we have other arguments against the ABI?
00:23:59.200 - 00:24:02.270, Speaker D: I mean, I think the ABI isn't good in the first.
00:24:04.080 - 00:24:04.444, Speaker A: So.
00:24:04.482 - 00:24:09.810, Speaker C: But. Okay, so these are the two things that you think is the most important is anyone else has any other.
00:24:10.180 - 00:24:32.810, Speaker D: It's also more expensive, extra four bytes that aren't necessary because we're splitting on sender. So it's not really semantically useful. The only advantage of the ABI is that it worked out of the box with solidity, and I don't think that's a good reason to make a change like this.
00:24:34.220 - 00:24:42.890, Speaker C: Okay, so it seems you feel very strongly about not using the AVi, and that's okay. Just wanted to know what your thoughts are.
00:24:46.400 - 00:25:43.740, Speaker A: If I could just one more thing. So I agree. So I think you said that it works out of the box with ABI and that's the only reason. But the counterargument to that is I found that it is very difficult to get it to work with solidity if you don't have the API. I might be wrong, but you need to pass input and you need to make solidity expect output. And it maybe it's possible, but it's definitely not triviable. And it's kind of not nice to force people to go into assembly mode to interact.
00:25:46.480 - 00:25:50.770, Speaker D: You don't think you have to go into assembly, do you? I think you can just do a raw call to the address.
00:25:53.460 - 00:26:02.710, Speaker A: I think the output might, the fact that it returns data might be a bit problematic for the roll call.
00:26:03.240 - 00:26:09.028, Speaker D: You can cast it to bytes 32. It's not nice, but you should be.
00:26:09.034 - 00:26:22.036, Speaker A: Able to do it. Compiler, the size of the output? Yeah. I'm not sure, maybe not, I don't know, sufficiently to really say, yeah, I'm.
00:26:22.068 - 00:26:28.460, Speaker D: Also not sure, but I wrote some tests with it and it wasn't terrible. Terrible.
00:26:29.440 - 00:26:42.850, Speaker A: Tim is asking if we can add the API later. The answer is no. Okay. The API means it has 36 bytes input. No. ABI 32. Got it.
00:26:42.850 - 00:26:51.700, Speaker A: Um. Yeah, I don't know how we make that decision.
00:26:55.640 - 00:27:01.030, Speaker C: I would wonder something. Do you guys think this contract will ever be extended in any way?
00:27:04.860 - 00:27:06.010, Speaker D: I don't think so.
00:27:06.620 - 00:27:17.290, Speaker C: Yeah, well, I mean we always think that, but then in the next fork it's like we want to add this field here that we just invented and why not stuff it in the same.
00:27:20.860 - 00:27:47.460, Speaker D: For sure. I guess this also kind of touches on the point of how to get the code into the state. And I generally would rather we use the standard transaction deployment mechanism rather than doing a regular state transition to add it. If we do in a regular state transition, then I think it's more likely that in the future we just modify the code. But if we deploy it as a transaction where it's just a regular part of the chain. I think it's less likely.
00:27:48.040 - 00:28:21.330, Speaker C: Well, I mean we can't really upgrade it then. Yeah, well that's not true. This contract is kind of like we could always, if we want to make a change to it, we could just create a new contract that is somehow better and then basically make it invoke the old for any query that goes beyond a certain block or something. It would always be possible to change it.
00:28:22.260 - 00:29:10.130, Speaker A: Yeah. By the way, just wanted to add, I realized that you're correct that now that we have return data it's not such a big problem anymore. And I looked at this solid example, it's not actually that painful to do a call even if you don't have. So I still prefer the ABI, but not as strongly so. Proto has an idea in the chat of having bindings for the contract that I guess would be a separate contract that we can just write and have anyone deploy if they want the ABI. Is that what you're saying, Frodo? It's kind of like an ABI wrapper, yes, basically.
00:29:11.060 - 00:29:43.128, Speaker F: So you could compare this to multicall or some other popular permissionless contracts that do a thing for UX do not really change the behavior of the virtual machine. So you could have a contract that does a delicate call into the pre compile or can you call it pre deploy anyway, the special contract of the storage route and provide the API does that.
00:29:43.294 - 00:30:04.032, Speaker C: Yeah, but it's questionable if this is going to be used then because literally this will only serve to just drive up the gas cost for something that you can actually do way cheaper if you just call the real one. This would just be like wasting gas for the code to look good.
00:30:04.166 - 00:30:07.330, Speaker A: Yeah, but then people can choose to do that, right?
00:30:08.580 - 00:30:29.770, Speaker C: Yeah, I mean they could also just import like a solidity library that makes it possible to call the contract in the normal way like that it expects. I mean if you're worried about the solidity, there will always be this. It's not going to be that complicated to call it. So it's literally just going to be this snippet that you can use.
00:30:30.620 - 00:30:37.630, Speaker A: Yeah, now that we have return, I mean it was per month, but I forgot that we now have return data. So now it is actually not that difficult.
00:30:45.040 - 00:30:45.790, Speaker C: No.
00:30:51.980 - 00:31:17.250, Speaker A: So has anyone shifted their view thinking? And I guess the reason I ask is it would be valuable to agree on this sooner rather than later because we're going to want to get the contract code audited. And obviously we want to get this implemented in Devnets, but we can change the specific contract a bit easier there.
00:31:20.660 - 00:31:25.120, Speaker B: Yeah, from my side, it's okay to drop the API.
00:31:30.680 - 00:32:19.220, Speaker A: Yeah, from my side too. It feels like the majority is mildly in favor of Abi and the way of lifetime is strongly approved, but I plan on dropping Abi. Anyone else want to share their thoughts otherwise? Yeah, I don't know. I would also lean to drop it. Just also because of the fact that there can be a solidity library to interact with it, there can be different contracts that interact with it. Oh, Daniel, you just posted I, in.
00:32:19.370 - 00:32:25.030, Speaker E: Chatter said a quote, I'll miss the API. I'd rather have it, but.
00:32:27.340 - 00:32:27.768, Speaker A: I'm not.
00:32:27.774 - 00:32:29.256, Speaker E: Going to be upset if it's not.
00:32:29.438 - 00:33:04.880, Speaker A: Okay. Okay. So I'd say let's move forward without the ABI and. Yeah, this way once that PR is merged with the code, we can start getting auditors to look at it, I guess. Lightline, do you feel like the PR you wrote is at that level? This is the thing people should review as the more or less final proposal.
00:33:08.680 - 00:33:12.916, Speaker D: Well, we've got the next problem to solve, which is how to get the code into the state.
00:33:13.098 - 00:33:27.880, Speaker A: Correct. But that's different than the code. Right, sorry. Yeah. And I guess my question wasn't here, but I guess just in terms of finalizing the contract. Oh, Tim, were you talking about the code now or were you talking about the. I'm talking.
00:33:27.880 - 00:34:15.610, Speaker A: If we want to audit that smart contract, do we feel comfortable? That's what's in light client's pr. Once it's reviewed, yeah, we're happy to send. I think we should give it a day. We have some finalized, there's maybe some comments about the stack, but basically it's finished and it's a really trivial, simplistic contract. It has like five flows, two jumps or something like that, or three. So it sounds like it's a big thing. We're going to get it audited, but it's really not the big thing.
00:34:15.610 - 00:34:33.864, Speaker A: Okay. We're quite confident about it. Okay, that sounds good. And anyways, I agree. If we can merge it in the next couple of days, that's great. Mostly to move Devnet eight forward. There's no auditor that's going to start working on something with a day's notice anyways.
00:34:33.864 - 00:35:37.700, Speaker A: So yeah, if we have this merge in the next couple of days and ready for Devnet eight, then we should be in a good spot to just get a sanity check from an external auditor as well. Okay. Anything else on the contract itself, then we can discuss the deployment. That's the deployment. Okay, so, yeah, other contentious issue. So do we deploy this with a singular, like a normal transaction, have the EIP assume that this is already on chain and fail somewhere or another if it's not? Or do we have the entire logic, sort of part of the EIP, including the actual deployment of the contract? Do people have strong opinions about this? Okay, no one has a very strong opinion. Does someone want to make the case for deploying it in just regular.
00:35:37.700 - 00:36:12.568, Speaker A: Oh, yes, please. And then joke. You can go, Martin, then Yoko. Okay, I'll make the case then for deploying it in a regular transaction. Because that's what I just think is the easiest from several perspectives. First of all, we could just deploy it now on Mainnet. On all our testnets, we could do testing of it.
00:36:12.568 - 00:36:29.990, Speaker A: It could be audited by whoever wants to look at it. And then months from now, we could just bless it to say, yeah, this is the contract. I just think it would be nice to do it that way. Okay.
00:36:31.960 - 00:36:32.324, Speaker D: Yeah.
00:36:32.362 - 00:37:06.956, Speaker A: Just as a note, if we deploy it as a normal transaction, then on our testnets, we will just have the case that we start without a contract, and we likely will immediately activate all the eips. And then at some point we just deploy the transaction. So we might have a few blocks where this contract is not yet there. So this is another. I thought that the DevOps team had said for the deposit contract, they have a way to work around this anyways. Yeah, we just set it in Genesis. We can set it in Genesis.
00:37:06.956 - 00:37:35.050, Speaker A: You could also, and this is kind of cool, you could actually set another contract in Genesis and you could set your allocation to do whatever you want. These specifications mandates that there's going to be a system call sending in the beacon route. If you're going to do some experimental private network where you do something else, you're free to do that. Yeah, makes sense. Okay.
00:37:35.580 - 00:37:42.040, Speaker E: Would the address be the same across all contracts, or we would just accept what it mean. We do a create two off of a known.
00:37:45.500 - 00:38:02.930, Speaker A: And Tim asked if someone wants to make the case for a normal transaction. So for a normal transaction, the address would vary. And we would probably have to make sure that our chain specifications are flexible enough that you actually put an app.
00:38:04.340 - 00:38:10.688, Speaker E: If we make it a create two off the same account, it should settle to the same address on all chains.
00:38:10.864 - 00:38:12.356, Speaker A: No, but we got to get the.
00:38:12.378 - 00:38:17.030, Speaker D: Create two contract out there, which, yeah, we needed the choir to create.
00:38:17.800 - 00:38:23.850, Speaker A: Yeah, it would have been really nice if we could achieve that. But I don't think we can.
00:38:24.220 - 00:38:27.610, Speaker C: But is it that important actually to have it the same?
00:38:28.620 - 00:38:48.592, Speaker A: Yeah, that's make it easy because then we just have to activate it. Then we could hard code the address and our chain config could just have a number or timestamp as usual cancun number and not also have a cancun beacon pre compile address. It would simplify things because that would beg the question.
00:38:48.646 - 00:39:10.100, Speaker E: Outside of testnets and main nets, where is it going to be used? Is the not being able to lock in a number such a bad thing? Because if this is truly just being used in Mainnet, then we lock the number into the genesis and any other alt chain or L2 wouldn't be using it anyway. So we're fine.
00:39:10.410 - 00:39:13.350, Speaker C: Yeah, it's not, definitely not required.
00:39:18.490 - 00:40:16.920, Speaker A: It. So one thing that they could do, and this is totally on a tangent, but if you're L2 or if you're some other network, you could actually use this and piggyback other features, because Ethereum Mainet has given you a system call to an address, and if you put something on an address and activate it, then you can have some kind of feature that you didn't have before where before block you can implement things like Deadman switches and whatever, but that's really beside the point. So that was a bit about doing it in a transaction. There are other ways to do it, and maybe someone else wants to make the case for those. I know, like science. You wanted to do something else, right?
00:40:18.170 - 00:41:08.730, Speaker D: Yeah, I proposed doing a synthetic transaction. I think that a synthetic transaction would give us a deterministic address across different chains. The only questionable part of it is making sure the fees work out where it gets included in all the chains. If you're not familiar, this idea of a synthetic transaction is you kind of construct the transaction you want to deploy and then you arbitrarily pick a VRS value and then you recover the address from that. So the idea is you don't have the private key for that address, you just have this one time transaction that's signed by that address so we could publish that as part of the EIP. And then if somebody wants to deploy the system contract on another chain, they would just fund that account and then include that transaction on that chain.
00:41:09.150 - 00:41:09.900, Speaker C: Right.
00:41:10.990 - 00:41:14.490, Speaker E: But they also might get a different address unless they accept legacy addresses.
00:41:15.490 - 00:41:48.440, Speaker D: Yeah, they would have to use a pre one five five transaction. But for other chains, I think it's up to them to how they want to get this contract in. We're not requiring as part of the EIP, this is how you get this contract into the state. The EIP is more written that you as a client just make a system call to this address and that can be configurable to the chain. And if they want to do an irregular state transition, if that's easier for them to do, they totally can do that.
00:41:50.650 - 00:41:52.534, Speaker E: Go ahead, Felix, go ahead.
00:41:52.652 - 00:42:08.320, Speaker C: Just wanted to say, I think it's also maybe not required for all chains because this is very specific to basically the main net at this point. Even for example, in some testnets, we might not need this contract. It's not like always.
00:42:13.810 - 00:42:14.174, Speaker A: Sorry.
00:42:14.212 - 00:42:15.306, Speaker D: Go ahead, Carlo.
00:42:15.498 - 00:42:46.330, Speaker F: I want to emphasize that the beacon block route is not just a layer one feature. This is information that every L2, every chain would want to expose, just so that these protocols around the beacon chain, like all these, can interface with the state. It's very useful information to have just like every layer one or every L2 exposes the layer one block root or the layer one block hash. The beacon chain information is just as useful.
00:42:50.190 - 00:43:03.902, Speaker C: Right? Maybe. Could you explain, I'm sorry, I don't want to drag out the call, but I'm really curious, how is the beacon block route going to be installed into the L2 chains? I mean, how is that different?
00:43:03.956 - 00:43:31.590, Speaker F: Layer two have their own different system transaction options. Now, if I speak for optimism as a protocol, there we have a system transaction that's a lot like a layer one to L2 deposit. So inside transaction, so that can insert things like this as any sender to any address if the hard fork defines this transaction to be inserted.
00:43:32.750 - 00:43:44.570, Speaker C: Right, for example. And then you would just basically include some kind of beacon route update as part of this operation.
00:43:45.390 - 00:44:21.110, Speaker F: We already exposed the rundown information in L2. We also do expose the layer one block adder information. The beacon block route would also be like part of the set of information we would want to expose and preferably just through the same standard interface, the same address, rather than having to reinvent the view and expose it with a L2 specific endpoint. Okay, but that might be arbitram, optimism and other chains. They all expose the layer one block hash in different places, like different non standard veins, because there's no such thing as a standard blockage contract.
00:44:23.210 - 00:45:20.154, Speaker C: In that case, it might actually make sense to go for the ABI after all, because it's easy for us to just say this contract for the main net is only for this particular block beacon route. But for example, if it was based on AbI, then you could just put the beacon route in another contract in your L2 and then have it as part of some other interface or something. But it would still respond to the same selector, I mean to the same four byte selector, but maybe in a different way or something. And this is not possible if you have a basic non ABI contract, because then it can only ever respond with one thing. So that might be a big reason to go with the ABI. I'm sorry to circle back to that, but maybe another change. It will be more useful as a L2.
00:45:20.192 - 00:46:01.590, Speaker F: We want to just stick as close to the layer one behavior as possible. If the EIP describes it as this is the layer one Ethereum mainet beacon block route, and not specifically just the beacon block route of the local chain, then at least we can agree between all these chains that, hey, you're trying to source this information from Mainet. And if there is the local chain to expose, maybe that needs to be part of the address. Like maybe the chain id is combined into the inputs that create the contract address. Doesn't have to be part of the API.
00:46:03.690 - 00:46:44.582, Speaker C: I mean something else. I mean, for example, in some future way we might, for example go ahead and start, I don't know, deploying a standard block hash contract or something. And then that would require some kind of interface as well. And then at that point it's going to be a bit silly because in the L2s there will be contracts already, like having operations to get the block hash using ABI. And then we'll come along and we'll have to deploy a custom contract with a custom interface. So we will never be able to agree with the L2s. So I was just trying to basically make a case that we should really reconsider this Abi thing because just for the interoperability with the L2s, because they are using ABI for everything.
00:46:44.582 - 00:47:07.610, Speaker C: And I think they might want to implement even this like beacon route with some kind of abi based hook in their existing system contract or whatever. Yeah. Anyway, sorry to derail again to the ABI, but.
00:47:12.700 - 00:47:49.160, Speaker A: So we've covered two of the ways. The third way would be in the regular state transition at the fork block. And I know some people prefer that. I don't know if anyone is on the call, would like to make the case for that. Okay, last call. There's some opposition in the. So anyone want to.
00:47:49.160 - 00:48:10.154, Speaker A: Danny and Alex are for the irregular state transit position. Yeah, Dan and Alex, neither of them are on the call. That was the path that they felt most comfortable with.
00:48:10.352 - 00:48:34.980, Speaker E: There's two sides to that. One is the philosophical agreement argument that we don't want to do etc stuff again. But I think the other side is that we're creating code that's going to be used once and disposed of. That's inherently fragile. So philosophically I'm more on that camp that I'd rather have just use a regular transaction if we don't care about the address. And that just feels cleaner and less code to write and less code to test.
00:48:38.010 - 00:49:41.350, Speaker A: Yeah, I agree. So one thing to say for doing an irregular state transition is that if we do that, we are at liberty to take that for example ox or something, or Oxob, which is as if it were a pre compiler or something closer to something to designate that this is a system contract and it's somehow magic. That is the biggest upside I guess. And the other upside being that we are then fully in control of the deployment. And when Cancun hits, no matter what testnet or network you are on, we know that bam, now these contracts exist and we are in charge.
00:49:42.170 - 00:49:45.478, Speaker E: So the argument is to go ahead.
00:49:45.564 - 00:49:51.290, Speaker A: Finish up, to wrap up. I think those are the two upsides.
00:49:52.750 - 00:50:03.246, Speaker E: So if we're putting an OXB, but we're defining it in bytecode, we're still going into the EVM. So it's not truly like the other nine pre compiles we have, where you never go into EVM code.
00:50:03.348 - 00:50:30.120, Speaker A: This is specified in EVM, like a precompile. It's rather the opposite because we actually do care about the code on it. But we could put it at for example oxf zero or something that's still designated as somewhat magical. Yeah, and then the proto's point is like, yeah, it also avoids ever being on a network where the contract's not there.
00:50:31.690 - 00:50:39.526, Speaker E: Well, we could define the system contract, the system call step to say if there's no code there, don't do it. If there's code there, make the call. So a call to a non existing.
00:50:39.558 - 00:50:51.742, Speaker A: Contract, I think that's kind of implicit if the tree falls in the forest. Because if we do a system call and nothing is there, then no one will ever know whether we did the system call or not.
00:50:51.876 - 00:50:54.350, Speaker E: Well you're executing Oxo by definition.
00:50:56.710 - 00:51:59.890, Speaker A: Right? So it's, I mean, but yeah, it's OPAc, it's the black box, whether we did that virtual stop code stop opcode or not. Okay, and I, I wonder like is this something we need to decide in the next 8 minutes, or is this something that figuring out before the Cl call does not introduce extra delays? I assume that one it feels like we do need time for the conversation, but I assume this is also a pretty big part of the implementation details, or is it not?
00:52:06.280 - 00:52:12.820, Speaker D: I mean, transaction versus irregular stage transition I think is a relatively big part of the implementation.
00:52:16.840 - 00:53:29.820, Speaker A: Do you feel like we can make this call now? And I guess part of the reason is if we decide one way or another now, but then get on the ACD call this Thursday and people feel that there's different consensus that forms. We've just wasted everybody's time starting to implement this. So I feel like the extra. Sorry, I was going to ask, is there anyone on this call who feels strongly in any direction? Danny just showed up. Nice. Yeah, Danny, everyone, I guess we've made cases for having this be deployed with a regular transaction, having it be deployed with synthetic transaction and yeah, we were now just talking about deploying as part of fork, but you're gone. Okay, let's give Danny another minute to rejoin.
00:53:29.820 - 00:55:02.182, Speaker A: Can you hear us now, Danny? Hello? Yeah. Oh hey, can you hear us? Yeah, do you want to quickly argue for. Yeah, I'll just make the case. I will preface it with it doesn't matter, it's more of kind of an aesthetic thing, obviously, but I think the aesthetics of having an EIP that is self contained and has no weird external human dependency to deploy is natural and good and better than the alternative that has the like. Okay, well, submit a transaction and set this configuration variable or whatever method is being done, and having contingencies for if somebody doesn't do that, and then having people to have to think about it in DevOps configurations, or having to think about it when deploying in another environment, it's just like this seems like a system operation that exists at a system address specified, which can be specified in code R as we had it before, could be specified in logic that's implemented. Specifying an EVM code doesn't all of a sudden make it like a dangerous irregular state transition. It's literally just system code.
00:55:02.182 - 00:55:41.730, Speaker A: Living at a system address and conflating it with the notion of an irregular state change, I think is just kind of like a weird, inaccurate, politically charged way to describe this thing. So again, it doesn't matter. It's EVM code. It's going to live somewhere. It's going to be deployed either at the fork or before because we're going to make sure it is on main net. But I just think it's really nice and self contained to be like, here's the bytecode at the fork. The fork deploys the bytecode it lives exactly where we want it to live and we move on with our lives instead of having like an external dependency.
00:55:41.730 - 00:55:58.840, Speaker A: I think it's just nice to have it all wrapped up in a bow. But I'm not going to dial on this hill. I'd like to just see this operation deployed. So if people have strong opinions and are unwilling to budge in my direction, that's fine.
00:56:02.360 - 00:56:33.010, Speaker C: Maybe something to consider is that if you put it as part of, like, if you just deploy it by the fork, then this will also mean that there will be no variance, like no possible variance across chains for this contract. Whereas what we were discussing earlier is also a little bit this possibility that maybe on some other chains they might want to expose a different kind of system contract with different functionality or something.
00:56:34.660 - 00:57:10.700, Speaker A: Right. But that doesn't seem to preclude that seems like an independent issue. You have the configuration variable that says this system operation goes at this address. And if you want to configure that to a different address in a different chain, it's just changing a configuration variable. Or if you want to deploy code, you just change that variable as well, which is the code variable. Yeah, look, the EVM is my friend, but not my intimate domain. I don't need to make this decision.
00:57:10.700 - 00:58:36.730, Speaker A: Yeah. And I guess the question we had before you hopped on is, do we need to make this decision now, basically the next couple of minutes, or should we take a couple of days to have people review it and think through it, and at the latest do it this Thursday? And does that slow down implementations from client team significantly so that particular decision, it does affect how the EEP is written and it does affect the implementation in the client. Yeah, it's not a huge thing, but it does add a bit of time. Yes, if we decide on Thursday, we're obviously not going to decide it in the next 45 seconds. Yes. Barnabas, is it something that maybe we should leave out of Devnote eight? I know I've been pushing to everything as much as possible in Devnote eight, but at this point we have Devnet seven, which is using some very stale branches of clients. And we would like to have a new Devnet up and running that would be running the client service code so they can also check everything that they wrote since almost a month.
00:58:36.730 - 00:58:45.836, Speaker A: But do all the clients have an implementation? Would that mean we use the pre compile for seven, eight, eight for Devnet eight? Do all clients have an implementation of.
00:58:45.858 - 00:58:48.908, Speaker E: That basic does not.
00:58:49.074 - 00:59:02.390, Speaker A: Okay. Get has one which contains. Okay, so, and Daniel, was that why you had your hand up.
00:59:03.400 - 00:59:23.610, Speaker E: No, I was going to say a different counterpoint to one of the arguments for having it as a state transition is that's going to be less work for DevOps, but we're just shifting the work from DevOps to client DevOps to write single use code for single transition. So at some point we're just moving the work around. It's not going to save work.
00:59:25.020 - 01:00:20.120, Speaker A: Yeah, agreed. My point would be that it becomes something that is just part of client logic if the feature is enabled rather than something that, pooling other chains, et cetera, have to make sure that they're thinking about. But you're right, it emerges. Yeah, and Proto has an interesting suggestion, like, do we just maybe skip the deployment part FDE IP, put the contract in an address of Genesis for Devnet eight and use this for Devnet eight, give ourselves another at least three days, maybe a bit more to figure out the right long term approach, and use that for devnet nine. Would that work? That would be actually kind of smart. Then we don't have to. Yeah, we just put it in the alloc, the genesis alloc.
01:00:20.120 - 01:01:02.520, Speaker A: That's something that doesn't work for minutes, but it works perfectly for a testnet. In that case, Barnabas or Perry, can either of you just basically make that part of the Devnet eight Genesis file and share the address with clients? Okay. And then use that for Hive as well? Probably also for Hive. Yeah. Client can give you the code in the next 24 hours or something. Yeah, that sounds good. We just want all the clients to play us Hive test, and it would be good to have that before we launch any devices.
01:01:02.520 - 01:01:24.112, Speaker A: Okay, so just to summarize, before we quit. So we agreed to not use the API for now. We agreed to like client. We don't have time, I think, to talk about system calls anyways. Wait, let's just recap where we're at. But. Okay, no API for now.
01:01:24.112 - 01:01:44.136, Speaker A: We're going to have the contract as part of the Genesis file, use the same address as the precompile did, zero xB. And then. Okay, if you want to talk about system calls, we can do it in a minute, I find. Are you still here?
01:01:44.238 - 01:02:08.560, Speaker D: Yeah, I think the last question was, do we want to have the functionality in the bytecode to set the relevant storage values so that before the block happens, you actually call the EVM? Or did we want to not have that functionality in the bytecode at all? And just in the EIP say, clients will update these storage values.
01:02:17.300 - 01:02:53.620, Speaker A: Right now it's written with the kind of conditional routing for the set, as well as a note that clients could just update storage values if they felt like it, right? Yes, that seems fine. It okay. Anything else before we wrap up? Okay, sweet. Thanks, everyone. Yeah. Talk to you all on the ACV. Call Thursday.
01:02:54.200 - 01:02:54.950, Speaker D: Thanks.
01:02:56.840 - 01:02:57.520, Speaker C: Bye bye.
01:02:57.600 - 01:08:54.710, Speaker A: See you. Sa. Sa, sa.
