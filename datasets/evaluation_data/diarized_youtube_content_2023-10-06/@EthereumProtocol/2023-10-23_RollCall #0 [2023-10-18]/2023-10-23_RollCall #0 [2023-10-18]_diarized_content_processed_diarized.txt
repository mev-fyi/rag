00:00:01.610 - 00:01:30.250, Speaker A: So welcome, everyone, to the inaugural roll call. This is an effort that Anskar, Huov and myself have been working on in the background and have chatted with many of you individually. And now we're trying to set this up as more of a group thing. Um, the idea of today's call is mostly just to get everyone together and to make sure we're all on the same page in terms of what exactly is happening here, what this process is, and to check that this is still what everyone would like to do. There's been a lot of hype and interest, but we want to make sure that expectations are exactly what we're going to have here. So I'll start by laying out a little bit of the vision for what this is. As you all know, Ethereum's vision for how we achieve the end goal of servicing as many users as possible, as cheaply as possible, in as trustless a means as possible, has sort of switched from relying on the core protocol l one onto this l two roll up driven vision.
00:01:30.250 - 00:02:47.840, Speaker A: And there have been many changes that have happened alongside of that. And I think part of this is that l one has really been focusing on ossifying and not having too many changes and to be as hard to capture as possible. And so this has also sort of limited the way the changes that we've seen happen to the EVM. So we've seen the rate of improvements and things that have shipped from new features standpoint reduce quite a lot. And instead the core devs have been l one. Core devs have been focusing on the merge and shipping 4844 and dunk sharding focal trees, et cetera, et cetera, which are all absolutely essential for l two s to achieve what they need to achieve, but also don't really help the end user in terms of lots of features that are needed. And we've also seen that EVM equivalence has been something that's been very important in the roadmap of many l two s.
00:02:47.840 - 00:04:15.200, Speaker A: But it seems unfortunate that we all have the score of EVM equivalence, but we're blocked on being able to have further changes to the EVM, which may help bring new functionality in things. There have been a number of efforts previously for cooperation along these lines, but there seem to have been a lot more ad hoc around one or two particular things that people have wanted to ship. And it's also, we've seen a bit of like n squared blow up, where it's like one team collaborating with another team on one particular project, as opposed to sort of this overall set of standards and collaboration efforts. And so the idea here is to try provide some credibly neutral platform for these discussions to happen. So what exactly we're proposing here, and the idea is, it's a general process which is comprised of many sort of sub discussions and sub processes. Obviously there is this call which the idea is to have on the third week of every month, so it's a monthly call on a Wednesday at this time. But on top of that, an optional set of standards which we've been calling rips up to this point.
00:04:15.200 - 00:05:38.890, Speaker A: And the goal there is to primarily ensure that there are as few conflicts as possible in features that we have. There are already a number of ways in which many of these l two s are subtly incompatible, particularly with regards to some of the features that the zkave roll ups have shipped, just due to the necessity and limitations of their design, which are less favorable or work less well with the existing EVM, some of the optimistic chains. So the idea here is to allow this to happen in a way where we can make sure that there are not going to be as few incompatibilities as possible, because I think that's just a really unfortunate thing to have. So ensure that we're not going to have weird pre compiles deployed at the same address or something like that, where it's just like this is obviously something that could be avoided with a little bit of coordination. And then secondly, there are many features which are very beneficial that just require a bit of collaboration. So things like account abstraction, everyone is very keen on. And some people have started shipping things that look like account abstraction, but are often very subtly different from one another.
00:05:38.890 - 00:07:37.470, Speaker A: And so instead of having an individual standard for each l two roll up, we can hopefully settle on one major standard that everyone agrees to use and ensure that this works well enough for everyone, even if it's got a slightly more limited set of features, that would be a far better outcome in terms of being able to have support from tooling and wallet ecosystems, et cetera, et cetera. And so extending this to all of the other coordination things that we need. Also, we would like this to be a metaphorical API between l ones and l two s. So there's a lot of like l one devs are very focused on the issues they particularly face, and are often unaware of what things are important and what changes need to happen, and also what priority those are. So if one team starts loudly proclaiming that this, and this is a super important thing that needs to happen, is absolutely essential for their vision it's hard to know for the l ones whether that is actually something that is a shared common thing or it would just help out one particular team. And so this call could help be an interface for bringing that all together and then being able to present this to the l one consensus process, and then vice versa to bubble up changes that are happening on the l ones. Make sure that l two s are ready for forks that are happening and are ready for new functionality and aware of changes that might be happening that are relevant, and also to bring research forward at like portent for l two s to be able to comment and maybe affect the roadmap a little bit for ways that could really help them out there.
00:07:37.470 - 00:08:49.734, Speaker A: So what this is not, this is a process that is of course, non binding. The process itself doesn't require any kind of commitment, and the changes that will be proposed and standards that will be proposed are entirely optional in terms of what people think is beneficial. This is not a decree and this is how things work. This is more here is a way that other people may or may not agree is a sensible way of doing things. And so everyone here is entirely in charge of their own rollout, so their own roadmaps and how we get everywhere, which makes it quite different from some of the other governance calls that we've seen, such as ACD, where there. It's like we need to have consensus from everyone on what the next steps are and which eips are going to be included in which forks, et cetera, et cetera. This would more look like individual people or individual teams deciding that, hey, they want to ship this feature and here's the way they're doing it.
00:08:49.734 - 00:09:54.678, Speaker A: Please can everyone else comment on how they're doing it to see if we can reach a more meaningful common standard. This is also not going to become a place for marketing and competition. This is really supposed to be a technical set of agreements. Obviously, there's a lot of money at play here, and everyone's incentives are slightly different. So we will do this as much as possible to keep these topics technical and to try reach common standards that are in everyone's technical best interest. This is also not a call that's going to establish who is and isn't an l two, this participation here doesn't define that, and it goes beyond that in that we actually are happy having people who aren't necessarily a part of the direct ethereum ecosystem, but are maybe using the EVM for their own context. They're welcome to propose standards that may be helpful to the greater EVM ecosystem.
00:09:54.678 - 00:11:01.022, Speaker A: But the bias is always going to be towards roll ups and l twos. But the idea is more that if something sensible that exists somewhere else, there's no reason we can't incorporate it here, too. So it's not some exclusive group being joining or not joining these efforts and these calls means nothing. It is just an individual set of discussions that are happening. So we can hopefully arrive at more of a central, like a single vision, with as few diverging ways of doing things as possible so that we can gain from some of those efficiencies and tooling, et cetera. I've been working on setting this up with Anska and Jov, who've been thinking about this, honestly, for longer than I have. Anska in the general sort of standardization and l two perspective, and yov specifically from the account abstraction side.
00:11:01.022 - 00:11:05.300, Speaker A: So I'm going to hand things over to Anskar quickly to introduce what he's been thinking about.
00:11:07.190 - 00:11:07.650, Speaker B: Sure.
00:11:07.720 - 00:11:46.110, Speaker C: Yeah. Hey, everyone. I think it's really exciting that we have this process now getting off the ground. Yeah, I think Carl has already said a lot of what the vision for this process is supposed to be. All, of course, very optional, but just having a shelling point for coordination, just from my perspective. Yeah, I think it's been really amazing to see all the innovation that came with layer twos at the same time. It always felt like, with the focus on EVM equivalents, that there was this bottleneck in innovation, specifically on the VM side, or at least to the extent that the EVM set limits.
00:11:46.110 - 00:12:36.878, Speaker C: And I think we've been thinking about how can we best overcome this for a while now. Of course, a lot of the individual teams here have already kind of done their own. Have found their own ways to basically go beyond this. But I think there's always been some demand to basically kind of combine the EVM equivalents with still enabling innovation. Initially, we had some ideas, I think, around basically more heavy handed, completely fork the EVM and have like a layer two EVM and really start pushing the limits there. But I think from a lot of feedback, from talking to people, it seems just like a heavy handed approach, just not the right thing. I think basically, now we have landed on this idea of having this IP process, having basically more individual features that are fully opt in, so you can basically mix and match whatever ones you want to support versus go with your own opinionated approach instead.
00:12:36.878 - 00:12:52.740, Speaker C: I think that's a very promising direction. And, yeah, I think now is also the time, I think last year, when we talked about this. People also like, no, but we have other things. We have to focus on the layer two side. I think now there's at least a little bit of breathing room to get to this. So I'm very excited for the process to get going.
00:12:56.480 - 00:12:59.490, Speaker A: And Yov, is there anything you'd like to add?
00:13:01.060 - 00:13:20.230, Speaker B: No, I think so. You and Ansgar already said everything. There isn't much to add and I'm really excited to see it finally happening. We've been discussing this, actually, we started working on this idea since Denver, so it's been a while, and finally everyone is here. So welcome.
00:13:23.020 - 00:13:57.570, Speaker A: Great. So I think the next thing would just be to get a rough idea of who's in attendance here. Not asking everyone to introduce themselves, but if one representative from each team stakeholder can just mention who they are and how they think this process is relevant, if they think it's relevant or not, not asking for long discussions, but just sort of like a 32nd of, hey, this is who we are, and this is generally something we think is meaningful or not, or whatever.
00:14:04.440 - 00:14:51.170, Speaker B: I can start nicola for linear. So thanks a lot for organizing this. I think there are many things that can be quite interesting to discuss during this. I mean, we saw some discussion in the chat on the state representation and it's a key topic for all zkvms, so I think it's a very interesting one. Another one, I think kind of easy one I think that we could work on is what we do for the difficulty of code. We know that in the layer one it's a random number, and I think that for all layer twos it's complicated for it to be a random number. So that's some easy stuff that could be done there, I think.
00:14:51.170 - 00:15:32.130, Speaker B: And maybe one comment is we should be careful even if we say, okay, everybody can do whatever he wants, we should be careful not to arrive in a situation where actually everybody does everything he wants because it can be a mess. So we know that it's impossible to add any pre compile in the layer one, like BLS has been incredibly difficult to get and in this case forages. We should not go too crazy on the layer two. I think we should try to say, okay, let's not have 20 different recompiles on the layer two, for example, but very happy to be there. And again, thanks a lot for organizing this.
00:15:40.110 - 00:15:45.420, Speaker A: Thanks Nicholas. Someone just put their hand up. Yes, PGo, you're up.
00:15:47.070 - 00:16:10.962, Speaker B: Hi everybody, this is Paul from Polygon. I don't know if I see anybody else from Polygon. On the call at the moment, but you guys all know Hudson Jameson. He's a polygon now and then. Paul Gebhaum has been involved with a lot of discussions with the ecosystem about various proposals. So, yeah, thanks again for putting this together. It's a time has come for sure.
00:16:10.962 - 00:17:06.902, Speaker B: Basically, I won't go into detail here. I think we've been putting out pips basically to discuss various ideas that we have about kind of top of mind issues to talk to the ecosystem about, things like account abstraction 30 74. I think we've got a pip for. We've got a pip for sectr one, the built ins, and obviously ZK integration and having standardized APIs for all that is very topical for us and something that we're very interested in working with other layer twos on as well. You mentioned the issue of competition. I think it's a good call out here, basically. But from my perspective, I'd like to emphasize that there's such thing as good competition and bad competition, and bad competition would be a lot of people trying to fight for kind of their own bespoke standards, basically, as opposed to us kind of at least agreeing that we can build something better by kind of doing it the right way the first time.
00:17:06.902 - 00:17:13.800, Speaker B: So that's kind of the mindset that we have at Polygon. That's all I got so far.
00:17:15.930 - 00:17:19.530, Speaker A: Great. Thanks, Ed. Hey, everyone.
00:17:19.600 - 00:18:15.210, Speaker B: Ed Felton from Offchain Labs, developers of arbitrum, and my colleagues Harry Kalodner and Austin are also on this call. From where I sit, I think, first of all, thanks. Let me join the. Thanks for getting this going. I think the two highest goals for this in my mind, first, are to address issues that are common across all roll ups, especially ones that l one doesn't see or doesn't have, so that we can find solutions to the things that we're all facing. And then, second, deconfliction to make sure that we don't get into a position accidentally where we are incompatible with l one or incompatible with each other. So just making sure that we can move forward with confidence on some things without worrying about that kind of conflict.
00:18:21.560 - 00:18:24.100, Speaker A: Great. Thank you, Tiago.
00:18:25.080 - 00:19:18.490, Speaker D: Hey, everyone, I'm Tiago. I'm CEO at ARC and also co founder of three Sigma. And for us, there are multiple issues that I think is important to address, especially for Arc. From our perspective, interoperability standards are the most important ones. So, for example, the standardization of wallet Ux, like we were discussing, it's very important for us since we'll be deploying multichain apps. Also because we'll be deploying different roll ups, different l two s with different tech stacks, it's very important to get standards around shared bridges of the different ecosystems. And also I would say that finding some compatibilities and standards so that shared sequence of projects can work with different roll ups using the different text is also quite important.
00:19:18.490 - 00:19:43.680, Speaker D: And coming here also on Paul, on the competition standpoint, I think finding these standards and for example understanding how multichain apps can work, this might eventually to a more cooperation scenario between the different l two s instead of direct competition for liquidity and projects. Finally, thank you again Ethereum foundation for the call and hope everyone enjoys.
00:19:47.910 - 00:19:52.366, Speaker A: Great, thanks. Yeah, sorry, I have no idea how to pronounce your handle.
00:19:52.558 - 00:20:39.780, Speaker B: Hey, I'm Carmen from ZK Singh Matterlabs. We're also very excited about this opportunity. I personally think that the most easiest things to do would be things around standardizing chain id derivation and also standardizing the layer one, layer two bridges across different roll ups. It would make it much easier for different DAP developers to have one standard interface which they could use. And in the future this could also be expanded to layer two to layer two standards. Thank you. Also, I forgot to mention that stas breadless is also on the call from ZK sing Matterlabs and Anthony Rose, thank you very much.
00:20:41.670 - 00:20:42.082, Speaker A: Thanks.
00:20:42.136 - 00:21:40.040, Speaker B: Coleman Proto hello everyone, I'm Proto from RP Labs. Well again, thank you for hosting this call. It's a good effort for layer twos. And yeah, I want to call out two things, why this is meaningful. One, it's to get the right product feedback from layer two to the rightr community, get these kind of standards. And specifically when it comes to infrastructure, I think we have been introducing protocol changes on layer one and then we have infrastructure of end users that's like an afterthought, whereas really the infrastructure around fort perform and other eips should just be there. Similar to how the execution APIs are really critical to Ethereum, but never really have been so much a part of the EIP process.
00:21:40.040 - 00:22:41.526, Speaker B: Layer two is at significant infrastructure requirements with the increased scale and having standard infrastructure would be really nice. And a second, what I'm hoping for is to meet that idea of deconflicting like future improvements and the idea of adding things is to just standardize a path for extending Ethereum. So I doubt we'll ever get to a situation where everything will be the exact same. But if we have a standard way of extending the block header in a compatible way, then we can allow for differences on player tools while still making the lives of tooling developers easier. Okay. And I think Mark is also on this call. I'm very interested to hear of your thoughts on layer two standardization.
00:22:41.526 - 00:22:42.700, Speaker B: Thank you.
00:22:44.830 - 00:22:47.126, Speaker A: Thanks, Proto Roberto.
00:22:47.318 - 00:23:06.610, Speaker B: Hey, Roberto here. I'm from Coinbase. I think I'm the only one from Coinbase on the call. There may be others I have missed. Specifically, I'm on the base team. We're quite interested in standardization around account abstraction, EDM scaling, developer tooling.
00:23:07.190 - 00:23:07.554, Speaker C: So.
00:23:07.592 - 00:23:12.820, Speaker B: Yeah, very happy to see this being organized and looking forward to what we come up with.
00:23:16.550 - 00:23:43.000, Speaker A: Great, thank you, Peter. This is Peter from Scroll. We also have Mohammed and Howie from our team here. Yeah, I agree with everyone. We're mostly excited about extending DVM and the RPC standard APIs as mentioned before, and excited to be part of the process. Perfect. Thanks, Alex.
00:23:43.000 - 00:24:40.904, Speaker A: Yeah. Hey everyone, I'm part of the Ipsilon team, which is EF funded and works on EVM research. The two main pieces we work on, you may have heard about, is EOF or EVM object format and EVM Max, which tries to give primitives so that we wouldn't need all these precompiles. And of course, so far we have been trying to introduce these features to Mainnet, which as Cart mentioned, is quite challenging. So this call is definitely super interesting to us to see how any of these changes could be coordinated across l two s and maybe main net. And I also wanted to maybe take the opportunity to mention that we are organizing an EVM summit at Dev Connect. And we do have plan to have some similar topics as discussed here.
00:24:40.904 - 00:25:06.460, Speaker A: But the summit is not related to what Carl and Joav and Anscar is organizing. But I would like to invite everyone, if you're interested, to discuss this also there. Thank you. Is anyone else. Would anyone else like to intro themselves team?
00:25:07.870 - 00:25:53.740, Speaker E: Yeah, sure, I'll go ahead. Hi, I'm Peter from immutable and I'm certain I'm the only person on the call because it's midnight here, middle of the night, what we want to get out of this call. And so thank you very much for organizing it, by the way, what we want to get out of this is having commonality of l two s, so that running across multiple provers will be smooth and seamless and so that a multi prover, multi roll up system, decentralized sequences will just work. So that's what we're about is multi prover, multi chain and just being able to get all that to just work.
00:25:58.570 - 00:26:00.790, Speaker A: Thanks, Peter. Dano.
00:26:01.610 - 00:26:37.650, Speaker B: Yeah, I'm Daniel Farron. I'm one of the maintainers on the Hyperledger Beisu, focusing mostly on the EVM. I've also been working with Team Ipsalon and some of the EVM implementer calls to try and get EOMf over the line and shipped implementing a lot of the features in Besu. My salary is also paid by swirls Labs who implements Hadera, so that gives a little bit of exposure to the Alt l one scene, and I think the biggest open question we have is to get a more firm definition on what ethereum equivalents is and is not. So that's something that would, I think, benefit not just l two s, but the greater evm ecosystem.
00:26:44.470 - 00:26:51.880, Speaker A: Okay, thanks Jenna. Definitely a topic we can get into at some point. Anyone else like to intro themselves?
00:26:57.120 - 00:27:22.580, Speaker F: Ulas and hello. Firstly, thanks for organizing this call, I think. I'm Ulash, I'm co author of EIP 7212 and I'm here with Don, the other co author. We are also from the Clave team and excited to present the EIP and discuss about the current progress in the further timeline.
00:27:28.000 - 00:28:48.074, Speaker A: Great, thank you and we definitely get into your EIP in a moment. Last call for intros. Great. Okay, so the next thing, as Axico is mentioning, they've got devconnect coming up in Istanbul next month, and what we're envisioning is sort of the next iteration of this call will be in person pretty much with breakout sessions, more whiteboarding style, to get into some, hopefully some more problem solving things around some of the topics we can touch on later on this call. So that's happening as a part of the l two days event organized by l two beaten scroll, which is on the 15 November. I'll drop a link to the web page. Hopefully by the end of this week we will have more details for you in terms of what our specific thing is.
00:28:48.074 - 00:29:22.300, Speaker A: So on the second day of this, we're going to have a stage dedicated to these discussions. Yeah, anyone have any questions about slash what's happening in Istanbul? No? Okay, so next is the topic of rips, and I'm going to hand over to Anskar to let him elaborate on what we've been thinking.
00:29:23.710 - 00:30:17.914, Speaker C: Yeah, great. So as I think Carla mentioned earlier a little bit already, we have thought a little about kind of the structure that this collaboration coordination effort could take, and ips seemed like a reasonable first element of that. So I think like most of, probably all of you already know, we have the EIP process on Ethereum mainnet for proposed changes to all rules that are consensus critical. That's mostly EVM related changes. Historically that has been combined with the erCs, which are just community standards. So anyone can just create an ERC on anything, does not have to actually be relevant for mainnet directly. We are now in the process of splitting these out.
00:30:17.914 - 00:31:05.446, Speaker C: So ERPs and ERCs will be separate but under the same umbrella. We're going to call these topic groups. And so when talking about how could we basically fit into this, it just was a very natural idea to just basically become a third topic group. So there will be eips, Ercs, and then what we propose rips to become. And the idea was basically to just have that as a standard for all kind of layer, two specific changes like EVM extensions that are not directly kind of targeting main net. And so eips would just not be a good fit. Being basically a topic group under the same umbrella as EIPs and ERCs would mean that we share the same, would share the same numbering scheme.
00:31:05.446 - 00:32:04.090, Speaker C: So it will not start with IP one, but with IP 7000 something wherever we're at also means that if there's ever EIP 7500, there will never be an rip with the same number. And the other way around, we would have a separate repo though Ethereum ips or something. And then we would reuse the same Eth magicians forum that I assume most of you have already been on various points in the past to discuss eips erCs. I think that has proven itself to actually just be a very, just nice place to facilitate discussion. One specific aspect as well is that with EIPs and ERCs we have so called editors, those are just people that basically make sure every time there's a new EIP proposed, that it follows just the formal rules of the structure the document has to have and these kind of things. Obviously it's not an opinionated rule. You're not supposed to have an opinion on whether it's a good change or not, just enforcing the structure.
00:32:04.090 - 00:33:02.242, Speaker C: We would also need equivalent rip editors. So the first call of action here would be that if maybe anyone here on the call thinks they would want to be involved as a volunteer, or if they know someone on their team that would want to be involved as a volunteer. I think the idea is that once we come together in person and in Istanbul, that we basically get an initial group of people together there that would want to take on this role. There are some others, basically small nuanced differences to the existing EIP process where we would want to kind of dive more into more details. In Istanbul, for example, eips have very defined statuses. So you give draft and then later on your review and final and everything, and we would basically have to slightly adjust that. Think about what does it mean in the layer two context? What status would correspond at what point? For example, if I want to implement this as a layer two, I want to implement a standard.
00:33:02.242 - 00:33:20.586, Speaker C: When can I rely on that? It will no longer change. Right. So basically mapping that to this new setting, this kind of work. And of course, just to reiterate, the big difference to aps is that this is not consensus forming. Right. It's just standards. So every layer two can at any point decide to opt in, opt out.
00:33:20.586 - 00:33:57.300, Speaker C: So it's a very different process in that regard. And then there are some other small aspects. Of example, I think one open question is the exact scope of this. So for say, non EVM changes or layer two specific standards, I think we have to basically figure out where the line is, what should be an IP versus maybe an ERC or some other type of standard. Right. So there's some more open questions. And then I think one really exciting topic that once we get this off the ground, I think will become more important over time will be the relationship with layer one.
00:33:57.300 - 00:34:34.720, Speaker C: Obviously, as people have been saying, it's one thing to make sure that if there's several different layer twos want to implement some cryptographic primitive, that they do it in the same way, ideally, unless they have specific reasons not to. But then ideally, of course, if mainet, two years later, I guess that's even optimistic timeline with Mainet ever decides to support that as well. Of course, it would be really unfortunate if it doesn't follow the same standard then. Right. So basically, how can we get layer one people already involved in this process without slowing it down? Of course. How then ips and later on eips once a target mainet related. So I think those are a lot of questions we have to figure out.
00:34:34.720 - 00:35:03.098, Speaker C: But yeah, I think for this call, probably just to keep it not going completely out of scope, I think I'd want to just get some feedback on in general, if people think this is a reasonable approach, if there's maybe some small things you would want to see done slightly differently or something, but then I think the details we would want to work out in Istanbul. Yes. Yeah.
00:35:03.264 - 00:36:00.954, Speaker B: So I think in cases where we're talking about standardizing something which l, one might also want to do and where we're worried about a conflict, say it's something like a new pre compile to support some elliptic curve group that we're interested in and that l one doesn't want to do yet. In a case like that, it seems like a sensible way to do it. To make sure that l one is on board is to have it be an EIP. But specify in the EIP that implementation is optional and each chain can decide whether to implement that way. L one is bought into the particular design of it and they're bought into reserving the pre compiled address and other things like that, as opposed to us developing something ourselves as an rip. And then l one kind of maybe having more optionality later to do something inconsistent. Right.
00:36:00.954 - 00:36:14.560, Speaker B: If we want to deconflict with them, we need them on board early on, and I think having it be one of their standards but stated off but optional implementation across all chains is maybe a better way to do that.
00:36:15.410 - 00:36:16.938, Speaker A: So just elaborate.
00:36:17.114 - 00:37:04.030, Speaker B: Sorry. Yeah, Joe, just saying that this is a part of the rip, of the goals of the rip process is that layer one devs will be in the process, will be involved in the process, and we will have some sort of commitment that once an rip gets, for example, if a pre compile gets reserved, then it will not be used for something else on layer one. So I think this is one of the goals of the current effort. But if I could jump back in, it's not just making sure that the numbers don't conflict, it's also, I think, making sure that l one doesn't introduce a slightly incompatible different version.
00:37:04.530 - 00:37:04.942, Speaker A: Yes.
00:37:04.996 - 00:37:20.340, Speaker B: Leading to confusion. Right. Having a standard that they are bought into fully from the beginning seems really important for those cases where it's not just an l two thing, but consistency with l one is an issue.
00:37:21.110 - 00:38:48.010, Speaker A: So part of the idea here, and this is a bit of what I was trying to get to, is being a metaphorical API, is if we come up with an rip, say for a curve support as you're talking about that we'd like to have enshrine, then I think it would be wise to go from here on to then raising this in one of the ACD calls to draw attention to it from the one devs to be like does this seem like a sensible thing? And then they can voice opinions on whether that's something that would be feasible to implement on r one, or whether they would need to have these small incompatible changes made. And then if it ever does ship on l one, we can have a separate eip which points to the rip basically saying here is the standard for how it's done and this is where you can find the implementation. And then the idea being that in rips, I think something that wasn't quite touched on, we can maintain which chain l two s do and don't implement things. So as we see more and more adoption for a particular rip, because again, this is not something that would necessarily happen all at once, we can add the list of who is supporting a particular thing. Tim, you've had your hand also to.
00:38:48.100 - 00:39:40.274, Speaker B: I think I agree with everything you just said, and maybe to add two more bits. One is that a list of potentially reserved pre compile addresses on l one seems like something that could be a valuable Eip. It came up in the context of an ERC literally this week as well. So I think that's probably the amount of signal you can get from l one. But I would push towards having a standard as the rip to start, just because it can literally be years for l one to adopt something. If you look at, say, the BLS precompile, which is probably the least controversial pre compile, we've been talking about it since 2018, and it's still not live. So just the speed at which roll ups can iterate and move on this stuff is probably an order of magnitude quicker than what l one can do.
00:39:40.274 - 00:40:32.338, Speaker B: And so I would try to have as little blocks or checks, like mandatory checks from l one onto the l two process. And not to say that you shouldn't sanity check with l one devs if they think it's a good idea or whatnot, but I think having the rap be a separate process and being able to move quicker is extremely valuable. And then yeah, maybe having a list of just reserve pre compiles or whatnot. And potentially what we can do as well is something like set a specific chunk of addresses, a specific registry that's like, these will be all the l two pre compiles. L one will never overwrite them. And if we were to ever import something, this is the default address space it would go to. Just want to be mindful of.
00:40:32.338 - 00:40:42.150, Speaker B: L one is extremely slow in doing stuff, and so if you're building your process over like l one validation, it's probably just going to slow it down unnecessarily.
00:40:46.540 - 00:40:46.952, Speaker C: Yeah.
00:40:47.006 - 00:41:38.360, Speaker A: Thanks, Tim. Agree with pretty much everything you mentioned. Then again, a lot of this is trying to free ourselves from some of the coordination and speed issues we see on l one, but also not be too free such that we end up breaking things will be incompatible. So walking that line is going to be something we're going to have to figure out as it goes some other items that were mentioned. Proto brought up licensing, so strong agree here that rips will all need to be some sort of open source licensed which will be able to be freely edited and not owned. Again, this is a non competitive, non marketing thing that we're trying to set up here. It's purely for collaboration and standardization.
00:41:38.360 - 00:41:47.050, Speaker A: Another thing, Dano, you brought up the idea of progressive pre compiles. Can you elaborate what you mean on that?
00:41:47.820 - 00:42:17.636, Speaker B: So that's a thread in Ethereum magicians. It's a way to deal with bringing in new pre compiles. And you would start by defining them as a solidity form. And the solidity form or the EVM form is the definition of the pre compile. And you would like canonize it at a certain address through create to process. So then when you implement it, you could do a native implementation of like say the r one pre compile or whatever curve you want to bring in. So that way there's a definition that everyone can bring in with that work if they're okay with really slow stuff.
00:42:17.636 - 00:42:39.150, Speaker B: There's issues around how do we modify gas charging for that? How do you make it so we don't get the full cost of the EVM and we reduce it to a more optimized value. But I think as far as reserving spaces and numbers, that's something that might be worth considering as we go through the process. Or we could just go with a registry, which is also another fine option.
00:42:45.340 - 00:43:06.900, Speaker A: Okay, I think that makes some sense. Anyone else have some things I'd like to mention with regards to rips? No. Anskar?
00:43:07.400 - 00:43:52.630, Speaker C: Yeah, I just wanted to briefly say, of course, this is like a big undertaking. There's a lot of, I think, open questions. I think the idea of this call is also more to just basically start the process, present the idea, and then we'll have to figure a lot of these questions out over the next few months. Hopefully we can make some progress in Istanbul already with people, hopefully at least as many as possible people in the same room, and enough time to really dive into this. But a lot of this will probably have to be refined over time as we actually see in practice how the interaction across layer twos, between layer two and layer one goes. Yeah, so this is by no means like a present finalized proposal here. It's more of like, this is how we want to get started and then take it from there.
00:43:58.210 - 00:44:44.220, Speaker A: Yes, that makes a lot of sense. Okay, so next topic I'd like to jump into is the r one pre compile. So that's EIP 7212. Obviously it being an EIP is already a thing we can think about, but it's a candidate that I think is very meaningful to bring that I think would have a lot of use and is another one of these seemingly just makes sense kind of things. Sec p 256 R one has a lot of usage, but anyways, I'm going to give it over again to onscar to dig into that a little bit.
00:44:45.710 - 00:44:46.122, Speaker B: Sure.
00:44:46.176 - 00:45:29.530, Speaker C: Yes, I think the idea was basically just to say that we have some technical topics we would want to talk about in Istanbul. A lot of these are like bigger topics that wouldn't make sense today. Anyway, to dive into this. One specific pre compile has been around for last few months now and just seems to be in a really nice place where a lot of their tools we've been talking to have already said that they'd really be interested in shipping this as soon as possible. And so we were thinking this might be a good candidate as like the first IP. So that's why we wanted to basically just have a small section on this call to just discuss it. And then the idea, the hope would be that maybe in Istanbul we could already basically finalize its spec so that we could really ship this as the first IP.
00:45:29.530 - 00:46:27.020, Speaker C: The idea is just, as you probably know, like Ethereum for UAS. For the enshrined cryptography we use the Sec B curve, which is relatively uncommon outside of blockchain. And so there's the much more common basically sister curve of the Sec 256 R one that, for example is also supported by a lot of these hardware secure enclave systems and the web authent standard and everything. So there's been a lot of desire to have this natively supported. I think there are implementations just in solidity, but that's like a million gas per invocation. So it's really quite inefficient. There has been this EIP we already heard in the intro round from the EAP authors, EIP 7212 in EIP so far, of course, because there has not been an IP process so far.
00:46:27.020 - 00:46:44.130, Speaker C: So yeah, what I would want to do is maybe briefly have the EIP authors give an update of where the EIP is at if there's like what the remaining open questions are. And then maybe briefly here just talk about how I choose feel about this as a potential candidate for first IP.
00:46:45.750 - 00:46:46.210, Speaker A: Sure.
00:46:46.280 - 00:46:46.754, Speaker B: Thank you.
00:46:46.792 - 00:48:05.818, Speaker F: I can talk about our current progress and open questions and current discussions about VIP. After we have discussed VIP in the ACDC, call the community has suggested us to apply an l two first approach. From that time we have been discussed with some l two s and roll ups to implement DzIP, and Zksync has already made a huge progress on building this pre compiles in Zksync error roll up. Then Polygon team has requested the PIP to discuss implementing it to the polygon chain. We have already published it, and currently we are still on the review phase and we have some still open questions. The biggest question, which is also talked in the ACD call, was having a recovery or verification as a pre compiled contract. We have started with verification because it's the standard of the curve and it's only supported in the devices who is using this elliptic curve, and recovery is not supported in this kind of devices.
00:48:05.818 - 00:49:14.450, Speaker F: Also, the programming language has already support for the verification operation, but they don't support recovery. So having some client implementations are harder in the recovery part. Also in the EOS, making a recovery makes sense because you get the public address of the accounts, but in this station I don't see a real value of making recovery. So we have choose verification, but it's still open to discuss. The second open question is having a malleability check in the pre compiled contract. EC recovery already has it, but we have removed it in this phase because it's not included in the curve standard. So we want to cover all of the test vectors of the elliptic curve.
00:49:14.450 - 00:50:02.340, Speaker F: Then the last discussion is having these pre compiled contracts as a progressive precompile, which as mentioned earlier, it might allow to use the same address in every chain by a solidity code, then replace it with a pre compiled contract. And last note, we have published a client implementation for the Go Ethereum clients, and a developer from the community has implemented it for the rust Ethereum and basic client has this elliptic curve in its native library, and I guess it would be easier to implement as a pre compiled contract. And it's all progress and discussion from my side.
00:50:06.630 - 00:50:07.890, Speaker A: Thank you Raj.
00:50:12.790 - 00:50:27.100, Speaker C: Yeah, awesome. I think that talking to people, it sounded to me also that the biggest remaining open question on the specific pre compile would be whether to follow the NIST standard, which indeed is basically.
00:50:28.910 - 00:50:29.226, Speaker B: You.
00:50:29.248 - 00:51:33.034, Speaker C: Get a signature and a pub key and verify the signature, as opposed to the more Ethereum native way that we do with k one signatures with EC recover pre compiler, where you only take the signature and then instead of verifying that it was indeed signed by a specific pub key, you recover the one valid pub key that could have signed the signature. So it's a bit of a different logic. There's some small efficiency advantages doing it with the EC recover, because then you don't have to store an entire pub key, you only have to store, say, some sort of hash. But yeah, as Luci was saying, is that basically because the NIST standard is such a common standard that basically all the implementations only support the verification. So it would be a huge effort to have an Ethereum specific easy recover logic instead. I think that's why most people were favoring the verify approach. And there's also, again, with another small difference in signature malleability.
00:51:33.034 - 00:52:20.750, Speaker C: The NIST explicitly allows for malleability. Of course Ethereum usually tries to avoid that. But yeah, basically there's just some small remaining decisions to be made here. And then this would be something that we could finalize this, back off and have ready for letters that would want to ship this. Also, of course, exec just mentioned in the chat that has been discussed before that there are alternative approaches. There's this EVM max proposition that's been around for a long time to basically just make more arbitrary elliptic curve operations in Ethereum cheaper by adding these more generic primitives that can be combined. There's some estimate that could bring down the r one verification to something like 70,000 gas.
00:52:20.750 - 00:53:12.320, Speaker C: An 80 b compiler would be more like two to 3000 gas. So it's still quite a bit of a difference, but less so than a million gas, of course. So at this point, what I would be mostly curious, I think kind of making sure that the spec is finalized. We can do that in Istanbul. What I'd be curious more would be to hear from different layer two teams. If you've already been in contact with this specific pre compiled proposal, is this something that you'd be interested in shipping if it were to become an ip and agreed upon spec wise between the different layer twos, is this something that you'd not be interested, you'd rather want to go with the Evmax route or you just want to wait until mainnet or something? Basically just getting your team's takes on whether this would make a good ip is what I'd be interested in.
00:53:23.790 - 00:53:52.130, Speaker B: Sorry, go ahead, Nicholas. No, please, I'll just go real quick. It's already been mentioned that polygon is very interested in this proposal. So it's both a great proposal for us, but then it's also, I think it's a great candidate to be kind of the initial way that we work through and figure out how this process is going to work. So we're definitely in favor.
00:53:58.910 - 00:54:00.650, Speaker C: Nicholas, I will go next one.
00:54:00.720 - 00:54:46.860, Speaker B: Yeah, I think it's quite interesting to look at the EVM implementations because I think a lot of work has been spent there as nobody had the curves he wanted and so on. For us, it's a reasonable trade off, actually, for two reasons. First, because everybody has exactly the same implementation, because it's not anymore having to agree on a pre compile. It's available in the layer one as well, which is always good for compatibility. So I think we should really be sure that these approaches don't work before going for the pre compile at this stage, considering all the work that has been spent on that.
00:54:51.710 - 00:55:42.460, Speaker C: Okay, thanks. Yeah, I think the only comment that I would have on this would just be that obviously our role here would not be to be opinionated to convince people whether they would want to go ahead with this pre compile or instead take a different route. We've just been hearing from teams that some of them are really kind of wanting to either just chip this on their own in their own version, or if we want to have a standard, then really basically people were telling us the standard would have to be finalized very soon, otherwise we don't want to wait for too long. So again, I think the general spirit of this group would be more to just say if there is interest in chipping something by some teams, then basically we'd be happy to facilitate the standard, and we don't want to make a call on whether you should or should not do so. Oh yeah, a lot of people. Carl, do you want to first?
00:55:43.470 - 00:56:08.500, Speaker A: Yeah, I think you got most of it, but yeah. Just to mention again that all of these proposed standards will be optional. We're not defining the one way to do things in an l two evm. It's about presenting some standards which you can opt into and implement if you so wish on a given l two. And yeah, I think a lot of these things are very complementary, and different trade offs make sense for different people. Thanks.
00:56:10.550 - 00:56:16.994, Speaker C: Great. Harry? Yeah, just wanted to say from an.
00:56:17.112 - 00:56:50.366, Speaker B: Optimistic world perspective, I think the nice thing about things like this is that they tend to be relatively straightforward to implement just because kind of, if there's a standard implementation in go ethereum that's kind of relatively easily incorporated. I think that from my perspective, this seems like a very nice sort of initial kind of target, just because it feels relatively non contentious and obviously quite high value. I think that all of my concerns around it would be kind of much more just figuring out the kind of underlying sort of.
00:56:50.468 - 00:56:51.022, Speaker C: Okay.
00:56:51.156 - 00:57:08.040, Speaker B: Making sure there are how we can avoid conflicts without one, how we can also kind of optimally coordinate around sort of tooling and other stuff. I feel like it's a kind of opportunity in a relatively non contentious way to kind of feel out the borders of what really works here.
00:57:11.810 - 00:57:18.820, Speaker C: Sounds good. Yeah. I can't pronounce this, but you go ahead.
00:57:19.670 - 00:57:26.980, Speaker B: So on our side at DK sync, the pre compile is also ready. So we're also very excited about this opportunity.
00:57:31.380 - 00:58:31.030, Speaker C: Great. Yeah. Then I would say it seems at least there's enough interest that it would make sense. So obviously we haven't even created the IP repo yet. We'll do this over the next some point between now and Istanbul, and then work with the Clave team to basically figure out either just turn the existing EIP into an IP, if that makes sense, or just create a new one or something to have that, I think still in Istanbul part of the conversation, besides just finalizing it, could also still be evaluating alternative approaches just so people can make up their minds whether they think this is a good idea to go ahead with or not. The only ask that I would have then would be for teams that are already, and I think Zksync is probably the one that's already the furthest in kind of implementing this, that at least ideally you hold off of finalizing the before we have to start, or if you of course, feel strongly that you'd want to go ahead and maybe at least kind of come and briefly talk with Carl and me. So we are at least aware of this.
00:58:31.030 - 00:59:05.250, Speaker C: But yeah, I think the idea is in either way would be to have this basically become a finalized standard on a very fast timeline, because it's a small change and there's been considerable interest on the layer one side as well already. So I think layer one devs would be more than happy to also basically participate in that conversation to make sure that if we ever bring it to mainnet, that this generally aligns with what layer one people feel about this. Awesome. I think that's probably a good conclusion to the r one section of the call.
00:59:09.570 - 00:59:46.060, Speaker A: Yes. Thank you. It seems like Tim has got some kind of poop thing going on in the chat, so if you're interested in that, have a look over there. So on the topic of Istanbul, some other things that we would like to be discussing there, and some of them have been brought up already. The first one would be state commitment verquel, which I believe Nicholas referred to. So, yeah, I think that'd be a pretty helpful thing. Obviously, there'd be a lot of work done already on main net for that.
00:59:46.060 - 01:00:42.986, Speaker A: And I think now this would be a good time to get feedback from Altus on what potential issues there are for using what we already have in terms of research for main net because there's a chance that we could be getting this into the next main net hard fork. So I think now is one of those moments where l two s need to look towards l one to see if that makes sense. Yeah, so I think that's Verkal. EOF is obviously something that's been discussed a lot. We've seen a lot of consideration there. It is something, again, that'd be a lot easier to ship on the l two side of things and would allow a lot of the discussions and changes we've been talking about here to happen a lot more easily. Should we have EOF? I believe there was a peep and eep done on this yesterday, so keep an eye out for that.
01:00:42.986 - 01:01:42.640, Speaker A: That'd be something that it'd be nice to have people caught up on and have opinions on by Istanbul. Counter abstraction is obviously always a very big topic, and that's really your expertise here. But again, would be a good discussion to be having in Istanbul and then some more general ones that come up is a standardized way of handling fee markets and multi dimensional gas pricing. We'll definitely have a breakout on that. Bridges is something that's been discussed and what this multichain lifestyle would look like and any other topics. We will be posting an eth magicians thread on some more of the details and topics, an outline for what's going to happen by the end of this week for Istanbul. And so we'll encourage you all to contribute to that.
01:01:42.640 - 01:01:52.660, Speaker A: Does anyone have any other topics that immediately like to mention that like to discuss in Istanbul at.
01:02:01.070 - 01:02:42.970, Speaker B: Things? We brought this up along in the channel already, but one of the things that we're working on here at Polygon is because we already have existent provers which do use a sparse Merkel tree, and we're seeing that as being something that's sort of starting to exist in the ecosystem. We would like to talk about how we can start working toward a standard on that, or at least standardize as much as possible so that tool builders, people that are interacting with these things, have a good starting point. So I don't know if we'll be able to get to a full standard for that, but we would like to start talking about that and seeing if there's interest for that in Istanbul.
01:02:52.390 - 01:03:38.158, Speaker A: Great. Yes, I think that brings us to the end of some of the more technical discussions. So I think some other things that are important and things to think about moving forward, and certainly before we see each other in Istanbul. One is this whole process is not something that Anska, you over myself are trying to run here. We're just trying to provide a credibly neutral platform for discussion. So we would really like this to be community run as much as possible. And I think a good first example of that is rip editors.
01:03:38.158 - 01:04:36.658, Speaker A: It would be really cool and helpful if teams can nominate people that they have to contribute to this and help as editors if that's something that you'd like to do. Other things as mentioned, we'd really like to potentially make some final decisions on ROI and pre compile. So that would be helpful if everyone can think about that. I just posted the magicians thread on that. If you haven't read up on some of the latest discussions there. And yeah, we have this telegram group that we've discussed some things in. I think that's been good for some of the discussions, but it's also led to there being bottlenecks for people joining, mainly just when us admins can add you.
01:04:36.658 - 01:05:09.840, Speaker A: So soon we will be porting that over to the EtH R and D discord, which I think makes a lot more sense. It's the same way we handle ACD discussions and the consensus layer discussions as well. And then that's just fully open, so watch out for that. And then we'll connect up the telegram group. We have again as a bridge between that. So you can still follow that if you need to via telegram. And yeah, I think.
01:05:09.840 - 01:05:16.720, Speaker A: Does anyone else have any final things they would like to raise or discuss in the last little bit of this call?
01:05:21.830 - 01:06:20.710, Speaker E: Sure Carl. So I've put together an EIP too about EVM profiles. So the idea is that we talk about type one, type two, type three, and what we're seeing at immutable across the different roll up implementations is different opcodes being implemented, different pre compiles being implemented, and for the things that say like the ran down difficulty having different values potentially being returned. So having a standardization on that would be really good. And in the agenda for this call there was a link to the ETH magicians conversation on that EIP, and hence the link back to the actual EIP itself. So I encourage you to all have a look at it and provide feedback.
01:06:24.110 - 01:06:54.380, Speaker A: Thank you. Peter. Yep, I posted the link to that in this chat as well, would encourage people to take a look at that and we can discuss further in person. In Istanbul. Other further topics. Anyone want to raise their hand? Going once, going twice. Okay.
01:06:54.380 - 01:07:28.850, Speaker A: Well, then thank you, everyone, for attending. I'm excited to see where we can take this. I think there's a lot of platform for collaboration. And then I look forward to seeing lots of you in Istanbul. Primarily it's again the Wednesday, the second day of the l two days. We'll be having a dedicated event to these kinds of discussions. And then there's also that separate event, which is the EVM day, as Isaac was mentioning.
01:07:28.850 - 01:07:37.930, Speaker A: So, yeah, thank you very much. Thank you and goodbye.
01:07:38.990 - 01:07:41.978, Speaker B: Thanks, everyone. Cheers. Thanks.
01:07:42.144 - 01:07:42.890, Speaker A: Bye.
01:07:44.310 - 01:07:46.160, Speaker B: Thank you. Bye bye. Thanks.
