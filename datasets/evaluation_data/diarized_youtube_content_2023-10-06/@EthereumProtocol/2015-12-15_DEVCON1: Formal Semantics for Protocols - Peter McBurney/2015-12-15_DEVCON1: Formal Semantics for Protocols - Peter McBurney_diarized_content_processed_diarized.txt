00:00:16.410 - 00:00:46.858, Speaker A: Thank you. Thank you, ladies and gentlemen. I'm the last speaker. I'm the only thing between all of you and a drink, so I'll try to be fast. Thank you for inviting me. I'm going to talk at a very high level about some very abstract stuff in another part of computer science, which I think has relevance, but probably not immediate relevance. So I'm going to throw in some ideas and take with them, as do with them what you will.
00:00:46.858 - 00:01:52.574, Speaker A: They may not be relevant for a while. So, starting with the idea that shared ledgers are just databases with a communication protocol, it made me think that there's been lots of work. Most people don't know about it, but a lot of work on communication protocols between autonomous intelligent agents, if you're not aware, are just objects with attitude, objects that have the capability to decide for themselves whether or not they will execute when invoked. The goal of this research has been trying to automate communications between software agents. So having automated dialogues between autonomous agents, the status of that work, it's still ongoing. The status is that we understand well different types of dialogues, drawing on work in the philosophy of language and the philosophy of argumentation, we also especially understand dialogues about beliefs. So, dialogues about facts, dialogues such as where one agent tries to persuade another agent of something, a dialogue where agents collectively try and resolve a factual question.
00:01:52.574 - 00:02:35.706, Speaker A: We understand those dialogues very well, and we can automate most of them. We can automate negotiations in the case of simple negotiations, more complex negotiations, by simple I mean things where you can define the objects of the negotiation very easily. For example, negotiations over the price of something for a well defined commodity or a well defined object. We can automate those very well. We don't, however, yet understand dialogues over actions. And the fundamental reason for this, in my opinion, is that the philosophers have spent something like two and a half thousand years studying beliefs, and only a little bit of that time studying actions. We don't have good theories.
00:02:35.706 - 00:03:37.330, Speaker A: Only recently have we started to have theories about intentionality and intentions and their relationship to actions. So therefore, we don't understand dialogues over actions, because we don't understand actions. How's that relevant? Well, in computer protocols, we have utterances, things are said, messages are sent. In computer protocols, these utterances are a means of communication either between the people behind the programs or the programs themselves, in the case of agents. So linguistics is relevant here, that human natural language, linguistics is relevant because of communications. But if they're computer protocols, then they will be defined, or they'll have a defined syntax, hopefully machine readable. It will be formal, and therefore logic is relevant, mathematical logic, in particular protocols, computer protocols with utterances, may be viewed in another way, and that is that the utterances themselves aim to change the state of some system.
00:03:37.330 - 00:04:34.690, Speaker A: So a message being sent generally has the purpose that it wants some state change or intends to create some state change. So we might imagine, and we can imagine utterances as being commands in some programming language. In the case of software agents, the agent is intending to do something, intending to change the opinion of some other agent, or intending to pass some factual information. So of relevance, if you view it this way, of relevance, is program language theory, the theory of programming languages, in particular the formal semantics of programming languages. So because of those three different ways of viewing utterances in protocols, communication protocols, we have lots of different techniques to come to use. And one of those techniques comes from all three of them is the concept of semantics. But all three disciplines, linguistics, logic, and program language theory, use that word semantics in different ways in this field.
00:04:34.690 - 00:05:16.798, Speaker A: In agent communications, we use it in all those ways. If we think about utterances on the blockchain, then the blockchain initially, as we all know, was a record of bitcoin, and it still is a record of bitcoin transactions. But in the last year, perhaps the last six months, even, there's been a transformation in how people view those utterances. So if we're recording bitcoin transactions, then we can easily record transactions in any currency. People quickly realize that we could record transactions of any exchange of assets, doesn't have to be currency. Then they realize we can record any information. And then people have started to realize just recently, we can record promises and commitments to future action, to actions.
00:05:16.798 - 00:06:13.362, Speaker A: So not just information about facts, about the world, but actions about our intentions or the intentions of some entity. And then we can use these ideas distributed ledger as a way to enable multiple parties to make decisions. So where there's an action that requires two or more parties to act jointly, we just saw an example in the previous couple of talks. Then the distributed ledger idea, or the blockchain idea, is a very powerful way of enabling that. Just as an aside, perhaps the most crucial example of actions that require multiple parties to act is the launch of nuclear missiles. You need to have at least two people turn the key, and those two people must be more than an arm's length away from one another so that one can't force the other to do it. Okay, how might we think about this? So we've seen quite a few different layered stack diagrams today, and there are many floating around.
00:06:13.362 - 00:06:37.238, Speaker A: This is the one I like to use to consider or conceive of this idea. At the bottom, we have real world events, things that happen in the real world, real world events and actions. Above that, we have dialogues. We can think about them as being separate dialogues about those events and actions. So they might be dialogues between humans, they might be dialogues between machines. For our purposes, that doesn't matter. They're dialogues.
00:06:37.238 - 00:07:15.970, Speaker A: Those dialogues and those events at the bottom, in the bottom layer, end up creating records on some shared database. So, for example, the blockchain. And then we might imagine inference over those records. So the inferences might be smart contracts, they might be reputation systems, they might be some combination of both. So if we separate out the different components like this, I think that helps us understand what we're modeling and where are records being created and what's happening to those records. Okay, so from linguistics, I said linguistics was relevant here. We talk about, linguists talk about syntax, semantics, and pragmatics.
00:07:15.970 - 00:07:47.346, Speaker A: So syntax is the logical form of sum utterance. So I have 100 pound. That's an english sentence. It has a subject, an object, and a verb. Have is the verb, and english grammar exists. We have rules about how we formulate and express sentences. Linguists are not agreed about the definition of the differences between semantics and pragmatics, but one common approach is to say that semantics is the relationship between the syntax on the one hand and real world on the other.
00:07:47.346 - 00:08:34.686, Speaker A: So whether the statement is true or false, for example, is a semantic question, a question about the meaning of the statement. So, do I have 100 pound? Well, if I needed to verify that statement, I'd have to show the money or point to a bank account balance that showed that I have that money. So semantics is about the relationship between the statement, the syntax on the one hand, and the reality on the other. Pragmatics is about anything else related to the meaning of the statement that's not about the truth or falsity. So pragmatics is often about, how is a statement correctly used? So a statement such as, I promise to give you 50 pound, that's a promise that has no truth value. There's no sensible way to say that's true or false. Who knows what's inside my head? You can't verify what's inside my head.
00:08:34.686 - 00:09:12.314, Speaker A: A promise requires. We'll see in a moment. A promise requires some participation from the audience, from the person to whom the promise is made. And in many situations, in many real world situations, the pragmatics, the rules under which statements might be made and the rules under which they turn into commitments become very important. So why do we look at semantics and pragmatics? Well, I thought I might have to justify this, but we had a couple of talks today, really good talks about formal semantics and formal verification. Here we're talking about communication protocols. In any communication, we want the entities that are doing the communicating, either agents or people.
00:09:12.314 - 00:10:10.542, Speaker A: We want them to have a shared understanding of what they're communicating about. That's not necessarily as easy as I make it sound, but we need, if there are agent communications, the agents involved have to think they're meaning the same thing when they make utterances to one another in computer protocols, they're typically different entities in the system are developed by different development teams, so they too need a shared understanding. They need the same, hopefully the same shared understanding of what they're saying. So this is linguistic semantics, what a common meaning for statements. It turns out that having a good formal semantics for communication protocols also helps with the specification design and the coding of those protocols. So one of the talks this morning, we heard about formal verification, where there was proof by construction. So just by doing the design in the appropriate formal language, automatically you could automatically generate the code.
00:10:10.542 - 00:10:49.674, Speaker A: Similar thing happens here. We want also to verify properties of protocols. So questions like fairness and termination, that the protocol terminates or ends or doesn't end if you don't want that, or that no gridlock state comes about. So formal verification, as in the talk two or three talks ago, we want that. Generally we want that for communication protocols as well. And if we're going to do automated inferences, if we're going to go, if I go back to this picture, go to the top layer, if we want those inferences at the top layer to be themselves automated, then we need a formal semantics. Typically we need a formal semantics for the protocol so that a machine can read those and make sense of those.
00:10:49.674 - 00:11:32.694, Speaker A: So quite often there's often a tension between developers, on the one hand, who just want to go I code, and people who come along later, US computer scientists who come along later and say, hey, wait a minute, you need to formalize what you're doing. And people in AI are particularly keen on formalizing because that's how we do automation, how we do anything automated. In programmed language theory we talk about semantics as well, and there are three main types of semantics. So I'm just giving you a very brief overview. This is a whole subject in itself. We talk about axiomatic semantics for, in this case, utterances. So those are the preconditions and the post conditions for each type of utterance.
00:11:32.694 - 00:12:12.274, Speaker A: There's a common agent language called the FIFA Acl. And in the FIFA ACL1 agent cannot tell a fact to another agent unless the first agent believes that fact. So the first agent has to believe it to be true. This is supposedly to prohibit agents lying to one another, but it prevents any negotiation. You don't want to give away your price before you start the negotiation. So the axiomatics can be quite tricky, can be quite subtle. To get an operational semantics is basically thinking of the utterances as being commands in some language, and that language acts on the state of some big virtual machine.
00:12:12.274 - 00:13:18.886, Speaker A: The machine doesn't exist in reality, but it's a conceptual trick to help us understand what the impact of an utterance is and what its impacts, its consequences might be. So it occurred to me during the talks today that if we have a true global state, if we adopt this policy that we were hearing about earlier in the day about sharding, where we have a true global state at the top level, but within each shard there might be local states, then it will be interesting to see what operational semantics, how that would play out, because the commands at the local level may not be operating on the global state until they are hashed up, till they go all the way up. And then a denotational semantics is a semantics that maps the syntax to some mathematical objects. Why do we want to map things to mathematical objects? Well, one reason is that we've got a couple of thousand years of experience of reasoning about mathematical objects. We know how to manage mathematical objects, we humans, and by doing this we are then able to reason about the programs and the formal verification. Talk about this afternoon was an example of that. One type of mathematical object we have used a lot in agent communications is games, particular games.
00:13:18.886 - 00:13:44.130, Speaker A: So we map utterances to games and study the properties of those games. An example of this is with promises. So promises require an audience. You can't make an effective promise to yourself. Philosophers have looked at this and they say it makes no sense. So if person a promises to wash the car of person b, then there has to be an audience. B has to hear this promise, or has to learn about this promise.
00:13:44.130 - 00:14:16.494, Speaker A: There's a concept called uptake in most cultures, English in particular. A promise doesn't become a commitment on the person making the promise. In this case, a commitment is only created when B accepts the promise. So B says, okay, yes, you can wash my car, I accept that promise. So the promise, in the jargon of the field is said to be uptaken, it's taken up by b. So notice that the promise was made by person a, but the uptake was by person b. Two parties involved there.
00:14:16.494 - 00:14:52.310, Speaker A: Now, if we want to revoke the promise or cancel it, then typically in most cultures, a promise can only be canceled by the party who took it up. So if I make a promise to wash your car and you say, yes, please do, then I can't come to you later and say, sorry, I don't want to make that promise anymore. So in many social situations I can, but there'll be a consequence to me. You might no longer trust me. You might think, I'm not going to take promises from him anymore. In legal or financial domains, there might be other consequences, more severe consequences. So this is an example where there's an utterance about an action.
00:14:52.310 - 00:15:19.202, Speaker A: There's two parties involved here, a and B. One is doing the promising. A party b can uptake it and revoke it at any time, and may also have the power to say it's fulfilled. For some utterances about action, there might be three parties involved. One party has the power to promise or to make the utterance. Another party has the power to update and a third party has the power to revoke. Quite often with legal domains, that's the situation.
00:15:19.202 - 00:15:50.010, Speaker A: We have multiple parties involved. There might be a regulator involved. Once a commitment has been made, only the regulator can cancel it. Once a trade is executed on the New York Stock Exchange, for example, it can be canceled, it can be revoked, but only the New York Stock Exchange itself can revoke it, can cancel it. And apparently they do cancel them, about one a week under special circumstances. So we can represent this particular situation because there's two parties involved. We can represent it as a game, a two party game, and we can study the properties of that game.
00:15:50.010 - 00:16:02.460, Speaker A: And that's an example of a denotational semantics, so that we understand what's going on between those two parties in a particular way that actually helps us with the implementation, with coding it. So that's the end. Thank you.
