00:00:00.590 - 00:00:01.140, Speaker A: You.
00:00:03.030 - 00:00:30.074, Speaker B: All right? Yeah. Since we are like ten minutes late already, maybe let's just get started with a round of updates and then maybe by the time we get to actual discussions, somebody from wiper going to join. So welcome everyone back to the EUF call. Let's start with should we start recording? It is recording already.
00:00:30.192 - 00:00:32.300, Speaker C: Oh, it is. Oh, the whole time. Got it.
00:00:35.230 - 00:00:41.914, Speaker B: All right, let's. Yeah. Daniel, you're on the top on the list right now, so maybe you can go client update.
00:00:41.962 - 00:01:27.820, Speaker C: So I've been updating the base implementation based off of Shanghai, trying to get it in line with where we're at. I've been running differential testing against the create three branch of EVM one. Between the two of us there's still a lot of things that we don't fully commit to. I haven't committed the full create three implementation yet, but there's also some other corner cases that I think get that's not get that Basu is correct on that EVM one doesn't have implemented yet. Like there are some things about crossing the delegate call barrier into legacy that should be rejected. So there's minor calls like that. But the stuff that we agree on have got us up to the point where Besu and EVM one mostly agree.
00:01:27.820 - 00:02:02.242, Speaker C: A lot of the changes I had to do that are changes from Shanghai relate to moving the container and the data kinds. Moving the container before the data and changing numbers from three to four. Since data is a mandatory section, I had to update nearly all of the validation tests to fix that. The only ones I didn't have to update were the ones where the data was missing. It was invalid. So pretty much all of them that are valid. Also all the r jump tests when we went from a one based list size to a zero based list size, I had to update some of those tests.
00:02:02.242 - 00:02:40.306, Speaker C: Got rid of a whole class of tests about jump table too short since we can have a zero link. Jump table of zero is maximum index zero, so that's one link. So got rid of an entire error case there. But I also had to update all of the jump test tests again. But after I worked through those two items, I got most of and updating the tests from the basic opcode interoperability. EVM one and Basu are mostly line. We probably need to update some of the reference tests once we seal the specification and lock it down and get it to the point we're not changing it again.
00:02:40.306 - 00:02:43.480, Speaker C: So that's what's been going on basically in the past week.
00:02:50.680 - 00:03:11.090, Speaker B: Awesome. That's a lot of updates. Anyone have any feedback or question to this? All right, let's go over to Nethermind. Ayman, you want to go next, please?
00:03:11.460 - 00:03:13.456, Speaker D: Okay. Can you hear me, guys?
00:03:13.638 - 00:03:14.944, Speaker B: Yep, it works.
00:03:15.142 - 00:03:47.020, Speaker D: Okay, so for nethermind, we actually completed a draft implementation of the spec and right now we are verifying it like line by line. We are going through the upcodes and the new type of transaction validation to see if we missed something and if something is wrong. And yeah, that's mostly it. Also, we are upgrading our tests from the previous version since they don't work anymore.
00:03:48.000 - 00:03:48.364, Speaker B: And.
00:03:48.402 - 00:03:49.550, Speaker D: Yeah, that's it.
00:03:51.120 - 00:03:55.820, Speaker B: By the spec you meant the mega spec in the UF repo, right?
00:03:55.890 - 00:03:57.410, Speaker D: The new one, yeah.
00:03:58.180 - 00:04:01.280, Speaker B: Did you run into any issues, any complications?
00:04:02.100 - 00:04:40.830, Speaker D: Well, we found that what is called exchange opcode had a collision with some other opcode. We opened an issue and now I guess it's fixed in the spec and there were some vague points about auxiliary data and what's it called? Recursive container validation in create four. Like does it go all the way deep or does it stop at layer one? For now we coded it to go as deep as possible. And yeah, that's mostly it. If I find something else, I'll share in the R D channel.
00:04:44.320 - 00:04:58.004, Speaker B: Sounds good. I saw those findings. Anybody has any comments to iman, just.
00:04:58.042 - 00:05:19.790, Speaker E: To remind both another mind and Bessel that we have some state tests in test repo that you might want to try running. They cover create three and create four testing mostly, but it can be just like a simple test to check how you agree or not. With EvM one, this is.
00:05:26.320 - 00:05:47.270, Speaker D: Also I remembered something. The call upcodes, the new ones for EOf that doesn't have like gas limits and stuff like this. Do they have the same opcode value as the previous ones or they will have new ones?
00:05:48.840 - 00:06:19.084, Speaker C: I think the plan was to have new ones. I think we have space reserved for them. One argument for reserving new opcodes instead of overriding existing opcodes has to do with ZK implementations. Like I was talking with some of the devs to know about linear. It would be easier if they had different opcodes. So when they arithmetize an EOf versus arithmetizing a legacy, it's the same loop because it's the same set of opcodes. So the validation is a different part of the ZK verification of the code.
00:06:19.084 - 00:06:28.130, Speaker C: And then once the code is validated, they just take the trace and do what they do with their ZK stuff so they don't have to worry about whether they're in EOf mode or not for the most part.
00:06:28.500 - 00:06:32.310, Speaker D: Okay, so they are not assigned yet.
00:06:34.120 - 00:06:42.310, Speaker C: There is a table in the execution specs that has a reservation for them. Let me find that for you.
00:06:44.780 - 00:06:57.870, Speaker B: I think we did agree on the new numbers end of last year or maybe actually middle of last year. We just probably never actually put the numbers into the spec.
00:06:58.480 - 00:07:01.710, Speaker E: Yeah, AIP has up to date numbers.
00:07:03.200 - 00:07:03.756, Speaker C: Okay.
00:07:03.858 - 00:07:04.510, Speaker E: Perfect.
00:07:08.080 - 00:07:12.930, Speaker D: Motivation. Okay, nice. Thanks guys.
00:07:19.480 - 00:07:24.200, Speaker B: All right, let's move on to our evm dragon. Do you want to give some updates?
00:07:26.540 - 00:07:56.480, Speaker F: Yeah, glad to be here. Yeah, last like two weeks something I did analysis of UF in general, just like overview what's going on and I still need to start implementing it. I'm not sure if you saw. Sorry. So the paradigm post about it. Yeah, I still need to start working on it. So I am still at the beginning, but seems great.
00:07:56.480 - 00:08:21.370, Speaker F: I have two questions. Or maybe I need more clarification about a need of the jump f function and about potentially removing 64 part of the gas in the calls. New calls. Other than that, it looks good to be honest.
00:08:24.910 - 00:09:22.270, Speaker B: Yeah, I wanted to reflect on the 64th so the calls 2.0 so that all those new opcodes. The idea was that we don't make an extreme number of changes beyond absolutely necessary and we deemed that removing the gas field is the most important change. And then not having the return data is something we also wanted to have. But we didn't wanted to change the gas logic too much because once the opcode goes live without being able to adjust the gas externally, we can always change the gas logic. So we could always later remove the 64th rule or redesign all of that once it's not inspectable. That was the idea we just wanted to minimize.
00:09:22.270 - 00:09:51.746, Speaker B: But I wonder, in the client implementations, when you do actually implement this, do you implement the new call up codes as part of the same handler which does all the complex versions of the existing ones or is it brand new helpers, aka yeah. What difference does it make to have this 64 rule from an implementation perspective?
00:09:51.858 - 00:10:29.234, Speaker F: For implementation, it's like different function. It's totally different. I'm not asking about implementation, ask in general. But you gave good explanation, like the path forward. Let's leave it as it is. And if you want we can remove it later because we don't have a gas inspection and that's like real big deal. I was just asking should we include it? Should we include that change now I'm not sure what that change is, but by just removing that gas, just having like fixed gas, something like that.
00:10:29.234 - 00:10:41.640, Speaker F: But, yeah, I can agree with, like, let's do it later. For now, let's leave what we already have. I just want to point out that we could potentially remove it. Okay.
00:10:44.950 - 00:11:11.210, Speaker B: Yeah, I think we are growing more concerned about the scope changes. Right. And this is like, yet another scope change. Yeah. Maybe we should just finish the round, and during this spec discussion, we can get back to jump f and maybe also discuss the 64 tool a bit more in depth.
00:11:12.270 - 00:11:13.900, Speaker F: Makes sense. Thank you.
00:11:15.150 - 00:11:28.000, Speaker B: All right, then. Someone from ipsilon. Well, actually, anybody have any response question to Dragon or the paradigm post?
00:11:34.220 - 00:11:36.780, Speaker F: Maybe we can talk about that a little bit later.
00:11:36.930 - 00:11:37.630, Speaker A: Because.
00:11:40.560 - 00:11:47.550, Speaker F: In general, what I would like to mention is, like, the bad things about EF, but we can do that later.
00:11:48.080 - 00:11:56.610, Speaker B: Yeah. All right, someone from ipsilon who wants to give the update on EVM one.
00:11:58.740 - 00:12:36.300, Speaker E: Yeah, we've merged a couple of things for you. We merged pen and swap new implementations, and we've merged disallowing unreachable sections. So that was merged into master and create three and create four are still in the branch. And in that branch, we actually realized we have a bug. Like, we forgot to disallow deploy an UF from legacy. So that was fixed today. And maybe that's the same problem that Dano encountered.
00:12:36.300 - 00:12:46.290, Speaker E: So that was a fix in creation and. Yeah, that's it, I guess.
00:12:52.190 - 00:13:10.760, Speaker B: All right, any comment? Question? All right, then. Let's move on to maybe Barnabas, I suppose you're DevOps panda ops. If you have any update, please go ahead.
00:13:12.330 - 00:13:27.390, Speaker G: We are basically just expecting a timeframe. We would like to begin testing eos as much as possible. So I would be curious, when do you guys think it would be a good time to start up like Devnet zero for UF?
00:13:32.950 - 00:13:37.682, Speaker B: So ideally, we would need at least two clients fully implemented for that.
00:13:37.736 - 00:13:37.954, Speaker F: Right.
00:13:37.992 - 00:13:39.554, Speaker B: That would be like a good start.
00:13:39.752 - 00:13:43.910, Speaker G: Yeah, that would be a very good start to have some kind of basic interrupting.
00:13:46.090 - 00:13:54.810, Speaker B: I think the best chance for that we have is Basu and Nethermind at this stage. Is that assumption correct? Ayman and Dano?
00:13:57.810 - 00:15:00.740, Speaker C: Yeah, we can get there. I would like a frozen spec before we get there, but we could start getting builds that can have that. As far as interop, I think we'll probably get more signal out of Martin's fuz testing, which I think would be better because I think more than a stable testnet, I think not getting any fuzz findings for a certain amount of time, I think is a better indicator that we are fully compatible with each other. But one of the advantages a testnet would give once we get the compilers producing output is for them to go through all of the masses of solidity code, compile those, deploy those, and wire those up into tests. So I think that the devnet is going to be important for when we get the compilers outputting stuff for them to get a test base. So we're still going to need that too. But I think there is another we need to get solidity and Viper to ship versions that compile down to EOF first, which we need a mostly frozen spec for.
00:15:03.030 - 00:15:08.710, Speaker G: For Devnet we wouldn't need a frozen spec. You could just relaunch.
00:15:09.610 - 00:15:10.886, Speaker C: Yeah, we could keep relaunching them.
00:15:10.908 - 00:15:41.760, Speaker G: Yeah, I mean, we can do very basic interrupt testing in kurtosis, which takes literally five minutes. So if we have some branches that would already work, then I can already spin that up in my local machine and see if we have basic interrupt working. But for longer term tests, other clients could also just sync up, maybe to a public devnet that could give some value also.
00:15:43.490 - 00:16:06.200, Speaker C: Okay, so I am pushing my changes, I need to push my recent batch up to Dasheof. That's a branch on Besu that's going to have the mega EOf spec. So yeah, there's a branch in Besu you could use, but I don't think we'll get much interrupt right now because there's still a lot of warts on it.
00:16:10.920 - 00:16:13.190, Speaker G: Sure, just let me know.
00:16:15.740 - 00:17:04.590, Speaker B: I do think there's one other use case that Devnet would be useful for is transaction tests. And I know that we have some transaction tests, but on an actual network we could just try submitting various experiments on the create transactions and all that, and that may be something of interest. All right, let's move on to spec updates and then discussions. Ipsilon, somebody from epsilon, do you want to give a brief update on the spec, any of the spec changes?
00:17:12.420 - 00:17:39.690, Speaker A: Okay, I can give it a shot. There's a bunch of changes that I guess were more like editing, but there are also some questions that we need to answer, which is one of them is already mentioned is the jump f. So maybe you could start with that, although I don't have any comments on that.
00:17:47.150 - 00:18:47.454, Speaker E: Yeah, I can give an intro to this topic. So yeah, after Dragon raised the concerns about whether jump f is really necessary in this pack. So I've created an issue for discussion in the spec repo and there was some discussion and Daniel from solidity and Charles from Wiper chimed in there. So I proposed how it could work in case we didn't have non returning functions and jump f. And yeah, note that jump f and non return function flag are kind of a package as I see it, they can only work together. So yeah, we either get rid of both of them or we need both of them. So there was a proposal how we could live without jump f.
00:18:47.454 - 00:19:58.790, Speaker E: If we just use call f to a function which is non returning and we don't have a flag, then this non return function will be just zero outputs. And in case if we want to imitate jump f in this design we could use call f stop sequence and then compiler does not need to clean the stack before this call f. So the same guarantee that jump f provides when jumping into non return function. So this is like a vibrant solidity. And Viper basically described what's their use case for jump f. And the use case is mostly like making helpers that extracting some shared con among several code paths into a helper, which can be either non returning but it ends with revert, for example, which is like a common like handling an errors and then reverting with different messages, or it can be returning so ending with red f. This might be useful too, according to Daniel.
00:19:58.790 - 00:21:19.440, Speaker E: And basically they want to keep as little overhead for this as possible, because in legacy they solve similar problems with basically zero overhead. So just doing a jump into such a subroutine and also possibly tail call optimizations are possible with jump f. But as I understand this is not something that exists in compilers. This is something like for future, which can be enabled with jump f. So yeah, overall this extra overhead that we would have without jump f and non return flag if we use call f stop instead, this is like an extra byte in the code which might be significant if it's used many times in the code. And also this call f, unlike jump f, consumes the slot in the call stack, which might be also significant at least like this is something the compiler needs to take into account when doing this kind of extracting the helper. So it's an extra pain for compilers at least to take care of this.
00:21:19.440 - 00:22:17.970, Speaker E: And jump f allows to just use jump f and don't think about it because it doesn't increase return stack. And another argument which I think is important is that non returning flag allows for validation to detect the code that is unreachable after calling the non returning function. So the code after caller for jump f into non return function is unreachable in practice. But if we don't have this flag, then this code will be considered reachable by validation. And this is not really nice. It means, yeah, this code will need to be validated, though it doesn't have to be, but it will need to be. And there might be some errors like stack underflow in that section of code, and then the entire code isn't valid, which is not really a good situation.
00:22:17.970 - 00:22:52.910, Speaker E: I think in general, I think that this non return flag and jump f makes this spec and makes the stack validation complete design in a way. So that's my view. I'm mostly in favor of keeping it, although I think complexity is significant because this stack validation around jump f and non returning is a bit tricky. And also this validating that function is really non returning when it is declared as such. This is also like another part of this complexity.
00:22:58.610 - 00:23:47.360, Speaker F: The biggest question that I had with Cola is like there is purpose for all of that. For cola is optimization. And with any kind of optimization, it's like optimizing for the right thing. It's really going to help solid wiper to a few percentages to speed up, or five percentages or ten percentages. They still can call ordinary functions to do whatever they need for returning. I'm just like fetch, I don't know. So the purpose why I'm that focused on Jap is to flush these things out.
00:23:47.360 - 00:24:47.650, Speaker F: And I think it should come from solidity. I think Wiper is not that for wiper, jump f is not that useful and they can go without it. I just basically want to verify that this is going to be very useful and we should include it. That was the main reason why I'm just pushing for reasons what's going on with jump earth in general. Maybe the step four for this is to basically wait for the slit analysis to see how impactful is that, and after that decide if it is good or not. I'm not sure what others think about this.
00:25:04.830 - 00:25:37.110, Speaker B: I mean, jump f was explicitly requested by solidity for basically the terminating functions Andre mentioned. But I suppose if you do remove some of these stack validation requirements, then maybe you could do without it. But if your question is where it was originating from, it definitely came from solidity as a request.
00:25:38.090 - 00:26:33.206, Speaker F: Yeah, this good information. Didn't know that. But the main question that I ask is like why do they need that? What's the problem that they want to solve? Maybe is there a different solution that we can basically give them at least that? GitHub issue 42, they said that relaxing some validation helped them with some of the cases. What I want to basically have in writing is hey, we jump f, we solving this and we are like having, I don't know, n amount of better code or something like that. In that sense maybe question for this group is, is this okay to ask? Do we step over the line? Basically in that sense, so I can.
00:26:33.228 - 00:27:42.030, Speaker B: Explain the original request and where this comes from. Maybe that helps. I think some of it Andre mentioned too. But basically it's not a gas savings, it's a code size issue. So in solidity, in error handling, you have these helper functions generated which do revert and at least in the design with the stack validation at that time this was discussed. So this goes back to over a year ago to the cancun, was it Cancun? Anyway, December 2022 version of UF. The stack validation requirements meant that if you would just call into any of these terminating helper functions solidity generates, solidity would have to generate a version of that helper function for each call site which has a different number of stack height.
00:27:42.030 - 00:28:08.870, Speaker B: And jump f was solving this by removing any of those issues and the solidity could have a single helper function. So by the design of the UF at that time, without jump f, solidity would have been extremely not useful, likely having a significant amount of the code size occupied by these duplicate helpers.
00:28:10.410 - 00:28:50.242, Speaker F: Okay, that makes sense. Is the main problem now about use case. Do they need like to do something and return from the debt subroutine or return from main call? Basically if this main call they can just return from the call, just return, revert whatever they need. If this sub call, maybe we need different solution for that. Do they need basically yeah, they need both.
00:28:50.296 - 00:28:55.110, Speaker E: According to Daniel, both can be useful for some cases.
00:28:56.570 - 00:30:12.340, Speaker F: Yeah, jump f like solves if you want to return for subroutine, basically jump some stack other things. Seems that solvable by the old sold. I'm just asking open ended questions and basically gathering more information because I don't know about history. This is the Connolly EP that I found a little bit not fitting in EOF in general maybe because I don't have full set information. In general maybe asking solidity for more like concrete hey, we need this because of this would give us more information to decide if you want this or not. Do others implementation like Dan or Andrew, are you okay with including jump f as this? Or maybe the flag of non returning flag?
00:30:15.520 - 00:30:24.370, Speaker C: I'm okay with it. I think the needs of the compiler are going to dictate which is more important to me and I'm okay with it going either way.
00:30:32.070 - 00:30:34.120, Speaker F: Alex, you want to say something?
00:30:37.950 - 00:31:30.890, Speaker B: Yeah, I wanted to ask Andre if there were a lot of discussions on relaxing stack height validation and that some version of that would have at least removed the terminating flag or the need for that flag. But I wonder, would any of those eliminate the need for jump f at least for this use case of jump f? I'm not sure if there's any. What other use case solidity imagines for jump f. But if you do have jump f, I mean one thing to be clear, if you do have any of these instructions, I'm pretty sure people are going to find ways to use them, ways we don't imagine yet. But I wonder what other use cases solidity was having in mind for jump f beyond basically the error handling functions.
00:31:31.950 - 00:32:36.590, Speaker E: Yes, stack validation is related and with the new algorithm that we have, the original issue that required jump f is kind of solved. And so if you make these helpers as if you make them inside one code section, then you can already jump into them and address it in this way. But according to Daniel there's a place for both helpers that are inside code section and for those that are extracted into a separate code. Guess. So the need for jumpf got less with this new stack validation, but according to Daniel it still provides some benefits for some cases. But yeah, there are no numbers and it's more like Daniel's intuition at this point I guess. And to evaluate it fully, I guess they would need to implement Uf first and then measure.
00:32:42.820 - 00:33:50.970, Speaker B: So I suppose the general logic is that we can always pool features easily getting closer to any of the rollouts, but adding new features is practically impossible, or at least we shouldn't aim to do it with that in mind, given we always have this chicken and an egg problem that we won't have really good data from the compilers before they implement it. And many of the compilers are reluctant to implement it before there's kind of complete spec and some indication from all core devs that this is going to likely to go ahead. So with that in mind, I'm leaning towards that we just keep jump f, we get everything implemented properly so that solidity has the confirmation that this is ready, will implement it, can do the measurements and I think we still have the option then to remove jump f. But adding it, if we don't have it right now, adding it wouldn't be an option.
00:33:53.740 - 00:34:13.250, Speaker F: I would agree with that and I would say echo what Daniel said, it's like solitary dictates what they want. That's very strong statement and I agree with that because we are building them to ease their work.
00:34:21.870 - 00:34:42.800, Speaker B: All right. Do we have any other spec discussion we want to have? I do have one meeting related question I want to discuss at some point in the call, but do we have any other spec topics or should we go into maybe discussing the paradigm post?
00:34:45.190 - 00:35:56.120, Speaker A: I can quickly go for the spec changes that we did or are considering doing. They are mostly smallish. One is that the data opcodes were moved to a different section because of the opcode conflict between exchange and data load that's been merged into the EOF. I'm going to merge the prs for the other places where it is relevant. There's this other discussion that's going whether the call to quote unquote opcodes should be also available in legacy. I posted the pr to EOF spec, which kind of goes the direction that they should not be allowed, but Andre said that Alex, you should take a look at this or anyone else that has any feedback and anything else. I think those are the main points.
00:35:56.120 - 00:36:25.900, Speaker A: And also that I don't know. I've started slowly updating the eips to be to match the mega aspect and also we need the meta EIP, which was requested a couple of times, but I don't think I'm going to be writing it. So if anyone is up to it, then go for it.
00:36:28.370 - 00:36:28.734, Speaker C: Yeah.
00:36:28.772 - 00:37:05.494, Speaker E: Regarding the calls, I think I lean to agreeing to not roll them out in legacy, mostly because of complexity of testing, like impossible interaction with old calls with new calls. And it just sounds a bit like a separate new project to cover all this with tests and investigate potential implications in legacy. And just. Yeah, I would rather not touch legacy at this point and I think that's fair.
00:37:05.612 - 00:37:05.894, Speaker F: Yeah.
00:37:05.932 - 00:37:22.560, Speaker E: If we still decide it also feels like we should champion for it separately, like mention it at ACD also often because everybody forgot about this detail by this point and it feels like we might not have capacity for this.
00:37:25.010 - 00:37:26.750, Speaker A: To mention what I meant.
00:37:31.270 - 00:37:39.010, Speaker E: EIP process wise, we have to champion it for it separately, separately from EOF if we want to roll it out in legacy.
00:37:43.470 - 00:37:58.374, Speaker A: Okay. Is it final to not allow them in legacy? Can we treat it as such? I think there's consensus, right?
00:37:58.412 - 00:38:22.720, Speaker C: So I think the first pass, we don't put them in legacy. If we change our mind, we could always bring them into legacy. But I think there's a strong argument for saying if you want this feature, you have to come to EOF. I mean, there's no structural reason we can't. But there's similarly no need that I would see in legacy. It's neat to say, hey, we could do this, but I think it would be a faster path to success to say these are EOF only and we don't change legacy at all.
00:38:24.630 - 00:38:24.994, Speaker F: Yeah.
00:38:25.032 - 00:38:56.410, Speaker A: Not changing legacy is also a principle because it's legacy. If we invite the possibility to change legacy, then we are not making it legacy really in a way, from the very beginning. Philosophically, it's also probably good to leave them out. Okay. That's all I've had, I think on the spec updates.
00:39:05.330 - 00:39:08.510, Speaker B: Any other feedback or question on the specs.
00:39:14.090 - 00:39:56.370, Speaker F: Maybe as a statement? I feel that the aips are like 90 95% done, but I think outside of this group, maybe a few more people, a lot of people don't know that. They think that the AIP are still like work in progress or not defined or still need a lot of work. Just saying for the people outside of this group that we should communicate that it's like close to 9500 percent, not 600%. But it's like few small details are left to define.
00:40:01.000 - 00:40:03.990, Speaker A: We could put that on the website. Probably.
00:40:05.820 - 00:40:24.908, Speaker F: Makes sense. I don't know, something in sense. EOF are very close, are finalized and few more details are left for discussions. I would say it's finalized in sense that just details are left.
00:40:24.994 - 00:40:42.930, Speaker A: Yeah. I mean, we can have a list of the live variables on the website, one of them being the megastack, for example, which is we can treat us, I don't know, 99% finalized and then the ips are we make up a number and then the clients and such.
00:40:45.620 - 00:40:59.530, Speaker F: It is for narrative so that people might know that this is ready to be included. I think everybody here already has the perpetration that needs to modify a little it. But yeah, other than RevM, but yeah.
00:41:11.560 - 00:42:00.230, Speaker G: In terms of testing, in case we do want to do another fork this year, we do have to have a devnet up by beginning of March probably latest like EOF changes and possibly anything else on the CS side that might want to be changed. So we have to have something working. It doesn't need to be the finalized spec because even for eight, four, four, we had like maybe 20 or 25 different devnets because of the change in the spec. But it would be good to have some client releases aiming to have something ready to go by beginning of March latest, I would say.
00:42:04.340 - 00:42:49.090, Speaker B: I think readiness, spec readiness in that terms. I think we reached it many months ago because many of the changes are, some of them are really just edge cases or simplifying or revising. But the one exception is using like Lev one two eight. That would be the only change which would go really against us being kind of stable. So TLDR, if you're happy to make multiple devnets, there shouldn't be any problem having like a March Devnet in my view.
00:42:55.620 - 00:43:35.230, Speaker G: I don't expect to just have one Devnet. Let's be clear about that because there will be changes all the time and I don't expect anything to be even when it's finalized, I don't expect it to be exactly how it is. As I said, 4844 was finalized back in I think February and then there was just change after change after change. It might be different. I hope it's going to be different for eos. I'm just saying that it's not uncommon to have changes in spec as we iterate forward.
00:43:37.840 - 00:44:00.592, Speaker F: I think that's a really good question. To have something testable in basically two months. I would ask like best nethermine, nobody from get I think, are they fine with that? Revm I'm fine with that. I need to do some work. But yeah, sounds reasonable.
00:44:00.736 - 00:44:11.676, Speaker C: That gives us six weeks to push to get something ready for Testnet, which I think is achievable. Again, on the caveat that we're going to find bugs and do multiple testnets.
00:44:11.728 - 00:44:41.570, Speaker F: After that, that's probably fine, but at least having been in that stage, hey, we can find bugs is like very big push. Netherbine Eiman okay he's not maybe here.
00:44:43.860 - 00:45:30.290, Speaker B: Yeah, iman let us know if you have a different view regarding Nethermind and having a devnet around march. Well, one comment about the devnet, we discussed it earlier that maybe fast testing would yield better results. I do think a devnet itself is just a different signal. It's more like a readiness signal that we got the implementations together. So I think from that perspective it definitely is an important step to make. Of course, fast testing and all kinds of other testing are equally as important. Since we only have six minutes left, I wanted to very briefly discuss the timing of this call.
00:45:30.290 - 00:45:47.690, Speaker B: Since now we overlap with the roll call and it seems like we are getting into the territory that we do have to probably sync up if you want to meet that March deadline. So should we move the call 1 hour later to avoid the conflict with roll call?
00:45:53.410 - 00:45:55.840, Speaker C: I can handle one early call a week.
00:45:58.730 - 00:46:01.350, Speaker A: That's 1 hour later or earlier.
00:46:07.070 - 00:46:19.886, Speaker B: Flex I meant later. Yeah, I think we cannot really move it earlier if we do want to get Daniel on the call, because 1 hour earlier would mean no.
00:46:19.988 - 00:46:26.980, Speaker A: I was just confused of what Dana said. But I think if it's later it's fine with me.
00:46:31.750 - 00:46:36.360, Speaker B: Okay, anybody strongly against moving this call plus 1 hour?
00:46:37.930 - 00:46:39.320, Speaker C: I'm cool with it.
00:46:45.580 - 00:46:59.100, Speaker B: All right, we'll update the calendar for the next one. The second question, with the March deadline, do we want to keep a bi weekly cadence or do we want to maybe consider weekly cadence?
00:47:01.040 - 00:47:04.220, Speaker A: I was going to suggest changing the cadence.
00:47:04.960 - 00:47:21.110, Speaker C: I think we need weekly cadence, especially because we're missing some key people from this call. I think we need to. If we're sending a radio signal, we need to be busy signal. I don't know what the correct word for that is and I think weekly meetings would do that.
00:47:23.560 - 00:47:24.500, Speaker A: Agreed.
00:47:25.240 - 00:47:28.890, Speaker G: We're going to need some people from all the years possible.
00:47:34.900 - 00:48:03.370, Speaker B: Nice. All right then we are agreed. I will ask Pooja to update the calendar entry. So it's going to be weekly starting next Wednesday and it's going to start 1 hour later. All right, we have three minutes left. I'm not sure dragon, if we addressed everything from the paradigm post or do you want to take an extra minutes to maybe explain some other feedback from there?
00:48:03.900 - 00:48:33.810, Speaker F: I think we did the bad thing that at least is like UF not finalized as the spec basically saying to the community it's not finalized. The second thing is basically not having champion. The problem is from time to time all core dev doesn't have like UF get mentioned, but nobody is there to respond. That's the only two thing that we can probably work on.
00:48:35.480 - 00:48:39.124, Speaker C: I think the worst case that was. Sorry, go ahead.
00:48:39.322 - 00:48:52.650, Speaker F: Yeah, that I heard from other people like Uf implementers don't care about UF to be in awkwardev or to support their cause.
00:48:57.890 - 00:49:19.346, Speaker C: Yeah, I think the real problem with it was three weeks ago when I was on vacation and we couldn't get someone to be vocal about it. I think that was the perception that it's not championed or anything. But I was on family vacation and I'll be on all the calls going forward, so don't worry, I'll bang the drum on it if it needs to be banged.
00:49:19.538 - 00:49:34.460, Speaker F: Okay, nice. Yeah, it's perfect. Fine to other people like championed it or basically talk about it, but either we need to have voice on that. Meetings, I think that's it. I took two minutes.
00:49:36.590 - 00:49:54.160, Speaker B: We move to weekly, I think. Yeah, this perception I think going to change in the last minute. Bornabasch had a question whether the implementations are built on top of Dennib. So Dano iman, yes, please answer.
00:49:55.250 - 00:50:13.800, Speaker C: Frog actually is what I'm targeting mine. I need to do some changes on mine, but on the basis side we need to plug Prague in places and various things anyway. And I'll make sure that EOF is currently targeting Prague for the state test. If you use the prog word, it'll go to something we call future eips, but it's all wired up right now.
00:50:20.140 - 00:50:45.024, Speaker B: Awesome. And Chloe, you joined quite late and I forgot to ask you, we have like 1 minute left. Do you have any feedback, any question to the group? Oh, hi. Not really from my side. Thank you. Awesome. All right, we are just about time.
00:50:45.024 - 00:51:02.540, Speaker B: Any closing comments from anyone? All right, then. Don't forget we're going to be weekly starting next week. And we change the time. It was a great call. Thank you all. See you next week.
00:51:02.910 - 00:51:03.610, Speaker F: Bye, guys.
00:51:03.680 - 00:51:04.830, Speaker A: Thank you. Bye bye.
00:51:04.950 - 00:51:06.990, Speaker B: Bye bye. Goodbye.
