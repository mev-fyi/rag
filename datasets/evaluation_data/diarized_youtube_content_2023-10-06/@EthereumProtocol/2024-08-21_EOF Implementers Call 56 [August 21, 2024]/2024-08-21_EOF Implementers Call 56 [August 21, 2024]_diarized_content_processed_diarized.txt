00:00:00.800 - 00:00:27.235, Speaker A: All right. Good morning, like good afternoon if that's where you're at. Or a good middle of the night even. This is the 56th EOF and Blenders call on 21st August 2024. Nothing was put in advance on the agenda except for a few items from last week that I just put on which should be a surprise to anyone. So we'll just go through these as we get get to them. If there's any other.
00:00:27.235 - 00:00:52.983, Speaker A: Are there any other items people feel we need to talk about that aren't expressed in the standard ones or the fuzzing and devnet forbidding this stuff. Okay. If you think there's stuff, just drop it in the chat as we get along. Client updates. I see the usual suspects. Nether mines here this week as well. Basically we VM1, I don't think we have anything exciting to talk about.
00:00:52.983 - 00:00:54.435, Speaker A: EVM1, do you have anything?
00:00:56.005 - 00:01:07.105, Speaker B: We actually found the bug in header parser today. So that's one more thing coming from father.
00:01:08.365 - 00:01:09.505, Speaker A: What was the bug?
00:01:12.605 - 00:01:41.315, Speaker B: EVM1 accepted multiple sub container sections because they are optional so that they were kind of handled differently. Slightly differently, but so you could put like O3 as the sub container section in the header and then another one and so header was kind of parsing. It's complicated.
00:01:42.255 - 00:01:44.167, Speaker A: Yeah, I totally get what triggered.
00:01:44.191 - 00:02:23.997, Speaker B: Yeah, yeah. We couldn't find a case where that could be exploited, but it's definitely a serious issue. But apparently Fuzzer has not found anything with this bug in that even one would consider fully, fully valid eos. Right. So maybe it's possible to construct some, but it's pretty difficult. So I think we didn't approach it more. But we'll have a fix and some test cases.
00:02:23.997 - 00:02:27.225, Speaker B: But yeah, okay.
00:02:28.405 - 00:02:35.945, Speaker A: Yeah. Probably finally hit the duplicate string and hit the right value after a week of fuzzing. I mean that's why you just let the fuzzers run.
00:02:38.125 - 00:03:20.627, Speaker B: So because I mean this topic maybe I'll try to address later. It's. It's not directly that the father has found it, it's just I. I was implementing Fuzz a mutator for. For the father and apparently the mutation was kind of going wrong according to the like my assumption and I needed to manually inspect some examples that were kind of broken and then I found it. That's why I don't see. That's why I say we couldn't find an example.
00:03:20.627 - 00:03:51.365, Speaker B: That would be if you consider how EOF would be considered successful on EVM side and like obviously wrong on the other side but maybe it's possible. And I think weakness of this fuzzing comes from the fact I only compare like the boolean value of validation, not like specific error codes. Right. So I plan so what happens if.
00:03:51.405 - 00:03:58.825, Speaker A: Multiple error codes trigger on the same one? I mean is it a fuzzing failure if multiple clients get the correct but different failure reason?
00:03:59.325 - 00:04:59.183, Speaker B: Well, you need to kind of handle that in the code somehow. I have some idea how to. Yeah, I mean so what I want to have in mind for like semi standardization would be instead of individual error codes I want to have some kind of error category. So for example like the error comes from like invalid header or like a specific code section that would be like difference and I think that would help like to distinguish what different implementations think about code. But I will write an issue about it probably for next meeting or something. Obviously I can try to map error codes coming from different implementation but I didn't try to do it yet. So it would be like kind of, you need to kind of implement some rules.
00:04:59.183 - 00:05:22.115, Speaker B: Like this error on this implementation means this one or like one of these on the other one. It's probably not like one to one match. And I don't think we want to standardize specific error codes right now. So I think that there's some work to do here. But yeah, I don't think that needs attention from everyone right now.
00:05:22.875 - 00:05:44.295, Speaker A: Okay. Yeah, I think a couple of the bugs that fuzzing found for be a couple weeks ago had to do with excess data in the sub container. If the sub container was had extra data at the end it shouldn't validate. It should be a perfect fit. So yeah, never mind. Ben Adams, do you have any.
00:05:45.955 - 00:05:57.695, Speaker C: Yeah, just a question on these Fuzzer test fails, are they being added as test? When the fuzz discovers something, are they being added to regular test?
00:05:58.235 - 00:06:12.615, Speaker A: Yes. I have an ugly PR I'm trying to massage into something submittable where I'm getting a lot of these failures I found into new tests. Typically they indicate a failure of test coverage when I find through fuzzer. So yeah, definitely adding tests for those.
00:06:13.115 - 00:06:42.925, Speaker C: Cool. So it was highlighted to us that we weren't testing the ERF container tests. We've added that in but we're failing them because we do a recursive validation and we blow our stack. So we're reworking how we're doing that to not be recursive.
00:06:43.675 - 00:06:44.495, Speaker A: Okay.
00:06:46.195 - 00:06:47.155, Speaker C: That's where we are.
00:06:47.235 - 00:07:01.515, Speaker A: I also found your tests and I turned off that blow up stack test and yeah, that's there's still a few other mostly boundary conditions. I don't know if you want to just do a catch at the end or check them ahead of time. That's. That's another thing that to figure out.
00:07:01.555 - 00:07:12.385, Speaker C: But yeah, yeah we'll pick that up as part of the reworking the. Yeah, yeah, we're sort of redesigning it.
00:07:13.005 - 00:08:04.235, Speaker A: Okay. But yeah it's. I've also got a fuzzer that I wrote in my own side repo and nethermind does participate in fuzzing but I guess one of the points you really need to be 100% fuzzing because the initial corpus is the unit tests and you're going to get a lot of fuzzing findings near the initial corpus. I don't see Ref or Geth or Ethereum JS on the call. Is that correct? Geth's got some fuzzing findings that are outstanding too as well as some state test failures. Cool. So spec updates.
00:08:04.235 - 00:08:14.115, Speaker A: Where were we with any spec updates? Are we pretty much closing the door on non emergency spec updates? Is that where we're at? Oh, sorry, you got something?
00:08:14.495 - 00:08:37.265, Speaker C: Yeah, there was some. I don't think I was on the last call but there were that open question on some of the previous opcodes. Has that been covered off previous upgrades? Op codes like ones to allow code length and things like that.
00:08:38.925 - 00:09:43.655, Speaker A: Yeah, I think where the vibe was last week was we're just not going to add them right now because there is an escape hatch you can just call out to regular contract to get the 7721 to the 7, the 721 and the 1155s. You can make a booster contract that will return it. Same with EXT code copy you can make another small booster contract to call it and one of the philosophies there is once we put it in we can never really take it out again. So we're erring on the side of having the option to change it later. And one of the reasons I think we're also erring towards not putting it in as it's leaning into the future of account abstraction where everything's going to be a contract. There are no EOAs so checking code leak doesn't get isn't going to get you any information because everything's a contract which actually helps out 1155 and 721 because they'll try and do the calls they need and the calls will fail. So that will actually help out in that world.
00:09:43.655 - 00:10:22.235, Speaker A: As far as the XD code copy there is was discussion for ext data copy, which is something we will probably revisit once we ship this first version. I think that was mentioned on Twitter, but I and I think we were against changing the. There wasn't enough consensus to change the return codes was another option that was discussed, but it never developed consensus around it. So we're going to stick with what's in there. So that's the say the spec is we thought about it and we don't feel we must change it. So I think that's the mode we're in right now.
00:10:27.895 - 00:10:39.595, Speaker D: Can you go over again how the account abstraction thing helps? 721 and 1155, you said something about you will make a call and it will fail.
00:10:40.305 - 00:11:29.035, Speaker A: Right. So the plan is if account abstraction gets their way, this is one of the not gets their way. This is what the current plan of record. I don't know how soon it's going to be, but when they try to count abstraction, every single other account that is an EOA will get an account that looks like it's that accident behaves with 721, with EOA validation, they'll put a contract in there that'll read the signature, value the signature and approve it and return it and accept transfers. But because it's a contract, if you call it with one of the functions that doesn't understand it will return failure. So that's one of the changes they're looking into for account abstraction. But you know, that we might look into, you know, we have more time to discuss it and talk both sides of it.
00:11:29.035 - 00:12:10.595, Speaker A: I don't know if we're going to do these in Osaka or Amsterdam, but EOF version 1.1 or whatever we call it, we're going to start looking at some of these minor addition changes that don't require breaking. And one of the candidates is definitely is contract slash ext code size ext Data copy is another candidate that we're going to discuss. And I think those are the two biggest things that we pushed for complexity reason because we don't have to break anything now with them. I mean taking them out is where we need to start out with, but putting them back in doesn't break anything per se. So that's how we came to that position.
00:12:13.935 - 00:12:36.925, Speaker D: Okay, so I just want to say like from the perspective of authoring a library, like a solidity library, even though it is technically possible to do the escape hatch, it seems like you would need to hard code an address for the auxiliary contract that does what you want.
00:12:37.585 - 00:12:41.033, Speaker A: And yes, so there's yeah, yeah.
00:12:41.049 - 00:12:50.405, Speaker D: So the address depends on the chain. There is no reliable method for deterministic cross chain addresses.
00:12:51.665 - 00:13:03.125, Speaker A: So it's just like really it's deployed to most L2s. There is a L2 Create 2 deployer that's almost L2s the minimum one. There was an EIP for it. Let me see.
00:13:03.205 - 00:13:03.397, Speaker C: Right.
00:13:03.421 - 00:13:24.119, Speaker D: But it's not, it's not solidity. It's not everywhere that you can do solidity so. Or even, even so it's. It's just like it is technically feasible. Like I don't know if for example Open Zeppelin would. Would be able to use that technique. And so it would.
00:13:24.119 - 00:13:51.605, Speaker D: There would be contracts that are like not EOF compatible. And so like. Yeah, I just. It doesn't seem like a good near term future. And personally the account abstraction argument, I don't find it convincing either because like I don't. I feel like there, there are no concrete plans for that yet and it could change a whole lot. So.
00:13:51.605 - 00:13:56.245, Speaker D: But I don't know, I just wanted to get that opinion on record at least.
00:13:56.865 - 00:13:59.565, Speaker A: Okay. Ben, you have something to add?
00:14:00.345 - 00:14:18.055, Speaker C: Yeah. For like a booster contract you can do the self signed transaction from like an unknown address and then deploy that to get the same contract address from every single L2.
00:14:19.555 - 00:14:30.307, Speaker A: Right. But I think the concern there is can open Zeppelin count on that? Is that a quality gate they want to put on their downstream users? Yeah.
00:14:30.331 - 00:14:52.855, Speaker D: And it would be a new thing because there, there's nothing like that already. So this would be a new decision to be made. And the method that you just mentioned, it's not 100% reliable either because you have gas numbers in their gas prices and. But it is true that there are these factories deployed in many places.
00:14:53.555 - 00:15:19.955, Speaker A: Yeah. Because the factories you can, you can just call. I can't find the default address for some of these, but there are some where you call in it does it via Create2 and those were deployed by it. But because the gas differences it might need to be a pre deployment which is what makes it messy. So I mean this is, this is the feedback we need to make sure that we get this in. If not now, definitely in the next part where we're going to do some EVM updates.
00:16:10.355 - 00:17:04.575, Speaker C: Just on the IS contract. The one of the slight issues with not having an IS contract is a lot of the. Was it EIP618? I don't remember the support thing where you call into another contract. A lot of those have the short circuit where you know, they test con whether the address is a contract before Calling it. So you know, Is this an NFT? Sorry, is this a contract that doesn't support receiving NFTs as like a ERC standard for that and you generally check whether it's the contract that you're calling first before you ask whether it supports the. Make the call.
00:17:05.555 - 00:17:09.855, Speaker A: I know, I know what you're talking about. I can't remember the number offhand. Is it a finalized one?
00:17:11.115 - 00:17:42.885, Speaker C: Well it's in the NFT contracts, but yeah, because I have. Do you support receiving this? So if it's an eoa, you just send them the NFT which is the IS contract chest. And if it's a contract then you query the contract to see whether it supports doing it. But I mean that's more of a GAS thing than anything else.
00:17:44.705 - 00:17:45.645, Speaker D: It's, it's.
00:17:48.755 - 00:17:49.615, Speaker A: Go ahead.
00:17:50.515 - 00:18:06.980, Speaker D: I think it's, it's like it's not really gas. I think it's part of the transfer semantics and I think that's the main motivation here that we have found to having this ability. Right. And it's like it's built into 712.
00:18:07.277 - 00:18:12.925, Speaker A: The main NFT standard.
00:18:13.222 - 00:18:17.383, Speaker D: Green B2P 712.
00:18:17.680 - 00:18:20.355, Speaker A: Oh sorry.
00:18:20.652 - 00:18:30.758, Speaker B: 721. 721. Yeah, they second receiver. 165.
00:18:31.055 - 00:18:39.675, Speaker C: There was a 6 in it.
00:18:39.972 - 00:18:50.078, Speaker A: Just to be clear, 721 does not.
00:18:50.375 - 00:18:58.395, Speaker D: Use 165 for the support NFT support detection.
00:19:00.655 - 00:19:06.885, Speaker A: Right. But lots of people will be using 165 outside and inside. They want to make sure it's.
00:19:12.225 - 00:20:02.859, Speaker D: You don't really need it for this. For this erc. You don't really need that because you're going to get zero bytes return data so it's just going to fail to check anyway and then. Okay, then it becomes a GAS thing for sure. Yes, the optimization but that can be omitted. So maybe like if I was to make this decision, I would like to see like a explanation of how exactly the AEA argument goes. Like because we assume this will happen, then we want this outcome in the immediate next hard fork.
00:20:02.859 - 00:20:20.215, Speaker D: Right too. Like is it that we want contracts to start failing so that the community starts doing something earlier, before the transition to aa? Or is it like what exactly is the argument there? I would like to see that stated if I was to make that decision.
00:20:51.335 - 00:21:11.315, Speaker A: All right. Yeah, I think, I think most of a lot of like the key epsilon people are still out on August vacations. So I'll bring this up in the chat room as well.
00:21:15.785 - 00:21:20.201, Speaker D: Okay, go ahead on the ETH R&D.
00:21:20.273 - 00:22:26.789, Speaker A: Discord yes, it would be an EVM group. Okay, any other spec updates? Is that the hottest one out there? Are there any that aren't as hot that we should discuss? Okay, testing updates. So testing is reaching a very important milestone here. Coming up shortly on ACD, last week EOF got slotted into Devnet 4 by Devnet 4. What we really need is Devnet 3 is 7702 and however many other devnets they need to get it right. And then the next feature that's going to be put into Devnets is going to be EOF, which assuming 7702 nails it on Devnet 3, then Devnet 4 would be when we would be in and that was at least four weeks from last week. So it's at least three weeks from today.
00:22:26.789 - 00:23:03.255, Speaker A: As soon as three weeks it might slip out of 7702 slips out. But we might be looking at needing to be ready to get at least a couple of clients up there within three weeks. So I guess the, the big thing that's coming up was we need to start doing what's necessary to merge the rest of Progn and seeing that we can activate it based on activated straight from Prague.
00:23:10.115 - 00:24:02.641, Speaker E: I think one of the first steps is just to make the test default to proc. Right now the latest release that we have, it contains both EOF on top of Cancun and on top of Prague. But I think we should force that the next releases only ship from brag just to make sure that the rest of the clients are up to date with their branches of EOF on top of brag. So right now the BRAG releases for eof, they are like this extra fork. But I think, I think we should first of all start with the tests now being filled with BRAG only. So no, no more brag. EIP7692 just brag.
00:24:02.641 - 00:24:08.285, Speaker E: And that should activate UI on tests. Yeah, for upcoming releases.
00:24:10.025 - 00:24:15.765, Speaker A: Okay. And that'll start next week's release?
00:24:17.285 - 00:24:54.875, Speaker E: Yeah, I think so. I first Wish to merge 7702 tests, make that stable and then we can start working on top of that working version of 7702 tests. We can just start working on migrating everything you have related into Prague. But I think that's going to be extremely easy because it's just a one line change. What also what this will activate. So right now with 7702 tests we have. I have been very careful to also consider EOF into the test cases.
00:24:54.875 - 00:25:54.205, Speaker E: And the nice thing is that we've basically parameterized all 7702 tests to also fail under EOF smart contracts. What this means is that once EOF the test. Org for prac includes EOF, all of these 7702 tests will automatically update to also fill for EOF. So that's a good thing. But yeah, I think we can do this once 702 mixes into a test execution spec test branch, sorry main and then we can start working on just bringing EOF and making sure that all tests fail correctly. There are no issues and if there are any issues, I will just try to. Yeah, just fix them to get the UF tests ready.
00:25:55.185 - 00:26:18.155, Speaker A: Okay. So yeah, that's probably a big thing that we need to be aware of. It should be. I mean, yeah, I think every client will need to support do some change because we've all got our custom forks for it. Okay. Anything else from the test team that we need to be aware of and ready for?
00:26:20.535 - 00:26:42.515, Speaker E: Maybe just that there was a release last week but it doesn't contain anything major. It just contains both Prague and Cancun fixtures. But there's not nothing of highly relevant from there. Yeah, I think that's, that's, that's about.
00:26:57.225 - 00:27:45.279, Speaker A: Okay, so as I mentioned earlier, we're also doing uf container fuzzing. EVM1 has a fuzzer, BASIC has a buzzer. But I think the one thing that we need to be sure of is we only get the best results if we pass all the ES tests. Because the at least in BASU and I expect in EVM1 the tests become the initial corpus. If you're not familiar how fuzzing works, they take stuff that works and they mess with it until it doesn't and it's going to get really close to the ones. So if we keep messing up broken tests, we're going to get lots of signal from the broken tests. But my results line up so far with EVM1's results.
00:27:45.279 - 00:28:17.195, Speaker A: Besu Geth and EVM1 can run long term fuzzing without any, without any differences or changes in any. But they all pass the same. They all fail the same. For Besu, the fuzzer only generates a valid EOF about 1/3 of 1% of the time. 99.7% of the test cases are invalid. So we're really getting an exercise of all the code validation shortcuts.
00:28:17.195 - 00:29:09.449, Speaker A: But we also need to start up and this is something I'm going to start writing up hopefully this week. EOF execution fuzzing and what's going to be Difficult with the execution fuzzing is invalid. EOF containers provide zero value to the fuzzing because we're actually needing it to validate and then execute it. I'm not expecting we're going to get a lot of hits because there's already legacy fuzzing that goes on very regularly. Martin and Marius keep it running in the background and they always ping people when they mess stuff up in their new releases. But the. Because we're exercising most of the same operations, we get a lot of the same coverage.
00:29:09.449 - 00:29:35.245, Speaker A: But there's operations they don't cover. Anything that's unique to EOF won't get coverage. Stuff like the data operations, swap end dupin exchange. So those we need to get into some execution fuzzing. And I'm going to look into this week to see what it's going to take to build a guided one with besu. I might just fall back and build new generators on Guidos. I'm not sure what I'm really getting into on this.
00:29:35.245 - 00:29:42.525, Speaker A: Anyone else have any experience writing execution fuzzers are working with them? Epsilon.
00:29:46.105 - 00:29:56.725, Speaker B: I have some with Go EVM Lab. I'm also in touch with Guido, but I never actually tried to run this one.
00:30:05.515 - 00:30:45.345, Speaker A: Yeah, I mean, I'd like to get it to where it's guided by at least one or two of the clients. I think we'll get higher signal that way because at the very least when it's guided, if we get a new hit that everyone passes, that tells us that maybe we have a. A new bug we need to work on. So a new test case. Okay, so I think those were the ones on my mind with anything else anyone wants to bring up. Powell, do you still have your mic on?
00:30:47.165 - 00:30:48.225, Speaker B: No, no.
00:30:49.325 - 00:30:56.335, Speaker F: I just want to throw a remind that we can. We have the testing matrix that the clients can confirm or fill out.
00:30:56.875 - 00:30:57.467, Speaker A: It's.
00:30:57.571 - 00:31:05.695, Speaker F: Right now it's pretty bad guesses. So if anything's off there, please.
00:31:08.635 - 00:31:21.465, Speaker A: Would. Would there be any interest in an automated form of this where all the clients have their current test run against it against the current EST tests? Would there be interest in that?
00:31:25.645 - 00:31:26.905, Speaker C: I don't know how.
00:31:30.205 - 00:31:41.825, Speaker F: If that would not be over Q because it's not only east. It's also more manual or informal testing like the EVM1 exported tests.
00:31:42.645 - 00:31:43.465, Speaker A: Yeah.
00:31:44.725 - 00:31:46.065, Speaker F: So one.
00:31:47.845 - 00:32:13.151, Speaker E: Option could be that we run a Hive Hive instance. We have a consumer in Hive. So this is called the Consume engine. Basically just runs the consume engine command that we have in East. It just sends engine API requests to the. To the. To to a running client in Hive.
00:32:13.151 - 00:32:45.115, Speaker E: So we have this, this nice HTML page where it shows all the results. The problem is that we have to first set it up. And the second thing is that it won't test. So I think that. I think a lot of the tests are container verification. So most of them, they are not filling into anything in this consumer engine format. So I think we are missing a lot of coverage even if we run this automatically.
00:32:45.115 - 00:32:52.235, Speaker E: So ideally maybe it's setting up some CI in the clients, I think. But yeah.
00:32:55.375 - 00:32:57.155, Speaker A: Does it run EOF tests?
00:32:57.895 - 00:33:31.981, Speaker E: Yeah. So the consumer engine will not run EF tests because it consumes directly using the client. So it basically spins up a client then with a certain genesis and then it fits ng new payload engine purchase validated and all that stuff. So it only works with the valid execution UF tests, not with the container validation, which is. I think it's a big chunk of the test that we have. So I think, yeah, the leci on the. On the.
00:33:31.981 - 00:33:40.225, Speaker E: On the client side would be better still. We consider we can set up Hive if, If that's. That's. That's a plus, I think.
00:33:41.885 - 00:33:54.849, Speaker A: Yeah, because I mean, we'll get there as part of the release process anyway. Running these tests on Hive. I don't know that we need to push it to the left any. I don't know. We'll see. I've got some scripts. I'll post some of my findings from the scripts.
00:33:54.849 - 00:34:22.414, Speaker A: Having problems getting the numbers to match up different the different clients and test tools. Some of them test all the subtests of them. Know when the outputs are all different, but at least when you get failures, you get a good signal there that something's failing. You might not get the camera. Right. Okay. Anything else?
00:35:18.375 - 00:35:31.575, Speaker F: Donald, you mentioned that you're working on the making proper test cases out of the cases that the father found. Is that correct? I have a PR PR on the side.
00:35:31.615 - 00:35:34.275, Speaker A: Yeah, with. With some of them, but not all of them.
00:35:35.415 - 00:35:37.715, Speaker F: That's the PR to East, I presume?
00:35:38.075 - 00:35:38.855, Speaker A: Yes.
00:35:39.355 - 00:35:45.095, Speaker F: Okay, can you post the link? Because we were also discussing working on this at one point, so let's not duplicate.
00:35:45.715 - 00:35:50.147, Speaker A: I haven't posted a PR yet. I'll get that out here before you start work tomorrow for sure.
00:35:50.331 - 00:35:51.575, Speaker C: Right, cool.
00:35:52.315 - 00:36:11.805, Speaker E: So also, if anyone's missing a review, I think I've left comments on most of the open PRs, but if there's any outstanding PR that doesn't have a review and needs a review for me, please just ping me. I will try to get to it. It's just that I've been very busy with 7,702 tests. But yeah, just please bear with me. Ping me if anything's missing from my side.
00:36:13.145 - 00:36:15.405, Speaker C: Cool, thank you.
00:36:22.185 - 00:36:26.125, Speaker A: All right, if there's no other last words I'll give everyone.
00:36:27.265 - 00:36:28.325, Speaker D: Oh, sorry.
00:36:28.985 - 00:36:29.449, Speaker A: Go ahead.
00:36:29.497 - 00:37:00.513, Speaker D: It's okay. I have another comment on spec updates. So I. What the other issue I had raised over a month ago was the thing about delegate call and how it reverts when delay are calling to non EOF contract. And this may introduce a new kind of risk of breaking some proxies. Anyway, I. I kind of understand the rationale.
00:37:00.513 - 00:37:55.303, Speaker D: I might be on the camp of okay, let's disallow that. But there. So the question that would be like, is there a way to detect that the delegate call I'm about to make will fail or that this address that I have I'm not going to be able to delegate call to. And so we had discussed maybe that it could be possible to use the XCODE hash opcode to detect that by simply seeing that the target that you are the address that you have is an EOF contract. So that was like one of the benefits of re enabling the EXT code path opcode. Now I understand, you know, the. The concerns with that.
00:37:55.303 - 00:38:18.385, Speaker D: So then it would. But I just wanted to raise like the same concern of like if you want to use this sort of escape hatch booster contract that you mentioned, we sort of have the same concern for library authors. So I feel like it's a similar question Right. In the end. What. Yeah, what's the. What was the current vibe about that issue in particular?
00:38:21.925 - 00:38:37.225, Speaker A: Mostly I think we were in a process. We need to gather more information, make sure we fix it right. And information like this would be useful. And then when you say we make proxies, you say EOF proxies or legacy proxies in eof.
00:38:38.325 - 00:38:45.095, Speaker D: This would be only EOF proxies. We've already talked about this, by the way.
00:38:45.675 - 00:38:47.027, Speaker A: I want to document it.
00:38:47.171 - 00:38:57.935, Speaker F: This is their case where someone updates the previous EOF implementation to a legacy implementation of an EOF proxy contract.
00:38:58.595 - 00:38:59.415, Speaker C: Okay.
00:39:04.035 - 00:39:08.335, Speaker D: Yeah, I could write it down and post it somewhere.
00:39:10.165 - 00:39:20.549, Speaker A: That would. That would be good because this specific case would help us make sure we get the thing that issued. Right. Yeah. One question. I have 7,702 delegates. Do we care? Does it matter? Should they.
00:39:20.549 - 00:39:38.965, Speaker A: Should they be transparent? Oh, for EXT code path for proxies. Are we okay if we pro. This is probably a little bit out of EOF scope, but we May as well fix it in EOF if we're going to fix it. Would proxy contracts care if they call into a 7702 proxy?
00:39:42.905 - 00:39:53.885, Speaker D: I don't have a strong opinion, but I don't see any reason why they would behave differently in EOF to Legacy.
00:39:55.905 - 00:39:56.645, Speaker A: Right.
00:39:59.225 - 00:40:08.745, Speaker F: Termina, an implementation of the proxy would be an EOA with a. With a delegation set via 7702.
00:40:09.165 - 00:40:09.905, Speaker A: Right.
00:40:11.085 - 00:40:11.825, Speaker C: Or.
00:40:14.405 - 00:40:21.625, Speaker A: Is that useful? Do we need that? Do we not need that? Do we just go ahead and go with what they intend, which is it looks like a contract now for all purposes?
00:40:23.685 - 00:40:24.997, Speaker D: Yeah, it sounds okay to me.
00:40:25.061 - 00:40:25.381, Speaker A: Weird.
00:40:25.413 - 00:40:39.019, Speaker F: But it sounds like it would be very weird because that would allow the implementation to vanish or just change arbitrarily after the EOA signs another set called the transaction. So it doesn't sound.
00:40:39.067 - 00:40:49.055, Speaker A: But that's not an E concern. That would be something we need to bring up in the AA chat room and, you know, proceed at your own risk. Dan.
00:40:51.875 - 00:41:14.739, Speaker C: I'm just thinking, is there a situation where you could be proxying the other way? So the EOA was an EOF and you were going trying to proxy through a legacy contract. So the 7702 wouldn't work, if that makes sense in all searches.
00:41:14.787 - 00:41:15.375, Speaker A: Right.
00:41:17.795 - 00:41:27.345, Speaker C: Whereas I assume you'd want to encourage people to use EOF contracts for 7780.
00:41:28.325 - 00:41:38.465, Speaker A: Okay. I mean there was talk of requiring EOF or 702 as well. That's one thing that was seriously discussed at one point and I'm not sure is entirely dead.
00:41:39.485 - 00:41:48.385, Speaker C: But then would that be a problem if your EOA tried to delegate call into another contract? If that makes sense. That's Legacy.
00:41:48.925 - 00:42:17.765, Speaker A: Right. And that was debated whether it was a feature or a bug. And I think bug the bug camp went out, so that's why it's not in the spec. Okay. But as far as getting rid of the delegate call, I'm remembering something with a 76780 rules. This self destruct still operates if it's created in the same transaction. So even though self destruct is nerfed, it still has visibility in eof.
00:42:17.765 - 00:42:24.105, Speaker A: It's just not as common a case. So I think that's why the delegate call ban is still in place.
00:42:28.165 - 00:42:34.653, Speaker D: Yeah, I think that was one of the main, if not the most, the strongest reason. Yeah, yeah.
00:42:34.669 - 00:42:42.785, Speaker A: That's the reason it got put in the first place. And 6780 didn't change it enough that we can get rid of the delegate call. Okay.
00:42:43.165 - 00:42:59.855, Speaker D: So I can write this down, share it somewhere to get the most visibility puzzle. Because I have written about this before in the magicians forum, but I feel like that's not maybe where the most eyes are. So you can just tell me where I should share for the most visibility.
00:43:00.635 - 00:43:04.935, Speaker A: It would be in the Discord Eth R&D EVM channel.
00:43:06.835 - 00:43:07.615, Speaker D: Okay.
00:43:08.675 - 00:43:14.925, Speaker A: And that entirely opaque sequence of discord numbers is where it's at that I just posted in the chat.
00:43:16.905 - 00:43:17.645, Speaker D: Thanks.
00:43:18.345 - 00:43:45.583, Speaker A: Okay, any other issues people want to discuss before we end the call? Okay, next call is in 2 weeks, same time ACDS next week. Appreciate everyone's work putting into this. Let's try and get those tests up to 100% so we can get get a good couple weeks of fuzz again before we shift over to the Devnets. All right, talk to everyone in a week or two. Bye.
00:43:45.679 - 00:43:46.359, Speaker F: Thank you very much.
00:43:46.407 - 00:43:46.535, Speaker A: Bye.
