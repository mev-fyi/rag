00:00:00.640 - 00:00:39.224, Speaker A: Welcome to EOF implementers, call number 48. Got a short official agenda, but we also got some request items from Mario on the testing side. So we'll start with client updates, compiler updates, we got four spec updates to go through and then testing updates and other updates. If you have anything you want added to the agenda, please add to the chat and we will work through it at the end on a time available basis. So I guess the first question is client updates. Let's go ahead and start with Peter from EVM one. Do you have any updates from EVM one?
00:00:41.204 - 00:01:09.284, Speaker B: Nothing substantial. We are still doing some final polishes on the creation transaction pr for EVM one, and also we've got a tentative implementation of the return data copy modification. And also we've got the change to the validation to include in it, called validation. In progress or in review? Not sure. Andre, do you have anything to add?
00:01:10.504 - 00:01:13.564, Speaker C: Not really. That summary.
00:01:15.264 - 00:01:15.664, Speaker D: Yep.
00:01:15.704 - 00:01:20.884, Speaker A: So that's it. Okay, I'm add. Never mind.
00:01:22.164 - 00:02:15.304, Speaker E: So we don't really have any update on this front, but I think that you can start hearing that we have fully implemented all of the eips. Once we finalize the spec, I think this is what is going to be like. Okay. But now it's the time to finalize the implementation because the spec is finalized and we, we will start working on finalizing the implementation because we have an implementation now. We're just not sure how much it differs from the current spec and we are not sure how to get the current spec. So once we have the final spec, we can just press the button. Now it's time to look into spec and make sure that it is implemented correctly in our side.
00:02:16.144 - 00:02:46.494, Speaker A: Yeah. So I think this is probably something we mentioned in every, every meeting. There's, there's two main specs floating around this epsilon. EOF is what's called the omnibus spec and 7692 is the EIP spec. So those are the two main specs to work off of. The omnibus has everything in there. You can just read right through it and find all the rules.
00:02:46.494 - 00:03:09.198, Speaker A: The 7692 works from the various eips, piece them together as a mega spec, and you have to know which EIP look for which specific rules. There's some weirdness with it, but they're all there and they're all referenced, right? Oh yeah. Specs are in the resource section. Oh yeah, that's the obvious part. Yeah. So here's all the specs. Okay.
00:03:09.246 - 00:04:07.950, Speaker E: Yes. So I understand that the specs are there and you can reference them, but they're not finalized yet. That's the main thing. So we want to have that final, final thing where we can say, okay, now we need to start comparing and resolving any discrepancies in the implementation. But yeah, where to find the spec maybe is obvious, but if the specs finalized is the question because this is what I keep getting when I trying to push Nethermind to say as a team to say, and ACD calls like we want EOF in Prague or any fork that is upcoming before Verkle they say, but is the spec finalized? But the spec is not finalized. This is always the pushback that me and Ayman are receiving and we obviously want uf. We understand the benefits, but this is the pushback.
00:04:07.950 - 00:04:12.274, Speaker E: So once we have that pushback resolved, this is where we can move forward.
00:04:12.774 - 00:04:41.824, Speaker A: Okay, so I would say that the broad strokes of the spec are finalized. What's being covered is finalized. What we're negotiating over is it'll find things like whether return copy data is zero padded, whether we're going to have return stop in the final init code. Really fine grained things are there. But the broad huge strokes and the spec list that we're negotiating over keeps getting shorter and shorter and they're really the in the weed stuff.
00:04:42.364 - 00:04:43.284, Speaker E: Perfect, perfect.
00:04:43.324 - 00:04:43.904, Speaker A: Great.
00:04:44.244 - 00:04:47.876, Speaker E: So I can report on that. So that's a good thing, right?
00:04:47.940 - 00:05:01.258, Speaker A: So the things that are changing are the things you find in testing. Like all the other specs that were final. There were always corner cases discovered in testing that they went over up until basically they forked the testnet. And that's the stage we're in right now.
00:05:01.426 - 00:05:04.554, Speaker E: Right, right. Got you. Okay, thank you. That's great.
00:05:04.634 - 00:05:14.574, Speaker A: Okay, so that's nether mind. Do we have one from geth on the call? I don't see anyone, but we have some from Ref Dragon.
00:05:15.074 - 00:05:57.534, Speaker F: Yeah, finally here. Sorry for the long pause. Yeah, basically coming back to EF after like month or so I removed J's create opcode and just implementing new creation from the creator section. I'm at that point right now. And from foundry side we tried to build like to use testing around it, but I think the create that creation of the contract is blocking one. So I'm focusing on that to unblock foundry to be used inside UF, basically.
00:05:58.954 - 00:06:04.294, Speaker A: Cool. When it comes to getting compilers working with EOF, that's going to be very helpful.
00:06:04.754 - 00:06:08.170, Speaker F: Yeah, yeah. It's my top priority to be honest. Yeah.
00:06:08.362 - 00:06:15.014, Speaker A: Cool. Baixu, do Gary and Justin have anything they want to say or do you want to let me lead with it?
00:06:15.664 - 00:06:16.604, Speaker D: Go for it.
00:06:17.344 - 00:07:13.022, Speaker A: Okay, Baesu is right now we're writing contributing tests to the east specification using BesU as the reference, and we're getting those. We got some nice prs queued up for Mario and them all to review. We did find one interesting corner case. We had coded it wrong from the spec, but we might want to keep the way that we initial coded it. And that was when you're doing an ext delegate call to a legacy contract that's specified, but it's implied when you do it to an eoa or an empty account that it should work, but it feels like it should fail. Because then can we distinguish between empty account eoas and legacy accounts? So that's a pillar of discussion on discord to possibly change it. That ext delegate only works to other EOF accounts rather than exe delegate fails on legacy.
00:07:13.022 - 00:07:30.034, Speaker A: So that's one. One corner case where we're discussing in discord, not on this week's list. We'll see if we get it on next week's list, if there's any. If that actually gets. Proposes a change. Don't have Ethereum J's. I think that's it for all the clients.
00:07:30.034 - 00:07:46.014, Speaker A: Any other clients. I forgot. Okay. For compiler updates, Charles already said in chat there's no viper updates. Is there anyone from solidity that wants to speak to their implementation?
00:07:51.354 - 00:07:55.370, Speaker B: We have Camille from solidity, and Radek also was working, right, so maybe.
00:07:55.442 - 00:07:56.094, Speaker G: Yeah.
00:07:56.434 - 00:08:18.854, Speaker E: So basically, I'm working on making all the tests pass, and it's going well. I think it should be ready in a week or two. Now, I'm fixing some minor things related to non returning functions. Yeah, it's going well.
00:08:21.274 - 00:08:34.870, Speaker A: Okay, so with that, I think we can go to spec updates. So we got four of them in three main groups.
00:08:35.022 - 00:08:43.714, Speaker B: May I have a suggestion to start from the ext call? The last one, the return codes where we have. Sorry.
00:08:44.574 - 00:08:59.374, Speaker A: On the call, 117, there's no text associated with it. Okay, so go ahead. Let's go ahead and talk about number 117. Extend exe return codes, detect account without code.
00:08:59.994 - 00:09:25.474, Speaker B: Right. Who's better reversed to give an intro to this? No, we don't have Pablo. I wasn't prepared to give an intro here, but the issue is with. Is a suggestion from. From the solidity team to. Sorry.
00:09:28.534 - 00:09:37.878, Speaker A: Was this the case where when you were calling a contract, solidity wants to make sure that it has a contract, and it's not that it's an empty account or an EOA? Yes.
00:09:37.926 - 00:10:19.224, Speaker B: So previously this was accomplished by a next code size call. And right now there's no way to distinguish between a call to a contract which succeeded but didn't return any return data, and a call to an EOA or an empty account, I guess. And correct me if I'm wrong, but the solidity team proposed to make a new return code for such a case. But then I think there's arguments against this which have been also mentioned in the previous call.
00:10:23.214 - 00:10:23.502, Speaker A: So.
00:10:23.518 - 00:11:10.514, Speaker H: Yeah, so maybe I'll argue for his length from the solid side, because for us, like, to be honest, this is not like something essential to the working, of course, because basically like a sanity check that you have, like if the contract doesn't have any code, it doesn't make sense to call it like, good, like from the programmers, perfect. You just think you're just calling some function and like, it's not fading. It's kind of often unexpected and undesired. People are often surprised by it, which is basically why the compiler just inserts an extra check for it. And it was possible to check it in before Eof. Now it won't be possible anyway. It won't really break anything.
00:11:10.514 - 00:11:49.132, Speaker H: But it's like now inconsistent between like non Uf and Uf compiled contracts. And like I don't see like strong reasons like not to provide sanity check. I mean, wouldn't be at the end of the end of the world, but like just having like extra return code from create. Sorry, from, from call would like both be kind of cheaper than what we have already. So like a separate check with an if and xcode sites. And it doesn't seem like complicates things much. So we would argue for keeping it mostly because it doesn't seem like harmful to have.
00:11:49.132 - 00:11:54.584, Speaker H: It seems like I'm upside to still keep it, but that was good from our side.
00:11:55.484 - 00:12:03.384, Speaker A: So you want ext code size returned again, you want something like ext code size returned.
00:12:04.824 - 00:12:35.364, Speaker H: I mean, we don't really care about the size, we just care about whether the code was there or not. I mean, there's an argument like for example, someone could deploy like a contract containing just a stop or something like that. That wouldn't be functional and it would be also not working and. Yeah, but like the biggest use case of it was basically preventing like stupid mistakes, like of the same kind, like someone like typing just the wrong address, someone like using address of the contract that doesn't exist or like that was supposed to be deployed but failed to deploy or something.
00:12:36.864 - 00:12:48.124, Speaker A: Okay, so you don't care if it's an EOA, you care that it's contract is really what you're caring about. EoA or empty really doesn't matter from your perspective.
00:12:50.024 - 00:13:09.546, Speaker H: Yeah, exactly. I mean, we don't even, like, specific about EOA, but more like whether there was, like something to execute or not. Because with this account extraction proposal, basically you could have a transaction. Transaction substitute some code. And from our perspective, we'll be just fine to do. Okay. We called something there.
00:13:09.546 - 00:13:14.494, Speaker H: It succeeded. We don't carry permanent contract which carry whether something could be called there.
00:13:29.934 - 00:13:30.874, Speaker A: Okay.
00:13:38.574 - 00:14:05.794, Speaker B: I mean, recently, I think the arguments against this were account obstruction in some way it's gonna, I think makes this obsolete in a way. But I don't recall the exact argument. And the other one was that we're actually removing the ability to distinguish between, like in the topic that was mentioned just before about this ex delegate call.
00:14:08.654 - 00:14:24.404, Speaker H: But isn't it possible to distinguish just going to, like, legacy contracts, like non uf one and then checking it and then returning something cool. So it's like, it's like possible just like more expensive.
00:14:26.224 - 00:14:29.644, Speaker A: And you want to check before the call, not after the call. Right.
00:14:31.144 - 00:14:33.204, Speaker B: I think after all works, right?
00:14:33.584 - 00:14:40.124, Speaker H: Not really. Like, for us, like, checking after the call is even better because we don't have to check explicitly. So it's cheaper for us.
00:14:44.564 - 00:14:56.064, Speaker A: Because one thing we discussed briefly in Africa was changing the return codes to have different return codes for calling a contract and calling non contract.
00:14:59.244 - 00:15:16.990, Speaker G: Yeah. I mean, it doesn't. You don't really need to do it. It's actually better to do it after, because if you get return data, then you don't need to do the check. But I mean, I think we've, like, kind of already gone over all of this. Like, I think I already presented the, you know, from Viper's perspective, it's very similar. Right.
00:15:16.990 - 00:15:54.894, Speaker G: We do it as a sanity check, but it's like, not actually that important. And if we want to ban code introspection, then we should, like, do it properly and ban it. I think Pavel's suggestion, which is just to ban calls, you know, a call to anything that starts with EF, sorry, that doesn't start with the EOF prefix, should just fail. And you don't care if it's a legacy contract or an EOA. I think that just solves all the problems. And I think that we should, like, write down all the discussion points so that we have them, like, recorded and we don't have to, like, rehash everything.
00:16:07.454 - 00:16:23.634, Speaker A: Okay. So the two first big arguments was this is code introspection and we're banning it, so it'll be gone. Another one is account abstraction. We'll be moving Eoa to have code so you won't be able to detect it anyway. What, was there a third one I was missing?
00:16:31.354 - 00:16:51.774, Speaker G: I'm not sure. It's kind of part of the first one. But it's like you shouldn't be able to call to legacy anything, anything that doesn't start with the u of prefix. Right. Yeah, it's just like more consistent. If you can't call eoas because eoas don't start with the ef zero zero prefix.
00:16:53.474 - 00:17:01.134, Speaker B: I mean, you should be able to call legacy. Right. Except xdelegate call. I want to bounce our calls.
00:17:04.274 - 00:17:07.854, Speaker C: There should be a way to transfer still without execution.
00:17:08.314 - 00:17:09.054, Speaker A: Right.
00:17:09.594 - 00:17:09.930, Speaker G: Right.
00:17:09.962 - 00:17:17.854, Speaker A: Because if we ban those calls, we can't transfer to legacy accounts. We can't transfer eoas at all. And that sounds like a problem. If you can't send ether to non eoas.
00:17:22.524 - 00:17:33.144, Speaker G: That is a problem. And we should have a payout code. And there is a way which is that you do the create a contract and then self destruct.
00:17:44.744 - 00:18:00.964, Speaker A: So if we didn't have. If things stay they were today, would this be problematic for solidity? Would we just be losing a safety check? Or is it something that solidity would really want us to require to find a solution to?
00:18:03.904 - 00:18:07.368, Speaker H: You mean just not providing anything or.
00:18:07.536 - 00:18:10.864, Speaker A: Right, just not providing anything. Let them make the mistake.
00:18:13.564 - 00:18:22.664, Speaker H: I mean, we could technically live with that, but just like we prefer not to have to. I mean, this kind of breaks user expectations.
00:18:23.444 - 00:18:43.204, Speaker A: Right. The self destruct hack. Don't forget we may have self destruct in EOA, so there is no roundabout self destruct method.
00:18:46.224 - 00:18:53.764, Speaker G: You can still use like sentinel things. But. Yeah, maybe that's like. Maybe we shouldn't be in soft.
00:18:58.024 - 00:19:15.394, Speaker A: Yeah, I mean, that's a tangent. The big problem with self destruct we got rid of and that it clears up memory, but the movement at the time when it was first banned was we just want to ban it across all the EVM and it's possibly going to be banned in legacy. This is before we nerfed it back in the last hard fork.
00:19:21.734 - 00:19:30.158, Speaker E: Just one thing. Pay opcode has been pushed back upon by a lot of client teams. Not sure it's really a good alternative.
00:19:30.286 - 00:19:36.154, Speaker G: Which has been pushed back by guess when.
00:19:38.814 - 00:19:40.234, Speaker A: Just this last cycle.
00:19:40.694 - 00:19:46.434, Speaker G: I think they pushed back on the testing requirements, but they didn't push back on the concept of it.
00:19:46.774 - 00:19:53.594, Speaker A: Well, they were doing testing stuff and they found corner cases and I think that's why they said it wasn't ready to be pushed in a Pektra.
00:19:54.234 - 00:20:02.294, Speaker G: I don't think that's actually what Marius said. I think Marius said that he found that there were a lot of edge cases, but he didn't comment whether, you know.
00:20:02.714 - 00:20:05.654, Speaker A: Right, we need to cover the edge cases before it becomes acceptable.
00:20:07.594 - 00:20:32.374, Speaker G: Yeah. And he didn't even say what the edge cases were. I think, to my recollection, the only client team that actually pushed back was like, Aragon, and their argument was that it's confusing to be able to send Ethereum to a contract without transferring execution context, but you can do that with self destruct. So it's like, I don't think it's actually ever been properly discussed.
00:20:40.834 - 00:21:01.544, Speaker E: So what I'm worried about once we finalize the spec for EOF is for client teams that are not joining these meetings to suddenly realize that this is spec'd out and ready to be implemented and included in the next fork. And now they need to look at the spec and they will have a lot of objections to whatever we have put there.
00:21:02.924 - 00:21:09.268, Speaker A: And that's the frustrating part, because we throw these meetings, we invite them to come and they don't come, and they come at the last moment and say we have to change everything.
00:21:09.436 - 00:21:10.984, Speaker E: Yep, I agree.
00:21:17.184 - 00:21:48.544, Speaker A: So unless there's a technical error with it or some sort of a security issue, I would say if they're not here to discuss it, then they've lost their opportunity, because we've made very. You've made a lot of accommodations to try and get them here. So collectively, what do we think? What do we want to do? There are several options. Which one do we want to work with or move forward? Alex?
00:21:52.844 - 00:22:33.432, Speaker I: Yeah, I think we don't have actually enough data to know how frequently eat is being sent to users from. From contracts. A lot of the. At some point, a lot of defi stuff was more working with wrapped eat, and then now a lot of it is working with the, you know, the staked eat versions. But at some point, then some DeFi started to move back to support eat natively. So it's. I don't think there's good data to know, but what I'm trying to get to is just a sentence here.
00:22:33.432 - 00:22:52.774, Speaker I: You know, if you just ban calling, like, eoas, then you cannot send it to them. I don't think that's actually fully true, because we could still have, like, a dedicated legacy contract, a pass through contract to accomplish that.
00:22:57.434 - 00:23:04.674, Speaker A: Yeah. You call someone else's contract, and if you're comfortable with the contract. Then we'll send forward all the eth. And you can still get it out of the system.
00:23:06.374 - 00:23:35.476, Speaker I: Yeah. I think the only downside of that is really if the recipient depends on the sender address. Then none of this works. So maybe it's not a good idea. But generally I'm kind of worried about this alternative where you basically you have to check for the highest bit set. To see if it's a failure or not.
00:23:35.620 - 00:23:35.924, Speaker D: Right.
00:23:35.964 - 00:23:37.304, Speaker I: That's the new proposal.
00:23:39.644 - 00:23:43.424, Speaker A: Well, the high. The number eight bit. Yeah.
00:23:44.604 - 00:24:08.998, Speaker I: Which is quite a few instructions. I mean, it can be a comparison. It can be shifting, et cetera. But, you know, it's more than what we have right now. I mean, you know, right now it is. It's double negation. But with the before uf.
00:24:08.998 - 00:24:21.214, Speaker I: But with the UF, we. It's basically just an e zero would be the check. And now with this, we do need. Yeah, we do need comparison or shifting.
00:24:25.714 - 00:25:13.762, Speaker A: So it'd be a net add of two opcodes, really, per call. So if it's less than. And then, you know, it actually could. I mean, if we do it in order, we could do it in our jump key. So if it was, we could do ext call our jump vlog. And then code. Code.
00:25:13.762 - 00:25:15.614, Speaker A: Error. Error.
00:25:17.754 - 00:25:26.774, Speaker I: I mean, you don't need. In the current design, you don't need the e zero. It's just x colon, r. Jump I for the error.
00:25:27.314 - 00:25:43.086, Speaker A: Oh, yeah. You don't even need the zero. So writing four bytes. So what would be a success from code or what we have to check out?
00:25:43.150 - 00:25:49.674, Speaker G: Yeah, that's like just two extra bytes, right? Or two extra instructions.
00:25:50.774 - 00:25:56.474, Speaker A: Well, two instructions about three bytes. The push, the immediate and the gtE.
00:25:59.414 - 00:26:09.620, Speaker I: We don't have GTE. So it's GD. So 127. No, we just have greater than.
00:26:09.812 - 00:26:10.228, Speaker G: Yeah.
00:26:10.276 - 00:26:25.184, Speaker A: Okay. Oh, it's signed greater. That's what I'm thinking of. Yeah. Slt. So.
00:26:34.714 - 00:26:56.862, Speaker I: I mean, true to be said, even with these two opcodes. Extra opcodes. It's still much less compared to what the compilers do right now. Checking for xcode size, etcetera. But it definitely increases the complexity of the call compared to what we proposed so far.
00:26:56.918 - 00:27:15.794, Speaker G: With EOf, it's also like. I mean, like, I think I'm fairly neutral whether code introspection is a goal of EOF. But if banning code introspection is a goal, then, like, this doesn't do it. Because, like, you might as well provide an is EOA opcode, right?
00:27:16.374 - 00:27:50.050, Speaker A: So the introspection, I think what they really don't want us to do what the request is. We don't mess with the code and rewrite it and create a jit on the fly. I don't think that asking do you have a contract? Is that big of a concession. So we could ext. Code size would be sufficient just restoring that, because we don't want to do the hash because the hash is even. Size is a moving target. Yeah, but the code hash gives too much information.
00:27:50.050 - 00:27:58.490, Speaker A: The size might leak information that it's EOF versus a non EOF, which is probably fine. We're going to need to figure that out anyway.
00:27:58.602 - 00:28:13.814, Speaker G: Yeah, and like, everything I've heard from the account abstraction people is like, there shouldn't be any way of distinguishing eos. But that's, yeah, that's just what I understand from other people.
00:28:14.234 - 00:28:33.814, Speaker A: But that also allows us to distinguish from an empty account and a non empty account, which might be valuable too. You don't want to call into an empty account. You might want to send eth to an empty account, but you wouldn't want to call the code in an empty account. If you know it's empty, then that would be valuable.
00:28:34.874 - 00:28:57.154, Speaker I: Here's a completely alternative solution. Having a flag on the input side of the call, seeing whether it accepts success. If there was no execution taking place. So then if it reaches an eoa, then it would just signal an error.
00:29:16.634 - 00:29:32.954, Speaker E: My perspective is that calling an empty account is not that big of a deal. Let it call the empty account. And yeah, that's better than being able to, to distinguish between eoas and not the oas.
00:29:34.734 - 00:29:35.094, Speaker D: Yeah.
00:29:35.134 - 00:29:54.354, Speaker E: And in my opinion, also, it should be, it should, it should depends on the, on the implementation of the contract, which is called, and if it doesn't return any data, then you cannot distinguish it was a contract or not. And so it's a matter of the implementation of the contract interface.
00:29:57.874 - 00:30:22.174, Speaker I: But this request mostly is coming from solidity, because it does take the distinction into account right now. And without this, without any support for this, solidity will have to change how they operate with UAS. And maybe that's a good thing, or maybe that's a bad thing, but yeah, I mean, Camille, what's.
00:30:23.154 - 00:30:26.554, Speaker B: This is a soft request, as I understood. Camille.
00:30:26.714 - 00:30:27.894, Speaker E: Yeah, exactly.
00:30:28.274 - 00:31:00.074, Speaker H: I mean, actually, we kind of bothered a lot by the fact that it would be different between, like, uf and non uf, and we kind of even considered, like, whether we might just drop for non uf, but kind of that's a breaking change. And really, like, in the end. Conclusion, we do see some value in this check because like usually it is unintended. So that's what we argue for. But I mean, we could live without it, like I said. But I still don't see, I mean, the create the call proposal from Alex also sounds perfectly fine. So I argue for it.
00:31:02.094 - 00:31:44.594, Speaker A: Okay, should we time box this and think about it for a week based on these notes and come back next week because we still got other issues on the agenda to discuss hearing? No objection. We will time box this and return to it next week and see what our opinions are going back to the top of the spec updates list. The first one is return data load and return data copy whether or not we zeropad or we enforce on boundary errors. What was the current thinking on this? Where are we at on it?
00:31:48.294 - 00:31:55.022, Speaker B: I think mostly in favor, so we can call the final call for objections.
00:31:55.078 - 00:32:50.126, Speaker A: And then we so to summarize, we change return data copy only in EOF to not have boundary failures, and we change return data load, which is an EOF only instruction to not have boundary errors. Right. All right, so if there's no objections, I guess we can merge it. All right, next one is Eof. There's a couple related to the question of how we handle init mode and runtime mode, which is a fairly recent additional, and how we handle things like return stop and whether we do the create contract in runtime mode. Who was advocating for this change?
00:32:50.310 - 00:33:06.604, Speaker B: Well, I tossed it, but I think it hadn't been really, not many folks were in favor or of either change. And Andre also brought up some.
00:33:09.144 - 00:33:09.432, Speaker A: I.
00:33:09.448 - 00:33:23.064, Speaker B: Think, like consistency issues with it. So unless anyone is really excited about these alternatives, and I would just drop them and keep things as they are and just leave with the validate EOF.
00:33:23.144 - 00:33:23.764, Speaker H: Which.
00:33:25.624 - 00:33:29.964, Speaker B: Needs to accept an extra argument, which is the runtime orient code mode.
00:33:32.044 - 00:34:10.064, Speaker A: Okay. From base's experience on that, you can run it where it's unknown, but also we're always going to know what state it's in. It's going to come in in a niccode mode if it's coming from a create transaction, and if it's in the state tree, it's going to be in runtime mode. But we're not supposed to validate it in runtime mode because it's supposed to have been cleared through a nit code mode. So I guess the testing implication is, is everything in testing init code mode or is it unknown mode, or do we add a flag on it to say it's runtime or knit?
00:34:12.804 - 00:34:18.756, Speaker B: I guess we're inclined to do the last, the latter to add the flag. Right, Andre?
00:34:18.940 - 00:34:20.476, Speaker A: Add the flag. Okay.
00:34:20.620 - 00:35:06.183, Speaker C: Yeah, we discussed that in the flag last time. Having second thoughts now? Maybe at least in unit test, in medium one, we don't have many tests for init code mode, so like mostly tests, check the runtime mode containers and maybe we could have that as default or even like explicit only option. And then if you want to test init code mode, you would need to wrap it into uf create. So I'm still thinking, yeah, what would be better? Yeah, these are two options, like either explicit flag or requiring everything to start with runtime.
00:35:06.223 - 00:35:13.903, Speaker A: Maybe if we were going to require one mode, I would require an encode mode because that's what, that's how we're going to run into it.
00:35:14.023 - 00:35:29.544, Speaker C: Yeah, that's the problem is that every test case must end with return contract to be valid. And even if we test some relative jumps, for example, and some other validation, it will always require this return contract, which is kind of annoying.
00:35:30.044 - 00:35:34.024, Speaker A: So it would be runtime mode, unless there's a flag that says init code mode.
00:35:34.524 - 00:35:42.424, Speaker C: Either that or it's just always runtime mode. And if you want to test init code mode, then just replication. Ufcreate.
00:35:45.054 - 00:35:47.834, Speaker A: Okay, what does Mario think about this?
00:35:48.534 - 00:35:53.634, Speaker D: I didn't get the last part. So a flag or what was the other option?
00:35:54.294 - 00:36:26.104, Speaker A: So one is to always have all our validation and runtime mode. And if you need to test it in code mode, you wrap it in an EOF create. That is a bit different from, you're always going to start in a nIc code mode in code, but it's just a flag and you swap into it pretty easily. The alternative was to add a flag and everything's presumed to be runtime mode unless we see the init code mode flag, and then we flip our validators over to init code mode. So some tests would have a flag, some tests wouldn't.
00:36:26.884 - 00:36:51.024, Speaker D: So I think the advantage of the flag is that we can also do other things when we transform the test into a state test. For example, if the flag is there and it says that it is init code, then we can simply switch the status to be a transaction creation contract. That would be much easier if we have the flag, in my opinion.
00:36:52.044 - 00:37:00.624, Speaker A: Okay, so let's do the flag presumed runtime mode, and if there's a flag, we're actually in a niccode mode. Okay.
00:37:03.944 - 00:37:06.284, Speaker B: All right, good.
00:37:06.584 - 00:37:15.564, Speaker A: And that takes us to testing, I think. Yeah. And Mario's got some things he wants to talk about.
00:37:17.424 - 00:37:57.684, Speaker D: Yeah. So, well, first of all, status I've been reviewing a lot of the prs and merged some of them. I've also made some comments on some of them and they're basically just minor things. But overall I think that the testing code is very good. And yeah, they're just there still a lot of them to review. I will get to them later this week. I don't know if you guys have any comments on the reviews or comments on how we are merging the code or anything related to the PRS, but yeah.
00:37:58.544 - 00:38:28.984, Speaker A: So I would like to know if we could keep some of these requests that are being made during the reviews if we could get like a coding standards best practices document. So we can say, well, read the best practices document. Follow this and your code review will be shorter if you follow all of these things like don't use hard coded addresses, don't use hard coded slots. Name things for readability. I think those are the big three things that I've hit so far.
00:38:29.484 - 00:39:23.974, Speaker D: Yeah, sorry about that last review. So the things that we are working on like a refactor, because we had this idea of we want to be able to run the tests in a live.net. so the only change is going to be that we are not going to use hard coded addresses. Also, there was an issue with rollups because we were using zero x 100 for every single smart contract that we wanted to use for testing. Now it's become a problem because the roll ups use this address for their precompiles. These are another reasons we are going to refactor many, if not all of the tests to do some like pre allocation dynamic addresses. So at the end of the day, I'm going to refactor them manually.
00:39:23.974 - 00:39:49.660, Speaker D: The EF tests, I mean, I'm just checking that there is no like breaking pattern in any of the, of the reviews. I think after we're done with this refactor, I can write the document, definitely, but it's not set in stone. We don't have a document that says this is the way that you have to write tests, but we will work on it. Definitely.
00:39:49.732 - 00:40:00.224, Speaker A: Okay. Yeah, I think that'll be helpful, especially when we get to the world where Eels is the reference implementation and you need to have ease tests before it can become CFI.
00:40:01.444 - 00:40:03.224, Speaker D: Absolutely. Yeah. Agree.
00:40:06.264 - 00:40:07.084, Speaker A: All right.
00:40:08.664 - 00:40:10.844, Speaker D: Yeah, thanks for that.
00:40:11.824 - 00:40:13.648, Speaker A: Did you want to talk about the versioning?
00:40:13.776 - 00:40:58.784, Speaker D: Yeah, definitely. So we had this idea just an hour ago. So it's very green. I would say it's not final. So wanted to suggest that since we have at least two features that are being currently being worked on, which is EOF and Berkel, which have not been included in a Devnet. We wanted to make a special tagging format, for example, for EOF, it would be like we will have EOF at and a version, version string. What this would do would be to be able to do prerelease formats where we can package all the EOF tests automatically for you.
00:40:58.784 - 00:41:59.954, Speaker D: We have prereleases in main which will be accompanied by the latest UF tests. And we can do this very easily, very fast. So every time that you guys want to release something, we can just simply tag it with this EOF prefix and we'd automatically fill the tests and package them for us to distribute. That's one thing. The other thing is that it would be maybe easier if we create a separate changelog for EF, because we are going to keep a separate version number for EF and a different version number for something that is actually in main and it's actually being released for a Devnet. Once UF makes this into makes it into a devnet, we can then simply just reference the UF Changelog and we can join EOF tests into the main release. But until then, I think it's important for us to just keep a separate changelog.
00:41:59.954 - 00:42:18.894, Speaker D: It's not completely necessary, but I think it would make it very easy for us to make a UF release and just point out the difference between the previous tests and the current tests that are being released. And for the last point point.
00:42:20.954 - 00:42:21.242, Speaker G: I.
00:42:21.258 - 00:42:34.494, Speaker D: Was working on filling the fixtures for UF and I found out that there's a conflict between the current fork definition that we have, which is that we require, for example the request hash.
00:42:36.754 - 00:42:37.066, Speaker A: For.
00:42:37.090 - 00:43:32.794, Speaker D: The header to be filled correctly. And this was not the case with EVM one, because even one doesn't implement EIP 6110. So what we were thinking to do is just create a new fork for the EVM one tool. When we pass the fork to the EVM one tool, it will receive breck. But in our internal testing and the tests that we write, it will be called UF. So basically just it will be seamless for the EVM one tool, but for us it will just serve the purpose of making the clear distinction between what is implemented in the EOF tests and versus what is not, in this case EIP 6110 and EIP 7002. I think it will make things easier for us when writing tests, and it's a fairly simple change to make in our framework.
00:43:32.794 - 00:43:53.304, Speaker D: This is just a suggestion. I don't know. I want to hear feedback and comments. What do you guys think about this? Do you guys like that we have one version for main and one version for specifically for EF? Or is that not a good approach for you?
00:44:01.404 - 00:44:29.958, Speaker A: I have ideas, but I want to hear some of the other client teams opinions first. Is there going to be any issues with that for ref or for EVM one or nethermind? Okay, so I like the. Go ahead, Ahmed, go ahead. Oh, I.
00:44:30.086 - 00:44:34.774, Speaker E: Sorry, I wasn't following. Very sorry. What was the question?
00:44:36.514 - 00:44:44.254, Speaker A: How do we feel about having different tests maintained for EOF versus Prague until it's scheduled into a fork?
00:44:46.074 - 00:44:54.574, Speaker E: That's fine, but if it's scheduled for Prague, then probably the same format is preferred. We can agree on the format with Mario.
00:44:55.194 - 00:45:19.702, Speaker D: So, yeah, I think when that time comes, what will happen is that we will introduce EOF into the other Eips and it will simply be switched into the main release. So now when you see the main release, when that happens, you will see EIP 7002, 6110, and also EOF inside everything inside of the same fixture package.
00:45:19.878 - 00:45:22.358, Speaker E: So it's a copy of the main.
00:45:22.406 - 00:45:38.014, Speaker D: Release, but EOF only you have actually. So without 61, ten, without 7002, without anything else. Because the problem was that request hash was the example problem in this case. Yeah.
00:45:38.354 - 00:45:41.054, Speaker E: Okay. Gotcha. Gotcha. Yeah, that's fine for it.
00:45:41.554 - 00:45:42.494, Speaker G: No problem.
00:45:43.194 - 00:45:49.374, Speaker A: But for EOF tests, aren't we not going to, we're not going to test deposits and requests in an EOF test, are we?
00:45:51.194 - 00:46:21.710, Speaker D: Maybe until we make it into the Devnet. So once Devnet. So once UF makes it into Devnet, we can start to think about interactions between UF and these kinds of eips. Unless we have like a concern that maybe there's a big interaction that we have to test beforehand, maybe we can think about it also putting that EIP into the EOF releases. That's the discussion, I think.
00:46:21.902 - 00:46:34.606, Speaker A: But the alternative is before then, clients could just put in empty deposits, empty withdrawals, and the empty tree request hash just dubbed those out in their t eight n responses. But then they'd have to mess with.
00:46:34.630 - 00:46:47.114, Speaker D: T eight n. Yeah, so my idea was that the EUF tests, they don't include the request cache at all in the header. So just imagine cancun plus Eof and nothing else.
00:46:48.494 - 00:47:46.000, Speaker A: Okay, so my thought on this is this is probably solving what's going to become a more generic problem is stuff that's coming into tests that isn't scheduled for fork in general. Anyof could possibly be the lead for that. You know, we could get vertical tests ready before being scheduled. We could get, yeah, we can get any of the other smaller changes that we're going to want to model that they start with eels before they become CFI. So if we can get a general solution and not just an EOF solution, so that what's scheduled for devnets and forks is one set of releases and everything else has its own naming convention. For example, 7702 tests that's not scheduled yet, but it's going to need to have tests for the clients. You know, are we going to give it a name or do we go by the aggregate EIP number, which I think is another question.
00:47:46.000 - 00:48:42.102, Speaker A: Do we want to call them EOF or do we want to call them 7692 to make it clear which version of which aggregate of it is? I personally am in favor of calling it EIP 7692. That would set the standard. That stuff that wants to have its own custom build has an EOF number that it's tracking against. And that also brings up another proposal of we could have these forks named Prague plus 7692. Let's make it clear that we're testing Prague plus the additions of this, which I know Geth is an easier time turning on random smaller hard forks, but I think Baesu for a subset of those, we could make those work. So that would make it easier for tests to make it clear that the fork is Prague post 7692. That also makes it clear what the base that they're building off of is for things like request hash.
00:48:42.102 - 00:48:45.834, Speaker A: So technically we'd be cancun plus 7692.
00:48:46.934 - 00:49:03.774, Speaker D: Yeah, exactly. Yeah. I don't mind any type of naming over the other one, but I think if the EIP is more clear, the EIP number is more clear. That's fine by me.
00:49:10.034 - 00:49:24.874, Speaker G: I mean, this is actually kind of really interesting, right, because it means that features for the EVM can be worked on without worrying about when they're going to be scheduled in, and then maybe when all the tests are passing for all the clients and they get scheduled in for a fork.
00:49:27.654 - 00:50:01.674, Speaker D: Yeah, exactly. We were thinking of a more general solution for this because this is going to happen over and over again. Even. We were also thinking about, for example, roll ups. If they want to come on and implement something, we want them to come to the execution spec us to implement that thing because it would be very easy then to just migrate into mainnet if something needs to be migrated to mainnet. But yeah, definitely just this is EF is the primary. Ef am Berkeley is a primary example right now, but I think this is being thought of in more general way.
00:50:01.674 - 00:50:03.774, Speaker D: We want the general solution for this.
00:50:06.194 - 00:50:12.654, Speaker A: And if we require a rip or an EIP number that encourages them to go down the standardization path too.
00:50:18.694 - 00:50:20.234, Speaker D: That's a good point, yes.
00:50:22.054 - 00:50:32.954, Speaker A: So what does this mean for the tests that are in there today? Do we need to re change the target fork to something? Do we need to put version numbers in our eips?
00:50:33.294 - 00:50:59.324, Speaker D: I'm working on a pr, so I will make another fork internally in the framework, which will be called EIP. And the number of the UFO and all of the EF tests will point to that fork. Okay? Yeah. And I think it should be a very simple change. I will try to get today. I will send you guys the pr just to make sure we are on the same page.
00:51:01.064 - 00:51:22.264, Speaker G: I have a question, which is like, how do Eips interact with each other? So for example, if some EIP, I think pay is a good example, but it could be like anything, you know, foobar instruction, like how does that get tested in conjunction with UF?
00:51:23.684 - 00:52:05.324, Speaker D: So we add, right now, if both of them are included in a Devnet, we simply add the crossover tests in one of the folders. So for example. Well, it's not a good example because we have the requests. It's a separate EIP. So the crossover testing between EIP 6110 and 7002, it was made into the other EIP. So the crossover testing was there. But generally what we do is we just simply add another Python file with the crossover testing for those two apartments, eips that are relevant to each other.
00:52:05.324 - 00:52:31.704, Speaker D: In the case of EOF, if there's any other EIp that is potentially going into Prague that potentially disrupts EOF, I think we can just migrate the tests and implement this other EIP and also write crossover tests inside of the EOF folder for the time being. Yes. Was that clear?
00:52:32.044 - 00:52:33.428, Speaker G: Yeah, sounds cool. Thanks.
00:52:33.556 - 00:53:08.284, Speaker A: Okay. Okay, just writing down what the proposal would be. Right. Any other comments about this? Anything else we want to discuss in our last four minutes? Any other issues?
00:53:13.144 - 00:53:24.844, Speaker G: I think it's worth discussing Peter's 118 proposal in more detail, but it doesn't have to be today unless there's time constraints or scheduling constraints.
00:53:25.264 - 00:54:43.734, Speaker A: So looking at that, my biggest concern has to be the code address generation, because when you do create and you go into runtime, you're never going to have contract deployed to that address, and you might have leftover storage from the runtime. So if we go into runtime mode, we need to either put safety features on it such as all s stores will be reverted or s store causes a revert on the first level and we would need to track what 7702 does on that. But I think my biggest thing I don't like about it is we lose the known space contract ordering, and some people might still depend on that. Then when you deploy a contract with the notes that you want a contract to show up at a certain address when you're done. I know at one point some developer tools had that hard coded, which was fun to deal with when I was working at Hedera, but they think they've recently moved away to take the return value of the contract. But it's some things that some places have built as an assumption. We can discuss it next week, but I just want to put out there that those are my major concerns with 118 is it's such a significant variation from the model that it would break too many expectations so we can put it on next week's agenda.
00:54:43.734 - 00:55:31.484, Speaker A: Any other comments? If not, I'd like to thank everyone for coming. Thank everyone for participating in the process. It works better when everyone is here and talking, and I think this is a very productive meeting, so I'd like to thank everyone for that. See everyone in a couple of weeks.
00:55:31.644 - 00:55:32.412, Speaker B: Thank you.
00:55:32.548 - 00:55:34.644, Speaker E: Thank you. Bye.
