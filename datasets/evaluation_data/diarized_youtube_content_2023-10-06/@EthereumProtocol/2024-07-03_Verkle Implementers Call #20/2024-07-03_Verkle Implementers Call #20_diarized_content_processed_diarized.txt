00:00:02.320 - 00:00:15.725, Speaker A: Hello, this is Virql Implementers call number 20 and issue 1089 in the PM repo. Starting off with any client team updates. Anyone want to kick things off this week?
00:00:24.185 - 00:00:25.765, Speaker B: I think I can go first.
00:00:26.915 - 00:00:28.859, Speaker C: So yeah, so in other mind I.
00:00:28.867 - 00:00:30.267, Speaker D: Was just trying to test the Vocal.
00:00:30.291 - 00:00:32.931, Speaker B: Sync implementation and last week I was.
00:00:32.963 - 00:00:38.987, Speaker D: Able to implement the healing part and test it on question and everything seems.
00:00:39.011 - 00:00:40.363, Speaker B: To be working fine. So we can.
00:00:40.459 - 00:00:42.323, Speaker D: So like anyone can just join question.
00:00:42.379 - 00:00:46.843, Speaker C: And now using Vocal Sync? I don't think so you'll ever use.
00:00:46.859 - 00:00:52.969, Speaker D: The healing phase, but in my testing I modified some things and tried healing as well and that part also works.
00:00:53.017 - 00:00:53.885, Speaker B: So yeah.
00:01:06.065 - 00:01:42.655, Speaker D: Yeah, for Geth. Well, there was work on the testing framework, but yeah, I guess Spencer will give an update. We did a lot of work on the specific. There's still an outstanding PR from Gajinder that unfortunately I didn't get around to review just yet. But that will be done today. And then we started the implementation of the new 4762, the one that we decided on in Kenya. So we haven't.
00:01:42.655 - 00:02:52.565, Speaker D: Yeah, I just fixed the last few bugs so I'm going to give it a run for the test and then we will need to run the testing framework again to make sure nothing breaks. And we've been busy with measuring GAS and witnesses. We don't have anything to publish yet, but we're collecting or we're making some progress collecting data so we'll have something in a few weeks. Inaccurate. Did I forget something? No, particularly maybe mentioning that I have almost ready this analysis that I've been doing regarding the code access GAS impact based on mainnet transactions and also comparison between the current 31 byte cold chunker versus the 32 bytecode chunker proposed by the Ypsilon team, also based on many transactions. So we are wrapping up some details and I will share this document in the next days. So for others to check.
00:03:17.275 - 00:03:19.535, Speaker A: Anyone else have any updates I'd like to share?
00:03:23.795 - 00:03:27.913, Speaker E: I think Kareem has. There we go. I think he's just joined with his micro.
00:03:27.999 - 00:03:28.665, Speaker C: Cool.
00:03:32.005 - 00:03:32.745, Speaker B: Hello.
00:03:33.205 - 00:03:34.117, Speaker E: Hey Karim.
00:03:34.221 - 00:03:34.865, Speaker C: Hey.
00:03:36.085 - 00:03:39.025, Speaker E: I was going to give an update for you, but it's probably better for you to give it yourself.
00:03:39.565 - 00:03:40.413, Speaker D: Okay.
00:03:40.589 - 00:04:10.885, Speaker B: Yes. So, still working on the Flood db. So I'm trying to do a refactor of the Flood DB in order to have something that much more the implementation based on STEM, etc. So not a lot of news since last week. And Thomas is also looking how we can save the different Verkel data. So 3 node ladb, etc. In order to reduce the size of the database.
00:04:10.885 - 00:05:00.967, Speaker B: So yeah, looking at some optimization, etc. We also had some performance. We also added some performance optimization, something we already have with Patricia 3. So it's. It's a way to preload the tree node during the block processing. So like that at the end of the block when we have to compute the stateroot, everything is already on memory. So yes, we implemented that in order to have also this mechanism for Verkel and also a mechanism to pre compute the stem during processing in order to optimize the final step in the block processing.
00:05:00.967 - 00:05:07.715, Speaker B: So the stateroot computation, it's all on my side.
00:05:22.265 - 00:05:22.689, Speaker C: Cool.
00:05:22.737 - 00:05:35.125, Speaker A: Anyone else? Any updates on the testing side of things that we'd like to share today?
00:05:36.395 - 00:06:09.605, Speaker F: Yeah, so thanks to Guillaume, we now have a successful framework. So we had a kind of a small bug that was hard to find that Guillaume pointed out. So thanks for that. It took me a while to find. And so we now have our first release. You can just post it in the chat right now. So these are the simplest form of the transition tests.
00:06:09.605 - 00:07:23.545, Speaker F: So the type of transition tests are mid fork transition tests, at least that's what the term we're calling them right now, where we're failing all our existing tests, where the test block starts on the fork transition block. And these are being filled with zero strides. And yeah, so if anyone wants to try this out, just make sure you have the Shanghai to Prague at time 32 fork enabled. It's mentioned in the release. And yeah, hopefully you guys can test this out and if there's any issues with it, then just feel free to ping, ping me or Mario and we'll be happy to help. As for the next steps, for us it will be filling the genesis test, so starting at the vertical fork as opposed to during transition. So this will be updating our framework to fill the tests that Ignacio has been adding.
00:07:23.545 - 00:08:56.885, Speaker F: So yeah, that's. That's one point. There was a small thing or just a question that I guess we wanted to bring up and it's kind of a specific question in relation to, I guess how we can debug mainnet issues in relation to whether we want to know, I guess the specific account that has the issue. So in a, in a post Verkal world where we have just the Verkle tree, will we need to know the exact account where an issue could reside or will the Verkle tree be enough? And maybe just to follow up on that and from our side, when we're Filling the transition tests. Ideally what we'll do or what we will do is create a mapping at the start before the transition occurs of all the accounts and we'll create a mapping of those accounts to get the stem in the tree and map those to the vertical tree stems so that if we do have an issue when filling a test, we can look at this mapping we have and index it back to the account. So if this is something that's necessary, I think it could be something we could look into. Yeah, I just wanted to ask that question if that made sense.
00:09:01.265 - 00:09:17.765, Speaker D: Yeah, that makes sense. I think. Was I not dumping the mapping at some point and maybe we removed it but we can add it back. We could do this. Oh no. There was a tool that would create the mappings for you. Yeah, that's the thing.
00:09:17.765 - 00:09:48.295, Speaker D: But otherwise. Yeah, this is how I debugged. I just look at the vertical tree like the witness and the vertical tree dump tells you everything you should need to know. If something is missing, then there's a bug. That's a bug in itself. But yeah, so far it's been working great because this is how I debugged everything. So just looking at the output, the VKT output and input should give you all the information you need.
00:09:48.295 - 00:09:54.895, Speaker D: And if you want to create a mapping that's also possible. Yeah, I can help you with that if you need.
00:09:59.275 - 00:10:05.175, Speaker F: No thanks. I don't know if Mario, you want to mention anything about this.
00:10:13.755 - 00:10:25.615, Speaker A: We can't hear you, Mario, if you're talking. Maybe some mic issues. Can anyone else hear Mario?
00:10:27.075 - 00:10:27.895, Speaker D: Nope.
00:10:34.965 - 00:10:40.749, Speaker A: Okay, we'll see if he comes back in a second. Sorry, go ahead.
00:10:40.797 - 00:10:42.945, Speaker D: You had a question? No, go ahead, go ahead.
00:10:43.485 - 00:10:52.465, Speaker A: I was just going to say a small thing. Spencer, you. If anyone wants to get a hold of you or Mario any preferred method for people to get a hold for with any sort of questions?
00:10:54.405 - 00:11:07.805, Speaker F: I think Discord. Discord is good. And I'll post the release in the vertical tree migration channel if that works for you guys. And then if anyone has questions, they can just reply to that.
00:11:08.465 - 00:11:09.925, Speaker A: Awesome. Thanks Mr.
00:11:10.625 - 00:11:29.213, Speaker D: So I do have a question. Hopefully it's not too long. We are going to try to merge because we have like maybe three branches. Different branches. I'd like to turn everything into one. I fixed the issues like the incompatibilities between at least two of those branches, if not all three. When I want to test those branches.
00:11:29.213 - 00:11:34.305, Speaker D: Wrenches. Is there an easy way I can do it? Was that new release?
00:11:37.445 - 00:12:05.797, Speaker F: Yeah. So the easiest way I think on geth would be to use the EVM block test command. But we have the ConsumerLP simulator, which we're using, and we have a CI setup. It's just the. It's kind of broken on the server right now. This is my fault, but it's an easy fix. So we can.
00:12:05.797 - 00:12:24.705, Speaker F: We can just start running clients on the CI, but otherwise I can send commands to tests with the fixtures. I said in a similar fashion to how all clients are running tests right now.
00:12:33.685 - 00:12:47.505, Speaker D: I have a small question for you, Spencer. So do you think it's a good idea that I rebase my branch with protocol Genesis tests on top of this release? Or should be another branch.
00:12:51.375 - 00:12:59.235, Speaker F: Yeah, maybe the Verkal main branch would be good right now. I can send you over discord.
00:13:11.455 - 00:13:12.095, Speaker C: Cool.
00:13:12.215 - 00:13:19.445, Speaker A: Anything else? I'm testing. Anything else? I'm testing a little echo.
00:13:23.425 - 00:13:27.765, Speaker E: Mario fixed his mic. Mario fixed his mic.
00:13:41.035 - 00:13:50.175, Speaker D: But did Mario say anything or is it just repeat? Like, is it just the monitor that does an echo or something?
00:13:51.195 - 00:13:55.575, Speaker E: I didn't hear you twice. So I think he's. He's probably muted or fixed it.
00:13:58.635 - 00:14:12.144, Speaker A: I guess we can keep going and we'll see if Mario comes back again. Cool. Okay, Guillaume, next up. You had updates that you wanted to share, I think, on a couple EIPs. 7709 and 2935.
00:14:12.287 - 00:14:38.155, Speaker D: Right? Yeah, I need to. So I created two updates to the EIPs. There's been a few discussions that were okay. Something went crazy with my mouse and now one of the tabs doesn't want to. Yeah. Okay. So it's going to be pretty bad to share Windows.
00:14:38.155 - 00:14:53.815, Speaker D: Okay. Maybe I can just do it this way. Sorry for the. For the mess. This one. Yeah. So I created.
00:14:53.815 - 00:16:00.495, Speaker D: So, yeah, there's been on ACD and other channels, there's been some pushback again, relating to the fact that we don't behave exactly like 4,788 and potential other Prague system contracts. They are. I mean, it's really a nitpick, but the conversations, as some of them have been fairly fierce. So the agreement was that to try to settle everything down, we have agreed that we will, in Prague, 2935 will behave exactly the same as 4,788. So that people are happy. And when they realize that, yeah, it's not going to work in Verkal, they will change their minds. And to that effect, I have created another eip.
00:16:00.495 - 00:16:23.627, Speaker D: Let me look for it. Because my window went crazy. Sorry. It's 77 09. Right. So there's the. An update to the 7709 EIP that does basically the reverse of the update 2935 does.
00:16:23.627 - 00:16:51.055, Speaker D: So it says contract execution is no longer favored over direct state updates. That's roughly what it is. So for your information, please have a look, tell us if there's a problem. It's. It's really just going around the nitpick. A very sticky nitpick. But yeah, it should not introduce many like any issue.
00:16:51.055 - 00:17:11.075, Speaker D: Just have a look, please give us some feedback and if we don't see any opposition in the next week, we'll merge that. In fact, I will probably mention that on ACD next Thursday. And yeah, if we don't see any opposition, we can, we can merge this. Yep, that's pretty much it.
00:17:18.015 - 00:17:20.435, Speaker A: Cool. I think there's a question from Dano in the chat.
00:17:21.575 - 00:17:43.175, Speaker C: Okay, even though the smart contracts are recommended, do they still need to be in place? Because this brings into some testing corner cases where if the contract has no balance, has no knowns, has no code, any rights to the storage, it's supposed to be cleared as an empty contract, which isn't going to be the case in Verkal. But until then, pre Verkal we still have the empty contract rule.
00:17:43.915 - 00:18:17.345, Speaker D: Yeah, so actually that's another thing I need to prepare for Wednesday for Thursday. Sorry. Deactivated 158. There's a good reason to do it in Prague and not in Osaka. Simply that if you, for whatever reason, people decide that they don't want to do the overlay method, they will have to replay blocks like the. What I call the counterfactual history or the revisionist history. And this EIP158 is going to cause a lot of trouble in that case.
00:18:17.345 - 00:18:31.125, Speaker D: So yeah, that's not answering directly your question, but just FYI. But so to. To do this. Sorry, I kind of lost track of my thought. What was your question again?
00:18:32.465 - 00:18:43.245, Speaker C: It has interactions with the empty. Do the contracts maybe in place for the second contract to execute or should contract make sure that the address is just not empty?
00:18:43.945 - 00:18:50.605, Speaker D: Right. So one of the changes in that EIP says that if the contract is not there, this is considered a bug.
00:18:52.185 - 00:19:11.765, Speaker C: So it's, it's, it's an invalid genesis config if the contractor isn't there. Okay, yeah, good. And would the transition fail if someone doesn't add the contract or are you doing a ist for the contract?
00:19:12.705 - 00:19:30.915, Speaker D: Well, the contract is will the transition fail? Yeah, I mean, yes, it will because you will need to update. Okay. The transition per se will not fail. It will write to this contract and this contract would be missing. So the write would cause an error.
00:19:32.095 - 00:19:37.035, Speaker C: But no block would process and therefore the transition would fail because the chain would halt by rule.
00:19:37.495 - 00:19:51.529, Speaker D: Right? Yeah. I mean, if it's not there. Indeed. Like the. I mean, let's assume a. If it's okay, if it's missing on a test net. If I understand correctly, that's your question.
00:19:51.529 - 00:19:54.561, Speaker D: Because the contract will be deployed on mainnet as part of Prague.
00:19:54.713 - 00:19:55.885, Speaker A: Or Layer two.
00:19:57.105 - 00:20:07.765, Speaker D: Or Layer two. Okay, fair enough. So if it's missing, then yes, the block processing will fail. So yes, it will. Like you said, it will not work. So that would be.
00:20:08.105 - 00:20:15.325, Speaker C: I think it would be safer to say instead of it fails, that the system contract processing does not occur if the account is empty.
00:20:17.845 - 00:20:31.985, Speaker D: But so how do you make block hash work if the system contract. I mean like. Yeah, that. That breaks block hash. So that's why I'm saying if the contract is not there, it's considered a bug, like a configuration bug.
00:20:32.725 - 00:20:44.845, Speaker C: True. All systems are still going to have the cache for the 256 block hash opcode. You don't have to use the system contract for block hash. Unless you want to go past 256.
00:20:45.825 - 00:20:46.233, Speaker D: Yeah.
00:20:46.289 - 00:20:50.805, Speaker C: So unless. Unless the systems are also going to remove that part of their blockache code.
00:20:51.745 - 00:21:07.525, Speaker D: Right, but yeah, exactly. If. That. If you do this, that you Simply don't have 7,709 implemented and your implementation of Verkho is incomplete. I mean, that can be your choice if you want to do this. But then I would say it's your problem. You're just not compliant with.
00:21:07.525 - 00:21:10.495, Speaker D: With the, with the eap. The vertical eap.
00:21:11.235 - 00:21:34.955, Speaker C: Yeah. I'm just concerned that specify that it sets up a trap that's going to break some L, some L2 that doesn't think through it. I think a more forgiving rule like, you know, either not writing it or another alternative will be to say that if the notes is 0, that the notes get sent to one or some other field must get set. That'll keep it from being empty, which gets in the way of deploying the code. But. Or, yeah. Or within that gets us in the ist.
00:21:34.955 - 00:21:56.815, Speaker C: I mean that's. Those are the issues we start getting into if the. If we don't get rid of the empty contract rule. So yeah, these are some things we need to think through and that if we do it this way before Verkal, then we would have to get rid of 1158 because the alternatives aren't looking good. Because there's always Arguments on both sides of it.
00:21:58.235 - 00:22:07.985, Speaker D: Yeah, I mean, yeah, like I said, I would like to get rid of it in Prague. So that would be the. Yeah, that will be a discussion at acd.
00:22:09.125 - 00:22:20.705, Speaker C: I think they have to go in together. I would think you'd have to go in together that if you want to move away from doing the contract, you'd also have to do that with 158. Both have to go in, I think.
00:22:21.205 - 00:22:40.335, Speaker D: Right. What I meant is158 would have to go. Okay, what I was suggesting is that 158 goes first. But yeah, they will have to go in together for sure. Like they will have to be activated at the same time for sure. Yinder.
00:22:42.675 - 00:23:34.453, Speaker G: Yeah. Just to add to this discussion, I think my opinion is that even in the current eips we should make it mandatory that the contract is deployed before the eips activated. So which is sort of contention that there's some pushback on this particular requirement for the. For again for this scenario that you know, there could be no contract while the EIP is activated. And as of now, I think all the Ethereum js, for example, treats this as a block failure. But as you have mentioned, it should probably. Either we change the behavior to basically say that okay, if there is no contract then the entire update Mechanism or for example, if 7702 is also not deployed, then you don't pull any withdrawals.
00:23:34.453 - 00:24:30.281, Speaker G: So we. Which we don't have that kind of clarity as of now because for example, Ethereum JS has implemented it as a failure of block processing if for example, the EVM call to the contract fails. Right. So EVM call if there is no. There is no contract that is out there and we can't find any contract code to execute similarly for 2935 and similarly for many of the system contracts that we have. So I think it is actually prudent to make sure that EIP says that the contract deployment is required. But this is sort of contention point that has come up and right now there is some opinion that says that EIP can be activated without the contract being deployed and that is some.
00:24:30.281 - 00:24:54.705, Speaker G: That is sort of causing this rewarding that is out there. And I think Verkal will basically make. Will mandate that, that, that those sort. Those sort of change where the contract is not deployed but the eips activated are buggy chains and we'll sort of introduce this requirement behavior into the eips.
00:25:00.685 - 00:25:58.575, Speaker D: Right? Yeah, I was just thinking, actually I think I had missed Daniel's point and I realized that when you said it. Yeah. If someone does not deploy the contract but use 2935 with EIP158 deactivated, then I mean, yes, in my view it should be considered buggy, but before people realize 7709, 7709 is activated, then they could have their own. They could have their own scheme that would kind of break this. Yeah, I mean I agree we should consider this buggy like right off the bat, but that's going to be a tougher sell on acd. Okay. I guess it's worth asking the question on ACDE and see what people say.
00:25:58.575 - 00:26:08.677, Speaker D: Cool.
00:26:08.741 - 00:26:19.905, Speaker A: Should we keep going? Next up in the agenda. Actually, Guillaume, did you have anything that you wanted to chat about with the testnet relaunch or did we decide to skip through that?
00:26:21.165 - 00:26:48.565, Speaker D: Yeah, so I. Until just a few minutes ago, I had completely forgotten what I wanted to talk about, which was embarrassing. But actually the question I wanted to ask is do we Want to deactivate EIP158 on the next testnet? I wanted to find out. Like I would be happy. I would like to do this on the next instead of the testnet. I'm just curious if other people are opposed to. It.
00:27:02.355 - 00:27:06.815, Speaker A: Seems like no opposition. I think Vitalik has voiced his support for it as well.
00:27:08.715 - 00:27:09.203, Speaker D: Yeah.
00:27:09.259 - 00:27:24.115, Speaker E: Okay then all the, all of the accounts that were. That this was meant to clean up have all been handled. Is that right? VIP158 and there's not a way to create new, new malformed accounts in this way.
00:27:24.575 - 00:27:43.115, Speaker D: There will be soon if 7702, depending on how 7702 is built. But yeah, in that case they should not be. They should not be deleted. So yeah, that's, that's the argument. Yes, it was a temporary measure that is no longer necessary. Necessary.
00:27:44.855 - 00:27:54.215, Speaker C: Yeah. The only people I could conceive of objecting to would be people who are around for those Shanghai attacks. And I think everyone that's still active has expressed support for it. So I think we'll be good.
00:28:06.835 - 00:28:07.379, Speaker D: Cool.
00:28:07.467 - 00:28:24.295, Speaker A: Let's keep going. Next up, there is a proposal around the transition and pre image distribution from Besu folks. I think maybe Gary and others. I don't know Gary, if you have one to.
00:28:25.515 - 00:29:11.715, Speaker E: I can speak to that. I think Karima's got some of the. Some more interesting justification. But yeah, I've started reengaging with the Verkal transition after working on some unrelated eaps and I've been approaching the Verkal transition with the expectation that it's going to be probably longer than a month that the transition is going to take. So I was, I've been expecting that. I was thinking that a month is going to be too long to not and not have clients able to sync via snap. So I had been approaching this with the notion in mind that we were going to need to support clients using Snap1 and Snap2 in order to get synced to the network during that transition period.
00:29:11.715 - 00:29:30.155, Speaker E: So I think that might not be something that we've considered so far that I think yom, you had mentioned that we just would not do anything but full sync. Would not be capable of doing anything but full sync during that one month period. Is that still kind of the case? Is that accurate?
00:29:30.935 - 00:30:04.565, Speaker D: Yeah, I mean the argument being that you would have to develop an algorithm, a sync algorithm for a period of one month or two months. Make it, make it two months and it would decrease the complexity by a lot of the fork. By a lot. When you can just do a full sync and doing a full sync. Unless you're really at the end of the fork of the transition period. Even then at the end of the transition period there would be like two hours worth worth of full sync. So I don't think it's too bad.
00:30:05.615 - 00:30:34.225, Speaker E: Yeah, I was thinking, I mean even, even taking a full sync approach from the point at which we freeze the Merkle tree, that seems, that seems like that's reasonable. It could be slow in some cases. But what I was more concerned about is clients syncing from scratch with no snap state at all to do the transition. Like how would they, how during that one month period are we just not going to be able to have clients do Snap one in that period with the frozen Patricia Merkle tree?
00:30:34.385 - 00:30:43.725, Speaker D: Right. So that's the thing. You would do a snap sync at the last Merkle Patricia tree block and then you do a full sync from there.
00:30:44.465 - 00:31:34.053, Speaker E: Okay. So we're going to continue to serve snap one even though we'll be further than 128 blocks from head with the, with the frozen tree. Okay, that, that's, that is reasonable. Kareem, do you want to speak to specifically including the pre image keys in the execution witness? I can't really speak too much to the parallelization that we would like to be able to do with that. I think that you do a better job of explaining the benefit there of having preimaged keys in the execution witness. Are you still here, Karim? There you are.
00:31:34.109 - 00:32:18.335, Speaker B: Sorry. Yes. Wanted to say that if we. I think Guillaume, you already said that you are thinking about that but if we have the address we are touching and maybe also the slot we are touching in each transaction so we can have this information state diff. It would be a way to maybe do some parallelization when we want to import the block as we know what kind of transaction will touch maybe a specific address and another will not touch the same address. Maybe we can parallelize two transactions and it will optimize the import block step. So I was thinking if we can maybe add this kind of information.
00:32:19.095 - 00:33:02.411, Speaker D: Yeah, okay. So my understanding is there are two things here. So yes, regarding the parallelism implementation, I'm going to work on that spec change tomorrow. I finally, I'm at a good, at a good location where I can actually stop and write more spec stuff. And yeah, it would, I mean in my, in my proposal at least you can always. We can discuss it at the next vac or before, but we would just add a bitmap for each transaction, for each stem to say this is the transactions that has been touched in. So this way you can schedule your execution in a different order.
00:33:02.411 - 00:33:49.395, Speaker D: Now the problem is that indeed you do not really know which address a given stem corresponds to, which still is not too bad because you could schedule all the transactions together. And when you see that a transaction has been scheduled, like you access a stem that has been scheduled in a different transaction, you can halt or do. Yeah, maybe enter a critical section or something. But my understanding was that there was another reason why you wanted to put the pre images. So on top of the stem you wanted to put the. In the witness. The tree address.
00:33:49.395 - 00:34:03.399, Speaker D: Sorry, the tree index and the address. Is that for parallelism? You wanted this or was there a snapsync related reason for that?
00:34:03.567 - 00:34:09.715, Speaker B: On my side it was for parallelization. I think Gary wanted also this modification for snapsync implementation.
00:34:10.065 - 00:35:25.425, Speaker E: Yeah, this is kind of like the convergence of a couple of concerns and the. Like you said, Gil, it's going to be a short concern during the transition where like if a client snap syncs during the post Merkle tree freeze, they won't have the pre images that would have occurred from the freeze up to the point at which you know, they've, they've now snapsynced to the network. So there's like a, I guess it's a bit of a trust assumption or a verification problem for playing blocks, you know, playing the transition blocks forward, knowing what has been transitioned and hasn't been transitioned in terms of the key space. So that was, that was really the concern about the pre image distribution for the state post Freeze. But prior to finishing, finishing the transition, I think that since that's a bit of a short term concern, I think it was more interesting to approach this from like a parallelism angle, whereas something that we could leverage during the transition but still would pay dividends post transition in terms of being able to do parallel transaction execution.
00:35:28.765 - 00:35:58.775, Speaker D: Okay, understood. Yeah. So let me just write this spec tomorrow, share it with you. We can see what you guys think. The biggest pushback I have against this is clearly that it's going to make the Witness much bigger. Right. We could shave a little by not putting the stem in this because you have all the data you need to recompute it, but it's still going to be twice the size of the stem, about.
00:35:58.775 - 00:36:15.855, Speaker D: So I would be against it. I would love to do without it. But yeah, I'd say let me make this spec update proposal and then we can, we can take it from there and see if, if we really, really can't go around it.
00:36:16.755 - 00:36:30.025, Speaker B: Yeah. Just for the polarization, I think if you have a map that say, okay, this transaction is touching this term, I think it will be okay for the polarization. Just it would be enough.
00:36:50.735 - 00:36:51.143, Speaker D: Cool.
00:36:51.199 - 00:36:59.607, Speaker A: Anything else on this topic? Roman, did you.
00:36:59.751 - 00:37:22.775, Speaker G: Yeah, apologies, I was a little bit late. So this last conversation, was it about including pre images in the Witness in general or specifically about this map of the dependencies between the transactions or which transaction touches a particular account?
00:37:23.995 - 00:37:41.415, Speaker D: Yeah, it was about adding pre images in relation with the bitmap of saying which transaction get touched by which. But we think we don't really need it after all to be confirmed. But we probably don't need it.
00:37:42.415 - 00:37:51.735, Speaker G: Okay, but we still preserve the pre images in the Witness, like regardless of this map, correct?
00:37:51.815 - 00:38:36.775, Speaker D: No, we don't put the pre images in the witness. Okay, so there might be some confusion because Gabrielle has proposed, I think that was during Kenya, the Kenya workshop that we put the pre images in the Witness during the transition to somehow solve part of the pre image distribution problem. But this is, this is something we're still thinking about. But the. I would say so far there's no decision on adding pre images to the Witness at all because it would increase the size of the witness and there's no clear benefits so far that we have identified for sure that would require us us to do this.
00:38:37.515 - 00:39:07.265, Speaker G: Okay, so a little bit of context from breath side and I know this is true for Arrogant as well. We primarily store the state by the pre image. So whatever the outcome of this decision is pretty crucial to us because potentially we would need to change our database schema by the all of the accounts by the hash key.
00:39:09.325 - 00:39:52.605, Speaker D: I understand why that would be critical, but why would that really be the case for you? Because currently the tree itself is completely hashed like right. It's the. When we call the secure tree in ger it's a catch of the address or to catch check of the slot number. And yet during block execution you collect all the account address like the pre images and this is what you store. Presumably you would be doing exactly the same thing while executing a verkle block. So I don't think, I mean of course I don't know your code base, but I don't think that would be a problem for you in that case.
00:39:55.715 - 00:40:04.375, Speaker G: Yeah, fair. I was more thinking about the use case of a stateless client. Yeah, I got mixed up. You're correct here.
00:40:05.155 - 00:40:20.055, Speaker D: I mean, yeah, I'm happy to discuss it offline as well. We want indeed, like you said, we want to make sure that's not going to be a dead end for you. So yeah, let's figure it out as soon as possible before we make the wrong decision.
00:40:21.825 - 00:41:02.225, Speaker E: I don't want to presuppose the value of having a complete pre image store, but it seems rather appealing to have if we're going to have a pre image distribution at the point in which we freeze the Merkle tree and then we had pre images available via execution witnesses, it seems like, you know, if and when there's a subsequent change to storage and we have the same pre image issue again, there'll be a fairly easy story for getting those pre images. They'll be by definition distributed by the chain plus that original pre image distribution file. So that to me is rather appealing.
00:41:04.245 - 00:41:46.223, Speaker D: That makes sense. However, I mean, yes, you're right, there might be a. There will probably be a further tree format change maybe in five years, hopefully not sooner. But what I would say is that witnesses are going to be deleted anyway. Otherwise you're just moving the data from one location on this to another location on this. So witnesses have to be deleted at some point. So I don't think using the witness to do this to do pre image distribution is reliable way to do this for long term distribution of pre images during the transition.
00:41:46.223 - 00:42:09.675, Speaker D: Yes. After that I'm not sure. I think we would need to simply require every client to store the pre images and to distribute them. But I don't think. Yeah, I don't see how we could do it with the witness and make sure that it's there forever. Because like I Said witnesses will be deleted.
00:42:11.865 - 00:42:58.215, Speaker B: Guillaume, just after the transition, do you want to keep using snapshot based on catch or do you want to migrate to another kind of snapshot using stem or something like that? Because if we don't have the address and slot after the transition, I think it will be hard to populate the snapshot with the data from the witness because the witness will only have the stem. So you will not have the ketchup of the address or the ketchup of the slot. So you will not be able to link the data from the witness to your snapshot. Because when you will run the evm, you will try to find an account by ketchuck. So I think we will have a problem at this time.
00:43:01.795 - 00:43:14.151, Speaker D: Yeah, that's a good point. Tanishq, how do you implement that? Like at the end of the sync, how do you. How do you. I mean, I know you're you, right?
00:43:14.303 - 00:43:31.635, Speaker B: Yeah. Because for example, for Bezu, in order to match that, after the transition, we will change the flood db so the flat DB based on cachac will not be used anymore and we will use directly the leaf of the tree. But I wanted to know what you will do in your client to be sure.
00:43:33.965 - 00:43:42.665, Speaker D: Yeah, for guests, it's still an open question, which is why I'm interested in what Nethermine has been doing because they do have an implementation of the sync.
00:43:44.765 - 00:43:45.725, Speaker C: Can you repeat the question?
00:43:45.765 - 00:44:11.075, Speaker D: I didn't get the question exactly. You have your snaps or you have your vertical sync with healing and everything. What is the format you use for the flood DB or the snapshot? Do you key it like the key format? Do you use the catch or do you use the. Simply the stem value?
00:44:12.455 - 00:44:14.087, Speaker E: I'm using the stem value right now.
00:44:14.151 - 00:44:28.235, Speaker D: No catch for worker. Okay, so that's basically what Karim is saying. So yeah, we would need.
00:44:28.755 - 00:44:29.091, Speaker C: Yeah.
00:44:29.123 - 00:44:53.739, Speaker D: Okay. There's a bit of design space that we need to explore here. Yeah, no, I don't have any answer right now, but yes, I agree. This is something that needs to be clarified. Cool.
00:44:53.827 - 00:45:28.755, Speaker A: So we have two topics left and we're running a little bit low on time. I'll just put both the topics out there and we can decide if we want to get into either of them or maybe save some for the next call. The topics are the recent proposal from Peter around El cross validation. I'll drop a link. I think that was discussed on the most recent acd. I think most people here are probably already aware of it. The idea was maybe just to touch on it here a bit and see if there's any further discussion needed on this topic or just get people's input and ideas around this idea.
00:45:28.755 - 00:45:49.855, Speaker A: And then the last topic was a potential or just yet discussion around the cost Of Xcode/Xcode size. And this was flagged, I think by Guillaume, actually. So do we want to get into either of these? I don't know, Guillaume, maybe. If you have any thoughts or if we want to save this for next.
00:45:49.895 - 00:46:30.873, Speaker D: Call, I'd like to go with the eof first, because Dan was here and second, because I had a conversation with Peter this morning and there's a few things we need to like, a few more things we need to explore. So I would rather do the EOF stuff. Yeah. And just to introduce it. So I discovered recently that, I mean, Marius pointed out that there are actually three things where at least EOF is different than legacy code. It's to do a code hash, it's to do a code size. And there was the xcode.
00:46:30.873 - 00:47:02.777, Speaker D: I'm trying to remember what he said this morning when you xcode delegate or something like this. For each of these things, if I understand correctly, you need to go. It's not just getting the code # delegate. OK, delegate call. Yeah, exactly. That's what Mari said. So from what I understand, for those three operations, you cannot only just read the code hash.
00:47:02.777 - 00:47:37.125, Speaker D: You also need to go and check that this is a format. Sorry, that this is a EOF format. So you need to go to the first byte of the code, check that it's 0xef, if I remember correctly, and then somehow update the answer based on this. My question like. So I have two questions. Like first, how do we handle the gas for this? Actually, that's the second question. Because the first one maybe prevents us from asking the second question or saves us from asking the second question.
00:47:37.125 - 00:47:55.035, Speaker D: The first question would be we have this code size field and this code hash field in the contract. Excuse me, in the header. Could we not directly put that value so that we don't have to go and read the Xerox ef.
00:47:57.135 - 00:48:25.765, Speaker C: We could totally put a flag in. I was about to suggest that because we got those two extra bytes or however many extra bytes, and you want to save some of them for flag fields. This is a perfect flag and the flag would be the first two bytes. And that's actually EF00. It's not just EF we want to worry about because EF00 marks that it's EOF code. And I think that 7702 is already wanting to Mark it as being delegate code. So that might be another field we want to mark in there.
00:48:29.685 - 00:48:45.901, Speaker D: Right. Okay, so that's good. But maybe you could also explain why does EOF have a different code size or a different code hash? So why don't we just ask? Yeah, go ahead.
00:48:45.973 - 00:49:17.231, Speaker C: EOF itself does not actually have code size, code hash and code copy. One of the mandates that we've been given was that we're supposed to get rid of code introspection. So within EOF code you cannot go into other EOF code, look at its byte code change, its bytecode expected to behave based on spike. Code contracts are opaque from within the execution of the evm. So it's actually we're changing those three ext code opcodes in legacy as well as. And well exe delegate call. Yeah, I'll get there in a quick.
00:49:17.231 - 00:49:55.965, Speaker C: But the three opcodes of ext code copy, ext code hash and ext code size cannot introspect into EOF in order to preserve that. Otherwise you would just call into legacy, have the legacy do the introspection have a return it. So that's an attempt to keep the system closed. So the changes to the legacy ext things would be if they see an EOF contract to treat it as if the contract is just the bytes EX00 and code hash, code size and code copy. I'll provide the correct answers. As though the EOF contract is just the 2 bytes EF00. Now ext delegate call.
00:49:55.965 - 00:50:36.267, Speaker C: There is a restriction within EOF you cannot delegate call into legacy code. And this was a decision made before self destruct was nerfed. Because we wanted to make sure that we accidentally didn't accidentally bring self destruct semantics into eof. Because you could just delegate call into an external contract that would self destruct and the self destruct would affect the code object that would be the EOF code. Now be a way that you could remove it from the system. So the decision there was you can't delegate code delegate call out to legacy code. And the generalized thing is you can only delegate call to the same generation of EOF.
00:50:36.267 - 00:51:10.343, Speaker C: You know, in 10 years when we do EOF2, that's going to be where things are going to start from is if there's EOF2, it can't delegate called EOF1. Assuming we even need that in 10 years. So that's the premise there. You could still non delegate call out to these and still get your escape hatches. But they don't affect the code object that is the EOF code object. So that's the rationale for the, for those two changes. And so yeah, the idea of having a flag that pre calculates that and stores that in the, in that first, you know, master description of it would really make things simple.
00:51:10.343 - 00:51:25.195, Speaker C: Otherwise we would need to include in those operations the cost of loading the first code chunk from the code from those. So, so we could inspect it as part of the operation. Those are the two realistic options that we have for this.
00:51:26.575 - 00:51:45.947, Speaker D: Right? Yeah, I guess this is a very good reason to use a flag. So just to recap, if there's a flag, if the flag is like the EOF flag is set, code copy should not work. Sorry. Code size and XCODE hash should not work. Neither does code copy.
00:51:46.131 - 00:52:04.635, Speaker C: That's the, they work in EOF mode. It'll copy 2 bytes EF00, the size is 2 and the hash is whatever EF00 is. So it's, it goes down a separate path. So it doesn't work the typical fashion, but it does work in a way to signal that say, hey, this is EOF code versus this is an empty account.
00:52:05.375 - 00:52:30.373, Speaker D: Okay, so if I do a code hash or a code size, just, just to recap. Yes, I understand code copy would work differently which, which is fine because the gas costs are more or less can be adapted basically. But if it's just for code size and code hash, then I don't need to go and read the. Read an extra chunk. That's my, that's my worry.
00:52:30.509 - 00:52:33.985, Speaker C: Right. If we have a flag for it. Yeah, we wouldn't have to read the chunk.
00:52:34.445 - 00:52:52.021, Speaker D: Okay, so that's good. So I can also prepare an update and run it by you like a spec update. I mean, and then for code copy, okay, it still needs to be handled differently, but just reading that flag would give us enough information that we know we need to behave differently. Okay.
00:52:52.093 - 00:53:01.511, Speaker C: We could make it cheaper for the EOF because we don't have to load the chunk. But I say we still charge for the first chunk anyway just to be consistent and not special case out code.
00:53:01.543 - 00:53:10.847, Speaker D: Copy the first chunk. Sorry. In case of EOF and we do like we charge for the first chunk. Doing. Doing what? Sorry?
00:53:11.031 - 00:53:24.375, Speaker C: So if you do ext code copy and you know you're doing eof, you don't have to load the chunk, but I mean we could just keep it specified as you will still load the chunk anyway just to keep the spec simpler.
00:53:24.835 - 00:53:40.435, Speaker D: Yeah, okay, that makes sense. Okay, cool. Thanks for the explanation. At least I don't have any more questions. Cool.
00:53:40.555 - 00:53:57.767, Speaker A: Then last up, we just had a PSA that we wanted to schedule another little mini breakout around gas cost updates. Maybe we can actually schedule that offline, but I think that was the last thing on the agenda. Guillaume, did you have anything on the gas cost breakout you wanted to add here quickly?
00:53:57.951 - 00:55:05.381, Speaker D: Yeah, so like I said, I think a bit earlier. Unless I forgot, there's been a significant amount of updates after the last breakout, gas cost breakout we've had to the spec. I just wanted to make sure that everybody was happy with the updates, that nothing was forgotten, that nothing was fully specified. So I would like to bring your attention to the fact that there's been a PR merged last week and there's another outstanding was made by Gajender that I will review after this call. I'm sharing it in fact right here. So it would be nice if the people interested could have a look at those two things and we could have a hopefully final specification call so that, you know, if there are some, if there are some need for more discussion, we could have a breakout call. If everybody is happy with it, then we don't even need to have the call.
00:55:05.381 - 00:55:20.505, Speaker D: But yeah, I would suggest next week at the same time as the Vic. If, if people are interested, like we could block that time already and cancel it if it's not needed. Cool.
00:55:20.625 - 00:55:41.193, Speaker A: So yeah, everyone can take a look at that and we'll coordinate offline if it. Or asynchronously, I mean, see if we another call or not. Awesome. Okay, great. Well, I think that's it for this week then. Unless anything last minute, we can wrap there. Thanks everybody for joining.
00:55:41.193 - 00:55:42.685, Speaker A: See you soon.
00:55:43.545 - 00:55:45.245, Speaker D: Thanks. Bye.
00:55:45.585 - 00:55:46.025, Speaker A: See you.
