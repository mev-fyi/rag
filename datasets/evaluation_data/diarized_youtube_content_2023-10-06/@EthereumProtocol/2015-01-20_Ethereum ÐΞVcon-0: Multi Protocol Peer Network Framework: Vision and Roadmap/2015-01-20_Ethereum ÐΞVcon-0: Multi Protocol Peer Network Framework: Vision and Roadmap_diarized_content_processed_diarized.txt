00:00:15.210 - 00:01:32.582, Speaker A: So subtitle here is vision and roadmap. However, the slides will be more some want technical and maybe philosophical, but the vision is simple. It's to create a protocol that multiple applications can run over that is encrypted and provides certain guarantees. And this has become more apparent over this week that this is an interest and it's in demand from many people. So people who are building dapps, we saw a few on Monday, and Ethereum itself. So in turning complete fashion, we are doing a similar thing with the network protocol in that it can be used for more than just Ethereum. So a little bit about me was born and raised in Texas.
00:01:32.582 - 00:02:48.850, Speaker A: So the yagny thing that Sven pointed out, we would say, y'all ain't going to need that, which is important in networking because we don't want to put things on the network that we don't need. It adds complexity and that's not good. So before I started programming, I worked in networking. I had a strong interest in networking and network security and helped build Internet service providers. That kind of thing got into programming, wrote, helped write a c plus plus Bittorrent tracker that was so Bittorrent itself was controversial. The reason that I mentioned this is because it's important to remember that we're adding encryption here, and this can be a double edged sword. So our objective is to build what we need for the protocol to have integrity, and that includes encryption.
00:02:48.850 - 00:04:01.722, Speaker A: Anything beyond that is we would like anything beyond that to be able to be built on this protocol. If it's feasible, something else could come along that's better. There may be other protocols out there already that have the potential to facilitate this role. So what we would like is multi protocol, peer to peer protocol. So right now, if you use Bittorrent, the peer network that you're connected to, and the things that you can do with that network and those code bases is to send and receive files, and it's really efficient because of how it's done. So now if we want to allow multiple protocols to use a similar peer to peer network, we're starting to layer things. And if you have two layers, that's usually not too difficult to do.
00:04:01.722 - 00:04:44.920, Speaker A: Something just needs to be lighter than the other different properties, whatever, or you just go back and forth. It keeps it really simple. We want to start adding more layers to this. It gets really complicated really fast. So with the protocol for ethereum, scalability, efficiency and usability are really important. If the network is slow, I think we can all agree that that wouldn't be a good thing. Faster network, that's not the goal, that's not the most important thing.
00:04:44.920 - 00:05:56.510, Speaker A: But between the two, this helps with robustness, so the network can respond to events faster. DHT tables can be kept more up to date, so the general status of a network can be more robust and stable if it's quick, if it's efficient. Privacy. We'll talk a little bit about privacy later. To me, I think that encryption is a form of privacy. So if we are encrypting traffic, we are automatically adding some form of privacy. So the Internet, as most application developers know it, can be laid out simple.
00:05:56.510 - 00:07:14.818, Speaker A: So a lot of networks run on Ethernet, or perhaps they run cell phone or ADSL, these things, a lot of those. So for example, DSL, actually, most DSL connections use a form of Ethernet Internet protocol, TTP and UDP. So an interesting thing about these protocols is they have their own sort of forms of how you use the protocol. So if you want to build an application that uses TCP, there's a lot of things that are going on in the background to allow that to work to begin with. So if you just took TCP and you put it on a small network, you're fine. If you take TCP IP and you put it on the Internet with just the simplest Ethernet IP and TCP IP, there's a lot of problems. So an important part also, each of these, well, these two have address resolution.
00:07:14.818 - 00:08:27.262, Speaker A: So Ethernet has addresses and we have address resolution protocol IP has addresses, which sometimes there's ways that you have discovery. So on the routing side of things, we have protocols that are used for infrastructure. Notably NPls is on all of them. So the interesting thing is that a lot of problems that large peer to peer networks need to solve to be robust are really problems that engineers working on keeping the Internet up. They are problems that these engineers are also researching solutions for. So to give an example of this, here's a diagram of just a network diagram from a test thing. And it gets complex really quick.
00:08:27.262 - 00:08:51.800, Speaker A: We don't have cell phones in here. There's a lot of things going on with the Internet. So this isn't here, but there could be a sonnet ring here, so that if one part of the fiber gets cut, everything just goes the other direction around the ring. So yeah.
00:08:56.330 - 00:08:59.500, Speaker B: What'S the diagram? I have a hard time reading it from.
00:09:00.350 - 00:09:30.580, Speaker A: So this is an example of different kinds of networks. So freight relay switched and then for other connectivity, just imagine that every single one of these connections is a different way of the connection. Routes messages differently, but yet they all get along on the Internet most of the time.
00:09:31.990 - 00:09:34.434, Speaker B: Can I ask very silly question?
00:09:34.552 - 00:09:35.230, Speaker A: Yes.
00:09:35.400 - 00:09:38.360, Speaker B: For software developer, why do I care?
00:09:38.810 - 00:10:47.530, Speaker A: I'm going to get to that. Okay, so do we have solutions? So, considering privacy as well as scalability of the Internet, there's a lot of people working on this. I-P-V six is there's, there's a part of I-P-V six that tries to help with privacy. Now, one interesting thing about I-P-V six is they are 128 bit addresses, so they're not quite large enough to use on a peer to peer network. That depends on cryptographic properties for shaping the network or for peers connecting. And we'll get to that later. So, recent issue, this is a blog post from an engineer at MIT.
00:10:47.530 - 00:12:04.286, Speaker A: And I-P-V six has this really interesting thing where everybody who actually gets an address doesn't get a full address, and they can generate their own private addresses just ad hoc, out of nowhere. And so it's kind of like an ephemeral address. But the problem is, is that routing equipment relies on addresses that don't change because it can do so quickly. So if every computer in the world changed its address every five minutes, it would be really difficult to scale that so that every message can go from its source to its destination. The amount of memory and processing power for core network equipment would have to change or algorithms have to change. Yes. So if you're interested in I-P-V six and how, there is a project that's trying to build on I-P-V six for privacy and encryption.
00:12:04.286 - 00:12:40.254, Speaker A: It's called cjdns. That's pretty cool if you want to check that. So, a lot of what I'm covering here is the Internet as we know it today for most application developers. So all major browsers today should be using TLS, which is like version four of SSL or something like that. They changed the name of it. TCP encrypted. Yeah.
00:12:40.254 - 00:13:37.300, Speaker A: So TLS is a protocol that runs on TCP IP, so it's similar to HTTP or IMAP or pop or any application protocol except TLS is to say, well, use TLS. So start your connection with TLS, and then it will be encrypted, and then just start sending messages once you know that it's encrypted. So a few of the things with TLS is that TLS itself is pretty good. It's well researched. The attacks against TLS are often edge cases and rely on attacks on other cryptographic algorithms. At the end of the day, the issue is the implementation. So TLS used by everyone.
00:13:37.300 - 00:14:50.998, Speaker A: Today everybody uses root certificate authorities and this is centralized. That works for certain use cases. But Ethereum is decentralized. So the usability of TLS is also somewhat of a black box, because if you're a developer and you write JavaScript web application or something, there's no way for your web application to determine if it's running on an encrypted connection or not. And if your web application wanted to determine if it's running on an encrypted connection, it couldn't find out who it's connected to over this encrypted connection. The only way that we could do this right now is to actually implement TLS inside of TLS with JavaScript or something, which would just be not fun. So on a more concerning level, TLS, most of its problems have had to do with browsers implementing it and making it really easy to downgrade the connection.
00:14:50.998 - 00:16:23.430, Speaker A: And so this has been used as an attack vector to basically when the browser goes to connect, you intercept a packet and you quickly get the browser to connect with a lower security, so say 56 bit encryption instead of as, and downgrade the line. And implementations are really geared towards running HTTP over it, not other protocols. Um, so one last thing. Maybe some of us here have seen this slide before. And again, to your question, I'll cover what this stuff is about and why. So this is an image from a paper from researchers, I think, at Harvard, and they're basically saying, okay, you can use Netflow analysis to figure out what's going on with Tor. And the reason that I present this is because this isn't necessarily a problem, but it's something that I guess you could say freedom fighters and people interested in privacy and freedom.
00:16:23.430 - 00:17:24.460, Speaker A: There's ongoing research here, so how do we actually have privacy? Like how can we send and receive information over the Internet? And there's no way for somebody to figure out what is being sent and received. So what's important here is really not the attack or it's Tor or anything like that. What's important to know is that in data centers all over the world, there's equipment for Netflow analysis. And what this does is this equipment reads every packet that comes into the network. Some of them do this based on sampling, so they'll read 5% of every packet that comes onto the network and extrapolate information from that. So the purpose of this equipment is to help their network. They don't install this equipment to eavesdrop on traffic or figure out what people are doing.
00:17:24.460 - 00:18:11.260, Speaker A: Oftentimes they install this equipment because it helps figure out where denial of service attacks are coming from. So back to the double edged sword thing. There's a lot of cases where there's a balance and. Yeah, so when I started working on the networking stuff, Gav was like, yeah, so we're going to run everything on this. No pressure. This is actually really applicable. And I'll get to that in a bit.
00:18:11.260 - 00:19:05.420, Speaker A: Yeah, so the Ethereum network protocol as we have it today is Ethereum relays transactions, block hashes and blocks whisper messages and filters. Right now, presumably swarm will be content hashes and content blocks. I'm probably missing something here. Later, I expect that we're going to add things like simple payment verification. Right now, we also sort of have p to p here, and all it does is exchange peers. So each of these protocols sort of has different requirements. Kind of.
00:19:05.420 - 00:19:54.586, Speaker A: So ethereum and swarm are both kind of hybrid. So that's a typo. The relaying of transactions is fairly important. Relaying of blocks, that can be fairly important. Same with relay hashes. But the throughput of relaying blocks is much higher than the throughput of relaying transactions. Naturally, if you wanted to send ten transactions down the line and ten blocks, the ten blocks are always going to use more bandwidth than the ten transactions now for sure.
00:19:54.768 - 00:19:56.662, Speaker B: It depends on the size of the contract.
00:19:56.726 - 00:20:04.160, Speaker A: Yeah. So if you sampled 10,000 blocks, this is true.
00:20:04.930 - 00:20:05.680, Speaker B: Okay.
00:20:08.130 - 00:21:06.850, Speaker A: Because the blocks contain the transaction. So blocks are actually groups of transactions. It could be argued that some of these messages need higher priority than others. And what does higher priority mean on a network? That means that there's lower latency. The message gets there faster than the others. So on to answering the question earlier about everything with routing and privacy, we won't be solving those problems with this protocol. This protocol is for a stable, robust network protocol that's encrypted and multiple applications are running over the protocol.
00:21:06.850 - 00:21:47.134, Speaker A: There won't be anything to do with routing priorities. Multicast or broadcast? Right now, multicast and broadcast is written in code, so send to every peer, and so it's unicast or the direction of the flow. So some protocols, similar to what will be proposed, provide a mechanism such that you can connect to something and say, don't send me data, I'm just going to send you data. Or they can say the same thing.
00:21:47.252 - 00:21:48.640, Speaker B: Are you okay with me?
00:21:50.290 - 00:23:06.546, Speaker A: No. Wait till the end. Yeah. So, yeah, so some good reading material for all of this, if you're interested or you're working on similar systems, is the speedy drafts from Google this blog post, which is really recent and does a great, great job of describing network buffering. And what do you do when you have to send out 100 megabytes of messages and you can only send out 1 context of scalability, not necessarily a single application. BitTorrent is excellent. The idea of BitTorrent takes a file and breaks it into a whole bunch of pieces, creates a merkel root hash of it, and then uses that as to being able to hand out pieces.
00:23:06.546 - 00:24:49.338, Speaker A: And the way that's done is applicable for the DHC stuff, which I won't cover. Amazon Dynamo blog posts and Kadimlia, these are both really good. The Amazon Dynamo is just a great introduction, so I kind of come up with a name, so it's called, and so it will provide an encrypted line, multiplexing multiple applications over the line, flow control and then later constraints, peer discovery and peer rating. Each of these sort of fit with privacy, scalability, efficiency or usability. And the constraints, this could say constraints and metrics, which is sort of connected with the peer rating system, and I don't have slides for that. So I swear there was a picture of something here. Yeah, okay, encryption is the way that we're using encryption is relatively new, so last, I don't know, five years.
00:24:49.338 - 00:26:15.214, Speaker A: There's other projects that are doing this. We're not the only ones, but most of the web right now is encrypted with TLS, and we know how this works with certificates, and the server has a certificate and they send it back and forth and things like that. So what we're doing is every node, every endpoint of the connection of a connection, if you want to call it that, is generated via a public private key pair, and the address of the public key is the address on the network. Yeah. So of course everything should always be encrypted and authenticated. So I'll get to the authentication bit. A lot of protocols, they authenticate every packet or every message, and what's being proposed here is to have authentication essentially out of band from the application.
00:26:15.214 - 00:27:22.330, Speaker A: So the wireline is doing authentication. In fact, this network protocol is authenticating the traffic rather than the box cipher or the application itself. So there was an article posted on Skype about using crypto, and I'm just going to read this. Designers and implementers should refrain from optimizing well studied protocols to achieve some specific application need, unless they're prepared to revisit and reevaluate the above security proofs. Small, insignificant changes in protocols can result in invalidating the guarantees of such proofs. So a lot of factors in here in this paper were about key sizes and parameters. And this was released by Enisa Utah link this paper earlier.
00:27:22.330 - 00:28:42.370, Speaker A: So with encryption, we are not changing any parameters. We are using the cryptographic primitives as they're expected to be used. However, we're combining a few things because we are multiplexing application traffic over a cryptographic channel. We're basically changing the time in which we are processing information about authentication. It's streamed instead of coming up with some new protocol or using a self authenticating block cipher. So, yeah, so encryption, the, the first version of proposed encryption protocol is this. So the implementation is that I want to connect to a peer.
00:28:42.370 - 00:29:39.260, Speaker A: So I need to get their public IP address. Sorry, their. Yeah, public IP port and public key. So I will always have the remote public key. They might not have mine and I might get it from the DHT, I might get it from another peer, or of course, I already know this peer's public key. So when the connection is started, the first message that's sent by the side that initiates the connection is using ecIs. They use the remote's public key to encrypt their address concatenated by a signature of information.
00:29:39.260 - 00:30:16.920, Speaker A: So Ethereum in general is relying on our ability to recover public keys from ECDSA signatures. And so what we're doing here is we can recover the public key from the signature. So when the connection is started, I'm sending my public key encrypted with their public key. So this also means that if I send this to the wrong person, they're not going to be able to decrypt it and they won't know my address.
00:30:17.610 - 00:30:20.870, Speaker B: Can you please explain the sign brief keys ticket?
00:30:22.890 - 00:31:41.780, Speaker A: This is signing with ECDSA and the private key is used to sign the ticket or the amount. So the ticket is essentially based on the previous session and then concatenate a random value which is used to do ephemeral diffie helmet. So this part and how this works, this is similar to TLS. We're doing a lot of things in one message and we're relying on the fact that we know the other side's public key. With web browsers today, you have to connect and find out what the public key is and they have to tell you the public key. And so we're not doing that as a part of starting the connection. And then this nox, the details of this knots is in the proposal and it could move into the encrypted payload or not.
00:31:41.780 - 00:32:13.770, Speaker A: This needs to be reviewed as to whether it's better to do one way or the other. And I'm open at the end afterwards of getting together with anyone who's interested in helping determine what the best thing to do is, because this potentially changes, has side effects based on where it's at.
00:32:13.840 - 00:32:15.340, Speaker B: So what does that not do?
00:32:18.670 - 00:33:02.940, Speaker A: It's used for updating the session. So after every successful connection, you update the session. And so when that is combined with using ephemeral public keys, then if somebody steals your laptop or they steal your server and they have your private keys, they could have packet logged everything coming out of your server and they won't be able to decrypt it. That's a part of that. Yeah.
00:33:05.950 - 00:33:10.240, Speaker B: So can you just say again what the nonsense tickets are derived from?
00:33:11.970 - 00:33:13.440, Speaker A: They are used as.
00:33:15.410 - 00:33:16.430, Speaker B: A signature.
00:33:20.130 - 00:33:20.782, Speaker A: This one?
00:33:20.836 - 00:33:21.440, Speaker B: Yeah.
00:33:25.990 - 00:34:38.300, Speaker A: So the ticket is a value that you have stored from a previous session, from a previous connection. And the knot is because there is no value. And so this establishes a new value. So this is similar to what's being done with TLS. So TLS uses this for driving key material for the shared secret, and that's what we're using that for as well. As I said, and I want to reiterate, the purpose here is to create something that we can use. This needs to be reviewed, because while we're not doing anything that's not by the book, there's implications on how we use this information to derive shared secrets and to update them.
00:34:38.300 - 00:35:34.042, Speaker A: So multiplexing is really simple because we already have it right now. The way that we're doing it is each sub protocol has like ten packets or five or whatever, and we're stacking those into one packet type. And then based on what protocols both connections agree on, is how we determine which packet type is which packet type when we receive it. I think the networking guys are familiar with this, and that's called adaptive message ids. And there's a wiki article page on this, actually.
00:35:34.096 - 00:35:36.410, Speaker B: It was awesome. Why are you canceling?
00:35:36.750 - 00:36:12.102, Speaker A: Well, so that's the question marks. It's been proposed that we go to a system where we have a protocol type and a packet type and it's just two values instead of stacking them. So whether we do that or not, we have to decide. Maybe tomorrow. But it's an implementation thing.
00:36:12.236 - 00:36:27.786, Speaker B: So I think the idea behind the analytic method was to make it harder for filters to filter us. One doesn't really see. Yeah, it's one of them, but I.
00:36:27.808 - 00:36:28.746, Speaker A: Kind of like it.
00:36:28.768 - 00:36:29.558, Speaker B: It was smart.
00:36:29.654 - 00:36:31.420, Speaker A: Yeah, I mean, I like it too.
00:36:34.110 - 00:36:35.442, Speaker B: Who is that even shown?
00:36:35.526 - 00:36:55.620, Speaker A: Well, there are people that don't like it. I don't think that they hate it. I'm 50 50. I like both. But the adaptive message id, I think is sort of a little artistic. It's very much like RLP. Yeah.
00:36:58.950 - 00:37:01.250, Speaker B: It'S like to say, hey, we are smart.
00:37:05.750 - 00:38:30.420, Speaker A: So flow control I. So we're not actually going to do this, but I think it's funny that messages on the Internet are obviously information on a journey through space and time. So what's interesting is these vehicles can operate differently when mixed together in the same environment, and with running multiple protocols over a single line. We have a very similar thing in Berlin. There's a lot of cyclists, which is really interesting because I can ride my bicycle to this office faster than I can drive a car here, usually five minutes faster, and it takes ten minutes to cycle here. Also applicable buses, planes, mass transportation are carrying a lot of people from point a to point b. And in most cases, it's economical to opt to maximize how the vehicles are built and how they travel.
00:38:30.420 - 00:39:57.486, Speaker A: Flying around an empty plane across the ocean is not a good idea. And so for the same reason, flow control helps ensure that the bandwidth that we have available is used is backslide. So one of the most similar implementations to this is speedy, which is for HTTP over TLS. This should really maybe say Google's data centers instead of Google Plex. And I haven't read the latest draft, but prior drafts. Essentially, the flow control for speedy is for infinite space and time. So my understanding of speedy is that you can have as many applications or channels as you want, and each channel does its own flow control, which that can work really well in an environment where I have a browser and my browser connects using speedy to an application server running a certificate which matches who I'm talking to.
00:39:57.486 - 00:41:20.234, Speaker A: So in a peer to peer network, we are connecting to peers and we don't know who they are. So where, where this is relevant is that it might not make sense for us to go this route, because what Google can do with this, under the assumption of how browsers are working, is that Google can optimize their systems from the browser all the way to the multiple sources of data within their own system. So for Google, speedy is multiplexing their entire operations, which is mostly web applications, search and Gmail and maps. And this works great for them. It also works good for browsers, because browsers are, you hit the page, it downloads, and it's done. And so the goal of speedy is so that that happens as fast as possible. And while the protocol itself allows for all of these channels, a web browser, when you click and you open a page, only has a finite amount of information.
00:41:20.234 - 00:42:46.594, Speaker A: And so the web browser, nothing out there is going to really exploit that. So with RLTX we have the ethereum protocol as it is, with just a slight change on the packet type. It's encrypted and the flow control is simple and deterministic. So for the flow control, what I want to do is talk about that with the whiteboard as sort of a part of the Q A. By the way, how many people by chance have read the speedy white paper? Okay, cool. Okay, so how does this work? So the application needs to send data, so it sends a message compression. I'm sure there's some questions on that header is added.
00:42:46.594 - 00:44:24.660, Speaker A: So these three steps. So the header may be, first, the authentication is done based on the byte stream, not on the messages. And so what we say is that every 8 kb we insert a shaw three hash of the previous 8 overhead for authenticating, the traffic is reduced substantially. And in addition to that, it operates on the same signal that's used for framing, then encrypt the bytes, send it out, and we get out the other side. So why is flow control important? So a network connection has limited bandwidth. So in many cases network connections have a fixed bandwidth Ethernet. Ethernet typically does, although to a single application you don't know how much bandwidth is available.
00:44:24.660 - 00:45:39.370, Speaker A: It's an unknown factor that changes over time and it can change substantially. And only the operating system has control over this. So when with Ethereum, we want to allow dapps to run over the same peer protocol and sometimes you have to make decisions. So if you have a network connection that is only 1 send ten megabytes, you're going to have to wait. And if your application needs that ten megabytes sent in a certain amount of time, you need to do something about this. At least be able to tell your application that data's, the data is not going to get there in time. More importantly, when you're running multiple applications over one connection, we don't want one application to be able to take up all of the bandwidth.
00:45:39.370 - 00:47:16.406, Speaker A: So when the network connection gets to the point to where it's full, you can't make the network connection bigger. And in fact it's quite likely that if the network connection gets full, congestion actually goes up and it's going to even get smaller. And your choices are to drop the packets that you're wanting to send, or the other option is to block the application from sending more packets. In order to do this, the application, our networking layer, needs more information about the connection, because as is, if I want to relay 100 megabytes of blocks, I can tell the OS to send 100 megabytes of blocks. And the OS might stop me at two megabytes or four megabytes or 16 megabytes. It's different for every operating system. So we want to employ a mechanism so that there's essentially a pipe, there's bandwidth for each subprotocol that's running on the line, and we want to do so in a way that there's enough information exchanged between the two peers that they know when it's overflowing.
00:47:16.406 - 00:48:34.340, Speaker A: Or we can also use this to know when there's more bandwidth available. And if there's more bandwidth available, maybe we can use this for swarm, maybe we can use this for something else that's not a part of the protocol right now, because that's an implementation detail. So this is the raw spec, and this part was not in the ether pad or on GitHub. This is currently on, on both. And as can be seen, it needs to be cleaned up and formalized. And I think it would be helpful to have some diagrams so that the implementations are similar. So next steps in addition to implementing this is peer discovery constraints on the way that the flow control system works.
00:48:34.340 - 00:50:53.794, Speaker A: And that will imply guarantees, and that will also imply that we will have some insight into what's happening on the network at scale when we're doing testing and simulations and things like that, because we can log what's happening with flow control and change some parameters and then see what happens. And so essentially we can actually work over a long period of time to optimize the throughput of the entire network, to optimize the throughput and the latency of the entire network. And what RLPX does is it just says that we have framing and that there's information that the peers will send Delta window updates back and forth with each other, and then the peer rating system, which is definitely an implementation detail, that's not a part of this, but it's a part of Lib P to P. So that an application that is actually a peer to peer application and depends on an exchange of peer to peer messages can ensure that it's connecting to good peers for what it needs. So maybe your needs are swarm right now and you aren't mining Ethereum and you don't need to download all of the, you're just doing transactions and swarm because you're using simple payment verification, you'll want good peers that provide responsive, simple payment verification. And obviously, however swarm works, that could be another protocol or another implementation, but, yeah, so peer rated. Okay, I.
00:50:53.794 - 00:50:55.840, Speaker A: That. That's it. So.
