00:00:00.320 - 00:00:37.169, Speaker A: I'd like to welcome everyone to EOF implementer call number 53. It's the 17th of July. Our agenda initially is client updates, compiler updates, spec updates, a couple of one requests from Solidity and one request about delegate call testing updates. I have a couple a few questions on testing and other items. If anybody has anything else they'd like to put in the agenda, feel free to drop it into the meeting chat and we'll come to it on a time available basis. But first, client updates. Let's see.
00:00:37.169 - 00:00:39.725, Speaker A: Eamonn nethermind do you want to go ahead and start us out?
00:00:42.025 - 00:00:46.265, Speaker B: Hi, can you hear me?
00:00:46.425 - 00:00:47.641, Speaker A: Yes, we can hear you.
00:00:47.793 - 00:01:09.105, Speaker B: Perfect. We are dealing with the failing test, the PI spec failing tests and we are making some progress. So far we have. I think you have Create and the new Create transaction tests that are failing because of some GAS issues, I presume, and we are trying to get to the bottom of it.
00:01:11.325 - 00:01:38.291, Speaker A: Okay. Yep. That's why we write tests. The test will generally guide you in the right direction as to what's actually broken, although it might take a bit to figure out how to fix it in your system. Yeah, if you have questions about what the test is testing, always feel free to reach out into the discord. Andre EVM1 Aragon 3 no significant updates in EVM1.
00:01:38.363 - 00:01:41.335, Speaker C: Like all the implementation is merged by this point.
00:01:41.755 - 00:01:49.163, Speaker A: Cool. Dragon Ref I'm passing state test, but.
00:01:49.219 - 00:01:55.405, Speaker C: There are a few changes for validation that I need to implement out of the debt. It looks good.
00:01:56.025 - 00:02:21.605, Speaker A: Okay, I'll speak for Besu. A couple weeks ago EVM1 dropped some of their tests into the test format. Found a couple bugs in BASU that we fixed. One relating to input data for Create, that was kind of an entertaining one. And another one. And this is something both Geth and BASU had wrong. We had the stack order wrong on ext call.
00:02:21.605 - 00:03:14.035, Speaker A: We had value coming before the argument offset and argument size, so that was a fairly easy fix. And I wrote up a bunch of tests, just merged it last night. That exercises that stack ordering and at the request to test, I also verified that the input call data doesn't get overwritten when you do a sub call. So we got tests covering those failures. Now I got a patch into Geth to fix that part of their bug. And I don't see anyone from Geth on the call. Is that correct? Okay, Anyone from Ethereum JS Anyone from Aragon 2.0
00:03:14.035 - 00:04:06.749, Speaker A: that's testing coverage tracker. We don't have the matrix on here, do we? Yeah. Oh, here. Oh, it is on evm.org it's included. That's right. Trying to give I'm missing anyone that's on this so I guess we'll go to compiler updates.
00:04:06.749 - 00:05:09.015, Speaker A: Are there any compiler people on I know Charles said he wouldn't make it. Do we have Solidity on any updates from if salon about the proof of concept compiler? Ok, doesn't sound too exciting. Oh, Eels. Anyone from Eels on Okay, so yeah, Eels is working on their implementation of it three weeks ago so it looks like most people are taking July off for ECC and other things. Just something I'm trying to do. Cool. So it doesn't look like we have any compiler updates Spec updates so the first question comes from Solidity.
00:05:12.555 - 00:06:15.695, Speaker C: Yeah, it turns out actually they already discussed it and came to conclusion it's not that important to change this Daniel posted a comment here but the idea was to change the address derivations formula to include input to UFCreate. There is constructor arguments from Solidity because that was how Legacy behaved. The constructor arguments were inside the INIT code so they were hashed and now like this one test behaves differently in EOF than it was in Legacy. The addresses collide and that is in the a description of pr. But yeah, they discussed and it changes the way they handle addresses basically change for EOF anyway so it's not that important to keep this compatibility Okay I think we shouldn't do anything about this.
00:06:17.515 - 00:06:46.865, Speaker A: Correct. And if they're not here to everybody said they're cool with it. It's been discussed so if anyone else has any comments, chime in on this. Okay, the next question requested by Frangio so on the call Lizzy. Oh yes, he is awesome. I'll let you lead this.
00:06:48.495 - 00:07:33.105, Speaker B: Yes. So this isn't the right. Okay, so the second section. Yeah there is this restriction EF1 contracts can only delegate call UF1 contracts and it's motivated by the self destruct issues. So first I was wondering if it's. You know, we still consider it necessary given EIP6780 but more important than that, I think that this restriction is introducing a new failure mode that is pretty bad for which I think the restriction needs to be lifted and so it's described here but I'll say it. So imagine that you have an.
00:07:33.105 - 00:08:24.673, Speaker B: Hold on, I need to remember how this worked. Yeah so imagine that you have a proxy, an upgradable proxy which is an E1 contract and it's working fine. It's using a EOF implementation. So a delegate calls to an EOF contract And it works fine. But you update, you upgrade it by changing the implementation address in storage to a new contract that turns out to be a legacy contract. And subsequently the proxy will not work because delegate call will begin to fail when it attempts to delegate call from the EOF proxy to the legacy implementation contract. And in.
00:08:24.673 - 00:08:43.355, Speaker B: For some proxies, this is an irrecoverable error because the upgrade logic is not in the proxy itself, that is in the implementation contract, and it may not be detected until it's too late. So, yeah, let me know what you think.
00:08:53.535 - 00:09:02.211, Speaker A: Wish ASIC was here. Or some of the other Andrea and Hugo, do you have any. Oh, ASIC is here.
00:09:02.243 - 00:09:06.067, Speaker B: Okay, yeah, I do, but I mean.
00:09:06.091 - 00:09:12.935, Speaker D: My question is, why would you. I don't really get it. Why would you have the need to upgrade to a legacy contract?
00:09:13.955 - 00:09:38.195, Speaker B: Well, you don't have the need, but it kind of happened. And it's just one more thing you'd have to check for. Right. It's a new kind of error. One more thing you have to check for during an upgrade process. It's not that you would need it, it might happen accidentally because your compiler was configured in one way or another and there was nothing in the middle that detected it until it was too late.
00:09:40.655 - 00:09:49.863, Speaker D: But also, this is about upgradable proxies. So even if you make this mistake, which would be very unfortunate, you should be able to upgrade it again, Right?
00:09:49.959 - 00:10:17.685, Speaker B: Right. So not necessarily because some proxies don't contain the upgrade logic in the proxy, they handle it by forwarding the call to the upgrade function through delegate call to the implementation target contract. So the only way to modify the storage variable that contains the current delegation target is through delegate call.
00:10:27.305 - 00:10:57.427, Speaker D: Yeah, I mean, that's an interesting concern, but generally, I mean, it's not like a new problem. Right, because this is kind of similar to the problem when you deploy a broken proxy target. And you know, in the case you explained that we also break or break even the proxy, the only, the only newly introduced issue is that you may be misconfiguring your compiler.
00:10:57.531 - 00:10:58.175, Speaker C: Right.
00:11:05.245 - 00:11:15.105, Speaker B: I mean, I see it as a new way that the target could be broken. I actually don't know what other kinds of broken you were thinking of that may already be possible.
00:11:15.445 - 00:11:43.835, Speaker D: I mean, you explained that in some cases the proxy upgrade process does require a working target because the actual upgrades partially may be implemented in the target itself. And if you deploy a broken target today, then you break the proxy the same way. So the problem, you know, this set of issues kind of already exists it's just a new version of the issue, in my opinion.
00:11:46.015 - 00:12:36.445, Speaker B: Yeah, to me it feels quite different or. Yeah. Or at least significantly different in that if you, for example, you tested the implementation kind of in isolation, it would work, but then once you do it, it doesn't work. I don't know. My feeling here is like this. I would ask like, sort of why is the restriction in place? And it seems to me like the restriction was put in place before self destruct had been neutralized and the motivation was to prevent errors like the parity multisig, but one that's no longer needed and second, it's adding a new kind of error. So it just seems kind of unfortunate.
00:12:37.145 - 00:13:21.047, Speaker D: No, I don't think it's for self destruct. Generally it's to avoid any unknown unknowns in the sense that EOF changes semantics of a number of opcodes and removes them. And if you. And based on those semantics, the contract which originates Delegate Call can make assumptions as long as the target is always eos because it will share the same semantics. But if the. I mean, as I said, you know, it's a lot of unknown unknowns. There was the main motivation that and sorry, I'm kind of tired today, so I cannot really think more cohesively.
00:13:21.047 - 00:13:36.715, Speaker D: But you know, if you allow legacy as a target, then you have to base your assumption based on legacy and not the uf. Because if you can call into legacy, then you may as well just call into Legacy. So your base assumptions are legacy and not EOF anymore.
00:13:39.735 - 00:13:40.515, Speaker A: Yeah.
00:13:40.975 - 00:14:00.355, Speaker B: Can someone think of an example of like a. I understand that it's unknown unknowns, but like, what kind of assumption are we thinking of here? You can start doing code introspection again so you could do, you know, what's the gas, all that sort of stuff. Isn't that stuff you can do through call?
00:14:04.175 - 00:14:20.135, Speaker A: Yeah. What's unique about Delegate Call and this self destruct situation is it affected the account that was eof. And you can introspect code and introspect gas by jumping out to a. To a legacy one without needing the security context.
00:14:28.195 - 00:14:30.603, Speaker B: Sorry, without needing the security context.
00:14:30.779 - 00:15:26.375, Speaker A: Well, without needing the security. Mixing metaphors without needing to have the caller the set to whoever you were. We don't, we don't need what Delegate Call provides to break that out of the container. Yep. I mean, what else are we banning and getting rid of in eof? The delegate call is the only sensible way to circumvent it. Or what changes might happen in Legacy that we don't want to see run in the eof I guess are the two questions to ask about this ban because right now we don't have a sweep opcode in eof. So that's the one thing that the current formulation of self destruct would provide, which is a way to clear out all of your balance without deleting the contract or deleting the storage.
00:15:49.285 - 00:15:58.055, Speaker B: I haven't, I can't think of anything that this having delegate call 2 legacy would break, but I'm not as right.
00:15:58.175 - 00:16:00.887, Speaker A: I was hoping Alexandre or Hugo might chime in on that.
00:16:00.991 - 00:16:01.675, Speaker B: Yeah.
00:16:12.095 - 00:16:26.055, Speaker A: And I guess the next question is if we change this rule, do we have to change it now or could we change it in a future version of the eof? Is this a one way door to leave it in? Because I think taking it out to oneway door.
00:16:41.475 - 00:16:50.035, Speaker B: With, with versioning isn't it possible to removing remove it or add it back in any version in the future?
00:16:50.775 - 00:17:50.575, Speaker A: So there, there's two aspects of versioning. There's a compatible change and there's an incompatible change. If we remove it, adding it back in would be an incompatible change and that would require a new EOF version and we would need to live side by side by existing EOF contracts that require that behavior. Whereas right now if you do try and delegate call out to a legacy, it's going to fail with an exception. And when, when right now, things that cause exceptions that don't like the address based expansion I think are falling into the compatible change category. So you know, the concern is that it's going to be, you know, user error or possibly some design requirement that you have to use a specific version of solidity that doesn't support EOF could require the proxy contract to change. But yeah, basically Alex's argument was these are not new issues introduced by this, but they exist.
00:17:50.575 - 00:18:18.405, Speaker A: It's just another thing in the checkbox. I'm not feeling there's consensus to change it, but I also want to point out that this could be changed in the future. Whereas if we remove the restriction re adding it would require harder changes. So at this late stage, you know, spec changes require a fairly high bar. So.
00:18:21.465 - 00:18:31.325, Speaker B: It'S not clear to me that removing the restriction would be a compatible change. Is that sort of consistent with how you've thought about other changes?
00:18:31.915 - 00:19:23.427, Speaker A: Right. Like if we're going to add new opcodes, I would say removing the change, removing the restriction of delegate call would be on the level of adding address space expansion and on the level of adding new opcodes. That's something we could do with just a new fork version that doesn't require a side by side support of evm. But if we were to say, let's say we're banning all the push OP codes and requiring a new or not reban all the DUP codes and require using the DUPN operation that would require side by side support of another version of EVM of the. Of the eof. So I mean it does present a problem, but the solution can be achieved without such an incompatible change. So I, I don't think it quite reaches the level of needing to change it unfortunately.
00:19:23.611 - 00:19:31.525, Speaker B: Yeah, so it can be achieved but it is a change to the semantic of an OPCODE that may have deployed contracts.
00:19:32.465 - 00:19:50.005, Speaker A: I don't because the failure mode is to do an exceptional halt, it's really not something you can depend on within it because you legacy call out to a contract, your whole stack frame pops with a halt and you're instantly out of the contract.
00:19:56.475 - 00:20:38.025, Speaker B: So my view hasn't been changed in this call. I still feel that this restriction should be lifted but I'll keep thinking about it and I would appreciate if others would keep considering it as well. I understand that there's not a lot of time, but I do see this as a new kind of error and as someone that's done a lot of work to try to prevent errors around breaking proxies irrecoverably and so on. This is like one more thing that we'll have to be dealing with and I think it is important to consider removing the restriction.
00:20:41.125 - 00:20:53.901, Speaker A: Okay, maybe we can discuss it next week but going to come to support this week on it? I don't think so and I think we need to time box it and move on. A couple more questions.
00:20:54.093 - 00:21:45.565, Speaker D: So I actually do have one back and it ties back to some earlier discussions we had regarding XCODE hash and whether to have an instruction for HESCODE or is code or whatever. If and in that discussion we kind of also discussed maybe we could have a flag on a call or have the tree return values whether the call ended up at an account, an EOA or code execution. Anyway, if we would have a way to tell that the target is an EOF contract without revealing anything more, then these proxies could do the check, you know is the target DOF before they proceed. So that may be one way to alleviate the problem.
00:21:46.625 - 00:21:53.485, Speaker B: Yeah, I agree it wouldn't be my preferred thing, but I agree that that would be a workaround. It's sort of acceptable.
00:21:54.785 - 00:22:00.805, Speaker C: I think it's possible like if you call legacy and Do X code hash from there.
00:22:04.915 - 00:22:31.405, Speaker D: Yeah, I mean there workarounds obviously. But you know we had this longer discussion and probably should be agenda for the next call. Just bring it up now. But we had this longer discussion whether we, we have the return values in the call, whether we have a flag or whether we have an other instruction to tell what is the target. And you know maybe if we, if we have more reasons for that instruction then maybe that's, that's a better approach and this may be like an extra reason for it.
00:22:41.305 - 00:23:24.983, Speaker A: Yeah, I didn't get put on this call so we definitely need to discuss. Because this is a higher level issue with solidity because they also need to figure out not just solidity. 721 is a contract. Is an account a contract or not. And yeah, so that was the two main options which actually was in here. Whether we have an IS contract opcode which we could have return one and two. Whether it's one for legacy and two for EOF is one way that could be changed or if we stick with the other option of having call status expand and say I call the legacy.
00:23:24.983 - 00:23:44.435, Speaker A: I called an eof. I called an account. Yeah, that's. I totally see that. Yeah. So let's, let's make sure that gets on next week's call and everyone think about it. In the meantime if those would solve the solution and which ones would be preferable.
00:23:44.435 - 00:24:27.055, Speaker A: And let me go back to 53. I think those were the two spec update questions. Any other spec update questions? All right, so let's move on to testing. Mario, do you have any comments before we go into the specific questions?
00:24:28.355 - 00:24:39.635, Speaker E: Not really. There are some open PRs I've been trying to review. I will get them get to them probably today or tomorrow. But yeah, nothing, Nothing specific.
00:24:41.655 - 00:24:49.315, Speaker A: Okay. Any other open comments about test before I go into my three questions from anyone?
00:24:50.055 - 00:25:00.555, Speaker B: Yeah, could we get a tag on top of the new EOF tests and GitHub so that it's version because we pull pull down on the tags.
00:25:04.305 - 00:25:06.165, Speaker A: Mario, is that something that can be done?
00:25:06.465 - 00:25:07.925, Speaker E: I didn't get the question.
00:25:09.785 - 00:25:15.285, Speaker A: Version tag of the current. A new version tag of what's current in the tests? Yep.
00:25:15.665 - 00:25:16.405, Speaker B: Right.
00:25:16.985 - 00:25:17.881, Speaker E: Based on Glenkun.
00:25:17.913 - 00:25:18.153, Speaker C: Right.
00:25:18.209 - 00:25:19.725, Speaker E: Or Rack.
00:25:23.665 - 00:25:25.645, Speaker B: Sorry, I didn't, I didn't have that.
00:25:26.865 - 00:25:40.655, Speaker E: So yeah, a new version of the is currently in Maine but based on Cancun or based on Prag I guess. I guess Cancun because that's. That's what we have been doing so far.
00:25:40.695 - 00:25:44.039, Speaker A: Cancun is what we've been Doing. That's one of my three questions.
00:25:44.207 - 00:25:45.103, Speaker E: All right, I see.
00:25:45.159 - 00:25:45.835, Speaker A: Yep.
00:25:47.135 - 00:25:51.487, Speaker B: I mean, the. Okay, I see there's two tags.
00:25:51.551 - 00:25:57.475, Speaker A: Yeah. What. What version are you needing to test off of the Cancun based EOF or Prog based dof?
00:26:02.195 - 00:26:06.783, Speaker B: I didn't notice there was a difference. I was just using version 105.
00:26:07.014 - 00:26:12.575, Speaker A: 105. Okay, which. Which client are you testing in?
00:26:13.595 - 00:26:15.147, Speaker B: Never mind, Never mind.
00:26:15.211 - 00:26:35.585, Speaker A: Okay, so I guess let's go with my three questions. That'll probably help inform some of why this is relevant. So my first question for the EOF tests. Container kind has been added. I know Base has implemented it. EVM1's implemented it. Has anyone else implemented it and are using it in test right now?
00:26:38.885 - 00:26:45.029, Speaker C: Yeah. Hari. Vm Are you talking about INIT code from transaction?
00:26:45.197 - 00:26:47.165, Speaker A: Yes. Init code in runtime? Yes.
00:26:47.245 - 00:26:48.599, Speaker C: Yeah, we have that.
00:26:48.797 - 00:27:02.907, Speaker A: Okay. So there are tests out there now that will fail if you don't take container kind into consideration. And I think that's probably what Ref ran into. They're mostly in. Go ahead.
00:27:02.931 - 00:27:05.895, Speaker C: Sorry, are you talking. Are you talking about validation?
00:27:06.235 - 00:27:07.555, Speaker A: Yes, validation.
00:27:07.715 - 00:27:08.091, Speaker C: Okay.
00:27:08.123 - 00:27:08.403, Speaker B: Yeah.
00:27:08.459 - 00:27:10.495, Speaker C: Yeah, that test I'm failing.
00:27:10.955 - 00:27:38.565, Speaker A: Yeah, I need to. Yeah, there's a couple of EOF Create contracts that we're testing. Deploy code as the root and validating from there and return contracts not available at the root container level because it's supposed to be INIT code when coming in from Create transactions. So it's. It's one of those, you know, questionable things. But yeah, that's the container kind in there. Spells it out.
00:27:38.565 - 00:27:50.675, Speaker A: What context is being used in what should be tested. The next question is T8N do only geth EVM1 and Besu have T8N support right now.
00:27:53.055 - 00:27:54.795, Speaker E: Eels also have it.
00:27:55.215 - 00:28:02.575, Speaker A: Eels. Okay. So Lucas nethermind has a PR with.
00:28:02.615 - 00:28:10.845, Speaker D: It and I haven't reviewed the newest version yet. I will probably review it tomorrow, but we're also close to having it.
00:28:11.705 - 00:28:39.041, Speaker A: Okay, so there's a new flag coming in in some of the CNN stuff that's going to affect eof. And it's more like it's more affecting Prog and Cancun stuff than eof. Uf it's just gets to be the first consumer of it. But with. With the new addition of system contracts and requests, implementing the block header, the question. And also these state things as a side effect of these system contracts. It's.
00:28:39.041 - 00:29:28.125, Speaker A: It's impacted. And I think it also impacted the Ethereum slash test for a while, whether or not you update those. So a new flag's been added is state test in T8N and what that means is you don't do any of your block level handling on it. There used to be a flag when you used to set the reward to zero where there's a couple of other old flags with retest at that you would use. But if you see that in a tnn, what it means is don't do coinbase rewards block rewards. You're still going to do transaction coinbase awards, I think, but you're not also not going to do deposits, withdrawals or consolidations or any of the generic request stuff. So any of the stuff that's coming in new for Pectra and some of the Cancun stuff that was already existing with withdrawals.
00:29:28.125 - 00:29:48.565, Speaker A: So it's going to be the same testing code. It's just you're not going to run those and that affects the state hash that comes out and the alloc the allocations that come out that affects the state route. GetH PR for supporting the state test. OK, good. GetH has it.
00:29:50.665 - 00:30:32.525, Speaker E: And also if you go into the PR from Geth, there's an example in a comment below that you can see the exact behavior that we. Yeah, for example, that, that one is the. Is one of the system contracts. So before if you have this state test set to false, you will see the storage get modified because you are actually implement, you are actually executing the block block level changes. Whereas if you set this flag to 2, it is expected that the system contract is not executed at the end of log and you can see that the storage is not there. This is just one example.
00:30:37.025 - 00:31:03.021, Speaker A: Yeah, because the. Let me convert this to decimal. The beacon chain is the one that always gets us because you have to set up the last time you set it. And if you're setting the beacon route to zeros, it still has to set up what the time that beacon route was, which is time is set to a thousand for most of the tests. That's where the 3e8 comes in. So that's usually what's breaking a lot of the tests. When literally every test starts breaking, that's one of the things.
00:31:03.021 - 00:31:53.925, Speaker A: And it's going to get more consistent with these new requests that are going to come in the generic requests in Cancun, not Cancun prog. So the next question right now we're developing tests off of a Cancun base with Cancun plus the 7692 changes. Should we be shifting to prog as the base and including all new prog features, including Potentially the requests. And that impacts the block header in the block tests and the state tests. Not a state test. The block tests and the Hive tests. Our team's ready to merge in their Devnet one and Devnet two stuff into their eof.
00:32:01.465 - 00:32:04.285, Speaker C: I think one doesn't have anything for.
00:32:08.475 - 00:32:09.575, Speaker A: For Cancun.
00:32:10.075 - 00:32:14.535, Speaker C: Yeah. Seems too early for us at least.
00:32:16.475 - 00:32:22.739, Speaker A: Okay. Do you. Do you support the Beacon chain updates in EDM1 at all?
00:32:22.827 - 00:32:24.135, Speaker C: I mean for Prague.
00:32:24.595 - 00:32:55.375, Speaker A: Okay. Okay. When do we feel we should shift over to the Prague stuff though? Is it going to be a problem building EOF off of Cancun and then shifting to Prague?
00:33:10.605 - 00:33:16.625, Speaker D: I don't think so. But Ayman, can you confirm or. Ben? I haven't looked at UOF code for some time.
00:33:18.365 - 00:33:30.275, Speaker B: We are not sure about the status of the other PRs, but I think we prefer it this way. Until later a bit. Until we pass. At least we pass all the tests.
00:33:41.535 - 00:33:47.115, Speaker A: Okay. And wrath you're currently building off of Cancun or Prague?
00:33:48.935 - 00:33:49.755, Speaker B: Prague.
00:33:51.665 - 00:34:00.045, Speaker C: We just have to finish the support for authorization intersection please Version for definite one.
00:34:00.825 - 00:34:02.845, Speaker A: But you have state test support, right?
00:34:03.385 - 00:34:05.685, Speaker C: Yeah, we can.
00:34:06.065 - 00:35:08.995, Speaker A: Yeah, we can leverage those in your state tests. Don't apply the Beacon chain updates? No. Okay. So it feels like most people are still able to or preferring to point to Cancun or can support the state test. It's going to break block taste tests and I don't know if anyone uses HIVE tests outside of Hive, but it looks like answer that is we're going to stick with Cancun for at least the next month or so. Okay. Any other testing concerns or other items? All right, if we're not hearing any.
00:35:08.995 - 00:35:38.165, Speaker A: So this week is an off cycle call. Last week was. Etc I was also on vacation at a family memorial. So this is actually a fill in for last week's meeting. The next meeting will be next week and then the idea would be to go to the two week cadence off of off of all core devs execution layer. So hopefully we'll be able to stick with that. But we're going to have another meeting next week.
00:35:38.165 - 00:36:07.825, Speaker A: Any other comments before we end the call? Any other questions? Right, we want it next week but not in two weeks. And so the idea when we don't have conferences and other vacations and family issues getting in the way is that we have it every other week opposite acde.
00:36:18.765 - 00:36:35.065, Speaker D: Do we want to discuss the IS contract right now or you know, given we have like 15 minutes left or do it next week but then for next week we could actually async prepare much better proposals, I suppose.
00:36:35.565 - 00:36:58.675, Speaker A: Yeah, we can discuss it. Yeah. Just no decision on it. I think it's fine. So one of my pitches for addressing. So a bit of background. ERC721 absolutely requires as part of their spec the ability to say is this account a contract or is this account an eoa? And we don't really have a way to distinguish that.
00:36:58.675 - 00:37:18.451, Speaker A: And solidity put. Put in some code to make sure you don't accidentally call eos when you're expecting a contract, which is where this originally came up. But the 721 requirement I think really forces us to do that. The IS contract I think is one solution. There's. There's two main solutions. My favorite is is contract.
00:37:18.451 - 00:38:04.667, Speaker A: But I would be okay if we also did return code changes EXD call series opcodes. But the IS contract one basically takes over the EXT code size operation and it fixes it to return a fixed value. And I'm thinking maybe we want to change it to return one of two fixed values. Because the check that there's written into ERC721 is a check is code size greater than zero. So we have the same opcode at the same location provide something that is greater than zero. When it's a contract, then that provides us the information we need. And if it returns one for a legacy contract and two for an EOF contract, that would address the needs of literally what 721 would do.
00:38:04.667 - 00:38:19.615, Speaker A: So we could use the old code, containerize it and it would work just the same. So that's the distinct advantage I see for is contract. But another option is to change the return code of EXT call. Hugo, you came off mute. You got comments on that?
00:38:23.155 - 00:38:24.895, Speaker B: No, I don't have any comment.
00:38:25.475 - 00:38:29.335, Speaker A: Okay. Anybody have any. Okay, Frangio.
00:38:30.595 - 00:38:37.175, Speaker B: Yeah. Is it a third option to do a separate call status opcode?
00:38:39.565 - 00:38:41.665, Speaker A: What would a call status opcode be?
00:38:43.645 - 00:39:29.035, Speaker B: The issue with changing the return values of the call opcodes is that it introduces or it requires a longer sequence of operations to check that a call failed or not. So that would be more gas expensive. One way to keep that as cheap as it is currently is to add a separate opcode to get flags or status codes for the call that just the last call that was done. So the. Yeah, it just achieves keeping it cheap and getting all the information that we want out of failures or successes here.
00:39:33.305 - 00:39:54.645, Speaker A: And this is the first time like a collect that's been proposed. I know it's. There's one EIP that didn't get much traction to track things like overflow and underflow in arithmetic operations and we would need some sort of a flag call to get the flags out of it from the last time the flag was set or cleared. And this could, you know, potentially provide that.
00:39:56.355 - 00:40:26.665, Speaker B: Yeah, well, the one that I was thinking was specifically about calls, but yeah, I guess it's general flags register that could be reused for that. I will say that for calls I also think there are other flags that we might be interested in such as that the sub call run out of gas, which is because of the removal of gas. Introspection is no longer possible. But some use cases require that kind of information. Like a 4337 entry point that's currently not implementable in UF.
00:40:28.885 - 00:40:31.225, Speaker A: Right. Go ahead.
00:40:31.685 - 00:41:16.555, Speaker D: The arithmetic flags would it. Because we had a similar proposal and we reviewed the number of options having flags, not having flags, et cetera and I think it turned out that the flag version is probably was the worst one. So I wouldn't probably mix that with the call flags and wanted to bring up one more option we kept discussing on and off. That call would return two values which again would be like a brand new concept, two stack items. But at least in that case you could just pop the one you don't need. Yeah, I'm not sure if that's a better option. It's just one other option we have been discussing.
00:41:16.555 - 00:41:50.245, Speaker D: But as a closing statement I would say that I think generally we were looking to optimize for the most common case to make sure that the instructions are the cheapest on the most commonly used case, which usually is what Solidity implements in other cases can be more expensive. It would be interesting to know this flag proposal if you could make up like a write up of this. How does it look like for the common case and solidity versus other cases?
00:41:54.465 - 00:42:13.295, Speaker B: I would. Just to make sure I understood you were suggesting I make like a. I explore the call status opcode and see what it would look like for the code gen for solidity in the common case which I guess is like checking did the call succeed?
00:42:15.515 - 00:42:42.265, Speaker D: Yeah, I mean the ask is two parts. One is because you mentioned there may be other flags of importance. So if you could just write them down in a list that may be like a good start for next week's discussion. But second, it would be interesting to see how you know this the status version translates into solidity what solidity does and maybe you know any of the other cases you think about.
00:43:00.775 - 00:43:27.325, Speaker A: So pushing two values is also. It would be notable to be the first opcode to return multiple values, but it would still be a net shrink of the. Of the stack because we already required three opcodes. So while novel, it's not problematic.
00:43:34.025 - 00:44:22.505, Speaker B: Regarding the. One of the suggestions in the chat for code version and this sort of wanting to stay as far as possible from code introspection. The way that I understand code introspection is not desirable in case in the future you want to make any translations to the bytecode. But it's like just being able to observe that there is or isn't code in there or even whether it is a specific EOF version or an EOF contract. Is that any. Do we see any problem from that? Is there a chance that legacy contracts become EOF in the future?
00:44:23.725 - 00:45:01.625, Speaker C: Yes, theoretical chance there, I guess. But yeah, I meant like if you translate one EOF version to another and some another contract assumes this one version or like. Yeah, because it can read it. So can make assumptions about this, I guess, and not support the next version. So something will be broken. But this is the code version is part of the code and observing it is also part of code observation, I guess.
00:45:09.535 - 00:45:52.095, Speaker A: Yeah, terrific. That translating code. I think one of the ideas was not just necessarily between EOF versions. Like let's say we got rid of dupen, a dupe and required everyone to use dupen. We could rewrite that and have mostly the same code. But also if we're going to translate the code into a ZK system, we're going to translate the code into some IR that, that supports, you know, compilation to it, or we did directly compile it down to say x86 and that's the canonical code for it. If we don't have, we don't have the ability to introspect into it, we can't cross that barrier and contracts won't break when systems do those changes.
00:45:52.095 - 00:47:13.485, Speaker A: So that's, I think one of the motivating factors and I think the most critical one is of course the translation of this code into a ZK validity proof and putting things like what version are you? Makes us hard code it. Or do nasty tricks like put the entire bytecode of the original into the data section. So if somebody queries it, that bytecode's still available if they, if they read from the code or read from external code. So that's a lot of the motivation was to make things, you know, the ZK translation in particular more cost effective. Any other questions? All right, if there's nothing more, I guess we'll see everyone next week at the same time at the same zoom address. Thanks, everyone for all the work they've been doing in EOF really appreciate it. Talk to you later.
00:47:15.625 - 00:47:16.025, Speaker C: Thank you.
