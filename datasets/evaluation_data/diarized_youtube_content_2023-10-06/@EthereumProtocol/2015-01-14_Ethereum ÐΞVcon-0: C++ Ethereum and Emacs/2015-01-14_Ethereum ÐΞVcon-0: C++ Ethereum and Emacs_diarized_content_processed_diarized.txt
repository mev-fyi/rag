00:00:13.050 - 00:01:32.490, Speaker A: Introduced myself yesterday too. I am Lefteris and I will be working in solidity and generally c plus plus development for Ethereum. This talk will be about having an Emacs development environment for Ethereum. It will be quite a short talk. So even if you're not interested in Emacs, I guess that it may get you interested. A quick question, who except from Felix that I know of, is actually using Emacs here? Goals of this presentation would be to familiarize with how to develop for CPP Ethereum with emacs, and also show ways that we can develop for Ethereum in emacs, like develop solidity contracts, maybe make you guys like emacs more. That's a very ambitious goal.
00:01:32.490 - 00:02:34.830, Speaker A: So why emacs? Right. The advantages is that along with Vim, it's one of the most popular editors. And as developers are our user base, we should provide easy ways for developers to develop for Ethereum using one of the most popular editors. It's extremely customizable and it's a tool that suits our needs since we want to be creating languages ids around the contracts, et cetera. Well, disadvantages is that you really need to customize the editor. Anyone that has opened the vanilla imacs must know that it's really a difficult thing to use. And as this temporary computer shows, it's a memory hog.
00:02:34.830 - 00:03:28.480, Speaker A: Emacs for some people may mean eight megabytes. And constantly swapping or emacs makes a computer slow, something that shows that it actually consumes a lot of memory. Just for your reference, the original abbreviation was editor macros. So how do you set up a nice environment in emacs then if not using the vanilla editor? There are many different environments that you can use. I would go with using a package manager called lGet. Specify packages for C Plus plus development, set them up and get to developing. So this is Elisp code.
00:03:28.480 - 00:04:23.374, Speaker A: It's the list flavor that powers emacs. So only with this small snippet here, basically you have a package manager that will install, update and synchronize your packages whenever you open your editor. Whenever you open your computer, if you run emacs as a server, which is what you should be doing. And also when you transfer your setup to a new computer, it has various commands. This could be the most important one. So you can download packages, install packages, delete or update all the packages. And for a clean Nimax setup, basically you would have something like a list of packages and the call to synchronize the packages.
00:04:23.374 - 00:05:44.134, Speaker A: So whenever, if it's a new computer and it reads this setup, it would contact probably GitHub download all of these packages, build them if there is a make file and load them into your remax load path. But what is required for C Plus plus development? People will tell you different things. Older developers would go with emacs default which is said it I would suggest packages through my own experience have become very useful over the years of development. And that is artads, autocomplete, flightech and projectile. And one that seamless advertising Malinka is a package that I have made which is a small package that acts as glue between the other ones. So Malinka, the only thing that it does is create product definitions. So this is a project definition for Ethereum.
00:05:44.134 - 00:07:10.822, Speaker A: Basically it feeds the data to all the other packages. So to tags creators or to syntax checkers, because we will need to know the include directories of the project, the macros, the defines that are used, et cetera. And also we have compile commands so that we needed compile the project test command to easily run the tests Artex so this is an amazing package that's quite new. It interfaces with clang. It's actually not Elis code, it's a native code. It's made in C plus plus eleven and create a client server that creates a client server interface that has a demon running in the background of your operating system and creates a memory database of all the tags of your project. For CPP Ethereum, because we have one big make file that makes the whole thing, it's over 2gb, which is quite a bit, but it's very fast.
00:07:10.822 - 00:08:28.746, Speaker A: Once the database is created, you can find the references of functions where they are used. You can get autocompletion and you can get what is called in clunk as fixit hints. So in a bit more detail now, I'm pretty sure that the resolution is not so nice. There is a function and you would like to see where it's used. You can just basically with one key combo, see all the references very easily and jump around the references autocompletion for example, this is from our p to p library. In C Plus plus there is can you see it? There is a boost basic resolver basically from the Azio library of boost. And just by typing r you see the type and you get the autocompleted functions.
00:08:28.746 - 00:10:23.094, Speaker A: And this happens without any delay like it happens in other inferior, let's say emacs packages. And a very nice, very nice thing that clang has is fixes. So in real time it runs a checker on your code that does static analysis and provides hints. So for example here, this is from the scanner of solidity and the location is valid method, but it's misspelled and the Silang static secure actually realizes that tells you that it's misspelled and it gives you a suggestion as to how to fix it, which you can apply immediately with basically this key compo, which is a default, but you can customize it. Another very useful package is flighteck that basically runs syntax checkers for any language that you may desire. Python, Lisp C Plus plus for C Plus plus it uses clunks in last but not least, projectile is a must have package for Nimax development environment because it automatically indexes and creates projects by using the version control system. So I don't really need to say that CPP ethereum is a project.
00:10:23.094 - 00:11:58.618, Speaker A: I don't need to index any files, I don't need to do anything. All I need to do is remember some key combinations and I can easily switch between header and sources, compile the project, test it, grep or Ack or AZ or whatever you have. You can also do version control, commits, and various other interesting stuff. I would refer you to the documentation of the project if you want to learn more. So that's about C plus plus, but what about Ethereum? So how can we develop contracts inside emacs? I mean, solidity is still under development. Someone from the forums of Ethereum actually developed a serpent mode, which you can get here, but as for solidity, over the weekend I made solidity mode Unimax, which is for now just the syntax highlighter which you can see here, and an indentation, so it properly indents and highlights the syntax of solidity. This is the contract that I think Chris used in his example of online solidity compiler.
00:11:58.618 - 00:12:52.340, Speaker A: Right, the ballot contract. So as I said, for now it is very simple just highlighting an indentation. But in the future we can provide autocompletion just like any other language. As soon as we get ast out of the solidity compiler, we can feed it as input data to any autocomplete package in image. We can also integrate with a debugger when that's possible, and also with other tools that will be developed for the id for solidity. So yeah, that's it. As I said, a small presentation for imag.
00:12:52.340 - 00:12:55.540, Speaker A: So any questions or.
00:13:04.110 - 00:13:06.700, Speaker B: Are you thinking of doing something in Vi as well?
00:13:09.310 - 00:13:12.730, Speaker A: No, I don't even know the key bindings in Vi.
00:13:14.990 - 00:13:16.202, Speaker B: Cool, no questions.
00:13:16.336 - 00:13:17.160, Speaker A: Okay, thanks.
